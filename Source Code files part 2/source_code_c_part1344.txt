   MVframe[0].y = 0;
  }
  else {
#ifndef USE_C
    ii = search_area + (x_curr+xoff-ilow) + (y_curr+yoff-jlow)*lx;
    sad = sv_H263PError16x16_S(ii, act_block, lx, H263Info->pels, Min_FRAME[0]);
#else
    ii = search_area + (x_curr+xoff-ilow) + (y_curr+yoff-jlow)*lx;
    sad = sv_H263SADMacroblock(ii, act_block, lx, H263Info->pels, Min_FRAME[0]);
#endif
    MVframe[0].x = (short)xoff;
    MVframe[0].y = (short)yoff;
  }
  /* NB: if xoff or yoff != 0, the Extended MV Range is used. If we
     allow the zero vector to be chosen prior to the half pel search
     in this case, the half pel search might lead to a
     non-transmittable vector (on the wrong side of zero). If SAD_0
     turns out to be the best SAD, the zero-vector will be chosen
     after half pel search instead.  The zero-vector can be
     transmitted in all modes, no matter what the MV predictor is */

  /* Spiral search */
  for (l = 1; l <= sxy; l++) {
    i = x_curr + xoff - l;
    j = y_curr + yoff - l;
    for (k = 0; k < 8*l; k++) {
      if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {
  	    /* 16x16 integer pel MV */
#ifndef USE_C
	    ii = search_area + (i-ilow) + (j-jlow)*lx;
	    sad = sv_H263PError16x16_S(ii, act_block, lx, H263Info->pels, Min_FRAME[0]);
#else
	    ii = search_area + (i-ilow) + (j-jlow)*lx;
	    sad = sv_H263SADMacroblock(ii, act_block, lx, H263Info->pels, Min_FRAME[0]);
#endif
	    if (sad < Min_FRAME[0]) {
	      MVframe[0].x = i - x_curr;
	      MVframe[0].y = j - y_curr;
	      Min_FRAME[0] = sad;
	    }

      }
      if      (k<2*l) i++;
      else if (k<4*l) j++;
      else if (k<6*l) i--;
      else            j--;
    }
  }

  if (H263Info->advanced) {

    /* Center the 8x8 search around the 16x16 vector.  This is
       different than in TMN5 where the 8x8 search is also a full
       search. The reasons for this is: (i) it is faster, and (ii) it
       generally gives better results because of a better OBMC
       filtering effect and less bits spent for vectors, and (iii) if
       the Extended MV Range is used, the search range around the
       motion vector predictor will be less limited */

    xvec = MVframe[0].x;
    yvec = MVframe[0].y;

    if (!H263Info->long_vectors) {
      if (xvec > 15 - H263_DEF_8X8_WIN) { xvec =  15 - H263_DEF_8X8_WIN ;}
      if (yvec > 15 - H263_DEF_8X8_WIN) { yvec =  15 - H263_DEF_8X8_WIN ;}

      if (xvec < -15 + H263_DEF_8X8_WIN) { xvec =  -15 + H263_DEF_8X8_WIN ;}
      if (yvec < -15 + H263_DEF_8X8_WIN) { yvec =  -15 + H263_DEF_8X8_WIN ;}
    }

    adv_x_curr = x_curr  + xvec;
    adv_y_curr = y_curr  + yvec;

    sxy = H263_DEF_8X8_WIN;

    adv_ilow = adv_x_curr - sxy;
    adv_ihigh = adv_x_curr + sxy;

    adv_jlow = adv_y_curr - sxy;
    adv_jhigh = adv_y_curr + sxy;

    adv_h_length = adv_ihigh - adv_ilow + 16;
    adv_v_length = adv_jhigh - adv_jlow + 16;

    adv_search_area = sv_H263LoadArea(prev, adv_ilow, adv_jlow,
			       adv_h_length, adv_v_length, lx);

    for (block = 0; block < 4; block++) {
      ii = adv_search_area + (adv_x_curr-adv_ilow) + ((block&1)<<3) +
	       (adv_y_curr-adv_jlow + ((block&2)<<2) )*adv_h_length;
#ifndef USE_C
      aa = act_block + ((block&1)<<3) + ((block&2)<<2)*H263Info->pels;
      Min_FRAME[block+1] = sv_H263PError8x8_S(ii,aa,adv_h_length,H263Info->pels,Min_FRAME[block+1]);
#else
      aa = act_block + ((block&1)<<3) + ((block&2)<<2)*H263Info->pels;
      Min_FRAME[block+1] = sv_H263MySADBlock(ii,aa,adv_h_length,H263Info->pels,Min_FRAME[block+1]);
#endif
      MVframe[block+1].x = MVframe[0].x;
      MVframe[block+1].y = MVframe[0].y;
    }

    /* Spiral search */
    for (l = 1; l <= sxy; l++) {
      i = adv_x_curr - l;
      j = adv_y_curr - l;
      for (k = 0; k < 8*l; k++) {
	    if (i>=adv_ilow && i<=adv_ihigh && j>=adv_jlow && j<=adv_jhigh) {
	
	      /* 8x8 integer pel MVs */
	      for (block = 0; block < 4; block++) {
	        ii = adv_search_area + (i-adv_ilow) + ((block&1)<<3) +
	             (j-adv_jlow + ((block&2)<<2) )*adv_h_length;
#ifndef USE_C
	        aa  = act_block + ((block&1)<<3) + ((block&2)<<2)*H263Info->pels;
            sad = sv_H263PError8x8_S(ii, aa, adv_h_length, H263Info->pels, Min_FRAME[block+1]);
#else
	        aa  = act_block + ((block&1)<<3) + ((block&2)<<2)*H263Info->pels;
            sad = sv_H263MySADBlock(ii, aa, adv_h_length, H263Info->pels, Min_FRAME[block+1]);
#endif
	        if (sad < Min_FRAME[block+1]) {
	          MVframe[block+1].x = i - x_curr;
	          MVframe[block+1].y = j - y_curr;
	          Min_FRAME[block+1] = sad;
	        }
	      }	
	    }
	    if      (k<2*l) i++;
	    else if (k<4*l) j++;
	    else if (k<6*l) i--;
	    else            j--;
      }
    }
  }

  i = x_curr/H263_MB_SIZE+1;
  j = y_curr/H263_MB_SIZE+1;

  if (!H263Info->advanced) {
    MV[0][j][i]->x = MVframe[0].x;
    MV[0][j][i]->y = MVframe[0].y;
    MV[0][j][i]->min_error = (short)Min_FRAME[0];
  }
  else {
    for (k = 0; k < 5; k++) {
      MV[k][j][i]->x = MVframe[k].x;
      MV[k][j][i]->y = MVframe[k].y;
      MV[k][j][i]->min_error = (short)Min_FRAME[k];
    }
  }
#if 0
  ScFree(act_block);
  ScFree(search_area);
#endif
  if (H263Info->advanced) ScFree(adv_search_area);
  return;
}

/**********************************************************************
 *
 *	Name:		LoadArea
 *	Description:    fills array with a square of image-data
 *	
 *	Input:	       pointer to image and position, x and y size
 *	Returns:       pointer to area
 *	Side effects:  memory allocated to array
 *
 ***********************************************************************/
#if 1
static unsigned char *sv_H263LoadArea(unsigned char *im, int x, int y,
                                     int x_size, int y_size, int lx)
{
  unsigned char *res = (unsigned char *)ScAlloc(sizeof(char)*x_size*y_size);
  register unsigned char *in, *out;

  in = im + (y*lx) + x;
  out = res;

  while (y_size--) {
    memcpy(out,in,x_size) ;
	in += lx ;
	out += x_size;
  };
  return res;
}
#else
static unsigned char *svH263LoadArea(unsigned char *im, int x, int y,
                                     int x_size, int y_size, int lx)
{
  unsigned char *res = (unsigned char *)ScAlloc(sizeof(char)*x_size*y_size);
  unsigned char *in;
  unsigned char *out;
  int i = x_size;
  int j = y_size;

  in = im + (y*lx) + x;
  out = res;

  while (j--) {
    while (i--)
      *out++ = *in++;
    i = x_size;
    in += lx - x_size;
  };
  return res;
}
#endif

/**********************************************************************
 *
 *	Name:		SAD_Macroblock
 *	Description:    fast way to find the SAD of one vector
 *	
 *	Input:	        pointers to search_area and current block,
 *                      Min_F1/F2/FR
 *	Returns:        sad_f1/f2
 *	Side effects:
 *
 ***********************************************************************/

#ifdef USE_C /* replaced by sv_H263PError16x16_S */
int sv_H263SADMacroblock(unsigned char *ii, unsigned char *act_block,
                               int h_length, int lx2, int Min_FRAME)
{
  unsigned char *kk;
  int i;
  int sad = 0;

  kk = act_block;
  i = 16;
  while (i--) {
    sad += (abs(*ii     - *kk     ) +abs(*(ii+1 ) - *(kk+1) )
  	    +abs(*(ii+2) - *(kk+2) ) +abs(*(ii+3 ) - *(kk+3) )
	    +abs(*(ii+4) - *(kk+4) ) +abs(*(ii+5 ) - *(kk+5) )
	    +abs(*(ii+6) - *(kk+6) ) +abs(*(ii+7 ) - *(kk+7) )
	    +abs(*(ii+8) - *(kk+8) ) +abs(*(ii+9 ) - *(kk+9) )
	    +abs(*(ii+10)- *(kk+10)) +abs(*(ii+11) - *(kk+11))
	    +abs(*(ii+12)- *(kk+12)) +abs(*(ii+13) - *(kk+13))
	    +abs(*(ii+14)- *(kk+14)) +abs(*(ii+15) - *(kk+15)) );

    ii += h_length;
    kk += lx2;

    if (sad > Min_FRAME)
      return INT_MAX;
  }

  return sad;
}
#endif

#ifdef USE_C /* replaced by  sv_H263PError8x8_S */
int svH263SAD_Block(unsigned char *ii, unsigned char *act_block,
	                int h_length, int min_sofar)
{
  unsigned char *kk;
  int i;
  int sad = 0;

  kk = act_block;
  i = 8;
  while (i--) {
    sad += (abs(*ii  - *kk     ) +abs(*(ii+1 ) - *(kk+1) )
	    +abs(*(ii+2) - *(kk+2) ) +abs(*(ii+3 ) - *(kk+3) )
	    +abs(*(ii+4) - *(kk+4) ) +abs(*(ii+5 ) - *(kk+5) )
	    +abs(*(ii+6) - *(kk+6) ) +abs(*(ii+7 ) - *(kk+7) ));

    ii += h_length;
    kk += 16;
    if (sad > min_sofar)
      return INT_MAX;
  }

  return sad;
}
#endif

int sv_H263BError16x16_C(unsigned char *ii, unsigned char *aa, unsigned char *bb,
                         int width, int min_sofar)
{
  unsigned char *ll, *kk;

  int i, sad = 0;

  kk = aa;
  ll = bb;
  i = 16;
  while (i--) {
    sad += (abs(*ii  - ((*kk    + *ll    )>>1)) +
	    abs(*(ii+1)  - ((*(kk+1)+ *(ll+1))>>1)) +
	    abs(*(ii+2)  - ((*(kk+2)+ *(ll+2))>>1)) +
	    abs(*(ii+3)  - ((*(kk+3)+ *(ll+3))>>1)) +
	    abs(*(ii+4)  - ((*(kk+4)+ *(ll+4))>>1)) +
	    abs(*(ii+5)  - ((*(kk+5)+ *(ll+5))>>1)) +
	    abs(*(ii+6)  - ((*(kk+6)+ *(ll+6))>>1)) +
	    abs(*(ii+7)  - ((*(kk+7)+ *(ll+7))>>1)) +
	    abs(*(ii+8)  - ((*(kk+8)+ *(ll+8))>>1)) +
	    abs(*(ii+9)  - ((*(kk+9)+ *(ll+9))>>1)) +
	    abs(*(ii+10) - ((*(kk+10)+ *(ll+10))>>1)) +
	    abs(*(ii+11) - ((*(kk+11)+ *(ll+11))>>1)) +
	    abs(*(ii+12) - ((*(kk+12)+ *(ll+12))>>1)) +
	    abs(*(ii+13) - ((*(kk+13)+ *(ll+13))>>1)) +
	    abs(*(ii+14) - ((*(kk+14)+ *(ll+14))>>1)) +
	    abs(*(ii+15) - ((*(kk+15)+ *(ll+15))>>1)));

    ii += width;
    kk += width;
    ll += width;
    if (sad > min_sofar)
      return INT_MAX;
  }
  return sad;
}

/**********************************************************************
 *
 *	Name:		FindMB
 *	Description:	Picks out one MB from picture
 *	
 *	Input:		position of MB to pick out,
 *			pointer to frame data, empty 16x16 array	
 *	Returns:	
 *	Side effects:	fills array with MB data
 *
 ***********************************************************************/

void sv_H263FindMB(SvH263CompressInfo_t *H263Info, int x, int y, unsigned char *image, short MB[16][16])
{
#ifndef USE_C
  sv_H263CtoI16_S((image + y*H263Info->pels + x), &(MB[0][0]), H263Info->pels);
#else
  register int m, n;

 int xdiff = H263Info->pels - H263_MB_SIZE;
  unsigned char *in;
  short *out;

  in = image + y*H263Info->pels + x;
  out = &(MB[0][0]);

  m = H263_MB_SIZE;
  while (m--) {
    n = H263_MB_SIZE;
    while (n--) *out++ = *in++;
    in += xdiff ;
  };
#endif
}

/**********************************************************************
 *
 *	Name:		MotionEstimation
 *	Description:	Estimate all motionvectors for one MB
 *	
 *	Input:		pointers to current an previous image,
 *			pointers to current slice and current MB
 *	Returns:	
 *	Side effects:	motion vector information in MB changed
 *
 ***********************************************************************/

void sv_H263FastME(SvH263CompressInfo_t *H263Info,
                   unsigned char *curr, unsigned char *prev, int x_curr,
		           int y_curr, int xoff, int yoff, int seek_dist,
		           short *MVx, short *MVy, short *MVer, int *SAD_0)
{
  int Min_FRAME;
  H263_MotionVector MVframe;
  int sxy,i,k,j;
  int ihigh,ilow,jhigh,jlow,h_length,v_length;
  unsigned char *act_block,*ii,*search_area, *zero_area = NULL;
  int h_lenby2,v_lenby2;
  unsigned char *act_block_subs2, *search_area_subs2;
  int xmax,ymax,sad;
  int xlevel1,ylevel1;
  int level1_x_curr,level1_y_curr;
  int level0_x_curr,level0_y_curr;

  xmax = H263Info->pels;
  ymax = H263Info->lines;
  sxy = seek_dist;

  sxy = mmin(15, sxy);

  ilow = x_curr + xoff - sxy;
  ihigh = x_curr + xoff + sxy;

  jlow = y_curr + yoff - sxy;
  jhigh = y_curr + yoff + sxy;

  if (ilow<0) ilow = 0;
  if (ihigh>xmax-16) ihigh = xmax-16;
  if (jlow<0) jlow = 0;
  if (jhigh>ymax-16) jhigh = ymax-16;

  h_length = ihigh - ilow + 16;
  v_length = jhigh - jlow + 16;

  act_block   = curr + x_curr +  y_curr * H263Info->pels;
  search_area = prev + ilow   +  jlow   * H263Info->pels;

  /* subsampled version for ME level 1 */
  h_lenby2 = (h_length-1)>>1;
  v_lenby2 = (v_length-1)>>1;
  act_block_subs2   = H263Info->block_subs2;
  search_area_subs2 = H263Info->srch_area_subs2;
  sv_H263LdSubs2Area(curr, x_curr, y_curr, 8, 8, H263Info->pels, act_block_subs2, 8);
  sv_H263LdSubs2Area(prev, ilow, jlow, h_lenby2, v_lenby2, H263Info->pels,
	                                  search_area_subs2, H263_SRCH_RANGE);

  Min_FRAME = INT_MAX;
  MVframe.x = 0;
  MVframe.y = 0;
  MVframe.x_half = 0;
  MVframe.y_half = 0;

  /* match for zero (or [xoff,yoff]) motion vector on subsampled images */
  ii = search_area_subs2 +
	      ((x_curr+xoff-ilow)>>1) + ((y_curr+yoff-jlow)>>1)*H263_SRCH_RANGE;
#ifndef USE_C
  Min_FRAME = sv_H263PEr8_init_S(ii,act_block_subs2,H263_SRCH_RANGE,8);
#else
  Min_FRAME = sv_H263MySADBlock(ii,act_block_subs2,H263_SRCH_RANGE,8,INT_MAX);
#endif
  MVframe.x = (short)xoff;
  MVframe.y = (short)yoff;

  /*** +-7 search on subsampled images: ***
   *** three-step +-4, +-2, +-1         ***/

  /* first step: +- 4 */
  /* sxylevel1 = 4; */
  i = x_curr + xoff - 8;
  j = y_curr + yoff - 8;
  for (k = 0; k < 32; k++) {
    if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {
      /* 8x8 integer pel MV */
      ii  = search_area_subs2+((i-ilow)>>1) + ((j-jlow)>>1)*H263_SRCH_RANGE;
#ifndef USE_C
      sad = sv_H263PError8x8_S(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME);
#else
      sad = sv_H263MySADBlock(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME);
#endif
      if (sad < Min_FRAME) {
	    MVframe.x = i - x_curr;
	    MVframe.y = j - y_curr;
	    Min_FRAME = sad;
      }
    }
    if      (k<8)  i+=2;
    else if (k<16) j+=2;
    else if (k<24) i-=2;
    else           j-=2;
  }

  /* second step: +- 2 */
  /* sxylevel1 = 2; */
  level1_x_curr = x_curr + MVframe.x;
  level1_y_curr = y_curr + MVframe.y;

  i = level1_x_curr - 4;
  j = level1_y_curr - 4;

  for (k = 0; k < 16; k++) {
    if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {
      /* 8x8 integer pel MV */
      ii  = search_area_subs2+((i-ilow)>>1) + ((j-jlow)>>1) * H263_SRCH_RANGE;
#ifndef USE_C
      sad = sv_H263PError8x8_S(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME);
#else
      sad = sv_H263MySADBlock(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME);
#endif
      if (sad < Min_FRAME) {
	    MVframe.x = i - x_curr;
	    MVframe.y = j - y_curr;
	    Min_FRAME = sad;
      }
    }
    if      (k<4)  i+=2;
    else if (k<8)  j+=2;
    else if (k<12) i-=2;
    else           j-=2;
  }

  /* third step: +- 1 */
  /*  sxylevel1 = 1; */
  level1_x_curr = x_curr + MVframe.x;
  level1_y_curr = y_curr + MVframe.y;

  i = level1_x_curr - 2;
  j = level1_y_curr - 2;

  for (k = 0; k < 8; k++) {
    if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {
      /* 8x8 integer pel MV */
      ii  = search_area_subs2+((i-ilow)>>1) + ((j-jlow)>>1) * H263_SRCH_RANGE;
#ifndef USE_C
      sad = sv_H263PError8x8_S(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME);
#else
      sad = sv_H263MySADBlock(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME);
#endif
      if (sad < Min_FRAME) {
	    MVframe.x = i - x_curr;
	    MVframe.y = j - y_curr;
 	    Min_FRAME = sad;
      }
    }
    if      (k<2) i+=2;
    else if (k<4) j+=2;
    else if (k<6) i-=2;
    else          j-=2;
  }

  /* motion vectors after step3 - level1 */
  xlevel1=MVframe.x;
  ylevel1=MVframe.y;

  /* reset */
  Min_FRAME = INT_MAX;
  MVframe.x = 0;
  MVframe.y = 0;

  /* Zero vector search*/
  if (x_curr-ilow         < 0        || y_curr-jlow         < 0        ||
      x_curr-ilow+H263_MB_SIZE > h_length || y_curr-jlow+H263_MB_SIZE > v_length) {
    /* in case the zero vector is outside the loaded area in search_area */
    zero_area = sv_H263LoadArea(prev, x_curr, y_curr, 16, 16, H263Info->pels);

#ifndef USE_C
    *SAD_0 = sv_H263PError16x16_S(zero_area, act_block, 16, H263Info->pels, INT_MAX) -
             H263_PREF_NULL_VEC;
#else
    *SAD_0 = sv_H263SADMacroblock(zero_area, act_block, 16, H263Info->pels, INT_MAX) -
             H263_PREF_NULL_VEC;
#endif

    ScFree(zero_area);
  }
  else {
    /* the zero vector is within search_area */
    ii = search_area + (x_curr-ilow) + (y_curr-jlow)*H263Info->pels;

#ifndef USE_C
    *SAD_0 = sv_H263PError16x16_S(ii, act_block, H263Info->pels, H263Info->pels, INT_MAX) -
       H263_PREF_NULL_VEC;
#else
    *SAD_0 = sv_H263SADMacroblock(ii, act_block, H263Info->pels, H263Info->pels, INT_MAX) -
       H263_PREF_NULL_VEC;
#endif
  }

  if (xoff == 0 && yoff == 0) {
    Min_FRAME = *SAD_0;
    MVframe.x = 0;
    MVframe.y = 0;
  }

  if (xlevel1 == 0 && ylevel1 == 0) {
    Min_FRAME = *SAD_0;
    MVframe.x = 0;
    MVframe.y = 0;
  }
  else {
    ii  = search_area + (x_curr+xlevel1-ilow) + (y_curr+ylevel1-jlow)*H263Info->pels;

#ifndef USE_C
    sad = sv_H263PError16x16_S(ii, act_block, H263Info->pels, H263Info->pels, Min_FRAME) ;
#else
    sad = sv_H263SADMacroblock(ii, act_block, H263Info->pels, H263Info->pels, Min_FRAME) ;
#endif
    if (sad < Min_FRAME) {
      MVframe.x = (short)xlevel1;
      MVframe.y = (short)ylevel1;
      Min_FRAME = sad;
    }
  }

  /* NB: if xoff or yoff != 0, the Extended MV Range is used. If we
     allow the zero vector to be chosen prior to the half pel search
     in this case, the half pel search might lead to a
     non-transmittable vector (on the wrong side of zero). If SAD_0
     turns out to be the best SAD, the zero-vector will be chosen
     after half pel search instead.  The zero-vector can be
     transmitted in all modes, no matter what the MV predictor is */

  /*** +-1 search on full-resolution images ***/
  level0_x_curr = x_curr + xlevel1;
  level0_y_curr = y_curr + ylevel1;
  /*  sxylevel0=1; */
  i = level0_x_curr - 1;
  j = level0_y_curr - 1;
  for (k = 0; k < 8; k++) {
    if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {
      /* 16x16 integer pel MV */
      ii  = search_area + (i-ilow) + (j-jlow)*H263Info->pels;
#ifndef USE_C
      sad = sv_H263PError16x16_S(ii, act_block, H263Info->pels, H263Info->pels, Min_FRAME) ;
#else
      sad = sv_H263SADMacroblock(ii, act_block, H263Info->pels, H263Info->pels, Min_FRAME) ;
#endif
	  if (sad < Min_FRAME) {
	    MVframe.x = i - x_curr;
	    MVframe.y = j - y_curr;
	    Min_FRAME = sad;
	  }
    }
    if      (k<2) i++;
    else if (k<4) j++;
    else if (k<6) i--;
    else          j--;
  }

  i = x_curr/H263_MB_SIZE+1;
  j = y_curr/H263_MB_SIZE+1;

  *MVx  = MVframe.x;
  *MVy  = MVframe.y;
  *MVer = (short)Min_FRAME;

  return;
}


#ifdef USE_C
int sv_H263MySADBlock(unsigned char *ii, unsigned char *act_block,
	      int h_length, int lx2, int min_sofar)
{
/*
  return sv_H263PError8x8_S(ii,act_block,h_length,8,min_sofar);
*/
  int i;
  int sad = 0;
  unsigned char *kk;

  kk = act_block;
  i = 8;
  while (i--) {
    sad += (abs(*ii     - *kk     ) +
		    abs(*(ii+1 ) - *(kk+1) ) +
	        abs(*(ii+2) - *(kk+2) ) +
			abs(*(ii+3 ) - *(kk+3) ) +
	        abs(*(ii+4) - *(kk+4) ) +
		    abs(*(ii+5 ) - *(kk+5) ) +
	        abs(*(ii+6) - *(kk+6) ) +
			abs(*(ii+7 ) - *(kk+7) ));

    ii += h_length;
    kk += lx2;
    if (sad > min_sofar)
      return INT_MAX;
  }
  return sad;
}

#endif

/**********************************************************************
 *
 *	Name:		LoadArea
 *	Description:    fills array with a square of image-data
 *	
 *	Input:	       pointer to image and position, x and y size
 *	Returns:       pointer to area
 *	Side effects:  memory allocated to array
 *
 *
 ***********************************************************************/

void sv_H263LdSubs2Area(unsigned char *im, int x, int y,
  	                    int x_size, int y_size, int lx,
						unsigned char *srch_area, int area_length)
{
  register unsigned char *in, *out;
  register int incrs1, incrs2, i;

  x = ((x+1)>>1) << 1;  /* subsampled images always correspond to pixels*/
  y = ((y+1)>>1) << 1;  /* of even coordinates in the original image */

  in = im + (y*lx) + x;
  out = srch_area;

#ifdef USE_C
  incrs1 = (lx - x_size) << 1;
  incrs2 = area_length - x_size;
  while (y_size--) {
    i = x_size;
    while (i--) {
      *out++ = *in;
      in+=2;
    }
    in += incrs1;
    out += incrs2;
  };
#else
  if(area_length == 8){
    sv_H263Subsamp8_S(in, out, y_size, (lx << 1)) ;
  }
  else {
    incrs1 = (lx - x_size) << 1;
    incrs2 = area_length - x_size;
    while (y_size--) {
      i = x_size;
      while (i--) {
        *out++ = *in;
        in+=2;
      }
      in += incrs1;
	  out += incrs2;
    };
  }
#endif

  return ;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\me4.c ===
/* File: sv_h263_me4.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#include "sv_h263.h"
#include "proto.h"
#ifndef USE_C
#include "perr.h"
#endif

#define THREEBYEIGHT .375
#define THREEBYFOUR .75
#define MINUSONEBYEIGHT -0.125

#define FIVEBY32 0.15625
#define FIFTEENBY16 0.9375
#define MINUSTHREEBY32 -0.09375

#define SEVENBY16 0.4375
#define TWENTYONEBY32 0.65625

/**********************************************************************
 *
 *	Name:		MotionEstimation
 *	Description:	Estimate all motionvectors for one MB
 *	
 *	Input:		pointers to current an previous image,
 *			pointers to current slice and current MB
 *	Returns:	
 *	Side effects:	motion vector information in MB changed
 *
 ***********************************************************************/


void sv_H263ME_2levels_7_pihp(SvH263CompressInfo_t *H263Info,
                              unsigned char *curr, unsigned char *prev, int x_curr,
                              int y_curr, int xoff, int yoff, int seek_dist,
                              H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0)
{

  int Min_FRAME[5];
  H263_MotionVector MVFrame[5];
  unsigned char *aa,*ii;
  unsigned char *adv_search_area = NULL, *zero_area = NULL;
  int sxy,i,k,j,l;
  int ihigh,ilow,jhigh,jlow,h_length,v_length;
  int adv_ihigh,adv_ilow,adv_jhigh,adv_jlow,adv_h_length,adv_v_length;
  int xmax,ymax,block,sad,lx;
  int adv_x_curr, adv_y_curr,xvec,yvec;

  unsigned char *act_block_subs2, *search_area_subs2, *adv_search_area_subs2;
  int h_lenby2,v_lenby2,adv_h_lenby2,adv_v_lenby2;
  int xlevel1,ylevel1,sxylevel1;
  int xlevel1_block[4], ylevel1_block[4];
/*
  int level0_x_curr,level0_y_curr,sxylevel0;
*/
  int start_x, start_y, stop_x, stop_y, new_x, new_y;
  int AE[5];
  H263_Point search[5];
  H263_Point half[5];
  int pym1,pxm1,pxp1,pyp1;
  int pym05,pxm05,pxp05,pyp05;
  int AE_minx, AE_miny, min_posx, min_posy, min_hposx, min_hposy;


  xmax = H263Info->pels;
  ymax = H263Info->lines;
  sxy = seek_dist;
  if (!H263Info->long_vectors) {
    /* Maximum normal search range centered around _zero-vector_ */
    sxy = mmin(15, sxy);
  }
  else {
    /* Maximum extended search range centered around _predictor_ */
    sxy = mmin(15 - (2*H263_DEF_8X8_WIN+1), sxy);

    /* NB! */

    /* It is only possible to transmit motion vectors within
       a 15x15 window around the motion vector predictor
       for any 8x8 or 16x16 block */

    /* The reason for the search window's reduction above with
       2*DEF_8X8_WIN+1 is that the 8x8 search may change the MV
       predictor for some of the blocks within the macroblock. When we
       impose the limitation above, we are sure that any 8x8 vector we
       might find is possible to transmit */

    /* We have found that with OBMC, DEF_8X8_WIN should be quite small
       for two reasons: (i) a good filtering effect, and (ii) not too
       many bits used for transferring the vectors. As can be seen
       above this is also useful to avoid a large limitation on the MV
       search range */

    /* It is possible to make sure the motion vectors found are legal
       in other less limiting ways than above, but this would be more
       complicated as well as time-consuming. Any good suggestions for
       improvement is welcome, though */
#ifdef USE_C
    xoff = mmin(16,mmax(-16,xoff));
    yoff = mmin(16,mmax(-16,yoff));
#else
	xoff = sv_H263lim_S(xoff,-16,16);
    yoff = sv_H263lim_S(yoff,-16,16);
#endif

    /* in case xoff or yoff is odd */
    xoff= 2 * ((xoff)>>1);
    yoff= 2 * ((yoff)>>1);

    /* There is no need to check if (xoff + x_curr) points outside
       the picture, since the Extended Motion Vector Range is
       always used together with the Unrestricted MV mode */
  }


  lx = (H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels);

  ilow = x_curr + xoff - sxy;
  ihigh = x_curr + xoff + sxy;

  jlow = y_curr + yoff - sxy;
  jhigh = y_curr + yoff + sxy;

  if (!H263Info->mv_outside_frame) {
    if (ilow<0) ilow = 0;
    if (ihigh>xmax-16) ihigh = xmax-16;
    if (jlow<0) jlow = 0;
    if (jhigh>ymax-16) jhigh = ymax-16;
  }

  h_length = ihigh - ilow + 16;
  v_length = jhigh - jlow + 16;

  /* subsampled version for ME level 1 */
  h_lenby2 = (h_length-1)>>1;
  v_lenby2 = (v_length-1)>>1;
  act_block_subs2 = sv_H263LoadSubs2Area(curr, x_curr, y_curr, 8, 8, H263Info->pels);
  search_area_subs2 = sv_H263LoadSubs2Area(prev, ilow, jlow, h_lenby2, v_lenby2, lx);

  for (k = 0; k < 5; k++) {
    Min_FRAME[k] = INT_MAX;
    MVFrame[k].x = 0;
    MVFrame[k].y = 0;
    MVFrame[k].x_half = 0;
    MVFrame[k].y_half = 0;
  }

  /* match for zero (or [xoff,yoff]) motion vector on subsampled images */
  ii = search_area_subs2 + ((x_curr+xoff-ilow)>>1) + ((y_curr+yoff-jlow)>>1)*h_lenby2;
#ifdef USE_C
  Min_FRAME[0] = sv_H263MySADBlock(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]);
#else
  Min_FRAME[0] = sv_H263PError8x8_S(ii,act_block_subs2,h_lenby2,8,Min_FRAME[0]);
#endif

  MVFrame[0].x = (short)xoff;
  MVFrame[0].y = (short)yoff;

  /*** Spiral search (+-7) on subsampled images ***/

  sxylevel1 = (sxy-1)>>1;

  for (l = 1; l <= sxylevel1; l++) {
    i = x_curr + xoff - 2*l;
    j = y_curr + yoff - 2*l;
    for (k = 0; k < 8*l; k++) {
      if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {

	/* 8x8 integer pel MV */
	ii = search_area_subs2 + ((i-ilow)>>1) + ((j-jlow)>>1)*h_lenby2;
#ifdef USE_C
	sad = sv_H263MySADBlock(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]);
#else
      sad = sv_H263PError8x8_S(ii,act_block_subs2,h_lenby2,8,Min_FRAME[0]);
#endif
	if (sad < Min_FRAME[0]) {
	  MVFrame[0].x = i - x_curr;
	  MVFrame[0].y = j - y_curr;
	  Min_FRAME[0] = sad;
	}

      }
      if      (k<2*l) i+=2;
      else if (k<4*l) j+=2;
      else if (k<6*l) i-=2;
      else            j-=2;
    }
  }

  /* motion vectors after level1 */
  xlevel1=MVFrame[0].x;
  ylevel1=MVFrame[0].y;

  /* reset */
  Min_FRAME[0] = INT_MAX;
  MVFrame[0].x = 0;
  MVFrame[0].y = 0;

  /* Zero vector search*/
  if (x_curr-ilow         < 0        || y_curr-jlow         < 0        ||
      x_curr-ilow+H263_MB_SIZE > h_length || y_curr-jlow+H263_MB_SIZE > v_length) {
    /* in case the zero vector is outside the loaded area in search_area */

    zero_area = sv_H263LoadSubs2Area(prev, x_curr, y_curr, 8, 8, lx);
#ifdef USE_C
    *SAD_0 = 4*sv_H263MySADBlock(zero_area, act_block_subs2, 8, 8, Min_FRAME[0]) -
       H263_PREF_NULL_VEC;
#else
    *SAD_0 = 4*sv_H263PError8x8_S(zero_area, act_block_subs2, 8, 8, Min_FRAME[0]) -
       H263_PREF_NULL_VEC;
#endif
    ScFree(zero_area);
  }
  else {
    /* the zero vector is within search_area */

    ii = search_area_subs2 + ((x_curr-ilow)>>1) + ((y_curr-jlow)>>1)*h_lenby2;
#ifdef USE_C
    *SAD_0 = 4*sv_H263MySADBlock(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]) -
       H263_PREF_NULL_VEC;
#else
    *SAD_0 = 4*sv_H263PError8x8_S(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]) -
       H263_PREF_NULL_VEC;
#endif
  }

  /*** +-1 search on full-resolution images done by polynomial interpolation ***/

  start_x = -1;
  stop_x = 1;
  start_y = -1;
  stop_y = 1;

  new_x = x_curr + xlevel1;
  new_y = y_curr + ylevel1;

  /* Make sure that no addressing is outside the frame */
  if (!H263Info->mv_outside_frame) {
    if ((new_x) <= (ilow+1))
      start_x = 0;
    if ((new_y) <= (jlow+1))
      start_y = 0;
    if ((new_x) >= (ihigh-1))
      stop_x = 0;
    if ((new_y) >= (jhigh-1))
      stop_y = 0;
  }

 /*     1     */
 /*   2 0 3   */
 /*     4     */

  search[0].x = 0; 		search[0].y = 0;
  search[1].x = 0; 		search[1].y = (short)start_y;
  search[2].x = (short)start_x;     	search[2].y = 0;
  search[3].x = (short)stop_x;     	search[3].y = 0;
  search[4].x = 0; 	       	search[4].y = (short)stop_y;

  half[0].x = 0; 		half[0].y = 0;
  half[1].x = 0; 		half[1].y = (short)start_y;
  half[2].x = (short)start_x;     	half[2].y = 0;
  half[3].x = (short)stop_x;     	half[3].y = 0;
  half[4].x = 0; 	       	half[4].y = (short)stop_y;

  for (l = 0; l < 5 ; l++) {
    AE[l] = INT_MAX;
    i =  new_x + 2*search[l].x;
    j =  new_y + 2*search[l].y;
	/* 8x8 integer pel MV */
	ii = search_area_subs2 + ((i-ilow)>>1) + ((j-jlow)>>1)*h_lenby2;
#ifdef USE_C
	AE[l] = sv_H263MySADBlock(ii, act_block_subs2, h_lenby2, 8, INT_MAX);
#else
	AE[l] = sv_H263PEr8_init_S(ii, act_block_subs2, h_lenby2, 8);
#endif
  }

  /* 1D polynomial interpolation along x and y respectively */

  AE_minx = AE[0];
  min_posx = 0;
  min_hposx = 0;

  pxm1 = (int)(THREEBYEIGHT * (double) AE[2]
             + THREEBYFOUR * (double) AE[0]
             + MINUSONEBYEIGHT * (double) AE[3]) ;

  if (pxm1<AE_minx) {
    AE_minx = pxm1;
    min_posx = 2;
  }

  pxp1 = (int)(MINUSONEBYEIGHT * (double) AE[2]
             + THREEBYFOUR * (double) AE[0]
             + THREEBYEIGHT * (double) AE[3]);

  if (pxp1<AE_minx) {
    AE_minx = pxp1;
    min_posx = 3;
  }

  switch(min_posx) {

  case 0:  /* now check +- 1/2 */
    pxm05 = (int)( FIVEBY32 * (double) AE[2]
                 + FIFTEENBY16 * (double) AE[0]
                 + MINUSTHREEBY32 * (double) AE[3]);

    if (pxm05<AE_minx) {
      AE_minx = pxm05;
      min_hposx = 2;
    }

    pxp05 = (int)( MINUSTHREEBY32 * (double) AE[2]
                 + FIFTEENBY16 * (double) AE[0]
                 + FIVEBY32 * (double) AE[3]);

    if (pxp05<AE_minx) {
      AE_minx = pxp05;
      min_hposx = 3;
    }
    break;

  case 2:  /* now check -3/2 -1/2 */
    pxp05 = (int)(FIVEBY32 * AE[2]
                + FIFTEENBY16 * AE[0]
 	            + MINUSTHREEBY32 * AE[3]);

    if (pxp05<AE_minx) {
      AE_minx = pxp05;
      min_hposx = 3;
    }
    break;

  case 3:  /* now check +1/2 +3/2 */
    pxm05 = (int)( MINUSTHREEBY32 * (double)AE[2]
                   + FIFTEENBY16 * (double)AE[0]
	               + FIVEBY32 * (double)AE[3]);

    if (pxm05<AE_minx) {
      AE_minx = pxm05;
      min_hposx = 2;
    }
    break;
  }

  /* along y */

  AE_miny = AE[0];
  min_posy = 0;
  min_hposy = 0;

  pym1 = (int)(THREEBYEIGHT * (double)AE[1]
             + THREEBYFOUR * (double)AE[0]
             + MINUSONEBYEIGHT * (double)AE[4]);

  if (pym1<AE_miny) {
    AE_miny = pym1;
    min_posy = 1;
  }

  pyp1 = (int)( MINUSONEBYEIGHT * (double)AE[1]
                + THREEBYFOUR * (double)AE[0]
                + THREEBYEIGHT * (double)AE[4]);

  if (pyp1<AE_miny) {
    AE_miny = pyp1;
    min_posy = 4;
  }

  switch(min_posy) {

  case 0:  /* +- 1/2 */
    pym05 = (int)( FIVEBY32 * (double)AE[1]
                 + FIFTEENBY16 * (double)AE[0]
	             + MINUSTHREEBY32 * (double)AE[4]);

    if (pym05<AE_miny) {
      AE_miny = pym05;
      min_hposy = 1;
    }

    pyp05 = (int)(MINUSTHREEBY32 * (double)AE[1]
                + FIFTEENBY16 * (double)AE[0]
	            + FIVEBY32 * (double)AE[4]);

    if (pyp05<AE_miny) {
      AE_miny = pyp05;
      min_hposy = 4;
    }
    break;

  case 1:  /*  -3/2 -1/2 */
    pyp05 = (int)(FIVEBY32 * (double)AE[1]
                + FIFTEENBY16 * (double)AE[0]
	            + MINUSTHREEBY32 * (double)AE[4]);

    if (pyp05<AE_miny) {
      AE_miny = pyp05;
      min_hposy = 4;
    }
    break;

  case 4:  /* +1/2 +3/2 */
    pym05 = (int)( MINUSTHREEBY32 * (double)AE[1]
                 + FIFTEENBY16 * (double)AE[0]
	             + FIVEBY32 * (double)AE[4]);

    if (pym05<AE_miny) {
      AE_miny = pym05;
      min_hposy = 1;
    }
    break;

  }

  /* Store optimal values */
  Min_FRAME[0] = (AE_minx<AE_miny ? 4*AE_minx : 4*AE_miny);
  MVFrame[0].x = new_x + search[min_posx].x - x_curr;
  MVFrame[0].y = new_y + search[min_posy].y - y_curr;
  MVFrame[0].x_half = half[min_hposx].x;
  MVFrame[0].y_half = half[min_hposy].y;

  if (H263Info->advanced) {

    /* Center the 8x8 search around the 16x16 vector.  This is
       different than in TMN5 where the 8x8 search is also a full
       search. The reasons for this is: (i) it is faster, and (ii) it
       generally gives better results because of a better OBMC
       filtering effect and less bits spent for vectors, and (iii) if
       the Extended MV Range is used, the search range around the
       motion vector predictor will be less limited */

    xvec = MVFrame[0].x;
    yvec = MVFrame[0].y;

    if (!H263Info->long_vectors) {
      if (xvec > 15 - H263_DEF_8X8_WIN) { xvec =  15 - H263_DEF_8X8_WIN ;}
      if (yvec > 15 - H263_DEF_8X8_WIN) { yvec =  15 - H263_DEF_8X8_WIN ;}

      if (xvec < -15 + H263_DEF_8X8_WIN) { xvec =  -15 + H263_DEF_8X8_WIN ;}
      if (yvec < -15 + H263_DEF_8X8_WIN) { yvec =  -15 + H263_DEF_8X8_WIN ;}
    }

    adv_x_curr = x_curr  + xvec;
    adv_y_curr = y_curr  + yvec;

    sxy = H263_DEF_8X8_WIN;

    adv_ilow = adv_x_curr - sxy;
    adv_ihigh = adv_x_curr + sxy;

    adv_jlow = adv_y_curr - sxy;
    adv_jhigh = adv_y_curr + sxy;

    adv_h_length = adv_ihigh - adv_ilow + 16;
    adv_v_length = adv_jhigh - adv_jlow + 16;

/*  BUG
    adv_h_lenby2 = (adv_h_length-1)>>1;
    adv_v_lenby2 = (adv_v_length-1)>>1;
*/
    adv_h_lenby2 = (adv_h_length)>>1;
    adv_v_lenby2 = (adv_v_length)>>1;
/*
    adv_search_area_subs2 = sv_H263LoadSubs2Area(prev, adv_ilow, adv_jlow,
			       adv_h_lenby2, adv_v_lenby2, lx);
*/
    adv_search_area_subs2 = sv_H263LoadSubs2Area(prev, adv_ilow, adv_jlow,
			       adv_h_length, adv_v_length, lx);

    for (block = 0; block < 4; block++) {
      ii = adv_search_area_subs2 + ((adv_x_curr-adv_ilow)>>1) + ((block&1)<<2) +
	(((adv_y_curr-adv_jlow)>>1) + ((block&2)<<1) )*adv_h_lenby2;
      aa = act_block_subs2 + ((block&1)<<2) + ((block&2)<<1)*8;
/*
      Min_FRAME[block+1] = sv_H263MySADSubBlock(ii,aa,adv_h_lenby2,Min_FRAME[block+1]);
*/
      Min_FRAME[block+1] = sv_H263MySADSubBlock(ii,aa,adv_h_length,Min_FRAME[block+1]);

      MVFrame[block+1].x = MVFrame[0].x;
      MVFrame[block+1].y = MVFrame[0].y;
    }

    /* Spiral search */
    sxylevel1 = (sxy-1)>>1;

    for (l = 1; l <= sxylevel1; l++) {
      i = adv_x_curr - 2*l;
      j = adv_y_curr - 2*l;
      for (k = 0; k < 8*l; k++) {
	if (i>=adv_ilow && i<=adv_ihigh && j>=adv_jlow && j<=adv_jhigh) {
	
	  /* 8x8 integer pel MVs */
	  for (block = 0; block < 4; block++) {
	    ii = adv_search_area_subs2 + ((i-adv_ilow)>>1) + ((block&1)<<2) +
	      (((j-adv_jlow)>>1) + ((block&2)<<1) )*adv_h_lenby2;
	    aa = act_block_subs2 + ((block&1)<<2) + ((block&2)<<1)*8;
/*
	    sad = sv_H263MySADSubBlock(ii, aa, adv_h_lenby2, Min_FRAME[block+1]);
*/
	    sad = sv_H263MySADSubBlock(ii, aa, adv_h_length, Min_FRAME[block+1]);

	    if (sad < Min_FRAME[block+1]) {
	      MVFrame[block+1].x = i - x_curr;
	      MVFrame[block+1].y = j - y_curr;
	      Min_FRAME[block+1] = sad;
	    }
	  }
	
	}
	if      (k<2*l) i++;
	else if (k<4*l) j++;
	else if (k<6*l) i--;
	else            j--;
      }
    }

    for (block = 0; block < 4; block++) {
      xlevel1_block[block] = MVFrame[block+1].x;
      ylevel1_block[block] = MVFrame[block+1].y;

      /* reset */
      Min_FRAME[block+1] = INT_MAX;
      MVFrame[block+1].x = 0;
      MVFrame[block+1].y = 0;
    }

    /* +-1 search on full resolution on full-resolution images */
    /* by polynomial interpolation */

    for (block = 0; block < 4; block++) {
      start_x = -1;
      stop_x = 1;
      start_y = -1;
      stop_y = 1;

      adv_x_curr = x_curr + xlevel1_block[block];
      adv_y_curr = y_curr + ylevel1_block[block];

      /*     1     */
      /*   2 0 3   */
      /*     4     */

      search[0].x = 0; 		search[0].y = 0;
      search[1].x = 0; 		search[1].y = (short)start_y;
      search[2].x = (short)start_x;    search[2].y = 0;
      search[3].x = (short)stop_x;     search[3].y = 0;
      search[4].x = 0; 	       	search[4].y = (short)stop_y;

      half[0].x = 0; 		half[0].y = 0;
      half[1].x = 0; 		half[1].y = (short)start_y;
      half[2].x = (short)start_x;     	half[2].y = 0;
      half[3].x = (short)stop_x;     	half[3].y = 0;
      half[4].x = 0; 	       	half[4].y = (short)stop_y;

      for (l = 0; l < 5 ; l++) {
	AE[l] = INT_MAX;
	i =  adv_x_curr + 2*search[l].x;
	j =  adv_y_curr + 2*search[l].y;
	/* 8x8 integer pel MV */
	ii = adv_search_area_subs2 + ((i-adv_ilow)>>1) + ((block&1)<<2) +
	  (((j-adv_jlow)>>1) + ((block&2)<<1) )*adv_h_lenby2;
	aa = act_block_subs2 + ((block&1)<<2) + ((block&2)<<1)*8;
/*
	AE[l] = sv_H263MySADSubBlock(ii, aa, adv_h_lenby2, INT_MAX);
*/
	AE[l] = sv_H263MySADSubBlock(ii, aa, adv_h_length, INT_MAX);

      }

      /* 1D polynomial interpolation along x and y respectively */

      AE_minx = AE[0];
      min_posx = 0;
      min_hposx = 0;

      pxm1 = (int)( THREEBYEIGHT * (double)AE[2]
	              + THREEBYFOUR * (double)AE[0]
	              + MINUSONEBYEIGHT * (double)AE[3]);

      if (pxm1<AE_minx) {
	AE_minx = pxm1;
	min_posx = 2;
      }

      pxp1 = (int)( MINUSONEBYEIGHT * (double)AE[2]
	              + THREEBYFOUR * (double)AE[0]
	              + THREEBYEIGHT * (double)AE[3]);

      if (pxp1<AE_minx) {
	AE_minx = pxp1;
	min_posx = 3;
      }

      switch(min_posx) {

      case 0:  /* now check +- 1/2 */
	pxm05 = (int) (FIVEBY32 * (double)AE[2]
	             + FIFTEENBY16 * (double)AE[0]
	             + MINUSTHREEBY32 * (double)AE[3]);

	if (pxm05<AE_minx) {
	  AE_minx = pxm05;
	  min_hposx = 2;
	}

	pxp05 = (int)(MINUSTHREEBY32 * (double)AE[2]
	            + FIFTEENBY16 * (double)AE[0]
	            + FIVEBY32 * (double)AE[3]);

	if (pxp05<AE_minx) {
	  AE_minx = pxp05;
	  min_hposx = 3;
	}
	break;

      case 2:  /* now check -3/2 -1/2 */
	pxp05 = (int)( FIVEBY32 * (double)AE[2]
	             + FIFTEENBY16 * (double)AE[0]
	             + MINUSTHREEBY32 * (double)AE[3]);

	if (pxp05<AE_minx) {
	  AE_minx = pxp05;
	  min_hposx = 3;
	}
	break;

      case 3:  /* now check +1/2 +3/2 */
	pxm05 = (int)(MINUSTHREEBY32 * (double)AE[2]
	            + FIFTEENBY16 * (double)AE[0]
	            + FIVEBY32 * (double)AE[3]);

	if (pxm05<AE_minx) {
	  AE_minx = pxm05;
	  min_hposx = 2;
	}
	break;
      }

      /* along y */

      AE_miny = AE[0];
      min_posy = 0;
      min_hposy = 0;

      pym1 = (int)(THREEBYEIGHT * (double)AE[1]
	             + THREEBYFOUR * (double)AE[0]
	             + MINUSONEBYEIGHT * (double)AE[4]);

      if (pym1<AE_miny) {
	AE_miny = pym1;
	min_posy = 1;
      }

      pyp1 = (int)(MINUSONEBYEIGHT * (double)AE[1] +
  	             + THREEBYFOUR * (double)AE[0]
	             + THREEBYEIGHT * (double)AE[4]);

      if (pyp1<AE_miny) {
	AE_miny = pyp1;
	min_posy = 4;
      }

      switch(min_posy) {

      case 0:  /* +- 1/2 */
	pym05 = (int)(FIVEBY32 * (double)AE[1]
	            + FIFTEENBY16 * (double)AE[0]
	            + MINUSTHREEBY32 * (double)AE[4]);

	if (pym05<AE_miny) {
	  AE_miny = pym05;
	  min_hposy = 1;
	}

	pyp05 = (int)(MINUSTHREEBY32 * (double)AE[1]
	            + FIFTEENBY16 * (double)AE[0]
	            + FIVEBY32 * (double)AE[4]);

	if (pyp05<AE_miny) {
	  AE_miny = pyp05;
	  min_hposy = 4;
	}
	break;

      case 1:  /*  -3/2 -1/2 */
	pyp05 = (int)(FIVEBY32 * (double)AE[1]
	           + FIFTEENBY16 * (double)AE[0]
	           + MINUSTHREEBY32 * (double)AE[4]);

	if (pyp05<AE_miny) {
	  AE_miny = pyp05;
	  min_hposy = 4;
	}
	break;

      case 4:  /* +1/2 +3/2 */
	pym05 = (int)(MINUSTHREEBY32 * (double)AE[1]
  	            + FIFTEENBY16 * (double)AE[0]
	            + FIVEBY32 * (double)AE[4]);

	if (pym05<AE_miny) {
	  AE_miny = pym05;
	  min_hposy = 1;
	}
	break;

      }

      /* Store optimal values */
      Min_FRAME[block+1] = (AE_minx<AE_miny ? 4*AE_minx : 4*AE_miny);
      MVFrame[block+1].x = adv_x_curr + search[min_posx].x - x_curr;
      MVFrame[block+1].y = adv_y_curr + search[min_posy].y - y_curr;
      MVFrame[block+1].x_half = half[min_hposx].x;
      MVFrame[block+1].y_half = half[min_hposy].y;

    }
  }

  i = x_curr/H263_MB_SIZE+1;
  j = y_curr/H263_MB_SIZE+1;

  if (!H263Info->advanced) {
    MV[0][j][i]->x = MVFrame[0].x;
    MV[0][j][i]->y = MVFrame[0].y;
    MV[0][j][i]->x_half = MVFrame[0].x_half;
    MV[0][j][i]->y_half = MVFrame[0].y_half;
    MV[0][j][i]->min_error = (short)Min_FRAME[0];
  }
  else {
    for (k = 0; k < 5; k++) {
      MV[k][j][i]->x = MVFrame[k].x;
      MV[k][j][i]->y = MVFrame[k].y;
      MV[k][j][i]->x_half = MVFrame[k].x_half;
      MV[k][j][i]->y_half = MVFrame[k].y_half;
      MV[k][j][i]->min_error = (short)Min_FRAME[k];
    }
  }

  ScFree(act_block_subs2);
  ScFree(search_area_subs2);

  if (H263Info->advanced)
    ScFree(adv_search_area);
  return;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\param.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib_param.c,v $
 * Revision 1.1.6.25  1996/12/13  18:19:09  Hans_Graves
 * 	Adjust file size in NEED_ACCURACY, if end of file is bad.
 * 	[1996/12/13  18:13:11  Hans_Graves]
 *
 * Revision 1.1.6.24  1996/12/12  20:54:47  Hans_Graves
 * 	Fixed NT compile warning with use of ftime.
 * 	[1996/12/12  20:51:38  Hans_Graves]
 * 
 * Revision 1.1.6.23  1996/12/05  20:10:18  Hans_Graves
 * 	Change max choosen MPEG audio bitrate to 192kbits
 * 	[1996/12/05  20:09:25  Hans_Graves]
 * 
 * Revision 1.1.6.22  1996/12/04  22:34:34  Hans_Graves
 * 	Make seeking in NEEDACCURACY quicker when seeks fail.
 * 	[1996/12/04  22:20:18  Hans_Graves]
 * 
 * Revision 1.1.6.21  1996/12/03  23:15:18  Hans_Graves
 * 	MME-1498: Made seeks with PERCENT100 more accurate
 * 	[1996/12/03  23:10:48  Hans_Graves]
 * 
 * Revision 1.1.6.20  1996/12/03  00:08:36  Hans_Graves
 * 	Handling of End Of Sequence points. Added PERCENT100 support.
 * 	[1996/12/03  00:06:06  Hans_Graves]
 * 
 * Revision 1.1.6.19  1996/11/18  23:07:38  Hans_Graves
 * 	Make use of presentation timestamps. Make seeking time-based.
 * 	[1996/11/18  22:48:00  Hans_Graves]
 * 
 * Revision 1.1.6.18  1996/11/14  22:32:10  Hans_Graves
 * 	AUDIOCHANNELS can only be changed under AC3 decompression.
 * 	[1996/11/14  22:31:39  Hans_Graves]
 * 
 * Revision 1.1.6.17  1996/11/14  21:49:29  Hans_Graves
 * 	Multichannel setting using AUDIOCHANNELS param.
 * 	[1996/11/14  21:44:44  Hans_Graves]
 * 
 * Revision 1.1.6.16  1996/11/11  18:21:10  Hans_Graves
 * 	Added SlibGetParamString() support for SLIB_PARAM_TYPE.
 * 	[1996/11/11  18:01:25  Hans_Graves]
 * 
 * Revision 1.1.6.15  1996/11/08  21:51:08  Hans_Graves
 * 	Added new PARAMs VIDEOMAINSTREAM, AUDIOMAINSTREAM and TYPE
 * 	[1996/11/08  21:31:08  Hans_Graves]
 * 
 * Revision 1.1.6.14  1996/10/28  17:32:34  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:23:07  Hans_Graves]
 * 
 * Revision 1.1.6.13  1996/10/17  00:23:36  Hans_Graves
 * 	Added SLIB_PARAM_VIDEOFRAME and SLIB_PARAM_FRAMEDURATION.
 * 	[1996/10/17  00:19:44  Hans_Graves]
 * 
 * Revision 1.1.6.12  1996/10/12  17:18:56  Hans_Graves
 * 	Added SLIB_PARAM_SKIPPEL and SLIB_PARAM_HALFPEL support.
 * 	[1996/10/12  17:02:37  Hans_Graves]
 * 
 * Revision 1.1.6.11  1996/10/03  19:14:26  Hans_Graves
 * 	Added Presentation and Decoding timestamp support.
 * 	[1996/10/03  19:10:42  Hans_Graves]
 * 
 * Revision 1.1.6.10  1996/09/29  22:19:44  Hans_Graves
 * 	Added STRIDE param.
 * 	[1996/09/29  21:31:34  Hans_Graves]
 * 
 * Revision 1.1.6.9  1996/09/25  19:16:50  Hans_Graves
 * 	Added SLIB_INTERNAL define.
 * 	[1996/09/25  19:01:56  Hans_Graves]
 * 
 * Revision 1.1.6.8  1996/09/23  18:04:05  Hans_Graves
 * 	Added STATS params.
 * 	[1996/09/23  17:58:54  Hans_Graves]
 * 
 * Revision 1.1.6.7  1996/09/18  23:47:17  Hans_Graves
 * 	Added new PARAMs: VBV, ASPECTRATIO, TIMECODE, VERSION
 * 	[1996/09/18  22:07:17  Hans_Graves]
 * 
 * Revision 1.1.6.6  1996/08/09  20:51:53  Hans_Graves
 * 	Allows deselecting of SLIB_PARAM_VIDEOSTREAMS and SLIB_PARAM_AUDIOSTREAMS
 * 	[1996/08/09  20:12:16  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/07/30  20:25:38  Wei_Hsu
 * 	Add motion algorithm param.
 * 	[1996/07/30  15:59:07  Wei_Hsu]
 * 
 * Revision 1.1.6.4  1996/07/19  02:11:17  Hans_Graves
 * 	Added SLIB_PARAM_DEBUG support
 * 	[1996/07/19  01:59:50  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/05/23  18:46:38  Hans_Graves
 * 	Merge MME-1220 & MME-1221 - Multiply MPEG audio bitrates by 1000 instead of 1024
 * 	[1996/05/23  18:46:09  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/05/10  21:17:47  Hans_Graves
 * 	Allow FILESIZE param to be set, for callbacks.
 * 	[1996/05/10  20:46:23  Hans_Graves]
 * 
 * Revision 1.1.4.13  1996/04/30  17:05:35  Hans_Graves
 * 	Report SlibErrorSettingNotEqual correctly under SetParamFloat(). Fixes MME-01173
 * 	[1996/04/30  16:49:06  Hans_Graves]
 * 
 * Revision 1.1.4.12  1996/04/24  22:33:48  Hans_Graves
 * 	MPEG encoding bitrate fixups.
 * 	[1996/04/24  22:27:16  Hans_Graves]
 * 
 * Revision 1.1.4.11  1996/04/23  21:01:42  Hans_Graves
 * 	Fix SlibValidateParams(). Add error checking for SlibErrorSettingNotEqual
 * 	[1996/04/23  20:59:03  Hans_Graves]
 * 
 * Revision 1.1.4.10  1996/04/22  15:04:54  Hans_Graves
 * 	Added SlibValidateParams()
 * 	[1996/04/22  14:43:04  Hans_Graves]
 * 
 * Revision 1.1.4.9  1996/04/19  21:52:26  Hans_Graves
 * 	Fix BITRATE parameter settings
 * 	[1996/04/19  21:47:01  Hans_Graves]
 * 
 * Revision 1.1.4.8  1996/04/11  14:14:12  Hans_Graves
 * 	Fix NT warnings
 * 	[1996/04/11  14:10:21  Hans_Graves]
 * 
 * Revision 1.1.4.7  1996/04/10  21:47:43  Hans_Graves
 * 	Added params: FASTENCODE, FASTDECODE, and QUALITY
 * 	[1996/04/10  21:40:18  Hans_Graves]
 * 
 * Revision 1.1.4.6  1996/04/09  16:04:43  Hans_Graves
 * 	Handle setting negative Height
 * 	[1996/04/09  14:42:13  Hans_Graves]
 * 
 * Revision 1.1.4.5  1996/04/01  19:07:57  Hans_Graves
 * 	And some error checking
 * 	[1996/04/01  19:04:40  Hans_Graves]
 * 
 * Revision 1.1.4.4  1996/04/01  16:23:17  Hans_Graves
 * 	NT porting
 * 	[1996/04/01  16:16:03  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/03/12  16:15:54  Hans_Graves
 * 	Added SLIB_PARAM_FILEBUFSIZE param
 * 	[1996/03/12  15:54:22  Hans_Graves]
 * 
 * Revision 1.1.4.2  1996/03/08  18:46:49  Hans_Graves
 * 	Added SlibGetParamString()
 * 	[1996/03/08  18:34:51  Hans_Graves]
 * 
 * Revision 1.1.2.6  1996/02/07  23:23:59  Hans_Graves
 * 	Added SEEK_EXACT. Fixed most frame counting problems.
 * 	[1996/02/07  23:20:37  Hans_Graves]
 * 
 * Revision 1.1.2.5  1996/02/06  22:54:08  Hans_Graves
 * 	Seek fix-ups. More accurate MPEG frame counts.
 * 	[1996/02/06  22:45:21  Hans_Graves]
 * 
 * Revision 1.1.2.4  1996/02/02  17:36:05  Hans_Graves
 * 	Enhanced audio info. Cleaned up API
 * 	[1996/02/02  17:29:49  Hans_Graves]
 * 
 * Revision 1.1.2.3  1996/01/15  16:26:32  Hans_Graves
 * 	Added Audio Params
 * 	[1996/01/15  15:48:20  Hans_Graves]
 * 
 * Revision 1.1.2.2  1996/01/11  16:17:35  Hans_Graves
 * 	First time under SLIB
 * 	[1996/01/11  16:11:45  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/

#include <stdio.h>
#ifdef WIN32
#include  <time.h>
#include  <sys/timeb.h>
#else
#include  <sys/time.h>
#endif /* WIN32 */
#define SLIB_INTERNAL
#include "slib.h"
#include "SC_err.h"

#ifdef _SLIBDEBUG_
#define _DEBUG_     1  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#endif

static float _version       = 2.10F;
static char _version_date[] = { __DATE__ };

SlibTime_t slibGetSystemTime()
{
  SlibTime_t mstime;
#ifdef WIN32
  struct _timeb t ;
  _ftime(&t);
  mstime = (SlibTime_t)(t.time * 1000 + t.millitm);
#else
  struct timeval t;
  struct timezone tz;

  gettimeofday(&t, &tz);
  mstime = (SlibTime_t)(t.tv_sec * 1000 + t.tv_usec / 1000);
#endif
  return(mstime);
}

qword SlibGetFrameNumber(SlibHandle_t handle, SlibStream_t stream)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (Info && Info->FramesPerSec>0.0F)
    return(slibTimeToFrame(Info, Info->VideoTimeStamp
                                 +(Info->VideoFrameDuration/200)));
  else
    return((qword)-1);
}

SlibTime_t SlibGetVideoTime(SlibHandle_t handle, SlibStream_t stream)
{
  if (!handle)
    return(0);
  return((long)((SlibInfo_t *)handle)->VideoTimeStamp);
}

SlibTime_t SlibGetAudioTime(SlibHandle_t handle, SlibStream_t stream)
{
  if (!handle)
    return(0);
  return((long)((SlibInfo_t *)handle)->AudioTimeStamp);
}

SlibBoolean_t SlibCanSetParam(SlibHandle_t handle, SlibStream_t stream,
                              SlibParameter_t param)
{
  return(TRUE);
}

SlibBoolean_t SlibCanGetParam(SlibHandle_t handle, SlibStream_t stream,
                              SlibParameter_t param)
{
  return(TRUE);
}

SlibStatus_t SlibSetParamInt(SlibHandle_t handle, SlibStream_t stream,
                             SlibParameter_t param, long value)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibStatus_t status=SlibErrorNone;
  long actvalue=value;
  if (!handle)
    return(SlibErrorBadHandle);
  _SlibDebug(_DEBUG_, printf("SlibSetParamInt(stream=%d, param=%d, %d)\n",
                   stream, param, value) );
  switch (param)
  {
    case SLIB_PARAM_FPS:
          _SlibDebug(_DEBUG_, printf("SlibSetParamInt(SLIB_PARAM_FPS)\n") );
          status=SlibSetParamFloat(handle, stream, param, (float)value);
          break;
    case SLIB_PARAM_BITRATE:
          _SlibDebug(_DEBUG_,
              printf("SlibSetParamInt(SLIB_PARAM_BITRATE, %d)\n", value) );
          if (stream==SLIB_STREAM_MAINAUDIO)
            status=SlibSetParamInt(handle, stream, SLIB_PARAM_AUDIOBITRATE,
                                   value);
          else if (stream==SLIB_STREAM_MAINVIDEO)
            status=SlibSetParamInt(handle, stream, SLIB_PARAM_VIDEOBITRATE,
                                   value);
          else /* setting overall bitrate: try to calc best audio+video rates */
          {
            long vbitrate=value;
            /* spread total bitrate across all streams */
            if (Info->AudioStreams)
            {
              long abitrate=Info->VideoStreams ? (value*Info->Channels)/10 
                                            : value;
              /* don't set bitrates higher than necessary */
              if (Info->Channels==1 && abitrate>112*1000)
                abitrate=112*1000;
              else if (abitrate>192*1000)
                abitrate=192*1000;
              status=SlibSetParamInt(handle, stream, SLIB_PARAM_AUDIOBITRATE,
                                abitrate);
              abitrate=SlibGetParamInt(handle, stream, SLIB_PARAM_AUDIOBITRATE);
              vbitrate=value-abitrate; /* subtract bitrate allocated to audio */
            }
            if (Info->VideoStreams)
              status=SlibSetParamInt(handle, stream, SLIB_PARAM_VIDEOBITRATE,
                                  vbitrate);
            slibValidateBitrates(Info);  /* check the bitrate setting */
            if (Info->VideoStreams && Info->TotalBitRate>value)
            {
              /*
               * Since the total bitrate is over the desired bitrate
               * subtract the difference from the video bitrate
               */
              vbitrate=Info->VideoBitRate-(Info->TotalBitRate-value);
              status=SlibSetParamInt(handle, stream, SLIB_PARAM_VIDEOBITRATE,
                                     vbitrate);
            }
          }
          slibValidateBitrates(Info);
          actvalue=Info->TotalBitRate;
          _SlibDebug(_DEBUG_,
            printf("MuxBitRate=%d TotalBitRate=%d abitrate=%d vbitrate=%d\n",
               Info->MuxBitRate, Info->TotalBitRate, 
                SlibGetParamInt(handle, stream, SLIB_PARAM_AUDIOBITRATE),
                SlibGetParamInt(handle, stream, SLIB_PARAM_VIDEOBITRATE) ) );
          break;
    case SLIB_PARAM_VIDEOBITRATE:
          _SlibDebug(_DEBUG_,
            printf("SlibSetParamInt(SLIB_PARAM_VIDEOBITRATE, %d)\n", value) );
          if (Info->Svh)
          {
            SvSetParamInt(Info->Svh, SV_PARAM_BITRATE, value);
            actvalue=(long)SvGetParamInt(Info->Svh, SV_PARAM_BITRATE);
          }
          if (actvalue>0)
            Info->VideoBitRate=actvalue;
          slibValidateBitrates(Info);
          break;
    case SLIB_PARAM_VIDEOSTREAMS:
          if (Info->VideoStreams!=(int)value)
          {
            Info->VideoStreams=(int)value;
            if (Info->VideoStreams)
              slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
            else
            {
              slibPinPrepareReposition(Info, SLIB_DATA_VIDEO);
              slibRemovePin(Info, SLIB_DATA_VIDEO);
            }
          }
          break;
    case SLIB_PARAM_MOTIONALG:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_MOTIONALG, value);
          break;
    case SLIB_PARAM_ALGFLAGS:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_ALGFLAGS, value);
          break;
    case SLIB_PARAM_MOTIONSEARCH:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_MOTIONSEARCH, value);
          break;
    case SLIB_PARAM_MOTIONTHRESH:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_MOTIONTHRESH, value);
          break;
    case SLIB_PARAM_QUANTI:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_QUANTI, value);
          break;
    case SLIB_PARAM_QUANTP:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_QUANTP, value);
          break;
    case SLIB_PARAM_QUANTB:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_QUANTB, value);
          break;
    case SLIB_PARAM_KEYSPACING:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_KEYSPACING, value);
          break;
    case SLIB_PARAM_SUBKEYSPACING:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_SUBKEYSPACING, value);
          break;
    case SLIB_PARAM_FRAMETYPE:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_FRAMETYPE, value);
          break;
    case SLIB_PARAM_VIDEOPROGRAM:
          Info->VideoPID=(int)value;
          break;
    case SLIB_PARAM_AUDIOPROGRAM:
          Info->AudioPID=(int)value;
          break;
    case SLIB_PARAM_VIDEOMAINSTREAM:
          Info->VideoMainStream=(int)value;
          break;
    case SLIB_PARAM_AUDIOMAINSTREAM:
          Info->AudioMainStream=(int)value;
          break;
    case SLIB_PARAM_WIDTH:
          _SlibDebug(_DEBUG_,
                printf("SlibSetParamInt(SLIB_PARAM_WIDTH)\n") );
          Info->Width=(short)value;
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CompVideoFormat)
            Info->CompVideoFormat->biWidth=Info->Width;
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CodecVideoFormat)
            Info->CodecVideoFormat->biWidth=Info->Width;
          if (Info->VideoFormat)
            Info->VideoFormat->biWidth=Info->Width;
          return(slibValidateVideoParams(Info));
    case SLIB_PARAM_STRIDE:
          _SlibDebug(_DEBUG_,
                printf("SlibSetParamInt(SLIB_PARAM_STRIDE)\n") );
          Info->Stride=(long)value;
          if (Info->Sch && Info->Mode==SLIB_MODE_DECOMPRESS)
            SconSetParamInt(Info->Sch, SCON_OUTPUT, SCON_PARAM_STRIDE, Info->Stride);
          break;
    case SLIB_PARAM_HEIGHT:
          _SlibDebug(_DEBUG_,
                printf("SlibSetParamInt(SLIB_PARAM_HEIGHT)\n") );
          Info->Height=(short)value<0 ? (short)-value : (short)value;
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CompVideoFormat)
            Info->CompVideoFormat->biHeight=Info->Height;
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CodecVideoFormat)
            Info->CodecVideoFormat->biHeight=Info->Height;
          if (Info->VideoFormat)
            Info->VideoFormat->biHeight=(short)value;
          return(slibValidateVideoParams(Info));
    case SLIB_PARAM_VIDEOFORMAT:
          _SlibDebug(_DEBUG_,
             printf("SlibSetParamInt(SLIB_PARAM_VIDEOFORMAT, '%c%c%c%c')\n",
              value&0xFF, (value>>8)&0xFF, (value>>16)&0xFF,(value>>24)&0xFF) );
          if (Info->VideoFormat)
            Info->VideoFormat->biCompression=(dword)value;
#if 0
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CodecVideoFormat)
            Info->CodecVideoFormat->biCompression=(dword)value;
#endif
          return(slibValidateVideoParams(Info));
    case SLIB_PARAM_VIDEOBITS:
          _SlibDebug(_DEBUG_,
                printf("SlibSetParamInt(SLIB_PARAM_VIDEOBITS, %d)\n", value) );
          if (Info->VideoFormat)
            Info->VideoFormat->biBitCount=(word)value;
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CodecVideoFormat)
            Info->CodecVideoFormat->biBitCount=(dword)value;
          return(slibValidateVideoParams(Info));
    case SLIB_PARAM_AUDIOSTREAMS:
          if (Info->AudioStreams!=(int)value)
          {
            Info->AudioStreams=(int)value;
            if (Info->AudioStreams)
              slibAddPin(Info, SLIB_DATA_AUDIO, "Audio");
            else
            {
              slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
              slibRemovePin(Info, SLIB_DATA_AUDIO);
            }
          }
          break;
    case SLIB_PARAM_AUDIOBITRATE:
          _SlibDebug(_DEBUG_,
            printf("SlibSetParamInt(SLIB_PARAM_AUDIOBITRATE, %d)\n", value) );
          if (Info->Sah)
          {
            SaSetParamInt(Info->Sah, SA_PARAM_BITRATE, value);
            actvalue=(long)SaGetParamInt(Info->Sah, SA_PARAM_BITRATE);
          }
          if (actvalue>0)
            Info->AudioBitRate=actvalue;
          slibValidateBitrates(Info);
          break;
    case SLIB_PARAM_AUDIOCHANNELS:
          if (Info->Mode==SLIB_MODE_COMPRESS ||
              Info->AudioType==SLIB_TYPE_AC3_AUDIO)
          {
            Info->Channels=value;
            if (Info->AudioFormat)
              Info->AudioFormat->nChannels=(word)value;
            SaSetParamInt(Info->Sah, SA_PARAM_CHANNELS, value);
          }
          actvalue=Info->Channels;
          break;
    case SLIB_PARAM_SAMPLESPERSEC:
          {
            unsigned dword nativesps;
            Info->SamplesPerSec=value;
            nativesps=value;
#ifdef MPEG_SUPPORT
            if (SlibTypeIsMPEG(Info->Type))
            {
              /* choose a MPEG supported native sample rate */
              if (value%11025 == 0) /* multiples of 11025 can be converted */
                nativesps=44100;
              else if (value==48000)
                nativesps=48000;
              else if (value%8000 == 0) /* multiples of 8000 can be converted */
                nativesps=32000;
            }
#endif /* MPEG_SUPPORT */
            if (Info->AudioFormat)
              Info->AudioFormat->nSamplesPerSec=nativesps;
          }
          break;
    case SLIB_PARAM_NATIVESAMPLESPERSEC:
          if (Info->AudioFormat)
            Info->AudioFormat->nSamplesPerSec=(dword)value;
          break;
    case SLIB_PARAM_BITSPERSAMPLE:
          Info->BitsPerSample=value;
          if (Info->AudioFormat && value==16)
            Info->AudioFormat->wBitsPerSample=(word)value;
          break;
    case SLIB_PARAM_NATIVEBITSPERSAMPLE:
          if (Info->AudioFormat)
            Info->AudioFormat->wBitsPerSample=(word)value;
          break;
    case SLIB_PARAM_VIDEOQUALITY:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_QUALITY, (ScBoolean_t)value);
          break;
    case SLIB_PARAM_AUDIOQUALITY:
          if (Info->Sah)
            SaSetParamInt(Info->Sah, SA_PARAM_QUALITY, (ScBoolean_t)value);
          break;
    case SLIB_PARAM_FILESIZE:
          Info->FileSize=(unsigned long)value;
          break;
    case SLIB_PARAM_FILEBUFSIZE:
          Info->FileBufSize=(unsigned dword)value;
          break;
    case SLIB_PARAM_COMPBUFSIZE:
          if (value<=0)
            Info->CompBufSize=(unsigned dword)2*1024; /* default */
          else
            Info->CompBufSize=(unsigned dword)value;
          break;
    case SLIB_PARAM_PACKETSIZE:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_PACKETSIZE, value);
          break;
    case SLIB_PARAM_FORMATEXT:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_FORMATEXT, value);
          break;
    case SLIB_PARAM_OVERFLOWSIZE:
          Info->OverflowSize=(unsigned long)value;
          break;
    case SLIB_PARAM_DEBUG:
          Info->dbg=(void *)value;
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_DEBUG, value);
          if (Info->Sah)
            SaSetParamInt(Info->Sah, SA_PARAM_DEBUG, value);
          break;
    default:
          return(SlibErrorUnsupportedParam);
  }
  if (actvalue!=value)
  {
    _SlibDebug(_DEBUG_ || _WARN_, 
         printf("SlibSetParamFloat() SettingNotEqual: %ld(req) != %ld(act)\n",
                     value, actvalue) );
    return(SlibErrorSettingNotEqual);
  }
  return(status);
}

SlibStatus_t SlibSetParamLong(SlibHandle_t handle, SlibStream_t stream,
                             SlibParameter_t param, qword value)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibStatus_t status=SlibErrorNone;
  qword actvalue=value;
  if (!handle)
    return(SlibErrorBadHandle);
  _SlibDebug(_DEBUG_, printf("SlibSetParamLong(stream=%d, param=%d, %ld)\n",
                   stream, param, value) );
  /* this needs to be implemented */
  return(SlibSetParamInt(handle, stream, param, (long)value));
}

SlibStatus_t SlibSetParamFloat(SlibHandle_t handle, SlibStream_t stream,
                               SlibParameter_t param, float value)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibStatus_t status=SlibErrorNone;
  float actvalue=value;
  if (!handle)
    return(SlibErrorBadHandle);
  _SlibDebug(_DEBUG_, printf("SlibSetParamFloat()\n") );
  switch (param)
  {
    case SLIB_PARAM_FPS:
          _SlibDebug(_DEBUG_,
                printf("SlibSetParamFloat(SLIB_PARAM_FPS)\n") );
          if (Info->Svh)
          {
            SvSetParamFloat(Info->Svh, SV_PARAM_FPS, value);
            actvalue=SvGetParamFloat(Info->Svh, SV_PARAM_FPS);
          }
          if (actvalue>0.0F)
            Info->FramesPerSec=actvalue;
          break;
    default:
          return(SlibSetParamInt(handle, stream, param, (long)value));
  }
  if (actvalue>value+(float)0.0000001 ||
      actvalue<value-(float)0.0000001)
  {
    _SlibDebug(_DEBUG_ || _WARN_, 
        printf("SlibSetParamFloat() SettingNotEqual: %.3f(req) != %.3f(act)\n",
                     value, actvalue) );
    return(SlibErrorSettingNotEqual);
  }
  return(status);
}

SlibStatus_t SlibSetParamBoolean(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param, SlibBoolean_t value)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (!handle)
    return(SlibErrorBadHandle);
  _SlibDebug(_DEBUG_, printf("SlibSetParamFloat()\n") );
  switch (param)
  {
    case SLIB_PARAM_STATS:
          if (value)
          {
            if (Info->stats==NULL)
            {
              Info->stats = (SlibStats_t *)ScAlloc(sizeof(SlibStats_t));
              if (Info->stats==NULL)
                return(SlibErrorMemory);
              SlibSetParamBoolean(handle, stream, SLIB_PARAM_STATS_RESET, TRUE);
            }
            else
              Info->stats->StartTime=slibGetSystemTime();
            Info->stats->Record=TRUE;
          }
          else if (Info->stats)
          {
            Info->stats->Record=FALSE;
            Info->stats->StopTime=slibGetSystemTime();
          }
          break;
    case SLIB_PARAM_STATS_RESET:
          if (Info->stats)
          {
            Info->stats->StartTime=Info->stats->StopTime=
                slibGetSystemTime();
            Info->stats->FramesProcessed=0;
            Info->stats->FramesSkipped=0;
          }
          break;
    case SLIB_PARAM_NEEDACCURACY:
          Info->NeedAccuracy = value ? TRUE : FALSE;
          if (Info->NeedAccuracy && slibHasTimeCode(Info))
          {
            /*
             * We'll seek toward the end of the file so the frame count
             * can be more accurately measured
             */
            if (!Info->VideoLengthKnown && Info->FileSize>0)
            {
              int minpercent=0, maxpercent=9900, lastpercent=0, trypercent=9900;
              int tries=0;
              unsigned qword newfilesize=Info->FileSize;
              qword stime = Info->VideoTimeStamp;
              SlibStatus_t status;
              if (SlibTimeIsInValid(stime)) stime=0;
              while (!Info->VideoLengthKnown && maxpercent-minpercent>200 && tries<5)
              {
                status=SlibSeekEx(handle, SLIB_STREAM_ALL, SLIB_SEEK_KEY, 
                                  trypercent, SLIB_UNIT_PERCENT100, NULL);
                if (status==SlibErrorEndOfStream)
                  break;
                else if (status==SlibErrorNoBeginning)
                {
                  /* adjust the file size, data at end must be invalid */
                  newfilesize=(Info->FileSize*(trypercent/100))/100;
                  lastpercent=trypercent;
                  maxpercent=trypercent;
                  trypercent=(minpercent+maxpercent)/2; /* try half way between min and max */
                }
                else if (status==SlibErrorNone)
                {
                  if (maxpercent-trypercent<=300)
                    break;
                  else
                  {
                    lastpercent=trypercent;
                    minpercent=trypercent;
                    trypercent=(minpercent+maxpercent)/2; /* try half way between min and max */
                  }
                }
                else
                {
                  lastpercent=trypercent;
                  trypercent=((trypercent-minpercent)*3)/4;
                }
                tries++;
              }
              Info->FileSize=newfilesize;
              while (status==SlibErrorNone && !Info->VideoLengthKnown)
                status=SlibSeek(handle, SLIB_STREAM_ALL, SLIB_SEEK_NEXT_KEY, 0);
              SlibSeekEx(handle, SLIB_STREAM_ALL, SLIB_SEEK_KEY, stime,
                                                  SLIB_UNIT_MS, NULL);
            }
          }
          break;
    case SLIB_PARAM_FASTENCODE:
          if (Info->Svh)
            SvSetParamBoolean(Info->Svh, SV_PARAM_FASTENCODE, 
                                         (ScBoolean_t)value);
          if (Info->Sah)
            SvSetParamBoolean(Info->Sah, SV_PARAM_FASTENCODE, 
                                         (ScBoolean_t)value);
          break;
    case SLIB_PARAM_FASTDECODE:
          if (Info->Svh)
            SvSetParamBoolean(Info->Svh, SV_PARAM_FASTDECODE, 
                                         (ScBoolean_t)value);
          if (Info->Sah)
            SvSetParamBoolean(Info->Sah, SV_PARAM_FASTDECODE, 
                                         (ScBoolean_t)value);
          break;
    case SLIB_PARAM_MOTIONALG:
          SlibSetParamInt(handle, stream, param, value?1:0);
          break;
    default:
         return(SlibErrorUnsupportedParam);
  }
  return(SlibErrorNone);
}

SlibStatus_t SlibSetParamStruct(SlibHandle_t handle, SlibStream_t stream,
                             SlibParameter_t param,
                             void *data, unsigned dword datasize)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibStatus_t status=SlibErrorNone;
  if (!handle)
    return(SlibErrorBadHandle);
  if (data==NULL || datasize==0)
    return(SlibErrorBadArgument);
  _SlibDebug(_DEBUG_, printf("SlibSetParamStruct(stream=%d, param=%d, data=%p datasize=%ld)\n",
                   stream, param, data, datasize) );
  switch (param)
  {
    case SLIB_PARAM_VIDEOFORMAT:
         {
           BITMAPINFOHEADER *bmh=(BITMAPINFOHEADER *)data;
           _SlibDebug(_DEBUG_,
             printf("SlibSetParamStruct(SLIB_PARAM_VIDEOFORMAT)\n") );
           if (Info->VideoFormat==NULL || Info->VideoFormat->biSize<datasize)
           {
             ScFree(Info->VideoFormat);
             Info->VideoFormat=NULL;
           }
           if (Info->VideoFormat==NULL)
             Info->VideoFormat=(BITMAPINFOHEADER *)ScAlloc(datasize);
           Info->Width=(word)bmh->biWidth;
           Info->Height=abs(bmh->biHeight);
           if (Info->VideoFormat)
           {
             memcpy(Info->VideoFormat, bmh, datasize);
             return(slibValidateVideoParams(Info));
           }
           else
             return(SlibErrorMemory);
         }
    default:
         return(SlibErrorUnsupportedParam);
  }
  /* this needs to be implemented */
  return(SlibErrorNone);
}

long SlibGetParamInt(SlibHandle_t handle, SlibStream_t stream,
                                          SlibParameter_t param)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (!handle)
    return(0);
  switch (param)
  {
    case SLIB_PARAM_TYPE:
          if (stream==SLIB_STREAM_MAINAUDIO)
            return((long)Info->AudioType);
          else if (stream==SLIB_STREAM_MAINVIDEO)
            return((long)Info->VideoType);
          else
            return((long)Info->Type);
          break;
    case SLIB_PARAM_FPS:
          return((long)Info->FramesPerSec);
          break;
    case SLIB_PARAM_BITRATE:
          return((long)Info->TotalBitRate);
    case SLIB_PARAM_VIDEOBITRATE:
          return((long)Info->VideoBitRate);
    case SLIB_PARAM_WIDTH:
          return((long)Info->Width);
    case SLIB_PARAM_HEIGHT:
          return((long)Info->Height);
    case SLIB_PARAM_STRIDE:
          return((long)Info->Stride);
    case SLIB_PARAM_NATIVEWIDTH:
          if (Info->CompVideoFormat)
            return((long)Info->CompVideoFormat->biWidth);
          else
            return((long)Info->Width);
    case SLIB_PARAM_NATIVEHEIGHT:
          if (Info->CompVideoFormat)
            return((long)Info->CompVideoFormat->biHeight);
          else
            return((long)Info->Height);
    case SLIB_PARAM_NATIVEVIDEOFORMAT:
          {
            long format=(long)SvGetParamInt(Info->Svh, SV_PARAM_NATIVEFORMAT);
            if (format==0)
              format=Info->CodecVideoFormat
                             ? Info->CodecVideoFormat->biCompression
                             : Info->VideoFormat->biCompression;
            return(format);
          }
    case SLIB_PARAM_IMAGESIZE:
          return((long)Info->ImageSize);
    case SLIB_PARAM_MININPUTSIZE:
          {
            long size=0;
            if (Info->Mode==SLIB_MODE_COMPRESS)
            {
              if (slibHasVideo(Info))
                size+=Info->ImageSize;
              if (slibHasAudio(Info))
                switch (Info->AudioType)
                {
                  case SLIB_TYPE_G723:
                       size+=480;
                       break;
                  default:
                       if (Info->AudioFormat)
                         size+=Info->AudioFormat->nBlockAlign;
                }
            }
            else if (Info->Mode==SLIB_MODE_DECOMPRESS)
            {
              if (slibHasVideo(Info))
                switch (Info->AudioType)
                {
                  case SLIB_TYPE_H263:
                       size+=Info->VideoBitRate>0?(Info->VideoBitRate/8):(64*1024);
                       break;
                  default:
                       size+=Info->VideoBitRate>0?(Info->VideoBitRate/8):(64*1024);
                }
              if (slibHasAudio(Info))
                switch (Info->AudioType)
                {
                  case SLIB_TYPE_G723:
                       size+=(Info->AudioBitRate>=6000)?24:20;
                       break;
                  default:
                       if (Info->AudioFormat)
                         size+=Info->AudioFormat->nBlockAlign;
                }
            }
            return(size);
          }
          break;
    case SLIB_PARAM_INPUTSIZE:
          {
            long size=0;
            size+=SlibGetParamInt(handle, stream, SLIB_PARAM_MININPUTSIZE);
            if (size<=8) size=8*1024;
            if (Info->Mode==SLIB_MODE_DECOMPRESS)
            {
              if (slibHasVideo(Info))
                switch (Info->Type) /* add in bytes for header */
                {
                  case SLIB_TYPE_AVI:      size+=64; break;
                }
              if (slibHasAudio(Info))
              {
                if (!Info->HeaderProcessed) /* add in header */
                  switch (Info->Type)
                  {
                    case SLIB_TYPE_PCM_WAVE: size+=40; break;
                  }
              }
            }
            return(size);
          }
          break;
    case SLIB_PARAM_VIDEOFRAME:
          if (Info->FramesPerSec)
            return((long)slibTimeToFrame(Info, Info->VideoTimeStamp
                                               +(Info->VideoFrameDuration/200)));
          break;
    case SLIB_PARAM_FRAMEDURATION:
          if (Info->FramesPerSec)
            return((long)(10000000L/Info->FramesPerSec));
          else
            return((long)0);
    case SLIB_PARAM_VIDEOFORMAT:
          if (Info->VideoFormat)
            return((long)Info->VideoFormat->biCompression);
          else
            return(0L);
          break;
    case SLIB_PARAM_VIDEOBITS:
          if (Info->VideoFormat)
            return((long)Info->VideoFormat->biBitCount);
          else
            return(0L);
    case SLIB_PARAM_VIDEOPROGRAM:
          return((long)Info->VideoPID);
    case SLIB_PARAM_AUDIOPROGRAM:
          return((long)Info->AudioPID);
    case SLIB_PARAM_VIDEOMAINSTREAM:
          return((long)Info->VideoMainStream);
    case SLIB_PARAM_AUDIOMAINSTREAM:
          return((long)Info->AudioMainStream);
    case SLIB_PARAM_KEYSPACING:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_KEYSPACING));
          else
            return((long)Info->KeySpacing);
    case SLIB_PARAM_SUBKEYSPACING:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_SUBKEYSPACING));
          else
            return((long)Info->SubKeySpacing);
    case SLIB_PARAM_AUDIOFORMAT:
          if (Info->AudioFormat)
            return((long)Info->AudioFormat->wFormatTag);
          else
            return(0);
          break;
    case SLIB_PARAM_AUDIOBITRATE:
          if (Info->AudioBitRate==0 && Info->Sah)
            Info->AudioBitRate=(dword)SaGetParamInt(Info->Sah, SA_PARAM_BITRATE);
          return((long)Info->AudioBitRate);
    case SLIB_PARAM_VIDEOSTREAMS:
          return((long)Info->VideoStreams);
    case SLIB_PARAM_AUDIOSTREAMS:
          return((long)Info->AudioStreams);
    case SLIB_PARAM_AUDIOCHANNELS:
          return((long)Info->Channels);
    case SLIB_PARAM_SAMPLESPERSEC:
          return((long)Info->SamplesPerSec);
    case SLIB_PARAM_NATIVESAMPLESPERSEC:
          if (Info->AudioFormat)
            return((long)Info->AudioFormat->nSamplesPerSec);
          break;
    case SLIB_PARAM_BITSPERSAMPLE:
          return((long)Info->BitsPerSample);
    case SLIB_PARAM_NATIVEBITSPERSAMPLE:
          if (Info->AudioFormat)
            return((long)Info->AudioFormat->wBitsPerSample);
          break;
    case SLIB_PARAM_FILESIZE:
          return((long)Info->FileSize);
    case SLIB_PARAM_FILEBUFSIZE:
          return((long)Info->FileBufSize);
    case SLIB_PARAM_COMPBUFSIZE:
          return((long)Info->CompBufSize);
    case SLIB_PARAM_OVERFLOWSIZE:
          return((long)Info->OverflowSize);
    case SLIB_PARAM_VIDEOQUALITY:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_QUALITY));
          break;
    case SLIB_PARAM_AUDIOQUALITY:
          if (Info->Sah)
            return((long)SaGetParamInt(Info->Sah, SA_PARAM_QUALITY));
          break;
    case SLIB_PARAM_VBVBUFFERSIZE:
          {
            dword vbv;
            if (Info->Svh)
              vbv=(dword)SvGetParamInt(Info->Svh, SV_PARAM_VBVBUFFERSIZE);
            if (vbv<=0)
              vbv=Info->VBVbufSize;
            return(vbv);
          }
    case SLIB_PARAM_VBVDELAY:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_VBVDELAY));
          break;
    case SLIB_PARAM_MOTIONALG:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_MOTIONALG));
          break;
    case SLIB_PARAM_ALGFLAGS:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_ALGFLAGS));
          break;
    case SLIB_PARAM_MOTIONSEARCH:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_MOTIONSEARCH));
          break;
    case SLIB_PARAM_MOTIONTHRESH:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_MOTIONTHRESH));
          break;
    case SLIB_PARAM_PACKETSIZE:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_PACKETSIZE));
          break;
    case SLIB_PARAM_FORMATEXT:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_FORMATEXT));
          break;
    case SLIB_PARAM_QUANTI:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_QUANTI));
          break;
    case SLIB_PARAM_QUANTP:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_QUANTP));
          break;
    case SLIB_PARAM_QUANTB:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_QUANTB));
          break;
    case SLIB_PARAM_FRAMETYPE:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE));
          break;
    case SLIB_PARAM_STATS_FPS:
          return((long)SlibGetParamFloat(handle, stream, SLIB_PARAM_STATS_FPS));
    default:
          return((long)SlibGetParamLong(handle, stream, param));
  }
  return(0);
}

qword SlibGetParamLong(SlibHandle_t handle, SlibStream_t stream,
                                          SlibParameter_t param)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (!handle)
    return((qword)0);
  switch (param)
  {
    case SLIB_PARAM_VIDEOFRAMES:
          if (Info->FramesPerSec)
            return(slibTimeToFrame(Info, Info->VideoLength
                                         +(Info->VideoFrameDuration/200)));
          break;
    case SLIB_PARAM_VIDEOLENGTH:
          return(Info->VideoLength);
    case SLIB_PARAM_AUDIOLENGTH:
          return((long)Info->AudioLength);
    case SLIB_PARAM_STATS_TIME:
          if (Info->stats)
          {
            if (Info->stats->Record) /* still recording */
              Info->stats->StopTime=slibGetSystemTime();
            return((long)(Info->stats->StopTime-Info->stats->StartTime));
          }
          break;
    case SLIB_PARAM_STATS_FRAMESPROCESSED:
          if (Info->stats)
            return(Info->stats->FramesProcessed);
          break;
    case SLIB_PARAM_STATS_FRAMESSKIPPED:
          if (Info->stats)
            return(Info->stats->FramesSkipped);
          break;
    case SLIB_PARAM_STATS_FRAMES:
          if (Info->stats)
            return(Info->stats->FramesSkipped+
                   Info->stats->FramesProcessed);
          break;
    case SLIB_PARAM_TIMECODE:
          if (Info->Svh)
            return(SvGetParamInt(Info->Svh, SV_PARAM_TIMECODE));
          break;
    case SLIB_PARAM_CALCTIMECODE:
          if (Info->Svh)
            return(SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE));
          break;
    case SLIB_PARAM_PTIMECODE:
          if (stream==SLIB_STREAM_MAINAUDIO)
            return(Info->AudioPTimeCode);
          else if (Info->VideoPTimeCode==SLIB_TIME_NONE && Info->Svh &&
                   SvGetParamInt(Info->Svh, SV_PARAM_TIMECODE)>0)
            return(SvGetParamInt(Info->Svh, SV_PARAM_TIMECODE));
          else
            return(Info->VideoPTimeCode);
    case SLIB_PARAM_DTIMECODE:
          if (stream==SLIB_STREAM_MAINAUDIO)
            return(Info->AudioDTimeCode);
          else if (Info->VideoDTimeCode==SLIB_TIME_NONE && Info->Svh &&
                   SvGetParamInt(Info->Svh, SV_PARAM_TIMECODE)>0)
            return(SvGetParamInt(Info->Svh, SV_PARAM_TIMECODE));
          else
            return(Info->VideoDTimeCode);
    case SLIB_PARAM_PERCENT100:
          if (Info->FileSize>0)
          {
            ScBitstream_t *bs;
            SlibPosition_t pos=slibGetPinPosition(Info, SLIB_DATA_COMPRESSED);
            /* subtract all the unused data from the input position */
            pos-=slibDataOnPin(Info, SLIB_DATA_VIDEO);
            pos-=slibDataOnPin(Info, SLIB_DATA_AUDIO);
            if ((bs=SvGetDataSource(Info->Svh))!=NULL)
              pos-=ScBSBufferedBytesUnused(bs); /* Video Codec unused bytes */
            if ((bs=SaGetDataSource(Info->Sah))!=NULL)
              pos-=ScBSBufferedBytesUnused(bs); /* Audio Codec unused bytes */
            if (pos>=(SlibPosition_t)Info->FileSize)
              return(10000);
            else if (pos>=0)
              return((pos*10000)/Info->FileSize);
            else
              return(0);
          }
          else
          {
            if (stream==SLIB_STREAM_MAINAUDIO &&
                   SlibTimeIsValid(Info->AudioTimeStamp) &&
                   Info->AudioLength>0)
              return((Info->AudioTimeStamp*10000)/Info->AudioLength);
            else if (SlibTimeIsValid(Info->VideoTimeStamp)
                      && Info->VideoLength>0)
              return((Info->VideoTimeStamp*10000)/Info->VideoLength);
          }
          return((qword)-1);
  }
  return((qword)0);
}

float SlibGetParamFloat(SlibHandle_t handle, SlibStream_t stream,
                        SlibParameter_t param)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  switch (param)
  {
    case SLIB_PARAM_VERSION:
          return(_version);
  }
  if (!handle)
    return((float)0.0);
  switch (param)
  {
    case SLIB_PARAM_FPS:
          return((float)Info->FramesPerSec);
    case SLIB_PARAM_VIDEOASPECTRATIO:
          if (Info->Svh)
            return(SvGetParamFloat(Info->Svh, SV_PARAM_ASPECTRATIO));
          break;
    case SLIB_PARAM_STATS_FPS:
          if (Info->stats)
          {
            float fps=0.0F;
            if (Info->stats->Record) /* still recording */
              Info->stats->StopTime=slibGetSystemTime();
            if (Info->stats->StartTime<Info->stats->StopTime)
            {
              qword ellapsedtime=Info->stats->StopTime-Info->stats->StartTime;
              fps=(float)(Info->stats->FramesProcessed*1000)/ellapsedtime;
            }
            return(fps);
          }
          else
            return(0.0F);
  }
  return((float)SlibGetParamInt(handle, stream, param));
}

SlibBoolean_t SlibGetParamBoolean(SlibHandle_t handle, SlibStream_t stream,
                                  SlibParameter_t param)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (!handle)
    return(SlibErrorBadHandle);
  switch (param)
  {
    case SLIB_PARAM_STATS:
          return(Info->stats ? Info->stats->Record : FALSE);
    case SLIB_PARAM_NEEDACCURACY:
          return((SlibBoolean_t)Info->NeedAccuracy);
    case SLIB_PARAM_FASTENCODE:
          if (Info->Svh)
            return((SlibBoolean_t)SvGetParamBoolean(Info->Svh, 
                                     SV_PARAM_FASTENCODE));
          break;
    case SLIB_PARAM_FASTDECODE:
          if (Info->Svh)
            return((SlibBoolean_t)SvGetParamBoolean(Info->Svh, 
                                     SV_PARAM_FASTDECODE));
          break;
  }
  return(FALSE);
}

char *SlibGetParamString(SlibHandle_t handle, SlibStream_t stream,
                                              SlibParameter_t param)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  static char result[100];
  strcpy(result, "Unknown");
  switch (param)
  {
    case SLIB_PARAM_VERSION_DATE:
          return(_version_date);
          break;
  }
  if (!handle)
    return(result);
  switch (param)
  {
    case SLIB_PARAM_NATIVEVIDEOFORMAT:
          if (Info->CodecVideoFormat)
            switch(Info->CodecVideoFormat->biCompression)
            {
              case BI_YUY2:
              case BI_DECYUVDIB:        strcpy(result, "YUV 4:2:2 Interleaved");
                                        break;
              case BI_BITFIELDS:        strcpy(result, "BITFIELDS");
                                        break;
              case BI_DECXIMAGEDIB:     sprintf(result, "XIMAGE %d",
                                           Info->VideoFormat->biBitCount);
                                        break;
              case BI_YU12SEP:          strcpy(result, "YUV 4:1:1 Separated");
                                        break;
              case BI_YU16SEP:          strcpy(result, "YUV 4:2:2 Separated");
                                        break;
              case BI_RGB:              sprintf(result, "RGB %d",
                                           Info->VideoFormat->biBitCount);
                                        break;
            }
          break;
    case SLIB_PARAM_VIDEOFORMAT:
          if (Info->VideoFormat)
            switch(Info->VideoFormat->biCompression)
            {
              case BI_YUY2:
              case BI_DECYUVDIB:        strcpy(result, "YUV 4:2:2 Interleaved");
                                        break;
              case BI_BITFIELDS:        strcpy(result, "BITFIELDS");
                                        break;
              case BI_DECXIMAGEDIB:     sprintf(result, "XIMAGE %d",
                                           Info->VideoFormat->biBitCount);
                                        break;
              case BI_YU12SEP:          strcpy(result, "YUV 4:1:1 Separated");
                                        break;
              case BI_YU16SEP:          strcpy(result, "YUV 4:2:2 Separated");
                                        break;
              case BI_RGB:              sprintf(result, "RGB %d",
                                           Info->VideoFormat->biBitCount);
                                        break;
            }
          break;
    case SLIB_PARAM_AUDIOFORMAT:
          if (Info->AudioFormat)
            switch (Info->AudioFormat->wFormatTag)
            {
              case WAVE_FORMAT_PCM:    strcpy(result, "PCM");
                                       break;
            }
          break;
    case SLIB_PARAM_TYPE:
          if (stream==SLIB_STREAM_MAINAUDIO)
            return(SlibQueryForDesc(SLIB_QUERY_TYPES, Info->AudioType));
          else if (stream==SLIB_STREAM_MAINVIDEO)
            return(SlibQueryForDesc(SLIB_QUERY_TYPES, Info->VideoType));
          else
            return(SlibQueryForDesc(SLIB_QUERY_TYPES, Info->Type));
          break;
  }
  return(result);
}

/*
** Name:    SlibValidateParams
** Purpose: Ensure that the the Video and Audio parameter settings are
**          valid and supported.
*/
SlibStatus_t SlibValidateParams(SlibHandle_t handle)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (Info->VideoStreams>0 && slibValidateVideoParams(Info)!=SlibErrorNone)
    return(slibValidateVideoParams(Info));
  if (Info->AudioStreams>0 && slibValidateAudioParams(Info)!=SlibErrorNone)
    return(slibValidateAudioParams(Info));
  if (Info->Svh)
  {
    SvStatus_t status;
    _SlibDebug(_DEBUG_, printf("SvQuery(%c%c%c%c,%d bits,%dx%d,%c%c%c%c,%d bits,%dx%d)\n",
                     (Info->CodecVideoFormat->biCompression)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>8)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>16)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>24)&0xFF,
                      Info->CodecVideoFormat->biBitCount,
                      Info->CodecVideoFormat->biWidth,
                      Info->CodecVideoFormat->biHeight,
                     (Info->CompVideoFormat->biCompression)&0xFF,
                     (Info->CompVideoFormat->biCompression>>8)&0xFF,
                     (Info->CompVideoFormat->biCompression>>16)&0xFF,
                     (Info->CompVideoFormat->biCompression>>24)&0xFF,
                      Info->CompVideoFormat->biBitCount,
                      Info->CompVideoFormat->biWidth,
                      Info->CompVideoFormat->biHeight) );
    if (Info->Mode==SLIB_MODE_COMPRESS)
      status=SvCompressQuery(Info->Svh, Info->CodecVideoFormat,
                                        Info->CompVideoFormat);
    else
      status=SvDecompressQuery(Info->Svh, Info->CompVideoFormat,
                                          Info->CodecVideoFormat);
    if (status!=NoErrors)
    {
      _SlibDebug(_WARN_, printf("SlibValidateParams() SvQuery failed\n");
                       ScGetErrorText(status,0,0) );
      return(SlibErrorUnsupportedFormat);
    }
  }
  if (Info->Sah)
  {
    SaStatus_t status;
    if (Info->Mode==SLIB_MODE_COMPRESS)
      status=SaCompressQuery(Info->Sah, Info->AudioFormat,
                                        Info->CompAudioFormat);
    else
      status=SaDecompressQuery(Info->Sah, Info->CompAudioFormat,
                                          Info->AudioFormat);
    if (status!=NoErrors)
    {
      _SlibDebug(_WARN_, printf("SlibValidateParams() SaBegin failed\n");
                       ScGetErrorText(status,0,0) );
      return(SlibErrorUnsupportedFormat);
    }
  }
  return(SlibErrorNone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\pred.c ===
/* File: sv_h263_pred.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
#define _SLIBDEBUG_
*/

#include "sv_h263.h"
#include "proto.h"
#ifndef USE_C
#include "perr.h"
#endif

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  0  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif

static int roundtab[] = {0,0,0,1,1,1,1,1,1,1,1,1,1,1,2,2};


static void FindForwLumPredPB(SvH263CompressInfo_t *H263Info,
                              unsigned char *prev_ipol, int x_curr, int y_curr,
                              H263_MotionVector *fr, short *pred, int TRD, int TRB,
                              int bdx, int bdy, int bs, int comp);
void FindBiDirLumPredPB(short *recon_P, H263_MotionVector *fr, short *pred, int TRD,
			   int TRB, int bdx, int bdy, int nh, int nv);

void BiDirLumPredPB(H263_MB_Structure *recon_P, H263_MotionVector *fr,
					H263_MB_Structure *pred, int TRD, int TRB, int bdx, int bdy);

void FindBiDirChrPredPB(H263_MB_Structure *recon_P, int dx, int dy,
			   H263_MB_Structure *pred);
void FindBiDirLimits(int vec, int *start, int *stop, int nhv);
void FindBiDirChromaLimits(int vec, int *start, int *stop);
void BiDirPredBlock(int xstart, int xstop, int ystart, int ystop,
		       int xvec, int yvec, short *recon, short *pred, int bl);
static void DoPredChrom_P(SvH263CompressInfo_t *H263Info,
                          int x_curr, int y_curr, int dx, int dy,
                          H263_PictImage *curr, H263_PictImage *prev,
                          H263_MB_Structure *pred_error);
static void FindPred(SvH263CompressInfo_t *H263Info,
                     int x, int y, H263_MotionVector *fr, unsigned char *prev,
                     short *pred, int bs, int comp);
static void FindPredOBMC(SvH263CompressInfo_t *H263Info,
                  int x, int y, H263_MotionVector *MV[5][H263_MBR+1][H263_MBC+2],
                  unsigned char *prev, short *pred, int comp, int PB);
static void ReconLumBlock_P(SvH263CompressInfo_t *H263Info,
                            int x, int y, H263_MotionVector *fr,
                            unsigned char *prev, short *data, int bs, int comp);
static void ReconChromBlock_P(SvH263CompressInfo_t *H263Info,
                              int x_curr, int y_curr, int dx, int dy,
                              H263_PictImage *prev, H263_MB_Structure *data);
static void FindChromBlock_P(SvH263CompressInfo_t *H263Info,
                             int x_curr, int y_curr, int dx, int dy,
                             H263_PictImage *prev, H263_MB_Structure *data);

/**********************************************************************
 *
 *	Name:		Predict_P
 *	Description:    Predicts P macroblock in advanced or normal
 *                      mode
 *	
 *	Input:		pointers to current and previous frames
 *			and previous interpolated image,
 *                      position and motion vector array
 *	Returns:	pointer to MB_Structure of data to be coded
 *	Side effects:	allocates memory to MB_Structure
 *
 ***********************************************************************/
void sv_H263PredictP(SvH263CompressInfo_t *H263Info,
                     H263_PictImage *curr_image, H263_PictImage *prev_image,
                     unsigned char *prev_ipol, int x, int y,
                     H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int PB,
                     H263_MB_Structure *pred_error)
{
  short curr[16][16];
  short pred[16][16];
  H263_MotionVector *fr0,*fr1,*fr2,*fr3,*fr4;
  int sum, dx, dy;
  int xmb, ymb;
#ifdef USE_C
  int m,n;
#endif

  xmb = x/H263_MB_SIZE+1;
  ymb = y/H263_MB_SIZE+1;

  fr0 = MV[0][ymb][xmb];
  fr1 = MV[1][ymb][xmb];
  fr2 = MV[2][ymb][xmb];
  fr3 = MV[3][ymb][xmb];
  fr4 = MV[4][ymb][xmb];

  /* Find MB in current image */
  sv_H263FindMB(H263Info, x, y, curr_image->lum, curr);


  /* Find prediction based on half pel MV */
  if (H263Info->advanced) {
    FindPredOBMC(H263Info, x, y, MV, prev_ipol, &pred[0][0], 0, PB);
    FindPredOBMC(H263Info, x, y, MV, prev_ipol, &pred[0][8], 1, PB);
    FindPredOBMC(H263Info, x, y, MV, prev_ipol, &pred[8][0], 2, PB);
    FindPredOBMC(H263Info, x, y, MV, prev_ipol, &pred[8][8], 3, PB);
  }
  else
    FindPred(H263Info, x, y, fr0, prev_ipol, &pred[0][0], 16, 0);

  /* Do the actual prediction */
  if (fr0->Mode == H263_MODE_INTER || fr0->Mode == H263_MODE_INTER_Q) {
#ifndef USE_C
    sv_H263Sub256_S(&(curr[0][0]), &(pred[0][0]), &(pred_error->lum[0][0]), 16);
#else
    for (n = 0; n < H263_MB_SIZE; n++)
      for (m = 0; m < H263_MB_SIZE; m++)
	    pred_error->lum[n][m] = curr[n][m] - pred[n][m];
#endif
    dx = 2*fr0->x + fr0->x_half;
    dy = 2*fr0->y + fr0->y_half;
    dx = ( dx % 4 == 0 ? dx >> 1 : (dx>>1)|1 );
    dy = ( dy % 4 == 0 ? dy >> 1 : (dy>>1)|1 );

    DoPredChrom_P(H263Info, x, y, dx, dy, curr_image, prev_image, pred_error);
  }
  else if (fr0->Mode == H263_MODE_INTER4V) {

#ifndef USE_C
  	  sv_H263Sub256_S(&(curr[0][0]), &(pred[0][0]), &(pred_error->lum[0][0]), 16);
#else
    for (n = 0; n < H263_MB_SIZE; n++)
      for (m = 0; m < H263_MB_SIZE; m++)
	    pred_error->lum[n][m] = curr[n][m] - pred[n][m];
#endif

    sum = 2*fr1->x + fr1->x_half + 2*fr2->x + fr2->x_half +
          2*fr3->x + fr3->x_half + 2*fr4->x + fr4->x_half ;
    dx = sign(sum)*(roundtab[abs(sum)%16] + (abs(sum)/16)*2);

    sum = 2*fr1->y + fr1->y_half + 2*fr2->y + fr2->y_half +
          2*fr3->y + fr3->y_half + 2*fr4->y + fr4->y_half;
    dy = sign(sum)*(roundtab[abs(sum)%16] + (abs(sum)/16)*2);

    DoPredChrom_P(H263Info, x, y, dx, dy, curr_image, prev_image, pred_error);
  }

  else
  {
    _SlibDebug(_WARN_, printf("Illegal Mode in Predict_P (pred.c)\n") );
  }
  return;
}


#ifdef USE_C /* replaced by svH263Ierr16 */
int sv_H263SADMBinteger(short *ii, short *act_block, int h_length, int min_sofar, int max_rtn)
{
  int i, sad = 0;
  short *kk;

  kk = act_block;
  i = 16;
  while (i--) {
    sad += (abs(*ii      - *kk     ) +
		    abs(*(ii+1 ) - *(kk+1) ) +
	        abs(*(ii+2)  - *(kk+2) ) +
			abs(*(ii+3 ) - *(kk+3) ) +
	        abs(*(ii+4)  - *(kk+4) ) +
			abs(*(ii+5 ) - *(kk+5) ) +
	        abs(*(ii+6)  - *(kk+6) ) +
			abs(*(ii+7 ) - *(kk+7) ) +
	        abs(*(ii+8)  - *(kk+8) ) +
			abs(*(ii+9 ) - *(kk+9) ) +
	        abs(*(ii+10) - *(kk+10)) +
		    abs(*(ii+11) - *(kk+11)) +
	        abs(*(ii+12) - *(kk+12)) +
			abs(*(ii+13) - *(kk+13)) +
	        abs(*(ii+14) - *(kk+14)) +
			abs(*(ii+15) - *(kk+15)) );

	/*  min_sofar = INT_MAX always */
    if (sad > min_sofar) return INT_MAX;

    ii += h_length;
    kk += 16;
  }
  return sad;
}
#endif

/***********************************************************************
 *
 *	Name:		Predict_B
 *	Description:    Predicts the B macroblock in PB-frame prediction
 *	
 *	Input:	        pointers to current frame, previous recon. frame,
 *                      pos. in image, MV-data, reconstructed macroblock
 *                      from image ahead
 *	Returns:        pointer to differential MB data after prediction
 *	Side effects:   allocates memory to MB_structure
 *
 ***********************************************************************/
void sv_H263PredictB(SvH263CompressInfo_t *H263Info,
            H263_PictImage *curr_image, H263_PictImage *prev_image,
			unsigned char *prev_ipol,int x, int y,
			H263_MotionVector *MV[5][H263_MBR+1][H263_MBC+2],
			H263_MB_Structure *recon_P, int TRD,int TRB,
			H263_MB_Structure *p_err, H263_MB_Structure *pred)
{
  int i,j,k;
  int sad, sad_min=INT_MAX, bdx=0, bdy=0;
  int start_x, start_y, end_x, end_y ;
  short curr[16][16];
  H263_MotionVector *f[5];
  int xvec, yvec, mvx, mvy;
#ifndef USE_C
  unsigned char *curCr, *curCb ;
#endif
  for(k=0; k<=4; k++) f[k]=MV[k][y/H263_MB_SIZE+1][x/H263_MB_SIZE+1];

  /* Find MB in current image */
  sv_H263FindMB(H263Info, x, y, curr_image->lum, curr);

  if(f[0]->Mode == H263_MODE_INTER4V) {  /* Mode INTER4V */

    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[1],&pred->lum[0][0],TRD,TRB,0,0,8,0);
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[2],&pred->lum[0][8],TRD,TRB,0,0,8,1);
	FindForwLumPredPB(H263Info, prev_ipol,x,y,f[3],&pred->lum[8][0],TRD,TRB,0,0,8,2);
	FindForwLumPredPB(H263Info, prev_ipol,x,y,f[4],&pred->lum[8][8],TRD,TRB,0,0,8,3);
#ifndef USE_C
    sad_min = sv_H263Ierr16_S(&curr[0][0],&pred->lum[0][0], 16, INT_MAX, INT_MAX);
#else
    sad_min = sv_H263SADMBinteger(&curr[0][0],&pred->lum[0][0], 16, INT_MAX, INT_MAX);
#endif
	sad_min -= H263_PREF_PBDELTA_NULL_VEC;
    bdx = bdy = 0;

    /* Find forward prediction */
    /* Luma */
    for (j = -H263_DEF_PBDELTA_WIN; j <= H263_DEF_PBDELTA_WIN; j++) {
      for (i = -H263_DEF_PBDELTA_WIN; i <= H263_DEF_PBDELTA_WIN; i++) {

	    if(i != 0 || j != 0) {
   	      FindForwLumPredPB(H263Info, prev_ipol,x,y,f[1],&pred->lum[0][0],TRD,TRB,i,j,8,0);
          FindForwLumPredPB(H263Info, prev_ipol,x,y,f[2],&pred->lum[0][8],TRD,TRB,i,j,8,1);
	      FindForwLumPredPB(H263Info, prev_ipol,x,y,f[3],&pred->lum[8][0],TRD,TRB,i,j,8,2);
	      FindForwLumPredPB(H263Info, prev_ipol,x,y,f[4],&pred->lum[8][8],TRD,TRB,i,j,8,3);
#ifndef USE_C
          sad = sv_H263Ierr16_S(&curr[0][0],&pred->lum[0][0], 16, sad_min, INT_MAX);
#else
          sad = sv_H263SADMBinteger(&curr[0][0],&pred->lum[0][0], 16, sad_min, INT_MAX);
#endif
	      if (sad < sad_min) { sad_min = sad; bdx = i; bdy = j; }
		}
      }
    }

    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[1],&pred->lum[0][0],TRD,TRB,bdx,bdy,8,0);
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[2],&pred->lum[0][8],TRD,TRB,bdx,bdy,8,1);
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[3],&pred->lum[8][0],TRD,TRB,bdx,bdy,8,2);
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[4],&pred->lum[8][8],TRD,TRB,bdx,bdy,8,3);

    /* chroma vectors are sum of B luma vectors divided and rounded */
    xvec = yvec = 0;
    for (k = 1; k <= 4; k++) {
      xvec += TRB*(2*f[k]->x + f[k]->x_half)/TRD + bdx;
      yvec += TRB*(2*f[k]->y + f[k]->y_half)/TRD + bdy;
    }

    /* round values according to TABLE 16/H.263 */
    i = sign(xvec)*(roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
    j = sign(yvec)*(roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

    FindChromBlock_P(H263Info, x, y, i, j, prev_image, pred);

    /* Find bidirectional prediction */
    FindBiDirLumPredPB(&recon_P->lum[0][0],f[1],&pred->lum[0][0],TRD,TRB,bdx,bdy,0,0);
    FindBiDirLumPredPB(&recon_P->lum[0][8],f[2],&pred->lum[0][8],TRD,TRB,bdx,bdy,1,0);
    FindBiDirLumPredPB(&recon_P->lum[8][0],f[3],&pred->lum[8][0],TRD,TRB,bdx,bdy,0,1);
    FindBiDirLumPredPB(&recon_P->lum[8][8],f[4],&pred->lum[8][8],TRD,TRB,bdx,bdy,1,1);

    /* chroma vectors are sum of B luma vectors divided and rounded */
    xvec = yvec = 0;
    for (k = 1; k <= 4; k++) {
      mvx = 2*f[k]->x + f[k]->x_half;
      mvy = 2*f[k]->y + f[k]->y_half;
      xvec += bdx == 0 ? (TRB-TRD) *  mvx / TRD : TRB * mvx / TRD + bdx - mvx;
      yvec += bdy == 0 ? (TRB-TRD) *  mvy / TRD : TRB * mvy / TRD + bdy - mvy;
    }

    /* round values according to TABLE 16/H.263 */
    i = sign(xvec)*(roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
    j = sign(yvec)*(roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

    FindBiDirChrPredPB(recon_P, i, j, pred);
  }
  else {  /* Mode INTER or INTER_Q */

    if( f[0]->Mode==H263_MODE_INTRA || f[0]->Mode==H263_MODE_INTRA_Q ||
       (f[0]->x==0 && f[0]->y==0 && f[0]->x_half==0 && f[0]->y_half==0))
	          bdx = bdy = 0;
    else{
      /* Find forward prediction */
      FindForwLumPredPB(H263Info, prev_ipol,x,y,f[0],&pred->lum[0][0],TRD,TRB,0,0,16,0);
#ifndef USE_C
      sad_min = sv_H263Ierr16_S(&curr[0][0],&pred->lum[0][0], 16, INT_MAX, INT_MAX);
#else
      sad_min = sv_H263SADMBinteger(&curr[0][0],&pred->lum[0][0], 16, INT_MAX, INT_MAX);
#endif
      sad_min -= H263_PREF_PBDELTA_NULL_VEC;
      bdx = bdy = 0;

	  start_x = start_y = -H263_DEF_PBDELTA_WIN;
	  end_x   = end_y   =  H263_DEF_PBDELTA_WIN;

      /* To keep things simple I turn off PB delta vectors at the edges */
      if(!H263Info->mv_outside_frame) {
         if (x == 0 || x == H263Info->pels - H263_MB_SIZE) start_x = end_x = 0;
         if (y == 0 || y == H263Info->lines - H263_MB_SIZE) start_y = end_y = 0;
      }

      for (j = start_y; j <= end_y; j++) {
        for (i = start_x; i <= end_x; i++) {
		  if(i || j) {
            FindForwLumPredPB(H263Info, prev_ipol,x,y,f[0],&pred->lum[0][0],
				                                          TRD,TRB,i,j,16,0);
#ifndef USE_C				
            sad = sv_H263Ierr16_S(&curr[0][0],&pred->lum[0][0], 16, sad_min, INT_MAX);
#else
            sad = sv_H263SADMBinteger(&curr[0][0],&pred->lum[0][0], 16, sad_min, INT_MAX);
#endif
	        if (sad < sad_min) { sad_min = sad; bdx = i; bdy = j; }
	      }
        }
      }
    }

    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[0],&pred->lum[0][0],TRD,TRB, bdx,bdy,16,0);

    xvec = 4 * (TRB*(2*f[0]->x + f[0]->x_half) / TRD + bdx);
    yvec = 4 * (TRB*(2*f[0]->y + f[0]->y_half) / TRD + bdy);
    /* round values according to TABLE 16/H.263 */
    i = sign(xvec)*(roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
    j = sign(yvec)*(roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

    FindChromBlock_P(H263Info, x, y, i, j, prev_image, pred);

    /* Find bidirectional prediction */
    BiDirLumPredPB(recon_P, f[0], pred, TRD, TRB, bdx, bdy);

    /* chroma vectors */
    mvx = 2*f[0]->x + f[0]->x_half;
    xvec = bdx == 0 ? (TRB-TRD) * mvx / TRD : TRB * mvx / TRD + bdx - mvx;
    xvec *= 4;

    mvy = 2*f[0]->y + f[0]->y_half;
    yvec = bdy == 0 ? (TRB-TRD) * mvy / TRD : TRB * mvy / TRD + bdy - mvy;
    yvec *= 4;

    /* round values according to TABLE 16/H.263 */
    i = sign(xvec)*(roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
    j = sign(yvec)*(roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

    FindBiDirChrPredPB(recon_P, i, j, pred);
  }

  /* store PB-deltas */
  MV[5][y/H263_MB_SIZE+1][x/H263_MB_SIZE+1]->x = (short)bdx; /* is in half pel format */
  MV[5][y/H263_MB_SIZE+1][x/H263_MB_SIZE+1]->y = (short)bdy;
  MV[5][y/H263_MB_SIZE+1][x/H263_MB_SIZE+1]->x_half = 0;
  MV[5][y/H263_MB_SIZE+1][x/H263_MB_SIZE+1]->y_half = 0;

#ifndef USE_C
  /* Do the actual prediction */
  curCr  = curr_image->lum + x + y*H263Info->pels ;
  sv_H263Sub16_S(curCr, &(pred->lum[0][0]), &(p_err->lum[0][0]), H263Info->pels) ;

  y >>= 1;  x >>= 1;
  curCr  = curr_image->Cr + x + y*H263Info->cpels ;
  curCb  = curr_image->Cb + x + y*H263Info->cpels ;

  sv_H263Sub8_S(curCr, &(pred->Cr[0][0]), &(p_err->Cr[0][0]), H263Info->cpels);
  sv_H263Sub8_S(curCb, &(pred->Cb[0][0]), &(p_err->Cb[0][0]), H263Info->cpels);

#else
 /* Do the actual prediction */
  for (j = 0; j < H263_MB_SIZE; j++)
    for (i = 0; i < H263_MB_SIZE; i++)
      p_err->lum[j][i] =
	   *(curr_image->lum+x+i + (y+j)*H263Info->pels) - pred->lum[j][i];

  y >>= 1;
  x >>= 1;
  for (j = 0; j < H263_MB_SIZE>>1; j++)
    for (i = 0; i < H263_MB_SIZE>>1; i++) {
      p_err->Cr[j][i] = *(curr_image->Cr+x+i + (y+j)*H263Info->cpels) - pred->Cr[j][i];
      p_err->Cb[j][i] = *(curr_image->Cb+x+i + (y+j)*H263Info->cpels) - pred->Cb[j][i];
    }
#endif

  return ;
}

/***********************************************************************
 *
 *	Name:		MB_Recon_B
 *	Description:    Reconstructs the B macroblock in PB-frame
 *                      prediction
 *	
 *	Input:	        pointers previous recon. frame, pred. diff.,
 *                      pos. in image, MV-data, reconstructed macroblock
 *                      from image ahead
 *	Returns:        pointer to reconstructed MB data
 *	Side effects:   allocates memory to MB_structure
 *
 ***********************************************************************/

void sv_H263MBReconB(SvH263CompressInfo_t *H263Info,
                     H263_PictImage *prev_image, H263_MB_Structure *diff,
                     unsigned char *prev_ipol,int x, int y,
                     H263_MotionVector *MV[5][H263_MBR+1][H263_MBC+2],
                     H263_MB_Structure *recon_P,int TRD, int TRB,
                     H263_MB_Structure *recon_B,H263_MB_Structure *pred)
{
#if 1
  int j;
  unsigned qword *dpc ;
  unsigned UNALIGNED qword *dpa, *dpb;

  dpc = (unsigned qword *) &(recon_B->lum[0][0]);
  dpb = (unsigned qword *) &(pred->lum[0][0]);
  dpa = (unsigned qword *) &(diff->lum[0][0]);

  for (j = 0; j < 12; j++) {
 	*dpc++ = *dpb++ + *dpa++ ;
 	*dpc++ = *dpb++ + *dpa++ ;
 	*dpc++ = *dpb++ + *dpa++ ;
 	*dpc++ = *dpb++ + *dpa++ ;

 	*dpc++ = *dpb++ + *dpa++ ;
 	*dpc++ = *dpb++ + *dpa++ ;
 	*dpc++ = *dpb++ + *dpa++ ;
 	*dpc++ = *dpb++ + *dpa++ ;
  }
#else
  int j,k;
  int dx, dy, bdx, bdy, mvx, mvy, xvec, yvec;
  H263_MotionVector *f[5];

  for (k = 0; k <= 4; k++)
    f[k] = MV[k][y/H263_MB_SIZE+1][x/H263_MB_SIZE+1];

  bdx = MV[5][y/H263_MB_SIZE+1][x/H263_MB_SIZE+1]->x;
  bdy = MV[5][y/H263_MB_SIZE+1][x/H263_MB_SIZE+1]->y;

  if (f[0]->Mode == H263_MODE_INTER4V) {  /* Mode INTER4V */
    /* Find forward prediction */

    /* Luma */
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[1],&pred->lum[0][0],TRD,TRB,bdx,bdy,8,0);
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[2],&pred->lum[0][8],TRD,TRB,bdx,bdy,8,1);
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[3],&pred->lum[8][0],TRD,TRB,bdx,bdy,8,2);
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[4],&pred->lum[8][8],TRD,TRB,bdx,bdy,8,3);

    /* chroma vectors are sum of B luma vectors divided and rounded */
    xvec = yvec = 0;
    for (k = 1; k <= 4; k++) {
      xvec += TRB*(2*f[k]->x + f[k]->x_half)/TRD + bdx;
      yvec += TRB*(2*f[k]->y + f[k]->y_half)/TRD + bdy;
    }

    /* round values according to TABLE 16/H.263 */
    dx = sign(xvec)*(roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
    dy = sign(yvec)*(roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

    FindChromBlock_P(H263Info, x, y, dx, dy, prev_image, pred);

    /* Find bidirectional prediction */
    FindBiDirLumPredPB(&recon_P->lum[0][0], f[1], &pred->lum[0][0],
		       TRD, TRB, bdx, bdy, 0, 0);
    FindBiDirLumPredPB(&recon_P->lum[0][8], f[2], &pred->lum[0][8],
		       TRD, TRB, bdx, bdy, 1, 0);
    FindBiDirLumPredPB(&recon_P->lum[8][0], f[3], &pred->lum[8][0],
		       TRD, TRB, bdx, bdy, 0, 1);
    FindBiDirLumPredPB(&recon_P->lum[8][8], f[4], &pred->lum[8][8],
		       TRD, TRB, bdx, bdy, 1, 1);

    /* chroma vectors are sum of B luma vectors divided and rounded */
    xvec = yvec = 0;
    for (k = 1; k <= 4; k++) {
      mvx = 2*f[k]->x + f[k]->x_half;
      mvy = 2*f[k]->y + f[k]->y_half;
      xvec += bdx == 0 ? (TRB-TRD) *  mvx / TRD : TRB * mvx / TRD + bdx - mvx;
      yvec += bdy == 0 ? (TRB-TRD) *  mvy / TRD : TRB * mvy / TRD + bdy - mvy;
    }

    /* round values according to TABLE 16/H.263 */
    dx = sign(xvec)*(roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
    dy = sign(yvec)*(roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

    FindBiDirChrPredPB(recon_P, dx, dy, pred);
  }
  else {  /* Mode INTER or INTER_Q */
    /* Find forward prediction */
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[0],&pred->lum[0][0],TRD,TRB,
		      bdx,bdy,16,0);

    xvec = 4 * (TRB*(2*f[0]->x + f[0]->x_half) / TRD + bdx);
    yvec = 4 * (TRB*(2*f[0]->y + f[0]->y_half) / TRD + bdy);
    /* round values according to TABLE 16/H.263 */
    dx = sign(xvec)*(roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
    dy = sign(yvec)*(roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

    FindChromBlock_P(H263Info, x, y, dx, dy, prev_image, pred);

    /* Find bidirectional prediction */
    BiDirLumPredPB(recon_P, f[0], pred, TRD, TRB, bdx, bdy);

    /* chroma vectors */
    mvx = 2*f[0]->x + f[0]->x_half;
    xvec = bdx == 0 ? (TRB-TRD) * mvx / TRD : TRB * mvx / TRD + bdx - mvx;
    xvec *= 4;

    mvy = 2*f[0]->y + f[0]->y_half;
    yvec = bdy == 0 ? (TRB-TRD) * mvy / TRD : TRB * mvy / TRD + bdy - mvy;
    yvec *= 4;

    /* round values according to TABLE 16/H.263 */
    dx = sign(xvec)*(roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
    dy = sign(yvec)*(roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

    FindBiDirChrPredPB(recon_P, dx, dy, pred);
  }

  /* Reconstruction */
  for (j = 0; j < H263_MB_SIZE; j++)
    for (k = 0; k < H263_MB_SIZE; k++)
      recon_B->lum[j][k] = pred->lum[j][k] + diff->lum[j][k];

  for (j = 0; j < H263_MB_SIZE>>1; j++)
    for (k = 0; k < H263_MB_SIZE>>1; k++) {
      recon_B->Cr[j][k] = pred->Cr[j][k] + diff->Cr[j][k];
      recon_B->Cb[j][k] = pred->Cb[j][k] + diff->Cb[j][k];
    }
#endif

  return ;
}

/**********************************************************************
 *
 *	Name:	       FindForwLumPredPB
 *	Description:   Finds the forward luma  prediction in PB-frame
 *                     pred.
 *	
 *	Input:	       pointer to prev. recon. frame, current positon,
 *                     MV structure and pred. structure to fill
 *
 ***********************************************************************/

static void FindForwLumPredPB(SvH263CompressInfo_t *H263Info,
                       unsigned char *prev_ipol, int x_curr, int y_curr,
		               H263_MotionVector *fr, short *pred, int TRD, int TRB,
		               int bdx, int bdy, int bs, int comp)
{
  int i,j,i2,j2;
  int xvec,yvec,lx2;
  unsigned char *ptn ;

  lx2 = ((H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels)) * 2;

  /* Luma */
  xvec = (TRB)*(2*fr->x + fr->x_half)/TRD + bdx;
  yvec = (TRB)*(2*fr->y + fr->y_half)/TRD + bdy;

  x_curr = (x_curr + ((comp&1)<<3)) * 2 + xvec;
  y_curr = (y_curr + ((comp&2)<<2)) * 2 + yvec;
  x_curr += (y_curr * lx2) ;

  ptn = prev_ipol + x_curr ;
  lx2 = (lx2 << 1) ;

#ifdef USE_C
  for (j = j2 = 0; j < bs; j++, j2 += lx2)
    for (i = i2 = 0; i < bs; i++, i2 += 2)
      *(pred+i+j*16) = *(ptn + i2 + j2);
#else
  if(bs == 16) {
     sv_H263Intpix16_S(ptn, pred, lx2, 16) ;
  }
  else {
    for (j = j2 = 0; j < bs; j++, j2 += lx2)
      for (i = i2 = 0; i < bs; i++, i2 += 2)
        *(pred+i+j*16) = *(ptn + i2 + j2);
  }
#endif

  return;
}

/**********************************************************************
 *
 *	Name:	       FindBiDirLumPredPB
 *	Description:   Finds the bi-dir. luma prediction in PB-frame
 *                     prediction
 *	
 *	Input:	       pointer to future recon. data, current positon,
 *                     MV structure and pred. structure to fill
 *
 ***********************************************************************/
void FindBiDirLumPredPB(short *recon_P, H263_MotionVector *fr, short *pred, int TRD,
			int TRB, int bdx, int bdy, int nh, int nv)
{
  int xstart,xstop,ystart,ystop;
  int xvec,yvec, mvx, mvy;

  mvx = 2*fr->x + fr->x_half;
  mvy = 2*fr->y + fr->y_half;

  xvec = (bdx == 0 ? (TRB-TRD) *  mvx / TRD : TRB * mvx / TRD + bdx - mvx);
  yvec = (bdy == 0 ? (TRB-TRD) *  mvy / TRD : TRB * mvy / TRD + bdy - mvy);

  /* Luma */

  FindBiDirLimits(xvec,&xstart,&xstop,nh);
  FindBiDirLimits(yvec,&ystart,&ystop,nv);

  BiDirPredBlock(xstart,xstop,ystart,ystop,xvec,yvec, recon_P,pred,16);

  return;
}

void BiDirLumPredPB(H263_MB_Structure *recon_P, H263_MotionVector *fr,
					H263_MB_Structure *pred,int TRD,int TRB,int bdx,int bdy)
{
  int xstart,xstop,ystart,ystop;
  int xvec,yvec, mvx, mvy;

  mvx = 2*fr->x + fr->x_half;
  mvy = 2*fr->y + fr->y_half;

  xvec = (bdx == 0 ? (TRB-TRD) *  mvx / TRD : TRB * mvx / TRD + bdx - mvx);
  yvec = (bdy == 0 ? (TRB-TRD) *  mvy / TRD : TRB * mvy / TRD + bdy - mvy);

  /* Luma */
  FindBiDirLimits(xvec,&xstart,&xstop,0);
  FindBiDirLimits(yvec,&ystart,&ystop,0);
  BiDirPredBlock(xstart,xstop,ystart,ystop,xvec,yvec, &recon_P->lum[0][0],
	             &pred->lum[0][0],16);

  FindBiDirLimits(xvec,&xstart,&xstop,1);
  FindBiDirLimits(yvec,&ystart,&ystop,0);
  BiDirPredBlock(xstart,xstop,ystart,ystop,xvec,yvec, &recon_P->lum[0][8],
	             &pred->lum[0][8],16);

  FindBiDirLimits(xvec,&xstart,&xstop,0);
  FindBiDirLimits(yvec,&ystart,&ystop,1);
  BiDirPredBlock(xstart,xstop,ystart,ystop,xvec,yvec, &recon_P->lum[8][0],
	             &pred->lum[8][0],16);

  FindBiDirLimits(xvec,&xstart,&xstop,1);
  FindBiDirLimits(yvec,&ystart,&ystop,1);
  BiDirPredBlock(xstart,xstop,ystart,ystop,xvec,yvec, &recon_P->lum[8][8],
	             &pred->lum[8][8],16);
  return;
}

/**********************************************************************
 *
 *	Name:	       FindBiDirChrPredPB
 *	Description:   Finds the bi-dir. chroma prediction in PB-frame
 *                     prediction
 *	
 *	Input:	       pointer to future recon. data, current positon,
 *                     MV structure and pred. structure to fill
 *
 ***********************************************************************/

void FindBiDirChrPredPB(H263_MB_Structure *recon_P, int dx, int dy,
			H263_MB_Structure *pred)
{
  int xstart,xstop,ystart,ystop;

  FindBiDirChromaLimits(dx,&xstart,&xstop);
  FindBiDirChromaLimits(dy,&ystart,&ystop);

  BiDirPredBlock(xstart,xstop,ystart,ystop,dx,dy,
		 &recon_P->Cb[0][0], &pred->Cb[0][0],8);
  BiDirPredBlock(xstart,xstop,ystart,ystop,dx,dy,
		 &recon_P->Cr[0][0], &pred->Cr[0][0],8);

  return;
}

void FindBiDirLimits(int vec, int *start, int *stop, int nhv)
{
  /* limits taken from C loop in section G5 in H.263 */
  *start = mmax(0,(-vec+1)/2 - nhv*8);
  *stop = mmin(7,15-(vec+1)/2 - nhv*8);

  return;
}

void FindBiDirChromaLimits(int vec, int *start, int *stop)
{
  /* limits taken from C loop in section G5 in H.263 */
  *start = mmax(0,(-vec+1)/2);
  *stop = mmin(7,7-(vec+1)/2);

  return;
}


#if 1
void BiDirPredBlock(int xstart, int xstop, int ystart, int ystop,
		    int xvec, int yvec, short *recon, short *pred, int bl)
{
  int i,j,pel;
  int xint, yint;
  int xh, yh;
  register short *ptn, *ptnd;

  xint = xvec>>1;
  xh = xvec - (xint << 1);
  yint = yvec>>1;
  yh = yvec - (yint << 1);

  ptn  =  recon + ystart*bl + xint + yint * bl;
  ptnd  = pred  + ystart*bl ;

  if (!xh && !yh) {
    for (j=ystart; j <= ystop; j++) {
      for (i=xstart; i <= xstop; i++) {
/*   *(ptnd + i) = (sv_H263lim255r_S(pel) + *(ptnd + i))>>1; */
	    *(ptnd + i) = ( *(ptn + i) + *(ptnd + i) )>>1;
      }
      ptn  += bl;  ptnd += bl;
    }
  }
  else if (!xh && yh) {
    yh *= bl ;
    for (j=ystart; j <= ystop; j++) {
      for (i=xstart; i <= xstop; i++) {
	    pel = (*(ptn + i) + *(ptn + i + yh) + 1)>>1;
	    *(ptnd + i) = (pel + *(ptnd + i))>>1;
      }
      ptn  += bl;  ptnd += bl;
    }
  }
  else if (xh && !yh) {
    for (j=ystart; j <= ystop; j++) {
      for (i=xstart; i <= xstop; i++) {
	     pel = (*(ptn + i) + *(ptn + i + xh) + 1)>>1;
		 *(ptnd + i) = (pel + *(ptnd + i))>>1;
      }
      ptn  += bl;  ptnd += bl;
    }
  }
  else { /* xh && yh */
    yh *= bl ;
    for (j=ystart; j <= ystop; j++) {
      for (i=xstart; i <= xstop; i++) {
	     pel = (*(ptn + i) + *(ptn + i + yh) +
	            *(ptn + i + xh) + *(ptn + i + yh + xh)+2)>>2;
	     *(ptnd + i) = (pel + *(ptnd + i))>>1;
      }
      ptn  += bl;  ptnd += bl;
    }
  }
  return;
}

#else

void BiDirPredBlock(int xstart, int xstop, int ystart, int ystop,
		    int xvec, int yvec, int *recon, int *pred, int bl)
{
  int i,j,pel;
  int xint, yint;
  int xh, yh;

  xint = xvec>>1;
  xh = xvec - 2*xint;
  yint = yvec>>1;
  yh = yvec - 2*yint;

  if (!xh && !yh) {
    for (j = ystart; j <= ystop; j++) {
      for (i = xstart; i <= xstop; i++) {
	pel = *(recon +(j+yint)*bl + i+xint);
#ifndef USE_C
	*(pred + j*bl + i) = (sv_H263lim255r_S(pel)) + *(pred + j*bl + i))>>1;
#else
	*(pred + j*bl + i) = (mmin(255,mmax(0,pel)) + *(pred + j*bl + i))>>1;
#endif
      }
    }
  }
  else if (!xh && yh) {
    for (j = ystart; j <= ystop; j++) {
      for (i = xstart; i <= xstop; i++) {
	pel = (*(recon +(j+yint)*bl + i+xint)       +
	       *(recon +(j+yint+yh)*bl + i+xint) + 1)>>1;
	*(pred + j*bl + i) = (pel + *(pred + j*bl + i))>>1;
      }
    }
  }
  else if (xh && !yh) {
    for (j = ystart; j <= ystop; j++) {
      for (i = xstart; i <= xstop; i++) {
	pel = (*(recon +(j+yint)*bl + i+xint)       +
	       *(recon +(j+yint)*bl + i+xint+xh) + 1)>>1;
	*(pred + j*bl + i) = (pel + *(pred + j*bl + i))>>1;
      }
    }
  }
  else { /* xh && yh */
    for (j = ystart; j <= ystop; j++) {
      for (i = xstart; i <= xstop; i++) {
	pel = (*(recon +(j+yint)*bl + i+xint)       +
	       *(recon +(j+yint+yh)*bl + i+xint) +
	       *(recon +(j+yint)*bl + i+xint+xh) +
	       *(recon +(j+yint+yh)*bl + i+xint+xh)+2)>>2;
	*(pred + j*bl + i) = (pel + *(pred + j*bl + i))>>1;
      }
    }
  }
  return;
}

#endif
/**********************************************************************
 *
 *	Name:		DoPredChrom_P
 *	Description:	Does the chrominance prediction for P-frames
 *	
 *	Input:		motionvectors for each field,
 *			current position in image,
 *			pointers to current and previos image,
 *			pointer to pred_error array,
 *			(int) field: 1 if field coding
 *			
 *	Side effects:	fills chrom-array in pred_error structure
 *
 ***********************************************************************/
static void DoPredChrom_P(SvH263CompressInfo_t *H263Info,
                          int x_curr, int y_curr, int dx, int dy,
                          H263_PictImage *curr, H263_PictImage *prev,
                          H263_MB_Structure *pred_error)
{
  int ofy, lx;
  int xh, yh, ofyy;
  register short *ptnr, *ptnb;
  unsigned char *preCr, *preCb, *curCr, *curCb;
  int x, y, ofx;
#ifdef USE_C
  int ydiff,pel,m,n;
#endif

  lx = (H263Info->mv_outside_frame ? H263Info->pels/2 + (H263Info->long_vectors?32:16) : H263Info->pels/2);

  x  = x_curr>>1;
  y = y_curr>>1;
  xh = dx & 1;
  yh = dy & 1;

  ptnr = &(pred_error->Cr[0][0]) ;
  ptnb = &(pred_error->Cb[0][0]) ;

  ofy   = (y + (dy >> 1))*lx + x + (dx >> 1) ;
  preCr = prev->Cr + ofy;
  preCb = prev->Cb + ofy ;

  ofx   = x + y * H263Info->cpels ;
  curCr = curr->Cr + ofx ;
  curCb = curr->Cb + ofx ;

  if (!xh && !yh) {
#ifndef USE_C
    sv_H263SubCpy_S(curCr, preCr, ptnr, H263Info->cpels, lx) ;
    sv_H263SubCpy_S(curCb, preCb, ptnb, H263Info->cpels, lx) ;
#else
	ofx = H263Info->cpels - 8;
	ydiff = lx - 8;
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	     *(ptnr++) = (short)(*(curCr++) - *(preCr++));
	     *(ptnb++) = (short)(*(curCb++) - *(preCb++));
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
	  curCr += ofx ;
	  curCb += ofx ;
    };
#endif
  }
  else if (!xh && yh) {
    ofyy = yh * lx ;
#ifndef USE_C
    sv_H263Sub2Cpy_S(curCr, preCr, preCr + ofyy, ptnr, H263Info->cpels, lx) ;
    sv_H263Sub2Cpy_S(curCb, preCb, preCb + ofyy, ptnb, H263Info->cpels, lx) ;
#else
	ofx = H263Info->cpels - 8;
	ydiff = lx - 8;
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
   *(ptnr++) = (short)(*(curCr++) - ((*(preCr + ofyy) + *(preCr++) + 1)>>1));
   *(ptnb++) = (short)(*(curCb++) - ((*(preCb + ofyy) + *(preCb++) + 1)>>1));
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
	  curCr += ofx ;
	  curCb += ofx ;
    };
#endif
   }
  else if (xh && !yh) {
#ifndef USE_C
    sv_H263Sub2Cpy_S(curCr, preCr, preCr + xh, ptnr, H263Info->cpels, lx) ;
    sv_H263Sub2Cpy_S(curCb, preCb, preCb + xh, ptnb, H263Info->cpels, lx) ;
#else
	ofx = H263Info->cpels - 8;
	ydiff = lx - 8;
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	 *(ptnr++) = (short)(*(curCr++) - ((*(preCr + xh) + *(preCr++) + 1)>>1));

	 *(ptnb++) = (short)(*(curCb++) - ((*(preCb + xh) + *(preCb++) + 1)>>1));
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
	  curCr += ofx ;
	  curCb += ofx ;
    };
#endif
  }
  else { /* xh && yh */
    ofyy = yh * lx ;
#ifndef USE_C
    sv_H263Sub4Cpy_S(curCr, preCr, preCr + xh, preCr + ofyy,
		           preCr + xh + ofyy, ptnr, H263Info->cpels, lx) ;
    sv_H263Sub4Cpy_S(curCb, preCb, preCb + xh, preCb + ofyy,
		           preCb + xh + ofyy, ptnb, H263Info->cpels, lx) ;
#else
	ofx = H263Info->cpels - 8;
	ydiff = lx - 8;
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
        pel = (short)(*(preCr + xh) + *(preCr + ofyy) +
 	                *(preCr + xh + ofyy) + *(preCr++) + 2)>>2;
	    *(ptnr++) = (short)(*(curCr++) - pel);

        pel = (short)(*(preCb + xh) + *(preCb + ofyy)+
	                *(preCb + xh + ofyy) + *(preCb++) + 2)>>2;
	    *(ptnb++) = (short)(*(curCb++) - pel);
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
	  curCr += ofx ;
	  curCb += ofx ;
    };
#endif
  }
  return;
}

/**********************************************************************
 *
 *	Name:		FindHalfPel
 *	Description:	Find the optimal half pel prediction
 *	
 *	Input:		position, vector, array with current data
 *			pointer to previous interpolated luminance,
 *
 *	Returns:
 *
 ***********************************************************************/

void sv_H263FindHalfPel(SvH263CompressInfo_t *H263Info,
                        int x, int y, H263_MotionVector *fr, unsigned char *prev,
                        unsigned char *curr, int bs, int comp)
{
  int m, n;
  int start_x, start_y, stop_x, stop_y, new_x, new_y, lx;
  int AE, AE_min;
  int m2, n2, lx2, lx4, n16;
  unsigned char *ptn, *ptnn, *cur ;
  int curX,curY,minX,minY;

  cur = curr + x + y * H263Info->pels;

  start_x = -1;  stop_x = 1;
  start_y = -1;  stop_y = 1;

  new_x = x + fr->x;
  new_y = y + fr->y;

  new_x += ((comp&1)<<3);
  new_y += ((comp&2)<<2);

  lx = (H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels);

  /* Make sure that no addressing is outside the frame */
  if (!H263Info->mv_outside_frame) {
    if ((new_x) <= 0) start_x = 0;
    if ((new_y) <= 0) start_y = 0;
    if ((new_x) >= (H263Info->pels-bs))  stop_x = 0;
    if ((new_y) >= (H263Info->lines-bs)) stop_y = 0;
  }

  lx2 = (lx << 1);
  lx4 = (lx2 << 1);
  ptn = prev + (new_x<<1) + ((new_y<<1) * lx2);

  minX = minY =0;

#ifdef USE_C

  AE_min = 0;
  for (n = n2 = 0; n < bs; n++, n2 += lx4) {
    n16 = n<<4;
     /* Find absolute error */
    for (m = m2 = 0; m < bs; m++, m2 += 2)
       AE_min += abs(*(ptn + m2 + n2) - *(cur + m + n * H263Info->pels));
  }
  for(curY=start_y;curY<=stop_y;curY++){
    for(curX=start_x; curX<=stop_x;curX++) {

      if(curX || curY) {	
         ptnn = ptn + curY*lx2 + curX ;
         AE = 0;
         for (n = n2 = 0; n < bs; n++, n2 += lx4) {
           n16 = n<<4;
           /* Find absolute error */
           for (m = m2 = 0; m < bs; m++, m2 += 2)
  	         AE += abs(*(ptnn + m2 + n2) - *(cur + m + n * H263Info->pels));

           if(AE > AE_min) { AE = INT_MAX; break;}
         }
         /*
          * if (i == 0 && fr->x == 0 && fr->y == 0 && bs == 16)
          * AE -= PREF_NULL_VEC;
          */
         if (AE < AE_min) {
           AE_min = AE;
           minX = curX;
           minY = curY;
		 }
	  }
	}
  }

#else

  if(bs == 16){

    AE_min = sv_H263HalfPerr16_S(cur, ptn, H263Info->pels, lx4, INT_MAX);

    for(curY=start_y;curY<=stop_y;curY++){
	  for(curX=start_x; curX<=stop_x;curX++) {
	    if(curX || curY) {	
	      ptnn = ptn + curY*lx2 + curX ;
          if((AE = sv_H263HalfPerr16_S(cur, ptnn, H263Info->pels,
		                               lx4, AE_min)) < AE_min) {
             AE_min = AE;
             minX = curX;
             minY = curY;
  } } } } }
  else if(bs == 8) {

    AE_min = sv_H263HalfPerr8_S(cur, ptn, H263Info->pels, lx4, INT_MAX);

    for(curY=start_y;curY<=stop_y;curY++){
	  for(curX=start_x; curX<=stop_x;curX++) {
	    if(curX || curY) {	
	      ptnn = ptn + curY*lx2 + curX ;
          if((AE = sv_H263HalfPerr8_S(cur, ptnn, H263Info->pels,
		                               lx4, AE_min)) < AE_min) {
             AE_min = AE;
             minX = curX;
             minY = curY;
  } } } } }
  else{

    AE_min = 0;
    for (n = n2 = 0; n < bs; n++, n2 += lx4) {
      n16 = n<<4;
       /* Find absolute error */
      for (m = m2 = 0; m < bs; m++, m2 += 2)
         AE_min += abs(*(ptn + m2 + n2) - *(cur + m + n * H263Info->pels));
    }
    for(curY=start_y;curY<=stop_y;curY++){
	  for(curX=start_x; curX<=stop_x;curX++) {

	    if(curX || curY) {	
           ptnn = ptn + curY*lx2 + curX ;
           AE = 0;
           for (n = n2 = 0; n < bs; n++, n2 += lx4) {
             n16 = n<<4;
             /* Find absolute error */
             for (m = m2 = 0; m < bs; m++, m2 += 2)
    	         AE += abs(*(ptnn + m2 + n2) - *(cur + m + n * H263Info->pels));

	         if(AE > AE_min) { AE = INT_MAX; break;}
           }
          /*
           * if (i == 0 && fr->x == 0 && fr->y == 0 && bs == 16)
           * AE -= PREF_NULL_VEC;
           */
          if (AE < AE_min) {
            AE_min = AE;
            minX = curX;
            minY = curY;
  } } } } }

#endif

   /* Store optimal values */
  fr->min_error = (short)AE_min;
  fr->x_half = (short)minX;
  fr->y_half = (short)minY;

  return;

}

/**********************************************************************
 *
 *	Name:		AdvHalfPel
 *	Description:	Find the optimal half pel prediction for Advanced mode
 *	
 *	Input:		position, vector, array with current data
 *			pointer to previous interpolated luminance,
 *
 *	Returns:
 *
 ***********************************************************************/

#ifndef USE_C
void sv_H263AdvHalfPel(SvH263CompressInfo_t *H263Info, int x, int y,
                             H263_MotionVector *fr0, H263_MotionVector *fr1,
                             H263_MotionVector *fr2, H263_MotionVector *fr3,
                             H263_MotionVector *fr4,
                             unsigned char *prev, unsigned char *curr,
                             int bs, int comp)
{
  int start_x, start_y, stop_x, stop_y, new_x, new_y, lx;
  unsigned int AE, AE_min, minER1, minER2, minER3, minER4;
  int lx2, lx4;
  unsigned char *ptn, *ptnn, *cur ;
  int curX,curY,minX,minY,minX1,minY1,minX2,minY2,minX3,minY3,minX4,minY4;
  unsigned int error[4];

  cur = curr + x + y * H263Info->pels;

  start_x = -1;  stop_x = 1;
  start_y = -1;  stop_y = 1;

  new_x = x + fr0->x;
  new_y = y + fr0->y;

  new_x += ((comp&1)<<3);
  new_y += ((comp&2)<<2);

  lx = (H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels);

  /* Make sure that no addressing is outside the frame */
  if (!H263Info->mv_outside_frame) {
    if ((new_x) <= 0) start_x = 0;
    if ((new_y) <= 0) start_y = 0;
    if ((new_x) >= (H263Info->pels-bs))  stop_x = 0;
    if ((new_y) >= (H263Info->lines-bs)) stop_y = 0;
  }

  lx2 = (lx << 1);
  lx4 = (lx2 << 1);
  ptn = prev + (new_x<<1) + ((new_y<<1) * lx2);

  minX=minY=minX1=minY1=minX2=minY2=minX3=minY3=minX4=minY4=0;

  sv_H263HalfPerr4_S(cur, ptn, H263Info->pels, lx4, error);
  AE_min = error[0] + error[1] + error[2] + error[3] ;
  minER1 = error[0];
  minER2 = error[1];
  minER3 = error[2];
  minER4 = error[3];

  for(curY=start_y;curY<=stop_y;curY++){
    for(curX=start_x; curX<=stop_x;curX++) {
      if(curX || curY) {	
        ptnn = ptn + curY*lx2 + curX ;
        sv_H263HalfPerr4_S(cur,ptnn,H263Info->pels,lx4,error);
		AE = error[0] + error[1] + error[2] + error[3] ;
		if(AE < AE_min) {
             AE_min = AE;
             minX = curX;
             minY = curY;
		}
		if(error[0] < minER1) {
             minER1 = error[0];
             minX1  = curX;
             minY1  = curY;
		}
		if(error[1] < minER2) {
             minER2 = error[1];
             minX2  = curX;
             minY2  = curY;
		}
		if(error[2] < minER3) {
             minER3 = error[2];
             minX3  = curX;
             minY3  = curY;
		}
		if(error[3] < minER4) {
             minER4 = error[3];
             minX4  = curX;
             minY4  = curY;
		}
	  }
	}
  }

   /* Store optimal values */
  fr0->min_error = (short)AE_min;
  fr0->x_half = (short)minX;
  fr0->y_half = (short)minY;

  fr1->min_error = (short)minER1;
  fr1->x_half = (short)minX1;
  fr1->y_half = (short)minY1;

  fr2->min_error = (short)minER2;
  fr2->x_half = (short)minX2;
  fr2->y_half = (short)minY2;

  fr3->min_error = (short)minER3;
  fr3->x_half = (short)minX3;
  fr3->y_half = (short)minY3;

  fr4->min_error = (short)minER4;
  fr4->x_half = (short)minX4;
  fr4->y_half = (short)minY4;

  return;
}
#endif

/**********************************************************************
 *
 *	Name:		FindPred
 *	Description:	Find the prediction block
 *	
 *	Input:		position, vector, array for prediction
 *			pointer to previous interpolated luminance,
 *
 *	Side effects:	fills array with prediction
 *
 ***********************************************************************/

static void FindPred(SvH263CompressInfo_t *H263Info,
                     int x, int y, H263_MotionVector *fr, unsigned char *prev,
                     short *pred, int bs, int comp)
{
  register int m, n, m2, n2;
  int new_x, new_y, lx2;
  unsigned char *ptn;

  lx2 = ((H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels)) << 1;

  new_x = ((x + fr->x + ((comp&1)<<3))<<1) + fr->x_half;
  new_y = ((y + fr->y + ((comp&2)<<2))<<1) + fr->y_half;
  new_x += (new_y * lx2) ;

  lx2 = (lx2 << 1) ;
  ptn = prev + new_x ;
  /* Fill pred. data */
#ifndef USE_C
  if(bs == 16) {
     sv_H263Intpix16_S(ptn, pred, lx2, 16) ;
  }
  else {
    for (n = n2 = 0; n < bs; n++, n2 += lx2)
      for (m = m2 = 0; m < bs; m++, m2 += 2)
        /* Find interpolated pixel-value */
        *(pred+m+n*16) = (int) *(ptn + m2 + n2);
  }
#else
  for (n = n2 = 0; n < bs; n++, n2 += lx2)
    for (m = m2 = 0; m < bs; m++, m2 += 2)
      /* Find interpolated pixel-value */
      *(pred+m+n*16) = (int) *(ptn + m2 + n2);
#endif
  return ;
}

/**********************************************************************
 *
 *	Name:		FindPredOBMC
 *	Description:	Find the OBMC prediction block
 *	
 *	Input:		position, vector, array for prediction
 *			pointer to previous interpolated luminance,
 *
 *	Returns:
 *	Side effects:	fills array with prediction
 *
 ***********************************************************************/


static void FindPredOBMC(SvH263CompressInfo_t *H263Info, int x, int y,
                  H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2],
                  unsigned char *prev, short *pred, int comp, int PB)
{
  register int m, n;
  int pc,pt,pb,pr,pl;
  int nxc,nxt,nxb,nxr,nxl;
  int nyc,nyt,nyb,nyr,nyl;
  int xit,xib,xir,xil;
  int yit,yib,yir,yil;
  int vect,vecb,vecr,vecl;
  int c8,t8,l8,r8;
  int ti8,li8,ri8;
  int xmb, ymb, lx;
  int m2, n2, lx2;
  register int *omc, *omt, *omb, *omr, *oml ;

  unsigned char *prevc, *prevt, *prevb, *prevr, *prevl;

  H263_MotionVector *fc,*ft,*fb,*fr,*fl;

  int Mc[8][8] = {
    {4,5,5,5,5,5,5,4},
    {5,5,5,5,5,5,5,5},
    {5,5,6,6,6,6,5,5},
    {5,5,6,6,6,6,5,5},
    {5,5,6,6,6,6,5,5},
    {5,5,6,6,6,6,5,5},
    {5,5,5,5,5,5,5,5},
    {4,5,5,5,5,5,5,4},
  };
  int Mt[8][8] = {
    {1,1,1,1,1,1,1,1},
    {0,0,1,1,1,1,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
  };
  int Mb[8][8] = {
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,1,1,1,1,0,0},
    {1,1,1,1,1,1,1,1},
  };
  int Mr[8][8] = {
    {0,0,0,0,0,0,0,1},
    {0,0,0,0,0,0,1,1},
    {0,0,0,0,0,0,1,1},
    {0,0,0,0,0,0,1,1},
    {0,0,0,0,0,0,1,1},
    {0,0,0,0,0,0,1,1},
    {0,0,0,0,0,0,1,1},
    {0,0,0,0,0,0,0,1},
  };
  int Ml[8][8] = {
    {1,0,0,0,0,0,0,0},
    {1,1,0,0,0,0,0,0},
    {1,1,0,0,0,0,0,0},
    {1,1,0,0,0,0,0,0},
    {1,1,0,0,0,0,0,0},
    {1,1,0,0,0,0,0,0},
    {1,1,0,0,0,0,0,0},
    {1,0,0,0,0,0,0,0},
  };
/*
  int Mt[8][8] = {
    {2,2,2,2,2,2,2,2},
    {1,1,2,2,2,2,1,1},
    {1,1,1,1,1,1,1,1},
    {1,1,1,1,1,1,1,1},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
  };
  int Mb[8][8] = {
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {1,1,1,1,1,1,1,1},
    {1,1,1,1,1,1,1,1},
    {1,1,2,2,2,2,1,1},
    {2,2,2,2,2,2,2,2},
  };
  int Mr[8][8] = {
    {0,0,0,0,1,1,1,2},
    {0,0,0,0,1,1,2,2},
    {0,0,0,0,1,1,2,2},
    {0,0,0,0,1,1,2,2},
    {0,0,0,0,1,1,2,2},
    {0,0,0,0,1,1,2,2},
    {0,0,0,0,1,1,2,2},
    {0,0,0,0,1,1,1,2},
  };
  int Ml[8][8] = {
    {2,1,1,1,0,0,0,0},
    {2,2,1,1,0,0,0,0},
    {2,2,1,1,0,0,0,0},
    {2,2,1,1,0,0,0,0},
    {2,2,1,1,0,0,0,0},
    {2,2,1,1,0,0,0,0},
    {2,2,1,1,0,0,0,0},
    {2,1,1,1,0,0,0,0},
  };
*/

  xmb = x/H263_MB_SIZE+1;
  ymb = y/H263_MB_SIZE+1;

  lx = (H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels);

  c8  = (MV[0][ymb][xmb]->Mode == H263_MODE_INTER4V ? 1 : 0);

  t8  = (MV[0][ymb-1][xmb]->Mode == H263_MODE_INTER4V ? 1 : 0);
  ti8 = (MV[0][ymb-1][xmb]->Mode == H263_MODE_INTRA ? 1 : 0);
  ti8 = (MV[0][ymb-1][xmb]->Mode == H263_MODE_INTRA_Q ? 1 : ti8);

  l8  = (MV[0][ymb][xmb-1]->Mode == H263_MODE_INTER4V ? 1 : 0);
  li8 = (MV[0][ymb][xmb-1]->Mode == H263_MODE_INTRA ? 1 : 0);
  li8 = (MV[0][ymb][xmb-1]->Mode == H263_MODE_INTRA_Q ? 1 : li8);

  r8  = (MV[0][ymb][xmb+1]->Mode == H263_MODE_INTER4V ? 1 : 0);
  ri8 = (MV[0][ymb][xmb+1]->Mode == H263_MODE_INTRA ? 1 : 0);
  ri8 = (MV[0][ymb][xmb+1]->Mode == H263_MODE_INTRA_Q ? 1 : ri8);

  if (PB) ti8 = li8 = ri8 = 0;

  switch (comp+1) {

  case 1:
    vect = (ti8 ? (c8 ? 1 : 0) : (t8 ? 3 : 0));
    yit  = (ti8 ? ymb : ymb - 1);
    xit = xmb;

    vecb = (c8 ? 3 : 0) ; yib = ymb; xib = xmb;

    vecl = (li8 ? (c8 ? 1 : 0) : (l8 ? 2 : 0));
    yil = ymb;
    xil = (li8 ? xmb : xmb-1);

    vecr = (c8 ? 2 : 0) ; yir = ymb; xir = xmb;

    /* edge handling */
    if (ymb == 1) {
      yit = ymb;
      vect = (c8 ? 1 : 0);
    }
    if (xmb == 1) {
      xil = xmb;
      vecl = (c8 ? 1 : 0);
    }
    break;

  case 2:
    vect = (ti8 ? (c8 ? 2 : 0) : (t8 ? 4 : 0));
    yit = (ti8 ? ymb : ymb-1);
    xit = xmb;

    vecb = (c8 ? 4 : 0) ; yib = ymb; xib = xmb;
    vecl = (c8 ? 1 : 0) ; yil = ymb; xil = xmb;

    vecr = (ri8 ? (c8 ? 2 : 0) : (r8 ? 1 : 0));
    yir = ymb;
    xir = (ri8 ? xmb : xmb+1);

    /* edge handling */
    if (ymb == 1) {
      yit = ymb;
      vect = (c8 ? 2 : 0);
    }
    if (xmb == H263Info->pels/16) {
      xir = xmb;
      vecr = (c8 ? 2 : 0);
    }
    break;

  case 3:
    vect = (c8 ? 1 : 0) ; yit = ymb  ; xit = xmb;
    vecb = (c8 ? 3 : 0) ; yib = ymb  ; xib = xmb;

    vecl = (li8 ? (c8 ? 3 : 0) : (l8 ? 4 : 0));
    yil = ymb;
    xil = (li8 ? xmb : xmb-1);

    vecr = (c8 ? 4 : 0) ; yir = ymb  ; xir = xmb;

    /* edge handling */
    if (xmb == 1) {
      xil = xmb;
      vecl = (c8 ? 3 : 0);
    }
    break;

  case 4:
    vect = (c8 ? 2 : 0) ; yit = ymb  ; xit = xmb;
    vecb = (c8 ? 4 : 0) ; yib = ymb  ; xib = xmb;
    vecl = (c8 ? 3 : 0) ; yil = ymb  ; xil = xmb;

    vecr = (ri8 ? (c8 ? 4 : 0) : (r8 ? 3 : 0));
    yir = ymb;
    xir = (ri8 ? xmb : xmb+1);

    /* edge handling */
    if (xmb == H263Info->pels/16) {
      xir = xmb;
      vecr = (c8 ? 4 : 0);
    }
    break;

  default:
    _SlibDebug(_WARN_, printf("Illegal block number in FindPredOBMC (pred.c)\n") );
    return;
    break;
  }

  fc = MV[c8 ? comp + 1: 0][ymb][xmb];

  ft = MV[vect][yit][xit];
  fb = MV[vecb][yib][xib];
  fr = MV[vecr][yir][xir];
  fl = MV[vecl][yil][xil];

  nxc = 2*x + ((comp&1)<<4); nyc = 2*y + ((comp&2)<<3);
  nxt = nxb = nxr = nxl = nxc;
  nyt = nyb = nyr = nyl = nyc;

  nxc += 2*fc->x + fc->x_half; nyc += 2*fc->y + fc->y_half;
  nxt += 2*ft->x + ft->x_half; nyt += 2*ft->y + ft->y_half;
  nxb += 2*fb->x + fb->x_half; nyb += 2*fb->y + fb->y_half;
  nxr += 2*fr->x + fr->x_half; nyr += 2*fr->y + fr->y_half;
  nxl += 2*fl->x + fl->x_half; nyl += 2*fl->y + fl->y_half;

#if 1
  /* Fill pred. data */
  lx2 = lx << 1 ;
  omc = &Mc[0][0] ; omt = &Mt[0][0] ; omb = &Mb[0][0] ;
  omr = &Mr[0][0] ; oml = &Ml[0][0] ;

  prevc = prev + nxc + nyc*lx2;
  prevt = prev + nxt + nyt*lx2;
  prevb = prev + nxb + nyb*lx2;
  prevr = prev + nxr + nyr*lx2;
  prevl = prev + nxl + nyl*lx2;

  lx2 <<= 1;
  for (n = n2 = 0; n < 4; n++, n2+=lx2) {

    /* Find interpolated pixel-value */
    for (m = 0, m2=n2; m < 4; m++, m2+=2) {
      pc = *(prevc + m2) * (*omc++);
      pt = *(prevt + m2) << (*omt++);
	  pl = *(prevl + m2) << (*oml++);

      *(pred + m + (n<<4)) = (pc+pt+pl+4)>>3;
    }	
	omr += 4;
	for (m = 4; m < 8; m++, m2+=2) {
      pc = *(prevc + m2) * (*omc++);
      pt = *(prevt + m2) << (*omt++);
	  pr = *(prevr + m2) << (*omr++);

      *(pred + m + (n<<4)) = (pc+pt+pr+4)>>3;
    }	
	oml += 4;
  }
  omb += 32;

  for (n = 4; n < 8; n++, n2+=lx2) {

    /* Find interpolated pixel-value */
    for (m = 0, m2=n2; m < 4; m++, m2+=2) {
      pc = *(prevc + m2) * (*omc++);
	  pb = *(prevb + m2) << (*omb++);
	  pl = *(prevl + m2) << (*oml++);

      *(pred + m + (n<<4)) = (pc+pb+pl+4)>>3;
    }	
	omr += 4;
	for (m = 4; m < 8; m++, m2+=2) {
      pc = *(prevc + m2) * (*omc++);
	  pb = *(prevb + m2) << (*omb++);
	  pr = *(prevr + m2) << (*omr++);

      *(pred + m + (n<<4)) = (pc+pb+pr+4)>>3;
    }	
	oml += 4;
  }
#else /* original */
  /* Fill pred. data */
  lx2 = lx << 1 ;
  omc = &Mc[0][0] ; omt = &Mt[0][0] ; omb = &Mb[0][0] ;
  omr = &Mr[0][0] ; oml = &Ml[0][0] ;

  for (n = n2 = 0; n < 8; n++,n2+=(lx2<<1)) {
    for (m = 0, m2=n2; m < 8; m++, m2 += 2) {
      /* Find interpolated pixel-value */
      pc = *(prev + nxc + m2 + nyc*lx2) * (*omc++);
      pt = *(prev + nxt + m2 + nyt*lx2) * (*omt++);
	  pb = *(prev + nxb + m2 + nyb*lx2) * (*omb++);
	  pr = *(prev + nxr + m2 + nyr*lx2) * (*omr++);
	  pl = *(prev + nxl + m2 + nyl*lx2) * (*oml++);

      *(pred + m + n*16) = (pc+pt+pb+pr+pl+4)>>3;
    }	
  }
#endif
  return;
}


/**********************************************************************
 *
 *	Name:		ReconMacroblock_P
 *	Description:	Reconstructs MB after quantization for P_images
 *	
 *	Input:		pointers to current and previous image,
 *			current slice and mb, and which mode
 *			of prediction has been used
 *	Returns:
 *	Side effects:
 *
 ***********************************************************************/
void sv_H263MBReconP(SvH263CompressInfo_t *H263Info,
                     H263_PictImage *prev_image, unsigned char *prev_ipol,
                     H263_MB_Structure *diff, int x_curr, int y_curr,
                     H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int PB,
                     H263_MB_Structure *recon_data)
{
  H263_MotionVector *fr0,*fr1,*fr2,*fr3,*fr4;
  short pred[16][16];
  int dx, dy, sum;
#ifdef USE_C
  int i,j;
#endif

  fr0 = MV[0][y_curr/H263_MB_SIZE+1][x_curr/H263_MB_SIZE+1];

  if (H263Info->advanced) {
    if (fr0->Mode == H263_MODE_INTER || fr0->Mode == H263_MODE_INTER_Q) {
      FindPredOBMC(H263Info, x_curr, y_curr, MV, prev_ipol, &pred[0][0], 0, PB);
      FindPredOBMC(H263Info, x_curr, y_curr, MV, prev_ipol, &pred[0][8], 1, PB);
      FindPredOBMC(H263Info, x_curr, y_curr, MV, prev_ipol, &pred[8][0], 2, PB);
      FindPredOBMC(H263Info, x_curr, y_curr, MV, prev_ipol, &pred[8][8], 3, PB);

#ifndef USE_C
      sv_H263Add256_S(&(diff->lum[0][0]),&(pred[0][0]));
#else
      for (j = 0; j < H263_MB_SIZE; j++)
  	    for (i = 0; i < H263_MB_SIZE; i++)
	       diff->lum[j][i] += pred[j][i];
#endif

      dx = 2*fr0->x + fr0->x_half;
      dy = 2*fr0->y + fr0->y_half;
      dx = ( dx % 4 == 0 ? dx >> 1 : (dx>>1)|1 );
      dy = ( dy % 4 == 0 ? dy >> 1 : (dy>>1)|1 );
      ReconChromBlock_P(H263Info, x_curr, y_curr, dx, dy, prev_image, diff);
    }
    else if (fr0->Mode == H263_MODE_INTER4V) { /* Inter 8x8 */

      FindPredOBMC(H263Info, x_curr, y_curr, MV, prev_ipol, &pred[0][0], 0, PB);
      FindPredOBMC(H263Info, x_curr, y_curr, MV, prev_ipol, &pred[0][8], 1, PB);
      FindPredOBMC(H263Info, x_curr, y_curr, MV, prev_ipol, &pred[8][0], 2, PB);
      FindPredOBMC(H263Info, x_curr, y_curr, MV, prev_ipol, &pred[8][8], 3, PB);

#ifndef USE_C
      sv_H263Add256_S(&(diff->lum[0][0]),&(pred[0][0]));
#else
      for (j = 0; j < H263_MB_SIZE; j++)
	     for (i = 0; i < H263_MB_SIZE; i++)
	        diff->lum[j][i] += pred[j][i];
#endif

      fr1 = MV[1][y_curr/H263_MB_SIZE+1][x_curr/H263_MB_SIZE+1];
      fr2 = MV[2][y_curr/H263_MB_SIZE+1][x_curr/H263_MB_SIZE+1];
      fr3 = MV[3][y_curr/H263_MB_SIZE+1][x_curr/H263_MB_SIZE+1];
      fr4 = MV[4][y_curr/H263_MB_SIZE+1][x_curr/H263_MB_SIZE+1];

      sum = 2*fr1->x + fr1->x_half + 2*fr2->x + fr2->x_half +
	2*fr3->x + fr3->x_half + 2*fr4->x + fr4->x_half ;
      dx = sign(sum)*(roundtab[abs(sum)%16] + (abs(sum)/16)*2);

      sum = 2*fr1->y + fr1->y_half + 2*fr2->y + fr2->y_half +
	2*fr3->y + fr3->y_half + 2*fr4->y + fr4->y_half;
      dy = sign(sum)*(roundtab[abs(sum)%16] + (abs(sum)/16)*2);

      ReconChromBlock_P(H263Info, x_curr, y_curr, dx, dy, prev_image, diff);
    }
  }
  else {
    if (fr0->Mode == H263_MODE_INTER || fr0->Mode == H263_MODE_INTER_Q) {
      /* Inter 16x16 */
      ReconLumBlock_P(H263Info, x_curr,y_curr,fr0,prev_ipol,&diff->lum[0][0],16,0);

      dx = 2*fr0->x + fr0->x_half;
      dy = 2*fr0->y + fr0->y_half;
      dx = ( dx % 4 == 0 ? dx >> 1 : (dx>>1)|1 );
      dy = ( dy % 4 == 0 ? dy >> 1 : (dy>>1)|1 );
      ReconChromBlock_P(H263Info, x_curr, y_curr, dx, dy, prev_image, diff);
    }
  }

  memcpy(recon_data, diff, sizeof(H263_MB_Structure));
  return ;
}

/**********************************************************************
 *
 *	Name:		ReconLumBlock_P
 *	Description:	Reconstructs one block of luminance data
 *	
 *	Input:		position, vector-data, previous image, data-block
 *	Returns:
 *	Side effects:	reconstructs data-block
 *
 ***********************************************************************/
static void ReconLumBlock_P(SvH263CompressInfo_t *H263Info,
                            int x, int y, H263_MotionVector *fr,
                            unsigned char *prev, short *data, int bs, int comp)
{
  int x1, y1, lx2;
  unsigned char *ptn ;
#ifdef USE_C
  int m,n;
#endif

  lx2 = ((H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels)) << 1;

  x1 = ((x + fr->x) << 1) + fr->x_half + ((comp&1)<<4) ;
  y1 = ((y + fr->y) << 1) + fr->y_half + ((comp&2)<<3);
  x1 += (y1 * lx2) ;

  ptn = prev + x1 ;

#ifndef USE_C
  sv_H263Add16Skp_S(ptn, data, (2 * lx2)) ;
#else
/* int m, n; */
  lx2 = (lx2 <<1) - (bs << 1) ;	
  for (n = 0; n < bs; n++, ptn += lx2)
    for (m = 0; m < bs; m++, ptn += 2)
       *(data++) += (short)(*ptn);
#endif
  return;
}

/**********************************************************************
 *
 *	Name:		ReconChromBlock_P
 *	Description:   	Reconstructs chrominance of one block in P frame
 *	
 *	Input:	      	position, vector-data, previous image, data-block
 *	Returns:       	
 *	Side effects:	reconstructs data-block
 *
 ***********************************************************************/

#ifndef USE_C
static void ReconChromBlock_P(SvH263CompressInfo_t *H263Info,
                              int x_curr, int y_curr, int dx, int dy,
                              H263_PictImage *prev, H263_MB_Structure *data)
{
  int ofy, lx;
  int xh, yh, ofyy, ydiff;
  register short *ptnr, *ptnb;
  unsigned char *preCr, *preCb;

  lx = (H263Info->mv_outside_frame ? H263Info->pels/2 + (H263Info->long_vectors?32:16) : H263Info->pels/2);

  xh = dx & 1;
  yh = dy & 1;

  ptnr = &(data->Cr[0][0]) ;
  ptnb = &(data->Cb[0][0]) ;

  ydiff = lx - 8 ;

  ofy = ((y_curr>>1) + (dy >> 1))*lx + (x_curr>>1) + (dx >> 1) ;
  preCr = prev->Cr + ofy;
  preCb = prev->Cb + ofy ;

  if (!xh && !yh) {
    sv_H263Add_S(preCr, ptnr, preCb, ptnb, lx);
  }
  else if (!xh && yh) {
    ofyy = yh * lx ;
    sv_H263Avg2Add_S(preCr + ofyy, preCr, ptnr, preCb + ofyy, preCb, ptnb, lx);
  }
  else if (xh && !yh) {
    sv_H263Avg2Add_S(preCr + xh, preCr, ptnr, preCb + xh, preCb, ptnb, lx);
  }
  else { /* xh && yh */
    ofyy = yh * lx ;
    sv_H263Avg4Add_S(preCr,preCr+xh,preCr+ofyy,preCr+xh+ofyy,ptnr,lx);
    sv_H263Avg4Add_S(preCb,preCb+xh,preCb+ofyy,preCb+xh+ofyy,ptnb,lx);
  }
  return;
}
#else
static void ReconChromBlock_P(SvH263CompressInfo_t *H263Info,
                              int x_curr, int y_curr, int dx, int dy,
                              H263_PictImage *prev, H263_MB_Structure *data)
{
  register int m,n;
  int ofy, lx;
  int xh, yh, ofyy, ydiff;
  register short *ptnr, *ptnb;
  unsigned char *preCr, *preCb;

  lx = (H263Info->mv_outside_frame ? H263Info->pels/2 + (H263Info->long_vectors?32:16) : H263Info->pels/2);

  xh = dx & 1;
  yh = dy & 1;

  ptnr = &(data->Cr[0][0]) ;
  ptnb = &(data->Cb[0][0]) ;

  ydiff = lx - 8 ;

  ofy = ((y_curr>>1) + (dy >> 1))*lx + (x_curr>>1) + (dx >> 1) ;
  preCr = prev->Cr + ofy;
  preCb = prev->Cb + ofy ;

  if (!xh && !yh) {
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	     *(ptnr++) += (short) *(preCr++);
		 *(ptnb++) += (short) *(preCb++);
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };
  }
  else if (!xh && yh) {
    ofyy = yh * lx ;
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	    *(ptnr++) += (short)(*(preCr + ofyy) + *(preCr++) + 1)>>1;
	    *(ptnb++) += (short)(*(preCb + ofyy) + *(preCb++) + 1)>>1;
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };
  }
  else if (xh && !yh) {
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	    *(ptnr++) += (short)(*(preCr + xh) + *(preCr++) + 1)>>1;
	    *(ptnb++) += (short)(*(preCb + xh) + *(preCb++) + 1)>>1;
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };
  }
  else { /* xh && yh */
    ofyy = yh * lx ;
	n = 8 ;
    while(n--){
	  m = 8 ;
      while(m--) {
	    *(ptnr++) += (short)(*(preCr + xh) + *(preCr + ofyy) +
 	                       *(preCr + xh + ofyy) + *(preCr++) + 2)>>2;
	    *(ptnb++) += (short)(*(preCb + xh) + *(preCb + ofyy)+
	                       *(preCb + xh + ofyy) + *(preCb++) + 2)>>2;
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };
  }
  return;
}
#endif

/**********************************************************************
 *
 *	Name:		FindChromBlock_P
 *	Description:   	Finds chrominance of one block in P frame
 *	
 *	Input:	      	position, vector-data, previous image, data-block
 *
 ***********************************************************************/

#ifndef USE_C
static void FindChromBlock_P(SvH263CompressInfo_t *H263Info, int x_curr, int y_curr, int dx, int dy,
                             H263_PictImage *prev, H263_MB_Structure *data)
{
  register int m,n;
  int ofy, lx;
  int xh, yh, ofyy, ydiff;

  register short *ptnr, *ptnb;
  register unsigned char *preCr, *preCb;

  lx = (H263Info->mv_outside_frame ? H263Info->pels/2 + (H263Info->long_vectors?32:16) : H263Info->pels/2);

  xh = dx & 1;
  yh = dy & 1;

  ptnr = &(data->Cr[0][0]) ;
  ptnb = &(data->Cb[0][0]) ;

  ydiff = lx - 8 ;

  ofy = ( (y_curr>>1) + (dy>>1)) * lx + (x_curr>>1) + (dx>>1) ;
  preCr = prev->Cr + ofy;
  preCb = prev->Cb + ofy ;

  if (!xh && !yh)     sv_H263Cpy_S(preCr, ptnr, preCb, ptnb, lx);
  else if (!xh && yh) {
    ofyy = yh * lx ;
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	    *(ptnr++) = (short)(*(preCr + ofyy) + *(preCr++) + 1)>>1;
		*(ptnb++) = (short)(*(preCb + ofyy) + *(preCb++) + 1)>>1;
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };

  }
  else if (xh && !yh) {
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	    *(ptnr++) = (short)(*(preCr + xh) + *(preCr++) + 1)>>1;
	    *(ptnb++) = (short)(*(preCb + xh) + *(preCb++) + 1)>>1;
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };
  }
  else { /* xh && yh */
    ofyy = yh * lx ;
    sv_H263Avg4Cpy_S(preCr,preCr+xh,preCr+ofyy,preCr+xh+ofyy,ptnr,lx);
    sv_H263Avg4Cpy_S(preCb,preCb+xh,preCb+ofyy,preCb+xh+ofyy,ptnb,lx);
  }
  return;
}

#else
void FindChromBlock_P(SvH263CompressInfo_t *H263Info, int x_curr, int y_curr, int dx, int dy,
		      H263_PictImage *prev, H263_MB_Structure *data)
{
  register int m,n;
  int ofy, lx;
  int xh, yh, ofyy, ydiff;

  register short *ptnr, *ptnb;
  register unsigned char *preCr, *preCb;

  lx = (H263Info->mv_outside_frame ? H263Info->pels/2 + (H263Info->long_vectors?32:16) : H263Info->pels/2);

  xh = dx & 1;
  yh = dy & 1;

  ptnr = &(data->Cr[0][0]) ;
  ptnb = &(data->Cb[0][0]) ;

  ydiff = lx - 8 ;

  ofy = ( (y_curr>>1) + (dy>>1)) * lx + (x_curr>>1) + (dx>>1) ;
  preCr = prev->Cr + ofy;
  preCb = prev->Cb + ofy ;

  if (!xh && !yh) {
    n = 8 ;
    while(n--) {
      m = 8;
      while(m--) {
	     *(ptnr++) = (short) *(preCr++);
		 *(ptnb++) = (short) *(preCb++);
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };
  }
  else if (!xh && yh) {
    ofyy = yh * lx ;
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	    *(ptnr++) = (short)(*(preCr + ofyy) + *(preCr++) + 1)>>1;
	    *(ptnb++) = (short)(*(preCb + ofyy) + *(preCb++) + 1)>>1;
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };

  }
  else if (xh && !yh) {
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	    *(ptnr++) = (short)(*(preCr + xh) + *(preCr++) + 1)>>1;
	    *(ptnb++) = (short)(*(preCb + xh) + *(preCb++) + 1)>>1;
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };
  }
  else { /* xh && yh */
    ofyy = yh * lx ;
	n = 8 ;
    while(n--){
	  m = 8 ;
      while(m--) {
	    *(ptnr++) = (short)(*(preCr + xh) + *(preCr + ofyy) +
	                      *(preCr + xh + ofyy) + *(preCr++) + 2)>>2;
	    *(ptnb++) = (short)(*(preCb + xh) + *(preCb + ofyy)+
	                      *(preCb + xh + ofyy) + *(preCb++) + 2)>>2;
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };
  }
  return;
}
#endif
/**********************************************************************
 *
 *	Name:		ChooseMode
 *	Description:    chooses coding mode
 *	
 *	Input:	        pointer to original fram, min_error from
 *                      integer pel search, DQUANT
 *	Returns:        1 for Inter, 0 for Intra
 *
 ***********************************************************************/

#ifndef USE_C
int sv_H263ChooseMode(SvH263CompressInfo_t *H263Info, unsigned char *curr,
					  int x_pos, int y_pos, int min_SAD, int *VARmb)
{
  x_pos += (y_pos*H263Info->pels) ;

  min_SAD -= 500;
  if((*VARmb=sv_H263VAR_S((curr+x_pos), H263Info->pels, min_SAD)) < min_SAD)
	  return H263_MODE_INTRA;
  else  return H263_MODE_INTER;
}
#else
int sv_H263ChooseMode(SvH263CompressInfo_t *H263Info,
                      unsigned char *curr, int x_pos, int y_pos, int min_SAD)
{
  register int m, n;
  int xdiff = H263Info->pels - H263_MB_SIZE;
  unsigned char *in;
  int MB_mean = 0, A = 0;

  x_pos = y_pos*H263Info->pels + x_pos ;
  in = curr + x_pos;

  m = H263_MB_SIZE;
  while (m--) {
    n = H263_MB_SIZE;
    while (n--) MB_mean += *in++;
    in += xdiff ;
  };
  MB_mean /= (H263_MB_SIZE*H263_MB_SIZE);

  in = curr + x_pos;
  m = H263_MB_SIZE;
  while (m--) {

    n = H263_MB_SIZE;
    while (n--) A += abs( *(in++) - MB_mean );
    in += xdiff ;
  };

  if (A < (min_SAD - 500))
    return H263_MODE_INTRA;
  else
    return H263_MODE_INTER;
}
#endif

int sv_H263ModifyMode(int Mode, int dquant)
{

  if (Mode == H263_MODE_INTRA) {
    if(dquant!=0)
      return H263_MODE_INTRA_Q;
    else
      return H263_MODE_INTRA;
  }
  else{
    if(dquant!=0)
      return H263_MODE_INTER_Q;
    else
      return Mode;
  }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\me3.c ===
/* File: sv_h263_me3.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/


#include "sv_h263.h"
#include "proto.h"
#ifndef USE_C
#include "perr.h"
#endif

#define THREEBYEIGHT .375
#define THREEBYFOUR .75
#define MINUSONEBYEIGHT -0.125

/**********************************************************************
 *
 *	Name:		MotionEstimation
 *	Description:	Estimate all motionvectors for one MB
 *	
 *	Input:		pointers to current an previous image,
 *			pointers to current slice and current MB
 *	Returns:	
 *	Side effects:	motion vector information in MB changed
 *
 ***********************************************************************/


void sv_H263ME_2levels_7_polint(SvH263CompressInfo_t *H263Info,
                                unsigned char *curr, unsigned char *prev, int x_curr,
                                int y_curr, int xoff, int yoff, int seek_dist,
                                H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0)
{

  int Min_FRAME[5];
  H263_MotionVector MVFrame[5];
  unsigned char *aa,*ii;
  unsigned char *adv_search_area = NULL, *zero_area = NULL;
  int sxy,i,k,j,l;
  int ihigh,ilow,jhigh,jlow,h_length,v_length;
  int adv_ihigh,adv_ilow,adv_jhigh,adv_jlow,adv_h_length,adv_v_length;
  int xmax,ymax,block,sad,lx;
  int adv_x_curr, adv_y_curr,xvec,yvec;

  unsigned char *act_block_subs2, *search_area_subs2, *adv_search_area_subs2;
  int h_lenby2,v_lenby2,adv_h_lenby2,adv_v_lenby2;
  int xlevel1,ylevel1,sxylevel1;
  int xlevel1_block[4], ylevel1_block[4];
  /*
  int level0_x_curr,level0_y_curr,sxylevel0;
*/
  int start_x, start_y, stop_x, stop_y, new_x, new_y;
  int AE[5];
  H263_Point search[5];
  int p1,p2,p3,p4;
  int AE_minx, AE_miny, min_posx, min_posy;


  xmax = H263Info->pels;
  ymax = H263Info->lines;
  sxy = seek_dist;
  if (!H263Info->long_vectors) {
    /* Maximum normal search range centered around _zero-vector_ */
    sxy = mmin(15, sxy);
  }
  else {
    /* Maximum extended search range centered around _predictor_ */
    sxy = mmin(15 - (2*H263_DEF_8X8_WIN+1), sxy);

    /* NB! */

    /* It is only possible to transmit motion vectors within
       a 15x15 window around the motion vector predictor
       for any 8x8 or 16x16 block */

    /* The reason for the search window's reduction above with
       2*DEF_8X8_WIN+1 is that the 8x8 search may change the MV
       predictor for some of the blocks within the macroblock. When we
       impose the limitation above, we are sure that any 8x8 vector we
       might find is possible to transmit */

    /* We have found that with OBMC, DEF_8X8_WIN should be quite small
       for two reasons: (i) a good filtering effect, and (ii) not too
       many bits used for transferring the vectors. As can be seen
       above this is also useful to avoid a large limitation on the MV
       search range */

    /* It is possible to make sure the motion vectors found are legal
       in other less limiting ways than above, but this would be more
       complicated as well as time-consuming. Any good suggestions for
       improvement is welcome, though */
#ifdef USE_C
    xoff = mmin(16,mmax(-16,xoff));
    yoff = mmin(16,mmax(-16,yoff));
#else
    xoff = sv_H263lim_S(xoff,-16,16);
    yoff = sv_H263lim_S(yoff,-16,16);
#endif

    /* in case xoff or yoff is odd */
    xoff= 2 * ((xoff)>>1);
    yoff= 2 * ((yoff)>>1);

    /* There is no need to check if (xoff + x_curr) points outside
       the picture, since the Extended Motion Vector Range is
       always used together with the Unrestricted MV mode */
  }


  lx = (H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels);

  ilow = x_curr + xoff - sxy;
  ihigh = x_curr + xoff + sxy;

  jlow = y_curr + yoff - sxy;
  jhigh = y_curr + yoff + sxy;

  if (!H263Info->mv_outside_frame) {
    if (ilow<0) ilow = 0;
    if (ihigh>xmax-16) ihigh = xmax-16;
    if (jlow<0) jlow = 0;
    if (jhigh>ymax-16) jhigh = ymax-16;
  }

  h_length = ihigh - ilow + 16;
  v_length = jhigh - jlow + 16;

  /* subsampled version for ME level 1 */
  h_lenby2 = (h_length-1)>>1;
  v_lenby2 = (v_length-1)>>1;
  act_block_subs2 = sv_H263LoadSubs2Area(curr, x_curr, y_curr, 8, 8, H263Info->pels);
  search_area_subs2 = sv_H263LoadSubs2Area(prev, ilow, jlow, h_lenby2, v_lenby2, lx);

  for (k = 0; k < 5; k++) {
    Min_FRAME[k] = INT_MAX;
    MVFrame[k].x = 0;
    MVFrame[k].y = 0;
    MVFrame[k].x_half = 0;
    MVFrame[k].y_half = 0;
  }

  /* match for zero (or [xoff,yoff]) motion vector on subsampled images */
  ii = search_area_subs2 + ((x_curr+xoff-ilow)>>1) + ((y_curr+yoff-jlow)>>1)*h_lenby2;
#ifdef USE_C
  Min_FRAME[0] = sv_H263MySADBlock(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]);
#else
  Min_FRAME[0] = sv_H263PError8x8_S(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]);
#endif
  MVFrame[0].x = (short)xoff;
  MVFrame[0].y = (short)yoff;

  /*** Spiral search (+-7) on subsampled images ***/

  sxylevel1 = (sxy-1)>>1;

  for (l = 1; l <= sxylevel1; l++) {
    i = x_curr + xoff - 2*l;
    j = y_curr + yoff - 2*l;
    for (k = 0; k < 8*l; k++) {
      if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {

	/* 8x8 integer pel MV */
	ii = search_area_subs2 + ((i-ilow)>>1) + ((j-jlow)>>1)*h_lenby2;
#ifdef USE_C
	sad = sv_H263MySADBlock(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]);
#else
	sad = sv_H263PError8x8_S(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]);
#endif
	if (sad < Min_FRAME[0]) {
	  MVFrame[0].x = i - x_curr;
	  MVFrame[0].y = j - y_curr;
	  Min_FRAME[0] = sad;
	}

      }
      if      (k<2*l) i+=2;
      else if (k<4*l) j+=2;
      else if (k<6*l) i-=2;
      else            j-=2;
    }
  }

  /* motion vectors after level1 */
  xlevel1=MVFrame[0].x;
  ylevel1=MVFrame[0].y;

  /* reset */
  Min_FRAME[0] = INT_MAX;
  MVFrame[0].x = 0;
  MVFrame[0].y = 0;

  /* Zero vector search*/
  if (x_curr-ilow         < 0        || y_curr-jlow         < 0        ||
      x_curr-ilow+H263_MB_SIZE > h_length || y_curr-jlow+H263_MB_SIZE > v_length) {
    /* in case the zero vector is outside the loaded area in search_area */

    zero_area = sv_H263LoadSubs2Area(prev, x_curr, y_curr, 8, 8, lx);
#ifdef USE_C
    *SAD_0 = 4*sv_H263MySADBlock(zero_area, act_block_subs2, 8, 8, Min_FRAME[0]) -
       H263_PREF_NULL_VEC;
#else
    *SAD_0 = 4*sv_H263PError8x8_S(zero_area, act_block_subs2, 8, 8, Min_FRAME[0]) -
       H263_PREF_NULL_VEC;
#endif
    ScFree(zero_area);
  }
  else {
    /* the zero vector is within search_area */

    ii = search_area_subs2 + ((x_curr-ilow)>>1) + ((y_curr-jlow)>>1)*h_lenby2;
#ifdef USE_C
    *SAD_0 = 4*sv_H263MySADBlock(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]) -
       H263_PREF_NULL_VEC;
#else
    *SAD_0 = 4*sv_H263PError8x8_S(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]) -
       H263_PREF_NULL_VEC;
#endif	
  }

  /*** +-1 search on full-resolution images done by polynomial interpolation ***/

  start_x = -1;
  stop_x = 1;
  start_y = -1;
  stop_y = 1;

  new_x = x_curr + xlevel1;
  new_y = y_curr + ylevel1;

  /* Make sure that no addressing is outside the frame */
  if (!H263Info->mv_outside_frame) {
    if ((new_x) <= (ilow+1))
      start_x = 0;
    if ((new_y) <= (jlow+1))
      start_y = 0;
    if ((new_x) >= (ihigh-1))
      stop_x = 0;
    if ((new_y) >= (jhigh-1))
      stop_y = 0;
  }

 /*     1     */
 /*   2 0 3   */
 /*     4     */

  search[0].x = 0; 		search[0].y = 0;
  search[1].x = 0; 		search[1].y = (short)start_y;
  search[2].x = (short)start_x;     	search[2].y = 0;
  search[3].x = (short)stop_x;     	search[3].y = 0;
  search[4].x = 0; 	       	search[4].y = (short)stop_y;

  for (l = 0; l < 5 ; l++) {
    AE[l] = INT_MAX;
    i =  new_x + 2*search[l].x;
    j =  new_y + 2*search[l].y;
	/* 8x8 integer pel MV */
	ii = search_area_subs2 + ((i-ilow)>>1) + ((j-jlow)>>1)*h_lenby2;
#ifdef USE_C
	AE[l] = sv_H263MySADBlock(ii, act_block_subs2, h_lenby2, 8, INT_MAX);
#else
	AE[l] = sv_H263PEr8_init_S(ii, act_block_subs2, h_lenby2, 8);
#endif
  }

  /* 1D polynomial interpolation along x and y respectively */

  AE_minx = AE[0];
  min_posx = 0;

  p2 = (int)( THREEBYEIGHT * (double) AE[2]
            + THREEBYFOUR * (double) AE[0]
            + MINUSONEBYEIGHT * (double) AE[3]);

  if (p2<AE_minx) {
    AE_minx = p2;
    min_posx = 2;
  }

  p3 = (int)(MINUSONEBYEIGHT * (double) AE[2]
           + THREEBYFOUR * (double) AE[0]
           + THREEBYEIGHT * (double) AE[3]);

  if (p3<AE_minx) {
    AE_minx = p3;
    min_posx = 3;
  }

  AE_miny = AE[0];
  min_posy = 0;

  p1 = (int)(THREEBYEIGHT * (double) AE[1]
           + THREEBYFOUR * (double) AE[0]
           + MINUSONEBYEIGHT * (double) AE[4]);

  if (p1<AE_miny) {
    AE_miny = p1;
    min_posy = 1;
  }

  p4 = (int)(MINUSONEBYEIGHT * (double) AE[1]
           + THREEBYFOUR * (double) AE[0]
           + THREEBYEIGHT * (double) AE[4]);

  if (p4<AE_miny) {
    AE_miny = p4;
    min_posy = 4;
  }

  /* Store optimal values */
  Min_FRAME[0] = (AE_minx<AE_miny ? 4*AE_minx : 4*AE_miny);
  MVFrame[0].x = new_x + search[min_posx].x - x_curr;
  MVFrame[0].y = new_y + search[min_posy].y - y_curr;

  if (H263Info->advanced) {

    /* Center the 8x8 search around the 16x16 vector.  This is
       different than in TMN5 where the 8x8 search is also a full
       search. The reasons for this is: (i) it is faster, and (ii) it
       generally gives better results because of a better OBMC
       filtering effect and less bits spent for vectors, and (iii) if
       the Extended MV Range is used, the search range around the
       motion vector predictor will be less limited */

    xvec = MVFrame[0].x;
    yvec = MVFrame[0].y;

    if (!H263Info->long_vectors) {
      if (xvec > 15 - H263_DEF_8X8_WIN) { xvec =  15 - H263_DEF_8X8_WIN ;}
      if (yvec > 15 - H263_DEF_8X8_WIN) { yvec =  15 - H263_DEF_8X8_WIN ;}

      if (xvec < -15 + H263_DEF_8X8_WIN) { xvec =  -15 + H263_DEF_8X8_WIN ;}
      if (yvec < -15 + H263_DEF_8X8_WIN) { yvec =  -15 + H263_DEF_8X8_WIN ;}
    }

    adv_x_curr = x_curr  + xvec;
    adv_y_curr = y_curr  + yvec;

    sxy = H263_DEF_8X8_WIN;

    adv_ilow = adv_x_curr - sxy;
    adv_ihigh = adv_x_curr + sxy;

    adv_jlow = adv_y_curr - sxy;
    adv_jhigh = adv_y_curr + sxy;

    adv_h_length = adv_ihigh - adv_ilow + 16;
    adv_v_length = adv_jhigh - adv_jlow + 16;

/*  BUG
    adv_h_lenby2 = (adv_h_length-1)>>1;
    adv_v_lenby2 = (adv_v_length-1)>>1;
*/
    adv_h_lenby2 = (adv_h_length)>>1;
    adv_v_lenby2 = (adv_v_length)>>1;
/*  must load entire macroblock
    adv_search_area_subs2 = sv_H263LoadSubs2Area(prev, adv_ilow, adv_jlow,
			       adv_h_lenby2, adv_v_lenby2, lx);
*/
    adv_search_area_subs2 = sv_H263LoadSubs2Area(prev, adv_ilow, adv_jlow,
			       adv_h_length, adv_v_length, lx);

    for (block = 0; block < 4; block++) {
      ii = adv_search_area_subs2 + ((adv_x_curr-adv_ilow)>>1) + ((block&1)<<2) +
	(((adv_y_curr-adv_jlow)>>1) + ((block&2)<<1) )*adv_h_lenby2;
      aa = act_block_subs2 + ((block&1)<<2) + ((block&2)<<1)*8;
/*
      Min_FRAME[block+1] = sv_H263MySADSubBlock(ii,aa,adv_h_lenby2,Min_FRAME[block+1]);
*/
      Min_FRAME[block+1] = sv_H263MySADSubBlock(ii,aa,adv_h_length,Min_FRAME[block+1]);

      MVFrame[block+1].x = MVFrame[0].x;
      MVFrame[block+1].y = MVFrame[0].y;
    }

    /* Spiral search */
    sxylevel1 = (sxy-1)>>1;

    for (l = 1; l <= sxylevel1; l++) {
      i = adv_x_curr - 2*l;
      j = adv_y_curr - 2*l;
      for (k = 0; k < 8*l; k++) {
	if (i>=adv_ilow && i<=adv_ihigh && j>=adv_jlow && j<=adv_jhigh) {
	
	  /* 8x8 integer pel MVs */
	  for (block = 0; block < 4; block++) {
	    ii = adv_search_area_subs2 + ((i-adv_ilow)>>1) + ((block&1)<<2) +
	      (((j-adv_jlow)>>1) + ((block&2)<<1) )*adv_h_lenby2;
	    aa = act_block_subs2 + ((block&1)<<2) + ((block&2)<<1)*8;
/*
	    sad = sv_H263MySADSubBlock(ii, aa, adv_h_lenby2, Min_FRAME[block+1]);
*/
	    sad = sv_H263MySADSubBlock(ii, aa, adv_h_length, Min_FRAME[block+1]);

	    if (sad < Min_FRAME[block+1]) {
	      MVFrame[block+1].x = i - x_curr;
	      MVFrame[block+1].y = j - y_curr;
	      Min_FRAME[block+1] = sad;
	    }
	  }
	
	}
	if      (k<2*l) i++;
	else if (k<4*l) j++;
	else if (k<6*l) i--;
	else            j--;
      }
    }

    for (block = 0; block < 4; block++) {
      xlevel1_block[block] = MVFrame[block+1].x;
      ylevel1_block[block] = MVFrame[block+1].y;

      /* reset */
      Min_FRAME[block+1] = INT_MAX;
      MVFrame[block+1].x = 0;
      MVFrame[block+1].y = 0;
    }

    /* +-1 search on full resolution on full-resolution images */
    /* by polynomial interpolation */

    for (block = 0; block < 4; block++) {
      start_x = -1;
      stop_x = 1;
      start_y = -1;
      stop_y = 1;

      adv_x_curr = x_curr + xlevel1_block[block];
      adv_y_curr = y_curr + ylevel1_block[block];

      /*     1     */
      /*   2 0 3   */
      /*     4     */

      search[0].x = 0; 		search[0].y = 0;
      search[1].x = 0; 		search[1].y = (short)start_y;
      search[2].x = (short)start_x;    search[2].y = 0;
      search[3].x = (short)stop_x;     search[3].y = 0;
      search[4].x = 0; 	       	search[4].y = (short)stop_y;

      for (l = 0; l < 5 ; l++) {
	AE[l] = INT_MAX;
	i =  adv_x_curr + 2*search[l].x;
	j =  adv_y_curr + 2*search[l].y;
	/* 8x8 integer pel MV */
	ii = adv_search_area_subs2 + ((i-adv_ilow)>>1) + ((block&1)<<2) +
	  (((j-adv_jlow)>>1) + ((block&2)<<1) )*adv_h_lenby2;
	aa = act_block_subs2 + ((block&1)<<2) + ((block&2)<<1)*8;
/*
	AE[l] = sv_H263MySADSubBlock(ii, aa, adv_h_lenby2, INT_MAX);
*/
	AE[l] = sv_H263MySADSubBlock(ii, aa, adv_h_length, INT_MAX);
      }

      /* 1D polynomial interpolation along x and y respectively */

      AE_minx = AE[0];
      min_posx = 0;

      p2 = (int)(THREEBYEIGHT * (double) AE[2]
	           + THREEBYFOUR * (double) AE[0]
	           + MINUSONEBYEIGHT * (double) AE[3]);

      if (p2<AE_minx) {
	AE_minx = p2;
	min_posx = 2;
      }

      p3 = (int)(MINUSONEBYEIGHT * (double) AE[2]
	           + THREEBYFOUR * (double) AE[0]
	           + THREEBYEIGHT * (double) AE[3]);

      if (p3<AE_minx) {
	AE_minx = p3;
	min_posx = 3;
      }

      AE_miny = AE[0];
      min_posy = 0;

      p1 = (int)(THREEBYEIGHT * (double) AE[1]
	           + THREEBYFOUR * (double) AE[0]
	           + MINUSONEBYEIGHT * (double) AE[4]);

      if (p1<AE_miny) {
	AE_miny = p1;
	min_posy = 1;
      }

      p4 = (int)(MINUSONEBYEIGHT * (double) AE[1]
	           + THREEBYFOUR * (double) AE[0]
	           + THREEBYEIGHT * (double) AE[4]);

      if (p4<AE_miny) {
	AE_miny = p4;
	min_posy = 4;
      }

      /* Store optimal values */
      Min_FRAME[block+1] = (AE_minx<AE_miny ? 4*AE_minx : 4*AE_miny);
      MVFrame[block+1].x = adv_x_curr + search[min_posx].x - x_curr;
      MVFrame[block+1].y = adv_y_curr + search[min_posy].y - y_curr;

    }
  }

  i = x_curr/H263_MB_SIZE+1;
  j = y_curr/H263_MB_SIZE+1;

  if (!H263Info->advanced) {
    MV[0][j][i]->x = MVFrame[0].x;
    MV[0][j][i]->y = MVFrame[0].y;
    MV[0][j][i]->min_error = (short)Min_FRAME[0];
  }
  else {
    for (k = 0; k < 5; k++) {
      MV[k][j][i]->x = MVFrame[k].x;
      MV[k][j][i]->y = MVFrame[k].y;
      MV[k][j][i]->min_error = (short)Min_FRAME[k];
    }
  }

  ScFree(act_block_subs2);
  ScFree(search_area_subs2);

  if (H263Info->advanced)
    ScFree(adv_search_area);
  return;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\morph.c ===
/* File: sv_h263_morph.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
#define _SLIBDEBUG_
*/

#include "sv_h263.h"
#include "proto.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  0  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif


static unsigned char min5(unsigned char a, unsigned char b,
						  unsigned char c, unsigned char d, 
						  unsigned char e) ;
static unsigned char max5(unsigned char a, unsigned char b, 
						  unsigned char c, unsigned char d, 
						  unsigned char e) ;
static void ErodeX(unsigned char *image, unsigned char *out, 
				   int rows, int cols);
static void DilateX(unsigned char *image, unsigned char *out, 
					int rows, int cols);
static void ErodeS(unsigned char *image, unsigned char *out, 
				   int rows, int cols, int sr, int sc);
static void DilateS(unsigned char *image, unsigned char *out, 
					int rows, int cols, int sr, int sc);
static void Dilate(unsigned char *image, unsigned char *out, 
				   int rows, int cols, int sr, int sc);
static void Erode(unsigned char *image, unsigned char *out, 
				  int rows, int cols, int sr, int sc);
static void Open(unsigned char *image, unsigned char *out, 
				 int rows, int cols, int sr, int sc);


static void EdgeSelect(H263_PictImage *input, H263_PictImage *filtd, 
					   unsigned char *edge, 
					   H263_PictImage *output, int rows, int cols) ;


/*****************************************************************************************************
 * Function min5
 * Computes the min of the five elements
 ****************************************************************************************************/
static unsigned char min5(unsigned char a, unsigned char b,
						  unsigned char c, unsigned char d, unsigned char e) 
{
	unsigned char out;

	out = a;
	if(b<out) out=b;
	if(c<out) out=c;
	if(d<out) out=d;
	if(e<out) out=e;
	return out;
}

/*****************************************************************************************************
 * Function max5
 * Computes the max of the five elements
 ****************************************************************************************************/
static unsigned char max5(unsigned char a, unsigned char b, unsigned char c, 
						  unsigned char d, unsigned char e) 
{
	unsigned char out;

	out = a;
	if(b>out) out=b;
	if(c>out) out=c;
	if(d>out) out=d;
	if(e>out) out=e;
	return out;
}


/*****************************************************************************************************
 * Function: ErodeX 
 * Erosion of image (dimensions rows, cols) by a "+" structuring element
 ****************************************************************************************************/
static void ErodeX(unsigned char *image, unsigned char *out, int rows, int cols)
{
	int i, j;
	unsigned char *pi, *po;

	pi = image;
	po = out;

	/**** First line ****/ 
	/* First pixel */
	*po = min5(*pi, *pi, *(pi+1), *pi, *(pi+cols));
	pi++; po++;
	/* Center pixels */
	for(j=1; j<cols-1; j++, pi++, po++) {
		*po = min5(*(pi-1), *pi, *(pi+1), *pi, *(pi+cols));
	}
	/* Last pixel */
	*po = min5(*(pi-1), *pi, *pi, *pi, *(pi+cols));
	pi++; po++;

	/**** Center lines ****/
	for(i=1; i<rows-1; i++) {
		/* First pixel */
		*po = min5(*pi, *pi, *(pi+1), *(pi-cols), *(pi+cols));
		pi++; po++;
		/* Center pixels */
		for(j=1; j<cols-1; j++, pi++, po++) {
			*po = min5(*(pi-1), *pi, *(pi+1), *(pi-cols), *(pi+cols));
		}
		/* Last pixel */
		*po = min5(*(pi-1), *pi, *pi, *(pi-cols), *(pi+cols));
		pi++; po++;
	}


	/**** Last line ****/ 
	/* First pixel */
	*po = min5(*pi, *pi, *(pi+1), *(pi-cols), *pi);
	pi++; po++;
	/* Center pixels */
	for(j=1; j<cols-1; j++, pi++, po++) {
		*po = min5(*(pi-1), *pi, *(pi+1), *(pi-cols), *pi);
	}
	/* Last pixel */
	*po = min5(*(pi-1), *pi, *pi, *(pi-cols), *pi);
	pi++; po++;
}

/*****************************************************************************************************
 * Function: ErodeX 
 * Erosion of image (dimensions rows, cols) by a "+" structuring element
 ****************************************************************************************************/
static void DilateX(unsigned char *image, unsigned char *out, int rows, int cols)
{
	int i, j;
	unsigned char *pi, *po;

	pi = image;
	po = out;

	/**** First line ****/ 
	/* First pixel */
	*po = max5(*pi, *pi, *(pi+1), *pi, *(pi+cols));
	pi++; po++;
	/* Center pixels */
	for(j=1; j<cols-1; j++, pi++, po++) {
		*po = max5(*(pi-1), *pi, *(pi+1), *pi, *(pi+cols));
	}
	/* Last pixel */
	*po = max5(*(pi-1), *pi, *pi, *pi, *(pi+cols));
	pi++; po++;

	/**** Center lines ****/
	for(i=1; i<rows-1; i++) {
		/* First pixel */
		*po = max5(*pi, *pi, *(pi+1), *(pi-cols), *(pi+cols));
		pi++; po++;
		/* Center pixels */
		for(j=1; j<cols-1; j++, pi++, po++) {
			*po = max5(*(pi-1), *pi, *(pi+1), *(pi-cols), *(pi+cols));
		}
		/* Last pixel */
		*po = max5(*(pi-1), *pi, *pi, *(pi-cols), *(pi+cols));
		pi++; po++;
	}


	/**** Last line ****/ 
	/* First pixel */
	*po = max5(*pi, *pi, *(pi+1), *(pi-cols), *pi);
	pi++; po++;
	/* Center pixels */
	for(j=1; j<cols-1; j++, pi++, po++) {
		*po = max5(*(pi-1), *pi, *(pi+1), *(pi-cols), *pi);
	}
	/* Last pixel */
	*po = max5(*(pi-1), *pi, *pi, *(pi-cols), *pi);
	pi++; po++;
}

/*****************************************************************************************************
 * Function: ErodeS 
 * Erosion of image (dimensions rows, cols) by a square structuring element of dimensions (sr, sc)
 ****************************************************************************************************/
static void ErodeS(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	int i, j, k, l, du, db, dl, dr, sr2, sc2;
	unsigned char *pi, *po, *pse, min, odd;

	odd = 1;
	if (!(sr%2) || !(sc%2)) odd = 0;

	sr2 = sr >> 1; sc2 = sc >> 1;

	pi = image;
	po = out;
	for(i=0; i<rows; i++) {
		for(j=0; j<cols; j++, pi++, po++) {

			du = i>sr2 ? sr2 : i;
			dl = j > sc2 ? sc2 : j;

			if(odd) {
				db = (rows-1-i) > sr2 ? sr2 : (rows-1-i);
				dr = (cols-1-j) > sc2 ? sc2 : (cols-1-j);
			} else {
				db = (rows-1-i) > sr2-1 ? sr2-1 : (rows-1-i);
				dr = (cols-1-j) > sc2-1 ? sc2-1 : (cols-1-j);
			}


			min = 255;
			for(k=-du; k<=db; k++) {
			    pse = pi + k * cols - dl;
				for(l=-dl; l<=dr; l++, pse++) {
					min = *pse < min ? *pse : min;
				}
			}
			*po = min;
		}
	}
}

/*****************************************************************************************************
 * Function: DilateS
 * Dilation of image (dimensions rows, cols) by a square structuring element of dimensions (sr, sc)
 ****************************************************************************************************/
static void DilateS(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	int i, j, k, l, du, db, dl, dr, sr2, sc2;
	unsigned char *pi, *po, *pse, max, odd;

	odd = 1;
	if (!(sr%2) || !(sc%2)) odd = 0;

	sr2 = sr >> 1; sc2 = sc >> 1;

	pi = image;
	po = out;
	for(i=0; i<rows; i++) {
		for(j=0; j<cols; j++, pi++, po++) {

			du = i>sr2 ? sr2 : i;
			dl = j > sc2 ? sc2 : j;

			if(odd) {
				db = (rows-1-i) > sr2 ? sr2 : (rows-1-i);
				dr = (cols-1-j) > sc2 ? sc2 : (cols-1-j);
			} else {
				db = (rows-1-i) > sr2-1 ? sr2-1 : (rows-1-i);
				dr = (cols-1-j) > sc2-1 ? sc2-1 : (cols-1-j);
			}

			max = 0;
			for(k=-du; k<=db; k++) {
				for(l=-dl; l<=dr; l++, pse++) {
					pse = pi + k * cols + l;
					max = (*pse > max) ? *pse : max;
				}
			}
			*po = max;
		}
	}
}

/*****************************************************************************************************
 * Function: Dilate
 * Dilation of image (dimensions rows, cols) by a structuring element of dimensions (sr, sc).
 * If (sr, sc) are positive the structuring element is positive. If they are -1 it is
 * the cross '+'
 ****************************************************************************************************/
static void Dilate(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	if(sr > 0 && sc > 0) {
		DilateS(image, out, rows, cols, sr, sc);
	} else if(sr==-1 && sc ==-1) {
		DilateX(image, out, rows, cols);
	} else {
		_SlibDebug(_WARN_, printf("Dilate() Unknown structuring element\n") );
		return;
	}
}

/*****************************************************************************************************
 * Function: Erode
 * Erosion of image (dimensions rows, cols) by a structuring element of dimensions (sr, sc).
 * If (sr, sc) are positive the structuring element is positive. If they are -1 it is
 * the cross '+'
 ****************************************************************************************************/
static void Erode(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	if(sr > 0 && sc > 0) {
		ErodeS(image, out, rows, cols, sr, sc);
	} else if(sr==-1 && sc ==-1) {
		ErodeX(image, out, rows, cols);
	} else {
		_SlibDebug(_WARN_, printf("Erode() Unknown structuring element\n") );
        return;
	}
}

/*****************************************************************************************************
 * Function: Open 
 * Opening of image (dimensions rows, cols) by a square structuring element of dimensions (sr, sc)
 ****************************************************************************************************/
static void Open(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	unsigned char *tmp;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("Open() ScAlloc failed\n") );
      return;
	}
	Erode(image, tmp, rows, cols, sr, sc);
	Dilate(tmp, out, rows, cols, sr, sc);
	ScFree(tmp);
}

/*****************************************************************************************************
 * Function: Close 
 * Closing of image (dimensions rows, cols) by a square structuring element of dimensions (sr, sc)
 ****************************************************************************************************/
void Close(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	unsigned char *tmp;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("Close() ScAlloc failed\n") );
      return;
	}
	Dilate(image, tmp, rows, cols, sr, sc);
	Erode(tmp, out, rows, cols, sr, sc);
	ScFree(tmp);
}

/*****************************************************************************************************
 * Function: OpenClose 
 * Open/Closing of image (dimensions rows, cols) by a square structuring element of dimensions (sr, sc)
 ****************************************************************************************************/
void OpenClose(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	unsigned char *tmp;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("OpenClose() ScAlloc failed\n") );
      return;
	}
	Open(image, tmp, rows, cols, sr, sc);
	Close(tmp, out, rows, cols, sr, sc);
	ScFree(tmp);
}

/*****************************************************************************************************
 * Function: CloseOpen 
 * Open/Closing of image (dimensions rows, cols) by a square structuring element of dimensions (sr, sc)
 ****************************************************************************************************/
void CloseOpen(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	unsigned char *tmp;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("CloseOpen() ScAlloc failed\n") );
      return;
	}
	Close(image, tmp, rows, cols, sr, sc);
	Open(tmp, out, rows, cols, sr, sc);
	ScFree(tmp);
}


/*****************************************************************************************************
 * Function: GeoDilate 
 * Geodesic dilation of size one of image with respect to reference
 ****************************************************************************************************/
void GeoDilate(unsigned char *image, unsigned char *reference, int rows, int cols, int sr, int sc)
{
	int i, j;
	unsigned char *pi, *pr, *pt, *tmp;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("GeoDilate() ScAlloc failed\n") );
      return;
	}
	Dilate(image, tmp, rows, cols, sr, sc);

	pi = image;
	pr = reference;
	pt = tmp;
	for(i=0; i<rows; i++) {
		for(j=0; j<cols; j++, pi++, pr++, pt++) {
			*pi = *pr < *pt ? *pr : *pt;
		}
	}
	ScFree(tmp);
}

/*****************************************************************************************************
 * Function: GeoErode 
 * Geodesic erosion of size one of image with respect to reference
 ****************************************************************************************************/
void GeoErode(unsigned char *image, unsigned char *reference, int rows, int cols, int sr, int sc)
{
	int i, j;
	unsigned char *pi, *pr, *pt, *tmp;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("GeoErode() ScAlloc failed\n") );
      return;
	}
	Erode(image, tmp, rows, cols, sr, sc);

	pi = image;
	pr = reference;
	pt = tmp;
	for(i=0; i<rows; i++) {
		for(j=0; j<cols; j++, pi++, pr++, pt++) {
			*pi = (-(*pr) < (-*pt)) ? *pr : *pt;
		}
	}
	ScFree(tmp);
}

/****************************************************************************************************
 * Function: RecDilate
 * Reconstruction by dilation of image with respect to reference using a structural element of 
 * dimenions (sr, sc).
 ****************************************************************************************************/
void RecDilate(unsigned char *image, unsigned char *reference, int rows, int cols, int sr, int sc)
{
	int i, sz;
	unsigned char *prevImg, *pi, *Pi, differ;

	sz = rows * cols;
	if (!(prevImg = (unsigned char *)ScAlloc(sz))) {
      _SlibDebug(_WARN_, printf("RecDilate() ScAlloc failed\n") );
      return;
	}
	do {
		memcpy(prevImg, image, rows*cols);
		GeoDilate(image, reference, rows, cols, sr, sc);
		pi = image;	Pi = prevImg;
		differ = 0;
		for(i=0; i<sz; i++) if(*(pi++) != *(Pi++)) { differ = 1; break;}
	} while (differ);
	ScFree(prevImg);
}

/****************************************************************************************************
 * Function: RecErode
 * Reconstruction by erosion of image with respect to reference using a structural element of 
 * dimenions (sr, sc).
 ****************************************************************************************************/
void RecErode(unsigned char *image, unsigned char *reference, int rows, int cols, int sr, int sc)
{
	int i, sz;
	unsigned char *prevImg, *pi, *Pi, differ;

	sz = rows * cols;
	if (!(prevImg = (unsigned char *)ScAlloc(sz))) {
      _SlibDebug(_WARN_, printf("RecErode() ScAlloc failed\n") );
      return;
	}
	do {
		memcpy(prevImg, image, rows*cols);
		GeoErode(image, reference, rows, cols, sr, sc);
		pi = image;	Pi = prevImg;
		differ = 0;
		for(i=0; i<sz; i++) if(*(pi++) != *(Pi++)) { differ = 1; break;}
	} while (differ);
	ScFree(prevImg);
}

/****************************************************************************************************
 * Function: OpenRecErode
 * Open by reconstruction of erosion of image using a structural element of 
 * dimenions (sr, sc).
 ****************************************************************************************************/
void OpenRecErode(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	int sz;

	sz = rows * cols;
	Erode(image, out, rows, cols, sr, sc);
	RecDilate(out, image, rows, cols, sr, sc);
}


/****************************************************************************************************
 * Function: CloseRecDilate
 * Closing by reconstruction of dilation of image using a structural element of 
 * dimenions (sr, sc).
 ****************************************************************************************************/
void CloseRecDilate(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	int sz;

	sz = rows * cols;
	Dilate(image, out, rows, cols, sr, sc);
	RecErode(out, image, rows, cols, sr, sc);
}

/****************************************************************************************************
 * Function: OpenCloseRec
 * Open-closing by reconstruction of image using a structural element of 
 * dimenions (sr, sc).
 ****************************************************************************************************/
void OpenCloseRec(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	int sz;
	unsigned char *opened;

	sz = rows * cols;
	if (!(opened = (unsigned char *)ScAlloc(sz))) {
      _SlibDebug(_WARN_, printf("OpenCloseRec() ScAlloc failed\n") );
      return;
	}
	OpenRecErode(image, opened, rows, cols, sr, sc);
	CloseRecDilate(opened, out, rows, cols, sr, sc);
	ScFree(opened);
}

/****************************************************************************************************
 * Function: PredOpenCloseRec
 * Open-closing by reconstruction of image using a structural element of 
 * dimenions (sr, sc), for prediction images.
 ****************************************************************************************************/
void PredOpenCloseRec(int *predimage, int *predout, int rows, int cols, int sr, int sc)
{
	int sz, i;
	unsigned char *opened, *image, *out;

	sz = rows * cols;
	if (!(image = (unsigned char *)ScAlloc(sz))) {
      _SlibDebug(_WARN_, printf("PredOpenCloseRec() ScAlloc failed\n") );
      return;
	}
	if (!(out = (unsigned char *)ScAlloc(sz))) {
      _SlibDebug(_WARN_, printf("PredOpenCloseRec() ScAlloc failed\n") );
      return;
	}
	for(i=0; i<sz; i++) image[i] = (unsigned char) predimage[i] + 128;

	if (!(opened = (unsigned char *)ScAlloc(sz))) {
      _SlibDebug(_WARN_, printf("PredOpenCloseRec() ScAlloc failed\n") );
      return;
	}
	OpenRecErode(image, opened, rows, cols, sr, sc);
	CloseRecDilate(opened, out, rows, cols, sr, sc);

	for(i=0; i<sz; i++) predout[i] = (int) out[i] - 128;

	ScFree(opened);
	ScFree(image);
	ScFree(out);
}

/**************************************************************************************************
 * Function: EdgeSelect
 * Given the edge map, copies to the output: pixels from the input image if edge points,
 * pixels form the filtered image if not edge points.
 *************************************************************************************************/
static void EdgeSelect(H263_PictImage *input, H263_PictImage *filtd, unsigned char *edge, 
					   H263_PictImage *output, int rows, int cols)
{
	unsigned char *pi, *po, *pf, *pe;
	int i, j;

	/* Luminance */
	pi = input->lum; pf = filtd->lum;
	po = output->lum; pe = edge;
	for(i=0; i<rows; i++) {
		for(j=0; j<cols; j++, pi++, pf++, pe++, po++) {
			*po = (*pe ? *pi : *pf);
		}
	}

	rows /=2; cols /=2;

	/* Color 1 */
	pi = input->Cr; pf = filtd->Cr;
	po = output->Cr; pe = edge;
	for(i=0; i<rows; i++) {
		for(j=0; j<cols; j++, pi++, pf++, pe+=2, po++) {
			*po = (*pe ? *pi : *pf); 
		}
		pe += cols;
	}

	/* Color 2 */
	pi = input->Cb; pf = filtd->Cb;
	po = output->Cb; pe = edge;
	for(i=0; i<rows; i++) {
		for(j=0; j<cols; j++, pi++, pf++, pe+=2, po++) {
			*po = (*pe ? *pi : *pf);	
		}
		pe += cols;
	}
}

/**************************************************************************************************
 * Function: AdaptClean
 * Adaptly cleans curr_image, by filtering it by open/close by reconstruction at the pixels
 * where there is no edge info. The edge map is grown by the size of the morphological
 * operator, to avoid oversmoothing of details. sr, sc are the dimensions of the structuring
 * element for the morphologic operations
 *************************************************************************************************/
H263_PictImage *sv_H263AdaptClean(SvH263CompressInfo_t *H263Info, 
                                  H263_PictImage *curr_image, int rows, int cols, int sr, int sc)
{
	H263_PictImage *morph, *clean;
    unsigned char *Edge, *Orient, *CleanEmap;

	if (!(Edge = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("PredOpenCloseRec() ScAlloc failed\n") );
      return(NULL);
	}
	if (!(Orient = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("PredOpenCloseRec() ScAlloc failed\n") );
      return(NULL);
	}
	sv_H263EdgeMap(curr_image->lum, Edge, Orient, rows, cols);
	
	morph = sv_H263InitImage(H263Info->pels*H263Info->lines);

	OpenCloseRec(H263Info->curr_image->lum, morph->lum, rows, cols, sr, sc);
	OpenCloseRec(H263Info->curr_image->Cr, morph->Cr, rows >> 1, cols >> 1, sr, sc);
	OpenCloseRec(H263Info->curr_image->Cb, morph->Cb, rows >> 1, cols >> 1, sr, sc); 

	clean = sv_H263InitImage(rows*cols);

	if (!(CleanEmap = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("PredOpenCloseRec() ScAlloc failed\n") );
      return(NULL);
	}

	CloseOpen(Edge, CleanEmap, rows, cols, sr, sc);
	EdgeSelect(H263Info->curr_image, morph, CleanEmap, clean, rows, cols);

	sv_H263FreeImage(morph);
	ScFree(CleanEmap);
	ScFree(Orient);
	ScFree(Edge);

	return clean;
}

 /*****************************************************************
 * Function MorphLayers
 * Builds an array of successively more morphologically low pass 
 * filtered images. sz is the size of the structuring element (-1 for
 * the cross '+').
 *****************************************************************/
 H263_PictImage **sv_H263MorphLayers(H263_PictImage *img, int depth, int rows, int cols, int sz)
 {
	 int d;
	 H263_PictImage **PictFiltd;

	 PictFiltd = (H263_PictImage **) ScAlloc(depth*sizeof(H263_PictImage *));
	 for(d=0; d<depth; d++) {
		PictFiltd[d] = sv_H263InitImage(rows*cols);
	 }

	 /* Luminance */
	 memcpy(PictFiltd[0]->lum, img->lum, rows*cols);
	 for(d=1; d<depth; d++) 
		 OpenCloseRec(PictFiltd[d-1]->lum, PictFiltd[d]->lum, rows, cols, sz, sz);

	 rows/=2; cols/=2;

	 /* Chroma 1 */
	 memcpy(PictFiltd[0]->Cr, img->Cr, rows*cols);
	 for(d=1; d<depth; d++) 
		 OpenCloseRec(PictFiltd[d-1]->Cr, PictFiltd[d]->Cr, rows, cols, sz, sz);

	 /* Chroma 2 */
	 memcpy(PictFiltd[0]->Cb, img->Cb, rows*cols);
	 for(d=1; d<depth; d++) 
		 OpenCloseRec(PictFiltd[d-1]->Cb, PictFiltd[d]->Cb, rows, cols, sz, sz);


	 return PictFiltd;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\mres.c ===
/* File: sv_h263_mres.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#include "sv_h263.h"
#include "proto.h"

static void hfilt121(unsigned char *img, unsigned char *filtd, 
					 unsigned char s, unsigned char gain, 
					 int rows, int cols) ;
static void hfilt5(unsigned char *img, unsigned char *filtd, 
				   unsigned char s, unsigned char gain, 
				   int rows, int cols) ;
static void vfilt121(unsigned char *img, unsigned char *filtd, 
					 unsigned char s, unsigned char gain, 
					 int rows, int cols) ;
static void vfilt5(unsigned char *img, unsigned char *filtd, 
				   unsigned char s, unsigned char gain, 
				   int rows, int cols) ;
 static void lowpass(unsigned char *img, unsigned char *lp, 
	                 int rows, int cols, int ntaps) ;
 static void reduce(unsigned char *img, unsigned char *red, 
	                int rows, int cols, int ntaps) ;
 static void hpad(unsigned char *img, unsigned char *zp, 
	              unsigned char s,
		          int rows, int cols, char mode) ;
static void Expand(unsigned char *img, unsigned char *exp, 
	               int rows, int cols, char mode, int ntaps) ;
 static void gaussp(unsigned char *img, unsigned char **pyr, 
	                int depth, int rows, int cols, int ntaps) ;
 static unsigned char **palloc(int depth, int rows, int cols) ;
 static H263_PictImage **PictPyr(H263_PictImage *img, int depth, int rows, 
                                            int cols, int ntaps); 
 static void expyr(unsigned char **pyr, unsigned char **filtd, 
	               int depth, int rows, int cols, 
				   char mode, int ntaps);
 static H263_PictImage **GaussFilt(H263_PictImage *img, int depth, int rows, 
	                                          int cols, int ntaps);



/******************************************************************
 * Function hfilt121
 * Filters img horizontally with a 1:2:1 filter, subsampling by s.
 * rows, cols are the dimensions of img
 *****************************************************************/
static void hfilt121(unsigned char *img, unsigned char *filtd, 
					 unsigned char s, unsigned char gain, 
					 int rows, int cols)
{

	unsigned char *pimg, *pf;
	float conv, tmp;
	int i, j;

	pf = filtd;
	pimg = img;
	for(i=0; i<rows; i++) {
		/* Do first pixel */
		conv = (float)gain * ((float)*pimg * (float)2.0 + (float)*(pimg+1) * (float)2.0) / (float)4.0;
		tmp = (conv > 255 ? 255 : conv);
		*(pf++) = (unsigned char) (tmp < 0 ? 0 : tmp);
		pimg+=s;
		
		/* Do line */
		for(j=s; j<cols-1; j+=s, pimg+=s) {
			conv = (float) gain * ((float)*(pimg-1) + (float)*pimg * (float)2 + (float)*(pimg+1)) / (float)4.0;
			tmp = (conv > 255 ? 255 : conv);
			*(pf++) = (unsigned char)(tmp < 0 ? 0 : tmp);
		}

		/* Do last pixel if s equals one */
		if(s==1) {
			conv = (float)gain * ((float)*pimg * (float)2.0 + (float)*(pimg-1) * (float)2.0) / (float)4.0;
			tmp = (conv > 255 ? 255 : conv);
			*(pf++) = (unsigned char)(tmp < 0 ? 0 : tmp);
		    pimg+=s;
		}
	}
}

/******************************************************************
 * Function hfilt5
 * Filters img horizontally with a 5 tap gaussian filter, subsampling by s.
 * rows, cols are the dimensions of img
 *****************************************************************/
static void hfilt5(unsigned char *img, unsigned char *filtd, 
				   unsigned char s, unsigned char gain, 
				   int rows, int cols)
{

	unsigned char *pimg, *pf;
	float conv, tmp;
	int i, j;

	pf = filtd;
	pimg = img;
	for(i=0; i<rows; i++) {
		/* Do line */
		for(j=0; j<cols; j+=s, pimg+=s) {
			if (j==0) 
				conv = (float)gain * ((float)6.0 * (float)*pimg + (float)8.0 * (float)*(pimg+1) + (float)2.0 * *(pimg+2)) / (float)16.0;
			else if(j==1)
				conv = (float)gain * ((float)4.0 * (float)*(pimg-1) + (float)6.0 * (float)*pimg + (float)4.0 * (float)*(pimg+1) + (float)2.0 * (float)*(pimg+2)) / (float)16.0;
			else if (j==cols-2)
				conv = (float)gain * ((float)2.0 * (float)*(pimg-2) + (float)4.0 * (float)*(pimg-1) + (float)6.0 * (float)*pimg + (float)4.0 * (float)*(pimg+1)) / (float)16.0;
			else if (j==cols-1)
				conv = (float)gain * ((float)2.0 * (float)*(pimg-2) + (float)8.0 * (float)*(pimg-1) + (float)6.0 * (float)*pimg) / (float)16.0;
			else
				conv = (float)gain * ((float)*(pimg-2) + (float)4.0 * (float)*(pimg-1) + (float)6.0 * (float)*pimg + (float)4.0 * (float)*(pimg+1) + (float)*(pimg+2)) / (float)16.0;
			tmp = (float)(conv > 255 ? 255 : conv);
			*(pf++) = (unsigned char)(tmp < 0 ? 0 : tmp);
		}
	}
}


/******************************************************************
 * Function vfilt121
 * Filters img vertically with a 1:2:1 filter, subsampling by s.
 * rows, cols are the dimensions of img
 *****************************************************************/
static void vfilt121(unsigned char *img, unsigned char *filtd, 
					 unsigned char s, unsigned char gain, 
					 int rows, int cols)
{

	unsigned char *pimg, *pf;
	float tmp, conv;
	int i, j;

	pf = filtd;
	pimg = img;

	/* Do first line */
	for(j=0; j<cols; j++, pimg++) {
			conv = (float)gain * ((float) *pimg * (float)2 + (float)2 * (float)*(pimg+cols)) / (float)4.0;
			tmp = (conv > 255 ? 255 : conv);
			*(pf++) = (unsigned char)(tmp < 0 ? 0 : tmp);
	}
	pimg+= (s-1)*cols;
		
	/* Do image center */
	for(i=s; i<rows-1; i+=s) { 
		for(j=0; j<cols; j++, pimg++) {
			conv = (float)gain * ((float)*(pimg-cols) + (float)*pimg * (float)2 + (float)*(pimg+cols)) / (float)4.0;
			tmp = (conv > 255 ? 255 : conv);
			*(pf++) = (unsigned char)(tmp < 0 ? 0 : tmp);
		}
		pimg+=(s-1)*cols;
	}

	/* Do last line if s equals one */
	if(s==1) {
		for(j=0; j<cols; j++, pimg++) {
			conv = (float)gain * ((float)*pimg * (float)2 + (float)2 * (float)*(pimg-cols)) / (float)4.0;
			tmp = (float)(conv > 255 ? 255 : conv);
			*(pf++) = (unsigned char)(tmp < 0 ? 0 : tmp);
		}
	}
}

/******************************************************************
 * Function vfilt5
 * Filters img vertically with a 5 tap gaussian filter, subsampling by s.
 * rows, cols are the dimensions of img
 *****************************************************************/
static void vfilt5(unsigned char *img, unsigned char *filtd, 
				   unsigned char s, unsigned char gain, 
				   int rows, int cols)
{

	unsigned char *pimg, *pf;
	float conv, tmp;
	int i, j, tcols;

	pf = filtd;
	pimg = img;
	tcols = 2*cols;

	for(i=0; i<rows; i+=s) {
		for(j=0; j<cols; j++, pimg++) {
			if (i==0)
				conv = (float)gain * ((float)6.0 * (float)*pimg + (float)8.0 * (float)*(pimg+cols) + (float)2.0 * (float)*(pimg+tcols)) / (float)16.0;
			else if (i==1) 
				conv = (float)gain * ((float)4.0 * (float)*(pimg-cols) + (float)6.0 * (float)*pimg + (float)4.0 * (float)*(pimg+cols) + (float)2.0 * (float)*(pimg+tcols)) / (float)16.0;
			else if (i==rows-2)
				conv = (float)gain * ((float)2.0 * (float)*(pimg-tcols) + (float)4.0 * (float)*(pimg-cols) + (float)6.0 * (float)*pimg + (float)4.0 * (float)*(pimg+cols)) / (float)16.0;
			else if (i==rows-1)
				conv = (float)gain * ((float)2.0 * (float)*(pimg-tcols) + (float)8.0 * (float)*(pimg-cols) + (float)6.0 * (float)*pimg) / (float)16.0;
			else
				conv = (float)gain * (float)(*(pimg-tcols) + (float)4.0 * (float)*(pimg-cols) + (float)6.0 * (float)*pimg + 
					           (float)4.0 * (float)*(pimg+cols) + (float)*(pimg+tcols)) / (float)16.0;
			tmp = (float)(conv > 255 ? 255 : conv);
			*(pf++) = (unsigned char)(tmp < 0 ? 0 : tmp);
		}
		pimg+=(s-1)*cols;
	}
}

/******************************************************************
 * Function lowpass
 * 2D low pass filtering of img into lp. rows,
 * cols are the dimensions of img.
 ******************************************************************/
 static void lowpass(unsigned char *img, unsigned char *lp, 
	                 int rows, int cols, int ntaps)
 {
	unsigned char *tmp;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols))) {
	  /* fprintf(stderr,"ScAlloc failed\n");
	  exit(-1); */
      return;
	}
	switch (ntaps) {
	case 3:
		hfilt121(img, tmp, 1, 1, rows, cols);
		vfilt121(tmp, lp, 1, 1, rows, cols);
		break;
	case 5:
		hfilt5(img, tmp, 1, 1, rows, cols);
		vfilt5(tmp, lp, 1, 1, rows, cols);
		break;
	default:
		/* printf("Unknown filter in lowpass\n");
		  exit(0); */
	    ScFree(tmp);
        return;
	}
	ScFree(tmp);
 }


/******************************************************************
 * Function reduce
 * 2D low pass filtering and subsampling by two of img into red. rows,
 * cols are the dimensions of img.
 ******************************************************************/
 static void reduce(unsigned char *img, unsigned char *red, 
	                int rows, int cols, int ntaps)
 {
	unsigned char *tmp;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols/2))) {
	  /* fprintf(stderr,"ScAlloc failed\n");
	  exit(-1); */
        return;
	}
	switch (ntaps) {
	case 3:
		hfilt121(img, tmp, 2, 1, rows, cols);
		vfilt121(tmp, red, 2, 1, rows, cols>>1);
		break;
	case 5:
		hfilt5(img, tmp, 2, 1, rows, cols);
		vfilt5(tmp, red, 2, 1, rows, cols>>1);
		break;
	default:
        /* 
		printf("Unknown filter in reduce\n");
		exit(0); */
	    ScFree(tmp);
        return;
	}

	ScFree(tmp);
 }

/******************************************************************
 * Function hpad
 * Zero-pads img horizontaly by the factor s. Returns zero-paded
 * image in zp. rows, cols are the dimensions of img
 *****************************************************************/
 static void hpad(unsigned char *img, unsigned char *zp, 
	              unsigned char s,
		          int rows, int cols, char mode)
 {
	 int i, j;
	 unsigned char *pf, *pimg, fill;

	 switch (mode) {
	 case 'l':
		 fill = 0;
		 break;
	 case 'c':
		 fill = 0;
		 break;
	 default:
         /*
		 printf("Unknown fill mode in hpad\n");
		 exit(0);
         */
         return;
	 }

	 pimg = img;
	 pf = zp;
	 for(i=0; i<rows; i++) 
		 for(j=0; j<cols*s; j++) 
			 *(pf++) = (j%s ? fill: *(pimg++));
 }

 /******************************************************************
 * Function vpad
 * Zero-pads img verticaly by the factor s. Returns zero-paded
 * image in zp. rows, cols are the dimensions of img
 *****************************************************************/
 static void vpad(unsigned char *img, unsigned char *zp, 
	              unsigned char s,
		          int rows, int cols, char mode)
 {
 	 int i, j;
	 unsigned char *pf, *pimg, fill;

	 switch (mode) {
	 case 'l':
		 fill = 0;
		 break;
	 case 'c':
		 fill = 0;
		 break;
	 default:
         /*
		 printf("Unknown fill mode in hpad\n");
		 exit(0); */
         return;
	 }

	 pimg = img;
	 pf = zp;
	 for(i=0; i<rows*s; i++) 
		 for(j=0; j<cols; j++) 
			 *(pf++) = (i%s ? fill: *(pimg++));
 }

 /******************************************************************
 * Function Expand
 * 2D upsampling by two and low pass filtering of img into exp. rows,
 * cols are the dimensions of img.
 ******************************************************************/
static void Expand(unsigned char *img, unsigned char *exp, 
	               int rows, int cols, char mode, int ntaps)
 {
	unsigned char *tmp, *tmp2, *tmp3;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols*2))) {
        /*
	  fprintf(stderr,"ScAlloc failed\n");
	  exit(-1); */
      return;
	}
	hpad(img, tmp, 2, rows, cols, mode);
	if (!(tmp2 = (unsigned char *)ScAlloc(rows*cols*2))) {
	  /* fprintf(stderr,"ScAlloc failed\n");
	  exit(-1); */
      return;
	}
	switch (ntaps) {
	case 3:
		hfilt121(tmp, tmp2, 1, 2, rows, cols<<1);
		break;
	case 5:
		hfilt5(tmp, tmp2, 1, 2, rows, cols<<1);
		break;
	default:
        /*
		printf("Unknown filter in Expand\n");
		exit(0); */
        return;
	}

	if (!(tmp3 = (unsigned char *)ScAlloc(rows*cols*4))) {
        /*
	  fprintf(stderr,"ScAlloc failed\n");
	  exit(-1);
      */
      return;
	}
	vpad(tmp2, tmp3, 2, rows, cols<<1, mode);
	switch (ntaps) {
	case 3:
		vfilt121(tmp3, exp, 1, 2, rows<<1, cols<<1);
		break;
	case 5:
		vfilt5(tmp3, exp, 1, 2, rows<<1, cols<<1);
		break;
	default:
        /*
		printf("Unknown filter in Expand\n");
		exit(0); */
        return;
	}
	ScFree(tmp); ScFree(tmp2); ScFree(tmp3);
 }

 /*****************************************************************
 * Function gaussp
 * Builds a Gaussian pyramid of depth levels.
 *****************************************************************/
 static void gaussp(unsigned char *img, unsigned char **pyr, 
	                int depth, int rows, int cols, int ntaps)
 {
	int d;

	memcpy(pyr[0], img, rows*cols);
	for(d=1; d<depth; d++) {
		reduce(pyr[d-1], pyr[d], rows, cols, ntaps);
		rows /= 2;
		cols /= 2;
	}
 }

 /*****************************************************************
 * Function palloc
 * Allocates memory for a Gaussian pyramid of depth levels.
 * Higher resolution is level 0, with dimensions rows, cols.
 *****************************************************************/
 static unsigned char **palloc(int depth, int rows, int cols)
 {
	 int d;
	 unsigned char **pyr;
	 
	 if (!(pyr = (unsigned char **)ScAlloc(depth*sizeof(unsigned char *)))) {
       /*
	   fprintf(stderr,"ScAlloc failed\n");
	   exit(-1);
       */
       return(NULL);
	 }
	 for(d=0; d<depth; d++) {
		 if (!(pyr[d] = (unsigned char *)ScAlloc(rows*cols))) {
           /*
		   fprintf(stderr,"ScAlloc failed\n");
		   exit(-1);
           */
           return(NULL);
		 }
		 rows /= 2;
		 cols /= 2;
	 }
	 return pyr;
 }

 /****************************************************************
 * Function PictPyr
 * Buids a Gaussian pyramid of picture images with depth levels.
 ****************************************************************/
 static H263_PictImage **PictPyr(H263_PictImage *img, int depth, int rows, int cols, int ntaps) 
 {
	 unsigned char **tmp;
	 H263_PictImage ** PictPyr;
	 int d;

	 if (!(PictPyr = (H263_PictImage **)ScAlloc(depth*sizeof(H263_PictImage *)))) {
       /*
	   fprintf(stderr,"ScAlloc failed\n");
	   exit(-1);
       */
       return(NULL);
	 }
	 for(d=0; d< depth; d++) {
		 if ((PictPyr[d] = (H263_PictImage *)ScAlloc(sizeof(H263_PictImage))) == NULL) {
            /*
			fprintf(stderr,"Couldn't allocate (PictImage *)\n");
			exit(-1);
            */
            return(NULL);
		 }
	 }

	 /* Luminance */
	 tmp = palloc(depth, rows, cols);
	 gaussp(img->lum, tmp, depth, rows, cols, ntaps);
	 for(d=0; d<depth; d++) PictPyr[d]->lum = tmp[d];

	 rows/=2; cols/=2;
	 /* Chroma 1 */
	 tmp = palloc(depth, rows, cols);
	 gaussp(img->Cr, tmp, depth, rows, cols, ntaps);
	 for(d=0; d<depth; d++) PictPyr[d]->Cr = tmp[d];

 	 /* Chroma 2 */
	 tmp = palloc(depth, rows, cols);
	 gaussp(img->Cb, tmp, depth, rows, cols, ntaps);
	 for(d=0; d<depth; d++) PictPyr[d]->Cb = tmp[d];

	 ScFree(tmp);
	 return PictPyr;
 }

 /*****************************************************************
 * Function expyr
 * Expands the pyramid channels to full resolution. rows, cols
 * are the dimensions of the expanded images, and the full resolution
 * layer of the pyramid.
 *****************************************************************/
 static void expyr(unsigned char **pyr, unsigned char **filtd, 
	               int depth, int rows, int cols, 
				   char mode, int ntaps)
 {
	 int d, l, r, c;

	 r = rows; c = cols;
	 memcpy(filtd[0], pyr[0], rows*cols);
	 for(d=1; d<depth; d++) {
		 r /= 2;
		 c /= 2;
		 for(l=d; l>0; l--) Expand(pyr[d], pyr[d-1], r, c, mode, ntaps);
		 memcpy(filtd[d], pyr[0], rows*cols);
	 }
 }

 /*****************************************************************
 * Function GaussFilt
 * Builds an array of successively more low pass filtered images
 * by constructing a gaussian pyramid and expanding each level
 * to full resolution
 *****************************************************************/
 static H263_PictImage **GaussFilt(H263_PictImage *img, int depth, int rows, 
	                                          int cols, int ntaps)
 {
	 int d;
	 H263_PictImage **PictFiltd;
	 unsigned char **tmp, **filtd;

	 PictFiltd = (H263_PictImage **) ScAlloc(depth*sizeof(H263_PictImage *));
	 for(d=0; d<depth; d++) {
		PictFiltd[d] = sv_H263InitImage(rows*cols);
	 }

	 /* Luminance */
	 filtd = (unsigned char **) ScAlloc(depth*sizeof(unsigned char *));
	 for(d=0; d<depth; d++) filtd[d] = (unsigned char *) ScAlloc(rows * cols);
	 tmp = palloc(depth, rows, cols);
	 gaussp(img->lum, tmp, depth, rows, cols, ntaps);
	 expyr(tmp, filtd, depth, rows, cols, 'l', ntaps);
 	 for(d=0; d<depth; d++) memcpy(PictFiltd[d]->lum, filtd[d], rows*cols);
	 for(d=0; d<depth; d++) {
		 ScFree(tmp[d]);
		 ScFree(filtd[d]);
	 }
	 ScFree(tmp);
	 ScFree(filtd);

	 rows/=2; cols/=2;

	 /* Chroma 1 */
	 filtd = (unsigned char **) ScAlloc(depth*sizeof(unsigned char *));
	 for(d=0; d<depth; d++) filtd[d] = (unsigned char *) ScAlloc(rows * cols);
	 tmp = palloc(depth, rows, cols);
	 gaussp(img->Cr, tmp, depth, rows, cols, ntaps);
	 expyr(tmp, filtd, depth, rows, cols, 'c', ntaps);
 	 for(d=0; d<depth; d++) memcpy(PictFiltd[d]->Cr, filtd[d], rows*cols);
	 for(d=0; d<depth; d++) {
		 ScFree(tmp[d]);
		 ScFree(filtd[d]);
	 }
	 ScFree((void *) tmp);
	 ScFree((void *) filtd);

 	 /* Chroma 2 */
	 filtd = (unsigned char **) ScAlloc(depth*sizeof(unsigned char *));
	 for(d=0; d<depth; d++) filtd[d] = (unsigned char *) ScAlloc(rows * cols);
	 tmp = palloc(depth, rows, cols);
	 gaussp(img->Cb, tmp, depth, rows, cols, ntaps);
	 expyr(tmp, filtd, depth, rows, cols, 'c', ntaps);
 	 for(d=0; d<depth; d++) memcpy(PictFiltd[d]->Cb, filtd[d], rows*cols);
	 for(d=0; d<depth; d++) {
		 ScFree(tmp[d]);
		 ScFree(filtd[d]);
	 }
	 ScFree((void *) tmp);
	 ScFree((void *) filtd);

	 return PictFiltd;
 }

 /*****************************************************************
 * Function GaussLayers
 * Builds an array of successively more low pass filtered images
 *****************************************************************/
 H263_PictImage **svH263GaussLayers(H263_PictImage *img, int depth, int rows, int cols, int ntaps)
 {
	 int d;
	 H263_PictImage **PictFiltd;

	 PictFiltd = (H263_PictImage **) ScAlloc(depth*sizeof(H263_PictImage *));
	 for(d=0; d<depth; d++) {
		PictFiltd[d] = sv_H263InitImage(rows*cols);
	 }

	 /* Luminance */
	 memcpy(PictFiltd[0]->lum, img->lum, rows*cols);
	 for(d=1; d<depth; d++) 
		 lowpass(PictFiltd[d-1]->lum, PictFiltd[d]->lum, rows, cols, ntaps);

	 rows/=2; cols/=2;

	 /* Chroma 1 */
	 memcpy(PictFiltd[0]->Cr, img->Cr, rows*cols);
	 for(d=1; d<depth; d++) 
		 lowpass(PictFiltd[d-1]->Cr, PictFiltd[d]->Cr, rows, cols, ntaps);

	 /* Chroma 2 */
	 memcpy(PictFiltd[0]->Cb, img->Cb, rows*cols);
	 for(d=1; d<depth; d++) 
		 lowpass(PictFiltd[d-1]->Cb, PictFiltd[d]->Cb, rows, cols, ntaps);


	 return PictFiltd;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\ratectrl.c ===
/* File: sv_h263_ratectl.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/* ABOUT THE NEW RATE CONTROL:

   ratectrl.c now contains the new simplified rate control we used to
   generate the MPEG-4 anchors, instead of the TMN5 rate control. This
   simplified scheme works fine to get a specified mean bitrate for
   the whole sequence for easy comparison with other coding schemes,
   but it is too simple to guarantee a minimum delay in real
   videophone applications. It does not skip any extra pictures after
   the first frame, and it uses a fixed frame rate. Its purpose is to
   achieve the target bitrate as a mean bitrate for the whole
   sequence. If the number of pictures encoded is very small, this
   will not always be possible because of the high number of bits
   spent on the first frame.

   The reason we have removed the TMN5 rate control is that we did not
   think it worked as well as it should, especially when PB-frames
   were used. Any real H.263 product would have had to improve it
   anyway. 

   When grabbing sequences from a framegrabber card, you will not
   always get the full reference frame rate, and the original sequence
   will have skipped frames. This was much easier to support with a
   fixed frame rate scheme.

   If you would like to include code for a rate control scheme which
   satisfies the HRD requirements in the H.263 standard as well as
   works for all types of sequences with and without PB-frames (for
   instance with the adaptive PB-frames as included in this version),
   please feel free to do so.

   If you think the TMN5 scheme worked well enough for you, and the
   simplified scheme is too simple, you can add the TMN5 code
   without too much work. However, this will not work with the
   adaptive PB-frames without a lot of changes, and also coding
   sequences which has a lower frame rate than the reference frame
   rate will not be possible without additional changes. */

/*
#define _SLIBDEBUG_
*/

#include <math.h>

#include "sv_h263.h"
#include "proto.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  0  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif


/**********************************************************************
 *
 *	Name:	        FrameUpdateQP
 *	Description:    updates quantizer once per frame for 
 *                      simplified rate control
 *	
 *      Returns:        new quantizer
 *	Side effects:
 *
 ***********************************************************************/

int sv_H263FrameUpdateQP(int buf, int bits, int frames_left, int QP, int B, 
                         float seconds) 
{
  int newQP, dQP;
  float buf_rest, buf_rest_pic;

  buf_rest = seconds * B - (float)buf;

  newQP = QP;

  if (frames_left > 0) {
    buf_rest_pic = buf_rest / (float)frames_left;
    _SlibDebug(_VERBOSE_,
        ScDebugPrintf(NULL, "  Simplified rate control for %d remaining pictures:\n", frames_left);
        ScDebugPrintf(NULL, "  Bits spent / left       : %8d / %d (%d per picture)\n", 
                                       buf, mnint(buf_rest), mnint(buf_rest_pic));
        ScDebugPrintf(NULL, "  Limits                  : %8.0f / %.0f\n", 
                                       buf_rest_pic / 1.15, buf_rest_pic * 1.15);
        ScDebugPrintf(NULL, "  Bits spent on last frame: %8d\n", bits)
        );
    dQP = (int) mmax(1,QP*0.1);


    if (bits > buf_rest_pic * 1.15) {
      newQP = mmin(31,QP+dQP);
      _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "  QP -> new QP            : %2d -> %2d\n", QP, newQP) );
    }
    else if (bits < buf_rest_pic / 1.15) {
      newQP = mmax(1,QP-dQP);
      _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "  QP -> new QP            : %2d -> %2d\n", QP, newQP) );
    }
    else {
      _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "  QP not changed\n", QP, newQP) );
    }
  }
  return newQP;
}



/* rate control static variables */

static float B_prev;     /* number of bits spent for the previous frame */
static float B_target;   /* target number of bits/picture               */
static float global_adj; /* due to bits spent for the previous frame    */

void sv_H263GOBInitRateCntrl()
{
  B_prev = (float)0.0;
}

void sv_H263GOBUpdateRateCntrl(int bits)
{
  B_prev = (float)bits;
}

int sv_H263GOBInitQP(float bit_rate, float target_frame_rate, float QP_mean) 

/* QP_mean = mean quantizer parameter for the previous picture */
/* bitcount = current total bit count                          */
/* To calculate bitcount in coder.c, do something like this :  */
/* int bitcount;                                               */
/* AddBitsPicture(bits);                                       */
/* bitcount = bits->total;                                     */
{
  int newQP;

  B_target = bit_rate / target_frame_rate;

  /* compute picture buffer descrepency as of the previous picture */

  if (B_prev != 0.0) {
    global_adj = (B_prev - B_target) / (2*B_target);
  }
  else {
    global_adj = (float)0.0;
  }
  newQP = (int)(QP_mean + QP_mean * global_adj + (float)0.5);
  newQP = mmax(1,mmin(31,newQP));  

  return newQP;
}


/*********************************************************************
*   Name:          UpdateQuantizer
*
*
* Description: This function generates a new quantizer step size based
*                  on bits spent up until current macroblock and bits
*                  spent from the previous picture.  Note: this
*                  routine should be called at the beginning of each
*                  macroblock line as specified by TMN4. However, this
*                  can be done at any macroblock if so desired.
*
*  Input: current macroblock number (raster scan), mean quantizer
*  paramter for previous picture, bit rate, source frame rate,
*  hor. number of macroblocks, vertical number of macroblocks, total #
*  of bits used until now in the current picture.
*
*  Returns: Returns a new quantizer step size for the use of current
*  macroblock Note: adjustment to fit with 2-bit DQUANT should be done
*  in the calling program.
*
*  Side Effects:  
*
*  Date: 1/5/95    Author: Anurag Bist
*
**********************************************************************/


int sv_H263GOBUpdateQP(int mb, float QP_mean, float bit_rate, 
                       int mb_width, int mb_height, int bitcount,
					   int NOgob, int *VARgob, int pb_frame) 

/* mb = macroblock index number */
/* QP_mean = mean quantizer parameter for the previous picture */
/* bitcount = total # of bits used until now in the current picture */
{
  int newQP=16, i, VARavg=0;
  float local_adj, descrepency, projection;
  double VARratio=0.0;

 if(NOgob) {
	 for(i=0;i<NOgob;i++) VARavg += VARgob[i];  
	 VARavg /= NOgob;
 }
  /* compute expected buffer fullness */
  projection = mb * (B_target / (mb_width*mb_height));
    
  /* measure descrepency between current fullness and projection */
  descrepency= ((float)bitcount - projection);

  /* scale */
  local_adj = 12 * descrepency / bit_rate;  

  if(NOgob) {
    VARratio = (double)VARgob[NOgob] / (double)VARavg ; 
    VARratio = log(VARratio) / 0.693147 ;
	if(pb_frame) local_adj += (float) (VARratio / 4.0);
	else         local_adj += (float) (VARratio / 2.0);
  }

  newQP = (int)(QP_mean + QP_mean * (global_adj + local_adj) + (float)0.5);

  newQP = mmax(1,mmin(31,newQP));  

  return newQP;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\recon.c ===
/* File: sv_h263_recon.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/


#include "sv_h263.h"
#include "proto.h"

/* private prototypes */
static void sv_recon_comp(unsigned char *src, unsigned char *dst,
  int lx, int lx2, int w, int h, int x, int y, int dx, int dy, int flag);
static void sv_recon_comp_obmc(SvH263DecompressInfo_t *H263Info, unsigned char *src, unsigned char *dst,
                            int lx, int lx2, int comp, int w, int h, int x, int y);
static void sv_rec(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
static void sv_recc(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
static void sv_reco(unsigned char *s, int *d, int lx2, int c, int xa, int xb, int ya, int yb);
static void sv_rech(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
static void sv_rechc(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
static void sv_recho(unsigned char *s, int *d, int lx2, int c, int xa, int xb, int ya, int yb);
static void sv_recv(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
static void sv_recvc(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
static void sv_recvo(unsigned char *s, int *d, int lx2, int c, int xa, int xb, int ya, int yb);
static void sv_rec4(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
static void sv_rec4c(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
static void sv_rec4o(unsigned char *s, int *d, int lx2, int c, int xa, int xb, int ya, int yb);

static int H263_roundtab[16]= {0,0,0,1,1,1,1,1,1,1,1,1,1,1,2,2};

void sv_H263Reconstruct(SvH263DecompressInfo_t *H263Info, int bx, int by, int P, int bdx, int bdy)
{
  int w,h,lx,lx2,dx,dy,xp,yp,comp,sum;
  int x,y,mode,xvec,yvec;
  unsigned char *src[3];

  x = bx/16+1; y = by/16+1;
  lx = H263Info->coded_picture_width;

  if (H263Info->mv_outside_frame) {
    lx2 = H263Info->coded_picture_width + 64;
    src[0] = H263Info->edgeframe[0];
    src[1] = H263Info->edgeframe[1];
    src[2] = H263Info->edgeframe[2];
  }
  else {
    lx2 = H263Info->coded_picture_width;
    src[0] = H263Info->oldrefframe[0];
    src[1] = H263Info->oldrefframe[1];
    src[2] = H263Info->oldrefframe[2];
  }

  mode = H263Info->modemap[y][x];

  if (P) {
    /* P prediction */
    if (H263Info->adv_pred_mode) {
      w = 8; h = 8;
      /* Y*/
      for (comp = 0; comp < 4; comp++) {
        xp = bx + ((comp&1)<<3);
        yp = by + ((comp&2)<<2);
        sv_recon_comp_obmc(H263Info, src[0],H263Info->newframe[0], lx,lx2,comp,w,h,xp,yp);
      }
      if (mode == H263_MODE_INTER4V) {

        sum = H263Info->MV[0][1][y][x]+H263Info->MV[0][2][y][x]+ H263Info->MV[0][3][y][x]+H263Info->MV[0][4][y][x];
        dx = sign(sum)*(H263_roundtab[abs(sum)%16] + (abs(sum)/16)*2);

        sum = H263Info->MV[1][1][y][x]+H263Info->MV[1][2][y][x]+ H263Info->MV[1][3][y][x]+H263Info->MV[1][4][y][x];
        dy = sign(sum)*(H263_roundtab[abs(sum)%16] + (abs(sum)/16)*2);

      }
      else {
        dx = H263Info->MV[0][0][y][x];
        dy = H263Info->MV[1][0][y][x];
        /* chroma rounding */
        dx = ( dx % 4 == 0 ? dx >> 1 : (dx>>1)|1 );
        dy = ( dy % 4 == 0 ? dy >> 1 : (dy>>1)|1 );
      }
      lx>>=1;bx>>=1; lx2>>=1; 
      by>>=1;
      /* Chroma */
      sv_recon_comp(src[1],H263Info->newframe[1], lx,lx2,w,h,bx,by,dx,dy,1);
      sv_recon_comp(src[2],H263Info->newframe[2], lx,lx2,w,h,bx,by,dx,dy,2);
    }
    else { /* normal prediction mode */
      /* P prediction */
      w = 16; h = 16;
      dx = H263Info->MV[0][0][y][x];
      dy = H263Info->MV[1][0][y][x];
      
      /* Y */
      sv_recon_comp(src[0],H263Info->newframe[0], lx,lx2,w,h,bx,by,dx,dy,0);
      
      lx>>=1; w>>=1; bx>>=1; lx2>>=1; 
      h>>=1; by>>=1;  
      /* chroma rounding */
      dx = ( dx % 4 == 0 ? dx >> 1 : (dx>>1)|1 );
      dy = ( dy % 4 == 0 ? dy >> 1 : (dy>>1)|1 );

      /* Chroma */
      sv_recon_comp(src[1],H263Info->newframe[1], lx,lx2,w,h,bx,by,dx,dy,1);
      sv_recon_comp(src[2],H263Info->newframe[2], lx,lx2,w,h,bx,by,dx,dy,2);
    }
  }
  else {
    /* B forward prediction */
    if (H263Info->adv_pred_mode) {
      if (mode == H263_MODE_INTER4V) {
        w = 8; h = 8;
        /* Y*/
        xvec = yvec = 0;
        for (comp = 0; comp < 4; comp++) {
          xvec += (dx = (H263Info->trb)*H263Info->MV[0][comp+1][y][x]/H263Info->trd + bdx);
          yvec += (dy = (H263Info->trb)*H263Info->MV[1][comp+1][y][x]/H263Info->trd + bdy);
          xp = bx + ((comp&1)<<3);
          yp = by + ((comp&2)<<2);
          sv_recon_comp(src[0],H263Info->bframe[0], lx,lx2,w,h,xp,yp,dx,dy,0);
        }

        /* chroma rounding (table 16/H.263) */
        dx = sign(xvec)*(H263_roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
        dy = sign(yvec)*(H263_roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

        lx>>=1;bx>>=1; lx2>>=1;
        by>>=1;
        /* Chroma */
        sv_recon_comp(src[1],H263Info->bframe[1], lx,lx2,w,h,bx,by,dx,dy,1);
        sv_recon_comp(src[2],H263Info->bframe[2], lx,lx2,w,h,bx,by,dx,dy,2);
      }
      else {  /* H263Info->adv_pred_mode but 16x16 vector */
        w = 16; h = 16;

        dx = (H263Info->trb)*H263Info->MV[0][0][y][x]/H263Info->trd + bdx;
        dy = (H263Info->trb)*H263Info->MV[1][0][y][x]/H263Info->trd + bdy;
        /* Y */
        sv_recon_comp(src[0],H263Info->bframe[0], lx,lx2,w,h,bx,by,dx,dy,0);
        
        lx>>=1; w>>=1; bx>>=1; lx2>>=1;
        h>>=1; by>>=1;  

        xvec = 4*dx;
        yvec = 4*dy;

        /* chroma rounding (table 16/H.263) */
        dx = sign(xvec)*(H263_roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
        dy = sign(yvec)*(H263_roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

        /* Chroma */
        sv_recon_comp(src[1],H263Info->bframe[1], lx,lx2,w,h,bx,by,dx,dy,1);
        sv_recon_comp(src[2],H263Info->bframe[2], lx,lx2,w,h,bx,by,dx,dy,2);
      }
    }
    else { /* normal B forward prediction */

      w = 16; h = 16;
      dx = (H263Info->trb)*H263Info->MV[0][0][y][x]/H263Info->trd + bdx;
      dy = (H263Info->trb)*H263Info->MV[1][0][y][x]/H263Info->trd + bdy;
      /* Y */
      sv_recon_comp(src[0],H263Info->bframe[0], lx,lx2,w,h,bx,by,dx,dy,0);

      lx>>=1; w>>=1; bx>>=1; lx2>>=1;
      h>>=1; by>>=1;  

      xvec = 4*dx;
      yvec = 4*dy;

      /* chroma rounding (table 16/H.263) */ 
      dx = sign(xvec)*(H263_roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
      dy = sign(yvec)*(H263_roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

      /* Chroma */
      sv_recon_comp(src[1],H263Info->bframe[1], lx,lx2,w,h,bx,by,dx,dy,1);
      sv_recon_comp(src[2],H263Info->bframe[2], lx,lx2,w,h,bx,by,dx,dy,2);
    }
  }
}


static void sv_recon_comp(src,dst,lx,lx2,w,h,x,y,dx,dy,chroma)
unsigned char *src;
unsigned char *dst;
int lx,lx2;
int w,h;
int x,y;
int dx,dy;
int chroma;
{
  register int xint, xh, yint, yh;
  register unsigned char *s, *d;

  xint = dx>>1;
  xh = dx & 1;
  yint = dy>>1;
  yh = dy & 1;

  /* origins */
  s = src + lx2*(y+yint) + x + xint;
  d = dst + lx*y + x;

#if 0 /* fast but less accurate */

  if (w!=8) {
    if      (!xh && !yh) svH263Rec16_S(s,d,lx,lx2,h);
    else if (!xh &&  yh) svH263Rec16V_S(s,d,lx,lx2,h);
    else if ( xh && !yh) svH263Rec16H_S(s,d,lx,lx2,h);
    else                 svH263Rec16B_S(s,d,lx,lx2,h);
  }
  else {
    if      (!xh && !yh) svH263Rec8_S(s,d,lx,lx2,h);
    else if (!xh &&  yh) svH263Rec8V_S(s,d,lx,lx2,h);
    else if ( xh && !yh) svH263Rec8H_S(s,d,lx,lx2,h);
    else                 svH263Rec8B_S(s,d,lx,lx2,h);
  }

#else

  if(w != 8) {
    if      (!xh && !yh) sv_rec(s,d,lx,lx2,h);
    else if (!xh &&  yh) sv_recv(s,d,lx,lx2,h);
    else if ( xh && !yh) sv_rech(s,d,lx,lx2,h);
    else                 sv_rec4(s,d,lx,lx2,h);
  }
  else {
    if      (!xh && !yh) sv_recc(s,d,lx,lx2,h);
    else if (!xh &&  yh) sv_recvc(s,d,lx,lx2,h);
    else if ( xh && !yh) sv_rechc(s,d,lx,lx2,h);
    else                 sv_rec4c(s,d,lx,lx2,h);
  }

#endif

}

static void sv_rec(s,d,lx,lx2,h)
unsigned char *s, *d;
int lx,lx2,h;
{
  register int j;
  register unsigned qword *p1;
  unsigned UNALIGNED qword *p2;

  for (j=0; j<h; j++)
  {
    p1 = (unsigned qword *) d;
    p2 = (unsigned qword *) s;
    p1[0] = p2[0];
    p1[1] = p2[1];
    s+= lx2;
    d+= lx;
  }

/*
  for (j=0; j<h; j++)
  {
    d[0] = s[0];
    d[1] = s[1];
    d[2] = s[2];
    d[3] = s[3];
    d[4] = s[4];
    d[5] = s[5];
    d[6] = s[6];
    d[7] = s[7];
    d[8] = s[8];
    d[9] = s[9];
    d[10] = s[10];
    d[11] = s[11];
    d[12] = s[12];
    d[13] = s[13];
    d[14] = s[14];
    d[15] = s[15];
    s+= lx2;
    d+= lx;
  }
*/
}

static void sv_recc(s,d,lx,lx2,h)
unsigned char *s, *d;
int lx,lx2,h;
{
  int j;

  for (j=0; j<h; j++)
  {
    unsigned qword *p1;
    unsigned UNALIGNED qword *p2;
 
    p1 = (unsigned qword *) d;
    p2 = (unsigned qword *) s;
    p1[0] = p2[0];
    s+= lx2;
    d+= lx;
  }
/*
  for (j=0; j<h; j++)
  {
    d[0] = s[0];
    d[1] = s[1];
    d[2] = s[2];
    d[3] = s[3];
    d[4] = s[4];
    d[5] = s[5];
    d[6] = s[6];
    d[7] = s[7];
    s+= lx2;
    d+= lx;
  }
*/
}

static void sv_rech(s,d,lx,lx2,h)
unsigned char *s, *d;
int lx,lx2,h;
{
/* unsigned int s1,s2; */
  register unsigned char *dp,*sp;
  int j;
  register unsigned qword *dpl;
  register unsigned UNALIGNED qword *p1;
  register unsigned UNALIGNED qword *p2;
  register unsigned qword acc1,acc2,acc3,acc4;

  sp = s;
  dp = d;
  for (j=0; j<h; j++)
  {
    dpl = (unsigned qword *) dp;
    p1 = (unsigned qword *) sp;
    p2 = (unsigned qword *) (sp+1);
    acc1 = p1[0];
    acc2 = p2[0];
    acc3 = (acc1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc4 = (acc2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc1 &= 0x00ff00ff00ff00ff;
    acc2 &= 0x00ff00ff00ff00ff;
    acc3 += acc4 + (unsigned qword) 0x0001000100010001;
    acc1 += acc2 + (unsigned qword) 0x0001000100010001;
    acc3 = (acc3 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    acc1 = (acc1 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[0] = (acc3 << 8) | acc1;
    acc1 = p1[1];
    acc2 = p2[1];
    acc3 = (acc1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc4 = (acc2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc3 += acc4 + (unsigned qword) 0x0001000100010001;
    acc1 += acc2 + (unsigned qword) 0x0001000100010001;
    acc3 = (acc3 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    acc1 = (acc1 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[1] = (acc3 << 8) | acc1;
   /*
    s1=sp[0];
    dp[0] = (unsigned int)(s1+(s2=sp[1])+1)>>1;
    dp[1] = (unsigned int)(s2+(s1=sp[2])+1)>>1;
    dp[2] = (unsigned int)(s1+(s2=sp[3])+1)>>1;
    dp[3] = (unsigned int)(s2+(s1=sp[4])+1)>>1;
    dp[4] = (unsigned int)(s1+(s2=sp[5])+1)>>1;
    dp[5] = (unsigned int)(s2+(s1=sp[6])+1)>>1;
    dp[6] = (unsigned int)(s1+(s2=sp[7])+1)>>1;
    dp[7] = (unsigned int)(s2+(s1=sp[8])+1)>>1;
    dp[8] = (unsigned int)(s1+(s2=sp[9])+1)>>1;
    dp[9] = (unsigned int)(s2+(s1=sp[10])+1)>>1;
    dp[10] = (unsigned int)(s1+(s2=sp[11])+1)>>1;
    dp[11] = (unsigned int)(s2+(s1=sp[12])+1)>>1;
    dp[12] = (unsigned int)(s1+(s2=sp[13])+1)>>1;
    dp[13] = (unsigned int)(s2+(s1=sp[14])+1)>>1;
    dp[14] = (unsigned int)(s1+(s2=sp[15])+1)>>1;
    dp[15] = (unsigned int)(s2+sp[16]+1)>>1;
*/
    sp+= lx2;
    dp+= lx;
  }
}

static void sv_rechc(s,d,lx,lx2,h)
unsigned char *s, *d;
int lx,lx2,h;
{
/*  unsigned int s1,s2; */
  register unsigned char *dp,*sp;
  int j;
  unsigned qword *dpl;
  unsigned UNALIGNED qword *p1;
  unsigned UNALIGNED qword *p2;
  unsigned qword acc1,acc2,acc3,acc4;

  sp = s;
  dp = d;
  for (j=0; j<h; j++)
  {
    dpl = (unsigned qword *) dp;
    p1 = (unsigned qword *) sp;
    p2 = (unsigned qword *) (sp+1);
    acc1 = p1[0];
    acc2 = p2[0];
    acc3 = (acc1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc4 = (acc2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc3 += acc4 + (unsigned qword) 0x0001000100010001;
    acc1 += acc2 + (unsigned qword) 0x0001000100010001;
    acc3 = (acc3 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    acc1 = (acc1 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[0] = (acc3 << 8) | acc1;
/*
    s1=sp[0];
    dp[0] = (unsigned int)(s1+(s2=sp[1])+1)>>1;
    dp[1] = (unsigned int)(s2+(s1=sp[2])+1)>>1;
    dp[2] = (unsigned int)(s1+(s2=sp[3])+1)>>1;
    dp[3] = (unsigned int)(s2+(s1=sp[4])+1)>>1;
    dp[4] = (unsigned int)(s1+(s2=sp[5])+1)>>1;
    dp[5] = (unsigned int)(s2+(s1=sp[6])+1)>>1;
    dp[6] = (unsigned int)(s1+(s2=sp[7])+1)>>1;
    dp[7] = (unsigned int)(s2+sp[8]+1)>>1;
*/
    sp+= lx2;
    dp+= lx;
  }
}


static void sv_recv(s,d,lx,lx2,h)
unsigned char *s, *d;
int lx,lx2,h;
{
  register unsigned char *dp,*sp,*sp2;
  int j;
  register unsigned qword *dpl;
  register unsigned UNALIGNED qword *p1;
  register unsigned UNALIGNED qword *p2;
  register unsigned qword acc1,acc2,acc3,acc4;

  sp = s;
  sp2 = s+lx2;
  dp = d;
  for (j=0; j<h; j++)
  {
    dpl = (unsigned qword *) dp;
    p1 = (unsigned qword *) sp;
    p2 = (unsigned qword *) sp2;
    acc1 = p1[0];
    acc2 = p2[0];
    acc3 = (acc1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc4 = (acc2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc3 += acc4 + (unsigned qword) 0x0001000100010001;
    acc1 += acc2 + (unsigned qword) 0x0001000100010001;
    acc3 = (acc3 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    acc1 = (acc1 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[0] = (acc3 << 8) | acc1;
    acc1 = p1[1];
    acc2 = p2[1];
    acc3 = (acc1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc4 = (acc2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc3 += acc4 + (unsigned qword) 0x0001000100010001;
    acc1 += acc2 + (unsigned qword) 0x0001000100010001;
    acc3 = (acc3 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    acc1 = (acc1 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[1] = (acc3 << 8) | acc1;
/*
    dp[0] = (unsigned int)(sp[0]+sp2[0]+1)>>1;
    dp[1] = (unsigned int)(sp[1]+sp2[1]+1)>>1;
    dp[2] = (unsigned int)(sp[2]+sp2[2]+1)>>1;
    dp[3] = (unsigned int)(sp[3]+sp2[3]+1)>>1;
    dp[4] = (unsigned int)(sp[4]+sp2[4]+1)>>1;
    dp[5] = (unsigned int)(sp[5]+sp2[5]+1)>>1;
    dp[6] = (unsigned int)(sp[6]+sp2[6]+1)>>1;
    dp[7] = (unsigned int)(sp[7]+sp2[7]+1)>>1;
    dp[8] = (unsigned int)(sp[8]+sp2[8]+1)>>1;
    dp[9] = (unsigned int)(sp[9]+sp2[9]+1)>>1;
    dp[10] = (unsigned int)(sp[10]+sp2[10]+1)>>1;
    dp[11] = (unsigned int)(sp[11]+sp2[11]+1)>>1;
    dp[12] = (unsigned int)(sp[12]+sp2[12]+1)>>1;
    dp[13] = (unsigned int)(sp[13]+sp2[13]+1)>>1;
    dp[14] = (unsigned int)(sp[14]+sp2[14]+1)>>1;
    dp[15] = (unsigned int)(sp[15]+sp2[15]+1)>>1;
*/
    sp+= lx2;
    sp2+= lx2;
    dp+= lx;
  }
}

static void sv_recvc(s,d,lx,lx2,h)
unsigned char *s, *d;
int lx,lx2,h;
{
  register unsigned char *dp,*sp,*sp2;
  int j;
  register unsigned qword *dpl;
  register unsigned UNALIGNED qword *p1;
  register unsigned UNALIGNED qword *p2;
  register unsigned qword acc1,acc2,acc3,acc4;

  sp = s;
  sp2 = s+lx2;
  dp = d;

  for (j=0; j<h; j++)
  {
/*
    dp[0] = (unsigned int)(sp[0]+sp2[0]+1)>>1;
    dp[1] = (unsigned int)(sp[1]+sp2[1]+1)>>1;
    dp[2] = (unsigned int)(sp[2]+sp2[2]+1)>>1;
    dp[3] = (unsigned int)(sp[3]+sp2[3]+1)>>1;
    dp[4] = (unsigned int)(sp[4]+sp2[4]+1)>>1;
    dp[5] = (unsigned int)(sp[5]+sp2[5]+1)>>1;
    dp[6] = (unsigned int)(sp[6]+sp2[6]+1)>>1;
    dp[7] = (unsigned int)(sp[7]+sp2[7]+1)>>1;
*/
    dpl = (unsigned qword *) dp;
    p1 = (unsigned qword *) sp;
    p2 = (unsigned qword *) sp2;
    acc1 = p1[0];
    acc2 = p2[0];
    acc3 = (acc1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc4 = (acc2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc3 += acc4 + (unsigned qword) 0x0001000100010001;
    acc1 += acc2 + (unsigned qword) 0x0001000100010001;
    acc3 = (acc3 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    acc1 = (acc1 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[0] = (acc3 << 8) | acc1;

    sp+= lx2;
    sp2+= lx2;
    dp+= lx;
  }
}


static void sv_rec4(s,d,lx,lx2,h)
unsigned char *s, *d;
int lx,lx2,h;
{
/*  unsigned int s1,s2,s3,s4; */
  register unsigned char *dp,*sp,*sp2;
  int j;
  register unsigned qword *dpl;
  register unsigned UNALIGNED qword *u1;
  register unsigned UNALIGNED qword *u2;
  register unsigned UNALIGNED qword *l1;
  register unsigned UNALIGNED qword *l2;
  unsigned qword odd1,odd2,even1,even2,oddacc,evenacc;


  sp = s;
  sp2 = s+lx2;
  dp = d;
  for (j=0; j<h; j++)
  {
/*
    s1=sp[0]; s3=sp2[0];
    dp[0] = (unsigned int)(s1+(s2=sp[1])+s3+(s4=sp2[1])+2)>>2;
    dp[1] = (unsigned int)(s2+(s1=sp[2])+s4+(s3=sp2[2])+2)>>2;
    dp[2] = (unsigned int)(s1+(s2=sp[3])+s3+(s4=sp2[3])+2)>>2;
    dp[3] = (unsigned int)(s2+(s1=sp[4])+s4+(s3=sp2[4])+2)>>2;
    dp[4] = (unsigned int)(s1+(s2=sp[5])+s3+(s4=sp2[5])+2)>>2;
    dp[5] = (unsigned int)(s2+(s1=sp[6])+s4+(s3=sp2[6])+2)>>2;
    dp[6] = (unsigned int)(s1+(s2=sp[7])+s3+(s4=sp2[7])+2)>>2;
    dp[7] = (unsigned int)(s2+(s1=sp[8])+s4+(s3=sp2[8])+2)>>2;
    dp[8] = (unsigned int)(s1+(s2=sp[9])+s3+(s4=sp2[9])+2)>>2;
    dp[9] = (unsigned int)(s2+(s1=sp[10])+s4+(s3=sp2[10])+2)>>2;
    dp[10] = (unsigned int)(s1+(s2=sp[11])+s3+(s4=sp2[11])+2)>>2;
    dp[11] = (unsigned int)(s2+(s1=sp[12])+s4+(s3=sp2[12])+2)>>2;
    dp[12] = (unsigned int)(s1+(s2=sp[13])+s3+(s4=sp2[13])+2)>>2;
    dp[13] = (unsigned int)(s2+(s1=sp[14])+s4+(s3=sp2[14])+2)>>2;
    dp[14] = (unsigned int)(s1+(s2=sp[15])+s3+(s4=sp2[15])+2)>>2;
    dp[15] = (unsigned int)(s2+sp[16]+s4+sp2[16]+2)>>2;
*/
    dpl = (unsigned qword *) dp;
    u1 = (unsigned qword *) sp;
    u2 = (unsigned qword *) (sp+1);
    l1 = (unsigned qword *) sp2;
    l2 = (unsigned qword *) (sp2+1);
    odd1 = u1[0];
    odd2 = u2[0];
    even1 = (odd1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    even2 = (odd2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    odd1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    odd2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    oddacc = odd1 + odd2;
    evenacc = even1 + even2;
    odd1 = l1[0];
    odd2 = l2[0];
    even1 = (odd1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    even2 = (odd2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    odd1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    odd2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    oddacc += odd1 + odd2 + (unsigned qword) 0x0002000200020002;
    evenacc += even1 + even2 + (unsigned qword) 0x0002000200020002;
    evenacc = (evenacc >> 2) & (unsigned qword) 0x00ff00ff00ff00ff;
    oddacc = (oddacc >> 2) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[0] = (evenacc << 8) | oddacc;

    odd1 = u1[1];
    odd2 = u2[1];
    even1 = (odd1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    even2 = (odd2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    odd1 &= (unsigned qword)0x00ff00ff00ff00ff;
    odd2 &= (unsigned qword)0x00ff00ff00ff00ff;
    oddacc = odd1 + odd2;
    evenacc = even1 + even2;
    odd1 = l1[1];
    odd2 = l2[1];
    even1 = (odd1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    even2 = (odd2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    odd1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    odd2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    oddacc += odd1 + odd2 + (unsigned qword) 0x0002000200020002;
    evenacc += even1 + even2 + (unsigned qword) 0x0002000200020002;
    evenacc = (evenacc >> 2) & (unsigned qword) 0x00ff00ff00ff00ff;
    oddacc = (oddacc >> 2) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[1] = (evenacc << 8) | oddacc;

    sp+= lx2;
    sp2+= lx2;
    dp+= lx;
  }
}

static void sv_rec4c(s,d,lx,lx2,h)
unsigned char *s, *d;
int lx,lx2,h;
{
/*  unsigned int s1,s2,s3,s4; */
  register unsigned char *dp,*sp,*sp2;
  int j;
  register unsigned qword *dpl;
  register unsigned UNALIGNED qword *u1;
  register unsigned UNALIGNED qword *u2;
  register unsigned UNALIGNED qword *l1;
  register unsigned UNALIGNED qword *l2;
  unsigned qword odd1,odd2,even1,even2,oddacc,evenacc;

  sp = s;
  sp2 = s+lx2;
  dp = d;
  for (j=0; j<h; j++)
  {
 /*

    s1=sp[0]; s3=sp2[0];
    dp[0] = (unsigned int)(s1+(s2=sp[1])+s3+(s4=sp2[1])+2)>>2;
    dp[1] = (unsigned int)(s2+(s1=sp[2])+s4+(s3=sp2[2])+2)>>2;
    dp[2] = (unsigned int)(s1+(s2=sp[3])+s3+(s4=sp2[3])+2)>>2;
    dp[3] = (unsigned int)(s2+(s1=sp[4])+s4+(s3=sp2[4])+2)>>2;
    dp[4] = (unsigned int)(s1+(s2=sp[5])+s3+(s4=sp2[5])+2)>>2;
    dp[5] = (unsigned int)(s2+(s1=sp[6])+s4+(s3=sp2[6])+2)>>2;
    dp[6] = (unsigned int)(s1+(s2=sp[7])+s3+(s4=sp2[7])+2)>>2;
    dp[7] = (unsigned int)(s2+sp[8]+s4+sp2[8]+2)>>2;
*/

    dpl = (unsigned qword *) dp;
    u1 = (unsigned qword *) sp;
    u2 = (unsigned qword *) (sp+1);
    l1 = (unsigned qword *) sp2;
    l2 = (unsigned qword *) (sp2+1);
    odd1 = u1[0];
    odd2 = u2[0];
    even1 = (odd1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    even2 = (odd2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    odd1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    odd2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    oddacc = odd1 + odd2;
    evenacc = even1 + even2;
    odd1 = l1[0];
    odd2 = l2[0];
    even1 = (odd1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    even2 = (odd2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    odd1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    odd2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    oddacc += odd1 + odd2 + (unsigned qword) 0x0002000200020002;
    evenacc += even1 + even2 + (unsigned qword) 0x0002000200020002;
    evenacc = (evenacc >> 2) & (unsigned qword) 0x00ff00ff00ff00ff;
    oddacc = (oddacc >> 2) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[0] = (evenacc << 8) | oddacc;
    sp+= lx2;
    sp2+= lx2;
    dp+= lx;
  }
}

static int DEC_OM[4][8][8] =
{{
  {1,1,1,1,1,1,1,1},
  {0,0,1,1,1,1,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
},{
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,1,1,1,1,0,0},
  {1,1,1,1,1,1,1,1},
},{
  {0,0,0,0,0,0,0,1},
  {0,0,0,0,0,0,1,1},
  {0,0,0,0,0,0,1,1},
  {0,0,0,0,0,0,1,1},
  {0,0,0,0,0,0,1,1},
  {0,0,0,0,0,0,1,1},
  {0,0,0,0,0,0,1,1},
  {0,0,0,0,0,0,0,1},
},{
  {1,0,0,0,0,0,0,0},
  {1,1,0,0,0,0,0,0},
  {1,1,0,0,0,0,0,0},
  {1,1,0,0,0,0,0,0},
  {1,1,0,0,0,0,0,0},
  {1,1,0,0,0,0,0,0},
  {1,1,0,0,0,0,0,0},
  {1,0,0,0,0,0,0,0},
} };

static void sv_reco(s,d,lx2,c,xa,xb,ya,yb)
unsigned char *s;
int *d;
int lx2,c,xa,xb,ya,yb;
{
  int i,j;

  switch(c) {

  case 0:
    *d++ = (unsigned int)s[0] << 2;
    for (i = 1; i < 7; i++) *d++ = (unsigned int)s[i] * 5 ;
    *d++ = (unsigned int)s[7] << 2;
    s+= lx2; 
	
    for (i = 0; i < 8; i++) *d++ = (unsigned int)s[i] * 5 ;
    s+= lx2; 

    for (j = 2; j < 6; j++) {
      *d++ = (unsigned int)s[0] * 5;
      *d++ = (unsigned int)s[1] * 5;
      for (i = 2; i < 6; i++) *d++ = (unsigned int)s[i] * 6 ;
      *d++ = (unsigned int)s[6] * 5;
      *d++ = (unsigned int)s[7] * 5;
      s+= lx2; 
    }

    for (i = 0; i < 8; i++) *d++ = (unsigned int)s[i] * 5 ;
    s+= lx2; 

    *d++ = (unsigned int)s[0] << 2;
    for (i = 1; i < 7; i++) *d++ = (unsigned int)s[i] * 5 ;
    *d++ = (unsigned int)s[7] << 2;
  	break;

  case 1:
    *d++ += ((unsigned int)s[0] << 1);
    *d++ += ((unsigned int)s[1] << 1);
    *d++ += ((unsigned int)s[2] << 1);
    *d++ += ((unsigned int)s[3] << 1);
    *d++ += ((unsigned int)s[4] << 1);
    *d++ += ((unsigned int)s[5] << 1);
    *d++ += ((unsigned int)s[6] << 1);
    *d++ += ((unsigned int)s[7] << 1);
    s += lx2;

    *d++ += s[0];
    *d++ += s[1];
    *d++ += ((unsigned int)s[2] << 1);
    *d++ += ((unsigned int)s[3] << 1);
    *d++ += ((unsigned int)s[4] << 1);
    *d++ += ((unsigned int)s[5] << 1);
    *d++ += s[6];
    *d++ += s[7];
	s += lx2; 

    for (j=2; j<4; j++) {
      *d++ += s[0];
      *d++ += s[1];
      *d++ += s[2];
      *d++ += s[3];
      *d++ += s[4];
      *d++ += s[5];
      *d++ += s[6];
      *d++ += s[7];
	  s += lx2; 
    }
  	break;

  case 2:
   for (j=0; j<2; j++) {
      *d++ += s[0];
      *d++ += s[1];
      *d++ += s[2];
      *d++ += s[3];
      *d++ += s[4];
      *d++ += s[5];
      *d++ += s[6];
      *d++ += s[7];
	  s += lx2;  
    }
    *d++ += s[0];
    *d++ += s[1];
    *d++ += ((unsigned int)s[2] << 1);
    *d++ += ((unsigned int)s[3] << 1);
    *d++ += ((unsigned int)s[4] << 1);
    *d++ += ((unsigned int)s[5] << 1);
    *d++ += s[6];
    *d++ += s[7];
	s += lx2; 

    *d++ += ((unsigned int)s[0] << 1);
    *d++ += ((unsigned int)s[1] << 1);
    *d++ += ((unsigned int)s[2] << 1);
    *d++ += ((unsigned int)s[3] << 1);
    *d++ += ((unsigned int)s[4] << 1);
    *d++ += ((unsigned int)s[5] << 1);
    *d++ += ((unsigned int)s[6] << 1);
    *d++ += ((unsigned int)s[7] << 1);
    s += lx2; 
    break;

  case 3:
    d[4] += s[4];
    d[5] += s[5];
    d[6] += s[6];
    d[7] += ((unsigned int)s[7] << 1) ;
	s += lx2; d += 8;

    for (j=0; j<6; j++) {
      d[4] += s[4];
	  d[5] += s[5];
      d[6] += ((unsigned int)s[6] << 1) ;
      d[7] += ((unsigned int)s[7] << 1) ;
	  s += lx2; d += 8;
    }

    d[4] += s[4];
    d[5] += s[5];
    d[6] += s[6];
    d[7] += ((unsigned int)s[7] << 1) ;
	break;

  case 4:
    d[0] += ((unsigned int)s[0] << 1) ;
    d[1] += s[1];
    d[2] += s[2];
    d[3] += s[3];
    s += lx2; d += 8;

    for (j=0; j<6; j++) {
      d[0] += ((unsigned int)s[0] << 1) ;
      d[1] += ((unsigned int)s[1] << 1) ;
      d[2] += s[2];
	  d[3] += s[3];
	  s += lx2; d += 8;
    }

    d[0] += ((unsigned int)s[0] << 1) ;
    d[1] += s[1];
    d[2] += s[2];
    d[3] += s[3];

  default:
  break;
  }
}

static void sv_recvo(s,d,lx2,c,xa,xb,ya,yb)
unsigned char *s;
int *d;
int lx2,c,xa,xb,ya,yb;
{
  register int *dp,*om;
  register unsigned char *sp,*sp2;
  int i,j;

  sp = s;
  sp2 = s+lx2;
  dp = d;

  if(!c) {
      
    *dp++ = (unsigned int)((sp[0] + sp2[0] + 1) >> 1) << 2;
    for (i = 1; i < 7; i++) *dp++ = ((unsigned int)(sp[i] + sp2[i] + 1)>>1) * 5 ;
    *dp++ = (unsigned int)((sp[7] + sp2[7] + 1) >> 1) << 2;
    sp  += lx2; sp2 += lx2; 
	
    for (i = 0; i < 8; i++) *dp++ = ((unsigned int)(sp[i] + sp2[i] + 1)>>1) * 5 ;
    sp  += lx2; sp2 += lx2; 

    for (j = 2; j < 6; j++) {
      *dp++ = ((unsigned int)(sp[0] + sp2[0] + 1)>>1) * 5;
      *dp++ = ((unsigned int)(sp[1] + sp2[1] + 1)>>1) * 5;
      for (i = 2; i < 6; i++) *dp++ = ((unsigned int)(sp[i] + sp2[i] + 1)>>1) * 6 ;
      *dp++ = ((unsigned int)(sp[6] + sp2[6] + 1)>>1) * 5;
      *dp++ = ((unsigned int)(sp[7] + sp2[7] + 1)>>1) * 5;
      sp+= lx2; sp2+=lx2;  
    }

    for (i = 0; i < 8; i++) *dp++ = ((unsigned int)(sp[i] + sp2[i] + 1)>>1) * 5 ;
    sp+= lx2; sp2+=lx2; 

    *dp++ = (unsigned int)((sp[0] + sp2[0] + 1) >> 1) << 2;
    for (i = 1; i < 7; i++) *dp++ = ((unsigned int)(sp[i] + sp2[i] + 1)>>1) * 5 ;
    *dp++ =  (unsigned int)((sp[7] + sp2[7] + 1) >> 1) << 2;
  }
  else {
	om = &DEC_OM[c-1][ya][0];
    for (j = ya; j < yb; j++) {
      for (i = xa; i < xb; i++) 
        dp[i] += (((unsigned int)(sp[i] + sp2[i] + 1)>>1) << om[i]) ;
        
      sp  += lx2; sp2 += lx2; dp  += 8; om  += 8;
    }
  }
}

static void sv_recho(s,d,lx2,c,xa,xb,ya,yb)
unsigned char *s;
int *d;
int lx2,c,xa,xb,ya,yb;
{
  register int *dp,*om;
  register unsigned char *sp,tmp;
  int i,j;

  sp = s;
  dp = d;

  if(!c) {

    *dp++ = (unsigned int)((sp[0] + (tmp=sp[1]) + 1) >> 1) << 2;
    for (i = 1; i < 7; i++) 
		*dp++ = ((unsigned int)(tmp + (tmp=sp[i+1]) + 1)>>1) * 5 ;
    *dp++ = (unsigned int)((tmp + sp[8]+1) >> 1) << 2;
    sp  += lx2; 
	
	tmp = sp[0] ;
    for (i = 0; i < 8; i++) 
		*dp++ = ((unsigned int)(tmp + (tmp=sp[i+1]) + 1)>>1) * 5 ;
    sp  += lx2; 

    for (j = 2; j < 6; j++) {
      *dp++ = ((unsigned int)(sp[0] + (tmp=sp[1]) + 1)>>1) * 5;
      *dp++ = ((unsigned int)(tmp + (tmp=sp[2]) + 1)>>1) * 5;
      for (i = 2; i < 6; i++) 
		  *dp++ = ((unsigned int)(tmp + (tmp=sp[i+1]) + 1)>>1) * 6 ;
      *dp++ = ((unsigned int)(tmp + (tmp=sp[7]) + 1)>>1) * 5;
      *dp++ = ((unsigned int)(tmp + (tmp=sp[8]) + 1)>>1) * 5;
      sp+= lx2;  
    }

	tmp = sp[0];
    for (i = 0; i < 8; i++) 
		*dp++ = ((unsigned int)(tmp + (tmp=sp[i+1]) + 1)>>1) * 5 ;
    sp+= lx2; 

    *dp++ = (unsigned int)((sp[0] + (tmp=sp[1]) + 1) >> 1) << 2;
    for (i = 1; i < 7; i++) 
		*dp++ = ((unsigned int)(tmp + (tmp=sp[i+1]) + 1)>>1) * 5 ;
    *dp++ =  (unsigned int)((tmp + sp[8]+1) >> 1) << 2;
  }
  else {
    om = &DEC_OM[c-1][ya][0];
    for (j = ya; j < yb; j++) {
      tmp = sp[xa];
      for (i = xa; i < xb; i++) 
    	dp[i] += ( ((unsigned int)(tmp + (tmp=sp[i+1]) + 1)>>1) << om[i]) ;
        
      sp+= lx2; dp+= 8; om+= 8;
    }
  }
}

static void sv_rec4o(s,d,lx2,c,xa,xb,ya,yb)
unsigned char *s;
int *d;
int lx2,c,xa,xb,ya,yb;
{
  register int *dp,tmp;
  register unsigned char *sp,*sp2;
  int i,j;

  sp = s;
  sp2 = s+lx2;
  dp = d;

  switch(c) {

  case 0:
    *dp++ = (unsigned int)(sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2);
    for (i = 1; i < 7; i++) 
	  *dp++ = ((unsigned int)(tmp+(tmp=(sp[i+1]+sp2[i+1]))+2)>>2)*5 ;
    *dp++ = (unsigned int)(tmp+sp[8]+sp2[8]+2);
    sp  += lx2; sp2 += lx2; 
	
	tmp = sp[0]+sp2[0];
    for (i = 0; i < 8; i++) 
	  *dp++ = ((unsigned int)(tmp+(tmp=(sp[i+1]+sp2[i+1]))+2)>>2)*5 ;
    sp  += lx2; sp2 += lx2; 

    for (j = 2; j < 6; j++) {
      *dp++ = ((unsigned int)(sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2)*5;
      *dp++ = ((unsigned int)(tmp+(tmp=(sp[2]+sp2[2]))+2)>>2)*5;
      for (i = 2; i < 6; i++) 
		*dp++ = ((unsigned int)(tmp+(tmp=(sp[i+1]+sp2[i+1]))+2)>>2)*6 ;
      *dp++ = ((unsigned int)(tmp+(tmp=(sp[7]+sp2[7]))+2)>>2)*5;
      *dp++ = ((unsigned int)(tmp+sp[8]+sp2[8]+2)>>2)*5;
      sp+= lx2; sp2+=lx2; 
    }

	tmp = sp[0]+sp2[0];
    for (i = 0; i < 7; i++) 
	  *dp++ = ((unsigned int)(tmp+(tmp=(sp[i+1]+sp2[i+1]))+2)>>2)*5 ;
    *dp++ =  (unsigned int)((tmp+sp[8]+sp2[8]+2)>>2)*5 ;
    sp+= lx2; sp2+=lx2; 

    *dp++ = (unsigned int)(sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2);
    for (i = 1; i < 7; i++) 
	  *dp++ = ((unsigned int)(tmp+(tmp=(sp[i+1]+sp2[i+1]))+2)>>2)*5 ;
    *dp++ =  (unsigned int)(tmp+sp[8]+sp2[8]+2);
    break;

  case 1:
    *dp++ += (((unsigned int)(sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[2]+sp2[2]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[3]+sp2[3]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[4]+sp2[4]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[5]+sp2[5]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[6]+sp2[6]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[7]+sp2[7]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[8]+sp2[8]))+2)>>2) << 1);
    sp+= lx2; sp2+= lx2; 

    *dp++ += ((sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2);
    *dp++ += ((tmp+(tmp=(sp[2]+sp2[2]))+2)>>2);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[3]+sp2[3]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[4]+sp2[4]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[5]+sp2[5]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[6]+sp2[6]))+2)>>2) << 1);
    *dp++ += ((tmp+(tmp=(sp[7]+sp2[7]))+2)>>2);
    *dp++ += ((tmp+(tmp=(sp[8]+sp2[8]))+2)>>2);
    sp+= lx2; sp2+= lx2; 
    
    for (j=2; j<4; j++) {
      *dp++ += ((sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[2]+sp2[2]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[3]+sp2[3]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[4]+sp2[4]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[5]+sp2[5]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[6]+sp2[6]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[7]+sp2[7]))+2)>>2);
      *dp++ += ((tmp+sp[8]+sp2[8]+2)>>2);
      sp+= lx2; sp2+= lx2;  
    }
  	break;

  case 2:
    for (j=0; j<2; j++) {
      *dp++ += ((sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[2]+sp2[2]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[3]+sp2[3]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[4]+sp2[4]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[5]+sp2[5]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[6]+sp2[6]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[7]+sp2[7]))+2)>>2);
      *dp++ += ((tmp+sp[8]+sp2[8]+2)>>2);
      sp+= lx2; sp2+= lx2;  
    }

    *dp++ += ((sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2);
    *dp++ += ((tmp+(tmp=(sp[2]+sp2[2]))+2)>>2);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[3]+sp2[3]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[4]+sp2[4]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[5]+sp2[5]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[6]+sp2[6]))+2)>>2) << 1);
    *dp++ += ((tmp+(tmp=(sp[7]+sp2[7]))+2)>>2);
    *dp++ += ((tmp+sp[8]+sp2[8]+2)>>2);
    sp+= lx2; sp2+= lx2; 

    *dp++ += (((unsigned int)(sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[2]+sp2[2]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[3]+sp2[3]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[4]+sp2[4]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[5]+sp2[5]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[6]+sp2[6]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[7]+sp2[7]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+sp[8]+sp2[8]+2)>>2) << 1);
    break;

  case 3:
    dp[4] += ((sp[4]+sp2[4]+(tmp=(sp[5]+sp2[5]))+2)>>2);
    dp[5] += ((tmp+(tmp=(sp[6]+sp2[6]))+2)>>2);
    dp[6] += ((tmp+(tmp=(sp[7]+sp2[7]))+2)>>2);
    dp[7] += (((unsigned int)(tmp+sp[8]+sp2[8]+2)>>2) << 1) ;
    sp  += lx2; sp2 += lx2; dp  += 8; 

    for (j=0; j<6; j++) {
      dp[4] += ((sp[4]+sp2[4]+(tmp=(sp[5]+sp2[5]))+2)>>2);
	  dp[5] += ((tmp+(tmp=(sp[6]+sp2[6]))+2)>>2);
      dp[6] += (((unsigned int)(tmp+(tmp=(sp[7]+sp2[7]))+2)>>2) << 1) ;
      dp[7] += (((unsigned int)(tmp+sp[8]+sp2[8]+2)>>2) << 1) ;
      sp  += lx2; sp2 += lx2; dp  += 8; ;
    }

    dp[4] += ((sp[4]+sp2[4]+(tmp=(sp[5]+sp2[5]))+2)>>2);
    dp[5] += ((tmp+(tmp=(sp[6]+sp2[6]))+2)>>2);
    dp[6] += ((tmp+(tmp=(sp[7]+sp2[7]))+2)>>2);
    dp[7] += (((unsigned int)(tmp+sp[8]+sp2[8]+2)>>2) << 1) ;

	break;

  case 4:
    dp[0] += (((unsigned int)(sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2) << 1) ;
    dp[1] += ((tmp+(tmp=(sp[2]+sp2[2]))+2)>>2);
    dp[2] += ((tmp+(tmp=(sp[3]+sp2[3]))+2)>>2);
    dp[3] += ((tmp+sp[4]+sp2[4]+2)>>2);
    sp  += lx2; sp2 += lx2; dp  += 8; 
   
    for (j=0; j<6; j++) {
      dp[0] += (((unsigned int)(sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2) << 1) ;
      dp[1] += (((unsigned int)(tmp+(tmp=(sp[2]+sp2[2]))+2)>>2) << 1) ;
      dp[2] += ((tmp+(tmp=(sp[3]+sp2[3]))+2)>>2);
	  dp[3] += ((tmp+sp[4]+sp2[4]+2)>>2);
      sp  += lx2; sp2 += lx2; dp  += 8; 
    }

    dp[0] += (((unsigned int)(sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2) << 1) ;
    dp[1] += ((tmp+(tmp=(sp[2]+sp2[2]))+2)>>2);
    dp[2] += ((tmp+(tmp=(sp[3]+sp2[3]))+2)>>2);
    dp[3] += ((tmp+sp[4]+sp2[4]+2)>>2);

  default:
  break;
  }
}

static void sv_recon_comp_obmc(SvH263DecompressInfo_t *H263Info, unsigned char *src, unsigned char *dst,
                            int lx, int lx2, int comp, int w, int h, int x, int y)
{
  int j,k;
  int xmb,ymb;
  int c8,t8,l8,r8;
  int ti8,li8,ri8;
  int xit,xib,xir,xil;
  int yit,yib,yir,yil;
  int vect,vecb,vecr,vecl;
  int nx[5],ny[5],xint,yint,xh[5],yh[5];
  int p[64],*pd;
  unsigned char *d,*s[5];

  xmb = (x>>4)+1;
  ymb = (y>>4)+1;

  c8  = (H263Info->modemap[ymb][xmb] == H263_MODE_INTER4V ? 1 : 0);

  t8  = (H263Info->modemap[ymb-1][xmb] == H263_MODE_INTER4V ? 1 : 0);
  ti8 = (H263Info->modemap[ymb-1][xmb] == H263_MODE_INTRA ? 1 : 0);
  ti8 = (H263Info->modemap[ymb-1][xmb] == H263_MODE_INTRA_Q ? 1 : ti8);

  l8  = (H263Info->modemap[ymb][xmb-1] == H263_MODE_INTER4V ? 1 : 0);
  li8 = (H263Info->modemap[ymb][xmb-1] == H263_MODE_INTRA ? 1 : 0);
  li8 = (H263Info->modemap[ymb][xmb-1] == H263_MODE_INTRA_Q ? 1 : li8);
  
  r8  = (H263Info->modemap[ymb][xmb+1] == H263_MODE_INTER4V ? 1 : 0);
  ri8 = (H263Info->modemap[ymb][xmb+1] == H263_MODE_INTRA ? 1 : 0);
  ri8 = (H263Info->modemap[ymb][xmb+1] == H263_MODE_INTRA_Q ? 1 : ri8);

  if (H263Info->pb_frame) ti8 = li8 = ri8 = 0;

  switch (comp+1) {

    case 1:
      vect = (ti8 ? (c8 ? 1 : 0) : (t8 ? 3 : 0)); 
      yit  = (ti8 ? ymb : ymb - 1); 
      xit = xmb;
      vecb = (c8 ? 3 : 0) ; yib = ymb; xib = xmb;
      vecl = (li8 ? (c8 ? 1 : 0) : (l8 ? 2 : 0)); 
      yil = ymb; 
      xil = (li8 ? xmb : xmb-1);
      vecr = (c8 ? 2 : 0) ; yir = ymb; xir = xmb;

      /* edge handling */
      if (ymb == 1) {
        yit = ymb;
        vect = (c8 ? 1 : 0);
      }
      if (xmb == 1) {
        xil = xmb;
        vecl = (c8 ? 1 : 0);
      }
      break;
  
    case 2:
      vect = (ti8 ? (c8 ? 2 : 0) : (t8 ? 4 : 0)); 
      yit = (ti8 ? ymb : ymb-1); 
      xit = xmb;
      vecb = (c8 ? 4 : 0) ; yib = ymb; xib = xmb;
      vecl = (c8 ? 1 : 0) ; yil = ymb; xil = xmb;
      vecr = (ri8 ? (c8 ? 2 : 0) : (r8 ? 1 : 0)); 
      yir = ymb; 
      xir = (ri8 ? xmb : xmb+1);

      /* edge handling */
      if (ymb == 1) {
        yit = ymb;
        vect = (c8 ? 2 : 0);
      }
      if (xmb == H263Info->mb_width) {
        xir = xmb;
        vecr = (c8 ? 2 : 0);
      }
      break;

    case 3:
      vect = (c8 ? 1 : 0) ; yit = ymb  ; xit = xmb;
      vecb = (c8 ? 3 : 0) ; yib = ymb  ; xib = xmb;
      vecl = (li8 ? (c8 ? 3 : 0) : (l8 ? 4 : 0)); 
      yil = ymb;  
      xil = (li8 ? xmb : xmb-1);
      vecr = (c8 ? 4 : 0) ; yir = ymb  ; xir = xmb;

      /* edge handling */
      if (xmb == 1) {
        xil = xmb;
        vecl = (c8 ? 3 : 0);
      }
      break;

    case 4:
      vect = (c8 ? 2 : 0) ; yit = ymb  ; xit = xmb;
      vecb = (c8 ? 4 : 0) ; yib = ymb  ; xib = xmb;
      vecl = (c8 ? 3 : 0) ; yil = ymb  ; xil = xmb;
      vecr = (ri8 ? (c8 ? 4 : 0) : (r8 ? 3 : 0)); 
      yir = ymb; 
      xir = (ri8 ? xmb : xmb+1);

      /* edge handling */
      if (xmb == H263Info->mb_width) {
        xir = xmb;
        vecr = (c8 ? 4 : 0);
      }
      break;

    default:
      svH263Error("Illegal block number in sv_recon_comp_obmc (sv_recon.c)\n");
      break;
  }

  nx[0] = H263Info->MV[0][c8 ? comp + 1 : 0][ymb][xmb];
  ny[0] = H263Info->MV[1][c8 ? comp + 1 : 0][ymb][xmb];
  
  nx[1] = H263Info->MV[0][vect][yit][xit]; ny[1] = H263Info->MV[1][vect][yit][xit];
  nx[2] = H263Info->MV[0][vecb][yib][xib]; ny[2] = H263Info->MV[1][vecb][yib][xib];
  nx[3] = H263Info->MV[0][vecr][yir][xir]; ny[3] = H263Info->MV[1][vecr][yir][xir];
  nx[4] = H263Info->MV[0][vecl][yil][xil]; ny[4] = H263Info->MV[1][vecl][yil][xil];

  for (k=0; k<5; k++) {
    xint  = nx[k]>>1;
    xh[k] = nx[k] & 1;
    yint  = ny[k]>>1;
    yh[k] = ny[k] & 1;
    s[k]  = src + lx2 * (y + yint) + x + xint;
  }
  
  d = dst + lx*y + x;
  pd = &p[0];

  if      (!xh[0] && !yh[0]) sv_reco(s[0],pd,lx2,0,0,8,0,8);
  else if (!xh[0] &&  yh[0]) sv_recvo(s[0],pd,lx2,0,0,8,0,8);
  else if ( xh[0] && !yh[0]) sv_recho(s[0],pd,lx2,0,0,8,0,8);
  else                       sv_rec4o(s[0],pd,lx2,0,0,8,0,8);

  if      (!xh[1] && !yh[1]) sv_reco(s[1],pd,lx2,1,0,8,0,4);
  else if (!xh[1] &&  yh[1]) sv_recvo(s[1],pd,lx2,1,0,8,0,4);
  else if ( xh[1] && !yh[1]) sv_recho(s[1],pd,lx2,1,0,8,0,4);
  else                       sv_rec4o(s[1],pd,lx2,1,0,8,0,4);

  if      (!xh[2] && !yh[2]) sv_reco(s[2]+(lx2<<2),pd+32,lx2,2,0,8,4,8);
  else if (!xh[2] &&  yh[2]) sv_recvo(s[2]+(lx2<<2),pd+32,lx2,2,0,8,4,8);
  else if ( xh[2] && !yh[2]) sv_recho(s[2]+(lx2<<2),pd+32,lx2,2,0,8,4,8);
  else                       sv_rec4o(s[2]+(lx2<<2),pd+32,lx2,2,0,8,4,8);

  if      (!xh[3] && !yh[3]) sv_reco(s[3],pd,lx2,3,4,8,0,8);
  else if (!xh[3] &&  yh[3]) sv_recvo(s[3],pd,lx2,3,4,8,0,8);
  else if ( xh[3] && !yh[3]) sv_recho(s[3],pd,lx2,3,4,8,0,8);
  else                       sv_rec4o(s[3],pd,lx2,3,4,8,0,8);

  if      (!xh[4] && !yh[4]) sv_reco(s[4],pd,lx2,4,0,4,0,8);
  else if (!xh[4] &&  yh[4]) sv_recvo(s[4],pd,lx2,4,0,4,0,8);
  else if ( xh[4] && !yh[4]) sv_recho(s[4],pd,lx2,4,0,4,0,8);
  else                       sv_rec4o(s[4],pd,lx2,4,0,4,0,8);

  for (j = 0; j < 8; j++) {
    d[0] = (pd[0] + 4 )>>3;	
    d[1] = (pd[1] + 4 )>>3;	
    d[2] = (pd[2] + 4 )>>3;	
    d[3] = (pd[3] + 4 )>>3;	
    d[4] = (pd[4] + 4 )>>3;	
    d[5] = (pd[5] + 4 )>>3;	
    d[6] = (pd[6] + 4 )>>3;	
    d[7] = (pd[7] + 4 )>>3;	
    d += lx;
    pd += 8;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\proto.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1994                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _SV_H263_PROTO_H_
#define _SV_H263_PROTO_H_

#include "sv_intrn.h"

#define svH263mputv(n, b)  ScBSPutBits(BSOut,b,n)
#define svH263mputb(b)     ScBSPutBit(BSOut,b?1:0)

void svH263Error(char *text);
/*
** sv_h263_getpic.c
*/
extern SvStatus_t sv_H263GetPicture(SvCodecInfo_t *Info);
/*
** sv_h263_gethdr.c
*/
extern SvStatus_t sv_H263GetHeader(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn, int *pgob);
extern SvStatus_t sv_H263StartCode(ScBitstream_t *BSIn);
/*
** sv_h263_recon.c
*/
extern void sv_H263Reconstruct(SvH263DecompressInfo_t *H263Info, int bx, int by, int P, int bdx, int bdy);
/*
** sv_h263_getvlc.c
*/
extern int sv_H263GetTMNMV(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn);
extern int sv_H263GetMCBPC(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn);
extern int sv_H263GetMODB(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn);
extern int sv_H263GetMCBPCintra(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn);
extern int sv_H263GetCBPY(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn);
/*
** sv_h263_getblk.c
*/
extern void sv_H263GetBlock(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn, int comp, int mode);
extern void sv_H263GetSACblock(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn, int comp, int ptype);
/*
** sv_h263_sac.c
*/
extern void sv_H263SACDecoderReset(ScBitstream_t *BSIn);
extern int sv_H263SACDecode_a_symbol(ScBitstream_t *BSIn, int cumul_freq[ ]);
extern int sv_H263AREncode(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                    int index, int cumul_freq[ ]);
extern int sv_H263AREncoderFlush(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut);
int sv_H263IndexFN(int value, int table[], int max);

/* sc_h263_idct3.s */
void sv_H263IDCTAddToFrameP_S(dword *inbuf,unsigned char *rfp,int incr);
void sv_H263IDCTToFrameP_S(dword *inbuf,unsigned char *rfp, int incr) ;
/*
int sv_H263lim_S(int input);
*/
int sv_H263lim_S( int input, int low, int upp) ; 


/* sv_h263_recon2.s */
void svH263Load16_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec16_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec8_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec16A_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec8A_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec16H_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec8H_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec16HA_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec8HA_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec16V_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec8V_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec16VA_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec8VA_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec16B_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec8B_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec16BA_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec8BA_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
/*
** sv_h263_encode.c
*/
void sv_H263UpdateQuality(SvCodecInfo_t *Info);
H263_PictImage *sv_H263InitImage(int size);
void sv_H263FreeImage(H263_PictImage *image);
H263_PictImage *sv_H263CodeOneIntra(SvCodecInfo_t *Info, H263_PictImage *curr,
                          H263_PictImage *recon, int QP, H263_Bits *bits, H263_Pict *pic);
void sv_H263Clip(H263_MB_Structure *data);
SvStatus_t sv_H263RefreshCompressor(SvCodecInfo_t *Info);

/*
** sv_h263_edge.c
*/
unsigned char *sv_H263EdgeGrow(unsigned char *Edge, int rows, int cols, int sr, int sc);
void sv_H263EdgeMap(unsigned char *image, unsigned char *EdgeMag, unsigned char *EdgeOrient,
                    int rows, int cols);
/*
** sv_h263_quant.c
*/
int sv_H263Quant(short *coeff, int QP, int Mode);
void sv_H263Dequant(short *qcoeff, short *rcoeff, int QP, int Mode);
/*
** sv_h263_pred.c
*/
void sv_H263PredictB(SvH263CompressInfo_t *H263Info,
            H263_PictImage *curr_image, H263_PictImage *prev_image,
			unsigned char *prev_ipol,int x, int y,
			H263_MotionVector *MV[5][H263_MBR+1][H263_MBC+2],
			H263_MB_Structure *recon_P, int TRD,int TRB,
			H263_MB_Structure *p_err, H263_MB_Structure *pred);
void sv_H263PredictP(SvH263CompressInfo_t *H263Info,
                     H263_PictImage *curr_image, H263_PictImage *prev_image,
                     unsigned char *prev_ipol, int x, int y, 
                     H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int PB,
                     H263_MB_Structure *pred_error);
void sv_H263MBReconP(SvH263CompressInfo_t *H263Info,
                     H263_PictImage *prev_image, unsigned char *prev_ipol,
                     H263_MB_Structure *diff, int x_curr, int y_curr, 
                     H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int PB,
                     H263_MB_Structure *recon_data);
void sv_H263MBReconB(SvH263CompressInfo_t *H263Info,
                     H263_PictImage *prev_image, H263_MB_Structure *diff,
                     unsigned char *prev_ipol,int x, int y,
                     H263_MotionVector *MV[5][H263_MBR+1][H263_MBC+2],
                     H263_MB_Structure *recon_P,int TRD, int TRB,
                     H263_MB_Structure *recon_B,H263_MB_Structure *pred);
void sv_H263FindHalfPel(SvH263CompressInfo_t *H263Info, 
                        int x, int y, H263_MotionVector *fr, unsigned char *prev, 
                        unsigned char *curr, int bs, int comp);
void sv_H263AdvHalfPel(SvH263CompressInfo_t *H263Info, int x, int y, 
                             H263_MotionVector *fr0, H263_MotionVector *fr1,
                             H263_MotionVector *fr2, H263_MotionVector *fr3,
                             H263_MotionVector *fr4,
                             unsigned char *prev, unsigned char *curr, 
                             int bs, int comp);

int sv_H263ChooseMode(SvH263CompressInfo_t *H263Info, unsigned char *curr, 
					  int x_pos, int y_pos, int min_SAD, int *VARmb);
/*
int sv_H263ChooseMode(SvH263CompressInfo_t *H263Info, unsigned char *curr, 
					  int x_pos, int y_pos, int min_SAD);
*/
int sv_H263ModifyMode(int Mode, int dquant);
/*
** sv_h263_putbits.c
*/
int sv_H263EqualVec(H263_MotionVector *MV2, H263_MotionVector *MV1);
void sv_H263AddBitsPicture(H263_Bits *bits);
void sv_H263AddBits(H263_Bits *total, H263_Bits *bits);
void sv_H263ZeroBits(H263_Bits *bits);
void sv_H263ZeroRes(H263_Results *res);
int sv_H263CountBitsPicture(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut, H263_Pict *pic);
int sv_H263CountBitsSlice(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                          int slice, int quant);
void sv_H263CountBitsMB(ScBitstream_t *BSOut, int Mode, int COD, int CBP,
                        int CBPB, H263_Pict *pic, H263_Bits *bits);
void sv_H263CountSACBitsMB(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                            int Mode,int COD,int CBP,int CBPB,H263_Pict *pic,H263_Bits *bits);
void sv_H263CountBitsCoeff(ScBitstream_t *BSOut, short *qcoeff, int Mode,
                           int CBP, H263_Bits *bits, int ncoeffs);
void sv_H263CountSACBitsCoeff(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                              short *qcoeff,int Mode,
                              int CBP, H263_Bits *bits, int ncoeffs);
void sv_H263CountBitsVectors(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                            H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], H263_Bits *bits, 
                            int x, int y, int Mode, int newgob, H263_Pict *pic);
void sv_H263CountSACBitsVectors(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                                H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], H263_Bits *bits,
                                int x, int y, int Mode, int newgob, H263_Pict *pic);
void sv_H263InitHuff(SvH263CompressInfo_t *H263Info);
void sv_H263FreeHuff(SvH263CompressInfo_t *H263Info);
void sv_H263FindPMV(H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int x, int y, 
                    int *pmv0, int *pmv1, int block, int newgob, int half_pel);
void sv_H263ZeroVec(H263_MotionVector *MV);
void sv_H263MarkVec(H263_MotionVector *MV);

/*
** sv_h263_morph.c
*/
H263_PictImage *sv_H263AdaptClean(SvH263CompressInfo_t *H263Info, 
                                  H263_PictImage *curr_image, int rows, int cols, int sr, int sc);
H263_PictImage **sv_H263MorphLayers(H263_PictImage *img, int depth, int rows, int cols, int sz);
/*
** sv_h263_ratectrl.c
*/
int sv_H263FrameUpdateQP(int buf, int bits, int frames_left, int QP, int B, 
                         float seconds);
/*
** sv_h263_dct.c
*/
void sv_H263init_idctref();
void sv_H263idctref(short *coeff, short *block);
int sv_H263IDCT(short *inbuf, short *outbuf, int QP, int Mode, int outbuf_size);
int sv_H263DCT( short *block, short *coeff, int QP, int Mode);

int sv_H263ZoneDCT( short *block, short *coeff, int QP, int Mode);
int sv_H263ZoneIDCT(short *inbuf, short *outbuf, int QP, int Mode, int outbuf_size);

/*
** sv_h263_motion.c
*/
void sv_H263FastME(SvH263CompressInfo_t *H263Info,
                   unsigned char *curr, unsigned char *prev, int x_curr,
		           int y_curr, int xoff, int yoff, int seek_dist, 
		           short *MVx, short *MVy, short *MVer, int *SAD_0);
void sv_H263MotionEstimation(SvH263CompressInfo_t *H263Info,
                             unsigned char *curr, unsigned char *prev, int x_curr,
                             int y_curr, int xoff, int yoff, int seek_dist, 
                             H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0);
void sv_H263FindMB(SvH263CompressInfo_t *H263Info, int x, int y, unsigned char *image, short MB[16][16]);
int sv_H263BError16x16_C(unsigned char *ii, unsigned char *aa, unsigned char *bb, 
                         int width, int min_sofar);
int sv_H263MySADBlock(unsigned char *ii, unsigned char *act_block,
                      int h_length, int lx2, int min_sofar);
void sv_H263LdSubs2Area(unsigned char *im, int x, int y, 
  	                    int x_size, int y_size, int lx, 
						unsigned char *srch_area, int area_length);
#ifdef USE_C
int sv_H263SADMacroblock(unsigned char *ii, unsigned char *act_block,
                               int h_length, int lx2, int Min_FRAME);
#endif
/*
** sv_h263_me1.c
*/
void sv_H263ME_2levels_7_1(SvH263CompressInfo_t *H263Info,
                          unsigned char *curr, unsigned char *prev, int x_curr,
                          int y_curr, int xoff, int yoff, int seek_dist, 
                          H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0);
unsigned char *sv_H263LoadSubs2Area(unsigned char *im, int x, int y, 
                                    int x_size, int y_size, int lx);
int sv_H263MySADSubBlock(unsigned char *ii, unsigned char *act_block,
	      int h_length, int min_sofar);
#ifdef USE_C
int sv_H263MySADBlock(unsigned char *ii, unsigned char *act_block,
	      int h_length, int lx2, int min_sofar);
#endif
/*
** sv_h263_me2.c
*/
void sv_H263ME_2levels_421_1(SvH263CompressInfo_t *H263Info,
                             unsigned char *curr, unsigned char *prev, int x_curr,
                             int y_curr, int xoff, int yoff, int seek_dist, 
                             H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0);
/*
** sv_h263_me3.c
*/
void sv_H263ME_2levels_7_polint(SvH263CompressInfo_t *H263Info,
                                unsigned char *curr, unsigned char *prev, int x_curr,
                                int y_curr, int xoff, int yoff, int seek_dist, 
                                H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0);
/*
** sv_h263_me4.c
*/
void sv_H263ME_2levels_7_pihp(SvH263CompressInfo_t *H263Info,
                              unsigned char *curr, unsigned char *prev, int x_curr,
                              int y_curr, int xoff, int yoff, int seek_dist, 
                              H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0);
#endif /* _SV_H263_PROTO_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sa_intrn.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sa_internals.h,v $
 * Revision 1.1.6.2  1996/11/08  21:50:56  Hans_Graves
 * 	Added AC3 stuff.
 * 	[1996/11/08  21:18:56  Hans_Graves]
 *
 * Revision 1.1.4.2  1996/03/29  22:21:09  Hans_Graves
 * 	Added MPEG_SUPPORT and GSM_SUPPORT ifdefs
 * 	[1996/03/29  21:47:46  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/07/21  17:41:04  Hans_Graves
 * 	Renamed Callback related stuff.
 * 	[1995/07/21  17:28:24  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/27  13:54:25  Hans_Graves
 * 	Added SaGSMInfo_t structure.
 * 	[1995/06/27  13:17:39  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:41  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:30:39  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/17  18:25:06  Hans_Graves
 * 	Added BSOut to CodecInfo struct for streaming
 * 	[1995/04/17  18:24:31  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:36:05  Hans_Graves
 * 	Inclusion in SLIB
 * 	[1995/04/07  19:25:01  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _SA_INTERNALS_H_
#define _SA_INTERNALS_H_

#include "SC.h"
#include "SA.h"

#ifdef MPEG_SUPPORT
#include "sa_mpeg.h"
#endif /* MPEG_SUPPORT */

#ifdef GSM_SUPPORT
#include "sa_gsm.h"
#endif /* GSM_SUPPORT */

#ifdef AC3_SUPPORT
#include "sa_ac3.h"
#endif /* AC3_SUPPORT */

#ifdef G723_SUPPORT
#include "sa_g723.h"
#endif /* G723_SUPPORT */

typedef struct SaCodecInfo_s {
  SaCodecType_e           Type;
  ScBoolean_t             started;           /* begin was called? */
  SaInfo_t                Info;

  union {
    void *info;
#ifdef MPEG_SUPPORT
    SaMpegDecompressInfo_t *MDInfo;
    SaMpegCompressInfo_t   *MCInfo;
#endif /* !MPEG_SUPPORT */
#ifdef GSM_SUPPORT
    SaGSMInfo_t            *GSMInfo;
#endif /* !GSM_SUPPORT */
#ifdef AC3_SUPPORT
    SaAC3DecompressInfo_t  *AC3Info;
#endif /* !AC3_SUPPORT */
#ifdef G723_SUPPORT
    SaG723Info_t  *pSaG723Info;
#endif /* !G723_SUPPORT */
  }; /* union */

  ScQueue_t              *Q;
  ScBitstream_t          *BSIn;
  ScBitstream_t          *BSOut;
  WAVEFORMATEX           *wfIn;
  WAVEFORMATEX           *wfOut;
  /*
   ** Callback function to control processing
   */
  int (* CallbackFunction)(SaHandle_t, SaCallbackInfo_t *, SaInfo_t *);
} SaCodecInfo_t; 

#endif _SA_INTERNALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\putbits.c ===
/* File: sv_h263_putbits.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/

#include "sv_h263.h"
#include "proto.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif

#define H263_EHUFF struct Modified_Encoder_Huffman

H263_EHUFF
{
  int n;
  int *Hlen;
  int *Hcode;
};

/* from sactbls.h */

int cumf_COD[3]={16383, 6849, 0};

int cumf_MCBPC[22]={16383, 4105, 3088, 2367, 1988, 1621, 1612, 1609, 1608, 496, 353, 195, 77, 22, 17, 12, 5, 4, 3, 2, 1, 0};

int cumf_MCBPC_intra[10]={16383, 7410, 6549, 5188, 442, 182, 181, 141, 1, 0};

int cumf_MODB[4]={16383, 6062, 2130, 0};

int cumf_YCBPB[3]={16383,6062,0};

int cumf_UVCBPB[3]={16383,491,0};

int cumf_CBPY[17]={16383, 14481, 13869, 13196, 12568, 11931, 11185, 10814, 9796, 9150, 8781, 7933, 6860, 6116, 4873, 3538, 0};

int cumf_CBPY_intra[17]={16383, 13619, 13211, 12933, 12562, 12395, 11913, 11783, 11004, 10782, 10689, 9928, 9353, 8945, 8407, 7795, 0};

int cumf_DQUANT[5]={16383, 12287, 8192, 4095, 0};

int cumf_MVD[65]={16383, 16380, 16369, 16365, 16361, 16357, 16350, 16343, 16339, 16333, 16326, 16318, 16311, 16306, 16298, 16291, 16283, 16272, 16261, 16249, 16235, 16222, 16207, 16175, 16141, 16094, 16044, 15936, 15764, 15463, 14956, 13924, 11491, 4621, 2264, 1315, 854, 583, 420, 326, 273, 229, 196, 166, 148, 137, 123, 114, 101, 91, 82, 76, 66, 59, 53, 46, 36, 30, 26, 24, 18, 14, 10, 5, 0};

int cumf_INTRADC[255]={16383, 16380, 16379, 16378, 16377, 16376, 16370, 16361, 16360, 16359, 16358, 16357, 16356, 16355, 16343, 16238, 16237, 16236, 16230, 16221, 16220, 16205, 16190, 16169, 16151, 16130, 16109, 16094, 16070, 16037, 16007, 15962, 15938, 15899, 15854, 15815, 15788, 15743, 15689, 15656, 15617, 15560, 15473, 15404, 15296, 15178, 15106, 14992, 14868, 14738, 14593, 14438, 14283, 14169, 14064, 14004, 13914, 13824, 13752, 13671, 13590, 13515, 13458, 13380, 13305, 13230, 13143, 13025, 12935, 12878, 12794, 12743, 12656, 12596, 12521, 12443, 12359, 12278, 12200, 12131, 12047, 12002, 11948, 11891, 11828, 11744, 11663, 11588, 11495, 11402, 11288, 11204, 11126, 11039, 10961, 10883, 10787, 10679, 10583, 10481, 10360, 10227, 10113, 9961, 9828, 9717, 9584, 9485, 9324, 9112, 9019, 8908, 8766, 8584, 8426, 8211, 7920, 7663, 7406, 7152, 6904, 6677, 6453, 6265, 6101, 5904, 5716, 5489, 5307, 5056, 4850, 4569, 4284, 3966, 3712, 3518, 3342, 3206, 3048, 2909, 2773, 2668, 2596, 2512, 2370, 2295, 2232, 2166, 2103, 2022, 1956, 1887, 1830, 1803, 1770, 1728, 1674, 1635, 1599, 1557, 1500, 1482, 1434, 1389, 1356, 1317, 1284, 1245, 1200, 1179, 1140, 1110, 1092, 1062, 1044, 1035, 1014, 1008, 993, 981, 954, 936, 912, 894, 876, 864, 849, 828, 816, 801, 792, 777, 756, 732, 690, 660, 642, 615, 597, 576, 555, 522, 489, 459, 435, 411, 405, 396, 387, 375, 360, 354, 345, 344, 329, 314, 293, 278, 251, 236, 230, 224, 215, 214, 208, 199, 193, 184, 178, 169, 154, 127, 100, 94, 73, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 20, 19, 18, 17, 16, 15, 9, 0};

int cumf_TCOEF1[104]={16383, 13455, 12458, 12079, 11885, 11800, 11738, 11700, 11681, 11661, 11651, 11645, 11641, 10572, 10403, 10361, 10346, 10339, 10335, 9554, 9445, 9427, 9419, 9006, 8968, 8964, 8643, 8627, 8624, 8369, 8354, 8352, 8200, 8192, 8191, 8039, 8036, 7920, 7917, 7800, 7793, 7730, 7727, 7674, 7613, 7564, 7513, 7484, 7466, 7439, 7411, 7389, 7373, 7369, 7359, 7348, 7321, 7302, 7294, 5013, 4819, 4789, 4096, 4073, 3373, 3064, 2674, 2357, 2177, 1975, 1798, 1618, 1517, 1421, 1303, 1194, 1087, 1027, 960, 890, 819, 758, 707, 680, 656, 613, 566, 534, 505, 475, 465, 449, 430, 395, 358, 335, 324, 303, 295, 286, 272, 233, 215, 0};

int cumf_TCOEF2[104]={16383, 13582, 12709, 12402, 12262, 12188, 12150, 12131, 12125, 12117, 12113, 12108, 12104, 10567, 10180, 10070, 10019, 9998, 9987, 9158, 9037, 9010, 9005, 8404, 8323, 8312, 7813, 7743, 7726, 7394, 7366, 7364, 7076, 7062, 7060, 6810, 6797, 6614, 6602, 6459, 6454, 6304, 6303, 6200, 6121, 6059, 6012, 5973, 5928, 5893, 5871, 5847, 5823, 5809, 5796, 5781, 5771, 5763, 5752, 4754, 4654, 4631, 3934, 3873, 3477, 3095, 2758, 2502, 2257, 2054, 1869, 1715, 1599, 1431, 1305, 1174, 1059, 983, 901, 839, 777, 733, 683, 658, 606, 565, 526, 488, 456, 434, 408, 380, 361, 327, 310, 296, 267, 259, 249, 239, 230, 221, 214, 0};

int cumf_TCOEF3[104]={16383, 13532, 12677, 12342, 12195, 12112, 12059, 12034, 12020, 12008, 12003, 12002, 12001, 10586, 10297, 10224, 10202, 10195, 10191, 9223, 9046, 8999, 8987, 8275, 8148, 8113, 7552, 7483, 7468, 7066, 7003, 6989, 6671, 6642, 6631, 6359, 6327, 6114, 6103, 5929, 5918, 5792, 5785, 5672, 5580, 5507, 5461, 5414, 5382, 5354, 5330, 5312, 5288, 5273, 5261, 5247, 5235, 5227, 5219, 4357, 4277, 4272, 3847, 3819, 3455, 3119, 2829, 2550, 2313, 2104, 1881, 1711, 1565, 1366, 1219, 1068, 932, 866, 799, 750, 701, 662, 605, 559, 513, 471, 432, 403, 365, 336, 312, 290, 276, 266, 254, 240, 228, 223, 216, 206, 199, 192, 189, 0};

int cumf_TCOEFr[104]={16383, 13216, 12233, 11931, 11822, 11776, 11758, 11748, 11743, 11742, 11741, 11740, 11739, 10203, 9822, 9725, 9691, 9677, 9674, 8759, 8609, 8576, 8566, 7901, 7787, 7770, 7257, 7185, 7168, 6716, 6653, 6639, 6276, 6229, 6220, 5888, 5845, 5600, 5567, 5348, 5327, 5160, 5142, 5004, 4900, 4798, 4743, 4708, 4685, 4658, 4641, 4622, 4610, 4598, 4589, 4582, 4578, 4570, 4566, 3824, 3757, 3748, 3360, 3338, 3068, 2835, 2592, 2359, 2179, 1984, 1804, 1614, 1445, 1234, 1068, 870, 739, 668, 616, 566, 532, 489, 453, 426, 385, 357, 335, 316, 297, 283, 274, 266, 259, 251, 241, 233, 226, 222, 217, 214, 211, 209, 208, 0};

int cumf_TCOEF1_intra[104]={16383, 13383, 11498, 10201, 9207, 8528, 8099, 7768, 7546, 7368, 7167, 6994, 6869, 6005, 5474, 5220, 5084, 4964, 4862, 4672, 4591, 4570, 4543, 4397, 4337, 4326, 4272, 4240, 4239, 4212, 4196, 4185, 4158, 4157, 4156, 4140, 4139, 4138, 4137, 4136, 4125, 4124, 4123, 4112, 4111, 4110, 4109, 4108, 4107, 4106, 4105, 4104, 4103, 4102, 4101, 4100, 4099, 4098, 4097, 3043, 2897, 2843, 1974, 1790, 1677, 1552, 1416, 1379, 1331, 1288, 1251, 1250, 1249, 1248, 1247, 1236, 1225, 1224, 1223, 1212, 1201, 1200, 1199, 1198, 1197, 1196, 1195, 1194, 1193, 1192, 1191, 1190, 1189, 1188, 1187, 1186, 1185, 1184, 1183, 1182, 1181, 1180, 1179, 0};

int cumf_TCOEF2_intra[104]={16383, 13242, 11417, 10134, 9254, 8507, 8012, 7556, 7273, 7062, 6924, 6839, 6741, 6108, 5851, 5785, 5719, 5687, 5655, 5028, 4917, 4864, 4845, 4416, 4159, 4074, 3903, 3871, 3870, 3765, 3752, 3751, 3659, 3606, 3580, 3541, 3540, 3514, 3495, 3494, 3493, 3474, 3473, 3441, 3440, 3439, 3438, 3425, 3424, 3423, 3422, 3421, 3420, 3401, 3400, 3399, 3398, 3397, 3396, 2530, 2419, 2360, 2241, 2228, 2017, 1687, 1576, 1478, 1320, 1281, 1242, 1229, 1197, 1178, 1152, 1133, 1114, 1101, 1088, 1087, 1086, 1085, 1072, 1071, 1070, 1069, 1068, 1067, 1066, 1065, 1064, 1063, 1062, 1061, 1060, 1059, 1058, 1057, 1056, 1055, 1054, 1053, 1052, 0};

int cumf_TCOEF3_intra[104]={16383, 12741, 10950, 10071, 9493, 9008, 8685, 8516, 8385, 8239, 8209, 8179, 8141, 6628, 5980, 5634, 5503, 5396, 5327, 4857, 4642, 4550, 4481, 4235, 4166, 4151, 3967, 3922, 3907, 3676, 3500, 3324, 3247, 3246, 3245, 3183, 3168, 3084, 3069, 3031, 3030, 3029, 3014, 3013, 2990, 2975, 2974, 2973, 2958, 2943, 2928, 2927, 2926, 2925, 2924, 2923, 2922, 2921, 2920, 2397, 2298, 2283, 1891, 1799, 1591, 1445, 1338, 1145, 1068, 1006, 791, 768, 661, 631, 630, 615, 592, 577, 576, 561, 546, 523, 508, 493, 492, 491, 476, 475, 474, 473, 472, 471, 470, 469, 468, 453, 452, 451, 450, 449, 448, 447, 446, 0};

int cumf_TCOEFr_intra[104]={16383, 12514, 10776, 9969, 9579, 9306, 9168, 9082, 9032, 9000, 8981, 8962, 8952, 7630, 7212, 7053, 6992, 6961, 6940, 6195, 5988, 5948, 5923, 5370, 5244, 5210, 4854, 4762, 4740, 4384, 4300, 4288, 4020, 3968, 3964, 3752, 3668, 3511, 3483, 3354, 3322, 3205, 3183, 3108, 3046, 2999, 2981, 2974, 2968, 2961, 2955, 2949, 2943, 2942, 2939, 2935, 2934, 2933, 2929, 2270, 2178, 2162, 1959, 1946, 1780, 1651, 1524, 1400, 1289, 1133, 1037, 942, 849, 763, 711, 591, 521, 503, 496, 474, 461, 449, 442, 436, 426, 417, 407, 394, 387, 377, 373, 370, 367, 366, 365, 364, 363, 362, 358, 355, 352, 351, 350, 0};

int cumf_SIGN[3]={16383, 8416, 0};

int cumf_LAST[3]={16383, 9469, 0};

int cumf_LAST_intra[3]={16383, 2820, 0};

int cumf_RUN[65]={16383, 15310, 14702, 13022, 11883, 11234, 10612, 10192, 9516, 9016, 8623, 8366, 7595, 7068, 6730, 6487, 6379, 6285, 6177, 6150, 6083, 5989, 5949, 5922, 5895, 5828, 5774, 5773, 5394, 5164, 5016, 4569, 4366, 4136, 4015, 3867, 3773, 3692, 3611, 3476, 3341, 3301, 2787, 2503, 2219, 1989, 1515, 1095, 934, 799, 691, 583, 435, 300, 246, 206, 125, 124, 97, 57, 30, 3, 2, 1, 0};

int cumf_RUN_intra[65]={16383, 10884, 8242, 7124, 5173, 4745, 4246, 3984, 3034, 2749, 2607, 2298, 966, 681, 396, 349, 302, 255, 254, 253, 206, 159, 158, 157, 156, 155, 154, 153, 106, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};

int cumf_LEVEL[255]={16383, 16382, 16381, 16380, 16379, 16378, 16377, 16376, 16375, 16374, 16373, 16372, 16371, 16370, 16369, 16368, 16367, 16366, 16365, 16364, 16363, 16362, 16361, 16360, 16359, 16358, 16357, 16356, 16355, 16354, 16353, 16352, 16351, 16350, 16349, 16348, 16347, 16346, 16345, 16344, 16343, 16342, 16341, 16340, 16339, 16338, 16337, 16336, 16335, 16334, 16333, 16332, 16331, 16330, 16329, 16328, 16327, 16326, 16325, 16324, 16323, 16322, 16321, 16320, 16319, 16318, 16317, 16316, 16315, 16314, 16313, 16312, 16311, 16310, 16309, 16308, 16307, 16306, 16305, 16304, 16303, 16302, 16301, 16300, 16299, 16298, 16297, 16296, 16295, 16294, 16293, 16292, 16291, 16290, 16289, 16288, 16287, 16286, 16285, 16284, 16283, 16282, 16281, 16280, 16279, 16278, 16277, 16250, 16223, 16222, 16195, 16154, 16153, 16071, 15989, 15880, 15879, 15878, 15824, 15756, 15674, 15606, 15538, 15184, 14572, 13960, 10718, 7994, 5379, 2123, 1537, 992, 693, 611, 516, 448, 421, 380, 353, 352, 284, 257, 230, 203, 162, 161, 160, 133, 132, 105, 104, 103, 102, 101, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};

int cumf_LEVEL_intra[255]={16383, 16379, 16378, 16377, 16376, 16375, 16374, 16373, 16372, 16371, 16370, 16369, 16368, 16367, 16366, 16365, 16364, 16363, 16362, 16361, 16360, 16359, 16358, 16357, 16356, 16355, 16354, 16353, 16352, 16351, 16350, 16349, 16348, 16347, 16346, 16345, 16344, 16343, 16342, 16341, 16340, 16339, 16338, 16337, 16336, 16335, 16334, 16333, 16332, 16331, 16330, 16329, 16328, 16327, 16326, 16325, 16324, 16323, 16322, 16321, 16320, 16319, 16318, 16317, 16316, 16315, 16314, 16313, 16312, 16311, 16268, 16267, 16224, 16223, 16180, 16179, 16136, 16135, 16134, 16133, 16132, 16131, 16130, 16129, 16128, 16127, 16126, 16061, 16018, 16017, 16016, 16015, 16014, 15971, 15970, 15969, 15968, 15925, 15837, 15794, 15751, 15750, 15749, 15661, 15618, 15508, 15376, 15288, 15045, 14913, 14781, 14384, 13965, 13502, 13083, 12509, 12289, 12135, 11892, 11738, 11429, 11010, 10812, 10371, 9664, 9113, 8117, 8116, 8028, 6855, 5883, 4710, 4401, 4203, 3740, 3453, 3343, 3189, 2946, 2881, 2661, 2352, 2132, 1867, 1558, 1382, 1250, 1162, 1097, 1032, 967, 835, 681, 549, 439, 351, 350, 307, 306, 305, 304, 303, 302, 301, 300, 299, 298, 255, 212, 211, 210, 167, 166, 165, 164, 163, 162, 161, 160, 159, 158, 115, 114, 113, 112, 111, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};

/* from indices.h */

int codtab[2] = {0,1};

int mcbpctab[21] = {0,16,32,48,1,17,33,49,2,18,34,50,3,19,35,51,4,20,36,52,255};

int mcbpc_intratab[9] = {3,19,35,51,4,20,36,52,255};

int cbpytab[16] = {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0};

int cbpy_intratab[16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};

int dquanttab[4] = {1,0,3,4};

int mvdtab[64] = {32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};

int intradctab[254] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,255,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254};

int tcoeftab[103] = {1,2,3,4,5,6,7,8,9,10,11,12,17,18,19,20,21,22,33,34,35,36,49,50,51,65,66,67,81,82,83,97,98,99,113,114,129,130,145,146,161,162,177,193,209,225,241,257,273,289,305,321,337,353,369,385,401,417,4097,4098,4099,4113,4114,4129,4145,4161,4177,4193,4209,4225,4241,4257,4273,4289,4305,4321,4337,4353,4369,4385,4401,4417,4433,4449,4465,4481,4497,4513,4529,4545,4561,4577,4593,4609,4625,4641,4657,4673,4689,4705,4721,4737,7167};

int signtab[2] = {0,1};

int lasttab[2] = {0,1};

int last_intratab[2] = {0,1};

int runtab[64] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};

int leveltab[254] = {129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127};


int arith_used = 0;

int CodeCoeff(ScBitstream_t *BSOut, int Mode, short *qcoeff, int block, int ncoeffs);
int Code_sac_Coeff(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut, int Mode, short *qcoeff, int block, int ncoeffs);
int CodeTCoef(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut, int mod_index, int position, int intra);

static int sv_H263HuffEncode(ScBitstream_t *BSOut, int val,H263_EHUFF *huff);

/**********************************************************************
 *
 *	Name:		CountBitsMB
 *	Description:    counts bits used for MB info
 *	
 *	Input:	        Mode, COD, CBP, Picture and Bits structures
 *	Returns:       
 *	Side effects:
 *
 ***********************************************************************/

void sv_H263CountBitsMB(ScBitstream_t *BSOut, int Mode, int COD, int CBP,
                        int CBPB, H263_Pict *pic, H263_Bits *bits)
{
  extern H263_EHUFF *vlc_cbpy, *vlc_cbpcm, *vlc_cbpcm_intra;
  int cbpy, cbpcm, length;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "sv_H263CountBitsMB(CBP=0x%X) MB=%d COD=%d\n",
                                                            CBP, pic->MB, COD) );
  if (pic->picture_coding_type == H263_PCT_INTER) {
    svH263mputv(1,COD);
    bits->COD++;
  }

  if (COD)  return;    /* not coded */

  /* CBPCM */
  cbpcm = Mode | ((CBP&3)<<4);
  _SlibDebug(_DEBUG_,
      ScDebugPrintf(NULL, "CBPCM (CBP=%d) (cbpcm=%d): \n", CBP, cbpcm) );
  if (pic->picture_coding_type == H263_PCT_INTRA)
    length = sv_H263HuffEncode(BSOut, cbpcm,vlc_cbpcm_intra);
  else
    length = sv_H263HuffEncode(BSOut, cbpcm,vlc_cbpcm);
  bits->CBPCM += length;

    /* MODB & CBPB */
  if (pic->PB) {
    switch (pic->MODB) {
    case H263_PBMODE_NORMAL:
      svH263mputv(1,0);
      bits->MODB += 1;
      break;
    case H263_PBMODE_MVDB:
      svH263mputv(2,2);
      bits->MODB += 2;
      break;
    case H263_PBMODE_CBPB_MVDB:
      svH263mputv(2,3);
      bits->MODB += 2;
      /* CBPB */
      svH263mputv(6,CBPB);
      bits->CBPB += 6;
      break;
    }
    _SlibDebug(_DEBUG_,
      ScDebugPrintf(NULL, "MODB: %d, CBPB: %d\n", pic->MODB, CBPB) );
  }
    
  /* CBPY */
  cbpy = CBP>>2;
  if (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q) /* Intra */
    cbpy = cbpy^15;
    _SlibDebug(_DEBUG_,
      ScDebugPrintf(NULL, "CBPY (CBP=%d) (cbpy=%d): \n",CBP,cbpy) );
  length = sv_H263HuffEncode(BSOut, cbpy, vlc_cbpy);
  bits->CBPY += length;
  
  /* DQUANT */
  if ((Mode == H263_MODE_INTER_Q) || (Mode == H263_MODE_INTRA_Q)) {
    switch (pic->DQUANT) {
    case -1:
      svH263mputv(2,0);
      break;
    case -2:
      svH263mputv(2,1);
      break;
    case 1:
      svH263mputv(2,2);
      break;
    case 2:
      svH263mputv(2,3);
      break;
    default:
      _SlibDebug(_WARN_,
        ScDebugPrintf(NULL, "sv_H263CountBitsMB() Invalid DQUANT: %d\n", pic->DQUANT) );
      return;
    }
    bits->DQUANT += 2;
  }
  return;
}

/**********************************************************************
 *
 *      Name:           Count_sac_BitsMB
 *      Description:    counts bits used for MB info using SAC models
 *                      modified from CountBitsMB
 *
 *      Input:          Mode, COD, CBP, Picture and Bits structures
 *      Returns:	none
 *      Side effects:	Updates Bits structure.
 *
 ***********************************************************************/
 
void sv_H263CountSACBitsMB(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                            int Mode,int COD,int CBP,int CBPB,H263_Pict *pic,H263_Bits *bits)
{
  int cbpy, cbpcm, length, i;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "sv_H263CountSACBitsMB(CBP=0x%X) MB=%d COD=%d\n",
                                                            CBP, pic->MB, COD) );
 
  arith_used = 1;
 
  /* COD */
  if (pic->picture_coding_type == H263_PCT_INTER)
    bits->COD+=sv_H263AREncode(H263Info, BSOut, COD, cumf_COD);
 
  if (COD)  return;    /* not coded */
 
  /* CBPCM */
   cbpcm = Mode | ((CBP&3)<<4);
  _SlibDebug(_DEBUG_,
      ScDebugPrintf(H263Info->dbg, "CBPCM (CBP=%d) (cbpcm=%d): \n",CBP,cbpcm) );
  if (pic->picture_coding_type == H263_PCT_INTRA)
    length = sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(cbpcm,mcbpc_intratab,9),cumf_MCBPC_intra);
  else
    length = sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(cbpcm,mcbpctab,21),cumf_MCBPC);
 
  bits->CBPCM += length;
 
  /* MODB & CBPB */
   if (pic->PB) {
     switch (pic->MODB) {
     case H263_PBMODE_NORMAL:
       bits->MODB += sv_H263AREncode(H263Info, BSOut, 0, cumf_MODB);
       break;
     case H263_PBMODE_MVDB:
       bits->MODB += sv_H263AREncode(H263Info, BSOut, 1, cumf_MODB);
       break;
     case H263_PBMODE_CBPB_MVDB:
       bits->MODB += sv_H263AREncode(H263Info, BSOut, 2, cumf_MODB);
       /* CBPB */
       for(i=5; i>1; i--)
	 bits->CBPB += sv_H263AREncode(H263Info, BSOut, ((CBPB & 1<<i)>>i), cumf_YCBPB);
       for(i=1; i>-1; i--)
	 bits->CBPB += sv_H263AREncode(H263Info, BSOut, ((CBPB & 1<<i)>>i), cumf_UVCBPB);
       break;
     }
     _SlibDebug(_VERBOSE_,
       ScDebugPrintf(H263Info->dbg, "MODB: %d, CBPB: %d\n", pic->MODB, CBPB) );
   }

  /* CBPY */
  cbpy = CBP>>2;
  if (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q) { /* Intra */
    length = sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(cbpy,cbpy_intratab,16),cumf_CBPY_intra);
  } else {
    length = sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(cbpy,cbpytab,16),cumf_CBPY);
  }
  _SlibDebug(_VERBOSE_,
      ScDebugPrintf(H263Info->dbg, "CBPY (CBP=%d) (cbpy=%d):\n",CBP,cbpy) );
  bits->CBPY += length;
 
  /* DQUANT */
  if ((Mode == H263_MODE_INTER_Q) || (Mode == H263_MODE_INTRA_Q)) {
    bits->DQUANT += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(pic->DQUANT+2,dquanttab,4), cumf_DQUANT);
  }
  return;
}


/**********************************************************************
 *
 *	Name:		CountBitsSlice
 *	Description:    couonts bits used for slice (GOB) info
 *	
 *	Input:	        slice no., quantizer
 *
 ***********************************************************************/

int sv_H263CountBitsSlice(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                          int slice, int quant)
{
  int bits = 0;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "sv_H263CountBitsSlice(slice=%d, quant=%d)\n",
                                     slice, quant) );

  if (arith_used) {
    bits+=sv_H263AREncoderFlush(H263Info, BSOut); /* Need to call before fixed length string output */
    arith_used = 0;
  }

  /* Picture Start Code */
  svH263mputv(H263_PSC_LENGTH,H263_PSC); /* PSC */
  bits += H263_PSC_LENGTH;

  /* Group Number */
  svH263mputv(5,slice);
  bits += 5;

  /* GOB Sub Bitstream Indicator */
  /* if CPM == 1: read 2 bits GSBI */
  /* not supported in this version */

  /* GOB Frame ID */

  svH263mputv(2, 0); 
  
  /* NB: in error-prone environments this value should change if 
     PTYPE in picture header changes. In this version of the encoder
     PTYPE only changes when PB-frames are used in the following cases:
     (i) after the first intra frame
     (ii) if the distance between two P-frames is very large 
     Therefore I haven't implemented this GFID change */
  /* GFID is not allowed to change unless PTYPE changes */
  bits += 2;

  /* Gquant */

  svH263mputv(5,quant);
  bits += 5;

  return bits;
}


/**********************************************************************
 *
 *	Name:		CountBitsCoeff
 *	Description:	counts bits used for coeffs
 *	
 *	Input:		qcoeff, coding mode CBP, bits structure, no. of 
 *                      coeffs
 *			
 *	Returns:	struct with no. of bits used
 *	Side effects:	
 *
 ***********************************************************************/

void sv_H263CountBitsCoeff(ScBitstream_t *BSOut, short *qcoeff, int Mode,
                           int CBP, H263_Bits *bits, int ncoeffs)
{
  int i;
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "sv_H263CountBitsCoeff(CBP=%d, ncoeffs=%d)\n",
                                       CBP, ncoeffs) );

  if (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q) {
    for (i = 0; i < 4; i++) 
      bits->Y += CodeCoeff(BSOut, Mode, qcoeff,i,ncoeffs);
    
    for (i = 4; i < 6; i++) 
      bits->C += CodeCoeff(BSOut, Mode, qcoeff,i,ncoeffs);
  }
  else {
    for (i = 0; i < 4; i++) 
      if ((i==0 && CBP&32) || (i==1 && CBP&16) || (i==2 && CBP&8) || 
	      (i==3 && CBP&4)) 
	       bits->Y += CodeCoeff(BSOut, Mode, qcoeff, i, ncoeffs);      
    
    for (i = 4; i < 6; i++) 
      if ((i==4 && CBP&2) || (i==5 && CBP&1)) 
   	    bits->C += CodeCoeff(BSOut, Mode, qcoeff, i, ncoeffs);
  }
  return;
}
  
int CodeCoeff(ScBitstream_t *BSOut, int Mode, short *qcoeff, int block, int ncoeffs)
{
  int j, jj, bits;
  int prev_run, run, prev_level, level, first;
  int prev_ind, ind, prev_s, s, length;

  extern H263_EHUFF *vlc_3d;

  run = bits = 0;
  first = 1;
  prev_run = prev_level = prev_ind = level = s = prev_s = ind = 0;
  
  jj = (block + 1)*ncoeffs;
  for (j = block*ncoeffs; j< jj; j++) {
    /* Do this block's DC-coefficient first */
    if (!(j%ncoeffs) && (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q)) {
      /* DC coeff */
      if (qcoeff[block*ncoeffs] != 128)
	     svH263mputv(8,qcoeff[block*ncoeffs]);
      else
	     svH263mputv(8,255);
      bits += 8;
    }
    else {
      /* AC coeff */
      s = 0;
      /* Increment run if coeff is zero */
      if ((level = qcoeff[j]) == 0)  run++;
      else {
	    /* code run & level and count bits */
	    if (level < 0) {
	      s = 1;
	      level = -level;
	    }
	    ind = level | run<<4;
  	    ind = ind | 0<<12; /* Not last coeff */

	    if (!first) {
	      /* Encode the previous ind */
	      if (prev_level  < 13 && prev_run < 64) 
	        length = sv_H263HuffEncode(BSOut, prev_ind,vlc_3d);
	      else length = 0;
	      if (length == 0) {  /* Escape coding */
	 	    if (prev_s == 1) {prev_level = (prev_level^0xff)+1;}
	          sv_H263HuffEncode(BSOut, H263_ESCAPE,vlc_3d);
	        svH263mputv(1,0);
	        svH263mputv(6,prev_run);
	        svH263mputv(8,prev_level);
	        bits += 22;
	      }
	      else {
	        svH263mputv(1,prev_s);
	        bits += length + 1;
	      }
	    }
	    prev_run = run; prev_s = s;
	    prev_level = level; prev_ind = ind;

	    run = first = 0;
      }
    }
  }
  /* Encode the last coeff */
  if (!first) {

    /* if (H263_trace) fprintf(H263_trace_file,"Last coeff: "); */

    prev_ind = prev_ind | 1<<12;   /* last coeff */
    if (prev_level  < 13 && prev_run < 64) 
      length = sv_H263HuffEncode(BSOut, prev_ind,vlc_3d);
    else length = 0;
    if (length == 0) {  /* Escape coding */
      if (prev_s == 1) {prev_level = (prev_level^0xff)+1;}
	  sv_H263HuffEncode(BSOut, H263_ESCAPE,vlc_3d);
      svH263mputv(1,1);
      svH263mputv(6,prev_run);
      svH263mputv(8,prev_level);
      bits += 22;
    }
	else {
      svH263mputv(1,prev_s);
      bits += length + 1;
    }
  }
  return bits;
}

/**********************************************************************
 *
 *      Name:           Count_sac_BitsCoeff
 *                      counts bits using SAC models
 *
 *      Input:          qcoeff, coding mode CBP, bits structure, no. of
 *                      coeffs
 *
 *      Returns:        struct with no. of bits used
 *      Side effects:
 *
 ***********************************************************************/
 
void sv_H263CountSACBitsCoeff(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                              short *qcoeff,int Mode,
                              int CBP, H263_Bits *bits, int ncoeffs)
{
 
  int i;
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "sv_H263CountSACBitsCoeff(CBP=%d, ncoeffs=%d)\n",
                                           CBP, ncoeffs) );

  arith_used = 1;
 
  if (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q) {
    for (i = 0; i < 4; i++) {
      bits->Y += Code_sac_Coeff(H263Info, BSOut, Mode, qcoeff,i,ncoeffs);
    }
    for (i = 4; i < 6; i++) {
      bits->C += Code_sac_Coeff(H263Info, BSOut, Mode, qcoeff,i,ncoeffs);
    }
  }
  else {
    for (i = 0; i < 4; i++) {
      if ((i==0 && CBP&32) ||
          (i==1 && CBP&16) ||
          (i==2 && CBP&8)  ||
          (i==3 && CBP&4)) { 
        bits->Y += Code_sac_Coeff(H263Info, BSOut, Mode, qcoeff, i, ncoeffs);
      }
    }
    for (i = 4; i < 6; i++) {
      if ((i==4 && CBP&2) || (i==5 && CBP&1)) 
        bits->C += Code_sac_Coeff(H263Info, BSOut, Mode, qcoeff, i, ncoeffs);
    }
  }
  return;
}
 
int Code_sac_Coeff(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                   int Mode, short *qcoeff, int block, int ncoeffs)
{
  int j, jj, bits, mod_index, intra;
  int prev_run, run, prev_level, level, first, prev_position, position;
  int prev_ind, ind, prev_s, s, length;
 
  run = bits = 0;
  first = 1; position = 0; intra = 0;
 
  level = s = ind = 0;
  prev_run = prev_level = prev_ind = prev_s = prev_position = 0;
 
  intra = (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q);
 
  jj = (block + 1)*ncoeffs;
  for (j = block*ncoeffs; j< jj; j++) {
 
    if (!(j%ncoeffs) && intra) {
      if (qcoeff[block*ncoeffs]!=128)
        mod_index = sv_H263IndexFN(qcoeff[block*ncoeffs],intradctab,254);
      else
        mod_index = sv_H263IndexFN(255,intradctab,254);
      bits += sv_H263AREncode(H263Info, BSOut, mod_index, cumf_INTRADC);
    }
    else {
 
      s = 0;
      /* Increment run if coeff is zero */
      if ((level = qcoeff[j]) == 0) {
        run++;
      }
      else {
	/* code run & level and count bits */
	if (level < 0) {
	  s = 1;
	  level = -level;
	}
	ind = level | run<<4;
	ind = ind | 0<<12; /* Not last coeff */
	position++;
 
	if (!first) {
	  mod_index = sv_H263IndexFN(prev_ind, tcoeftab, 103);
	  if (prev_level < 13 && prev_run < 64)
	    length = CodeTCoef(H263Info, BSOut, mod_index, prev_position, intra);
	  else
	    length = -1;
 
	  if (length == -1) {  /* Escape coding */
 
	    if (prev_s == 1) {prev_level = (prev_level^0xff)+1;}
 
	    mod_index = sv_H263IndexFN(H263_ESCAPE, tcoeftab, 103);
	    bits += CodeTCoef(H263Info, BSOut, mod_index, prev_position, intra);
 
	    if (intra)
	      bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(0, lasttab, 2), cumf_LAST_intra);
	    else
	      bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(0, lasttab, 2), cumf_LAST);
 
	    if (intra)
	      bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_run, runtab, 64), cumf_RUN_intra);
	    else
	      bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_run, runtab, 64), cumf_RUN);
 
	    if (intra)
	      bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_level, leveltab, 254), 
				cumf_LEVEL_intra);
	    else
	      bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_level, leveltab, 254), 
				cumf_LEVEL);
 
	  }
	  else {
	    bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_s, signtab, 2), cumf_SIGN);
	    bits += length;
	  }
	}
 
	prev_run = run; prev_s = s;
	prev_level = level; prev_ind = ind;
	prev_position = position;
 
	run = first = 0;
 
      }
    }
  }
 
  /* Encode Last Coefficient */
 
  if (!first) {
    prev_ind = prev_ind | 1<<12;   /* last coeff */
    mod_index = sv_H263IndexFN(prev_ind, tcoeftab, 103);
 
    if (prev_level  < 13 && prev_run < 64)
      length = CodeTCoef(H263Info, BSOut, mod_index, prev_position, intra);
    else
      length = -1;
 
    if (length == -1) {  /* Escape coding */

      if (prev_s == 1) {prev_level = (prev_level^0xff)+1;}
 
      mod_index = sv_H263IndexFN(H263_ESCAPE, tcoeftab, 103);
      bits += CodeTCoef(H263Info, BSOut, mod_index, prev_position, intra);
 
      if (intra)
        bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(1, lasttab, 2), cumf_LAST_intra);
      else
        bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(1, lasttab, 2), cumf_LAST);
 
      if (intra)
        bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_run, runtab, 64), cumf_RUN_intra);
      else
        bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_run, runtab, 64), cumf_RUN);
 
      if (intra)
        bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_level, leveltab, 254), cumf_LEVEL_intra);
      else
        bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_level, leveltab, 254), cumf_LEVEL);
    }
    else {
      bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_s, signtab, 2), cumf_SIGN);
      bits += length;
    }
  } /* last coeff */
 
  return bits;
}
 
/*********************************************************************
 *
 *      Name:           CodeTCoef
 *
 *      Description:    Encodes an AC Coefficient using the
 *                      relevant SAC model.
 *
 *      Input:          Model index, position in DCT block and intra/
 *			inter flag.
 *
 *      Returns:        Number of bits used.
 *
 *      Side Effects:   None
 *
 *********************************************************************/

int CodeTCoef(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut, int mod_index, int position, int intra)
{
  int length;
 
  switch (position) {
    case 1:
    {
        if (intra)
          length = sv_H263AREncode(H263Info, BSOut, mod_index, cumf_TCOEF1_intra);
        else
          length = sv_H263AREncode(H263Info, BSOut, mod_index, cumf_TCOEF1);
        break;
    }
    case 2:
    {
        if (intra)
          length = sv_H263AREncode(H263Info, BSOut, mod_index, cumf_TCOEF2_intra);
        else
          length = sv_H263AREncode(H263Info, BSOut, mod_index, cumf_TCOEF2);
        break;
    }
    case 3:
    {
        if (intra)
          length = sv_H263AREncode(H263Info, BSOut, mod_index, cumf_TCOEF3_intra);
        else
          length = sv_H263AREncode(H263Info, BSOut, mod_index, cumf_TCOEF3);
        break;
    }
    default:
    {
        if (intra)
          length = sv_H263AREncode(H263Info, BSOut, mod_index, cumf_TCOEFr_intra);
        else
          length = sv_H263AREncode(H263Info, BSOut, mod_index, cumf_TCOEFr);
        break;
    }
  }
 
  return length;
}

/**********************************************************************
 *
 *	Name:		FindCBP
 *	Description:	Finds the CBP for a macroblock
 *	
 *	Input:		qcoeff and mode
 *			
 *	Returns:	CBP
 *	Side effects:	
 *
 ***********************************************************************/

#if 0 /* merged into Quantizer */
int svH263FindCBP(short *qcoeff, int Mode, int ncoeffs)
{
  int i,j,jj;
  int CBP = 0;
  int intra = (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q);
  register short *ptr;

  /* Set CBP for this Macroblock */
  jj = ncoeffs - intra;
  qcoeff += intra;
  
  for (i=0; i < 6; i++, qcoeff += ncoeffs) {
	ptr = qcoeff; 
    for (j=0; j < jj; j++) if (*ptr++) {     
         CBP |= (32 >> i); 
		 break; 
	}
  }

  return CBP;
}
#endif

void sv_H263CountBitsVectors(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                            H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], H263_Bits *bits, 
                            int x, int y, int Mode, int newgob, H263_Pict *pic)
{
  int y_vec, x_vec;
  extern H263_EHUFF *vlc_mv;
  int pmv0, pmv1;
  int start,stop,block;
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "sv_H263CountBitsVectors(x=%d, y=%d)\n", x, y) );

  x++;y++;

  if (Mode == H263_MODE_INTER4V) {
    start = 1; stop = 4;
  }
  else {
    start = 0; stop = 0;
  }

  for (block = start; block <= stop;  block++) {

    sv_H263FindPMV(MV,x,y,&pmv0,&pmv1, block, newgob, 1);

    x_vec = (2*MV[block][y][x]->x + MV[block][y][x]->x_half) - pmv0;
    y_vec = (2*MV[block][y][x]->y + MV[block][y][x]->y_half) - pmv1;

    if (!H263Info->long_vectors) {
      if (x_vec < -32) x_vec += 64;
      else if (x_vec > 31) x_vec -= 64;

      if (y_vec < -32) y_vec += 64;
      else if (y_vec > 31) y_vec -= 64;
    }
    else {
      if (pmv0 < -31 && x_vec < -63) x_vec += 64;
      else if (pmv0 > 32 && x_vec > 63) x_vec -= 64;

      if (pmv1 < -31 && y_vec < -63) y_vec += 64;
      else if (pmv1 > 32 && y_vec > 63) y_vec -= 64;
    }
    
    if (x_vec < 0) x_vec += 64;
    if (y_vec < 0) y_vec += 64;

    bits->vec += sv_H263HuffEncode(BSOut, x_vec,vlc_mv);
    bits->vec += sv_H263HuffEncode(BSOut, y_vec,vlc_mv);

  _SlibDebug(_DEBUG_,
      if (x_vec > 31) x_vec -= 64;
      if (y_vec > 31) y_vec -= 64;
      ScDebugPrintf(H263Info->dbg, "(x,y) = (%d,%d) - ",
	      (2*MV[block][y][x]->x + MV[block][y][x]->x_half),
	      (2*MV[block][y][x]->y + MV[block][y][x]->y_half));
      ScDebugPrintf(H263Info->dbg, "(Px,Py) = (%d,%d)\n", pmv0,pmv1);
      ScDebugPrintf(H263Info->dbg, "(x_diff,y_diff) = (%d,%d)\n",x_vec,y_vec)
          );
  }

  /* PB-frames delta vectors */
  if (pic->PB)
    if (pic->MODB == H263_PBMODE_MVDB || pic->MODB == H263_PBMODE_CBPB_MVDB) {

      x_vec = MV[5][y][x]->x;
      y_vec = MV[5][y][x]->y;

      /* x_vec and y_vec are the PB-delta vectors */
    
      if (x_vec < 0) x_vec += 64;
      if (y_vec < 0) y_vec += 64;

      bits->vec += sv_H263HuffEncode(BSOut, x_vec,vlc_mv);
      bits->vec += sv_H263HuffEncode(BSOut, y_vec,vlc_mv);

      _SlibDebug(_DEBUG_, 
         if (x_vec > 31) x_vec -= 64;
         if (y_vec > 31) y_vec -= 64;
         ScDebugPrintf(H263Info->dbg, "MVDB (x,y) = (%d,%d)\n",x_vec,y_vec) );
    }

  return;
}

void sv_H263CountSACBitsVectors(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                                H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], H263_Bits *bits,
                                int x, int y, int Mode, int newgob, H263_Pict *pic)
{
  int y_vec, x_vec;
  int pmv0, pmv1;
  int start,stop,block;
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "sv_H263CountSACBitsVectors(x=%d, y=%d)", x, y) );
 
  arith_used = 1;
  x++;y++;
 
  if (Mode == H263_MODE_INTER4V) {
    start = 1; stop = 4;
  }
  else {
    start = 0; stop = 0;
  }
 
  for (block = start; block <= stop;  block++) {
 
    sv_H263FindPMV(MV,x,y,&pmv0,&pmv1, block, newgob, 1);
 
    x_vec = (2*MV[block][y][x]->x + MV[block][y][x]->x_half) - pmv0;
    y_vec = (2*MV[block][y][x]->y + MV[block][y][x]->y_half) - pmv1;
 
    if (!H263Info->long_vectors) {
      if (x_vec < -32) x_vec += 64;
      else if (x_vec > 31) x_vec -= 64;

      if (y_vec < -32) y_vec += 64;
      else if (y_vec > 31) y_vec -= 64;
    }
    else {
      if (pmv0 < -31 && x_vec < -63) x_vec += 64;
      else if (pmv0 > 32 && x_vec > 63) x_vec -= 64;

      if (pmv1 < -31 && y_vec < -63) y_vec += 64;
      else if (pmv1 > 32 && y_vec > 63) y_vec -= 64;
    }

    if (x_vec < 0) x_vec += 64;
    if (y_vec < 0) y_vec += 64;
 
    bits->vec += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(x_vec,mvdtab,64),cumf_MVD);
    bits->vec += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(y_vec,mvdtab,64),cumf_MVD);
 
    _SlibDebug(_DEBUG_,
      if (x_vec > 31) x_vec -= 64;
      if (y_vec > 31) y_vec -= 64;
      ScDebugPrintf(H263Info->dbg, "(x,y) = (%d,%d) - ",
              (2*MV[block][y][x]->x + MV[block][y][x]->x_half),
              (2*MV[block][y][x]->y + MV[block][y][x]->y_half));
      ScDebugPrintf(H263Info->dbg, "(Px,Py) = (%d,%d)\n", pmv0,pmv1);
      ScDebugPrintf(H263Info->dbg, "(x_diff,y_diff) = (%d,%d)\n",x_vec,y_vec) );
  }

   /* PB-frames delta vectors */
  if (pic->PB)
    if (pic->MODB == H263_PBMODE_MVDB || pic->MODB == H263_PBMODE_CBPB_MVDB) {
 
      x_vec = MV[5][y][x]->x;
      y_vec = MV[5][y][x]->y;
 
      if (x_vec < -32)
 	x_vec += 64;
      else if (x_vec > 31)
 	x_vec -= 64;
      if (y_vec < -32)
 	y_vec += 64;
      else if (y_vec > 31)
 	y_vec -= 64;
      
      if (x_vec < 0) x_vec += 64;
      if (y_vec < 0) y_vec += 64;
      
      bits->vec += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(x_vec,mvdtab,64),cumf_MVD);
      bits->vec += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(y_vec,mvdtab,64),cumf_MVD);
      
      _SlibDebug(_DEBUG_, 
        if (x_vec > 31) x_vec -= 64;
        if (y_vec > 31) y_vec -= 64;
        ScDebugPrintf(H263Info->dbg, "PB delta vectors: MVDB (x,y) = (%d,%d)\n",x_vec,y_vec)
        );
    }
  
  return;
}

void sv_H263FindPMV(H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int x, int y, 
                    int *pmv0, int *pmv1, int block, int newgob, int half_pel)
{
  int p1,p2,p3;
  int xin1,xin2,xin3;
  int yin1,yin2,yin3;
  int vec1,vec2,vec3;
  int l8,o8,or8;


  l8 = o8 = or8 = 0;
  if (MV[0][y][x-1]->Mode == H263_MODE_INTER4V)
    l8 = 1;
  if (MV[0][y-1][x]->Mode == H263_MODE_INTER4V)
    o8 = 1;
  if (MV[0][y-1][x+1]->Mode == H263_MODE_INTER4V)
    or8 = 1;

  switch (block) {
  case 0: 
    vec1 = (l8 ? 2 : 0) ; yin1 = y  ; xin1 = x-1;
    vec2 = (o8 ? 3 : 0) ; yin2 = y-1; xin2 = x;
    vec3 = (or8? 3 : 0) ; yin3 = y-1; xin3 = x+1;
    break;
  case 1:
    vec1 = (l8 ? 2 : 0) ; yin1 = y  ; xin1 = x-1;
    vec2 = (o8 ? 3 : 0) ; yin2 = y-1; xin2 = x;
    vec3 = (or8? 3 : 0) ; yin3 = y-1; xin3 = x+1;
    break;
  case 2:
    vec1 = 1            ; yin1 = y  ; xin1 = x;
    vec2 = (o8 ? 4 : 0) ; yin2 = y-1; xin2 = x;
    vec3 = (or8? 3 : 0) ; yin3 = y-1; xin3 = x+1;
    break;
  case 3:
    vec1 = (l8 ? 4 : 0) ; yin1 = y  ; xin1 = x-1;
    vec2 = 1            ; yin2 = y  ; xin2 = x;
    vec3 = 2            ; yin3 = y  ; xin3 = x;
    break;
  case 4:
    vec1 = 3            ; yin1 = y  ; xin1 = x;
    vec2 = 1            ; yin2 = y  ; xin2 = x;
    vec3 = 2            ; yin3 = y  ; xin3 = x;
    break;
  default:
    _SlibDebug(_WARN_, ScDebugPrintf(NULL, "Illegal block number in FindPMV (countbit.c)\n") );
    return;
  }
  if (half_pel) {
    p1 = 2*MV[vec1][yin1][xin1]->x + MV[vec1][yin1][xin1]->x_half;
    p2 = 2*MV[vec2][yin2][xin2]->x + MV[vec2][yin2][xin2]->x_half;
    p3 = 2*MV[vec3][yin3][xin3]->x + MV[vec3][yin3][xin3]->x_half;
  }
  else {
    p1 = 2*MV[vec1][yin1][xin1]->x;
    p2 = 2*MV[vec2][yin2][xin2]->x;
    p3 = 2*MV[vec3][yin3][xin3]->x;
  }
  if (newgob && (block == 0 || block == 1 || block == 2))
    p2 = 2*H263_NO_VEC;

  if (p2 == 2*H263_NO_VEC) { p2 = p3 = p1; }

  *pmv0 = p1+p2+p3 - mmax(p1,mmax(p2,p3)) - mmin(p1,mmin(p2,p3));
    
  if (half_pel) {
    p1 = 2*MV[vec1][yin1][xin1]->y + MV[vec1][yin1][xin1]->y_half;
    p2 = 2*MV[vec2][yin2][xin2]->y + MV[vec2][yin2][xin2]->y_half;
    p3 = 2*MV[vec3][yin3][xin3]->y + MV[vec3][yin3][xin3]->y_half;
  }
  else {
    p1 = 2*MV[vec1][yin1][xin1]->y;
    p2 = 2*MV[vec2][yin2][xin2]->y;
    p3 = 2*MV[vec3][yin3][xin3]->y;
  }    
  if (newgob && (block == 0 || block == 1 || block == 2))
    p2 = 2*H263_NO_VEC;

  if (p2 == 2*H263_NO_VEC) { p2 = p3 = p1; }

  *pmv1 = p1+p2+p3 - mmax(p1,mmax(p2,p3)) - mmin(p1,mmin(p2,p3));
  
  return;
}

void sv_H263ZeroBits(H263_Bits *bits)
{
  bits->Y = 0;
  bits->C = 0;
  bits->vec = 0;
  bits->CBPY = 0;
  bits->CBPCM = 0;
  bits->MODB = 0;
  bits->CBPB = 0;
  bits->COD = 0;
  bits->DQUANT = 0;
  bits->header = 0;
  bits->total = 0;
  bits->no_inter = 0;
  bits->no_inter4v = 0;
  bits->no_intra = 0;
  return;
}
void sv_H263ZeroRes(H263_Results *res)
{
  res->SNR_l = (float)0;
  res->SNR_Cr = (float)0;
  res->SNR_Cb = (float)0;
  res->QP_mean = (float)0;
}
void sv_H263AddBits(H263_Bits *total, H263_Bits *bits)
{
  total->Y += bits->Y;
  total->C += bits->C;
  total->vec += bits->vec;
  total->CBPY += bits->CBPY;
  total->CBPCM += bits->CBPCM;
  total->MODB += bits->MODB;
  total->CBPB += bits->CBPB;
  total->COD += bits->COD;
  total->DQUANT += bits->DQUANT;
  total->header += bits->header;
  total->total += bits->total;
  total->no_inter += bits->no_inter;
  total->no_inter4v += bits->no_inter4v;
  total->no_intra += bits->no_intra;
  return;
}
void sv_H263AddRes(H263_Results *total, H263_Results *res, H263_Pict *pic)
{
  total->SNR_l += res->SNR_l;
  total->SNR_Cr += res->SNR_Cr;
  total->SNR_Cb += res->SNR_Cb;
  total->QP_mean += pic->QP_mean;

  return;
}

void sv_H263AddBitsPicture(H263_Bits *bits)
{
  bits->total = 
    bits->Y + 
    bits->C + 
    bits->vec +  
    bits->CBPY + 
    bits->CBPCM + 
    bits->MODB +
    bits->CBPB +
    bits->COD + 
    bits->DQUANT +
    bits->header ;
}

void sv_H263ZeroVec(H263_MotionVector *MV)
{
  MV->x = 0;
  MV->y = 0;
  MV->x_half = 0;
  MV->y_half = 0;
  return;
}

void sv_H263MarkVec(H263_MotionVector *MV)
{
  MV->x = H263_NO_VEC;
  MV->y = H263_NO_VEC;
  MV->x_half = 0;
  MV->y_half = 0;
  return;
}

void svH263CopyVec(H263_MotionVector *MV2, H263_MotionVector *MV1)
{
  MV2->x = MV1->x;
  MV2->x_half = MV1->x_half;
  MV2->y = MV1->y;
  MV2->y_half = MV1->y_half;
  return;
}

int sv_H263EqualVec(H263_MotionVector *MV2, H263_MotionVector *MV1)
{
  if (MV1->x != MV2->x)
    return 0;
  if (MV1->y != MV2->y)
    return 0;
  if (MV1->x_half != MV2->x_half)
    return 0;
  if (MV1->y_half != MV2->y_half)
    return 0;
  return 1;
}

/**********************************************************************
 *
 *	Name:		CountBitsPicture(Pict *pic)
 *	Description:    counts the number of bits needed for picture
 *                      header
 *	
 *	Input:	        pointer to picture structure
 *	Returns:        number of bits
 *	Side effects:
 *
 ***********************************************************************/

int sv_H263CountBitsPicture(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut, H263_Pict *pic)
{
  int bits = 0;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "sv_H263CountBitsPicture(frames=%d)\n",
                                           H263Info->frames) );

  /* in case of arithmetic coding, encoder_flush() has been called before
     zeroflush() in main.c */

  /* Picture start code */
#if 0
  if (H263_trace) {    fprintf(tf,"picture_start_code: "); }
#endif
  svH263mputv(H263_PSC_LENGTH,H263_PSC);
  bits += H263_PSC_LENGTH;

  /* Group number */
#if 0
  if (H263_trace) {   fprintf(tf,"Group number in picture header: ");}
#endif
  svH263mputv(5,0); 
  bits += 5;
  
  /* Time reference */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "Time reference: %d\n", pic->TR) );
  svH263mputv(8,pic->TR);
  bits += 8;

 /* bit 1 */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "Spare: %d\n", pic->spare) );
  pic->spare = 1; /* always 1 to avoid start code emulation */
  svH263mputv(1,pic->spare);
  bits += 1;

  /* bit 2 */
#if 0
  if (H263_trace) {    fprintf(tf,"always zero for distinction with H.261\n"); }
#endif
  svH263mputv(1,0);
  bits += 1;
  
  /* bit 3 */
#if 0
  if (H263_trace) {   fprintf(tf,"split_screen_indicator: ");  }
#endif
  svH263mputv(1,0);     /* no support for split-screen in this software */
  bits += 1;

  /* bit 4 */
#if 0
  if (H263_trace) {   fprintf(tf,"document_camera_indicator: ");  }
#endif
  svH263mputv(1,0);
  bits += 1;

  /* bit 5 */
#if 0
  if (H263_trace) {   fprintf(tf,"freeze_picture_release: "); }
#endif
  svH263mputv(1,0);
  bits += 1;

  /* bit 6-8 */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "source_format: %d\n", pic->source_format) );
  svH263mputv(3,pic->source_format);
  bits += 3;

  /* bit 9 */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "picture_coding_type: %d\n",
                                                pic->picture_coding_type) );
  svH263mputv(1,pic->picture_coding_type);
  bits += 1;

  /* bit 10 */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "mv_outside_frame: %d\n",
                                                pic->unrestricted_mv_mode) );
  svH263mputv(1,pic->unrestricted_mv_mode);  /* Unrestricted Motion Vector mode */
  bits += 1;

  /* bit 11 */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "sac_coding: %d\n",
                                                H263Info->syntax_arith_coding) );
  svH263mputv(1,H263Info->syntax_arith_coding); /* Syntax-based Arithmetic Coding mode */
  bits += 1;

  /* bit 12 */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "adv_pred_mode: %d\n", H263Info->advanced) );
  svH263mputv(1,H263Info->advanced); /* Advanced Prediction mode */
  bits += 1;

  /* bit 13 */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "PB-coded: %d\n", pic->PB) );
  svH263mputv(1,pic->PB);
  bits += 1;


  /* QUANT */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "QUANT: %d\n", pic->QUANT) );
  svH263mputv(5,pic->QUANT);
  bits += 5;

  /* Continuous Presence Multipoint (CPM) */
  svH263mputv(1,0); /* CPM is not supported in this software */
  bits += 1;

  /* Picture Sub Bitstream Indicator (PSBI) */
  /* if CPM == 1: 2 bits PSBI */
  /* not supported */

  /* extra information for PB-frames */
  if (pic->PB) {
#if 0
    if (H263_trace) {      fprintf(tf,"TRB: "); }
#endif
    svH263mputv(3,pic->TRB);
    bits += 3;

#if 0
    if (H263_trace) {      fprintf(tf,"BQUANT: ");}
#endif
    svH263mputv(2,pic->BQUANT);
    bits += 2;
    
  }

  /* PEI (extra information) */
#if 0
  if (H263_trace) { fprintf(tf,"PEI: "); }
#endif
  /* "Encoders shall not insert PSPARE until specified by the ITU" */
  svH263mputv(1,0); 
  bits += 1;

  /* PSPARE */
  /* if PEI == 1: 8 bits PSPARE + another PEI bit */
  /* not supported */

  return bits;
}

/*****************************************************************
 *
 *  huffman.c, Huffman coder for H.263 encoder 
 *  Wei-Lien Hsu
 *  Date: December 11, 1996
 *
 *****************************************************************/

/*
************************************************************
huffman.c

This file contains the Huffman routines.  They are constructed to use
no look-ahead in the stream.

************************************************************
*/


/* tables.h */
/* TMN Huffman tables */

/* Motion vectors */
int vlc_mv_coeff[] = {
32,13,5,
33,13,7,
34,12,5,
35,12,7,
36,12,9,
37,12,11,
38,12,13,
39,12,15,
40,11,9,
41,11,11,
42,11,13,
43,11,15,
44,11,17,
45,11,19,
46,11,21,
47,11,23,
48,11,25,
49,11,27,
50,11,29,
51,11,31,
52,11,33,
53,11,35,
54,10,19,
55,10,21,
56,10,23,
57,8,7,
58,8,9,
59,8,11,
60,7,7,
61,5,3,
62,4,3,
63,3,3,
 0,1,1,
 1,3,2,
 2,4,2,
 3,5,2,
 4,7,6,
 5,8,10,
 6,8,8,
 7,8,6,
 8,10,22,
 9,10,20,
10,10,18,
11,11,34,
12,11,32,
13,11,30,
14,11,28,
15,11,26,
16,11,24,
17,11,22,
18,11,20,
19,11,18,
20,11,16,
21,11,14,
22,11,12,
23,11,10,
24,11,8,
25,12,14,
26,12,12,
27,12,10,
28,12,8,
29,12,6,
30,12,4,
31,13,6,
-1,-1
};

/* CBPCM (MCBPC) */
int vlc_cbpcm_intra_coeff[] = {
3,1,1,
19,3,1,
35,3,2,
51,3,3,
4,4,1,
20,6,1,
36,6,2,
52,6,3,
255,9,1,
-1,-1
};

int vlc_cbpcm_coeff[] = {
0,1,1,
16,4,3,
32,4,2,
48,6,5,
1,3,3,
17,7,7,
33,7,6,
49,9,5,
2,3,2,
18,7,5,
34,7,4,
50,8,5,
3,5,3,
19,8,4,
35,8,3,
51,7,3,
4,6,4,
20,9,4,
36,9,3,
52,9,2,
255,9,1,
-1,-1
};


/* CBPY */
int vlc_cbpy_coeff[] = {
0,  2,3,
8,  4,11,
4,  4,10,
12, 4,9,
2,  4,8,
10, 4,7,
6,  6,3,
14, 5,5,
1,  4,6,
9,  6,2,
5,  4,5,
13, 5,4,
3,  4,4,
11, 5,3,
7,  5,2,
15, 4,3,
-1,-1
};

/* 3D VLC */
int vlc_3d_coeff[] = {
1,2,2,
2,4,15,
3,6,21,
4,7,23,
5,8,31,
6,9,37,
7,9,36,
8,10,33,
9,10,32,
10,11,7,
11,11,6,
12,11,32,
17,3,6,
18,6,20,
19,8,30,
20,10,15,
21,11,33,
22,12,80,
33,4,14,
34,8,29,
35,10,14,
36,12,81,
49,5,13,
50,9,35,
51,10,13,
65,5,12,
66,9,34,
67,12,82,
81,5,11,
82,10,12,
83,12,83,
97,6,19,
98,10,11,
99,12,84,
113,6,18,
114,10,10,
129,6,17,
130,10,9,
145,6,16,
146,10,8,
161,7,22,
162,12,85,
177,7,21,
193,7,20,
209,8,28,
225,8,27,
241,9,33,
257,9,32,
273,9,31,
289,9,30,
305,9,29,
321,9,28,
337,9,27,
353,9,26,
369,11,34,
385,11,35,
401,12,86,
417,12,87,

4097,4,7,                          /* Table for last coeff */
4098,9,25,
4099,11,5,
4113,6,15,
4114,11,4,
4129,6,14,
4145,6,13,
4161,6,12,
4177,7,19,
4193,7,18,
4209,7,17,
4225,7,16,
4241,8,26,
4257,8,25,
4273,8,24,
4289,8,23,
4305,8,22,
4321,8,21,
4337,8,20,
4353,8,19,
4369,9,24,
4385,9,23,
4401,9,22,
4417,9,21,
4433,9,20,
4449,9,19,
4465,9,18,
4481,9,17,
4497,10,7,
4513,10,6,
4529,10,5,
4545,10,4,
4561,11,36,
4577,11,37,
4593,11,38,
4609,11,39,
4625,12,88,
4641,12,89,
4657,12,90,
4673,12,91,
4689,12,92,
4705,12,93,
4721,12,94,
4737,12,95,
7167,7,3,               /* escape */
-1,-1
};


#define MakeStructure(S) (S *) ScAlloc(sizeof(S))

H263_EHUFF *vlc_3d;
H263_EHUFF *vlc_cbpcm;
H263_EHUFF *vlc_cbpcm_intra;
H263_EHUFF *vlc_cbpy;
H263_EHUFF *vlc_mv;

H263_EHUFF *MakeEhuff();
void  FreeEhuff(H263_EHUFF *eh);
void  LoadETable();


/**********************************************************************
 *
 *	Name:		InitHuff
 *	Description:   	Initializes vlc-tables
 *	
 *	Input:	      
 *	Returns:       
 *	Side effects:
 *
 ***********************************************************************/

void sv_H263InitHuff(SvH263CompressInfo_t *H263Info)
{
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "sv_H263InitHuff()\n") );
  vlc_3d = MakeEhuff(8192);
  vlc_cbpcm = MakeEhuff(256);
  vlc_cbpcm_intra = MakeEhuff(256);
  vlc_cbpy = MakeEhuff(16);
  vlc_mv = MakeEhuff(65);
  LoadETable(vlc_3d_coeff,vlc_3d);
  LoadETable(vlc_cbpcm_coeff,vlc_cbpcm);
  LoadETable(vlc_cbpcm_intra_coeff,vlc_cbpcm_intra);
  LoadETable(vlc_cbpy_coeff,vlc_cbpy);
  LoadETable(vlc_mv_coeff,vlc_mv);
  return;
}

/* FreeHuff(): Frees the VLC-tables */
void sv_H263FreeHuff(SvH263CompressInfo_t *H263Info)
{
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "sv_H263FreeHuff()\n") );
  FreeEhuff(vlc_3d);
  FreeEhuff(vlc_cbpcm);
  FreeEhuff(vlc_cbpcm_intra);
  FreeEhuff(vlc_cbpy);
  FreeEhuff(vlc_mv);
}
    
/*
MakeEhuff() constructs an encoder huff with a designated table-size.
This table-size, n, is used for the lookup of Huffman values, and must
represent the largest positive Huffman value.

*/

H263_EHUFF *MakeEhuff(int n)
{
    int i;
    H263_EHUFF *temp;

    temp = MakeStructure(H263_EHUFF);
    temp->n = n;
    temp->Hlen = (int *) ScCalloc(n*sizeof(int));
    temp->Hcode = (int *) ScCalloc(n*sizeof(int));
    for(i=0;i<n;i++)
	{
	    temp->Hlen[i] = -1;
	    temp->Hcode[i] = -1;
	}
    return(temp);
}

void FreeEhuff(H263_EHUFF *eh)
{
    ScFree(eh->Hlen);
    ScFree(eh->Hcode);
    ScFree(eh);
}

/*

LoadETable() is used to load an array into an encoder table.  The
array is grouped in triplets and the first negative value signals the
end of the table.

*/

void LoadETable(int *array,H263_EHUFF *table)
{
    while(*array>=0)
	{
	    _SlibDebug(_WARN_ && *array>table->n,
		    ScDebugPrintf(NULL, "Table overflow.\n");
            return );
	    table->Hlen[*array] = array[1];
	    table->Hcode[*array] = array[2];
	    array+=3;
	}
}

/*

PrintEhuff() prints the encoder Huffman structure passed into it.

*/

/*$void PrintEhuff(H263_EHUFF *huff)
{
    int i;

    printf("Modified Huffman Encoding Structure: %x\n",&huff);
    printf("Number of values %d\n",huff->n);
    for(i=0;i<huff->n;i++)
	{
	    if (huff->Hlen[i]>=0)
		{
		    printf("Value: %x  Length: %d  Code: %x\n",
			   i,huff->Hlen[i],huff->Hcode[i]);
		}
	}
}$*/

/*

PrintTable() prints out 256 elements in a nice byte ordered fashion.

*/
#if 0
void PrintTable(int *table)
{
    int i,j;

    for(i=0;i<16;i++)
	{
	    for(j=0;j<16;j++)
		printf("%2x ",*(table++));
	    printf("\n");
	}
}
#endif
/*
Encode() encodes a symbol according to a designated encoder Huffman
table out to the stream. It returns the number of bits written to the
stream and a zero on error.
*/

static int sv_H263HuffEncode(ScBitstream_t *BSOut, int val,H263_EHUFF *huff)
{

    if (val < 0)
    {
	    _SlibDebug(_WARN_, ScDebugPrintf(NULL, "Out of bounds val:%d.\n",val) );
	    return(-1);
    }
    else if (val >= huff->n) {
	return 0; /* No serious error, can occur with some values */
    }
    else if (huff->Hlen[val] < 0) {
	return 0;
    }
    else {
	svH263mputv(huff->Hlen[val],huff->Hcode[val]); 
	return(huff->Hlen[val]);
    }
}

/*
char *BitPrint(int length, int val)
{
    int m;
    char *bit = (char *)ScAlloc(sizeof(char)*(length+3));

    m = length;
    bit[0] = '"';
    while (m--) 
	bit[length-m] = (val & (1<<m)) ? '1' : '0';
    bit[length+1] = '"';
    bit[length+2] = '\0';
    return bit;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\quant.c ===
/* File: sv_h263_quant.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#include "sv_h263.h"
#include "proto.h"


/**********************************************************************
 *
 *	Name:		Quant
 *	Description:	quantizer for SIM3
 *	
 *	Input:		pointers to coeff and qcoeff
 *			
 *	Returns:	
 *	Side effects:	
 *
 ***********************************************************************/

int sv_H263Quant(short *coeff, int QP, int Mode)
{
  register int i;
  register int Q2, hfQ;
  register short *ptn, tmp;

  unsigned __int64 *dp ;

  if (QP) {
    Q2 = QP << 1 ;
    if(Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q) { /* Intra */

	  coeff[0] = mmax(1,mmin(254,coeff[0]/8));

	  ptn = coeff + 1;
	  if (Q2 > 10)
		  for (i=1; i < 64; i++, ptn++) *ptn /= (short)Q2;
      else
        for (i=1; i < 64; i++, ptn++) {
          if(tmp = *ptn)
	        *ptn = (tmp > 0) ? mmin(127,tmp/Q2) : mmax(-127,-(-tmp/Q2));
        }

	  /* check CBP */
      ptn = coeff + 1;
      for (i=1; i < 64; i++) if(*ptn++) return 1;

      return 0;
    }
    else { /* non Intra */
      hfQ = QP >> 1;
	  ptn = coeff;
	  if( Q2 > 10)
        for (i = 0; i < 64; i++, ptn++) {
          if(tmp = *ptn)
            *ptn = (tmp>0) ? (tmp-hfQ)/Q2 : (tmp+hfQ)/Q2 ;
        }
	  else
        for (i = 0; i < 64; i++, ptn++) {
          if(tmp = *ptn)
            *ptn = (tmp>0) ? mmin(127,(tmp-hfQ)/Q2) : mmax(-127,-((-tmp-hfQ)/Q2));
	  }
    }
  }
  /* IF(QP == 0). No quantizing.
     Used only for testing. Bitstream will not be decodable
     whether clipping is performed or not */

  /* check CBP */
  dp = (unsigned __int64 *) coeff ;
  for (i = 0; i < 16; i++) 	if(*dp++) return 1;

  return 0;
}

/**********************************************************************
 *
 *	Name:		Dequant
 *	Description:	dequantizer for SIM3
 *	
 *	Input:		pointers to coeff and qcoeff
 *			
 *	Returns:	
 *	Side effects:	
 *
 ***********************************************************************/
void sv_H263Dequant(short *qcoeff, short *rcoeff, int QP, int Mode)
{
  int i;
  register int Q2;
  register short *inptr, *outptr, tmp;
	
  inptr  = qcoeff;
  outptr = rcoeff;

  Q2 = QP << 1;
  if (QP) {
    if((QP%2) == 1){
      for (i = 0; i < 64; i++) {
        if (!(tmp = *inptr++)) *outptr++ = 0;
	    else        *outptr++ = (tmp > 0) ? Q2*tmp+QP : Q2*tmp-QP ;
	  }
    }
	else {
      for (i = 0; i < 64; i++) {
        if (!(tmp = *inptr++)) *outptr++ = 0;
	    else        *outptr++ = (tmp > 0) ? Q2*tmp+QP-1 : Q2*tmp-QP+1 ;
	  }
	}

	/* Intra */
    if (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q)
       rcoeff[0] = qcoeff[0] << 3;
  }
  else {
    /* No quantizing at all */
    for (i = 0; i < 64; i++) *outptr++ = *inptr++;
  }

  return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\render.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib_render.c,v $
 * Revision 1.1.2.3  1996/10/28  17:32:35  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:23:09  Hans_Graves]
 *
 * Revision 1.1.2.2  1996/10/12  17:18:58  Hans_Graves
 * 	Move render related code out of slib_api.c
 * 	[1996/10/11  21:19:37  Hans_Graves]
 * 
 * $EndLog$
 */

/*
#define _SLIBDEBUG_
*/

#define SLIB_INTERNAL
#include "slib.h"
#include "SC_err.h"
#include "SC_conv.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"
#define _DEBUG_     0  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#endif

SlibStatus_t slibConvertAudio(SlibInfo_t *Info,
                              void *inbuf, unsigned dword inbufsize,
                              unsigned int insps, unsigned int inbps,
                              void **poutbuf, unsigned dword *poutbufsize,
                              unsigned int outsps, unsigned int outbps,
                              unsigned int channels)
{
  char *fromptr, *toptr;
  unsigned dword outbufsize, samples, count;
  unsigned dword ratio, spsratio;
  char *outbuf;
  if (inbps==outbps && insps==outsps)/* input and output formats are the same */
  {
    if (*poutbuf==NULL)
    {
      SlibAllocSubBuffer(inbuf, inbufsize);
      *poutbuf=inbuf;
    }
    else
      memcpy(*poutbuf, inbuf, inbufsize);
    *poutbufsize=inbufsize;
    return(SlibErrorNone);
  }
  samples = inbufsize/(inbps/2);
  ratio=(insps*inbps*256)/(outsps*outbps);
  outbufsize = (inbufsize*256)/ratio;
  spsratio=(insps*256)/outsps;
  if (spsratio!=64 && spsratio!=128 && spsratio!=256 && spsratio!=512)
    return(SlibErrorUnsupportedFormat);
  if (*poutbuf==NULL)
  {
    outbuf=SlibAllocBuffer(outbufsize);
    *poutbuf=outbuf;
    if (outbuf==NULL)
      return(SlibErrorMemory);
  }
  else
    outbuf=*poutbuf;
  *poutbufsize=outbufsize;
  fromptr = (char *)inbuf;
  toptr = (char *)outbuf;
  if (inbps==16 && outbps==8) /* 16 bit -> 8 bit */
  {
    fromptr++;
    if (spsratio==64) /* insps==outsps/4 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = *fromptr+128;
          *toptr++ = *fromptr+128;
          *toptr++ = *fromptr+128;
          *toptr++ = *fromptr+128;
        }
      else
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
        }
      return(SlibErrorNone);
    }
    else if (spsratio==128) /* insps==outsps/2 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = *fromptr+128;
          *toptr++ = *fromptr+128;
        }
      else
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
        }
      return(SlibErrorNone);
    }
    else if (spsratio==256) /* insps==outsps */
    {
      for (count=inbufsize/2; count; count--, fromptr+=2)
        *toptr++ = *fromptr+128;
      return(SlibErrorNone);
    }
    else if (spsratio==512) /* insps==outsps*2 */
    {
      if (channels==1)
        for (count=inbufsize/4; count; count--, fromptr+=4)
          *toptr++ = *fromptr+128;
      else
        for (count=inbufsize/8; count; count--, fromptr+=8)
        {
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
        }
      return(SlibErrorNone);
    }
  }
  else if (inbps==8 && outbps==16) /* 8 bit -> 16 bit */
  {
    unsigned word left, right;
    if (spsratio==64) /* insps==outsps/4 */
    {
      if (channels==1)
        for (count=inbufsize; count; count--, fromptr++)
        {
          left=(*fromptr-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
        }
      else /* stereo */
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          left=(fromptr[0]-128)<<8;
          right=(fromptr[1]-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
        }
      return(SlibErrorNone);
    }
    else if (spsratio==128) /* insps==outsps/2 */
    {
      if (channels==1)
        for (count=inbufsize; count; count--, fromptr++)
        {
          left=(*fromptr-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
        }
      else /* stereo */
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          left=(fromptr[0]-128)<<8;
          right=(fromptr[1]-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
        }
      return(SlibErrorNone);
    }
    else if (spsratio==256) /* insps==outsps */
    {
      if (channels==1)
        for (count=inbufsize; count; count--, fromptr++)
        {
          left=(*fromptr-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
        }
      else /* stereo */
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          left=(fromptr[0]-128)<<8;
          right=(fromptr[1]-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
        }
      return(SlibErrorNone);
    }
    else if (spsratio==512) /* insps==outsps*2 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          left=(*fromptr-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
        }
      else /* stereo */
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          left=(fromptr[0]-128)<<8;
          right=(fromptr[1]-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
        }
      return(SlibErrorNone);
    }
  }
  else if (inbps==16 && outbps==16) /* 16 bit -> 16 bit */
  {
    if (spsratio==64) /* insps==outsps/4 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      else /* stereo */
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
        }
      return(SlibErrorNone);
    }
    else if (spsratio==128) /* insps==outsps/2 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      else /* stereo */
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
        }
      return(SlibErrorNone);
    }
    else if (spsratio==512) /* insps==outsps*2 */
    {
      if (channels==1)
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      else /* stereo */
        for (count=inbufsize/8; count; count--, fromptr+=8)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
        }
      return(SlibErrorNone);
    }
  }
  else if (inbps==8 && outbps==8) /* 8 bit -> 8 bit */
  {
    if (spsratio==64) /* insps==outsps/4 */
    {
      if (channels==1)
        for (count=inbufsize; count; count--, fromptr++)
        {
          *toptr++ = *fromptr;
          *toptr++ = *fromptr;
          *toptr++ = *fromptr;
          *toptr++ = *fromptr;
        }
      else /* stereo */
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      return(SlibErrorNone);
    }
    else if (spsratio==128) /* insps==outsps/2 */
    {
      if (channels==1)
        for (count=inbufsize; count; count--, fromptr++)
        {
          *toptr++ = *fromptr;
          *toptr++ = *fromptr;
        }
      else /* stereo */
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      return(SlibErrorNone);
    }
    else if (spsratio==512) /* insps==outsps*2 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
          *toptr++ = *fromptr;
      else /* stereo */
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      return(SlibErrorNone);
    }
  }
  *poutbufsize=0;
  return(SlibErrorUnsupportedFormat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\scon.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: scon.h,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1997                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _SCON_H_
#define _SCON_H_

#ifdef WIN32
#include <windows.h>
#endif
#include "SC.h"

typedef void       *SconHandle_t;
typedef ScBoolean_t SconBoolean_t;

typedef enum {
  SCON_MODE_NONE,
  SCON_MODE_VIDEO,  /* Video conversions */
  SCON_MODE_AUDIO   /* Audio conversions */
} SconMode_t;

typedef enum {
  SconErrorNone = 0,
  SconErrorInternal,
  SconErrorMemory,
  SconErrorBadArgument,
  SconErrorBadHandle,
  SconErrorBadMode,
  SconErrorUnsupportedFormat,
  SconErrorBufSize,
  SconErrorUnsupportedParam,
  SconErrorImageSize,        /* Invalid image height and/or width */
  SconErrorSettingNotEqual,  /* The exact Parameter setting was not accepted */
  SconErrorInit,             /* initialization error */
} SconStatus_t;

typedef enum {
  SCON_INPUT = 1,
  SCON_OUTPUT = 2,
  SCON_INPUT_AND_OUTPUT = 3,
} SconParamType_t;

typedef enum {
  /* SCON Parameters */
  SCON_PARAM_VERSION=0x00,  /* SCON version number */
  SCON_PARAM_VERSION_DATE,  /* SCON build date */
  SCON_PARAM_DEBUG,         /* debug handle */
  SCON_PARAM_KEY,           /* SCON security key */
  /* Video Parameters */
  SCON_PARAM_WIDTH=0x100,
  SCON_PARAM_HEIGHT,
  SCON_PARAM_STRIDE,            /* bytes between scan lines */
  SCON_PARAM_IMAGESIZE,
  SCON_PARAM_VIDEOFORMAT,
  SCON_PARAM_VIDEOBITS,
  SCON_PARAM_VIDEOQUALITY,      /* video quality */
} SconParameter_t;

typedef qword SconListParam1_t;
typedef qword SconListParam2_t;

typedef struct SconList_s {
  int   Enum;   /* an enumerated value associated with the entry */
  char *Name;   /* the name of an entry in the list. NULL = last entry */
  char *Desc;   /* a lengthy description of the entry */
  SconListParam1_t param1;
  SconListParam2_t param2;
} SconList_t;

/********************** Public Prototypes ***********************/
/*
 * scon_api.c
 */
EXTERN SconStatus_t SconOpen(SconHandle_t *handle, SconMode_t smode,
                             void *informat, void *outformat);
EXTERN SconStatus_t SconConvert(SconHandle_t handle, void *inbuf, dword inbufsize,
                                void *outbuf, dword outbufsize);
EXTERN SconBoolean_t SconIsSame(SconHandle_t handle);
EXTERN SconStatus_t SconClose(SconHandle_t handle);
EXTERN SconStatus_t SconSetParamInt(SconHandle_t handle, SconParamType_t ptype,
                             SconParameter_t param, long value);

#endif /* _SCON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\scon_int.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: scon_internals.h,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1997                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _SCON_INTERNALS_H_
#define _SCON_INTERNALS_H_

#include "scon.h"

typedef struct SconVideoInfo_s {
  dword         Width;
  dword         Height;
  SconBoolean_t NegHeight; /* height is negative */
  dword         Stride;
  dword         FourCC;
  dword         BPP;       /* bits per pixel */
  dword         Pixels;    /* total pixels in a frame */
  dword         ImageSize; /* image size in bytes */
  dword         RGBmasks;  /* 565, 555, 888 */
  dword         Rmask;     /* Red mask */
  dword         Gmask;     /* Green mask */
  dword         Bmask;     /* Blue mask */
} SconVideoInfo_t;

typedef struct SconAudioInfo_s {
  dword SPS;      /* samples per second: 8000, 11025, 22050, etc */
  dword BPS;      /* bits per sample: 8 or 16 */
  dword Channels; /* channels: 1=mono, 2=stereo */
} SconAudioInfo_t;

typedef struct SconInfo_s {
  SconMode_t        Mode;
  SconBoolean_t     InputInited;  /* input format has been setup */
  SconBoolean_t     OutputInited; /* output format has been setup */
  SconBoolean_t     SameFormat;   /* input and output are the same format */
  SconBoolean_t     Flip;         /* image must be flipped when converted */
  SconBoolean_t     ScaleDown;    /* input image is being scaled down */
  SconBoolean_t     ScaleUp;      /* input image is being scaled up */
  union {
    SconVideoInfo_t vinfo;
    SconAudioInfo_t ainfo;
  } Input;
  union {
    SconVideoInfo_t vinfo;
    SconAudioInfo_t ainfo;
  } Output;
  unsigned char    *FImage;        /* format conversion image buffer */
  dword             FImageSize;
  unsigned char    *SImage;        /* scaling image buffer */
  dword             SImageSize;
  void             *Table;         /* conversion lookup table */
  dword             TableSize;
  void             *dbg;           /* debug handle */
} SconInfo_t;

/********************** Private Prototypes ***********************/
/*
 * scon_video.c
 */
unsigned dword sconCalcImageSize(SconVideoInfo_t *vinfo);
SconStatus_t sconConvertVideo(SconInfo_t *Info, void *inbuf, dword inbufsize,
                                                void *outbuf, dword outbufsize);

/*
 * scon_yuv_to_rgb.c
 */
SconStatus_t sconInitYUVtoRGB(SconInfo_t *Info);
SconStatus_t scon422ToRGB565(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable);
SconStatus_t scon420ToRGB565(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable);
SconStatus_t scon422ToRGB888(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable);
SconStatus_t scon420ToRGB888(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable);
SconStatus_t sconInitRGBtoYUV(SconInfo_t *Info);
SconStatus_t sconRGB888To420(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable);

#endif /* _SCON_INTERNALS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sa.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: SA.h,v $
 * Revision 1.1.8.4  1996/11/14  21:49:22  Hans_Graves
 * 	Added SaDecompressEx() for AC3 multichannels.
 * 	[1996/11/14  21:46:20  Hans_Graves]
 *
 * Revision 1.1.8.3  1996/11/08  21:50:34  Hans_Graves
 * 	Added AC3 enum types.
 * 	[1996/11/08  21:16:32  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/07/19  02:11:00  Hans_Graves
 * 	Added SA_PARAM_DEBUG.
 * 	[1996/07/19  01:22:50  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/04/23  21:01:39  Hans_Graves
 * 	Added protos for SaDecompressQuery() and SaCompressQuery()
 * 	[1996/04/23  20:57:15  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/04/15  14:18:34  Hans_Graves
 * 	Change proto for SaCompress() - returns bytes processed
 * 	[1996/04/15  14:10:30  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/04/10  21:47:05  Hans_Graves
 * 	Added PARAMs. Replaced externs with EXTERN.
 * 	[1996/04/10  21:22:49  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/03/29  22:20:59  Hans_Graves
 * 	Changed include <mme/mmsystem.h> to <mmsystem.h>
 * 	[1996/03/29  22:16:43  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/02/06  22:53:52  Hans_Graves
 * 	Added PARAM enums
 * 	[1996/02/06  22:18:04  Hans_Graves]
 * 
 * Revision 1.1.4.2  1996/01/15  16:26:21  Hans_Graves
 * 	Added prototypes for SaSetDataDestination() and SaSetBitrate()
 * 	[1996/01/15  15:42:41  Hans_Graves]
 * 
 * Revision 1.1.2.8  1995/09/14  17:28:10  Bjorn_Engberg
 * 	Ported to NT
 * 	[1995/09/14  17:17:18  Bjorn_Engberg]
 * 
 * Revision 1.1.2.7  1995/07/21  17:41:00  Hans_Graves
 * 	Moved Callback related stuff to SC.h
 * 	[1995/07/21  17:27:29  Hans_Graves]
 * 
 * Revision 1.1.2.6  1995/07/17  22:01:30  Hans_Graves
 * 	Defined SaBufferInfo_t as ScBufferInfo_t.
 * 	[1995/07/17  21:41:54  Hans_Graves]
 * 
 * Revision 1.1.2.5  1995/06/27  17:40:59  Hans_Graves
 * 	Added include <mme/mmsystem.h>.
 * 	[1995/06/27  17:39:26  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/06/27  13:54:20  Hans_Graves
 * 	Added SA_GSM_DECODE and SA_GSM_ENCODE
 * 	[1995/06/26  21:01:12  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/09  18:33:29  Hans_Graves
 * 	Added SaGetInputBitstream() prototype.
 * 	[1995/06/09  17:41:59  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:17  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:19:33  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/17  18:26:57  Hans_Graves
 * 	Added ENCODE Codec defs
 * 	[1995/04/17  18:26:33  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:35:31  Hans_Graves
 * 	Inclusion in SLIB
 * 	[1995/04/07  19:22:48  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/


#ifndef _SA_H_
#define _SA_H_

#ifdef WIN32
#include <windows.h>  /* Windows NT        */
#endif
#include <mmsystem.h> /* needed for WAVEFORMATEX structure def */

#include "SC.h"

typedef enum {
   SA_MPEG_DECODE = 102,
   SA_MPEG_ENCODE = 103,
   SA_PCM_DECODE =  104,
   SA_PCM_ENCODE =  105,
   SA_GSM_DECODE =  106,
   SA_GSM_ENCODE =  107,
   SA_AC3_DECODE =  108,
   SA_AC3_ENCODE =  109,
   SA_G723_DECODE = 110,
   SA_G723_ENCODE = 111,
   SA_TMP_DECODE =  200,  /* temp - used for testing */
   SA_TMP_ENCODE =  201,
} SaCodecType_e;

#define SA_USE_SAME           STREAM_USE_SAME
#define SA_USE_FILE           STREAM_USE_FILE
#define SA_USE_BUFFER_QUEUE   STREAM_USE_QUEUE
#define SA_USE_BUFFER         STREAM_USE_BUFFER

/*
** Parameters
*/
typedef enum {
  SA_PARAM_NATIVEFORMAT,  /* native/preferred decompressed format (FOURCC) */
  SA_PARAM_BITRATE,       /* bitrate - bits per second */
  SA_PARAM_CHANNELS,      /* channels - 1=mono, 2=stereo, 4/5=surround */
  SA_PARAM_AUDIOLENGTH,   /* milliseconds of audio */
  SA_PARAM_SAMPLESPERSEC, /* samples per second (8000, 11025, 22050, etc.)
  SA_PARAM_BITSPERSAMPLE, /* bits per sample (8 or 16) */
  SA_PARAM_TIMECODE,      /* audio time code */
  SA_PARAM_MPEG_LAYER,    /* MPEG Layer: I, II, or III */
  SA_PARAM_PSY_MODEL,     /* Psy Acoustic Model */
  SA_PARAM_ALGFLAGS,      /* Algorithm flags */
  SA_PARAM_QUALITY,       /* Quality: 0=worst 99>=best */
  SA_PARAM_FASTDECODE,    /* Fast decode desired */
  SA_PARAM_FASTENCODE,    /* Fast encode desired */
  SA_PARAM_DEBUG,         /* Setup debug */
} SaParameter_t;

/*
** Type definitions
*/
typedef int SaStatus_t;
typedef void *SaHandle_t;
typedef ScCallbackInfo_t SaCallbackInfo_t;

/*
** Store basic info for user about the codec
*/
typedef struct SaInfo_s {
  SaCodecType_e Type;     /* Codec Type */
  char          Name[20];         /* Codec name (i.e. "MPEG-Decode") */
  char          Description[128]; /* Codec description */
  unsigned int  Version;          /* Codec version number */
  int           CodecStarted;     /* SaDecompressBegin/End */
  unsigned int  MS;               /* Number of milliseconds processed */
  unsigned int  NumBytesIn;       /* Number of bytes input */
  unsigned int  NumBytesOut;      /* Number of bytes output */
  unsigned int  NumFrames;        /* Number of ellapsed frames */
  unsigned long TotalFrames;      /* Total number of frames */
  unsigned long TotalMS;          /* Total number of milliseconds */
} SaInfo_t;

/***************************** Prototypes ********************************/
EXTERN SaStatus_t SaOpenCodec (SaCodecType_e CodecType, SaHandle_t *Sah);
EXTERN SaStatus_t SaCloseCodec (SaHandle_t Sah);
EXTERN SaStatus_t SaRegisterCallback (SaHandle_t Sah,
           int (*Callback)(SaHandle_t, SaCallbackInfo_t *, SaInfo_t *),
           void *UserData);
EXTERN ScBitstream_t *SaGetInputBitstream (SaHandle_t Sah);
EXTERN SaStatus_t SaDecompressQuery(SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                             WAVEFORMATEX *wfOut);
EXTERN SaStatus_t SaDecompressBegin (SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                              WAVEFORMATEX *wfOut);
EXTERN SaStatus_t SaDecompress (SaHandle_t Sah, u_char *CompData, 
                                       unsigned int CompLen,
                           u_char *DcmpData, unsigned int *DcmpLen);
PRIVATE_EXTERN SaStatus_t SaDecompressEx (SaHandle_t Sah, u_char *CompData, 
                                       unsigned int CompLen,
                           u_char **DcmpData, unsigned int *DcmpLen);
EXTERN SaStatus_t SaDecompressEnd (SaHandle_t Sah);
EXTERN SaStatus_t SaCompressQuery(SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                             WAVEFORMATEX *wfOut);
EXTERN SaStatus_t SaCompressBegin (SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                            WAVEFORMATEX *wfOut);
EXTERN SaStatus_t SaCompress (SaHandle_t Sah,
                           u_char *DcmpData, unsigned int *DcmpLen,
                           u_char *CompData, unsigned int *CompLen);
EXTERN SaStatus_t SaCompressEnd (SaHandle_t Sah);
EXTERN SaStatus_t SaSetDataSource(SaHandle_t Sah, int Source, int Fd,
                            void *Buffer_UserData, int BufSize);
EXTERN SaStatus_t SaSetDataDestination(SaHandle_t Sah, int Dest, int Fd,
                            void *Buffer_UserData, int BufSize);
EXTERN ScBitstream_t *SaGetDataSource (SaHandle_t Sah);
EXTERN ScBitstream_t *SaGetDataDestination(SaHandle_t Sah);
EXTERN SaStatus_t SaAddBuffer (SaHandle_t Sah, SaCallbackInfo_t *BufferInfo);
#ifdef MPEG_SUPPORT
EXTERN SaStatus_t sa_GetMpegAudioInfo(int fd, WAVEFORMATEX *wf, 
                                      SaInfo_t *info);
#endif /* MPEG_SUPPORT */
EXTERN SaStatus_t SaSetParamBoolean(SaHandle_t Sah, SaParameter_t param,
                                             ScBoolean_t value);
EXTERN SaStatus_t SaSetParamInt(SaHandle_t Sah, SaParameter_t param,
                                             qword value);
EXTERN ScBoolean_t SaGetParamBoolean(SaHandle_t Sah, SaParameter_t param);
EXTERN qword SaGetParamInt(SaHandle_t Sah, SaParameter_t param);

#endif _SA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sac.c ===
/* File: sv_h263_sac.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/

#include "sv_h263.h"
#include "sv_intrn.h"
#include "SC_err.h"
#include "proto.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  0  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
extern void *dbg;
#endif

#define   q1    16384
#define   q2    32768
#define   q3    49152
#define   top   65535

/* local prototypes */
static void bit_out_psc_layer(ScBitstream_t *BSIn);
static int sv_H263bit_opp_bits(ScBitstream_t *BSOut, int bit);              
static int sv_H263bit_in_psc_layer(ScBitstream_t *BSOut, int bit);

/*********************************************************************
 *        SAC Decoder Algorithm as Specified in H26P Annex -E
 *
 *        Name:        decode_a_symbol
 *
 *	Description:	Decodes an Aritmetically Encoded Symbol
 *
 *	Input:        array holding cumulative freq. data
 *        also uses static data for decoding endpoints
 *        and code_value variable
 *
 *	Returns:	Index to relevant symbol model
 *
 *	Side Effects:	Modifies low, high, length, cum and code_value
 *
 *	Author:        Wayne Ellis <ellis_w_wayne@bt-web.bt.co.uk>
 *
 *********************************************************************/
 
static qword low=0, high=top, zerorun=0; /* decoder and encoder */
static qword code_value, bit; /* decoder */
static qword opposite_bits=0; /* encoder */

int sv_H263SACDecode_a_symbol(ScBitstream_t *BSIn, int cumul_freq[ ])
{
  qword length, cum, sacindex;
  length = high - low + 1;
  cum = (-1 + (code_value - low + 1) * cumul_freq[0]) / length;
  for (sacindex = 1; cumul_freq[sacindex] > cum; sacindex++);
  high = low - 1 + (length * cumul_freq[sacindex-1]) / cumul_freq[0];
  low += (length * cumul_freq[sacindex]) / cumul_freq[0];

  for ( ; ; ) {  
    if (high < q2) ;
    else if (low >= q2) {
      code_value -= q2; 
      low -= q2; 
      high -= q2;
    }
    else if (low >= q1 && high < q3) {
      code_value -= q1; 
      low -= q1; 
      high -= q1;
    }
    else
	{
      _SlibDebug(_VERBOSE_,
          ScDebugPrintf(dbg, "sv_H263SACDecode_a_symbol() code_value=%ld sacindex=%ld\n",
                                code_value, sacindex) );
      break;
    }
    low = low << 1; 
    high = (high << 1) + 1;
    bit_out_psc_layer(BSIn); 
    code_value = (code_value << 1) + bit;
  }

  return ((int)sacindex-1);
}
 
/*********************************************************************
 *
 *        Name:        decoder_reset
 *
 *	Description:	Fills Decoder FIFO after a fixed word length
 *        string has been detected.
 *
 *	Input:        None
 *
 *	Returns:	Nothing
 *
 *	Side Effects:	Fills Arithmetic Decoder FIFO
 *
 *	Author:        Wayne Ellis <ellis_w_wayne@bt-web.bt.co.uk>
 *
 *********************************************************************/

void sv_H263SACDecoderReset(ScBitstream_t *BSIn)
{
  int i;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(dbg, "sv_H263SACDecoderReset() bytepos=%d\n",
                                              (int)ScBSBytePosition(BSIn)) );
  zerorun = 0;        /* clear consecutive zero's counter */
  code_value = 0;
  low = 0;
  high = top;
  for (i = 1;   i <= 16;   i++) {
    bit_out_psc_layer(BSIn); 
    code_value = (code_value << 1) + bit;
  }
}

/*********************************************************************
 *
 *        Name:        bit_out_psc_layer
 *
 *	Description:	Gets a bit from the Encoded Stream, Checks for
 *        and removes any PSC emulation prevention bits
 *        inserted at the decoder, provides 'zeros' to the
 *        Arithmetic Decoder FIFO to allow it to finish 
 *        data prior to the next PSC. (Garbage bits)
 *
 *	Input:        None
 *
 *	Returns:	Nothing
 *
 *	Side Effects:	Gets a bit from the Input Data Stream
 *
 *	Author:        Wayne Ellis <ellis_w_wayne@bt-web.bt.co.uk>
 *
 *********************************************************************/

static void bit_out_psc_layer(ScBitstream_t *BSIn)
{
  if (ScBSPeekBits(BSIn, 17)!=1)  /* check for startcode in Arithmetic Decoder FIFO */
  {
    _SlibDebug(_DEBUG_, ScDebugPrintf(dbg, "bit_out_psc_layer()\n") );

    bit = ScBSGetBit(BSIn);

    if (zerorun > 13) {	/* if number of consecutive zeros = 14 */	 
      if (!bit) {
        _SlibDebug(_WARN_,
            ScDebugPrintf(dbg, "bit_out_psc_layer() PSC/GBSC, Header Data, or Encoded Stream Error\n") );
        zerorun = 1;        
      }
      else { /* if there is a 'stuffing bit present */
/*
        if (H263_DEC_trace)
          printf("Removing Startcode Emulation Prevention bit \n");
*/
        bit = ScBSGetBit(BSIn);        /* overwrite the last bit */	
        zerorun = !bit;        /* zerorun=1 if bit is a '0' */
      }
    }

    else { /* if consecutive zero's not exceeded 14 */
      if (!bit) zerorun++;
      else      zerorun = 0;
    }

  } /* end of if !(showbits(17)) */
  else {
    _SlibDebug(_WARN_, ScDebugPrintf(dbg, "bit_out_psc_layer() startcode found, using 'Garbage bits'\n") );
    bit = 0;
  }

   /*	
   printf("lastbit = %ld bit = %ld zerorun = %ld \n", lastbit, bit, zerorun); 
   lastbit = bit;
   */
  /* latent diagnostics */
}

/*********************************************************************
 *
 * SAC Encoder Module
 * Algorithm as specified in H263 (Annex E)
 *
 *********************************************************************/

/*********************************************************************
 *
 *      Name:           AR_Encode
 *
 *      Description:    Encodes a symbol using syntax based arithmetic
 *			coding. Algorithm specified in H.263 (Annex E).
 *
 *      Input:          Array holding cumulative frequency data.
 *			Index into specific cumulative frequency array.
 *                      Static data for encoding endpoints.
 *
 *      Returns:        Number of bits used while encoding symbol.
 *
 *      Side Effects:   Modifies low, high, length and opposite_bits
 *			variables.
 *
 *********************************************************************/

int sv_H263AREncode(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                    int index, int cumul_freq[ ])
{
  qword length;
  int bitcount=0;

  if (index<0) 
    return -1; /* Escape Code */

  length = high - low + 1;
  high = low - 1 + (length * cumul_freq[index]) / cumul_freq[0];
  low += (length * cumul_freq[index+1]) / cumul_freq[0];

  for ( ; ; ) {
    if (high < q2) {
      bitcount+=sv_H263bit_opp_bits(BSOut, 0);
    }
    else if (low >= q2) {
      bitcount+=sv_H263bit_opp_bits(BSOut, 1);	
      low -= q2; 
      high -= q2;
    }
    else if (low >= q1 && high < q3) {
      opposite_bits += 1; 
      low -= q1; 
      high -= q1;
    }
    else break;
 
    low *= 2; 
    high = 2*high+1;
  }
  return bitcount;
}

static int sv_H263bit_opp_bits(ScBitstream_t *BSOut, int bit) /* Output a bit and the following opposite bits */              
{                                   
  int bitcount=0;

  bitcount = sv_H263bit_in_psc_layer(BSOut, bit);

  while(opposite_bits > 0){
    bitcount += sv_H263bit_in_psc_layer(BSOut, !bit);
    opposite_bits--;
  }
  return bitcount;
}

/*********************************************************************
 *
 *      Name:           encoder_flush
 *
 *      Description:    Completes arithmetic coding stream before any
 *			fixed length codes are transmitted.
 *
 *      Input:          None
 *
 *      Returns:        Number of bits used.
 *
 *      Side Effects:   Resets low, high, zerorun and opposite_bits 
 *			variables.
 *
 *********************************************************************/

int sv_H263AREncoderFlush(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut)
{
  int bitcount = 0;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(dbg, "sv_H263AREncoderFlush() bytepos=%d\n",
                                              (int)ScBSBytePosition(BSOut)) );

  opposite_bits++;
  if (low < q1) {
    bitcount+=sv_H263bit_opp_bits(BSOut, 0);
  }
  else {
    bitcount+=sv_H263bit_opp_bits(BSOut, 1);
  }
  low = 0; 
  high = top;

  zerorun=0;

  return bitcount;
}

/*********************************************************************
 *
 *      Name:           bit_in_psc_layer
 *
 *      Description:    Inserts a bit into output bitstream and avoids
 *			picture start code emulation by stuffing a one
 *			bit.
 *
 *      Input:          Bit to be output.
 *
 *      Returns:        Nothing
 *
 *      Side Effects:   Updates zerorun variable.
 *
 *********************************************************************/

static int sv_H263bit_in_psc_layer(ScBitstream_t *BSOut, int bit)
{
  int bitcount = 0;

  if (zerorun > 13) {
    _SlibDebug(_DEBUG_, ScDebugPrintf(dbg,
               "sv_H263bit_in_psc_layer() bytepos=%d, PSC emulation...Bit stuffed\n",
                                              (int)ScBSBytePosition(BSOut)) );
    svH263mputb(1);
    bitcount++;
    zerorun = 0;
  }

  svH263mputb(bit);
  bitcount++;

  if (bit)
    zerorun = 0;
  else
    zerorun++;

  return bitcount;
}

/*********************************************************************
 *
 *      Name:           indexfn
 *
 *      Description:    Translates between symbol value and symbol
 *			index.
 *
 *      Input:          Symbol value, index table, max number of
 *			values.
 *
 *      Returns:        Index into cumulative frequency tables or
 *			escape code.
 *
 *      Side Effects:   none
 *
 *********************************************************************/

int sv_H263IndexFN(int value, int table[], int max)
{
  int n=0;

  while(1) {
    if (table[n++]==value) return n-1;
    if (n>max) return -1;
  }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sa_proto.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sa_prototypes.h,v $
 * Revision 1.1.8.4  1996/11/14  21:49:25  Hans_Graves
 * 	Added sa_AC3SetParamInt() proto.
 * 	[1996/11/14  21:48:29  Hans_Graves]
 *
 * Revision 1.1.8.3  1996/11/08  21:50:58  Hans_Graves
 * 	Added AC3 stuff.
 * 	[1996/11/08  21:18:58  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/09/18  23:46:14  Hans_Graves
 * 	Changed proto for sa_PsychoAnal()
 * 	[1996/09/18  21:58:47  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/04/10  21:47:34  Hans_Graves
 * 	Added sa_MpegGet/SetParam functions
 * 	[1996/04/10  21:38:49  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/04/09  16:04:38  Hans_Graves
 * 	Fix protos for sa_SetMPEGBitrate and sa_SetMPEGParams)
 * 	[1996/04/09  16:02:14  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/03/29  22:21:11  Hans_Graves
 * 	Added MPEG_SUPPORT and GSM_SUPPORT ifdefs
 * 	[1996/03/29  22:13:39  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/01/19  15:29:34  Bjorn_Engberg
 * 	Removed compiler wanrnings for NT.
 * 	[1996/01/19  14:57:39  Bjorn_Engberg]
 * 
 * Revision 1.1.4.2  1996/01/15  16:26:24  Hans_Graves
 * 	Added prototype for sa_SetMPEGBitrate()
 * 	[1996/01/15  15:43:13  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/27  13:54:26  Hans_Graves
 * 	Added prototypes for GSM.
 * 	[1995/06/27  13:24:34  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:45  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:34:15  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/17  18:38:58  Hans_Graves
 * 	Added MPEG Encoding prototypes
 * 	[1995/04/17  18:32:28  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:36:59  Hans_Graves
 * 	Inclusion in SLIB
 * 	[1995/04/07  19:31:43  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*--------------------------------------------------------------------------
 * SLIB Internals Prototype file (externals are in SA.h)
 *
 * Modification History: sa_prototypes.h
 *
 *      29-Jul-94  PSG  Created
 *---------------------------------------------------------------------------*/

#ifndef _SA_PROTOTYPES_H
#define _SA_PROTOTYPES_H

#ifdef MPEG_SUPPORT
#include "sa_mpeg.h"
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
#include "sa_gsm.h"
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
#include "sa_ac3.h"
#endif /* GSM_SUPPORT */
#include "sa_intrn.h"

/*---------------------------------------------------------------------------*/
/*                     Compress/Decompress Codec Prototypes                  */
/*---------------------------------------------------------------------------*/

#ifdef MPEG_SUPPORT
/*
 *  sa_mpeg_common.c
 */
extern SaStatus_t saMpegSetParamInt(SaHandle_t Sah, SaParameter_t param,
                                qword value);
extern SaStatus_t saMpegSetParamBoolean(SaHandle_t Sah, SaParameter_t param,
                                  ScBoolean_t value);
extern qword saMpegGetParamInt(SaHandle_t Sah, SaParameter_t param);
extern ScBoolean_t saMpegGetParamBoolean(SaHandle_t Svh, SaParameter_t param);

extern int sa_PickTable(SaFrameParams_t *fr_ps);
extern void sa_ShowHeader(SaFrameParams_t *fr_ps);
extern void sa_ShowBitAlloc(unsigned int bit_alloc[2][SBLIMIT],
                            SaFrameParams_t *f_p);
extern void sa_ShowScale(unsigned int bit_alloc[2][SBLIMIT],
                  unsigned int scfsi[2][SBLIMIT],
                  unsigned int scalar[2][3][SBLIMIT],
                  SaFrameParams_t *fr_ps);
extern void sa_ShowSamples(int ch, unsigned int FAR sample[SBLIMIT],
                    unsigned int bit_alloc[SBLIMIT], SaFrameParams_t *fr_ps);
extern int sa_BitrateIndex(int layr, int bRate);
extern int sa_SmpFrqIndex(long sRate);
extern void sa_CRCupdate(unsigned int data, unsigned int length, unsigned int *crc);
extern void sa_CRCcalcI(SaFrameParams_t *fr_ps, unsigned int bit_alloc[2][SBLIMIT],
                                        unsigned int *crc);
extern void sa_CRCcalcII(SaFrameParams_t *fr_ps, unsigned int bit_alloc[2][SBLIMIT],
                             unsigned int scfsi[2][SBLIMIT], unsigned int *crc);
extern SaStatus_t sa_hdr_to_frps(SaFrameParams_t *fr_ps);


/*
 *   sa_mpeg_decode.c
 */
extern SaStatus_t sa_DecompressMPEG(SaCodecInfo_t *Info,
                              unsigned char *buffer, unsigned int size,
                              unsigned int *ret_length);
extern SaStatus_t sa_DecodeInfo(ScBitstream_t *bs, SaFrameParams_t *fr_ps);
extern SaStatus_t sa_InitMpegDecoder(SaCodecInfo_t *Info);
extern SaStatus_t sa_EndMpegDecoder(SaCodecInfo_t *Info);

/*
 *   sa_mpeg_encode.c
 */
extern SaStatus_t sa_MpegVerifyEncoderSettings(SaHandle_t Sah);
extern SaStatus_t sa_CompressMPEG(SaCodecInfo_t *Info,
                           unsigned char *dcmp_buf, unsigned int *dcmp_len,
                           unsigned int *comp_len);
extern SaStatus_t sa_InitMpegEncoder(SaCodecInfo_t *Info);
extern SaStatus_t sa_EndMpegEncoder(SaCodecInfo_t *Info);
extern unsigned int sa_GetMPEGSampleSize(SaCodecInfo_t *Info);

/*
** sa_mpeg_tonal.c
*/
extern void sa_II_Psycho_One(float buffer[2][1152], float scale[2][SBLIMIT],
                      float ltmin[2][SBLIMIT], SaFrameParams_t *fr_ps);
extern void sa_I_Psycho_One(float buffer[2][1152], float scale[2][SBLIMIT],
                      float ltmin[2][SBLIMIT], SaFrameParams_t *fr_ps);
/*
** sa_mpeg_psy.c
*/
extern void sa_PsychoAnal(SaMpegCompressInfo_t *MCInfo, float *buffer,
                          float savebuf[1056],int chn,int lay,
                          float snr32[32],float sfreq,int num_pass);
#endif /* MPEG_SUPPORT */

#ifdef GSM_SUPPORT
/*
** sa_gsm_common.c
*/
SaStatus_t sa_InitGSM(SaGSMInfo_t *info);

extern word  gsm_mult(word a, word b);
extern dword gsm_L_mult(word a, word b);
extern word  gsm_mult_r(word a, word b);
extern word  gsm_div(word num, word denum);
extern word  gsm_add( word a, word b );
extern dword gsm_L_add(dword a, dword b );
extern word  gsm_sub(word a, word b);
extern dword gsm_L_sub(dword a, dword b);
extern word  gsm_abs(word a);
extern word  gsm_norm(dword a);
extern dword gsm_L_asl(dword a, int n);
extern word  gsm_asl(word a, int n);
extern dword gsm_L_asr(dword a, int n);
extern word  gsm_asr(word a, int n);

/*
** sa_gsm_encode.c
*/
extern SaStatus_t sa_GSMEncode(SaGSMInfo_t *s, word *dcmp_buf, 
                               unsigned int *dcmp_len,
                               unsigned char *comp_buf,
                               ScBitstream_t *bsout);
extern void Gsm_Long_Term_Predictor(SaGSMInfo_t *S, word *d, word *dp, word *e, word *dpp,
                                    word *Nc, word *bc);
extern void Gsm_Encoding(SaGSMInfo_t *S, word *e, word *ep, word *xmaxc, 
                          word *Mc, word *xMc);
extern void Gsm_Short_Term_Analysis_Filter(SaGSMInfo_t *S,word *LARc,word *d);
/*
** sa_gsm_decode.c
*/
extern int sa_GSMDecode(SaGSMInfo_t *s, unsigned char *comp_buf, word *dcmp_buf);
extern void Gsm_Decoding(SaGSMInfo_t *S, word xmaxcr, word Mcr, word *xMcr, word *erp);
extern void Gsm_Long_Term_Synthesis_Filtering(SaGSMInfo_t *S, word Ncr, word bcr,
                                               word *erp, word *drp);
void Gsm_RPE_Decoding(SaGSMInfo_t *S, word xmaxcr, word Mcr, word * xMcr, word * erp);
void Gsm_RPE_Encoding(SaGSMInfo_t *S, word *e, word *xmaxc, word *Mc, word *xMc);
/*
** sa_gsm_filter.c
*/
extern void Gsm_Short_Term_Synthesis_Filter(SaGSMInfo_t *S, word *LARcr, 
                                            word *drp, word *s);
extern void Gsm_Update_of_reconstructed_short_time_residual_signal(word *dpp,
                                                              word *ep, word *dp);
/*
** sa_gsm_table.c
*/
extern word gsm_A[8], gsm_B[8], gsm_MIC[8], gsm_MAC[8];
extern word gsm_INVA[8];
extern word gsm_DLB[4], gsm_QLB[4];
extern word gsm_H[11];
extern word gsm_NRFAC[8];
extern word gsm_FAC[8];
#endif /* GSM_SUPPORT */

#ifdef AC3_SUPPORT

/* AC-3 specific stuff goes here */
/*
 *   sa_ac3_decode.c
 */
extern SaStatus_t sa_DecompressAC3(SaCodecInfo_t *Info,
                              unsigned char **buffer, unsigned int size,
                              unsigned int *ret_length);
extern SaStatus_t sa_InitAC3Decoder(SaCodecInfo_t *Info);
extern SaStatus_t sa_EndAC3Decoder(SaCodecInfo_t *Info);
extern SaStatus_t saAC3SetParamInt(SaHandle_t Sah, SaParameter_t param,
                                qword value);


#endif /* AC3_SUPPORT */

#ifdef G723_SUPPORT
/* G723 encoder functions. 
   sa_g723_coder.c
*/
typedef  short int   Flag  ;
extern void saG723CompressInit(SaG723Info_t *psaG723Info);

//DataBuff :Input frame (480 bytes)
//Vout     :Encoded frame (20 bytes :5.3K bits/s
//                        (24 bytes :6.3K bits/s)
extern SaStatus_t  saG723Compress( SaCodecInfo_t *Info,word *DataBuff, char *Vout );

extern void saG723CompressFree(SaG723Info_t *psaG723Info);

/* G723 decoder functions. 
   sa_g723_decod.c
*/
extern void saG723DecompressInit(SaG723Info_t *psaG723Info);

//DataBuff :Empty Buffer to hold decoded frame(480 bytes)
//Vinp     :Encoded frame (20 bytes :5.3K bits/s
//                        (24 bytes :6.3K bits/s)
//Crc      : Transmission Error code (Cyclic Redundant code)
extern SaStatus_t  saG723Decompress( SaCodecInfo_t *Info,word *DataBuff, 
               char *Vinp, word Crc );

extern void saG723DecompressFree(SaG723Info_t *psaG723Info);

extern SaStatus_t saG723SetParamInt(SaHandle_t Sah, SaParameter_t param,
                                qword value);

extern SaStatus_t saG723SetParamBoolean(SaHandle_t Sah, SaParameter_t param,
                                  ScBoolean_t value);

extern qword saG723GetParamInt(SaHandle_t Sah, SaParameter_t param);

extern ScBoolean_t saG723GetParamBoolean(SaHandle_t Svh, SaParameter_t param);

#endif /* G723_SUPPORT */

#endif _SA_PROTOTYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\scon_api.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: scon_api.c,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1997                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
 * SLIB Conversion API
 */

/*
#define _SLIBDEBUG_
*/

#include "scon_int.h"
#include "SC_err.h"
#include "SC_conv.h"

#ifdef WIN32
#include <mmsystem.h>
#endif

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_     1  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#endif


static unsigned dword sconTranslateFourCC(unsigned dword FourCC)
{
  switch (FourCC)
  {
      case BI_DECYUVDIB:     /* YUV 4:2:2 Packed */
      case BI_YUY2:          /* YUV 4:2:2 Packed */
          return(BI_YUY2);
      case BI_YU16SEP:       /* YUV 4:2:2 Planar */
      case BI_DECSEPYUVDIB:  /* YUV 4:2:2 Planar */
          return(BI_YU16SEP);
      case BI_YU12SEP:       /* YUV 4:1:1 Planar */
      case BI_RGB:           /* RGB */
      case BI_BITFIELDS:     /* RGB masked */
#ifndef WIN32
      case BI_DECXIMAGEDIB:  /* Unix Ximage RGB */
#endif /* !WIN32 */
      case BI_YVU9SEP:       /* YUV 16:1:1 Planar */
      default:
          return(FourCC);
  }
}

static void sconInitInfo(SconInfo_t *Info)
{
  _SlibDebug(_DEBUG_, printf("sconInitInfo()\n") );
  Info->Mode = SCON_MODE_NONE;
  Info->InputInited = FALSE;
  Info->OutputInited = FALSE;
  Info->Flip = FALSE;
  Info->SameFormat = TRUE;
  Info->ScaleUp = FALSE;
  Info->ScaleDown = FALSE;
  Info->FImage = NULL;
  Info->FImageSize = 0;
  Info->SImage = NULL;
  Info->SImageSize = 0;
  Info->Table = NULL;
  Info->TableSize = 0;
  Info->dbg = NULL;
}

static void sconValidateInfo(SconInfo_t *Info)
{
  if (Info->Mode==SCON_MODE_VIDEO)
  {
    if (Info->InputInited && Info->OutputInited)
    {
      SconVideoInfo_t *in_vinfo=&Info->Input.vinfo;
      SconVideoInfo_t *out_vinfo=&Info->Output.vinfo;
      Info->Flip=(in_vinfo->NegHeight!=out_vinfo->NegHeight)?TRUE:FALSE;
      sconCalcImageSize(in_vinfo);
      sconCalcImageSize(out_vinfo);
      Info->ScaleDown=(in_vinfo->Pixels>out_vinfo->Pixels)?TRUE:FALSE;
      Info->ScaleUp=(in_vinfo->Pixels<out_vinfo->Pixels)?TRUE:FALSE;
      if (!Info->ScaleDown && !Info->ScaleUp && in_vinfo->Width>out_vinfo->Width)
        Info->ScaleUp=TRUE;
      in_vinfo->FourCC=sconTranslateFourCC(in_vinfo->FourCC);
      out_vinfo->FourCC=sconTranslateFourCC(out_vinfo->FourCC);
      if (in_vinfo->BPP==out_vinfo->BPP && 
          in_vinfo->FourCC==out_vinfo->FourCC)
        Info->SameFormat=TRUE;
      else
        Info->SameFormat=FALSE;
    }
  }
}

static void sconBMHtoVideoInfo(BITMAPINFOHEADER *bmh, SconVideoInfo_t *vinfo)
{
  vinfo->Width=bmh->biWidth;
  if (bmh->biHeight<0) /* height is negative */
  {
    vinfo->Height=-bmh->biHeight;
    vinfo->NegHeight=TRUE;
  }
  else /* height is positive */
  {
    vinfo->Height=bmh->biHeight;
    vinfo->NegHeight=FALSE;
  }
  vinfo->FourCC=bmh->biCompression;
  vinfo->BPP=bmh->biBitCount;
  vinfo->Stride=vinfo->Width*((vinfo->BPP+7)>>3);
  /* RGB bit masks */
  vinfo->Rmask=0;
  vinfo->Gmask=0;
  vinfo->Bmask=0;
  vinfo->RGBmasks=0;
  if (vinfo->FourCC==BI_BITFIELDS || vinfo->FourCC==BI_RGB ||
      vinfo->FourCC==BI_DECXIMAGEDIB)
  {
    if (vinfo->BPP==32 || vinfo->BPP==24)
    {
      vinfo->Rmask=0xFF0000;
      vinfo->Gmask=0x00FF00;
      vinfo->Bmask=0x0000FF;
    }
    else if (vinfo->BPP==16) /* RGB 565 */
    {
      vinfo->Rmask=0xF800;
      vinfo->Gmask=0x07E0;
      vinfo->Bmask=0x001F;
    }
    if (vinfo->FourCC==BI_BITFIELDS &&
        bmh->biSize>=sizeof(BITMAPINFOHEADER)+3*4)
    {
      DWORD *MaskPtr = (DWORD *)&bmh[1];
      if (MaskPtr[0] && MaskPtr[1] && MaskPtr[2])
      {
        /* get bit masks */
        vinfo->Rmask=MaskPtr[0];
        vinfo->Gmask=MaskPtr[1];
        vinfo->Bmask=MaskPtr[2];
      }
    }
    if (vinfo->Rmask==0xF800 && vinfo->Gmask==0x07E0 && vinfo->Bmask==0x001F)
      vinfo->RGBmasks=565;
    else if (vinfo->Rmask==0x001F && vinfo->Gmask==0x07E0 && vinfo->Bmask==0xF800)
      vinfo->RGBmasks=565;
    else if (vinfo->Rmask==0x7C00 && vinfo->Gmask==0x03E0 && vinfo->Bmask==0x001F)
      vinfo->RGBmasks=555;
    else if (vinfo->Rmask==0x001F && vinfo->Gmask==0x03E0 && vinfo->Bmask==0x7C00)
      vinfo->RGBmasks=555;
    else if (vinfo->Rmask==0xFF0000 && vinfo->Gmask==0x00FF00 && vinfo->Bmask==0x0000FF)
      vinfo->RGBmasks=888;
    else if (vinfo->Rmask==0x0000FF && vinfo->Gmask==0x00FF00 && vinfo->Bmask==0xFF0000)
      vinfo->RGBmasks=888;
  }
}

SconStatus_t SconOpen(SconHandle_t *handle, SconMode_t smode,
                      void *informat, void *outformat)
{
  SconInfo_t *Info;
  if (smode==SCON_MODE_VIDEO)
  {
    if ((Info = (SconInfo_t *)ScAlloc(sizeof(SconInfo_t))) == NULL)
      return(SconErrorMemory);
    sconInitInfo(Info);
    Info->Mode=smode;
    if (informat)
    {
      sconBMHtoVideoInfo((BITMAPINFOHEADER *)informat, &Info->Input.vinfo);
      Info->InputInited = TRUE;
    }
    if (outformat)
    {
      sconBMHtoVideoInfo((BITMAPINFOHEADER *)outformat, &Info->Output.vinfo);
      Info->OutputInited = TRUE;
    }
    sconValidateInfo(Info);
    *handle=(SconHandle_t)Info;
    return(SconErrorNone);
  }
  else
    return(SconErrorBadMode);
}

SconStatus_t SconClose(SconHandle_t handle)
{
  SconInfo_t *Info=(SconInfo_t *)handle;
  _SlibDebug(_VERBOSE_, printf("SconClose()\n") );
  if (!handle)
    return(SconErrorBadHandle);
  if (Info->Table)
    ScPaFree(Info->Table);
  if (Info->FImage)
    ScPaFree(Info->FImage);
  if (Info->SImage)
    ScPaFree(Info->SImage);
  ScFree(Info);
  return(SconErrorNone);
}

/*
** Name: SconIsSame
** Desc: Return true if input and output formats are identical.
** Return: TRUE   input == output format
**         FALSE  input != out format
*/
SconBoolean_t SconIsSame(SconHandle_t handle)
{
  if (handle)
  {
    SconInfo_t *Info=(SconInfo_t *)handle;

    if (Info->Mode==SCON_MODE_VIDEO)
    {
      if (Info->SameFormat && !Info->Flip && !Info->ScaleUp && !Info->ScaleDown)
        return(TRUE);
    }
  }
  return(FALSE);
}

SconStatus_t SconConvert(SconHandle_t handle, void *inbuf, dword inbufsize,
                                              void *outbuf, dword outbufsize)
{
  SconInfo_t *Info=(SconInfo_t *)handle;
  SconStatus_t status;
  _SlibDebug(_VERBOSE_, printf("SconConvert()\n") );
  if (!handle)
    return(SconErrorBadHandle);
  if (inbuf==NULL || outbuf==NULL)
    return(SconErrorBadArgument);
  if (Info->Mode==SCON_MODE_VIDEO)
    status=sconConvertVideo(Info, inbuf, inbufsize, outbuf, outbufsize);
  else
    status=SconErrorBadMode;
  return(status);
}

SconStatus_t SconSetParamInt(SconHandle_t handle, SconParamType_t ptype,
                             SconParameter_t param, long value)
{
  SconInfo_t *Info=(SconInfo_t *)handle;
  SconStatus_t status=SconErrorNone;
  if (!handle)
    return(SconErrorBadHandle);
  _SlibDebug(_DEBUG_, printf("SconSetParamInt(stream=%d, param=%d, %d)\n",
                   stream, param, value) );
  switch (param)
  {
    case SCON_PARAM_STRIDE:
          _SlibDebug(_DEBUG_,
                printf("SconSetParamInt(SCON_PARAM_STRIDE)\n") );
          if (Info->Mode==SCON_MODE_VIDEO)
          {
            if (ptype==SCON_INPUT || ptype==SCON_INPUT_AND_OUTPUT)
              Info->Input.vinfo.Stride=(long)value;
            if (ptype==SCON_OUTPUT || ptype==SCON_INPUT_AND_OUTPUT)
              Info->Output.vinfo.Stride=(long)value;
          }
          else
            status=SconErrorBadMode;
          break;
    default:
          return(SconErrorUnsupportedParam);
  }
  return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sc.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: SC.h,v $
 * Revision 1.1.8.10  1996/12/03  23:15:11  Hans_Graves
 * 	Added ScBSBufferedBytes() macros.
 * 	[1996/12/03  23:11:06  Hans_Graves]
 *
 * Revision 1.1.8.9  1996/11/13  16:10:47  Hans_Graves
 * 	Addition of ScBitstreamSave_t.
 * 	[1996/11/13  15:58:26  Hans_Graves]
 * 
 * Revision 1.1.8.8  1996/11/08  21:50:36  Hans_Graves
 * 	Protos fixed for use with C++. Added bitstream protos for AC3.
 * 	[1996/11/08  21:17:23  Hans_Graves]
 * 
 * Revision 1.1.8.7  1996/10/28  17:32:20  Hans_Graves
 * 	MME-01402. Added TimeStamp support to Callbacks.
 * 	[1996/10/28  16:56:21  Hans_Graves]
 * 
 * Revision 1.1.8.6  1996/10/12  17:18:11  Hans_Graves
 * 	Added ScImageSize().
 * 	[1996/10/12  16:53:38  Hans_Graves]
 * 
 * Revision 1.1.8.5  1996/09/18  23:45:46  Hans_Graves
 * 	Added ScFileClose() proto; ISIZE() macro
 * 	[1996/09/18  23:37:33  Hans_Graves]
 * 
 * Revision 1.1.8.4  1996/08/20  22:11:48  Bjorn_Engberg
 * 	For NT - Made several routines public to support JV3.DLL and SOFTJPEG.DLL.
 * 	[1996/08/20  21:53:23  Bjorn_Engberg]
 * 
 * Revision 1.1.8.3  1996/05/24  22:21:27  Hans_Graves
 * 	Added ScPatScaleIDCT8x8i_S proto
 * 	[1996/05/24  21:56:31  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/05/07  19:55:49  Hans_Graves
 * 	Added BI_DECHUFFDIB
 * 	[1996/05/07  17:24:17  Hans_Graves]
 * 
 * Revision 1.1.6.9  1996/04/17  16:38:36  Hans_Graves
 * 	Change NT bitstream buffer sizes from 32 to 64-bit
 * 	[1996/04/17  16:37:04  Hans_Graves]
 * 
 * Revision 1.1.6.8  1996/04/15  21:08:39  Hans_Graves
 * 	Define ScBitBuff_t and ScBitString_t as dword or qword
 * 	[1996/04/15  21:05:46  Hans_Graves]
 * 
 * Revision 1.1.6.7  1996/04/10  21:47:16  Hans_Graves
 * 	Added definition for EXTERN
 * 	[1996/04/10  21:23:23  Hans_Graves]
 * 
 * Revision 1.1.6.6  1996/04/09  16:04:32  Hans_Graves
 * 	Added USE_C ifdef.
 * 	[1996/04/09  14:48:04  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/04/01  16:23:09  Hans_Graves
 * 	NT porting
 * 	[1996/04/01  16:15:48  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/03/20  22:32:46  Hans_Graves
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.6.2 **}
 * 		{** Merge revision:	1.1.6.3 **}
 * 	{** End **}
 * 	Added protos for IDCT1x1,1x2,2x1,2x2,3x3,4x4,6x6
 * 	[1996/03/20  22:25:47  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/03/16  19:22:51  Karen_Dintino
 * 	added NT port changes
 * 	[1996/03/16  19:20:07  Karen_Dintino]
 * 
 * Revision 1.1.6.2  1996/03/08  18:46:27  Hans_Graves
 * 	Added proto for ScScaleIDCT8x8m_S()
 * 	[1996/03/08  18:41:45  Hans_Graves]
 * 
 * Revision 1.1.4.14  1996/02/07  23:23:50  Hans_Graves
 * 	Added prototype for ScFileSeek()
 * 	[1996/02/07  23:18:32  Hans_Graves]
 * 
 * Revision 1.1.4.13  1996/02/01  17:15:50  Hans_Graves
 * 	Added ScBSSkipBitsFast() and ScBSPeekBitsFast() macros
 * 	[1996/02/01  17:14:17  Hans_Graves]
 * 
 * Revision 1.1.4.12  1996/01/24  19:33:18  Hans_Graves
 * 	Added prototype for ScScaleIDCT8x8i_S
 * 	[1996/01/24  18:13:51  Hans_Graves]
 * 
 * Revision 1.1.4.11  1996/01/08  20:15:13  Bjorn_Engberg
 * 	Added one more cast to avoid warnings.
 * 	[1996/01/08  20:14:55  Bjorn_Engberg]
 * 
 * Revision 1.1.4.10  1996/01/08  16:41:21  Hans_Graves
 * 	Added protos for more IDCT routines.
 * 	[1996/01/08  15:44:17  Hans_Graves]
 * 
 * Revision 1.1.4.9  1996/01/02  18:31:13  Bjorn_Engberg
 * 	Added casts to avoid warning messages when compiling.
 * 	[1996/01/02  15:02:16  Bjorn_Engberg]
 * 
 * Revision 1.1.4.8  1995/12/07  19:31:18  Hans_Graves
 * 	Added protos for ScFDCT8x8s_C() and ScIDCT8x8s_C(), Added ScBSAlignPutBits() macro.
 * 	[1995/12/07  17:58:36  Hans_Graves]
 * 
 * Revision 1.1.4.7  1995/11/16  12:33:34  Bjorn_Engberg
 * 	Add BI_BITFIELDS to IsRGBPacked macro
 * 	[1995/11/16  12:33:17  Bjorn_Engberg]
 * 
 * Revision 1.1.4.6  1995/10/13  21:01:42  Hans_Graves
 * 	Added macros for format classes.
 * 	[1995/10/13  20:59:15  Hans_Graves]
 * 
 * Revision 1.1.4.5  1995/09/22  19:41:00  Hans_Graves
 * 	Moved ValidBI_BITFIELDSKinds to SC_convert.h
 * 	[1995/09/22  19:40:42  Hans_Graves]
 * 
 * Revision 1.1.4.4  1995/09/20  18:27:59  Hans_Graves
 * 	Added Bjorn's NT defs
 * 	[1995/09/15  13:21:00  Hans_Graves]
 * 
 * Revision 1.1.4.3  1995/09/14  12:35:22  Hans_Graves
 * 	Added ScCopyClipToPacked422() prototypes.
 * 	[1995/09/14  12:34:58  Hans_Graves]
 * 
 * Revision 1.1.4.2  1995/09/13  14:51:45  Hans_Graves
 * 	Added ScScaleIDCT8x8(). Added buffer Type to queues.
 * 	[1995/09/13  14:29:10  Hans_Graves]
 * 
 * Revision 1.1.2.18  1995/09/11  19:17:23  Hans_Graves
 * 	Moved ValidateBI_BITFIELDS() prototype to SC_convert.h - Removed mmsystem.h include.
 * 	[1995/09/11  19:14:27  Hans_Graves]
 * 
 * Revision 1.1.2.17  1995/09/11  18:51:25  Farokh_Morshed
 * 	Support BI_BITFIELDS format
 * 	[1995/09/11  18:50:48  Farokh_Morshed]
 * 
 * Revision 1.1.2.16  1995/08/31  14:15:43  Farokh_Morshed
 * 	transfer BI_BITFIELDS stuff to SV.h
 * 	[1995/08/31  14:15:20  Farokh_Morshed]
 * 
 * Revision 1.1.2.15  1995/08/31  13:51:53  Farokh_Morshed
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.13 **}
 * 		{** Merge revision:	1.1.2.14 **}
 * 	{** End **}
 * 	Add BI_BITFIELDS support
 * 	[1995/08/31  13:50:46  Farokh_Morshed]
 * 
 * Revision 1.1.2.14  1995/08/29  22:17:05  Hans_Graves
 * 	Fixed-up Bitstream prototypes. Added BI_ image formats and defined BI_DECSEPYUV411DIB == BI_YU12SEP
 * 	[1995/08/29  22:15:27  Hans_Graves]
 * 
 * Revision 1.1.2.13  1995/08/14  19:40:26  Hans_Graves
 * 	Added Flush, ScCopySubClip_S() and ScCopyRev_S() prototypes.
 * 	[1995/08/14  18:43:11  Hans_Graves]
 * 
 * Revision 1.1.2.12  1995/07/21  17:41:01  Hans_Graves
 * 	Mirrored Callbacks with MME structure/naming.
 * 	[1995/07/21  17:30:04  Hans_Graves]
 * 
 * Revision 1.1.2.11  1995/07/17  22:01:31  Hans_Graves
 * 	Added BufSize and BufType to ScCallback_t.
 * 	[1995/07/17  21:42:45  Hans_Graves]
 * 
 * Revision 1.1.2.10  1995/07/12  19:48:23  Hans_Graves
 * 	Added H261_FILE type.
 * 	[1995/07/12  19:33:18  Hans_Graves]
 * 
 * Revision 1.1.2.9  1995/07/11  15:24:30  Hans_Graves
 * 	Fixed ScCopySubClip and ScCopyRev macros.
 * 	[1995/07/11  15:24:09  Hans_Graves]
 * 
 * Revision 1.1.2.8  1995/07/11  14:50:44  Hans_Graves
 * 	Added prototypes for sc_mc2.s and sc_copy2.s
 * 	[1995/07/11  14:23:18  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/06/27  13:54:21  Hans_Graves
 * 	Added STREAM_USE_NET and prototype for ScBSCreateFromNet()
 * 	[1995/06/26  21:00:17  Hans_Graves]
 * 
 * Revision 1.1.2.6  1995/06/22  21:35:03  Hans_Graves
 * 	Moved filetypes from SV.h to here
 * 	[1995/06/22  21:29:11  Hans_Graves]
 * 
 * Revision 1.1.2.5  1995/06/21  18:37:58  Hans_Graves
 * 	Added prototype for ScBSPutBytes()
 * 	[1995/06/21  18:36:43  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/06/15  21:17:59  Hans_Graves
 * 	Added prototypes for sc_copy.c
 * 	[1995/06/15  20:41:40  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/01  19:35:36  Hans_Graves
 * 	Added prototype for ScCopyClip()
 * 	[1995/06/01  19:31:28  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:20  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:17:35  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/03  19:26:38  Hans_Graves
 * 	Included in SLIB (Oct 95)
 * 	[1995/05/03  19:26:26  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/17  18:04:26  Hans_Graves
 * 	Added math prototypes and defs. Expanding Bitstream defs.
 * 	[1995/04/17  18:02:16  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:18:43  Hans_Graves
 * 	Inclusion in SLIB
 * 	[1995/04/07  19:04:13  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/


#ifndef _SC_H_
#define _SC_H_

#define SLIB_VERSION 0x300

/************************* Debug Handling ***********************/
#ifdef _VERBOSE_
#define sc_vprintf printf
#else
#define sc_vprintf
#endif

#ifdef _DEBUG_
#define sc_dprintf printf
#else
#define sc_dprintf
#endif

#ifdef _TEST_
#define sc_tprintf(test, msg)  if (test) printf(msg)
#else
#define sc_tprintf
#endif

#ifdef _SLIBDEBUG_
#define _SlibDebug(test, statements) { if (test) { statements; } }
#else
#define _SlibDebug(test, statements)
#endif

#ifndef EXTERN
#ifdef __cplusplus
#if !defined(WIN32) || defined(STATIC_BUILD)
#define EXTERN extern "C"
#else
#define EXTERN __declspec( dllexport ) extern "C"
#endif
#else
#if !defined(WIN32) || defined(STATIC_BUILD)
#define EXTERN extern
#else
#define EXTERN __declspec( dllexport ) extern
#endif
#endif /* __cplusplus */
#endif /* EXTERN */

#ifndef PRIVATE_EXTERN
#ifdef __cplusplus
#define PRIVATE_EXTERN extern "C"
#else /* __cplusplus */
#define PRIVATE_EXTERN extern
#endif /* __cplusplus */
#endif /* PRIVATE_EXTERN */

#ifdef WIN32
/*
 * These b* routines are mem* routines on NT.
 */
#define bcopy(_src_,_dst_,_len_) memcpy(_dst_,_src_,_len_)
#define bzero(_dst_,_len_)	 memset(_dst_,0,_len_)
#define bcmp(_src_,_dst_,_len_)  memcmp(_src_,_dst_,_len_)
/*
 * These cma routines are doing nothing for NT.
 * Avoid lots of ifdefs on the code by defining
 * null macros for them. 
 */
#define cma_mutex_lock(foo)
#define cma_mutex_unlock(foo)
#endif /* WIN32 */

/************************* Elementary Types ***********************/
/*
#ifndef UNALIGNED
#if defined(WIN95) || defined(INTEL)
#define UNALIGNED
#else
#define UNALIGNED __unaligned
#endif
#endif
*/
#ifndef u_char
#if defined( __VMS ) || defined( WIN32 )
typedef unsigned char  u_char;			/*  8 bits */
typedef unsigned short u_short;			/* 16 bits */
typedef unsigned int   u_int;			/* 32 bits */
typedef unsigned long  u_long;			/* 32 bits */
#else
typedef unsigned char  u_char;			/*  8 bits */
typedef unsigned short u_short;			/* 16 bits */
typedef unsigned int   u_int;			/* 32 bits */
typedef unsigned long  u_long;			/* 64 bits */
typedef unsigned int   UINT;
#endif
#endif /* u_char */

#ifndef WIN32
#ifndef byte   /* 8 bit */
#define byte   char
#endif
#endif /* !WIN32 */

#ifndef word   /* 16 bit */
#define word   short
#endif /* word */

#ifndef dword  /* 32 bit */
#define dword  int
#endif /* dword */

#ifndef qword  /* 64 bit */
#if defined(__VMS) || defined(WIN32)
#define qword  _int64
#else
#define qword  long
#endif
#endif /* qword */

#define MIN_WORD     ((-32767)-1)
#define MAX_WORD     ( 32767)
#define MIN_DWORD    ((-2147483647)-1)
#define MAX_DWORD    ( 2147483647)

/************************** Definitions ****************************/
#define RETURN_ON_ERROR(A)      {if (A) return (A);}

#ifndef NULL
#define NULL   0L
#endif

#ifndef TRUE
#define TRUE  1 
#define FALSE 0
#endif

#ifndef WIN32
#ifndef FAR
#define FAR
#endif
#endif

#ifndef PI
#define PI      3.14159265358979
#define PI4     PI/4
#define PI64    PI/64
#endif

/*
** public parameter settings
*/
/* Algorithm Flags - video */
#define PARAM_ALGFLAG_HALFPEL  0x0001  /* Half pixel accuracy */
#define PARAM_ALGFLAG_SKIPPEL  0x0002  /* Skip-pixel error calculation */
#define PARAM_ALGFLAG_PB       0x0004  /* PB frame encoding */
#define PARAM_ALGFLAG_SAC      0x0008  /* Syntax Arithmetic Coding */
#define PARAM_ALGFLAG_UMV      0x0010  /* Unrestricted Motion Vectors */
#define PARAM_ALGFLAG_ADVANCED 0x0020  /* Advanced Prediction Mode */
/* Algorithm Flags - audio */
#define PARAM_ALGFLAG_VAD      0x1000  /* Voice Activity Detection (G.723) */
/* Format Extensions */
#define PARAM_FORMATEXT_RTPA   0x0001  /* RTP Mode A */
#define PARAM_FORMATEXT_RTPB   0x0002  /* RTP Mode B */
#define PARAM_FORMATEXT_RTPC   0x0004  /* RTP Mode C */

/* Frame types */
#define FRAME_TYPE_NONE        0x0000
#define FRAME_TYPE_I           0x0001  /* Key frame */
#define FRAME_TYPE_P           0x0002  /* Partial frame */
#define FRAME_TYPE_B           0x0004  /* Bi-directional frame */
#define FRAME_TYPE_D           0x0008  /* Preview frame */

/************************** Formats (FOURCC's) ***************************/
/*
** Image formats
*/
#define BI_MSH261DIB            mmioFOURCC('M','2','6','1')
#define BI_MSH263DIB            mmioFOURCC('M','2','6','3')
#define BI_DECH261DIB           mmioFOURCC('D','2','6','1')
#define BI_DECH263DIB           mmioFOURCC('D','2','6','3')
#define BI_DECJPEGDIB           mmioFOURCC('J','P','E','G')
#define BI_DECMJPGDIB           mmioFOURCC('M','J','P','G')
#define BI_DECYUVDIB            mmioFOURCC('D','Y','U','V')
#define BI_DECXIMAGEDIB         mmioFOURCC('D','X','I','M')	
#define BI_DECSEPYUVDIB         mmioFOURCC('D','S','Y','U')
#define BI_DECMPEGDIB           mmioFOURCC('D','M','P','G')
#define BI_DECHUFFDIB           mmioFOURCC('D','H','U','F')
#define BI_DECSEPRGBDIB         mmioFOURCC('D','S','R','G')
#define BI_DECGRAYDIB           mmioFOURCC('D','G','R','Y')
#define BI_YVU9SEP              mmioFOURCC('Y','V','U','9')
#define BI_YU12SEP              mmioFOURCC('Y','U','1','2')
#define BI_YU16SEP              mmioFOURCC('Y','U','1','6')
#define BI_DECSEPYUV411DIB      mmioFOURCC('Y','U','1','2')
#define BI_S422                 mmioFOURCC('S','4','2','2')
#define BI_YUY2                 mmioFOURCC('Y','U','Y','2')

/*
 * FYI - Other image formats that are defined elsewhere:
 */
#if 0
#define BI_RGB              0
#define BI_BITFIELDS        3
#define BICOMP_JFIF         mmioFOURCC('J','F','I','F')
#endif

/*
 * Macros to identify classes of image formats.
 */
#define IsJPEG(s)         (((s) == JPEG_DIB)            || \
                           ((s) == MJPG_DIB))
#define IsYUV422Packed(s) (((s) == BI_DECYUVDIB)        || \
                           ((s) == BI_S422)             || \
                           ((s) == BI_YUY2))
#define IsYUV422Sep(s)    (((s) == BI_DECSEPYUVDIB)     || \
                           ((s) == BI_YU16SEP))
#define IsYUV411Sep(s)    (((s) == BI_DECSEPYUV411DIB)  || \
                           ((s) == BI_YU12SEP))
#define IsYUV1611Sep(s)   (((s) == BI_YVU9SEP))
#define IsYUVSep(s)       ((IsYUV422Sep(s))             || \
                           (IsYUV411Sep(s))             || \
                           (IsYUV1611Sep(s)))
#define IsYUV(s)          ((IsYUV422Packed(s))          || \
                           (IsYUVSep(s)))

#define IsRGBPacked(s)    (((s) == BI_RGB)              || \
                           ((s) == BI_DECXIMAGEDIB)     || \
                           ((s) == BI_BITFIELDS))
#define IsRGBSep(s)       (((s) == BI_DECSEPRGBDIB))
#define IsRGB(s)          ((IsRGBPacked(s))             || \
                           (IsRGBSep(s)))

#define IsGray(s)         (((s) == BI_DECGRAYDIB))

#define ISIZE(w,h,c) \
        (IsYUV411Sep(c)) ? ((w) * (h) * 3 / 2) : \
                ((IsYUV1611Sep(c)) ? \
                        ((w) * (h) * 9 / 8) : \
                                ((IsYUV422Sep(c) || IsYUV422Packed(c)) ? \
                                        ((w) * (h) * 2) : ((w) * (h) * 3)));

/*
** File Types (returned from ScGetFileType)
*/
#define UNKNOWN_FILE        0
#define AVI_FILE            201
#define MPEG_VIDEO_FILE     202
#define MPEG_AUDIO_FILE     203
#define MPEG_SYSTEM_FILE    204
#define JFIF_FILE           205
#define QUICKTIME_JPEG_FILE 206
#define GSM_FILE            207
#define WAVE_FILE           208
#define PCM_FILE            209
#define H261_FILE           210
#define AC3_FILE            211

/*
** Callback messages
*/
#define CB_RELEASE_BUFFER       1   /* buffer finished */
#define CB_END_BUFFERS          2   /* no more buffers */
#define CB_RESET_BUFFERS        3   /* reset to beginning */
#define CB_SEQ_HEADER           4   /* sequence header */
#define CB_SEQ_END              5   /* sequence end */
#define CB_FRAME_FOUND          6   /* frame found */
#define CB_FRAME_READY          7   /* frame completed */
#define CB_FRAME_START          8   /* frame starting to be processed */
#define CB_PROCESSING           9   /* processing data */
#define CB_CODEC_DONE          10   /* codec done ended */

/*
** Data types for callback message
*/
#define CB_DATA_NONE            0x0000 /* no data */
#define CB_DATA_COMPRESSED      0x0001 /* data is compressed */
#define CB_DATA_IMAGE           0x0002 /* data is decompressed image */
#define CB_DATA_AUDIO           0x0004 /* data is decompressed audio */
/*
** Frame flags for callback message
*/
#define CB_FLAG_TYPE_KEY        0x0001 /* key frame */
#define CB_FLAG_TYPE_MPEGB      0x0002 /* MPEG B-Frame */
#define CB_FLAG_FRAME_DROPPED   0x0008 /* frame dropped */
#define CB_FLAG_FRAME_BAD       0x0010 /* could not de/compress */
/*
** Action values in response to callback message
*/
#define CB_ACTION_WAIT          0x0000 /* wait - callback still busy */
#define CB_ACTION_CONTINUE      0x0001 /* accept a frame */
#define CB_ACTION_DROP          0x0002 /* drop a frame */
#define CB_ACTION_DUPLICATE     0x0004 /* duplicate a frame */
#define CB_ACTION_END           0x0080 /* end de/compression */

/* These are old definitions
#define CLIENT_CONTINUE        CB_ACTION_CONTINUE
#define CLIENT_ABORT           CB_ACTION_END
#define CLIENT_PROCESS         CB_ACTION_CONTINUE
#define CLIENT_DROP            CB_ACTION_DROP
#define CB_IMAGE_BUFFER_READY  CB_FRAME_READY
#define CB_PICTURE_FOUND       CB_FRAME_FOUND
#define CB_PICTURE_PROCEESSED  CB_FRAME_READY
#define CB_FRAME               CB_FRAME_FOUND
*/


/*
 * Stream sources/destinations
 */
#define STREAM_USE_SAME     -1
#define STREAM_USE_NULL     0
#define STREAM_USE_QUEUE    1
#define STREAM_USE_FILE     2
#define STREAM_USE_BUFFER   3
#define STREAM_USE_DEVICE   4
#define STREAM_USE_STDOUT   5
#define STREAM_USE_NET      6
#define STREAM_USE_NET_TCP  6  /* reliable transport */
#define STREAM_USE_NET_UDP  7  /* unreliable transport */

/************************** Type Definitions *******************************/
typedef int           ScStatus_t;
typedef void         *ScHandle_t;
typedef unsigned char ScBoolean_t;
#if !defined( _VMS ) && !defined( WIN32 )
/* typedef long          _int64; */
#endif

/*
** Bitstream stuff
*/
#if defined( _VMS ) || defined( WIN95 )
#define SC_BITBUFFSZ    32
typedef unsigned dword ScBitBuff_t;
typedef unsigned dword ScBitString_t;
#else
#define SC_BITBUFFSZ    64
typedef unsigned qword ScBitBuff_t;
typedef unsigned qword ScBitString_t;
#endif
#define SC_BITBUFFMASK  (ScBitBuff_t)-1
#define ALIGNING        8
#define ScBSPreLoad(bs, bits) if ((int)bs->shift<(bits)) sc_BSLoadDataWord(bs);
#define ScBSPreLoadW(bs, bits) if ((int)bs->shift<(bits)) sc_BSLoadDataWordW(bs);
#define ScBSByteAlign(bs) { \
      int len=bs->shift%8; \
      if (len) { \
        bs->OutBuff=(bs->OutBuff<<len)|(bs->InBuff>>(SC_BITBUFFSZ-len)); \
        bs->InBuff<<=len; bs->CurrentBit+=len; bs->shift-=len; } \
        }
#define ScBSAlignPutBits(bs) if (bs->shift%8) \
                               ScBSPutBits(bs, 0, 8-(bs->shift%8));
#define ScBSBitPosition(bs)  (bs->CurrentBit)
#define ScBSBytePosition(bs) (bs->CurrentBit>>3)
#define ScBSBufferedBytes(bs) (bs->bufftop)
#define ScBSBufferedBytesUsed(bs) (bs->buffp)
#define ScBSBufferedBytesUnused(bs) (bs->bufftop-bs->buffp)
#define ScBSSkipBit(bs)      ScBSSkipBits(bs, 1)
#define ScBSSkipBitsFast(bs, len) { if ((u_int)(len)<=bs->shift) { \
     if ((len)==SC_BITBUFFSZ) \
       { bs->OutBuff=bs->InBuff; bs->InBuff=0; } \
     else { \
       bs->OutBuff=(bs->OutBuff<<(len))|(bs->InBuff>>(SC_BITBUFFSZ-(len))); \
       bs->InBuff<<=(len); } \
       bs->CurrentBit+=len; bs->shift-=len; \
     } else ScBSSkipBits(bs, len); }
#define ScBSSkipBitFast(bs) ScBSSkipBitsFast(bs, 1)
#define ScBSPeekBitsFast(bs, len) (!(len) ? 0 \
     : (((len)<=bs->shift || !sc_BSLoadDataWord(bs)) && (len)==SC_BITBUFFSZ \
            ? bs->OutBuff : (bs->OutBuff >> (SC_BITBUFFSZ-len))) )
#define ScBSPeekBitsFull(bs, result) \
        { ScBSPreLoad(bs, SC_BITBUFFSZ); result = bs->OutBuff; }

/*
** Sort stuff
*/
typedef struct ScSortDouble_s {
  int    index;   /* index to actual data */
  double num;     /* the number to sort by */
} ScSortDouble_t;

typedef struct ScSortFloat_s {
  int    index;   /* index to actual data */
  double num;     /* the number to sort by */
} ScSortFloat_t;

/*
** ScBuf_s structure used in Buffer/Image Queue management.
** Contains info for one buffer.
*/
struct ScBuf_s {
  u_char *Data;                 /* Pointer to buffer's data            */
  int    Size;                  /* Length of buffer in bytes           */
  int    Type;                  /* Type of buffer                      */
  struct ScBuf_s *Prev;         /* Pointer to previous buffer in queue */
};

/*
** Buffer queue structure. One for each queue.
*/
typedef struct ScQueue_s {
  int NumBufs;                  /* Number of buffers currently in queue */
  struct ScBuf_s *head, *tail;  /* pointers to head & tail of queue     */
} ScQueue_t;

/*
** ScCallbackInfo_t passes info back & forth during callback
*/
typedef struct ScCallbackInfo_s {
  int     Message;    /* Callback reason: CB_FRAME_READY, etc. */
  int     DataType;   /* Buffer data type */
  u_char *Data;       /* Pointer to data buffer. */
  dword   DataSize;   /* Length of data buffer */
  dword   DataUsed;   /* Actual bytes used in buffer */
  void   *UserData;   /* User defined data */
  qword   TimeStamp;  /* Timestamp of decompressed img/audio */
                      /* relative to start of sequence */
  dword   Flags;      /* decomp/compression details */
  int     Action;     /* drop frame or continue */
  dword   Value;      /* a value for special flags/actions */
  void   *Format;     /* BITMAPINFOHEADER or WAVEFORMATEX */
} ScCallbackInfo_t;

typedef qword ScBSPosition_t;
/*
** State info for the input bitstream
*/
typedef struct ScBitstream_s {
  dword DataSource;             /* STREAM_USE_BUFFER, _USE_QUEUE,_USE_FILE,   */
                                /* or _USE_DEVICE                             */
  char Mode;                    /* 'r'=read, 'w'=write, 'b'=both              */
  ScQueue_t *Q;                 /* Buffer Queue (STREAM_USE_QUEUE)            */
  int (*Callback)(ScHandle_t,   /* Callback to supply Bufs (STREAM_USE_QUEUE) */
             ScCallbackInfo_t *, void *);
  int (*FilterCallback)(struct  /* Callback to filter data from bitstream     */
               ScBitstream_s *);
  unsigned qword FilterBit;     /* Bit to call filter callback at             */
  unsigned char  InFilterCallback; /* TRUE when FilterCallback is busy           */
  ScHandle_t     Sch;           /* Handle passed to Callback                  */
  dword          DataType;      /* Data type passed to Callback               */
  void          *UserData;      /* User Data passed to Callback               */
  int            FileFd;        /* File descriptor (STREAM_USE_FILE/NET)      */
  unsigned char *RdBuf;         /* Buf to use if (_USE_BUFFER,_USE_FILE)      */
  unsigned dword RdBufSize;     /* Size of RdBuf                              */
  char           RdBufAllocated;/* = TRUE if RdBuf was internally allocated   */
  dword          Device;        /* Device to use (STREAM_USE_DEVICE)          */
  ScBitBuff_t    InBuff, OutBuff; /* 64-bit or 32-bit data buffers            */
  unsigned int   shift;         /* Shift value for current bit position       */
  ScBSPosition_t CurrentBit;    /* Current bit position in bitstream          */
  unsigned char *buff;          /* pointer to bitstream data buffer           */
  unsigned dword buffstart;     /* byte offset of start of buff               */
  unsigned dword buffp;         /* byte offset in buffer                      */
  unsigned dword bufftop;       /* number of bytes in buffer                  */
  ScBoolean_t    EOI;           /* = TRUE when no more data in data source    */
  ScBoolean_t    Flush;         /* = TRUE to signal a flush at next 32/64 bit */
} ScBitstream_t;

/*
** Bitstream context block to save current position of input stream
*/
typedef struct ScBitstreamSave_s {
  ScBitBuff_t    InBuff, OutBuff;  /* 64-bit or 32-bit data buffers              */
  unsigned dword shift;            /* Shift value for current bit position       */
  ScBSPosition_t CurrentBit;       /* Current bit position in bitstream          */
  unsigned char *buff;             /* pointer to bitstream data buffer           */
  unsigned dword buffp;            /* byte offset in buffer                      */
  ScBoolean_t    EOI;              /* = TRUE when no more data in data source    */
  ScBoolean_t    Flush;            /* = TRUE to signal a flush at next 32/64 bit */
} ScBitstreamSave_t;


/************************** Prototypes *****************************/
/*
 * sc_file.c
 */
PRIVATE_EXTERN ScBoolean_t ScFileExists(char *filename);
PRIVATE_EXTERN int         ScFileOpenForReading(char *filename);
PRIVATE_EXTERN int         ScFileOpenForWriting(char *filename, ScBoolean_t truncate);
PRIVATE_EXTERN ScStatus_t  ScFileSize(char *filename, unsigned qword *size);
PRIVATE_EXTERN dword       ScFileRead(int fd, void *buffer, unsigned dword bytes);
PRIVATE_EXTERN dword       ScFileWrite(int fd, void *buffer, unsigned dword bytes);
PRIVATE_EXTERN ScStatus_t  ScFileSeek(int fd, qword bytepos);
PRIVATE_EXTERN void        ScFileClose(int fd);
PRIVATE_EXTERN ScStatus_t  ScFileMap(char *filename, int *fd, u_char **buffer,
                                         unsigned qword *size);
PRIVATE_EXTERN ScStatus_t  ScFileUnMap(int fd, u_char *buffer, unsigned int size);
PRIVATE_EXTERN int         ScGetFileType(char *filename);

/*
 * sc_mem.c
 */
PRIVATE_EXTERN void     *ScAlloc(unsigned long bytes);
PRIVATE_EXTERN void     *ScAlloc2(unsigned long bytes, char *name);
PRIVATE_EXTERN void     *ScCalloc(unsigned long bytes);
PRIVATE_EXTERN void      ScFree(void *);
PRIVATE_EXTERN int       ScMemCheck(char *array,int test,int num);
EXTERN char     *ScPaMalloc(int);
EXTERN void      ScPaFree(void *);
EXTERN int       getpagesize();

/*
 * sc_util.c
 */
extern int       sc_Dummy();
PRIVATE_EXTERN unsigned int ScImageSize(unsigned int fourcc, int w, int h, int bits);
extern void      ScReadCommandSwitches(char *argv[],int argc,
                                 void (*error_routine)(),char *,...);
extern void      ScShowBuffer(unsigned char *, int);
extern void      ScShowBufferFloat(float *, int);
extern void      ScShowBufferInt(int *, int);
extern int       ScDumpChar(unsigned char *ptr, int nbytes, int startpos);



/*
 * sc_errors.c
 */
PRIVATE_EXTERN ScStatus_t ScGetErrorText (int errno, char *ReturnMsg, u_int MaxChars);
PRIVATE_EXTERN char *ScGetErrorStr(int errno);
extern char _serr_msg[80];

/*
 * sc_buf.c
 */
PRIVATE_EXTERN ScStatus_t ScBSSetFilter(ScBitstream_t *BS,
                    int (*Callback)(ScBitstream_t *BS));
PRIVATE_EXTERN ScStatus_t ScBSCreate(ScBitstream_t **BS);
PRIVATE_EXTERN ScStatus_t ScBSCreateFromBuffer(ScBitstream_t **BS,
                                    u_char *Buffer, unsigned int BufSize);
PRIVATE_EXTERN ScStatus_t ScBSCreateFromBufferQueue(ScBitstream_t **BS,
                                ScHandle_t Sch, int DataType, ScQueue_t *Q,
                         int (*Callback)(ScHandle_t,ScCallbackInfo_t *,void *),
                         void *UserData);
PRIVATE_EXTERN ScStatus_t ScBSCreateFromFile(ScBitstream_t **BS,int FileFd,
                                u_char *Buffer, int BufSize);
PRIVATE_EXTERN ScStatus_t ScBSCreateFromNet(ScBitstream_t **BS, int SocketFd, 
                                u_char *Buffer, int BufSize);
PRIVATE_EXTERN ScStatus_t ScBSCreateFromDevice(ScBitstream_t **BS, int device);
PRIVATE_EXTERN ScStatus_t ScBSDestroy(ScBitstream_t *BS);
PRIVATE_EXTERN ScStatus_t ScBSFlush(ScBitstream_t *BS);
PRIVATE_EXTERN ScStatus_t ScBSFlushSoon(ScBitstream_t *BS);
PRIVATE_EXTERN ScStatus_t ScBSReset(ScBitstream_t *BS);
PRIVATE_EXTERN ScStatus_t ScBSResetCounters(ScBitstream_t *BS);

PRIVATE_EXTERN ScStatus_t ScBSSkipBits(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN ScStatus_t ScBSSkipBitsW(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN ScStatus_t ScBSSkipBytes(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN int        ScBSPeekBit(ScBitstream_t *BS);
PRIVATE_EXTERN ScBitString_t ScBSPeekBits(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN ScBitString_t ScBSPeekBytes(ScBitstream_t *BS, u_int length);

PRIVATE_EXTERN int ScBSGetBytes(ScBitstream_t *BS, u_char *buffer, u_int length,
                                                 u_int *ret_length);
PRIVATE_EXTERN int ScBSGetBytesStopBefore(ScBitstream_t *BS, u_char *buffer, 
                              u_int length, u_int *ret_length,
                              ScBitString_t seek_word, int word_len);
PRIVATE_EXTERN ScBitString_t ScBSGetBits(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN ScBitString_t ScBSGetBitsW(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN int        ScBSGetBitsVarLen(ScBitstream_t *BS, const int *table, 
                                                     int len);
PRIVATE_EXTERN ScStatus_t ScBSPutBytes(ScBitstream_t *BS, u_char *buffer,
                                                 u_int length);
PRIVATE_EXTERN ScStatus_t ScBSPutBits(ScBitstream_t *BS, ScBitString_t bits, 
                                                 u_int length);
PRIVATE_EXTERN ScStatus_t ScBSPutBit(ScBitstream_t *BS, char bit);
PRIVATE_EXTERN int        ScBSGetBit(ScBitstream_t *BS);

PRIVATE_EXTERN ScStatus_t ScBSSeekToPosition(ScBitstream_t *BS, unsigned long pos);
PRIVATE_EXTERN int        ScBSSeekStopBefore(ScBitstream_t *BS, ScBitString_t seek_word, int word_len);
PRIVATE_EXTERN int        ScBSSeekAlign(ScBitstream_t *BS, ScBitString_t seek_word,int word_len);
PRIVATE_EXTERN int        ScBSSeekAlignStopBefore(ScBitstream_t *BS,ScBitString_t seek_word,int word_len);
PRIVATE_EXTERN int        ScBSSeekAlignStopBeforeW(ScBitstream_t *BS,ScBitString_t seek_word,int word_len);
PRIVATE_EXTERN int        ScBSSeekAlignStopAt(ScBitstream_t *BS,
                                      ScBitString_t seek_word,
                                      int word_len, unsigned long end_byte_pos);
extern ScStatus_t sc_BSLoadDataWord(ScBitstream_t *BS);
extern ScStatus_t sc_BSStoreDataWord(ScBitstream_t *BS, ScBitBuff_t Buff);

PRIVATE_EXTERN ScStatus_t ScBufQueueCreate(ScQueue_t **Q);
PRIVATE_EXTERN ScStatus_t ScBufQueueDestroy(ScQueue_t *Q);
PRIVATE_EXTERN ScStatus_t ScBufQueueAdd(ScQueue_t *Q, u_char *Data, int Size);
PRIVATE_EXTERN ScStatus_t ScBufQueueAddExt(ScQueue_t *Q, u_char *Data, int Size,
                                   int Type);
PRIVATE_EXTERN ScStatus_t ScBufQueueRemove(ScQueue_t *Q);
PRIVATE_EXTERN int        ScBufQueueGetNum(ScQueue_t *Q);
PRIVATE_EXTERN ScStatus_t ScBufQueueGetHead(ScQueue_t *Q, u_char **Data,
                                                          int *Size);
PRIVATE_EXTERN ScStatus_t ScBufQueueGetHeadExt(ScQueue_t *Q, u_char **Data,
                                               int *Size, int *Type);


/*
** sc_math.c
*/
/* #define ScAbs(val) (val > 0.0) ? val : -val */
extern float ScAbs(float val);
extern double ScSqr(double x);
extern double ScDistance(double x1, double y1, double z1,
                         double x2, double y2, double z2);
extern void  ScDigrv4(float *real, float *imag, int n);
extern float ScArcTan(float Q,float I);

/*
** sc_dct.c
*/
extern void ScFDCT(float in_block[32], float out_block1[32],
                   float out_block2[32]);
extern void ScIFDCT(float in_block[32], float out_block[32]);
extern void ScFDCT8x8_C(float *ipbuf, float *outbuf);
extern void ScFDCT8x8s_C(short *inbuf, short *outbuf);

/*
** sc_dct2.c
*/
extern void ScFDCT8x8_S(float *ipbuf, float *outbuf);

/*
** sc_idct.c
*/
extern void ScIDCT8x8(int *outbuf);
extern void ScScaleIDCT8x8_C(float *ipbuf, int *outbuf);
extern void ScIDCT8x8s_C(short *inbuf, short *outbuf);

/*
** sc_idct_scaled.c
*/
extern void ScScaleIDCT8x8i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT8x8i128_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT1x1i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT1x2i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT2x1i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT2x2i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT3x3i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT4x4i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT6x6i_C(int *inbuf, int *outbuf);

/*
** sc_idct2.s
*/
extern void ScIDCT8x8s_S(short *inbuf, short *outbuf);
extern void ScScaleIDCT8x8i_S(int *inbuf, int *outbuf);

/*
** sc_idct3.s
*/
extern void ScScaleIDCT8x8m_S(int *inbuf);

/*
** sc_idctp2.s
*/
extern void ScPatScaleIDCT8x8i_S(int *inbuf, int *outbuf);

/*
** sc_fft.c
*/
extern void  ScFFTtrl(float *real,float *imag,int n,int max_fft,float *c1,
                      float *s1,float *c2,float *s2,float *c3,float *s3);
extern void  ScFFTtl(float *real, float *imag, int n, int max_fft, float *c1,
                     float *s1, float *c2, float *s2, float *c3, float *s3);
extern void  ScFFTt4l(float *real, float *imag, int n, int *angle_increment,
                      int max_fft, float *c1, float *s1, float *c2, float *s2,
                      float *c3, float *s3);

/*
** sc_sort.c
*/
extern void ScSortDoubles(ScSortDouble_t *a, int n);

/*
** sc_copy.c
*/
extern void ScCopyClip_C(int *buf, unsigned int *pos, int inc);
extern void ScCopyClipToPacked422_C(int *buf, unsigned char *pos, int inc);
extern void ScCopyAddClip_C(unsigned char *mvbuf, int *idctbuf,
                unsigned int *pbuf, int mvinc, int pwidth);
extern void ScCopySubClip_C(unsigned char *mvbuf, float *idctbuf, 
                unsigned int *pbuf, int mvinc, int pwidth);
extern void ScCopyRev_C(unsigned int *yptr, float *Idctptr, int Inc);
extern void ScCopyMV8_C(unsigned char *mvbuf, unsigned int *pbuf,
                        int mvinc, int pwidth);
extern void ScLoopFilter_C(unsigned char *input, unsigned int *work, int inc);
extern void ScCopyBlock_C(unsigned char *linmemu, unsigned char *linmemv,
                 int xpos, unsigned char *blkmemu,
                 unsigned char *blkmemv, int cwidth, int wsis);
extern void ScCopyMB_C(unsigned char *ysrc, int xpos, unsigned char *ymb,
                  int ywidth, int yywidth);
extern void ScCopyMB8_C(unsigned char *ysrc, unsigned char *ymb,
                         int ywidth, int yywidth);
extern void ScCopyMB16_C(unsigned char *ysrc, unsigned char *ymb,
                         int ywidth, int yywidth);

/*
** sc_copy2.s
*/
extern void ScCopyClip_S(int *buf, unsigned int *pos, int inc);
extern void ScCopyClipToPacked422_S(int *buf, unsigned char *pos, int inc);
extern void ScCopyAddClip_S(unsigned char *mvbuf, int *idctbuf,
                unsigned int *pbuf, int mvinc, int pwidth);
extern void ScCopySubClip_S(unsigned char *mvbuf, float *idctbuf, 
                unsigned int *pbuf, int mvinc, int pinc);
extern void ScCopyRev_S(unsigned int *yptr, float *Idctptr, int yinc);
extern void ScLoopFilter_S(unsigned char *input, unsigned int *work, int inc);
extern void ScCopyMV8_S(unsigned char *mvbuf, unsigned int *pbuf,
                         int mvinc, int pwidth);
extern void ScCopyMV16_S(unsigned char *mvbuf, unsigned int *pbuf,
                         int mvinc, int pwidth);
extern void ScCopyMB8_S(unsigned char *ysrc, unsigned char *ymb,
                         int ywidth, int yywidth);
extern void ScCopyMB16_S(unsigned char *ysrc, unsigned char *ymb,
                         int ywidth, int yywidth);
extern void ScAvgMV_S(unsigned char *, unsigned char *);


/*
** sc_mc2.s
*/
extern void ScMCy8(unsigned char *, unsigned char *, int);
extern void ScMCy16(unsigned char *, unsigned char *, int);
extern void ScMCx8(unsigned char *, unsigned char *, int);
extern void ScMCx16(unsigned char *, unsigned char *, int);
extern void ScMCxy8(unsigned char *, unsigned char *, int);
extern void ScMCxy16(unsigned char *, unsigned char *, int);

/*
**  macros for using C or assembly versions
*/
#ifdef USE_C
#define ScCopyClip             ScCopyClip_C
#define ScCopyClipToPacked422  ScCopyClipToPacked422_C
#define ScCopyAddClip          ScCopyAddClip_C
#define ScCopySubClip          ScCopySubClip_C
#define ScCopyRev              ScCopyRev_C
#define ScLoopFilter           ScLoopFilter_C
#define ScCopyMV8              ScCopyMV8_C
#define ScCopyMV16             ScCopyMV16_C
#define ScCopyMB8              ScCopyMB8_C
#define ScCopyMB16             ScCopyMB16_C
#define ScAvgMV                ScAvgMV_C
#define ScScaleIDCT8x8         ScScaleIDCT8x8_C
#define ScScaleIDCT8x8i        ScScaleIDCT8x8i_C
#define ScScaleIDCT8x8i128     ScScaleIDCT8x8i128_C
#define ScPatScaleIDCT8x8i     ScScaleIDCT8x8i_C
#define ScFDCT8x8              ScFDCT8x8_C
#define ScFDCT8x8s             ScFDCT8x8s_C
#define ScIDCT8x8s             ScIDCT8x8s_C
#define ScIDCT8x8sAndCopy      ScIDCT8x8sAndCopy_C
#else /* USE_C */
#define ScCopyClip             ScCopyClip_S
#define ScCopyClipToPacked422  ScCopyClipToPacked422_S
#define ScCopyAddClip          ScCopyAddClip_S
#define ScCopySubClip          ScCopySubClip_S
#define ScCopyRev              ScCopyRev_S
#define ScLoopFilter           ScLoopFilter_S
#define ScCopyMV8              ScCopyMV8_S
#define ScCopyMV16             ScCopyMV16_S
#define ScCopyMB8              ScCopyMB8_S
#define ScCopyMB16             ScCopyMB16_S
#define ScAvgMV                ScAvgMV_S
#define ScScaleIDCT8x8         ScScaleIDCT8x8_C
#define ScScaleIDCT8x8i        ScScaleIDCT8x8i_C
#define ScScaleIDCT8x8i128     ScScaleIDCT8x8i128_C
#define ScPatScaleIDCT8x8i     ScPatScaleIDCT8x8i_S
#define ScFDCT8x8              ScFDCT8x8_S
#define ScFDCT8x8s             ScFDCT8x8s_C
#define ScIDCT8x8s             ScIDCT8x8s_S
#define ScIDCT8x8sAndCopy      ScIDCT8x8sAndCopy_S
#endif /* USE_C */

#endif /* _SC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sa_api.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sa_api.c,v $
 * Revision 1.1.8.6  1996/11/25  18:21:14  Hans_Graves
 * 	Fix compile warnings under unix.
 * 	[1996/11/25  18:21:00  Hans_Graves]
 *
 * Revision 1.1.8.5  1996/11/14  21:49:21  Hans_Graves
 * 	AC3 buffering fixes.
 * 	[1996/11/14  21:45:14  Hans_Graves]
 * 
 * Revision 1.1.8.4  1996/11/13  16:10:44  Hans_Graves
 * 	AC3 frame size calculation change.
 * 	[1996/11/13  15:53:44  Hans_Graves]
 * 
 * Revision 1.1.8.3  1996/11/08  21:50:27  Hans_Graves
 * 	Added AC3 support.
 * 	[1996/11/08  21:08:35  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/09/18  23:45:23  Hans_Graves
 * 	Add some some MPEG memory freeing
 * 	[1996/09/18  21:42:12  Hans_Graves]
 * 
 * Revision 1.1.6.8  1996/04/23  21:01:38  Hans_Graves
 * 	Added SaDecompressQuery() and SaCompressQuery()
 * 	[1996/04/23  20:57:47  Hans_Graves]
 * 
 * Revision 1.1.6.7  1996/04/17  16:38:31  Hans_Graves
 * 	Add casts where ScBitBuf_t and ScBitString_t types are used
 * 	[1996/04/17  16:34:14  Hans_Graves]
 * 
 * Revision 1.1.6.6  1996/04/15  14:18:32  Hans_Graves
 * 	Change proto for SaCompress() - returns bytes processed
 * 	[1996/04/15  14:10:27  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/04/10  21:46:51  Hans_Graves
 * 	Added SaGet/SetParam functions
 * 	[1996/04/10  21:25:16  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/04/09  16:04:23  Hans_Graves
 * 	Remove warnings under NT
 * 	[1996/04/09  15:55:26  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/03/29  22:20:48  Hans_Graves
 * 	Added MPEG_SUPPORT and GSM_SUPPORT
 * 	[1996/03/29  21:51:24  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/03/08  18:46:05  Hans_Graves
 * 	Removed debugging printf
 * 	[1996/03/08  18:42:52  Hans_Graves]
 * 
 * Revision 1.1.4.5  1996/02/22  21:55:04  Bjorn_Engberg
 * 	Removed a compiler warning on NT.
 * 	[1996/02/22  21:54:39  Bjorn_Engberg]
 * 
 * Revision 1.1.4.4  1996/02/06  22:53:51  Hans_Graves
 * 	Moved ScBSReset() from DecompressBegin() to DecompressEnd(). Disabled FRAME callbacks.
 * 	[1996/02/06  22:19:16  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/01/19  15:29:27  Bjorn_Engberg
 * 	Removed compiler wanrnings for NT.
 * 	[1996/01/19  15:03:46  Bjorn_Engberg]
 * 
 * Revision 1.1.4.2  1996/01/15  16:26:18  Hans_Graves
 * 	Added SaSetBitrate(). SOme MPEG Audio encoding fix-ups
 * 	[1996/01/15  16:07:48  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/07/21  17:40:57  Hans_Graves
 * 	Renamed Callback related stuff.
 * 	[1995/07/21  17:25:44  Hans_Graves]
 * 
 * Revision 1.1.2.6  1995/06/27  17:40:57  Hans_Graves
 * 	Removed include <mmsystem.h>.
 * 	[1995/06/27  17:32:20  Hans_Graves]
 * 
 * Revision 1.1.2.5  1995/06/27  13:54:14  Hans_Graves
 * 	Added GSM Encoding and Decoding
 * 	[1995/06/26  21:04:12  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/06/09  18:33:27  Hans_Graves
 * 	Added SaGetInputBitstream().
 * 	[1995/06/09  18:32:35  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/07  19:34:39  Hans_Graves
 * 	Enhanced sa_GetMpegAudioInfo().
 * 	[1995/06/07  19:33:25  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:07:17  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  17:28:50  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/17  18:47:31  Hans_Graves
 * 	Added MPEG Compression functionality
 * 	[1995/04/17  18:47:00  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:55:45  Hans_Graves
 * 	Inclusion in SLIB
 * 	[1995/04/07  19:55:15  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _DEBUG_
#define _VERBOSE_
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "SC.h"
#include "SC_err.h"
#include "SA.h"
#ifdef MPEG_SUPPORT
#include "sa_mpeg.h"
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
#include "sa_gsm.h"
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
#include "sa_ac3.h"
#endif /* AC3_SUPPORT */
#include "sa_intrn.h"
#include "sa_proto.h"

#ifdef MPEG_SUPPORT
static int MPEGAudioFilter(ScBitstream_t *bs)
{
  int type, stat=NoErrors;
  unsigned dword PacketStartCode;
  ScBSPosition_t PacketStart, PacketLength=0;

  while (!bs->EOI)
  {
    if ((int)ScBSPeekBits(bs, MPEG_SYNC_WORD_LEN)==MPEG_SYNC_WORD)
    {
      ScBSSetFilter(bs, NULL);
      return(0);
    }
    PacketStartCode=(unsigned int)ScBSGetBits(bs, PACKET_START_CODE_PREFIX_LEN);
    if (PacketStartCode!=PACKET_START_CODE_PREFIX) {
      fprintf(stderr,"Packet cannot be located at Byte pos 0x%X; got 0x%X\n",
                      ScBSBytePosition(bs),PacketStartCode);
      bs->EOI=TRUE;
      return(-1);
    }
    type=(int)ScBSGetBits(bs, 8);
    switch (type)
    {
      case AUDIO_STREAM_BASE:
             PacketLength=(unsigned int)ScBSGetBits(bs, 16)*8;
             PacketStart=ScBSBitPosition(bs);
             sc_dprintf("Audio Packet Start=0x%X Length=0x%X (0x%X)\n",
                          PacketStart/8, PacketLength/8, PacketLength/8);
             while (ScBSPeekBits(bs, 8)==0xFF) /* Stuffing bytes */
               ScBSSkipBits(bs, 8);
             if (ScBSPeekBits(bs, 2)==1)       /* STD_buffer stuff */
               ScBSSkipBits(bs, 2*8);
             if (ScBSPeekBits(bs, 4)==2)       /* Time Stamps */
               ScBSSkipBits(bs, 5*8);
             else if (ScBSPeekBits(bs, 4)==3)  /* Time Stamps */
               ScBSSkipBits(bs, 10*8);
             else if (ScBSGetBits(bs, 8)!=0x0F)
               fprintf(stderr, "Last byte before data not 0x0F at pos 0x%X\n",
                                             ScBSBytePosition(bs));
             return((int)(PacketStart+PacketLength));
             break;
      case PACK_START_BASE:
             sc_dprintf("Pack Start=0x%X Length=0x%X\n",
                          ScBSBytePosition(bs), 8);
             ScBSSkipBits(bs, 8*8);
             break;
      default:
             PacketLength=(unsigned int)ScBSGetBits(bs, 16)*8;
             ScBSSkipBits(bs, (unsigned int)PacketLength);
             break;
    }
  }
  return(0);
}
#endif /* MPEG_SUPPORT */

/*
** Name:     SaOpenCodec
** Purpose:  Open the specified codec. Return stat code.
**
** Args:     CodecType = SA_MPEG_ENCODE & SA_MPEG_DECODE are the only
**           recognized codec for now.
**           Sah = handle to software codec's Info structure.
*/
SaStatus_t SaOpenCodec (SaCodecType_e CodecType, SaHandle_t *Sah)
{
   int stat;
   SaCodecInfo_t          *Info = NULL;

   if ((CodecType != SA_PCM_DECODE)
       && (CodecType != SA_PCM_ENCODE)
#ifdef MPEG_SUPPORT
       && (CodecType != SA_MPEG_DECODE)
       && (CodecType != SA_MPEG_ENCODE)
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
       && (CodecType != SA_GSM_DECODE)
       && (CodecType != SA_GSM_ENCODE)
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
       && (CodecType != SA_AC3_DECODE)
       /* && (CodecType != SA_AC3_ENCODE) */
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
       && (CodecType != SA_G723_DECODE)
       && (CodecType != SA_G723_ENCODE)
#endif /* G723_SUPPORT */
     )
     return(SaErrorCodecType);

   if (!Sah)
     return (SaErrorBadPointer);

   /*
   ** Allocate memory for the Codec Info structure:
   */
   if ((Info = (SaCodecInfo_t *)ScAlloc(sizeof(SaCodecInfo_t))) == NULL)
       return (SaErrorMemory);

   Info->Type = CodecType;
   Info->CallbackFunction=NULL;
   Info->BSIn = NULL;
   Info->BSOut = NULL;
   stat = ScBufQueueCreate(&Info->Q);
   if (stat != NoErrors)
     return(stat);

   /*
   ** Allocate memory for Info structure and clear it
   */
   switch(CodecType)
   {
     case SA_PCM_DECODE:
     case SA_PCM_ENCODE:
          break;

#ifdef MPEG_SUPPORT
     case SA_MPEG_DECODE:
          {
            SaMpegDecompressInfo_t *MDInfo;
            if ((MDInfo = (SaMpegDecompressInfo_t *)
                  ScAlloc (sizeof(SaMpegDecompressInfo_t))) == NULL)
              return(SaErrorMemory);
            Info->MDInfo = MDInfo;
            stat = sa_InitMpegDecoder (Info);
            RETURN_ON_ERROR(stat);
          }
          break;

     case SA_MPEG_ENCODE:
          {
            SaMpegCompressInfo_t *MCInfo;
            if ((MCInfo = (SaMpegCompressInfo_t *)
                  ScAlloc (sizeof(SaMpegCompressInfo_t))) == NULL)
              return(SaErrorMemory);
            Info->MCInfo = MCInfo;
            stat = sa_InitMpegEncoder (Info);
            RETURN_ON_ERROR(stat);
          }
          break;
#endif /* MPEG_SUPPORT */

#ifdef AC3_SUPPORT
     case SA_AC3_DECODE:
     /* case SA_AC3_ENCODE: */
          {
            SaAC3DecompressInfo_t *AC3Info;
            if ((AC3Info = (SaAC3DecompressInfo_t *)
                       ScAlloc (sizeof(SaAC3DecompressInfo_t))) == NULL)
              return(SaErrorMemory);
            Info->AC3Info = AC3Info;

            /* Initialize Dolby subroutine */
            stat = sa_InitAC3Decoder(Info);
          }
          break;
#endif /* AC3_SUPPORT */


#ifdef GSM_SUPPORT
     case SA_GSM_DECODE:
     case SA_GSM_ENCODE:
          {
            SaGSMInfo_t *GSMInfo;
            if ((GSMInfo = (SaGSMInfo_t *)ScAlloc (sizeof(SaGSMInfo_t)))==NULL)
              return(SaErrorMemory);
            Info->GSMInfo = GSMInfo;
            stat = sa_InitGSM(GSMInfo);
            RETURN_ON_ERROR(stat);
          }
          break;
#endif /* GSM_SUPPORT */

#ifdef G723_SUPPORT
     case SA_G723_DECODE:
          {
            SaG723Info_t *pSaG723Info;
            if ((pSaG723Info = (SaG723Info_t *)
                  ScAlloc (sizeof(SaG723Info_t))) == NULL)
              return(SaErrorMemory);

            Info->pSaG723Info = pSaG723Info;
            saG723DecompressInit(pSaG723Info);
          }
          break;

     case SA_G723_ENCODE:
          {
            SaG723Info_t *pSaG723Info;
            if ((pSaG723Info = (SaG723Info_t *)
                  ScAlloc (sizeof(SaG723Info_t))) == NULL)
              return(SaErrorMemory);

            Info->pSaG723Info = pSaG723Info;
            saG723CompressInit(pSaG723Info);
            SaSetParamInt((SaHandle_t)Info, SA_PARAM_BITRATE, 6400);
          }
          break;
#endif /* G723_SUPPORT */

    default:
          return(SaErrorCodecType);
   }
   *Sah = (SaHandle_t) Info;        /* Return handle */
   Info->wfIn=NULL;
   Info->wfOut=NULL;

   return(NoErrors);
}

/*
** Name:     SaCloseCodec
** Purpose:  Closes the specified codec. Free the Info structure
**
** Args:     Sah = handle to software codec's Info structure.
**
*/
SaStatus_t SaCloseCodec (SaHandle_t Sah)
{
   SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

   if (!Info)
     return(SaErrorCodecHandle);

   ScBufQueueDestroy(Info->Q);

   switch (Info->Type)
   {
#ifdef MPEG_SUPPORT
       case SA_MPEG_DECODE:
            if (Info->MDInfo) 
            {
              sa_EndMpegDecoder(Info);
              ScFree(Info->MDInfo);
            }
            break;
       case SA_MPEG_ENCODE:
            if (Info->MCInfo)
            {
              sa_EndMpegEncoder(Info);
              ScFree(Info->MCInfo);
            }
            break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
     case SA_AC3_DECODE:
     /* case SA_AC3_ENCODE: */
            sa_EndAC3Decoder(Info);
            if (Info->AC3Info)
              ScFree(Info->AC3Info);
            break;
#endif /* AC3_SUPPORT */
#ifdef GSM_SUPPORT
     case SA_GSM_DECODE:
     case SA_GSM_ENCODE:
            if (Info->GSMInfo)
              ScFree(Info->GSMInfo);
            break;
#endif /* GSM_SUPPORT */

#ifdef G723_SUPPORT
       case SA_G723_DECODE:
            if (Info->pSaG723Info) 
            {
              saG723DecompressFree(Info->pSaG723Info);
              ScFree(Info->pSaG723Info);
            }
            break;
       case SA_G723_ENCODE:
            if (Info->pSaG723Info)
            {
              saG723CompressFree(Info->pSaG723Info);
              ScFree(Info->pSaG723Info);
            }
            break;
#endif /* G723_SUPPORT */
   }

   if (Info->wfIn)
     ScFree(Info->wfIn);
   if (Info->wfOut)
     ScFree(Info->wfOut);

   /*
   ** Free Info structure
   */
   if (Info->BSIn)
     ScBSDestroy(Info->BSIn);
   if (Info->BSOut)
     ScBSDestroy(Info->BSOut);

   ScFree(Info);

   return(NoErrors);
}

/*
** Name:     SaRegisterCallback
** Purpose:  Specify the user-function that will be called during processing
**           to determine if the codec should abort the frame.
** Args:     Sah          = handle to software codec's Info structure.
**           Callback     = callback function to register
**
*/
SaStatus_t SaRegisterCallback (SaHandle_t Sah,
           int (*Callback)(SaHandle_t, SaCallbackInfo_t *, SaInfo_t *),
           void *UserData)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (!Info)
    return(SaErrorCodecHandle);

  if (!Callback)
     return(SaErrorBadPointer);

  Info->CallbackFunction = Callback;
  if (Info->BSIn)
  {
    Info->BSIn->Callback=(int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Callback;
    Info->BSIn->UserData=UserData;
  }
  if (Info->BSOut)
  {
    Info->BSOut->Callback=(int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Callback;
    Info->BSOut->UserData=UserData;
  }
  return(NoErrors);
}

/*
** Name: SaGetInputBitstream
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
*/
ScBitstream_t *SaGetInputBitstream (SaHandle_t Sah)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (Info)
    return(Info->BSIn);
  return(NULL);
}

/***************************** Decompression *******************************/
/*
** Name:     SaDecompressQuery
** Purpose:  Check if input and output formats are supported.
*/
SaStatus_t SaDecompressQuery(SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                             WAVEFORMATEX *wfOut)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  /*
   * This stuff should really be pushed down to the individual codecs
   * unless it has to be here - tfm 
   */
  if (!Info)
    return(SaErrorCodecHandle);

  if (wfIn)
  {
    if (wfIn->nChannels!=1 && wfIn->nChannels!=2)
      return(SaErrorUnrecognizedFormat);
  }
  if (wfOut)
  {
    if (wfOut->wFormatTag != WAVE_FORMAT_PCM)
      return(SaErrorUnrecognizedFormat);
    if (wfOut->nChannels!=1 && wfOut->nChannels!=2 && wfOut->nChannels!=4)
      return(SaErrorUnrecognizedFormat);
  }
  if (wfIn && wfOut)
  {
    if (wfIn->nSamplesPerSec != wfOut->nSamplesPerSec)
      return(SaErrorUnrecognizedFormat);

    if (wfIn->wBitsPerSample !=16 && 
        (wfOut->wBitsPerSample !=16 || wfOut->wBitsPerSample !=8))
      return(SaErrorUnrecognizedFormat);
  }
  return(SaErrorNone);
}

/*
** Name:     SaDecompressBegin
** Purpose:  Initialize the Decompression Codec. Call after SaOpenCodec &
**           before SaDecompress (SaDecompress will call SaDecompressBegin
**           on first call to codec after open if user doesn't call it)
**
** Args:     Sah = handle to software codec's Info structure.
**           wfIn  = format of input (compressed) audio
**           wfOut = format of output (uncompressed) audio
*/
SaStatus_t SaDecompressBegin (SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                              WAVEFORMATEX *wfOut)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  SaStatus_t status;

  if (!Info)
    return(SaErrorCodecHandle);

  if (!wfIn || !wfOut)
    return(SaErrorBadPointer);

  status=SaDecompressQuery(Sah, wfIn, wfOut);
  if (status!=SaErrorNone)
    return(status);

  switch (Info->Type)
  {
     case SA_PCM_DECODE:
        break;
#ifdef MPEG_SUPPORT
     case SA_MPEG_DECODE:
        if (Info->MDInfo->DecompressStarted = FALSE)
           Info->MDInfo->DecompressStarted = TRUE;
        break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
     case SA_AC3_DECODE:
        if (Info->AC3Info->DecompressStarted = FALSE)
           Info->AC3Info->DecompressStarted = TRUE;
        break;
#endif /* AC3_SUPPORT */

#ifdef G723_SUPPORT
     /*
     case SA_G723_DECODE:
        if (Info->pSaG723Info->DecompressStarted = FALSE)
           Info->pSaG723Info->DecompressStarted = TRUE;
        break;
      */
#endif /* G723_SUPPORT */
  }
  if ((Info->wfIn = (WAVEFORMATEX *)ScAlloc(sizeof(WAVEFORMATEX)+
            wfIn->cbSize)) == NULL)
       return (SaErrorMemory);
  if ((Info->wfOut = (WAVEFORMATEX *)ScAlloc(sizeof(WAVEFORMATEX)+
           wfOut->cbSize)) == NULL)
       return (SaErrorMemory);
  memcpy(Info->wfOut, wfOut, sizeof(WAVEFORMATEX)+wfOut->cbSize);
  memcpy(Info->wfIn, wfIn, sizeof(WAVEFORMATEX)+wfIn->cbSize);
  return(NoErrors);
}

/*
** Name:     SaDecompress
** Purpose:  Decompress a frame CompData -> PCM
**
** Args:     Sah        = handle to software codec's Info structure.
**           CompData   = Pointer to compressed data (INPUT)
**           CompLen    = Length of CompData buffer
**           DcmpData   = buffer for decompressed data (OUTPUT)
**           DcmpLen    = Size of output buffer
**
*/
SaStatus_t SaDecompress (SaHandle_t Sah, u_char *CompData, unsigned int CompLen,
                           u_char *DcmpData, unsigned int *DcmpLen)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  unsigned int MaxDcmpLen = *DcmpLen;
  int stat=NoErrors;


  if (Sah==NULL)
    return(SaErrorCodecHandle);

  if (!DcmpData || !DcmpLen)
    return(SaErrorBadPointer);

  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_DECODE:
       stat=sa_DecompressMPEG(Info, DcmpData, MaxDcmpLen, DcmpLen);
       Info->Info.NumBytesOut += *DcmpLen;
       break; 
    case SA_PCM_DECODE:
       stat=ScBSGetBytes(Info->BSIn, DcmpData, MaxDcmpLen, DcmpLen);
       Info->Info.NumBytesIn += *DcmpLen;
       Info->Info.NumBytesOut += *DcmpLen;
       break;
#endif /* MPEG_SUPPORT */

#ifdef AC3_SUPPORT
    case SA_AC3_DECODE:
       stat=sa_DecompressAC3(Info, &DcmpData, MaxDcmpLen, DcmpLen);
	    Info->Info.NumBytesOut += *DcmpLen;
       break;
#endif /* AC3_SUPPORT */

#ifdef GSM_SUPPORT
    case SA_GSM_DECODE:
       stat=sa_GSMDecode(Info->GSMInfo, CompData, (word *)DcmpData);
       if (stat==NoErrors)
       {
         *DcmpLen = 160 * 2;
         Info->Info.NumBytesIn += 33;
         Info->Info.NumBytesOut += 160 * 2;
       }
       else
         *DcmpLen = 0;
       break;
#endif /* GSM_SUPPORT */

#ifdef G723_SUPPORT
    case SA_G723_DECODE:
       //Can add a Param for to have CRC or not
       {
         word Crc = 0;

         stat = saG723Decompress( Info,(word *)DcmpData,
                                       (char *)CompData, Crc ) ;
         if(stat == SaErrorNone)
         {
            *DcmpLen = 480; //G723 240 samples(16-bit)= 240*2 = 480 bytes
            Info->Info.NumBytesOut += *DcmpLen;
         }
         else
            *DcmpLen = 0;
       }  
       break; 
    /*
    case SA_PCM_DECODE:
       stat=ScBSGetBytes(Info->BSIn, DcmpData, MaxDcmpLen, DcmpLen);
       Info->Info.NumBytesIn += *DcmpLen;
       Info->Info.NumBytesOut += *DcmpLen;
       break;
    */
#endif /* G723_SUPPORT */
    default:
       *DcmpLen=0;
       return(SaErrorUnrecognizedFormat);
  }
#if 0
  if (*DcmpLen && Info->CallbackFunction)
  {
    SaCallbackInfo_t CB;
    CB.Message       = CB_FRAME_READY;
    CB.Data          = DcmpData;
    CB.DataSize      = CB_DATA_AUDIO;
    CB.DataSize      = MaxDcmpLen;
    CB.DataUsed      = *DcmpLen;
    CB.Action        = CB_ACTION_CONTINUE;
    (*Info->CallbackFunction)(Sah, &CB, &Info->Info);
  }
#endif

  return(stat);
}

/*
** Name:     SaDecompressEx
** Purpose:  Decompress a frame CompData -> PCM
**
** Args:     Sah        = handle to software codec's Info structure.
**           CompData   = Pointer to compressed data (INPUT)
**           CompLen    = Length of CompData buffer
**           DcmpData   = Array of pointers to buffer for decompressed data (OUTPUT)
**           DcmpLen    = Size of decompressed buffers (all must be the same size)
**
*/
SaStatus_t SaDecompressEx (SaHandle_t Sah, u_char *CompData, unsigned int CompLen,
                           u_char **DcmpData, unsigned int *DcmpLen)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  unsigned int MaxDcmpLen = *DcmpLen;
  int stat=NoErrors;


  if (Sah==NULL)
    return(SaErrorCodecHandle);

  if (!DcmpData || !DcmpLen)
    return(SaErrorBadPointer);

  switch (Info->Type)
  {
#ifdef AC3_SUPPORT
    case SA_AC3_DECODE:

       stat=sa_DecompressAC3(Info, DcmpData, MaxDcmpLen, DcmpLen);
	   Info->Info.NumBytesOut += *DcmpLen;
       break;
#endif /* AC3_SUPPORT */
  }

  return(stat);
}


/*
** Name:     SaDecompressEnd
** Purpose:  Terminate the Decompression Codec. Call after all calls to
**           SaDecompress are done.
**
** Args:     Sah = handle to software codec's Info structure.
*/
SaStatus_t SaDecompressEnd (SaHandle_t Sah)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (!Info)
    return(SaErrorCodecHandle);

  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
     case SA_MPEG_DECODE:
        Info->MDInfo->DecompressStarted = FALSE;
        break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
     case SA_AC3_DECODE:
        Info->AC3Info->DecompressStarted = FALSE;
        break;
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
     case SA_G723_DECODE:
        //Info->pSaG723Info->DecompressStarted = FALSE;
        break;
#endif /* G723_SUPPORT */
     default:
        break;
  }
  if (Info->BSIn)
    ScBSReset(Info->BSIn); /* frees up any remaining compressed buffers */
  return(NoErrors);
}

/****************************** Compression ********************************/
/*
** Name:     SaCompressQuery
** Purpose:  Check if input and output formats are supported.
*/
SaStatus_t SaCompressQuery(SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                           WAVEFORMATEX *wfOut)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  if (!Info)
    return(SaErrorCodecHandle);

  if (!wfIn || !wfOut)
    return(SaErrorBadPointer);

  if (wfIn)
  {
    if (wfIn->wFormatTag != WAVE_FORMAT_PCM)
      return(SaErrorUnrecognizedFormat);
    if (wfIn->nChannels!=1 && wfIn->nChannels!=2)
      return(SaErrorUnrecognizedFormat);
  }
  if (wfOut)
  {
    if (wfOut->nChannels!=1 && wfOut->nChannels!=2)
      return(SaErrorUnrecognizedFormat);
  }

  if (wfIn && wfOut)
  {
    if (wfIn->nSamplesPerSec != wfOut->nSamplesPerSec)
      return(SaErrorUnrecognizedFormat);

    if (wfIn->wBitsPerSample!=16 && 
        (wfOut->wBitsPerSample !=16 || wfOut->wBitsPerSample !=8))
      return(SaErrorUnrecognizedFormat);
  }
  return(SaErrorNone);
}

/*
** Name:     SaCompressBegin
** Purpose:  Initialize the Compression Codec. Call after SaOpenCodec &
**           before SaCompress (SaCompress will call SaCompressBegin
**           on first call to codec after open if user doesn't call it)
**
** Args:     Sah = handle to software codec's Info structure.
**           wfIn  = format of input (uncompressed) audio
**           wfOut = format of output (compressed) audio
*/
SaStatus_t SaCompressBegin (SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                            WAVEFORMATEX *wfOut)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  SaStatus_t status;

  if (!Info)
    return(SaErrorCodecHandle);

  if (!wfIn || !wfOut)
    return(SaErrorBadPointer);

  status=SaCompressQuery(Sah, wfIn, wfOut);
  if (status!=SaErrorNone)
    return(status);

  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
     case SA_MPEG_ENCODE:
        SaSetParamInt(Sah, SA_PARAM_SAMPLESPERSEC, wfIn->nSamplesPerSec);
        SaSetParamInt(Sah, SA_PARAM_CHANNELS, wfIn->nChannels);
        sa_MpegVerifyEncoderSettings(Sah);
        if (Info->MCInfo->CompressStarted = FALSE)
           Info->MCInfo->CompressStarted = TRUE;
        break;
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
     case SA_GSM_ENCODE:
        break;
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
#if 0
     case SA_AC3_ENCODE:
        break;
#endif
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
     case SA_G723_ENCODE:
        //SaSetParamInt(Sah, SA_PARAM_SAMPLESPERSEC, wfIn->nSamplesPerSec);
        //SaSetParamInt(Sah, SA_PARAM_CHANNELS, wfIn->nChannels);
        //sa_MpegVerifyEncoderSettings(Sah);
        /*
        if (Info->pSaG723Info->CompressStarted = FALSE)
           Info->pSaG723Info->CompressStarted = TRUE;
        */
        break;
#endif /* G723_SUPPORT */
     case SA_PCM_ENCODE:
        break;
     default:
        return(SaErrorUnrecognizedFormat);
  }
  if ((Info->wfIn = (WAVEFORMATEX *)ScAlloc(sizeof(WAVEFORMATEX)+
            wfIn->cbSize)) == NULL)
       return (SaErrorMemory);
  if ((Info->wfOut = (WAVEFORMATEX *)ScAlloc(sizeof(WAVEFORMATEX)+
           wfOut->cbSize)) == NULL)
       return (SaErrorMemory);
  memcpy(Info->wfOut, wfOut, sizeof(WAVEFORMATEX)+wfOut->cbSize);
  memcpy(Info->wfIn, wfIn, sizeof(WAVEFORMATEX)+wfIn->cbSize);
  return(NoErrors);
}

/*
** Name:     SaCompress
** Purpose:  Compress PCM audio  ->CompData 
**
** Args:     Sah        = handle to software codec's Info structure.
**           DcmpData   = buffer for decompressed data (INPUT)
**           DcmpLen    = Number of Bytes Compressed (return bytes processed)
**           CompData   = Pointer to compressed data (OUTPUT)
**           CompLen    = Length of CompData buffer
**
*/
SaStatus_t SaCompress(SaHandle_t Sah, 
                           u_char *DcmpData, unsigned int *DcmpLen,
                           u_char *CompData, unsigned int *CompLen)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  unsigned int MaxCompLen = *CompLen, NumBytesIn=0;
  int stat=NoErrors;

  if (Sah==NULL)
    return(SaErrorCodecHandle);

  if (!DcmpData || !DcmpLen || !CompLen)
    return(SaErrorBadPointer);

  *CompLen = 0;
  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_ENCODE:
       {
         unsigned int DcmpBytes, CompBytes, Offset;
         Offset=0;
         *CompLen=0;
         do  {
           DcmpBytes=*DcmpLen-Offset;
           if (DcmpBytes<sa_GetMPEGSampleSize(Info)*2)
             break;
           _SlibDebug(_DEBUG_,
               printf("sa_CompressMPEG(Offset=%d) Address=%p Len=%d\n", Offset,
                          DcmpData, DcmpBytes) );
           stat=sa_CompressMPEG(Info, DcmpData+Offset, &DcmpBytes, 
                                                       &CompBytes);
           if (stat==NoErrors)
           {
             if (CompBytes && Info->CallbackFunction)
             {
               SaCallbackInfo_t CB;
               CB.Message       = CB_FRAME_READY;
               CB.Data          = DcmpData+Offset;
               CB.DataType      = CB_DATA_COMPRESSED;
               CB.DataSize      = *DcmpLen-Offset;
               CB.DataUsed      = CompBytes;
               CB.Action        = CB_ACTION_CONTINUE;
               (*Info->CallbackFunction)(Sah, &CB, &Info->Info);
             }
             Offset+=DcmpBytes;
             NumBytesIn += DcmpBytes;
             *CompLen+=CompBytes;
           }
         } while (stat==NoErrors && DcmpBytes>0 && Offset<*DcmpLen);
       }
       break; 
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
    case SA_GSM_ENCODE:
       {
         unsigned int DcmpBytes, CompBytes, Offset;
         Offset=0;
         *CompLen=0;
         if (!Info->BSOut && !CompData)
           return(SaErrorBadPointer);
         do  {
           DcmpBytes=*DcmpLen-Offset;
           stat=sa_GSMEncode(Info->GSMInfo, (word *)(DcmpData+Offset),
                                          &DcmpBytes, CompData, Info->BSOut);
           if (stat==NoErrors)
           {
             Offset+=DcmpBytes;
             NumBytesIn += DcmpBytes;
             *CompLen += 33;
             if (CompData)
               CompData += 33;
           }
         } while (stat==NoErrors && Offset<*DcmpLen);
       }
       break;
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
#if 0 /* no AC-3 Encode yet */
    case SA_AC3_ENCODE:
       {
         unsigned int DcmpBytes, CompBytes, Offset;
         Offset=0;
         *CompLen=0;
         if (!Info->BSOut && !CompData)
           return(SaErrorBadPointer);
         do  {
           DcmpBytes=*DcmpLen-Offset;
           stat=sa_AC3Encode(Info->AC3Info, (word *)(DcmpData+Offset),
                                      &DcmpBytes, CompData, Info->BSOut);
           if (stat==NoErrors)
           {
             Offset+=DcmpBytes;
             NumBytesIn += DcmpBytes;
             *CompLen += 33;
             if (CompData)
               CompData += 33;
           }
         } while (stat==NoErrors && Offset<*DcmpLen);
       }
       break;
#endif
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
    case SA_G723_ENCODE:
       {
         /* Call SaG723Compress (audiobufsize/480) times
          * Need to store unprocessed stuff in Info->AudiobufUsed.
          * (This is done in SlibWriteAudio)
          * G723 encodes 240 samples at a time.=240*2 =480
          */
         unsigned int Offset;
         int iTimes = (int)(*DcmpLen / 480);
         int iLoop =0;
         Offset=0;
         *CompLen=0;
         while (stat==SaErrorNone && iLoop<iTimes)
         {
           stat = saG723Compress(Info,(word *)(DcmpData+Offset),
                                            (char *)CompData);
           Offset+=480; /* Input :240 samples (240*2 = 480 bytes) */
           NumBytesIn += 480;
           *CompLen+=24;/* 24 for 6.3 ;20 for 5.3 rate */
           iLoop++;
         }
       }
       break; 
#endif /* G723_SUPPORT */
    case SA_PCM_ENCODE:
       ScBSPutBytes(Info->BSOut, DcmpData, *DcmpLen);
       *CompLen = *DcmpLen;
       NumBytesIn = *DcmpLen;
       break;
    default:
       *CompLen=0;
       return(SaErrorUnrecognizedFormat);
  }
  *DcmpLen = NumBytesIn;
  Info->Info.NumBytesIn += NumBytesIn;
  Info->Info.NumBytesOut += *CompLen;

  return(stat);
}

/*
** Name:     SaCompressEnd
** Purpose:  Terminate the Compression Codec. Call after all calls to
**           SaCompress are done.
**
** Args:     Sah = handle to software codec's Info structure.
*/
SaStatus_t SaCompressEnd (SaHandle_t Sah)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (!Info)
    return(SaErrorCodecHandle);

  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_ENCODE:
       Info->MCInfo->CompressStarted = FALSE;
       break;
#endif /* MPEG_SUPPORT */
#ifdef G723_SUPPORT
    case SA_G723_ENCODE:
       //Info->pSaG723Info->CompressStarted = FALSE;
       break;
#endif /* G723_SUPPORT */
    default:
       break;
  }
  if (Info->BSOut)
    ScBSFlush(Info->BSOut);  /* flush out any remaining compressed buffers */

/*
  if (Info->CallbackFunction)
  {
    CB.Message = CB_CODEC_DONE;
    CB.Data = NULL;
    CB.DataSize = 0;
    CB.DataUsed = 0;
    CB.DataType = CB_DATA_NONE;
    CB.TimeStamp = 0;
    CB.Flags = 0;
    CB.Value = 0;
    CB.Format = NULL;
    CB.Action  = CB_ACTION_CONTINUE;
    (*Info->CallbackFunction)(Sah, &CB, NULL);
    _SlibDebug(_DEBUG_,
            printf("SaDecompressEnd Callback: CB_CODEC_DONE Action = %d\n",
                    CB.Action) );
    if (CB.Action == CB_ACTION_END)
      return (ScErrorClientEnd);
  }
*/
  return(NoErrors);
}


/***************************** Miscellaneous *******************************/
/*
** Name:     SaSetDataSource
** Purpose:  Set the data source used by the MPEG bitstream parsing code
**           to either the Buffer Queue or File input. The default is
**           to use the Buffer Queue where data buffers are added by calling
**           SaAddBuffer. When using file IO, the data is read from a file
**           descriptor into a buffer supplied by the user.
**
** Args:     Sah    = handle to software codec's Info structure.
**           Source = SU_USE_QUEUE or SU_USE_FILE
**           Fd     = File descriptor to use if Source = SV_USE_FILE
**           Buf    = Pointer to buffer to use if Source = SV_USE_FILE
**           BufSize= Size of buffer when Source = SV_USE_FILE
*/
SaStatus_t SaSetDataSource (SaHandle_t Sah, int Source, int Fd,
                            void *Buffer_UserData, int BufSize)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  int stat=NoErrors;
  int DataType;

  if (!Info)
    return(SaErrorCodecHandle);

  if (Info->Type==SA_MPEG_DECODE || Info->Type==SA_GSM_DECODE ||
	  Info->Type==SA_AC3_DECODE || Info->Type == SA_G723_DECODE )
    DataType=CB_DATA_COMPRESSED;
  else
    DataType=CB_DATA_AUDIO;

  if (Info->BSIn)
  {
    ScBSDestroy(Info->BSIn);
    Info->BSIn=NULL;
  }

  switch (Source)
  {
#ifdef MPEG_SUPPORT
     case SA_USE_SAME:
       if (Info->Type==SA_MPEG_DECODE)
         ScBSSetFilter(Info->BSIn, MPEGAudioFilter);
       break;
#endif /* MPEG_SUPPORT */
     case SA_USE_BUFFER:
       stat=ScBSCreateFromBuffer(&Info->BSIn, Buffer_UserData, BufSize); 
#ifdef MPEG_SUPPORT
       if (stat==NoErrors && Info->Type==SA_MPEG_DECODE)
         ScBSSetFilter(Info->BSIn, MPEGAudioFilter);
#endif /* MPEG_SUPPORT */
       break;

     case SA_USE_BUFFER_QUEUE:
       stat=ScBSCreateFromBufferQueue(&Info->BSIn, Sah, DataType, Info->Q, 
         (int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Info->CallbackFunction,
         (void *)Buffer_UserData);
       break;

     case SA_USE_FILE:
       stat=ScBSCreateFromFile(&Info->BSIn, Fd, Buffer_UserData, BufSize);
#ifdef MPEG_SUPPORT
       if (stat==NoErrors && Info->Type==SA_MPEG_DECODE)
         ScBSSetFilter(Info->BSIn, MPEGAudioFilter);
#endif /* MPEG_SUPPORT */
       break;

     default:
       stat=SaErrorBadArgument;
  }
  if (stat==NoErrors && Info->BSIn)
    ScBSReset(Info->BSIn);
  return(stat);
}

SaStatus_t SaSetDataDestination (SaHandle_t Sah, int Dest, int Fd,
                            void *Buffer_UserData, int BufSize)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  int stat=NoErrors;
  int DataType;

  if (!Info)
    return(SaErrorCodecHandle);

  if (Info->Type==SA_MPEG_ENCODE || Info->Type==SA_GSM_ENCODE 
	  /* || Info->Type==SA_AC3_ENCODE */ ||Info->Type==SA_G723_ENCODE)
    DataType=CB_DATA_COMPRESSED;
  else
    DataType=CB_DATA_AUDIO;

  if (Info->BSOut)
  {
    ScBSDestroy(Info->BSOut);
    Info->BSOut=NULL;
  }

  switch (Dest)
  {
     case SA_USE_SAME:
       break;
     case SA_USE_BUFFER:
       stat=ScBSCreateFromBuffer(&Info->BSOut, Buffer_UserData, BufSize); 
       break;

     case SA_USE_BUFFER_QUEUE:
       stat=ScBSCreateFromBufferQueue(&Info->BSOut, Sah, DataType, Info->Q, 
         (int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Info->CallbackFunction,
         (void *)Buffer_UserData);
       break;

     case SA_USE_FILE:
       stat=ScBSCreateFromFile(&Info->BSOut, Fd, Buffer_UserData, BufSize);
       break;

     default:
       stat=SaErrorBadArgument;
  }
/*
  if (stat==NoErrors && Info->BSOut)
    ScBSReset(Info->BSOut);
*/
  return(stat);
}


/*
** Name: SaGetDataSource
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
*/
ScBitstream_t *SaGetDataSource (SaHandle_t Sah)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (!Info)
    return(NULL);

  return(Info->BSIn);
}

/*
** Name: SaGetDataDestination
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
*/
ScBitstream_t *SaGetDataDestination(SaHandle_t Sah)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (!Info)
    return(NULL);

  return(Info->BSOut);
}

/*
** Name:     SaAddBuffer
** Purpose:  Add a buffer of MPEG bitstream data to the CODEC or add an image
**           buffer to be filled by the CODEC (in streaming mode)
**
** Args:     Sah = handle to software codec's Info structure.
**           BufferInfo = structure describing buffer's address, type & size
*/
SaStatus_t SaAddBuffer (SaHandle_t Sah, SaCallbackInfo_t *BufferInfo)
{
   SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

   if (!Info)
     return(SaErrorCodecHandle);

   if (BufferInfo->DataType != CB_DATA_COMPRESSED)
     return(SaErrorBadArgument);

   if (!BufferInfo->Data || (BufferInfo->DataSize <= 0))
     return(SaErrorBadArgument);

   ScBufQueueAdd(Info->Q, BufferInfo->Data, BufferInfo->DataSize);

   return(NoErrors);
}

#ifdef MPEG_SUPPORT
/*
** Name:  sa_GetMpegAudioInfo()
** Purpose: Extract info about audio packets in an MPEG file.
** Notes:   If an "info" structure is passed to this function,
**          the entire file will be read for extended info.
** Return:  Not 0 = error
*/
SaStatus_t sa_GetMpegAudioInfo(int fd, WAVEFORMATEX *wf, SaInfo_t *info)
{
  int stat, sync;
  ScBitstream_t *bs;
  SaFrameParams_t fr_ps;
  SaLayer_t layer;
  unsigned long aframes=0, samples=0;
  /* Default info parameters */
  if (info)
  {
    info->Name[0]=0;
    info->Description[0]=0;
    info->Version=0;
    info->CodecStarted=FALSE;
    info->MS=0;
    info->NumBytesIn=0;
    info->NumBytesOut=0;
    info->NumFrames=0;
    info->TotalFrames=0;
    info->TotalMS=0;
  }

  /* Default wave parameters */
  wf->wFormatTag = WAVE_FORMAT_PCM;
  wf->nChannels = 2;
  wf->nSamplesPerSec = 44100;
  wf->wBitsPerSample = 16; 
  wf->cbSize = 0; 

  stat=ScBSCreateFromFile(&bs, fd, NULL, 1024);
  if (stat!=NoErrors)
  {
    fprintf(stderr, "Error creating bitstream.\n");
    return(-1);
  }
  if (ScBSPeekBits(bs, PACK_START_CODE_LEN)!=PACK_START_CODE_BIN
      && ScBSPeekBits(bs, MPEG_SYNC_WORD_LEN)!=MPEG_SYNC_WORD)
    stat=SaErrorUnrecognizedFormat;
  else
  {
    if (ScBSPeekBits(bs, MPEG_SYNC_WORD_LEN)==MPEG_SYNC_WORD)
      printf("No MPEG packs found in file; assuming Audio stream only.\n");
    else
      ScBSSetFilter(bs, MPEGAudioFilter); /* Use the MPEG audio filter */

    fr_ps.header = &layer;
    fr_ps.tab_num = -1;   /* no table loaded */
    fr_ps.alloc = NULL;

    sync = ScBSSeekAlign(bs, MPEG_SYNC_WORD, MPEG_SYNC_WORD_LEN);
    if (!sync) {
      sc_vprintf(stderr,"sa_GetMpegAudioInfo: Frame cannot be located\n");
      return(SaErrorSyncLost);
    }
    /* Decode the first header to see what kind of audio we have */
    sa_DecodeInfo(bs, &fr_ps);
    sa_hdr_to_frps(&fr_ps);
#ifdef _VERBOSE_
    sa_ShowHeader(&fr_ps);
#endif

    /* Save no. of channels & sample rate return parameters for caller */
    wf->nChannels = fr_ps.stereo;
    wf->nSamplesPerSec = s_freq_int[fr_ps.header->sampling_frequency];
    wf->wBitsPerSample = 16; 
    stat=SaErrorNone;
    if (info) /* Read through all frames if there's a info structure */
    {
      sc_vprintf("Counting frames...\n");
      aframes=0;
      while (!bs->EOI && sync)
      {
        sync = ScBSSeekAlign(bs, MPEG_SYNC_WORD, MPEG_SYNC_WORD_LEN);
        if (sync)
        {
          sc_dprintf("0x%X: Frame found\n", 
                      ScBSBytePosition(bs)-4);
          aframes++;
        }
        sa_DecodeInfo(bs, &fr_ps);
        if (wf->nChannels<2)  /* take the maximum number of channels */
        {
          sa_hdr_to_frps(&fr_ps);
          wf->nChannels = fr_ps.stereo;
        }
        if (layer.lay==1)
          samples+=384;
        else
          samples+=1152;

      }
      info->TotalFrames=aframes;
      info->TotalMS=(samples*1000)/wf->nSamplesPerSec;
      info->NumBytesOut=samples * wf->nChannels * 2;
      sc_vprintf("Total Audio Frames = %u Bytes = %d MS = %d\n", 
                       info->TotalFrames, info->NumBytesOut, info->TotalMS);
    }
  }
  /* Reset the bitstream back to the beginning */
  ScBSReset(bs);
  /* Close the bit stream */
  ScBSDestroy(bs);
  /* Calculate additional parameters */
  wf->nBlockAlign = (wf->wBitsPerSample>>3) * wf->nChannels; 
  wf->nAvgBytesPerSec = wf->nBlockAlign*wf->nSamplesPerSec;
  return(stat);
}
#endif /* MPEG_SUPPORT */

/*
** Name:  sa_ConvertFormat()
** Purpose: Do simple PCM data conversion (i.e. 16 to 8 bit,
**          Stereo to Mono, etc.)
*/
static int sa_ConvertPCMFormat(SaCodecInfo_t *Info, u_char *data, int length)
{
  int skip, rbytes;
  u_char *fromptr, *toptr;
  /* convert 16 bit to 8 bit if necessary */
  if (Info->wfOut->wBitsPerSample == 8)
  {
    if (Info->wfOut->nChannels==1 && Info->wfOut->nChannels==2)
      skip=4;
    else
      skip=2;
    length/=skip;
    toptr = data;
    fromptr = data+1;
    for (rbytes=length; rbytes; rbytes--, toptr++, fromptr+=skip)
      *toptr = *fromptr;
  }
  return(length);
}

SaStatus_t SaSetParamBoolean(SaHandle_t Sah, SaParameter_t param, 
                                             ScBoolean_t value)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  if (!Info)
    return(SaErrorCodecHandle);
  _SlibDebug(_VERBOSE_, printf("SaSetParamBoolean()\n") );
  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_ENCODE:
           saMpegSetParamBoolean(Sah, param, value);
           break;
#endif

#ifdef G723_SUPPORT
    case SA_G723_ENCODE:
           saG723SetParamBoolean(Sah, param, value);
           break;
#endif
    default:
           return(SaErrorCodecType);
  }
  return(NoErrors);
}

SaStatus_t SaSetParamInt(SaHandle_t Sah, SaParameter_t param, qword value)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  if (!Info)
    return(SaErrorCodecHandle);
  _SlibDebug(_VERBOSE_, printf("SaSetParamInt()\n") );
  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_DECODE:
    case SA_MPEG_ENCODE:
           saMpegSetParamInt(Sah, param, value);
           break;
#endif

#ifdef AC3_SUPPORT
    case SA_AC3_DECODE:
    /* case SA_AC3_ENCODE: */
           saAC3SetParamInt(Sah, param, value);
           break;
#endif

#ifdef G723_SUPPORT
    case SA_G723_DECODE:
    case SA_G723_ENCODE:
           saG723SetParamInt(Sah, param, value);
           break;
#endif

    default:
           return(SaErrorCodecType);
  }
  return(NoErrors);
}

ScBoolean_t SaGetParamBoolean(SaHandle_t Sah, SaParameter_t param)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  if (!Info)
    return(FALSE);
  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_DECODE:
    case SA_MPEG_ENCODE:
           return(saMpegGetParamBoolean(Sah, param));
           break;
#endif

#ifdef G723_SUPPORT
    case SA_G723_DECODE:
    case SA_G723_ENCODE:
           return(saG723GetParamBoolean(Sah, param));
           break;
#endif
  }
  return(FALSE);
}

qword SaGetParamInt(SaHandle_t Sah, SaParameter_t param)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  if (!Info)
    return(0);
  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_DECODE:
    case SA_MPEG_ENCODE:
           return(saMpegGetParamInt(Sah, param));
           break;
#endif

#ifdef G723_SUPPORT
    case SA_G723_DECODE:
    case SA_G723_ENCODE:
           return(saG723GetParamInt(Sah, param));
           break;
#endif
  }
  return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\scon_vid.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: scon_video.h,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1997                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
 * SLIB Conversion API - Video
 */

/*
#define _SLIBDEBUG_
*/

#include "scon_int.h"
#include "SC_err.h"
#include "SC_conv.h"

#ifdef WIN32
#include <mmsystem.h>
#endif

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_     1  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#endif

unsigned dword sconCalcImageSize(SconVideoInfo_t *vinfo)
{
  vinfo->Pixels=vinfo->Width*vinfo->Height;
  switch (vinfo->FourCC)
  {
      case BI_YVU9SEP:       /* YUV 16:1:1 Planar */
          vinfo->ImageSize = (vinfo->Pixels*5)/4;
          break;
      case BI_YU12SEP:       /* YUV 4:1:1 Planar */
          vinfo->ImageSize = (vinfo->Pixels*3)/2;
          break;
      case BI_DECYUVDIB:     /* YUV 4:2:2 Packed */
      case BI_YUY2:          /* YUV 4:2:2 Packed */
      case BI_YU16SEP:       /* YUV 4:2:2 Planar */
          vinfo->ImageSize = vinfo->Pixels*2;
          break;
#ifndef WIN32
      case BI_DECXIMAGEDIB:
          vinfo->ImageSize = vinfo->Pixels*(vinfo->BPP==24 ? 4 : 1);
          break;
#endif /* !WIN32 */
      case BI_RGB:
      case BI_BITFIELDS:
          vinfo->ImageSize = vinfo->Pixels*((vinfo->BPP+7)/8);
          break;
      default:
          vinfo->ImageSize = vinfo->Pixels;
  }
  return(vinfo->ImageSize);
}

static void sconScaleFrame(unsigned word bytesperpixel,
                           void *inbuf, int inw, int inh,
                           void *outbuf, int outw, int outh, int stride)
{
  int inx, outx, iny=0, outy=0;
  int deltax, deltay;
  _SlibDebug(_VERBOSE_,
         ScDebugPrintf(NULL, "sconScaleFrame(byteperpixel=%d) %dx%d -> %dx%d\n",
                      bytesperpixel, inw, inh, outw, outh) );
  if (inh<0)  inh=-inh;   /* no flipping supported */
  if (outh<0) outh=-outh; /* no flipping supported */
  if (bytesperpixel==4)
  {
    unsigned dword *inscan, *outscan;
    deltay=0;
    while (iny<inh)
    {
      inscan=(unsigned dword *)inbuf;
      while (deltay<outh)
      {
        outscan=(unsigned dword *)outbuf;
        inx=0; outx=0;
        deltax=0;
        while (inx<inw)
        {
          while (deltax<outw)
          {
            outscan[outx]=inscan[inx];
            deltax+=inw;
            outx++;
          }
          inx++;
          deltax-=outw;
        }
        outy++;
        deltay+=inh;
        (unsigned char *)outbuf+=stride;
      }
      iny++;
      deltay-=outh;
      ((unsigned dword *)inbuf)+=inw;
    }
  }
  else if (bytesperpixel==3)
  {
    unsigned char *inscan, *outscan;
    deltay=0;
    inw*=3;
    outw*=3;
    while (iny<inh)
    {
      inscan=(unsigned char *)inbuf;
      _SlibDebug(_DEBUG_>1,
          ScDebugPrintf(NULL, "deltay=%d iny=%d outy=%d inh=%d outh=%d\n",
                 deltay, iny, outy, inh, outh) );
      while (deltay<outh)
      {
        outscan=(unsigned char *)outbuf;
        inx=0; outx=0;
        deltax=0;
        while (inx<inw)
        {
          while (deltax<outw)
          {
            outscan[outx]=inscan[inx];
            outscan[outx+1]=inscan[inx+1];
            outscan[outx+2]=inscan[inx+2];
            deltax+=inw;
            outx+=3;
          }
          inx+=3;
          deltax-=outw;
        }
        outy++;
        deltay+=inh;
        (unsigned char *)outbuf+=stride;
      }
      iny++;
      deltay-=outh;
      ((unsigned char *)inbuf)+=inw;
    }
  }
  else if (bytesperpixel==2)
  {
    unsigned word *inscan, *outscan;
    deltay=0;
    while (iny<inh)
    {
      inscan=(unsigned word *)inbuf;
      while (deltay<outh)
      {
        outscan=(unsigned word *)outbuf;
        inx=0; outx=0;
        deltax=0;
        while (inx<inw)
        {
          while (deltax<outw)
          {
            outscan[outx]=inscan[inx];
            deltax+=inw;
            outx++;
          }
          inx++;
          deltax-=outw;
        }
        outy++;
        deltay+=inh;
        (unsigned char *)outbuf+=stride;
      }
      iny++;
      deltay-=outh;
      ((unsigned word *)inbuf)+=inw;
    }
  }
  else /* bytesperpixel==1 */
  {
    unsigned char *inscan, *outscan;
    deltay=0;
    while (iny<inh)
    {
      inscan=(unsigned char *)inbuf;
      _SlibDebug(_DEBUG_>1,
          ScDebugPrintf(NULL, "deltay=%d iny=%d outy=%d inh=%d outh=%d\n",
                 deltay, iny, outy, inh, outh) );
      while (deltay<outh)
      {
        outscan=(unsigned char *)outbuf;
        inx=0; outx=0;
        deltax=0;
        while (inx<inw)
        {
          while (deltax<outw)
          {
            outscan[outx]=inscan[inx];
            deltax+=inw;
            outx++;
          }
          inx++;
          deltax-=outw;
        }
        outy++;
        deltay+=inh;
        (unsigned char *)outbuf+=stride;
      }
      iny++;
      deltay-=outh;
      ((unsigned char *)inbuf)+=inw;
    }
  }
}


SconStatus_t sconConvertVideo(SconInfo_t *Info, void *inbuf, dword inbufsize,
                                                void *outbuf, dword outbufsize)
{
  unsigned dword informat, outformat;
  unsigned char *prescalebuf=inbuf;
  dword inwidth, inheight, outwidth, outheight, inbpp, outbpp, stride;
  SconStatus_t retval=SconErrorNone;
  SconBoolean_t scale, flip, sameformat;
  _SlibDebug(_VERBOSE_, printf("sconConvertVideo()\n") );
  if (inbuf==NULL || outbuf==NULL)
    return(SconErrorBadArgument);
  inwidth=Info->Input.vinfo.Width;
  inheight=Info->Input.vinfo.Height;
  informat=Info->Input.vinfo.FourCC;
  inbpp=Info->Input.vinfo.BPP;
  outwidth=Info->Output.vinfo.Width,
  outheight=Info->Output.vinfo.Height;
  outformat=Info->Output.vinfo.FourCC;
  outbpp=Info->Output.vinfo.BPP;
  scale=(Info->ScaleUp || Info->ScaleDown)?TRUE:FALSE;
  flip=Info->Flip;
  sameformat=Info->SameFormat;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "SconConvert() %dx%d(%c%c%c%c)->%dx%d(%c%c%c%c)\n",
            inwidth, inheight, informat&0xFF, (informat>>8)&0xFF, (informat>>16)&0xFF, (informat>>24)&0xFF,
            outwidth, outheight, outformat&0xFF, (outformat>>8)&0xFF, (outformat>>16)&0xFF, (outformat>>24)&0xFF) );
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "SconConvert() scale=%d flip=%d sameformat=%d\n",
                            scale, flip, sameformat) );
  if (scale || flip)
  {
    if (Info->SImage==NULL && !sameformat)
    {
      SconVideoInfo_t int_vinfo;
      memcpy(&int_vinfo, &Info->Output.vinfo, sizeof(SconVideoInfo_t));
      int_vinfo.Width=inwidth;
      int_vinfo.Height=inheight;
      Info->SImageSize=sconCalcImageSize(&int_vinfo);
      if ((Info->SImage=ScPaMalloc(Info->SImageSize))==NULL)
        return(SconErrorMemory);
    }
  }
  else if (sameformat)
  {
    memcpy(outbuf, inbuf, Info->Input.vinfo.ImageSize);
    return(SconErrorNone);
  }
  if (sameformat)
    prescalebuf=(unsigned char *)inbuf;
  else
  {
    prescalebuf=(unsigned char *)(scale?Info->SImage:outbuf);
    stride=scale?(inwidth*((outbpp+7)>>3)):Info->Output.vinfo.Stride;
    if (flip) stride=-stride;
    if (IsYUV411Sep(informat)) /* YUV 4:1:1 Planar */
    {
      switch (outformat)
      {
        case BI_DECYUVDIB: /* YUV 4:2:2 Packed */
        case BI_YUY2:      /* YUV 4:2:2 Packed */
          _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() BI_YU12SEP->BI_YUY2\n") );
          ScSepYUVto422i((unsigned char *)inbuf,
                     (unsigned char *)inbuf+(inwidth*inheight),
                     (unsigned char *)inbuf+(inwidth*inheight*5)/4,
                     (unsigned char *)prescalebuf, inwidth, inheight);
          break;
        case BI_YU16SEP: /* YUV 4:2:2 Planar */
        case BI_DECSEPYUVDIB:
          _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() BI_YU12SEP->BI_YU16SEP\n") );
          {
            register int i;
            unsigned char *Ue=(unsigned char *)prescalebuf+inwidth*inheight,
                          *Uo=Ue+inwidth/2;
            memcpy(prescalebuf, inbuf, inwidth*inheight);
            ((unsigned char *)inbuf)+=inwidth*inheight;
            for (i=inheight; i; i--)
            {
              memcpy(Ue, inbuf, inwidth/2);
              memcpy(Uo, inbuf, inwidth/2);
              ((unsigned char *)inbuf)+=inwidth/2;
              Ue+=inwidth;
              Uo+=inwidth;
            }
          }
          break;
        case BI_YVU9SEP: /* YUV 16:1:1 Planar */
          _SlibDebug(_VERBOSE_,
              ScDebugPrintf(NULL, "SconConvert() BI_YU12SEP->BI_YVU9\n") );
          ScConvert411sTo1611s((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf,
                           ((unsigned char *)prescalebuf)+(outwidth*outheight),
                           ((unsigned char *)prescalebuf)+(outwidth*outheight*9)/8,
                           inwidth, flip?-inheight:inheight);
          break;
        case BI_RGB:
        case BI_BITFIELDS:
        case BI_DECXIMAGEDIB:
          if (outbpp==16)
          {
            if (Info->Table==NULL)
              sconInitYUVtoRGB(Info);
            if (Info->Output.vinfo.RGBmasks==565)
              scon420ToRGB565((unsigned char *)inbuf,
                              (unsigned char *)prescalebuf,
                              inwidth, inheight, stride, Info->Table);
          }
          else if (outbpp=24)
          {
            if (Info->Table==NULL)
              sconInitYUVtoRGB(Info);
            scon420ToRGB888((unsigned char *)inbuf,
                            (unsigned char *)prescalebuf,
                            inwidth, inheight, stride, Info->Table);
          }
          else
          {
            BITMAPINFOHEADER outbmh;
            outbmh.biWidth=inwidth;
            outbmh.biHeight=inheight;
            outbmh.biCompression=outformat;
            outbmh.biBitCount=(WORD)outbpp;
            stride=scale?inwidth:outwidth;
            _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() BI_YU12SEP->RGB\n") );
            ScYuv411ToRgb(&outbmh, (unsigned char *)inbuf,
                     (unsigned char *)inbuf+(inwidth*inheight),
                     (unsigned char *)inbuf+(inwidth*inheight*5)/4,
                     (unsigned char *)prescalebuf,
                     inwidth, inheight, stride);
          }
          break;
        default:
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_YU12SEP->Unsupported\n") );
      }
    }
    else if (IsYUV422Sep(informat)) /* YUV 4:2:2 Planar */
    {
      switch (outformat)
      {
        case BI_YU12SEP: /* YUV 4:1:1 Planar */
          _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() 422 Planar->BI_YU12SEP\n") );
          ScConvert422PlanarTo411_C((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf,
                           ((unsigned char *)prescalebuf)+(outwidth*outheight),
                           ((unsigned char *)prescalebuf)+(outwidth*outheight*5)/4,
                           inwidth, inheight);
          break;
        case BI_DECYUVDIB: /* YUV 4:2:2 Packed */
        case BI_YUY2:
          ScConvert422PlanarTo422i_C((unsigned char *)inbuf,
                           ((unsigned char *)inbuf)+(inwidth*inheight),
                           ((unsigned char *)inbuf)+(inwidth*inheight*3)/2,
                           (unsigned char *)prescalebuf,
                           inwidth, inheight);
          break;
        case BI_RGB:
        case BI_BITFIELDS:
        case BI_DECXIMAGEDIB:
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_YU16SEP->BI_RGB Unsupported\n") );
          if (outbpp==16)
          {
            if (Info->Table==NULL)
              sconInitYUVtoRGB(Info);
            if (Info->Output.vinfo.RGBmasks==565)
              scon422ToRGB565((unsigned char *)inbuf,
                            (unsigned char *)prescalebuf,
                            inwidth, inheight, stride, Info->Table);
          }
          else if (outbpp==24)
          {
            if (Info->Table==NULL)
              sconInitYUVtoRGB(Info);
            scon422ToRGB888((unsigned char *)inbuf,
                            (unsigned char *)prescalebuf,
                            inwidth, inheight, stride, Info->Table);
          }
          else
            retval=SconErrorUnsupportedFormat;
          break;
        default:
          retval=SconErrorUnsupportedFormat;
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_YU16SEP->Unsupported\n") );
      }
    }
    else if (IsYUV422Packed(informat)) /* YUV 4:2:2 Packed */
    {
      switch (outformat)
      {
        case BI_YU12SEP: /* YUV 4:1:1 Planar */
          _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() 422 Packed->BI_YU12SEP\n") );
          ScConvert422ToYUV_char((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf,
                           ((unsigned char *)prescalebuf)+(outwidth*outheight),
                           ((unsigned char *)prescalebuf)+(outwidth*outheight*5)/4,
                           inwidth, flip?-inheight:inheight);
          break;
        case BI_YU16SEP: /* 4:2:2 Packed -> 4:2:2 Planar */
        case BI_DECSEPYUVDIB:
          _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() BI_YUY2->BI_YU16SEP\n") );
          {
            register int i;
            unsigned char *Y=prescalebuf,
                          *U=(unsigned char *)prescalebuf+(inwidth*inheight),
                          *V=U+(inwidth*inheight)/2;
            for (i=(inwidth*inheight)/2; i; i--)
            {
              *Y++ = *((unsigned char *)inbuf)++;
              *U++ = *((unsigned char *)inbuf)++;
              *Y++ = *((unsigned char *)inbuf)++;
              *V++ = *((unsigned char *)inbuf)++;
            }
          }
          break;
        case BI_RGB: /* 4:2:2 Packed -> RGB */
          if (outbpp!=16)
            return(SconErrorUnsupportedFormat);
          else
          {
            u_short *Sout;
            int i, Y1, Y2, U, V, Luma;
            int R1,R2, G1,G2, B1,B2;
            _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() BI_YUY2->BI_RGB\n") );
            Sout = (u_short *)prescalebuf;
            for (i=(inwidth*inheight)/4; i; i--)
            {
              Y1=(int)*((unsigned char *)inbuf)++;
              U=(int)(*((unsigned char *)inbuf)++) - 128;
              Y2=(int)*((unsigned char *)inbuf)++;
              V=(int)(*((unsigned char *)inbuf)++) - 128;
               if (U || V) {
                 R1 = R2 = (int) (              + (1.596 * V));
                 G1 = G2 = (int) (- (0.391 * U) - (0.813 * V));
                 B1 = B2 = (int) (+ (2.018 * U)              );
               } else { R1=R2=G1=G2=B1=B2=0; }
                   Luma = (int) ((float)(Y1 - 16) * (float)1.164);
               R1 += Luma; G1 += Luma; B1 += Luma;
                   Luma = (int) ((float)(Y2 - 16) * (float)1.164);
               R2 += Luma; G2 += Luma; B2 += Luma;
               if ((R1 | G1 | B1 | R2 | G2 | B2) & 0xffffff00) {
                 if (R1<0) R1=0; else if (R1>255) R1=255;
                 if (G1<0) G1=0; else if (G1>255) G1=255;
                 if (B1<0) B1=0; else if (B1>255) B1=255;
                 if (R2<0) R2=0; else if (R2>255) R2=255;
                 if (G2<0) G2=0; else if (G2>255) G2=255;
                 if (B2<0) B2=0; else if (B2>255) B2=255;
               }
#if 1 /* RGB 565 - 16 bit */
               *(Sout++) = ((R1&0xf8)<<8)|((G1&0xfC)<<3)|((B1&0xf8)>>3);
               *(Sout++) = ((R2&0xf8)<<8)|((G2&0xfC)<<3)|((B2&0xf8)>>3);
#else /* RGB 555 - 15 bit */
               *(Sout++) = ((R1&0xf8)<<7)|((G1&0xf8)<<2)|((B1&0xf8)>>3);
               *(Sout++) = ((R2&0xf8)<<7)|((G2&0xf8)<<2)|((B2&0xf8)>>3);
#endif
            }
          }
          break;
        default:
          retval=SconErrorUnsupportedFormat;
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_YUY2->Unsupported\n") );
      }
    }
    else if (IsRGBPacked(informat)) /* RGB Packed */
    {
      switch (outformat)
      {
        case BI_YU12SEP: /* YUV 4:1:1 Planar */
          if (inbpp==16)
            ScConvertRGB555To411s((unsigned char *)inbuf,
                                (unsigned char *)prescalebuf,
                                inwidth, flip?-inheight:inheight);
          else
          {
            if (Info->Table==NULL)
              sconInitRGBtoYUV(Info);
            sconRGB888To420((unsigned char *)inbuf,
                            (unsigned char *)prescalebuf,
                            inwidth, inheight, (flip?-inwidth:inwidth)*3, Info->Table);
            // ScConvertRGB24To411s((unsigned char *)inbuf,
            //                    (unsigned char *)prescalebuf,
            //                    ((unsigned char *)prescalebuf)+(inwidth*inheight),
            //                    ((unsigned char *)prescalebuf)+(inwidth*inheight*5)/4,
            //                    inwidth, flip?-inheight:inheight);
          }
          break;
        case BI_RGB: /* RGB */
          retval=SconErrorUnsupportedFormat;
          break;
        default:
          retval=SconErrorUnsupportedFormat;
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_RGB->Unsupported\n") );
      }
    }
    else if (IsYUV1611Sep(informat)) /* YUV 16:1:1 Planar */
    {
      switch (outformat)
      {
        case BI_YU12SEP: /* YUV 4:1:1 Planar */
          _SlibDebug(_VERBOSE_,
              ScDebugPrintf(NULL, "SconConvert() BI_YVU9->BI_YU12SEP\n") );
          ScConvert1611sTo411s((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf,
                           ((unsigned char *)prescalebuf)+(outwidth*outheight),
                           ((unsigned char *)prescalebuf)+(outwidth*outheight*5)/4,
                           inwidth, flip?-inheight:inheight);
          break;
        case BI_YU16SEP: /* YUV 4:2:2 Planar */
          _SlibDebug(_VERBOSE_,
              ScDebugPrintf(NULL, "SconConvert() BI_YVU9->BI_YU16SEP\n") );
          ScConvert1611sTo422s((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf,
                           ((unsigned char *)prescalebuf)+(outwidth*outheight),
                           ((unsigned char *)prescalebuf)+(outwidth*outheight*3)/2,
                           inwidth, flip?-inheight:inheight);
          break;
        case BI_DECYUVDIB: /* YUV 4:2:2 Packed */
        case BI_YUY2:
          _SlibDebug(_VERBOSE_,
              ScDebugPrintf(NULL, "SconConvert() BI_YVU9->BI_YUY2\n") );
          ScConvert1611sTo422i((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf, inwidth, flip?-inheight:inheight);
          break;
        default:
          retval=SconErrorUnsupportedFormat;
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_YVU9->Unsupported\n") );
      }
    }
    _SlibDebug(_VERBOSE_ && retval==SconErrorUnsupportedFormat,
              ScDebugPrintf(NULL, "SconConvert() Unsupported->Unsupported\n"));
  }
  if (retval==SconErrorNone && scale)
  {
    if (IsRGBPacked(outformat))
    {
      /* Scaling RGB */
      _SlibDebug(_VERBOSE_,
           ScDebugPrintf(NULL, "SconConvert() Scaling BI_RGB\n") );
      stride=Info->Output.vinfo.Stride;
      sconScaleFrame((unsigned word)((outbpp+7)>>3),
                   prescalebuf, inwidth, inheight,
                   outbuf, outwidth, outheight, stride);
    }
    else if (IsYUV411Sep(outformat)) /* YUV 4:1:1 Planar */
    {
      _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "SconConvert() Scaling BI_YU12SEP\n") );
      sconScaleFrame(1,
                         prescalebuf, inwidth, inheight,
                         outbuf, outwidth, outheight, outwidth);
      sconScaleFrame(1,
                         ((unsigned char *)prescalebuf)+(inwidth*inheight),
                               inwidth/2, inheight,
                         ((unsigned char *)outbuf)+(outwidth*outheight),
                               outwidth/2, outheight, outwidth/2);
    }
    else if (IsYUV422Packed(outformat)) /* YUV 4:2:2 Packed */
    {
      stride=Info->Output.vinfo.Stride;
      sconScaleFrame(4,
                     prescalebuf, inwidth/2, inheight,
                     outbuf, outwidth/2, outheight, stride);
    }
    else if (IsYUV422Sep(outformat)) /* YUV 4:2:2 Planar */
    {
      sconScaleFrame(1,
                         prescalebuf, inwidth, inheight,
                         outbuf, outwidth, outheight, outwidth);
      sconScaleFrame(1,
                         ((unsigned char *)prescalebuf)+(inwidth*inheight),
                               inwidth, inheight,
                         ((unsigned char *)outbuf)+(outwidth*outheight),
                               outwidth, outheight, outwidth);
    }
    else if (IsYUV1611Sep(outformat)) /* YUV 16:1:1 Planar */
    {
      sconScaleFrame(1,
                         prescalebuf, inwidth, inheight,
                         outbuf, outwidth, outheight, outwidth);
      sconScaleFrame(1,
                         ((unsigned char *)prescalebuf)+(inwidth*inheight),
                               inwidth/8, inheight,
                         ((unsigned char *)outbuf)+(outwidth*outheight),
                               outwidth/8, outheight, outwidth/8);
    }
    else
    {
      retval=SconErrorUnsupportedFormat;
      _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() Scaling Unsupported\n") );
    }
  }
  return(retval);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sc_buf.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_buf.c,v $
 * Revision 1.1.8.4  1996/12/12  20:54:41  Hans_Graves
 * 	Fixed reading of last odd bits.
 * 	[1996/12/12  20:54:05  Hans_Graves]
 *
 * Revision 1.1.8.3  1996/11/13  16:10:46  Hans_Graves
 * 	Tom's changes to ScBSGetBitsW() and ScBSSeekAlignStopBeforeW().
 * 	[1996/11/13  15:57:34  Hans_Graves]
 *
 * Revision 1.1.8.2  1996/11/08  21:50:32  Hans_Graves
 * 	Added ScBSGetBitsW(), ScBSSkipBitsW() and sc_BSLoadDataWordW() for AC3.
 * 	[1996/11/08  21:25:52  Hans_Graves]
 *
 * Revision 1.1.6.4  1996/04/17  16:38:33  Hans_Graves
 * 	Correct some type casting to support 64-bit buffers under NT
 * 	[1996/04/17  16:36:08  Hans_Graves]
 *
 * Revision 1.1.6.3  1996/04/15  21:08:37  Hans_Graves
 * 	Declare mask and imask as ScBitString_t
 * 	[1996/04/15  21:06:32  Hans_Graves]
 *
 * Revision 1.1.6.2  1996/04/01  16:23:05  Hans_Graves
 * 	Replace File I/O with ScFile calls
 * 	[1996/04/01  16:22:27  Hans_Graves]
 *
 * Revision 1.1.4.7  1996/02/19  14:29:25  Bjorn_Engberg
 * 	Enable FILTER_SUPPORT for NT, so Mview can play audio.
 * 	This is only until we port the MPEG Systems code to NT.
 * 	[1996/02/19  14:29:07  Bjorn_Engberg]
 *
 * Revision 1.1.4.6  1996/02/01  17:15:48  Hans_Graves
 * 	Added FILTER_SUPPORT ifdef; disabled it
 * 	[1996/02/01  17:13:29  Hans_Graves]
 *
 * Revision 1.1.4.5  1996/01/08  16:41:12  Hans_Graves
 * 	Remove NT compiler warnings, and minor fixes for NT.
 * 	[1996/01/08  14:14:10  Hans_Graves]
 *
 * Revision 1.1.4.3  1995/11/06  18:47:37  Hans_Graves
 * 	Added support for small buffer: 1-7 bytes
 * 	[1995/11/06  18:46:49  Hans_Graves]
 *
 * Revision 1.1.4.2  1995/09/13  14:51:34  Hans_Graves
 * 	Added ScBufQueueGetHeadExt() and ScBufQueueAddExt().
 * 	[1995/09/13  14:47:11  Hans_Graves]
 *
 * Revision 1.1.2.18  1995/08/30  19:37:49  Hans_Graves
 * 	Fixed compiler warning about #else and #elif.
 * 	[1995/08/30  19:36:15  Hans_Graves]
 *
 * Revision 1.1.2.17  1995/08/29  22:17:04  Hans_Graves
 * 	Disabled debugging statements.
 * 	[1995/08/29  22:11:38  Hans_Graves]
 *
 * 	PTT 00938 - MPEG Seg Faulting fixes, Repositioning problem.
 * 	[1995/08/29  22:04:06  Hans_Graves]
 *
 * Revision 1.1.2.16  1995/08/14  19:40:24  Hans_Graves
 * 	Added Flush routines. Some optimization.
 * 	[1995/08/14  18:40:33  Hans_Graves]
 *
 * Revision 1.1.2.15  1995/08/02  15:26:58  Hans_Graves
 * 	Fixed writing bitstreams directly to files.
 * 	[1995/08/02  14:11:00  Hans_Graves]
 *
 * Revision 1.1.2.14  1995/07/28  20:58:37  Hans_Graves
 * 	Initialized all variables in callback messages.
 * 	[1995/07/28  20:52:04  Hans_Graves]
 *
 * Revision 1.1.2.13  1995/07/28  17:36:04  Hans_Graves
 * 	Fixed END_BUFFER callback from GetNextBuffer()
 * 	[1995/07/28  17:31:30  Hans_Graves]
 *
 * Revision 1.1.2.12  1995/07/27  18:28:52  Hans_Graves
 * 	Fixed buffer queues in PutData and StoreDataWord.
 * 	[1995/07/27  18:23:30  Hans_Graves]
 *
 * Revision 1.1.2.11  1995/07/27  12:20:35  Hans_Graves
 * 	Renamed SvErrorClientAbort to SvErrorClientEnd
 * 	[1995/07/27  12:19:12  Hans_Graves]
 *
 * Revision 1.1.2.10  1995/07/21  17:40:59  Hans_Graves
 * 	Renamed Callback related stuff. Added DataType.
 * 	[1995/07/21  17:26:48  Hans_Graves]
 *
 * Revision 1.1.2.9  1995/07/17  22:01:27  Hans_Graves
 * 	Added Callback call in PutData().
 * 	[1995/07/17  21:50:49  Hans_Graves]
 *
 * Revision 1.1.2.8  1995/07/12  19:48:21  Hans_Graves
 * 	Added Queue debugging statements.
 * 	[1995/07/12  19:30:37  Hans_Graves]
 *
 * Revision 1.1.2.7  1995/07/07  20:11:23  Hans_Graves
 * 	Fixed ScBSGetBit() so it returns the bit.
 * 	[1995/07/07  20:07:27  Hans_Graves]
 *
 * Revision 1.1.2.6  1995/06/27  13:54:17  Hans_Graves
 * 	Added ScBSCreateFromNet() and STREAM_USE_NET cases.
 * 	[1995/06/27  13:27:38  Hans_Graves]
 *
 * Revision 1.1.2.5  1995/06/21  18:37:56  Hans_Graves
 * 	Added ScBSPutBytes()
 * 	[1995/06/21  18:37:08  Hans_Graves]
 *
 * Revision 1.1.2.4  1995/06/15  21:17:55  Hans_Graves
 * 	Changed return type for GetBits() and PeekBits() to ScBitString_t. Added some debug statements.
 * 	[1995/06/15  20:40:54  Hans_Graves]
 *
 * Revision 1.1.2.3  1995/06/09  18:33:28  Hans_Graves
 * 	Fixed up some problems with Bitstream reads from Buffer Queues
 * 	[1995/06/09  16:27:50  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/05/31  18:07:25  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:05:37  Hans_Graves]
 *
 * Revision 1.1.2.3  1995/04/17  18:41:05  Hans_Graves
 * 	Added ScBSPutBits, BSStoreWord, and BSPutData functions
 * 	[1995/04/17  18:40:44  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/04/07  18:22:55  Hans_Graves
 * 	Bitstream and Buffer Queue functions pulled from Sv sources.
 * 	     Added functionality and cleaned up API.
 * 	[1995/04/07  18:21:58  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
** Bitstream and queue routines
**
** Note: For reading, "BS->shift" refers to the number of bits stored across
**       BS->OutBuff and BS->InBuff
*/
/*
#define _SLIBDEBUG_
*/

#include "SC.h"
#include "SC_err.h"
#include <string.h>
#ifdef WIN32
#include <io.h>
#include <windows.h>
#include <assert.h>
#endif

#ifdef _SLIBDEBUG_
#include <stdio.h>
#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 0  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#define _QUEUE_   0  /* show queue progress */
#define _DUMP_    0  /* dump out buffer data in hex */

int _debug_getbits=TRUE;
long _debug_start=0, _debug_stop=0;
#endif

#define USE_FAST_SEEK   0  /* fast seeking for words in the bistream */

#define FILTER_SUPPORT  0  /* data filtering callback support */

#ifdef __VMS
#define USE_MASK_TABLES
#else
#define USE_MASK_TABLES
#endif

#ifdef USE_MASK_TABLES
/* to mask the n least significant bits of an integer */
#if SC_BITBUFFSZ == 64
const static ScBitString_t mask[65] =
{
(ScBitString_t)0x0000000000000000,(ScBitString_t)0x0000000000000001,
(ScBitString_t)0x0000000000000003,(ScBitString_t)0x0000000000000007,
(ScBitString_t)0x000000000000000f,(ScBitString_t)0x000000000000001f,
(ScBitString_t)0x000000000000003f,(ScBitString_t)0x000000000000007f,
(ScBitString_t)0x00000000000000ff,(ScBitString_t)0x00000000000001ff,
(ScBitString_t)0x00000000000003ff,(ScBitString_t)0x00000000000007ff,
(ScBitString_t)0x0000000000000fff,(ScBitString_t)0x0000000000001fff,
(ScBitString_t)0x0000000000003fff,(ScBitString_t)0x0000000000007fff,
(ScBitString_t)0x000000000000ffff,(ScBitString_t)0x000000000001ffff,
(ScBitString_t)0x000000000003ffff,(ScBitString_t)0x000000000007ffff,
(ScBitString_t)0x00000000000fffff,(ScBitString_t)0x00000000001fffff,
(ScBitString_t)0x00000000003fffff,(ScBitString_t)0x00000000007fffff,
(ScBitString_t)0x0000000000ffffff,(ScBitString_t)0x0000000001ffffff,
(ScBitString_t)0x0000000003ffffff,(ScBitString_t)0x0000000007ffffff,
(ScBitString_t)0x000000000fffffff,(ScBitString_t)0x000000001fffffff,
(ScBitString_t)0x000000003fffffff,(ScBitString_t)0x000000007fffffff,
(ScBitString_t)0x00000000ffffffff,(ScBitString_t)0x00000001ffffffff,
(ScBitString_t)0x00000003ffffffff,(ScBitString_t)0x00000007ffffffff,
(ScBitString_t)0x0000000fffffffff,(ScBitString_t)0x0000001fffffffff,
(ScBitString_t)0x0000003fffffffff,(ScBitString_t)0x0000007fffffffff,
(ScBitString_t)0x000000ffffffffff,(ScBitString_t)0x000001ffffffffff,
(ScBitString_t)0x000003ffffffffff,(ScBitString_t)0x000007ffffffffff,
(ScBitString_t)0x00000fffffffffff,(ScBitString_t)0x00001fffffffffff,
(ScBitString_t)0x00003fffffffffff,(ScBitString_t)0x00007fffffffffff,
(ScBitString_t)0x0000ffffffffffff,(ScBitString_t)0x0001ffffffffffff,
(ScBitString_t)0x0003ffffffffffff,(ScBitString_t)0x0007ffffffffffff,
(ScBitString_t)0x000fffffffffffff,(ScBitString_t)0x001fffffffffffff,
(ScBitString_t)0x003fffffffffffff,(ScBitString_t)0x007fffffffffffff,
(ScBitString_t)0x00ffffffffffffff,(ScBitString_t)0x01ffffffffffffff,
(ScBitString_t)0x03ffffffffffffff,(ScBitString_t)0x07ffffffffffffff,
(ScBitString_t)0x0fffffffffffffff,(ScBitString_t)0x1fffffffffffffff,
(ScBitString_t)0x3fffffffffffffff,(ScBitString_t)0x7fffffffffffffff,
(ScBitString_t)0xffffffffffffffff
};
/* inverse mask */
const static ScBitString_t imask[65] =
{
(ScBitString_t)0xffffffffffffffff,(ScBitString_t)0xfffffffffffffffe,
(ScBitString_t)0xfffffffffffffffc,(ScBitString_t)0xfffffffffffffff8,
(ScBitString_t)0xfffffffffffffff0,(ScBitString_t)0xffffffffffffffe0,
(ScBitString_t)0xffffffffffffffc0,(ScBitString_t)0xffffffffffffff80,
(ScBitString_t)0xffffffffffffff00,(ScBitString_t)0xfffffffffffffe00,
(ScBitString_t)0xfffffffffffffc00,(ScBitString_t)0xfffffffffffff800,
(ScBitString_t)0xfffffffffffff000,(ScBitString_t)0xffffffffffffe000,
(ScBitString_t)0xffffffffffffc000,(ScBitString_t)0xffffffffffff8000,
(ScBitString_t)0xffffffffffff0000,(ScBitString_t)0xfffffffffffe0000,
(ScBitString_t)0xfffffffffffc0000,(ScBitString_t)0xfffffffffff80000,
(ScBitString_t)0xfffffffffff00000,(ScBitString_t)0xffffffffffe00000,
(ScBitString_t)0xffffffffffc00000,(ScBitString_t)0xffffffffff800000,
(ScBitString_t)0xffffffffff000000,(ScBitString_t)0xfffffffffe000000,
(ScBitString_t)0xfffffffffc000000,(ScBitString_t)0xfffffffff8000000,
(ScBitString_t)0xfffffffff0000000,(ScBitString_t)0xffffffffe0000000,
(ScBitString_t)0xffffffffc0000000,(ScBitString_t)0xffffffff80000000,
(ScBitString_t)0xffffffff00000000,(ScBitString_t)0xfffffffe00000000,
(ScBitString_t)0xfffffffc00000000,(ScBitString_t)0xfffffff800000000,
(ScBitString_t)0xfffffff000000000,(ScBitString_t)0xffffffe000000000,
(ScBitString_t)0xffffffc000000000,(ScBitString_t)0xffffff8000000000,
(ScBitString_t)0xffffff0000000000,(ScBitString_t)0xfffffe0000000000,
(ScBitString_t)0xfffffc0000000000,(ScBitString_t)0xfffff80000000000,
(ScBitString_t)0xfffff00000000000,(ScBitString_t)0xffffe00000000000,
(ScBitString_t)0xffffc00000000000,(ScBitString_t)0xffff800000000000,
(ScBitString_t)0xffff000000000000,(ScBitString_t)0xfffe000000000000,
(ScBitString_t)0xfffc000000000000,(ScBitString_t)0xfff8000000000000,
(ScBitString_t)0xfff0000000000000,(ScBitString_t)0xffe0000000000000,
(ScBitString_t)0xffc0000000000000,(ScBitString_t)0xff80000000000000,
(ScBitString_t)0xff00000000000000,(ScBitString_t)0xfe00000000000000,
(ScBitString_t)0xfc00000000000000,(ScBitString_t)0xf800000000000000,
(ScBitString_t)0xf000000000000000,(ScBitString_t)0xe000000000000000,
(ScBitString_t)0xc000000000000000,(ScBitString_t)0x8000000000000000,
(ScBitString_t)0x0000000000000000
};
#else
const static ScBitString_t mask[33] =
{
  0x00000000,0x00000001,0x00000003,0x00000007,
  0x0000000f,0x0000001f,0x0000003f,0x0000007f,
  0x000000ff,0x000001ff,0x000003ff,0x000007ff,
  0x00000fff,0x00001fff,0x00003fff,0x00007fff,
  0x0000ffff,0x0001ffff,0x0003ffff,0x0007ffff,
  0x000fffff,0x001fffff,0x003fffff,0x007fffff,
  0x00ffffff,0x01ffffff,0x03ffffff,0x07ffffff,
  0x0fffffff,0x1fffffff,0x3fffffff,0x7fffffff,
  0xffffffff
};
/* inverse mask */
const static ScBitString_t imask[33] =
{
  0xffffffff,0xfffffffe,0xfffffffc,0xfffffff8,
  0xfffffff0,0xffffffe0,0xffffffc0,0xffffff80,
  0xffffff00,0xfffffe00,0xfffffc00,0xfffff800,
  0xfffff000,0xffffe000,0xffffc000,0xffff8000,
  0xffff0000,0xfffe0000,0xfffc0000,0xfff80000,
  0xfff00000,0xffe00000,0xffc00000,0xff800000,
  0xff000000,0xfe000000,0xfc000000,0xf8000000,
  0xf0000000,0xe0000000,0xc0000000,0x80000000,
  0x00000000
};
#endif
#endif USE_MASK_TABLES
/*********************** Bitstream/Buffer Management *************************/
/*
** sc_GetNextBuffer()
** Release current buffer and return info about buffer at head of queue
** Callbacks are made to 1) release old buffer and 2) ask for more buffers
*/
static u_char *sc_GetNextBuffer(ScBitstream_t *BS, int *BufSize)
{
  u_char *Data;
  int Size;
  ScCallbackInfo_t CB;
  ScQueue_t *Q=BS->Q;

  _SlibDebug(_VERBOSE_, printf("sc_GetNextBuffer(Q=%p)\n", Q) );
  if (ScBufQueueGetNum(Q))
  {
    /*
    ** Get pointer to current buffer so we can release it with a callback
    */
    ScBufQueueGetHead(Q, &Data, &Size);

    /*
    ** Remove current buffer from head of queue, replacing it with next in line
    */
    ScBufQueueRemove(Q);

    /*
    ** Make callback to client to tell that old buffer can be reused.
    ** Client may tell us to abort processing. If so, return 0 for BufSize.
    */
    if (BS->Callback && Data) {
      CB.Message = CB_RELEASE_BUFFER;
      CB.Data  = Data;
      CB.DataSize = Size;
      CB.DataUsed = Size;
      CB.DataType = BS->DataType;
      CB.UserData = BS->UserData;
      CB.Action  = CB_ACTION_CONTINUE;
      (*(BS->Callback))(BS->Sch, &CB, NULL);
      _SlibDebug(_DEBUG_,
         printf("Callback: RELEASE_BUFFER. Addr = 0x%x, Client response = %d\n",
                CB.Data, CB.Action) );
      if (CB.Action == CB_ACTION_END)
      {
        *BufSize = 0;
        return(NULL);
      }
    }
  }

  /*
  ** If there's no more buffers in queue, make a callback telling client.
  ** Hopefully, client will call ScAddBuffer to add one or more buffers.
  ** If not, or if client tells us to abort, return 0 for BufSize.
  */
  if (!ScBufQueueGetNum(Q)) {
    if (BS->Callback) {
      CB.Message = CB_END_BUFFERS;
      CB.Data     = NULL;
      CB.DataSize = 0;
      CB.DataUsed = 0;
      CB.DataType = BS->DataType;
      CB.UserData = BS->UserData;
      CB.Action   = CB_ACTION_CONTINUE;
      (*(BS->Callback))(BS->Sch, &CB, NULL);
      if (CB.Action == CB_ACTION_END)
      {
	_SlibDebug(_DEBUG_,
           printf("sc_GetNextBuffer() CB.Action = CB_ACTION_END\n") );
        *BufSize = 0;
        return(NULL);
      }
      else
        _SlibDebug(_VERBOSE_, printf("sc_GetNextBuffer() CB.Action = %d\n",
                                  CB.Action) );
    }
    if (!ScBufQueueGetNum(Q)) {
      _SlibDebug(_DEBUG_, printf("sc_GetNextBuffer() no more buffers\n") );
      *BufSize = 0;
      return(NULL);
    }
  }

  /*
  ** Get & return pointer & size of new current buffer
  */
  ScBufQueueGetHead(Q, &Data, BufSize);
  _SlibDebug(_VERBOSE_, printf("New buffer: Addr = 0x%p, size = %d\n",
                                  Data, *BufSize) );
  return(Data);
}

/*************************** Bitstream Management ***************************/
/* Name:  ScBSSetFilter
** Purpose: Set the callback used to filter out data from the Bitstream
*/
ScStatus_t ScBSSetFilter(ScBitstream_t *BS,
                    int (*Callback)(ScBitstream_t *))
{
  if (!BS)
    return(ScErrorBadPointer);
  BS->FilterCallback=Callback;
  BS->FilterBit=BS->CurrentBit;
  BS->InFilterCallback=FALSE;
  return(ScErrorNone);
}

/* Name:  ScBSCreate
** Purpose: Open a Bitstream (no data source)
*/
ScStatus_t ScBSCreate(ScBitstream_t **BS)
{
  _SlibDebug(_VERBOSE_, printf("ScBSCreate()\n"));

  if ((*BS = (ScBitstream_t *)ScAlloc(sizeof(ScBitstream_t))) == NULL)
    return(ScErrorMemory);

  (*BS)->DataSource = STREAM_USE_NULL;
  (*BS)->Mode='r';
  (*BS)->Q=NULL;
  (*BS)->Callback=NULL;
  (*BS)->FilterCallback=NULL;
  (*BS)->FilterBit=0;
  (*BS)->InFilterCallback=FALSE;
  (*BS)->Sch=0;
  (*BS)->DataType=0;
  (*BS)->UserData=NULL;
  (*BS)->FileFd=0;
  (*BS)->RdBuf=NULL;
  (*BS)->RdBufSize=0;
  (*BS)->RdBufAllocated=FALSE;
  (*BS)->shift=0;
  (*BS)->CurrentBit=0;
  (*BS)->buff=0;
  (*BS)->buffstart=0;
  (*BS)->buffp=0;
  (*BS)->bufftop=0;
  (*BS)->OutBuff = 0;
  (*BS)->InBuff = 0;
  (*BS)->Flush = FALSE;
  (*BS)->EOI = FALSE;
  return(ScErrorNone);
}

/* Name:  ScBSCreateFromBuffer
** Purpose: Open a Bitstream using a single Buffer as a data source
*/
ScStatus_t ScBSCreateFromBuffer(ScBitstream_t **BS, u_char *Buffer,
                                    unsigned int BufSize)
{
  _SlibDebug(_VERBOSE_, printf("ScBSCreateFromBuffer()\n") );
  if (!Buffer)
     return(ScErrorBadPointer);
  if (BufSize <= 0)
    return(ScErrorBadArgument);
  if (ScBSCreate(BS) != ScErrorNone)
     return (ScErrorMemory);

  (*BS)->DataSource = STREAM_USE_BUFFER;
  (*BS)->RdBuf=Buffer;
  (*BS)->RdBufSize=BufSize;
  (*BS)->RdBufAllocated=FALSE;
  return(ScErrorNone);
}

/* Name:  ScBSCreateFromBufferQueue
** Purpose: Open a Bitstream using a Buffer Queue as a data source
*/
ScStatus_t ScBSCreateFromBufferQueue(ScBitstream_t **BS, ScHandle_t Sch,
                                  int DataType, ScQueue_t *Q,
                    int (*Callback)(ScHandle_t,ScCallbackInfo_t *, void *),
                    void *UserData)
{
  _SlibDebug(_VERBOSE_, printf("ScBSCreateFromBufferQueue()\n") );
  if (!Q)
     return(ScErrorNullStruct);
  if (!Callback)
     return(ScErrorBadPointer);
  if (ScBSCreate(BS) != ScErrorNone)
     return (ScErrorMemory);

  (*BS)->DataSource = STREAM_USE_QUEUE;
  (*BS)->Q=Q;
  (*BS)->Callback=Callback;
  (*BS)->Sch=Sch;
  (*BS)->DataType=DataType;
  (*BS)->UserData=UserData;
  return(ScErrorNone);
}


/* Name:  ScBSCreateFromFile
** Purpose: Open a Bitstream using a file as a data source
*/
ScStatus_t ScBSCreateFromFile(ScBitstream_t **BS, int FileFd,
                                 u_char *Buffer, int BufSize)
{
  _SlibDebug(_VERBOSE_, printf("ScBSCreateFromFile()\n") );

  if (BufSize < SC_BITBUFFSZ)
    return(ScErrorBadArgument);
  if (FileFd < 0)
    return(ScErrorBadArgument);

  if (ScBSCreate(BS) != ScErrorNone)
     return (ScErrorMemory);

  (*BS)->DataSource = STREAM_USE_FILE;
  (*BS)->FileFd=FileFd;
  if (Buffer==NULL)  /* if no buffer provided, alloc one */
  {
    if (((*BS)->RdBuf=(u_char *)ScAlloc(BufSize))==NULL)
    {
      ScFree(*BS);
      *BS=NULL;
      return (ScErrorMemory);
    }
    (*BS)->RdBufAllocated=TRUE;
  }
  else
  {
    (*BS)->RdBufAllocated=FALSE;
    (*BS)->RdBuf=Buffer;
  }
  (*BS)->RdBufSize=BufSize;
  return(ScErrorNone);
}

/* Name:  ScBSCreateFromNet
** Purpose: Open a Bitstream using a network socket as a data source
*/
ScStatus_t ScBSCreateFromNet(ScBitstream_t **BS, int SocketFd,
                                u_char *Buffer, int BufSize)
{
  ScStatus_t stat;
  _SlibDebug(_VERBOSE_, printf("ScBSCreateFromNet(SocketFd=%d)\n", SocketFd) );
  stat=ScBSCreateFromFile(BS, SocketFd, Buffer, BufSize);
  if (stat!=NoErrors)
    return(stat);
  (*BS)->DataSource = STREAM_USE_NET;
  return(ScErrorNone);
}

/* Name:  ScBSCreateFromDevice
** Purpose: Open a Bitstream using a device (i.e. WAVE_MAPPER)
*/
ScStatus_t ScBSCreateFromDevice(ScBitstream_t **BS, int device)
{
  _SlibDebug(_VERBOSE_, printf("ScBSCreateFromBuffer()\n") );
  if (ScBSCreate(BS) != ScErrorNone)
     return (ScErrorMemory);

  (*BS)->DataSource = STREAM_USE_DEVICE;
  (*BS)->Device=device;
  return(ScErrorNone);
}


/*
** Name:    ScBSSeekToPosition()
** Purpose: Position the bitstream to a specific byte offset.
*/
ScStatus_t ScBSSeekToPosition(ScBitstream_t *BS, unsigned long pos)
{
#ifndef SEEK_SET
#define SEEK_SET 0
#endif
  ScCallbackInfo_t CB;
  _SlibDebug(_VERBOSE_,
             printf("ScBSSeekToPosition(pos=%d 0x%X) from %d (0x%X)\n",
                       pos, pos, ScBSBytePosition(BS),ScBSBytePosition(BS)) );
  BS->shift=0;
  BS->OutBuff = 0;
  BS->InBuff = 0;
  switch (BS->DataSource)
  {
    case STREAM_USE_BUFFER:
          if (pos==0)
          {
            if (BS->Mode=='w')
            {
              BS->buff = BS->RdBuf;
              BS->bufftop = BS->RdBufSize;
            }
            else
            {
              BS->buff = 0;
              BS->bufftop = 0;
            }
            BS->buffp=0;
            BS->EOI = FALSE;
          }
          else if (pos>=BS->buffstart && pos<(BS->buffstart+BS->bufftop))
          {
            BS->buffp=pos-BS->buffstart;
            BS->EOI = FALSE;
          }
          else
            BS->EOI = TRUE;
          break;
    case STREAM_USE_QUEUE:
          if (pos>=BS->buffstart && pos<(BS->buffstart+BS->bufftop) && pos>0)
          {
            BS->buffp=pos-BS->buffstart;
            BS->EOI = FALSE;
          }
          else /* use callback to reset buffer position */
          {
            int datasize;
            /* Release the current buffer */
            if (BS->Callback && BS->buff)
            {
              CB.Message = CB_RELEASE_BUFFER;
              CB.Data = BS->buff;
              CB.DataSize = BS->bufftop;
              CB.DataUsed = BS->buffp;
              CB.DataType = BS->DataType;
              CB.UserData = BS->UserData;
              CB.Action  = CB_ACTION_CONTINUE;
              (*(BS->Callback))(BS->Sch, &CB, NULL);
              _SlibDebug(_VERBOSE_,
                         printf("Callback: RELEASE_BUFFER. Addr = 0x%x, Client response = %d\n",
                           CB.Data, CB.Action) );
            }
            /* Remove all buffers from queue */
            while (ScBufQueueGetNum(BS->Q))
            {
              ScBufQueueGetHead(BS->Q, &CB.Data, &datasize);
              ScBufQueueRemove(BS->Q);
              if (BS->Callback && CB.Data)
              {
                CB.Message = CB_RELEASE_BUFFER;
                CB.DataSize = datasize;
                CB.DataUsed = 0;
                CB.DataType = BS->DataType;
                CB.UserData = BS->UserData;
                CB.Action  = CB_ACTION_CONTINUE;
                (*(BS->Callback))(BS->Sch, &CB, NULL);
                _SlibDebug(_VERBOSE_,
                           printf("Callback: RELEASE_BUFFER. Addr = 0x%x, Client response = %d\n",
                           CB.Data, CB.Action) );
              }
            }
            BS->buffp=0;
            BS->buff=NULL;
            if (CB.Action == CB_ACTION_END)
            {
              BS->EOI = TRUE;
              return(ScErrorClientEnd);
            }
            else
            {
              BS->buffstart=pos;
              BS->bufftop=0;
              BS->EOI = FALSE;
            }
          }
          break;
    case STREAM_USE_FILE:
          /*
          ** check if the desired position is within the
          ** current buffer
          */
          if (pos>=BS->buffstart && pos<(BS->buffstart+BS->bufftop))
          {
            _SlibDebug(_VERBOSE_, printf("pos is in BS->buff, BS->bufftop=%d\n",
                                        BS->bufftop) );
            BS->buffp=pos-BS->buffstart;
            BS->EOI = FALSE;
          }
          /* otherwise seek to it */
	  else if (ScFileSeek(BS->FileFd, pos)==NoErrors)
          {
            _SlibDebug(_VERBOSE_, printf("seek(%d 0x%X)\n",pos,pos) );
            BS->buffstart=pos;
            BS->bufftop=0;
            BS->buffp=0;
            BS->EOI = FALSE;
          }
          else
          {
            _SlibDebug(_VERBOSE_, printf("seek(%d 0x%X) failed\n",pos,pos) );
            BS->buffstart=0;
            BS->bufftop=0;
            BS->buffp=0;
            BS->EOI = TRUE;
          }
          break;
    default:
          BS->buffstart=0;
          BS->EOI = FALSE;
  }
  BS->CurrentBit=pos<<3;
  _SlibDebug(_VERBOSE_, printf("ScBSSeekToPosition() done\n") );
  return(ScErrorNone);
}

/*
** Name:    ScBSReset()
** Purpose: Reset the bitstream back to the beginning.
*/
ScStatus_t ScBSReset(ScBitstream_t *BS)
{
  _SlibDebug(_VERBOSE_, printf("ScBSReset()\n") );
  BS->EOI=FALSE;
  if (BS->DataSource==STREAM_USE_FILE)
  {
    /*
    ** for files always empty buffer and seek to beginning
    ** just in case the file descriptor was used for something else
    */
    _SlibDebug(_VERBOSE_, printf("seek(0)\n") );
	ScFileSeek(BS->FileFd, 0);
    BS->bufftop=0;  /* empty buffer */
    BS->buffp=0;
    BS->buffstart=0;
  }
  BS->Flush=FALSE;
  return(ScBSSeekToPosition(BS, 0));
}

/*
** Name:    sc_BSGetData()
** Purpose: Set the bitstream pointer to the next buffer in the buffer
**          queue, or if we're using simple file IO, read from the file.
** Returns: TRUE if data read
**          FALSE if none read (EOI)
*/
static u_int sc_BSGetData(ScBitstream_t *BS)
{
  int BufSize;

  _SlibDebug(_VERBOSE_, printf("sc_BSGetData\n") );
  BS->buffp = 0;
  if (BS->EOI)
  {
    BS->buff = NULL;
    BS->bufftop = 0;
    return(FALSE);
  }
  switch (BS->DataSource)
  {
    case STREAM_USE_BUFFER:
          if (BS->buff == BS->RdBuf)
          {
            BS->buff = NULL;
            BS->bufftop = 0;
          }
          else
          {
            BS->buff = BS->RdBuf;
            BS->bufftop = BS->RdBufSize;
          }
          break;
    case STREAM_USE_QUEUE:
          BS->buffstart+=BS->bufftop;
          _SlibDebug(_VERIFY_ && BS->buffstart<(BS->CurrentBit/8),
            printf("ScBSGetData() QUEUE buffstart(%d/0x%X) < currentbyte(%d/0x%X)\n",
             BS->buffstart, BS->buffstart, BS->CurrentBit/8, BS->CurrentBit/8);
            return(FALSE) );
          BS->buff = sc_GetNextBuffer(BS, &BufSize);
          BS->bufftop = BufSize;
          break;
    case STREAM_USE_NET:
    case STREAM_USE_NET_UDP:
    case STREAM_USE_FILE:
          BS->buff = BS->RdBuf;
          BS->buffstart+=BS->bufftop;
          _SlibDebug(_VERIFY_ && BS->buffstart<(BS->CurrentBit/8),
            printf("ScBSGetData() FILE buffstart(%d/0x%X) < currentbyte(%d/0x%X)\n",
             BS->buffstart, BS->buffstart, BS->CurrentBit/8, BS->CurrentBit/8);
            return(FALSE) );
          BufSize = ScFileRead(BS->FileFd, BS->buff, BS->RdBufSize);
          if (BufSize<0)
            BS->bufftop = 0;
          else
            BS->bufftop = BufSize;
          _SlibDebug(_VERBOSE_,
                      printf("%d bytes read from fd %d: BytePosition=%d (0x%X) RdBufSize=%d\n buffstart=%d (0x%X)",
                        BS->bufftop,BS->FileFd,ScBSBytePosition(BS),
                        ScBSBytePosition(BS),BS->RdBufSize,
                        BS->buffstart,BS->buffstart) );
          break;
    case STREAM_USE_NULL:
          BS->buff = NULL;
          BS->bufftop   =10240;
          BS->buffstart+=10240;
          break;
  }
  _SlibDebug(_DUMP_ && BS->buff && BS->bufftop &&
                      BS->DataSource==STREAM_USE_QUEUE,
            printf("sc_BSGetData():\n");
            ScDumpChar(BS->buff, BS->bufftop, BS->buffstart);
            if (BS->bufftop>0x8000)  /* show end of buffer */
              ScDumpChar(BS->buff+BS->bufftop-0x500, 0x500,
                         BS->buffstart+BS->bufftop-0x500) );

  if (BS->buff && BS->bufftop)
    return(TRUE);
  else
    return(FALSE);
}

/*
** Name:    sc_BSPutData()
** Purpose: Set the bitstream pointer to the next buffer in the buffer
**          queue, or if we're using simple file IO, read from the file.
*/
static ScStatus_t sc_BSPutData(ScBitstream_t *BS)
{
  ScStatus_t stat;
  int written;

  _SlibDebug(_VERBOSE_, printf("sc_BSPutData\n") );
  BS->Flush=FALSE;
  switch (BS->DataSource)
  {
    case STREAM_USE_BUFFER:
          stat=ScErrorEndBitstream;
          break;
    case STREAM_USE_QUEUE:
          if (BS->Callback)
          {
            ScCallbackInfo_t CB;
            if (BS->buff)
            {
              _SlibDebug(_VERBOSE_, printf("Callback CB_RELEASE_BUFFERS\n"));
              CB.Message = CB_RELEASE_BUFFER;
              CB.Data  = BS->buff;
              CB.DataSize = BS->buffp;
              CB.DataUsed = CB.DataSize;
              CB.DataType = BS->DataType;
              CB.UserData = BS->UserData;
              CB.Action  = CB_ACTION_CONTINUE;
              (*BS->Callback)(BS->Sch, &CB, NULL);
              BS->buff = 0;
              BS->bufftop = 0;
              BS->buffp=0;
              if (CB.Action == CB_ACTION_END)
                return(ScErrorClientEnd);
            }
            else
              BS->bufftop = 0;
            if (!BS->Q)
              stat=ScErrorEndBitstream;
            else
            {
              _SlibDebug(_DEBUG_, printf("Callback CB_END_BUFFERS\n") );
              CB.Message  = CB_END_BUFFERS;
              CB.Data     = NULL;
              CB.DataSize = 0;
              CB.DataUsed = 0;
              CB.DataType = BS->DataType;
              CB.UserData = BS->UserData;
              CB.Action   = CB_ACTION_CONTINUE;
              (*BS->Callback)(BS->Sch, &CB, NULL);
              if (CB.Action != CB_ACTION_CONTINUE ||
                   ScBufQueueGetNum(BS->Q)==0)
                stat=ScErrorEndBitstream;
              else
              {
                int size;
                ScBufQueueGetHead(BS->Q, &BS->buff, &size);
                BS->bufftop=size;
                ScBufQueueRemove(BS->Q);
                if (!BS->buff || size<=0)
                  stat=ScErrorEndBitstream;
                else
                  stat=NoErrors;
              }
            }
          }
          else
          {
            BS->buff = 0;
            BS->bufftop = 0;
          }
          BS->buffp=0;
          break;
    case STREAM_USE_FILE:
    case STREAM_USE_NET:
    case STREAM_USE_NET_UDP:
          if (BS->buffp>0)
          {
            written=ScFileWrite(BS->FileFd, BS->buff, BS->buffp);
            _SlibDebug(_VERBOSE_,
                       printf("%d bytes written to fd %d (buffer=%d bytes)\n",
                                             written, BS->FileFd, BS->buffp) );
            _SlibDebug(_DUMP_,
                printf("sc_BSPutData():\n");
                ScDumpChar(BS->buff, BS->buffp, BS->buffstart));
            if (written<(int)BS->buffp)
            {
              BS->buff = BS->RdBuf;
              BS->buffp=0;
              BS->bufftop=0;
              stat=ScErrorEndBitstream;
            }
            else
            {
              BS->buff = BS->RdBuf;
              BS->buffp=0;
              BS->bufftop = BS->RdBufSize;
              stat=NoErrors;
            }
          }
          break;
    case STREAM_USE_NULL:
          BS->buff = NULL;
          BS->buffp=0;
          BS->bufftop = 10240;
          break;
    default:
          stat=ScErrorEndBitstream;
  }

  return(stat);
}

/*
** Name:    sc_BSLoadDataWord
** Purpose: Copy a longword from the bitstream buffer into local working buffer
*/
ScStatus_t sc_BSLoadDataWord(ScBitstream_t *BS)
{
  int i, bcount;
  register ScBitBuff_t InBuff;
  const int shift=BS->shift;
  const u_int buffp=BS->buffp;
  register u_char *buff=BS->buff+buffp;

  _SlibDebug(_DEBUG_,
          printf("sc_BSLoadDataWord(BS=%p) shift=%d bit=%d byte=%d (0x%X)\n",
          BS, BS->shift, BS->CurrentBit, BS->CurrentBit/8, BS->CurrentBit/8) );
  /* If we have plenty of room, use fast path */
  if (BS->bufftop - buffp >= SC_BITBUFFSZ/8)
  {
#if SC_BITBUFFSZ == 64
    InBuff=(ScBitBuff_t)buff[7];
    InBuff|=(ScBitBuff_t)buff[6]<<8;
    InBuff|=(ScBitBuff_t)buff[5]<<16;
    InBuff|=(ScBitBuff_t)buff[4]<<24;
    InBuff|=(ScBitBuff_t)buff[3]<<32;
    InBuff|=(ScBitBuff_t)buff[2]<<40;
    InBuff|=(ScBitBuff_t)buff[1]<<48;
    InBuff|=(ScBitBuff_t)buff[0]<<56;
    _SlibDebug(_VERIFY_ && (u_char)((InBuff>>24)&0xFF)!=buff[4],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>24(%X)!=buff[4](%X)\n",
           BS, (InBuff>>24)&0xFF, buff[4]) );
    _SlibDebug(_VERIFY_ && (u_char)(InBuff>>56)!=buff[0],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>56(%X)!=buff[0](%X)\n",
           BS, (InBuff>>56), buff[0]) );
#elif SC_BITBUFFSZ == 32
    InBuff=(ScBitBuff_t)buff[3];
    InBuff|=(ScBitBuff_t)buff[2]<<8;
    InBuff|=(ScBitBuff_t)buff[1]<<16;
    InBuff|=(ScBitBuff_t)buff[0]<<24;
    _SlibDebug(_VERIFY_ && (InBuff>>24)!=buff[0],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>24(%X)!=buff[0](%X)\n",
           BS, InBuff>>24, buff[0]) );
#else
    printf("SC_BITBUFFSZ <> 32\n");
    for (InBuff=0, i = SC_BITBUFFSZ/8; i > 0; i--, buff++)
      InBuff = (InBuff << 8) | (ScBitBuff_t)*buff;
#endif
    BS->buffp=buffp+SC_BITBUFFSZ/8;
    bcount = SC_BITBUFFSZ/8;
  }
  /* Near or at end of buffer */
  else
  {
    /* Get remaining bytes */
    bcount = BS->bufftop - buffp;
    for (InBuff=0, i = bcount; i > 0; i--, buff++)
      InBuff = (InBuff << 8) | (ScBitBuff_t)*buff;
    BS->buffp=buffp+bcount;
    /* Attempt to get more data - if successful, shuffle rest of bytes */
    if (sc_BSGetData(BS))
    {
      BS->EOI = FALSE;
      i = (SC_BITBUFFSZ/8) - bcount;
      if (i>(int)BS->bufftop)
      {
        _SlibDebug(_WARN_,
           printf("ScBSLoadDataWord() Got small buffer. Expected %d bytes got %d bytes.\n",
                     i, BS->bufftop) );
        i=BS->bufftop;
        bcount+=i;
        while (i > 0)
        {
	  InBuff = (InBuff << 8) | (ScBitBuff_t)BS->buff[BS->buffp++];
          i--;
        }
        InBuff<<=SC_BITBUFFSZ-(bcount*8);
      }
      else
      {
        bcount = SC_BITBUFFSZ/8;
        while (i > 0)
        {
	  InBuff = (InBuff << 8) | (ScBitBuff_t)BS->buff[BS->buffp++];
          i--;
        }
      }
    }
    else if (bcount==0)
      BS->EOI = TRUE;
    else
      InBuff <<= SC_BITBUFFSZ-bcount*8;
  }

  _SlibDebug(_VERIFY_ && BS->shift>SC_BITBUFFSZ,
           printf("sc_BSLoadDataWord(BS=%p) shift (%d) > SC_BITBUFFSZ (%d)\n",
           BS, BS->shift, SC_BITBUFFSZ) );
  if (!shift) /* OutBuff is empty */
  {
    BS->OutBuff = InBuff;
    BS->InBuff = 0;
    BS->shift=bcount*8;
  }
  else if (shift<SC_BITBUFFSZ)
  {
    BS->OutBuff |= InBuff >> shift;
    BS->InBuff = InBuff << (SC_BITBUFFSZ-shift);
    BS->shift=shift+(bcount*8);
  }
  else /* shift == SC_BITBUFFSZ - OutBuff is full */
  {
    BS->InBuff = InBuff;
    BS->shift=bcount*8;
  }
  _SlibDebug(_VERIFY_,
    if (BS->shift<SC_BITBUFFSZ)
    {
      if (BS->OutBuff & (SC_BITBUFFMASK>>BS->shift))
        printf("sc_BSLoadDataWord(BS=%p) Non-zero bits to right of OutBuff: shift=%d\n", BS, BS->shift);
      else if (BS->InBuff)
        printf("sc_BSLoadDataWord(BS=%p) Non-zero bits in InBuff: shift=%d\n",
           BS, BS->shift);
    }
    else if (BS->InBuff&(SC_BITBUFFMASK>>(BS->shift-SC_BITBUFFSZ)))
      printf("sc_BSLoadDataWord(BS=%p) Non-zero bits to right of InBuff: shift=%d\n", BS->shift);
    if ((BS->CurrentBit%8) && !(BS->shift%8))
      printf("sc_BSLoadDataWord(BS=%p) CurrentBit (%d) and shift (%d) not aligned.\n", BS, BS->CurrentBit, BS->shift);
    if ((BS->CurrentBit+BS->shift)/8!=BS->buffstart+BS->buffp)
    {
      printf("sc_BSLoadDataWord(BS=%p) (CurrentBit+shift)/8 (%d) <> buffstart+buffp (%d)\n", BS, (BS->CurrentBit+BS->shift)/8, BS->buffstart+BS->buffp);
      BS->EOI = TRUE;
      return(ScErrorEndBitstream);
    }
  );
  return(NoErrors);
}
/*
** Name:    sc_BSLoadDataWordW
** Purpose: Copy a longword from the bitstream buffer into local working buffer
**		** This version operates a word at a time for Dolby **
*/
ScStatus_t sc_BSLoadDataWordW(ScBitstream_t *BS)
{
  int i, wcount;
  register ScBitBuff_t InBuff;
  const int shift=BS->shift;
  const u_int buffp=BS->buffp;
  register u_short *buff=(u_short *)BS->buff+(buffp/2);

  _SlibDebug(_DEBUG_,
          printf("sc_BSLoadDataWord(BS=%p) shift=%d bit=%d byte=%d (0x%X)\n",
          BS, BS->shift, BS->CurrentBit, BS->CurrentBit/8, BS->CurrentBit/8) );
  /* If we have plenty of room, use fast path */
  if (BS->bufftop - buffp >= SC_BITBUFFSZ/8)
  {
#if SC_BITBUFFSZ == 64
    InBuff=(ScBitBuff_t)buff[3];
    InBuff|=(ScBitBuff_t)buff[2]<<16;
    InBuff|=(ScBitBuff_t)buff[1]<<32;
    InBuff|=(ScBitBuff_t)buff[0]<<48;
    _SlibDebug(_VERIFY_ && (InBuff>>24)&0xFFFF!=buff[4],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>24(%X)!=buff[0](%X)\n",
           BS, (InBuff>>24)&0xFF, buff[4]) );
    _SlibDebug(_VERIFY_ && (InBuff>>56)!=buff[0],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>56(%X)!=buff[0](%X)\n",
           BS, (InBuff>>56), buff[0]) );
#elif SC_BITBUFFSZ == 32
    InBuff=(ScBitBuff_t)buff[1];
    InBuff|=(ScBitBuff_t)buff[0]<<16;
    _SlibDebug(_VERIFY_ && (InBuff>>16)!=buff[0],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>24(%X)!=buff[0](%X)\n",
           BS, InBuff>>24, buff[0]) );
#else
    printf("SC_BITBUFFSZ <> 32\n");
    for (InBuff=0, i = SC_BITBUFFSZ/16; i > 0; i--, buff++)
      InBuff = (InBuff << 16) | (ScBitBuff_t)*buff;
#endif
    BS->buffp=buffp+SC_BITBUFFSZ/8;
    wcount = SC_BITBUFFSZ/16;
  }
  /* Near or at end of buffer */
  else
  {
    /* Get remaining bytes */
    wcount = (BS->bufftop - buffp)/2;
    for (InBuff=0, i = wcount; i > 0; i--, buff++)
      InBuff = (InBuff << 16) | (ScBitBuff_t)*buff;
    BS->buffp=buffp+wcount*2;
    /* Attempt to get more data - if successful, shuffle rest of bytes */
    if (sc_BSGetData(BS))
    {
	  int wordp=BS->buffp/2;	/* Pointer is stored as a byte count, but we need words */

      BS->EOI = FALSE;
      i = (SC_BITBUFFSZ/16) - wcount;
      if (i>(int)BS->bufftop)
      {
        _SlibDebug(_WARN_,
           printf("ScBSLoadDataWord() Got small buffer. Expected %d words got %d words.\n",
                     i, BS->bufftop) );
        i=BS->bufftop;
        wcount+=i;
        while (i >= 0)
        {
	  InBuff = (InBuff << 16) | (ScBitBuff_t)((u_short *)BS->buff)[wordp++];
          i--;
        }
        InBuff<<=SC_BITBUFFSZ-(wcount*16);
      }
      else
      {
        wcount = SC_BITBUFFSZ/16;
        while (i > 0)
        {
	  InBuff = (InBuff << 16) | (ScBitBuff_t)((u_short *)BS->buff)[wordp++];
          i--;
        }
      }
	  BS->buffp=wordp*2;
    }
    else
      BS->EOI = TRUE;
  }
  _SlibDebug(_VERIFY_ && BS->shift>SC_BITBUFFSZ,
           printf("sc_BSLoadDataWordW(BS=%p) shift (%d) > SC_BITBUFFSZ (%d)\n",
           BS, BS->shift, SC_BITBUFFSZ) );
  if (!shift) /* OutBuff is empty */
  {
    BS->OutBuff = InBuff;
    BS->InBuff = 0;
    BS->shift=wcount*16;
  }
  else if (shift<SC_BITBUFFSZ)
  {
    BS->OutBuff |= InBuff >> shift;
    BS->InBuff = InBuff << (SC_BITBUFFSZ-shift);
    BS->shift=shift+(wcount*16);
  }
  else /* shift == SC_BITBUFFSZ - OutBuff is full */
  {
    BS->InBuff = InBuff;
    BS->shift=wcount*16;
  }
  _SlibDebug(_VERIFY_,
    if (BS->shift<SC_BITBUFFSZ)
    {
      if (BS->OutBuff & (SC_BITBUFFMASK>>BS->shift))
        printf("sc_BSLoadDataWord(BS=%p) Non-zero bits to right of OutBuff: shift=%d\n", BS, BS->shift);
      else if (BS->InBuff)
        printf("sc_BSLoadDataWord(BS=%p) Non-zero bits in InBuff: shift=%d\n",
           BS, BS->shift);
    }
    else if (BS->InBuff&(SC_BITBUFFMASK>>(BS->shift-SC_BITBUFFSZ)))
      printf("sc_BSLoadDataWord(BS=%p) Non-zero bits to right of InBuff: shift=%d\n", BS->shift);
    if ((BS->CurrentBit%8) && !(BS->shift%8))
      printf("sc_BSLoadDataWord(BS=%p) CurrentBit (%d) and shift (%d) not aligned.\n", BS, BS->CurrentBit, BS->shift);
    if ((BS->CurrentBit+BS->shift)/8!=BS->buffstart+BS->buffp)
    {
      printf("sc_BSLoadDataWord(BS=%p) (CurrentBit+shift)/8 (%d) <> buffstart+buffp (%d)\n", BS, (BS->CurrentBit+BS->shift)/8, BS->buffstart+BS->buffp);
      BS->EOI = TRUE;
      return(ScErrorEndBitstream);
    }
  );
  return(NoErrors);
}

/*
** Name:    sc_BSStoreDataWord
** Purpose: Copy a longword from the local working buffer to the
**          bitstream buffer
*/
ScStatus_t sc_BSStoreDataWord(ScBitstream_t *BS, ScBitBuff_t OutBuff)
{
  int i, bcount, shift=SC_BITBUFFSZ-8;
  ScStatus_t stat=NoErrors;

  _SlibDebug(_VERBOSE_,
             printf("sc_BSStoreDataWord(0x%lX 0x%lX) buffp=%d\n",
                            OutBuff>>32, OutBuff&0xFFFFFFFF, BS->buffp) );
  if (BS->EOI)
    return(ScErrorEndBitstream);
  if (!BS->buff || BS->bufftop<=0)
  {
    if (BS->DataSource==STREAM_USE_QUEUE)
    {
      if (BS->Callback && BS->Q)
      {
        ScCallbackInfo_t CB;
        _SlibDebug(_DEBUG_, printf("Callback CB_END_BUFFERS\n") );
        CB.Message  = CB_END_BUFFERS;
        CB.Data     = NULL;
        CB.DataSize = 0;
        CB.DataUsed = 0;
        CB.DataType = BS->DataType;
        CB.UserData = BS->UserData;
        CB.Action   = CB_ACTION_CONTINUE;
        (*BS->Callback)(BS->Sch, &CB, NULL);
        if (CB.Action != CB_ACTION_CONTINUE || ScBufQueueGetNum(BS->Q)==0)
        {
          BS->EOI = TRUE;
          return(ScErrorEndBitstream);
        }
        else
        {
          int size;
          ScBufQueueGetHead(BS->Q, &BS->buff, &size);
          BS->bufftop=size;
          ScBufQueueRemove(BS->Q);
          if (!BS->buff || size<=0)
          {
            BS->EOI = TRUE;
            return(ScErrorEndBitstream);
          }
          BS->EOI = FALSE;
        }
      }
      else
      {
        BS->EOI = TRUE;
        return(ScErrorEndBitstream);
      }
    }
    else if (BS->RdBuf)
    {
      BS->buff=BS->RdBuf;
      BS->bufftop=BS->RdBufSize;
    }
  }
  bcount = BS->bufftop - BS->buffp;
  /* If we have plenty of room, use fast path */
  if (bcount >= SC_BITBUFFSZ>>3) {
    u_char *buff=BS->buff+BS->buffp;
#if SC_BITBUFFSZ == 64
    buff[0]=(unsigned char)(OutBuff>>56);
    buff[1]=(unsigned char)(OutBuff>>48);
    buff[2]=(unsigned char)(OutBuff>>40);
    buff[3]=(unsigned char)(OutBuff>>32);
    buff[4]=(unsigned char)(OutBuff>>24);
    buff[5]=(unsigned char)(OutBuff>>16);
    buff[6]=(unsigned char)(OutBuff>>8);
    buff[7]=(unsigned char)OutBuff;
#elif SC_BITBUFFSZ == 32
    buff[0]=(unsigned char)(OutBuff>>24);
    buff[1]=(unsigned char)(OutBuff>>16);
    buff[2]=(unsigned char)(OutBuff>>8);
    buff[3]=(unsigned char)OutBuff;
#else
    for (bcount = SC_BITBUFFSZ/8; bcount; shift-=8, bcount--, buff++)
      *buff=(Buff>>shift)&0xFF;
#endif
    BS->buffp+=SC_BITBUFFSZ/8;
    if (BS->Flush && sc_BSPutData(BS)!=NoErrors)
      BS->EOI=TRUE;
  }
  else /* Near end of buffer */
  {
    /* Fill up current buffer */
    for (i=0; i<bcount; shift-=8, i++)
      BS->buff[BS->buffp++]=(unsigned char)(OutBuff>>shift);
    /* Commit the buffer */
    if ((stat=sc_BSPutData(BS))==NoErrors)
    {
      /* Successful, so copy rest of bytes to new buffer */
      bcount = (SC_BITBUFFSZ>>3) - bcount;
      for (i=0; i<bcount; shift-=8, i++)
        BS->buff[BS->buffp++]=(unsigned char)(OutBuff>>shift);
    }
    else
      BS->EOI=TRUE;
  }
  BS->Mode='w';
  return(stat);
}

/*
** ScBSSkipBits()
** Skip a certain number of bits
**
*/
ScStatus_t ScBSSkipBits(ScBitstream_t *BS, u_int length)
{
  register u_int skipbytes, skipbits;
  register int shift;
  _SlibDebug(_DEBUG_, printf("ScBSSkipBits(%d): Byte offset = 0x%X\n",length,
                                                    ScBSBytePosition(BS)) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSSkipBits(%d) length==0\n", length) );
  _SlibDebug(_WARN_ && length>SC_BITBUFFSZ,
         printf("ScBSSkipBits(%d) length > SC_BITBUFFSZ (%d)\n",
                        length, SC_BITBUFFSZ) );
  if (length<=SC_BITBUFFSZ)
    ScBSPreLoad(BS, length);
  if ((shift=BS->shift)>0)
  {
    if (length<=(u_int)shift) /* all the bits are already in OutBuff & InBuff */
    {
      if (length==SC_BITBUFFSZ)
      {
        BS->OutBuff=BS->InBuff;
        BS->InBuff=0;
      }
      else
      {
        BS->OutBuff=(BS->OutBuff<<length)|(BS->InBuff>>(SC_BITBUFFSZ-length));
        BS->InBuff<<=length;
      }
      BS->CurrentBit+=length;
      BS->shift=shift-length;
      return(NoErrors);
    }
    else /* discard all the bits in OutBuff & InBuff */
    {
      length-=shift;
      BS->OutBuff=BS->InBuff=0;
      BS->CurrentBit+=shift;
      BS->shift=0;
    }
  }
  _SlibDebug(_VERIFY_ && (BS->shift || BS->CurrentBit%8),
            printf("ScBSSkipBits() Bad Alignment - shift=%d CurrentBit=%d\n",
                BS->shift, BS->CurrentBit) );

  skipbytes=length>>3;
  skipbits=length%8;
  _SlibDebug(_WARN_ && skipbits,
     printf("ScBSSkipBits() Skipping odd amount: skipbytes=%d skipbits=%d\n",
               skipbytes, skipbits) );
  if (BS->EOI)
    return(ScErrorEndBitstream);
  while (skipbytes>=(BS->bufftop - BS->buffp))
  {
    /* discard current block of data */
    BS->CurrentBit+=(BS->bufftop - BS->buffp)<<3;
    skipbytes-=BS->bufftop - BS->buffp;
    BS->buffp=0;
    /* get another block */
    if (sc_BSGetData(BS))
      BS->EOI = FALSE;
    else
    {
      BS->EOI = TRUE;
      BS->shift=0;
      return(ScErrorEndBitstream);
    }
  }
  if (skipbytes)
  {
    /* skip forward in current block of data */
    BS->buffp+=skipbytes;
    BS->CurrentBit+=skipbytes<<3;
  }
  if (skipbits)
  {
    /* skip odd number of bits - between 0 and 7 bits */
    ScBSPreLoad(BS, skipbits);
    BS->OutBuff<<=skipbits;
    BS->CurrentBit += skipbits;
    BS->shift-=skipbits;
  }
  return(NoErrors);
}


/*
** ScBSSkipBitsW()
** Skip a certain number of bits
** ** Dolby version **
*/
ScStatus_t ScBSSkipBitsW(ScBitstream_t *BS, u_int length)
{
  register u_int skipwords, skipbits;
  register int shift;
  _SlibDebug(_DEBUG_, printf("ScBSSkipBitsW(%d): Byte offset = 0x%X\n",length,
                                                    ScBSBytePosition(BS)) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSSkipBitsW(%d) length==0\n", length) );
  _SlibDebug(_WARN_ && length>SC_BITBUFFSZ,
         printf("ScBSSkipBits(%d) length > SC_BITBUFFSZ (%d)\n",
                        length, SC_BITBUFFSZ) );
  if (length<=SC_BITBUFFSZ)
    ScBSPreLoadW(BS, length);
  if ((shift=BS->shift)>0)
  {
    if (length<=(u_int)shift) /* all the bits are already in OutBuff & InBuff */
    {
      if (length==SC_BITBUFFSZ)
      {
        BS->OutBuff=BS->InBuff;
        BS->InBuff=0;
      }
      else
      {
        BS->OutBuff=(BS->OutBuff<<length)|(BS->InBuff>>(SC_BITBUFFSZ-length));
        BS->InBuff<<=length;
      }
      BS->CurrentBit+=length;
      BS->shift=shift-length;
      return(NoErrors);
    }
    else /* discard all the bits in OutBuff & InBuff */
    {
      length-=shift;
      BS->OutBuff=BS->InBuff=0;
      BS->CurrentBit+=shift;
      BS->shift=0;
    }
  }
  _SlibDebug(_VERIFY_ && (BS->shift || BS->CurrentBit%8),
            printf("ScBSSkipBitsW() Bad Alignment - shift=%d CurrentBit=%d\n",
                BS->shift, BS->CurrentBit) );

  skipwords=length>>4;
  skipbits=length%16;
  _SlibDebug(_WARN_ && skipbits,
     printf("ScBSSkipBitsW() Skipping odd amount: skipwords=%d skipbits=%d\n",
               skipwords, skipbits) );
  if (BS->EOI)
    return(ScErrorEndBitstream);
  while (skipwords>=(BS->bufftop - BS->buffp)/2)
  {
    /* discard current block of data */
    BS->CurrentBit+=((BS->bufftop - BS->buffp)/2)<<4;
    skipwords-=(BS->bufftop - BS->buffp)/2;
    BS->buffp=0;
    /* get another block */
    if (sc_BSGetData(BS))
      BS->EOI = FALSE;
    else
    {
      BS->EOI = TRUE;
      BS->shift=0;
      return(ScErrorEndBitstream);
    }
  }
  if (skipwords)
  {
    /* skip forward in current block of data */
    BS->buffp+=skipwords*2;
    BS->CurrentBit+=skipwords<<4;
  }
  if (skipbits)
  {
    /* skip odd number of bits - between 0 and 7 bits */
    ScBSPreLoadW(BS, skipbits);
    BS->OutBuff<<=skipbits;
    BS->CurrentBit += skipbits;
    BS->shift-=skipbits;
  }
  return(NoErrors);
}


/*
** ScBSSkipBytes()
** Skip a certain number of bytes
**
*/
ScStatus_t ScBSSkipBytes(ScBitstream_t *BS, u_int length)
{
  return(ScBSSkipBits(BS, length<<3));
}


/*
** ScBSPeekBits()
** Return the next length bits from the bitstream without
** removing them.
*/
ScBitString_t ScBSPeekBits(ScBitstream_t *BS, u_int length)
{
  _SlibDebug(_DEBUG_,
         printf("ScBSPeekBits(%d): Byte offset = 0x%X OutBuff=0x%lX\n",length,
                                   ScBSBytePosition(BS),BS->OutBuff) );
  _SlibDebug(_VERIFY_ && length>SC_BITBUFFSZ,
         printf("ScBSPeekBits(%d) length > SC_BITBUFFSZ\n", length) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSPeekBits(%d) length==0\n", length) );
  if (length==0)
    return(0);
  ScBSPreLoad(BS, length);
  _SlibDebug(_VERIFY_ && BS->shift<length,
    printf("ScBSPeekBits(%d) shift (%d) < length (%d) at byte pos %d (0x%X)\n",
             length, BS->shift, length, BS->CurrentBit/8, BS->CurrentBit/8) );
  if (length == SC_BITBUFFSZ)
    return(BS->OutBuff);
  else
    return(BS->OutBuff >> (SC_BITBUFFSZ-length));
}


/*
** ScBSPeekBit()
** Return the next bit from the bitstream without
** removing it.
*/
int ScBSPeekBit(ScBitstream_t *BS)
{
  _SlibDebug(_DEBUG_,
             printf("ScBSPeekBit(): Byte offset = 0x%X OutBuff=0x%lX\n",
                                   ScBSBytePosition(BS),BS->OutBuff) );
  ScBSPreLoad(BS, 1);
  return((int)(BS->OutBuff >> (SC_BITBUFFSZ-1)));
}


/*
** ScBSPeekBytes()
** Return the next length bytes from the bitstream without
** removing them.
*/
ScBitString_t ScBSPeekBytes(ScBitstream_t *BS, u_int length)
{
  if (length==0)
    return(0);
  length*=8;
  ScBSPreLoad(BS, length);
  if (length == SC_BITBUFFSZ)
    return(BS->OutBuff);
  else
    return(BS->OutBuff >> (SC_BITBUFFSZ-length));
}

/*
** ScBSGetBytes()
** Return the next length bytes from the bitstream
*/
ScStatus_t ScBSGetBytes(ScBitstream_t *BS, u_char *buffer, u_int length,
                                                 u_int *ret_length)
{
  int i, shift;
  unsigned int offset=0;
  _SlibDebug(_VERBOSE_, printf("ScBSGetBytes(%d): Byte offset = 0x%X\n",
                             length, ScBSBytePosition(BS)) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSGetBytes(%d) length==0\n", length) );

  if (BS->EOI)
  {
    *ret_length=0;
    return(ScErrorEndBitstream);
  }
  if (length<(SC_BITBUFFSZ>>3))
  {
    while (offset<length && !BS->EOI)
    {
      *(buffer+offset)=(unsigned char)ScBSGetBits(BS,8);
      offset++;
    }
    *ret_length=offset;
    if (BS->EOI)
      return(ScErrorEndBitstream);
    else
      return(ScErrorNone);
  }
  else if (BS->bufftop>0)
  {
    ScBSByteAlign(BS);
    shift=BS->shift;
    /* remove bytes already in OutBuff and InBuff */
    for (i=0; shift>0 && offset<length; i++, shift-=8, offset++)
    {
      *(buffer+offset)=(unsigned char)(BS->OutBuff>>(SC_BITBUFFSZ-8));
      if (shift<=SC_BITBUFFSZ) /* only bits in OutBuff */
        BS->OutBuff <<= 8;
      else
      {
        BS->OutBuff=(BS->OutBuff<<8)|(BS->InBuff>>(SC_BITBUFFSZ-8));
        BS->InBuff<<=8;
      }
    }
    BS->shift=shift;
    BS->CurrentBit+=i*8;
  }
  while (offset<length)
  {
    i=BS->bufftop-BS->buffp;
    if (offset+i>length)
      i=length-offset;
    memcpy(buffer+offset, BS->buff+BS->buffp, i);
    offset+=i;
    BS->buffp+=i;
    BS->CurrentBit+=i<<3;
    _SlibDebug(_VERIFY_,
         if ((BS->CurrentBit+BS->shift)/8!=BS->buffstart+BS->buffp)
         {
           printf("ScBSGetBytes() (CurrentBit+shift)/8 (%d) <> buffstart+buffp (%d)\n", (BS->CurrentBit+BS->shift)/8, BS->buffstart+BS->buffp);
           BS->EOI = TRUE;
           return(ScErrorEndBitstream);
         } );
    if (offset<length)
      if (!sc_BSGetData(BS))
      {
        BS->EOI = TRUE;
        *ret_length=offset;
        return(ScErrorEndBitstream);
      }
  }
  *ret_length=offset;
  return(ScErrorNone);
}

/*
** ScBSGetBits()
** Return the next length bits from the bitstream
*/
ScBitString_t ScBSGetBits(ScBitstream_t *BS, u_int length)
{
  ScBitString_t val;

  _SlibDebug(_DEBUG_ && _debug_getbits,
             printf("ScBSGetBits(%d): Byte offset = 0x%X shift=%d ",
                             length, ScBSBytePosition(BS), BS->shift) );
  _SlibDebug(_VERIFY_ && length>SC_BITBUFFSZ,
         printf("ScBSPeekBits(%d) length > SC_BITBUFFSZ\n", length) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSGetBits(%d) length==0\n", length) );

#if FILTER_SUPPORT
  if (BS->FilterCallback && BS->InFilterCallback==FALSE
      && BS->FilterBit<(BS->CurrentBit+length))
  {
    const int tmp=BS->FilterBit-BS->CurrentBit;
    BS->InFilterCallback=TRUE;
    _SlibDebug(_DEBUG_,
          printf("FilterCallback at bitpos=0x%X bytepos=0x%X GetBits(%d/%d)\n",
                  ScBSBitPosition(BS), ScBSBytePosition(BS),
                  tmp, length-tmp) );
    if (tmp>0)
    {
      length-=tmp;
      val=ScBSGetBits(BS,tmp)<<length;
    }
    else
      val=0;
    _SlibDebug(_VERIFY_ && (BS->FilterBit != BS->CurrentBit),
          printf("ScBSGetBits() FilterCallback not at FilterBit (%d) CurrentBit=%d\n", BS->FilterBit, BS->CurrentBit) );

    BS->FilterBit=(BS->FilterCallback)(BS);
    BS->InFilterCallback=FALSE;
  }
  else
    val=0;
  if (!length)
    return(val);
#else
  if (!length)
    return(0);
#endif
  ScBSPreLoad(BS, length);
  if (BS->shift<length) /* End of Input - ran out of bits */
  {
#if FILTER_SUPPORT
    val |= BS->OutBuff >> (SC_BITBUFFSZ-length); /* return whatever's there */
#else
    val = BS->OutBuff >> (SC_BITBUFFSZ-length); /* return whatever's there */
#endif
    BS->shift=0;
    BS->OutBuff=0;
    return(val);
  }
  else
  {
    _SlibDebug(_VERIFY_ && BS->shift<length,
     printf("ScBSGetBits(%d) shift (%d) < length (%d) at byte pos %d (0x%X)\n",
             length, BS->shift, length, BS->CurrentBit/8, BS->CurrentBit/8) );
    if (length!=SC_BITBUFFSZ)
    {
      const ScBitBuff_t OutBuff=BS->OutBuff;
      const ScBitString_t InBuff=BS->InBuff;
      const int shift=BS->shift;
#if FILTER_SUPPORT
      val |= OutBuff >> (SC_BITBUFFSZ-length);
#else
      val = OutBuff >> (SC_BITBUFFSZ-length);
#endif
      BS->OutBuff=(OutBuff<<length)|(InBuff>>(SC_BITBUFFSZ-length));
      BS->InBuff = InBuff<<length;
      BS->shift=shift-length;
      BS->CurrentBit += length;
    }
    else /* length == SC_BITBUFFSZ */
    {
      val = BS->OutBuff;
      BS->OutBuff = BS->InBuff;
      BS->InBuff = 0;
      BS->shift-=SC_BITBUFFSZ;
      BS->CurrentBit += SC_BITBUFFSZ;
    }
  }
  _SlibDebug(_DEBUG_ && _debug_getbits, printf(" Return 0x%lX\n",val) );
  return(val);
}

/*
** ScBSGetBitsW()
** Return the next length bits from the bitstream
*/
ScBitString_t ScBSGetBitsW(ScBitstream_t *BS, u_int length)
{
  ScBitString_t val;

  _SlibDebug(_DEBUG_ && _debug_getbits,
             printf("ScBSGetBitsW(%d): Byte offset = 0x%X shift=%d ",
                             length, ScBSBytePosition(BS), BS->shift) );
  _SlibDebug(_VERIFY_ && length>SC_BITBUFFSZ,
         printf("ScBSPeekBits(%d) length > SC_BITBUFFSZ\n", length) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSGetBitsW(%d) length==0\n", length) );

#if FILTER_SUPPORT
  if (BS->FilterCallback && BS->InFilterCallback==FALSE
      && BS->FilterBit<(BS->CurrentBit+length))
  {
    const int tmp=BS->FilterBit-BS->CurrentBit;
    BS->InFilterCallback=TRUE;
    _SlibDebug(_DEBUG_,
          printf("FilterCallback at bitpos=0x%X bytepos=0x%X GetBits(%d/%d)\n",
                  ScBSBitPosition(BS), ScBSBytePosition(BS),
                  tmp, length-tmp) );
    if (tmp>0)
    {
      length-=tmp;
      val=ScBSGetBitsW(BS,tmp)<<length;
    }
    else
      val=0;
    _SlibDebug(_VERIFY_ && (BS->FilterBit != BS->CurrentBit),
          printf("ScBSGetBits() FilterCallback not at FilterBit (%d) CurrentBit=%d\n", BS->FilterBit, BS->CurrentBit) );

    BS->FilterBit=(BS->FilterCallback)(BS);
    BS->InFilterCallback=FALSE;
  }
  else
    val=0;
  if (!length)
    return(val);
#else
  if (!length)
    return(0);
#endif
  ScBSPreLoadW(BS, length);
  if (BS->shift<length) /* End of Input - ran out of bits */
  {
#if FILTER_SUPPORT
    val |= BS->OutBuff >> (SC_BITBUFFSZ-length); /* return whatever's there */
#else
    val = BS->OutBuff >> (SC_BITBUFFSZ-length); /* return whatever's there */
#endif
    BS->shift=0;
    BS->OutBuff=0;
    return(val);
  }
  else
  {
    _SlibDebug(_VERIFY_ && BS->shift<length,
     printf("ScBSGetBits(%d) shift (%d) < length (%d) at byte pos %d (0x%X)\n",
             length, BS->shift, length, BS->CurrentBit/8, BS->CurrentBit/8) );
    if (length!=SC_BITBUFFSZ)
    {
      const ScBitBuff_t OutBuff=BS->OutBuff;
      const ScBitString_t InBuff=BS->InBuff;
      const int shift=BS->shift;
#if FILTER_SUPPORT
      val |= OutBuff >> (SC_BITBUFFSZ-length);
#else
      val = OutBuff >> (SC_BITBUFFSZ-length);
#endif
      BS->OutBuff=(OutBuff<<length)|(InBuff>>(SC_BITBUFFSZ-length));
      BS->InBuff = InBuff<<length;
      BS->shift=shift-length;
      BS->CurrentBit += length;
    }
    else /* length == SC_BITBUFFSZ */
    {
      val = BS->OutBuff;
      BS->OutBuff = BS->InBuff;
      BS->InBuff = 0;
      BS->shift-=SC_BITBUFFSZ;
      BS->CurrentBit += SC_BITBUFFSZ;
    }
  }
  _SlibDebug(_DEBUG_ && _debug_getbits, printf(" Return 0x%lX\n",val) );
  return(val);
}


/*
** ScBSGetBit()
** Put a single bit onto the bitstream
*/
int ScBSGetBit(ScBitstream_t *BS)
{
  int val;
  _SlibDebug(_DEBUG_ && _debug_getbits,
    printf("ScBSGetBit(): Byte offset = 0x%X shift=%d ",
                                         ScBSBytePosition(BS), BS->shift) );

#if FILTER_SUPPORT
  if (BS->FilterCallback && BS->InFilterCallback==FALSE
      && BS->FilterBit==BS->CurrentBit)
  {
    BS->InFilterCallback=TRUE;
    _SlibDebug(_DEBUG_,
          printf("FilterCallback at bitpos=0x%X bytepos=0x%X\n",
                  ScBSBitPosition(BS), ScBSBytePosition(BS)) );
    BS->FilterBit=(BS->FilterCallback)(BS);
    BS->InFilterCallback=FALSE;
  }
#endif

  ScBSPreLoad(BS, 1);
  if (!BS->EOI)
  {
    const ScBitBuff_t OutBuff=BS->OutBuff;
    val=(int)(OutBuff>>(SC_BITBUFFSZ-1));
    if (--BS->shift>=SC_BITBUFFSZ)
    {
      const ScBitBuff_t InBuff=BS->InBuff;
      BS->OutBuff = (OutBuff<<1)|(InBuff >> (SC_BITBUFFSZ-1));
      BS->InBuff = InBuff<<1;
    }
    else
      BS->OutBuff = OutBuff<<1;
    BS->CurrentBit++;
  }
  else
    val=0;
  _SlibDebug(_DEBUG_ && _debug_getbits, printf(" Return 0x%lX\n",val) );
  return(val);
}

/*
** ScBSPutBits()
** Put a number of bits onto the bitstream
*/
ScStatus_t ScBSPutBits(ScBitstream_t *BS, ScBitString_t bits, u_int length)
{
  ScStatus_t stat;
  const int newshift=BS->shift+length;

  if (length<SC_BITBUFFSZ)
    bits &= ((ScBitString_t)1<<length)-1;
  _SlibDebug(_DEBUG_, printf("ScBSPutBits(0x%lX, %d): Byte offset = 0x%X ",
                                       bits, length, ScBSBytePosition(BS)) );
  _SlibDebug(_VERIFY_&&length<SC_BITBUFFSZ && bits>=((ScBitString_t)1<<length),
            printf("ScBSPutBits(%d): bits (0x%X) to large\n", length, bits) );
  if (!length)
    return(NoErrors);
  else if (newshift < SC_BITBUFFSZ)
  {
    BS->OutBuff=(BS->OutBuff<<length) | bits;
    BS->shift=newshift;
    stat=NoErrors;
  }
  else if (newshift == SC_BITBUFFSZ)
  {
    stat=sc_BSStoreDataWord(BS, (BS->OutBuff<<length)|bits);
    BS->OutBuff=0;
    BS->shift=0;
  }
  else
  {
    const int bitsavail=SC_BITBUFFSZ-BS->shift;
    const int bitsleft=length-bitsavail;
    const ScBitString_t outbits=bits>>bitsleft;
    _SlibDebug(_DEBUG_, printf("ScBSPutBits(%d) Storing 0x%lX\n",
                               length, (BS->OutBuff<<bitsavail)|outbits) );
    stat=sc_BSStoreDataWord(BS, (BS->OutBuff<<bitsavail)|outbits);
    _SlibDebug(_VERIFY_ && (bitsavail<=0 || bitsleft>=SC_BITBUFFSZ),
               printf("ScBSPutBits(%d) bad bitsleft (%d)\n",
               bitsleft) );
    _SlibDebug(_VERIFY_ && (bitsavail<=0 || bitsavail>=SC_BITBUFFSZ),
               printf("ScBSPutBits(%d) bad bitsavail (%d)\n", bitsavail) );
#if 1
    BS->OutBuff=bits & (((ScBitBuff_t)1<<bitsleft)-1);
#else
    BS->OutBuff=bits-(outbits<<bitsleft);
#endif
    BS->shift=bitsleft;
  }
  BS->CurrentBit += length;
  return(stat);
}

/*
** ScBSPutBytes()
** Put a number of bits onto the bitstream
*/
ScStatus_t ScBSPutBytes(ScBitstream_t *BS, u_char *buffer, u_int length)
{
  ScStatus_t stat=NoErrors;
  _SlibDebug(_VERIFY_, printf("ScBSPutBytes(length=%d): Byte offset = 0x%X ",
                                        length, ScBSBytePosition(BS)) );

  while (stat==NoErrors && length>0)
  {
    stat=ScBSPutBits(BS, (ScBitString_t)*buffer, 8);
    buffer++;
    length--;
  }
  return(stat);
}

/*
** ScBSPutBit()
** Put a single bit onto the bitstream
*/
ScStatus_t ScBSPutBit(ScBitstream_t *BS, char bit)
{
  ScStatus_t stat;
  const int shift=BS->shift;

  _SlibDebug(_DEBUG_, printf("ScBSPutBit(0x%lX): Byte offset = 0x%X ",
                                                bit, ScBSBytePosition(BS)) );
  _SlibDebug(_VERIFY_ && bit>1, printf("ScBSPutBit(): bit>1") );
  if (shift < (SC_BITBUFFSZ-1))
  {
    BS->OutBuff<<=1;
    if (bit)
      BS->OutBuff|=1;
    BS->shift=shift+1;
    stat=NoErrors;
  }
  else if (shift == SC_BITBUFFSZ-1)
  {
    if (bit)
      stat=sc_BSStoreDataWord(BS, (BS->OutBuff<<1)+1);
    else
      stat=sc_BSStoreDataWord(BS, BS->OutBuff<<1);
    BS->OutBuff=0;
    BS->shift=0;
  }
  else
  {
    _SlibDebug(_DEBUG_, printf("BS Storing(0x%lX)\n", BS->OutBuff) );
    stat=sc_BSStoreDataWord(BS, BS->OutBuff);
    BS->OutBuff=bit;
    BS->shift=1;
  }
  BS->CurrentBit++;
  return(stat);
}

/*
** Name:    ScBSGetBitsVarLen()
** Purpose: Return bits from the bitstream. # bits depends on table
*/
int ScBSGetBitsVarLen(ScBitstream_t *BS, const int *table, int len)
{
  int index, lookup;

  index=(int)ScBSPeekBits(BS, len);
  lookup = table[index];
  _SlibDebug(_DEBUG_,
     printf("ScBSGetBitsVarLen(len=%d): Byte offset=0x%X table[%d]=0x%X Return=%d\n",
                      len, ScBSBytePosition(BS), index, lookup, lookup >> 6) );
  ScBSGetBits(BS, lookup & 0x3F);
  return(lookup >> 6);
}


#ifndef ScBSBitPosition
/* Now is a macro in SC.h */
/*
** Name:    ScBSBitPosition()
** Purpose: Return the absolute bit position in the stream
*/
long ScBSBitPosition(ScBitstream_t *BS)
{
  return(BS->CurrentBit);
}
#endif

#ifndef ScBSBytePosition
/* Now is a macro in SC.h */
/*
** Name:    ScBSBytePosition()
** Purpose: Return the absolute byte position in the stream
*/
long ScBSBytePosition(ScBitstream_t *BS)
{
  return(BS->CurrentBit>>3);
}
#endif

/*
** Name:    ScBSSeekAlign()
** Purpose: Seeks for a byte aligned word in the bit stream
**          and places the bit stream pointer right after its
**          found position.
** Return:  Returns TRUE if the sync was found otherwise it returns FALSE.
*/
int ScBSSeekAlign(ScBitstream_t *BS, ScBitString_t seek_word, int word_len)
{
  _SlibDebug(_VERBOSE_,
            printf("ScBSSeekAlign(BS=%p, seek_word=0x%x, word_len=%d)\n",
                                    BS, seek_word, word_len) );
  _SlibDebug(_VERIFY_ && !word_len,
              printf("ScBSSeekAlign(BS=%p) word_len=0\n", BS) );

  ScBSByteAlign(BS)
  _SlibDebug(_VERIFY_, _debug_start=BS->CurrentBit );

#if USE_FAST_SEEK
  if (word_len%8==0 && word_len<=32 && !BS->EOI)  /* do a fast seek */
  {
    unsigned char *buff, nextbyte;
    const unsigned char byte1=(seek_word>>(word_len-8))&0xFF;
    int bytesinbuff;
    seek_word-=((ScBitString_t)byte1)<<word_len;
    word_len-=8;
    _SlibDebug(_VERIFY_ && seek_word >= (ScBitString_t)1<<word_len,
       printf("ScBSSeekAlign(BS=%p) shift (%d) <> 0\n", BS, BS->shift) );
    if (BS->buffp>=(BS->shift/8)) /* empty OutBuff & InBuff */
    {
      BS->shift=0;
      BS->OutBuff=0;
      BS->InBuff=0;
      BS->buffp-=BS->shift/8;
    }
    else while (BS->shift) /* search whats in OutBuff & InBuff first */
    {
      _SlibDebug(_DEBUG_,
              printf("ScBSSeekAlign() Fast searching OutBuff & InBuff\n") );
      nextbyte=BS->OutBuff>>(SC_BITBUFFSZ-8);
      BS->shift-=8;
      BS->OutBuff=(BS->OutBuff<<8)|(BS->InBuff>>(SC_BITBUFFSZ-8));
      BS->InBuff<<=8;
      BS->CurrentBit+=8;
      if (nextbyte==byte1
            && (word_len==0 || ScBSPeekBits(BS, word_len)==seek_word))
      {
        /* found seek_word in buffer */
        ScBSSkipBits(BS, word_len);
        return(!BS->EOI);
      }
    }
    _SlibDebug(_VERIFY_ && BS->shift,
       printf("ScBSSeekAlign(BS=%p) shift (%d) <> 0\n", BS, BS->shift) );
    _SlibDebug(_VERIFY_ && BS->OutBuff,
       printf("ScBSSeekAlign(BS=%p) OutBuff (0x%lX) <> 0\n", BS, BS->OutBuff) );
    _SlibDebug(_VERIFY_ && BS->InBuff,
       printf("ScBSSeekAlign(BS=%p) InBuff (0x%lX) <> 0\n", BS, BS->InBuff) );

    bytesinbuff=BS->bufftop-BS->buffp;
    if (bytesinbuff<=0) /* Get more data if all out */
    {
      if (!sc_BSGetData(BS))
      {
        BS->EOI=TRUE;
        return(FALSE);
      }
      bytesinbuff=BS->bufftop;
    }
    buff=BS->buff+BS->buffp;
    switch (word_len/8)
    {
      case 0: /* word length = 1 byte */
              while (1)
              {
                if (*buff++==byte1)
                {
                  BS->buffp=buff-BS->buff;
                  BS->CurrentBit=(BS->buffstart+BS->buffp)*8;
                  _SlibDebug(_DEBUG_,
                    printf("ScBSSeekAlign() Found %X at pos %d (0x%X)\n",
                                 byte1, BS->CurrentBit/8, BS->CurrentBit/8) );
                  _SlibDebug(_VERIFY_ && BS->buff[BS->buffp-1]!=byte1,
                    printf("ScBSSeekAlign() bad position for buffp\n") );
                  return(TRUE);
                }
                if ((--bytesinbuff)==0)
                {
                  if (!sc_BSGetData(BS))
                  {
                    BS->EOI=TRUE;
                    return(FALSE);
                  }
                  buff=BS->buff;
                  bytesinbuff=BS->bufftop;
                }
                  _SlibDebug(_VERIFY_ && bytesinbuff<=0,
                printf("ScBSSeekAlign() bytesinbuff (%d)<=0\n", bytesinbuff) );
              }
              break;
      case 1: /* word length = 2 bytes */
              {
                const unsigned char byte2=seek_word&0xFF;
                while (1)
                {
                  if (*buff++==byte1)
                  {
                    if ((--bytesinbuff)==0)
                    {
                      BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                      if (!sc_BSGetData(BS))
                      {
                        BS->EOI=TRUE;
                        return(FALSE);
                      }
                      buff=BS->buff;
                      bytesinbuff=BS->bufftop;
                    }
                    if (*buff++==byte2)
                    {
                      BS->buffp=buff-BS->buff;
                      BS->CurrentBit=(BS->buffstart+BS->buffp)*8;
                      _SlibDebug(_DEBUG_,
                       printf("ScBSSeekAlign() Found %X %X at pos %d (0x%X)\n",
                            byte1, byte2, BS->CurrentBit/8, BS->CurrentBit/8) );
                      _SlibDebug(_VERIFY_ && BS->buff[BS->buffp-1]!=byte2,
                         printf("ScBSSeekAlign() bad position for buffp\n") );
                      return(TRUE);
                    }
                  }
                  if ((--bytesinbuff)==0)
                  {
                    BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                    if (!sc_BSGetData(BS))
                    {
                      BS->EOI=TRUE;
                      return(FALSE);
                    }
                    buff=BS->buff;
                    bytesinbuff=BS->bufftop;
                  }
                  _SlibDebug(_VERIFY_ && bytesinbuff<=0,
                printf("ScBSSeekAlign() bytesinbuff (%d)<=0\n", bytesinbuff) );
                }
              }
              break;
      case 2: /* word length = 3 bytes */
              {
                const unsigned char byte2=(seek_word>>8)&0xFF;
                const unsigned char byte3=seek_word&0xFF;
                while (1)
                {
                  if (*buff++==byte1)
                  {
                    if ((--bytesinbuff)==0)
                    {
                      BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                      if (!sc_BSGetData(BS))
                      {
                        BS->EOI=TRUE;
                        return(FALSE);
                      }
                      buff=BS->buff;
                      bytesinbuff=BS->bufftop;
                    }
                    if (*buff++==byte2)
                    {
                      if ((--bytesinbuff)==0)
                      {
                        BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                        if (!sc_BSGetData(BS))
                        {
                          BS->EOI=TRUE;
                          return(FALSE);
                        }
                        buff=BS->buff;
                        bytesinbuff=BS->bufftop;
                      }
                      if (*buff++==byte3)
                      {
                        BS->buffp=buff-BS->buff;
                        BS->CurrentBit=(BS->buffstart+BS->buffp)*8;
                      _SlibDebug(_DEBUG_,
                    printf("ScBSSeekAlign() Found %X %X %X at pos %d (0x%X)\n",
                                 byte1, byte2, byte3,
                                 BS->CurrentBit/8, BS->CurrentBit/8) );
                        _SlibDebug(_VERIFY_ && BS->buff[BS->buffp-1]!=byte3,
                           printf("ScBSSeekAlign() bad position for buffp\n") );
                        return(TRUE);
                      }
                    }
                  }
                  if ((--bytesinbuff)==0)
                  {
                    BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                    if (!sc_BSGetData(BS))
                    {
                      BS->EOI=TRUE;
                      return(FALSE);
                    }
                    buff=BS->buff;
                    bytesinbuff=BS->bufftop;
                  }
                  _SlibDebug(_VERIFY_ && bytesinbuff<=0,
                printf("ScBSSeekAlign() bytesinbuff (%d)<=0\n", bytesinbuff) );
                }
              }
              break;
      case 3: /* word length = 4 bytes */
              {
                const unsigned char byte2=(seek_word>>16)&0xFF;
                const unsigned char byte3=(seek_word>>8)&0xFF;
                const unsigned char byte4=seek_word&0xFF;
                while (1)
                {
                  if (*buff++==byte1)
                  {
                    if ((--bytesinbuff)==0)
                    {
                      BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                      if (!sc_BSGetData(BS))
                      {
                        BS->EOI=TRUE;
                        return(FALSE);
                      }
                      buff=BS->buff;
                      bytesinbuff=BS->bufftop;
                    }
                    if (*buff++==byte2)
                    {
                      if ((--bytesinbuff)==0)
                      {
                        BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                        if (!sc_BSGetData(BS))
                        {
                          BS->EOI=TRUE;
                          return(FALSE);
                        }
                        buff=BS->buff;
                        bytesinbuff=BS->bufftop;
                      }
                      if (*buff++==byte3)
                      {
                        if ((--bytesinbuff)==0)
                        {
                          BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                          if (!sc_BSGetData(BS))
                          {
                            BS->EOI=TRUE;
                            return(FALSE);
                          }
                          buff=BS->buff;
                          bytesinbuff=BS->bufftop;
                        }
                        if (*buff++==byte4)
                        {
                          BS->buffp=buff-BS->buff;
                          BS->CurrentBit=(BS->buffstart+BS->buffp)*8;
                          _SlibDebug(_DEBUG_,
                 printf("ScBSSeekAlign() Found %X %X %X %X at pos %d (0x%X)\n",
                                 byte1, byte2, byte3, byte4,
                                 BS->CurrentBit/8, BS->CurrentBit/8) );
                          _SlibDebug(_VERIFY_ && BS->buff[BS->buffp-1]!=byte4,
                           printf("ScBSSeekAlign() bad position for buffp\n") );
                          return(TRUE);
                        }
                      }
                    }
                  }
                  if ((--bytesinbuff)==0)
                  {
                    BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                    if (!sc_BSGetData(BS))
                    {
                      BS->EOI=TRUE;
                      return(FALSE);
                    }
                    buff=BS->buff;
                    bytesinbuff=BS->bufftop;
                  }
                  _SlibDebug(_VERIFY_ && bytesinbuff<=0,
                printf("ScBSSeekAlign() bytesinbuff (%d)<=0\n", bytesinbuff) );
                }
              }
              break;
       default:
              _SlibDebug(_VERIFY_,
                printf("ScBSSeekAlign() Bad fast word length %d\n", word_len) );
              break;
    }
  }
  else
#endif
  {  /* a slow seek */
    ScBitString_t val;
    const ScBitString_t maxi = ((ScBitString_t)1 << word_len)-(ScBitString_t)1;
    val = ScBSGetBits(BS, word_len);
    _SlibDebug(_DEBUG_, _debug_getbits=FALSE );
    while ((val&maxi)!=seek_word && !BS->EOI)
      val = (val<<8)|ScBSGetBits(BS, 8);
    _SlibDebug(_DEBUG_, _debug_getbits=TRUE );
  }
  _SlibDebug(_WARN_,
            _debug_stop=BS->CurrentBit;
            if ((_debug_stop-_debug_start)>word_len)
              printf("ScBSSeekAlign() Moved %d bits (%d bytes) byte pos 0x%X->0x%X\n",
                   _debug_stop-_debug_start, (_debug_stop-_debug_start)/8,
                   _debug_start/8, _debug_stop/8)
             );

  _SlibDebug(_DEBUG_, printf("ScBSSeekAlign() Exit with %s\n",
                                  BS->EOI ? "FALSE" : "TRUE") );
  return(!BS->EOI);
}

/*
** Name:    ScBSSeekAlignStopAt()
** Purpose: Seeks for a byte aligned word in the bit stream
**          and places the bit stream pointer right after its
**          found position.
**          Searches only until end_byte_pos is reached.
** Return:  Returns TRUE if the word was found otherwise it returns FALSE.
*/
int ScBSSeekAlignStopAt(ScBitstream_t *BS, ScBitString_t seek_word,
                        int word_len, unsigned long end_byte_pos)
{
  ScBSPosition_t end_bit_pos=end_byte_pos<<3;
  ScBitString_t val;
  const ScBitString_t maxi = ((ScBitString_t)1 << word_len) - 1;

  _SlibDebug(_VERBOSE_,
       printf("ScBSSeekAlignStopAt(seek_word=0x%x, word_len=%d, end=%d)\n",
                                      seek_word, word_len, end_byte_pos) );
  if (ScBSBytePosition(BS)>=end_byte_pos)
    return(FALSE);

  ScBSByteAlign(BS)
  if (ScBSBytePosition(BS)>=end_byte_pos)
    return(FALSE);
  if ((BS->CurrentBit+word_len)>end_bit_pos)
  {
    ScBSSkipBits(BS, (unsigned int)(end_bit_pos-BS->CurrentBit));
    return(FALSE);
  }
  val = ScBSGetBits(BS, word_len);
  _SlibDebug(_DEBUG_, _debug_getbits=FALSE );
  while ((val&maxi)!=seek_word && !BS->EOI)
  {
    if ((BS->CurrentBit+word_len)>end_bit_pos)
    {
      ScBSSkipBits(BS, (unsigned int)(end_bit_pos-BS->CurrentBit));
      _SlibDebug(_DEBUG_, _debug_getbits=TRUE );
      return(FALSE);
    }
    val <<= 8;
    val |= ScBSGetBits(BS, 8);
  }
  _SlibDebug(_DEBUG_, _debug_getbits=TRUE );

  _SlibDebug(_DEBUG_, printf("ScBSSeekAlignStopAt() Exit with %s\n",
                                       BS->EOI ? "FALSE" : "TRUE") );
  return(!BS->EOI);
}

/*
** Name:    ScBSSeekAlignStopBefore()
** Purpose: Seeks for a byte aligned word in the bit stream,
**          if found, places the bit stream pointer right at the beginning
**          of the word.
** Return:  Returns TRUE if the word was found otherwise it returns FALSE.
*/
int ScBSSeekAlignStopBefore(ScBitstream_t *BS, ScBitString_t seek_word,
                                               int word_len)
{
  const int iword_len=SC_BITBUFFSZ-word_len;

  _SlibDebug(_VERBOSE_,
             printf("ScBSSeekAlignStopBefore(seek_word=0x%x, word_len=%d)\n",
                                      seek_word, word_len) );
  _SlibDebug(_VERIFY_ && !word_len,
              printf("ScBSSeekAlignStopBefore() word_len=0\n") );

  ScBSByteAlign(BS)
  _SlibDebug(_VERIFY_, _debug_start=BS->CurrentBit );
  _SlibDebug(_DEBUG_, _debug_getbits=FALSE );
  /* make sure there's at least word_len bits in OutBuff */
  ScBSPreLoad(BS, word_len);
  while ((BS->OutBuff>>iword_len)!=seek_word && !BS->EOI)
  {
    ScBSSkipBits(BS, 8);
    ScBSPreLoad(BS, word_len);
  }
  _SlibDebug(_DEBUG_, _debug_getbits=TRUE );
  _SlibDebug(_WARN_,
           _debug_stop=BS->CurrentBit;
           if ((_debug_stop-_debug_start)>word_len)
             printf("ScBSSeekAlignStopBefore() Moved %d bits (%d bytes) byte pos 0x%X->0x%X\n",
                   _debug_stop-_debug_start, (_debug_stop-_debug_start)/8,
                   _debug_start/8, _debug_stop/8)
            );

  _SlibDebug(_DEBUG_, printf("ScBSSeekAlignStopBefore() Exit with %s\n",
                                   BS->EOI ? "FALSE" : "TRUE") );
  return(!BS->EOI);
}

/*
** Name:    ScBSSeekStopBefore()
** Purpose: Seeks for a word in the bit stream,
**          if found, places the bit stream pointer right at the beginning
**          of the word.
** Return:  Returns TRUE if the word was found otherwise it returns FALSE.
*/
int ScBSSeekStopBefore(ScBitstream_t *BS, ScBitString_t seek_word, 
                                               int word_len)
{
  const int iword_len=SC_BITBUFFSZ-word_len;

  _SlibDebug(_VERBOSE_, 
             printf("ScBSSeekStopBefore(seek_word=0x%x, word_len=%d)\n",
                                      seek_word, word_len) );
  _SlibDebug(_VERIFY_ && !word_len,  
              printf("ScBSSeekStopBefore() word_len=0\n") );

  _SlibDebug(_VERIFY_, _debug_start=BS->CurrentBit );
  _SlibDebug(_DEBUG_, _debug_getbits=FALSE );
  /* make sure there's at least word_len bits in OutBuff */
  ScBSPreLoad(BS, word_len);
  while ((BS->OutBuff>>iword_len)!=seek_word && !BS->EOI)
  {
    ScBSSkipBits(BS, 1);
    ScBSPreLoad(BS, word_len);
  }
  _SlibDebug(_DEBUG_, _debug_getbits=TRUE );
  _SlibDebug(_WARN_, 
           _debug_stop=BS->CurrentBit;
           if ((_debug_stop-_debug_start)>word_len)
             printf("ScBSSeekAlignStopBefore() Moved %d bits (%d bytes) byte pos 0x%X->0x%X\n",
                   _debug_stop-_debug_start, (_debug_stop-_debug_start)/8,
                   _debug_start/8, _debug_stop/8)
            );

  _SlibDebug(_DEBUG_, printf("ScBSSeekStopBefore() Exit with %s\n",
                                   BS->EOI ? "FALSE" : "TRUE") );
  return(!BS->EOI);
}

/*
** Name:    ScBSSeekAlignStopBeforeW()
** Purpose: Seeks for a byte aligned word in the bit stream,
**          if found, places the bit stream pointer right at the beginning
**          of the word.
** Return:  Returns TRUE if the word was found otherwise it returns FALSE.
**
** NB: This version uses Dolby style word loading for bitstream
*/
int ScBSSeekAlignStopBeforeW(ScBitstream_t *BS, ScBitString_t seek_word,
                                               int word_len)
{
  const int iword_len=SC_BITBUFFSZ-word_len;

  _SlibDebug(_VERBOSE_,
             printf("ScBSSeekAlignStopBeforeW(seek_word=0x%x, word_len=%d)\n",
                                      seek_word, word_len) );
  _SlibDebug(_VERIFY_ && !word_len,
              printf("ScBSSeekAlignStopBeforeW() word_len=0\n") );

  ScBSByteAlign(BS)
  _SlibDebug(_VERIFY_, _debug_start=BS->CurrentBit );
  _SlibDebug(_DEBUG_, _debug_getbits=FALSE );
  /* make sure there's at least word_len bits in OutBuff */
  ScBSPreLoadW(BS, word_len);
  while ((BS->OutBuff>>iword_len)!=seek_word && !BS->EOI)
  {
    ScBSSkipBitsW(BS, 8);
    ScBSPreLoadW(BS, word_len);
  }
  _SlibDebug(_DEBUG_, _debug_getbits=TRUE );
  _SlibDebug(_WARN_,
           _debug_stop=BS->CurrentBit;
           if ((_debug_stop-_debug_start)>word_len)
             printf("ScBSSeekAlignStopBeforeW() Moved %d bits (%d bytes) byte pos 0x%X->0x%X\n",
                   _debug_stop-_debug_start, (_debug_stop-_debug_start)/8,
                   _debug_start/8, _debug_stop/8)
            );

  _SlibDebug(_DEBUG_, printf("ScBSSeekAlignStopBeforeW() Exit with %s\n",
                                   BS->EOI ? "FALSE" : "TRUE") );
  return(!BS->EOI);
}

/*
** Name:    ScBSGetBytesStopBefore()
** Purpose: Gets all the bytes until seek_word (byte aligned)
**          is encountered.
**          Searches only until 'length' bytes are read.
** Return:  Returns TRUE if the word was found otherwise it returns FALSE.
*/
int ScBSGetBytesStopBefore(ScBitstream_t *BS, u_char *buffer, u_int length,
                           u_int *ret_length, ScBitString_t seek_word,
                           int word_len)
{
  unsigned long offset=0;
  const int iword_len=SC_BITBUFFSZ-word_len;

  _SlibDebug(_VERBOSE_,
             printf("ScBSGetBytesStopBefore(seek_word=0x%x, word_len=%d)\n",
                                       seek_word, word_len) );
  ScBSByteAlign(BS)
  ScBSPreLoad(BS, word_len);
  while ((BS->OutBuff>>iword_len) != seek_word &&
             offset<length && !BS->EOI)
  {
    *buffer = (unsigned char)ScBSGetBits(BS, 8);
    buffer++;
    offset++;
    ScBSPreLoad(BS, word_len);
  }

  *ret_length=offset;
  _SlibDebug(_DEBUG_,
             printf("ScBSGetBytesStopBefore(ret_length=%d) Exit with %s\n",
               *ret_length, (BS->EOI||offset>=length) ? "FALSE" : "TRUE") );
  if (BS->EOI || offset>=length)
    return(FALSE);
  else
    return(TRUE);
}

/*
** Name:    ScBSFlush()
** Purpose: Flushes data from the buffers
*/
ScStatus_t ScBSFlush(ScBitstream_t *BS)
{
  ScStatus_t stat=NoErrors;
  _SlibDebug(_VERBOSE_, printf("ScBSFlush() In\n") );
  if (!BS)
    return(ScErrorBadPointer);

  if ((BS->Mode=='w' || BS->Mode=='b') && BS->buffp>0)
  {
    if (BS->shift>0) /* some remaining bits in internal buffers */
    {
      /* byte align last bits */
      ScBSAlignPutBits(BS);
      if (BS->buffp>=BS->bufftop)
        stat=sc_BSPutData(BS);
      /* Copy the remaining bytes in OutBuff to the current buffer */
      while (BS->shift>0 && BS->buffp<BS->bufftop)
      {
        BS->shift-=8;
        BS->buff[BS->buffp++]=(unsigned char)(BS->OutBuff>>BS->shift);
      }
      stat=sc_BSPutData(BS);
      if (BS->shift>0) /* still some bytes left */
      {
        while (BS->shift>0 && BS->buffp<BS->bufftop)
        {
          BS->shift-=8;
          BS->buff[BS->buffp++]=(unsigned char)(BS->OutBuff>>BS->shift);
        }
        stat=sc_BSPutData(BS);
      }
    }
    else
      stat=sc_BSPutData(BS);
  }
  ScBSReset(BS);  /* release and re-initialize buffer pointers */
  _SlibDebug(_VERBOSE_, printf("ScBSFlush() Out\n") );
  return(stat);
}

/*
** Name:    ScBSResetCounters()
** Purpose: Resets the bit position counters to zero
*/
ScStatus_t ScBSResetCounters(ScBitstream_t *BS)
{
  if (!BS)
    return(ScErrorBadPointer);
  BS->CurrentBit=0;
  return(NoErrors);
}

/*
** Name:    ScBSFlushSoon()
** Purpose: Flushes data from the buffers at the next
**          32 or 64 bit boundary
*/
ScStatus_t ScBSFlushSoon(ScBitstream_t *BS)
{
  ScStatus_t stat=NoErrors;
  _SlibDebug(_VERBOSE_, printf("ScBSFlushSoon()\n") );
  if (!BS)
    return(ScErrorBadPointer);

  if (BS->Mode=='w' || BS->Mode=='b')
    BS->Flush=TRUE;
  return(stat);
}

/*
** Name:    ScBSDestroy()
** Purpose: Destroys a bitstream (Closes and frees associated memory)
**          created using ScBSCreateFromBufferQueue() or
**          ScBSCreateFromFile()
*/
ScStatus_t ScBSDestroy(ScBitstream_t *BS)
{
  ScStatus_t stat=NoErrors;
  _SlibDebug(_VERBOSE_, printf("ScBSDestroy\n") );
  if (!BS)
    return(ScErrorBadPointer);

/* We won't flush automatically
  if (BS->Mode=='w' || BS->Mode=='b')
    ScBSFlush(BS);
*/
  if (BS->RdBufAllocated)
    ScFree(BS->RdBuf);
  ScFree(BS);
  return(stat);
}

/*********************** Buffer/Image Queue Management ***********************/
/*                                                                           */
/* ScBufQueueCreate()  - Create a buffer queue                               */
/* ScBufQueueDestroy() - Destroy a buffer queue                              */
/* ScBufQueueAdd()     - Add a buffer to tail of a queue                     */
/* ScBufQueueRemove()  - Remove the buffer at the head of a queue            */
/* ScBufQueueGetNum()  - Return number of buffers in a queue                 */
/* ScBufQueueGetHead() - Return info about buffer at head of a queue         */
/*                                                                           */
/*****************************************************************************/


ScStatus_t ScBufQueueCreate(ScQueue_t **Q)
{
  if ((*Q = (ScQueue_t *)ScAlloc(sizeof(ScQueue_t))) == NULL)
    return(ScErrorMemory);
  (*Q)->NumBufs = 0;
  (*Q)->head = (*Q)->tail = NULL;
  _SlibDebug(_QUEUE_, printf("ScBufQueueCreate() Q=%p\n",*Q) );
  return(NoErrors);
}

ScStatus_t ScBufQueueDestroy(ScQueue_t *Q)
{
  _SlibDebug(_QUEUE_, printf("ScBufQueueDestroy(Q=%p)\n",Q) );
  if (!Q)
    return(ScErrorBadArgument);
  _SlibDebug(_QUEUE_, printf("ScBufQueueDestroy()\n") );

  while (ScBufQueueGetNum(Q))
    ScBufQueueRemove(Q);

  ScFree(Q);
  return(NoErrors);
}

ScStatus_t ScBufQueueAdd(ScQueue_t *Q, u_char *Data, int Size)
{
  struct ScBuf_s *b;

  if (!Q)
    return(ScErrorBadPointer);

  if ((b = (struct ScBuf_s *)ScAlloc(sizeof(struct ScBuf_s))) == NULL)
    return(ScErrorMemory);

  _SlibDebug(_QUEUE_, printf("ScBufQueueAdd(Q=%p, Data=0x%p, Size=%d)\n",
                                   Q,Data,Size) );
  b->Data = Data;
  b->Size = Size;
  b->Prev = NULL;

  if (!Q->tail)
    Q->tail = Q->head = b;
  else {
    Q->tail->Prev = b;
    Q->tail = b;
  }
  Q->NumBufs++;
  return(NoErrors);
}

ScStatus_t ScBufQueueAddExt(ScQueue_t *Q, u_char *Data, int Size, int Type)
{
  struct ScBuf_s *b;

  if (!Q)
    return(ScErrorBadPointer);

  if ((b = (struct ScBuf_s *)ScAlloc(sizeof(struct ScBuf_s))) == NULL)
    return(ScErrorMemory);

  _SlibDebug(_QUEUE_, printf("ScBufQueueAdd(Q=%p, Data=0x%p, Size=%d)\n",
                                   Q,Data,Size) );
  b->Data = Data;
  b->Size = Size;
  b->Type = Type;
  b->Prev = NULL;

  if (!Q->tail)
    Q->tail = Q->head = b;
  else {
    Q->tail->Prev = b;
    Q->tail = b;
  }
  Q->NumBufs++;
  return(NoErrors);
}

ScStatus_t ScBufQueueRemove(ScQueue_t *Q)
{
  struct ScBuf_s *head;
  _SlibDebug(_QUEUE_, printf("ScBufQueueRemove(Q=%p)\n",Q) );

  if (!Q)
    return(ScErrorBadPointer);

  if (!(head = Q->head))
    return(ScErrorBadQueueEmpty);

  _SlibDebug(_QUEUE_, printf("ScBufQueueRemove() Data=%p Size=%d\n",
                            Q->head->Data,Q->head->Size) );
  Q->head = head->Prev;
  if (!Q->head)
    Q->tail = NULL;
  Q->NumBufs--;
  ScFree(head);
  return(NoErrors);
}

int ScBufQueueGetNum(ScQueue_t *Q)
{
  _SlibDebug(_QUEUE_, printf("ScBufQueueGetNum(Q=%p) num=%d\n",
                             Q, Q ? Q->NumBufs : 0) );
  return(Q ? Q->NumBufs : 0);
}

ScStatus_t ScBufQueueGetHead(ScQueue_t *Q, u_char **Data, int *Size)
{
  if (!Q || !Q->head) {
    if (Data) *Data = NULL;
    if (Size) *Size = 0;
    return(NoErrors);
  }
  _SlibDebug(_QUEUE_, printf("ScBufQueueGetHead() Data=%p Size=%d\n",
                               Q->head->Data,Q->head->Size) );
  if (Data) *Data = Q->head->Data;
  if (Size) *Size = Q->head->Size;
  return(NoErrors);
}

ScStatus_t ScBufQueueGetHeadExt(ScQueue_t *Q, u_char **Data, int *Size,
                                 int *Type)
{
  if (!Q || !Q->head) {
    if (Data) *Data = NULL;
    if (Size) *Size = 0;
    if (Type) *Type = 0;
    return(NoErrors);
  }
  _SlibDebug(_QUEUE_, printf("ScBufQueueGetHeadExt() Data=%p Size=%d Type=%d\n",
                               Q->head->Data,Q->head->Size,Q->head->Type) );
  if (Data) *Data = Q->head->Data;
  if (Size) *Size = Q->head->Size;
  if (Type) *Type = Q->head->Type;
  return(NoErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sc_conv.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_convert.c,v $
 * Revision 1.1.8.6  1996/10/28  17:32:17  Hans_Graves
 * 	Add use IsYUV422Sep() macro in ScConvertSepYUVToOther().
 * 	[1996/10/28  16:51:30  Hans_Graves]
 *
 * Revision 1.1.8.5  1996/10/02  18:42:50  Hans_Graves
 * 	Fix RGB 24-bit conversion in ScYuv411ToRgb().
 * 	[1996/10/02  18:32:51  Hans_Graves]
 *
 * Revision 1.1.8.4  1996/09/29  22:19:32  Hans_Graves
 * 	Added stride support to ScYuv411ToRgb()
 * 	[1996/09/29  21:27:17  Hans_Graves]
 *
 * Revision 1.1.8.3  1996/09/18  23:45:34  Hans_Graves
 * 	Added ScConvert1611PlanarTo411_C, ScConvert411sTo422s_C, and ScRgbToYuv411
 * 	[1996/09/18  21:52:27  Hans_Graves]
 *
 * Revision 1.1.8.2  1996/05/07  19:55:42  Hans_Graves
 * 	Added YUV 4:1:1 to RGB 32-bit conversion - C code
 * 	[1996/05/07  19:44:38  Hans_Graves]
 *
 * Revision 1.1.6.4  1996/04/11  20:21:57  Hans_Graves
 * 	Moved ScIsUpsideDown() from sc_convert_yuv.c
 * 	[1996/04/11  20:03:44  Hans_Graves]
 *
 * Revision 1.1.6.3  1996/04/09  16:04:24  Hans_Graves
 * 	Added ValidateBI_BITFIELDS(). Fixed BI_RGB 16 bit conversion in ScYuv411ToRgb()
 * 	[1996/04/09  14:46:27  Hans_Graves]
 *
 * Revision 1.1.6.2  1996/04/03  21:41:07  Hans_Graves
 * 	Change include path for <mmsystems.h>
 * 	[1996/04/03  21:37:55  Hans_Graves]
 *
 * Revision 1.1.4.4  1996/02/22  17:35:17  Bjorn_Engberg
 * 	Added support for BI_BITFIELDS 16 and BI_RGB 32 rendering.
 * 	[1996/02/22  17:31:35  Bjorn_Engberg]
 *
 * Revision 1.1.4.3  1996/01/02  18:30:33  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added Casts
 * 	[1996/01/02  15:21:27  Bjorn_Engberg]
 *
 * Revision 1.1.4.2  1995/12/07  19:31:15  Hans_Graves
 * 	Added ScConvert422PlanarTo411_C()
 * 	[1995/12/07  17:44:00  Hans_Graves]
 *
 * Revision 1.1.2.21  1995/11/30  20:17:02  Hans_Graves
 * 	Cleaned up ScYuv422toRgb() routine
 * 	[1995/11/30  20:13:26  Hans_Graves]
 *
 * Revision 1.1.2.20  1995/11/28  22:47:28  Hans_Graves
 * 	Make XIMAGE 24 identical to BI_BITFIELDS pBGR
 * 	[1995/11/28  22:26:11  Hans_Graves]
 *
 * 	Added ScYuv1611ToRgb() routine for use by Indeo
 * 	[1995/11/28  21:34:28  Hans_Graves]
 *
 * Revision 1.1.2.19  1995/11/17  21:31:21  Hans_Graves
 * 	Add ScYuv411ToRgb() conversion routine.
 * 	[1995/11/17  20:50:51  Hans_Graves]
 *
 * Revision 1.1.2.18  1995/10/25  18:19:18  Bjorn_Engberg
 * 	Support Upside Down in ScRgbInterlToYuvInterl().
 * 	[1995/10/25  18:05:18  Bjorn_Engberg]
 *
 * Revision 1.1.2.17  1995/10/10  21:43:02  Bjorn_Engberg
 * 	Speeded up RgbToYuv code and made it table driven.
 * 	[1995/10/10  21:21:48  Bjorn_Engberg]
 *
 * Revision 1.1.2.16  1995/10/09  19:44:31  Bjorn_Engberg
 * 	Removed ValidateBI_BITFIELDS(), it's now in sc_convert_yuv.c
 * 	[1995/10/09  19:44:14  Bjorn_Engberg]
 *
 * Revision 1.1.2.15  1995/10/06  20:43:23  Farokh_Morshed
 * 	Enhance ScRgbInterlToYuvInterl to handle BI_BITFIELDS
 * 	[1995/10/06  20:42:43  Farokh_Morshed]
 *
 * Revision 1.1.2.14  1995/10/02  19:30:26  Bjorn_Engberg
 * 	Added support for Assebler YUV to RGB routines.
 * 	[1995/10/02  18:39:05  Bjorn_Engberg]
 *
 * Revision 1.1.2.13  1995/09/28  20:37:53  Farokh_Morshed
 * 	Handle negative Height
 * 	[1995/09/28  20:37:39  Farokh_Morshed]
 *
 * Revision 1.1.2.12  1995/09/26  15:58:47  Paul_Gauthier
 * 	Fix mono JPEG to interlaced 422 YUV conversion
 * 	[1995/09/26  15:58:09  Paul_Gauthier]
 *
 * Revision 1.1.2.11  1995/09/22  18:56:35  Paul_Gauthier
 * 	{** Merge Information **}
 * 	      {** Command used:       bsubmit **}
 * 	      {** Ancestor revision:  1.1.2.7 **}
 * 	      {** Merge revision:     1.1.2.10 **}
 * 	{** End **}
 * 	Use faster method for 16bit YUV output for TGA2
 * 	[1995/09/22  18:39:55  Paul_Gauthier]
 *
 * Revision 1.1.2.10  1995/09/21  18:26:45  Farokh_Morshed
 * 	When BI_RGB or BI_BITFIELDS, invert the image while translating from
 * 	YUV to RGB.  Also fix the coefficient for the YUV colors.
 * 	This work was actually done by Bjorn
 * 	[1995/09/21  18:26:19  Farokh_Morshed]
 *
 * Revision 1.1.2.9  1995/09/20  17:39:18  Karen_Dintino
 * 	Add RGB support to JPEG
 * 	[1995/09/20  17:37:22  Karen_Dintino]
 *
 * Revision 1.1.2.8  1995/09/20  14:59:31  Bjorn_Engberg
 * 	Port to NT
 * 	[1995/09/20  14:41:10  Bjorn_Engberg]
 *
 * Revision 1.1.2.7  1995/09/18  19:47:47  Paul_Gauthier
 * 	Added conversion of MPEG planar 4:1:1 to interleaved 4:2:2
 * 	[1995/09/18  19:46:13  Paul_Gauthier]
 *
 * Revision 1.1.2.6  1995/09/14  14:40:34  Karen_Dintino
 * 	Move RgbToYuv out of rendition
 * 	[1995/09/14  14:26:13  Karen_Dintino]
 *
 * Revision 1.1.2.5  1995/09/11  18:47:25  Farokh_Morshed
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.3 **}
 * 		{** Merge revision:	1.1.2.4 **}
 * 	{** End **}
 * 	Support BI_BITFIELDS format
 * 	[1995/09/11  18:43:39  Farokh_Morshed]
 *
 * Revision 1.1.2.4  1995/09/05  17:17:34  Paul_Gauthier
 * 	Fix for softjpeg decompression JPEG -> BICOMP_DECYUVDIB
 * 	[1995/09/05  17:17:09  Paul_Gauthier]
 *
 * Revision 1.1.2.3  1995/08/03  15:01:06  Hans_Graves
 * 	Moved ScConvert422ToYUV_char_C() from h261.
 * 	[1995/08/03  14:46:23  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/05/31  18:07:27  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:06:30  Hans_Graves]
 *
 * $EndLog$
 */

/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1993                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
**
**  Miscellaneous conversion utility subroutines
**
**  Author(s): Victor Bahl
**  Date:      May 27, 1993
**
*/

#include <stdio.h>  /* NULL */
#include <sys/types.h>
#ifdef WIN32
#include <windows.h>
#include <mmsystem.h>
#else /* !WIN32 */
#include <mmsystem.h>
#endif /* !WIN32 */

#include "SC_conv.h"
#include "SC_err.h"

#ifndef BI_DECSEPRGBDIB
#define BI_DECSEPRGBDIB         mmioFOURCC('D','S','R','G')
#endif

#define NEW_YCBCR		/* Use new YUV to RGB coefficients */

/*
** Name:     ScCreateBMHeader
** Purpose:  Allocate memory for a (Microsoft specified) bitmap header and
**           fill in the appropriate fields
**
*/
BITMAPINFOHEADER *ScCreateBMHeader(int width, int height, int bpp,
                                 int format, int ncolors)
{
    BITMAPINFOHEADER *pHead;
    int struct_size = sizeof(BITMAPINFOHEADER) + ncolors*sizeof(RGBQUAD);

    if ((pHead = (BITMAPINFOHEADER *)ScAlloc(struct_size)) == NULL) {
       puts("Can't Allocate memory for image headers");
       return NULL;
    }

    pHead->biSize          = sizeof(BITMAPINFOHEADER);
    pHead->biWidth         = width;
    pHead->biHeight        = height;
    pHead->biPlanes        = 1;
    pHead->biBitCount      = (WORD)bpp;
    pHead->biCompression   = format;
    pHead->biSizeImage     = 0;
    pHead->biXPelsPerMeter = 0;
    pHead->biYPelsPerMeter = 0;
    pHead->biClrUsed       = ncolors;
    pHead->biClrImportant  = 0;

    return pHead;
}

/*
** Function: ScIsUpsideDown
** Descript: Return TRUE if the current combination
** of input and output formats and image
** heights means that the image should be
** flipped during the render stage.
*/
int ScIsUpsideDown( BITMAPINFOHEADER *lpbiIn,
                    BITMAPINFOHEADER *lpbiOut )
{
    int ups = 0 ;
    if( lpbiIn )
      ups = (((lpbiIn->biCompression == BI_RGB) ||
              (lpbiIn->biCompression == BI_BITFIELDS)) ^
             ((int) lpbiIn->biHeight < 0)) ;
    if( lpbiOut )
      ups ^= (((lpbiOut->biCompression == BI_RGB) ||
               (lpbiOut->biCompression == BI_BITFIELDS)) ^
              ((int) lpbiOut->biHeight < 0)) ;
    return ups ;
}

/*
**++
**  FUNCTIONAL_DESCRIPTION:
**	Return an enum value that validates a BI_BITFIELDS bitmapinfoheader
**      with BI_BITFIELDS format.
**
**  FORMAL PARAMETERS:
**	Pointer to bitmapinfoheader
**  RETURN VALUE:
**	A value from enum type ValidBI_BITFIELDSKinds.
**/
enum ValidBI_BITFIELDSKinds ValidateBI_BITFIELDS(
    LPBITMAPINFOHEADER 	lpbi)
{
    DWORD *MaskPtr;

    if (lpbi == NULL || lpbi->biCompression != BI_BITFIELDS)
        return InvalidBI_BITFIELDS;

    MaskPtr = (DWORD *)&lpbi[1];

    /*
     * For 32-bit BI_BITFIELDS, we support
     * only the special cases 00RRGGBB and 00BBGGRR.
     */

    if( lpbi->biBitCount == 32 ) {
	if (MaskPtr[1] != 0x0000FF00U)
	    return InvalidBI_BITFIELDS;
	else if (MaskPtr[0] == 0x00FF0000U && MaskPtr[2] == 0x000000FFU)
	    return pRGB;
	else if (MaskPtr[0] == 0x000000FFU && MaskPtr[2] == 0x00FF0000U)
            return pBGR;
	else
	    return InvalidBI_BITFIELDS;
    }

#ifdef WIN32
    /*
     * For 16-bit BI_BITFIELDS, we support any legal
     * color arrangement, but RGB565 and RGB555 are
     * recognized as special since we have extra
     * fast assembler code for those cases.
     */

    else if( lpbi->biBitCount == 16 ) {
	int i ;
	if( MaskPtr[2] == 0x001f ) {
	    if( MaskPtr[0] == 0xf800 && MaskPtr[1] == 0x07e0 )
	    	return pRGB565 ;
	    else if( MaskPtr[0] == 0x7c00 && MaskPtr[1] == 0x03e00 )
	    	return pRGB555 ;
	}
	/*
	 * Generic case: First make sure that each mask is
	 * a 16-bit mask.
	 */

	if( (MaskPtr[0] | MaskPtr[1] | MaskPtr[2]) & ~0x0000ffff )
	    return InvalidBI_BITFIELDS ;

	/*
	 * Masks must not overlap.
	 */

	if( (MaskPtr[0] & MaskPtr[1]) ||
	    (MaskPtr[0] & MaskPtr[2]) ||
	    (MaskPtr[1] & MaskPtr[2]) )
	    return InvalidBI_BITFIELDS ;

	/*
	 * Make sure each mask contains a contiguous
	 * sequence of 1's (or is 0).
	 */

	for( i=0 ; i<3 ; i++ ) {
	   DWORD v = MaskPtr[i] ;
	   if( (((v-1)|v)+1)&v )
	       return InvalidBI_BITFIELDS ;	
	}

	/*
	 * If we pass all these tests, we have
	 * a valid generic 16-bit BI_BITFIELDS case.
	 */

	return pRGBnnn ;
    }

#endif /* WIN32 */

    /*
     * No other biBitCounts are supported.
     */

    return InvalidBI_BITFIELDS ;
}

/*********************** Conversion Routines ***************************/

static void sc_ExtractBlockNonInt(u_char *InData, float **OutData,
	   		          int ByteWidth, int x, int y)
{
  register int i,j;
  u_char *Inp, *IStart = InData + 8*y*ByteWidth + 8*x;

  for (i = 0 , Inp = IStart ; i < 8 ; i++ , Inp += ByteWidth)
    for (j = 0 ; j < 8 ; j++)
      *((*OutData)++) = (float)((int)(*Inp++) - 128);
}


/*
** Name:     ScConvertSepYUVToOther
** Purpose:  Convert Seperated YUV 422 to another format
**
*/
ScStatus_t ScConvertSepYUVToOther(BITMAPINFOHEADER *InBmh,
				  BITMAPINFOHEADER *OutBmh,
				  u_char *OutImage,
				  u_char *YData, u_char *CbData, u_char *CrData)
{
    /*
    ** no need to do extensive checking, DecompressBegin and CompressBegin
    ** should take care of static checking (eg. valid output colorspace
    */


    /*
    ** Are we converting from SepYUV to RGB ?
    */
    if ((OutBmh->biCompression == BI_RGB)              ||
        (OutBmh->biCompression == BI_BITFIELDS)        ||
        (OutBmh->biCompression == BI_DECXIMAGEDIB) ||
	(OutBmh->biCompression == BI_DECSEPRGBDIB)) {
        /*
	** It is assumed that YUV is subsampled 4:2:2, we will need to
	** generalize the code below to handle other cases as well -- VB
	*/
        if (InBmh->biBitCount == 8)
	  ScYuv422ToRgb (OutBmh, YData, NULL, NULL, OutImage);
        else
	  ScYuv422ToRgb (OutBmh, YData, CbData, CrData, OutImage);
    }
    /*
    ** Are we converting from SepYUV to Interlaced YUV ?
    */
    else if (IsYUV422Sep(OutBmh->biCompression))
    {
       /*
       ** It is assumed that YUV is subsampled 4:2:2, we will need to
       ** generalize the code below to handle other cases as well
       **   XXX - Bad idea to do this here, should be done as part of
       **         decompression (VB)
       **   XXX - While we can move the Sep YUV to 422 interleaved
       **         to decompression, we also need a copy here so we
       **         can use this as a general purpose dither'ing
       **         device. (JPL)
       */
       int i, j;

       /*
       ** If the input format is Mono JPEG and the output format is
       ** packed YUV422, we must reset the U and V values to neutral (Gray).
       */
       if (InBmh->biBitCount == 8) {
#ifdef __alpha
         /*
	  * If we're an Alpha, and the buffer is quadword
	  * aligned, we can use 64-bit transfers.
	  */
         if( ((INT_PTR) OutImage & 0x7) == 0 )
	   {
	     _int64 val   = 0x7f007f007f007f00L ;
	     _int64 *iptr = (_int64 *) OutImage ;
	     for( i=(OutBmh->biWidth*abs(OutBmh->biHeight)>>2) ; i>0 ; i-- )
	       *iptr++ = val ;
	   }
         else
#endif /* __alpha */
	   {
	     int val   = 0x7f007f00 ;
	     int *iptr = (int *) OutImage ;
	     for( i=(OutBmh->biWidth*abs(OutBmh->biHeight)>>1) ; i>0 ; i-- )
	       *iptr++ = val ;
	   }
         /*
	 ** Plug in the luminance samples
	 */
         for( i=(OutBmh->biWidth * abs(OutBmh->biHeight)) ; i>0 ; i-- ) {
           *OutImage = *YData++;
           OutImage +=2;
         }
       }
       /*
       ** Color input
       */
       else {
	 /* If this is quad padded in both X and Y and quad aligned,
	 ** we can call the assembly routine
	 */
	 if ( (abs(OutBmh->biHeight) & 0x7) == 0 &&
	     (OutBmh->biWidth & 0x7) == 0 &&
	     ((ULONG_PTR)OutImage & 0xf) == 0 )
	   {
	     ScConvert422PlanarTo422i(YData, CbData, CrData, OutImage,
				      OutBmh->biWidth, abs(OutBmh->biHeight));
	   }
	 else {
	   for (i=0; i<abs(OutBmh->biHeight); i++)
	     /* Remember, pixels are 16 bit in interleaved YUV. That
	     ** means the 4 bytes below represent two pixels so our
	     ** loop should be for half the width.
	     */
	     for (j=0; j<OutBmh->biWidth>>1; j++) {     /* Note: was j+=2 */
	       *OutImage++ = *YData++;
	       *OutImage++ = *CbData++;
	       *OutImage++ = *YData++;
	       *OutImage++ = *CrData++;
	     }
	 }
       }
    }
    else return(ScErrorUnrecognizedFormat);

    return(ScErrorNone);
}

/*
** Name:    ScYuv411ToRgb
** Purpose: convert 16-bit YCrCb 4:1:1 to an 16/24/32-bit RGB
**
** Note:    The code below is pixel based and is inefficient, we
**	    plan to replace faster assembly code
*/
ScStatus_t ScYuv411ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y, u_char *Cb,
			u_char *Cr, u_char *ImageOut, int Width, int Height, long stride)
{
   const int pixels = Width;
   int lines  = Height;
   register int row, col;
   register int Luma, U, V;
   /* Variables to hold R, G and B values for a 2x2 matrix of pixels */
   int R1,R2,R3,R4;
   int G1,G2,G3,G4;
   int B1,B2,B3,B4;
   int Ups = 0, tmp;			/* Flip image upside down */
   u_char  *Y1=Y, *Y2=Y+pixels;
#define _LoadRGBfrom411() \
         R1 = R2 = R3 = R4 = (int) (              + (1.596 * V)); \
         G1 = G2 = G3 = G4 = (int) (- (0.391 * U) - (0.813 * V)); \
         B1 = B2 = B3 = B4 = (int) (+ (2.018 * U)              ); \
	 Luma = (int) (((int) *(Y1++) - 16) * 1.164); \
         R1 += Luma; G1 +=Luma; B1 += Luma; \
	 Luma = (int) (((int) *(Y1++) - 16) * 1.164); \
         R2 += Luma; G2 +=Luma; B2 += Luma; \
         if ((R1 | G1 | B1 | R2 | G2 | B2) & 0xffffff00) { \
           if (R1<0) R1=0; else if (R1>255) R1=255; \
           if (G1<0) G1=0; else if (G1>255) G1=255; \
           if (B1<0) B1=0; else if (B1>255) B1=255; \
           if (R2<0) R2=0; else if (R2>255) R2=255; \
           if (G2<0) G2=0; else if (G2>255) G2=255; \
           if (B2<0) B2=0; else if (B2>255) B2=255; \
         } \
         Luma = (int) (((int) *(Y2++) - 16) * 1.164); \
         R3 += Luma; G3 +=Luma; B3 += Luma; \
         Luma = (int) (((int) *(Y2++) - 16) * 1.164); \
         R4 += Luma; G4 +=Luma; B4 += Luma; \
         if ((R3 | G3 | B3 | R4 | G4 | B4) & 0xffffff00) { \
           if (R3<0) R3=0; else if (R3>255) R3=255; \
           if (G3<0) G3=0; else if (G3>255) G3=255; \
           if (B3<0) B3=0; else if (B3>255) B3=255; \
           if (R4<0) R4=0; else if (R4>255) R4=255; \
           if (G4<0) G4=0; else if (G4>255) G4=255; \
           if (B4<0) B4=0; else if (B4>255) B4=255; \
         }

   /*
    * Normally, images are stored right side up, that is with the
    * first pixel in the buffer corresponding to the top left pixel
    * in the image.
    *
    * The Microsoft standard Device Independent bitmap formats BI_RGB and
    * BI_BITFIELD are stored with the lower left pixel first.  We view that
    * as upside down.
    *
    * Each format can also have a negative height, which also signifes
    * upside down.
    *
    * Since two negatives makes a positive, that means that BI_ formats with
    * negative height are right side up.
    */
   if( Bmh->biCompression == BI_RGB ||
       Bmh->biCompression == BI_BITFIELDS )
       Ups = 1 ;

   if( lines < 0 ) {
      Ups = 1-Ups ;
      lines = -lines ;
   }

   /*
   ** The assumption is that YCrCb are subsampled 4:1:1
   **	YSize           = lines * pixels
   **   CbSize = CrSize = (lines*pixels)/4
   */
   switch (Bmh->biCompression)
   {
      case BI_RGB:
            switch (Bmh->biBitCount)
            {
              case 15:
                {
                  u_short *Sout1 = (u_short *)ImageOut, *Sout2=Sout1+pixels;
                  for (row = 0; row < lines; row+=2)
                  {
                    if (Ups)
                    {
                      tmp = stride * (lines-row-1) ;
                      Sout1 = (u_short *)ImageOut+tmp; /* For 16-bit */
                      Sout2=Sout1-stride;
                    }
                    else
                    {
                      tmp = stride * row;
                      Sout1 = (u_short *)ImageOut+tmp; /* For 16-bit */
                      Sout2=Sout1+stride;
                    }
                    Y2=Y1+pixels;
                    for (col = 0; col < pixels; col += 2)
                    {
	              U = *Cb++ - 128;
	              V = *Cr++ - 128;
                      _LoadRGBfrom411();
		      *(Sout1++) = ((R1&0xf8)<<7)|((G1&0xf8)<<2)|((B1&0xf8)>>3);
		      *(Sout1++) = ((R2&0xf8)<<7)|((G2&0xf8)<<2)|((B2&0xf8)>>3);
		      *(Sout2++) = ((R3&0xf8)<<7)|((G3&0xf8)<<2)|((B3&0xf8)>>3);
		      *(Sout2++) = ((R4&0xf8)<<7)|((G4&0xf8)<<2)|((B4&0xf8)>>3);
                    }
                    Y1=Y2;
                  }
                }
                break;
              case 16:
                {
                  u_short *Sout1 = (u_short *)ImageOut, *Sout2=Sout1+pixels;
                  for (row = 0; row < lines; row+=2)
                  {
                    if (Ups)
                    {
                      tmp = stride * (lines-row-1) ;
                      Sout1 = (u_short *)ImageOut+tmp; /* For 16-bit */
                      Sout2=Sout1-stride;
                    }
                    else
                    {
                      tmp = stride * row;
                      Sout1 = (u_short *)ImageOut+tmp; /* For 16-bit */
                      Sout2=Sout1+stride;
                    }
                    Y2=Y1+pixels;
                    for (col = 0; col < pixels; col += 2)
                    {
	              U = *Cb++ - 128;
	              V = *Cr++ - 128;
                      _LoadRGBfrom411();
#ifdef WIN95  /* RGB 565 - 16 bit */
		      *(Sout1++) = ((R1&0xf8)<<8)|((G1&0xfC)<<3)|((B1&0xf8)>>3);
		      *(Sout1++) = ((R2&0xf8)<<8)|((G2&0xfC)<<3)|((B2&0xf8)>>3);
		      *(Sout2++) = ((R3&0xf8)<<8)|((G3&0xfC)<<3)|((B3&0xf8)>>3);
		      *(Sout2++) = ((R4&0xf8)<<8)|((G4&0xfC)<<3)|((B4&0xf8)>>3);
#else /* RGB 555 - 15 bit */
		      *(Sout1++) = ((R1&0xf8)<<7)|((G1&0xf8)<<2)|((B1&0xf8)>>3);
		      *(Sout1++) = ((R2&0xf8)<<7)|((G2&0xf8)<<2)|((B2&0xf8)>>3);
		      *(Sout2++) = ((R3&0xf8)<<7)|((G3&0xf8)<<2)|((B3&0xf8)>>3);
		      *(Sout2++) = ((R4&0xf8)<<7)|((G4&0xf8)<<2)|((B4&0xf8)>>3);
#endif
                    }
                    Y1=Y2;
                  }
                }
                break;
              case 24:
                {
                  u_char *Cout1, *Cout2;
                  stride*=3;
                  for (row = 0; row < lines; row+=2)
                  {
                    if (Ups)
                    {
                      tmp = stride * (lines-row-1) ;
                      Cout1 = (u_char *)(ImageOut + tmp); /* For 24-bit */
                      Cout2=Cout1-stride;
                    }
                    else
                    {
                      tmp = stride * row;
                      Cout1 = (u_char *)(ImageOut + tmp); /* For 24-bit */
                      Cout2=Cout1+stride;
                    }
                    Y2=Y1+pixels;
                    for (col = 0; col < pixels; col += 2)
                    {
	              U = *Cb++ - 128;
	              V = *Cr++ - 128;
                      _LoadRGBfrom411();
	              *(Cout1++) = (u_char)B1; *(Cout1++) = (u_char)G1; *(Cout1++) = (u_char)R1;
	              *(Cout1++) = (u_char)B2; *(Cout1++) = (u_char)G2; *(Cout1++) = (u_char)R2;
	              *(Cout2++) = (u_char)B3; *(Cout2++) = (u_char)G3; *(Cout2++) = (u_char)R3;
	              *(Cout2++) = (u_char)B4; *(Cout2++) = (u_char)G4; *(Cout2++) = (u_char)R4;
                    }
                    Y1=Y2;
                  }
                }
                break;
              case 32:
                {
                  unsigned dword *Wout1 = (unsigned dword *)ImageOut,
                                 *Wout2=Wout1+pixels;
                  for (row = 0; row < lines; row+=2)
                  {
                    if (Ups)
                    {
                      tmp = stride * (lines-row-1);
                      Wout1 = (unsigned dword *)ImageOut + tmp;
                      Wout2=Wout1-stride;
                    }
                    else
                    {
                      tmp = stride * row;
                      Wout1 = (unsigned dword *)ImageOut + tmp;
                      Wout2=Wout1+stride;
                    }
                    Y2=Y1+pixels;
                    for (col = 0; col < pixels; col += 2)
                    {
	              U = *Cb++ - 128;
	              V = *Cr++ - 128;
                      _LoadRGBfrom411();
		      *(Wout1++) = (R1<<16) | (G1<<8) | B1;
		      *(Wout1++) = (R2<<16) | (G2<<8) | B2;
		      *(Wout2++) = (R3<<16) | (G3<<8) | B3;
		      *(Wout2++) = (R4<<16) | (G4<<8) | B4;
                    }
                    Y1=Y2;
                  }
                }
                break;
            }
            break;
      case BI_DECSEPRGBDIB: /* 24-bit separate RGB */
            {
              u_char *RData1, *GData1, *BData1;
              u_char *RData2, *GData2, *BData2;
              RData1 = ImageOut;
              GData1 = RData1 + (pixels * lines);
              BData1 = GData1 + (pixels * lines);
              RData2 = RData1 + pixels;
              GData2 = GData1 + pixels;
              BData2 = BData1 + pixels;
              for (row = 0; row < lines; row+=2)
              {
                Y2=Y1+pixels;
                for (col = 0; col < pixels; col += 2)
                {
	          U = *Cb++ - 128;
	          V = *Cr++ - 128;
                  _LoadRGBfrom411();
		  *(RData1++) = (u_char)R1; *(RData1++) = (u_char)R2;
          *(RData2++) = (u_char)R3; *(RData2++) = (u_char)R4;
		  *(GData1++) = (u_char)G1; *(GData1++) = (u_char)G2;
		  *(GData2++) = (u_char)G3; *(GData2++) = (u_char)G4;
		  *(BData1++) = (u_char)B1; *(BData1++) = (u_char)B2;
		  *(BData2++) = (u_char)B3; *(BData2++) = (u_char)B4;
	        }
                RData1=RData2;
                RData2=RData1+pixels;
                Y1=Y2;
              }
            }
            break;
      case BI_DECXIMAGEDIB:  /* XIMAGE 24 == pBGR */
      case BI_BITFIELDS: /* 32-bit RGB */
            {
              unsigned dword *Iout1 = (unsigned dword *)ImageOut,
                             *Iout2=Iout1+pixels;
              if (ValidateBI_BITFIELDS(Bmh) == pRGB)
                for (row = 0; row < lines; row+=2)
                {
                  if (Ups)
                  {
                    tmp = stride * (lines-row-1);
                    Iout1 = (unsigned dword *)ImageOut+tmp;  /* For 32-bit */
                    Iout2=Iout1-stride;
                  }
                  else
                  {
                    tmp = stride * row;
                    Iout1 = (unsigned dword *)ImageOut+tmp;  /* For 32-bit */
                    Iout2=Iout1+stride;
                  }
                  Y2=Y1+pixels;
                  for (col = 0; col < pixels; col += 2)
                  {
	            U = *Cb++ - 128;
	            V = *Cr++ - 128;
                    _LoadRGBfrom411();
                    *(Iout1++) = (R1<<16) | (G1<<8) | B1;
                    *(Iout1++) = (R2<<16) | (G2<<8) | B2;
                    *(Iout2++) = (R3<<16) | (G3<<8) | B3;
                    *(Iout2++) = (R4<<16) | (G4<<8) | B4;
                  }
                  Y1=Y2;
                }
              else /* pBGR and XIMAGE 24-bit */
                for (row = 0; row < lines; row+=2)
                {
                  if (Ups)
                  {
                    tmp = stride * (lines-row-1);
                    Iout1 = (unsigned dword *)ImageOut+tmp;  /* For 32-bit */
                    Iout2=Iout1-stride;
                  }
                  else
                  {
                    tmp = stride * row;
                    Iout1 = (unsigned dword *)ImageOut+tmp;  /* For 32-bit */
                    Iout2=Iout1+stride;
                  }
                  Y2=Y1+pixels;
                  for (col = 0; col < pixels; col += 2)
                  {
	            U = *Cb++ - 128;
	            V = *Cr++ - 128;
                    _LoadRGBfrom411();
                    *(Iout1++) = (B1<<16) | (G1<<8) | R1;
                    *(Iout1++) = (B2<<16) | (G2<<8) | R2;
                    *(Iout2++) = (B3<<16) | (G3<<8) | R3;
                    *(Iout2++) = (B4<<16) | (G4<<8) | R4;
                  }
                  Y1=Y2;
                }
            }
            break;
        default:
            return(ScErrorUnrecognizedFormat);
   }
   return (NoErrors);
}


/*
** Name:    ScYuv1611ToRgb
** Purpose: convert 16-bit YCrCb 16:1:1 (YUV9/YVU9) to 16/24/32-bit RGB
**
** Note:    The code below is pixel based and is inefficient, we
**	    plan to replace faster assembly code
** This routine is used by Indeo, which actually only has 7-bits for
** Y, U and V components.  The 8th bits are ignored.
*/
ScStatus_t ScYuv1611ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y, u_char *Cb,
			u_char *Cr, u_char *ImageOut)
{
   const int pixels = Bmh->biWidth;
   int lines  = Bmh->biHeight;
   register int row, col, i;
   register int Luma, U, V;
   /* Variables to hold R, G and B values for a 4x4 matrix of pixels */
   int R[16], G[16], B[16], tmpR, tmpG, tmpB, cR, cG, cB;
   int Ups = 0, tmp;			/* Flip image upside down */
   u_char  *Y0=Y, *Y1, *Y2, *Y3;
#define _LoadRGBfrom1611() \
         cR=(int) (             + (1.596 * V));\
	 cG=(int) (-(0.391 * U) - (0.813 * V));\
	 cB=(int) (+(2.018 * U)              );\
         for (i=0; i<4; i++) { \
	   Luma = (int) ((((int)(*Y0++)<<1) - 16) * 1.164); \
           tmpR=cR + Luma; tmpG=cG + Luma; tmpB=cB + Luma; \
           if ((tmpR | tmpG | tmpB) & 0xffffff00) { \
             if (tmpR<0) R[i]=0; else if (tmpR>255) R[i]=255; else R[i]=tmpR; \
             if (tmpG<0) G[i]=0; else if (tmpG>255) G[i]=255; else G[i]=tmpG; \
             if (tmpB<0) B[i]=0; else if (tmpB>255) B[i]=255; else B[i]=tmpB; \
           } else { R[i]=tmpR; G[i]=tmpG; B[i]=tmpB; } \
         } \
         for (; i<8; i++) { \
	   Luma = (int) ((((int)(*Y1++)<<1) - 16) * 1.164); \
           tmpR=cR + Luma; tmpG=cG + Luma; tmpB=cB + Luma; \
           if ((tmpR | tmpG | tmpB) & 0xffffff00) { \
             if (tmpR<0) R[i]=0; else if (tmpR>255) R[i]=255; else R[i]=tmpR; \
             if (tmpG<0) G[i]=0; else if (tmpG>255) G[i]=255; else G[i]=tmpG; \
             if (tmpB<0) B[i]=0; else if (tmpB>255) B[i]=255; else B[i]=tmpB; \
           } else { R[i]=tmpR; G[i]=tmpG; B[i]=tmpB; } \
         } \
         for (; i<12; i++) { \
	   Luma = (int) ((((int)(*Y2++)<<1) - 16) * 1.164); \
           tmpR=cR + Luma; tmpG=cG + Luma; tmpB=cB + Luma; \
           if ((tmpR | tmpG | tmpB) & 0xffffff00) { \
             if (tmpR<0) R[i]=0; else if (tmpR>255) R[i]=255; else R[i]=tmpR; \
             if (tmpG<0) G[i]=0; else if (tmpG>255) G[i]=255; else G[i]=tmpG; \
             if (tmpB<0) B[i]=0; else if (tmpB>255) B[i]=255; else B[i]=tmpB; \
           } else { R[i]=tmpR; G[i]=tmpG; B[i]=tmpB; } \
         } \
         for (; i<16; i++) { \
	   Luma = (int) ((((int)(*Y3++)<<1) - 16) * 1.164); \
           tmpR=cR + Luma; tmpG=cG + Luma; tmpB=cB + Luma; \
           if ((tmpR | tmpG | tmpB) & 0xffffff00) { \
             if (tmpR<0) R[i]=0; else if (tmpR>255) R[i]=255; else R[i]=tmpR; \
             if (tmpG<0) G[i]=0; else if (tmpG>255) G[i]=255; else G[i]=tmpG; \
             if (tmpB<0) B[i]=0; else if (tmpB>255) B[i]=255; else B[i]=tmpB; \
           } else { R[i]=tmpR; G[i]=tmpG; B[i]=tmpB; } \
         }

   /*
    * Normally, images are stored right side up, that is with the
    * first pixel in the buffer corresponding to the top left pixel
    * in the image.
    *
    * The Microsoft standard Device Independent bitmap formats BI_RGB and
    * BI_BITFIELD are stored with the lower left pixel first.  We view that
    * as upside down.
    *
    * Each format can also have a negative height, which also signifes
    * upside down.
    *
    * Since two negatives makes a positive, that means that BI_ formats with
    * negative height are right side up.
    */
   if( Bmh->biCompression == BI_RGB ||
       Bmh->biCompression == BI_BITFIELDS )
       Ups = 1 ;

   if( lines < 0 ) {
      Ups = 1-Ups ;
      lines = -lines ;
   }

   /*
   ** The assumption is that YCrCb are subsampled 4:1:1
   **	YSize           = lines * pixels
   **   CbSize = CrSize = (lines*pixels)/4
   */
   switch (Bmh->biCompression)
   {
      case BI_DECXIMAGEDIB:  /* XIMAGE 24 == pBGR */
      case BI_BITFIELDS: /* 32-bit RGB */
            {
              unsigned dword *Iout0 = (unsigned dword *)ImageOut,
                             *Iout1, *Iout2, *Iout3;
              if (ValidateBI_BITFIELDS(Bmh) == pRGB)
                for (row = 0; row < lines; row+=4)
                {
                  if (Ups) {
                    tmp = pixels * (lines-row-1) ;
                    Iout0 = (unsigned dword *)ImageOut+tmp;
                    Iout1=Iout0-pixels; Iout2=Iout1-pixels; Iout3=Iout2-pixels;
                  }
                  else {
                    Iout1=Iout0+pixels; Iout2=Iout1+pixels; Iout3=Iout2+pixels;
                  }
                  Y1=Y0+pixels; Y2=Y1+pixels; Y3=Y2+pixels;
                  for (col = 0; col < pixels; col += 4)
                  {
                    if (*Cb & 0x80) /* if 8th bit is set, ignore */
                    {
                      for (i=0; i<4; i++) {
                        *(Iout0++) = 0;
                        *(Iout1++) = 0;
                        *(Iout2++) = 0;
                        *(Iout3++) = 0;
                      }
                      Cb++; Cr++;
                    }
                    else
                    {
	              U = ((*Cb++)<<1) - 128;
	              V = ((*Cr++)<<1) - 128;
                      _LoadRGBfrom1611();
                      for (i=0; i<4; i++)
                        *(Iout0++) = (R[i]<<16) | (G[i]<<8) | B[i];
                      for (; i<8; i++)
                        *(Iout1++) = (R[i]<<16) | (G[i]<<8) | B[i];
                      for (; i<12; i++)
                        *(Iout2++) = (R[i]<<16) | (G[i]<<8) | B[i];
                      for (; i<16; i++)
                        *(Iout3++) = (R[i]<<16) | (G[i]<<8) | B[i];
                    }
                  }
                  Iout0=Iout3;
                  Y0=Y3;
                }
              else /* pBGR and XIMAGE 24-bit */
                for (row = 0; row < lines; row+=4)
                {
                  if (Ups) {
                    tmp = pixels * (lines-row-1) ;
                    Iout0 = (unsigned dword *)ImageOut+tmp;
                    Iout1=Iout0-pixels; Iout2=Iout1-pixels; Iout3=Iout2-pixels;
                  }
                  else {
                    Iout1=Iout0+pixels; Iout2=Iout1+pixels; Iout3=Iout2+pixels;
                  }
                  Y1=Y0+pixels; Y2=Y1+pixels; Y3=Y2+pixels;
                  for (col = 0; col < pixels; col += 4)
                  {
                    if (*Cb & 0x80) /* if 8th bit is set, ignore */
                    {
                      for (i=0; i<4; i++) {
                        *(Iout0++) = 0;
                        *(Iout1++) = 0;
                        *(Iout2++) = 0;
                        *(Iout3++) = 0;
                      }
                      Cb++; Cr++;
                    }
                    else
                    {
	              U = ((*Cb++)<<1) - 128;
	              V = ((*Cr++)<<1) - 128;
                      _LoadRGBfrom1611();
                      for (i=0; i<4; i++)
                        *(Iout0++) = (B[i]<<16) | (G[i]<<8) | R[i];
                      for (; i<8; i++)
                        *(Iout1++) = (B[i]<<16) | (G[i]<<8) | R[i];
                      for (; i<12; i++)
                        *(Iout2++) = (B[i]<<16) | (G[i]<<8) | R[i];
                      for (; i<16; i++)
                        *(Iout3++) = (B[i]<<16) | (G[i]<<8) | R[i];
                    }
                  }
                  Iout0=Iout3;
                  Y0=Y3;
                }
            }
            break;
      case BI_RGB:
            switch (Bmh->biBitCount)
            {
              case 15:
              case 16:
                {
                  u_short *Sout0 = (u_short *)ImageOut, *Sout1, *Sout2, *Sout3;
                  for (row = 0; row < lines; row+=4)
                  {
                    if (Ups) {
                     tmp = pixels * (lines-row-1) ;
                     Sout0 = &((u_short *)ImageOut)[tmp];  /* For 32-bit */
                     Sout1=Sout0-pixels; Sout2=Sout1-pixels; Sout3=Sout2-pixels;
                    }
                    else {
                     Sout1=Sout0+pixels; Sout2=Sout1+pixels; Sout3=Sout2+pixels;
                    }
                    Y1=Y0+pixels; Y2=Y1+pixels; Y3=Y2+pixels;
                    for (col = 0; col < pixels; col += 4)
                    {
                      if (*Cb & 0x80) /* if 8th bit is set, ignore */
                      {
                        for (i=0; i<4; i++) {
                          *(Sout0++) = 0;
                          *(Sout1++) = 0;
                          *(Sout2++) = 0;
                          *(Sout3++) = 0;
                        }
                        Cb++; Cr++;
                      }
                      else
                      {
	                U = ((*Cb++)<<1) - 128;
	                V = ((*Cr++)<<1) - 128;
                        _LoadRGBfrom1611();
                        for (i=0; i<4; i++)
                          *(Sout0++)=
                             ((R[i]&0xf8)<<7)|((G[i]&0xf8)<<2)|((B[i]&0xf8)>>3);
                        for (; i<8; i++)
                          *(Sout1++)=
                             ((R[i]&0xf8)<<7)|((G[i]&0xf8)<<2)|((B[i]&0xf8)>>3);
                        for (; i<12; i++)
                          *(Sout2++)=
                             ((R[i]&0xf8)<<7)|((G[i]&0xf8)<<2)|((B[i]&0xf8)>>3);
                        for (; i<16; i++)
                          *(Sout3++)=
                             ((R[i]&0xf8)<<7)|((G[i]&0xf8)<<2)|((B[i]&0xf8)>>3);
                      }
                    }
                    Sout0=Sout3;
                    Y0=Y3;
                  }
                }
                break;
              case 24:
                {
                  u_char *Cout0 = (u_char *)ImageOut, *Cout1, *Cout2, *Cout3;
                  for (row = 0; row < lines; row+=4)
                  {
                    if (Ups) {
                     tmp = pixels * (lines-row-1) ;
                     Cout0 = &((u_char *)ImageOut)[tmp*3];  /* For 32-bit */
                     Cout1=Cout0-pixels; Cout2=Cout1-pixels; Cout3=Cout2-pixels;
                    }
                    else {
                     Cout1=Cout0+pixels; Cout2=Cout1+pixels; Cout3=Cout2+pixels;
                    }
                    Y1=Y0+pixels; Y2=Y1+pixels; Y3=Y2+pixels;
                    for (col = 0; col < pixels; col += 4)
                    {
                      if (*Cb & 0x80) /* if 8th bit is set, ignore */
                      {
                        for (i=0; i<4*3; i++) {
                          *(Cout0++) = 0;
                          *(Cout1++) = 0;
                          *(Cout2++) = 0;
                          *(Cout3++) = 0;
                        }
                        Cb++; Cr++;
                      }
                      else
                      {
	                U = ((*Cb++)<<1) - 128;
	                V = ((*Cr++)<<1) - 128;
                        _LoadRGBfrom1611();
                        for (i=0; i<4; i++)
                        { *(Cout0++)=(u_char)B[i]; *(Cout0++)=(u_char)G[i]; *(Cout0++)=(u_char)R[i]; }
                        for (; i<8; i++)
                        { *(Cout1++)=(u_char)B[i]; *(Cout1++)=(u_char)G[i]; *(Cout1++)=(u_char)R[i]; }
                        for (; i<12; i++)
                        { *(Cout2++)=(u_char)B[i]; *(Cout2++)=(u_char)G[i]; *(Cout2++)=(u_char)R[i]; }
                        for (; i<16; i++)
                        { *(Cout3++)=(u_char)B[i]; *(Cout3++)=(u_char)G[i]; *(Cout3++)=(u_char)R[i]; }
                      }
                    }
                    Cout0=Cout3;
                    Y0=Y3;
                  }
                }
                break;
            }
            break;
        default:
            return(ScErrorUnrecognizedFormat);
   }
   return (NoErrors);
}


/*
** Name:    ScYuv422ToRgb
** Purpose: convert 16-bit YCrCb 4:2:2 to an 24-bit/16-bit/32-bit RGB
**
** Note:    The code below is pixel based and is *extremely* inefficient, we
**	    plan to replace the dumb code below with some fast code
** If Cb==NULL and Cr==NULL then assume BI_DECGRAYDIB (use only Y component).
*/
ScStatus_t ScYuv422ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y, u_char *Cb,
			u_char *Cr, u_char *ImageOut)
{
   register int row, col;
   register int Luma,U=0,V=0;
   int R1,R2, G1,G2, B1,B2;
   int Ups = 0, tmp;			/* Flip image upside down */
   u_char *RData, *GData, *BData;	/* pointers for non-interlaced mode */
   u_char  *Cout = (u_char *)ImageOut;
   u_short *Sout = (u_short *)ImageOut;
   u_int   *Iout = (u_int *)ImageOut;
   int pixels = Bmh->biWidth;
   int lines  = Bmh->biHeight;
#ifdef NEW_YCBCR
#define _LoadRGBfrom422() \
         if (U || V) { \
           R1 = R2 = (int) (              + (1.596 * V)); \
           G1 = G2 = (int) (- (0.391 * U) - (0.813 * V)); \
           B1 = B2 = (int) (+ (2.018 * U)              );  \
         } else { R1=R2=G1=G2=B1=B2=0; } \
	 Luma = (int) (((int) *(Y++) - 16) * 1.164); \
         R1 += Luma; G1 += Luma; B1 += Luma; \
	 Luma = (int) (((int) *(Y++) - 16) * 1.164); \
         R2 += Luma; G2 += Luma; B2 += Luma; \
         if ((R1 | G1 | B1 | R2 | G2 | B2) & 0xffffff00) { \
           if (R1<0) R1=0; else if (R1>255) R1=255; \
           if (G1<0) G1=0; else if (G1>255) G1=255; \
           if (B1<0) B1=0; else if (B1>255) B1=255; \
           if (R2<0) R2=0; else if (R2>255) R2=255; \
           if (G2<0) G2=0; else if (G2>255) G2=255; \
           if (B2<0) B2=0; else if (B2>255) B2=255; \
         }
#else
#define _LoadRGBfrom422() \
	 Luma = *(Y++); \
         R1 = Luma                + (1.4075 * V); \
         G1 = Luma - (0.3455 * U) - (0.7169 * V); \
         B1 = Luma + (1.7790 * U); \
	 Luma = *(Y++); \
         R2 = Luma                + (1.4075 * V); \
         G2 = Luma - (0.3455 * U) - (0.7169 * V); \
         B2 = Luma + (1.7790 * U); \
         if ((R1 | G1 | B1 | R2 | G2 | B2) & 0xffffff00) { \
           if (R1<0) R1=0; else if (R1>255) R1=255; \
           if (G1<0) G1=0; else if (G1>255) G1=255; \
           if (B1<0) B1=0; else if (B1>255) B1=255; \
           if (R2<0) R2=0; else if (R2>255) R2=255; \
           if (G2<0) G2=0; else if (G2>255) G2=255; \
           if (B2<0) B2=0; else if (B2>255) B2=255; \
         }
#endif /* NEW_YCBCR */

   /*
    * Normally, images are stored right side up,
    * that is with the first pixel in the buffer
    * corresponding to the top left pixel in the image.
    *
    * The Microsoft standard Device Independent bitmap
    * formats BI_RGB and BI_BITFIELD are stored with
    * the lower left pixel first.
    * We view that as upside down.
    *
    * Each format can also have a negative height,
    * which also signifes upside down.
    *
    * Since two negatives makes a positive, that means
    * that BI_ formats with a negative height are right side up.
    */

   if( Bmh->biCompression == BI_RGB ||
       Bmh->biCompression == BI_BITFIELDS)
       Ups = 1 ;

   if( lines < 0 ) {
      Ups = 1-Ups ;
      lines = -lines ;
   }

   /*
   ** needed if the three components are to be provided in a
   ** non-interlaced mode:
   */
   if (Bmh->biCompression == BI_DECSEPRGBDIB) {
      RData = ImageOut;
      GData = RData + (pixels * lines);
      BData = GData + (pixels * lines);
   }


   /*
   ** The assumption is that YCrCb are subsampled 4:2:2
   **	YSize           = lines * pixels
   **   CbSize = CrSize = (lines*pixels)/2
   */
   switch (Bmh->biCompression)
   {
      case BI_RGB:
            switch (Bmh->biBitCount)
            {
              case 15:
              case 16:
                {
                  u_short *Sout = (u_short *)ImageOut;
                  for (row = 0; row < lines; row++)
                  {
                    if (Ups)
                    {
                      tmp = pixels * (lines-row-1) ;
                      Sout = &((u_short *)ImageOut)[tmp]; /* For 16-bit */
                    }
                    for (col = 0; col < pixels; col += 2)
                    {
                      if (Cb) {
	                U = *Cb++ - 128;
	                V = *Cr++ - 128;
                      }
                      _LoadRGBfrom422();
		      *(Sout++) = ((R1&0xf8)<<7)|((G1&0xf8)<<2)|((B1&0xf8)>>3);
		      *(Sout++) = ((R2&0xf8)<<7)|((G2&0xf8)<<2)|((B2&0xf8)>>3);
                    }
                  }
                }
                break;
              case 24:
                {
                  u_char *Cout = (u_char *)ImageOut;
                  for (row = 0; row < lines; row++)
                  {
                    if (Ups)
                    {
                      tmp = pixels * (lines-row-1) ;
                      Cout = &((u_char *)ImageOut)[3*tmp]; /* For 24-bit */
                    }
                    for (col = 0; col < pixels; col += 2)
                    {
                      if (Cb) {
	                U = *Cb++ - 128;
	                V = *Cr++ - 128;
                      }
                      _LoadRGBfrom422();
	              *(Cout++) = (u_char)B1; *(Cout++) = (u_char)G1; *(Cout++) = (u_char)R1;
	              *(Cout++) = (u_char)B2; *(Cout++) = (u_char)G2; *(Cout++) = (u_char)R2;
                    }
                  }
                }
                break;
              case 32:
                {
                  u_int *Iout = (u_int *)ImageOut;
                  for (row = 0; row < lines; row++)
                  {
                    if (Ups)
                    {
                      tmp = pixels * (lines-row-1) ;
                      Iout = &((u_int *)ImageOut)[tmp]; /* For 32-bit */
                    }
                    for (col = 0; col < pixels; col += 2)
                    {
                      if (Cb) {
	                U = *Cb++ - 128;
	                V = *Cr++ - 128;
                      }
                      _LoadRGBfrom422();
		      *(Iout++) = (R1<<16) | (G1<<8) | B1 ;
		      *(Iout++) = (R2<<16) | (G2<<8) | B2 ;
                    }
                  }
                }
                break;
            }
            break;
      case BI_DECSEPRGBDIB: /* 24-bit separate RGB */
            {
              u_char *RData, *GData, *BData;
              RData = ImageOut;
              GData = RData + (pixels * lines);
              BData = GData + (pixels * lines);
              for (row = 0; row < lines; row++)
              {
                for (col = 0; col < pixels; col += 2)
                {
                  if (Cb) {
	            U = *Cb++ - 128;
	            V = *Cr++ - 128;
                  }
                  _LoadRGBfrom422();
		  *(RData++) = (u_char)R1; *(RData++) = (u_char)R2;
		  *(GData++) = (u_char)G1; *(GData++) = (u_char)G2;
		  *(BData++) = (u_char)B1; *(BData++) = (u_char)B2;
	        }
              }
            }
            break;
      case BI_DECXIMAGEDIB:  /* XIMAGE 24 == pBGR */
      case BI_BITFIELDS: /* 16 or 32-bit RGB */
            switch (Bmh->biBitCount)
            {
	    case 16:
	      {	/* 16-bit BI_BITFIELDS, hardcoded to RGB565 */
		u_short *Sout = (u_short *)ImageOut;
                for (row = 0; row < lines; row++)
                {
                  if (Ups)
                  {
                    tmp = pixels * (lines-row-1) ;
                    Sout = &((u_short *)ImageOut)[tmp];  /* For 16-bit */
                  }
                  for (col = 0; col < pixels; col += 2)
                  {
                    if (Cb) {
	              U = *Cb++ - 128;
	              V = *Cr++ - 128;
                    }
                    _LoadRGBfrom422();
                    *(Sout++) = ((R1<<8) & 0xf800) | ((G1<<3) & 0x07e0) | ((B1>>3) & 0x01f);
                    *(Sout++) = ((R2<<8) & 0xf800) | ((G2<<3) & 0x07e0) | ((B2>>3) & 0x01f);
                  }
                }
	      }
	      break ;
	    case 24:
	    case 32:
	      { /* 32-bit RGB */
                u_int *Iout = (u_int *)ImageOut;
                if (ValidateBI_BITFIELDS(Bmh) == pRGB)
		{
                  for (row = 0; row < lines; row++)
                  {
                    if (Ups)
                    {
                      tmp = pixels * (lines-row-1) ;
                      Iout = &((u_int *)ImageOut)[tmp];  /* For 32-bit */
                    }
                    for (col = 0; col < pixels; col += 2)
                    {
                      if (Cb) {
	                U = *Cb++ - 128;
	                V = *Cr++ - 128;
                      }
                      _LoadRGBfrom422();
                      *(Iout++) = (R1<<16) | (G1<<8) | B1;
                      *(Iout++) = (R2<<16) | (G2<<8) | B2;
                    }
                  }
		}
                else /* pBGR and XIMAGE 24-bit */
                {
		  for (row = 0; row < lines; row++)
                  {
                    if (Ups)
                    {
                      tmp = pixels * (lines-row-1) ;
                      Iout = &((u_int *)ImageOut)[tmp];  /* For 32-bit */
                    }
                    for (col = 0; col < pixels; col += 2)
                    {
                      if (Cb) {
	                U = *Cb++ - 128;
	                V = *Cr++ - 128;
                      }
                      _LoadRGBfrom422();
                      *(Iout++) = (B1<<16) | (G1<<8) | R1;
                      *(Iout++) = (B2<<16) | (G2<<8) | R2;
                    }
                  }
		}	
	      }
	      break;
	    }
            break;
       default:
	    return(ScErrorUnrecognizedFormat);
   }
   return (NoErrors);
}

/*
** Name: ScInitRgbToYuv
** Purpose: Initializes tables for RGB to YUV conversion.
**
** Notes:
**
**	The tables are allocated and filled in once the first
**	time they are needed. They will remin for the lifetime
**	of the server.
**
**	The following formula is used:
**
**	y =  0.257 * r + 0.504 * g + 0.098 * b +  16 ; /+  16 - 235 +/
**	u = -0.148 * r - 0.291 * g + 0.439 * b + 128 ; /+  16 - 239 +/
**	v =  0.439 * r - 0.368 * g - 0.071 * b + 128 ; /+  16 - 239 +/
**
**	But we rewrite it thus:
**
**	y = 16.000 + 0.257 * r       + 0.504 * g       + 0.098 * b       ;
**	u = 16.055 + 0.148 * (255-r) + 0.291 * (255-g) + 0.439 * b       ;
**	v = 16.055 + 0.439 * r       + 0.368 * (255-g) + 0.071 * (255-b) ;
**
**    ( By the way, the old constants are:				     )
**    ( y = r *  0.299 + g *  0.587 + b *  0.114        ;		     )
**    ( u = r * -0.169 + g * -0.332 + b *  0.500  + 128 ;		     )
**    ( v = r *  0.500 + g * -0.419 + b * -0.0813 + 128 ;		     )
**    ( or								     )
**    ( y =  0.0    + 0.299 * r       + 0.587 * g       + 0.1140 * b       ; )
**    ( u =  0.245  + 0.169 * (255-r) + 0.332 * (255-g) + 0.5000 * b       ; )
**    ( v =  0.4235 + 0.500 * r       + 0.419 * (255-g) + 0.0813 * (255-b) ; )
**
**	This particular arrangement of the formula allows Y, U and V values
**	to be calculated in paralell by simple table lookup.
**	The paralellism comes from the fact that Y,U and V values
**	are stored in the same word, but in different bytes.
**	The tables are such that the contribution from red, green
**	and blue can simply be added together, without any carry
**	between bytes. Since the YUV space is larger than the RGB
**	cube, and the RGB cube fits entirely within YUV space,
**	there is no overflow and no range checking is needed.
**
*/

#ifdef NEW_YCBCR
/*
**	y = 16.000 + 0.257 * r       + 0.504 * g       + 0.098 * b       ;
**	u = 16.055 + 0.148 * (255-r) + 0.291 * (255-g) + 0.439 * b       ;
**	v = 16.055 + 0.439 * r       + 0.368 * (255-g) + 0.071 * (255-b) ;
*/
#define YC 16.000
#define UC 16.055
#define VC 16.055
#define YR  0.257
#define UR  0.148
#define VR  0.439
#define YG  0.504
#define UG  0.291
#define VG  0.368
#define YB  0.098
#define UB  0.439
#define VB  0.071

#else /* !NEW_YCBCR */
/*
**    ( y =  0.0      0.299 * r       + 0.587 * g       + 0.1140 * b       ; )
**    ( u =  0.245  + 0.169 * (255-r) + 0.332 * (255-g) + 0.5000 * b       ; )
**    ( v =  0.4235 + 0.500 * r       + 0.419 * (255-g) + 0.0813 * (255-b) ; )
*/
#define YC 0.0
#define UC 0.245
#define VC 0.4235
#define YR 0.299
#define UR 0.169
#define VR 0.500
#define YG 0.587
#define UG 0.332
#define VG 0.419
#define YB 0.1140
#define UB 0.5000
#define VB 0.0813

#endif /* !NEW_YCBCR */

/*
 * We only need an int (32 bits) per table entry but
 * 64-bit aligned access is faster on alpha.
 */

#ifdef __alpha
_int64 *RedToYuyv, *GreenToYuyv, *BlueToYuyv ;
#else /* !__alpha */
unsigned int *RedToYuyv, *GreenToYuyv, *BlueToYuyv ;
#endif /* !__alpha */

int ScInitRgbToYuv()
{
  int i, y, u, v ;

  if( RedToYuyv == NULL ) {
#ifdef __alpha
    RedToYuyv   = (_int64 *) ScAlloc( 256 * sizeof( _int64 ) ) ;
    GreenToYuyv = (_int64 *) ScAlloc( 256 * sizeof( _int64 ) ) ;
    BlueToYuyv  = (_int64 *) ScAlloc( 256 * sizeof( _int64 ) ) ;
#else /* !__alpha */
    RedToYuyv   = (unsigned int *) ScAlloc( 256 * sizeof( unsigned int ) ) ;
    GreenToYuyv = (unsigned int *) ScAlloc( 256 * sizeof( unsigned int ) ) ;
    BlueToYuyv  = (unsigned int *) ScAlloc( 256 * sizeof( unsigned int ) ) ;
#endif /* !__alpha */

    if( !RedToYuyv || !GreenToYuyv || !BlueToYuyv )
      return 0 ;

    for( i=0 ; i<256 ; i++ ) {

      /*
       * Calculate contribution from red.
       * We will also add in the constant here.
       * Pack it into the tables thus: lsb->YUYV<-msb
       */

      y = (int) (YC + YR * i) ;
      u = (int) (UC + UR * (255-i)) ;
      v = (int) (VC + VR * i) ;
      RedToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;

      /*
       * Calculate contribution from green.
       */

      y = (int) (YG * i) ;
      u = (int) (UG * (255-i)) ;
      v = (int) (VG * (255-i)) ;
      GreenToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;

      /*
       * Calculate contribution from blue.
       */

      y = (int) (YB * i) ;
      u = (int) (UB * i) ;
      v = (int) (VB * (255-i)) ;
      BlueToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;

    }
  }
  return 1 ;
}

/*
** Name:    ScConvertRGB24sTo422i_C
** Purpose: convert 24-bit RGB (8:8:8 format) to 16-bit YCrCb (4:2:2 format)
*/
ScStatus_t ScConvertRGB24sTo422i_C(BITMAPINFOHEADER *Bmh, u_char *R, u_char *G,
                                   u_char *B, u_short *ImageOut)
{
   register int row, col;
   int yuyv,r,g,b;
   int pixels = Bmh->biWidth;
   int lines  = abs(Bmh->biHeight);

   if( !RedToYuyv && !ScInitRgbToYuv() )
     return ScErrorMemory ;

   for (row = 0; row < lines; row++) {
      for (col = 0; col < pixels; col++) {
        r = *(R++); g = *(G++); b = *(B++);

	/*
	 * Quick convert to YUV.
	 */

	yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]) ;

        /*
         * Pack 4:2:2 = YUYV YUYV ...
	 * We'll pack YU or YV depending on whether col is odd or not.
	 * Shift yuyv 0 for even, 16 for odd columns.
         */

	*(ImageOut++) = yuyv >> ((col & 1) << 4) ;

      }
    }
    return (NoErrors);
}

#define M_RND(f) ((int) ((f) + .5))

/*
** Name:    ScConvertRGB24To411s_C
** Purpose: convert 24-bit RGB (8:8:8 format) to 16-bit YCrCb (4:1:1 format)
*/
ScStatus_t ScConvertRGB24To411s_C(u_char *inimage,
                                  u_char *Y, u_char *U, u_char *V,
                                  int width, int height)
{
  register int row, col;
  int yuyv, r, g, b;
  u_char *tmp, *evl, *odl;

  if( !RedToYuyv && !ScInitRgbToYuv() )
    return(ScErrorMemory);
  if (height<0) /* flip image */
  {
    height = -height;
    for (row = height-1; row; row--)
    {
      tmp = inimage+(width*row*3);
      if (row & 1)
      {
        odl = tmp;
        evl = tmp-(width*3);
      }
      else
      {
        evl = tmp;
        odl = tmp-(width*3);
      }
      for (col = 0; col < width; col++)
      {
        r = *tmp++;
        g = *tmp++;
        b = *tmp++;
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          r = *evl++ + *odl++;
          g = *evl++ + *odl++;
          b = *evl++ + *odl++;
          r += (*evl++ + *odl++);
          g += (*evl++ + *odl++);
          b += (*evl++ + *odl++);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  else
  {
    tmp = inimage;
    for (row = 0; row < height; row++)
    {
      if (row & 1)
        odl = tmp;
      else
        evl = tmp;
      for (col = 0; col < width; col++)
      {
        r = *tmp++;
        g = *tmp++;
        b = *tmp++;
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          r = *evl++ + *odl++;
          g = *evl++ + *odl++;
          b = *evl++ + *odl++;
          r += (*evl++ + *odl++);
          g += (*evl++ + *odl++);
          b += (*evl++ + *odl++);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  return (NoErrors);
}

/*
** Name:    ScConvertRGB555To411s_C
** Purpose: convert 16-bit RGB (5:5:5 format) to 16-bit YCrCb (4:1:1 format)
*/
ScStatus_t ScConvertRGB555To411s_C(u_char *inimage, u_char *outimage,
                                  int width, int height)
{
  u_char *Y=outimage, *U, *V;
  register int row, col, inpixel;
  int yuyv, r, g, b;
  unsigned word *tmp, *evl, *odl;

#define GetRGB555(in16, r, g, b) b = (inpixel>>7)&0xF8; \
                                 g = (inpixel>>2)&0xF8; \
                                 r = (inpixel<<3)&0xF8

#define AddRGB555(in16, r, g, b) b += (inpixel>>7)&0xF8; \
                                 g += (inpixel>>2)&0xF8; \
                                 r += (inpixel<<3)&0xF8

  if( !RedToYuyv && !ScInitRgbToYuv() )
    return(ScErrorMemory);
  if (height<0) /* flip image */
  {
    height = -height;
    U=Y+(width*height);
    V=U+(width*height*1)/4;
    for (row = height-1; row; row--)
    {
      tmp = ((unsigned word *)inimage)+(width*row);
      if (row & 1)
      {
        odl = tmp;
        evl = tmp-width;
      }
      else
      {
        evl = tmp;
        odl = tmp-width;
      }
      for (col = 0; col < width; col++)
      {
        inpixel=*tmp++;
        GetRGB555(inpixel, r, g, b);
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          inpixel=*evl++;
          GetRGB555(inpixel, r, g, b);
          inpixel=*evl++;
          AddRGB555(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB555(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB555(inpixel, r, g, b);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  else
  {
    U=Y+(width*height);
    V=U+(width*height*1)/4;
    tmp = (unsigned word *)inimage;
    for (row = 0; row < height; row++)
    {
      if (row & 1)
        odl = tmp;
      else
        evl = tmp;
      for (col = 0; col < width; col++)
      {
        inpixel=*tmp++;
        GetRGB555(inpixel, r, g, b);
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          inpixel=*evl++;
          GetRGB555(inpixel, r, g, b);
          inpixel=*evl++;
          AddRGB555(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB555(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB555(inpixel, r, g, b);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  return (NoErrors);
}

/*
** Name:    ScConvertRGB565To411s_C
** Purpose: convert 16-bit RGB (5:6:5 format) to 16-bit YCrCb (4:1:1 format)
*/
ScStatus_t ScConvertRGB565To411s_C(u_char *inimage, u_char *outimage,
                                  int width, int height)
{
  u_char *Y=outimage, *U, *V;
  register int row, col, inpixel;
  int yuyv, r, g, b;
  unsigned word *tmp, *evl, *odl;

#define GetRGB565(in16, r, g, b) b = (inpixel>>8)&0xF8; \
                                 g = (inpixel>>3)&0xFC; \
                                 r = (inpixel<<3)&0xF8

#define AddRGB565(in16, r, g, b) b += (inpixel>>8)&0xF8; \
                                 g += (inpixel>>3)&0xFC; \
                                 r += (inpixel<<3)&0xF8

  if( !RedToYuyv && !ScInitRgbToYuv() )
    return(ScErrorMemory);
  if (height<0) /* flip image */
  {
    height = -height;
    U=Y+(width*height);
    V=U+(width*height*1)/4;
    for (row = height-1; row; row--)
    {
      tmp = ((unsigned word *)inimage)+(width*row);
      if (row & 1)
      {
        odl = tmp;
        evl = tmp-width;
      }
      else
      {
        evl = tmp;
        odl = tmp-width;
      }
      for (col = 0; col < width; col++)
      {
        inpixel=*tmp++;
        GetRGB565(inpixel, r, g, b);
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          inpixel=*evl++;
          GetRGB565(inpixel, r, g, b);
          inpixel=*evl++;
          AddRGB565(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB565(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB565(inpixel, r, g, b);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  else
  {
    U=Y+(width*height);
    V=U+(width*height*1)/4;
    tmp = (unsigned word *)inimage;
    for (row = 0; row < height; row++)
    {
      if (row & 1)
        odl = tmp;
      else
        evl = tmp;
      for (col = 0; col < width; col++)
      {
        inpixel=*tmp++;
        GetRGB565(inpixel, r, g, b);
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          inpixel=*evl++;
          GetRGB565(inpixel, r, g, b);
          inpixel=*evl++;
          AddRGB565(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB565(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB565(inpixel, r, g, b);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  return (NoErrors);
}

/*
** Name:    ScRgbInterlToYuvInterl
** Purpose: convert many RGB formats to 16-bit YCrCb (4:2:2 format)
*/
ScStatus_t ScRgbInterlToYuvInterl (
    LPBITMAPINFOHEADER Bmh,
    int Width,
    int Height,
    u_char *ImageIn,
    u_short *ImageOut)
{
    register int row, col;
    int yuyv,r,g,b,mask=0x00ff;
    int pixels = Width;
    int lines  = abs(Height);
    int IspBGR = (ValidateBI_BITFIELDS(Bmh) == pBGR) ||
         (Bmh->biCompression==BI_DECXIMAGEDIB && Bmh->biBitCount==24);
    int IspRGB_BI_RGB_24 = (Bmh->biCompression==BI_RGB && Bmh->biBitCount==24);
    int linestep = 0 ;

    if( !RedToYuyv && !ScInitRgbToYuv() )
      return ScErrorMemory ;

    /*
     * Check the input format and decide
     * whether the image is to be turned
     * upside down or not.
     */

    if( (Bmh->biCompression == BI_RGB ||
    	 Bmh->biCompression == BI_BITFIELDS) ^
	((int) Bmh->biHeight < 0) ) {
	ImageOut = &ImageOut[ pixels * (lines - 1) ] ;
	linestep = -(pixels << 1) ;
    }

    /*
     * To avoid if-then-else statements inside
     * the inner loop, we have 3 loops.
     */

    /*
     * 24 bits per pixel RGB.
     */

    if (IspRGB_BI_RGB_24) {

      for (row = 0; row < lines; row++) {
	for (col = 0; col < pixels; col++) {
	  b = *(ImageIn++);
	  g = *(ImageIn++);
	  r = *(ImageIn++);

	  /*
	   * Quick convert from RGB to YUV. Just add together
	   * the contributions from each of Red, Green and Blue.
	   */

	  yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]) ;
	
	  /*
	   * Pack 4:2:2 = YUYV YUYV ...
	   * We'll pack YU or YV depending on whether col is odd or not.
	   * Shift yuyv 0 for even, 16 for odd columns.
	   */
	
	  *(ImageOut++) = yuyv >> ((col & 1) << 4) ;

	}
	/*
	 * In case we're turning the image upside down.
	 * This will do nothing if it's right side up.
	 */
	ImageOut = &ImageOut[linestep] ;
      }
    }
    /*
     * 32 bits per pixels 0BGR.
     */
    else if (IspBGR) {
      for (row = 0; row < lines; row++) {
	for (col = 0; col < pixels; col++) {
	  r = *((int *) ImageIn)++ ;
	  b = (r>>16) & mask ;
	  g = (r>> 8) & mask ;
	  r &= mask ;
	  yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]) ;
	  *(ImageOut++) = yuyv >> ((col & 1) << 4) ;
	}
	ImageOut = &ImageOut[linestep] ;
      }
    }
    /*
     * 32 bits per pixels 0RGB.
     */
    else {
      for (row = 0; row < lines; row++) {
	for (col = 0; col < pixels; col++) {
	  b = *((int *) ImageIn)++ ;
	  r = (b>>16) & mask ;
	  g = (b>> 8) & mask ;
	  b &= mask ;
	  yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]) ;
	  *(ImageOut++) = yuyv >> ((col & 1) << 4) ;
	}
	ImageOut = &ImageOut[linestep] ;
      }
    }

    return (NoErrors);
}


/*
** Function: ScConvert422ToYUV_char_C
** Purpose:  Extract the Y, U and V components into separate planes.
**           The interleaved format is YUYV, 4:2:2, we want 4:1:1 so,
**           only copy every other line of the chrominance
*/
ScStatus_t ScConvert422ToYUV_char_C (u_char *RawImage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height)
{
  register int x, y;

  Width/=2;
  Height=abs(Height)/2;
  for (y = 0; y < Height; y++)
  {
    for (x = 0 ; x < Width; x++)
    {
      *Y++ = *RawImage++;
      *U++ = *RawImage++;
      *Y++ = *RawImage++;
      *V++ = *RawImage++;
    }
    for (x = 0; x < Width; x++)
    {
      *Y++ = *RawImage;
      RawImage+=2;
      *Y++ = *RawImage;
      RawImage+=2;
    }
 }
 return (NoErrors);
}

/*
** Function: ScConvert422PlanarTo411_C
** Purpose:  Extract the Y, U and V components from (4:2:2)
**           planes and convert to 4:1:1 so,
**           only copy every other line of the chrominance
*/
ScStatus_t ScConvert422PlanarTo411_C (u_char *RawImage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height)
{
  register int y;
  const int HalfWidth=Width/2;
  unsigned char *RY, *RU, *RV;
  RY=RawImage;
  RU=RY+(Width*Height);
  RV=RU+(Width*Height/2);

  Height=abs(Height);
  memcpy(Y, RawImage, Width*Height);
  for (y = Height/2; y > 0; y--)
  {
    memcpy(U, RU, HalfWidth);
    memcpy(V, RV, HalfWidth);
    U+=HalfWidth;
    V+=HalfWidth;
    RU+=Width; /* skip odd U and V lines */
    RV+=Width;
 }
 return (NoErrors);
}

/*
** C versions of block-extraction routines. To be replaced by ASM
*/
void ScConvertSep422ToBlockYUV (u_char *RawImage, int bpp,
			    float *Comp1, float *Comp2, float *Comp3,
			    int Width, int Height)
{
  int x,y;
  int VertBlocks = abs(Height)/8;
  int YBlocks    = Width/8;
  int UBlocks    = Width/16;
  int VBlocks    = Width/16;
  int ByteWidth  = Width*2;
  u_char *I1 = RawImage;
  u_char *I2 = I1 + Width*abs(Height);
  u_char *I3 = I2 + Width*abs(Height)/2;
  float *C1 = Comp1, *C2 = Comp2, *C3 = Comp3;

  for (y = 0 ; y < VertBlocks ; y++) {
    for (x = 0 ; x < YBlocks ; x++)
      sc_ExtractBlockNonInt(I1, &C1, ByteWidth, x, y);
    for (x = 0 ; x < UBlocks ; x++)
      sc_ExtractBlockNonInt(I2, &C2, ByteWidth, x, y);
    for (x = 0 ; x < VBlocks ; x++)
      sc_ExtractBlockNonInt(I3, &C3, ByteWidth, x, y);
  }
}

void ScConvertGrayToBlock (u_char *RawImage, int bpp,
		       float *Comp1, int Width, int Height)
{
  int x,y;
  int VertBlocks = abs(Height)/8;
  int YBlocks    = Width/8;
  int ByteWidth  = Width;
  u_char *I1 = RawImage;
  float *C1 = Comp1;

  for (y = 0 ; y < VertBlocks ; y++)
    for (x = 0 ; x < YBlocks ; x++)
      sc_ExtractBlockNonInt(I1, &C1, ByteWidth, x, y);
}


/*
** Function: ScSepYUVto422i_C
** Purpose:  Convert a 4:1:1 YUV image in separate-component form to its
**           equivalent interleaved 4:2:2 form.
*/
extern int ScSepYUVto422i_C(u_char *Y, u_char *U,
                            u_char *V, u_char *ImageOut,
                            u_int width, u_int height)
{
  /* need C code for this */
  return(0);
}

/*
** Function: ScConvert422PlanarTo422i_C
** Purpose:  Convert a 4:2:2 YUV image in separate-component form to its
**           equivalent interleaved 4:2:2 form.
*/
extern void ScConvert422PlanarTo422i_C(u_char *Y, u_char *Cb,
				     u_char *Cr, u_char *OutImage,
				     long width, long height)
{
  int i, j;
  height=abs(height);
  width=width>>1;
  for (i=0; i<height; i++)
  {
    /* Remember, pixels are 16 bit in interleaved YUV. That
     ** means the 4 bytes below represent two pixels so our
     ** loop should be for half the width.
     */
    for (j=0; j<width; j++)
    {
       *OutImage++ = *Y++;
       *OutImage++ = *Cb++;
       *OutImage++ = *Y++;
       *OutImage++ = *Cr++;
    }
  }
}

/*
** Function: ScConvert422iTo422s_C
** Purpose:  Convert a 4:2:2 YUV interleaved to 4:2:2 planar.
*/
extern void ScConvert422iTo422s_C(u_char *InImage,
                                  u_char *Y, u_char *U, u_char *V,
                                  long width, long height)
{
  int i, j;
  height=abs(height);
  width=width>>1;
  for (i=0; i<height; i++)
  {
    /* Remember, pixels are 16 bit in interleaved YUV. That
     ** means the 4 bytes below represent two pixels so our
     ** loop should be for half the width.
     */
    for (j=0; j<width; j++)
    {
       *Y++ = *InImage++;
       *U++ = *InImage++;
       *Y++ = *InImage++;
       *V++ = *InImage++;
    }
  }
}

/*
** Function: ScConvert422iTo422sf_C
** Purpose:  Convert a 4:2:2 YUV interleaved to 4:2:2 planar.
*/
extern void ScConvert422iTo422sf_C(u_char *InImage, int bpp,
                                  float *Y, float *U, float *V,
                                  long width, long height)
{
  int i, j;
  height=abs(height);
  width=width>>1;
  for (i=0; i<height; i++)
  {
    /* Remember, pixels are 16 bit in interleaved YUV. That
     ** means the 4 bytes below represent two pixels so our
     ** loop should be for half the width.
     */
    for (j=0; j<width; j++)
    {
       *Y++ = (float)*InImage++;
       *U++ = (float)*InImage++;
       *Y++ = (float)*InImage++;
       *V++ = (float)*InImage++;
    }
  }
}

/*
** Function: ScConvert411sTo422i_C
** Purpose:  Convert a 4:1:1 YUV image in separate-component form to its
**           equivalent interleaved 4:2:2 form.
*/
extern void ScConvert411sTo422i_C(u_char *Y, u_char *Cb,
                                  u_char *Cr, u_char *OutImage,
                                  long width, long height)
{
  u_char *p422e, *p422o, *Yo=Y+width;
  int i, j;
  height=abs(height)/2;
  p422e=OutImage;
  p422o=OutImage+width*2;

  for (i=0; i<height; i++)
  {
    for (j=0; j<width; j+=2)
    {
      *p422e++ = *Y++;
      *p422e++ = *Cb;
      *p422e++ = *Y++;
      *p422e++ = *Cr;
      *p422o++ = *Yo++;
      *p422o++ = *Cb++;
      *p422o++ = *Yo++;
      *p422o++ = *Cr++;
    }
    p422e=p422o;
    p422o=p422e+width*2;
    Y=Yo;
    Yo=Y+width;
  }
}

/*
** Function: ScConvert411sTo422s_C
** Purpose:  Convert a 4:1:1 YUV image in separate-component form to its
**           equivalent interleaved 4:2:2 form.
*/
extern void ScConvert411sTo422s_C(u_char *Y, u_char *Cb,
                                  u_char *Cr, u_char *OutImage,
                                  long width, long height)
{
  u_char *p411, *p422e, *p422o;
  int i, j;
  height=abs(height);

  if (OutImage!=Y)
    memcpy(OutImage, Y, width*height); /* copy Y components */
  p411=Cb+((height/2)-1)*(width/2);
  p422e=OutImage+((height*width*3)/2)-width; /* U component */
  p422o=p422e+(width/2);
  for (i=0; i<height; i+=2)
  {
    for (j=0; j<width; j+=2, p411++, p422e++, p422o++)
      *p422e=*p422o=*p411;
    p411-=width;
    p422o=p422e-width;
    p422e=p422o-(width/2);
  }
  p411=Cr+((height/2)-1)*(width/2);
  p422e=OutImage+(height*width*2)-width; /* V component */
  p422o=p422e+(width/2);
  for (i=0; i<height; i+=2)
  {
    for (j=0; j<width; j+=2, p411++, p422e++, p422o++)
      *p422e=*p422o=*p411;
    p411-=width;
    p422o=p422e-width;
    p422e=p422o-(width/2);
  }
}

/*
** Name:    ScConvert1611sTo411s_C
** Purpose: convert a YCrCb 16:1:1 (YUV9/YVU9) to YCrCb 4:1:1
*/
ScStatus_t ScConvert1611sTo411s_C (u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height)
{
  register int y;
  const int HalfWidth=Width/2;
  unsigned char *RU, *RV;
  int pixels = Width * abs(Height), tmp;

  tmp = pixels / 16;
  RU=inimage+pixels;
  RV=RU+tmp;

  memcpy(Y, inimage, pixels);
  for (y = 0; y < tmp; y++)
  {
      *U++ = *RU;
      *U++ = *RU;
      *U++ = *RU;
      *U++ = *RU++;
      *V++ = *RV;
      *V++ = *RV;
      *V++ = *RV;
      *V++ = *RV++;
 }
 return (NoErrors);
}

/*
** Name:    ScConvert1611sTo422s_C
** Purpose: convert a YCrCb 16:1:1 (YUV9/YVU9) to YCrCb 4:2:2
*/
ScStatus_t ScConvert1611sTo422s_C(u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height)
{
  register int x, y;
  const int HalfWidth=Width/2;
  unsigned char *RU, *RV;
  unsigned char *Uo, *Vo;
  int pixels = Width * abs(Height), tmp;

  tmp = pixels / 16;
  RU=inimage+pixels;
  RV=RU+tmp;

  memcpy(Y, inimage, pixels);
  for (y = Height/32; y>0; y--)
  {
    Vo=V+Width;
    Uo=U+Width;
    for (x = Width/4; x > 0; x--)
    {
      *U++ = *Uo++ = *RU;
      *U++ = *Uo++ = *RU;
      *U++ = *Uo++ = *RU;
      *U++ = *Uo++ = *RU++;
      *V++ = *Vo++ = *RV;
      *V++ = *Vo++ = *RV;
      *V++ = *Vo++ = *RV;
      *V++ = *Vo++ = *RV++;
    }
    V=Vo; U=Uo;
  }
 return (NoErrors);
}

/*
** Name:    ScConvert1611sTo422i_C
** Purpose: convert a YCrCb 16:1:1 (YUV9/YVU9) to 4:2:2 interleaved
*/
ScStatus_t ScConvert1611sTo422i_C(u_char *inimage, u_char *outimage,
                                  int Width, int Height)
{
  register int x, y;
  const int HalfWidth=Width/2;
  unsigned char *Ye, *Yo, *Ye2, *Yo2, *RU, *RV;
  unsigned char *o1, *e1, *o2, *e2;
  unsigned char U, V;

  RU=inimage+Width*abs(Height);
  RV=RU+(Width*abs(Height))/16;

  e1=outimage;
  Ye=inimage;
  for (y = abs(Height)/4; y>0; y--)
  {
    Yo=Ye+Width;
    Ye2=Yo+Width;
    Yo2=Ye2+Width;
    o1=e1+Width*2;
    e2=o1+Width*2;
    o2=e2+Width*2;
    for (x = Width/4; x > 0; x--)
    {
      U = *RU++;
      V = *RV++;
      /* even line */
      *e1++ = *Ye++;
      *e1++ = U;
      *e1++ = *Ye++;
      *e1++ = V;
      *e1++ = *Ye++;
      *e1++ = U;
      *e1++ = *Ye++;
      *e1++ = V;
      /* odd line */
      *o1++ = *Yo++;
      *o1++ = U;
      *o1++ = *Yo++;
      *o1++ = V;
      *o1++ = *Yo++;
      *o1++ = U;
      *o1++ = *Yo++;
      *o1++ = V;
      /* even line */
      *e2++ = *Ye2++;
      *e2++ = U;
      *e2++ = *Ye2++;
      *e2++ = V;
      *e2++ = *Ye2++;
      *e2++ = U;
      *e2++ = *Ye2++;
      *e2++ = V;
      /* odd line */
      *o2++ = *Yo2++;
      *o2++ = U;
      *o2++ = *Yo2++;
      *o2++ = V;
      *o2++ = *Yo2++;
      *o2++ = U;
      *o2++ = *Yo2++;
      *o2++ = V;
    }
    e1=o2;
    Ye=Yo2;
  }
 return (NoErrors);
}

/*
** Name:    ScConvert411sTo1611s_C
** Purpose: convert a YCrCb 4:1:1 to YCrCb 16:1:1 (YUV9/YVU9)
*/
ScStatus_t ScConvert411sTo1611s_C (u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height)
{
  register int x, y, c0, c1, c2, c3;
  unsigned char *Ue, *Uo, *Ve, *Vo;
  int pixels = Width * abs(Height), tmp;
  Width/=2;
  tmp = pixels / 4;
  Ue=inimage+pixels;
  Uo=Ue+Width;
  Ve=Ue+tmp;
  Vo=Ve+Width;

  memcpy(Y, inimage, pixels);
  for (y = 0; y < tmp; y+=2)
  {
    for (x=0; x<Width; x+=2)
    {
      c0=*Ue++;
      c1=*Ue++;
      c2=*Uo++;
      c3=*Uo++;
      *U++ = (c0+c1+c2+c3)/4;
    }
    Ue=Uo;
    Uo+=Width;
  }
  for (y = 0; y < tmp; y+=2)
  {
    for (x=0; x<Width; x+=2)
    {
      c0=*Ve++;
      c1=*Ve++;
      c2=*Vo++;
      c3=*Vo++;
      *V++ = (c0+c1+c2+c3)/4;
    }
    Ve=Vo;
    Vo+=Width;
  }
  return (NoErrors);
}

/*
** Function: ScConvertNTSCtoCIF422()
** Purpose:  Convert a Q/CIF frame from a 4:2:2 NTSC input.  We dup every 10th
**           pixel horizontally and every 4th line vertically.  We also
**           discard the chroma on every other line, since CIF wants 4:1:1.
*/
ScStatus_t ScConvertNTSC422toCIF411_C(u_char *framein,
                         u_char *yp, u_char *up, u_char *vp,
                         int stride)
{
  int h, w;

  int vdup = 5;
  for (h = 0; h < 240; ++h)
  {
    int hdup = 10/2;
    for (w = 320; w > 0; w -= 2)
    {
      yp[0] = framein[0];
      yp[1] = framein[2];
      yp += 2;
      if ((h & 1) == 0)
      {
        *up++ = framein[1];
        *vp++ = framein[3];
      }
      framein += 4;
      if (--hdup <= 0)
      {
        hdup = 10/2;
        yp[0] = yp[-1];
        yp += 1;
        if ((h & 1) == 0)
        {
          if ((w & 2) == 0)
          {
            up[0] = up[-1];
            ++up;
            vp[0] = vp[-1];
            ++vp;
          }
        }
      }
    }
    if (--vdup <= 0)
    {
      vdup = 5;
      /* copy previous line */
      memcpy((char*)yp, (char*)yp - stride, stride);
      yp += stride;
      if ((h & 1) == 0)
      {
        int s = stride >> 1;
        memcpy((char*)up, (char*)up - s, s);
        memcpy((char*)vp, (char*)vp - s, s);
        up += s;
        vp += s;
      }
    }
  }
  return (NoErrors);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sc_file.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_file.c,v $
 * Revision 1.1.8.6  1996/12/12  20:54:43  Hans_Graves
 * 	Fix some NT warnings (when linking statically).
 * 	[1996/12/12  20:07:58  Hans_Graves]
 *
 * Revision 1.1.8.5  1996/11/04  22:38:38  Hans_Graves
 * 	Fixed open/closes under NT. File closes weren't always happening.
 * 	[1996/11/04  22:29:53  Hans_Graves]
 * 
 * Revision 1.1.8.4  1996/10/28  17:32:18  Hans_Graves
 * 	Replace longs with dwords for NT portability.
 * 	[1996/10/28  16:54:46  Hans_Graves]
 * 
 * Revision 1.1.8.3  1996/09/18  23:45:38  Hans_Graves
 * 	Added ScFileClose() for portability
 * 	[1996/09/18  21:53:20  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/05/07  19:55:45  Hans_Graves
 * 	Fix file creation under NT.
 * 	[1996/05/07  17:11:18  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/04/01  16:23:08  Hans_Graves
 * 	Added ScFileOpen and ScFileRead/Write functions for portability
 * 	[1996/04/01  16:11:56  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/02/07  23:23:48  Hans_Graves
 * 	Added ScFileSeek().
 * 	[1996/02/07  23:21:55  Hans_Graves]
 * 
 * Revision 1.1.4.2  1996/01/02  18:30:51  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added include files for NT.
 * 	[1996/01/02  15:25:02  Bjorn_Engberg]
 * 
 * Revision 1.1.2.5  1995/09/20  14:59:32  Bjorn_Engberg
 * 	Port to NT
 * 	[1995/09/20  14:41:12  Bjorn_Engberg]
 * 
 * Revision 1.1.2.4  1995/07/12  19:48:22  Hans_Graves
 * 	Added H261 recognition to ScFileType().
 * 	[1995/07/12  19:33:48  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/22  21:36:00  Hans_Graves
 * 	Moved ScGetFileType() from sv_gentoc.c. Added some Audio file types.
 * 	[1995/06/22  21:33:05  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:07:49  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:13:00  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/07  18:55:36  Hans_Graves
 * 	Added FileExists()
 * 	[1995/04/07  18:55:13  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  18:34:21  Hans_Graves
 * 	Inclusion in SLIB's Su library
 * 	[1995/04/07  18:33:26  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#include <fcntl.h>
#include <sys/types.h>
#ifndef WIN32
#include <sys/mman.h>
#endif /* WIN32 */
#include <sys/stat.h>
#include "SC.h"
#include "SC_err.h"

#ifdef WIN32
#include <string.h>
#include <sys/stat.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>
#endif

/*
** Name:     ScFileExists
** Purpose:  Does this file exist?
**
*/
ScBoolean_t ScFileExists(char *filename)
{
#ifdef WIN32
  struct _stat stat_buf;
  if (_stat(filename, &stat_buf))
#else
  struct stat stat_buf;
  if (stat(filename, &stat_buf))
#endif
    return(FALSE);
  else
    return(TRUE);
}

/*
** Name:    ScFileOpenForReading
** Purpose: Open a file for reading.
** Returns: Handle to file.
**          -1 if error
*/
int ScFileOpenForReading(char *filename)
{
  if (!filename)
    return(-1);
#ifdef WIN32
  return((int)_open(filename, _O_RDONLY|_O_BINARY));
#else /* OSF */
  return((int)open(filename, O_RDONLY));
#endif
}

/*
** Name:    ScFileOpenForWriting
** Purpose: Open a file for writing.  Creates it if it doesn't already exist.
** Returns: Handle to file.
**          -1 if error
*/
int ScFileOpenForWriting(char *filename, ScBoolean_t truncate)
{
  if (!filename)
    return(-1);
#ifdef WIN32
  if (truncate)
    return((int)_open(filename, _O_WRONLY|_O_CREAT|_O_TRUNC|_O_BINARY,
                                _S_IREAD|_S_IWRITE));
  else
    return((int)_open(filename, _O_WRONLY|_O_CREAT|_O_BINARY,
                                _S_IREAD|_S_IWRITE));
#else
  if (truncate)
    return((int)open(filename, O_WRONLY|O_CREAT|O_TRUNC,
                           S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH));
  else
    return((int)open(filename, O_WRONLY|O_CREAT,
                           S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH));
#endif
}

/*
** Name:    ScFileSize
** Purpose: Get the size of a file in bytes
*/
ScStatus_t ScFileSize(char *filename, unsigned qword *size)
{
#ifdef WIN32
  struct _stat stat_buf;
#else
  struct stat stat_buf;
#endif

  if (!filename || !size)
    return(ScErrorBadArgument);
#ifdef WIN32
  if (_stat(filename, &stat_buf) < 0)
#else
  if (stat(filename, &stat_buf) < 0)
#endif
  {
    *size=0;
    return(ScErrorFile);
  }
  *size=(unsigned qword)stat_buf.st_size;
  return(NoErrors);
}

/*
** Name: ScFileRead
** Purpose: Read a number of bytes from a file into a buffer
** Return:  Number of bytes read
**          -1 if EOF
*/
dword ScFileRead(int fd, void *buffer, unsigned dword bytes)
{
#ifdef __VMS
   return((long)fread(buffer, 1, bytes, fd));
#elif defined(WIN32)
   return((long)_read(fd, buffer, bytes));
#else /* UNIX */
   return((long)read(fd, buffer, bytes));
#endif
}

/*
** Name: ScFileWrite
** Purpose: Write a number of bytes from a buffer to a file
** Return:  Number of bytes written
**          0 if error
*/
dword ScFileWrite(int fd, void *buffer, unsigned dword bytes)
{
#ifdef __VMS
   return((dword)fwrite(buffer, 1, bytes, fd));
#elif defined(WIN32)
   return((dword)_write(fd, buffer, bytes));
#else /* UNIX */
   return((dword)write(fd, buffer, bytes));
#endif
}

/*
** Name: ScFileSeek
** Purpose: Seek to a specific position is a file
*/
ScStatus_t ScFileSeek(int fd, qword bytepos)
{
#ifdef __VMS
  if (fseek(fd,bytepos,SEEK_SET)<0)
#elif defined(WIN32)
  if (_lseek(fd,(long)bytepos,SEEK_SET)<0)
#else
  if (lseek(fd,(long)bytepos,SEEK_SET)<0)
#endif
    return(ScErrorFile);
  else
    return(NoErrors);
}

/*
** Name: ScFileClose
** Purpose: Close an opened file
*/
void ScFileClose(int fd)
{
  if (fd>=0)
  {
#ifdef WIN32
   _close(fd);
#else /* UNIX or VMS */
   close(fd);
#endif
  }
}

/*
** Name:    ScFileMap
** Purpose: Map an entire file to memory
**          if fd<0 then the filename is opened for reading
** Returns: buffer = memory pointer to the mapped file
**          size   = size of the buffer (file)
*/
ScStatus_t ScFileMap(char *filename, int *pfd, u_char **buffer, 
                                         unsigned qword *size)
{
#ifdef WIN32

  /*
   * Mapping of files can be supported on NT,
   * but for now return an error and implement
   * file mapping later - BE.
   */
   return(ScErrorMapFile);

#else /* !WIN32 */
  if (!pfd || !filename || !buffer || !size)
    return(ScErrorBadArgument);
  if (ScFileSize(filename, size)!=NoErrors)
    return(ScErrorFile);

  if (*pfd<0)
  {
    if ((*pfd = open (filename, O_RDONLY)) < 0)
      return(ScErrorFile);
  }

  *buffer= (unsigned char *)mmap(0, *size, PROT_READ,
                   MAP_FILE | MAP_VARIABLE | MAP_PRIVATE, *pfd, 0);
  if (*buffer==(u_char *)-1L)
  {
    *buffer=NULL;
    *size=0;
    return(ScErrorMapFile);
  }

#endif /* !WIN32 */
  return(NoErrors);
}

/*
** Name:    ScFileUnMap
** Purpose: UnMap a file mapped to memory
**          if fd>=0 then the file is closed
*/
ScStatus_t ScFileUnMap(int fd, u_char *buffer, unsigned int size)
{
  if (!buffer || !size)
    return(ScErrorBadArgument);
#ifndef WIN32
  if (munmap(buffer, size)<0)
#endif /* !WIN32 */
    return(ScErrorMapFile);
  if (fd>=0)
    ScFileClose(fd);
  return(NoErrors);
}

/*
** Name:    ScGetFileType
** Purpose: Find out the type of a multmedia file.
** Returns: UNKNOWN_FILE, AVI_FILE, JFIF_FILE, QUICKTIME_JPEG_FILE
**          MPEG_VIDEO_FILE, MPEG_AUDIO_FILE, MPEG_SYSTEM_FILE,
**          GSM_FILE
*/
int ScGetFileType(char *filename)
{
  int fd;
  u_char buf[20];
  char *fileext;

  if ((fd = ScFileOpenForReading(filename)) < 0)
    return(ScErrorDevOpen);

  ScFileRead(fd, buf, 11);

  /*
  ** MPEG video file
  */
  if ((buf[0] == 0) &&
      (buf[1] == 0) &&
      (buf[2] == 1) &&
      (buf[3] == 0xb3)) {
    ScFileClose(fd);
    return(MPEG_VIDEO_FILE);
  }
  /*
  ** MPEG system file
  */
  if ((buf[0] == 0x00) &&
      (buf[1] == 0x00) &&
      (buf[2] == 0x01) &&
      (buf[3] == 0xba)) {
    ScFileClose(fd);
    return(MPEG_SYSTEM_FILE);
  }
  /*
  ** H261 video stream file
  */
  if ((buf[0] == 0x00) &&
      (buf[1] == 0x01) &&
      (buf[2] == 0x00) &&
      (buf[3] == 0x88)) {
    ScFileClose(fd);
    return(H261_FILE);
  }
  /*
  ** JFIF file (ffd8 = Start-Of-Image marker)
  */
  if ((buf[0] == 0xff) &&
      (buf[1] == 0xd8)) {
    ScFileClose(fd);
    return(JFIF_FILE);
  }
  /*
  ** QUICKTIME JPEG file (4 ignored bytes, "mdat", ff, d8, ff)
  */
  if ((strncmp(&buf[4], "mdat", 4) == 0 ) &&
      (buf[8]  == 0xff) &&
      (buf[9]  == 0xd8) &&
      (buf[10] == 0xff)) {
    ScFileClose(fd);
    return(QUICKTIME_JPEG_FILE);
  }
  /******* use the file's extension to help guess the type ********/
  for (fileext=filename; *fileext; fileext++)
    if (*fileext=='.' && *(fileext+1)!='.')
    {
      fileext++;
      if (strncmp(fileext, "p64", 3)==0)
      {
        ScFileClose(fd);
        return(H261_FILE);
      }
      if (strncmp(fileext, "gsm", 3)==0)
      {
        ScFileClose(fd);
        return(GSM_FILE);
      }
      if (strncmp(fileext, "pcm", 3)==0)
      {
        ScFileClose(fd);
        return(PCM_FILE);
      }
      if (strncmp(fileext, "wav", 3)==0 && strncmp(buf, "RIFF", 4)==0)
      {
        ScFileClose(fd);
        return(WAVE_FILE);
      }
      if (strncmp(fileext, "mp", 2)==0 && buf[0]==0xFF)
      {
        ScFileClose(fd);
        return(MPEG_AUDIO_FILE);
      }
      break;
    }

  /*
  ** AVI RIFF file
  */
  if ( strncmp(buf, "RIFF", 4) == 0 ) {
    ScFileClose(fd);
    return(AVI_FILE);
  }

  ScFileClose(fd);
  return(UNKNOWN_FILE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sc_conv.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: SC_convert.h,v $
 * Revision 1.1.9.4  1996/09/29  22:19:34  Hans_Graves
 * 	Added stride argument to ScYuv411ToRgb()
 * 	[1996/09/29  21:27:43  Hans_Graves]
 *
 * Revision 1.1.9.3  1996/09/18  23:45:50  Hans_Graves
 * 	Added protos for ScRgbToYuv411(), 411sTo422i, 411sTo422s,
 * 	and 1611PlanarTo411
 * 	[1996/09/18  23:31:09  Hans_Graves]
 * 
 * Revision 1.1.9.2  1996/08/20  22:11:52  Bjorn_Engberg
 * 	For NT - Made several routines public to support JV3.DLL and SOFTJPEG.DLL.
 * 	[1996/08/20  21:53:26  Bjorn_Engberg]
 * 
 * Revision 1.1.6.5  1996/04/11  20:22:02  Hans_Graves
 * 	Removed protos for GetDitherTemplate10/15(), their static now.
 * 	[1996/04/11  20:05:44  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/04/10  21:47:19  Hans_Graves
 * 	Added _S after assembly routines
 * 	[1996/04/10  21:21:54  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/04/09  16:04:34  Hans_Graves
 * 	Added USE_C ifdef.
 * 	[1996/04/09  14:48:31  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/03/29  22:21:02  Hans_Graves
 * 	Cleaned up convert protos
 * 	[1996/03/29  21:46:48  Hans_Graves]
 * 
 * Revision 1.1.4.4  1996/01/08  16:20:39  Bjorn_Engberg
 * 	Got rid of compiler warning messages.
 * 	[1996/01/08  15:23:14  Bjorn_Engberg]
 * 
 * Revision 1.1.4.3  1996/01/02  18:31:15  Bjorn_Engberg
 * 	Added and improved function prototypes.
 * 	[1996/01/02  15:03:03  Bjorn_Engberg]
 * 
 * Revision 1.1.4.2  1995/12/07  19:31:21  Hans_Graves
 * 	Added prototype for ScConvert422PlanarTo411_C()
 * 	[1995/12/07  17:44:41  Hans_Graves]
 * 
 * Revision 1.1.2.18  1995/11/30  20:17:04  Hans_Graves
 * 	Renamed ScYuvToRgb() to ScYuv422toRgb()
 * 	[1995/11/30  20:10:09  Hans_Graves]
 * 
 * Revision 1.1.2.17  1995/11/28  22:47:31  Hans_Graves
 * 	Added prototype for ScYuv1611ToRgb()
 * 	[1995/11/28  21:34:55  Hans_Graves]
 * 
 * Revision 1.1.2.16  1995/11/17  21:31:25  Hans_Graves
 * 	Added prototype for ScYuv411ToRgb()
 * 	[1995/11/17  20:51:27  Hans_Graves]
 * 
 * Revision 1.1.2.15  1995/10/17  15:37:05  Karen_Dintino
 * 	Move DitherTemplate routines from render to common
 * 	[1995/10/17  15:36:49  Karen_Dintino]
 * 
 * Revision 1.1.2.14  1995/10/13  16:57:16  Bjorn_Engberg
 * 	Added prototypes for routines in sc_convert_yuv.c
 * 	[1995/10/13  16:48:55  Bjorn_Engberg]
 * 
 * Revision 1.1.2.13  1995/10/10  21:43:04  Bjorn_Engberg
 * 	Modified RgbToYuv prototype declarations.
 * 	[1995/10/10  21:10:52  Bjorn_Engberg]
 * 
 * Revision 1.1.2.12  1995/10/06  20:46:29  Farokh_Morshed
 * 	Change ScRgbInterlToYuvInterl to take a Bmh by reference
 * 	[1995/10/06  20:46:06  Farokh_Morshed]
 * 
 * Revision 1.1.2.11  1995/10/02  19:30:52  Bjorn_Engberg
 * 	Added more BI_BITFIELDS formats.
 * 	[1995/10/02  18:15:47  Bjorn_Engberg]
 * 
 * Revision 1.1.2.10  1995/09/26  15:58:48  Paul_Gauthier
 * 	Fix mono JPEG to interlaced 422 YUV conversion
 * 	[1995/09/26  15:58:12  Paul_Gauthier]
 * 
 * Revision 1.1.2.9  1995/09/22  12:58:40  Bjorn_Engberg
 * 	Changed uchar to u_char in a function prototype.
 * 	[1995/09/22  12:48:40  Bjorn_Engberg]
 * 
 * Revision 1.1.2.8  1995/09/20  17:39:19  Karen_Dintino
 * 	Add RGB support to JPEG
 * 	[1995/09/20  17:37:04  Karen_Dintino]
 * 
 * Revision 1.1.2.7  1995/09/18  19:47:49  Paul_Gauthier
 * 	Added conversion of MPEG planar 4:1:1 to interleaved 4:2:2
 * 	[1995/09/18  19:46:15  Paul_Gauthier]
 * 
 * Revision 1.1.2.6  1995/09/15  18:17:47  Farokh_Morshed
 * 	Move ValidBI_BITFIELDSKinds from SC.h to SC_convert.h
 * 	[1995/09/15  18:17:19  Farokh_Morshed]
 * 
 * Revision 1.1.2.5  1995/09/14  14:40:35  Karen_Dintino
 * 	Move RgbToYuv out of rendition
 * 	[1995/09/14  14:25:20  Karen_Dintino]
 * 
 * Revision 1.1.2.4  1995/09/11  19:17:25  Hans_Graves
 * 	Added ValidateBI_BITFIELDS() prototype.
 * 	[1995/09/11  19:14:45  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/08/03  15:01:09  Hans_Graves
 * 	Added prototype for ScConvert422ToYUV_char()
 * 	[1995/08/03  15:00:49  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:23  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:22:50  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
** Filename: SC_convert.h
** Purpose:  Header info for using conversion routines.
*/

#include "SC.h"

enum ValidBI_BITFIELDSKinds {
  pRGB,		/* 32-bit 00RRGGBB special case */
  pBGR,		/* 32-bit 00BBGGRR special case */
  pRGB555,	/* 16-bit 0RRRRRGGGGGBBBBB special case */
  pRGB565,	/* 16-bit RRRRRGGGGGGBBBBB special case */
  pRGBnnn,	/* 16-bit general case */
  InvalidBI_BITFIELDS
};

/*********************** Prototypes *************************/
/*
** sc_convert.c
*/
EXTERN enum ValidBI_BITFIELDSKinds ValidateBI_BITFIELDS(LPBITMAPINFOHEADER lpbi);
EXTERN int ScIsUpsideDown(BITMAPINFOHEADER *lpbiIn,
			  BITMAPINFOHEADER *lpbiOut);
extern BITMAPINFOHEADER *ScCreateBMHeader(int width, int height, int bpp,
                                 int format, int ncolors);
extern ScStatus_t ScConvertSepYUVToOther(BITMAPINFOHEADER *InBmh,
				 BITMAPINFOHEADER *OutBmh,
				 u_char *OutImage,
				 u_char *YData, u_char *CbData, u_char *CrData);
extern ScStatus_t ScYuv422ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y,
                         u_char *Cb, u_char *Cr, u_char *ImageOut);
extern ScStatus_t ScYuv411ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y,
                         u_char *Cb, u_char *Cr, u_char *ImageOut,
                         int width, int height, long stride);
extern ScStatus_t ScYuv1611ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y, u_char *Cb,
                        u_char *Cr, u_char *ImageOut);
extern ScStatus_t ScConvertRGB24sTo422i_C(BITMAPINFOHEADER *Bmh,
                              u_char *R, u_char *G, u_char *B, u_short *ImageOut);
extern ScStatus_t ScConvertRGB24To411s_C(u_char *inimage,
                        u_char *Y, u_char *U, u_char *V, int width, int height);
extern ScStatus_t ScConvertRGB555To411s_C(u_char *inimage, u_char *outimage,
                                         int width, int height);
extern ScStatus_t ScConvertRGB565To411s_C(u_char *inimage, u_char *outimage,
                                         int width, int height);
EXTERN ScStatus_t ScRgbInterlToYuvInterl (LPBITMAPINFOHEADER Bmh, int Width,
			int Height, u_char *ImageIn, u_short *ImageOut);
extern ScStatus_t ScConvert422ToYUV_char_C (u_char *RawImage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern int ScConvert422ToBlockYUV(u_char *, int, float *, float *, float *,
                                    int, int);
extern void ScConvertSep422ToBlockYUV (u_char *RawImage, int bpp,
                            float *Comp1, float *Comp2, float *Comp3,
                            int Width, int Height);
extern void ScConvertGrayToBlock (u_char *RawImage, int bpp,
                       float *Comp1, int Width, int Height);
extern int ScSepYUVto422i_C(u_char *Y, u_char *U,
                            u_char *V, u_char *ImageOut,
                            u_int width, u_int height);
extern ScStatus_t ScConvert422PlanarTo411_C (u_char *RawImage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern void ScConvert422PlanarTo422i_C(u_char *Y, u_char *Cb,
				     u_char *Cr, u_char *ImageOut,
				     long width, long height );
extern void ScConvert422iTo422s_C(u_char *InImage,
                                  u_char *Y, u_char *Cb, u_char *Cr, 
                                  long width, long height);
extern void ScConvert422iTo422sf_C(u_char *InImage, int bpp,
                                  float *Y, float *U, float *V, 
                                  long width, long height);
extern void ScConvert411sTo422i_C(u_char *Y, u_char *Cb,
			          u_char *Cr, u_char *ImageOut,
				  long width, long height );
extern void ScConvert411sTo422s_C(u_char *Y, u_char *Cb,
			          u_char *Cr, u_char *ImageOut,
				  long width, long height );
extern ScStatus_t ScConvert1611sTo411s_C(u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern ScStatus_t ScConvert411sTo1611s_C (u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern ScStatus_t ScConvert1611sTo422s_C(u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern ScStatus_t ScConvert1611sTo422i_C(u_char *inimage, u_char *outimage,
                                         int Width, int Height);
extern ScStatus_t ScConvertNTSC422toCIF411_C(u_char *framein,
                         u_char *yp, u_char *up, u_char *vp,
                         int stride);
/*
** sc_convert2.s
*/
extern void ScConvert422iTo422sf_S(u_char *InImage, int bpp,
                                  float *Y, float *U, float *V, 
                                  long width, long height);
extern int ScSepYUVto422i_S(u_char *Y, u_char *U,
                          u_char *V, u_char *ImageOut,
                          u_int width, u_int height);
extern ScStatus_t ScConvert422ToYUV_char_S(u_char *RawImage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern void ScConvert422PlanarTo422i_S(u_char *Y, u_char *Cb,
				     u_char *Cr, u_char *ImageOut,
				     long width, long height );


/*
** sc_convert_yuv.c
*/

extern int ScInitYUVcvt();
extern int ScInitYUVtoRGB(void **pColpack,
			  BITMAPINFOHEADER *lpbiIn,
			  BITMAPINFOHEADER *lpbiOut);
extern int sc_SIFrenderYUVtoRGBnn(u_char *pY, u_char *pU, u_char *pV,
				  u_char *Oimage,
				  void *Colpack,
				  int pixels, int lines);
extern void YUV_To_RGB_422_Init(int bSign, int bBGR, _int64 * pTable);


#ifdef USE_C
#define ScConvert422ToYUV_char   ScConvert422ToYUV_char_C
#define ScConvert422PlanarTo422i ScConvert422PlanarTo422i_C
#define ScConvert411sTo422i      ScConvert411sTo422i_C
#define ScConvert411sTo422s      ScConvert411sTo422s_C
#define ScSepYUVto422i           ScSepYUVto422i_C
#define ScConvert422PlanarTo411  ScConvert422PlanarTo411_C
#define ScConvertNTSC422toCIF411 ScConvertNTSC422toCIF411_C
#define ScConvert422iTo422s      ScConvert422iTo422s_C
#define ScConvert422iTo422sf     ScConvert422iTo422sf_C
#define ScConvert1611sTo411s     ScConvert1611sTo411s_C
#define ScConvert411sTo1611s     ScConvert411sTo1611s_C
#define ScConvert1611sTo422s     ScConvert1611sTo422s_C
#define ScConvert1611sTo422i     ScConvert1611sTo422i_C
#define ScConvertRGB24sTo422i    ScConvertRGB24sTo422i_C
#define ScConvertRGB24To411s     ScConvertRGB24To411s_C
#define ScConvertRGB555To411s    ScConvertRGB555To411s_C
#define ScConvertRGB565To411s    ScConvertRGB565To411s_C
#else /* USE_C */
#define ScConvert422ToYUV_char   ScConvert422ToYUV_char_S
#define ScConvert422PlanarTo422i ScConvert422PlanarTo422i_S
#define ScConvert411sTo422i      ScConvert411sTo422i_C
#define ScConvert411sTo422s      ScConvert411sTo422s_C
#define ScSepYUVto422i           ScSepYUVto422i_S
#define ScConvert422PlanarTo411  ScConvert422PlanarTo411_C
#define ScConvertNTSC422toCIF411 ScConvertNTSC422toCIF411_C
#define ScConvert422iTo422s      ScConvert422iTo422s_C
#define ScConvert422iTo422sf     ScConvert422iTo422sf_S
#define ScConvert1611sTo411s     ScConvert1611sTo411s_C
#define ScConvert411sTo1611s     ScConvert411sTo1611s_C
#define ScConvert1611sTo422s     ScConvert1611sTo422s_C
#define ScConvert1611sTo422i     ScConvert1611sTo422i_C
#define ScConvertRGB24sTo422i    ScConvertRGB24sTo422i_C
#define ScConvertRGB24To411s     ScConvertRGB24To411s_C
#define ScConvertRGB555To411s    ScConvertRGB555To411s_C
#define ScConvertRGB565To411s    ScConvertRGB565To411s_C
#endif /* USE_C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sc_mem.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_mem.c,v $
 * Revision 1.1.4.2  1996/01/02  18:30:56  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added include files for NT.
 * 	[1996/01/02  15:25:04  Bjorn_Engberg]
 *
 * Revision 1.1.2.4  1995/09/20  14:59:33  Bjorn_Engberg
 * 	Port to NT
 * 	[1995/09/20  14:41:14  Bjorn_Engberg]
 *
 * Revision 1.1.2.3  1995/09/14  17:28:09  Bjorn_Engberg
 * 	Ported to NT
 * 	[1995/09/14  17:21:10  Bjorn_Engberg]
 *
 * Revision 1.1.2.2  1995/05/31  18:07:53  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:15:46  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/05/03  19:12:55  Hans_Graves
 * 	First time under SLIB
 * 	[1995/05/03  19:12:17  Hans_Graves]
 *
 * Revision 1.1.2.3  1995/04/17  17:46:54  Hans_Graves
 * 	Added ScAlloc2()
 * 	[1995/04/17  17:45:28  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/04/07  18:40:03  Hans_Graves
 * 	Inclusion in SLIB's Su library
 * 	[1995/04/07  18:39:43  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1993                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*-------------------------------------------------------------------------
**  Modification History: sc_mem.c
**      05-29-93  Victor Bahl  Paged aligned malloc and free
**      12-07-93  PSG          Added error reporting code
**      03-15-95  HWG          Moved to Su library, Added SuAlloc & SuFree
**      04-04-97  HWG          With WIN32 use LocalAlloc and LocalFree in
**                               place of malloc and free
**                             Added ScCalloc function.
**      04-15-97  HWG          Added memory linked list to help track leaks
**                             Fixed potential initalization bug in linked
**                               list used to track ScPaMalloc's
--------------------------------------------------------------------------*/
/*
#define _SLIBDEBUG_
*/

#include <stdio.h>  /* NULL */
#include <sys/types.h>
#ifdef WIN32
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#endif /* WIN32 */
#include "SC.h"
#include "SC_err.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_     0  /* detailed debuging statements */
#define _VERBOSE_   0  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */

/* keep a linked list to ttrack memory leaks */
typedef struct memblock_s {
    void *ptr;
    dword size;
    dword counter;
    char  desc[15];
    struct memblock_s *next;
} memblock_t;

static memblock_t *_blocklist=NULL;
static _blockcounter=0;
static _memused=0;

void scMemAddWatch(void *ptr, dword size, char *desc)
{
  memblock_t *pblock;
#if defined(WIN32)
  pblock = (void *)LocalAlloc(LPTR, sizeof(memblock_t));
#else
  pblock = (void *)malloc(sizeof(memblock_t));
#endif
  _memused+=size;
  if (pblock)
  {
    pblock->ptr=ptr;
    pblock->next=_blocklist;
    pblock->size=size;
    pblock->counter=_blockcounter;
    if (desc==NULL)
      pblock->desc[0]=0;
    else
    {
      int i;
      for (i=0; desc[i] && i<14; i++)
        pblock->desc[i]=desc[i];
      pblock->desc[i]=0;
    }
    _blocklist=pblock;
    _blockcounter++;
  }
}

ScBoolean_t scMemRemoveWatch(void *ptr)
{
  memblock_t *plastblock=NULL, *pblock=_blocklist;
  while (pblock)
  {
    if (pblock->ptr==ptr) /* remove from list */
    {
      if (plastblock==NULL) /* beginning of linked list */
        _blocklist=pblock->next;
      else
        plastblock->next=pblock->next;
      _memused-=pblock->size;
#ifdef WIN32
      LocalFree(pblock);
#else
      free(pblock);
#endif
      if (_blocklist==NULL) /* all memory freed, reset counter */
        _blockcounter=0;
      return(TRUE);
    }
    plastblock=pblock;
    pblock=pblock->next;
  }
  return(FALSE);
}

dword scMemDump()
{
  memblock_t *plastblock=NULL, *pblock=_blocklist;
  ScDebugPrintf(NULL, "scMemDump: memused=%ld\n", _memused);
  while (pblock)
  {
    ScDebugPrintf(NULL, " ptr=%p counter=%ld size=%ld desc=%s\n",
        pblock->ptr, pblock->counter, pblock->size, pblock->desc);
    pblock=pblock->next;
  }
  return(_memused);
}
#endif

#ifdef WIN32
int getpagesize()
{
    SYSTEM_INFO sysInfo;
    static int pagesize = 0 ;

    if( pagesize == 0 ) {
	GetSystemInfo(&sysInfo);

	pagesize = (int)sysInfo.dwPageSize;
    }

    return pagesize ;
}

#define bzero(_addr_,_len_) memset(_addr_,0,_len_)
#endif

/*------------------------------------------------------------------------
                         Simple Memory Allocation
-------------------------------------------------------------------------*/
/*
** Name:    ScAlloc
** Purpose: Allocate number of bytes of memory.
**
*/
void *ScAlloc(unsigned long bytes)
{
  void *ptr;

#ifdef  MACINTOSH
  ptr = NewPtr(bytes);
#elif MSC60
  ptr = (void FAR *) _fmalloc((unsigned int)bytes); /* far memory */
#elif defined(WIN32)
  ptr = (void *)LocalAlloc(LPTR, bytes);
#else
  ptr = (void *)malloc(bytes);
#endif
  _SlibDebug(ptr, scMemAddWatch(ptr, bytes, NULL) );
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "ScAlloc(%ld) returns %p\n",bytes,ptr) );
  return(ptr);
}

/*
** Name:    ScCalloc
** Purpose: Allocate number of bytes of memory and zero it out.
**
*/
void *ScCalloc(unsigned long bytes)
{
  void *ptr = ScAlloc(bytes);
  if (ptr != NULL)
  {
#ifdef  MSC60
     _fmemset(ptr, 0, (unsigned int)bytes);
#else
     memset(ptr, 0, bytes);
#endif
  }
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "ScCalloc(%ld) returns %p\n",bytes,ptr) );
  return(ptr);
}

/*
** Name:    ScAlloc2
** Purpose: Allocate number of bytes of memory equal to "bytes".
**          Takes an extra argument "name" which identifies the block
**          (used for debugging).
*/
void *ScAlloc2(unsigned long bytes, char *desc)
{
  void *ptr;

  ptr = ScAlloc(bytes);
#ifdef _SLIBDEBUG_
  if (_blocklist) /* copy description to leak tracking info */
  {
    int i;
    for (i=0; desc[i] && i<14; i++)
      _blocklist->desc[i]=desc[i];
    _blocklist->desc[i]=0;
  }
#endif
  _SlibDebug(_DEBUG_,
      ScDebugPrintf(NULL, "ScAlloc(%ld, %s) returns %p\n",bytes,desc,ptr) );
  return(ptr);
}

/*
** Name:    ScFree
** Purpose: Free memory pointed to by "*ptr_addr"
**
*/
void ScFree(void *ptr)
{
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "ScFree(%p)\n", ptr) );
  _SlibDebug(ptr, scMemRemoveWatch(ptr) );
  if (ptr != NULL)
  {
#ifdef MACINTOSH
    DisposPtr(ptr);
#elif defined(WIN32)
#ifdef _SLIBDEBUG_
    _SlibDebug(LocalFree(ptr)!=NULL, ScDebugPrintf(NULL, "ScFree(%p) failed\n", ptr) );
#else
    LocalFree(ptr);
#endif
#else
    free(ptr);
#endif
  }
}

/*
** Name:    ScMemCheck
** Purpose: Check block of memory all equal to a single byte,
**          else return FALSE
*/
int ScMemCheck(char *array, int test, int num)
{
  int i=0;
  /* 'test' is only tested as a char (bottom 8 bits) */
  while (array[i] == test && i<num)
    i++;
  if (i==num)
    return TRUE;
  else
    return FALSE;
}

/*------------------------------------------------------------------------
                Paged aligned malloc() and free()
-------------------------------------------------------------------------*/

/*
** This structure is used by the page align malloc/free support code.
** These "working sets" will  contain  the malloc-ed address and the
** page aligned address for the free*() call.
*/
typedef struct mpa_ws_s
{
    char *palign_addr;          /* the page aligned address that's used */
    char *malloc_addr;          /* the malloc-ed address to free */
    struct mpa_ws_s *next;      /* for the next on the list */
} mpa_ws_t;


/*
** Initialized and uninitialized data.
*/
static mpa_ws_t *mpa_qhead=NULL;      /* local Q head for the malloc stuctures */


/*
** Name:    ScPaMalloc
** Purpose: Allocate Paged Alligned Memory
**          This  routine  allocates  and returns to  the caller a system
**          page  aligned buffer. Enough  space  will  be added, one more
**          page, to allow the pointers to be  adjusted  to the next page
**          boundry. A local linked list will keep copies of the original
**          and adjusted addresses. This list will be used by sv_PaFree()
**          to free the correct buffer.
**
*/
char *ScPaMalloc(int size)
{
    mpa_ws_t *ws;                 /* pointer for the working set  */
    ULONG_PTR tptr;               /* to store pointer temp for bit masking */
    int PageSize = getpagesize(); /* system's page size           */

    /*
    ** The space for the working set structure that will go on the queue
    ** is allocated first.
    */
    if ((ws = (mpa_ws_t *)ScAlloc(sizeof(mpa_ws_t))) == (mpa_ws_t *)NULL)
        return( (char *)NULL );


    /*
    ** Using the requested size, from the argument list, and the page size
    ** from the system,  allocate enough space to page align the requested
    ** buffer.  The original request will have the space of one system page
    ** added to it.  The pointer will be adjusted.
    */
    ws->malloc_addr = (char *)ScAlloc(size + PageSize);
    if (ws->malloc_addr == (char *)NULL)
    {
      ScFree(ws);                              /* not going to be used */
      return((char *)NULL);                    /* signal the failure */
    } else
        (void) bzero (ws->malloc_addr, (size + PageSize));

    /*
    ** Now using the allocated space + 1 page, adjust the pointer to
    ** point to the next page boundry.
    */
    ws->palign_addr = ws->malloc_addr + PageSize;       /* to the next page */

    /*
    ** Using the page size and subtracting 1 to get a bit mask, mask off
    ** the low order "page offset" bits to get the aligned address.  Now the
    ** aligned pointer will contain the address of the next page with enough
    ** space to hold the users requested size.
    */
    tptr  = (ULONG_PTR)ws->palign_addr;            /* copy to local int    */
    tptr &= (ULONG_PTR)(~(PageSize - 1));          /* Mask addr bit to the */
    ws->palign_addr = (char *)tptr;             /* put back the address */
    /*
    ** Put the working set onto the linked list so that the original
    ** malloc-ed buffer can be freeed when the user program is done with it.
    */
    ws->next=mpa_qhead;
    mpa_qhead=ws;                  /* just put it at the head */

    /*
    ** Now return the aligned address to the caller.
    */
    return((char *)ws->palign_addr);
}

/*
** Name:    ScPaFree
** Purpose: This is a local free routine to return to the system a previously
**          alloc-ed buffer.  A local linked list keeps copies of the original
**          and adjusted addresses.  This list is used by this routine to free
**          the correct buffer.
*/
void ScPaFree (void *pa_addr)
{
    mpa_ws_t *p, *q;                    /* walkers for the malloc list */

    /*
    ** Walk along the malloc-ed memory linked list, watch for a match
    ** on the page aligned address.  If a match is found break out of the
    ** loop.
    */
    p = mpa_qhead;                 /* set the pointers */
    q = NULL;

    while (p != NULL)
    {
       if (p->palign_addr == pa_addr)   /* found the buffer */
          break;

       q = p;                           /* save current */
       p = p->next;                     /* get next */
    }
    _SlibDebug(_WARN_ && p==NULL,
      ScDebugPrintf(NULL, "ScPaFree(%p) Illegal pointer\n", pa_addr) );

    /*
    ** After falling out of the loop the pointers are at the place where
    ** some work has to be done, (this could also be at the beginning).
    ** If a match is found call the free() routine to return the buffer, if
    ** the loop fell off the end just return.
    */
    if (p != NULL)
    {
        /*
        ** Where on the list is it, check for making it empty.
        */
        if (q == NULL)                   /* at the front */
            mpa_qhead = p->next;   /* pop off front */
        else                            /* inside the list */
            q->next = p->next;          /* pop it */

        ScFree(p->malloc_addr);           /* free the malloc-ed addr */

        /*
        ** Now free up the working set, it is not needed any more.
        */
        ScFree(p);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sc_dct.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_dct.c,v $
 * Revision 1.1.4.6  1996/01/08  16:41:14  Hans_Graves
 * 	Moved IDCT routines to sc_idct.c
 * 	[1996/01/08  15:31:42  Hans_Graves]
 *
 * Revision 1.1.4.5  1996/01/02  18:30:42  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added Casts, Removed unused local variables.
 * 	[1996/01/02  15:23:37  Bjorn_Engberg]
 * 
 * Revision 1.1.4.4  1995/12/28  18:16:55  Bjorn_Engberg
 * 	Define floorf = floor for NT since NT does not have floorf.
 * 	[1995/12/28  17:10:31  Bjorn_Engberg]
 * 
 * Revision 1.1.4.3  1995/12/07  19:31:16  Hans_Graves
 * 	Added ScFDCT8x8s_C() and ScIDCT8x8s_C to be used by MPEG encoder
 * 	[1995/12/07  17:43:21  Hans_Graves]
 * 
 * Revision 1.1.4.2  1995/09/13  14:51:40  Hans_Graves
 * 	Added ScScaleIDCT8x8().
 * 	[1995/09/13  14:40:56  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:07:33  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:08:02  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
** Filename: sc_dct.c
** DCT related functions.
** (Pulled from MPEG/JPEG Decode & Encode source.)
*/

#include <math.h>
#include "SC.h"

/*-----------------------------------------------------------------------
                Forward Discrete Cosine Transform
 -------------------------------------------------------------------------*/

#define F (float)
#define RSQ2    F 0.7071067811865
#define COSM1P3 F 1.3065629648764
#define COS1M3  F 0.5411961001462
#define COS3    F 0.3826834323651

#ifdef WIN32
#define floorf  F floor
#endif /* WIN32 */

/*
** Name:    ScIFDCT
** Purpose: IFDCT takes the fast inverse DCT of 32 data points
*/
void ScIFDCT(float in_block[32], float out_block[32])
{
        static float            cpi4,cpi8,c3pi8,cpi16,c3pi16;
        static float            cpi32,c3pi32,c5pi32,c7pi32;
        static float            spi8,s3pi8,spi16,s3pi16;
        static float            spi32,s3pi32,s5pi32,s7pi32;
        static float            cpi64,c17pi64,c9pi64,c25pi64,c5pi64,c21pi64;
        static float            c13pi64,c29pi64;
        static float            spi64,s17pi64,s9pi64,s25pi64,s5pi64,s21pi64;
        static float            s13pi64,s29pi64;

        static int              init=0;

        float                   temp;
        float                   c0,c1,c2,c3,c4,c5,c6,c7,c8;
        float                   c9,c10,c11,c12,c13,c14,c15;
        float                   c16,c17,c18,c19,c20,c21,c22;
        float                   c23,c24,c25,c26,c27,c28,c29;
        float                   c30,c31;
        float                   d0,d1,d2,d3,d4,d5,d6,d7,d8;
        float                   d9,d10,d11,d12,d13,d14,d15;
        float                   d16,d17,d18,d19,d20,d21,d22;
        float                   d23,d24,d25,d26,d27,d28,d29;
        float                   d30,d31;
        float                   e0,e1,e2,e3,e4,e5,e6,e7,e8;
        float                   e9,e10,e11,e12,e13,e14,e15;
        float                   e16,e17,e18,e19,e20,e21,e22;
        float                   e23,e24,e25,e26,e27,e28,e29;
        float                   e30,e31;
        float                   *out_block_ptr;
        float                   *in_block_ptr;
/* initialization.  This is to be done only once. */

        if(init==0) {
        /* establish internal variables */
	  cpi4 = F cos(PI/4.0);
          temp = F (PI/8.0);          cpi8 = F cos(temp);    spi8 = F sin(temp);
          temp = F (3.0*PI/8.0);     c3pi8 = F cos(temp);   s3pi8 = F sin(temp);
          temp = F (PI/16.0);        cpi16 = F cos(temp);   spi16 = F sin(temp);
          temp = F (3.0*PI/16.0);   c3pi16 = F cos(temp);  s3pi16 = F sin(temp);
          temp = F (PI/32.0);        cpi32 = F cos(temp);   spi32 = F sin(temp);
          temp = F (3.0*PI/32.0);   c3pi32 = F cos(temp);  s3pi32 = F sin(temp);
          temp = F (5.0*PI/32.0);   c5pi32 = F cos(temp);  s5pi32 = F sin(temp);
          temp = F (7.0*PI/32.0);   c7pi32 = F cos(temp);  s7pi32 = F sin(temp);
          temp = F (PI/64.0);        cpi64 = F cos(temp);   spi64 = F sin(temp);
          temp = F (17.0*PI/64.0); c17pi64 = F cos(temp); s17pi64 = F sin(temp);
          temp = F (9.0*PI/64.0);   c9pi64 = F cos(temp);  s9pi64 = F sin(temp);
          temp = F (25.0*PI/64.0); c25pi64 = F cos(temp); s25pi64 = F sin(temp);
          temp = F (5.0*PI/64.0);   c5pi64 = F cos(temp);  s5pi64 = F sin(temp);
          temp = F (21.0*PI/64.0); c21pi64 = F cos(temp); s21pi64 = F sin(temp);
          temp = F (13.0*PI/64.0); c13pi64 = F cos(temp); s13pi64 = F sin(temp);
          temp = F (29.0*PI/64.0); c29pi64 = F cos(temp); s29pi64 = F sin(temp);
	  init++;
        }

        /* rearrange coefficients to do bit reversed ordering */

          in_block_ptr = &in_block[0];
          d0  = *in_block_ptr++ * F 1.414213562; /******** normalization ********/

          d16 = *in_block_ptr++;
                  d8  = *in_block_ptr++;
          d24 = *in_block_ptr++;
                  e4  = *in_block_ptr++;
          d20 = *in_block_ptr++;
                  d12 = *in_block_ptr++;
          d28 = *in_block_ptr++;
          d2  = *in_block_ptr++;
          d18 = *in_block_ptr++;
                  d10 = *in_block_ptr++;
          d26 = *in_block_ptr++;
                  e6  = *in_block_ptr++;
          d22 = *in_block_ptr++;
                  d14 = *in_block_ptr++;
          d30 = *in_block_ptr++;
          d1  = *in_block_ptr++;
          d17 = *in_block_ptr++;
                  d9  = *in_block_ptr++;
          d25 = *in_block_ptr++;
                  e5  = *in_block_ptr++;
          d21 = *in_block_ptr++;
                  d13 = *in_block_ptr++;
          d29 = *in_block_ptr++;
          d3  = *in_block_ptr++;
          d19 = *in_block_ptr++;
                  d11 = *in_block_ptr++;
          d27 = *in_block_ptr++;
                  e7  = *in_block_ptr++;
          d23 = *in_block_ptr++;
                  d15 = *in_block_ptr++;
          d31 = *in_block_ptr++;

        /* first stage of fast idct */

          c16=spi64*d16-cpi64*d31;
          c31=spi64*d31+cpi64*d16;

          c17=s17pi64*d17-c17pi64*d30;
          c30=s17pi64*d30+c17pi64*d17;

          c18=s9pi64*d18-c9pi64*d29;
          c29=s9pi64*d29+c9pi64*d18;

          c19=s25pi64*d19-c25pi64*d28;
          c28=s25pi64*d28+c25pi64*d19;

          c20=s5pi64*d20-c5pi64*d27;
          c27=s5pi64*d27+c5pi64*d20;

          c21=s21pi64*d21-c21pi64*d26;
          c26=s21pi64*d26+c21pi64*d21;

          c22=s13pi64*d22-c13pi64*d25;
          c25=s13pi64*d25+c13pi64*d22;

          c23=s29pi64*d23-c29pi64*d24;
          c24=s29pi64*d24+c29pi64*d23;

        /* second stage of fast idct */

          e8=spi32*d8-cpi32*d15;
          e15=spi32*d15+cpi32*d8;

          e9=c7pi32*d9-s7pi32*d14;
          e14=c7pi32*d14+s7pi32*d9;

          e10=s5pi32*d10-c5pi32*d13;
          e13=s5pi32*d13+c5pi32*d10;

          e11=c3pi32*d11-s3pi32*d12;
          e12=c3pi32*d12+s3pi32*d11;

                  d16=c17+c16;
          e17=c16-c17;
          e18=c19-c18;
                  d19=c18+c19;
                  d20=c21+c20;
          e21=c20-c21;
          e22=c23-c22;
                  d23=c22+c23;
                  d24=c25+c24;
          e25=c24-c25;
          e26=c27-c26;
                  d27=c26+c27;
                  d28=c29+c28;
          e29=c28-c29;
          e30=c31-c30;
                  d31=c30+c31;

        /* third stage of fast idct */

          d4=spi16*e4-cpi16*e7;
          d7=spi16*e7+cpi16*e4;

          d5=c3pi16*e5-s3pi16*e6;
          d6=c3pi16*e6+s3pi16*e5;

                c8=e9+e8;
          d9=e8-e9;
          d10=e11-e10;
                c11=e10+e11;
                c12=e13+e12;
          d13=e12-e13;
          d14=e15-e14;
                c15=e14+e15;

          d17= -cpi16*e17+spi16*e30;
          d30=cpi16*e30+spi16*e17;

          d18= -spi16*e18-cpi16*e29;
          d29=spi16*e29-cpi16*e18;

          d21=c3pi16*e26-s3pi16*e21;
          d26=c3pi16*e21+s3pi16*e26;

          d22= -s3pi16*e25-c3pi16*e22;
          d25= -s3pi16*e22+c3pi16*e25;

        /* fourth stage of fast idct */

          c0=cpi4*(d1+d0);
          c1=cpi4*(d0-d1);
          c2= -cpi8*d3+spi8*d2;
          c3= cpi8*d2+spi8*d3;
                  e4=d5+d4;
          c5=d4-d5;
          c6=d7-d6;
                  e7=d6+d7;
          c9=spi8*d14-cpi8*d9;
          c14=spi8*d9+cpi8*d14;

          c10= -cpi8*d13-spi8*d10;
          c13= -cpi8*d10+spi8*d13;
                  e16=d19+d16;
          c19=d16-d19;
                  e17=d18+d17;
          c18=d17-d18;
          c20=d23-d20;
                  e23=d20+d23;
          c21=d22-d21;
                  e22=d21+d22;
                  e24=d27+d24;
          c27=d24-d27;
                  e25=d26+d25;
          c26=d25-d26;
          c28=d31-d28;
                  e31=d28+d31;
          c29=d30-d29;
                  e30=d29+d30;

        /* fifth stage of fast idct */

          e0=c3+c0;
          e3=c0-c3;
          e1=c2+c1;
          e2=c1-c2;
          e5=cpi4*(c6-c5);
          e6=cpi4*(c6+c5);
                  d8=c11+c8;
          e11=c8-c11;
                  d9=c10+c9;
          e10=c9-c10;
          e12=c15-c12;
                  d15=c12+c15;
          e13=c14-c13;
                  d14=c13+c14;
          e18=spi8*c29-cpi8*c18;
          e29=spi8*c18+cpi8*c29;

          e19=spi8*c28-cpi8*c19;
          e28=spi8*c19+cpi8*c28;

          e20= -cpi8*c27-spi8*c20;
          e27= -cpi8*c20+spi8*c27;

          e21= -cpi8*c26-spi8*c21;
          e26= -cpi8*c21+spi8*c26;

        /* sixth stage of fast dct */

          d0=e0+e7;
          d7=e0-e7;

          d1=e1+e6;
          d6=e1-e6;

          d2=e2+e5;
          d5=e2-e5;

          d3=e3+e4;
          d4=e3-e4;

          d10=cpi4*(e13-e10);
          d13=cpi4*(e13+e10);

          d11=cpi4*(e12-e11);
          d12=cpi4*(e12+e11);

                  c16=e23+e16;
          d23=e16-e23;

                  c17=e22+e17;
          d22=e17-e22;

                  c18=e21+e18;
          d21=e18-e21;

                  c19=e20+e19;
          d20=e19-e20;

          d24=e31-e24;
                  c31=e24+e31;

          d25=e30-e25;
                  c30=e25+e30;

          d26=e29-e26;
                  c29=e26+e29;

          d27=e28-e27;
                  c28=e27+e28;

        /* seventh stage of fast dct */

          c0=d0+d15;
          c15=d0-d15;

          c1=d1+d14;
          c14=d1-d14;

          c2=d2+d13;
          c13=d2-d13;

          c3=d3+d12;
          c12=d3-d12;

          c4=d4+d11;
          c11=d4-d11;

          c5=d5+d10;
          c10=d5-d10;

          c6=d6+d9;
          c9=d6-d9;

          c7=d7+d8;
          c8=d7-d8;

          c20=cpi4*(d27-d20);
          c27=cpi4*(d27+d20);

          c21=cpi4*(d26-d21);
          c26=cpi4*(d26+d21);

          c22=cpi4*(d25-d22);
          c25=cpi4*(d25+d22);

          c23=cpi4*(d24-d23);
          c24=cpi4*(d24+d23);


        /* last stage of fast idct */
          out_block_ptr = &out_block[0];
          *out_block_ptr++ = c0+c31;
          *out_block_ptr++ = c1+c30;
          *out_block_ptr++ = c2+c29;
          *out_block_ptr++ = c3+c28;
          *out_block_ptr++ = c4+c27;
          *out_block_ptr++ = c5+c26;
          *out_block_ptr++ = c6+c25;
          *out_block_ptr++ = c7+c24;
          *out_block_ptr++ = c8+c23;
          *out_block_ptr++ = c9+c22;
          *out_block_ptr++ = c10+c21;
          *out_block_ptr++ = c11+c20;
          *out_block_ptr++ = c12+c19;
          *out_block_ptr++ = c13+c18;
          *out_block_ptr++ = c14+c17;
          *out_block_ptr++ = c15+c16;
          *out_block_ptr++ = -c16+c15;
          *out_block_ptr++ = -c17+c14;
          *out_block_ptr++ = -c18+c13;
          *out_block_ptr++ = -c19+c12;
          *out_block_ptr++ = -c20+c11;
          *out_block_ptr++ = -c21+c10;
          *out_block_ptr++ = -c22+c9;
          *out_block_ptr++ = -c23+c8;
          *out_block_ptr++ = -c24+c7;
          *out_block_ptr++ = -c25+c6;
          *out_block_ptr++ = -c26+c5;
          *out_block_ptr++ = -c27+c4;
          *out_block_ptr++ = -c28+c3;
          *out_block_ptr++ = -c29+c2;
          *out_block_ptr++ = -c30+c1;
          *out_block_ptr++ = -c31+c0;
}

/*
 * Name:    ScFDCT
 * Purpose: FDCT takes the fast forward DCT of 32 data points
 * optimize: 21%
 */
void ScFDCT(float in_block[32],float out_block1[32],float out_block2[32])
{
        static float            cpi4,cpi8,cpi16,c3pi16;
        static float            cpi32,c3pi32,c5pi32,c7pi32;
        static float            spi8,spi16,s3pi16;
        static float            spi32,s3pi32,s5pi32,s7pi32;
        static float            cpi64,c17pi64,c9pi64,c25pi64,c5pi64,c21pi64;
        static float            c13pi64,c29pi64;
        static float            spi64,s17pi64,s9pi64,s25pi64,s5pi64,s21pi64;
        static float            s13pi64,s29pi64;

        static int              init = 1;

        register float          c0,c1,c2,c3,c4,c5,c6,c7,c8;
        register float          c9,c10,c11,c12,c13,c14,c15;
        register float          c16,c17,c18,c19,c20,c21,c22;
        float                   c23,c24,c25,c26,c27,c28,c29;
        float                   c30,c31;
        float                   d0,d1,d2,d3,d4,d5,d6,d7,d8;
        float                   d9,d10,d11,d12,d13,d14,d15;
        float                   d16,d17,d18,d19,d20,d21,d22;
        float                   d23,d24,d25,d26,d27,d28,d29;
        float                   d30,d31;
        float                   e0,e1,e2,e3,e4,e5,e6,e7,e8;
        float                   e9,e10,e11,e12,e13,e14,e15;
        float                   e16,e17,e18,e19,e20,e21,e22;
        float                   e23,e24,e25,e26,e27,e28,e29;
        float                   e30,e31;

/* initialization.  This is to be done only once. */

        if(init) {
        /* establish internal variables */
          float   temp;
          cpi4 = F cos(PI/4.0);
          temp = F (PI/8.0);          cpi8 = F cos(temp);    spi8 = F sin(temp);
          temp = F (PI/16.0);        cpi16 = F cos(temp);   spi16 = F sin(temp);
          temp = F (3.0*PI/16.0);   c3pi16 = F cos(temp);  s3pi16 = F sin(temp);
          temp = F (PI/32.0);        cpi32 = F cos(temp);   spi32 = F sin(temp);
          temp = F (3.0*PI/32.0);   c3pi32 = F cos(temp);  s3pi32 = F sin(temp);
          temp = F (5.0*PI/32.0);   c5pi32 = F cos(temp);  s5pi32 = F sin(temp);
          temp = F (7.0*PI/32.0);   c7pi32 = F cos(temp);  s7pi32 = F sin(temp);
          temp = F (PI/64.0);        cpi64 = F cos(temp);   spi64 = F sin(temp);
          temp = F (17.0*PI/64.0); c17pi64 = F cos(temp); s17pi64 = F sin(temp);
          temp = F (9.0*PI/64.0);   c9pi64 = F cos(temp);  s9pi64 = F sin(temp);
          temp = F (25.0*PI/64.0); c25pi64 = F cos(temp); s25pi64 = F sin(temp);
          temp = F (5.0*PI/64.0);   c5pi64 = F cos(temp);  s5pi64 = F sin(temp);
          temp = F (21.0*PI/64.0); c21pi64 = F cos(temp); s21pi64 = F sin(temp);
          temp = F (13.0*PI/64.0); c13pi64 = F cos(temp); s13pi64 = F sin(temp);
          temp = F (29.0*PI/64.0); c29pi64 = F cos(temp); s29pi64 = F sin(temp);
          init = 0;
        }

        /* first stage of fast dct */

          c0= in_block[0] + in_block[31];
          c1= in_block[1] + in_block[30];
          c2= in_block[2] + in_block[29];
          c3= in_block[3] + in_block[28];
          c4= in_block[4] + in_block[27];
          c5= in_block[5] + in_block[26];
          c6= in_block[6] + in_block[25];
          c7= in_block[7] + in_block[24];
          c8= in_block[8] + in_block[23];
          c9= in_block[9] + in_block[22];
          c10= in_block[10] + in_block[21];
          c11= in_block[11] + in_block[20];
          c12= in_block[12] + in_block[19];
          c13= in_block[13] + in_block[18];
          c14= in_block[14] + in_block[17];
          c15= in_block[15] + in_block[16];

                  d16= in_block[15] - in_block[16];
                  d17= in_block[14] - in_block[17];
                  d18= in_block[13] - in_block[18];
                  d19= in_block[12] - in_block[19];
          c20= in_block[11] - in_block[20];
          c21= in_block[10] - in_block[21];
          c22= in_block[9] - in_block[22];
          c23= in_block[8] - in_block[23];
          c24= in_block[7] - in_block[24];
          c25= in_block[6] - in_block[25];
          c26= in_block[5] - in_block[26];
          c27= in_block[4] - in_block[27];
                  d28= in_block[3] - in_block[28];
                  d29= in_block[2] - in_block[29];
                  d30= in_block[1] - in_block[30];
                  d31= in_block[0] - in_block[31];

        /* second stage of fast dct */

          d0=c0+c15;
          d1=c1+c14;
          d2=c2+c13;
          d3=c3+c12;
          d4=c4+c11;
          d5=c5+c10;
          d6=c6+c9;
          d7=c7+c8;
                  e8=c7-c8;
                  e9=c6-c9;
          d10=c5-c10;
          d11=c4-c11;
          d12=c3-c12;
          d13=c2-c13;
                  e14=c1-c14;
                  e15=c0-c15;
          d20=cpi4*(c27-c20);
          d21=cpi4*(c26-c21);
          d22=cpi4*(c25-c22);
          d23=cpi4*(c24-c23);
          d24=cpi4*(c24+c23);
          d25=cpi4*(c25+c22);
          d26=cpi4*(c26+c21);
          d27=cpi4*(c27+c20);

        /* third stage of fast dct */

          e0=d0+d7;
          e1=d1+d6;
          e2=d2+d5;
          e3=d3+d4;
                  c4=d3-d4;
          e5=d2-d5;
          e6=d1-d6;
                  c7=d0-d7;
          e10=cpi4*(d13-d10);
          e11=cpi4*(d12-d11);
          e12=cpi4*(d12+d11);
          e13=cpi4*(d13+d10);
                c16=d23+d16;
                c17=d22+d17;
          e18=d21+d18;
          e19=d20+d19;
          e20=d19-d20;
          e21=d18-d21;
                  c22=d17-d22;
                  c23=d16-d23;
                  c24=d31-d24;
                  c25=d30-d25;
          e26=d29-d26;
          e27=d28-d27;
          e28=d27+d28;
          e29=d26+d29;
                  c30=d25+d30;
                  c31=d24+d31;

        /* fourth stage of fast dct */

          c0=e3+e0;
          c1=e2+e1;
          c2=e1-e2;
          c3=e0-e3;
          c5=cpi4*(e6-e5);
          c6=cpi4*(e6+e5);
                  d8=e11+e8;
          c9=e10+e9;
          c10=e9-e10;
                  d11=e8-e11;
                  d12=e15-e12;
          c13=e14-e13;
          c14=e13+e14;
                  d15=e12+e15;
          c18=spi8*e29-cpi8*e18;
          c19=spi8*e28-cpi8*e19;
          c20= -cpi8*e27-spi8*e20;
          c21= -cpi8*e26-spi8*e21;
          c26= -cpi8*e21+spi8*e26;
          c27= -cpi8*e20+spi8*e27;
          c28=spi8*e19+cpi8*e28;
          c29=spi8*e18+cpi8*e29;

        /* fifth stage of fast dct */

                  d0=cpi4*(c1+c0);              /*done*/
                  d1=cpi4*(c0-c1);              /*done*/
                  d2=cpi8*c3+spi8*c2;           /*done*/
                  d3= -cpi8*c2+spi8*c3;         /*done*/
          d4=c5+c4;
          d5=c4-c5;
          d6=c7-c6;
          d7=c6+c7;
          d9=spi8*c14-cpi8*c9;
          d10= -cpi8*c13-spi8*c10;
          d13= -cpi8*c10+spi8*c13;
          d14=spi8*c9+cpi8*c14;
                  e16=c19+c16;
          d17=c18+c17;
          d18=c17-c18;
                  e19=c16-c19;
                  e20=c23-c20;
          d21=c22-c21;
          d22=c21+c22;
                  e23=c20+c23;
                  e24=c27+c24;
          d25=c26+c25;
          d26=c25-c26;
                  e27=c24-c27;
                  e28=c31-c28;
          d29=c30-c29;
          d30=c29+c30;
                  e31=c28+c31;

        /* sixth stage of fast dct */
                  e4=cpi16*d7+spi16*d4;         /*done*/
                  e5=s3pi16*d6+c3pi16*d5;       /*done*/
                  e6= -s3pi16*d5+c3pi16*d6;     /*done*/
                  e7= -cpi16*d4+spi16*d7;       /*done*/
          e8=d9+d8;
          e9=d8-d9;
          e10=d11-d10;
          e11=d10+d11;
          e12=d13+d12;
          e13=d12-d13;
          e14=d15-d14;
          e15=d14+d15;
          e17=spi16*d30-cpi16*d17;
          e18= -cpi16*d29-spi16*d18;
          e29= -cpi16*d18+spi16*d29;
          e30=spi16*d17+cpi16*d30;

          e21=c3pi16*d26-s3pi16*d21;
          e22= -s3pi16*d25-c3pi16*d22;
          e25= -s3pi16*d22+c3pi16*d25;
          e26=c3pi16*d21+s3pi16*d26;

        /* seventh stage of fast dct */

                  d8=cpi32*e15+spi32*e8;        /*done*/
                  d9=s7pi32*e14+c7pi32*e9;      /*done*/
                  d10=c5pi32*e13+s5pi32*e10;    /*done*/
                  d11=s3pi32*e12+c3pi32*e11;    /*done*/
                  d12= -s3pi32*e11+c3pi32*e12;  /*done*/
                  d13= -c5pi32*e10+s5pi32*e13;  /*done*/
                  d14= -s7pi32*e9+c7pi32*e14;   /*done*/
                  d15= -cpi32*e8+spi32*e15;     /*done*/
          c16=e17+e16;
          c17=e16-e17;
          c18=e19-e18;
          c19=e18+e19;
          c20=e21+e20;
          c21=e20-e21;
          c22=e23-e22;
          c23=e22+e23;
          c24=e25+e24;
          c25=e24-e25;
          c26=e27-e26;
          c27=e26+e27;
          c28=e29+e28;
          c29=e28-e29;
          c30=e31-e30;
          c31=e30+e31;


        /* last stage of fast dct */

          d16=cpi64*c31+spi64*c16;      /*done*/
          d17=c17pi64*c30+s17pi64*c17;  /*done*/
          d18=c9pi64*c29+s9pi64*c18;    /*done*/
          d19=c25pi64*c28+s25pi64*c19;  /*done*/
          d20=c5pi64*c27+s5pi64*c20;    /*done*/
          d21=c21pi64*c26+s21pi64*c21;  /*done*/
          d22=c13pi64*c25+s13pi64*c22;  /*done*/
          d23=c29pi64*c24+s29pi64*c23;  /*done*/
          d24= -c29pi64*c23+s29pi64*c24;/*done*/
          d25= -c13pi64*c22+s13pi64*c25;/*done*/
          d26= -c21pi64*c21+s21pi64*c26;/*done*/
          d27= -c5pi64*c20+s5pi64*c27;  /*done*/
          d28= -c25pi64*c19+s25pi64*c28;/*done*/
          d29= -c9pi64*c18+s9pi64*c29;  /*done*/
          d30= -c17pi64*c17+s17pi64*c30;/*done*/
          d31= -cpi64*c16+spi64*c31;    /*done*/

        /* rearrange coefficients to undo bit reversed ordering */
          out_block2[16] = -d0;/******** normalization done in window********/
          out_block2[15] = -d16;
          out_block2[14] = -d8;
          out_block2[13] = -d24;
          out_block2[12] = -e4;
          out_block2[11] = -d20;
          out_block2[10] = -d12;
          out_block2[9] = -d28;
          out_block2[8] = -d2;
          out_block2[7] = -d18;
          out_block2[6] = -d10;
          out_block2[5] = -d26;
          out_block2[4] = -e6;
          out_block2[3] = -d22;
          out_block2[2] = -d14;
          out_block2[1] = -d30;
          out_block2[0] = -d1;

          out_block1[0] =d1;
          out_block1[1] =d17;
          out_block1[2] =d9;
          out_block1[3] =d25;
          out_block1[4] =e5;
          out_block1[5] =d21;
          out_block1[6] =d13;
          out_block1[7] =d29;
          out_block1[8] =d3;
          out_block1[9] =d19;
          out_block1[10] =d11;
          out_block1[11] =d27;
          out_block1[12] =e7;
          out_block1[13] =d23;
          out_block1[14] =d15;
          out_block1[15] =d31;
          out_block1[16] = F 0;
}

/*
** Name:      ScFDCT8x8_C
** Purpose:   2-d Forward DCT (C version).  Customized for (8x8) blocks
**            "c" version
**
*/
void ScFDCT8x8_C(float *ipbuf, float *outbuf)
{
        int i;
        register float t0, t1, t2, t3, t4, t5, t6, t7, tmp;
        register float *spptr, *interptr;
        register float *spptr_int;
        float tempptr[64];


        spptr_int = ipbuf;
        interptr = tempptr;

        /*
        ** Perform Row Computations
        */
        for (i = 0; i < 8; i++) {
           /* Compute A3  */
           t0  = spptr_int[0] + spptr_int[7];
           t7  = spptr_int[0] - spptr_int[7];
           t1  = spptr_int[1] + spptr_int[6];
           t6  = spptr_int[1] - spptr_int[6];
           t2  = spptr_int[2] + spptr_int[5];
           t5  = spptr_int[2] - spptr_int[5];
           t3  = spptr_int[3] + spptr_int[4];
           t4  = spptr_int[3] - spptr_int[4];

           /* Compute A2   */
           tmp = t0;
           t0 += t3;
           t3  = tmp - t3;

           tmp = t1;
           t1 += t2;
           t2  = tmp - t2;

           t4  = -t4 - t5;
           t5 += t6;
           t6 += t7;

           /*  Compute A1 */
           interptr[32]  = t0 - t1;
           interptr[0]   = t0 + t1;
           t2 += t3;

           /*  Compute M */
           t2  = t2*RSQ2 ;
           t5  = t5*RSQ2 ;
           tmp = (t6 - t4)*COS3;
           t4  = -t4*COSM1P3 - tmp;
           t6  = COS1M3*t6 + tmp;


           /*  Compute B2   */
           interptr[16]  = t2 + t3;
           interptr[48] = t3 - t2;

           tmp = t5;
           t5 += t7;
           t7 -= tmp;

           /*  Compute PB1  */
           interptr[8]  = t5 + t6;
           interptr[56] = t5 - t6;
           interptr[24] = t7 - t4;
           interptr[40] = t7 + t4;

           spptr_int +=  8;
           interptr++;
        }


        spptr = tempptr;
        interptr = outbuf;

        /*
        ** Perform Column Computations
        */
        for (i = 0; i < 8; i++) {
           /* Compute A3  */
           t0  = spptr[0] + spptr[7];
           t7  = spptr[0] - spptr[7];
           t1  = spptr[1] + spptr[6];
           t6  = spptr[1] - spptr[6];
           t2  = spptr[2] + spptr[5];
           t5  = spptr[2] - spptr[5];
           t3  = spptr[3] + spptr[4];
           t4  = spptr[3] - spptr[4];

           /* Compute A2   */
           tmp = t0;
           t0 += t3;
           t3  = tmp - t3;

           tmp = t1;
           t1 += t2;
           t2  = tmp - t2;

           t4  = -t4 - t5;
           t5 += t6;
           t6 += t7;

           /*  Compute A1 */
           interptr[32]  = t0 - t1;
           interptr[0]   = t0 + t1;
           t2 = t2+t3;

           /*  Compute M */
           t2  = t2*RSQ2 ;
           t5  = t5*RSQ2 ;
           tmp = (t6 - t4)*COS3;
           t4  = -t4*COSM1P3 - tmp;
           t6  = COS1M3*t6 + tmp ;

           /*  Compute B2   */
           interptr[16] = t2 + t3;
           interptr[48] = t3 - t2;

           tmp = t5;
           t5 += t7;
           t7 -= tmp;

           /*  Compute PB1  */
           interptr[8]  = t5 + t6;
           interptr[56] = t5 - t6;
           interptr[24] = t7 - t4;
           interptr[40] = t7 + t4;

           spptr +=  8;
           interptr++;
       }
}

static const float dct_constants[64] = {
   F 0.12500000,   F 0.09011998,   F 0.09567086,   F 0.10630377,
       F 0.12500000,   F 0.15909483,   F 0.23096988,   F 0.45306373,
   F 0.09011998,   F 0.06497288,   F 0.06897485,   F 0.07664075,
       F 0.09011998,   F 0.11470097,   F 0.16652001,   F 0.32664075,
   F 0.09567086,   F 0.06897485,   F 0.07322331,   F 0.08136138,
       F 0.09567086,   F 0.12176590,   F 0.17677669,   F 0.34675997,
   F 0.10630377,   F 0.07664074,   F 0.08136138,   F 0.09040392,
       F 0.10630377,   F 0.13529903,   F 0.19642374,   F 0.38529903,
   F 0.12500000,   F 0.09011998,   F 0.09567086,   F 0.10630377,
       F 0.12500000,   F 0.15909483,   F 0.23096988,   F 0.45306373,
   F 0.15909483,   F 0.11470097,   F 0.12176590,   F 0.13529903,
       F 0.15909483,   F 0.20248929,   F 0.29396889,   F 0.57664073,
   F 0.23096988,   F 0.16652001,   F 0.17677669,   F 0.19642374,
       F 0.23096988,   F 0.29396892,   F 0.42677671,   F 0.83715260,
   F 0.45306373,   F 0.32664075,   F 0.34675995,   F 0.38529903,
       F 0.45306373,   F 0.57664073,   F 0.83715260,   F 1.64213395
};

/*
** Name:      ScFDCT8x8s_C
** Purpose:   2-d Forward DCT (C version) for (8x8) blocks
**
*/
void ScFDCT8x8s_C(short *inbuf, short *outbuf)
{
        int i;
        register float t0, t1, t2, t3, t4, t5, t6, t7, tmp;
        float *tempptr, tempbuf[64];
        const float *cptr=dct_constants;

        tempptr=tempbuf;
        /*
        ** Perform Row Computations
        */
        for (i = 0; i < 8; i++) {
           /* Compute A3  */
           t0  = F (inbuf[0] + inbuf[7]);
           t7  = F (inbuf[0] - inbuf[7]);
           t1  = F (inbuf[1] + inbuf[6]);
           t6  = F (inbuf[1] - inbuf[6]);
           t2  = F (inbuf[2] + inbuf[5]);
           t5  = F (inbuf[2] - inbuf[5]);
           t3  = F (inbuf[3] + inbuf[4]);
           t4  = F (inbuf[3] - inbuf[4]);

           /* Compute A2   */
           tmp = t0;
           t0 += t3;
           t3  = tmp - t3;

           tmp = t1;
           t1 += t2;

           t2  = tmp - t2;

           t4  = -t4 - t5;
           t5 += t6;
           t6 += t7;

           /*  Compute A1 */
           tempptr[32]  = t0 - t1;
           tempptr[0]   = t0 + t1;
           t2 += t3;

           /*  Compute M */
           t2  = t2*RSQ2 ;
           t5  = t5*RSQ2 ;
           tmp = (t6 - t4)*COS3;
           t4  = -t4*COSM1P3 - tmp;
           t6  = COS1M3*t6 + tmp;


           /*  Compute B2   */
           tempptr[16]  = t2 + t3;
           tempptr[48] = t3 - t2;

           tmp = t5;
           t5 += t7;
           t7 -= tmp;

           /*  Compute PB1  */
           tempptr[8]  = t5 + t6;
           tempptr[56] = t5 - t6;
           tempptr[24] = t7 - t4;
           tempptr[40] = t7 + t4;

           inbuf +=  8;
           tempptr++;
        }


        tempptr = tempbuf;

        /*
        ** Perform Column Computations
        */
        for (i = 0; i < 8; i++) {
           /* Compute A3  */
           t0  = tempptr[0] + tempptr[7];
           t7  = tempptr[0] - tempptr[7];
           t1  = tempptr[1] + tempptr[6];
           t6  = tempptr[1] - tempptr[6];
           t2  = tempptr[2] + tempptr[5];
           t5  = tempptr[2] - tempptr[5];
           t3  = tempptr[3] + tempptr[4];
           t4  = tempptr[3] - tempptr[4];

           /* Compute A2   */
           tmp = t0;
           t0 += t3;
           t3  = tmp - t3;

           tmp = t1;
           t1 += t2;
           t2  = tmp - t2;

           t4  = -t4 - t5;
           t5 += t6;
           t6 += t7;

           /*  Compute A1 */
           outbuf[32]  = (short) floorf((t0 - t1)*cptr[4]+0.499999);
           outbuf[0]   = (short) floorf((t0 + t1)*cptr[0]+0.499999);
           t2 = t2+t3;

           /*  Compute M */
           t2  = t2*RSQ2 ;
           t5  = t5*RSQ2 ;
           tmp = (t6 - t4)*COS3;
           t4  = -t4*COSM1P3 - tmp;
           t6  = COS1M3*t6 + tmp ;

           /*  Compute B2   */
           outbuf[16] = (short) floorf((t2 + t3)*cptr[2]+0.499999);
           outbuf[48] = (short) floorf((t3 - t2)*cptr[6]+0.499999);

           tmp = t5;
           t5 += t7;
           t7 -= tmp;

           /*  Compute PB1  */
           outbuf[8]  = (short) floorf((t5 + t6)*cptr[1]+0.499999);
           outbuf[56] = (short) floorf((t5 - t6)*cptr[7]+0.499999);
           outbuf[24] = (short) floorf((t7 - t4)*cptr[3]+0.499999);
           outbuf[40] = (short) floorf((t7 + t4)*cptr[5]+0.499999);

           tempptr += 8;
           cptr    += 8;
           outbuf++;
       }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sc_err.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: SC_err.h,v $
 * Revision 1.1.4.2  1996/12/03  00:08:28  Hans_Graves
 * 	Added SvErrorEndOfSequence error.
 * 	[1996/12/03  00:07:34  Hans_Graves]
 *
 * Revision 1.1.2.7  1995/08/04  16:32:25  Karen_Dintino
 * 	New error codes for H.261
 * 	[1995/08/04  16:24:25  Karen_Dintino]
 * 
 * Revision 1.1.2.6  1995/07/26  17:48:54  Hans_Graves
 * 	Added ErrorClientEnd errors.
 * 	[1995/07/26  17:44:27  Hans_Graves]
 * 
 * Revision 1.1.2.5  1995/07/11  22:11:27  Karen_Dintino
 * 	Add new H.261 Error Codes
 * 	[1995/07/11  21:52:53  Karen_Dintino]
 * 
 * Revision 1.1.2.4  1995/07/11  14:50:45  Hans_Graves
 * 	Added ScErrorNet* errors
 * 	[1995/07/11  14:24:18  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/22  21:35:04  Hans_Graves
 * 	Added ScErrorDevOpen and fixed some error numbers
 * 	[1995/06/22  21:31:32  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:28  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:25:17  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/03  19:26:59  Hans_Graves
 * 	Included in SLIB (Oct 95)
 * 	[1995/05/03  19:23:33  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:19:26  Hans_Graves
 * 	Expanded to include new libraries: Sg,Su,Sa,Sr
 * 	[1995/04/07  19:11:07  Hans_Graves]
 * 
 * $EndLog$
 */

/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1993                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*----------------------------------------------------------------------------
 * Modification History: SC_err.h (previously SV_err.h)
 *
 * 05-Nov-1991  Victor Bahl & Bob Ulichney   creation date
 * 07-Oct-1994  Paul Gauthier                SLIB v3.0 incl. MPEG Decode
 * 09-Nov-1994  Paul Gauthier                Optimizations
 *--------------------------------------------------------------------------*/

#ifndef _SC_ERR_H_
#define _SC_ERR_H_
/* 	
** List of possible errors that can be returned from routines in any 
** of SLIB libraries.
*/

/******************** Error Offsets **********************************/
#define ERR_SC   0x0000  /* Common Error */
#define ERR_SV   0x1000  /* Video Error */
#define ERR_SA   0x2000  /* Audio Error */
#define ERR_SR   0x3000  /* Render Error */

#define	NoErrors                   0

/******************** Sc (common) Errors ****************************/
#define ScErrorNone                NoErrors
#define ScErrorForeign             (ERR_SC+1)
#define ScErrorMemory              (ERR_SC+2)
#define ScErrorBadPointer          (ERR_SC+3)
#define ScErrorNullStruct          (ERR_SC+4)
#define ScErrorFile                (ERR_SC+5)
#define ScErrorEOI                 (ERR_SC+6)
#define ScErrorBadArgument         (ERR_SC+7)
#define ScErrorSmallBuffer         (ERR_SC+8)
#define ScErrorUnrecognizedFormat  (ERR_SC+9)
#define ScErrorEndBitstream        (ERR_SC+10)
#define ScErrorMapFile             (ERR_SC+11)
#define ScErrorBadQueueEmpty       (ERR_SC+12)
#define ScErrorClientEnd           (ERR_SC+13)
#define ScErrorDevOpen             (ERR_SC+14)
#define ScErrorNetConnectIn        (ERR_SC+15)
#define ScErrorNetConnectOut       (ERR_SC+16)
#define ScErrorNetProtocol         (ERR_SC+17)
#define ScErrorNetSend             (ERR_SC+18)
#define ScErrorNetReceive          (ERR_SC+19)
#define ScErrorNetBadHeader        (ERR_SC+20)
#define ScErrorNetBadTrailer       (ERR_SC+21)
#define ScErrorNetChecksum         (ERR_SC+22)

/******************** Sv (video) Errors ****************************/
#ifdef ERR_SV
#define	SvErrorNone                NoErrors
#define SvErrorMemory              ScErrorMemory
#define SvErrorBadPointer          ScErrorBadPointer
#define SvErrorNullStruct          ScErrorNullStruct
#define SvErrorBadArgument         ScErrorBadArgument
#define SvErrorSmallBuffer         ScErrorSmallBuffer
#define SvErrorEndBitstream        ScErrorEndBitstream
#define SvErrorClientEnd           ScErrorClientEnd

#define SvErrorCodecType           (ERR_SV+2)
#define SvErrorCodecHandle         (ERR_SV+3)
#define SvErrorNullCodec           (ERR_SV+4)
#define SvErrorNullToken           (ERR_SV+5)
#define SvErrorSyncLost            (ERR_SV+6)
#define	SvErrorLevels	           (ERR_SV+7)
#define	SvErrorOrder	           (ERR_SV+8)
#define SvErrorLevNoneg            (ERR_SV+9)
#define SvErrorLev1K               (ERR_SV+10)
#define SvErrorLevGt0              (ERR_SV+11)
#define SvErrorYuvOnly             (ERR_SV+13)
#define SvErrorDevOpen             (ERR_SV+14)
#define SvErrorDevMap              (ERR_SV+15)
#define SvErrorStatQueMap          (ERR_SV+16)
#define SvErrorDevLock             (ERR_SV+17)
#define SvErrorDevUlock            (ERR_SV+18)
#define SvErrorCache               (ERR_SV+19)
#define SvErrorPageAll             (ERR_SV+20)
#define SvErrorTimeOut             (ERR_SV+21)
#define SvErrorSelect              (ERR_SV+22)
#define SvErrorMapOvrfl            (ERR_SV+23)
#define SvErrorForeign             (ERR_SV+24)
#define SvErrorIIC                 (ERR_SV+25)
#define SvErrorCompPtrs            (ERR_SV+26)
#define SvErrorVideoInput          (ERR_SV+27)
#define SvErrorPhase	           (ERR_SV+28)
#define SvErrorCmdQueMap	   (ERR_SV+29)
#define SvErrorTmpQueMap	   (ERR_SV+30)
#define SvErrorStart               (ERR_SV+31)
#define SvErrorStop                (ERR_SV+32)
#define SvErrorWaitMix             (ERR_SV+33)
#define SvErrorClose               (ERR_SV+34)
#define SvErrorCmdQFull            (ERR_SV+35)
#define SvErrorPictureOp           (ERR_SV+36)
#define SvErrorRefToken            (ERR_SV+37)
#define SvErrorEditChange          (ERR_SV+38)
#define SvErrorCompROI             (ERR_SV+39)
#define SvErrorBufOverlap          (ERR_SV+40)
#define SvErrorReqQueueFull        (ERR_SV+41)
#define SvErrorCompBufOverflow     (ERR_SV+42)
#define SvErrorFunctionInputs      (ERR_SV+43)
#define SvErrorIICAck              (ERR_SV+44)
#define SvErrorCompressedData      (ERR_SV+45)
#define SvErrorDecompPreload       (ERR_SV+46)
#define SvErrorHuffCode            (ERR_SV+47)
#define SvErrorOutOfData           (ERR_SV+48)
#define SvErrorMarkerFound         (ERR_SV+49)
#define SvErrorSgMapsExhausted     (ERR_SV+50)
#define SvErrorSgMapInit           (ERR_SV+51)
#define SvErrorSgMapAlreadyFree    (ERR_SV+52)
#define SvErrorSgMapId             (ERR_SV+53)
#define SvErrorNumBytes            (ERR_SV+54)
#define SvErrorDevName             (ERR_SV+55)
#define SvErrorAnalogPortTiming    (ERR_SV+56)
#define SvErrorFrameMode           (ERR_SV+57)
#define SvErrorSampFactors         (ERR_SV+58)
#define SvErrorNumComponents       (ERR_SV+59)
#define SvErrorDHTTable            (ERR_SV+60)
#define SvErrorQuantTable          (ERR_SV+61)
#define SvErrorRestartInterval     (ERR_SV+62)
#define SvErrorJfifRev             (ERR_SV+63)
#define SvErrorEmptyJPEG           (ERR_SV+64)
#define SvErrorJPEGPrecision       (ERR_SV+65)
#define SvErrorSOFLength           (ERR_SV+66)
#define SvErrorSOSLength           (ERR_SV+67)
#define SvErrorSOSCompNum          (ERR_SV+68)
#define SvErrorMarker              (ERR_SV+69)
#define SvErrorSOFType             (ERR_SV+70)
#define SvErrorFrameNum            (ERR_SV+71)
#define SvErrorHuffUndefined       (ERR_SV+72)
#define SvErrorJPEGData            (ERR_SV+73)
#define SvErrorQMismatch           (ERR_SV+74)
#define SvErrorEmptyFlush          (ERR_SV+75)
#define SvErrorDmaChan             (ERR_SV+76)
#define SvErrorFuture              (ERR_SV+77)
#define SvErrorWrongev             (ERR_SV+78)
#define SvErrorUnknev              (ERR_SV+79)
#define SvErrorQueueExecuting      (ERR_SV+80)
#define SvErrorReturnAddr          (ERR_SV+81)
#define SvErrorObjClass            (ERR_SV+82)
#define SvErrorRegAnchor           (ERR_SV+83)
#define SvErrorTimerRead           (ERR_SV+84)
#define SvErrorDriverFatal         (ERR_SV+85)
#define SvErrorChromaSubsample     (ERR_SV+86)
#define SvErrorReadBufSize         (ERR_SV+87)
#define SvErrorQuality             (ERR_SV+88)
#define SvErrorBadImageSize        (ERR_SV+89)
#define SvErrorValue               (ERR_SV+90)
#define SvErrorDcmpNotStarted      (ERR_SV+91)
#define SvErrorNotImplemented      (ERR_SV+92)
#define SvErrorNoSOIMarker         (ERR_SV+93)
#define SvErrorProcessingAborted   (ERR_SV+94)
#define SvErrorCompNotStarted      (ERR_SV+95)
#define SvErrorNotAligned          (ERR_SV+96)
#define SvErrorBadQueueEmpty       (ERR_SV+97)
#define SvErrorCannotDecompress    (ERR_SV+98)
#define SvErrorMultiBufChanged     (ERR_SV+99)
#define SvErrorNotDecompressable   (ERR_SV+100)
#define SvErrorIndexEmpty          (ERR_SV+101)
#define SvErrorFile                (ERR_SV+102)
#define SvErrorEOI                 (ERR_SV+103)
#define SvErrorUnrecognizedFormat  (ERR_SV+104)
#define SvErrorIllegalMType	   (ERR_SV+105)
#define SvErrorExpectedEOB         (ERR_SV+106)
#define SvErrorNoCompressBuffer    (ERR_SV+107)
#define SvErrorNoImageBuffer       (ERR_SV+108)
#define SvErrorCBPWrite		   (ERR_SV+109)
#define SvErrorEncodingMV          (ERR_SV+110)
#define SvErrorEmptyHuff           (ERR_SV+111)
#define SvErrorIllegalGBSC         (ERR_SV+112)
#define SvErrorEndOfSequence       (ERR_SV+113)



#endif ERR_SV


/******************** Sa (video) Errors ****************************/
#ifdef ERR_SA
#define	SaErrorNone                NoErrors
#define SaErrorMemory              ScErrorMemory
#define SaErrorBadPointer          ScErrorBadPointer
#define SaErrorUnrecognizedFormat  ScErrorUnrecognizedFormat
#define SaErrorNullStruct          ScErrorNullStruct
#define SaErrorFile                ScErrorFile
#define SaErrorEOI                 ScErrorEOI
#define SaErrorBadArgument         ScErrorBadArgument
#define SaErrorSmallBuffer         ScErrorSmallBuffer
#define SaErrorClientEnd           ScErrorClientEnd

#define SaErrorCodecType           (ERR_SA+1)
#define SaErrorCodecHandle         (ERR_SA+2)
#define SaErrorNullCodec           (ERR_SA+3)
#define SaErrorSyncLost            (ERR_SA+4)
#define SaErrorMPEGLayer           (ERR_SA+5)
#define SaErrorMPEGModeExt         (ERR_SA+6)
#define SaErrorNoCompressBuffer    (ERR_SA+7)
#define SaErrorNoAudioBuffer       (ERR_SA+8)
#endif ERR_SA

/******************** Sr (render) Errors ****************************/
#ifdef ERR_SR
#define	SrErrorNone                NoErrors
#define SrErrorMemory              ScErrorMemory
#define SrErrorBadPointer          ScErrorBadPointer
#define SrErrorUnrecognizedFormat  ScErrorUnrecognizedFormat
#define SrErrorNullStruct          ScErrorNullStruct
#define SrErrorFile                ScErrorFile
#define SrErrorEOI                 ScErrorEOI
#define SrErrorBadArgument         ScErrorBadArgument
#define SrErrorSmallBuffer         ScErrorSmallBuffer
#define SrErrorClientEnd           ScErrorClientEnd

#define SrErrorRenderType          (ERR_SR+1)
#define SrErrorRenderHandle        (ERR_SR+2)
#define SrErrorRenderNotStarted    (ERR_SR+3)
#define SrErrorDitherNOL           (ERR_SR+4)
#define SrErrorDitherPhase         (ERR_SR+5)
#define SrErrorDefSteepness        (ERR_SR+6)
#define SrErrorSteepness           (ERR_SR+7)
#define SrErrorDefYoffset          (ERR_SR+8)
#define SrErrorYoffset             (ERR_SR+9)
#define SrErrorDefXoffset          (ERR_SR+10)
#define SrErrorXoffset             (ERR_SR+11)
#define SrErrorNumColors           (ERR_SR+12)
#define SrErrorBadNumColors        (ERR_SR+13)
#define SrErrorColorSpace          (ERR_SR+14)
#define SrErrorBadImageSize        (ERR_SR+15)
#define SrErrorValue               (ERR_SR+16)
#endif ERR_SR

#endif _S_ERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sc_err.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_errors.c,v $
 * Revision 1.1.7.2  1996/12/03  00:08:25  Hans_Graves
 * 	Added SvErrorEndOfSequence error.
 * 	[1996/12/03  00:07:32  Hans_Graves]
 *
 * Revision 1.1.5.2  1996/01/02  18:30:45  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added include files for NT.
 * 	[1996/01/02  15:25:01  Bjorn_Engberg]
 * 
 * Revision 1.1.2.6  1995/08/04  16:32:23  Karen_Dintino
 * 	Add new errors for H.261
 * 	[1995/08/04  16:25:15  Karen_Dintino]
 * 
 * Revision 1.1.2.5  1995/07/26  17:48:53  Hans_Graves
 * 	Added errors: NoCompressBuffer and ClientEnd
 * 	[1995/07/26  17:46:13  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/07/11  22:11:26  Karen_Dintino
 * 	Add new H.261 Error Codes
 * 	[1995/07/11  21:56:35  Karen_Dintino]
 * 
 * Revision 1.1.2.3  1995/07/11  14:50:37  Hans_Graves
 * 	Added ScErrorNet* errors
 * 	[1995/07/11  14:24:32  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:07:44  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:11:22  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/03  19:13:40  Hans_Graves
 * 	First time under SLIB
 * 	[1995/05/03  19:12:02  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  18:28:50  Hans_Graves
 * 	Redesigned error handling (taken from sv_printerrors.c)
 * 	     to handle multiple libraries (Sg, Su, Sv, Sa, Sr)
 * 	[1995/04/07  18:28:06  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#include <stdio.h>
#include <string.h>
#include "SC.h"
#include "SC_err.h"

char _serr_msg[80];

typedef struct ErrorDesc_s {
  int   code;
  char *name;
  char *text;
} ErrorDesc_t;

/*
** ErrorDesc is a table of all errors that need to be translated into
** text messages.  Order doesn't matter, except that if there are two
** error numbers which are of the same value, the first one will be
** returned.
** Note: Any %s contained in the message text will be filled by the
**       string assigned to _serr_msg
*/
static ErrorDesc_t ErrorDesc[] =
{
  NoErrors, 		"",
			"",
/******************** Sc (Common) **************************/
  ScErrorNone, 		"",
			"",
  ScErrorForeign,	"ScErrorForeign",
			"%s",
  ScErrorMemory,	"ScErrorMemory",
			"memory request denied",
  ScErrorBadPointer,	"ScErrorBadPointer",
			"Invalid pointer passed to function",
  ScErrorNullStruct, 	"ScErrorNullStruct",
			"Parameter set structure is required",
  ScErrorFile, 		"ScErrorFile",
                        "file",
  ScErrorEOI, 		"ScErrorEOI",
			"End of Input reached",
  ScErrorBadArgument, 	"ScErrorBadArgument",
			"Invalid argument to function",
  ScErrorSmallBuffer, 	"ScErrorSmallBuffer",
			"Buffer too small",
  ScErrorUnrecognizedFormat, "ScErrorUnrecognizedFormat",
			"Unrecognized format",
  ScErrorEndBitstream,	"ScErrorEndBitstream",
			"End of data bitstream reached",
  ScErrorBadQueueEmpty,	"ScErrorBadQueueEmpty",
			"Buffer queue is empty",
  ScErrorClientEnd,     "ScErrorClientEnd",
                        "Client ended processing",
  ScErrorNetConnectIn,  "ScErrorNetConnectIn",
			"No network connection made for input.",
  ScErrorNetConnectOut, "ScErrorNetConnectOut",
			"No network connection made for output.",
  ScErrorNetProtocol,   "ScErrorNetProtocol",
			"Unsupported network protocol.",
  ScErrorNetSend,       "ScErrorNetSend",
			"Network error sending data.",
  ScErrorNetReceive,    "ScErrorNetReceive",
			"Network error receiving data.",
  ScErrorNetBadHeader,  "ScErrorNetBadHeader",
			"Bad network data header received.",
  ScErrorNetBadTrailer, "ScErrorNetBadTrailer",
			"Bad network data trailor received.",
  ScErrorNetChecksum,   "ScErrorNetChecksum",
			"Checksum error on data received over network.",
/******************** Sv (Video) ****************************/
  SvErrorForeign,	"SvErrorForeign",
			"%s",
  SvErrorMemory,	"SvErrorMemory",
			"memory request denied",
  SvErrorBadPointer,	"SvErrorBadPointer",
			"Invalid pointer passed to function",
  SvErrorFile,		"SvErrorFile",
			"Not a JPEG file",
  SvErrorEOI,		"SvErrorEOI",
			"Empty JPEG file",
  SvErrorBadArgument,	"SvErrorBadArgument",
			"Invalid argument to function",
  SvErrorSmallBuffer,	"SvErrorSmallBuffer",
			"Buffer too small",
  SvErrorEndBitstream,	"SvErrorEndBitstream",
			"End of data bitstream reached",
  SvErrorCodecType,	"SvErrorCodecType",
			"Codec type not recognized",
  SvErrorCodecHandle,	"SvErrorCodecHandle",
			"Invalid Codec handle",
  SvErrorNullCodec,	"SvErrorNullCodec",
			"Codec argument may not be NULL",
  SvErrorNullToken,	"SvErrorNullToken",
			"Registration token  may not be NULL",
  SvErrorSyncLost,	"SvErrorSyncLost",
			"Syncronization lost in data bitstream",
  SvErrorLevels,	"SvErrorLevels",
			"levels - must be between 2 and 256",
  SvErrorOrder,		"SvErrorOrder",
			"order - must be between 0 and 6",
  SvErrorLevNoneg,	"SvErrorLevNoneg",
			"%s - Must be nonnegative",
  SvErrorLev1K,		"SvErrorLev1K",	
			"%s - Must be between -1000 and 1000",
  SvErrorLevGt0,	"SvErrorLevGt0",
			"%s - Must be greater than zero",
  SvErrorYuvOnly,	"SvErrorYuvOnly",
			"operation supported for YUV images only",
  SvErrorDevOpen,	"SvErrorDevOpen",
			"unable to open device %s",
  SvErrorDevMap,	"SvErrorDevMap",
			"unable to map device registers",
  SvErrorStatQueMap,	"SvErrorStatQueMap",
			"unable to map status queue",
  SvErrorDevLock,	"SvErrorDevLock",
			"unable to Lock %s bytes of memory",
  SvErrorDevUlock,	"SvErrorDevUlock",
			"unable to unLock memory %s",
  SvErrorCache,		"SvErrorCache",	
			"could not make the pages NONCACHEABLE",
  SvErrorPageAll,	"SvErrorPageAll",
			"memory has to be page alligned, need integral # of pages",
  SvErrorTimeOut,	"SvErrorTimeOut",
			"time out on following operation(s): %s",
  SvErrorSelect,	"SvErrorSelect",
			"select failure during following operation(s): %s",
  SvErrorMapOvrfl,	"SvErrorMapOvrfl",
			"DMA scatter/gather map overflow",
  SvErrorIIC,		"SvErrorIIC",
			"IIC Bus error",
  SvErrorCompPtrs,	"SvErrorCompPtrs",
			"storage for compression flushing and/or byte count missing",
  SvErrorVideoInput,	"SvErrorVideoInput",
			"no video input",
  SvErrorPhase,		"SvErrorPhase",
			"Invalid Phase",
  SvErrorCmdQueMap,	"SvErrorCmdQueMap",
			"CmdQueue Map",
  SvErrorTmpQueMap,	"SvErrorTmpQueMap",
			"TmpQueue Map",
  SvErrorStart,		"SvErrorStart",
			"couldn't start the application",
  SvErrorStop,		"SvErrorStop",
			"couldn't stop the application",
  SvErrorWaitMix,	"SvErrorWaitMix",
			"non-blocking operations still pending",
  SvErrorClose,		"SvErrorClose",
			"Error closing device",
  SvErrorCmdQFull,	"SvErrorCmdQFull",
			"JLib internal error -- CmdQueue full",
  SvErrorPictureOp,	"SvErrorPictureOp",
			"Picture operation failed",
  SvErrorRefToken,	"SvErrorRefToken",
			"Reference token required on edit",
  SvErrorEditChange,	"SvErrorEditChange",
			"No change specified for edit",
  SvErrorCompROI,	"SvErrorCompROI",
			"SvError compression ROI",
  SvErrorBufOverlap,	"SvErrorBufOverlap",
			"Buffer overlaps previously registered buffer",
  SvErrorReqQueueFull,	"SvErrorReqQueueFull",
			"JLib internal error -- RequestQueue is full",
  SvErrorCompBufOverflow,"SvErrorCompBufOverflow",
			"Compression buffer overflow",
  SvErrorFunctionInputs,"SvErrorFunctionInputs",
			"Illegal library function inputs",
  SvErrorIICAck,	"SvErrorIICAck",
			"Missing acknowledge on video IIC bus",
  SvErrorCompressedData,"SvErrorCompressedData",
			"Cannot find end of compressed data",
  SvErrorDecompPreload,	"SvErrorDecompPreload",
			"Compressed data preload failed",
  SvErrorHuffCode,	"SvErrorHuffCode",
			"huffman code in compressed data",
  SvErrorOutOfData,	"SvErrorOutOfData",
			"Compressed data exhausted",
  SvErrorMarkerFound,	"SvErrorMarkerFound",
			"marker found in compressed data",
  SvErrorSgMapsExhausted,"SvErrorSgMapsExhausted",
			"No more DMA Map pages available",
  SvErrorSgMapInit,	"SvErrorSgMapInit",
			"Failure initializing DMA Map Pool",
  SvErrorSgMapAlreadyFree,"SvErrorSgMapAlreadyFree",
			"Freeing a DMA Map that is already free",
  SvErrorSgMapId,	"SvErrorSgMapId",
			"Invalid DMA Map Id",
  SvErrorNumBytes,	"SvErrorNumBytes",
			"Location for number of compressed bytes is required",
  SvErrorDevName,	"SvErrorDevName",
			"%s is not a valid JV2 device",
  SvErrorDevName,	"SvErrorNullStruct",
			"Parameter set structure is required",
  SvErrorAnalogPortTiming,"SvErrorAnalogPortTiming",
			"Analog port settings differ from pending settings: Use blocking call",
  SvErrorFrameMode,	"SvErrorFrameMode",
			"Frame mode not supported with PAL or SECAM video",
  SvErrorSampFactors,	"SvErrorSampFactors",
			"Invalid sampling factor",
  SvErrorNumComponents,	"SvErrorNumComponents",
			"Too many components for interleaved scan",
  SvErrorDHTTable,	"SvErrorDHTTable",
			"Invalid Huffman table",
  SvErrorQuantTable,	"SvErrorQuantTable",
			"Invalid quantization table",
  SvErrorRestartInterval,"SvErrorRestartInterval",
			"Invalid restart interval",
  SvErrorJfifRev,	"SvErrorJfifRev",
			"Unsupported JFIF version",
  SvErrorEmptyJPEG,	"SvErrorEmptyJPEG",
			"Empty JPEG image (DNL not supported)",
  SvErrorJPEGPrecision,	"SvErrorJPEGPrecision",
			"Unsupported JPEG data precision",
  SvErrorSOFLength,	"SvErrorSOFLength",
			"Invalid SOF length",
  SvErrorSOSLength,	"SvErrorSOSLength",
			"Invalid SOS length",
  SvErrorSOSCompNum,	"SvErrorSOSCompNum",
			"Invalid SOS number of components",
  SvErrorMarker,	"SvErrorMarker",
			"Unexpected Marker",
  SvErrorSOFType,	"SvErrorSOFType",
			"Unsupported SOF marker type",
  SvErrorFrameNum,	"SvErrorFrameNum",
			"frame number",
  SvErrorHuffUndefined,	"SvErrorHuffUndefined",
			"Huffman tables not initialized",
  SvErrorJPEGData,	"SvErrorJPEGData",
			"Corrupt JPEG data",
  SvErrorQMismatch,	"SvErrorQMismatch",
			"Request/status queue mismatch",
  SvErrorEmptyFlush,	"SvErrorEmptyFlush",
			"Driver's temp (flush) queue is empty",
  SvErrorDmaChan,	"SvErrorDmaChan",
			"invalid DMA channel",
  SvErrorFuture,	"SvErrorFuture",
			"future",
  SvErrorWrongev,	"SvErrorWrongev",
			"wrong ev",
  SvErrorUnknev,	"SvErrorUnknev",
			"unknown ev",
  SvErrorQueueExecuting,"SvErrorQueueExecuting",
			"JLib internal error -- Can't download with running queue",
  SvErrorReturnAddr,	"SvErrorReturnAddr",
			"JLib internal error -- Missing return address",
  SvErrorObjClass,	"SvErrorObjClass",
			"JLib internal error -- SvError object class",
  SvErrorRegAnchor,	"SvErrorRegAnchor",
			"JLib internal error -- No registration object anchor",
  SvErrorTimerRead,	"SvErrorTimerRead",
			"reading timer",
  SvErrorDriverFatal,	"SvErrorDriverFatal",
			"Fatal driver error",
  SvErrorChromaSubsample,"SvErrorChromaSubsample",
			"Chroma subsample must be Mono, 4:2:2 or 4:2:0",
  SvErrorReadBufSize,	"SvErrorReadBufSize",
			"Compressed data buffer too small",
  SvErrorQuality,	"SvErrorQuality",
			"Invalid Quality value. Range = 0 to 10,000",
  SvErrorUnrecognizedFormat,"SvErrorUnrecognizedFormat",
			"Unrecognized image format",
  SvErrorIllegalMType,    "SvErrorIllegalMType",
                        "Illegal Macroblock type",
  SvErrorBadImageSize,	"SvErrorBadImageSize",
			"Invalid image size",
  SvErrorValue,		"SvErrorValue",
			"Invalid parameter value",
  SvErrorDcmpNotStarted,"SvErrorDcmpNotStarted",
			"Codec not setup. Call SvDecompressBegin",
  SvErrorNotImplemented,"SvErrorNotImplemented",
			"Not implemented yet",
  SvErrorNoSOIMarker,	"SvErrorNoSOIMarker",
			"Invalid JPEG data",
  SvErrorProcessingAborted,"SvErrorProcessingAborted",
			"Processing Aborted by callback",
  SvErrorCompNotStarted,"SvErrorCompNotStarted",
			"Codec not setup. Call SvCompressBegin",
  SvErrorNotAligned,	"SvErrorNotAligned",
			"Memory pointer not 64-bit aligned",
  SvErrorBadQueueEmpty,	"SvErrorBadQueueEmpty",
			"Buffer queue is empty",
  SvErrorCannotDecompress,"SvErrorCannotDecompress",
			"Picture cannot be decompressed",
  SvErrorMultiBufChanged,"SvErrorMultiBufChanged",
			"Multibuffer address has changed",
  SvErrorNotDecompressable,"SvErrorNotDecompressable",
			"Picture not decompressable",
  SvErrorIndexEmpty,	"SvErrorIndexEmpty",
			"Requested frame not in index",
  SvErrorExpectedEOB,   "SvErrorExpectedEOB",
			"Expected End Of Block",
  SvErrorNoCompressBuffer, "SvErrorNoCompressBuffer",
			"No more compressed buffers available",
  SvErrorNoImageBuffer, "SvErrorNoImageBuffer",
			"No more image buffers available",
  SvErrorCBPWrite, "SvErrorCBPWrite",
			"CBP Write Error",
  SvErrorEncodingMV, "SvErrorEncodingMV",
                        "Cannot encode Motion Vectors",
  SvErrorEmptyHuff, "SvErrorEmptyHuff",
                        "Attempting to write an empty huffman code",
  SvErrorIllegalGBSC, "SvErrorIllegalGBSC",
                        "Illegal GOB Start Code",
  SvErrorEndOfSequence, "SvEndOfSequence",
                        "End Of Sequence",
/******************** Sa (Audio) ****************************/
  SaErrorNullCodec,	"SaErrorNullCodec",
			"Codec argument may not be NULL",
  SaErrorSyncLost,	"SaErrorSyncLost",
			"Syncronization lost in data bitstream",
  SaErrorMPEGLayer,     "SaErrorMPEGLayer",
			"Bad MPEG Layer %s",
  SaErrorMPEGModeExt,   "SaErrorMPEGModeExt",
			"Bad MPEG Mode Extension %s",
  SaErrorNoCompressBuffer, "SaErrorNoCompressBuffer",
			"No more compressed buffers available",
  SaErrorNoAudioBuffer, "SaErrorNoAudioBuffer",
			"No more audio buffers available",
/******************** Sr (Render) ****************************/
  SrErrorRenderType,	"SrErrorRenderType",
			"Render type not recognized",
  SrErrorRenderHandle,	"SrErrorRenderHandle",
			"Invalid Render handle",
  SrErrorRenderNotStarted,"SrErrorRenderNotStarted",
			"Renderer not setup. Call SvRenderBegin",
  SrErrorDitherNOL,	"SrErrorDitherNOL",
			"Invalid NOL value - must be between 2 & 256",
  SrErrorDitherPhase,	"SrErrorDitherPhase",
			"Invalid PhaseX/Y value - must be >= 0",
  SrErrorDefSteepness,	"SrErrorDefSteepness",
			"Invalid Default Steepness -1000.0 to +1000.0",
  SrErrorSteepness,	"SrErrorSteepness",
			"Invalid Steepness -1000.0 to +1000.0",
  SrErrorDefYoffset,	"SrErrorDefYoffset",
			"Invalid Default Yoffset -100.0 to +100.0",
  SrErrorYoffset,	"SrErrorYoffset",
			"Invalid Yoffset -100.0 to +100.0",
  SrErrorDefXoffset,	"SrErrorDefXoffset",
			"Invalid Default Xoffset -100.0 to +100.0",
  SrErrorXoffset,	"SrErrorXoffset",
			"Invalid Xoffset -100.0 to +100.0",
  SrErrorNumColors,	"SrErrorNumColors",
			"Not enough colors available for dithering",
  SrErrorBadNumColors,	"SrErrorBadNumColors",
			"Invalid Number of colors. Range = 2 to 256",
  SrErrorColorSpace,	"SrErrorColorSpace",
			"unsupported color space",
  SrErrorBadImageSize,	"SrErrorBadImageSize",
			"Invalid image size",
  SrErrorValue,		"SrErrorValue",
			"Invalid parameter value",
  0,			NULL, NULL
};


ScStatus_t ScGetErrorText (int errno, char *ReturnMsg, u_int MaxChars)
{
  int status;
  char msg[255], *pmsg;
  ErrorDesc_t *perr=ErrorDesc;

  msg[0]=0;
  pmsg=msg;
  while (perr->name!=NULL && perr->code!=errno)
    perr++;
  if (perr->name!=NULL) /* matching message found */
  {
    if (perr->name[0])
    {
      sprintf(msg,"(%s) ",perr->name);
      pmsg+=strlen(pmsg);
    }
    if (perr->text[0])
    {
      sprintf (pmsg, perr->text, _serr_msg);
      pmsg+=strlen(pmsg);
    }
    if (*msg) /* put newline if there was a message */
    {
      *pmsg++='\n';
      *pmsg=0;
    }
    status=NoErrors;
  }
  else
  {
    sprintf (msg, "No text exists for error number %d\n", errno);
    status=ScErrorForeign;
  }
  if (*msg)
  {
    if (ReturnMsg == NULL)
    {
      switch(errno&0xF000)
      {
        case ERR_SC:
	  fprintf (stderr,"SLIB Error -- %s", msg);
          break;
#ifdef ERR_SV
        case ERR_SV:
	  fprintf (stderr,"SLIB Video Error -- %s", msg);
          break;
#endif
#ifdef ERR_SA
        case ERR_SA:
	  fprintf (stderr,"SLIB Audio Error -- %s", msg);
          break;
#endif
#ifdef ERR_SR
        case ERR_SR:
	  fprintf (stderr,"SLIB Render Error -- %s", msg);
          break;
#endif
        default:
	  fprintf (stderr,"Error -- %s", msg);
      }
    }
    else
    {
      strncpy (ReturnMsg, msg, MaxChars);
      ReturnMsg[MaxChars-1] = 0; /* Make sure string is NULL terminated */
    }
  }

  return (status);
}


char *ScGetErrorStr(int errno)
{
  static char errstr[255];
  errstr[0]=0;
  ScGetErrorText(errno, errstr, sizeof(errstr)-1);
  return(errstr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sv_intrn.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sv_internals.h,v $
 * Revision 1.1.8.2  1996/05/07  19:56:06  Hans_Graves
 * 	Added HUFF_SUPPORT.
 * 	[1996/05/07  17:25:29  Hans_Graves]
 *
 * Revision 1.1.6.2  1996/03/29  22:21:16  Hans_Graves
 * 	Added JPEG_SUPPORT ifdefs.  Moved JPEG specific data to JpegInfo structures
 * 	[1996/03/29  22:14:34  Hans_Graves]
 * 
 * Revision 1.1.4.2  1995/12/07  19:31:30  Hans_Graves
 * 	Added SvMpegCompressInfo_t pointer
 * 	[1995/12/07  18:27:16  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/09/22  12:58:41  Bjorn_Engberg
 * 	Added MPEG_SUPPORT, H261_SUPPORT and BITSTREAM_SUPPORT.
 * 	[1995/09/22  12:49:37  Bjorn_Engberg]
 * 
 * Revision 1.1.2.6  1995/09/11  18:49:43  Farokh_Morshed
 * 	Support BI_BITFIELDS format
 * 	[1995/09/11  18:49:23  Farokh_Morshed]
 * 
 * Revision 1.1.2.5  1995/07/21  17:41:06  Hans_Graves
 * 	Renamed Callback related stuff.
 * 	[1995/07/21  17:28:26  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/07/17  16:12:14  Hans_Graves
 * 	Moved BSIn, BufQ and ImageQ to SvCodecInfo_t structure.
 * 	[1995/07/17  15:54:04  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/19  20:31:17  Karen_Dintino
 * 	Added support for H.261
 * 	[1995/06/19  20:14:01  Karen_Dintino]
 * 
 * Revision 1.1.2.2  1995/05/31  18:10:06  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:43:08  Hans_Graves]
 * 
 * Revision 1.1.2.3  1994/11/18  18:48:17  Paul_Gauthier
 * 	Cleanup & bug fixes
 * 	[1994/11/18  18:45:08  Paul_Gauthier]
 * 
 * Revision 1.1.2.2  1994/10/07  14:54:06  Paul_Gauthier
 * 	SLIB v3.0 incl. MPEG Decode
 * 	[1994/10/07  13:56:29  Paul_Gauthier]
 * 
 * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0 
** 
** FILE NAME:   
** MODULE NAME: 
**
** MODULE DESCRIPTION: 
** 
** DESIGN OVERVIEW: 
** 
**--
*/
/*      "%Z% %M% revision %I%; last modified %G%"; */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1994                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
                                                                                
/*--------------------------------------------------------------------------
 * Baseline data structure definitions.
 *
 * Modification History: sv_internals.h
 *
 *      08-Sep-94  PSG   Created
 *---------------------------------------------------------------------------*/



#ifndef _SV_INTERNALS_H_
#define _SV_INTERNALS_H_

#include "SV.h"
#ifdef JPEG_SUPPORT
#include "sv_jpeg.h"
#endif /* JPEG_SUPPORT */

#ifdef MPEG_SUPPORT
#include "sv_mpeg.h"
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
#include "sv_h261.h"
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
#include "sv_h263.h"
#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
#include "sv_huff.h"
#endif /* HUFF_SUPPORT */

#if defined(MPEG_SUPPORT) || defined(H261_SUPPORT) || defined(H263_SUPPORT) || defined(HUFF_SUPPORT)
#define BITSTREAM_SUPPORT
#endif /* MPEG_SUPPORT || H261_SUPPORT */

#define  TOC_ENTRIES_INCREMENT 100
#define  TEMP_BUF_SIZE        8192
#define  JBUFSIZE	     16384 
#define  BYTE_BUF_SIZE        8192

/*
** The following structure contains *all* state information pertaining 
** to each individual codec instance. Anything SLIB would ever want
** about the codec configuration is contained in this structure.
** For example:
**	- what is the codec configured for: compression or decompression
**	- source image characteristics
**	- destination image characteristics
**	- characteristics particular to JPEG compression
**	- characteristics particular to JPEG decompression
**	- component specific information
**
*/
typedef struct SvCodecInfo_s {
  /*
  ** what is the CODEC opened for:
  */ 
  SvCodecType_e	mode;		       /* code type, encode or decode */
  ScBoolean_t   started;           /* begin was called? */
  /*
  ** specific CODEC info
  */
  union {
    void *info;
#ifdef JPEG_SUPPORT
    /*
    ** JPEG information is stored here:
    **	modes = SV_JPEG_DECODE, SV_JPEG_ENCODE
    */
    SvJpegDecompressInfo_t *jdcmp;
    SvJpegCompressInfo_t *jcomp;
#endif /* !JPEG_SUPPORT */
#ifdef MPEG_SUPPORT
    /*
    ** MPEG specific information is stored here:
    **   modes = SV_MPEG_DECODE, SV_MPEG_ENCODE, SV_MPEG_DECODE, SV_MPEG_ENCODE
    */
    SvMpegDecompressInfo_t *mdcmp;
    SvMpegCompressInfo_t   *mcomp;
#endif /* !MPEG_SUPPORT */
#ifdef H261_SUPPORT
    /* Encoding specific information for H.261 is kept in this structure
    ** which is defined in sv_h261.h
    */
    SvH261Info_t *h261;
#endif /* !H261_SUPPORT */
#ifdef H263_SUPPORT
    /*
    ** H263 specific information is stored here:
    */
    SvH263DecompressInfo_t *h263dcmp;
    SvH263CompressInfo_t *h263comp;
#endif /* !MPEG_SUPPORT */
#ifdef HUFF_SUPPORT
    /* Encoding specific information for huffman video encoder & decoder
    */
    SvHuffInfo_t  *huff;
#endif /* !HUFF_SUPPORT */
  }; /* union */

  /*
  ** Source image characteristics:
  */
  int Width;			       /* pixels/lines     */
  int Height;			       /* number of lines  */
  unsigned int NumOperations;  /* # codec operations this session */

                                /*
  ** Microsoft specific:
  */
  BITMAPINFOHEADER   InputFormat;	
  DWORD InRedMask;      /* For BI_BITFIELDS */
  DWORD InGreenMask;    /* For BI_BITFIELDS */
  DWORD InBlueMask;     /* For BI_BITFIELDS */

  BITMAPINFOHEADER   OutputFormat;	
  DWORD OutRedMask;      /* For BI_BITFIELDS */
  DWORD OutGreenMask;    /* For BI_BITFIELDS */
  DWORD OutBlueMask;     /* For BI_BITFIELDS */

  /*
  **  Bitstream stuff - Only used by H261, H263 and MPEG
  */
  ScQueue_t      *BufQ;    /* The queue of bitstream data buffers */
  ScQueue_t      *ImageQ;  /* The queue of images (streaming mode only) */
  ScBitstream_t  *BSIn;
  ScBitstream_t  *BSOut;
  /*
  ** Callback function to abort processing & bitstream operations
  */
  int (* CallbackFunction)(SvHandle_t, SvCallbackInfo_t *, SvPictureInfo_t *); 
} SvCodecInfo_t;


#endif _SV_INTERNALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\slib.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib.h,v $
 * Revision 1.1.6.22  1996/12/13  18:19:02  Hans_Graves
 * 	Added SlibErrorNoBeginning enum
 * 	[1996/12/13  17:42:20  Hans_Graves]
 *
 * Revision 1.1.6.21  1996/12/10  19:21:51  Hans_Graves
 * 	Added Avg/VarVideoTimeDiff and SlibFrameToTime100() macro
 * 	[1996/12/10  19:17:53  Hans_Graves]
 * 
 * Revision 1.1.6.20  1996/12/05  20:10:13  Hans_Graves
 * 	Added AvgVideoTimeDiff and AvgAudioTimeDiff to SlibInfo_t
 * 	[1996/12/05  20:07:53  Hans_Graves]
 * 
 * Revision 1.1.6.19  1996/12/03  00:08:29  Hans_Graves
 * 	Added unit SLIB_UNIT_PERCENT100 and Seek type SLIB_SEEK_RESYNC.
 * 	[1996/12/03  00:02:47  Hans_Graves]
 * 
 * Revision 1.1.6.18  1996/11/20  02:15:07  Hans_Graves
 * 	Added SEEK_AHEAD.
 * 	[1996/11/20  01:49:55  Hans_Graves]
 * 
 * Revision 1.1.6.17  1996/11/18  23:07:14  Hans_Graves
 * 	Change operations to the time-based instead of frame-based.
 * 	[1996/11/18  22:56:34  Hans_Graves]
 * 
 * Revision 1.1.6.16  1996/11/11  18:21:02  Hans_Graves
 * 	Added proto for slibRenamePin().
 * 	[1996/11/11  17:58:03  Hans_Graves]
 * 
 * Revision 1.1.6.15  1996/11/08  21:50:59  Hans_Graves
 * 	Added AC3 stuff. Better seperation of stream types.
 * 	[1996/11/08  21:18:22  Hans_Graves]
 * 
 * Revision 1.1.6.14  1996/10/31  00:08:53  Hans_Graves
 * 	Added SLIB_TIME_UNKNOWN
 * 	[1996/10/31  00:07:57  Hans_Graves]
 * 
 * Revision 1.1.6.13  1996/10/28  17:32:23  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:19:38  Hans_Graves]
 * 
 * Revision 1.1.6.12  1996/10/17  00:23:30  Hans_Graves
 * 	Added SLIB_PARAM_VIDEOFRAME and SLIB_PARAM_FRAMEDURATION.
 * 	[1996/10/17  00:17:53  Hans_Graves]
 * 
 * Revision 1.1.6.11  1996/10/12  17:18:19  Hans_Graves
 * 	Added params HALFPEL and SKIPPEL. Seperated MPEG2_SYSTEMS into TRANSPORT and PROGRAM.
 * 	[1996/10/12  16:57:14  Hans_Graves]
 * 
 * Revision 1.1.6.10  1996/10/03  19:14:19  Hans_Graves
 * 	Added PTimeCode and DTimeCode to Info struct.
 * 	[1996/10/03  19:08:35  Hans_Graves]
 * 
 * Revision 1.1.6.9  1996/09/29  22:19:35  Hans_Graves
 * 	Added stride support. Added SlibQueryData().
 * 	[1996/09/29  21:28:25  Hans_Graves]
 * 
 * Revision 1.1.6.8  1996/09/25  19:16:41  Hans_Graves
 * 	Reduce number of includes needed publicly by adding SLIB_INTERNAL ifdef.
 * 	[1996/09/25  19:02:38  Hans_Graves]
 * 
 * Revision 1.1.6.7  1996/09/23  18:04:01  Hans_Graves
 * 	Added STATS params.
 * 	[1996/09/23  18:03:23  Hans_Graves]
 * 
 * Revision 1.1.6.6  1996/09/18  23:46:20  Hans_Graves
 * 	Clean up. Added SlibAddBufferEx() and SlibReadData() protos.
 * 	[1996/09/18  21:59:36  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/08/09  20:51:19  Hans_Graves
 * 	Fix proto for SlibRegisterVideoBuffer()
 * 	[1996/08/09  20:06:26  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/07/19  02:11:05  Hans_Graves
 * 	New params. Added SlibRegisterVideoBuffer.
 * 	[1996/07/19  01:26:07  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/05/10  21:16:53  Hans_Graves
 * 	Changes for Callback support.
 * 	[1996/05/10  20:59:56  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/05/07  19:56:00  Hans_Graves
 * 	Added Callback framework.
 * 	[1996/05/07  17:23:12  Hans_Graves]
 * 
 * Revision 1.1.4.13  1996/04/24  22:33:42  Hans_Graves
 * 	Added proto for slibValidateBitrates()
 * 	[1996/04/24  22:27:46  Hans_Graves]
 * 
 * Revision 1.1.4.12  1996/04/23  21:01:41  Hans_Graves
 * 	Added SlibErrorSettingNotEqual
 * 	[1996/04/23  20:59:36  Hans_Graves]
 * 
 * Revision 1.1.4.11  1996/04/22  15:04:50  Hans_Graves
 * 	Added protos for: slibValidateVideoParams, slibValidateAudioParams, SlibValidateParams
 * 	[1996/04/22  15:03:17  Hans_Graves]
 * 
 * Revision 1.1.4.10  1996/04/19  21:52:20  Hans_Graves
 * 	Additions to SlibInfo: TotalBitRate, MuxBitRate, SystemTimeStamp, PacketCount
 * 	[1996/04/19  21:49:13  Hans_Graves]
 * 
 * Revision 1.1.4.9  1996/04/15  14:18:35  Hans_Graves
 * 	Added temp audio buffer info
 * 	[1996/04/15  14:09:23  Hans_Graves]
 * 
 * Revision 1.1.4.8  1996/04/10  21:47:36  Hans_Graves
 * 	Moved definition for EXTERN to SC.h
 * 	[1996/04/10  21:24:09  Hans_Graves]
 * 
 * 	Added QUALITY and FAST params
 * 	[1996/04/10  20:41:21  Hans_Graves]
 * 
 * Revision 1.1.4.7  1996/04/09  16:04:39  Hans_Graves
 * 	Added EXTERN define for cplusplus compatibility
 * 	[1996/04/09  14:49:16  Hans_Graves]
 * 
 * Revision 1.1.4.6  1996/04/01  19:07:50  Hans_Graves
 * 	Change slibVerifyVideoParams() proto
 * 	[1996/04/01  19:05:31  Hans_Graves]
 * 
 * Revision 1.1.4.5  1996/04/01  16:23:11  Hans_Graves
 * 	NT porting
 * 	[1996/04/01  16:15:51  Hans_Graves]
 * 
 * Revision 1.1.4.4  1996/03/29  22:21:13  Hans_Graves
 * 	Added HeaderProcessed to SlibInfo
 * 	[1996/03/27  21:52:31  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/03/12  16:15:42  Hans_Graves
 * 	Added SLIB_PARAM_FILEBUFSIZE parameter
 * 	[1996/03/12  16:11:55  Hans_Graves]
 * 
 * Revision 1.1.4.2  1996/03/08  18:46:31  Hans_Graves
 * 	Added Imagebuf to SlibInfo_t
 * 	[1996/03/08  16:23:53  Hans_Graves]
 * 
 * Revision 1.1.2.13  1996/02/19  18:03:53  Hans_Graves
 * 	Added more SEEK types.
 * 	[1996/02/19  17:59:12  Hans_Graves]
 * 
 * Revision 1.1.2.12  1996/02/13  18:47:45  Hans_Graves
 * 	Fix some Seek related bugs
 * 	[1996/02/13  18:41:51  Hans_Graves]
 * 
 * Revision 1.1.2.11  1996/02/07  23:23:51  Hans_Graves
 * 	Added slibCountCodesOnPin() prototype
 * 	[1996/02/07  23:19:11  Hans_Graves]
 * 
 * Revision 1.1.2.10  1996/02/06  22:53:55  Hans_Graves
 * 	Prototype updates
 * 	[1996/02/06  22:44:06  Hans_Graves]
 * 
 * Revision 1.1.2.9  1996/02/02  17:36:01  Hans_Graves
 * 	Updated prototypes
 * 	[1996/02/02  17:28:41  Hans_Graves]
 * 
 * Revision 1.1.2.8  1996/01/30  22:23:06  Hans_Graves
 * 	Added AVI YUV support
 * 	[1996/01/30  22:22:00  Hans_Graves]
 * 
 * Revision 1.1.2.7  1996/01/15  16:26:26  Hans_Graves
 * 	Added: TYPE_WAVE, more PARAMs, SlibWriteAudio()
 * 	[1996/01/15  15:44:44  Hans_Graves]
 * 
 * Revision 1.1.2.6  1996/01/11  16:17:26  Hans_Graves
 * 	Added SlibGet/SetParam() prototypes
 * 	[1996/01/11  16:13:44  Hans_Graves]
 * 
 * Revision 1.1.2.5  1996/01/08  16:41:25  Hans_Graves
 * 	Cleaned up prototypes
 * 	[1996/01/08  15:48:38  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/12/07  19:31:27  Hans_Graves
 * 	Added JPEG Decoding and MPEG encoding support
 * 	[1995/12/07  18:28:11  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/11/09  23:14:03  Hans_Graves
 * 	Added Time structure members and prototypes
 * 	[1995/11/09  23:10:32  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/11/06  18:47:45  Hans_Graves
 * 	First time under SLIB
 * 	[1995/11/06  18:34:32  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _SLIB_H_
#define _SLIB_H_

#ifdef WIN32
#include <windows.h>
#endif
#include "SC.h"
#ifdef SLIB_INTERNAL
#include "SV.h"
#include "SA.h"
#include "scon.h"
#endif /* SLIB_INTERNAL */

typedef void       *SlibHandle_t;
typedef ScBoolean_t SlibBoolean_t;
typedef int         SlibStream_t;
typedef qword       SlibTime_t;
typedef qword       SlibPosition_t;

#define SLIB_TIME_NONE     (SlibTime_t)(-1)
#define SLIB_TIME_UNKNOWN  (SlibTime_t)(-2)

/* units used in seeking */
typedef enum {
  SLIB_UNIT_NONE,
  SLIB_UNIT_FRAMES,     /* frames */
  SLIB_UNIT_MS,         /* milliseconds */
  SLIB_UNIT_PERCENT100, /* one hundredth of percent */
} SlibUnit_t;

#define SlibTimeIsValid(stime)  ((stime)>=0)
#define SlibTimeIsInValid(stime)  ((stime)<0)
#define SlibTimeToFrame(Sh,vs,stime) \
      ((qword)((stime)*SlibGetParamFloat(Sh, vs, SLIB_PARAM_FPS))/1000)
#define SlibFrameToTime(Sh,vs,frame) \
  ((SlibTime_t)((float)(frame*1000)/SlibGetParamFloat(Sh, vs, SLIB_PARAM_FPS)))
#define SlibFrameToTime100(Sh,vs,frame) \
 ((SlibTime_t)((float)(frame*100000)/SlibGetParamFloat(Sh, vs, SLIB_PARAM_FPS)))

typedef qword SlibListParam1_t;
typedef qword SlibListParam2_t;

typedef struct SlibList_s {
  int   Enum;   /* an enumerated value associated with the entry */
  char *Name;   /* the name of an entry in the list. NULL = last entry */
  char *Desc;   /* a lengthy description of the entry */
  SlibListParam1_t param1;
  SlibListParam2_t param2;
} SlibList_t;

typedef enum {
  SlibErrorNone = 0,
  SlibErrorInternal,
  SlibErrorMemory,
  SlibErrorBadArgument,
  SlibErrorBadHandle,
  SlibErrorBadStream,
  SlibErrorBadMode,
  SlibErrorUnsupportedFormat,
  SlibErrorReading,
  SlibErrorWriting,
  SlibErrorBufSize,
  SlibErrorEndOfStream,
  SlibErrorForwardOnly,
  SlibErrorUnsupportedParam,
  SlibErrorImageSize,        /* Invalid image height and/or width */
  SlibErrorSettingNotEqual,  /* The exact Parameter setting was not accepted */
  SlibErrorInit,             /* initialization error */
  SlibErrorFileSize,         /* file size unknown */
  SlibErrorBadPosition,      /* position argument to seek is invalid */
  SlibErrorBadUnit,          /* units are invalid */
  SlibErrorNoBeginning,      /* couldn't begin the codecs */
  SlibErrorNoData,           /* no data available */
} SlibStatus_t;

typedef enum {
  SLIB_MODE_NONE,
  SLIB_MODE_COMPRESS,
  SLIB_MODE_COMPRESS_APPEND,
  SLIB_MODE_DECOMPRESS,
} SlibMode_t;

typedef enum {
  SLIB_TYPE_UNKNOWN=0,
  /* MPEG elementary stream types */
  SLIB_TYPE_MPEG1_VIDEO=0x01,
  SLIB_TYPE_MPEG1_AUDIO=0x02,
  SLIB_TYPE_MPEG2_VIDEO=0x04,
  SLIB_TYPE_MPEG2_AUDIO=0x08,
  SLIB_TYPE_AC3_AUDIO=0x10,
  /* MPEG multiplex types */
  SLIB_TYPE_MPEG_SYSTEMS=0x100,
  SLIB_TYPE_MPEG_SYSTEMS_MPEG2=0x104, /* MPEG Systems with MPEG2 data */
  SLIB_TYPE_MPEG_TRANSPORT=0x200,
  SLIB_TYPE_MPEG_PROGRAM=0x400,
  /* H26? stream types */
  SLIB_TYPE_H261=0x800,
  SLIB_TYPE_RTP_H261=0x808,
  SLIB_TYPE_H263=0x810,
  SLIB_TYPE_RTP_H263=0x818,
  /* RIFF stream types */
  SLIB_TYPE_RIFF=0x1000,
  SLIB_TYPE_PCM_WAVE,
  SLIB_TYPE_AVI,
  SLIB_TYPE_MJPG_AVI,
  SLIB_TYPE_JPEG_AVI,
  SLIB_TYPE_YUV_AVI,
  /* Other stream types */
  SLIB_TYPE_JPEG_QUICKTIME=0x2000,
  SLIB_TYPE_JFIF,
  SLIB_TYPE_MJPG,
  SLIB_TYPE_JPEG,
  SLIB_TYPE_YUV,
  SLIB_TYPE_RGB,
  SLIB_TYPE_PCM,
  /* G72? stream types */
  SLIB_TYPE_G723=0x4000,
  /* Miscellaneous types */
  SLIB_TYPE_RASTER=0x8000,
  SLIB_TYPE_BMP,
  /* Test stream types */
  SLIB_TYPE_SLIB=0xC000,
  SLIB_TYPE_SHUFF
} SlibType_t;

#ifdef OLD_SLIB
#define SLIB_TYPE_MPEG1_SYSTEMS   SLIB_TYPE_MPEG_SYSTEMS
#define SLIB_TYPE_MPEG2_SYSTEMS   SLIB_TYPE_MPEG_TRANSPORT
#define SLIB_TYPE_MPEG2_TRANSPORT SLIB_TYPE_MPEG_TRANSPORT
#define SLIB_TYPE_MPEG2_PROGRAM   SLIB_TYPE_MPEG_PROGRAM
#endif /* OLD_SLIB */

#define SlibTypeIsMPEG(stype) (stype>=SLIB_TYPE_MPEG1_VIDEO && \
                               stype<=SLIB_TYPE_MPEG_PROGRAM)
#define SlibTypeIsMPEGVideo(stype) (stype<=SLIB_TYPE_MPEG_PROGRAM && \
                                    (stype&0x705))
#define SlibTypeIsMPEGAudio(stype) (stype<=SLIB_TYPE_MPEG_PROGRAM && \
                                    (stype&0x70A))
#define SlibTypeIsMPEGMux(stype) (stype>=SLIB_TYPE_MPEG_SYSTEMS && \
                                  stype<=SLIB_TYPE_MPEG_PROGRAM)
#define SlibTypeIsMPEG2(stype) (stype==SLIB_TYPE_MPEG2_VIDEO || \
                                stype==SLIB_TYPE_MPEG_PROGRAM || \
                                stype==SLIB_TYPE_MPEG_TRANSPORT || \
                                stype==SLIB_TYPE_MPEG2_AUDIO)
#define SlibTypeIsMPEG1(stype) (stype==SLIB_TYPE_MPEG1_VIDEO || \
                                stype==SLIB_TYPE_MPEG1_AUDIO || \
                                stype==SLIB_TYPE_MPEG_SYSTEMS)
#define SlibTypeIsH26X(stype)  ((stype&0xFF00)==0x0800)
#define SlibTypeIsAVI(stype)   (stype>=SLIB_TYPE_AVI && \
                                stype<=SLIB_TYPE_YUV_AVI)
#define SlibTypeIsAudioOnly(stype) (stype==SLIB_TYPE_MPEG1_AUDIO || \
                                    stype==SLIB_TYPE_AC3_AUDIO || \
                                    stype==SLIB_TYPE_G723 || \
                                    stype==SLIB_TYPE_PCM || \
                                    stype==SLIB_TYPE_PCM_WAVE)
#define SlibTypeIsVideoOnly(stype) (stype==SLIB_TYPE_MPEG1_VIDEO || \
                                    stype==SLIB_TYPE_MPEG2_VIDEO || \
                                    SlibTypeIsH26X(stype) || \
                                    stype==SLIB_TYPE_YUV || \
                                    stype==SLIB_TYPE_RGB || \
                                    stype==SLIB_TYPE_BMP || \
                                    stype==SLIB_TYPE_RASTER)
#define SlibTypeIsMux(stype)     (SlibTypeIsMPEGMux(stype) || \
                                  SlibTypeIsAVI(stype))
#define SlibTypeHasTimeStamps(stype) (SlibTypeIsMPEGMux(stype))

typedef enum {
  SLIB_DATA_COMPRESSED=0,
  SLIB_DATA_AUDIO,
  SLIB_DATA_VIDEO,
  SLIB_DATA_PRIVATE
} SlibDataType_t;

typedef enum {
  SLIB_MSG_CONTINUE=0,
  SLIB_MSG_OPEN=0x01,
  SLIB_MSG_ENDOFDATA=0x10,
  SLIB_MSG_ENDOFSTREAM,
  SLIB_MSG_BUFDONE,
  SLIB_MSG_REPOSITION=0x20,
  SLIB_MSG_BADPOSITION,
  SLIB_MSG_CLOSE=0x80
} SlibMessage_t;

typedef qword SlibCBParam1_t;
typedef qword SlibCBParam2_t;

typedef enum {
  SLIB_QUERY_QUERIES,
  SLIB_QUERY_TYPES,
  SLIB_QUERY_COMP_TYPES,
  SLIB_QUERY_DECOMP_TYPES,
  SLIB_QUERY_MODES,
  SLIB_QUERY_PARAMETERS,
  SLIB_QUERY_ERRORS
} SlibQueryType_t;

typedef enum {
  /* these use position */
  SLIB_SEEK_EXACT=0x00,    /* jump to the exact frame */
  SLIB_SEEK_KEY,           /* jump to the closest key (I) frame */
  SLIB_SEEK_AHEAD,         /* jump ahead by a certain amount */
  SLIB_SEEK_NEXT_NEAR=0x08, /* advance to a frame near the requested frame */
  SLIB_SEEK_NEXT_EXACT,    /* advance to the exact requested frame */
  /* these don't use position */
  SLIB_SEEK_NEXT_KEY=0x10, /* advance to the next key (I) frame */
  SLIB_SEEK_NEXT_SUBKEY,   /* advance to the next key (I) or subkey (P) frame */
  SLIB_SEEK_NEXT,          /* advance one frame */
  SLIB_SEEK_RESET=0x100,   /* reset the streams */
  SLIB_SEEK_RESYNC         /* sync up all the streams */
} SlibSeekType_t;

#define SlibSeekTypeUsesPosition(seektype) (seektype<SLIB_SEEK_NEXT_KEY)

typedef struct SlibSeekInfo_s {
  SlibTime_t        VideoTimeStamp;
  SlibTime_t        AudioTimeStamp;
  qword             FramesSkipped;
} SlibSeekInfo_t;

typedef enum {
  /* SLIB Parameters */
  SLIB_PARAM_VERSION=0x00,  /* SLIB version number */
  SLIB_PARAM_VERSION_DATE,  /* SLIB build date */
  SLIB_PARAM_NEEDACCURACY,  /* need accurate frame counts and audio lengths */
  SLIB_PARAM_DEBUG,         /* debug handle */
  SLIB_PARAM_TYPE,          /* stream type */
  SLIB_PARAM_OVERFLOWSIZE,  /* pin overflowing size */
  SLIB_PARAM_KEY,           /* SLIB security key */
  /* Video Parameters */
  SLIB_PARAM_FPS=0x100,
  SLIB_PARAM_WIDTH,
  SLIB_PARAM_HEIGHT,
  SLIB_PARAM_IMAGESIZE,
  SLIB_PARAM_VIDEOBITRATE,
  SLIB_PARAM_VIDEOFORMAT,
  SLIB_PARAM_VIDEOBITS,
  SLIB_PARAM_VIDEOSTREAMS,
  SLIB_PARAM_VIDEOLENGTH,       /* total video length in miliiseconds */
  SLIB_PARAM_VIDEOFRAMES,       /* total video frames */
  SLIB_PARAM_VIDEOQUALITY,      /* video quality */
  SLIB_PARAM_VIDEOASPECTRATIO,  /* video aspect ratio: height/width */
  SLIB_PARAM_NATIVEVIDEOFORMAT, /* native/compressed format */
  SLIB_PARAM_NATIVEWIDTH,       /* native/compressed width */
  SLIB_PARAM_NATIVEHEIGHT,      /* native/compress height */
  SLIB_PARAM_VIDEOPROGRAM,      /* Video Program ID (Transport) */
  SLIB_PARAM_STRIDE,            /* bytes between scan lines */
  SLIB_PARAM_VIDEOFRAME,        /* video frame */
  SLIB_PARAM_FRAMEDURATION,     /* video frame duration in 100-nanosec units */
  SLIB_PARAM_VIDEOMAINSTREAM,   /* Main Video Stream (Systems+Program) */
  SLIB_PARAM_FRAMETYPE,         /* frame type - I, P, B or D */
  /* Audio Parameters */
  SLIB_PARAM_AUDIOFORMAT=0x200,
  SLIB_PARAM_AUDIOBITRATE,
  SLIB_PARAM_AUDIOSTREAMS,
  SLIB_PARAM_AUDIOCHANNELS,
  SLIB_PARAM_AUDIOLENGTH,     /* milliseconds of audio */
  SLIB_PARAM_AUDIOQUALITY,    /* audio quality */
  SLIB_PARAM_SAMPLESPERSEC,
  SLIB_PARAM_BITSPERSAMPLE,
  SLIB_PARAM_NATIVESAMPLESPERSEC,
  SLIB_PARAM_NATIVEBITSPERSAMPLE,
  SLIB_PARAM_AUDIOPROGRAM,    /* Audio Program ID (Transport) */
  SLIB_PARAM_AUDIOMAINSTREAM, /* Main Audio Stream (Systems+Program) */
  /* Common Codec Parameters */
  SLIB_PARAM_FASTENCODE=0x400,/* fast encoding desired */
  SLIB_PARAM_FASTDECODE,      /* fast decoding desired */
  SLIB_PARAM_KEYSPACING,      /* I frames */
  SLIB_PARAM_SUBKEYSPACING,   /* P frames */
  SLIB_PARAM_MOTIONALG=0x420, /* Motion estimation algorithm */
  SLIB_PARAM_MOTIONSEARCH,    /* Motion search limit */
  SLIB_PARAM_MOTIONTHRESH,    /* Motion threshold */
  SLIB_PARAM_ALGFLAGS,        /* Algorithm flags */
  SLIB_PARAM_FORMATEXT,       /* Format Extensions */
  SLIB_PARAM_QUANTI=0x480,    /* Intra-frame Quantization Step */
  SLIB_PARAM_QUANTP,          /* Inter-frame Quantization Step */
  SLIB_PARAM_QUANTB,          /* Bi-directional frame Quantization Step */
  SLIB_PARAM_QUANTD,          /* D (preview) frame Quantization Step */
  /* File/Stream Parameters */
  SLIB_PARAM_BITRATE=0x800,   /* overall bitrate */
  SLIB_PARAM_TIMECODE,        /* actual timecode */
  SLIB_PARAM_CALCTIMECODE,    /* calculated timecode - 0 based */
  SLIB_PARAM_FILESIZE,
  SLIB_PARAM_FILEBUFSIZE,     /* file read/write buffer size */
  SLIB_PARAM_PTIMECODE,       /* presentation timestamp */
  SLIB_PARAM_DTIMECODE,       /* decoding timestamp */
  SLIB_PARAM_PERCENT100,      /* position in 100th of percent units */
  /* Buffering/delay Parameters */
  SLIB_PARAM_VBVBUFFERSIZE=0x1000, /* Video Buffer Verifier buf size in bytes */
  SLIB_PARAM_VBVDELAY,        /* Video Buffer Verifier delay */
  SLIB_PARAM_PACKETSIZE,      /* Packet size (RTP) */
  SLIB_PARAM_MININPUTSIZE,    /* Minimum input sample size */
  SLIB_PARAM_INPUTSIZE,       /* Suggested input sample size */
  SLIB_PARAM_COMPBUFSIZE,     /* Slib Internal compressed buffer size */
  /* Stats Parameters */
  SLIB_PARAM_STATS=0x1800,    /* Turn stats recording on/off */
  SLIB_PARAM_STATS_RESET,     /* Reset stats */
  SLIB_PARAM_STATS_TIME,      /* Ellapsed time */
  SLIB_PARAM_STATS_FRAMES,    /* Frames encoded/decoded/skipped */
  SLIB_PARAM_STATS_FRAMESPROCESSED, /* Frames encoded/decoded */
  SLIB_PARAM_STATS_FRAMESSKIPPED,   /* Frames skipped */
  SLIB_PARAM_STATS_FPS,             /* Frames per second */
  /* Miscellaneous Parameters */
  SLIB_PARAM_CB_IMAGE=0x1C00, /* Turn image callbacks on/off */
  SLIB_PARAM_CB_TIMESTAMP,    /* Turn timestamp callbacks on/off */
} SlibParameter_t;

typedef enum {
  SLIB_CODEC_STATE_NONE,   /* codec is unopened */
  SLIB_CODEC_STATE_OPEN,   /* codec is opened */
  SLIB_CODEC_STATE_INITED, /* codec is opened and inited */
  SLIB_CODEC_STATE_BEGUN,  /* codec is opened, inited and begun */
  SLIB_CODEC_STATE_REPOSITIONING,  /* codec is opened, inited and begun,
                                      but stream is being repositioned */
} SlibCodecState_t;
/*
** Stream selections
*/
#define SLIB_STREAM_ALL       -1
#define SLIB_STREAM_MAINVIDEO  0
#define SLIB_STREAM_MAINAUDIO  1

typedef struct SlibQueryInfo_s {
  SlibType_t    Type;
  dword         HeaderStart;
  dword         HeaderSize;
  dword         Bitrate; /* overall bitrate */
  /* Video info */
  int           VideoStreams;
  short         Width;
  short         Height;
  dword         VideoBitrate;
  float         FramesPerSec;
  qword         VideoLength;
  /* Audio info */
  int           AudioStreams;
  unsigned int  SamplesPerSec;
  int           BitsPerSample;
  int           Channels;
  dword         AudioBitrate;
  qword         AudioLength;
} SlibQueryInfo_t;

#ifdef SLIB_INTERNAL
typedef struct SlibBuffer_s {
  qword          offset;
  unsigned dword size;
  unsigned char *address;
  SlibTime_t     time;
  struct SlibBuffer_s *next;
} SlibBuffer_t;

typedef struct SlibPin_s {
  int           ID;
  char          name[15];
  qword         Offset;
  SlibBuffer_t *Buffers;
  SlibBuffer_t *BuffersTail;
  dword         BufferCount;
  qword         DataSize;   /* total amount of data on pin */
  struct SlibPin_s *next;
} SlibPin_t;

typedef struct SlibStats_s {
  SlibBoolean_t Record;         /* stats recording on/off */
  SlibTime_t    StartTime;
  SlibTime_t    StopTime;
  qword         FramesProcessed;
  qword         FramesSkipped;
} SlibStats_t;

typedef struct SlibInfo_s {
  SlibType_t        Type;
  SlibMode_t        Mode;
  /* Handles */
  SvHandle_t        Svh; /* video */
  SaHandle_t        Sah; /* audio */
  SconHandle_t      Sch; /* conversion */
  SlibBoolean_t     NeedAccuracy;
  dword             TotalBitRate;/* overall bitrate: video+audio+mux */
  dword             MuxBitRate;  /* bitrate required by multiplexing codes */
  SlibTime_t        SystemTimeStamp; /* timestamp for next data on pins */
  int               VideoPID;    /* MPEG II Video Program ID */
  int               VideoMainStream; /* Main Stream used for video */
  SlibType_t        VideoType;   /* Video Stream type */
  /* Audio parameters */
  int               AudioStreams;
  unsigned int      SamplesPerSec;
  int               BitsPerSample;
  int               Channels;
  dword             AudioBitRate;
  int               AudioPID;    /* MPEG II Audio Program ID */
  int               AudioMainStream; /* Main Stream used for audio */
  SlibType_t        AudioType;   /* Audio Stream type */
  /* Video parameters */
  int               VideoStreams;
  word              Width;
  word              Height;
  dword             Stride;
  dword             VideoBitRate;
  float             FramesPerSec;
  /* Data Exchange */
  SlibPin_t        *Pins;
  int               PinCount;
  dword             Offset;
  SlibBoolean_t     IOError;       /* file read/write error - EOF */
  unsigned dword    MaxBytesInput; /* used with slibSetMaxInput */
  unsigned qword    InputMarker;   /* used with slibSetMaxInput */
  /* stream dependent stuff */
  SlibTime_t        VideoLength;
  SlibBoolean_t     VideoLengthKnown;
  SlibTime_t        VideoTimeStamp;     /* current video time */
  SlibTime_t        VideoFrameDuration; /* time between frames in 100th ms */
  qword             VideoFramesProcessed;/* frames processed since key points */
  SlibTime_t        AudioLength;
  SlibBoolean_t     AudioLengthKnown;
  SlibTime_t        AudioTimeStamp;     /* current audio time */
  SlibTime_t        LastAudioTimeStamp; /* used when compressing */
  int               KeySpacing;
  int               SubKeySpacing;
  SlibTime_t        AudioPTimeBase;     /* statring presentation timecode */
  SlibTime_t        AudioPTimeCode;     /* presentation timecode */
  SlibTime_t        AudioDTimeCode;     /* decoding timecode */
  SlibTime_t        LastAudioPTimeCode; /* last encoded decoding timecode */
  SlibTime_t        VideoPTimeBase;     /* starting presentation timecode */
  SlibTime_t        VideoPTimeCode;     /* presentation timecode */
  SlibTime_t        VideoDTimeCode;     /* decoding timecode */
  SlibTime_t        LastVideoPTimeCode; /* last encoded decoding timecode */
  SlibTime_t        LastVideoDTimeCode; /* last encoded decoding timecode */
  SlibTime_t        AvgVideoTimeDiff;   /* video times differences */
  SlibTime_t        VarVideoTimeDiff;   /* video times differences variation */
  unsigned qword    BytesProcessed;     /* bytes input or output */
  /* Encoding info */
  SlibBoolean_t     HeaderProcessed;
  int               PacketCount;
  unsigned qword    BytesSincePack;
  /* Miscellaneous */
  SlibMessage_t (*SlibCB)(SlibHandle_t,   /* Callback to supply Bufs */
             SlibMessage_t, SlibCBParam1_t, SlibCBParam2_t, void *);
  void             *SlibCBUserData;
  int               Fd;            /* file descriptor */
  unsigned qword    FileSize;      /* total file length in bytes */
  unsigned dword    FileBufSize;   /* file read/write buffer size */
  unsigned dword    CompBufSize;   /* compressed buffer size */    
  unsigned dword    PacketSize;    /* RTP */    
  BITMAPINFOHEADER *VideoFormat;
  WAVEFORMATEX     *AudioFormat;
  BITMAPINFOHEADER *CodecVideoFormat;
  BITMAPINFOHEADER *CompVideoFormat;
  WAVEFORMATEX     *CompAudioFormat;
  SlibBoolean_t     VideoCodecState;
  SlibBoolean_t     AudioCodecState;
  unsigned char    *Multibuf;      /* multiple image buffer - MPEG, H261 */
  dword             MultibufSize;
  unsigned char    *Imagebuf;      /* temp image buffer - for conversions */
  dword             ImageSize;
  unsigned char    *CodecImagebuf; /* temp image buffer - for scaling */
  dword             CodecImageSize;
  unsigned char    *IntImagebuf;   /* intermediate image buffer - for scaling */
  dword             IntImageSize;
  unsigned char    *Audiobuf;      /* temp audio buffer - for conversions */
  unsigned dword    AudiobufSize;  /* temp audio buffer - for conversions */
  unsigned dword    AudiobufUsed;  /* byte used in audio buffer */
  unsigned dword    OverflowSize;  /* max number of bytes on a stream */
  unsigned dword    VBVbufSize;    /* video buffer verifier size */
  SlibStats_t      *stats;
  void             *dbg;           /* debug handle */
} SlibInfo_t;

#define slibTimeToFrame(Info,stime) ((qword)((stime)*Info->FramesPerSec)/1000)
#define slibFrameToTime(Info,frame) \
             ((SlibTime_t)((float)(frame*1000)/Info->FramesPerSec))
#define slibFrameToTime100(Info,frame) \
             ((SlibTime_t)((float)(frame*100000)/Info->FramesPerSec))
#define slibHasAudio(Info) (Info->AudioStreams>0 || Info->Sah)
#define slibHasVideo(Info) (Info->VideoStreams>0 || Info->Svh)
#define slibHasTimeCode(Info) (slibHasVideo(Info) && SlibTypeIsMPEG(Info->Type))
#define slibInSyncMode(Info) (Info->Fd<0 && Info->SlibCB==NULL)
#endif /* SLIB_INTERNAL */

/********************** Public Prototypes ***********************/
/*
 * slib_api.c
 */
EXTERN SlibStatus_t SlibOpen(SlibHandle_t *handle, SlibMode_t smode,
                   SlibType_t *stype, SlibMessage_t (*slibCB)(SlibHandle_t,
                   SlibMessage_t, SlibCBParam1_t, SlibCBParam2_t, void *),
                    void *cbuserdata);
EXTERN SlibStatus_t SlibOpenSync(SlibHandle_t *handle, SlibMode_t smode, 
                          SlibType_t *stype, void *buffer, unsigned dword bufsize);
EXTERN SlibStatus_t SlibOpenFile(SlibHandle_t *handle, SlibMode_t smode,
                                 SlibType_t *stype, char *filename);
EXTERN SlibStatus_t SlibAddBuffer(SlibHandle_t handle, SlibDataType_t dtype,
                                void *buffer, unsigned dword bufsize);
EXTERN SlibStatus_t SlibAddBufferEx(SlibHandle_t handle, SlibDataType_t dtype,
                                    void *buffer, unsigned dword bufsize,
                                    void *userdata);
EXTERN SlibStatus_t SlibRegisterVideoBuffer(SlibHandle_t handle,
                                void *buffer, unsigned dword bufsize);
EXTERN SlibStatus_t SlibReadAudio(SlibHandle_t handle, SlibStream_t stream,
                      void *audiobuf, unsigned dword *audiobufsize);
EXTERN SlibStatus_t SlibReadVideo(SlibHandle_t handle, SlibStream_t stream,
                      void **videobuf, unsigned dword *videobufsize);
EXTERN SlibStatus_t SlibWriteVideo(SlibHandle_t handle, SlibStream_t stream,
                      void *videobuf, unsigned dword videobufsize);
EXTERN SlibStatus_t SlibWriteAudio(SlibHandle_t handle, SlibStream_t stream,
                      void *audiobuf, unsigned dword audiobufsize);
EXTERN SlibStatus_t SlibReadData(SlibHandle_t handle, SlibStream_t stream,
                          void **databuf, unsigned dword *databufsize,
                          SlibStream_t *readstream);
EXTERN SlibStatus_t SlibQueryData(void *databuf, unsigned dword databufsize,
                                  SlibQueryInfo_t *qinfo);

EXTERN SlibStatus_t SlibSeek(SlibHandle_t handle, SlibStream_t stream,
                      SlibSeekType_t seektype, SlibPosition_t frame);
EXTERN SlibStatus_t SlibSeekEx(SlibHandle_t handle, SlibStream_t stream,
                      SlibSeekType_t seektype, SlibPosition_t position,
                      SlibUnit_t units, SlibSeekInfo_t *seekinfo);
EXTERN SlibBoolean_t SlibIsEnd(SlibHandle_t handle, SlibStream_t stream);

EXTERN SlibStatus_t SlibClose(SlibHandle_t handle);

EXTERN char *SlibGetErrorText(SlibStatus_t status);
EXTERN SlibList_t *SlibQueryList(SlibQueryType_t qtype);
EXTERN char *SlibQueryForDesc(SlibQueryType_t qtype, int enumval);
EXTERN int   SlibQueryForEnum(SlibQueryType_t qtype, char *name);
EXTERN SlibList_t *SlibFindEnumEntry(SlibList_t *list, int enumval);
/*
 * slib_param.c
 */
EXTERN qword SlibGetFrameNumber(SlibHandle_t handle, SlibStream_t stream);
EXTERN SlibTime_t SlibGetAudioTime(SlibHandle_t handle, SlibStream_t stream);
EXTERN SlibTime_t SlibGetVideoTime(SlibHandle_t handle, SlibStream_t stream);

EXTERN SlibBoolean_t SlibCanSetParam(SlibHandle_t handle, SlibStream_t stream,
                                     SlibParameter_t param);
EXTERN SlibBoolean_t SlibCanGetParam(SlibHandle_t handle, SlibStream_t stream,
                                     SlibParameter_t param);
EXTERN SlibStatus_t SlibSetParamInt(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param, long value);
EXTERN SlibStatus_t SlibSetParamLong(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param, qword value);
EXTERN SlibStatus_t SlibSetParamFloat(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param, float value);
EXTERN SlibStatus_t SlibSetParamBoolean(SlibHandle_t handle, 
                                 SlibStream_t stream,
                                 SlibParameter_t param, SlibBoolean_t value);
EXTERN SlibStatus_t SlibSetParamStruct(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param,
                                 void *data, unsigned dword datasize);

EXTERN long SlibGetParamInt(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param);
EXTERN qword SlibGetParamLong(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param);
EXTERN float SlibGetParamFloat(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param);
EXTERN SlibBoolean_t SlibGetParamBoolean(SlibHandle_t handle,
                                 SlibStream_t stream, SlibParameter_t param);
EXTERN char *SlibGetParamString(SlibHandle_t handle, SlibStream_t stream,
                                              SlibParameter_t param);
EXTERN SlibStatus_t SlibValidateParams(SlibHandle_t handle);

/*
 * slib_buffer.c
 */
EXTERN void *SlibAllocBuffer(unsigned int bytes);
EXTERN void *SlibAllocBufferEx(SlibHandle_t handle, unsigned int bytes);
EXTERN void *SlibAllocSharedBuffer(unsigned int bytes, int *shmid);
EXTERN dword SlibGetSharedBufferID(void *address);
EXTERN SlibStatus_t SlibAllocSubBuffer(void *address,
                                        unsigned int bytes);
EXTERN SlibStatus_t SlibFreeBuffer(void *address);
EXTERN SlibStatus_t SlibFreeBuffers(SlibHandle_t handle);
EXTERN unsigned qword SlibMemUsed();

#ifdef SLIB_INTERNAL
/********************** Private Prototypes ***********************/
/*
 * slib_api.c
 */
SlibStatus_t slibStartVideo(SlibInfo_t *Info, SlibBoolean_t fillbuf);
SlibBoolean_t slibUpdatePositions(SlibInfo_t *Info, SlibBoolean_t exactonly);
void slibAdvancePositions(SlibInfo_t *Info, qword frames);
SlibBoolean_t slibUpdateLengths(SlibInfo_t *Info);


/*
 * slib_render.c
 */
SlibStatus_t slibConvertAudio(SlibInfo_t *Info,
                              void *inbuf, unsigned dword inbufsize,
                              unsigned int insps, unsigned int inbps,
                              void **poutbuf, unsigned dword *poutbufsize,
                              unsigned int outsps, unsigned int outbps,
                              unsigned int channels);
SlibStatus_t slibRenderFrame(SlibInfo_t *Info, void *inbuf,
                               unsigned dword informat, void **outbuf);

/*
 * slib_video.c
 */
void SlibUpdateVideoInfo(SlibInfo_t *Info);
SlibStatus_t slibValidateVideoParams(SlibInfo_t *Info);
int slibCalcBits(unsigned dword fourcc, int currentbits);

/*
 * slib_audio.c
 */
void SlibUpdateAudioInfo(SlibInfo_t *Info);
SlibTime_t slibSkipAudio(SlibInfo_t *Info, SlibStream_t stream,
                                           SlibTime_t timems);
SlibStatus_t slibValidateAudioParams(SlibInfo_t *Info);

/*
 * slib_buffer.c
 */
SlibBoolean_t SlibValidBuffer(void *address);
SlibStatus_t slibManageUserBuffer(SlibInfo_t *Info, void *address,
                                   unsigned int bytes, void *userdata);
unsigned char *SlibGetBuffer(SlibInfo_t *Info, int pinid,
                                    unsigned dword *size, SlibTime_t *time);
unsigned char *SlibPeekBuffer(SlibInfo_t *Info, int pinid,
                                    unsigned dword *size, SlibTime_t *time);
unsigned char *slibSearchBuffersOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                 unsigned char *lastbuf, unsigned dword *size,
                                 unsigned int code, int codebytes,
                                 ScBoolean_t discard);
SlibTime_t slibGetNextTimeOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                   unsigned dword maxbytes);
void slibSetMaxInput(SlibInfo_t *Info, unsigned dword maxbytes);
SlibPosition_t slibGetPinPosition(SlibInfo_t *Info, int pinid);
SlibPosition_t slibSetPinPosition(SlibInfo_t *Info, int pinid,
                                                    SlibPosition_t pos);

void slibRemovePins(SlibInfo_t *Info);
void slibEmptyPins(SlibInfo_t *Info);
SlibPin_t *slibRenamePin(SlibInfo_t *Info, int oldpinid,
                                           int newpinid, char *newname);
SlibPin_t *slibGetPin(SlibInfo_t *Info, int pinid);
SlibPin_t *slibAddPin(SlibInfo_t *Info, int pinid, char *name);
SlibStatus_t slibAddBufferToPin(SlibPin_t *pin, void *buffer,
                                unsigned dword size, SlibTime_t time);
SlibStatus_t slibInsertBufferOnPin(SlibPin_t *pin, void *buffer,
                                unsigned dword size, SlibTime_t time);

SlibStatus_t slibRemovePin(SlibInfo_t *Info, int pinid);
SlibStatus_t slibEmptyPin(SlibInfo_t *Info, int pinid);
SlibPin_t *slibLoadPin(SlibInfo_t *Info, int pinid);
SlibPin_t *slibPreLoadPin(SlibInfo_t *Info, SlibPin_t *pin);
SlibStatus_t slibPutBuffer(SlibInfo_t *Info, unsigned char *buffer,
                                             unsigned dword bufsize);
qword slibDataOnPin(SlibInfo_t *Info, int pinid);
qword slibDataOnPins(SlibInfo_t *Info);
unsigned char *slibGetBufferFromPin(SlibInfo_t *Info, SlibPin_t *pin,
                                    unsigned dword *size, SlibTime_t *time);
unsigned char *slibPeekBufferOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                   unsigned dword *size, SlibTime_t *time);
unsigned char *slibPeekNextBufferOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                       unsigned char *lastbuffer,
                                       unsigned dword *size, SlibTime_t *time);
unsigned int slibFillBufferFromPin(SlibInfo_t *Info, SlibPin_t *pin,
                           unsigned char *fillbuf, unsigned dword bufsize,
                           SlibTime_t *time);
word slibGetWordFromPin(SlibInfo_t *Info, SlibPin_t *pin);
dword slibGetDWordFromPin(SlibInfo_t *Info, SlibPin_t *pin);
dword slibCountCodesOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                        unsigned int code, int codebytes,
                        unsigned dword maxlen);
SlibStatus_t slibReposition(SlibInfo_t *Info, SlibPosition_t position);
void slibPinPrepareReposition(SlibInfo_t *Info, int pinid);
void slibPinFinishReposition(SlibInfo_t *Info, int pinid);
SlibBoolean_t slibCommitBuffers(SlibInfo_t *Info, SlibBoolean_t flush);
void slibValidateBitrates(SlibInfo_t *Info);
qword slibGetSystemTime();
#endif /* SLIB_INTERNAL */

#endif /* _SLIB_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sv_h263.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1996                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/****************************************************************************
 *
 *  sv_h263.h
 *  Wei-Lien Hsu
 *  Date: December 11, 1996
 *
 ****************************************************************************/


#ifndef _SV_H263_
#define _SV_H263_

#include "SC.h"
#include "h263.h"

/* Scaled IDCT precision */
#define H263_SCALED_IDCT_BITS   20
#define H263_SCALED_IDCT_MULT   (1<<H263_SCALED_IDCT_BITS)

/* Some macros */
#define sign(a)  	((a) < 0 ? -1 : 1)
#define mnint(a)	((a) < 0 ? (int)(a - 0.5) : (int)(a + 0.5))
#define mshort(a)	((a) < 0.0 ? (short)(a - 0.5) : (short)(a + 0.5))  
#define mmax(a, b)  	((a) > (b) ? (a) : (b))
#define mmin(a, b)  	((a) < (b) ? (a) : (b))

#ifndef INT_MAX
#define INT_MIN     (-2147483647 - 1) /* minimum (signed) int value */
#define INT_MAX       2147483647    /* maximum (signed) int value */
#endif

#ifdef WIN32
#ifndef floorf
#define floorf floor
#endif
#endif

#define H263_mfloor(a)      ((a) < 0 ? (int)(a - 0.5) : (int)(a))
#define H263_limit(x) \
{ \
    if (x > 255) x = 255; \
    if (x <   0)   x = 0; \
}

#define H263_S_CODE

#define H263_NO_VEC                          999

#define H263_DEF_OUTPUTNAME  "DECOUT"

#define H263_T_YUV      0
#define H263_T_SIF      1
#define H263_T_TGA      2
#define H263_T_PPM      3
#define H263_T_X11      4
#define H263_T_YUV_CONC 5
#define H263_T_WIN      6

/* MBC = DEF_PELS/MB_SIZE, MBR = DEF_LINES/MB_SIZE$*/
/* this is necessary for the max resolution 16CIF */
#define H263_MBC                             88
#define H263_MBR                             72

#define H263_YES       1
#define H263_NO        0
#define H263_ON        1
#define H263_OFF       0


/************************** H263 Decoder ********************************/

/*
** Structures used to pass around the H263 decompression information.
** Part of SvCodecInfo_t structure.
*/
typedef struct SvH263DecompressInfo_s {
  ScBoolean_t inited;  /* was this info initialized yet */
  int quality;
  /* output */
  char *outputname;
  int outtype;
  /* printf's */
  int quiet;
  int trace;
  char errortext[256];
  unsigned int frame_rate;
  unsigned int bit_rate; /* encode bitrate */
  unsigned char *refframe[3], *oldrefframe[3];
  unsigned char *bframe[3], *newframe[3];
  unsigned char *edgeframe[3], *edgeframeorig[3]; 
  unsigned char *exnewframe[3];
  int MV[2][5][H263_MBR+1][H263_MBC+2];
  int modemap[H263_MBR+1][H263_MBC+2];
  unsigned char *clp;
  int horizontal_size, vertical_size;
  int mb_width, mb_height;
  int coded_picture_width, coded_picture_height;
  int chrom_width, chrom_height, blk_cnt;
  int pict_type, newgob;
  int mv_outside_frame, syntax_arith_coding;
  int adv_pred_mode, pb_frame;
  int long_vectors;
  int fault, expand;
  int verbose;
  int refidct;
  int matrix_coefficients;
  int temp_ref, quant, source_format;
  int framenum;

  int trd, trb, bscan, bquant;
#if 0
  /* bit input */
  int infile;
  unsigned char rdbfr[2051];
  unsigned char *rdptr;
  unsigned qword inbfr;
  unsigned qword position;
  int incnt;
  int bitcnt;
#endif
  /* block data [12] */
  int (*block)[66];
  void *dbg;  /* debug handle */
} SvH263DecompressInfo_t;


/************************************* H263 Encoder *************************************/

/* If you are not using the included Makefile, or want to override
   the Makefile, you can uncomment one or more of the defines 
   below instead */
/* #define PRINTMV */
/* to print MVs to stdout while coding. */
/* #define PRINTQ */
/* to print the quantizer used during coding */
/* #define FASTIDCT */
/* for a fast single precision IDCT. */
/* #define OFFLINE_RATE_CONTROL */
/* for the rate control optimized for offline encoding. */
/* #define QCIF */
/* to change the coding format uncommment the above line and change to
   SQCIF, QCIF, CIF, CIF4, or CIF16 */

/* From config.h */

/* for FAST search */
#define H263_SRCH_RANGE 24

/*************************************************************************/

/* Default modes */
/* see http://www.nta.no/brukere/DVC/h263_options.html */

/* Added by Nuno on 06/27/96 to support prefiltering */
/* use prefiltering as default */
#define H263_DEF_PREFILT_MODE H263_NO
/*************************************************************************/

/* Search windows */

/* default integer pel search seek distance ( also option "-s <n> " ) */
#define H263_DEF_SEEK_DIST        15   

/* default integer search window for 8x8 search centered 
   around 16x16 vector. When it is zero only half pel estimation
   around the integer 16x16 vector will be performed */
/* for best performance, keep this small, preferably zero,
   but do your own simulations if you want to try something else */
#define H263_DEF_8X8_WIN          0

/* default search window for PB delta vectors */
/* keep this small also */
#define H263_DEF_PBDELTA_WIN      2

/*************************************************************************/

/* Miscellaneous */

/* write repeated reconstructed frames to disk (useful for variable
 * framerate, since sequence will be saved at 25 Hz) 
 * Can be changed at run-time with option "-m" */
#define H263_DEF_WRITE_REPEATED   H263_NO

/* write bitstream trace to files trace.intra / trace 
 * (also option "-t") */
#define H263_DEF_WRITE_TRACE      H263_NO

/* start rate control after DEF_START_RATE_CONTROL % of sequence
 * has been encoded. Can be changed at run-time with option "-R <n>" */
#define H263_DEF_START_RATE_CONTROL   0

/* headerlength on concatenated 4:1:1 YUV input file 
 * Can be changed at run-time with option -e <headerlength> */
#define H263_DEF_HEADERLENGTH     0

/* insert sync after each DEF_INSERT_SYNC for increased error robustness
 * 0 means do not insert extra syncs */
#define H263_DEF_INSERT_SYNC      0

/*************************************************************************/

/* ME methods */
#define H263_FULL_SEARCH         0
#define H263_TWO_LEVELS_7_1      1
#define H263_TWO_LEVELS_421_1    2
#define H263_TWO_LEVELS_7_polint 3
#define H263_TWO_LEVELS_7_pihp   4

#define H263_FINDHALFPEL         0
#define H263_POLINT              1
#define H263_IDLE                2

#define H263_DCT8BY8             0
#define H263_DCT16COEFF          1
#define H263_DCT4BY4             2

/* prefiltering */
#define H263_GAUSS 1
#define H263_MORPH 2

/* morph.c */

#define H263_DEF_HPME_METHOD  H263_FINDHALFPEL
#define H263_DEF_DCT_METHOD   H263_DCT8BY8
#define H263_DEF_VSNR         0  /* FALSE */

#define H263_DEF_SOURCE_FORMAT   H263_SF_QCIF

/* Added by Nuno to support prefiltering */
#define H263_DEF_PYR_DEPTH 3
#define H263_DEF_PREF_PYR_TYPE H263_GAUSS
#define H263_MAX_PYR_DEPTH 5
#define H263_DEF_STAT_PREF_STATE H263_NO

/* This should not be changed */
#define H263_MB_SIZE              16

/* Parameters from TMN */
#define H263_PREF_NULL_VEC        100
#define H263_PREF_16_VEC          200
#define H263_PREF_PBDELTA_NULL_VEC 50


#define H263_MAX_CALC_QUALITY     0xFFFFFFFF
#define H263_MIN_CALC_QUALITY     0x00000000

/****************************/

/* Motionvector structure */

typedef struct H263_motionvector {
  short x;        /* Horizontal comp. of mv         */
  short y;        /* Vertical comp. of mv         */
  short x_half;        /* Horizontal half-pel acc.	 */
  short y_half;        /* Vertical half-pel acc.	 */
  short min_error;        /* Min error for this vector	 */
  short Mode;                     /* Necessary for adv. pred. mode */
} H263_MotionVector;

/* Point structure */

typedef struct H263_point {
  short x;
  short y;
} H263_Point;

/* Structure with image data */

typedef struct H263_pict_image {
  unsigned char *lum;        /* Luminance plane        */
  unsigned char *Cr;        /* Cr plane        */
  unsigned char *Cb;        /* Cb plane        */
} H263_PictImage;

/* Added by Nuno on 06/24/96 to support filtering of the prediction error */
typedef struct pred_image {
  short *lum;		/* Luminance plane		*/
  short *Cr;		/* Cr plane			*/
  short *Cb;		/* Cb plane			*/
} PredImage;

/* Group of pictures structure. */

/* Picture structure */
typedef struct H263_pict {
  int prev; 
  int curr;
  int TR;             /* Time reference */
  int bit_rate;
  int src_frame_rate;
  float target_frame_rate;
  int source_format;
  int picture_coding_type;
  int spare;
  int unrestricted_mv_mode;
  int PB;
  int QUANT;
  int DQUANT;
  int MB;
  int seek_dist;        /* Motion vector search window */
  int use_gobsync;      /* flag for gob_sync */
  int MODB;             /* B-frame mode */
  int BQUANT;           /* which quantizer to use for B-MBs in PB-frame */
  int TRB;              /* Time reference for B-picture */
  float QP_mean;        /* mean quantizer */
} H263_Pict;

/* Slice structure */
/*
typedef struct H263_slice {
  unsigned int vert_pos;	
  unsigned int quant_scale;	
} H263_Slice;
*/
/* Macroblock structure */
/*
typedef struct H263_macroblock {
  int mb_address;        
  int macroblock_type;       
  int skipped;        
  H263_MotionVector motion;	       
} H263_Macroblock;
*/

/* Structure for macroblock data */
typedef struct mb_structure {
  short lum[16][16];
  short Cr[8][8];
  short Cb[8][8];
} H263_MB_Structure;

/* Added by Nuno on 06/24/96 to support filtering of the prediction error */
typedef struct working_buffer {
  short         *qcoeff_P;              /* P frame coefficient */   
  unsigned char *ipol_image;            /* interpolated image */ 
} H263_WORKING_BUFFER;

/* Structure for counted bits */

typedef struct H263_bits_counted {
  int Y;
  int C;
  int vec;
  int CBPY;
  int CBPCM;
  int MODB;
  int CBPB;
  int COD;
  int header;
  int DQUANT;
  int total;
  int no_inter;
  int no_inter4v;
  int no_intra;
/* NB: Remember to change AddBits(), ZeroBits() and AddBitsPicture() 
   when entries are added here */
} H263_Bits;

/* Structure for data for data from previous macroblock */

/* Structure for average results and virtal buffer data */

typedef struct H263_results {
  float SNR_l;        /* SNR for luminance */
  float SNR_Cr;        /* SNR for chrominance */
  float SNR_Cb;
  float QP_mean;                /* Mean quantizer */
} H263_Results;

/**************** RTP *****************/
#define RTP_H263_INTRA_CODED 0x00000001
#define RTP_H263_PB_FRAME    0x00000002
#define RTP_H263_AP          0x00000004
#define RTP_H263_SAC         0x00000008

#define H263_RTP_MODE_A      PARAM_FORMATEXT_RTPA
#define H263_RTP_MODE_B      PARAM_FORMATEXT_RTPB
#define H263_RTP_MODE_C      PARAM_FORMATEXT_RTPC

#define H263_RTP_DEFAULT_MODE  RTP_H263_MODE_A 
#define H263_RTP_MAX_PACKETS   64*2

typedef struct SvH263BSInfo_s {
	unsigned dword	dwFlag;
	unsigned dword	dwBitOffset;
	unsigned char	Mode;
	unsigned char	MBA;
	unsigned char	Quant;
	unsigned char	GOBN;
	char			HMV1;
	char			VMV1;
	char			HMV2;
	char			VMV2;
} SvH263BSInfo_t;

typedef struct SvH263BSTrailer_s {
	unsigned dword	dwVersion;
	unsigned dword	dwFlags;
	unsigned dword	dwUniqueCode;
	unsigned dword  dwCompressedSize;
	unsigned dword  dwNumberOfPackets;
	unsigned char	SourceFormat;
	unsigned char	TR;
	unsigned char   TRB;
	unsigned char   DBQ;
} SvH263BSTrailer_t;

typedef struct SvH263RTPInfo_s {
    SvH263BSTrailer_t trailer;
    SvH263BSInfo_t    bsinfo[H263_RTP_MAX_PACKETS];
    dword             packet_id;
    ScBSPosition_t    pic_start_position, packet_start_position;
	ScBSPosition_t    pre_GOB_position, pre_MB_position;
} SvH263RTPInfo_t;

/*
** Structures used to pass around the H263 compression information.
** Part of SvCodecInfo_t structure.
*/
typedef struct SvH263CompressInfo_s {
  ScBoolean_t inited;  /* was this info initialized yet */
  /* options */
  int quality;
  unsigned dword calc_quality;  /* calculated quality */
  int advanced;
  int syntax_arith_coding;
  int pb_frames;
  int unrestricted;
  int extbitstream;  /* extended bitstream (rtp) */
  int packetsize;    /* packet size (rtp) */
  /* for FAST search */
  unsigned char *block_subs2, *srch_area_subs2;
  /* Global variables */ 
  int headerlength;
  int source_format;
  int mb_width;
  int mb_height;
  int pels;
  int cpels;
  int lines;
  int trace;
  int mv_outside_frame;
  int long_vectors;
  float target_framerate;
  int prefilter; /* Added by Nuno on 06/24/96 to support prefiltering */

  H263_PictImage *prev_image;
  H263_PictImage *curr_image;
  H263_PictImage *curr_recon;
  H263_PictImage *prev_recon;

  /* To support filtering of the prediction error */
  H263_PictImage **curr_filtd;
  H263_PictImage *curr_clean;
  H263_PictImage *curr_selects;
  H263_PictImage *B_selects;

  /* PB-frame specific */
  H263_PictImage *B_recon;
  H263_PictImage *B_image;
  H263_PictImage **B_filtd;
  H263_PictImage *B_clean;

  H263_Pict *pic;
  H263_WORKING_BUFFER *wk_buffers;
  /* for Motion Estimation */
  H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2];
  unsigned char PREF_LEVEL[4][3], MOTresh[4];
  int PYR_DEPTH, PrefPyrType, H263_StaticPref, PETresh[3];

  H263_Bits *bits ;
  H263_Bits *total_bits;
  H263_Bits *intra_bits ;
  H263_Results *res; 
  H263_Results *total_res; 
  H263_Results *b_res ;
  /* bitrate control */
  int buffer_fullness;
  int buffer_frames_stored;
  int first_loop_finished, start_rate_control;
  unsigned char **PreFilterLevel;
  int bit_rate;
  int total_frames_passed, PPFlag;
  int first_frameskip, next_frameskip, chosen_frameskip;
  float orig_frameskip;
  int frames,bframes,pframes,pdist,bdist;
  int distance_to_next_frame;
  int QP, QP_init, QPI;
  float ref_frame_rate, orig_frame_rate;
  float frame_rate, seconds;
  int ME_method;
  int HPME_method;
  int refidct;
  int DCT_method;
  int vsnr;
  int start, end;
  int frame_no;

  SvH263RTPInfo_t *RTPInfo;
  int VARgob[16];

  char *seqfilename; 
  char *streamname; 
  void *dbg;  /* debug handle */
} SvH263CompressInfo_t;


#endif _SV_H263_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sv_api.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sv_api.c,v $
 * Revision 1.1.8.11  1996/10/28  17:32:51  Hans_Graves
 * 	MME-01402. Changed SvGet/SetParamInt() to qwords to allow for timestamps.
 * 	[1996/10/28  17:09:33  Hans_Graves]
 *
 * Revision 1.1.8.10  1996/10/12  17:19:24  Hans_Graves
 * 	Added initialization of SV_PARAM_SKIPPEL and SV_PARAM_HALFPEL to MPEG encode.
 * 	[1996/10/12  17:16:28  Hans_Graves]
 * 
 * Revision 1.1.8.9  1996/09/29  22:19:56  Hans_Graves
 * 	Added stride to ScYuv411ToRgb() calls.
 * 	[1996/09/29  21:34:40  Hans_Graves]
 * 
 * Revision 1.1.8.8  1996/09/25  19:17:01  Hans_Graves
 * 	Fix up support for YUY2 under MPEG.
 * 	[1996/09/25  19:03:17  Hans_Graves]
 * 
 * Revision 1.1.8.7  1996/09/18  23:51:11  Hans_Graves
 * 	Added JPEG 4:1:1 to 4:2:2 conversions. Added BI_YVU9SEP and BI_RGB 24 support in MPEG decode.
 * 	[1996/09/18  22:16:08  Hans_Graves]
 * 
 * Revision 1.1.8.6  1996/07/30  20:25:50  Wei_Hsu
 * 	Add Logarithmetic search for motion estimation.
 * 	[1996/07/30  15:57:59  Wei_Hsu]
 * 
 * Revision 1.1.8.5  1996/05/24  22:22:26  Hans_Graves
 * 	Add GetImageSize MPEG support for BI_DECYUVDIB
 * 	[1996/05/24  22:14:20  Hans_Graves]
 * 
 * Revision 1.1.8.4  1996/05/08  16:24:32  Hans_Graves
 * 	Put BITSTREAM_SUPPORT around BSIn in SvDecompress
 * 	[1996/05/08  16:24:15  Hans_Graves]
 * 
 * Revision 1.1.8.3  1996/05/07  21:24:05  Hans_Graves
 * 	Add missing break in switch statement in SvRegisterCallback
 * 	[1996/05/07  21:19:50  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/05/07  19:56:46  Hans_Graves
 * 	Added HUFF_SUPPORT.  Remove NT warnings.
 * 	[1996/05/07  17:27:18  Hans_Graves]
 * 
 * Revision 1.1.6.12  1996/04/23  18:51:10  Karen_Dintino
 * 	Fix the memory alloc for the ref buffer for WIN32
 * 	[1996/04/23  18:49:23  Karen_Dintino]
 * 
 * Revision 1.1.6.11  1996/04/17  23:44:35  Karen_Dintino
 * 	added initializations for H.261/WIN32
 * 	[1996/04/17  23:43:20  Karen_Dintino]
 * 
 * Revision 1.1.6.10  1996/04/11  22:54:43  Karen_Dintino
 * 	added casting for in SetFrameRate
 * 	[1996/04/11  22:52:29  Karen_Dintino]
 * 
 * Revision 1.1.6.9  1996/04/11  14:14:14  Hans_Graves
 * 	Fix NT warnings
 * 	[1996/04/11  14:09:53  Hans_Graves]
 * 
 * Revision 1.1.6.8  1996/04/10  21:48:09  Hans_Graves
 * 	Added SvGet/SetBoolean() functions.
 * 	[1996/04/10  21:28:13  Hans_Graves]
 * 
 * Revision 1.1.6.7  1996/04/09  20:50:44  Karen_Dintino
 * 	Adding WIN32 support
 * 	[1996/04/09  20:47:26  Karen_Dintino]
 * 
 * Revision 1.1.6.6  1996/04/09  16:05:00  Hans_Graves
 * 	Add some abs() around height params. SvRegisterCallback() cleanup
 * 	[1996/04/09  15:39:31  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/04/04  23:35:27  Hans_Graves
 * 	Removed BI_YU16SEP support from MPEG decomp.
 * 	[1996/04/04  23:12:02  Hans_Graves]
 * 
 * 	Fixed up Multibuf size (MPEG) related stuff
 * 	[1996/04/04  23:08:55  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/04/01  15:17:47  Bjorn_Engberg
 * 	Got rid of a compiler warning.
 * 	[1996/04/01  15:02:35  Bjorn_Engberg]
 * 
 * Revision 1.1.6.3  1996/03/29  22:22:36  Hans_Graves
 * 	-Added JPEG_SUPPORT ifdefs.
 * 	-Changed JPEG related structures to fit naming conventions.
 * 	[1996/03/29  21:59:08  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/03/16  20:13:51  Karen_Dintino
 * 	Adding NT port changes for H.261
 * 	[1996/03/16  19:48:31  Karen_Dintino]
 * 
 * Revision 1.1.4.12  1996/02/26  18:42:32  Karen_Dintino
 * 	fix PTT 01106 server crash in ICCompress
 * 	[1996/02/26  18:41:33  Karen_Dintino]
 * 
 * Revision 1.1.4.11  1996/02/22  17:35:19  Bjorn_Engberg
 * 	Added support for JPEG Mono to BI_BITFIELDS 16 decompression on NT.
 * 	[1996/02/22  17:34:53  Bjorn_Engberg]
 * 
 * Revision 1.1.4.10  1996/02/08  13:48:44  Bjorn_Engberg
 * 	Get rid of int to float compiler warning.
 * 	[1996/02/08  13:48:20  Bjorn_Engberg]
 * 
 * Revision 1.1.4.9  1996/02/07  23:24:08  Hans_Graves
 * 	MPEG Key frame stats initialization
 * 	[1996/02/07  23:14:41  Hans_Graves]
 * 
 * Revision 1.1.4.8  1996/02/06  22:54:17  Hans_Graves
 * 	Added SvGet/SetParam functions
 * 	[1996/02/06  22:51:19  Hans_Graves]
 * 
 * Revision 1.1.4.7  1996/01/08  20:19:33  Bjorn_Engberg
 * 	Got rid of more compiler warnings.
 * 	[1996/01/08  20:19:13  Bjorn_Engberg]
 * 
 * Revision 1.1.4.6  1996/01/08  16:42:47  Hans_Graves
 * 	Added MPEG II decoding support
 * 	[1996/01/08  15:41:37  Hans_Graves]
 * 
 * Revision 1.1.4.5  1996/01/02  18:32:14  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added Casts, Removed unused variables.
 * 	[1996/01/02  17:26:21  Bjorn_Engberg]
 * 
 * Revision 1.1.4.4  1995/12/28  18:40:06  Bjorn_Engberg
 * 	IsSupported() sometimes returned garbage and thus a false match.
 * 	SvDecompressQuery() and SvCompressQuery() were using the
 * 	wrong lookup tables.
 * 	[1995/12/28  18:39:30  Bjorn_Engberg]
 * 
 * Revision 1.1.4.3  1995/12/08  20:01:30  Hans_Graves
 * 	Added SvSetRate() and SvSetFrameRate() to H.261 compression open
 * 	[1995/12/08  19:58:32  Hans_Graves]
 * 
 * Revision 1.1.4.2  1995/12/07  19:32:17  Hans_Graves
 * 	Added MPEG I & II Encoding support
 * 	[1995/12/07  18:43:45  Hans_Graves]
 * 
 * Revision 1.1.2.46  1995/11/30  20:17:06  Hans_Graves
 * 	Added BI_DECGRAYDIB handling for JPEG decompression, used with Mono JPEG
 * 	[1995/11/30  20:12:24  Hans_Graves]
 * 
 * Revision 1.1.2.45  1995/11/29  17:53:26  Hans_Graves
 * 	Added JPEG_DIB 8-bit to BI_DECGRAYDIB as supported format
 * 	[1995/11/29  17:53:00  Hans_Graves]
 * 
 * Revision 1.1.2.44  1995/11/28  22:47:33  Hans_Graves
 * 	Added BI_BITFIELDS as supported decompression format for H261 and MPEG
 * 	[1995/11/28  22:39:25  Hans_Graves]
 * 
 * Revision 1.1.2.43  1995/11/17  21:31:28  Hans_Graves
 * 	Added checks on ImageSize in SvDecompress()
 * 	[1995/11/17  21:27:19  Hans_Graves]
 * 
 * 	Query cleanup - Added lookup tables for supportted formats
 * 	[1995/11/17  20:53:54  Hans_Graves]
 * 
 * Revision 1.1.2.42  1995/11/03  16:36:25  Paul_Gauthier
 * 	Reject requests to scale MPEG input during decompression
 * 	[1995/11/03  16:34:01  Paul_Gauthier]
 * 
 * Revision 1.1.2.41  1995/10/25  18:19:22  Bjorn_Engberg
 * 	What was allocated with ScPaMalloc() must be freed with ScPaFree().
 * 	[1995/10/25  18:02:04  Bjorn_Engberg]
 * 
 * Revision 1.1.2.40  1995/10/25  17:38:04  Hans_Graves
 * 	Removed some memory freeing calls on image memory in SvCloseCodec for H261 decoding.  The app allocates the image buffer.
 * 	[1995/10/25  17:37:35  Hans_Graves]
 * 
 * Revision 1.1.2.39  1995/10/13  16:57:19  Bjorn_Engberg
 * 	Added a cast to get rid of a compiler warning.
 * 	[1995/10/13  16:56:29  Bjorn_Engberg]
 * 
 * Revision 1.1.2.38  1995/10/06  20:51:47  Farokh_Morshed
 * 	Enhance to handle BI_BITFIELDS for input to compression
 * 	[1995/10/06  20:49:10  Farokh_Morshed]
 * 
 * Revision 1.1.2.37  1995/10/02  19:31:03  Bjorn_Engberg
 * 	Clarified what formats are supported and not.
 * 	[1995/10/02  18:51:49  Bjorn_Engberg]
 * 
 * Revision 1.1.2.36  1995/09/28  20:40:09  Farokh_Morshed
 * 	Handle negative Height
 * 	[1995/09/28  20:39:45  Farokh_Morshed]
 * 
 * Revision 1.1.2.35  1995/09/26  17:49:47  Paul_Gauthier
 * 	Fix H.261 output conversion to interleaved YUV
 * 	[1995/09/26  17:49:20  Paul_Gauthier]
 * 
 * Revision 1.1.2.34  1995/09/26  15:58:44  Paul_Gauthier
 * 	Fix mono JPEG to interlaced 422 YUV conversion
 * 	[1995/09/26  15:58:16  Paul_Gauthier]
 * 
 * Revision 1.1.2.33  1995/09/25  21:18:14  Paul_Gauthier
 * 	Added interleaved YUV output to decompression
 * 	[1995/09/25  21:17:42  Paul_Gauthier]
 * 
 * Revision 1.1.2.32  1995/09/22  12:58:50  Bjorn_Engberg
 * 	More NT porting work; Added MPEG_SUPPORT and H261_SUPPORT.
 * 	[1995/09/22  12:26:14  Bjorn_Engberg]
 * 
 * Revision 1.1.2.31  1995/09/20  19:35:02  Hans_Graves
 * 	Cleaned-up debugging statements
 * 	[1995/09/20  19:33:07  Hans_Graves]
 * 
 * Revision 1.1.2.30  1995/09/20  18:22:53  Karen_Dintino
 * 	Free temp buffer after convert
 * 	[1995/09/20  18:22:37  Karen_Dintino]
 * 
 * Revision 1.1.2.29  1995/09/20  17:39:22  Karen_Dintino
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.27 **}
 * 		{** Merge revision:	1.1.2.28 **}
 * 	{** End **}
 * 	Add RGB support to JPEG
 * 	[1995/09/20  17:37:41  Karen_Dintino]
 * 
 * Revision 1.1.2.28  1995/09/20  15:00:03  Bjorn_Engberg
 * 	Port to NT
 * 	[1995/09/20  14:43:15  Bjorn_Engberg]
 * 
 * Revision 1.1.2.27  1995/09/13  19:42:44  Paul_Gauthier
 * 	Added TGA2 support (direct 422 interleaved output from JPEG codec
 * 	[1995/09/13  19:15:47  Paul_Gauthier]
 * 
 * Revision 1.1.2.26  1995/09/11  18:53:45  Farokh_Morshed
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.24 **}
 * 		{** Merge revision:	1.1.2.25 **}
 * 	{** End **}
 * 	Support BI_BITFIELDS format
 * 	[1995/09/11  18:52:08  Farokh_Morshed]
 * 
 * Revision 1.1.2.25  1995/09/05  14:05:01  Paul_Gauthier
 * 	Add ICMODE_OLDQ flag on ICOpen for softjpeg to use old quant tables
 * 	[1995/08/31  20:58:06  Paul_Gauthier]
 * 
 * Revision 1.1.2.24  1995/08/16  19:56:46  Hans_Graves
 * 	Fixed RELEASE_BUFFER callbacks for Images
 * 	[1995/08/16  19:54:40  Hans_Graves]
 * 
 * Revision 1.1.2.23  1995/08/15  19:14:18  Karen_Dintino
 * 	pass H261 struct to inithuff & freehuff
 * 	[1995/08/15  19:10:58  Karen_Dintino]
 * 
 * Revision 1.1.2.22  1995/08/14  19:40:36  Hans_Graves
 * 	Add CB_CODEC_DONE callback. Fixed Memory allocation and freeing under H261.
 * 	[1995/08/14  18:45:22  Hans_Graves]
 * 
 * Revision 1.1.2.21  1995/08/04  17:22:49  Hans_Graves
 * 	Make END_SEQ callback happen after any H261 decompress error.
 * 	[1995/08/04  17:20:55  Hans_Graves]
 * 
 * Revision 1.1.2.20  1995/08/04  16:32:46  Karen_Dintino
 * 	Free Huffman codes on end of Encode and Decode
 * 	[1995/08/04  16:25:59  Karen_Dintino]
 * 
 * Revision 1.1.2.19  1995/07/31  21:11:14  Karen_Dintino
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.17 **}
 * 		{** Merge revision:	1.1.2.18 **}
 * 	{** End **}
 * 	Add 411YUVSEP Support
 * 	[1995/07/31  20:41:28  Karen_Dintino]
 * 
 * Revision 1.1.2.18  1995/07/31  20:19:58  Hans_Graves
 * 	Set Format parameter in Frame callbacks
 * 	[1995/07/31  20:16:06  Hans_Graves]
 * 
 * Revision 1.1.2.17  1995/07/28  20:58:40  Hans_Graves
 * 	Added Queue debugging messages.
 * 	[1995/07/28  20:49:15  Hans_Graves]
 * 
 * Revision 1.1.2.16  1995/07/28  17:36:10  Hans_Graves
 * 	Fixed up H261 Compression and Decompression.
 * 	[1995/07/28  17:26:17  Hans_Graves]
 * 
 * Revision 1.1.2.15  1995/07/27  18:28:55  Hans_Graves
 * 	Fixed AddBuffer() so it works with H261.
 * 	[1995/07/27  18:24:37  Hans_Graves]
 * 
 * Revision 1.1.2.14  1995/07/26  17:49:04  Hans_Graves
 * 	Fixed SvCompressBegin() JPEG initialization.  Added ImageQ support.
 * 	[1995/07/26  17:41:24  Hans_Graves]
 * 
 * Revision 1.1.2.13  1995/07/25  22:00:33  Hans_Graves
 * 	     Fixed H261 image size logic in SvCompressQuery().
 * 	     [1995/07/25  21:59:08  Hans_Graves]
 * 
 * Revision 1.1.2.12  1995/07/21  17:41:20  Hans_Graves
 * 	Renamed Callback related stuff.
 * 	[1995/07/21  17:26:11  Hans_Graves]
 * 
 * Revision 1.1.2.11  1995/07/18  17:26:56  Hans_Graves
 * 	Fixed QCIF width parameter checking.
 * 	[1995/07/18  17:24:55  Hans_Graves]
 * 
 * Revision 1.1.2.10  1995/07/17  22:01:45  Hans_Graves
 * 	Removed defines for CIF_WIDTH, CIF_HEIGHT, etc.
 * 	[1995/07/17  21:48:51  Hans_Graves]
 * 
 * Revision 1.1.2.9  1995/07/17  16:12:37  Hans_Graves
 * 	H261 Cleanup.
 * 	[1995/07/17  15:50:51  Hans_Graves]
 * 
 * Revision 1.1.2.8  1995/07/12  19:48:30  Hans_Graves
 * 	Fixed up some H261 Queue/Callback bugs.
 * 	[1995/07/12  19:31:51  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/07/11  22:12:00  Karen_Dintino
 * 	Add SvCompressQuery, SvDecompressQuery support
 * 	[1995/07/11  21:57:21  Karen_Dintino]
 * 
 * Revision 1.1.2.6  1995/07/01  18:43:49  Karen_Dintino
 * 	Add support for H.261 Decompress
 * 	[1995/07/01  18:26:18  Karen_Dintino]
 * 
 * Revision 1.1.2.5  1995/06/19  20:31:51  Karen_Dintino
 * 	Adding support for H.261 Codec
 * 	[1995/06/19  19:25:27  Karen_Dintino]
 * 
 * Revision 1.1.2.4  1995/06/09  18:33:34  Hans_Graves
 * 	Added SvGetInputBitstream(). Changed SvDecompressBegin() to handle NULL Image formats.
 * 	[1995/06/09  16:35:29  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/05  21:07:20  Hans_Graves
 * 	Fixed logic in SvRegisterCallback().
 * 	[1995/06/05  20:04:30  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:12:42  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  17:18:53  Hans_Graves]
 * 
 * Revision 1.1.2.10  1995/02/02  19:26:01  Paul_Gauthier
 * 	Fix to blank bottom strip & server crash for softjpeg compress
 * 	[1995/02/02  19:12:58  Paul_Gauthier]
 * 
 * Revision 1.1.2.9  1995/01/20  21:45:57  Jim_Ludwig
 * 	Add support for 16 bit YUV
 * 	[1995/01/20  21:28:49  Jim_Ludwig]
 * 
 * Revision 1.1.2.8  1994/12/12  15:38:54  Paul_Gauthier
 * 	Merge changes from other SLIB versions
 * 	[1994/12/12  15:34:21  Paul_Gauthier]
 * 
 * Revision 1.1.2.7  1994/11/18  18:48:36  Paul_Gauthier
 * 	Cleanup & bug fixes
 * 	[1994/11/18  18:44:02  Paul_Gauthier]
 * 
 * Revision 1.1.2.6  1994/10/28  19:56:30  Paul_Gauthier
 * 	Additional Clean Up
 * 	[1994/10/28  19:54:35  Paul_Gauthier]
 * 
 * Revision 1.1.2.5  1994/10/17  19:03:28  Paul_Gauthier
 * 	Fixed reversed Quality scale
 * 	[1994/10/17  19:02:50  Paul_Gauthier]
 * 
 * Revision 1.1.2.4  1994/10/13  20:34:27  Paul_Gauthier
 * 	MPEG cleanup
 * 	[1994/10/13  20:23:23  Paul_Gauthier]
 * 
 * Revision 1.1.2.3  1994/10/10  21:45:50  Tom_Morris
 * 	Rename Status to not conflict with X11
 * 	[1994/10/10  21:44:16  Tom_Morris]
 * 
 * Revision 1.1.2.2  1994/10/07  14:39:25  Paul_Gauthier
 * 	SLIB v3.0 incl. MPEG Decode
 * 	[1994/10/07  13:53:40  Paul_Gauthier]
 * 
 * 	******************************************************************
 * 	Changes from original brance merged into this file 11/30/94 PSG
 * 	******************************************************************
 * 	Revision 1.1.2.10  1994/08/11  21:27:24  Leela_Obilichetti
 * 	Added in width and height checks into SvDecompressQuery and SvCompressQuery.
 * 	[1994/08/11  21:03:38  Leela_Obilichetti]
 * 
 * Revision 1.1.2.9  1994/08/09  18:52:40  Ken_Chiquoine
 * 	set mode type in decode as well as encode
 * 	[1994/08/09  18:52:17  Ken_Chiquoine]
 * 
 * Revision 1.1.2.8  1994/08/04  22:06:33  Leela_Obilichetti
 * 	oops, removed fprintf.
 * 	[1994/08/04  21:54:11  Leela_Obilichetti]
 * 
 * Revision 1.1.2.7  1994/08/04  21:34:04  Leela_Obilichetti
 * 	v1 drop.
 * 	[1994/08/04  21:05:01  Leela_Obilichetti]
 * 
 * Revision 1.1.2.6  1994/07/15  23:31:43  Leela_Obilichetti
 * 	added new stuff for compression - v4 of SLIB.
 * 	[1994/07/15  23:29:17  Leela_Obilichetti]
 * 
 * Revision 1.1.2.5  1994/06/08  16:44:28  Leela_Obilichetti
 * 	fixes for YUV_to_RGB for OSF/1.  Haven't tested on Microsoft.
 * 	[1994/06/08  16:42:46  Leela_Obilichetti]
 * 
 * Revision 1.1.2.4  1994/06/03  21:11:14  Leela_Obilichetti
 * 	commment out the code to let in DECYUVDIB
 * 	free memory that is allocated for YUV
 * 	add in code to convert from DECSEPYUV to DECYUV -
 * 		shouldn't get there since se don't allow YUV anymore
 * 	[1994/06/03  21:03:42  Leela_Obilichetti]
 * 
 * Revision 1.1.2.3  1994/05/11  21:02:17  Leela_Obilichetti
 * 	bug fix for NT
 * 	[1994/05/11  20:56:16  Leela_Obilichetti]
 * 
 * Revision 1.1.2.2  1994/05/09  22:06:07  Leela_Obilichetti
 * 	V3 drop
 * 	[1994/05/09  21:51:30  Leela_Obilichetti]
 * 
 * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0 
** 
** FILE NAME:   
** MODULE NAME: 
**
** MODULE DESCRIPTION: 
** 
** DESIGN OVERVIEW: 
** 
**--
*/
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1994                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*-------------------------------------------------------------------------
 * Modification History: sv_api.c
 *
 *      08-Sep-94  PSG   Added MPEG decode support
 *	29-Jul-94  VB    Added restrictions for compression
 *      21-Jul-94  VB	 Rewrote/cleaned up sections of JPEG decompression
 *      13-Jul-94  PSG   Added support for encode/decode of grayscale only
 *      07-Jul-94  PSG   Converted to single Info structure (cmp/dcmp)
 *	14-Jun-94  VB	 Added JPEG compression support
 *      08-Jun-94  PSG   Added support for BI_DECXIMAGEDIB (B,G,R,0)
 *      06-Jun-94  PSG   Bring code up to SLIB v0.04 spec
 *	15-Apr-94  VB	 Added support for 24-bit,16-bit and 15-bit RGB output 
 *      24-Feb-94  PSG   Bring code up to SLIB v0.02 spec
 *      20-Jan-94  PSG   added a number of new SLIB routines
 *	12-Jan-94  VB    Created (from SLIB spec.) 
 *	
 *   Author(s):
 *	 VB - Victor Bahl
 *	PSG - Paul Gauthier
 --------------------------------------------------------------------------*/


/*
#define _SLIBDEBUG_
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "SV.h"
#include "sv_intrn.h"
#ifdef JPEG_SUPPORT
/*
 *  More JPEG code needs to be moved to sv_jpeg_init file
 */
#include "sv_jpeg_tables.h"
#endif /* JPEG_SUPPORT */
#include "sv_proto.h"
#include "SC.h"
#include "SC_conv.h"
#include "SC_err.h"

#ifdef WIN32
#include <mmsystem.h>
#endif

#ifdef _SLIBDEBUG_
#define _DEBUG_   1  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    0  /* warnings about strange behavior */
#endif

static void sv_copy_bmh (
    BITMAPINFOHEADER *ImgFrom, 
    BITMAPINFOHEADER *ImgTo);

typedef struct SupportList_s {
  int   InFormat;   /* Input format */
  int   InBits;     /* Input number of bits */
  int   OutFormat;  /* Output format */
  int   OutBits;    /* Output number of bits */
} SupportList_t;

/*
** Input & Output Formats supported by SLIB Compression
*/
static SupportList_t _SvCompressionSupport[] = {
  BI_DECYUVDIB,        16, JPEG_DIB,             8, /* YUV 4:2:2 Packed */
  BI_DECYUVDIB,        16, JPEG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_DECYUVDIB,        16, MJPG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_YUY2,             16, JPEG_DIB,             8, /* YUV 4:2:2 Packed */
  BI_YUY2,             16, JPEG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_YUY2,             16, MJPG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_S422,             16, JPEG_DIB,             8, /* YUV 4:2:2 Packed */
  BI_S422,             16, JPEG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_S422,             16, MJPG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_BITFIELDS,        32, JPEG_DIB,             8, /* BITFIELDS */
  BI_BITFIELDS,        32, JPEG_DIB,            24, /* BITFIELDS */
  BI_BITFIELDS,        32, MJPG_DIB,            24, /* BITFIELDS */
  BI_DECSEPRGBDIB,     32, JPEG_DIB,             8, /* RGB 32 Planar */
  BI_DECSEPRGBDIB,     32, JPEG_DIB,            24, /* RGB 32 Planar */
  BI_DECSEPRGBDIB,     32, MJPG_DIB,            24, /* RGB 32 Planar */
#ifdef WIN32
  BI_RGB,              24, JPEG_DIB,             8, /* RGB 24 */
  BI_RGB,              24, JPEG_DIB,            24, /* RGB 24 */
  BI_RGB,              24, MJPG_DIB,            24, /* RGB 24 */
  BI_RGB,              32, JPEG_DIB,             8, /* RGB 32 */
  BI_RGB,              32, JPEG_DIB,            24, /* RGB 32 */
  BI_RGB,              32, MJPG_DIB,            24, /* RGB 32 */
#endif /* WIN32 */
#ifndef WIN32
  BI_DECGRAYDIB,        8, JPEG_DIB,             8, /* Gray 8 */
  BI_DECXIMAGEDIB,     24, JPEG_DIB,             8, /* XIMAGE 24 */
  BI_DECXIMAGEDIB,     24, JPEG_DIB,            24, /* XIMAGE 24 */
  BI_DECXIMAGEDIB,     24, MJPG_DIB,            24, /* XIMAGE 24 */
#endif /* !WIN32 */
#ifdef H261_SUPPORT
  BI_DECYUVDIB,        16, BI_DECH261DIB,       24, /* YUV 4:2:2 Packed */
  BI_YU12SEP,          24, BI_DECH261DIB,       24, /* YUV 4:1:1 Planar */
  BI_DECSEPYUV411DIB,  24, BI_DECH261DIB,       24, /* YUV 4:1:1 Planar */
  BI_YU16SEP,          24, BI_DECH261DIB,       24, /* YUV 4:2:2 Planar */
  BI_DECSEPYUVDIB,     24, BI_DECH261DIB,       24, /* YUV 4:2:2 Planar */
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
  BI_DECYUVDIB,        16, BI_DECH263DIB,       24, /* YUV 4:2:2 Packed */
  BI_YU12SEP,          24, BI_DECH263DIB,       24, /* YUV 4:1:1 Planar */
  BI_DECSEPYUV411DIB,  24, BI_DECH263DIB,       24, /* YUV 4:1:1 Planar */
  BI_YU16SEP,          24, BI_DECH263DIB,       24, /* YUV 4:2:2 Planar */
  BI_DECSEPYUVDIB,     24, BI_DECH263DIB,       24, /* YUV 4:2:2 Planar */
#endif /* H263_SUPPORT */
#ifdef MPEG_SUPPORT
  BI_DECYUVDIB,        16, BI_DECMPEGDIB,       24, /* YUV 4:2:2 Packed */
  BI_YU12SEP,          24, BI_DECMPEGDIB,       24, /* YUV 4:1:1 Planar */
  BI_DECSEPYUV411DIB,  24, BI_DECMPEGDIB,       24, /* YUV 4:1:1 Planar */
  BI_YU16SEP,          24, BI_DECMPEGDIB,       24, /* YUV 4:2:2 Planar */
  BI_DECSEPYUVDIB,     24, BI_DECMPEGDIB,       24, /* YUV 4:2:2 Planar */
  BI_YVU9SEP,          24, BI_DECMPEGDIB,       24, /* YUV 16:1:1 Planar */
  BI_RGB,              24, BI_DECMPEGDIB,       24, /* RGB 24 */
#endif /* MPEG_SUPPORT */
#ifdef HUFF_SUPPORT
  BI_DECYUVDIB,        16, BI_DECHUFFDIB,       24, /* YUV 4:2:2 Packed */
  BI_YU12SEP,          24, BI_DECHUFFDIB,       24, /* YUV 4:1:1 Planar */
  BI_DECSEPYUV411DIB,  24, BI_DECHUFFDIB,       24, /* YUV 4:1:1 Planar */
  BI_YU16SEP,          24, BI_DECHUFFDIB,       24, /* YUV 4:2:2 Planar */
  BI_DECSEPYUVDIB,     24, BI_DECHUFFDIB,       24, /* YUV 4:2:2 Planar */
#endif /* HUFF_SUPPORT */
  0, 0, 0, 0
};

/*
** Input & Output Formats supported by SLIB Decompression
*/
static SupportList_t _SvDecompressionSupport[] = {
#ifdef JPEG_SUPPORT
  JPEG_DIB,             8, BI_DECSEPYUVDIB,     24, /* YUV 4:2:2 Planar */
  JPEG_DIB,            24, BI_DECSEPYUVDIB,     24, /* YUV 4:2:2 Planar */
  MJPG_DIB,            24, BI_DECSEPYUVDIB,     24, /* YUV 4:2:2 Planar */
  JPEG_DIB,             8, BI_YU16SEP,          24, /* YUV 4:2:2 Planar */
  JPEG_DIB,            24, BI_YU16SEP,          24, /* YUV 4:2:2 Planar */
  MJPG_DIB,            24, BI_YU16SEP,          24, /* YUV 4:2:2 Planar */
  JPEG_DIB,             8, BI_DECYUVDIB,    16, /* YUV 4:2:2 Packed */
  JPEG_DIB,            24, BI_DECYUVDIB,    16, /* YUV 4:2:2 Packed */
  MJPG_DIB,            24, BI_DECYUVDIB,    16, /* YUV 4:2:2 Packed */
  JPEG_DIB,             8, BI_YUY2,             16, /* YUV 4:2:2 Packed */
  JPEG_DIB,            24, BI_YUY2,             16, /* YUV 4:2:2 Packed */
  MJPG_DIB,            24, BI_YUY2,             16, /* YUV 4:2:2 Packed */
  JPEG_DIB,             8, BI_BITFIELDS,        32, /* BITFIELDS */
  JPEG_DIB,            24, BI_BITFIELDS,        32, /* BITFIELDS */
  MJPG_DIB,            24, BI_BITFIELDS,        32, /* BITFIELDS */
  JPEG_DIB,             8, BI_DECGRAYDIB,        8, /* Gray 8 */
#endif /* JPEG_SUPPORT */

#ifdef WIN32
  JPEG_DIB,             8, BI_RGB,              16, /* RGB 16 */
  JPEG_DIB,            24, BI_RGB,              16, /* RGB 16 */
  MJPG_DIB,            24, BI_RGB,              16, /* RGB 16 */
  JPEG_DIB,             8, BI_RGB,              24, /* RGB 24 */
  JPEG_DIB,            24, BI_RGB,              24, /* RGB 24 */
  MJPG_DIB,            24, BI_RGB,              24, /* RGB 24 */
  JPEG_DIB,             8, BI_RGB,              32, /* RGB 32 */
  JPEG_DIB,            24, BI_RGB,              32, /* RGB 32 */
  MJPG_DIB,            24, BI_RGB,              32, /* RGB 32 */
  JPEG_DIB,             8, BI_BITFIELDS,        16, /* BITFIELDS */
#ifdef H261_SUPPORT
  BI_DECH261DIB,       24, BI_RGB,              16, /* RGB 16 */
  BI_DECH261DIB,       24, BI_RGB,              24, /* RGB 24 */
  BI_DECH261DIB,       24, BI_RGB,              32, /* RGB 32 */
#endif /* H261_SUPPORT */
#ifdef MPEG_SUPPORT
  BI_DECMPEGDIB,       24, BI_RGB,              16, /* RGB 16 */
  BI_DECMPEGDIB,       24, BI_RGB,              24, /* RGB 24 */
  BI_DECMPEGDIB,       24, BI_RGB,              32, /* RGB 32 */
#endif /* MPEG_SUPPORT */
#endif /* WIN32 */

#ifndef WIN32
  JPEG_DIB,             8, BI_DECXIMAGEDIB,     24, /* XIMAGE 24 */
  JPEG_DIB,            24, BI_DECXIMAGEDIB,     24, /* XIMAGE 24 */
  MJPG_DIB,            24, BI_DECXIMAGEDIB,     24, /* XIMAGE 24 */
#ifdef H261_SUPPORT
  BI_DECH261DIB,       24, BI_DECXIMAGEDIB,     24, /* XIMAGE 24 */
#endif /* H261_SUPPORT */
#ifdef MPEG_SUPPORT
  BI_DECMPEGDIB,       24, BI_DECXIMAGEDIB,     24, /* XIMAGE 24 */
#endif /* MPEG_SUPPORT */
#endif /* !WIN32 */

#ifdef H261_SUPPORT
  BI_DECH261DIB,       24, BI_YU12SEP,          24, /* YUV 4:1:1 Planar */
  BI_DECH261DIB,       24, BI_DECSEPYUV411DIB,  24, /* YUV 4:1:1 Planar */
  BI_DECH261DIB,       24, BI_DECYUVDIB,        16, /* YUV 4:2:2 Packed */
  BI_DECH261DIB,       24, BI_BITFIELDS,        32, /* BITFIELDS */
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
  BI_DECH263DIB,       24, BI_YU12SEP,          24, /* YUV 4:1:1 Planar */
  BI_DECH263DIB,       24, BI_DECSEPYUV411DIB,  24, /* YUV 4:1:1 Planar */
  BI_DECH263DIB,       24, BI_YUY2,             16, /* YUV 4:2:2 Packed */
  BI_DECH263DIB,       24, BI_DECYUVDIB,        16, /* YUV 4:2:2 Packed */
#endif /* H263_SUPPORT */
#ifdef MPEG_SUPPORT
  BI_DECMPEGDIB,       24, BI_YU12SEP,          24, /* YUV 4:1:1 Planar */
  BI_DECMPEGDIB,       24, BI_DECSEPYUV411DIB,  24, /* YUV 4:1:1 Planar */
  BI_DECMPEGDIB,       24, BI_DECYUVDIB,        16, /* YUV 4:2:2 Packed */
  BI_DECMPEGDIB,       24, BI_YUY2,             16, /* YUV 4:2:2 Packed */
  BI_DECMPEGDIB,       24, BI_YU16SEP,          24, /* YUV 4:2:2 Planar */
  BI_DECMPEGDIB,       24, BI_BITFIELDS,        32, /* BITFIELDS */
#endif /* MPEG_SUPPORT */
#ifdef HUFF_SUPPORT
  BI_DECHUFFDIB,       24, BI_YU12SEP,          24, /* YUV 4:1:1 Planar */
  BI_DECHUFFDIB,       24, BI_DECSEPYUV411DIB,  24, /* YUV 4:1:1 Planar */
  BI_DECHUFFDIB,       24, BI_DECYUVDIB,        16, /* YUV 4:2:2 Packed */
#endif /* HUFF_SUPPORT */
  0, 0, 0, 0
};

/*
** Name: IsSupported
** Desc: Lookup the a given input and output format to see if it
**       exists in a SupportList.
** Note: If OutFormat==-1 and OutBits==-1 then only input format
**          is checked for support.
**       If InFormat==-1 and InBits==-1 then only output format
**          is checked for support.
** Return: NULL       Formats not supported.
**         not NULL   A pointer to the list entry.
*/
static SupportList_t *IsSupported(SupportList_t *list,
                                  int InFormat, int InBits,
                                  int OutFormat, int OutBits)
{
  if (OutFormat==-1 && OutBits==-1) /* Looking up only the Input format */
  {
    while (list->InFormat || list->InBits)
      if (list->InFormat == InFormat && list->InBits==InBits)
        return(list);
      else
        list++;
    return(NULL);
  }
  if (InFormat==-1 && InBits==-1) /* Looking up only the Output format */
  {
    while (list->InFormat || list->InBits)
      if (list->OutFormat == OutFormat && list->OutBits==OutBits)
        return(list);
      else
        list++;
    return(NULL);
  }
  /* Looking up both Input and Output */
  while (list->InFormat || list->InBits)
    if (list->InFormat == InFormat && list->InBits==InBits &&
         list->OutFormat == OutFormat && list->OutBits==OutBits)
        return(list);
    else
      list++;
  return(NULL);
}

/*
** Name:     SvOpenCodec
** Purpose:  Open the specified codec. Return stat code.
**
** Args:     CodecType = i.e. SV_JPEG_ENCODE, SV_JPEG_DECODE, etc.
**           Svh = handle to software codec's Info structure.
*/
SvStatus_t SvOpenCodec (SvCodecType_e CodecType, SvHandle_t *Svh)
{
   SvCodecInfo_t *Info = NULL;
   _SlibDebug(_DEBUG_, printf("SvOpenCodec()\n") );

   /* check if CODEC is supported */
   switch (CodecType)
   {
#ifdef JPEG_SUPPORT
     case SV_JPEG_DECODE:
     case SV_JPEG_ENCODE:
           break;
#endif /* JPEG_SUPPORT */
#ifdef H261_SUPPORT
     case SV_H261_ENCODE:
     case SV_H261_DECODE:
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
     case SV_H263_ENCODE:
     case SV_H263_DECODE:
           break;
#endif /* H263_SUPPORT */
#ifdef MPEG_SUPPORT
     case SV_MPEG_ENCODE:
     case SV_MPEG_DECODE:
     case SV_MPEG2_ENCODE:
     case SV_MPEG2_DECODE:
           break;
#endif /* MPEG_SUPPORT */
#ifdef HUFF_SUPPORT
     case SV_HUFF_ENCODE:
     case SV_HUFF_DECODE:
           break;
#endif /* HUFF_SUPPORT */
     default:
           return(SvErrorCodecType);
   }
     
   if (!Svh)
     return (SvErrorBadPointer);

   /*
   ** Allocate memory for the Codec Info structure:
   */
   if ((Info = (SvCodecInfo_t *) ScAlloc(sizeof(SvCodecInfo_t))) == NULL) 
       return (SvErrorMemory);
   memset (Info, 0, sizeof(SvCodecInfo_t));
   Info->BSIn=NULL;
   Info->BSOut=NULL;
   Info->mode = CodecType;
   Info->started = FALSE;

   /*
   ** Allocate memory for Info structure and clear it
   */
   switch (CodecType)
   {
#ifdef JPEG_SUPPORT
       case SV_JPEG_DECODE:
            if ((Info->jdcmp = (SvJpegDecompressInfo_t *) 
	        ScAlloc(sizeof(SvJpegDecompressInfo_t))) == NULL) 
              return(SvErrorMemory);
            memset (Info->jdcmp, 0, sizeof(SvJpegDecompressInfo_t));
            break;

       case SV_JPEG_ENCODE:
            if ((Info->jcomp = (SvJpegCompressInfo_t *)
	                      ScAlloc(sizeof(SvJpegCompressInfo_t))) == NULL) 
              return (SvErrorMemory);
            memset (Info->jcomp, 0, sizeof(SvJpegCompressInfo_t));
            break;
#endif /* JPEG_SUPPORT */

#ifdef MPEG_SUPPORT
       case SV_MPEG_DECODE:
       case SV_MPEG2_DECODE:
            if ((Info->mdcmp = (SvMpegDecompressInfo_t *)
                ScAlloc(sizeof(SvMpegDecompressInfo_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->mdcmp, 0, sizeof(SvMpegDecompressInfo_t));
            Info->mdcmp->timecode0 = 0;
            Info->mdcmp->timecode_state = MPEG_TIMECODE_START;
            Info->mdcmp->timecodefps = 0.0F;
            Info->mdcmp->fps = 0.0F;
            Info->mdcmp->twostreams = 0;
            Info->mdcmp->verbose=FALSE;
            Info->mdcmp->quiet=TRUE;
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
       case SV_MPEG_ENCODE:
       case SV_MPEG2_ENCODE:
            if ((Info->mcomp = (SvMpegCompressInfo_t *)
                ScAlloc(sizeof(SvMpegCompressInfo_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->mcomp, 0, sizeof(SvMpegCompressInfo_t));
            Info->mcomp->quiet=1;
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUALITY, 100);
            SvSetParamBoolean((SvHandle_t)Info, SV_PARAM_FASTENCODE, FALSE);
            SvSetParamBoolean((SvHandle_t)Info, SV_PARAM_FASTDECODE, FALSE);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_MOTIONALG, 0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_ALGFLAGS,
                                               PARAM_ALGFLAG_HALFPEL);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_BITRATE, 1152000);
            SvSetParamFloat((SvHandle_t)Info, SV_PARAM_FPS, (float)25.0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_KEYSPACING, 12);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_SUBKEYSPACING, 4);
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
       case SV_H261_DECODE:
            if ((Info->h261 = (SvH261Info_t *)
                  ScAlloc(sizeof(SvH261Info_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->h261, 0, sizeof(SvH261Info_t));
            Info->h261->inited=FALSE;
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUALITY, 100);
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
       case SV_H261_ENCODE:
            if ((Info->h261 = (SvH261Info_t *)
                  ScAlloc(sizeof(SvH261Info_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->h261, 0, sizeof(SvH261Info_t));
            Info->h261->inited=FALSE;
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUALITY, 100);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_MOTIONALG, ME_BRUTE);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_MOTIONSEARCH, 5);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_MOTIONTHRESH, 600);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_ALGFLAGS, 0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_BITRATE, 352000);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUANTI, 10); /* for VBR */
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUANTP, 10);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_PACKETSIZE, 512);
            SvSetParamFloat((SvHandle_t)Info, SV_PARAM_FPS, (float)15.0);
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
       case SV_H263_DECODE:
            if ((Info->h263dcmp = (SvH263DecompressInfo_t *)
                  ScAlloc(sizeof(SvH263DecompressInfo_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->h263dcmp, 0, sizeof(SvH263DecompressInfo_t));
            Info->h263dcmp->inited=FALSE;
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
       case SV_H263_ENCODE:
            if ((Info->h263comp = (SvH263CompressInfo_t *)
                  ScAlloc(sizeof(SvH263CompressInfo_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->h263comp, 0, sizeof(SvH263CompressInfo_t));
            Info->h263comp->inited=FALSE;
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_MOTIONALG, 0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_BITRATE, 0);
            SvSetParamFloat((SvHandle_t)Info, SV_PARAM_FPS, (float)30.0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_ALGFLAGS, 0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_PACKETSIZE, 512);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUANTI, 10);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUANTP, 10);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUALITY, 0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_KEYSPACING, 120);
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
       case SV_HUFF_DECODE:
       case SV_HUFF_ENCODE:
            if ((Info->huff = (SvHuffInfo_t *)
                  ScAlloc(sizeof(SvHuffInfo_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->huff, 0, sizeof(SvHuffInfo_t));
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
#endif /* HUFF_SUPPORT */
   }
   *Svh = (SvHandle_t) Info;        /* Return handle */
   _SlibDebug(_DEBUG_, printf("SvOpenCodec() returns Svh=%p\n", *Svh) );

   return(NoErrors);
}




/*
** Name:     SvCloseCodec
** Purpose:  Closes the specified codec. Free the Info structure
**
** Args:     Svh = handle to software codec's Info structure.
**
** XXX - needs to change since now we have compression also, i.e.
**       Svh should be handle to the CodecInfo structure.  (VB)
*/
SvStatus_t SvCloseCodec (SvHandle_t Svh)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
   _SlibDebug(_DEBUG_, printf("SvCloseCodec()\n") );

   if (!Info)
     return(SvErrorCodecHandle);

   if (Info->BSIn)
     ScBSDestroy(Info->BSIn);
   if (Info->BSOut)
     ScBSDestroy(Info->BSOut);
   if (Info->BufQ);
     ScBufQueueDestroy(Info->BufQ);
   if (Info->ImageQ);
     ScBufQueueDestroy(Info->ImageQ);

   switch (Info->mode) /* free all associated codec memory */
   {
#ifdef JPEG_SUPPORT
      case SV_JPEG_DECODE:
           {
             int i;
             for (i = 0; i < 4; i++) {
               if (Info->jdcmp->DcHt[i])
                 ScPaFree(Info->jdcmp->DcHt[i]);
               if (Info->jdcmp->AcHt[i])
                 ScPaFree(Info->jdcmp->AcHt[i]);
             }
             if (Info->jdcmp->compinfo)
               ScFree(Info->jdcmp->compinfo);
             if (Info->jdcmp) {
               if (Info->jdcmp->TempImage)
	         ScPaFree(Info->jdcmp->TempImage);
               if (Info->jdcmp->_SvBlockPtr)
	         ScFree(Info->jdcmp->_SvBlockPtr);
               ScFree(Info->jdcmp);
             }
           }
           break;

      case SV_JPEG_ENCODE:
           {
             int i;
             for (i = 0 ; i < Info->jcomp->NumComponents ; i++) 
               if (Info->jcomp->Qt[i])
                 ScPaFree(Info->jcomp->Qt[i]);
             for (i = 0; i < 4; i++) {
               if (Info->jcomp->DcHt[i])
                 ScPaFree(Info->jcomp->DcHt[i]);
               if (Info->jcomp->AcHt[i])
                 ScPaFree(Info->jcomp->AcHt[i]);
             }
             if (Info->jcomp->compinfo)
               ScFree(Info->jcomp->compinfo);
             if (Info->jcomp) {
               if (Info->jcomp->BlkBuffer)
	         ScPaFree(Info->jcomp->BlkBuffer);
               if (Info->jcomp->BlkTable)
	         ScPaFree(Info->jcomp->BlkTable);
               ScFree(Info->jcomp);
             }
           }
           break;
#endif /* JPEG_SUPPORT */

#ifdef H261_SUPPORT
      case SV_H261_ENCODE:
           if (Info->h261)
           {
             svH261CompressFree(Info);
             ScFree(Info->h261);
           }
           break;
     case SV_H261_DECODE:
           if (Info->h261)
           {
             svH261DecompressFree(Info);
             ScFree(Info->h261);
           }
           break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
     case SV_H263_DECODE:
           if (Info->h263dcmp)
           {
             svH263FreeDecompressor(Info);
             ScFree(Info->h263dcmp);
           }
           break;
     case SV_H263_ENCODE:
           if (Info->h263comp)
           {
             svH263FreeCompressor(Info);
             ScFree(Info->h263comp);
           }
           break;
#endif /* H263_SUPPORT */

#ifdef MPEG_SUPPORT
      case SV_MPEG_DECODE:
      case SV_MPEG2_DECODE:
           if (Info->mdcmp) {
             sv_MpegFreeDecoder(Info);
             ScFree(Info->mdcmp);
           }
           break;
      case SV_MPEG_ENCODE:
      case SV_MPEG2_ENCODE:
           if (Info->mcomp) {
             ScFree(Info->mcomp);
           }
           break;
#endif /* MPEG_SUPPORT */

#ifdef HUFF_SUPPORT
      case SV_HUFF_DECODE:
      case SV_HUFF_ENCODE:
           if (Info->huff) {
             sv_HuffFreeDecoder(Info);
             ScFree(Info->huff);
           }
           break;
           break;
#endif /* HUFF_SUPPORT */
   }

   /*
   ** Free Info structure
   */
   ScFree(Info);
   
   return(NoErrors);
}




/*
** Name:     SvDecompressBegin
** Purpose:  Initialize the Decompression Codec. Call after SvOpenCodec &
**           before SvDecompress (SvDecompress will call SvDecompressBegin
**           on first call to codec after open if user doesn't call it)
**
** Args:     Svh = handle to software codec's Info structure.
**           ImgIn  = format of input (uncompressed) image
**           ImgOut = format of output (compressed) image
*/
SvStatus_t SvDecompressBegin (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                              BITMAPINFOHEADER *ImgOut)
{
   int stat;
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
   _SlibDebug(_DEBUG_, printf("SvDecompressBegin()\n") );

   if (!Info)
     return(SvErrorCodecHandle);
   if (Info->started)
     return(SvErrorNone);
   /* if no Image header provided, use previous headers */
   if (!ImgIn)
     ImgIn = &Info->InputFormat;
   if (!ImgOut)
     ImgOut = &Info->OutputFormat;
   stat=SvDecompressQuery (Svh, ImgIn, ImgOut);
   RETURN_ON_ERROR(stat);

   /*
   ** Save input & output formats for SvDecompress
   */
   sv_copy_bmh(ImgIn, &Info->InputFormat);
   sv_copy_bmh(ImgOut, &Info->OutputFormat);

   Info->Width = Info->InputFormat.biWidth;
   Info->Height = abs(Info->InputFormat.biHeight);
      
   switch (Info->mode)
   {
#ifdef JPEG_SUPPORT
       case SV_JPEG_DECODE:
            {
              SvJpegDecompressInfo_t *DInfo;
              /*
              ** Load the default Huffman tablse
              */
              stat = sv_LoadDefaultHTable (Info);
              RETURN_ON_ERROR (stat);

              stat = sv_InitJpegDecoder (Info);
              RETURN_ON_ERROR (stat);

              /*
              ** Video-specific information will be filled in during processing
              ** of first frame
              */
              DInfo = Info->jdcmp;
              DInfo->InfoFilled = 0;
              DInfo->ReInit     = 1;
              DInfo->DecompressStarted = TRUE;
              DInfo->TempImage = NULL; 
              break;
            }
#endif

#ifdef MPEG_SUPPORT
       case SV_MPEG_DECODE:
       case SV_MPEG2_DECODE:
            Info->mdcmp->DecompressStarted = TRUE;
            /* the default data source is the buffer queue */
            if (Info->BSIn)
              ScBSReset(Info->BSIn);
            else
              stat=SvSetDataSource (Svh, SV_USE_BUFFER_QUEUE, 0, NULL, 0);
            RETURN_ON_ERROR (stat);
            stat = sv_MpegInitDecoder(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
       case SV_H261_DECODE:
            stat = svH261Init(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
       case SV_H263_DECODE:
            stat = svH263InitDecompressor(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
       case SV_HUFF_DECODE:
            Info->huff->DecompressStarted = TRUE;
            /* the default data source is the buffer queue */
            if (Info->BSIn)
              ScBSReset(Info->BSIn);
            else
              stat=SvSetDataSource (Svh, SV_USE_BUFFER_QUEUE, 0, NULL, 0);
            RETURN_ON_ERROR (stat);
            stat = sv_HuffInitDecoder(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* HUFF_SUPPORT */
   }
   Info->started=TRUE;
   return (NoErrors);
}



/*
** Name:     SvGetDecompressSize
** Purpose:  Return minimum data buffer size to receive decompressed data
**           for current settings on codec
**
** Args:     Svh = handle to software codec's Info structure.
**           MinSize = Returns minimum buffer size required
*/
SvStatus_t SvGetDecompressSize (SvHandle_t Svh, int *MinSize)
{
   int pixels,lines;
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return(SvErrorCodecHandle);

   switch (Info->mode) /* check that decompressor was started */
   {
#ifdef JPEG_SUPPORT
     case SV_JPEG_DECODE:
           if (!Info->jdcmp->DecompressStarted) 
             return(SvErrorDcmpNotStarted);
           break;
#endif /* JPEG_SUPPORT */
#ifdef MPEG_SUPPORT
     case SV_MPEG_DECODE:
     case SV_MPEG2_DECODE:
           if (!Info->mdcmp->DecompressStarted) 
             return(SvErrorDcmpNotStarted);
           break;
#endif /* MPEG_SUPPORT */
     default:
           break;
   }

   if (!MinSize)
     return(SvErrorBadPointer);

   pixels = Info->OutputFormat.biWidth;
   lines  = Info->OutputFormat.biHeight;
   if (lines < 0) lines = -lines;
   _SlibDebug(_VERBOSE_, 
              printf("OutputFormat.biWidth=%d OutputFormat.biHeight=%d\n",
                      pixels, lines) );

   switch (Info->mode)
   {
#ifdef JPEG_SUPPORT
     case SV_JPEG_DECODE:
           /*
           ** On output, accept: 8, 16 or 24 bit uncompressed RGB
           ** or YUV formats, 32 bit uncompressed RGB
           */
           if (Info->OutputFormat.biBitCount == 8) 
             *MinSize = pixels * lines;
           else if (Info->OutputFormat.biBitCount == 24) {
             if (Info->OutputFormat.biCompression == BI_RGB)
	       *MinSize = 3 * pixels * lines;
             else if (Info->OutputFormat.biCompression == BI_DECSEPRGBDIB) 
	       *MinSize = 3 * pixels * lines;
             else if (IsYUV422Packed(Info->OutputFormat.biCompression)) 
	       *MinSize = 2 * pixels * lines;
             else if (Info->OutputFormat.biCompression == BI_DECXIMAGEDIB) 
	       *MinSize = 4 * pixels * lines;
             else if (IsYUV422Sep(Info->OutputFormat.biCompression)) 
	       *MinSize = 2 * pixels * lines;
             else if (IsYUV411Sep(Info->OutputFormat.biCompression)) 
	       *MinSize = 2 * pixels * lines;
             else
	     return(SvErrorUnrecognizedFormat);
           }
           else if (Info->OutputFormat.biBitCount == 16) {
             if (IsYUV422Packed(Info->OutputFormat.biCompression)) 
	       *MinSize = 2 * pixels * lines;
             else if (Info->OutputFormat.biCompression == BI_RGB)
	       *MinSize = 2 * pixels * lines;
           }
           else if (Info->OutputFormat.biBitCount == 32) {
             if (Info->OutputFormat.biCompression == BI_RGB ||
               Info->OutputFormat.biCompression == BI_BITFIELDS)
	       *MinSize = 4 * pixels * lines;
           }
           break;
#endif /* JPEG_SUPPORT */
#ifdef MPEG_SUPPORT
     case SV_MPEG_DECODE:
     case SV_MPEG2_DECODE:
           /*
           ** MPEG multibuffer size = 3 pictures*(1Y + 1/4 U + 1/4 V)*imagesize
           */
           if (IsYUV422Sep(SvGetParamInt(Svh, SV_PARAM_FINALFORMAT)) ||
               IsYUV422Packed(SvGetParamInt(Svh, SV_PARAM_FINALFORMAT)))
             *MinSize = 3 * pixels * lines * 2;  /* 4:2:2 */
           else
             *MinSize = 3 * (pixels * lines * 3)/2;  /* 4:1:1 */
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
     case SV_H261_DECODE:
           *MinSize = 3 * (pixels * lines * 3)/2;  /* 4:1:1 */
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
     case SV_H263_DECODE:
           *MinSize = 3 * (pixels * lines * 3)/2;  /* 4:1:1 */
           break;
#endif /* H263_SUPPORT */
     default:
           return(SvErrorUnrecognizedFormat);
   }
   return(NoErrors);
}



/*
** Name:     SvDecompressQuery
** Purpose:  Determine if Codec can decompress desired format
**
** Args:     Svh = handle to software codec's Info structure.
**           ImgIn  = Pointer to BITMAPINFOHEADER structure describing format
**           ImgOut = Pointer to BITMAPINFOHEADER structure describing format
*/
SvStatus_t SvDecompressQuery (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                              BITMAPINFOHEADER *ImgOut)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

  if (!Info)
    return(SvErrorCodecHandle);

  if (!ImgIn && !ImgOut)
    return(SvErrorBadPointer);

  if (!IsSupported(_SvDecompressionSupport,
                    ImgIn ? ImgIn->biCompression : -1, 
                    ImgIn ? ImgIn->biBitCount : -1,
                    ImgOut ? ImgOut->biCompression : -1, 
                    ImgOut ? ImgOut->biBitCount : -1))
    return(SvErrorUnrecognizedFormat);
	 
  if (ImgOut) /* Query output format */
  {
    /*
    ** XXX - check to see if the # of output lines/# of output
    **       pixels/line are a multiple of 8. If not can't decompress
    **	    Note: This is an artifical restriction since the JPEG
    **	          bitream will always be a multiple of 8x8, so we
    **		  should have no problems decoding, only on the
    **		  output will be have to add an extra copy operation
    **	    XXX - will address/remove this restriction in the 
    **		  later release  (VB)
    */ 
    if (ImgOut->biWidth  <= 0 || ImgOut->biHeight == 0)
      return(SvErrorBadImageSize);
    switch (Info->mode)
    {
#ifdef JPEG_SUPPORT
      case SV_JPEG_DECODE: /* 8x8 restriction */
            if ((ImgOut->biWidth%8) || (ImgOut->biHeight%8)) 
              return(SvErrorBadImageSize);
            break;
#endif /* JPEG_SUPPORT */
#ifdef MPEG_SUPPORT
      case SV_MPEG_DECODE:
      case SV_MPEG2_DECODE:
            /* MPEG 16x16 - because of Software Renderer YUV limitation */
            if ((ImgOut->biWidth%16) || (ImgOut->biHeight%16)) 
              return(SvErrorBadImageSize);
            /* Reject requests to scale during decompression - renderer's job */
            if (ImgIn && ImgOut &&
                (ImgIn->biWidth  != ImgOut->biWidth) ||
                (abs(ImgIn->biHeight) != abs(ImgOut->biHeight)))
              return (SvErrorBadImageSize);
            break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SV_H261_DECODE:
            /* H261 16x16 - because of Software Renderer YUV limitation */
            if ((ImgOut->biWidth%16) || (ImgOut->biHeight%16))
              return(SvErrorBadImageSize);
            if ((ImgOut->biWidth!=CIF_WIDTH && ImgOut->biWidth!=QCIF_WIDTH) ||
                (abs(ImgOut->biHeight)!=CIF_HEIGHT && abs(ImgOut->biHeight)!=QCIF_HEIGHT))
              return (SvErrorBadImageSize);
            /* Reject requests to scale during decompression - renderer's job */
            if (ImgIn && ImgOut &&
                (ImgIn->biWidth  != ImgOut->biWidth) ||
                (abs(ImgIn->biHeight) != abs(ImgOut->biHeight)))
              return (SvErrorBadImageSize);
            break;
#endif /* H261_SUPPORT */
      default:
            break;
    }

    if (ImgOut->biCompression == BI_BITFIELDS && 
         ValidateBI_BITFIELDS(ImgOut) == InvalidBI_BITFIELDS)
            return (SvErrorUnrecognizedFormat);
  }

  if (ImgIn) /* Query input format also */
  {
    if (ImgIn->biWidth  <= 0 || ImgIn->biHeight == 0)
      return(SvErrorBadImageSize);
  }
  return(NoErrors);
}

/*
** Name:     SvDecompress
** Purpose:  Decompress a frame CompData -> YUV or RGB
**
** Args:     Svh          = handle to software codec's Info structure.
**           Data         = For JPEG points to compressed data (INPUT)
**                          For MPEG & H261, points to MultiBuf
**           MaxDataSize  = Length of Data buffer
**           Image        = buffer for decompressed data (OUTPUT)
**           MaxImageSize = Size of output image buffer
**
*/
SvStatus_t SvDecompress(SvHandle_t Svh, u_char *Data, int MaxDataSize,
			 u_char *Image, int MaxImageSize)
{
  int stat=NoErrors, UsedQ=FALSE, ImageSize;
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  u_char *YData=NULL, *CbData=NULL, *CrData=NULL;
  int pixels, lines;
  SvCallbackInfo_t CB;
  u_char *ReturnImage=NULL;
  _SlibDebug(_VERBOSE_, printf("SvDecompress() In\n") );

  if (!Info)
    return(SvErrorCodecHandle);
  if (!Info->started)
    return(SvErrorDcmpNotStarted);
  if (!Data && !Info->BSIn)
    return(SvErrorBadPointer);

  /*
  ** If no image buffer is supplied, see if the Image Queue
  ** has any.  If not do a callback to get a buffer.
  */
  if (Image == NULL && Info->ImageQ)
  {
    if (ScBufQueueGetNum(Info->ImageQ))
    {
      ScBufQueueGetHead(Info->ImageQ, &Image, &MaxImageSize);
      ScBufQueueRemove(Info->ImageQ);
      UsedQ = TRUE;
      _SlibDebug(_VERBOSE_, printf("SvDecompress() Got Image %p from Q\n",
                            Image) );
    }
    else if (Info->CallbackFunction)
    {
      CB.Message = CB_END_BUFFERS;
      CB.Data  = NULL;
      CB.DataSize = 0;
      CB.DataUsed = 0;
      CB.DataType = CB_DATA_IMAGE;
      CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
      CB.Action  = CB_ACTION_CONTINUE;
      _SlibDebug(_VERBOSE_,
                 printf("SvDecompress() Calling callback for Image\n") );
      (*(Info->CallbackFunction))(Svh, &CB, NULL);
      if (CB.Action == CB_ACTION_END)
      {
        _SlibDebug(_DEBUG_, 
                   printf("SvDecompress() CB.Action = CB_ACTION_END\n") );
        return(SvErrorClientEnd);
      }
      else if (ScBufQueueGetNum(Info->ImageQ))
      {
        ScBufQueueGetHead(Info->ImageQ, &Image, &MaxImageSize);
        ScBufQueueRemove(Info->ImageQ);
        UsedQ = TRUE;
        _SlibDebug(_VERBOSE_,
                   printf("SvDecompress() Got Image %p from Q\n", Image) );
      }
      else
        return(SvErrorNoImageBuffer);
    }
  }

  if (!Image)
    return(SvErrorNoImageBuffer);
  ImageSize=MaxImageSize;
  pixels = Info->OutputFormat.biWidth;
  lines  = Info->OutputFormat.biHeight;
  if (lines<0) lines=-lines;

  /*
  ** Decompress an image
  */
  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
        {
          SvMpegDecompressInfo_t *MDInfo;
          _SlibDebug(_DEBUG_, printf("SvDecompress() SV_MPEG_DECODE\n") );

          if (!(MDInfo = Info->mdcmp))
            return(SvErrorBadPointer);

          if (!MDInfo->DecompressStarted)
            return(SvErrorDcmpNotStarted);

          if (MaxDataSize < MDInfo->finalbufsize)
            return(SvErrorSmallBuffer);

          if (!Data)
            return(SvErrorBadPointer);

          stat = sv_MpegDecompressFrame(Info, Data, &ReturnImage);
          RETURN_ON_ERROR(stat);
          /*
          ** Because the ReturnImage is a pointer into Data
          ** we need to copy it (do a format conversion if necessary).
          */
          switch (Info->OutputFormat.biCompression)
          {
            case BI_YU12SEP:
                 /* native format is 4:1:1 planar, just copy */
                 ImageSize=(3 * lines * pixels)/2;
                 if (ImageSize > MaxImageSize)
                   return(SvErrorSmallBuffer);
                 memcpy(Image, ReturnImage, ImageSize);
                 break;
            case BI_DECYUVDIB:
            case BI_YUY2:
            case BI_S422: /* 4:1:1 planar -> 4:2:2 interleaved */
                 ImageSize=(3 * lines * pixels)/2;
                 if (ImageSize > MaxImageSize)
                   return(SvErrorSmallBuffer);
                 ScSepYUVto422i(Image, Image+(lines*pixels), 
                                       Image+(lines*pixels*5)/4, 
	                               ReturnImage, pixels, lines);
                 break;
            default: /* 4:1:1 planar -> RGB */
                 if (Info->OutputFormat.biCompression==BI_DECXIMAGEDIB)
                   ImageSize=lines*pixels *
                             (Info->OutputFormat.biBitCount==24 ? 4 : 1);
                 else
                   ImageSize=lines*pixels * (Info->OutputFormat.biBitCount/8);
                 if (ImageSize > MaxImageSize)
                   return(SvErrorSmallBuffer);
                 YData  = ReturnImage;
                 CbData = YData + (pixels * lines);
                 CrData = CbData + (pixels * lines)/4;
                 ScYuv411ToRgb(&Info->OutputFormat, YData, CbData, CrData,
                                 Image, pixels, lines, pixels);
                 break;
          }
        }
        break;
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
    case SV_H261_DECODE:
        {
          SvH261Info_t *H261 = Info->h261;
          _SlibDebug(_DEBUG_, printf("SvDecompress() SV_H261_DECODE\n") );
          if (!H261)
            return(SvErrorBadPointer);
          if (!Data)
            return(SvErrorBadPointer);
          _SlibDebug(_DEBUG_, printf("sv_DecompressH261(Data=%p)\n",Data) );
          stat=svH261Decompress(Info, Data, &ReturnImage);
          if (stat==NoErrors)
          {
            /*
            ** Because the ReturnImage is a pointer into Data
            ** we need to copy it (do a format conversion if necessary).
            */
            switch (Info->OutputFormat.biCompression)
            {
              case BI_YU12SEP:
                   /* native format is 4:1:1 planar, just copy */
                   ImageSize=(3 * lines * pixels)/2;
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   memcpy(Image, ReturnImage, ImageSize);
                   break;
              case BI_DECYUVDIB:
              case BI_YUY2:
              case BI_S422:
                   /* 4:1:1 planar -> 4:2:2 interleaved */
                   ImageSize=(3 * lines * pixels)/2;
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   ScSepYUVto422i(Image, Image+(lines*pixels), 
                                         Image+(lines*pixels*5)/4,
	                                 ReturnImage, pixels, lines);
                   break;
              default:
                   if (Info->OutputFormat.biCompression==BI_DECXIMAGEDIB)
                     ImageSize=lines*pixels *
                               (Info->OutputFormat.biBitCount==24 ? 4 : 1);
                   else
                     ImageSize=lines*pixels * (Info->OutputFormat.biBitCount/8);
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   YData  = ReturnImage;
                   CbData = YData  + (pixels * lines * sizeof(u_char));
                   CrData = CbData + ((pixels * lines * sizeof(u_char))/4);
                   ScYuv411ToRgb(&Info->OutputFormat, YData, CbData, CrData,
                                 Image, pixels, lines, pixels);
                   break;
            }
          }
          else
          {
            ImageSize=0;
            if (Info->CallbackFunction)
            {
              CB.Message = CB_SEQ_END;
              CB.Data = NULL;
              CB.DataSize = 0;
              CB.DataType = CB_DATA_NONE;
              CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
              CB.Action  = CB_ACTION_CONTINUE;
              (*Info->CallbackFunction)(Svh, &CB, NULL);
              _SlibDebug(_DEBUG_, 
                   printf("H261 Callback: CB_SEQ_END Data = 0x%x Action = %d\n",
                                        CB.Data, CB.Action) );
              if (CB.Action == CB_ACTION_END)
                return (ScErrorClientEnd);
            }
          }
        }
        break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
        {
          SvH263DecompressInfo_t *H263Info = Info->h263dcmp;
          _SlibDebug(_DEBUG_, printf("SvDecompress() SV_H261_DECODE\n") );
          if (!H263Info)
            return(SvErrorBadPointer);
          _SlibDebug(_DEBUG_, printf("svH263Decompress(Data=%p)\n",Data) );
          stat=svH263Decompress(Info, &ReturnImage);
          if (stat==NoErrors)
          {
            /*
            ** Because the ReturnImage is a pointer into Data
            ** we need to copy it (do a format conversion if necessary).
            */
            switch (Info->OutputFormat.biCompression)
            {
              case BI_YU12SEP:
                   /* native format is 4:1:1 planar, just copy */
                   ImageSize=(3 * lines * pixels)/2;
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   memcpy(Image, ReturnImage, ImageSize);
                   break;
              case BI_DECYUVDIB:
              case BI_YUY2:
              case BI_S422:
                   /* 4:1:1 planar -> 4:2:2 interleaved */
                   ImageSize=(3 * lines * pixels)/2;
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   ScSepYUVto422i(Image, Image+(lines*pixels), 
                                         Image+(lines*pixels*5)/4,
	                                 ReturnImage, pixels, lines);
                   break;
              default:
                   if (Info->OutputFormat.biCompression==BI_DECXIMAGEDIB)
                     ImageSize=lines*pixels *
                               (Info->OutputFormat.biBitCount==24 ? 4 : 1);
                   else
                     ImageSize=lines*pixels * (Info->OutputFormat.biBitCount/8);
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   YData  = ReturnImage;
                   CbData = YData  + (pixels * lines * sizeof(u_char));
                   CrData = CbData + ((pixels * lines * sizeof(u_char))/4);
                   ScYuv411ToRgb(&Info->OutputFormat, YData, CbData, CrData,
                                 Image, pixels, lines, pixels);
                   break;
            }
          }
          else
          {
            ImageSize=0;
            if (Info->CallbackFunction)
            {
              CB.Message = CB_SEQ_END;
              CB.Data = NULL;
              CB.DataSize = 0;
              CB.DataType = CB_DATA_NONE;
              CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
              CB.Action  = CB_ACTION_CONTINUE;
              (*Info->CallbackFunction)(Svh, &CB, NULL);
              _SlibDebug(_DEBUG_, 
                   printf("H263 Callback: CB_SEQ_END Data = 0x%x Action = %d\n",
                                        CB.Data, CB.Action) );
              if (CB.Action == CB_ACTION_END)
                return (ScErrorClientEnd);
            }
          }
        }
        break;
#endif /* H263_SUPPORT */
#ifdef JPEG_SUPPORT
    case SV_JPEG_DECODE:
        {
        SvJpegDecompressInfo_t *DInfo;
        register int i;
        JPEGINFOHEADER *jpegbm;
        int maxMcu;
        EXBMINFOHEADER * exbi;
        _SlibDebug(_DEBUG_, printf("SvDecompress() SV_JPEG_DECODE\n") );

        if (!(DInfo = Info->jdcmp))
          return(SvErrorBadPointer);

        exbi = (EXBMINFOHEADER *)&Info->InputFormat;

        jpegbm = (JPEGINFOHEADER *)(
                (unsigned long)exbi + exbi->biExtDataOffset);
 	
        /*
        ** In case the application forgot to call SvDecompressBegin().
        */
        if (!DInfo->DecompressStarted)
          return(SvErrorDcmpNotStarted);
        /*
        ** If desired output is not separate YUV components, we have to 
        ** convert from Sep. YUV to desired format. Create intermediate image.
        */
        _SlibDebug(_DEBUG_, printf ("JPEGBitsPerSample %d \n",
                            jpegbm->JPEGBitsPerSample) );

        if (lines < 0) lines = -lines;
        _SlibDebug(_DEBUG_, 
           printf ("JPEG_RGB : %d - ", JPEG_RGB);
           if (jpegbm->JPEGColorSpaceID == JPEG_RGB) 
             printf ("Color Space is RGB \n");
           else
             printf ("Color Space is %d \n", jpegbm->JPEGColorSpaceID) );

        if (!IsYUV422Sep(Info->OutputFormat.biCompression) &&
            !IsYUV411Sep(Info->OutputFormat.biCompression) &&
            Info->OutputFormat.biCompression != BI_DECGRAYDIB)
        {
          /*
          ** should be done only once for each instance of the CODEC.
          **    - Note: this forces us to check the size parameters (pixels &
          **            lines)  for  each  image  to be decompressed. Should we
          **	    support sequences that do not have constant frame sizes?
          */
          if (!DInfo->TempImage) {
            DInfo->TempImage = (u_char *)ScPaMalloc (3 * pixels * lines);
	    if (DInfo->TempImage == NULL)
	      return(SvErrorMemory);
          }
          YData  = DInfo->TempImage;
          CbData = YData  + (pixels * lines * sizeof(u_char));
          CrData = CbData + (pixels * lines * sizeof(u_char));
        }
        else {
          /*
          ** For YUV Planar formats, no need to translate.
          ** Get pointers to individual components.
          */
          _SlibDebug(_DEBUG_, printf ("sv_GetYUVComponentPointers\n") );
          stat = sv_GetYUVComponentPointers(Info->OutputFormat.biCompression,
					pixels, lines, Image, MaxImageSize,
					&YData, &CbData, &CrData);
          RETURN_ON_ERROR (stat);
        }

        _SlibDebug(_DEBUG_, printf ("sv_ParseFrame\n") );
        stat = sv_ParseFrame (Data, MaxDataSize, Info);
        RETURN_ON_ERROR (stat);
      
       /*
       ** Fill Info structure with video-specific data on first frame
       */
       if (!DInfo->InfoFilled) {
         _SlibDebug(_DEBUG_, printf ("sv_InitJpegDecoder\n") );
         stat = sv_InitJpegDecoder (Info);
         RETURN_ON_ERROR (stat);
         DInfo->InfoFilled = 1;

         /*
         ** Error checking: 
         **      make the assumption that for MJPEG we need to check for 
         **      valid subsampling only once at the start of the seqence
         */
         _SlibDebug(_DEBUG_, printf ("sv_CheckChroma\n") );
         stat = sv_CheckChroma(Info);
         RETURN_ON_ERROR (stat);
       }

       /*
       ** Decompress everything into MCU's
       */
       if (!DInfo->ReInit) /* Reset the JPEG compressor */
	     sv_ReInitJpegDecoder (Info);
       maxMcu = DInfo->MCUsPerRow * DInfo->MCUrowsInScan;
       if (DInfo->ReInit) 
         DInfo->ReInit = 0; 

       DInfo->CurrBlockNumber = 0;
       /*
       ** Create the BlockPtr array for the output buffers
       */
       if ((YData  != DInfo->Old_YData)  ||
           (CbData != DInfo->Old_CbData) ||
           (CrData != DInfo->Old_CrData)) 
       {
         DInfo->Old_YData =YData;
         DInfo->Old_CbData=CbData;
         DInfo->Old_CrData=CrData;

         stat = sv_MakeDecoderBlkTable (Info);
         RETURN_ON_ERROR (stat);
       }

       CB.Message = CB_PROCESSING;
       for (i = 0; i < maxMcu; i++) {
#if 0
         if ((Info->CallbackFunction) && ((i % MCU_CALLBACK_COUNT) == 0)) {
	   (*Info->CallbackFunction)(Svh, &CB, &PictureInfo);
	   if (CB.Action == CB_ACTION_END)
	     return(SvErrorClientEnd);
         }
#endif
         _SlibDebug(_DEBUG_, printf ("sv_DecodeJpeg\n") );
         stat = sv_DecodeJpeg (Info);
         RETURN_ON_ERROR (stat);
       }
#if 0
       /*
       ** Check for multiple scans in the JPEG file
       **	  - we do not support multiple scans 
       */
       if (sv_ParseScanHeader (Info) != SvErrorEOI) 
	 _SlibDebug(_DEBUG_ || _WARN_ || _VERBOSE_, 
         printf(" *** Warning ***, Multiple Scans detected, unsupported\n") );
#endif
       if (DInfo->compinfo[0].Vsf==2) /* 4:1:1->4:2:2 */
       {
         if (IsYUV422Packed(Info->OutputFormat.biCompression))
           ScConvert411sTo422i_C(YData, CbData, CrData, Image,
                                 pixels, lines);
         else if IsYUV422Sep(Info->OutputFormat.biCompression)
           ScConvert411sTo422s_C(YData, CbData, CrData, Image,
                                 pixels, lines);
         else if IsYUV411Sep(Info->OutputFormat.biCompression)
         {
           if (YData!=Image)
             memcpy(Image, YData, pixels*lines);
           memcpy(Image+pixels*lines, CbData, (pixels*lines)/4);
           memcpy(Image+(pixels*lines*5)/4, CrData, (pixels*lines)/4);
         }
         else
         {
           ScConvert411sTo422s_C(YData, CbData, CrData, YData,
                                 pixels, lines);
           ScConvertSepYUVToOther(&Info->InputFormat, &Info->OutputFormat, 
                             Image, YData, CbData, CrData);
         }
       }
       else if (!IsYUV422Sep(Info->OutputFormat.biCompression) &&
           !IsYUV411Sep(Info->OutputFormat.biCompression) &&
            Info->OutputFormat.biCompression != BI_DECGRAYDIB)
          ScConvertSepYUVToOther(&Info->InputFormat, &Info->OutputFormat, 
                             Image, YData, CbData, CrData);
       }
       break; /* SV_JPEG_DECODE */
#endif /* JPEG_SUPPORT */

#ifdef HUFF_SUPPORT
    case SV_HUFF_DECODE:
        {
          SvHuffInfo_t *HInfo;
          _SlibDebug(_DEBUG_, printf("SvDecompress() SV_HUFF_DECODE\n") );

          if (!(HInfo = Info->huff))
            return(SvErrorBadPointer);

          if (!HInfo->DecompressStarted)
            return(SvErrorDcmpNotStarted);

          stat = sv_HuffDecodeFrame(Info, Image);
          RETURN_ON_ERROR(stat);
        }
        break;
#endif /* HUFF_SUPPORT */

    default:
       return(SvErrorCodecType);
  }

  Info->NumOperations++;
  if (Info->CallbackFunction)
  {
    if (ImageSize>0)
    {
      CB.Message = CB_FRAME_READY;
      CB.Data  = Image;
      CB.DataSize = MaxImageSize;
      CB.DataUsed = ImageSize;
      CB.DataType = CB_DATA_IMAGE;
      CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
      CB.TimeStamp = 0;
      CB.Flags = 0;
      CB.Value = 0;
      CB.Format = (void *)&Info->OutputFormat;
      CB.Action  = CB_ACTION_CONTINUE;
      (*(Info->CallbackFunction))(Svh, &CB, NULL);
      _SlibDebug(_DEBUG_,
        printf("Decompress Callback: CB_FRAME_READY Addr=0x%x, Action=%d\n",
                CB.Data, CB.Action) );
      if (CB.Action == CB_ACTION_END)
        return(SvErrorClientEnd);
    }
    /*
    ** If an Image buffer was taken from the queue, do a callback
    ** to let the client free or re-use the buffer.
    */
    if (UsedQ)
    {
      CB.Message = CB_RELEASE_BUFFER;
      CB.Data  = Image;
      CB.DataSize = MaxImageSize;
      CB.DataUsed = ImageSize;
      CB.DataType = CB_DATA_IMAGE;
      CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
      CB.Action  = CB_ACTION_CONTINUE;
      (*(Info->CallbackFunction))(Svh, &CB, NULL);
      _SlibDebug(_DEBUG_,
          printf("Decompress Callback: RELEASE_BUFFER Addr=0x%x, Action=%d\n",
                  CB.Data, CB.Action) );
      if (CB.Action == CB_ACTION_END)
        return(SvErrorClientEnd);
    }
  }
  _SlibDebug(_DEBUG_, printf("SvDecompress() Out\n") );
  return(stat);
}



/*
** Name:     SvDecompressEnd
** Purpose:  Terminate the Decompression Codec. Call after all calls to
**           SvDecompress are done.
**
** Args:     Svh = handle to software codec's Info structure.
*/
SvStatus_t SvDecompressEnd (SvHandle_t Svh)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvCallbackInfo_t CB;
  _SlibDebug(_DEBUG_, printf("SvDecompressEnd()\n") );

  if (!Info)
    return(SvErrorCodecHandle);
  if (!Info->started)
    return(SvErrorDcmpNotStarted);

  switch (Info->mode)
  {
#ifdef JPEG_SUPPORT
     case SV_JPEG_DECODE:
        Info->jdcmp->DecompressStarted = FALSE;
        break;
#endif /* JPEG_SUPPORT */

#ifdef MPEG_SUPPORT
     case SV_MPEG_DECODE:
     case SV_MPEG2_DECODE:
        Info->mdcmp->DecompressStarted = FALSE;
        Info->mdcmp->PicturePositioned = FALSE;
        Info->mdcmp->lastI = -1;
        Info->mdcmp->lastP = -1;
        Info->mdcmp->N = 12;
        Info->mdcmp->M = 3;
        Info->mdcmp->framenum = 0;
        break;
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
     case SV_H261_DECODE:
        {
        int status=svH261DecompressFree(Svh);
        RETURN_ON_ERROR(status);
        }
        break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
    case SV_H263_DECODE:
        {
        int status=svH263FreeDecompressor(Info);
        RETURN_ON_ERROR(status);
        }
#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
     case SV_HUFF_DECODE:
/*
	{
        int status=sv_HuffDecompressEnd(Svh);
        RETURN_ON_ERROR(status);
        }
*/
        break;
#endif /* HUFF_SUPPORT */
  }
  /* Release any Image Buffers in the queue */
  if (Info->ImageQ)
  {
    int datasize;
    _SlibDebug(_VERBOSE_, printf("Info->ImageQ exists\n") );
    while (ScBufQueueGetNum(Info->ImageQ))
    {
      _SlibDebug(_VERBOSE_, printf("Removing from ImageQ\n") );
      ScBufQueueGetHead(Info->ImageQ, &CB.Data, &datasize);
      ScBufQueueRemove(Info->ImageQ);
      if (Info->CallbackFunction && CB.Data)
      {
        CB.Message = CB_RELEASE_BUFFER;
        CB.DataSize = datasize;
        CB.DataUsed = 0;
        CB.DataType = CB_DATA_IMAGE;
        CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
        CB.Action  = CB_ACTION_CONTINUE;
        (*(Info->CallbackFunction))(Svh, &CB, NULL);
        _SlibDebug(_DEBUG_,
           printf("SvDecompressEnd: RELEASE_BUFFER. Data = 0x%x, Action = %d\n",
                           CB.Data, CB.Action) );
      }
    }
  }
  if (Info->BSIn)
    ScBSFlush(Info->BSIn);  /* flush out any remaining compressed buffers */

  if (Info->CallbackFunction)
  {
    CB.Message = CB_CODEC_DONE;
    CB.Data = NULL;
    CB.DataSize = 0;
    CB.DataUsed = 0;
    CB.DataType = CB_DATA_NONE;
    CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
    CB.TimeStamp = 0;
    CB.Flags = 0;
    CB.Value = 0;
    CB.Format = NULL;
    CB.Action  = CB_ACTION_CONTINUE;
    (*Info->CallbackFunction)(Svh, &CB, NULL);
    _SlibDebug(_DEBUG_,
            printf("SvDecompressEnd Callback: CB_CODEC_DONE Action = %d\n",
                    CB.Action) );
    if (CB.Action == CB_ACTION_END)
      return (ScErrorClientEnd);
  }
  Info->started=FALSE;
  return(NoErrors);
}

/*
** Name:     SvSetDataSource 
** Purpose:  Set the data source used by the MPEG or H261 bitstream parsing code
**           to either the Buffer Queue or File input. The default is
**           to use the Buffer Queue where data buffers are added by calling
**           SvAddBuffer. When using file IO, the data is read from a file
**           descriptor into a buffer supplied by the user.
**
** Args:     Svh    = handle to software codec's Info structure.
**           Source = SV_USE_BUFFER_QUEUE or SV_USE_FILE
**           Fd     = File descriptor to use if Source = SV_USE_FILE
**           Buf    = Pointer to buffer to use if Source = SV_USE_FILE
**           BufSize= Size of buffer when Source = SV_USE_FILE
*/
SvStatus_t SvSetDataSource (SvHandle_t Svh, int Source, int Fd, 
			    void *Buffer_UserData, int BufSize)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  int stat=NoErrors;

  if (!Info)
    return(SvErrorCodecHandle);

  if (Info->mode!=SV_MPEG_DECODE && Info->mode!=SV_MPEG2_DECODE
      && Info->mode!=SV_H261_DECODE && Info->mode!=SV_H263_DECODE
      && Info->mode!=SV_HUFF_DECODE)
    return(SvErrorCodecType);

  if (Info->BSIn)
  {
    ScBSDestroy(Info->BSIn);
    Info->BSIn=NULL;
  }

  switch (Source)
  {
     case SV_USE_BUFFER:
       _SlibDebug(_DEBUG_, printf("SvSetDataSource(SV_USE_BUFFER)\n") );
       stat=ScBSCreateFromBuffer(&Info->BSIn, Buffer_UserData, BufSize);
       break;

     case SV_USE_BUFFER_QUEUE:
       _SlibDebug(_DEBUG_, printf("SvSetDataSource(SV_USE_BUFFER_QUEUE)\n") );
       stat=ScBSCreateFromBufferQueue(&Info->BSIn, Svh, 
                                      CB_DATA_COMPRESSED,
                                      Info->BufQ,
         (int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Info->CallbackFunction,
         (void *)Buffer_UserData);
       break;

     case SV_USE_FILE:
       _SlibDebug(_DEBUG_, printf("SvSetDataSource(SV_USE_FILE)\n") );
       stat=ScBSCreateFromFile(&Info->BSIn, Fd, Buffer_UserData, BufSize);
       break;

     default:
       stat=SvErrorBadArgument;
   }
   return(stat);
}

/*
** Name:     SvSetDataDestination 
** Purpose:  Set the data destination used by the MPEG or H261 bitstream
**           writing code
**           to either the Buffer Queue or File input. The default is
**           to use the Buffer Queue where data buffers are added by calling
**           SvAddBuffer. When using file IO, the data is read from a file
**           descriptor into a buffer supplied by the user.
**
** Args:     Svh    = handle to software codec's Info structure.
**           Source = SV_USE_BUFFER_QUEUE or SV_USE_FILE
**           Fd     = File descriptor to use if Source = SV_USE_FILE
**           Buf    = Pointer to buffer to use if Source = SV_USE_FILE
**           BufSize= Size of buffer when Source = SV_USE_FILE
*/
SvStatus_t SvSetDataDestination(SvHandle_t Svh, int Dest, int Fd, 
			        void *Buffer_UserData, int BufSize)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  int stat=NoErrors;

  if (!Info)
    return(SvErrorCodecHandle);

  if (Info->mode != SV_H261_ENCODE && Info->mode != SV_H263_ENCODE &&
      Info->mode != SV_MPEG_ENCODE &&
      Info->mode != SV_MPEG2_ENCODE && Info->mode != SV_HUFF_ENCODE)
    return(SvErrorCodecType);

  if (Info->BSOut)
  {
    ScBSDestroy(Info->BSOut);
    Info->BSOut=NULL;
  }

  switch (Dest)
  {
     case SV_USE_BUFFER:
       _SlibDebug(_DEBUG_, printf("SvSetDataDestination(SV_USE_BUFFER)\n") );
       stat=ScBSCreateFromBuffer(&Info->BSOut, Buffer_UserData, BufSize);
       break;

     case SV_USE_BUFFER_QUEUE:
       _SlibDebug(_DEBUG_, 
                  printf("SvSetDataDestination(SV_USE_BUFFER_QUEUE)\n") );
       stat=ScBSCreateFromBufferQueue(&Info->BSOut, Svh, 
                                      CB_DATA_COMPRESSED, Info->BufQ,
         (int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Info->CallbackFunction,
         (void *)Buffer_UserData);
       break;

     case SV_USE_FILE:
       _SlibDebug(_DEBUG_, printf("SvSetDataDestination(SV_USE_FILE)\n") );
       stat=ScBSCreateFromFile(&Info->BSOut, Fd, Buffer_UserData, BufSize);
       break;

     default:
       stat=SvErrorBadArgument;
   }
   return(stat);
}

/*
** Name: SvGetDataSource
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
**          (currently H.261 and MPEG use a bitstream)
*/
ScBitstream_t *SvGetDataSource (SvHandle_t Svh)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  
  if (!Info)
    return(NULL);

  return(Info->BSIn);
}

/*
** Name: SvGetDataDestination
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
**          (currently H.261 and MPEG use a bitstream)
*/
ScBitstream_t *SvGetDataDestination(SvHandle_t Svh)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  
  if (!Info)
    return(NULL);

  return(Info->BSOut);
}

/*
** Name: SvGetInputBitstream
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
**          (currently H.261 and MPEG use a bitstream)
*/
ScBitstream_t *SvGetInputBitstream (SvHandle_t Svh)
{
  return(SvGetDataSource(Svh));
}

/*
** Name:    SvFlush
** Purpose: Flushes out current compressed buffers.
** Return:  status
*/
SvStatus_t SvFlush(SvHandle_t Svh)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(SvErrorCodecHandle);
  if (Info->BSIn)
    ScBSFlush(Info->BSIn);  /* flush out any remaining input compressed buffers */
  if (Info->BSOut)
    ScBSFlush(Info->BSOut); /* flush out any remaining output compressed buffers */
  return(SvErrorNone);
}

/*
** Name:     SvRegisterCallback
** Purpose:  Specify the user-function that will be called during processing
**           to determine if the codec should abort the frame.
** Args:     Svh          = handle to software codec's Info structure.
**           Callback     = callback function to register
**
*/
SvStatus_t SvRegisterCallback (SvHandle_t Svh, 
	   int (*Callback)(SvHandle_t, SvCallbackInfo_t *, SvPictureInfo_t *),
       void *UserData)
{
  SvStatus_t stat=NoErrors;
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  _SlibDebug(_DEBUG_, printf("SvRegisterCallback()\n") );

  if (!Info)
    return(SvErrorCodecHandle);

  if (!Callback)
     return(SvErrorBadPointer);

  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT    
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
           Info->CallbackFunction = Callback;
           if (Info->BSIn==NULL)
             stat=SvSetDataSource(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           Info->CallbackFunction = Callback;
           if (Info->BSOut==NULL)
             stat=SvSetDataDestination(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT    
    case SV_H261_DECODE:
           Info->CallbackFunction = Callback;
           if (Info->h261) /* copy callback to H261 structure */
             Info->h261->CallbackFunction=Callback;
           if (Info->BSIn==NULL)
             stat=SvSetDataSource(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
    case SV_H261_ENCODE:
           Info->CallbackFunction = Callback;
           if (Info->h261) /* copy callback to H261 structure */
             Info->h261->CallbackFunction=Callback;
           if (Info->BSOut==NULL)
             stat=SvSetDataDestination(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT    
    case SV_H263_DECODE:
           Info->CallbackFunction = Callback;
           if (Info->BSIn==NULL)
             stat=SvSetDataSource(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
    case SV_H263_ENCODE:
           Info->CallbackFunction = Callback;
           if (Info->BSOut==NULL)
             stat=SvSetDataDestination(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT    
    case SV_HUFF_DECODE:
           Info->CallbackFunction = Callback;
           if (Info->BSIn==NULL)
             stat=SvSetDataSource(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
    case SV_HUFF_ENCODE:
           Info->CallbackFunction = Callback;
           if (Info->BSOut==NULL)
             stat=SvSetDataDestination(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
#endif /* HUFF_SUPPORT */
    default:
           return(SvErrorCodecType);
  }
  return(stat);
}

/*
** Name:     SvAddBuffer
** Purpose:  Add a buffer of MPEG bitstream data to the CODEC or add an image
**           buffer to be filled by the CODEC (in streaming mode)
**
** Args:     Svh = handle to software codec's Info structure.
**           BufferInfo = structure describing buffer's address, type & size
*/
SvStatus_t SvAddBuffer (SvHandle_t Svh, SvCallbackInfo_t *BufferInfo)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  ScQueue_t *Q=NULL;
  _SlibDebug(_DEBUG_, printf("SvAddBuffer() length=%d\n",BufferInfo->DataSize));

  if (!Info)
    return(SvErrorCodecHandle);

  if (BufferInfo->DataType != CB_DATA_COMPRESSED &&
      BufferInfo->DataType != CB_DATA_IMAGE)
    return(SvErrorBadArgument);

  /*
  ** Compressed data can only be added for MPEG and H261
  */
  if (BufferInfo->DataType == CB_DATA_COMPRESSED
#ifdef MPEG_SUPPORT
        && Info->mode != SV_MPEG_DECODE 
        && Info->mode != SV_MPEG2_DECODE 
        && Info->mode != SV_MPEG_ENCODE 
        && Info->mode != SV_MPEG2_ENCODE 
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
        && Info->mode != SV_H261_DECODE
        && Info->mode != SV_H261_ENCODE
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
        && Info->mode != SV_H263_DECODE
        && Info->mode != SV_H263_ENCODE
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
        && Info->mode != SV_HUFF_DECODE
        && Info->mode != SV_HUFF_ENCODE
#endif /* HUFF_SUPPORT */
     )
    return(SvErrorCodecType);

  if (!BufferInfo->Data || (BufferInfo->DataSize <= 0))
    return(SvErrorBadArgument);

  switch (BufferInfo->DataType)
  {
     case CB_DATA_COMPRESSED:
            _SlibDebug(_DEBUG_, printf("SvAddBuffer() COMPRESSED\n") );
            if (Info->BSOut && Info->BSOut->EOI)
              ScBSReset(Info->BSOut);
            if (Info->BSIn && Info->BSIn->EOI)
              ScBSReset(Info->BSIn);
            Q = Info->BufQ;
            break;
     case CB_DATA_IMAGE:
            _SlibDebug(_DEBUG_, printf("SvAddBuffer() IMAGE\n") );
            Q = Info->ImageQ;
            break;
     default:
            return(SvErrorBadArgument);
  }
  if (Q)
    ScBufQueueAdd(Q, BufferInfo->Data, BufferInfo->DataSize);
  else
    _SlibDebug(_DEBUG_, printf("ScBufQueueAdd() no Queue\n") );

  return(NoErrors);
}

/*
** Name:     SvFindNextPicture
** Purpose:  Find the start of the next picture in a bitstream.
**           Return the picture type to the caller.
**
** Args:     Svh = handle to software codec's Info structure.
**           PictureInfo = Structure used to select what type of pictures to
**                         search for and to return information about the
**                         picture that is found
*/
SvStatus_t SvFindNextPicture (SvHandle_t Svh, SvPictureInfo_t *PictureInfo)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
   _SlibDebug(_DEBUG_, printf("SvFindNextPicture()\n") );

   if (!Info)
     return(SvErrorCodecHandle);

   switch (Info->mode)
   {
#ifdef MPEG_SUPPORT
     case SV_MPEG_DECODE:
     case SV_MPEG2_DECODE:
            if (!Info->mdcmp)
              return(SvErrorBadPointer);
            if (!Info->mdcmp->DecompressStarted)
              return(SvErrorDcmpNotStarted);
            {
		SvStatus_t stat = sv_MpegFindNextPicture(Info, PictureInfo);
		return(stat);
	    }
#endif /* MPEG_SUPPORT */
     default:
            return(SvErrorCodecType);
   }
}

#ifdef MPEG_SUPPORT
/*
** Name:     SvDecompressMPEG
** Purpose:  Decompress the MPEG picture that starts at the current position
**           of the bitstream. If the bitstream is not properly positioned
**           then find the next picture.
**
** Args:     Svh = handle to software codec's Info structure.
**           MultiBuf = Specifies pointer to start of the Multibuffer, an area
**                      large enough to hold 3 decompressed images: the
**                      current image, the past reference image and the
**                      future reference image.
**           MaxMultiSize = Size of the Multibuffer in bytes.
**           ImagePtr = Returns a pointer to the current image. This will be
**                      somewhere within the Multibuffer.
*/
SvStatus_t SvDecompressMPEG (SvHandle_t Svh, u_char *MultiBuf, 
			     int MaxMultiSize, u_char **ImagePtr)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
   SvMpegDecompressInfo_t *MDInfo;
   _SlibDebug(_DEBUG_, printf("SvDecompressMPEG()\n") );

   if (!Info)
     return(SvErrorCodecHandle);

   if (!(MDInfo = Info->mdcmp))
     return(SvErrorBadPointer);

   if (!MDInfo->DecompressStarted)
     return(SvErrorDcmpNotStarted);

   return(sv_MpegDecompressFrame(Info, MultiBuf, ImagePtr));
}
#endif /* MPEG_SUPPORT */	

#ifdef H261_SUPPORT
SvStatus_t SvDecompressH261 (SvHandle_t Svh, u_char *MultiBuf,
                             int MaxMultiSize, u_char **ImagePtr)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvH261Info_t *H261;
  ScCallbackInfo_t CB;
  SvStatus_t status;

  if (!Info)
    return(SvErrorCodecHandle);

  if (!(H261 = Info->h261))
    return(SvErrorBadPointer);

  if (Info->BSIn->EOI)
    return(SvErrorEndBitstream);

  status = svH261Decompress(Info, MultiBuf, ImagePtr);
  if (status == SvErrorEndBitstream && Info->CallbackFunction)
  {
    CB.Message = CB_SEQ_END;
    CB.Data = NULL;
    CB.DataSize = 0;
    CB.DataType = CB_DATA_NONE;
    CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
    CB.Action  = CB_ACTION_CONTINUE;
    (*Info->CallbackFunction)(Svh, &CB, NULL);
    _SlibDebug(_DEBUG_, 
               printf("H261 Callback: CB_SEQ_END Data = 0x%x Action = %d\n",
                          CB.Data, CB.Action) );
    if (CB.Action == CB_ACTION_END)
      return (ScErrorClientEnd);
  }
  else if (status==NoErrors)
  {
    *ImagePtr = H261->Y;
    if (Info->CallbackFunction)
    {
      CB.Message = CB_FRAME_READY;
      CB.Data = *ImagePtr;
      CB.DataSize = H261->PICSIZE+(H261->PICSIZE/2);
      CB.DataUsed = CB.DataSize;
      CB.DataType = CB_DATA_IMAGE;
      CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
      CB.TimeStamp = 0;
      CB.Flags = 0;
      CB.Value = 0;
      CB.Format = (void *)&Info->OutputFormat;
      CB.Action  = CB_ACTION_CONTINUE;
      (*Info->CallbackFunction)(Svh, &CB, NULL);
      _SlibDebug(_DEBUG_, 
            printf("H261 Callback: CB_FRAME_READY Data = 0x%x, Action = %d\n",
                  CB.Data, CB.Action) );
      if (CB.Action == CB_ACTION_END)
        return (ScErrorClientEnd);
    }
  }
  return (status);
}
#endif /* H261_SUPPORT */

#ifdef JPEG_SUPPORT
/*---------------------------------------------------------------------
	SLIB routines to Query and return CODEC Tables to caller
 *---------------------------------------------------------------------*/

/*
** From JPEG Spec. :
**    Huffman tables are specified in terms of a 16-byte list (BITS) giving 
**    the number of codes for each code length from 1 to 16. This is 
**    followed by a list of 8-bit symbol values (HUFVAL), each of which is
**    assigned a Huffman code. The symbol values are placed in the list
**    in order of increasing code length.  Code length greater than 16-bits
**    are not allowed. 
*/


/*
** Name:     SvSetDcmpHTables
** Purpose: 
**
** Notes:    Baseline process is the only supported mode:
**		- uses 2 AC tables and 2 DC Tables
**
*/
SvStatus_t SvSetDcmpHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  int i,stat,count;
  SvHt_t **htblptr;
  SvHTable_t *HTab;
  register int j;

  if (!Info)
    return(SvErrorCodecHandle);

  if (!Ht)
    return(SvErrorBadPointer);

  for (j = 0; j < 4; j++) {
    switch(j) {
    case 0: htblptr = &Info->jdcmp->DcHt[0];
      HTab = &Ht->DcY;
      break;
    case 1: htblptr = &Info->jdcmp->AcHt[0];
      HTab = &Ht->AcY;
      break;
    case 2: htblptr = &Info->jdcmp->DcHt[1];
      HTab = &Ht->DcUV;
      break;
    case 3: htblptr = &Info->jdcmp->AcHt[1];
      HTab = &Ht->AcUV;
      break;
    }
      
    if (*htblptr == NULL)
      *htblptr = (SvHt_t *) ScPaMalloc(sizeof(SvHt_t));
    
    (*htblptr)->bits[0] = 0;
    count   = 0;
    for (i = 1; i < BITS_LENGTH; i++) {
      (*htblptr)->bits[i] = (u_char)HTab->bits[i-1];
      count += (*htblptr)->bits[i];
    }
    if (count > 256) 
      return(SvErrorDHTTable);
    
    /*
    ** Load Huffman table:
    */
    for (i = 0; i < count; i++)
      (*htblptr)->value[i] = (u_char)HTab->value[i];
  }

  stat = sv_LoadDefaultHTable (Info);
  if (stat) return(stat);
  
  return(NoErrors);
}


/*
** Name:     SvGetDcmpHTables
** Purpose: 
**
*/
SvStatus_t SvGetDcmpHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  int i,count;
  SvHt_t **htblptr;
  SvHTable_t *HTab;
  register int j;

  if (!Info)
    return (SvErrorCodecHandle);

  if (!Ht)
    return(SvErrorBadPointer);

  for (j = 0; j < 4; j++) {
    switch(j) {
    case 0: htblptr = &Info->jdcmp->DcHt[0];
      HTab = &Ht->DcY;
      break;
    case 1: htblptr = &Info->jdcmp->AcHt[0];
      HTab = &Ht->AcY;
      break;
    case 2: htblptr = &Info->jdcmp->DcHt[1];
      HTab = &Ht->DcUV;
      break;
    case 3: htblptr = &Info->jdcmp->AcHt[1];
      HTab = &Ht->AcUV;
      break;
    }
      
    if (*htblptr == NULL)
      return(SvErrorHuffUndefined);
    
    count   = 0;
    for (i = 1; i < BITS_LENGTH; i++) {
      HTab->bits[i-1] = (int)(*htblptr)->bits[i];
      count += (*htblptr)->bits[i];
    }
    if (count > 256) 
      return(SvErrorDHTTable);
    
    /*
    ** Copy Huffman table:
    */
    for (i = 0; i < count; i++)
      HTab->value[i] = (u_int)(*htblptr)->value[i];
  }

  return(NoErrors);
}



/*
** Name:     SvSetCompHTables
** Purpose: 
**
*/
SvStatus_t SvSetCompHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht)
{
   return(SvErrorNotImplemented);
}


/*
** Name:     SvGetCompHTables
** Purpose: 
**
*/
SvStatus_t SvGetCompHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht)
{
   SvCodecInfo_t *Info  = (SvCodecInfo_t *)Svh;
   SvHt_t **htblptr;
   SvHTable_t *HTab;
   register int i, j, count;

   if (!Info)
     return (SvErrorCodecHandle);

   if (!Ht)
     return (SvErrorBadPointer);

   for (j = 0; j < 4; j++) {
      switch(j) {
      case 0: htblptr = &Info->jcomp->DcHt[0];
        HTab = &Ht->DcY;
        break;
      case 1: htblptr = &Info->jcomp->AcHt[0];
        HTab = &Ht->AcY;
        break;
      case 2: htblptr = &Info->jcomp->DcHt[1];
        HTab = &Ht->DcUV;
        break;
      case 3: htblptr = &Info->jcomp->AcHt[1];
        HTab = &Ht->AcUV;
        break;
      }
      
      if (*htblptr == NULL)
        return (SvErrorHuffUndefined);
    
      /*
      ** Copy the "bits" array (contains number of codes of each size)
      */
      count = 0;		
      for (i = 1; i < BITS_LENGTH; i++) {
         HTab->bits[i-1] = (int)(*htblptr)->bits[i];
         count += (*htblptr)->bits[i];
      }
      if (count > 256) 			
	 /* 
         **  total # of Huffman code words cannot exceed 256
         */
         return (SvErrorDHTTable);
    
      /*
      ** Copy the "value" array (contains values associated with above codes) 
      */
      for (i = 0; i < count; i++)
         HTab->value[i] = (u_int)(*htblptr)->value[i];
  }

  return(NoErrors);
}



/*
** Name:     SvSetDcmpQTables
** Purpose: 
**
*/
SvStatus_t SvSetDcmpQTables (SvHandle_t Svh, SvQuantTables_t *Qt)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvJpegDecompressInfo_t *DInfo;

  if (!Info)
    return(SvErrorCodecHandle);

  DInfo = (SvJpegDecompressInfo_t *)Info->jdcmp;

  if (!Qt)
    return(SvErrorBadPointer);

  if (DInfo->_SviquantTblPtrs[0] == NULL) 
    if ((DInfo->_SviquantTblPtrs[0] = (int *) ScAlloc(64*sizeof(int))) ==
	(int *)NULL) return(SvErrorMemory);
  if (DInfo->_SviquantTblPtrs[1] == NULL) 
    if ((DInfo->_SviquantTblPtrs[1] = (int *) ScAlloc(64*sizeof(int))) ==
	(int *)NULL) return(SvErrorMemory);

  bcopy (Qt->c1,  DInfo->_SviquantTblPtrs[0], 64*sizeof(int));
  bcopy (Qt->c2,  DInfo->_SviquantTblPtrs[1], 64*sizeof(int));
  bcopy (Qt->c3,  DInfo->_SviquantTblPtrs[1], 64*sizeof(int));

  return(NoErrors);
}


/*
** Name:     SvGetDcmpQTables
** Purpose: 
**
*/
SvStatus_t SvGetDcmpQTables (SvHandle_t Svh, SvQuantTables_t *Qt)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvJpegDecompressInfo_t *DInfo;

  if (!Info)
    return(SvErrorCodecHandle);

  DInfo = (SvJpegDecompressInfo_t *)Info->jdcmp;

  if (!Qt)
    return(SvErrorBadPointer);

  if (DInfo->_SviquantTblPtrs[0])
    bcopy (DInfo->_SviquantTblPtrs[0], Qt->c1, 64*sizeof(int));
  else
    bzero (Qt->c1, 64*sizeof(int));

  if (DInfo->_SviquantTblPtrs[1])
    bcopy(DInfo->_SviquantTblPtrs[1], Qt->c2, 64*sizeof(int));
  else
    bzero(Qt->c2, 64*sizeof(int));

  /*
  ** XXX - when the structure is changed approprately remove the
  **	   above and do the following:
  **
  **  if ((!Qt->c1) || (!Qt->c2) || (!Qt->c3))
  **     return (SvErrorBadPointer);
  **  bcopy ((u_char *)DInfo->Qt, (u_char *)Qt, sizeof(SvQuantTables_t));
  */

  return(NoErrors);
}


/*
** Name:     SvSetCompQTables
** Purpose:  Allows user to set quantization tables directly
**
*/
SvStatus_t SvSetCompQTables (SvHandle_t Svh, SvQuantTables_t *Qt)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if (!Info->jcomp->CompressStarted)
     return (SvErrorCompNotStarted);

   if (!Qt)
     return (SvErrorBadPointer);

   if ((!Qt->c1) || (!Qt->c2) || (!Qt->c3)) 
     return (SvErrorBadPointer);

   /*
   ** Convert SvQuantTables_t structure to internal SvQt_t structure.
   */
   sv_ConvertQTable(Info, Qt);

   return(NoErrors);
}
#endif /* JPEG_SUPPORT */

/*---------------------------------------------------------------------
	SLIB Compression Routines
 *---------------------------------------------------------------------*/

/*
** Name:     SvCompressBegin
** Purpose:  Initialize the Compression Codec. Call after SvOpenCodec &
**           before SvCompress (SvCompress will call SvCompressBegin
**           on first call to codec after open if user doesn't call it)
**
** Args:     Svh = handle to software codec's Info structure.
**           ImgIn  = format of input (uncompressed) image
**           ImgOut = format of output (compressed) image
*/
SvStatus_t SvCompressBegin (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                            BITMAPINFOHEADER *ImgOut)
{
   int stat;
   SvCodecInfo_t *Info  = (SvCodecInfo_t *)Svh;

   /*
   ** Sanity checks:
   */
   if (!Info)
     return (SvErrorCodecHandle);

   if (!ImgIn || !ImgOut)
     return (SvErrorBadPointer);

   stat=SvCompressQuery (Svh, ImgIn, ImgOut);
   RETURN_ON_ERROR(stat);

   /*
   ** Save input & output formats for SvDecompress
   */
   sv_copy_bmh(ImgIn, &Info->InputFormat);
   sv_copy_bmh(ImgOut, &Info->OutputFormat);

   Info->Width = Info->OutputFormat.biWidth;
   Info->Height = abs(Info->OutputFormat.biHeight);
   /*
   **  Initialize -  the encoder structure 
   **  Load       -  the default Huffman Tables
   **  Make       -  the internal Block Table
   */  
   switch (Info->mode)
   {
#ifdef JPEG_SUPPORT
      case SV_JPEG_ENCODE:
            stat = sv_InitJpegEncoder (Info);
            RETURN_ON_ERROR (stat);
            /*
            ** Set up the default quantization matrices:
            */ 
            stat = SvSetQuality (Svh, DEFAULT_Q_FACTOR);
            Info->jcomp->CompressStarted = TRUE;
            Info->jcomp->Quality = DEFAULT_Q_FACTOR;
            RETURN_ON_ERROR (stat);
            break;

#endif /* JPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SV_H261_ENCODE:
            stat = svH261CompressInit(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
      case SV_H263_ENCODE:
            stat = svH263InitCompressor(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* MPEG_SUPPORT */

#ifdef MPEG_SUPPORT
      case SV_MPEG_ENCODE:
      case SV_MPEG2_ENCODE:
            stat = sv_MpegInitEncoder (Info);
            RETURN_ON_ERROR (stat);
            sv_MpegEncoderBegin(Info);
            break;
#endif /* MPEG_SUPPORT */

#ifdef HUFF_SUPPORT
      case SV_HUFF_ENCODE:
            stat = sv_HuffInitEncoder (Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* HUFF_SUPPORT */

      default:
            return(SvErrorCodecType);
   }
   return (NoErrors);
}


/*
** Name:     SvCompressEnd
** Purpose:  Terminate the Compression Codec. Call after all calls to
**           SvCompress are done.
**
** Args:     Svh = handle to software codec's Info structure.
*/
SvStatus_t SvCompressEnd (SvHandle_t Svh)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvCallbackInfo_t CB;

  SvStatus_t status=NoErrors;
  _SlibDebug(_VERBOSE_, printf("SvCompressEnd()\n") );

  if (!Info)
    return (SvErrorCodecHandle);
  switch (Info->mode)
  {
#ifdef H261_SUPPORT
    case SV_H261_ENCODE:
          status=svH261CompressFree(Svh);
          RETURN_ON_ERROR(status)
          break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
    case SV_H263_ENCODE:
          status=svH263FreeCompressor(Svh);
          RETURN_ON_ERROR(status)
          break;
#endif /* H263_SUPPORT */

#ifdef MPEG_SUPPORT
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
          sv_MpegEncoderEnd(Info);
          sv_MpegFreeEncoder(Info);
          break;
#endif /* MPEG_SUPPORT */

#ifdef JPEG_SUPPORT
    case SV_JPEG_ENCODE:
          if (!Info->jcomp)
            return (SvErrorMemory);
          Info->jcomp->CompressStarted = FALSE;
          break;
#endif /* JPEG_SUPPORT */

#ifdef HUFF_SUPPORT
    case SV_HUFF_ENCODE:
          sv_HuffFreeEncoder(Info);
          break;
#endif /* HUFF_SUPPORT */
    default:
          break;
  }

  /* Release any Image Buffers in the queue */
  if (Info->ImageQ)
  {
    int datasize;
    while (ScBufQueueGetNum(Info->ImageQ))
    {
      ScBufQueueGetHead(Info->ImageQ, &CB.Data, &datasize);
      ScBufQueueRemove(Info->ImageQ);
      if (Info->CallbackFunction && CB.Data)
      {
        CB.Message = CB_RELEASE_BUFFER;
        CB.DataSize = datasize;
        CB.DataUsed = 0;
        CB.DataType = CB_DATA_IMAGE;
        CB.UserData = Info->BSOut?Info->BSOut->UserData:NULL;
        CB.Action  = CB_ACTION_CONTINUE;
        (*(Info->CallbackFunction))(Svh, &CB, NULL);
        _SlibDebug(_DEBUG_, 
            printf("SvCompressEnd: RELEASE_BUFFER. Data = 0x%X, Action = %d\n",
                           CB.Data, CB.Action) );
      }
    }
  }
  if (Info->BSOut)
    ScBSFlush(Info->BSOut);  /* flush out the last compressed data */

  if (Info->CallbackFunction)
  {
    CB.Message = CB_CODEC_DONE;
    CB.Data = NULL;
    CB.DataSize = 0;
    CB.DataUsed = 0;
    CB.DataType = CB_DATA_NONE;
    CB.UserData = Info->BSOut?Info->BSOut->UserData:NULL;
    CB.TimeStamp = 0;
    CB.Flags = 0;
    CB.Value = 0;
    CB.Format = NULL;
    CB.Action  = CB_ACTION_CONTINUE;
    (*Info->CallbackFunction)(Svh, &CB, NULL);
    _SlibDebug(_DEBUG_, 
            printf("SvCompressEnd Callback: CB_CODEC_DONE Action = %d\n",
                  CB.Action) );
    if (CB.Action == CB_ACTION_END)
      return (ScErrorClientEnd);
  }

  return (status);
}


/*
** Name:     SvCompress
** Purpose: 
**
*/
SvStatus_t SvCompress(SvHandle_t Svh, u_char *CompData, int MaxCompLen,
			 u_char *Image, int ImageSize, int *CmpBytes)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvCallbackInfo_t CB;
  int stat=NoErrors, UsedQ=FALSE;
  _SlibDebug(_DEBUG_, printf("SvCompress()\n") );

  if (!Info)
    return (SvErrorCodecHandle);
 
  /*
  ** If no image buffer is supplied, see if the Image Queue
  ** has any.  If not do a callback to get a buffer.
  */
  if (Image == NULL && Info->ImageQ)
  {
    if (ScBufQueueGetNum(Info->ImageQ))
    {
      ScBufQueueGetHead(Info->ImageQ, &Image, &ImageSize);
      ScBufQueueRemove(Info->ImageQ);
      UsedQ = TRUE;
    }
    else if (Info->CallbackFunction)
    {
      CB.Message = CB_END_BUFFERS;
      CB.Data  = NULL;
      CB.DataSize = 0;
      CB.DataUsed = 0;
      CB.DataType = CB_DATA_IMAGE;
      CB.UserData = Info->BSOut?Info->BSOut->UserData:NULL;
      CB.Action  = CB_ACTION_CONTINUE;
      (*(Info->CallbackFunction))(Svh, &CB, NULL);
      if (CB.Action == CB_ACTION_END)
      {
        _SlibDebug(_DEBUG_, 
                   printf("SvDecompress() CB.Action = CB_ACTION_END\n") );
        return(SvErrorClientEnd);
      }
      else if (ScBufQueueGetNum(Info->ImageQ))
      {
        ScBufQueueGetHead(Info->ImageQ, &Image, &ImageSize);
        ScBufQueueRemove(Info->ImageQ);
        UsedQ = TRUE;
      }
      else
        return(SvErrorNoImageBuffer);
    }
  }

  if (Image == NULL)
    return(SvErrorNoImageBuffer);

  switch (Info->mode)
  {
#ifdef H261_SUPPORT
    case SV_H261_ENCODE:
         stat = svH261Compress(Svh, Image);
         if (CmpBytes)
           *CmpBytes = (int)(Info->h261->TotalBits/8);
         break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
    case SV_H263_ENCODE:
         stat = svH263Compress(Svh, Image);
         break;
#endif /* H261_SUPPORT */

#ifdef MPEG_SUPPORT
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
         stat = sv_MpegEncodeFrame(Svh, Image);
         break;
#endif /* MPEG_SUPPORT */

#ifdef JPEG_SUPPORT 
    case SV_JPEG_ENCODE:
         {
           SvJpegCompressInfo_t *CInfo;
           u_char *CompBuffer;
           register int i;
           int RetBytes, InLen;

           CInfo = Info->jcomp;
           /*
           ** In case the application forgot to call SvCompressBegin().
           */
           if (!CInfo->CompressStarted) 
             return (SvErrorCompNotStarted);

           if ((u_int)Image%8)
             return (SvErrorNotAligned);

           CompBuffer = CompData;
           /*
           ** Start - add header information
           **       - needed if we want to conform to the interchange format
           */
           stat = sv_AddJpegHeader (Svh, CompBuffer, MaxCompLen, &RetBytes);
           RETURN_ON_ERROR (stat);
           CompBuffer += RetBytes;

           /*
           ** Separate input image directly into 8x8 blocks.
           ** level shift to go from signed to unsigned representation
           **    - since we support baseline DCT process only (i.e 8-bit
           **      precision) subtract raw data by 128
           */
           sv_JpegExtractBlocks (Info, Image);

           for (i = 0; i < CInfo->NumComponents; i++)
             CInfo->lastDcVal[i] = 0;

           /*
           ** JPEG business loop:
           */
           {
           register int Cid, HQid, blkN, mcuN, mbn, DcVal;
           float *FQt, *FThresh, *FThreshNeg;
           float *RawData;
           SvRLE_t rle;
           const static long Mask = 0xffL;
           float DCTData[64];
           register float tmp,AcVal;

           CB.Message = CB_PROCESSING;
           /*
           ** Processing within a frame is done on a MCU by MCU basis:
           */
           for (blkN = 0, mcuN = 0 ; mcuN < (int) CInfo->NumMCU; mcuN++)
           {
             /*
             ** Callback user routine every now&then to see if we should abort
             */
             if ((Info->CallbackFunction) && ((i % MCU_CALLBACK_COUNT) == 0))
             {
               SvPictureInfo_t DummyPictInfo;
               (*Info->CallbackFunction)(Svh, &CB, &DummyPictInfo);
               if (CB.Action == CB_ACTION_END) 
                 return(SvErrorClientEnd);
             }
             /*
             ** Account for restart interval, emit restart marker if needed
             */
             if (CInfo->restartInterval)
             {
               if (CInfo->restartsToGo == 0)
                 EmitRestart (CInfo);
               CInfo->restartsToGo--;
             }
             /*
             ** Processing within an MCU is done on a block by block basis:
             */
             for (mbn = 0; mbn < (int) CInfo->BlocksInMCU; mbn++, blkN++)
             {
	       /*
	       ** Figure out the component to which the current block belongs:
	       ** -Due to the way input data is processed by "sv_extract_blocks"
	       **  and under the assumption that the input is YCrCb, 
	       **  Cid is 0,0,1,2 for each block in the MCU
	       */
               switch (mbn) {
	         case 0:
	         case 1:  Cid = 0;  HQid = 0;  break;
	         case 2:  Cid = 1;  HQid = 1;  break;
	         case 3:  Cid = 2;  HQid = 1;  break;
	       }

               RawData = CInfo->BlkTable[blkN];

#ifndef _NO_DCT_
               /*
               ** Discrete Cosine Transform:
	       ** Perform the Forward DCT, take the input data from "RawData"
	       ** and place the computed coefficients in "DCTData":
               */
               ScFDCT8x8 (RawData, DCTData);
#ifndef _NO_QUANT_
               /*
               **  Quantization:
	       **
	       ** Identify the quantization tables:
	       */
	       FQt        = (float *) (CInfo->Qt[HQid])->fval;
	       FThresh    = (float *) (CInfo->Qt[HQid])->fthresh;
	       FThreshNeg = (float *) (CInfo->Qt[HQid])->fthresh_neg;

	       /*
	       ** Quantize the DC value first:
	       */
	       tmp = DCTData[0] *FQt[0];
               if (tmp < 0)
	         DcVal = (int) (tmp - 0.5);
               else
	         DcVal = (int) (tmp + 0.5);

	       /* 
	       ** Go after (quantize) the AC coefficients now:
	       */
               for (rle.numAC = 0, i = 1; i < 64; i++)
               {
	         AcVal = DCTData[ZagIndex[i]];
 
	         if (AcVal > FThresh[i]) {
	           rle.ac[rle.numAC].index = i;
	           rle.ac[rle.numAC++].value = (int) (AcVal * FQt[i] + 0.5);
	         }
	         else if (AcVal < FThreshNeg[i]) {
	           rle.ac[rle.numAC].index = i;
	           rle.ac[rle.numAC++].value = (int) (AcVal * FQt[i] - 0.5);
	         }
               }

               /*
               ** DPCM coding:
	       **
	       ** Difference encoding of the DC value, 
	       */
	       rle.dc = DcVal - CInfo->lastDcVal[Cid];
	       CInfo->lastDcVal[Cid] = DcVal;

#ifndef _NO_HUFF_
               /*
               ** Entropy Coding:
	       **
	       ** Huffman encode the current block
	       */
  	       sv_EncodeOneBlock (&rle, CInfo->DcHt[HQid], CInfo->AcHt[HQid]); 
	       FlushBytes(&CompBuffer);
#endif /* _NO_HUFF_ */
#endif /* _NO_QUANT_ */
#endif /* _NO_DCT_ */
             }
           }
           }
           (void ) sv_HuffEncoderTerm (&CompBuffer);

           Info->OutputFormat.biSize = CompBuffer - CompData;
           InLen = MaxCompLen - Info->OutputFormat.biSize;

           /*
           ** JPEG End:
           ** - add trailer information to the compressed bitstream, 
           **   - needed if we want to conform to the interchange format
           */
           stat = sv_AddJpegTrailer (Svh, CompBuffer, InLen, &RetBytes);
           RETURN_ON_ERROR (stat);
           CompBuffer += RetBytes;
           Info->OutputFormat.biSize += RetBytes;
           if (CmpBytes)
             *CmpBytes = CompBuffer - CompData;
         }
         break;
#endif /* JPEG_SUPPORT */

#ifdef HUFF_SUPPORT
    case SV_HUFF_ENCODE:
         stat = sv_HuffEncodeFrame(Svh, Image);
         break;
#endif /* HUFF_SUPPORT */

    default:
         return(SvErrorCodecType);
  }

  Info->NumOperations++;
  /*
  ** If an Image buffer was taken from the queue, do a callback
  ** to let the client free or re-use the buffer.
  */
  if (Info->CallbackFunction && UsedQ)
  {
    CB.Message = CB_RELEASE_BUFFER;
    CB.Data  = Image;
    CB.DataSize = ImageSize;
    CB.DataUsed = ImageSize;
    CB.DataType = CB_DATA_IMAGE;
    CB.UserData = Info->BSOut?Info->BSOut->UserData:NULL;
    CB.Action  = CB_ACTION_CONTINUE;
    (*(Info->CallbackFunction))(Svh, &CB, NULL);
    _SlibDebug(_DEBUG_, 
             printf("Compress Callback: RELEASE_BUFFER Addr=0x%x, Action=%d\n",
                 CB.Data, CB.Action) );
    if (CB.Action == CB_ACTION_END)
      return(SvErrorClientEnd);
  }
  return (stat);
}

static SvStatus_t sv_ConvertRGBToSepComponent(u_char *Iimage,
BITMAPINFOHEADER * Bmh, u_char *comp1, u_char *comp2, u_char *comp3, 
int pixels, int lines)
{
  register i;
  int bpp = Bmh->biBitCount;
  u_int *Ip = (u_int *)Iimage;
  u_short *Is = (u_short *)Iimage;

  if (bpp == 24) {
    if (Bmh->biCompression == BI_RGB) {
      for (i = 0 ; i < pixels*lines ; i++) {
        comp3[i] = *Iimage++; /* Blue */
        comp2[i] = *Iimage++; /* Green */
        comp1[i] = *Iimage++; /* Red */
      }
    }
    else if (Bmh->biCompression == BI_DECXIMAGEDIB) {
                             /* RGBQUAD structures: (B,G,R,0) */
      for (i = 0 ; i < pixels*lines ; i++) {
        comp3[i] = *Iimage++; /* Blue */
        comp2[i] = *Iimage++; /* Green */
        comp1[i] = *Iimage++; /* Red */
        Iimage++;             /* Reserved */
      }
    }
  }
  else if (bpp == 32) {      /* RGBQUAD structures: (B,G,R,0) */
    for (i = 0 ; i < pixels*lines ; i++) {
      comp3[i] = (Ip[i] >> 24) & 0xFF;
      comp2[i] = (Ip[i] >> 16) & 0xFF;
      comp1[i] = (Ip[i] >> 8)  & 0xFF;
    }
  }
  else if (bpp == 16) {
    for (i = 0 ; i < pixels*lines ; i++) {
      comp1[i] = (Is[i] >> 7) & 0xf8;
      comp2[i] = (Is[i] >> 2) & 0xf8;
      comp3[i] = (Is[i] << 3) & 0xf8;
    }
  }
  return (NoErrors);
}


/*
** Name:     SvCompressQuery
** Purpose:  Determine if Codec can Compress desired format
**
** Args:     Svh = handle to software codec's Info structure.
**           ImgIn  = Pointer to BITMAPINFOHEADER structure describing format
**           ImgOut = Pointer to BITMAPINFOHEADER structure describing format
*/
SvStatus_t SvCompressQuery (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                            BITMAPINFOHEADER *ImgOut)
{
   /*
   ** We don't *really* need the Info structures, but we check for
   ** NULL pointers to make sure the CODEC,  whoes ability is being
   ** queried, was at least opened.
   */
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return(SvErrorCodecHandle);

   if (!ImgIn && !ImgOut)
     return(SvErrorBadPointer);

   if (!IsSupported(_SvCompressionSupport,
                    ImgIn ? ImgIn->biCompression : -1, 
                    ImgIn ? ImgIn->biBitCount : -1,
                    ImgOut ? ImgOut->biCompression : -1, 
                    ImgOut ? ImgOut->biBitCount : -1))
     return(SvErrorUnrecognizedFormat);
	 
   /*
   ** For speed we impose a restriction that the image size should be
   ** a multiple of 16x8. This insures that we would have at least one
   ** MCU for a 4:2:2 image
   **
   ** NOTE: This is an artificial restriction from JPEG's perspective.
   **       In the case when the dimesnsions are otherwise, we should
   **       pixel replicate and/or line replicate before compressing.
   */
   if (ImgIn)
   {
     if (ImgIn->biWidth  <= 0 || ImgIn->biHeight == 0)
       return(SvErrorBadImageSize);
     if ((ImgIn->biWidth%16) || (ImgIn->biHeight%8))
       return (SvErrorNotImplemented);
   }

   if (ImgOut) /* Query Output also */
   {
     if (ImgOut->biWidth <= 0 || ImgOut->biHeight == 0)
       return (SvErrorBadImageSize);
     if (ImgOut->biCompression == BI_DECH261DIB)
     {
       if ((ImgOut->biWidth != CIF_WIDTH && ImgOut->biWidth != QCIF_WIDTH) ||
	   (abs(ImgOut->biHeight) != CIF_HEIGHT && abs(ImgOut->biHeight) != QCIF_HEIGHT))
       return (SvErrorBadImageSize);
     }
   }

   return(NoErrors);
}


/*
** Name:    SvGetCompressSize
** Purpose:
**
*/
SvStatus_t SvGetCompressSize (SvHandle_t Svh, int *MaxSize)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if (!MaxSize)
     return (SvErrorBadPointer);

   /*
   ** We are being extra cautious here, it would reflect poorly on the JPEG 
   ** commitee is the compressed bitstream was so big
   */
   *MaxSize = 2 * Info->InputFormat.biWidth * abs(Info->InputFormat.biHeight);

   return(NoErrors);
}



#ifdef JPEG_SUPPORT
/*
** Name:     SvGetQuality
** Purpose:
**
*/
SvStatus_t SvGetQuality (SvHandle_t Svh, int *Quality)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if (!Quality)
     return (SvErrorBadPointer);

   *Quality = Info->jcomp->Quality;

   return (NoErrors);
}
#endif /* JPEG_SUPPORT */

#ifdef JPEG_SUPPORT
/*
** Name:    SvSetQuality
** Purpose: 
**
*/
SvStatus_t SvSetQuality (SvHandle_t Svh, int Quality)
{
   int stat,ConvertedQuality;
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if ((Quality < 0) || (Quality > 10000))
     return (SvErrorValue);

   Info->jcomp->Quality = Quality;
   ConvertedQuality = 10000 - Quality;
   if (ConvertedQuality < MIN_QUAL)
     ConvertedQuality = MIN_QUAL;
   stat = sv_MakeQTables (ConvertedQuality, Info);
   return (stat);
}
#endif /* JPEG_SUPPORT */

#ifdef JPEG_SUPPORT
/*
** Name:     SvGetCompQTables
** Purpose: 
**
*/
SvStatus_t SvGetCompQTables (SvHandle_t Svh, SvQuantTables_t *Qt)
{
   register int i;
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if (!Info->jcomp->CompressStarted)
     return (SvErrorCompNotStarted);

   if (!Qt)
     return (SvErrorBadPointer);

   if ((!Qt->c1) || (!Qt->c2) || (!Qt->c3)) 
     return (SvErrorBadPointer);

   for (i = 0 ; i < 64 ; i++) {
     register int zz = ZigZag[i];
     Qt->c1[i] = (Info->jcomp->Qt[0])->ival[zz];
     Qt->c2[i] = (Info->jcomp->Qt[1])->ival[zz];
     Qt->c3[i] = (Info->jcomp->Qt[1])->ival[zz];
   }

   return(NoErrors);
}
#endif /* JPEG_SUPPORT */

/*
** Name:     SvGetCodecInfo
** Purpose:  Get info about the codec & the data
**
** Args:     Svh = handle to software codec's Info structure.
**
** XXX - does not work for compression, this has to wait for the
**       decompressor to use SvCodecInfo_t struct for this to work
*/
SvStatus_t SvGetInfo (SvHandle_t Svh, SV_INFO_t *lpinfo, BITMAPINFOHEADER *Bmh)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return(SvErrorCodecHandle);

   lpinfo->Version 	     = SLIB_VERSION;
   switch (Info->mode)
   {
#ifdef JPEG_SUPPORT
     case SV_JPEG_ENCODE:
           lpinfo->CodecStarted = Info->jcomp->CompressStarted;
           break;
     case SV_JPEG_DECODE:
           lpinfo->CodecStarted = Info->jdcmp->DecompressStarted;
           break;
#endif /* JPEG_SUPPORT */
     default:
           lpinfo->CodecStarted = 0;
           break;
   }
   lpinfo->NumOperations     = Info->NumOperations;

   *Bmh = Info->InputFormat;
   return(NoErrors);
}



/*
** Name:     sv_GetComponentPointers
** Purpose:  Given a pointer to an image and its size,
**           return pointers to the individual image components
**
** Args:     pixels   = number of pixels in a line.
**           lines    = number of lines in image.
**           Image    = Pointer to start of combined image data
**           MaxLen   = Size of image data in bytes
**           comp1/2/3= pointers to pointers to individual components
*/
static SvStatus_t sv_GetYUVComponentPointers(int biCompression, 
		    int pixels, int lines, u_char *Image, 
		    int MaxLen, u_char **comp1, u_char **comp2, u_char **comp3)
{
  u_int sz1,sz2,sz3,maxlen;

  sz1 = pixels * lines; 
  sz2 = sz3 = (IsYUV411Sep(biCompression)) ? (sz1 / 4) : 
              ((IsYUV1611Sep(biCompression)) ? (pixels * lines / 16) 
                                             : (sz1 / 2));
  maxlen = (MaxLen > 0) ? (u_int) MaxLen : 0 ;
  if (biCompression == BI_DECGRAYDIB) {
    if (sz1 > maxlen)
      return(SvErrorBadImageSize);
    *comp1 = Image;
    *comp2 = NULL;
    *comp3 = NULL;
  }
  else {
    if ((sz1+sz2+sz3) > maxlen)
      return(SvErrorBadImageSize);
    *comp1 = Image;
    *comp2 = Image + sz1;
    *comp3 = Image + sz1 + sz2;
  }
  return(SvErrorNone);
}



#ifdef JPEG_SUPPORT
/*
** Name:     sv_JpegExtractBlocks 
** Purpose:  
**
** Note:    If we did our job right, memory for all global structures should 
**	    have been allocated by the upper layers, we do not waste time 
**	    checking for NULL pointers at this point
**
*/
static SvStatus_t sv_JpegExtractBlocks (SvCodecInfo_t *Info, u_char *RawImage)
{
  SvJpegCompressInfo_t *CInfo = (SvJpegCompressInfo_t *)Info->jcomp;
  int size = Info->Width * Info->Height;
  u_char *TempImage;
  SvStatus_t stat;

  if (IsYUV422Packed(Info->InputFormat.biCompression))
    /*
    ** This will extract chunks of 64 bytes (8x8 blocks) from the uncompressed
    ** 4:2:2 interleaved input video frame and place them in three separate 
    ** linear arrays for later processing.
    **	XXX - should also do level shifting in this routine
    ** 
    */
    ScConvert422iTo422sf_C(RawImage, 16, 
			     (float *)(CInfo->BlkBuffer),
			     (float *)(CInfo->BlkBuffer + size),
			     (float *)(CInfo->BlkBuffer + size + size/2),
			     Info->Width, 
			     Info->Height);

  else if (IsYUV422Sep(Info->InputFormat.biCompression))
    /*
    ** Same but RawImage is not interleaved. Three components are sequential.
    */
    ScConvertSep422ToBlockYUV (RawImage, 16, 
				(float *)(CInfo->BlkBuffer),
				(float *)(CInfo->BlkBuffer + size),
				(float *)(CInfo->BlkBuffer + size + size/2),
				Info->Width, 
				Info->Height);

  else if (Info->InputFormat.biCompression == BI_DECGRAYDIB)
    /*
    ** Grayscale: one component
    */
    ScConvertGrayToBlock (RawImage, 
                          8, 
			  (float *)(CInfo->BlkBuffer),
			  Info->Width, 
			  Info->Height);

  if ((Info->InputFormat.biCompression == BI_RGB) ||
      (Info->InputFormat.biCompression == BI_DECXIMAGEDIB) ||
      (ValidateBI_BITFIELDS(&Info->InputFormat) != InvalidBI_BITFIELDS))
  {
      TempImage = (u_char *)ScPaMalloc (3 * Info->Width * Info->Height);

      if (TempImage == NULL)
	 return(ScErrorMemory);

      stat = ScRgbInterlToYuvInterl(
		 &Info->InputFormat,
		 (int)Info->Width, 
		 (int)Info->Height,
		 RawImage, 
		 (u_short *) TempImage);
      RETURN_ON_ERROR (stat);

      ScConvert422iTo422sf_C(
          TempImage, 
          16,
	  (float *)(CInfo->BlkBuffer),
	  (float *)(CInfo->BlkBuffer + size),
	  (float *)(CInfo->BlkBuffer + size + size/2),
	  Info->Width,
	  Info->Height);

     ScPaFree(TempImage);
  }

  return (NoErrors);
}
#endif /* JPEG_SUPPORT */

#ifdef JPEG_SUPPORT
/*
** Name:    SvSetQuantMode
** Purpose: Used only in the "Q Conversion" program "jpegconvert" to
**          set a flag in the comp & decomp info structures that causes
**          the quantization algorithm to use the new or old versions
**          of JPEG quantization.
**
*/
SvStatus_t SvSetQuantMode (SvHandle_t Svh, int QuantMode)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if ((QuantMode != SV_JPEG_QUANT_OLD) && (QuantMode != SV_JPEG_QUANT_NEW))
     return (SvErrorValue);

   if (Info->jdcmp)
     Info->jdcmp->QuantMode = QuantMode;
   if (Info->jcomp)
     Info->jcomp->QuantMode = QuantMode;

   return (NoErrors);
}
#endif /* JPEG_SUPPORT */

/*
** Name: SvSetParamBoolean()
** Desc: Generic call used to set specific BOOLEAN (TRUE or FALSE) parameters
**       of the CODEC.
*/
SvStatus_t SvSetParamBoolean(SvHandle_t Svh, SvParameter_t param, 
                                             ScBoolean_t value)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(SvErrorCodecHandle);
  _SlibDebug(_VERBOSE_, printf("SvSetParamBoolean()\n") );
  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           sv_MpegSetParamBoolean(Svh, param, value);
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           svH261SetParamBoolean(Svh, param, value);
           break;
#endif /* H263_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           svH263SetParamBoolean(Svh, param, value);
           break;
#endif /* H263_SUPPORT */
    default:
           return(SvErrorCodecType);
  }
  return(NoErrors);
}

/*
** Name: SvSetParamInt()
** Desc: Generic call used to set specific INTEGER (qword) parameters
**       of the CODEC.
*/
SvStatus_t SvSetParamInt(SvHandle_t Svh, SvParameter_t param, qword value)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(SvErrorCodecHandle);
  _SlibDebug(_VERBOSE_, printf("SvSetParamInt()\n") );
  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           sv_MpegSetParamInt(Svh, param, value);
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           svH261SetParamInt(Svh, param, value);
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           svH263SetParamInt(Svh, param, value);
           break;
#endif /* H263_SUPPORT */
    default:
           return(SvErrorCodecType);
  }
  return(NoErrors);
}

/*
** Name: SvSetParamFloat()
** Desc: Generic call used to set specific FLOAT parameters of the CODEC.
*/
SvStatus_t SvSetParamFloat(SvHandle_t Svh, SvParameter_t param, float value)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(SvErrorCodecHandle);
  _SlibDebug(_VERBOSE_, printf("SvSetParamFloat()\n") );
  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           sv_MpegSetParamFloat(Svh, param, value);
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           svH261SetParamFloat(Svh, param, value);
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           svH263SetParamFloat(Svh, param, value);
           break;
#endif /* H263_SUPPORT */
    default:
           return(SvErrorCodecType);
  }
  return(NoErrors);
}

/*
** Name: SvGetParamBoolean()
** Desc: Generic call used to get the setting of specific BOOLEAN (TRUE or FALSE)
**       parameters of the CODEC.
*/
ScBoolean_t SvGetParamBoolean(SvHandle_t Svh, SvParameter_t param)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(FALSE);
  switch (Info->mode)
  {
#ifdef JPEG_SUPPORT
    /* this code should be moved into JPEG codec: svJPEGGetParamBoolean()  */
    case SV_JPEG_DECODE:
    case SV_JPEG_ENCODE:
           switch (param)
           {
              case SV_PARAM_BITSTREAMING:
                    return(FALSE);  /* this is a frame-based codecs */
           }
           break;
#endif /* JPEG_SUPPORT */
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           return(sv_MpegGetParamBoolean(Svh, param));
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
    /* this code should be moved into H261 codec: svH261GetParamBoolean()  */
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           return(svH261GetParamBoolean(Svh, param));
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           return(svH263GetParamBoolean(Svh, param));
           break;
#endif /* H263_SUPPORT */
  }
  return(FALSE);
}

/*
** Name: SvGetParamInt()
** Desc: Generic call used to get the setting of specific INTEGER (qword)
**       parameters of the CODEC.
*/
qword SvGetParamInt(SvHandle_t Svh, SvParameter_t param)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(0);
  switch (Info->mode)
  {
#ifdef JPEG_SUPPORT
    /* this code should be moved into JPEG codec: svJPEGGetParamInt() */
    case SV_JPEG_DECODE:
    case SV_JPEG_ENCODE:
           switch (param)
           {
              case SV_PARAM_NATIVEFORMAT:
                    return(BI_YU16SEP);
           }
           break;
#endif /* JPEG_SUPPORT */
#ifdef H261_SUPPORT
    /* this code should be moved into H261 codec: svH261GetParamInt()  */
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           return(svH261GetParamInt(Svh, param));
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           return(svH263GetParamInt(Svh, param));
           break;
#endif /* H263_SUPPORT */
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           return(sv_MpegGetParamInt(Svh, param));
#endif /* MPEG_SUPPORT */
  }
  switch (param)
  {
     case SV_PARAM_FINALFORMAT:
           return(Info->OutputFormat.biCompression);
  }
  return(0);
}

/*
** Name: SvGetParamBoolean()
** Desc: Generic call used to get the setting of specific FLOAT
**       parameters of the CODEC.
*/
float SvGetParamFloat(SvHandle_t Svh, SvParameter_t param)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(0.0f);
  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           return(sv_MpegGetParamFloat(Svh, param));
#endif
#ifdef H261_SUPPORT
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           return(svH261GetParamFloat(Svh, param));
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           return(svH263GetParamFloat(Svh, param));
#endif /* H263_SUPPORT */
  }
  return(0.0f);
}

/*
** Name:     sv_copy_bmh
** Purpose:  Copy a BITMAPINFOHEADER struct.  For now, it only knows about the 
**           extra DWORD masks at the end of BI_BITFIELDS bitmapinfoheaders.
**           Otherwise, it treats others (such as 8 bit rgb, or jpeg) the
**           same as a vanilla bitmapinfoheader.
*/
static void sv_copy_bmh (
    BITMAPINFOHEADER *ImgFrom, 
    BITMAPINFOHEADER *ImgTo)
{
    *ImgTo = *ImgFrom;

    if (ImgFrom->biCompression == BI_BITFIELDS)
        bcopy(ImgFrom + 1, ImgTo + 1, 3*sizeof(DWORD));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sv_proto.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sv_prototypes.h,v $
 * Revision 1.1.9.6  1996/10/28  17:32:26  Hans_Graves
 * 	Changed sv_MpegGet/SetParamInt() to use qwords.
 * 	[1996/10/28  17:07:11  Hans_Graves]
 *
 * Revision 1.1.9.5  1996/10/02  18:42:52  Hans_Graves
 * 	Added InputFourCC to sv_MpegEncodeFrameInOrder().
 * 	[1996/10/02  18:34:36  Hans_Graves]
 * 
 * Revision 1.1.9.4  1996/07/19  02:11:09  Hans_Graves
 * 	Change 422i motion recon function protos.
 * 	[1996/07/19  01:27:59  Hans_Graves]
 * 
 * Revision 1.1.9.3  1996/05/24  22:21:42  Hans_Graves
 * 	Added MPEG 422i protos
 * 	[1996/05/24  21:55:51  Hans_Graves]
 * 
 * Revision 1.1.9.2  1996/05/07  19:56:10  Hans_Graves
 * 	Added HUFF_SUPPORT
 * 	[1996/05/07  17:24:56  Hans_Graves]
 * 
 * Revision 1.1.7.7  1996/04/10  21:47:39  Hans_Graves
 * 	Added Set/GetParamBoolean()
 * 	[1996/04/10  20:39:51  Hans_Graves]
 * 
 * Revision 1.1.7.6  1996/04/09  20:50:35  Karen_Dintino
 * 	Adding WIN32 support
 * 	[1996/04/09  20:47:45  Karen_Dintino]
 * 
 * Revision 1.1.7.5  1996/04/09  16:04:40  Hans_Graves
 * 	Fix protos for sv_MpegIDCTToFrame/AddToFrame()
 * 	[1996/04/09  16:03:24  Hans_Graves]
 * 
 * Revision 1.1.7.4  1996/04/04  23:35:05  Hans_Graves
 * 	Added protos for sv_MpegReconFieldBlock() and sv_MpegReconFrameBlock()
 * 	[1996/04/04  22:59:42  Hans_Graves]
 * 
 * Revision 1.1.7.3  1996/03/29  22:21:21  Hans_Graves
 * 	Added JPEG_SUPPORT ifdefs.
 * 	[1996/03/29  22:14:58  Hans_Graves]
 * 
 * 	Added protos for SvMpegIDCTToFrameP_S() and SvMpegIDCTAddToFrameP_S()
 * 	[1996/03/27  21:54:00  Hans_Graves]
 * 
 * Revision 1.1.7.2  1996/03/08  18:46:37  Hans_Graves
 * 	Added protos for new MPEG assembly
 * 	[1996/03/08  16:25:05  Hans_Graves]
 * 
 * Revision 1.1.4.5  1996/02/06  22:54:03  Hans_Graves
 * 	Added MpegGet/SetParam() prototypes
 * 	[1996/02/06  22:50:20  Hans_Graves]
 * 
 * Revision 1.1.4.4  1996/01/24  19:33:21  Hans_Graves
 * 	Changed DCT block for shorts to ints
 * 	[1996/01/24  18:13:05  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/01/08  16:41:29  Hans_Graves
 * 	Updated MPEG I and II prototypes for new decoder
 * 	[1996/01/08  15:47:45  Hans_Graves]
 * 
 * Revision 1.1.4.2  1995/12/07  19:31:35  Hans_Graves
 * 	Removed prototype for error()
 * 	[1995/12/07  19:20:55  Hans_Graves]
 * 
 * 	Added MPEG encoder prototypes
 * 	[1995/12/07  18:00:18  Hans_Graves]
 * 
 * Revision 1.1.2.16  1995/09/22  12:58:43  Bjorn_Engberg
 * 	Use MPEG_SUPPORT and H261_SUPPORT.
 * 	[1995/09/22  12:50:18  Bjorn_Engberg]
 * 
 * Revision 1.1.2.15  1995/09/11  20:36:34  Paul_Gauthier
 * 	Add version string to JPEG header as APP1 segment
 * 	[1995/09/11  20:35:13  Paul_Gauthier]
 * 
 * Revision 1.1.2.14  1995/08/15  19:13:57  Karen_Dintino
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.12 **}
 * 		{** Merge revision:	1.1.2.13 **}
 * 	{** End **}
 * 	fix reentrant problem
 * 	[1995/08/15  18:31:06  Karen_Dintino]
 * 
 * Revision 1.1.2.13  1995/08/14  19:40:28  Hans_Graves
 * 	Fixed H261 Init prototypes.
 * 	[1995/08/14  18:43:51  Hans_Graves]
 * 
 * Revision 1.1.2.12  1995/08/07  22:09:52  Hans_Graves
 * 	Added prototype for CrawlMotionEstimation()
 * 	[1995/08/07  22:09:31  Hans_Graves]
 * 
 * Revision 1.1.2.11  1995/08/04  16:32:28  Karen_Dintino
 * 	Change to SvStatus_t for some low level rtns
 * 	[1995/08/04  16:22:50  Karen_Dintino]
 * 
 * Revision 1.1.2.10  1995/08/03  18:02:07  Karen_Dintino
 * 	Encode/Decode routines need to return SvStatus_t
 * 	[1995/08/03  18:00:02  Karen_Dintino]
 * 
 * Revision 1.1.2.9  1995/08/02  15:27:00  Hans_Graves
 * 	Changed prototype for blockdiff16_C()
 * 	[1995/08/02  15:25:00  Hans_Graves]
 * 
 * Revision 1.1.2.8  1995/07/28  17:36:05  Hans_Graves
 * 	Added prototype for sv_CompressH261()
 * 	[1995/07/28  17:29:00  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/07/26  17:48:57  Hans_Graves
 * 	Added prototype for sv_DecompressH261()
 * 	[1995/07/26  17:47:19  Hans_Graves]
 * 
 * Revision 1.1.2.6  1995/07/17  16:12:17  Hans_Graves
 * 	Added H261 prototypes.
 * 	[1995/07/17  15:54:27  Hans_Graves]
 * 
 * Revision 1.1.2.5  1995/06/27  13:54:27  Hans_Graves
 * 	Removed prototype for sv_RdRunLevel().
 * 	[1995/06/27  13:52:12  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/06/20  14:13:39  Karen_Dintino
 * 	Separate H.261 prototypes
 * 	[1995/06/20  13:29:25  Karen_Dintino]
 * 
 * Revision 1.1.2.3  1995/06/19  20:31:18  Karen_Dintino
 * 	Added support for H.261
 * 	[1995/06/19  20:14:23  Karen_Dintino]
 * 
 * Revision 1.1.2.2  1995/05/31  18:10:24  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:51:00  Hans_Graves]
 * 
 * Revision 1.1.2.8  1994/12/14  19:09:54  Paul_Gauthier
 * 	Removed sv_gentoc.c from SLIB
 * 	[1994/12/14  19:07:29  Paul_Gauthier]
 * 
 * Revision 1.1.2.7  1994/12/12  15:39:31  Paul_Gauthier
 * 	Merge changes from other SLIB versions
 * 	[1994/12/12  15:35:04  Paul_Gauthier]
 * 
 * Revision 1.1.2.6  1994/11/09  21:33:12  Paul_Gauthier
 * 	Optimizations
 * 	[1994/11/09  15:31:22  Paul_Gauthier]
 * 
 * Revision 1.1.2.3  1994/10/13  20:34:53  Paul_Gauthier
 * 	MPEG cleanup
 * 	[1994/10/12  21:08:55  Paul_Gauthier]
 * 
 * Revision 1.1.2.2  1994/10/07  14:58:16  Paul_Gauthier
 * 	SLIB v3.0 incl. MPEG Decode
 * 	[1994/10/07  13:57:07  Paul_Gauthier]
 * 
 * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0 
** 
** FILE NAME:   
** MODULE NAME: 
**
** MODULE DESCRIPTION: 
** 
** DESIGN OVERVIEW: 
** 
**--
*/
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1994                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*--------------------------------------------------------------------------
 * SLIB Internals Prototype file (externals are in SV.h)
 *
 * Modification History: sv_prototypes.h
 *
 *      29-Jul-94  PSG  Created
 *---------------------------------------------------------------------------*/

#ifndef _SV_PROTOTYPES_H
#define _SV_PROTOTYPES_H

extern void DumpBlock(char *title, short *blk);

/*---------------------------------------------------------------------------*/
/*                     Compress/Decompress Codec Prototypes                  */
/*---------------------------------------------------------------------------*/

/*
** sv_codec_api.c
*/
static SvStatus_t sv_GetYUVComponentPointers(int, int, int, u_char *, int,
					     u_char **, u_char **, u_char **);
static SvStatus_t sv_JpegExtractBlocks (SvCodecInfo_t *, u_char *);

#ifdef JPEG_SUPPORT
/*
** sv_jpeg_decode.c
*/
static void sv_FillBitBuffer (int);
static SvStatus_t sv_ProcessRestart (SvCodecInfo_t *);
extern SvStatus_t sv_DecodeJpeg (SvCodecInfo_t *);
extern void sv_ReInitJpegDecoder (SvCodecInfo_t *);

/*
** sv_jpeg_encode.c
*/
extern void WriteJpegData(char *, int, u_char **);
extern void FlushBytes (u_char **);
static void EmitBits(u_short, int);
static void FlushBits (void);
extern void sv_EncodeOneBlock (SvRLE_t *, SvHt_t *, SvHt_t *);
extern void sv_HuffEncoderInit (SvCodecInfo_t *);
extern void EmitRestart (SvJpegCompressInfo_t *);
extern void sv_HuffEncoderTerm (u_char **);


/*
** sv_jpeg_format.c
*/
extern SvStatus_t sv_AddJpegHeader (SvHandle_t, u_char *, int, int *);
extern SvStatus_t sv_AddJpegTrailer (SvHandle_t, u_char *, int, int *);
extern SvStatus_t sv_FormatJpegData (SvHandle_t, char *, char *, int, int *);
static SvStatus_t sv_AddCompSpecs (int, int, int, int, char **, char *); 
static SvStatus_t sv_AddEntropyData (SvCodecInfo_t *, char *, char **, char *);
static SvStatus_t sv_AddFrame (SvCodecInfo_t *, char *, char **, char *);
static SvStatus_t sv_AddFrameHeader (SvCodecInfo_t *, char **, char *);
static SvStatus_t sv_AddMarker ();
static SvStatus_t sv_AddScanHeader (SvCodecInfo_t *, char **, char *);
static SvStatus_t sv_AddSLIBHeader (char **, char *);
static SvStatus_t sv_Write16bits (short, char **, char *);
static SvStatus_t sv_Write8bits (int, char **, char *);
static SvStatus_t sv_AddMMSVer (char **, char *);

/*
** sv_jpeg_init.c
*/
static SvStatus_t sv_InitEncoderStruct (SvCodecInfo_t *);
static SvStatus_t sv_InitDecoderStruct (SvCodecInfo_t *);
static SvStatus_t sv_InitHDecoder (SvCodecInfo_t *);
extern SvStatus_t sv_InitJpegEncoder (SvCodecInfo_t *);
extern SvStatus_t sv_InitJpegDecoder (SvCodecInfo_t *);
extern SvStatus_t sv_InitInfo (SvCodecInfo_t *);
extern void sv_copyHTable (SvHt_t *, SvHt_t *);
extern SvStatus_t sv_CheckChroma (SvCodecInfo_t *);
static int JroundUp (int, int);
/*
** sv_jpeg_tables.c
*/
extern SvStatus_t sv_MakeQTables (int, SvCodecInfo_t *);
extern SvStatus_t sv_MakeHEncodingTables (SvCodecInfo_t *);
extern SvStatus_t sv_MakeHDecodingTables (SvCodecInfo_t *);
extern SvStatus_t sv_MakeEncoderBlkTable (SvCodecInfo_t *);
extern SvStatus_t sv_MakeDecoderBlkTable (SvCodecInfo_t *);
static void sv_MakeHCodeTables (SvHt_t *, char *, u_short *, u_int *);
extern SvStatus_t sv_ConvertQTable (SvCodecInfo_t *, SvQuantTables_t *);
extern SvStatus_t sv_LoadDefaultHTable (SvCodecInfo_t *);

/*
** sv_jpeg_parse.c
*/
static u_int sv_GetShort (SvCodecInfo_t *);
static int sv_GetNextMarker (void);
static void sv_ProcessBogusMarker (SvCodecInfo_t *);
static SvStatus_t sv_ProcessDHT (SvCodecInfo_t *);
static SvStatus_t sv_ProcessDQT (SvCodecInfo_t *);
static SvStatus_t sv_ProcessDRI (SvCodecInfo_t *);
static SvStatus_t sv_ProcessAPP0 (SvCodecInfo_t *);
static SvStatus_t sv_ProcessSOF (SvCodecInfo_t *, int);
static SvStatus_t sv_ProcessSOS (SvCodecInfo_t *);
static SvStatus_t sv_ProcessSOI (SvCodecInfo_t *);
/*static int sv_ProcessTables (SvCodecInfo_t *);*/
static SvStatus_t sv_ParseFileHeader (SvCodecInfo_t *);
extern SvStatus_t sv_ParseScanHeader (SvCodecInfo_t *);
extern SvStatus_t sv_ParseFrame (u_char *, int, SvCodecInfo_t *);
#endif /* JPEG_SUPPORT */

#ifdef MPEG_SUPPORT
/*---------------------------------------------------------------------------*/
/*                              MPEG Prototypes                              */
/*---------------------------------------------------------------------------*/
/*
** sv_mpeg_common.c
*/
extern SvStatus_t sv_MpegSetParamBoolean(SvHandle_t Svh, SvParameter_t param,
                                                  ScBoolean_t value);
extern SvStatus_t sv_MpegSetParamInt(SvHandle_t Svh, SvParameter_t param,
                                qword value);
extern SvStatus_t sv_MpegSetParamFloat(SvHandle_t Svh, SvParameter_t param,
                                float value);
extern ScBoolean_t sv_MpegGetParamBoolean(SvHandle_t Svh, SvParameter_t param);
extern qword sv_MpegGetParamInt(SvHandle_t Svh, SvParameter_t param);
extern float sv_MpegGetParamFloat(SvHandle_t Svh, SvParameter_t param);

/*
** sv_mpeg_parse.c
*/
extern SvStatus_t sv_MpegGetHeader(SvMpegDecompressInfo_t *MpegInfo,
                                   ScBitstream_t *bs);
extern int sv_MpegGetSliceHdr(SvMpegDecompressInfo_t *MpegInfo,
                              ScBitstream_t *bs,
                              SvMpegLayer_t *layer);
extern SvStatus_t sv_MpegGetImageInfo(int fd, SvImageInfo_t *iminfo);
extern SvStatus_t sv_MpegFindNextPicture(SvCodecInfo_t *Info,
                                         SvPictureInfo_t *PictureInfo);

/*
** sv_mpeg_decode.c
*/
extern SvStatus_t sv_MpegInitDecoder (SvCodecInfo_t *Info);
extern SvStatus_t sv_MpegFreeDecoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_MpegDecompressFrame(SvCodecInfo_t *, u_char *, u_char **);

/*
** sv_mpeg_block.c
*/
extern ScBoolean_t sv_MpegGetIntraBlock(
                          ScBitstream_t *bs, SvMpegLayer_t *layer, int comp,
                          int *dc_dct_pred);
extern ScBoolean_t sv_MpegGetInterBlock(SvMpegDecompressInfo_t *MpegInfo,
                          ScBitstream_t *bs, SvMpegLayer_t *layer, int comp);
extern ScBoolean_t sv_Mpeg2GetIntraBlock(SvMpegDecompressInfo_t *MpegInfo,
                           ScBitstream_t *bs, SvMpegLayer_t *layer, int comp,
                           int *dc_dct_pred);
extern ScBoolean_t sv_Mpeg2GetInterBlock(SvMpegDecompressInfo_t *MpegInfo,
                           ScBitstream_t *bs, SvMpegLayer_t *layer, int comp);

extern ScBoolean_t sv_MpegMotionVectors(ScBitstream_t *bs,
                            int PMV[2][2][2],
                            int dmvector[2], int mv_field_sel[2][2],
                            int s, int mv_count, int mv_format,
                            int h_r_size, int v_r_size, int dmv, int mvscale);
extern ScBoolean_t sv_MpegMotionVector(ScBitstream_t *bs,
                                int *PMV, int *dmvector,
                                int h_r_size, int v_r_size, 
                                int dmv, int mvscale, int full_pel_vector);
extern void sv_MpegCalcDMV(SvMpegDecompressInfo_t *MpegInfo,
                           int DMV[][2], int *dmvector, int mvx, int mvy);
extern int sv_MpegGetDClum_C(ScBitString_t bits, unsigned int *bitsleft);
extern int sv_MpegGetDCchrom_C(ScBitString_t bits, unsigned int *bitsleft);

/*
** sv_mpeg_block2.s
*/
extern void sv_MpegClearBlock_S(int *block);
extern int sv_MpegInterHuffToDCT_S(int *dctblk, unsigned int zzpos, 
                        ScBitString_t bits, unsigned int *pbitsleft,
                        int quant_scale, int *quant_matrix);
extern int sv_MpegIntraHuffToDCT_S(int *dctblk, unsigned int comp, 
                        ScBitString_t bits, unsigned int *pbitsleft,
                        int quant_scale, int *quant_matrix,
                        int *dc_dct_pred);
extern int sv_MpegGetDClum_S(ScBitString_t  bits, unsigned int  *bitsleft);
extern int sv_MpegGetDCchrom_S(ScBitString_t bits, unsigned int *bitsleft);


/*
** sv_mpeg_recon.c
*/
extern void sv_MpegReconstruct(SvMpegDecompressInfo_t *MpegInfo,
                       unsigned char **newframe, int bx, int by,
                       int mb_type, int motion_type, int PMV[2][2][2],
                       int mv_field_sel[2][2], int dmvector[2], int stwtype);
extern void sv_MpegReconFieldBlock(int chroma,
                  unsigned char *src[], int sfield,
                  unsigned char *dst[], int dfield, int lx, int lx2,
                  int w, int h, int x, int y, int dx, int dy, int addflag);
extern void sv_MpegReconFrameBlock(int chroma,
                  unsigned char *src[], unsigned char *dst[], int lx, int lx2,
                  int w, int h, int x, int y, int dx, int dy, int addflag);


/*
** sv_mpeg_getmb.c
*/
extern int sv_MpegGetMBtype(SvMpegDecompressInfo_t *MpegInfo,
                            ScBitstream_t *bs, SvMpegLayer_t *layer);
extern int sv_MpegGetIMBtype(SvMpegDecompressInfo_t *MpegInfo,
                             ScBitstream_t *bs);
extern int sv_MpegGetPMBtype(SvMpegDecompressInfo_t *MpegInfo,
                             ScBitstream_t *bs);
extern int sv_MpegGetBMBtype(SvMpegDecompressInfo_t *MpegInfo,
                             ScBitstream_t *bs);
extern int sv_MpegGetDMBtype(SvMpegDecompressInfo_t *MpegInfo,
                             ScBitstream_t *bs);
extern int sv_MpegGetSpIMBtype(SvMpegDecompressInfo_t *MpegInfo,
                             ScBitstream_t *bs);
extern int sv_MpegGetSpPMBtype(SvMpegDecompressInfo_t *MpegInfo,
                               ScBitstream_t *bs);
extern int sv_MpegGetSpBMBtype(SvMpegDecompressInfo_t *MpegInfo,
                               ScBitstream_t *bs);
extern int sv_MpegGetSNRMBtype(SvMpegDecompressInfo_t *MpegInfo,
                               ScBitstream_t *bs);

extern int sv_MpegGetCBP(ScBitstream_t *bs);

/*
** sv_mpeg_422recon.c
*/
void sv_CopyCBP_C(int *cpbdata, unsigned char *np, unsigned int w);
void sv_CopyCBPf_C(int *cpbdata, unsigned char *np, unsigned int w);
void sv_MpegFrameCopy411to422i(unsigned char *refframe,
                              unsigned char *newframe,
                              int x, int y, unsigned int w,
                              int dx, int dy, unsigned char *tmpbuf);
void sv_MpegFrameMC411to422i(int *block, unsigned int cbp,
                    unsigned char *refframe, unsigned char *newframe,
                    int x, int y, unsigned int w, int dx, int dy,
                    ScBoolean_t fdct, unsigned char *tmpbuf);
void sv_MpegDFrameMC411to422i(int *block, unsigned int cbp,
                    unsigned char *brefframe, unsigned char *frefframe,
                    unsigned char *newframe,
                    int x, int y, unsigned int w,
                    int bdx, int bdy, int fdx, int fdy, ScBoolean_t fdct,
                    unsigned char *tmpbuf);
void sv_MpegDFieldMC411to422i(int *block, unsigned int cbp,
                    unsigned char *refframe, int rfield0, int rfield1,
                    unsigned char *newframe, int x, int y, unsigned int w,
                    int dx0, int dy0, int dx1, int dy1, ScBoolean_t fdct,
                    unsigned char *tmpbuf);
void sv_MpegQFieldMC411to422i(int *blocks, unsigned int cbp,
                unsigned char *bframe, int bfield0, int bfield1,
                unsigned char *fframe, int ffield0, int ffield1,
                unsigned char *newframe, int x, int y, unsigned int w,
                int bdx0, int bdy0, int bdx1, int bdy1,
                int fdx0, int fdy0, int fdx1, int fdy1,
                ScBoolean_t fdct, unsigned char *tmpbuf);

/*
** sv_mpeg_422reconcbp.s
*/
void sv_CopyCBP_S(int *cpbdata, unsigned char *np, unsigned int w);
void sv_CopyCBPf_S(int *cpbdata, unsigned char *np, unsigned int w);

/*
** sv_mpeg_idct.c
*/
void sv_MpegIDCTToFrame_C(int *inbuf, unsigned char *rfp, int incr);
void sv_MpegIDCTAddToFrame_C(int *inbuf, unsigned char *rfp, int incr);
void sv_MpegIDCTToFrame2_C(int *inbuf, unsigned char *rfp, int rinc,
                                       unsigned char *ffp, int finc, int comp);
void sv_MpegIDCTAddToFrame2_C(int *inbuf, unsigned char *rfp, int rinc,
                                       unsigned char *ffp, int finc, int comp);

/*
** sv_mpeg_idct2.s
*/
void sv_MpegIDCTToFrame_S(int *inbuf, unsigned char *rfp, int incr);
void sv_MpegIDCTAddToFrame_S(int *inbuf, unsigned char *rfp, int incr);

/*
** sv_mpeg_idct3.s
*/
void sv_MpegIDCTToFrameP_S(int *inbuf, unsigned char *rfp, int incr);
void sv_MpegIDCTAddToFrameP_S(int *inbuf, unsigned char *rfp, int incr);

/*
** sv_mpeg_init.c
*/
extern SvStatus_t sv_MpegInitEncoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_MpegFreeEncoder(SvCodecInfo_t *Info);

/*
** sv_mpeg_encode.c
*/
extern SvStatus_t sv_MpegEncoderBegin(SvCodecInfo_t *Info);
extern SvStatus_t sv_MpegEncodeFrame(SvCodecInfo_t *Info, 
                                     unsigned char *InputImage);
extern SvStatus_t sv_MpegEncodeFrameInOrder(SvCodecInfo_t *Info,
                                     unsigned char *InputImage,
                                     unsigned int InputFourCC);
extern SvStatus_t sv_MpegEncoderEnd(SvCodecInfo_t *Info);

/*
** sv_mpeg_putpic.c
*/
extern void sv_MpegPutPict(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *BS,
                           unsigned char *frame);

/*
** sv_mpeg_puthdr.c
*/
extern void sv_MpegPutSeqHdr(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *bs);
extern void sv_MpegPutSeqExt(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *bs);
extern void sv_MpegPutSeqDispExt(SvMpegCompressInfo_t *MpegInfo,
                                           ScBitstream_t *bs);
extern void sv_MpegPutUserData(ScBitstream_t *bs, char *userdata);
extern void sv_MpegPutGOPHdr(ScBitstream_t *bs, float frame_rate, int tco,
                       int frame, int closed_gop);
extern void sv_MpegPutSeqEnd(ScBitstream_t *bs);

/*
** sv_mpeg_motion.c
*/
extern void sv_MpegMotionEstimation(SvMpegCompressInfo_t *MpegInfo, 
                       unsigned char *oldorg, unsigned char *neworg,
                       unsigned char *oldref, unsigned char *newref,
                       unsigned char *cur, unsigned char *curref,
                       int sxf, int syf, int sxb, int syb,
                       struct mbinfo *mbi, int secondfield, int ipflag);

/*
** sv_mpeg_quantize.c
*/
int sv_MpegIntraQuant(short *src, short *dst, int dc_prec,
                unsigned char *quant_mat, int mquant, int mpeg1);
int sv_MpegNonIntraQuant(short *src, short *dst,
                    unsigned char *quant_mat, int mquant, int mpeg1);
void sv_MpegIntraInvQuant(short *src, short *dst, int dc_prec,
                  unsigned char *quant_mat, int mquant, int mpeg1);
void sv_MpegNonIntraInvQuant(short *src, short *dst,
                      unsigned char *quant_mat, int mquant, int mpeg1);

/*
** sv_mpeg_transfrm.c
*/
void sv_MpegTransform(SvMpegCompressInfo_t *MpegInfo,
               unsigned char *pred[], unsigned char *cur[],
               struct mbinfo *mbi, short blocks[][64]);
void sv_MpegInvTransform(SvMpegCompressInfo_t *MpegInfo,
                unsigned char *pred[], unsigned char *cur[],
                struct mbinfo *mbi,short blocks[][64]);
void sv_MpegDCTtypeEstimation(SvMpegCompressInfo_t *MpegInfo,
                         unsigned char *pred, unsigned char *cur,
                         struct mbinfo *mbi);

/*
** sv_mpeg_predict.c
*/
extern void sv_MpegPredict(SvMpegCompressInfo_t *MpegInfo,
             unsigned char *reff[], unsigned char *refb[],
             unsigned char *cur[3], int secondfield, struct mbinfo *mbi);

/*
** sv_mpeg_ratectl.c
*/
extern void rc_init_seq(SvMpegCompressInfo_t *MpegInfo);
extern void rc_init_GOP(SvMpegCompressInfo_t *MpegInfo, int np, int nb);
extern void rc_init_pict(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *bs,
                         unsigned char *frame);
extern void rc_update_pict(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *bs);
extern int rc_start_mb(SvMpegCompressInfo_t *MpegInfo);
extern int rc_calc_mquant(SvMpegCompressInfo_t *MpegInfo,  ScBitstream_t *bs,
                         int j);
void sv_MpegVBVendofpic(ScBitstream_t *bs);
void sv_MpegVBVcalcdelay(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *bs);

#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
/*---------------------------------------------------------------------------*/
/*                             H.261 Prototypes                              */
/*---------------------------------------------------------------------------*/

/*
** sv_h261_init.c
*/
extern SvStatus_t svH261Init(SvCodecInfo_t *Info);
extern SvStatus_t svH261CompressInit(SvCodecInfo_t *Info);

extern SvStatus_t svH261SetParamInt(SvHandle_t Svh, SvParameter_t param, qword value);
extern qword      svH261GetParamInt(SvHandle_t Svh, SvParameter_t param);
extern SvStatus_t svH261SetParamFloat(SvHandle_t Svh, SvParameter_t param, float value);
extern float      svH261GetParamFloat(SvHandle_t Svh, SvParameter_t param);
extern SvStatus_t svH261SetParamBoolean(SvHandle_t Svh, SvParameter_t param, ScBoolean_t value);
extern ScBoolean_t svH261GetParamBoolean(SvHandle_t Svh, SvParameter_t param);

/*
** sv_h261_decompress.c
*/
extern SvStatus_t svH261Decompress(SvCodecInfo_t *Info,
                             u_char *MultiBuf, u_char **ImagePtr);
extern SvStatus_t svH261DecompressFree(SvHandle_t Svh);

/*
** sv_h261_compress.c
*/
extern SvStatus_t svH261Compress(SvCodecInfo_t *Info, u_char *InputImage);
extern SvStatus_t svH261CompressFree(SvHandle_t Svh);
extern SvStatus_t SvSetFrameSkip (SvHandle_t Svh, int FrameSkip);
extern SvStatus_t SvSetFrameCount (SvHandle_t Svh, int FrameCount);
extern SvStatus_t SvSetSearchLimit (SvHandle_t Svh, int SearchLimit);

extern SvStatus_t SvSetImageType (SvHandle_t Svh, int ImageType);
extern SvStatus_t SvGetFrameNumber (SvHandle_t Svh, u_int *FrameNumber);


#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
/*---------------------------------------------------------------------------*/
/*                              H263 Prototypes                              */
/*---------------------------------------------------------------------------*/
/*
** sv_h263_common.c
*/
extern SvStatus_t svH263SetParamInt(SvHandle_t Svh, SvParameter_t param, qword value);
extern qword      svH263GetParamInt(SvHandle_t Svh, SvParameter_t param);
extern SvStatus_t svH263SetParamFloat(SvHandle_t Svh, SvParameter_t param, float value);
extern float      svH263GetParamFloat(SvHandle_t Svh, SvParameter_t param);
extern SvStatus_t svH263SetParamBoolean(SvHandle_t Svh, SvParameter_t param, ScBoolean_t value);
extern ScBoolean_t svH263GetParamBoolean(SvHandle_t Svh, SvParameter_t param);

/*
** sv_h263_decode.c
*/
extern SvStatus_t svH263InitDecompressor(SvCodecInfo_t *Info);
extern SvStatus_t svH263Decompress(SvCodecInfo_t *Info, u_char **ImagePtr);
extern SvStatus_t svH263FreeDecompressor(SvCodecInfo_t *Info);
/*
** sv_h263_encode.c
*/
extern SvStatus_t svH263InitCompressor(SvCodecInfo_t *Info);
extern SvStatus_t svH263Compress(SvCodecInfo_t *Info, u_char *ImagePtr);
extern SvStatus_t svH263FreeCompressor(SvCodecInfo_t *Info);

#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
/*---------------------------------------------------------------------------*/
/*                             Huff Prototypes                               */
/*---------------------------------------------------------------------------*/

/*
** sv_huff_encode.c
*/
extern SvStatus_t sv_HuffInitEncoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_HuffFreeEncoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_HuffEncodeFrame(SvCodecInfo_t *Info,
                                      unsigned char *InputImage);
extern SvStatus_t sv_HuffPutHeader(SvHuffInfo_t *HInfo, ScBitstream_t *bs);


/*
** sv_huff_decode.c
*/
extern SvStatus_t sv_HuffInitDecoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_HuffFreeDecoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_HuffDecodeFrame(SvCodecInfo_t *Info,
                                     unsigned char *OutputImage);
extern SvStatus_t sv_HuffGetHeader(SvHuffInfo_t *HInfo, ScBitstream_t *bs);

/*
** sv_huff_encode.c
*/

#endif /* HUFF_SUPPORT */

#endif /* _SV_PROTOTYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\video.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib_video.c,v $
 * Revision 1.1.6.13  1996/12/13  18:19:11  Hans_Graves
 * 	Added initialization of VideoPTimeBase.
 * 	[1996/12/13  18:07:51  Hans_Graves]
 *
 * Revision 1.1.6.12  1996/12/10  19:22:01  Hans_Graves
 * 	Made calculate video positions more accurate using slibFrameToTime100().
 * 	[1996/12/10  19:16:24  Hans_Graves]
 *
 * Revision 1.1.6.11  1996/11/18  23:07:40  Hans_Graves
 * 	Make use of presentation timestamps. Make seeking time-based.
 * 	[1996/11/18  22:48:05  Hans_Graves]
 *
 * Revision 1.1.6.10  1996/11/11  18:21:11  Hans_Graves
 * 	Moved setting of VideoMainStream to slib_api.c
 * 	[1996/11/11  18:02:11  Hans_Graves]
 *
 * Revision 1.1.6.9  1996/11/08  21:51:09  Hans_Graves
 * 	Added AC3 support. Better seperation of stream types.
 * 	[1996/11/08  21:28:03  Hans_Graves]
 *
 * Revision 1.1.6.8  1996/10/28  17:32:36  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:23:11  Hans_Graves]
 *
 * Revision 1.1.6.7  1996/10/12  17:18:59  Hans_Graves
 * 	Seperated TYPE_MPEG2_SYSTEMS into TRANSPORT and PROGRAM.
 * 	[1996/10/12  17:03:19  Hans_Graves]
 *
 * Revision 1.1.6.6  1996/09/29  22:19:45  Hans_Graves
 * 	Added Stride support. YUY2 fixups.
 * 	[1996/09/29  21:32:24  Hans_Graves]
 *
 * Revision 1.1.6.5  1996/09/25  19:16:51  Hans_Graves
 * 	Fix up support for YUY2. Add SLIB_INTERNAL define.
 * 	[1996/09/25  19:01:18  Hans_Graves]
 *
 * Revision 1.1.6.4  1996/09/23  18:04:06  Hans_Graves
 * 	Add reallocation of ScaleBuf if width/height changes.
 * 	[1996/09/23  17:58:27  Hans_Graves]
 *
 * Revision 1.1.6.3  1996/09/18  23:47:25  Hans_Graves
 * 	Added MPEG2 YUV 4:2:2 handling
 * 	[1996/09/18  22:04:18  Hans_Graves]
 *
 * Revision 1.1.6.2  1996/05/07  19:56:25  Hans_Graves
 * 	Added HUFF_SUPPORT.
 * 	[1996/05/07  17:21:23  Hans_Graves]
 *
 * Revision 1.1.4.7  1996/05/02  17:10:37  Hans_Graves
 * 	Reject a data type when header info is not found. Fixes MME-01234
 * 	[1996/05/02  17:09:53  Hans_Graves]
 *
 * Revision 1.1.4.6  1996/04/22  15:04:56  Hans_Graves
 * 	Renamed slibVerifyVideoParams() to slibValidateVideoParams()
 * 	[1996/04/22  14:44:29  Hans_Graves]
 *
 * Revision 1.1.4.5  1996/04/19  21:52:28  Hans_Graves
 * 	Fix Height and Width checking for H261
 * 	[1996/04/19  21:46:27  Hans_Graves]
 *
 * Revision 1.1.4.4  1996/04/01  19:07:58  Hans_Graves
 * 	And some error checking
 * 	[1996/04/01  19:04:42  Hans_Graves]
 *
 * Revision 1.1.4.3  1996/03/29  22:21:37  Hans_Graves
 * 	Added MPEG/JPEG/H261_SUPPORT ifdefs
 * 	[1996/03/29  21:57:04  Hans_Graves]
 *
 * 	Added MPEG-I Systems encoding support
 * 	[1996/03/27  21:56:00  Hans_Graves]
 *
 * Revision 1.1.4.2  1996/03/08  18:46:51  Hans_Graves
 * 	Added slibVerifyVideoParams()
 * 	[1996/03/08  18:36:51  Hans_Graves]
 *
 * Revision 1.1.2.12  1996/02/19  18:04:00  Hans_Graves
 * 	Fixed a number of MPEG related bugs
 * 	[1996/02/19  17:57:50  Hans_Graves]
 *
 * Revision 1.1.2.11  1996/02/07  23:24:01  Hans_Graves
 * 	Added SEEK_EXACT. Fixed most frame counting problems.
 * 	[1996/02/07  23:20:39  Hans_Graves]
 *
 * Revision 1.1.2.10  1996/02/02  17:36:06  Hans_Graves
 * 	Enhanced audio info. Cleaned up API
 * 	[1996/02/02  17:29:51  Hans_Graves]
 *
 * Revision 1.1.2.9  1996/01/30  22:23:10  Hans_Graves
 * 	Added AVI YUV support
 * 	[1996/01/30  22:21:45  Hans_Graves]
 *
 * Revision 1.1.2.8  1996/01/15  16:26:33  Hans_Graves
 * 	No video if SLIB_TYPE_MPEG1_AUDIO or SLIB_TYPE_WAVE
 * 	[1996/01/15  15:47:40  Hans_Graves]
 *
 * Revision 1.1.2.7  1996/01/11  16:17:36  Hans_Graves
 * 	Added MPEG II Systems decode support
 * 	[1996/01/11  16:12:41  Hans_Graves]
 *
 * Revision 1.1.2.6  1996/01/08  16:41:35  Hans_Graves
 * 	Added MPEG II decoding support
 * 	[1996/01/08  15:53:10  Hans_Graves]
 *
 * Revision 1.1.2.5  1995/12/08  20:01:24  Hans_Graves
 * 	Added H.261 compression support.
 * 	[1995/12/08  20:00:52  Hans_Graves]
 *
 * Revision 1.1.2.4  1995/12/07  19:31:37  Hans_Graves
 * 	Added JPEG Decoding and MPEG encoding support
 * 	[1995/12/07  18:30:12  Hans_Graves]
 *
 * Revision 1.1.2.3  1995/11/09  23:14:08  Hans_Graves
 * 	Added GetVideoTime()
 * 	[1995/11/09  23:09:19  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/11/06  18:47:57  Hans_Graves
 * 	First time under SLIB
 * 	[1995/11/06  18:36:05  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
#define _SLIBDEBUG_
*/

#define SLIB_INTERNAL
#include "slib.h"
#include "mpeg.h"
#include "h261.h"
#include "h263.h"
#include "jpeg.h"
#include "avi.h"

#ifdef _SLIBDEBUG_
#define _DEBUG_   1  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif

int slibCalcBits(unsigned dword fourcc, int currentbits)
{
  switch (fourcc)
  {
      case BI_DECMPEGDIB:
      case BI_DECH261DIB:
      case BI_MSH261DIB:
      case BI_DECH263DIB:
      case BI_MSH263DIB:
      case JPEG_DIB:
          return(24);
      case MJPG_DIB:
      case BI_YU12SEP:         /* YUV 4:1:1 Planar */
          return(24);
      case BI_DECYUVDIB:       /* YUV 4:2:2 Packed */
      case BI_YUY2:            /* YUV 4:2:2 Packed */
          return(16);
      case BI_YU16SEP:         /* YUV 4:2:2 Planar */
          return(24);
      case BI_YVU9SEP:         /* YUV 16:1:1 Planar */
          return(24);
  }
  return(currentbits);
}

static unsigned dword slibCalcImageSize(unsigned dword fourcc, int bits,
                              int width, int height)
{
  unsigned dword imagesize=0;
  if (width<0) width=-width;
  if (height<0) height=-height;
  switch (fourcc)
  {
      case BI_YVU9SEP:       /* YUV 16:1:1 Planar */
          imagesize = (width*height*5)/4;
          break;
      case BI_YU12SEP:       /* YUV 4:1:1 Planar */
          imagesize = (width*height*3)/2;
          break;
      case BI_DECYUVDIB:     /* YUV 4:2:2 Packed */
      case BI_YUY2:          /* YUV 4:2:2 Packed */
      case BI_YU16SEP:       /* YUV 4:2:2 Planar */
          imagesize = width*height*2;
          break;
#ifndef WIN32
      case BI_DECXIMAGEDIB:
          imagesize = width*height*(bits==24 ? 4 : 1);
          break;
#endif /* !WIN32 */
      case BI_RGB:
      case BI_BITFIELDS:
          imagesize = width*height*(bits/8);
          break;
      default:
          imagesize = width*height;
  }
  return(imagesize);
}

static dword slibFOURCCtoVideoType(dword *fourcc)
{
  switch (*fourcc)
  {
    case BI_DECH261DIB:
    case BI_MSH261DIB:
       *fourcc=BI_DECH261DIB;
       return(SLIB_TYPE_H261);
    case BI_DECH263DIB:
    case BI_MSH263DIB:
       *fourcc=BI_DECH263DIB;
       return(SLIB_TYPE_H263);
    case JPEG_DIB:
       return(SLIB_TYPE_JPEG);
    case MJPG_DIB:
       return(SLIB_TYPE_MJPG);
    case BI_DECYUVDIB: /* YUV 4:2:2 Packed */
    case BI_YUY2:      /* YUV 4:2:2 Packed */
    case BI_YU16SEP:   /* YUV 4:2:2 Planar */
    case BI_YU12SEP:   /* YUV 4:1:1 Planar */
    case BI_YVU9SEP:   /* YUV 16:1:1 Planar */
       return(SLIB_TYPE_YUV);
    default:
       _SlibDebug(_WARN_, printf("Unsupported AVI format\n") );
  }
  return(0);
}

static void slibUpdateVideoFrames(SlibInfo_t *Info)
{
#ifdef MPEG_SUPPORT
  if (Info->VideoLengthKnown==FALSE && slibDataOnPin(Info, SLIB_DATA_VIDEO) &&
           Info->FileSize>0 && Info->FileSize<Info->OverflowSize)
  {
    if (SlibTypeIsMPEGVideo(Info->Type))
    {
      dword frames = slibCountCodesOnPin(Info,
                                    slibGetPin(Info, SLIB_DATA_VIDEO),
                                    MPEG_PICTURE_START, 4, 0);
      if (Info->FramesPerSec)
        Info->VideoLength=slibFrameToTime(Info, frames);
      Info->VideoLengthKnown=TRUE;
    }
  }
#endif /* MPEG_SUPPORT */
}

void SlibUpdateVideoInfo(SlibInfo_t *Info)
{
  int inbpp=24, outbpp=24, compformat=0, dcmpformat=0;
  SlibTime_t ptime;
  _SlibDebug(_DEBUG_, printf("SlibUpdateVideoInfo()\n") );

  if (SlibTypeIsAudioOnly(Info->Type)) /* no video? */
    return;
  if (Info->Mode == SLIB_MODE_COMPRESS)
  {
    switch (Info->Type)
    {
#ifdef MPEG_SUPPORT
      case SLIB_TYPE_MPEG1_VIDEO:
      case SLIB_TYPE_MPEG2_VIDEO:
      case SLIB_TYPE_MPEG_SYSTEMS:
      case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
            compformat=BI_DECMPEGDIB;
            dcmpformat=BI_YU12SEP;
            Info->Width = SIF_WIDTH;
            Info->Height = SIF_HEIGHT;
            Info->FramesPerSec = 25.0F;
            Info->VideoBitRate = 1152000;
            break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SLIB_TYPE_H261:
      case SLIB_TYPE_RTP_H261:
            compformat=BI_DECH261DIB;
            dcmpformat=BI_YU12SEP;
            Info->Width = CIF_WIDTH;
            Info->Height = CIF_HEIGHT;
            Info->FramesPerSec = 15.0F;
            Info->VideoBitRate = 352000;
            break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
      case SLIB_TYPE_H263:
      case SLIB_TYPE_RTP_H263:
            compformat=BI_DECH263DIB;
            dcmpformat=BI_YU12SEP;
            Info->Width = CIF_WIDTH;
            Info->Height = CIF_HEIGHT;
            Info->FramesPerSec = 30.0F;
            Info->VideoBitRate = 0;
            break;
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
      case SLIB_TYPE_SHUFF:
            compformat=BI_DECHUFFDIB;
            dcmpformat=BI_YU12SEP;
            Info->Width = 320;
            Info->Height = 240;
            Info->FramesPerSec = 30.0F;
            Info->VideoBitRate = 0;
            break;
#endif /* HUFF_SUPPORT */
      default:
            break;
    }
  }
  else if (Info->Mode == SLIB_MODE_DECOMPRESS)
  {
    unsigned char *buf;
    unsigned dword size;
    Info->VideoStreams=1;
    switch (Info->Type)
    {
#ifdef MPEG_SUPPORT
      case SLIB_TYPE_MPEG1_VIDEO:
      case SLIB_TYPE_MPEG2_VIDEO:
      case SLIB_TYPE_MPEG_SYSTEMS:
      case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
      case SLIB_TYPE_MPEG_TRANSPORT:
      case SLIB_TYPE_MPEG_PROGRAM:
            _SlibDebug(_DEBUG_,
                 printf("SlibUpdateVideoInfo() MPEG1 or MPEG2\n") );
            if (!slibLoadPin(Info, SLIB_DATA_VIDEO))
            {
              _SlibDebug(_DEBUG_,
                printf("SlibUpdateVideoInfo() No VIDEO data\n") );
              Info->Type=SLIB_TYPE_UNKNOWN;
              Info->VideoStreams=0;
              return;
            }
            buf = slibSearchBuffersOnPin(Info,
                                         slibGetPin(Info, SLIB_DATA_VIDEO),
                                         NULL, &size, MPEG_SEQ_HEAD,
                                         MPEG_SEQ_HEAD_LEN/8, FALSE);
            if (buf)
            {
              const float fps[16] = {
               30.0F, 23.976F, 24.0F, 25.0F, 29.97F, 30.0F, 50.0F, 59.94F,
               60.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F
              };
             /*  ScDumpChar(buf, size, 0); */
              Info->Width = ((int)buf[0])*16+(int)(buf[1]>>4);
              Info->Height = ((int)buf[1]&0x0F)*256+(int)buf[2];
              /* must be 16x16 because of Render limitations, round up */
              Info->Width += (Info->Width%16) ? 16-(Info->Width%16) : 0;
              Info->Height += (Info->Height%16) ? 16-(Info->Height%16) : 0;
              Info->FramesPerSec = fps[buf[3]&0x0F];
              Info->VideoBitRate = (((dword)buf[4]&0xFF)<<10) +
                                   (((dword)buf[5])<<2) +
                                    (dword)(buf[6]>>6);
              Info->VideoBitRate *= 400;
              Info->VBVbufSize = ((int)buf[6]&0x1F)<<5 | (int)(buf[7]>>3);
              Info->VBVbufSize *= 2*1024;
              _SlibDebug(_DEBUG_, printf("VBVbufSize=%d\n", Info->VBVbufSize) );
              if (Info->VideoBitRate)
              {
                qword secs=(qword)(((qword)Info->FileSize*80L)
                                                       /Info->VideoBitRate);
                Info->VideoLength = secs*100;
                _SlibDebug(_DEBUG_,
                printf("SlibUpdateVideoInfo() VideoLength = %ld  Bitrate=%ld\n",
                                Info->VideoLength, Info->VideoBitRate) );
              }
            }
            else /* invalid format */
            {
              _SlibDebug(_DEBUG_,
                printf("SlibUpdateVideoInfo() Didn't find MPEG sequence header\n") );
              Info->Type=SLIB_TYPE_UNKNOWN;
              Info->VideoStreams=0;
              return;
            }
            compformat=BI_DECMPEGDIB;
            dcmpformat=BI_YU12SEP;
            Info->VideoType=SLIB_TYPE_MPEG1_VIDEO;
            /* check to see if this is MPEG 2 */
            _SlibDebug(_DEBUG_,
              printf("Searching for MPEG 2 extensions...\n") );
            do {
              buf = slibSearchBuffersOnPin(Info,
                                           slibGetPin(Info, SLIB_DATA_VIDEO),
                                           buf, &size, MPEG_START_CODE,
                                           MPEG_START_CODE_LEN/8, FALSE);
              if (buf && buf[0]==MPEG_EXT_START_BASE)
              {
                _SlibDebug(_DEBUG_,
                  printf("Found START CODE %X, ID=%d\n", buf[0], buf[1]>>4) );
                if ((buf[1]>>4)==MPEG_SEQ_ID) /* has to be MPEG 2 */
                {
                  if (Info->Type==SLIB_TYPE_MPEG1_VIDEO)
                    Info->Type=SLIB_TYPE_MPEG2_VIDEO;
                  else if (Info->Type==SLIB_TYPE_MPEG_SYSTEMS)
                    Info->Type=SLIB_TYPE_MPEG_SYSTEMS_MPEG2;
                  Info->VideoType=SLIB_TYPE_MPEG2_VIDEO;
                  switch ((buf[2]>>1)&0x03)
                  {
                    default:
                    case 1: /* 4:1:1 */ dcmpformat=BI_YU12SEP;
                            _SlibDebug(_DEBUG_, printf("4:1:1\n") );
                            break;
                    case 2: /* 4:2:2 */ dcmpformat=BI_YU16SEP;
                            _SlibDebug(_DEBUG_, printf("4:2:2\n") );
                            break;
                    case 3: /* 4:4:4 */ dcmpformat=BI_YU16SEP;
                            _SlibDebug(_DEBUG_, printf("4:4:4\n") );
                            break;
                  }
                  break;
                }
              }
              else
                break;
            } while (1);
            _SlibDebug(_DEBUG_,
              printf("Done searching for MPEG 2 extensions.\n") );
            Info->KeySpacing=12;
            Info->SubKeySpacing=3;
            break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SLIB_TYPE_H261:
      case SLIB_TYPE_RTP_H261:
            slibLoadPin(Info, SLIB_DATA_VIDEO);
            buf = slibSearchBuffersOnPin(Info,
                                         slibGetPin(Info, SLIB_DATA_VIDEO),
                                         NULL, &size, H261_START_CODE,
                                         H261_START_CODE_LEN/8, FALSE);
            if (buf)
            {
              if ((buf[0]&0xF0)==0) /* picture start code */
              {
                if (buf[1]&0x08)
                {
                  Info->Width = 352;
                  Info->Height = 288;
                }
                else
                {
                  Info->Width = 176;
                  Info->Height = 144;
                }
              }
              Info->FramesPerSec = 15.0F;
            }
            compformat=BI_DECH261DIB;
            dcmpformat=BI_YU12SEP;
            Info->VideoType=SLIB_TYPE_H261;
            break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
      case SLIB_TYPE_H263:
      case SLIB_TYPE_RTP_H263:
            slibLoadPin(Info, SLIB_DATA_VIDEO);
            buf = slibSearchBuffersOnPin(Info,
                                         slibGetPin(Info, SLIB_DATA_VIDEO),
                                         NULL, &size, 0x000080,
                                         3, FALSE);
            if (buf)
            {
              switch ((buf[1]>>2)&0x07)
              {
                case H263_SF_SQCIF:
                  Info->Width = SQCIF_WIDTH;
                  Info->Height = SQCIF_HEIGHT;
                  break;
                case H263_SF_QCIF:
                  Info->Width = QCIF_WIDTH;
                  Info->Height = QCIF_HEIGHT;
                  break;
                case H263_SF_4CIF:
                  Info->Width = CIF4_WIDTH;
                  Info->Height = CIF4_HEIGHT;
                  break;
                case H263_SF_16CIF:
                  Info->Width = CIF16_WIDTH;
                  Info->Height = CIF16_HEIGHT;
                  break;
                case H263_SF_CIF:
                default:
                  Info->Width = CIF_WIDTH;
                  Info->Height = CIF_HEIGHT;
              }
              Info->FramesPerSec = 30.0F;
            }
            compformat=BI_DECH263DIB;
            dcmpformat=BI_YU12SEP;
            Info->VideoType=SLIB_TYPE_H263;
            break;
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
      case SLIB_TYPE_SHUFF:
            slibLoadPin(Info, SLIB_DATA_VIDEO);
            buf=slibPeekBufferOnPin(Info,
                    slibGetPin(Info,SLIB_DATA_VIDEO), &size, NULL);
            if (buf)
            {
              _SlibDebug(_DEBUG_,
                  printf("%2X %2X %2X %2X %2X %2X\n", buf[0], buf[1],
                                       buf[2], buf[3],  buf[4], buf[5]) );
              Info->Width = ((int)buf[3]*256)+(int)buf[4];
              Info->Height = ((int)buf[5]*256)+(int)buf[6];
            }
            Info->FramesPerSec = 30.0F;
            Info->VideoBitRate = 0;
            compformat=BI_DECHUFFDIB;
            dcmpformat=BI_YU12SEP;
            Info->KeySpacing=1;
            Info->SubKeySpacing=1;
            Info->VideoType=SLIB_TYPE_SHUFF;
            break;
#endif /* HUFF_SUPPORT */
      case SLIB_TYPE_RASTER:
            buf=slibPeekBufferOnPin(Info, 
                    slibGetPin(Info,SLIB_DATA_COMPRESSED), &size, NULL);
            Info->FramesPerSec = 30.0F;
            if (buf)
            {
              _SlibDebug(_DEBUG_,
                  printf("%2X %2X %2X %2X %2X %2X\n", buf[0], buf[1], 
                                       buf[2], buf[3],  buf[4], buf[5]) );
              Info->Width = ((int)buf[4]<<24)+((int)buf[5]<<16)+((int)buf[6]<<8)+(int)buf[7];
              Info->Height = ((int)buf[8]<<24)+((int)buf[9]<<16)+((int)buf[10]<<8)+(int)buf[11];

              Info->VideoLength = slibFrameToTime(Info,
                                 (signed qword)Info->FileSize/(Info->Width*Info->Height*3));
            }
            else
              Info->VideoLength = slibFrameToTime(Info, 1);
            Info->VideoBitRate = 0;
            compformat=BI_RGB;
            dcmpformat=BI_YU12SEP;
            Info->KeySpacing=1;
            Info->SubKeySpacing=1;
            Info->VideoType=SLIB_TYPE_RASTER;
            break;
      case SLIB_TYPE_BMP:
            buf=slibPeekBufferOnPin(Info, 
                    slibGetPin(Info,SLIB_DATA_COMPRESSED), &size, NULL);
            Info->FramesPerSec = 30.0F;
            if (buf)
            {
              _SlibDebug(_DEBUG_,
                  printf("%2X %2X %2X %2X %2X %2X\n", buf[0], buf[1], 
                                       buf[2], buf[3],  buf[4], buf[5]) );
              Info->Width = ((dword)buf[15]<<24)+((dword)buf[16]<<16)+((dword)buf[17]<<8)+(dword)buf[18];
              Info->Height = ((dword)buf[19]<<24)+((dword)buf[20]<<16)+((dword)buf[21]<<8)+(dword)buf[22];
              compformat=((dword)buf[30]<<24)+((dword)buf[25]<<16)+((dword)buf[26]<<8)+(dword)buf[27];
              inbpp=(dword)buf[28];
              Info->VideoLength = slibFrameToTime(Info,
                                 (signed qword)Info->FileSize/(Info->Width*Info->Height*3));
            }
            else
              Info->VideoLength = slibFrameToTime(Info, 1);
            Info->VideoBitRate = 0;
            Info->VideoType = slibFOURCCtoVideoType(&compformat);
            dcmpformat=BI_YU16SEP;
            outbpp=slibCalcBits(dcmpformat, outbpp);
            Info->KeySpacing=1;
            Info->SubKeySpacing=1;
            break;

      case SLIB_TYPE_RIFF:
      case SLIB_TYPE_AVI:
            slibLoadPin(Info, SLIB_DATA_COMPRESSED);
            buf = slibSearchBuffersOnPin(Info,
                                         slibGetPin(Info,SLIB_DATA_COMPRESSED),
                                         NULL, &size, AVI_MAINHDR, 4, FALSE);
            if (buf)
            {
              AVI_MainHeader hdr;
              /* printf("%d %d %d %d\n", buf[4], buf[5], buf[6], buf[7]); */
              memcpy(&hdr, buf+4, sizeof(AVI_MainHeader));
              Info->Width  = (short)hdr.dwWidth;
              Info->Height = (short)hdr.dwHeight;
              Info->FramesPerSec = 1000000.0F/hdr.dwMicroSecPerFrame;
              if (Info->FramesPerSec==0.0F)
                Info->FramesPerSec = 30.0F;
              Info->VideoLength = slibFrameToTime(Info, hdr.dwTotalFrames);
              Info->VideoLengthKnown = TRUE;
            }
            buf = slibSearchBuffersOnPin(Info,
                                     slibGetPin(Info,SLIB_DATA_COMPRESSED),
                                     NULL, &size, AVI_STREAMFORMAT, 4, FALSE);
            if (buf)
            {
              AVI_StreamHeader hdr;
              /* printf("%c %c %c %c\n", buf[4], buf[5], buf[6], buf[7]); */
              memcpy(&hdr, buf+20, sizeof(AVI_StreamHeader));
              compformat=hdr.fccType;
              Info->VideoType = slibFOURCCtoVideoType(&compformat);
              switch (Info->VideoType)
              {
                case SLIB_TYPE_JPEG:
                  Info->Type = SLIB_TYPE_JPEG_AVI;
                  dcmpformat=BI_YU16SEP;
                  break;
                case SLIB_TYPE_MJPG:
                  Info->Type = SLIB_TYPE_MJPG_AVI;
                  dcmpformat=BI_YU16SEP;
                  break;
                case SLIB_TYPE_YUV:
                  Info->Type = SLIB_TYPE_YUV_AVI;
                  dcmpformat=compformat;
                  if (IsYUV422Packed(dcmpformat) || IsYUV422Sep(dcmpformat))
                    dcmpformat=BI_YU16SEP;
                  break;
                default:
                  _SlibDebug(_WARN_, printf("Unsupported AVI format\n") );
                  return;
              }
              inbpp=slibCalcBits(compformat, inbpp);
              outbpp=slibCalcBits(dcmpformat, outbpp);
              Info->KeySpacing=1;
              Info->SubKeySpacing=1;
            }
            break;
#ifdef JPEG_SUPPORT
      case SLIB_TYPE_JPEG_QUICKTIME:
      case SLIB_TYPE_JFIF:
            /* not supported - need to know how to parse */
            slibLoadPin(Info, SLIB_DATA_VIDEO);
            buf = slibSearchBuffersOnPin(Info,
                                    slibGetPin(Info, SLIB_DATA_VIDEO),
                                    NULL, &size, (JPEG_MARKER<<8)|JPEG_SOF0,
                                    2, FALSE);
            if (buf)
            {
              Info->Width  = ((int)buf[5]<<8) + (int)buf[6];
              Info->Height = ((int)buf[3]<<8) + (int)buf[4];
              Info->FramesPerSec = 30.0F;
            }
            compformat=MJPG_DIB;
            dcmpformat=BI_YU16SEP;
            Info->VideoType = SLIB_TYPE_JPEG;
            break;
#endif /* JPEG_SUPPORT */
    }
    slibUpdateVideoFrames(Info);
  }
  if (SlibTypeHasTimeStamps(Info->Type))
  {
    ptime=slibGetNextTimeOnPin(Info, slibGetPin(Info, SLIB_DATA_VIDEO), 100*1024);
    if (SlibTimeIsValid(ptime))
      Info->VideoPTimeBase=ptime;
  }
  if (Info->CompVideoFormat==NULL)
    Info->CompVideoFormat=(BITMAPINFOHEADER *)ScAlloc(sizeof(BITMAPINFOHEADER));
  _SlibDebug(_VERBOSE_,
         printf("Width=%d Height=%d Stride=%d\n",
              Info->Width, Info->Height, Info->Stride) );
  if (Info->CompVideoFormat!=NULL)
  {
    Info->CompVideoFormat->biSize          = sizeof(BITMAPINFOHEADER);
    Info->CompVideoFormat->biWidth         = Info->Width;
    Info->CompVideoFormat->biHeight        = Info->Height;
    Info->CompVideoFormat->biPlanes        = 1;
    Info->CompVideoFormat->biBitCount      = (WORD)inbpp;
    Info->CompVideoFormat->biCompression   = compformat;
    Info->CompVideoFormat->biSizeImage     = 0;
    Info->CompVideoFormat->biXPelsPerMeter = 0;
    Info->CompVideoFormat->biYPelsPerMeter = 0;
    Info->CompVideoFormat->biClrUsed       = 0;
    Info->CompVideoFormat->biClrImportant  = 0;
  }
  if (Info->VideoFormat==NULL)
    Info->VideoFormat=(BITMAPINFOHEADER *)ScAlloc(sizeof(BITMAPINFOHEADER));
  if (Info->VideoFormat!=NULL)
  {
    Info->VideoFormat->biSize          = sizeof(BITMAPINFOHEADER);
    Info->VideoFormat->biWidth         = Info->Width;
    Info->VideoFormat->biHeight        = Info->Height;
    Info->VideoFormat->biPlanes        = 1;
    Info->VideoFormat->biBitCount      = (WORD)outbpp;
    Info->VideoFormat->biCompression   = dcmpformat;
    Info->VideoFormat->biSizeImage     = 0;
    Info->VideoFormat->biXPelsPerMeter = 0;
    Info->VideoFormat->biYPelsPerMeter = 0;
    Info->VideoFormat->biClrUsed       = 0;
    Info->VideoFormat->biClrImportant  = 0;
  }
  if (Info->CodecVideoFormat==NULL)
  {
    Info->CodecVideoFormat=(BITMAPINFOHEADER *)ScAlloc(sizeof(BITMAPINFOHEADER));
    if (Info->CodecVideoFormat!=NULL)
      memcpy(Info->CodecVideoFormat, Info->VideoFormat,
                                     sizeof(BITMAPINFOHEADER));
  }
  slibValidateVideoParams(Info);
}

SlibStatus_t slibValidateVideoParams(SlibInfo_t *Info)
{
  dword oldimagesize, codecwidth, codecheight;
  SlibStatus_t status=SlibErrorNone;
  if (Info->CodecVideoFormat)
  {
    codecwidth=Info->CodecVideoFormat->biWidth;
    codecheight=Info->CodecVideoFormat->biHeight;
  }
  else
  {
    codecwidth=Info->Width;
    codecheight=Info->Height;
  }
  if (Info->Mode==SLIB_MODE_COMPRESS)
  {
    switch (Info->Type)
    {
      case SLIB_TYPE_H261:
            if (Info->Width!=CIF_WIDTH && Info->Width!=QCIF_WIDTH)
              status=SlibErrorImageSize;
            if (Info->Height!=CIF_HEIGHT && Info->Height!=QCIF_HEIGHT)
              status=SlibErrorImageSize;
            if (status!=SlibErrorNone) /* set to closest size */
            {
              if (Info->Width<=300)
              {
                codecwidth=QCIF_WIDTH;
                codecheight=QCIF_HEIGHT;
              }
              else
              {
                codecwidth=CIF_WIDTH;
                codecheight=CIF_HEIGHT;
              }
            }
            break;
      case SLIB_TYPE_H263:
            if (Info->Width!=CIF_WIDTH && Info->Width!=SQCIF_WIDTH && Info->Width!=QCIF_WIDTH &&
                Info->Width!=CIF4_WIDTH && Info->Width!=CIF16_WIDTH)
              status=SlibErrorImageSize;
            if (Info->Height!=CIF_HEIGHT && Info->Height!=SQCIF_HEIGHT && Info->Height!=QCIF_HEIGHT &&
                Info->Height!=CIF4_HEIGHT && Info->Height!=CIF16_HEIGHT)
              status=SlibErrorImageSize;
            if (status!=SlibErrorNone) /* set to closest size */
            {
              if (Info->Width<=168)
              {
                codecwidth=SQCIF_WIDTH;
                codecheight=SQCIF_HEIGHT;
              }
              else if (Info->Width<=300)
              {
                codecwidth=QCIF_WIDTH;
                codecheight=QCIF_HEIGHT;
              }
              else if (Info->Width<=(CIF4_WIDTH+CIF_WIDTH)/2)
              {
                codecwidth=CIF_WIDTH;
                codecheight=CIF_HEIGHT;
              }
              else if (Info->Width<=(CIF16_WIDTH+CIF4_WIDTH)/2)
              {
                codecwidth=CIF4_WIDTH;
                codecheight=CIF4_HEIGHT;
              }
              else
              {
                codecwidth=CIF16_WIDTH;
                codecheight=CIF16_HEIGHT;
              }
            }
            break;
    }
    /* height and width must be mults of 8 */
    if (codecwidth%8 || codecheight%8)
      return(SlibErrorImageSize);
    if (status==SlibErrorImageSize)
    {
      if (Info->CodecVideoFormat)
      {
        Info->CodecVideoFormat->biWidth=codecwidth;
        Info->CodecVideoFormat->biHeight=codecheight;
      }
      if (Info->CompVideoFormat)
      {
        Info->CompVideoFormat->biWidth=codecwidth;
        Info->CompVideoFormat->biHeight=codecheight;
      }
    }
  }
  if (Info->VideoFormat)
  {
    oldimagesize=Info->ImageSize;
    Info->ImageSize=slibCalcImageSize(Info->VideoFormat->biCompression,
                                      Info->VideoFormat->biBitCount,
                                      Info->VideoFormat->biWidth,
                                      Info->VideoFormat->biHeight);
    if (Info->ImageSize!=oldimagesize && Info->Imagebuf)
    {
      SlibFreeBuffer(Info->Imagebuf);
      Info->Imagebuf=NULL;
    }
    Info->VideoFormat->biBitCount=(WORD)slibCalcBits(
                                      Info->VideoFormat->biCompression,
                                      Info->VideoFormat->biBitCount);
    Info->VideoFormat->biSizeImage=Info->ImageSize;
  }
  if (Info->CodecVideoFormat)
  {
    oldimagesize=Info->CodecImageSize;
    Info->CodecImageSize=slibCalcImageSize(
                                      Info->CodecVideoFormat->biCompression,
                                      Info->CodecVideoFormat->biBitCount,
                                      Info->CodecVideoFormat->biWidth,
                                      Info->CodecVideoFormat->biHeight);
    if (Info->CodecImageSize!=oldimagesize && Info->CodecImagebuf)
    {
      SlibFreeBuffer(Info->CodecImagebuf);
      Info->CodecImagebuf=NULL;
    }
    Info->CodecVideoFormat->biBitCount=(WORD)slibCalcBits(
                                      Info->CodecVideoFormat->biCompression,
                                      Info->CodecVideoFormat->biBitCount);
    Info->CodecVideoFormat->biSizeImage=Info->CodecImageSize;
  }
  if (Info->VideoFormat && Info->CodecVideoFormat)
  {
    oldimagesize=Info->IntImageSize;
    Info->IntImageSize=slibCalcImageSize(Info->VideoFormat->biCompression,
                                         Info->VideoFormat->biBitCount,
                                         Info->CodecVideoFormat->biWidth,
                                         Info->CodecVideoFormat->biHeight);
    if (Info->IntImageSize!=oldimagesize && Info->IntImagebuf)
    {
      SlibFreeBuffer(Info->IntImagebuf);
      Info->IntImagebuf=NULL;
    }
  }
  /* close format converter since formats may have changed */
  if (Info->Sch)
  {
    SconClose(Info->Sch);
    Info->Sch=NULL;
  }
  if (Info->FramesPerSec)
    Info->VideoFrameDuration=slibFrameToTime100(Info, 1);
  return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\yuv2rgb.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: scon_yuv_to_rgb.c,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1997                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: YUV_To_RGB_422_Init                                     */
/*  Author:   Bill Hallahan                                           */
/*  Date:     July 29, 1994                                           */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function produces a table that is used by the         */
/*    yuv_to_rgb_422 conversion routines. This table is required      */
/*    by the following routines.                                      */
/*                                                                    */
/*        YUV_To_RGB_422_24_Bit                                       */
/*        YUV_To_RGB_422_555                                          */
/*                                                                    */
/*                                                                    */
/*         YUV to RGB conversion can be described by a 3x3 matrix     */
/*    multiplication:                                                 */
/*                                                                    */
/*         R     | 1   0  VR |  Y                                     */
/*         G  =  | 1  UG  VG |  U                                     */
/*         B     | 1  UB   0 |  V                                     */
/*                                                                    */
/*         where:                                                     */
/*                                                                    */
/*            0 <= Y <= 255                                           */
/*         -128 <= U <= 127    UG = -0.3455    UB =  1.7790           */
/*         -128 <= V <= 127    VR =  1.4075    VG = -0.7169           */
/*                                                                    */
/*         The Red, Green, and Blue output values are obtained in     */
/*    parallel by summing three 64 bit words as shown. Each of the    */
/*    quadwords is obtained from either the Y_Table, the U_Table,     */
/*    or the V_table using the corresponding 8 bit Y, U, or V value   */
/*    as an index. Thus all multiplications are performed by table    */
/*    lookup. Note that the matrix output is ordered as B, R, G	      */
/*    and then B again (starting at the LSB).			      */
/*    This is to allow an efficient conversion to the output format.  */
/*								      */
/*    For 32-bit RGB, the Red and Blue bits are already in the	      */
/*    correct position, the conversion routine only has to shift      */
/*    the Green bits. For General BI-BITFIELDS however, the Red,      */
/*    Green and Blue bits could be anywhere in a 16-bit or 32-bit     */
/*    word (we only support 16-bit for now). To avoid a costly	      */
/*    decicion in the inner loop whether to shift the Blue bits left  */
/*    or right, we maintain a copy of the Blue bits in position 48    */
/*    so a right shift will always work. Each conversion routine can  */
/*    choose whichever set of Blue bits that are fastest to use,      */
/*    they are identical.					      */
/*								      */
/*                                                                    */
/*           MSW                                         LSW          */
/*                                                                    */
/*           63       48 47       32 31       16 15        0    Index */
/*           -----------------------------------------------          */
/*          |          Y|          Y|          Y|          Y|     Y   */
/*           -----------------------------------------------          */
/*                                                                    */
/*           -----------------------------------------------          */
/*          |         ub|         ug|          0|         ub|     U   */
/*           -----------------------------------------------          */
/*                                                                    */
/*           -----------------------------------------------          */
/*       +  |          0|         vg|         vr|          0|     V   */
/*           -----------------------------------------------          */
/*    __________________________________________________________      */
/*                                                                    */
/*           -----------------------------------------------          */
/*    Total |    0|    0|    x|    G|    x|    R|    x|    B|         */
/*           -----------------------------------------------          */
/*                                                                    */
/*                                                                    */
/*      where:                                                        */
/*                                                                    */
/*          ub = UB * U                                               */
/*          ug = UG * U                                               */
/*          vg = VG * V                                               */
/*          vr = VR * V                                               */
/*                                                                    */
/*                                                                    */
/*         The maximum absolute value for Y is 255 and the maximum    */
/*    for U or V is 128, so 9 bits is the minimum size to represent   */
/*    them together as two's complement values. The maximum           */
/*    chrominance (U or V) magnitude is 128. This is 0.5 as a Q9      */
/*    two's complement fraction. 255 is 1 - 2^-8 in Q9 fraction form. */
/*                                                                    */
/*    The maximum possible bit growth is determined as follows.       */
/*                                                                    */
/*      R_Max = 1 - 2^-8 +                  0.5 * fabs(VR) = 1.6998   */
/*      G_Max = 1 - 2^-8 + 0.5 * fabs(UG) + 0.5 * fabs(VG) = 1.5273   */
/*      B_Max = 1 - 2^-8 + 0.5 * fabs(UB)                  = 1.8856   */
/*                                                                    */
/*                                                                    */
/*         Since B_Max = 1.8856 then the next highest integer         */
/*    greater than or equal to log base 2 of 1.8856 is 1. So 1 bit    */
/*    is required for bit growth. The minimum accumulator size        */
/*    required is 9 + 1 = 10 bits. This code uses 12 bit accumulators */
/*    since there are bits to spare.                                  */
/*                                                                    */
/*         The 11'th bit (starting at bit 0) of each accumulator      */
/*    is the sign bit. This may be tested to determine if there is    */
/*    a negative result. Accumulator overflows are discarded as is    */
/*    normal for two's complement arithmetic. Each R, G, or B result  */
/*    that is over 255 is set to 255. Each R, G, or B result that is  */
/*    less than zero is set to zero.                                  */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*                                                                    */
/*    bSign     Contains a 32 bit boolean that if non-zero, changes   */
/*              the interpretation of the chrominance (U and V) data  */
/*              from an offset binary format, where the values range  */
/*              from 0 to 255 with 128 representing 0 chrominance,    */
/*              to a signed two's complement format, where the values */
/*              range from -128 to 127.                               */
/*                                                                    */
/*                                                                    */
/*    bBGR      Contains a 32 bit boolean that if non-zero, changes   */
/*              the order of the conversion from RGB to BGR.          */
/*                                                                    */
/*                                                                    */
/*    pTable    The address of the RGB (or BGR) conversion table      */
/*              that is filled in by this function. The table         */
/*              address must be quadword aligned. The table size      */
/*              is 6244 bytes 3 * 256 quadwords.                      */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function has no return value.                              */
/*                                                                    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

/*
#define _SLIBDEBUG_
*/

#include "scon_int.h"
#include "SC_err.h"
#include "SC_conv.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_     1  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#endif

/*
 * Define NEW_YCBCR to use new YCbCr conversion values.
 */
#define NEW_YCBCR

#define GetRGB555(in16, r, g, b) b = (in16>>7)&0xF8; \
                                 g = (in16>>2)&0xF8; \
                                 r = (in16<<3)&0xF8

#define AddRGB555(in16, r, g, b) b += (in16>>7)&0xF8; \
                                 g += (in16>>2)&0xF8; \
                                 r += (in16<<3)&0xF8

#define PutRGB565(r, g, b, out16) out16 = ((r&0xf8)<<8)|((g&0xfC)<<3)|((b&0xf8)>>3)

#define PutRGB555(r, g, b, out16) out16 = ((r&0xf8)<<7)|((g&0xf8)<<2)|((b&0xf8)>>3)

#ifdef NEW_YCBCR
/*
**	y = 16.000 + 0.257 * r       + 0.504 * g       + 0.098 * b       ;
**	u = 16.055 + 0.148 * (255-r) + 0.291 * (255-g) + 0.439 * b       ;
**	v = 16.055 + 0.439 * r       + 0.368 * (255-g) + 0.071 * (255-b) ;
*/
#define YC 16.000
#define UC 16.055
#define VC 16.055
#define YR  0.257
#define UR  0.148
#define VR  0.439
#define YG  0.504
#define UG  0.291
#define VG  0.368
#define YB  0.098
#define UB  0.439
#define VB  0.071

#else /* !NEW_YCBCR */
/*
**    ( y =  0.0      0.299 * r       + 0.587 * g       + 0.1140 * b       ; )
**    ( u =  0.245  + 0.169 * (255-r) + 0.332 * (255-g) + 0.5000 * b       ; )
**    ( v =  0.4235 + 0.500 * r       + 0.419 * (255-g) + 0.0813 * (255-b) ; )
*/
#define YC 0.0
#define UC 0.245
#define VC 0.4235
#define YR 0.299
#define UR 0.169
#define VR 0.500
#define YG 0.587
#define UG 0.332
#define VG 0.419
#define YB 0.1140
#define UB 0.5000
#define VB 0.0813

#endif /* !NEW_YCBCR */

/********************************** YUV to RGB ***********************************/
/*
 * The YUV to RGB conversion routines
 * generates RGB values in a 64-bit
 * word thus:
 *
 *	63   56	55   48	47   40 39   32	31   24	23   16	15    8	7     0
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |     0 |  Blue |     0 | Green |     0 |   Red |     0 |  Blue |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 *
 * Figure out how many steps to the right are needed to
 * shift the red, green and blue into the correct position.
 */
#define ArrangRGB565(inrgb, outrgb) \
	  outrgb=((inrgb>>8)&0xf800)|((inrgb>>29)&0x07e0)|((inrgb>>51)&0x001f)
#define ArrangRGB888(inrgb, outrgb) \
	  outrgb=(inrgb&0xFF0000)|((inrgb>>24)&0x00FF00)|(inrgb&0x0000FF)


SconStatus_t sconInitYUVtoRGB(SconInfo_t *Info)
{
  qword i, qY, qUV, qSigned;
  SconBoolean_t bBGR=Info->Output.vinfo.Rmask&1; /* BGR vs RGB ordering */
  SconBoolean_t bSign=FALSE; /* U and V are signed values */
  unsigned qword qRed;
  unsigned qword qGreen;
  unsigned qword qBlue;
  unsigned qword qTemp;
  unsigned qword qAccMask = 0xFFF;
  unsigned qword *pTable, *pU_Table, *pV_Table;
  double Chrominance;
#ifdef NEW_YCBCR
  double CF_UB = 2.018;
  double CF_UG = -0.391;
  double CF_VG = -0.813;
  double CF_VR = 1.596;
#else /* !NEW_YCBCR */
  double CF_UB = 1.7790;
  double CF_UG = -0.3455;
  double CF_VG = -0.7169;
  double CF_VR = 1.4075;
#endif /* !NEW_YCBCR */

  /* allocate memory to hold the lookup table */
  if (Info->Table && Info->TableSize<256*3*8)
  {
    ScPaFree(Info->Table);
    Info->Table=NULL;
  }
  if (Info->Table==NULL)
  {
    if ((Info->Table = ScPaMalloc(256*3*8)) == NULL)
      return(SconErrorMemory);
    Info->TableSize=256*3*8;
  }
  /*
   *  Set constant that determines if the U and V chrominance values
   *  are interpreted as signed or unsigned values.
   */
  if ( !bSign )
    qSigned = 0;
  else
    qSigned = 0xFFFFFFFFFFFFFF80;

  /* Get the U, and V table pointers. */
  pTable = (unsigned qword *)Info->Table;
  pU_Table = pTable + 256;
  pV_Table = pU_Table + 256;

  /* Initialize the Y_Table, the U_Table, and the V_Table. */
  for ( i = 0; i < 256; i++ )
  {
    /******************************************************************/
    /*  Construct the Y array value for the current index value.      */
    /*                                                                */
    /*   63       48 47       32 31       16 15        0    Index     */
    /*   -----------------------------------------------              */
    /*  |          Y|          Y|          Y|          Y|     Y = i   */
    /*   -----------------------------------------------              */
    /*                                                                */
    /******************************************************************/

#ifdef NEW_YCBCR
    qY = (qword) ((i-16)*1.164) ;
    qY = (qY < 0) ? 0 : (qY > 255) ? 255 : qY ;
#else /* !NEW_YCBCR */
    qY = i ;
#endif /* !NEW_YCBCR */
    qY |= qY << 16 ;
    *pTable++ = qY | ( qY << 32 ) ;
    /******************************************************************/
    /*  Construct the U array value for the current index value.      */
    /*                                                                */
    /*   63       48 47       32 31       16 15        0    Index     */
    /*   -----------------------------------------------              */
    /*  |         ub|         ug|          0|         ub|     U = i   */
    /*   -----------------------------------------------              */
    /*                                                                */
    /******************************************************************/

#ifdef NEW_YCBCR
    qUV = (i< 16) ? 16
        : (i<240) ?  i
        : 240 ;
#else /* !NEW_YCBCR */
    qUV = i ;
#endif /* !NEW_YCBCR */
         
    Chrominance = (double) (( qUV - 128 ) ^ qSigned );

    qBlue = ((qword)( CF_UB * Chrominance )) & qAccMask;
    qGreen = ((qword)( CF_UG * Chrominance )) & qAccMask;
    qRed = 0;
    if ( bBGR )
    {
      qTemp = qBlue;
      qBlue = qRed;
      qRed = qTemp;
    }
    *pU_Table++ = qBlue | ( qRed << 16 ) | ( qGreen << 32 ) | ( qBlue << 48 );
    /******************************************************************/
    /*  Construct the V array value for the current index value.      */
    /*                                                                */
    /*   63       48 47       32 31       16 15        0    Index     */
    /*   -----------------------------------------------              */
    /*  |          0|         vg|         vr|          0|     V = i   */
    /*   -----------------------------------------------              */
    /*                                                                */
    /******************************************************************/
    qBlue = 0;
    qGreen = ((qword)( CF_VG * Chrominance )) & qAccMask;
    qRed = ((qword)( CF_VR * Chrominance )) & qAccMask;
    if ( bBGR )
    {
      qTemp = qBlue;
      qBlue = qRed;
      qRed = qTemp;
    }
    *pV_Table++ = qBlue | ( qRed << 16 ) | ( qGreen << 32 );
  }
  return(SconErrorNone);
}

SconStatus_t scon422ToRGB565(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable)
{
  unsigned qword y, u, v, mask ;
  unsigned qword y0, y1, y2, y3 ;
  unsigned qword y4, y5, y6, y7 ;
  unsigned qword u01, v01, u23, v23 ;
  unsigned qword  *yData=(unsigned qword *)inimage;
  unsigned int *uData=(unsigned int *)(inimage+width*height);
  unsigned int *vData=(unsigned int *)(inimage+(width*height*3)/2);
  unsigned qword *rgbData=(unsigned qword *)outimage;
  unsigned dword x, line;
  if (stride<0) /* flip */
    outimage=outimage+((height-1)*(-stride));
  for (line=height; line>0; line--, outimage+=stride)
  {
    rgbData=(unsigned qword *)outimage;
    for (x=width>>3; x>0; x--)
    {
      y   = *yData++ ;
      y0  = y & 255 ; y >>= 8 ;
      y1  = y & 255 ; y >>= 8 ;
      y2  = y & 255 ; y >>= 8 ;
      y3  = y & 255 ;	y >>= 8 ;
      y4  = y & 255 ;	y >>= 8 ;
      y5  = y & 255 ;	y >>= 8 ;
      y6  = y & 255 ;	y >>= 8 ;
      y7  = y & 255 ;	y >>= 8 ;

      u   = *uData++ ;
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ; u >>= 8 ;

      v   = *vData++ ;
      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ; v >>= 8 ;

      y0  = pTable[y0] ;
      y1  = pTable[y1] ;
      y2  = pTable[y2] ;
      y3  = pTable[y3] ;
      y4  = pTable[y4] ;
      y5  = pTable[y5] ;
      y6  = pTable[y6] ;
      y7  = pTable[y7] ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;
      /* Now, convert to RGB */
      y0 += u01 + v01 ;
      y1 += u01 + v01 ;
      y2 += u23 + v23 ;
      y3 += u23 + v23 ;
      /*
       * Same thing for more pixels.
       * Use u01 for u45 and u23 for u67
       */
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ;

      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;
      /* Convert to RGB. */
      y4 += u01 + v01 ;
      y5 += u01 + v01 ;
      y6 += u23 + v23 ;
      y7 += u23 + v23 ;
      /* See if any value is out of range. */
      mask = (unsigned qword)0x0F000F000F000F00L;
      if( (y0 | y1 | y2 | y3 | y4 | y5 | y6 | y7) & mask )
      {
	      /* Zero values that are negative */
        mask = (unsigned qword)0x0800080008000800L ;
        y = y0 & mask ; y0 &= ~(y - (y>>11)) ;
        y = y1 & mask ; y1 &= ~(y - (y>>11)) ;
        y = y2 & mask ; y2 &= ~(y - (y>>11)) ;
        y = y3 & mask ; y3 &= ~(y - (y>>11)) ;
        y = y4 & mask ; y4 &= ~(y - (y>>11)) ;
        y = y5 & mask ; y5 &= ~(y - (y>>11)) ;
        y = y6 & mask ; y6 &= ~(y - (y>>11)) ;
        y = y7 & mask ; y7 &= ~(y - (y>>11)) ;
        /* Clamp values that are > 255 to 255. */
        mask = (unsigned qword)0x0100010001000100L ;
        y = y0 & mask ; y0 |= (y - (y >> 8)) ;
        y = y1 & mask ; y1 |= (y - (y >> 8)) ;
        y = y2 & mask ; y2 |= (y - (y >> 8)) ;
        y = y3 & mask ; y3 |= (y - (y >> 8)) ;
        y = y4 & mask ; y4 |= (y - (y >> 8)) ;
        y = y5 & mask ; y5 |= (y - (y >> 8)) ;
        y = y6 & mask ; y6 |= (y - (y >> 8)) ;
        y = y7 & mask ; y7 |= (y - (y >> 8)) ;
        /* Stray bits left over will be masked below */
      }
      ArrangRGB565(y0, y0);
      ArrangRGB565(y1, y1);
      ArrangRGB565(y2, y2);
      ArrangRGB565(y3, y3);
      ArrangRGB565(y4, y4);
      ArrangRGB565(y5, y5);
      ArrangRGB565(y6, y6);
      ArrangRGB565(y7, y7);
      *rgbData++ = y0 | (y1 << 16) | (y2 << 32) | (y3 << 48) ;
      *rgbData++ = y4 | (y5 << 16) | (y6 << 32) | (y7 << 48) ;
    }
  }
  return(SconErrorNone);
}

SconStatus_t scon422ToRGB888(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable)
{
  unsigned qword y, u, v, mask ;
  unsigned qword y0, y1, y2, y3 ;
  unsigned qword u01, v01, u23, v23 ;
  unsigned dword *yData=(unsigned dword *)inimage;
  unsigned word *uData=(unsigned word *)(inimage+width*height);
  unsigned word *vData=(unsigned word *)(inimage+(width*height*3)/2);
  unsigned dword *rgbData=(unsigned dword *)outimage;
  unsigned dword x, line;
  if (stride<0) /* flip */
    outimage=outimage+((height-1)*(-stride));
  for (line=height; line>0; line--, outimage+=stride)
  {
    rgbData=(unsigned dword *)outimage;
    for (x=width>>2; x>0; x--)
    {
      y   = *yData++ ;
      y0  = y & 255 ; y >>= 8 ;
      y1  = y & 255 ; y >>= 8 ;
      y2  = y & 255 ; y >>= 8 ;
      y3  = y & 255 ;

      u   = *uData++ ;
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ;

      v   = *vData++ ;
      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ;

      y0  = pTable[y0] ;
      y1  = pTable[y1] ;
      y2  = pTable[y2] ;
      y3  = pTable[y3] ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;
      /* Now, convert to RGB */
      y0 += u01 + v01 ;
      y1 += u01 + v01 ;
      y2 += u23 + v23 ;
      y3 += u23 + v23 ;
      /* See if any value is out of range. */
      mask = (unsigned qword)0x0F000F000F000F00L;
      if( (y0 | y1 | y2 | y3) & mask )
      {
	      /* Zero values that are negative */
        mask = (unsigned qword)0x0800080008000800L ;
        y = y0 & mask ; y0 &= ~(y - (y>>11)) ;
        y = y1 & mask ; y1 &= ~(y - (y>>11)) ;
        y = y2 & mask ; y2 &= ~(y - (y>>11)) ;
        y = y3 & mask ; y3 &= ~(y - (y>>11)) ;
        /* Clamp values that are > 255 to 255. */
        mask = (unsigned qword)0x0100010001000100L ;
        y = y0 & mask ; y0 |= (y - (y >> 8)) ;
        y = y1 & mask ; y1 |= (y - (y >> 8)) ;
        y = y2 & mask ; y2 |= (y - (y >> 8)) ;
        y = y3 & mask ; y3 |= (y - (y >> 8)) ;
        /* Stray bits left over will be masked below */
      }
      ArrangRGB888(y0, y0);
      ArrangRGB888(y1, y1);
      ArrangRGB888(y2, y2);
      ArrangRGB888(y3, y3);
      *rgbData++ = (unsigned dword)(y0 | (y1 << 24));
      *rgbData++ = (unsigned dword)((y1 & 0xFFFF) | (y2 << 16));
      *rgbData++ = (unsigned dword)((y2 & 0xFF) | (y3 << 8));
    }
  }
  return(SconErrorNone);
}

SconStatus_t scon420ToRGB565(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable)
{
  unsigned qword y, u, v, mask ;
  unsigned qword y0, y1, y2, y3 ;
  unsigned qword y4, y5, y6, y7 ;
  unsigned qword u01, v01, u23, v23;
  unsigned qword  *yData=(unsigned qword *)inimage;
  unsigned int *uData=(unsigned int *)(inimage+width*height);
  unsigned int *vData=(unsigned int *)(inimage+(width*height*5)/4);
  unsigned int *puData, *pvData;
  unsigned qword *rgbData=(unsigned qword *)outimage;
  unsigned dword x, line;
  if (stride<0) /* flip */
    outimage=outimage+((height-1)*(-stride));
  puData=uData;
  pvData=vData;
  for (line=(height>>1)<<1; line>0; line--, outimage+=stride)
  {
    rgbData=(unsigned qword *)outimage;
    if (line&1) /* odd line, reuse U and V */
    {
      puData=uData;
      pvData=vData;
    }
    else
    {
      uData=puData;
      vData=pvData;
    }
    for (x=width>>3; x>0; x--)
    {
      y   = *yData++ ;
      y0  = y & 255 ; y >>= 8 ;
      y1  = y & 255 ; y >>= 8 ;
      y2  = y & 255 ; y >>= 8 ;
      y3  = y & 255 ;	y >>= 8 ;
      y4  = y & 255 ;	y >>= 8 ;
      y5  = y & 255 ;	y >>= 8 ;
      y6  = y & 255 ;	y >>= 8 ;
      y7  = y & 255 ;	y >>= 8 ;

      u   = *puData++ ;
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ; u >>= 8 ;

      v   = *pvData++ ;
      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ; v >>= 8 ;

      y0  = pTable[y0] ;
      y1  = pTable[y1] ;
      y2  = pTable[y2] ;
      y3  = pTable[y3] ;
      y4  = pTable[y4] ;
      y5  = pTable[y5] ;
      y6  = pTable[y6] ;
      y7  = pTable[y7] ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;

      /* Now, convert to RGB */
      y0 += u01 + v01 ;
      y1 += u01 + v01 ;
      y2 += u23 + v23 ;
      y3 += u23 + v23 ;
      /*
       * Same thing for more pixels.
       * Use u01 for u45 and u23 for u67
       */
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ;

      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;
      /* Convert to RGB. */
      y4 += u01 + v01 ;
      y5 += u01 + v01 ;
      y6 += u23 + v23 ;
      y7 += u23 + v23 ;
      /* See if any value is out of range. */
      mask = (unsigned qword)0x0F000F000F000F00L;
      if( (y0 | y1 | y2 | y3 | y4 | y5 | y6 | y7) & mask )
      {
	      /* Zero values that are negative */
        mask = (unsigned qword)0x0800080008000800L ;
        y = y0 & mask ; y0 &= ~(y - (y>>11)) ;
        y = y1 & mask ; y1 &= ~(y - (y>>11)) ;
        y = y2 & mask ; y2 &= ~(y - (y>>11)) ;
        y = y3 & mask ; y3 &= ~(y - (y>>11)) ;
        y = y4 & mask ; y4 &= ~(y - (y>>11)) ;
        y = y5 & mask ; y5 &= ~(y - (y>>11)) ;
        y = y6 & mask ; y6 &= ~(y - (y>>11)) ;
        y = y7 & mask ; y7 &= ~(y - (y>>11)) ;
        /* Clamp values that are > 255 to 255. */
        mask = (unsigned qword)0x0100010001000100L ;
        y = y0 & mask ; y0 |= (y - (y >> 8)) ;
        y = y1 & mask ; y1 |= (y - (y >> 8)) ;
        y = y2 & mask ; y2 |= (y - (y >> 8)) ;
        y = y3 & mask ; y3 |= (y - (y >> 8)) ;
        y = y4 & mask ; y4 |= (y - (y >> 8)) ;
        y = y5 & mask ; y5 |= (y - (y >> 8)) ;
        y = y6 & mask ; y6 |= (y - (y >> 8)) ;
        y = y7 & mask ; y7 |= (y - (y >> 8)) ;
        /* Stray bits left over will be masked below */
      }
      ArrangRGB565(y0, y0);
      ArrangRGB565(y1, y1);
      ArrangRGB565(y2, y2);
      ArrangRGB565(y3, y3);
      ArrangRGB565(y4, y4);
      ArrangRGB565(y5, y5);
      ArrangRGB565(y6, y6);
      ArrangRGB565(y7, y7);
      *rgbData++ = y0 | (y1 << 16) | (y2 << 32) | (y3 << 48) ;
      *rgbData++ = y4 | (y5 << 16) | (y6 << 32) | (y7 << 48) ;
    }
  }
  return(SconErrorNone);
}

SconStatus_t scon420ToRGB888(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable)
{
  unsigned qword y, u, v, mask ;
  unsigned qword y0, y1, y2, y3 ;
  unsigned qword u01, v01, u23, v23;
  unsigned dword *yData=(unsigned dword *)inimage;
  unsigned word *uData=(unsigned word *)(inimage+width*height);
  unsigned word *vData=(unsigned word *)(inimage+(width*height*5)/4);
  unsigned word *puData, *pvData;
  unsigned dword *rgbData=(unsigned dword *)outimage;
  unsigned dword x, line;
  if (stride<0) /* flip */
    outimage=outimage+((height-1)*(-stride));
  puData=uData;
  pvData=vData;
  for (line=(height>>1)<<1; line>0; line--, outimage+=stride)
  {
    rgbData=(unsigned dword *)outimage;
    if (line&1) /* odd line, reuse U and V */
    {
      puData=uData;
      pvData=vData;
    }
    else
    {
      uData=puData;
      vData=pvData;
    }
    for (x=width>>2; x>0; x--)
    {
      y   = *yData++ ;
      y0  = y & 255 ; y >>= 8 ;
      y1  = y & 255 ; y >>= 8 ;
      y2  = y & 255 ; y >>= 8 ;
      y3  = y & 255 ;

      u   = *puData++ ;
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ;

      v   = *pvData++ ;
      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ;

      y0  = pTable[y0] ;
      y1  = pTable[y1] ;
      y2  = pTable[y2] ;
      y3  = pTable[y3] ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;

      /* Now, convert to RGB */
      y0 += u01 + v01 ;
      y1 += u01 + v01 ;
      y2 += u23 + v23 ;
      y3 += u23 + v23 ;
      /* See if any value is out of range. */
      mask = (unsigned qword)0x0F000F000F000F00L;
      if( (y0 | y1 | y2 | y3) & mask )
      {
	      /* Zero values that are negative */
        mask = (unsigned qword)0x0800080008000800L ;
        y = y0 & mask ; y0 &= ~(y - (y>>11)) ;
        y = y1 & mask ; y1 &= ~(y - (y>>11)) ;
        y = y2 & mask ; y2 &= ~(y - (y>>11)) ;
        y = y3 & mask ; y3 &= ~(y - (y>>11)) ;
        /* Clamp values that are > 255 to 255. */
        mask = (unsigned qword)0x0100010001000100L ;
        y = y0 & mask ; y0 |= (y - (y >> 8)) ;
        y = y1 & mask ; y1 |= (y - (y >> 8)) ;
        y = y2 & mask ; y2 |= (y - (y >> 8)) ;
        y = y3 & mask ; y3 |= (y - (y >> 8)) ;
        /* Stray bits left over will be masked below */
      }
      ArrangRGB888(y0, y0);
      ArrangRGB888(y1, y1);
      ArrangRGB888(y2, y2);
      ArrangRGB888(y3, y3);
      *rgbData++ = (unsigned dword)(y0 | (y1 << 24));
      *rgbData++ = (unsigned dword)((y1 >> 8) | (y2 << 16));
      *rgbData++ = (unsigned dword)((y2 >> 16) | (y3 << 8));
    }
  }
  return(SconErrorNone);
}

/********************************** YUV to RGB ***********************************/
SconStatus_t sconInitRGBtoYUV(SconInfo_t *Info)
{
  unsigned dword i, y, u, v ;
  qword *RedToYuyv, *GreenToYuyv, *BlueToYuyv;

  /* allocate memory to hold the lookup table */
  if (Info->Table && Info->TableSize<256*3*8)
  {
    ScPaFree(Info->Table);
    Info->Table=NULL;
  }
  if (Info->Table==NULL)
  {
    if ((Info->Table = ScPaMalloc(256*3*8)) == NULL)
      return(SconErrorMemory);
    Info->TableSize=256*3*8;
  }
  RedToYuyv=(unsigned qword *)Info->Table;
  GreenToYuyv=RedToYuyv+256;
  BlueToYuyv=RedToYuyv+512;

  for( i=0 ; i<256 ; i++ )
  {
    /*
     * Calculate contribution from red.
     * We will also add in the constant here.
     * Pack it into the tables thus: lsb->YUYV<-msb
     */
    y = (unsigned dword) ((float)YC + (float)YR * (float)i) ;
    u = (unsigned dword) ((float)UC + (float)UR * (float)(255-i)) ;
    v = (unsigned dword) ((float)VC + (float)VR * (float)i) ;
    RedToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;
    /*
     * Calculate contribution from green.
     */
    y = (unsigned dword) ((float)YG * (float)i) ;
    u = (unsigned dword) ((float)UG * (float)(255-i)) ;
    v = (unsigned dword) ((float)VG * (float)(255-i)) ;
    GreenToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;
    /*
     * Calculate contribution from blue.
     */
    y = (unsigned dword) ((float)YB * (float)i) ;
    u = (unsigned dword) ((float)UB * (float)i) ;
    v = (unsigned dword) ((float)VB * (float)(255-i)) ;
    BlueToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;
  }
  return(SconErrorNone);
}

/*
** Name:    sconRGB888To420
** Purpose: convert 24-bit RGB (8:8:8 format) to 16-bit YCrCb (4:1:1 format)
*/
SconStatus_t sconRGB888To420(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable)
{
  unsigned char *yData=(unsigned char *)outimage;
  unsigned char *uData=(unsigned char *)(outimage+width*height);
  unsigned char *vData=(unsigned char *)(outimage+(width*height*5)/4);
  register unsigned dword row, col;
  unsigned dword yuyv, r, g, b;
  unsigned char *tmp, *evl, *odl;
  if (stride<0)
    inimage=inimage+(-stride*(height-1));
  for (row=height; row>0; row--)
  {
    if (row&1)
    {
      tmp=inimage;
      for (col = 0; col < width; col++)
      {
        r = *tmp++;
        g = *tmp++;
        b = *tmp++;
        yuyv = (unsigned dword)(pTable[r] + pTable[g+256] + pTable[b+512]);
        *yData++ = (yuyv&0xff);
      }
      inimage+=stride;
    }
    else
    {
      tmp = evl = inimage;
      inimage+=stride;
      odl = inimage;
      for (col = 0; col < width; col++)
      {
        r = *tmp++;
        g = *tmp++;
        b = *tmp++;
        yuyv = (unsigned dword)(pTable[r] + pTable[g+256] + pTable[b+512]);
        *yData++ = (yuyv&0xff);
        /* We only store every fourth value of u and v components */
        if (col & 1)
        {
          /* Compute average r, g and b values */
          r = (unsigned dword)*evl++ + (unsigned dword)*odl++;
          g = (unsigned dword)*evl++ + (unsigned dword)*odl++;
          b = (unsigned dword)*evl++ + (unsigned dword)*odl++;
          r += (unsigned dword)*evl++ + (unsigned dword)*odl++;
          g += (unsigned dword)*evl++ + (unsigned dword)*odl++;
          b += (unsigned dword)*evl++ + (unsigned dword)*odl++;
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;
          yuyv = (unsigned dword)(pTable[r] + pTable[g+256] + pTable[b+512]);
          *uData++ = (yuyv>>24)& 0xff;       // V
          *vData++ = (yuyv>>8) & 0xff;       // U
        }
      }
    }
  }
  return(SconErrorNone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\sv.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: SV.h,v $
 * Revision 1.1.10.6  1996/10/28  17:32:21  Hans_Graves
 * 	MME-01402. Added TimeStamp support to Callbacks.
 * 	[1996/10/28  17:05:52  Hans_Graves]
 *
 * Revision 1.1.10.5  1996/10/12  17:18:18  Hans_Graves
 * 	Rearranged PARAMs. Added SV_PARAM_HALFPEL and SV_PARAM_SKIPPEL.
 * 	[1996/10/12  16:55:44  Hans_Graves]
 * 
 * Revision 1.1.10.4  1996/09/18  23:45:53  Hans_Graves
 * 	More PARAMs
 * 	[1996/09/18  21:56:45  Hans_Graves]
 * 
 * Revision 1.1.10.3  1996/07/19  02:11:02  Hans_Graves
 * 	Added SV_PARAM_DEBUG
 * 	[1996/07/19  01:23:39  Hans_Graves]
 * 
 * Revision 1.1.10.2  1996/05/07  19:55:54  Hans_Graves
 * 	Added SV_HUFF_DECODE and SV_HUFF_ENCODE
 * 	[1996/05/07  17:23:47  Hans_Graves]
 * 
 * Revision 1.1.8.6  1996/04/10  21:47:20  Hans_Graves
 * 	Added PARAMs. Replaced externs with EXTERN.
 * 	[1996/04/10  21:22:51  Hans_Graves]
 * 
 * Revision 1.1.8.5  1996/04/04  23:35:03  Hans_Graves
 * 	Added SV_PARAM_FINALFORMAT enum
 * 	[1996/04/04  23:02:48  Hans_Graves]
 * 
 * Revision 1.1.8.4  1996/04/01  15:17:45  Bjorn_Engberg
 * 	Replace include mmsystem.h with windows.h and mmreg.h for NT.
 * 	[1996/04/01  14:58:57  Bjorn_Engberg]
 * 
 * Revision 1.1.8.3  1996/03/29  22:21:06  Hans_Graves
 * 	Include <mmsystem.h> here only
 * 	[1996/03/29  21:48:59  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/03/16  19:22:55  Karen_Dintino
 * 	added H261 NT includes
 * 	[1996/03/16  18:39:31  Karen_Dintino]
 * 
 * Revision 1.1.6.4  1996/02/06  22:53:54  Hans_Graves
 * 	Added PARAM enums
 * 	[1996/02/06  22:18:07  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/01/02  18:31:16  Bjorn_Engberg
 * 	Added and improved function prototypes.
 * 	[1996/01/02  15:03:05  Bjorn_Engberg]
 * 
 * Revision 1.1.6.2  1995/12/07  19:31:23  Hans_Graves
 * 	Added defs for SV_MPEG_ENCODE,SV_MPEG2_DECODE,SV_MPEG2_ENCODE,IT_FULL,FULL_WIDTH,FULL_HEIGHT
 * 	[1995/12/07  17:59:38  Hans_Graves]
 * 
 * Revision 1.1.2.18  1995/09/22  18:17:02  Hans_Graves
 * 	Remove MPEG_SUPPORT, H261_SUPPORT, and JPEG_SUPPORT
 * 	[1995/09/22  18:14:14  Hans_Graves]
 * 
 * Revision 1.1.2.17  1995/09/22  15:04:40  Hans_Graves
 * 	Added definitions for MPEG_SUPPORT, H261_SUPPORT, and JPEG_SUPPORT
 * 	[1995/09/22  15:04:22  Hans_Graves]
 * 
 * Revision 1.1.2.16  1995/09/20  14:59:39  Bjorn_Engberg
 * 	Port to NT
 * 	[1995/09/20  14:40:10  Bjorn_Engberg]
 * 
 * 	Add ICMODE_OLDQ flag on ICOpen for softjpeg to use old quant tables
 * 	[1995/08/31  20:57:52  Paul_Gauthier]
 * 
 * Revision 1.1.2.15  1995/09/05  14:52:39  Hans_Graves
 * 	Removed BI_* definitions - moved to SC.h
 * 	[1995/09/05  14:50:45  Hans_Graves]
 * 
 * Revision 1.1.2.14  1995/08/31  21:13:27  Paul_Gauthier
 * 	Add SV_JPEG_QUANT_NEW/OLD definitions
 * 	[1995/08/31  21:13:04  Paul_Gauthier]
 * 
 * Revision 1.1.2.12  1995/08/08  13:21:17  Hans_Graves
 * 	Added Motion Estimation types
 * 	[1995/08/07  22:03:30  Hans_Graves]
 * 
 * Revision 1.1.2.11  1995/07/31  21:11:02  Karen_Dintino
 * 	Add yuv12 definition
 * 	[1995/07/31  19:27:58  Karen_Dintino]
 * 
 * Revision 1.1.2.10  1995/07/26  17:48:56  Hans_Graves
 * 	Added prototypes for sv_GetMpegImageInfo() and sv_GetH261ImageInfo().
 * 	[1995/07/26  17:45:14  Hans_Graves]
 * 
 * Revision 1.1.2.9  1995/07/21  17:41:03  Hans_Graves
 * 	Moved Callback related stuff to SC.h
 * 	[1995/07/21  17:27:31  Hans_Graves]
 * 
 * Revision 1.1.2.8  1995/07/17  22:01:33  Hans_Graves
 * 	Defined SvBufferInfo_t as ScBufferInfo_t.
 * 	[1995/07/17  21:45:06  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/07/17  16:12:05  Hans_Graves
 * 	Added extern's to prototypes.
 * 	[1995/07/17  15:56:16  Hans_Graves]
 * 
 * Revision 1.1.2.6  1995/07/01  18:43:17  Karen_Dintino
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.4 **}
 * 		{** Merge revision:	1.1.2.5 **}
 * 	{** End **}
 * 	Add H.261 Decompress support
 * 	[1995/07/01  18:27:43  Karen_Dintino]
 * 
 * Revision 1.1.2.5  1995/06/22  21:35:06  Hans_Graves
 * 	Moved filetypes to SC.h
 * 	[1995/06/22  21:29:42  Hans_Graves]
 * 
 * 	Added TimeCode parameter to SvPictureInfo struct
 * 	[1995/04/26  19:23:55  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/06/19  20:30:48  Karen_Dintino
 * 	Added support for H.261
 * 	[1995/06/19  20:13:47  Karen_Dintino]
 * 
 * Revision 1.1.2.3  1995/06/09  18:33:31  Hans_Graves
 * 	Added SvGetInputBitstream() prototype.
 * 	[1995/06/09  16:36:52  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:38  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:28:39  Hans_Graves]
 * 
 * Revision 1.1.2.9  1995/01/17  16:40:30  Paul_Gauthier
 * 	Use Modified Adjust LUTs for Indeo video
 * 	[1995/01/17  16:38:31  Paul_Gauthier]
 * 
 * Revision 1.1.2.8  1994/12/12  15:39:28  Paul_Gauthier
 * 	Merge changes from other SLIB versions
 * 	[1994/12/12  15:34:59  Paul_Gauthier]
 * 
 * Revision 1.1.2.7  1994/11/18  18:48:26  Paul_Gauthier
 * 	Cleanup & bug fixes
 * 	[1994/11/18  18:45:02  Paul_Gauthier]
 * 
 * Revision 1.1.2.6  1994/11/08  21:58:59  Paul_Gauthier
 * 	Changed <mmsystem.h> to <mme/mmsystem.h>
 * 	[1994/11/08  21:47:58  Paul_Gauthier]
 * 
 * Revision 1.1.2.5  1994/10/25  19:17:47  Paul_Gauthier
 * 	Changes for random access
 * 	[1994/10/25  19:09:07  Paul_Gauthier]
 * 
 * Revision 1.1.2.4  1994/10/13  20:34:55  Paul_Gauthier
 * 	MPEG cleanup
 * 	[1994/10/12  21:08:45  Paul_Gauthier]
 * 
 * Revision 1.1.2.3  1994/10/10  21:45:43  Tom_Morris
 * 	Rename Status to not conflict with X11
 * 	[1994/10/10  21:44:59  Tom_Morris]
 * 
 * Revision 1.1.2.2  1994/10/07  14:51:19  Paul_Gauthier
 * 	SLIB v3.0 incl. MPEG Decode
 * 	[1994/10/07  13:56:05  Paul_Gauthier]
 * 
 * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0 
** 
** FILE NAME:   
** MODULE NAME: 
**
** MODULE DESCRIPTION: 
** 
** DESIGN OVERVIEW: 
** 
**--
*/
/*	"%Z% %M% revision %I%; last modified %G%"; */
/*
**                              SV.h 
**
**    User required data structures for Software Video Codec
**
*/

/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1993                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*---------------------------------------------------------------------------
 * Modification History: SV.h 
 *
 *   08-Sep-1994  PSG   Modified to include MPEG decoder
 *   10-Jan-1994  VB	Created for SLIB 
 *--------------------------------------------------------------------------*/

#ifndef _SV_H_
#define _SV_H_

#ifndef _SV_COMMON_
#define _SV_COMMON_

#include <sys/types.h>
#include "SC.h"

#define SV_CONTINUE 0
#define SV_ABORT    1

typedef void      *SvHandle_t;       /* Identifies a codec or renderer */
typedef ScStatus_t SvStatus_t;       /* Return status code */

#ifdef WIN32
#include <windows.h>
#include <mmreg.h>
#else /* !WIN32 */
#include <mmsystem.h> 
#endif /* !WIN32 */

#endif /* _SV_COMMON_ */

#define SV_USE_BUFFER       STREAM_USE_BUFFER
#define SV_USE_BUFFER_QUEUE STREAM_USE_QUEUE
#define SV_USE_FILE         STREAM_USE_FILE

typedef enum {
   SV_JPEG_DECODE = 100,
   SV_JPEG_ENCODE = 101,
   SV_MPEG_DECODE = 102,
   SV_MPEG_ENCODE = 103,
   SV_MPEG2_DECODE = 104,
   SV_MPEG2_ENCODE = 105,
   SV_H261_DECODE = 106,
   SV_H261_ENCODE = 107,
   SV_H263_DECODE = 108,
   SV_H263_ENCODE = 109,
   SV_HUFF_DECODE = 110,
   SV_HUFF_ENCODE = 111
} SvCodecType_e;

/*
** Parameters
*/
typedef enum {
  /* General params */
  SV_PARAM_WIDTH = 0x10,    /* image width */
  SV_PARAM_HEIGHT,          /* image height */
  SV_PARAM_BITRATE,         /* bit rate (bits per second) */
  SV_PARAM_NATIVEFORMAT,    /* native decompressed format (FOURCC) */
  SV_PARAM_FINALFORMAT,     /* Final format (format returned by codec) */
  SV_PARAM_BITSPERPIXEL,    /* Average bits per pixel */
  SV_PARAM_FPS,             /* frames per second */
  SV_PARAM_ASPECTRATIO,     /* Aspect ratio: height/width */
  SV_PARAM_BITSTREAMING,    /* is this a bitstreaming CODEC */
  /* Frame params */
  SV_PARAM_FRAME = 0x30,    /* current frame number */
  SV_PARAM_KEYSPACING,      /* I frames */
  SV_PARAM_SUBKEYSPACING,   /* P frames */
  /* Timecode/length */
  SV_PARAM_TIMECODE = 0x50, /* Actual frame timecode */
  SV_PARAM_CALCTIMECODE,    /* Calculated frame timecode for start of seq */
  SV_PARAM_LENGTH,          /* total video length in miliiseconds */
  SV_PARAM_FRAMES,          /* total video frames */
  /* Decode params */
  SV_PARAM_FRAMETYPE = 0x70, /* I, P, B or D frame */
  /* Encode params */
  SV_PARAM_ALGFLAGS,        /* Algorithm flags */
  SV_PARAM_MOTIONALG,       /* Motion estimation algorithm */
  SV_PARAM_MOTIONSEARCH,    /* Motion search limit */
  SV_PARAM_MOTIONTHRESH,    /* Motion threshold */
  SV_PARAM_QUANTI,          /* Intra-frame Quantization Step */
  SV_PARAM_QUANTP,          /* Inter-frame Quantization Step */
  SV_PARAM_QUANTB,          /* Bi-drectional frame Quantization Step */
  SV_PARAM_QUANTD,          /* D (preview) frame Quantization Step */
  /* Encode/Decode params */
  SV_PARAM_QUALITY=0x90,    /* Quality: 0=worst 99>=best */
  SV_PARAM_FASTDECODE,      /* Fast decode desired */
  SV_PARAM_FASTENCODE,      /* Fast decode desired */
  SV_PARAM_VBVBUFFERSIZE,   /* Video Buffer Verifier buffer size in bytes */
  SV_PARAM_VBVDELAY,        /* Video Buffer Verifier delay */
  SV_PARAM_FORMATEXT,       /* format extensions (i.e. rtp) */
  SV_PARAM_PACKETSIZE,      /* packet size in bytes (rtp) */
  SV_PARAM_DEBUG,           /* Setup debug info */
} SvParameter_t;

/*
** Old & new quantization modes for use by the "convertjpeg" program
** that converts JPEG clips using old quantiztion algorithm to new algorithm
*/
typedef enum {
   SV_JPEG_QUANT_NEW = 0,
   SV_JPEG_QUANT_OLD = 1
} SvQuantMode_e;

/*
** Store basic info for user about the codec
*/
typedef struct SV_INFO_s {
    u_int Version;              /* Codec version number  */
    int   CodecStarted;         /* SvDecompressBegin/End */
    u_int NumOperations;        /* Current # of decompresses */
} SV_INFO_t;

/*
** Image types
*/
#define IT_NTSC 0
#define IT_CIF  1
#define IT_QCIF 2
#define IT_FULL 3

/*
** Algorithms (Motion Estimation)
*/
#define ME_CRAWL        1
#define ME_BRUTE        2
#define ME_TEST1        3
#define ME_TEST2        4
#define ME_FASTEST      ME_CRAWL

/*
** Standard Image sizes
*/
#define FULL_WIDTH      640
#define FULL_HEIGHT     480
#define NTSC_WIDTH      320
#define NTSC_HEIGHT     240
#define SIF_WIDTH       352
#define SIF_HEIGHT      240
#define CIF_WIDTH       352
#define CIF_HEIGHT      288
#define SQCIF_WIDTH     128
#define SQCIF_HEIGHT    96
#define QCIF_WIDTH      176
#define QCIF_HEIGHT     144
#define CIF4_WIDTH      (CIF_WIDTH*2)
#define CIF4_HEIGHT     (CIF_HEIGHT*2)
#define CIF16_WIDTH     (CIF_WIDTH*4)
#define CIF16_HEIGHT    (CIF_HEIGHT*4)

/******************** MPEG structures & constants ***************************/

/*
** Picture types
*/
#define SV_I_PICTURE 1
#define SV_P_PICTURE 2
#define SV_B_PICTURE 4
#define SV_D_PICTURE 8
#define SV_ANY_PICTURE  SV_I_PICTURE | SV_P_PICTURE | SV_B_PICTURE
#define SV_ALL_PICTURES SV_ANY_PICTURE | SV_D_PICTURE

/*
** Status values returned by SvFindNextPicture
*/
#define SV_CAN_DECOMPRESS    1
#define SV_CANNOT_DECOMPRESS 2

/*
** SvPictureInfo_t describes picture found by CODEC
*/
typedef struct SvPictureInfo_s {
  int Type;                     /* SV_I_PICTURE | SV_P_PICTURE |             */
                                /* SV_B_PICTURE | SV_D_PICTURE               */
  int myStatus;                   /* CAN_DECOMPRESS or CANNOT_DECOMPRESS     */
  int TemporalRef;              /* Temporal reference # from picture header  */
  int PicNumber;                /* Cummulative picture num from stream start */
  qword ByteOffset;             /* Cummulative byte offset from stream start */
  qword TimeCode;               /* TimeCode: hours (5 bits), min (6 bits),   */
                                /*           sec (6 bits), frame (6 bits)    */
} SvPictureInfo_t;

/*
** SvCallbackInfo_t passes info back & forth during callback
*/
typedef ScCallbackInfo_t SvCallbackInfo_t;

/*
** Structure used in sv_GetMpegImageInfo call
*/
typedef struct SvImageInfo_s {
  int len;                      /* Meaning depends on file format */
  int precision;                /* Bits per pixel */
  int height;                   /* Height of images in pixels */
  int width;                    /* Width  of images in pixels */
  int numcomps;                 /* Number of color components present */
  float picture_rate;           /* Picture rate decoded from seq header */
} SvImageInfo_t;

/******************** End of MPEG structures & constants *********************/


/******************** JPEG structures & constants ****************************/

/*
** Huffman Tables (JPEG)
*/
typedef struct SvHTable_s {
    u_int bits[16];
    u_int value[256];
} SvHTable_t;


typedef struct SvHuffmanTables_s {
    SvHTable_t DcY;
    SvHTable_t DcUV;
    SvHTable_t AcY;
    SvHTable_t AcUV;
} SvHuffmanTables_t;


/*
** Quantization Tables (JPEG)
*/
typedef u_int SvQTable_t;
typedef struct SvQuantTables_s {
    SvQTable_t c1[64];
    SvQTable_t c2[64];
    SvQTable_t c3[64];
} SvQuantTables_t;

/******************** End of JPEG structures & constants *********************/

/*
** Table of contents structure
*/
typedef struct SvToc_s {
    u_int offset;                 /* Byte offset of start of video frame */
    u_int size;                   /* Size in bytes of frame */
    u_int type;                   /* Type of frame (SV_I_PICTURE, ...) */
} SvToc_t;

typedef struct IndexStr {         /* AVI-format table of contents entry */
  size_t        size;
  unsigned long offset;
} IndexStr, indexStr;

#define SvSetRate(Svh, Rate) SvSetParamInt(Svh, SV_PARAM_BITRATE, Rate)
#define SvSetFrameRate(Svh, FrameRate) SvSetParamFloat(Svh, SV_PARAM_FPS, FrameRate)

EXTERN SvStatus_t SvOpenCodec (SvCodecType_e CodecType, SvHandle_t *Svh);
EXTERN SvStatus_t SvCloseCodec (SvHandle_t Svh);
EXTERN SvStatus_t SvDecompressQuery(SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                                    BITMAPINFOHEADER *ImgOut);
EXTERN SvStatus_t SvDecompressBegin (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                              BITMAPINFOHEADER *ImgOut);
EXTERN SvStatus_t SvGetDecompressSize (SvHandle_t Svh, int *MinSize);
EXTERN SvStatus_t SvDecompress (SvHandle_t Svh, u_char *CompData, int MaxCompLen,
			        u_char *DcmpImage, int MaxOutLen);
EXTERN SvStatus_t SvDecompressEnd (SvHandle_t Svh);
EXTERN SvStatus_t SvSetDataSource (SvHandle_t Svh, int Source, int Fd, 
    			           void *Buffer_UserData, int BufSize);
EXTERN SvStatus_t SvSetDataDestination (SvHandle_t Svh, int Source, int Fd, 
			                void *Buffer_UserData, int BufSize);
EXTERN ScBitstream_t *SvGetDataSource (SvHandle_t Svh);
EXTERN ScBitstream_t *SvGetDataDestination (SvHandle_t Svh);
EXTERN ScBitstream_t *SvGetInputBitstream (SvHandle_t Svh);
EXTERN SvStatus_t SvFlush(SvHandle_t Svh);
EXTERN SvStatus_t SvAddBuffer (SvHandle_t Svh, SvCallbackInfo_t *BufferInfo);
EXTERN SvStatus_t SvFindNextPicture (SvHandle_t Svh, 
                                     SvPictureInfo_t *PictureInfo);
#ifdef JPEG_SUPPORT
EXTERN SvStatus_t SvSetDcmpHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht);
EXTERN SvStatus_t SvGetDcmpHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht);
EXTERN SvStatus_t SvSetCompHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht);
EXTERN SvStatus_t SvGetCompHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht);
EXTERN SvStatus_t SvSetDcmpQTables (SvHandle_t Svh, SvQuantTables_t *Qt);
EXTERN SvStatus_t SvGetDcmpQTables (SvHandle_t Svh, SvQuantTables_t *Qt);
EXTERN SvStatus_t SvSetCompQTables (SvHandle_t Svh, SvQuantTables_t *Qt);
EXTERN SvStatus_t SvGetCompQTables (SvHandle_t Svh, SvQuantTables_t *Qt);
EXTERN SvStatus_t SvSetQuantMode (SvHandle_t Svh, int QuantMode);
EXTERN SvStatus_t SvGetQuality (SvHandle_t Svh, int *Quality);
EXTERN SvStatus_t SvSetQuality (SvHandle_t Svh, int Quality);
#endif /* JPEG_SUPPORT */

EXTERN SvStatus_t SvSetParamBoolean(SvHandle_t Svh, SvParameter_t param,
                                  ScBoolean_t value);
EXTERN SvStatus_t SvSetParamInt(SvHandle_t Svh, SvParameter_t param,
                                  qword value);
EXTERN SvStatus_t SvSetParamFloat(SvHandle_t Svh, SvParameter_t param,
                                  float value);
EXTERN ScBoolean_t SvGetParamBoolean(SvHandle_t Svh, SvParameter_t param);
EXTERN qword SvGetParamInt(SvHandle_t Svh, SvParameter_t param);
EXTERN float SvGetParamFloat(SvHandle_t Svh, SvParameter_t param);

EXTERN SvStatus_t SvCompressBegin (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                            BITMAPINFOHEADER *ImgOut);
EXTERN SvStatus_t SvCompressEnd (SvHandle_t Svh);
EXTERN SvStatus_t SvCompress (SvHandle_t Svh, u_char *CompData, int MaxCompLen,
			 u_char *InputImage, int InLen, int *CmpBytes);
EXTERN SvStatus_t SvCompressQuery (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                            BITMAPINFOHEADER *ImgOut);
EXTERN SvStatus_t SvGetCompressSize (SvHandle_t Svh, int *MaxSize);
EXTERN SvStatus_t SvGetInfo (SvHandle_t Svh, SV_INFO_t *lpinfo, 
                                             BITMAPINFOHEADER *ImgOut);
EXTERN SvStatus_t SvRegisterCallback (SvHandle_t, 
          int (*Callback)(SvHandle_t, SvCallbackInfo_t *, SvPictureInfo_t *),
          void *UserData);
#ifdef MPEG_SUPPORT
EXTERN SvStatus_t SvDecompressMPEG (SvHandle_t Svh, u_char *MultiBuf, 
			     int MaxMultiSize, u_char **ImagePtr);
EXTERN SvStatus_t sv_GetMpegImageInfo(int fd, SvImageInfo_t *iminfo);
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
EXTERN SvStatus_t SvDecompressH261 (SvHandle_t Svh, u_char *MultiBuf,
                             int MaxMultiSize, u_char **ImagePtr);
EXTERN SvStatus_t sv_GetH261ImageInfo(int fd, SvImageInfo_t *iminfo);
#endif /* H261_SUPPORT */

#endif /* _SV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\11to8.c ===
#include <stdio.h>
#include <memory.h>

#define BUF  220  // input buffer size for test main

#define OUT2(o,i,t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13) \
  t = ( (int)in[i]*t0 + (int)in[i+1]*t1 + \
    (int)in[i+2]*t2 + (int)in[i+3]*t3 + \
    (int)in[i+4]*t4 + (int)in[i+5]*t5 + \
    (int)in[i+6]*t6 + (int)in[i+7]*t7 + \
    (int)in[i+8]*t8 + (int)in[i+9]*t9 + \
    (int)in[i+8]*t10 + (int)in[i+9]*t11 + \
    (int)in[i+8]*t12 + (int)in[i+9]*t13 ) >> 10; \
  if (t < -32768) out[o] = -32768; else if (t > 32767) out[o]=32767; else out[o] = t;

//--------------------------------------------------------
void segment11to8(short *in, short *out)
{
  int t;
  
  OUT2(   0,   0,     7, -20,  12,  42,-140, 238,
    745, 238,-140,  42,  12, -20,   7,   0);
  OUT2(   1,   1,     4,  -4, -18,  62, -85,   0,
    654, 510, -99, -27,  49, -26,   3,   1);
  OUT2(   2,   2,     0,   6, -26,  38,   0,-126,
    422, 704,  70,-110,  61, -10,  -9,   5);
  OUT2(   3,   4,     6, -15,   0,  55,-129, 150,
    734, 330,-140,  24,  25, -24,   7,   0);
  OUT2(   4,   5,     2,   0, -24,  58, -56, -57,
    589, 589, -57, -56,  58, -24,   0,   2);
  OUT2(   5,   7,     7, -24,  25,  24,-140, 330,
    734, 150,-129,  55,   0, -15,   6,   0);
  OUT2(   6,   8,     5,  -9, -10,  61,-110,  70,
    704, 422,-126,   0,  38, -26,   6,   0);
  OUT2(   7,   9,     1,   3, -26,  49, -27, -99,
    510, 654,   0, -85,  62, -18,  -4,   4);
}
//--------------------------------------------------------
void convert11to8(short *in, short *out, short *prev, int len)
{
/*
  Convert a buffer from 11KHz to 8KHz.

  Note: len is number of shorts in input buffer, which MUST
  be a multiple of 11 and at least 44.

  How the overhang works:  The filter kernel for 1 section of
  11 input samples requires KERNEL (=25) samples of the input.  So we use 14
  samples of overhang from the previous frame, which means the
  beginning of this frame looks like:

    ppppppppppp ppp01234567 89abcdefghi 19.... 30.... / 41 42 43
    X           X           x           x

  So we first have to do two special segments (the ones starting
  at X) then we do the rest (the x's) in a loop.  For the example
  length=44 shown above, we'll do up & including 44-25=19, stopping on the
  last x shown.  Then we save 30-43 in the overhang buffer so that
  30 is the first group done on the next frame.
*/

#define OVERHANG2 14
#define KERNEL2   25

  int i,k;
  short tmp[KERNEL2+11];
  
// Convert the first two segments, where segment= 11 samples of input

  memcpy(tmp,prev,sizeof(short)*OVERHANG2);
  memcpy(tmp+OVERHANG2,in,sizeof(short)*(KERNEL2+11-OVERHANG2));

  segment11to8(tmp,out);
  segment11to8(tmp+11,out+8);

// Loop through the remaining segments

  k = 16;
  for (i=22-OVERHANG2; i<=len-KERNEL2; i+=11)
  {
    segment11to8(in+i,out+k);
    k += 8;
  }

// Save OVERHANG2 samples for next time

  memcpy(prev,in+len-OVERHANG2,sizeof(short)*OVERHANG2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\cb53.c ===
//cb53.c - 5.3 rate codebook code

#include "opt.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <memory.h>
#include "typedef.h"
#include "cst_lbc.h"
#include "tab_lbc.h"
#include "util_lbc.h"
#include "exc_lbc.h"
#include "timer.h"
#include "mmxutil.h"

void fourPulseFlt (float *rr, float *Dn, float thres, int ip[], int *shiftPtr);

//--------------------------------------------------------
int extra;
void reset_max_time(void)
{
  extra = 120;
}


//------------------------------------------------------------
int ACELP_LBC_code(float X[], float h[], int T0, float code[],
		int *ind_gain, int *shift, int *sign, float gain_T0, int flags)
{
  int i, index;
  float gain_q;
  float Dn[SubFrLen2], tmp_code[SubFrLen2];
  float rr[DIM_RR];

// Include fixed-gain pitch contribution into impulse resp. h[]

  if (T0 < SubFrLen-2)
    for (i = T0; i < SubFrLen; i++)
      h[i] += gain_T0*h[i-T0];

// Compute correlations of h[] needed for the codebook search

  Cor_h(h, rr);
 
// Compute correlation of target vector with impulse response.

  Cor_h_X(h, X, Dn);
  
// Find codebook index

  index = D4i64_LBC(Dn, rr, h, tmp_code, rr, shift, sign, flags);

// Compute innovation vector gain.
// Include fixed-gain pitch contribution into code[].

  *ind_gain = G_code(X, rr, &gain_q);

  for (i=0; i < SubFrLen; i++)
    code[i] = tmp_code[i]*gain_q;

  if(T0 < SubFrLen-2)
    for (i=T0; i < SubFrLen; i++)
      code[i] += code[i-T0]*gain_T0;

  return index;
}


//---------------------------------------------------------------
void Cor_h(float *H, float *rr)
{

//  Compute  correlations of h[]  needed for the codebook search.
//    h[]              :Impulse response.
//    rr[]             :Correlations.

  float *rri0i0, *rri1i1, *rri2i2, *rri3i3;
  float *rri0i1, *rri0i2, *rri0i3;
  float *rri1i2, *rri1i3, *rri2i3;

  float *p0, *p1, *p2, *p3;
  float cor, *h2;
  int i, k, m, t;
  float h[SubFrLen2];

  for(i=0; i<SubFrLen; i++)
    h[i+4] = H[i];

  for(i=0; i<4; i++)
    h[i] = 0.0f;

// Init pointers

  rri0i0 = rr;
  rri1i1 = rri0i0 + NB_POS;
  rri2i2 = rri1i1 + NB_POS;
  rri3i3 = rri2i2 + NB_POS;

  rri0i1 = rri3i3 + NB_POS;
  rri0i2 = rri0i1 + MSIZE;
  rri0i3 = rri0i2 + MSIZE;
  rri1i2 = rri0i3 + MSIZE;
  rri1i3 = rri1i2 + MSIZE;
  rri2i3 = rri1i3 + MSIZE;

// Compute rri0i0[], rri1i1[], rri2i2[] and rri3i3[]

  cor = 0.0f;
  m = 0;
  for(i=NB_POS-1; i>=0; i--)
  {
    cor += h[m+0]*h[m+0] + h[m+1]*h[m+1];   rri3i3[i] = cor*0.5f;
    cor += h[m+2]*h[m+2] + h[m+3]*h[m+3];   rri2i2[i] = cor*0.5f;
    cor += h[m+4]*h[m+4] + h[m+5]*h[m+5];   rri1i1[i] = cor*0.5f;
    cor += h[m+6]*h[m+6] + h[m+7]*h[m+7];   rri0i0[i] = cor*0.5f;

    m += 8;
  }

// Compute elements of: rri0i1[], rri0i3[], rri1i2[] and rri2i3[]

  h2 = h+2;
  p3 = rri2i3 + MSIZE-1;
  p2 = rri1i2 + MSIZE-1;
  p1 = rri0i1 + MSIZE-1;
  p0 = rri0i3 + MSIZE-2;
    
  for (k=0; k<NB_POS; k++)
  {
    cor = 0.0f;
    m = 0;
    t = 0;

    for(i=k+1; i<NB_POS; i++)
    {
      cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
      cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
      cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
      cor += h[m+6]*h2[m+6] + h[m+7]*h2[m+7];   p0[t] = cor;

      t -= (NB_POS+1);
      m += 8;
    }
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
    cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
    cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;

    h2 += STEP;
    p3 -= NB_POS;
    p2 -= NB_POS;
    p1 -= NB_POS;
    p0 -= 1;
  }


// Compute elements of: rri0i2[], rri1i3[] 

  h2 = h+4;
  p3 = rri1i3 + MSIZE-1;
  p2 = rri0i2 + MSIZE-1;
  p1 = rri1i3 + MSIZE-2;
  p0 = rri0i2 + MSIZE-2;
    
  for (k=0; k<NB_POS; k++)
  {
    cor = 0.0f;
    m = 0;
    t = 0;

    for(i=k+1; i<NB_POS; i++)
    {
      cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
      cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
      cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
      cor += h[m+6]*h2[m+6] + h[m+7]*h2[m+7];   p0[t] = cor;

      t -= (NB_POS+1);
      m += 8;
    }
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
    cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
    
    h2 += STEP;
    p3 -= NB_POS;
    p2 -= NB_POS;
    p1 -= 1;
    p0 -= 1;
  }
  
// Compute elements of: rri0i1[], rri0i3[], rri1i2[] and rri2i3[]

  h2 = h+6;
  p3 = rri0i3 + MSIZE-1;
  p2 = rri2i3 + MSIZE-2;
  p1 = rri1i2 + MSIZE-2;
  p0 = rri0i1 + MSIZE-2;
    
  for (k=0; k<NB_POS; k++)
  {
    cor = 0.0f;
    m = 0;
    t = 0;

    for(i=k+1; i<NB_POS; i++)
    {
      cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
      cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
      cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
      cor += h[m+6]*h2[m+6] + h[m+7]*h2[m+7];   p0[t] = cor;

      t -= (NB_POS+1);
      m += 8;
    }
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;

    h2 += STEP;
    p3 -= NB_POS;
    p2 -= 1;
    p1 -= 1;
    p0 -= 1;
  }
  
  return;
}

//---------------------------------------------------------------------------
void Cor_h_X(float h[],float X[],float D[])
{
   int i;
  
   for (i=0; i < SubFrLen; i++)	 
     D[i] = DotProd(&X[i],h,(SubFrLen-i));
	
   return;
}

//-------------------------------------------------------------------------
Find_Pulse4(float *Dn,float *rri3i3,float *ptr_ri0i3,float *ptr_ri1i3,
  float *ptr_ri2i3,float *ptr, float ps2,float alp2,float *psbest,float *abest)
{
  int k,bestk;
  float ps3;
  float a[16];

  for (k=0; k<8; k++)
  {
    ps3 = ps2 + *ptr;
    a[k] = alp2 + rri3i3[k] + ptr_ri0i3[k] + ptr_ri1i3[k] + ptr_ri2i3[k];
    a[k+8] = ps3 * ps3;
    
    ptr += STEP;
  }

  bestk = -1;
  for (k=0; k<8; k++)
  {
    if((a[k+8] * (*abest)) > ((*psbest) * a[k]))
    {
      *psbest = a[k+8];
      *abest = a[k];
      bestk = k;
    }
  }
  return(bestk);
}

//-------------------------------------------------------------------------
//   routine   D4i64_LBC                                                  
//           ~~~~~~~~~                                                   
// Algebraic codebook for LBC.                                           
//  -> 17 bits; 4 pulses in a frame of 60 samples                        
//                                                                       
// The code length is 60, containing 4 nonzero pulses i0, i1, i2, i3.    
// Each pulses can have 8 possible positions (positive or negative):     
//                                                                       
// i0 (+-1) : 0, 8,  16, 24, 32, 40, 48, 56                              
// i1 (+-1) : 2, 10, 18, 26, 34, 42, 50, 58                              
// i2 (+-1) : 4, 12, 20, 28, 36, 44, 52, (60)                            
// i3 (+-1) : 6, 14, 22, 30, 38, 46, 54, (62)                            
//                                                                       
// All the pulse can be shift by one.                                    
// The last position of the last 2 pulse falls outside the               
// frame and signifies that the pulse is not present.                    
//
//  Input arguments:                                                     
//                                                                       
//   Dn[]       Correlation between target vector and impulse response h[]
//   rr[]       Correlations of impulse response h[]                     
//   h[]        Impulse response of filters                              
//                                                                       
//  Output arguments:                                                   
//                                                                       
//   cod[]      Selected algebraic codeword                              
//   y[]        Filtered codeword                                        
//   code_shift Shift of the codeword                                    
//   sign       Signs of the 4 pulses.                                   
//                                                                       
//   return:    Index of selected codevector                             
//
// The threshold control if a section of the innovative              
// codebook should be searched or not.                               
//                                                                   
//--------------------------------------------------------------------

int D4i64_LBC(float Dn[], float rr[], float h[], float cod[],
			  float y[], int *code_shift, int *sign, int flags)
{
   int  ip[4];
   int  i0, i1, i2, i3, ip0, ip1, ip2, ip3;
   int  i, j;
   int  shif;
   float   means, max0, max1, max2, thres;

   float *rri0i0,*rri1i1,*rri2i2,*rri3i3;
   float *rri0i1,*rri0i2,*rri0i3;
   float *rri1i2,*rri1i3,*rri2i3;

  // float *ptr_ri0i0,*ptr_ri1i1,*ptr_ri2i2;
   float *ptr_ri0i1,*ptr_ri0i2,*ptr_ri0i3;
   float *ptr_ri1i2,*ptr_ri1i3,*ptr_ri2i3;

   int  p_sign[SubFrLen2/2];
//   float  p_sign[SubFrLen2/2],p_sign2[SubFrLen2/2];

// Init pointers 

  rri0i0 = rr;
  rri1i1 = rri0i0 + NB_POS;
  rri2i2 = rri1i1 + NB_POS;
  rri3i3 = rri2i2 + NB_POS;

  rri0i1 = rri3i3 + NB_POS;
  rri0i2 = rri0i1 + MSIZE;
  rri0i3 = rri0i2 + MSIZE;
  rri1i2 = rri0i3 + MSIZE;
  rri1i3 = rri1i2 + MSIZE;
  rri2i3 = rri1i3 + MSIZE;

 // Extend the backward filtered target vector by zeros                

   for (i=SubFrLen; i < SubFrLen2; i++) 
     Dn[i] = 0.0f;

// Chose the sign of the impulse.                                        

   for (i=0; i<SubFrLen; i+=2)
   {
     if((Dn[i] + Dn[i+1]) >= 0.0f)
     {
		 p_sign[i/2] = 0x00000000;
//       p_sign[i/2] = 1.0f;
//       p_sign2[i/2] = 2.0f;
     }
     else
     {
		 p_sign[i/2] = 0x80000000;
//       p_sign[i/2] = -1.0f;
//       p_sign2[i/2] = -2.0f;
       Dn[i] = -Dn[i];
       Dn[i+1] = -Dn[i+1];
     }
   }
   p_sign[30] = p_sign[31] = 0x00000000;
//   p_sign[30] = p_sign[31] = 1.0f;
//   p_sign2[30] = p_sign2[31] = 2.0f;

// - Compute the search threshold after three pulses                 
// odd positions 
// Find maximum of Dn[i0]+Dn[i1]+Dn[i2]

   max0 = Dn[0];
   max1 = Dn[2];
   max2 = Dn[4];
   for (i=8; i < SubFrLen; i+=STEP)
   {
     if (Dn[i] > max0)   max0 = Dn[i];
     if (Dn[i+2] > max1) max1 = Dn[i+2];
     if (Dn[i+4] > max2) max2 = Dn[i+4];
   }
   max0 = max0 + max1 + max2;

// Find means of Dn[i0]+Dn[i1]+Dn[i]

   means = 0.0f;
   for (i=0; i < SubFrLen; i+=STEP)
     means += Dn[i+4] + Dn[i+2] + Dn[i];

   means *= 0.125f;  
   if (flags & SC_THRES)
     thres = means*0.25f + max0*0.75f;
   else
     thres = means + (max0-means)*0.5f;
 
 // even positions 
 // Find maximum of Dn[i0]+Dn[i1]+Dn[i2]

   max0 = Dn[1];
   max1 = Dn[3];
   max2 = Dn[5];
   for (i=9; i < SubFrLen; i+=STEP)
   {
     if (Dn[i] > max0)   max0 = Dn[i];
     if (Dn[i+2] > max1) max1 = Dn[i+2];
     if (Dn[i+4] > max2) max2 = Dn[i+4];
   }
   max0 = max0 + max1 + max2;

// Find means of Dn[i0]+Dn[i1]+Dn[i2] 

   means = 0.0f;
   for (i=1; i < SubFrLen; i+=STEP)
     means += Dn[i+4] + Dn[i+2] + Dn[i];
  
   means *= 0.125f;
   if (flags & SC_THRES)
     max1 = means*0.25f + max0*0.75f;
   else
     max1 = means + (max0-means)*0.5f; 

// Keep maximum threshold between odd and even position 

   if(max1 > thres) thres = max1;

// Modification of rrixiy[] to take signs into account.
//TIMER_STAMP(a);            
  ptr_ri0i1 = rri0i1;
  ptr_ri0i2 = rri0i2;
  ptr_ri0i3 = rri0i3;

  for(i0=0; i0<SubFrLen/2; i0+=STEP/2)
  {
	 for(i1=2/2; i1<SubFrLen/2; i1+=STEP/2)
     {
	   (int)*ptr_ri0i1++ = (asint(*ptr_ri0i1) ^ p_sign[i0] ^ p_sign[i1]);
	   (int)*ptr_ri0i2++ = (asint(*ptr_ri0i2) ^ p_sign[i0] ^ p_sign[i1+1]);
	   (int)*ptr_ri0i3++ = (asint(*ptr_ri0i3) ^ p_sign[i0] ^ p_sign[i1+2]);
     }
  }

  ptr_ri1i2 = rri1i2;
  ptr_ri1i3 = rri1i3;
  for(i1=2/2; i1<SubFrLen/2; i1+=STEP/2)
  {
	 for(i2=4/2; i2<SubFrLen2/2; i2+=STEP/2)
     {
	   (int)*ptr_ri1i2++ = (asint(*ptr_ri1i2) ^ p_sign[i1] ^ p_sign[i2]);
	   (int)*ptr_ri1i3++ = (asint(*ptr_ri1i3) ^ p_sign[i1] ^ p_sign[i2+1]);
     }
  }

  ptr_ri2i3 = rri2i3;
  for(i2=4/2; i2<SubFrLen2/2; i2+=STEP/2)
  {
	 for(i3=6/2; i3<SubFrLen2/2; i3+=STEP/2)
	   (int)*ptr_ri2i3++ = (asint(*ptr_ri2i3) ^ p_sign[i2] ^ p_sign[i3]);
  }

//TIMER_STAMP(b);            
fourPulseFlt(rr, Dn, thres, ip, code_shift);
//TIMER_STAMP(c);            

ip0 = ip[0];
ip1 = ip[1];
ip2 = ip[2];
ip3 = ip[3];
shif = *code_shift;

// Set the sign of impulses 

 i0 = (p_sign[(ip0 >> 1)]>=0?1:-1);
 i1 = (p_sign[(ip1 >> 1)]>=0?1:-1);
 i2 = (p_sign[(ip2 >> 1)]>=0?1:-1);
 i3 = (p_sign[(ip3 >> 1)]>=0?1:-1);

// Find the codeword corresponding to the selected positions 

 for(i=0; i<SubFrLen; i++) 
   cod[i] = 0.0f;

 if(shif > 0)
 {
   ip0++;
   ip1++;
   ip2++;
   ip3++;
 }
 
//printf("%3d %3d %3d %3d\n",ip0*i0,ip1*i1,ip2*i2,ip3*i3);
 cod[ip0] =  (float)i0;
 cod[ip1] =  (float)i1;
 if(ip2<SubFrLen)
   cod[ip2] = (float)i2;
 if(ip3<SubFrLen)
   cod[ip3] = (float)i3;

// find the filtered codeword 

 for (i=0; i < SubFrLen; i++) 
   y[i] = 0.0f;

 if(i0 > 0)
   for(i=ip0, j=0; i<SubFrLen; i++, j++)
	   y[i] = y[i] + h[j];
 else
   for(i=ip0, j=0; i<SubFrLen; i++, j++)
       y[i] = y[i] - h[j];

 if(i1 > 0)
   for(i=ip1, j=0; i<SubFrLen; i++, j++)
	   y[i] = y[i] + h[j];
 else
   for(i=ip1, j=0; i<SubFrLen; i++, j++)
       y[i] = y[i] - h[j];

 if(ip2<SubFrLen)
 {
   if(i2 > 0)
	 for(i=ip2, j=0; i<SubFrLen; i++, j++)
         y[i] = y[i] + h[j];
   else
	 for(i=ip2, j=0; i<SubFrLen; i++, j++)
         y[i] = y[i] - h[j];
 }

 if(ip3<SubFrLen)
 {
   if(i3 > 0)
	 for(i=ip3, j=0; i<SubFrLen; i++, j++)
       y[i] = y[i] + h[j];
   else
	 for(i=ip3, j=0; i<SubFrLen; i++, j++)
       y[i] = y[i] - h[j];
 }

// find codebook index;  17-bit address 

 *code_shift = shif;

 *sign = 0;
 if(i0 > 0) *sign += 1;
 if(i1 > 0) *sign += 2;
 if(i2 > 0) *sign += 4;
 if(i3 > 0) *sign += 8;

 i = ((ip3 >> 3) << 9) + ((ip2 >> 3) << 6) + ((ip1 >> 3) << 3) + (ip0 >> 3);
//TIMER_STAMP(d);

 return i;
}

//--------------------------------------------------------------------
int G_code(float X[], float Y[], float *gain_q)
{
   int i;
   float xy, yy, gain_nq; 
   int gain;
   float dist, dist_min;

// Compute scalar product <X[],Y[]>
   
	xy = DotProd(X,Y,SubFrLen);

// Be sure xy < yy 

   if(xy <= 0) 
   {
	 gain = 0;
	 *gain_q =FcbkGainTable[gain];
	 return(gain);
   }

// Compute scalar product <Y[],Y[]> 
  
   yy = DotProd(Y,Y,SubFrLen);

   if (yy != 0.0f)
     gain_nq = xy/yy * 0.5f;
   else
     gain_nq = 0.0f;

   gain = 0;
   dist_min = (float)fabs(gain_nq - FcbkGainTable[0]);
 
   for (i=1; i <NumOfGainLev; i++) 
   {
	 dist = (float)fabs(gain_nq - FcbkGainTable[i]);
	 if (dist < dist_min) 
	 {
		dist_min = dist;
		gain = i;
	 }
   }
   *gain_q = FcbkGainTable[gain];
   return(gain);
}



 //-------------------------------------------------------------------
 // Search the optimum positions of the four  pulses which maximize   
 //     square(correlation) / energy                                  
 // The search is performed in four  nested loops. At each loop, one  
 // pulse contribution is added to the correlation and energy.        
 //                                                                   
 // The fourth loop is entered only if the correlation due to the     
 //  contribution of the first three pulses exceeds the preset        
 //  threshold.                                                       
 //-------------------------------------------------------------------
void fourPulseFlt (float *rr, float *Dn, float thres, int ip[], int *shifPtr){

 // Default values 

   int ip0    = 0;
   int ip1    = 2;
   int ip2    = 4;
   int ip3    = 6;
   int shif   = 0;
   int  i0, i1, i2;
   int  k, time;
   int  shift, bestk, lasti2, inc;
   float psc    = 0.0f;
   float alpha  = 1.0f;
   float  ps0, ps1, ps2, alp0;
   float  alp1, alp2;
   float  ps0a, ps1a, ps2a;
   float *ptr_ri0i0,*ptr_ri1i1,*ptr_ri2i2;
   float *ptr_ri0i1,*ptr_ri0i2,*ptr_ri0i3;
   float *ptr_ri1i2,*ptr_ri1i3,*ptr_ri2i3;

   float *rri0i0,*rri1i1,*rri2i2,*rri3i3;
   float *rri0i1,*rri0i2,*rri0i3;
   float *rri1i2,*rri1i3,*rri2i3;
   
   float a[16];
   float t1,t2,*pntr;
   float dmax4, dmax5, dmax2, dmax3; //used for bypass
#if !OPT_PULSE4
   int i3;
   float ps3;
#endif

 time   = max_time + extra;

 // Four loops to search innovation code.
 // Init. pointers that depend on first loop
  
  rri0i0 = rr;
  rri1i1 = rri0i0 + NB_POS;
  rri2i2 = rri1i1 + NB_POS;
  rri3i3 = rri2i2 + NB_POS;

  rri0i1 = rri3i3 + NB_POS;
  rri0i2 = rri0i1 + MSIZE;
  rri0i3 = rri0i2 + MSIZE;
  rri1i2 = rri0i3 + MSIZE;
  rri1i3 = rri1i2 + MSIZE;
  rri2i3 = rri1i3 + MSIZE;

 ptr_ri0i0 = rri0i0;    
 ptr_ri0i1 = rri0i1;
 ptr_ri0i2 = rri0i2;
 ptr_ri0i3 = rri0i3;

 // Compute the Dn max's

 dmax2 = dmax3 = dmax4 = dmax5 = -1000000.0f; //i.e., large negative number
 for (k = 2; k<SubFrLen2; k+=STEP)
 {
   if (Dn[k] > dmax2) dmax2 = Dn[k];
   if (Dn[k+1] > dmax3) dmax3 = Dn[k+1];
   if (Dn[k+2] > dmax4) dmax4 = Dn[k+2];
   if (Dn[k+3] > dmax5) dmax5 = Dn[k+3];
 }

// first pulse loop  
 for (i0=0; i0 < SubFrLen; i0 +=STEP)        
 {
   ps0  = Dn[i0];
   ps0a = Dn[i0+1];
   alp0 = *ptr_ri0i0++;

// Init. pointers that depand on second loop
 
   ptr_ri1i1 = rri1i1;    
   ptr_ri1i2 = rri1i2;
   ptr_ri1i3 = rri1i3;

   ps1 = ps0 + dmax2 + dmax4;
   ps1a = ps0a + dmax3 + dmax5;
   if (asint(ps1) < asint(thres) && asint(ps1a) < asint(thres))
   {
	 ptr_ri0i1 += NB_POS;
	 goto skipsecond;
   }

 // second pulse loop

   for (i1=2; i1 < SubFrLen; i1 +=STEP)     
   {
	 ps1  = ps0 + Dn[i1];
	 ps1a = ps0a + Dn[i1+1];

	 alp1 = alp0 + *ptr_ri1i1++ + *ptr_ri0i1++; 

// Init. pointers that depend on third loop
 
     ptr_ri2i2 = rri2i2;     
     ptr_ri2i3 = rri2i3;
     lasti2 = 4;
 
     ps2 = ps1 + dmax4;
     ps2a = ps1a + dmax5;
     if (asint(ps2) < asint(thres) && asint(ps2a) < asint(thres))
     {
	   i2 = 68;
	   goto skipthird;
     }

// third pulse loop

	 for (i2 = 4; i2 < SubFrLen2; i2 +=STEP)    
   {
	   ps2  = ps1 + Dn[i2];
	   ps2a = ps1a + Dn[i2+1];

// Threshold test and 4th pulse loop.  Since the probability of
// entering this is low, we cram as much of the 3rd-pulse-loop
// logic inside the threshold test.  So the computation of shift,
// the choice of ps2 vs ps2a, the computation of alp2, and the
// incrementing of the 02,12,22 pointers are all done there.
     
     if (asint(ps2) > asint(thres) || asint(ps2a) > asint(thres))
	   {
       shift = 0;
       if(asint(ps2a) > asint(ps2))
       {
         shift = 1;
         ps2   = ps2a;
       }

       inc = (i2 - lasti2) >> 3;
       lasti2 = i2;
       ptr_ri0i2 += inc;
       ptr_ri1i2 += inc;
       ptr_ri2i2 += inc;

       alp2 = alp1 + *ptr_ri2i2 + *ptr_ri0i2 + *ptr_ri1i2; 
       pntr = &Dn[6+shift];

#if OPT_PULSE4

  ASM
  {
    push esi;
    push ebx;

    mov esi,pntr;

;// First half of first loop

    fld DP [esi+4*8*0];
    fld DP [esi+4*8*1];
    fld DP [esi+4*8*2];
    fld DP [esi+4*8*3];

    fxch ST(3);
    fadd ps2;
    fxch ST(2);
    fadd ps2;
    fxch ST(1);
    fadd ps2;
    fxch ST(3);
    fadd ps2;

    fxch ST(2);
    fmul ST,ST(0);
    fxch ST(1);
    fmul ST,ST(0);
    fxch ST(3);
    fmul ST,ST(0);
    fxch ST(2);
    fmul ST,ST(0);

    fxch ST(1);
    fstp a[4*8];
    fxch ST(2);
    fstp a[4*9];
    fstp a[4*10];
    fstp a[4*11];

;// Second half of first loop

    fld DP [esi+4*8*4];
    fld DP [esi+4*8*5];
    fld DP [esi+4*8*6];
    fld DP [esi+4*8*7];

    fxch ST(3);
    fadd ps2;
    fxch ST(2);
    fadd ps2;
    fxch ST(1);
    fadd ps2;
    fxch ST(3);
    fadd ps2;

    fxch ST(2);
    fmul ST,ST(0);
    fxch ST(1);
    fmul ST,ST(0);
    fxch ST(3);
    fmul ST,ST(0);
    fxch ST(2);
    fmul ST,ST(0);

    fxch ST(1);
    fstp a[4*12];
    fxch ST(2);
    fstp a[4*13];
    fstp a[4*14];
    fstp a[4*15];

;// First half of second loop

    mov eax,rri3i3;
    mov ebx,ptr_ri0i3;
    mov ecx,ptr_ri1i3;
    mov edx,ptr_ri2i3;

    fld alp2;
    fld alp2;
    fld alp2;
    fld alp2;

    fxch ST(3);
    fadd DP [eax+4*0];
    fxch ST(2);
    fadd DP [eax+4*1];
    fxch ST(1);
    fadd DP [eax+4*2];
    fxch ST(3);
    fadd DP [eax+4*3];

    fxch ST(2);
    fadd DP [ebx+4*0];
    fxch ST(1);
    fadd DP [ebx+4*1];
    fxch ST(3);
    fadd DP [ebx+4*2];
    fxch ST(2);
    fadd DP [ebx+4*3];

    fxch ST(1);
    fadd DP [ecx+4*0];
    fxch ST(3);
    fadd DP [ecx+4*1];
    fxch ST(2);
    fadd DP [ecx+4*2];
    fxch ST(1);
    fadd DP [ecx+4*3];

    fxch ST(3);
    fadd DP [edx+4*0];
    fxch ST(2);
    fadd DP [edx+4*1];
    fxch ST(1);
    fadd DP [edx+4*2];
    fxch ST(3);
    fadd DP [edx+4*3];

    fxch ST(2);
    fstp a[4*0];
    fstp a[4*1];
    fxch ST(1);
    fstp a[4*2];
    fstp a[4*3];

;// Second half of second loop

    fld alp2;
    fld alp2;
    fld alp2;
    fld alp2;

    fxch ST(3);
    fadd DP [eax+4*4];
    fxch ST(2);
    fadd DP [eax+4*5];
    fxch ST(1);
    fadd DP [eax+4*6];
    fxch ST(3);
    fadd DP [eax+4*7];

    fxch ST(2);
    fadd DP [ebx+4*4];
    fxch ST(1);
    fadd DP [ebx+4*5];
    fxch ST(3);
    fadd DP [ebx+4*6];
    fxch ST(2);
    fadd DP [ebx+4*7];

    fxch ST(1);
    fadd DP [ecx+4*4];
    fxch ST(3);
    fadd DP [ecx+4*5];
    fxch ST(2);
    fadd DP [ecx+4*6];
    fxch ST(1);
    fadd DP [ecx+4*7];

    fxch ST(3);
    fadd DP [edx+4*4];
    fxch ST(2);
    fadd DP [edx+4*5];
    fxch ST(1);
    fadd DP [edx+4*6];
    fxch ST(3);
    fadd DP [edx+4*7];

    fxch ST(2);
    fstp a[4*4];
    fstp a[4*5];
    fxch ST(1);
    fstp a[4*6];
    fstp a[4*7];
    
    pop ebx;
    pop esi;
  }

#else

       for (k=0; k<8; k++)
       {
         ps3 = ps2 + *pntr;
         pntr += STEP;
         a[k+8] = ps3 * ps3;
       }

       for (k=0; k<8; k++)
         a[k] = alp2 + rri3i3[k] + ptr_ri0i3[k] + ptr_ri1i3[k] + ptr_ri2i3[k];

#endif

       bestk = -1;
       for (k=0; k<8; k++)
       {
         t1 = a[k+8] * alpha;
         t2 = psc * a[k];
         if (asint(t1) > asint(t2))
         {
           psc = a[k+8];
           alpha = a[k];
           bestk = k;
         }
       }
          
       if (bestk >= 0)
       {
         ip0 = i0;
         ip1 = i1;
         ip2 = i2;
         ip3 = 6 + (bestk << 3);
         shif = shift;
//#define t32 4294967296.0f
//		 printf("  %3d %3d %3d %3d %d %f %f %f\n",ip0,ip1,ip2,ip3,shift,psc/thres/thres,alpha/thres,(float)psc/(float)alpha/thres);
       }
       
       time--;
       if(time <= 0) 
         goto end_search;     
     }
     ptr_ri2i3 += NB_POS;
	 }
skipthird:
   inc = (i2 - lasti2) >> 3;
   ptr_ri0i2 += inc;
   ptr_ri1i2 += inc;
   ptr_ri2i2 += inc;
	 
 // end of for i2 = 

     ptr_ri0i2 -= NB_POS;
     ptr_ri1i3 += NB_POS;
   } 
skipsecond:

 // end of for i1 =

   ptr_ri0i2 += NB_POS;
   ptr_ri0i3 += NB_POS;
 }
 // end of for i0 = 

end_search:

extra = time;
 
 ip[0] = ip0;
 ip[1] = ip1;
 ip[2] = ip2;
 ip[3] = ip3;
 *shifPtr = shif;

 return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\coder.c ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//
#include "timer.h"
#include "ctiming.h"
#include "opt.h"
#include <stdlib.h>
#include <stdio.h>
#include "typedef.h"
#include "cst_lbc.h"
#include "tab_lbc.h"
#include "coder.h"
#include "lpc.h"
#include "lsp.h"
#include "exc_lbc.h"
#include "util_lbc.h"
#include "memory.h"
#include "mmxutil.h"

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
#pragma message ("Current log encode timing computations handle 2057 frames max")
void OutputEncodeTimingStatistics(char * szFileName, ENC_TIMING_INFO * pEncTimingInfo, unsigned long dwFrameCount);
void OutputEncTimingDetail(FILE * pFile, ENC_TIMING_INFO * pEncTimingInfo);
#endif // } LOG_ENCODE_TIMINGS_ON

//
//   This file includes the coder main functions
//



//--------------------------------------------------
void  Init_Coder(CODDEF  *CodStat)
{
   int   i;

// Init prev Lsp to Dc  
   for (i=0; i < LpcOrder; i++)
      CodStat->PrevLsp[i] = LspDcTable[i];
	CodStat->p = 9;
	CodStat->q = 9;
	CodStat->VadAct = 1;

/* Initialize the taming procedure */
   for(i=0; i<SizErr; i++) CodStat->Err[i] = Err0;

}

//---------------------------------------------------
Flag  Coder(float *DataBuff, Word32 *Vout, CODDEF *CodStat,
 int quality, int UseCpuId, int UseMMX)
{
   int   i,j,flags  ;

   static int qual2flags[16] =
   {SC_DEF,SC_DEF,SC_DEF,SC_DEF,SC_DEF,SC_DEF,SC_DEF,SC_DEF,
    SC_DEF,SC_DEF,SC_DEF,SC_DEF,
    SC_LAG1 | SC_GAIN | SC_FINDB,
    SC_GAIN | SC_FINDB,
    SC_FINDB,
    0};

//   Local variables
    
   float   UnqLpc[SubFrames*LpcOrder];
   float   QntLpc[SubFrames*LpcOrder];
   float   PerLpc[2*SubFrames*LpcOrder];

   float   LspVect[LpcOrder];
   LINEDEF Line;
   PWDEF   Pw[SubFrames];

   float   ImpResp[SubFrLen];
   float   Dpnt[PitchMax+Frame];
   float   *dptr;
 
#if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
	unsigned long dwStartLow;
	unsigned long dwStartHigh;
	unsigned long dwElapsed;
	unsigned long dwBefore;
	unsigned long dwEncode = 0;
	int bTimingThisFrame = 0;
#endif // } #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	unsigned long dwRem_Dc = 0;
	unsigned long dwComp_Lpc = 0;
	unsigned long dwAtoLsp = 0;
	unsigned long dwLsp_Qnt = 0;
	unsigned long dwLsp_Inq = 0;
	unsigned long dwLsp_Int = 0;
	unsigned long dwMem_Shift = 0;
	unsigned long dwWght_Lpc = 0;
	unsigned long dwError_Wght = 0;
	unsigned long dwFew_Lps_In_Coder = 0;
	unsigned long dwFilt_Pw = 0;
	unsigned long dwComp_Ir = 0;
	unsigned long dwSub_Ring = 0;
	unsigned long dwFind_Acbk = 0;
	unsigned long dwFind_Fcbk = 0;
	unsigned long dwDecode_Acbk = 0;
	unsigned long dwReconstr_Excit = 0;
	unsigned long dwUpd_Ring = 0;
	unsigned long dwLine_Pack = 0;
	unsigned long dwComp_IrTemp = 0;
	unsigned long dwSub_RingTemp = 0;
	unsigned long dwFind_AcbkTemp = 0;
	unsigned long dwFind_FcbkTemp = 0;
	unsigned long dwDecode_AcbkTemp = 0;
	unsigned long dwReconstr_ExcitTemp = 0;
	unsigned long dwUpd_RingTemp = 0;
#endif // } DETAILED_ENCODE_TIMINGS_ON
#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	ENC_TIMING_INFO * pEncTimingInfo = NULL;
#endif // } LOG_ENCODE_TIMINGS_ON

#if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
	TIMER_START(bTimingThisFrame,dwStartLow,dwStartHigh);
#endif // } #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	if (CodStat->dwStatFrameCount < ENC_TIMING_INFO_FRAME_COUNT)
	{
		CodStat->dwStartLow = dwStartLow;
		CodStat->dwStartHigh = dwStartHigh;
	}
	CodStat->bTimingThisFrame = bTimingThisFrame;
#endif // } LOG_ENCODE_TIMINGS_ON

	if (quality < 0 || quality > 15) quality = 0;
		flags = qual2flags[quality];

	// If UseCpuId is set, determine whether to use MMX based on the
	// actual hardware CPUID.  Otherwise, just use the passed-in parameter.
#if COMPILE_MMX
	if (UseCpuId)
		UseMMX = IsMMX();
#else
	UseMMX = UseCpuId = FALSE;
#endif //COMPILE_MMX


	//Coder Start
	Line.Crc = 0;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	Rem_Dc(DataBuff, CodStat);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwRem_Dc);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Compute the Unquantized Lpc set for whole frame
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

#if COMPILE_MMX
	if (UseMMX)
		Comp_LpcInt(UnqLpc, CodStat->PrevDat, DataBuff, CodStat);
	else
#endif
	Comp_Lpc(UnqLpc, CodStat->PrevDat, DataBuff, CodStat);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwComp_Lpc);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Convert to Lsp
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	AtoLsp(LspVect, &UnqLpc[LpcOrder*(SubFrames-1)], CodStat->PrevLsp);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwAtoLsp);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// VQ Lsp vector
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	Line.LspId = Lsp_Qnt(LspVect, CodStat->PrevLsp, UseMMX);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwLsp_Qnt);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Inverse quantization of the LSP 
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	Lsp_Inq(LspVect, CodStat->PrevLsp, Line.LspId, Line.Crc);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwLsp_Inq);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Interpolate the Lsp vectors
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	Lsp_Int(QntLpc, LspVect, CodStat->PrevLsp);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwLsp_Int);
#endif // } DETAILED_ENCODE_TIMINGS_ON

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	Mem_Shift(CodStat->PrevDat, DataBuff);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwMem_Shift);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Compute Percetual filter Lpc coefficeints 
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	Wght_Lpc(PerLpc, UnqLpc);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwWght_Lpc);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Apply the perceptual weighting filter 
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	Error_Wght(DataBuff, PerLpc,CodStat);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwError_Wght);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Compute Open loop pitch estimates
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Construct the buffer

	memcpy(Dpnt,CodStat->PrevWgt,4*PitchMax);
	memcpy(&Dpnt[PitchMax],DataBuff,4*Frame);
	/*
	for (i=0; i < PitchMax;i++)
		Dpnt[i] = CodStat->PrevWgt[i];
	for (i=0;i < Frame;i++)
		Dpnt[PitchMax+i] = DataBuff[i];
	*/

	j = PitchMax;
	for (i=0; i < SubFrames/2; i++) 
	{
#if COMPILE_MMX
		if (UseMMX)
			Line.Olp[i] = Estim_Int(Dpnt, j);
		else
#endif
			Line.Olp[i] = Estim_Pitch(Dpnt, j);
		j += 2*SubFrLen;
	}

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwFew_Lps_In_Coder);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Compute the Hmw 
	j = PitchMax;
	for (i=0; i < SubFrames; i++) 
	{
		Pw[i] = Comp_Pw(Dpnt, j, Line.Olp[i>>1]);
		j += SubFrLen;
	}

	// Reload the buffer 
	for (i=0; i < PitchMax; i++)
		Dpnt[i] = CodStat->PrevWgt[i];
	for (i=0; i < Frame; i++)
		Dpnt[PitchMax+i] = DataBuff[i];

	// Save PrevWgt
	for (i=0; i < PitchMax; i++)
		CodStat->PrevWgt[i] = Dpnt[Frame+i];

	// Apply the Harmonic filter
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON
	j = 0;
	for (i=0; i < SubFrames; i++) 
	{
		Filt_Pw(DataBuff, Dpnt, j , Pw[i]);
		j += SubFrLen;
	}
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwFilt_Pw);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	// Start the sub frame processing loop
	dptr = DataBuff;

	for (i=0; i < SubFrames; i++) 
	{
		// Compute full impulse responce
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		Comp_Ir(ImpResp, &QntLpc[i*LpcOrder], &PerLpc[i*2*LpcOrder], Pw[i]);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwComp_IrTemp);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		// Subtruct the ringing of previos sub-frame
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		Sub_Ring(dptr, &QntLpc[i*LpcOrder], &PerLpc[i*2*LpcOrder],
				CodStat->PrevErr, Pw[i], CodStat);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwSub_RingTemp);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		// Compute adaptive code book contribution
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

#if COMPILE_MMX
		if(UseMMX)
			Find_AcbkInt(dptr, ImpResp, CodStat->PrevExc, &Line,i, CodStat->WrkRate, flags, CodStat);
		else
#endif
			Find_Acbk(dptr, ImpResp, CodStat->PrevExc, &Line,i, CodStat->WrkRate, flags, CodStat);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwFind_AcbkTemp);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		// Compute fixed code book contribution
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		Find_Fcbk(dptr, ImpResp, &Line, i, CodStat->WrkRate, flags, UseMMX);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwFind_FcbkTemp);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		// Reconstruct the excitation
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		Decod_Acbk(ImpResp, CodStat->PrevExc, Line.Olp[i>>1],
					Line.Sfs[i].AcLg, Line.Sfs[i].AcGn, CodStat->WrkRate);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwDecode_AcbkTemp);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		for (j=SubFrLen; j < PitchMax; j++)
			CodStat->PrevExc[j-SubFrLen] = CodStat->PrevExc[j];

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		for (j=0; j < SubFrLen; j++) 
		{
			dptr[j] = dptr[j]*2.0f+ImpResp[j];
			CodStat->PrevExc[PitchMax-SubFrLen+j] = dptr[j];
			/* Clip the new samples */
#if 1 //do clipping
			//clip to +/- 32767.0 doing abs & compare with integer unit
			//if clipping is needed shift sign bit to use as lookup table index
#define FLTCLIP(x) \
			{\
				const float T[2] = {32767.0f, -32767.0f};\
				if ((asint(x) & 0x7fffffff) > asint(T[0]))\
				x = T[((unsigned)asint(x)) >> 31];\
			}

			FLTCLIP(CodStat->PrevExc[PitchMax-SubFrLen+j]);
#endif //optclip
		}

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwReconstr_ExcitTemp);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		/* Update exc_err */
		Update_Err(Line.Olp[i>>1], Line.Sfs[i].AcLg, Line.Sfs[i].AcGn, CodStat);

		// Update the ringing delays 
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		Upd_Ring(dptr, &QntLpc[i*LpcOrder], &PerLpc[i*2*LpcOrder],
					CodStat->PrevErr, CodStat);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwUpd_RingTemp);
#endif // } DETAILED_ENCODE_TIMINGS_ON

		dptr += SubFrLen;

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		// Sum stats
		dwComp_Ir += dwComp_IrTemp; dwComp_IrTemp = 0;
		dwSub_Ring += dwSub_RingTemp; dwSub_RingTemp = 0;
		dwFind_Acbk += dwFind_AcbkTemp; dwFind_AcbkTemp = 0;
		dwFind_Fcbk += dwFind_FcbkTemp; dwFind_FcbkTemp = 0;
		dwDecode_Acbk += dwDecode_AcbkTemp; dwDecode_AcbkTemp = 0;
		dwReconstr_Excit += dwReconstr_ExcitTemp; dwReconstr_ExcitTemp = 0;
		dwUpd_Ring += dwUpd_RingTemp; dwUpd_RingTemp = 0;
#endif // } DETAILED_ENCODE_TIMINGS_ON
	}

	// Pack the Line structure
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_ENCODE_TIMINGS_ON

	Line_Pack(&Line, Vout,&(CodStat->VadAct),CodStat->WrkRate);

#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwLine_Pack);
#endif // } DETAILED_ENCODE_TIMINGS_ON

#if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON) // { #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)
	TIMER_STOP(bTimingThisFrame,dwStartLow,dwStartHigh,dwEncode);
#endif // } ENCODE_TIMINGS_ON

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	if (bTimingThisFrame && (CodStat->dwStatFrameCount < ENC_TIMING_INFO_FRAME_COUNT))
	{
		pEncTimingInfo = &CodStat->EncTimingInfo[CodStat->dwStatFrameCount];
		pEncTimingInfo->dwEncode			= dwEncode;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		pEncTimingInfo->dwRem_Dc			= dwRem_Dc;
		pEncTimingInfo->dwComp_Lpc			= dwComp_Lpc;
		pEncTimingInfo->dwAtoLsp			= dwAtoLsp;
		pEncTimingInfo->dwLsp_Qnt			= dwLsp_Qnt;
		pEncTimingInfo->dwLsp_Inq			= dwLsp_Inq;
		pEncTimingInfo->dwLsp_Int			= dwLsp_Int;
		pEncTimingInfo->dwMem_Shift			= dwMem_Shift;
		pEncTimingInfo->dwWght_Lpc			= dwWght_Lpc;
		pEncTimingInfo->dwError_Wght		= dwError_Wght;
		pEncTimingInfo->dwFew_Lps_In_Coder	= dwFew_Lps_In_Coder;
		pEncTimingInfo->dwFilt_Pw			= dwFilt_Pw;
		pEncTimingInfo->dwComp_Ir			= dwComp_Ir;
		pEncTimingInfo->dwSub_Ring			= dwSub_Ring;
		pEncTimingInfo->dwFind_Acbk			= dwFind_Acbk;
		pEncTimingInfo->dwFind_Fcbk			= dwFind_Fcbk;
		pEncTimingInfo->dwDecode_Acbk		= dwDecode_Acbk;
		pEncTimingInfo->dwReconstr_Excit	= dwReconstr_Excit;
		pEncTimingInfo->dwUpd_Ring			= dwUpd_Ring;
		pEncTimingInfo->dwLine_Pack			= dwLine_Pack;
#endif // } DETAILED_ENCODE_TIMINGS_ON
		CodStat->dwStatFrameCount++;
	}
	else
	{
		_asm int 3;
	}
#endif // } #if defined(ENCODE_TIMINGS_ON) || defined(DETAILED_ENCODE_TIMINGS_ON)

	return (Flag) True;
}


#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
void OutputEncodeTimingStatistics(char * szFileName, ENC_TIMING_INFO * pEncTimingInfo, unsigned long dwFrameCount)
{
    FILE * pFile;
	ENC_TIMING_INFO * pTempEncTimingInfo;
	ENC_TIMING_INFO etiTemp;
	int i;
	int iCount;

	pFile = fopen(szFileName, "a");
	if (pFile == NULL)
	    goto done;

#if 0
	// Too verbose !!!
	/* Output the detail information
	*/
	fprintf(pFile,"\nDetail Timing Information\n");
	for ( i = 0, pTempEncTimingInfo = pEncTimingInfo ; i < dwFrameCount ; i++, pTempEncTimingInfo++ )
	{
		fprintf(pFile, "Frame %d Detail Timing Information\n", i);
		OutputEncTimingDetail(pFile, pTempEncTimingInfo);
	}
#endif

	/* Compute the total information
	*/
	memset(&etiTemp, 0, sizeof(ENC_TIMING_INFO));
	iCount = 0;

	for ( i = 0, pTempEncTimingInfo = pEncTimingInfo ; i < dwFrameCount ; i++, pTempEncTimingInfo++ )
	{
		iCount++;
		etiTemp.dwEncode			+= pTempEncTimingInfo->dwEncode;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		etiTemp.dwRem_Dc			+= pTempEncTimingInfo->dwRem_Dc;
		etiTemp.dwComp_Lpc			+= pTempEncTimingInfo->dwComp_Lpc;
		etiTemp.dwAtoLsp			+= pTempEncTimingInfo->dwAtoLsp;
		etiTemp.dwLsp_Qnt			+= pTempEncTimingInfo->dwLsp_Qnt;
		etiTemp.dwLsp_Inq			+= pTempEncTimingInfo->dwLsp_Inq;
		etiTemp.dwLsp_Int			+= pTempEncTimingInfo->dwLsp_Int;
		etiTemp.dwMem_Shift			+= pTempEncTimingInfo->dwMem_Shift;
		etiTemp.dwWght_Lpc			+= pTempEncTimingInfo->dwWght_Lpc;
		etiTemp.dwError_Wght		+= pTempEncTimingInfo->dwError_Wght;
		etiTemp.dwFew_Lps_In_Coder	+= pTempEncTimingInfo->dwFew_Lps_In_Coder;
		etiTemp.dwFilt_Pw			+= pTempEncTimingInfo->dwFilt_Pw;
		etiTemp.dwComp_Ir			+= pTempEncTimingInfo->dwComp_Ir;
		etiTemp.dwSub_Ring			+= pTempEncTimingInfo->dwSub_Ring;
		etiTemp.dwFind_Acbk			+= pTempEncTimingInfo->dwFind_Acbk;
		etiTemp.dwFind_Fcbk			+= pTempEncTimingInfo->dwFind_Fcbk;
		etiTemp.dwDecode_Acbk		+= pTempEncTimingInfo->dwDecode_Acbk;
		etiTemp.dwReconstr_Excit	+= pTempEncTimingInfo->dwReconstr_Excit;
		etiTemp.dwUpd_Ring			+= pTempEncTimingInfo->dwUpd_Ring;
		etiTemp.dwLine_Pack			+= pTempEncTimingInfo->dwLine_Pack;
#endif // } DETAILED_ENCODE_TIMINGS_ON
	}

	if (iCount > 0) 
	{
		/* Output the total information
		*/
		fprintf(pFile,"Total for %d frames\n", iCount);
		OutputEncTimingDetail(pFile, &etiTemp);

		/* Compute the average
		*/
		etiTemp.dwEncode			= (etiTemp.dwEncode + (iCount / 2)) / iCount;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
		etiTemp.dwRem_Dc			= (etiTemp.dwRem_Dc + (iCount / 2)) / iCount;
		etiTemp.dwComp_Lpc			= (etiTemp.dwComp_Lpc + (iCount / 2)) / iCount;
		etiTemp.dwAtoLsp			= (etiTemp.dwAtoLsp + (iCount / 2)) / iCount;
		etiTemp.dwLsp_Qnt			= (etiTemp.dwLsp_Qnt + (iCount / 2)) / iCount;
		etiTemp.dwLsp_Inq			= (etiTemp.dwLsp_Inq + (iCount / 2)) / iCount;
		etiTemp.dwLsp_Int			= (etiTemp.dwLsp_Int + (iCount / 2)) / iCount;
		etiTemp.dwMem_Shift			= (etiTemp.dwMem_Shift + (iCount / 2)) / iCount;
		etiTemp.dwWght_Lpc			= (etiTemp.dwWght_Lpc + (iCount / 2)) / iCount;
		etiTemp.dwError_Wght		= (etiTemp.dwError_Wght + (iCount / 2)) / iCount;
		etiTemp.dwFew_Lps_In_Coder	= (etiTemp.dwFew_Lps_In_Coder + (iCount / 2)) / iCount;
		etiTemp.dwFilt_Pw			= (etiTemp.dwFilt_Pw + (iCount / 2)) / iCount;
		etiTemp.dwComp_Ir			= (etiTemp.dwComp_Ir + (iCount / 2)) / iCount;
		etiTemp.dwSub_Ring			= (etiTemp.dwSub_Ring + (iCount / 2)) / iCount;
		etiTemp.dwFind_Acbk			= (etiTemp.dwFind_Acbk + (iCount / 2)) / iCount;
		etiTemp.dwFind_Fcbk			= (etiTemp.dwFind_Fcbk + (iCount / 2)) / iCount;
		etiTemp.dwDecode_Acbk		= (etiTemp.dwDecode_Acbk + (iCount / 2)) / iCount;
		etiTemp.dwReconstr_Excit	= (etiTemp.dwReconstr_Excit + (iCount / 2)) / iCount;
		etiTemp.dwUpd_Ring			= (etiTemp.dwUpd_Ring + (iCount / 2)) / iCount;
		etiTemp.dwLine_Pack			= (etiTemp.dwLine_Pack + (iCount / 2)) / iCount;
#endif // } DETAILED_ENCODE_TIMINGS_ON

		/* Output the average information
		*/
		fprintf(pFile,"Average over %d frames\n", iCount);
		OutputEncTimingDetail(pFile, &etiTemp);
	}

	fclose(pFile);
done:

    return;
}

void OutputEncTimingDetail(FILE * pFile, ENC_TIMING_INFO * pEncTimingInfo)
{
	unsigned long dwOther;
	unsigned long dwRoundUp;
	unsigned long dwDivisor;

	fprintf(pFile, "\tEncode =     %10u (%d milliseconds at 166Mhz)\n", pEncTimingInfo->dwEncode,
			(pEncTimingInfo->dwEncode + 83000) / 166000);
	dwOther = pEncTimingInfo->dwEncode;
	
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	/* This is needed because of the integer truncation.
	 */
	dwDivisor = pEncTimingInfo->dwEncode / 100; // to yield a percent
	dwRoundUp = dwDivisor / 2;
	
	if (dwDivisor)
	{
		fprintf(pFile, "\tRem_Dc =           %10u (%2d%%)\n", pEncTimingInfo->dwRem_Dc, 
				(pEncTimingInfo->dwRem_Dc + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwRem_Dc;
									   
		fprintf(pFile, "\tComp_Lpc =         %10u (%2d%%)\n", pEncTimingInfo->dwComp_Lpc, 
				(pEncTimingInfo->dwComp_Lpc + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwComp_Lpc;
									   
		fprintf(pFile, "\tAtoLsp =           %10u (%2d%%)\n", pEncTimingInfo->dwAtoLsp, 
				(pEncTimingInfo->dwAtoLsp + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwAtoLsp;

		fprintf(pFile, "\tLsp_Qnt =          %10u (%2d%%)\n", pEncTimingInfo->dwLsp_Qnt, 
				(pEncTimingInfo->dwLsp_Qnt + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwLsp_Qnt;
									   
		fprintf(pFile, "\tLsp_Inq =          %10u (%2d%%)\n", pEncTimingInfo->dwLsp_Inq, 
				(pEncTimingInfo->dwLsp_Inq + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwLsp_Inq;
									   
		fprintf(pFile, "\tLsp_Int =          %10u (%2d%%)\n", pEncTimingInfo->dwLsp_Int, 
				(pEncTimingInfo->dwLsp_Int + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwLsp_Int;
									   
		fprintf(pFile, "\tMem_Shift =        %10u (%2d%%)\n", pEncTimingInfo->dwMem_Shift, 
				(pEncTimingInfo->dwMem_Shift + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwMem_Shift;
									   
		fprintf(pFile, "\tWght_Lpc =         %10u (%2d%%)\n", pEncTimingInfo->dwWght_Lpc, 
				(pEncTimingInfo->dwWght_Lpc + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwWght_Lpc;
									   
		fprintf(pFile, "\tError_Wght =       %10u (%2d%%)\n", pEncTimingInfo->dwError_Wght, 
				(pEncTimingInfo->dwError_Wght + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwError_Wght;
									   
		fprintf(pFile, "\tFew_Lps_In_Coder = %10u (%2d%%)\n", pEncTimingInfo->dwFew_Lps_In_Coder, 
				(pEncTimingInfo->dwFew_Lps_In_Coder + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwFew_Lps_In_Coder;
									   
		fprintf(pFile, "\tFilt_Pw =          %10u (%2d%%)\n", pEncTimingInfo->dwFilt_Pw, 
				(pEncTimingInfo->dwFilt_Pw + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwFilt_Pw;
									   
		fprintf(pFile, "\tComp_Ir =          %10u (%2d%%)\n", pEncTimingInfo->dwComp_Ir, 
				(pEncTimingInfo->dwComp_Ir + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwComp_Ir;
									   
		fprintf(pFile, "\tSub_Ring =         %10u (%2d%%)\n", pEncTimingInfo->dwSub_Ring, 
				(pEncTimingInfo->dwSub_Ring + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwSub_Ring;
									   
		fprintf(pFile, "\tFind_Acbk =        %10u (%2d%%)\n", pEncTimingInfo->dwFind_Acbk, 
				(pEncTimingInfo->dwFind_Acbk + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwFind_Acbk;
									   
		fprintf(pFile, "\tFind_Fcbk =        %10u (%2d%%)\n", pEncTimingInfo->dwFind_Fcbk, 
				(pEncTimingInfo->dwFind_Fcbk + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwFind_Fcbk;
									   
		fprintf(pFile, "\tDecode_Acbk =      %10u (%2d%%)\n", pEncTimingInfo->dwDecode_Acbk, 
				(pEncTimingInfo->dwDecode_Acbk + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwDecode_Acbk;
									   
		fprintf(pFile, "\tReconstr_Excit =   %10u (%2d%%)\n", pEncTimingInfo->dwReconstr_Excit, 
				(pEncTimingInfo->dwReconstr_Excit + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwReconstr_Excit;
									   
		fprintf(pFile, "\tUpd_Ring =         %10u (%2d%%)\n", pEncTimingInfo->dwUpd_Ring, 
				(pEncTimingInfo->dwUpd_Ring + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwUpd_Ring;
									   
		fprintf(pFile, "\tLine_Pack =        %10u (%2d%%)\n", pEncTimingInfo->dwLine_Pack, 
				(pEncTimingInfo->dwLine_Pack + dwRoundUp) / dwDivisor);
		dwOther -= pEncTimingInfo->dwLine_Pack;
									   
		fprintf(pFile, "\tOther =            %10u (%2d%%)\n", dwOther, 
				(dwOther + dwRoundUp) / dwDivisor);
	}
#endif // } DETAILED_ENCODE_TIMINGS_ON

}
#endif // { LOG_ENCODE_TIMINGS_ON
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\cb63.c ===
//cb63.c - 6.3 rate codebook code
#include "opt.h"

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <memory.h>
#include "typedef.h"
#include "cst_lbc.h"
#include "tab_lbc.h"
#include "util_lbc.h"
#include "exc_lbc.h"
#include "timer.h"
#include "mmxutil.h"

//-------------------------------------------------------
void  Gen_Trn(float *Dst, float *Src, int Olp)
{
  int  i;

  int Tmp0;
  float  Tmp[SubFrLen];

  Tmp0 = Olp;

  for (i=0; i < SubFrLen; i++)
  {
    Tmp[i] = Src[i];
    Dst[i] = Src[i];
  }

  while (Tmp0 < SubFrLen)
  {
    for (i=Tmp0; i < SubFrLen; i++)
      Dst[i] += Tmp[i-Tmp0];

    Tmp0 += Olp;
  }
}

//------------------------------------------------------------------------
int Find_L(float *OccPos, float *ImrCorr, float *WrkBlk, float Pamp, int k)
{
#if FT_FINDL

//====== New version using FT trick that removes OccPos test ======

#if FIND_L_OPT

  int best;
  float max = -32768.0f;
  float tmp0,tmp1,tmp2,tmp3,tmp4;

// Simply interleave 5 copies of the inner loop.  Since we step
// by 2, this means we do the 60 samples in chunks of 10.

ASM
{
  mov edi,WrkBlk;
  mov edx,ImrCorr;
  mov ecx,k;

loop1:
  fld  DP[edx+4*ecx+4*0];
  fmul Pamp;
  fld  DP[edx+4*ecx+4*2];
  fmul Pamp;
  fld  DP[edx+4*ecx+4*4];
  fmul Pamp;
  fld  DP[edx+4*ecx+4*6];
  fmul Pamp;
  fld  DP[edx+4*ecx+4*8];// 4 3 2 1 0
  fmul Pamp;

  fxch ST(4);            // 0 3 2 1 4
  fsubr DP[edi+4*ecx+4*0];
  fxch ST(3);            // 1 3 2 0 4
  fsubr DP[edi+4*ecx+4*2];
  fxch ST(2);            // 2 3 1 0 4
  fsubr DP[edi+4*ecx+4*4];
  fxch ST(1);            // 3 2 1 0 4
  fsubr DP[edi+4*ecx+4*6];
  fxch ST(4);            // 4 2 1 0 3
  fsubr DP[edi+4*ecx+4*8];

  fxch ST(3);            // 0 2 1 4 3
  fst DP[edi+4*ecx+4*0];
  fxch ST(2);            // 1 2 0 4 3
  fst DP[edi+4*ecx+4*2];
  fxch ST(1);            // 2 1 0 4 3
  fst DP[edi+4*ecx+4*4];
  fxch ST(4);            // 3 1 0 4 2
  fst DP[edi+4*ecx+4*6];
  fxch ST(3);            // 4 1 0 3 2
  fst DP[edi+4*ecx+4*8];

  fxch ST(2);            // 0 1 4 3 2
  fabs;
  fxch ST(1);            // 1 0 4 3 2
  fabs;
  fxch ST(4);            // 2 0 4 3 1
  fabs;
  fxch ST(3);            // 3 0 4 2 1
  fabs;
  fxch ST(2);            // 4 0 3 2 1
  fabs;

  fxch ST(1);            // 0 4 3 2 1
  fstp tmp0;             // 4 3 2 1
  fxch ST(3);            // 1 3 2 4
  fstp tmp1;             // 3 2 4
  fxch ST(1);            // 2 3 4
  fstp tmp2;
  fstp tmp3;
  fstp tmp4;

  mov eax,tmp0;
   mov ebx,max;
  cmp eax,ebx;
   jle skip0;
  mov max,eax;
   mov best,ecx;
skip0:

  mov eax,tmp1;
   mov ebx,max;
  cmp eax,ebx;
   jle skip1;
  lea esi,[ecx+2];
  mov max,eax;
   mov best,esi;
skip1:

  mov eax,tmp2;
   mov ebx,max;
  cmp eax,ebx;
   jle skip2;
  lea esi,[ecx+4];
  mov max,eax;
   mov best,esi;
skip2:

  mov eax,tmp3;
   mov ebx,max;
  cmp eax,ebx;
   jle skip3;
  lea esi,[ecx+6];
  mov max,eax;
   mov best,esi;
skip3:

  mov eax,tmp4;
   mov ebx,max;
  cmp eax,ebx;
   jle skip4;
  lea esi,[ecx+8];
  mov max,eax;
   mov best,esi;
skip4:

  add ecx,10;
  cmp ecx,SubFrLen;
   jl loop1;
}
#else

  int best;
  float max = -32768.0f,tmp;
  
  while (k < SubFrLen)
  {
    WrkBlk[k] = WrkBlk[k] - Pamp*ImrCorr[k];

    tmp = (float) fabs(WrkBlk[k]);

//    printf("k %2d  tmp %10.2f  max %10.2f\n",k,tmp,max);
    if (asint(tmp) > asint(max))
    {
      max = tmp;
      best = k;
    }
    k += Sgrid;
  }
#endif

#else
//==================================================================
// Old version of Find_L

  int best;
  float max = -32768.0f,tmp;
  
#if FIND_L_OPT

// Because of the (if OccPos[k]) clause, this code is difficult
// to pipeline.  We could do a complicated pipeline job, but that
// would require computing most of WrkBlk[k] = WrkBlk[k] - Pamp*ImrCorr[k]
// whether or not OccPos[k] was 0.  Alternatively, we can just do
// one iteration at a time, in which case we can avoid more of that computation
// when OccPos[k] is not 0, but we pay a penalty in that computing it once
// is slower due to stalls.  Since there isn't much difference between these
// two approaches, we choose the second one since the code is so much
// simpler.  Loop control is only 2 clocks, so we don't even bother to unroll.

ASM
{
  mov esi,OccPos;
  mov edi,WrkBlk;
  mov edx,ImrCorr;
  mov ecx,k;

loop1:
  fld  DP[edx+4*ecx];    // start this here so fsubr below doesn't stall
  fmul Pamp;

  mov eax,DP[esi+4*ecx];
  test eax,07fffffffh;
  jne next1;             // but if this is taken we have to pop FP stack once

  fsubr DP[edi+4*ecx];
  fld ST(0);
  fabs;
  fstp tmp;              // save store of non-absolute-value for later

  mov eax,tmp;
   mov ebx,max;
  cmp eax,ebx;
   jle skip1;

  mov max,eax;
   mov best,ecx;

skip1:
  fstp DP[edi+4*ecx];    // store new WrkBlk value

  add ecx,2;
  cmp ecx,SubFrLen;
  jl loop1;
  jmp endit;

next1:
  faddp ST(0),ST;       // get rid of value on top of stack
  add ecx,2;
  cmp ecx,SubFrLen;
  jl loop1;

endit:
}

#else
  
  while (k < SubFrLen)
  {
    if (OccPos[k] == 0.0f)
    {
      WrkBlk[k] = WrkBlk[k] - Pamp*ImrCorr[k];

      tmp = (float) fabs(WrkBlk[k]);
      if (asint(tmp) > asint(max))
      {
        max = tmp;
        best = k;
      }
    }
    k += Sgrid;
  }

#endif
  
#endif

//  printf("best = %d\n",best);
//  printaff("WrkBlk",WrkBlk,60);

  return(best);
}
//------------------------------------------------------------------------
void  Find_Best(BESTDEF *Best, float *Tv, float *ImpResp,int Np,int Olp)
{


  int  i,j,k,l,n,ip;
  BESTDEF  Temp;
 
  int     MaxAmpId,flag=0;
  float   MaxAmp;
  float   Acc0,Acc1,Acc2,amp;

  float   Imr[SubFrLen];
  float   OccPos[SubFrLen];
  float   ImrCorr[2*SubFrLen];  // see comment below
  float   ErrBlk[SubFrLen];
  float   WrkBlk[SubFrLen];

// A trick is used here to simplify Find_L.  The original Find_L
// accessed ImrCorr[abs(k)].  In order to simplify this to ImrCorr[k],
// we double the size of the ImrCorr array, offset the elements with
// non-negative indices by SubFrLen, and then duplicate them in
// reverse order in the first half of the array.  This affects the
// way ImrCorr is addressed in this routine also.

//Update Impulse responce
   
  if (Olp < (SubFrLen-2)) 
  {
    Temp.UseTrn = 1;
    Gen_Trn(Imr, ImpResp, Olp);
  }
  else 
  {
    Temp.UseTrn = 0;
    for (i = 0; i < SubFrLen; i++)
      Imr[i] = ImpResp[i];
  }

//Search for the best sequence
 
  for (k=0; k < Sgrid; k++)
  {
    Temp.GridId = k;

//Find maximum amplitude
 
    Acc1 = 0.0f;
    for (i=k; i < SubFrLen; i +=Sgrid)
    { 
       OccPos[i] = Imr[i];	
       ImrCorr[SubFrLen+i] = DotProd(&Imr[i],Imr,SubFrLen-i) * 2.0f;
       Acc0 = (float) fabs(ErrBlk[i]=DotProd(&Tv[i],Imr,SubFrLen-i));
     
      if (Acc0 >= Acc1)
      {
        Acc1 = Acc0;
        Temp.Ploc[0] = i;
      }
    }
    for (i=1; i<SubFrLen; i++)
      ImrCorr[i] = ImrCorr[2*SubFrLen-i];
    
 //Quantize the maximum amplitude
  
    Acc2 = Acc1;
    Acc1 = 32767.0f;
    MaxAmpId = (NumOfGainLev - MlqSteps);

    for (i=MaxAmpId; i >= MlqSteps; i--)
    {
      Acc0 = (float) fabs(FcbkGainTable[i]*ImrCorr[SubFrLen] - Acc2);
      if (Acc0 < Acc1)
      {
        Acc1 = Acc0;
        MaxAmpId = i;
      }
    }
    MaxAmpId --;

    for (i=1; i <=2*MlqSteps; i++)
    {
      for (j=k; j < SubFrLen; j +=Sgrid)
      {
        WrkBlk[j] = ErrBlk[j];
        OccPos[j] = 0.0f;
      }
      Temp.MampId = MaxAmpId - MlqSteps + i;

      MaxAmp = FcbkGainTable[Temp.MampId];

      if (WrkBlk[Temp.Ploc[0]] >= 0.0f)
        Temp.Pamp[0] = MaxAmp;
      else
        Temp.Pamp[0] = -MaxAmp;

      OccPos[Temp.Ploc[0]] = 1.0f;

      for (j=1; j < Np; j++)
      {

#if FT_FINDL
        for (ip=0; ip<j; ip++)
          WrkBlk[Temp.Ploc[ip]] = Temp.Pamp[j-1]*
            ImrCorr[SubFrLen + Temp.Ploc[ip] - Temp.Ploc[j-1]];
#endif

        Temp.Ploc[j] = Find_L(OccPos,&ImrCorr[SubFrLen-Temp.Ploc[j-1]],WrkBlk,
          Temp.Pamp[j-1],k);
    
        if (WrkBlk[Temp.Ploc[j]] >= 0.0f)
          Temp.Pamp[j] = MaxAmp;
        else
          Temp.Pamp[j] = -MaxAmp;

        OccPos[Temp.Ploc[j]] = 1.0f;
      }

//Compute error vector
 
#if FT_FBFILT
// FT/CNET's trick #6, for reducing computation of filtered codeword
      
      for (j=0; j < SubFrLen; j++)
        OccPos[j] = 0.0f;

      for (j=0; j<Np; j++)
      {
// Extra sub-trick we added: since pulse positions are either all
// even or all odd, there's a natural two-ness in the inner loop,
// so we unroll two times.

        amp = Temp.Pamp[j];
        l = 0;
        for (n=Temp.Ploc[j]; n<SubFrLen-k; n+=2)
        {
          OccPos[n] += amp*Imr[l];
          OccPos[n+1] += amp*Imr[l+1];
          l += 2;
        }
        if (k)
          OccPos[n] += amp*Imr[l];
      }

#else
      for (j=0; j < SubFrLen; j++)
        OccPos[j] = 0.0f;

      for (j=0; j < Np; j++)
        OccPos[Temp.Ploc[j]] = Temp.Pamp[j];

      for (l=SubFrLen-1; l >= 0; l--)
        OccPos[l] = DotRev(OccPos,Imr,l+1); 
#endif
       
       
//Evaluate error
 
      Acc2 = DotProd(Tv,OccPos,SubFrLen) - DotProd(OccPos,OccPos,SubFrLen);

      if (Acc2 > (*Best).MaxErr)
      {
        flag = 1;
        (*Best).MaxErr = Acc2;
        (*Best).GridId = Temp.GridId;
        (*Best).MampId = Temp.MampId;
        (*Best).UseTrn = Temp.UseTrn;
        for (j = 0; j < Np; j++)
        {
          (*Best).Pamp[j] = Temp.Pamp[j];
          (*Best).Ploc[j] = Temp.Ploc[j];
        }
      }
    }
  }

#ifdef DEBUG
	if (flag == 0)
	{
		// this code is for tracking a rare condition in which
		// the above loop never get executed (Best is left uninitialized)
		DebugBreak();
	}

#endif


 return;
}

void  Fcbk_Pack(float *Dpnt, SFSDEF *Sfs, BESTDEF *Best, int Np)
{
  int  i,j;

//Code the amplitudes and positions
 
  j = MaxPulseNum - Np;

  (*Sfs).Pamp = 0;
  (*Sfs).Ppos = 0;

  for (i=0; i < SubFrLen/Sgrid; i++) 
  {

    if (Dpnt[(*Best).GridId + Sgrid*i] == 0)
      (*Sfs).Ppos = (*Sfs).Ppos + CombinatorialTable[j][i];
    else {
      (*Sfs).Pamp = (*Sfs).Pamp << 1;
      if (Dpnt[(*Best).GridId + Sgrid*i] < 0)
        (*Sfs).Pamp++;

      j++;

//Check for end 

      if (j == MaxPulseNum)
        break;
      }
    }

  (*Sfs).Mamp = (*Best).MampId;
  (*Sfs).Grid = (*Best).GridId;
  (*Sfs).Tran = (*Best).UseTrn;

  return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\8to11.c ===
#include <stdio.h>
#include <memory.h>

#define BUF  240  // input buffer size for test main

#define OUTPUT(o,i,t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16) \
  t = ( (int)in[i]*t0 + (int)in[i+1]*t1 + \
    (int)in[i+2]*t2 + (int)in[i+3]*t3 + \
    (int)in[i+4]*t4 + (int)in[i+5]*t5 + \
    (int)in[i+6]*t6 + (int)in[i+7]*t7 + \
    (int)in[i+8]*t8 + (int)in[i+9]*t9 + \
    (int)in[i+10]*t10 + (int)in[i+11]*t11 + \
    (int)in[i+12]*t12 + (int)in[i+13]*t13 + \
    (int)in[i+14]*t14 + (int)in[i+15]*t15 + \
    (int)in[i+16]*t16 ) >> 10; \
  if (t < -32768) out[o] = -32768; else if (t > 32767) out[o]=32767; else out[o] = t;

//--------------------------------------------------------
void segment8to11(short *in, short *out)
{
  int t;
  
  OUTPUT(  0,  0,     0,   0,   0,   0,   0,   0,   0,   0,1024,   0,   0,   0,   0,   0,   0,   0,   0);
  OUTPUT(  1,  1,    -5,  11, -20,  32, -49,  77,-134, 335, 903,-187,  97, -60,  39, -24,  15,  -8,   3);
  OUTPUT(  2,  1,     2,  -9,  17, -29,  47, -73, 116,-213, 708, 589,-199, 111, -70,  45, -28,  16,  -8);
  OUTPUT(  3,  2,     2,  -6,  11, -18,  29, -45,  73,-145, 969, 213, -91,  53, -34,  22, -13,   7,  -3);
  OUTPUT(  4,  3,    -2,   4,  -7,  11, -17,  26, -45,  99,1010, -82,  40, -24,  16, -10,   6,  -3,   1);
  OUTPUT(  5,  4,    -7,  14, -25,  40, -61,  97,-172, 463, 814,-210, 112, -69,  45, -28,  17,  -8,   3);
  OUTPUT(  6,  4,     3,  -8,  17, -28,  45, -69, 112,-210, 814, 463,-172,  97, -61,  40, -25,  14,  -7);
  OUTPUT(  7,  5,     1,  -3,   6, -10,  16, -24,  40, -82,1010,  99, -45,  26, -17,  11,  -7,   4,  -2);
  OUTPUT(  8,  6,    -3,   7, -13,  22, -34,  53, -91, 213, 969,-145,  73, -45,  29, -18,  11,  -6,   2);
  OUTPUT(  9,  7,    -8,  16, -28,  45, -70, 111,-199, 589, 708,-213, 116, -73,  47, -29,  17,  -9,   2);
  OUTPUT( 10,  7,     3,  -8,  15, -24,  39, -60,  97,-187, 903, 335,-134,  77, -49,  32, -20,  11,  -5);

/* original
  out[0] = in[4];
  OUTPUT(1,  0,  3, -20,  52,-116, 327, 899,-174,  75, -32,   9);
  OUTPUT(2,  1,  9, -36,  85,-192, 701, 581,-178,  79, -32,   7);
  OUTPUT(3,  2,  8, -25,  58,-136, 968, 206, -77,  35, -13,   1);
  OUTPUT(4,  2,  0,  -6,  17, -37,  96,1010, -78,  32, -14,   5);
  OUTPUT(5,  3,  5, -27,  68,-151, 454, 809,-192,  84, -36,  10);
  OUTPUT(6,  4, 10, -36,  84,-192, 809, 454,-151,  68, -27,   5);
  OUTPUT(7,  5,  5, -14,  32, -78,1010,  96, -37,  17,  -6,   0);
  OUTPUT(8,  5,  1, -13,  35, -77, 206, 968,-136,  58, -25,   8);
  OUTPUT(9,  6,  7, -32,  79,-178, 581, 701,-192,  85, -36,   9);
  OUTPUT(10, 7,  9, -32,  75,-174, 899, 327,-116,  52, -20,   3);
*/
/*  From MD
  OUTPUT( 1, 0, 10, -16,  26, -44,  98,1000, -81,  39, -24,  15,);
  OUTPUT( 2, 0, 21, -32,  51, -88, 208, 951,-142,  71, -43,  28,);
  OUTPUT( 3, 0, 30, -47,  74,-130, 326, 879,-182,  94, -57,  37,);
  OUTPUT( 4, 0, 37, -58,  93,-165, 448, 788,-202, 107, -66,  42,);
  OUTPUT( 5, 0, 42, -66, 106,-191, 568, 683,-205, 111, -69,  44,);
  OUTPUT( 6, 0, 44, -69, 111,-205, 683, 568,-191, 106, -66,  42,);
  OUTPUT( 7, 0, 42, -66, 107,-202, 788, 448,-165,  93, -58,  37,);
  OUTPUT( 8, 0, 37, -57,  94,-182, 879, 326,-130,  74, -47,  30,);
  OUTPUT( 9, 0, 28, -43,  71,-142, 951, 208, -88,  51, -32,  21,);
  OUTPUT(10, 0, 15, -24,  39, -81,1000,  98, -44,  26, -16,  10,);
*/
}
//--------------------------------------------------------
void convert8to11(short *in, short *out, short *prev, int len)
{
/*
  Convert a buffer from 8KHz to 11KHz.

  Note: len is number of shorts in input buffer, which MUST
  be a multiple of 8 and at least 32.

  How the overhang works:  The filter kernel for 1 section of
  8 samples requires KERNEL (=17) samples of the input.  So we use 16
  samples of overhang from the previous frame, which means the
  beginning of this frame looks like:

    pppppppp pppppppp 01234567 89abcdef 16...... 24......
    X        X        x        x

  So we first have to do two special segments (the ones starting
  at X) then we do the rest (the x's) in a loop.  For the example
  length=32 shown above, we'll do up to 32-24=8, stopping on the
  last x shown.  Then we save 16-31 in the overhang buffer so that
  16 is the first group done on the next frame.
*/

#define OVERHANG 16
#define KERNEL   24

  int i,k;
  short tmp[KERNEL+8];
  
// Convert the first two segments, where segment= 8 samples of input

  memcpy(tmp,prev,sizeof(short)*OVERHANG);
  memcpy(tmp+OVERHANG,in,sizeof(short)*(KERNEL+8-OVERHANG));

  segment8to11(tmp,out);
  segment8to11(tmp+8,out+11);

// Loop through the remaining segments

  k = 22;
  for (i=16-OVERHANG; i<=len-KERNEL; i+=8)
  {
    segment8to11(in+i,out+k);
    k += 11;
  }

// Save overhang samples for next time

  memcpy(prev,in+len-OVERHANG,sizeof(short)*OVERHANG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\cb53mmx.c ===
// cb53mmx.c

#include "cst_lbc.h"
#include "mmxutil.h"
#include "opt.h"
#include "exc_lbc.h"
#include "timer.h"
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include "util_lbc.h"

#define ASM_CORHPL 1
#define ASM_CORHDL 1
#define TESTME 0
#define CHTEST 0

#if COMPILE_MMX
void CorrelateIntTri(short *taps, short *array, int *corr, int ncor);
void CorrelateInt22(short *taps, short *array, int *corr, int ncor);
void Cor_h_Xint(short h[],short X[],int D[]);
void Cor_hint0(short *H, int *rr);
void Cor_hint1(short *H, int *rr);
void cor_h_prodloop(int n, int oddn,short *h,short *h2,int *p3,int *p2,int *p1,int *p0);
void cor_h_diag(int n, int oddn,short *h,short *h2,int *p3,int *p2,int *p1,int *p0);

//------------------------------------------------------------
int ACELP_LBC_code_int(float X[], float h[], int T0, float code[],
		int *ind_gain, int *shift, int *sign, float gain_T0, int flags)
{
  int i, index;
  float gain_q;
  float Dn[SubFrLen2], tmp_code[SubFrLen2];
  float rr[DIM_RR];
  DECLARE_INT(rrint, DIM_RR);
  DECLARE_SHORT(hint, SubFrLen2);
  DECLARE_INT(Dnint, SubFrLen2);
  DECLARE_SHORT(Xint, SubFrLen2);
  int XScale;
  float hScale;
  int m;
#if 0//TESTME
   float htest[SubFrLen], Xtest[SubFrLen];

   for (i = 0; i<SubFrLen; i++)
   {
	 htest[i] = i; //(float)(i<30?i:60-i);
	 Xtest[i] = (float)(i<30?i:60-i);
   }
   h = htest;
   X = Xtest;
#endif //TESTME

// Include fixed-gain pitch contribution into impulse resp. h[]

  if (T0 < SubFrLen-2)
    for (i = T0; i < SubFrLen; i++)
      h[i] += gain_T0*h[i-T0];

  ALIGN_ARRAY(rrint);
  ALIGN_ARRAY(hint);
  ALIGN_ARRAY(Dnint);
  ALIGN_ARRAY(Xint);

  //hScale = FloatToShortScaled(h, hint, SubFrLen, 3);
  hScale = (float)sqrt(DotProd(h,h,SubFrLen)/(double)SubFrLen);
  m = (asint(hScale) & 0x7f800000) >> 23;
  ScaleFloatToShort(h, hint, SubFrLen, m+3);

  XScale = FloatToShortScaled(X, Xint, SubFrLen, 3);  //would be better to normalize based on engery, not max
#if 0
   for (i = 0; i<SubFrLen; i++)
   {
	 hint[i] = i;
   }
#endif

  // Compute correlations of h[] needed for the codebook search
//TIMER_STAMP(a);
  Cor_hint1(hint, rrint);
   IntToFloat(rrint, DIM_RR, rr);
//TIMER_STAMP(b);
//  Cor_h(h, rr);
////TIMER_STAMP(c);
#if CHTEST
{
  DECLARE_INT(rrint2, DIM_RR);

  ALIGN_ARRAY(rrint2);//debug
  Cor_hint0(hint, rrint2);
  for(i = 0; i<DIM_RR; i++)	 //debug
	  if(rrint[i] != rrint2[i])
	    printf("%3d: %8d %8d  %8d\n",i, rrint[i], rrint2[i], rrint[i] - rrint2[i]);
}
#endif //CHTEST

// Compute correlation of target vector with impulse response.

//TIMER_STAMP(c);
   Cor_h_Xint(hint, Xint, Dnint);
//TIMER_STAMP(d);
   IntToFloat(Dnint, SubFrLen, Dn);

   //TIMER_STAMP(a);

#if TESTME //test
  {
    int fpDnint[SubFrLen2];
//	float scale;

//	scale  =
    Cor_h_X(h,X,Dn);
    FloatToIntScaled(Dn, fpDnint, SubFrLen, 7);
    for (i = 0; i<SubFrLen; i++)
      if(fpDnint[i] != Dnint[i])
        printf("%3d: %8x %8x %8x\n", i, Dnint[i] - fpDnint[i],Dnint[i], fpDnint[i]);
  }
#endif //test


// Find codebook index

//TIMER_STAMP(c);
  index = D4i64_LBC(Dn, rr, h, tmp_code, rr, shift, sign, flags);
//TIMER_STAMP(f);

// Compute innovation vector gain.
// Include fixed-gain pitch contribution into code[].

  *ind_gain = G_code(X, rr, &gain_q);

  for (i=0; i < SubFrLen; i++)
    code[i] = tmp_code[i]*gain_q;

  if(T0 < SubFrLen-2)
    for (i=T0; i < SubFrLen; i++)
      code[i] += code[i-T0]*gain_T0;

  return index;
}


//---------------------------------------------------------------
//---------------------------------------------------------------
void Cor_hint0(short *H, int *rr)
{

//  Compute  correlations of h[]  needed for the codebook search.
//    h[]              :Impulse response.
//    rr[]             :Correlations.

  int *rri0i0, *rri1i1, *rri2i2, *rri3i3;
  int *rri0i1, *rri0i2, *rri0i3;
  int *rri1i2, *rri1i3, *rri2i3;

  int *p0, *p1, *p2, *p3;
  int cor;

  int i, k, m, t;
  DECLARE_SHORT(h,SubFrLen2);
  DECLARE_SHORT(h2,SubFrLen2);

  ALIGN_ARRAY(h);
  ALIGN_ARRAY(h2);

  for(i=0; i<4; i++)
    h[i] = (short)0;

  for(i=0; i<SubFrLen; i++)
    h2[i+2] = h[i+4] = H[i];


// Init pointers

  rri0i0 = rr;
  rri1i1 = rri0i0 + NB_POS;
  rri2i2 = rri1i1 + NB_POS;
  rri3i3 = rri2i2 + NB_POS;

  rri0i1 = rri3i3 + NB_POS;
  rri0i2 = rri0i1 + MSIZE;
  rri0i3 = rri0i2 + MSIZE;
  rri1i2 = rri0i3 + MSIZE;
  rri1i3 = rri1i2 + MSIZE;
  rri2i3 = rri1i3 + MSIZE;

// Compute rri0i0[], rri1i1[], rri2i2[] and rri3i3[]

  cor = 0;
  m = 0;
  for(i=NB_POS-1; i>=0; i--)
  {
    cor += h[m+0]*h[m+0] + h[m+1]*h[m+1];   rri3i3[i] = cor;
    cor += h[m+2]*h[m+2] + h[m+3]*h[m+3];   rri2i2[i] = cor;
    cor += h[m+4]*h[m+4] + h[m+5]*h[m+5];   rri1i1[i] = cor;
    cor += h[m+6]*h[m+6] + h[m+7]*h[m+7];   rri0i0[i] = cor;

    m += 8;
  }

// Compute elements of: rri0i1[], rri0i3[], rri1i2[] and rri2i3[]

  h2 = h+2;
  p3 = rri2i3 + MSIZE-1;
  p2 = rri1i2 + MSIZE-1;
  p1 = rri0i1 + MSIZE-1;
  p0 = rri0i3 + MSIZE-2;

  for (k=0; k<NB_POS; k++)
  {
    cor = 0;
    m = 0;
    t = 0;

    for(i=k+1; i<NB_POS; i++)
    {
      cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
      cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
      cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
      cor += h[m+6]*h2[m+6] + h[m+7]*h2[m+7];   p0[t] = cor;

      t -= (NB_POS+1);
      m += 8;
    }
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
    cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
    cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;

    h2 += STEP;
    p3 -= NB_POS;
    p2 -= NB_POS;
    p1 -= NB_POS;
    p0 -= 1;
  }


// Compute elements of: rri0i2[], rri1i3[]

  h2 = h+4;
  p3 = rri1i3 + MSIZE-1;
  p2 = rri0i2 + MSIZE-1;
  p1 = rri1i3 + MSIZE-2;
  p0 = rri0i2 + MSIZE-2;

  for (k=0; k<NB_POS; k++)
  {
    cor = 0;
    m = 0;
    t = 0;

    for(i=k+1; i<NB_POS; i++)
    {
      cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
      cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
      cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
      cor += h[m+6]*h2[m+6] + h[m+7]*h2[m+7];   p0[t] = cor;

      t -= (NB_POS+1);
      m += 8;
    }
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
    cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;

    h2 += STEP;
    p3 -= NB_POS;
    p2 -= NB_POS;
    p1 -= 1;
    p0 -= 1;
  }

// Compute elements of: rri0i1[], rri0i3[], rri1i2[] and rri2i3[]

  h2 = h+6;
  p3 = rri0i3 + MSIZE-1;
  p2 = rri2i3 + MSIZE-2;
  p1 = rri1i2 + MSIZE-2;
  p0 = rri0i1 + MSIZE-2;

  for (k=0; k<NB_POS; k++)
  {
    cor = 0;
    m = 0;
    t = 0;

    for(i=k+1; i<NB_POS; i++)
    {
      cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
      cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
      cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
      cor += h[m+6]*h2[m+6] + h[m+7]*h2[m+7];   p0[t] = cor;

      t -= (NB_POS+1);
      m += 8;
    }
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;

    h2 += STEP;
    p3 -= NB_POS;
    p2 -= 1;
    p1 -= 1;
    p0 -= 1;
  }

  return;
}

//---------------------------------------------------------------
void cor_h_prods(int oddn,short *h,short *h2,int *p3,int *p2,int *p1,int *p0,int dp3,int dp2,int dp1,int dp0){
  int k;

  for (k=0; k<NB_POS; k++)
  {
    cor_h_prodloop(NB_POS-(k+1),oddn,h,h2,p3,p2,p1,p0);
    h2 += STEP;
    p3 -= dp3;
    p2 -= dp2;
    p1 -= dp1;
    p0 -= dp0;
  }
  return;
}

#if _MSC_FULL_VER >= 13008827 && defined(_M_IX86)
#pragma warning(disable:4731)			// EBP modified with inline asm
#endif

void cor_h_prodloop(int n, int oddn,short *h,short *h2,int *p3,int *p2,int *p1,int *p0)
{
#if ASM_CORHPL
	

	n = n * 4 + oddn;

#define in edi
#define inoff edx
#define out esi
#define out3 out+eax
#define out2 out+ebx
#define out1 out+ebp
#define out0 out

#define L(m,n)  ASM movq mm##m, QP[in+8*n]
#define M(m,n)  ASM pmaddwd mm##m, QP[in+inoff+8*n]
#define S(m)    ASM psrlq mm##m, 32
#define AH(m,n)   ASM paddd mm##m, mm##n
#define WH(m,o) ASM movd DP[out##o], mm##m
#define AL(m,n)   ASM paddd mm##m, mm##n
#define WL(m,o) ASM movd DP[out##o], mm##m


ASM {
   push ebp;
   mov ecx, n;
   mov in, h;
   mov inoff, h2;
   sub inoff, in;
   mov out, p0;
   mov eax, p3;
   mov ebx, p2;
   mov ebp, p1;
   sub eax, out;
   sub ebx, out;
   sub ebp, out;
}
L(0,0);
ASM pxor mm3,mm3;
M(0,0);
		L(1,1);
						AL(3,0); //really a copy
		M(1,1);
S(0);
ASM sub ecx,8;
ASM  jl oddends;

inner:
				L(2,2);
AH(0,3);
						WL(3,3);
WH(0,2);
AL(0,1);
				M(2,2);
		S(1);

						L(3,3);
		AH(1,0);
WL(0,1);
		WH(1,0);
		AL(1,2);
						M(3,3);
				S(2);
ASM sub out, 4*(NB_POS+1);

L(0,4);
				AH(2,1);
		WL(1,3);
				WH(2,2);
				AL(2,3);
M(0,4);
						S(3);

		L(1,5);
						AH(3,2);
				WL(2,1);
						WH(3,0);
						AL(3,0);
		M(1,5);
S(0);
ASM sub out, 4*(NB_POS+1);
ASM  add in, 16*2;
ASM sub ecx, 8;
ASM  jge inner;

oddends:
ASM add ecx, 4;
ASM  jl cleanup;

//four more
				L(2,2);
AH(0,3);
						WL(3,3);
WH(0,2);
AL(0,1);
				M(2,2);
		S(1);

						L(3,3);
		AH(1,0);
WL(0,1);
		WH(1,0);
		AL(1,2);
						M(3,3);
				S(2);
ASM sub out, 4*(NB_POS+1);

				AH(2,1);
ASM dec ecx;
ASM jl innerdone;
		WL(1,3);
ASM dec ecx;
ASM jl innerdone;
				WH(2,2);
				AL(2,3);
ASM dec ecx;
ASM jl innerdone;
				WL(2,1);
ASM jmp innerdone;

cleanup:
ASM add ecx, 4;
ASM dec ecx;
ASM jl innerdone;
AH(0,3);
						WL(3,3);
ASM dec ecx;
ASM jl innerdone;
WH(0,2);
AL(0,1);
ASM dec ecx;
ASM jl innerdone;
WL(0,1);

innerdone:
ASM emms;		
ASM pop ebp;
#undef in
#undef inoff
#undef out
#undef out3
#undef out2
#undef out1
#undef out0

#undef L
#undef M
#undef S
#undef AH
#undef WH
#undef AL
#undef WL
#else //ASM_CORHPL
  int cor;
  int i,m,t;

  cor = 0;
  m = 0;
  t = 0;

  for(i=n; i; i--)
  {
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
    cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
    cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
    cor += h[m+6]*h2[m+6] + h[m+7]*h2[m+7];   p0[t] = cor;

    t -= (NB_POS+1);
    m += 8;
  }
  if(oddn >= 1) {
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
    if(oddn >= 2) {
      cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
      if(oddn >= 3) {
        cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
      }
    }
  }
#endif //ASM_CORHPL

  return;
}

void cor_h_diag(int n, int oddn,short *h,short *h2,int *p3,int *p2,int *p1,int *p0)
{
#if ASM_CORHDL
	

	n = n * 4 + oddn;

#define in edi
#define inoff edx
#define out esi
#define out3 out+eax
#define out2 out+ebx
#define out1 out+ebp
#define out0 out

#define L(m,n)  ASM movq mm##m, QP[in+8*n]
#define M(m,n)  ASM pmaddwd mm##m, QP[in+inoff+8*n]
#define R(m)    ASM psrad mm##m, 1
#define S(m)    ASM psrlq mm##m, 32
#define AH(m,n) ASM paddd mm##m, mm##n
#define WH(m,o) ASM movd DP[out##o], mm##m
#define AL(m,n) ASM paddd mm##m, mm##n
#define WL(m,o) ASM movd DP[out##o], mm##m


ASM {
   push ebp;
   mov ecx, n;
   mov in, h;
   mov inoff, h2;
   sub inoff, in;
   mov out, p0;
   mov eax, p3;
   mov ebx, p2;
   mov ebp, p1;
   sub eax, out;
   sub ebx, out;
   sub ebp, out;
}
L(0,0);
ASM pxor mm3,mm3;
M(0,0);
		L(1,1);
						AL(3,0); //really a copy
		M(1,1);
R(0);
S(0);
ASM sub ecx,8;
ASM  jl oddends;

inner:
				L(2,2);
AH(0,3);
						WL(3,3);
		R(1);
WH(0,2);
AL(0,1);
				M(2,2);
		S(1);

						L(3,3);
		AH(1,0);
WL(0,1);
				R(2);
		WH(1,0);
		AL(1,2);
						M(3,3);
				S(2);
ASM sub out, 4*1;

L(0,4);
				AH(2,1);
		WL(1,3);
						R(3);
				WH(2,2);
				AL(2,3);
M(0,4);
						S(3);

		L(1,5);
						AH(3,2);
				WL(2,1);
R(0);
						WH(3,0);
						AL(3,0);
		M(1,5);
S(0);
ASM sub out, 4*1;
ASM  add in, 16*2;
ASM sub ecx, 8;
ASM  jge inner;

oddends:
ASM add ecx, 4;
ASM  jl cleanup;

//four more
				L(2,2);
AH(0,3);
						WL(3,3);
		R(1);
WH(0,2);
AL(0,1);
				M(2,2);
		S(1);

						L(3,3);
		AH(1,0);
WL(0,1);
				R(2);
		WH(1,0);
		AL(1,2);
						M(3,3);
				S(2);
ASM sub out, 4*1;

				AH(2,1);
ASM dec ecx;
ASM jl innerdone;
		WL(1,3);
ASM dec ecx;
ASM jl innerdone;
				WH(2,2);
				AL(2,3);
ASM dec ecx;
ASM jl innerdone;
				WL(2,1);
ASM jmp innerdone;

cleanup:
ASM add ecx, 4;
ASM dec ecx;
ASM jl innerdone;
AH(0,3);
						WL(3,3);
ASM dec ecx;
ASM jl innerdone;
WH(0,2);
AL(0,1);
ASM dec ecx;
ASM jl innerdone;
WL(0,1);

innerdone:
ASM emms;		
ASM pop ebp;
#undef in
#undef inoff
#undef out
#undef out3
#undef out2
#undef out1
#undef out0

#undef L
#undef M
#undef R
#undef S
#undef AH
#undef WH
#undef AL
#undef WL
#else //ASM_CORHDL
  int cor;
  int i,m,t;

  cor = 0;
  m = 0;
  t = 0;

  for(i=n; i; i--)
  {
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor>>1;
    cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor>>1;
    cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor>>1;
    cor += h[m+6]*h2[m+6] + h[m+7]*h2[m+7];   p0[t] = cor>>1;

    t -= 1;
    m += 8;
  }
  if(oddn >= 1) {
    cor += h[m+0]*h2[m+0] + h[m+1]*h2[m+1];   p3[t] = cor;
    if(oddn >= 2) {
      cor += h[m+2]*h2[m+2] + h[m+3]*h2[m+3];   p2[t] = cor;
      if(oddn >= 3) {
        cor += h[m+4]*h2[m+4] + h[m+5]*h2[m+5];   p1[t] = cor;
      }
    }
  }
#endif //ASM_CORHDL

  return;
}

void Cor_hint1(short *H, int *rr)
{

//  Compute  correlations of h[]  needed for the codebook search.
//    h[]              :Impulse response.
//    rr[]             :Correlations.

  int *rri0i0, *rri1i1, *rri2i2, *rri3i3;
  int *rri0i1, *rri0i2, *rri0i3;
  int *rri1i2, *rri1i3, *rri2i3;

  int *p0, *p1, *p2, *p3;
  short *h2;

  int i;
  DECLARE_SHORT(h,SubFrLen2);
  DECLARE_SHORT(hp2,SubFrLen2);

  ALIGN_ARRAY(h);
  ALIGN_ARRAY(hp2);

  for(i=0; i<4; i++)
    h[i] = (short)0;

  for(i=0; i<SubFrLen; i++)
    hp2[i+2] = h[i+4] = H[i];


// Init pointers

  rri0i0 = rr;
  rri1i1 = rri0i0 + NB_POS;
  rri2i2 = rri1i1 + NB_POS;
  rri3i3 = rri2i2 + NB_POS;

  rri0i1 = rri3i3 + NB_POS;
  rri0i2 = rri0i1 + MSIZE;
  rri0i3 = rri0i2 + MSIZE;
  rri1i2 = rri0i3 + MSIZE;
  rri1i3 = rri1i2 + MSIZE;
  rri2i3 = rri1i3 + MSIZE;
//TIMER_STAMP(a);
// Compute rri0i0[], rri1i1[], rri2i2[] and rri3i3[]

  cor_h_diag(NB_POS,0,h,h,&rri3i3[NB_POS-1],&rri2i2[NB_POS-1],&rri1i1[NB_POS-1],&rri0i0[NB_POS-1]);
//TIMER_STAMP(b);

// Compute elements of: rri0i1[], rri0i3[], rri1i2[] and rri2i3[]

  h2 = hp2;
  p3 = rri2i3 + MSIZE-1;
  p2 = rri1i2 + MSIZE-1;
  p1 = rri0i1 + MSIZE-1;
  p0 = rri0i3 + MSIZE-2;

  cor_h_prods(4-1,h,h2,p3,p2,p1,p0,NB_POS,NB_POS,NB_POS,1);

// Compute elements of: rri0i2[], rri1i3[]

  h2 = h+4;
  p3 = rri1i3 + MSIZE-1;
  p2 = rri0i2 + MSIZE-1;
  p1 = rri1i3 + MSIZE-2;
  p0 = rri0i2 + MSIZE-2;

  cor_h_prods(4-2,h,h2,p3,p2,p1,p0,NB_POS,NB_POS,1,1);

// Compute elements of: rri0i1[], rri0i3[], rri1i2[] and rri2i3[]

  h2 = hp2+4;
  p3 = rri0i3 + MSIZE-1;
  p2 = rri2i3 + MSIZE-2;
  p1 = rri1i2 + MSIZE-2;
  p0 = rri0i1 + MSIZE-2;

  cor_h_prods(4-3,h,h2,p3,p2,p1,p0,NB_POS,1,1,1);
//TIMER_STAMP(c);

  return;
}

//---------------------------------------------------------------------------
void Cor_h_Xint(short h[],short X[],int D[])
{
   int i;
   DECLARE_SHORT(hh, 2*SubFrLen+16); //h[-1,0,0,1,1,2,2,3,3,4,4,5,...57,58,58,59]
   DECLARE_SHORT(XX, 2*SubFrLen+16); //X[ 0,1,0,1,2,3,2,3,4,5,4,5,...58,59,58,59]
#if TESTME
   short htest[SubFrLen], Xtest[SubFrLen];

   for (i = 0; i<SubFrLen; i++)
   {
	 htest[i] = 1;//(short)(i<30?i:60-i);
	 Xtest[i] = 1;//(short)(i<30?i:60-i);
   }
   h = htest;
   X = Xtest;
#endif //TESTME

   ALIGN_ARRAY(hh);
   ALIGN_ARRAY(XX);
   for (i=2*SubFrLen; i < 2*SubFrLen+16; i++) {
	 XX[i] = hh[i] = (short)0;
   }
//   hh += 8; XX += 8;

#define ASM_Cor_h_Xint 1
#if ASM_Cor_h_Xint
   ab2ababw(X, XX, SubFrLen);
   ab2abzaw(h, hh, SubFrLen);
   //TIMER_STAMP(e);
   CorrelateIntTri (hh, XX, D, SubFrLen);
#if TESTME
   {
	   int D2[SubFrLen];
       CorrelateInt22 (hh, XX, D2, SubFrLen);
	   for (i = 0; i<SubFrLen; i++)	{
		//  if(D[i] != D2[i])
			printf("%3d: %6d %6d %6d   ", i,D[i], D2[i], D[i] - D2[i]);
			if(i&1) printf("\n");
	   }
   }
#endif TESTME	

#else //ASM_Cor_h_Xint
   for (i=0; i < SubFrLen; i+=2)	 {
	 hh[2*i] = (i-1 >= 0) ? h[i-1] : (short)0;
     hh[2*i+1] = h[i];
     hh[2*i+2] = h[i];
     hh[2*i+3] = h[i+1];
	 XX[2*i] = X[i];
	 XX[2*i+1] = X[i+1];
	 XX[2*i+2] = X[i];
	 XX[2*i+3] = X[i+1];
}

   for (i=0; i < 2*SubFrLen; i+=4)	 {
	 int acc0 = 0, acc1 = 0;
	 for (j=0; j < 2*SubFrLen - i; j+=4) {
       acc0 += (int)hh[j]*XX[i+j] + (int)hh[j+1]*XX[i+j+1];
       acc1 += (int)hh[j+2]*XX[i+j+2] + (int)hh[j+3]*XX[i+j+3];
	 }
	 D[i/2] = acc0 >> 16;
	 D[i/2+1] = acc1 >> 16;
   }
#endif //ASM_Cor_h_Xint
	
   return;
}
//---------------------------------------------------------------------------
#define ASM_CORR_TRI 1
//#if ASM_CORR_TRI
//------------------------------------------------------
// triangular correlations
// ASSUMES that array has 8 zero values beyond the end
//   and can be read 8 more beyond that (without page fault etc)
// data format is
//   taps: 0 t0 t0 t1  t1 t2 t2 t3  t3 t4 t4 t5 ... t57 t58 t58 t59
//	 arr: a0 a1 a0 a1  a2 a3 a2 a3  a4 a5 a4 a5 ... a58 a59 a58 a59
//
void CorrelateIntTri(short *taps, short *array, int *corr, int ncor)
{
#define rega0  mm0
#define regb0  mm1
#define rega1  mm2
#define regb1  mm3
#define rega2  mm4
#define regb2  mm5
#define acc0   mm6
#define acc1   mm7

#define arr    esi
#define tap    edi
#define cor    eax
#define icnt   ecx

// In the following macros, 'n' is the column number and 'i' is the
// iteration number.

// we use "the convolution trick" or using la twice so that one
// of the pmadd's is reg,reg and thus can be in the V-slot.

// NOTE: we have read ahead up to 2 quadwords
//   so we need QP[taps+8*ncor] = QP[taps+8*ncor+8] = [0 0 0 0]
//   and reading QP[array+8*ncor] or QP[array+8*ncor+8] must be legal

#define la(n,i)  ASM movq  rega##n,QP[arr+8*i]
#define lb(n,i)  ASM movq  regb##n,QP[tap+8*i-8]
#define m0(n,i)  ASM pmaddwd regb##n,rega##n
#define m1(n,i)  ASM pmaddwd rega##n,QP[tap+8*i]
#define a0(n,i)  ASM paddd acc0,regb##n
#define a1(n,i)  ASM paddd acc1,rega##n

  ASM
  {
    shr ncor,1;
    mov cor,corr;
    mov tap,taps;
    mov arr,array;
    mov icnt,ncor;
  }

ForEachCorrPair:

// prime the pump

  la(0,0);
  ASM pxor regb0,regb0;   // to  avoid lb(0,0) reading taps[-1]
          la(1,1);
  ASM pxor acc0,acc0;	  // clear accumulator
  m1(0,0);
  ASM pxor acc1,acc1;	  // clear accumulator
          lb(1,1);
  ASM sub icnt, 1;        // account for pump priming
  ASM jle cleanup;        // bypass if only one to do

inner:
                  la(2,2);
          m0(1,1);
          m1(1,1);
  a0(0,0);
                  lb(2,2);
  a1(0,0);
  la(0,3);
                  m0(2,2);
                  m1(2,2);
          a0(1,1);
  lb(0,3);
          a1(1,1);
          la(1,4);
  m0(0,3);
  m1(0,3);
                  a0(2,2);
          lb(1,4);
                  a1(2,2);

  ASM add arr,24;
  ASM add tap,24;

  ASM sub icnt,3;
  ASM jg inner;

cleanup:  //  last two adds
  a0(0,0);
  a1(0,0);

// Done with one correlation pair.  Pack and store 2 results in corr array

  ASM
  {
    add cor,16;
     mov arr, array
    mov tap,taps;
	 add arr,16;
    mov icnt, ncor;
	
	mov array, arr;
	 sub icnt,2;	  //set flags for jump

	movq  QP[cor-16],acc1;
	movq  QP[cor-8],acc0;

	mov ncor, icnt;
    jg ForEachCorrPair;

    emms;
  }

}
#undef rega0
#undef regb0
#undef rega1
#undef regb1
#undef rega2
#undef regb2
#undef acc0
#undef acc1

#undef arr
#undef tap
#undef cor
#undef icnt
#undef la
#undef lb
#undef m0
#undef m1
#undef a0
#undef a1
// 16 bit output
//	 psrad acc0,16;//this could be less in some cases
//	 psrad acc1,16;
//	 packssdw acc1,acc0;
//   movq  QP[cor-8],acc0;

//#else
//------------------------------------------------------
void CorrelateInt22(short *taps, short *array, int *corr, int ncor)
{
  int i,j;

  for (i=0; i < 2*ncor; i+=4)	 {
    int acc0 = 0, acc1 = 0;
    for (j=0; j < 2*ncor - i; j+=4) {
      acc0 += (int)taps[j]*array[i+j] + (int)taps[j+1]*array[i+j+1];
      acc1 += (int)taps[j+2]*array[i+j+2] + (int)taps[j+3]*array[i+j+3];
    }
    corr[i/2] = acc0 ;
    corr[i/2+1] = acc1 ;
  }

  return;
}
//#endif

#endif //COMPILE_MMX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\dec\dech263\slib_api.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib_api.c,v $
 * Revision 1.1.6.35  1996/12/13  18:19:04  Hans_Graves
 * 	Update Audio and Video timestamp correctly.
 * 	[1996/12/13  18:09:02  Hans_Graves]
 *
 * Revision 1.1.6.34  1996/12/12  20:54:44  Hans_Graves
 * 	Timestamp fixes after seek to Key frames.
 * 	[1996/12/12  20:52:06  Hans_Graves]
 *
 * Revision 1.1.6.33  1996/12/10  19:46:02  Hans_Graves
 * 	Fix floating division error when audio only.
 * 	[1996/12/10  19:45:03  Hans_Graves]
 *
 * Revision 1.1.6.32  1996/12/10  19:21:55  Hans_Graves
 * 	Made calculate video positions more accurate using slibFrameToTime100().
 * 	[1996/12/10  19:16:20  Hans_Graves]
 *
 * Revision 1.1.6.31  1996/12/05  20:10:15  Hans_Graves
 * 	Add gradual increase or decrease of framerates according to timestamps.
 * 	[1996/12/05  20:06:57  Hans_Graves]
 *
 * Revision 1.1.6.30  1996/12/04  22:34:28  Hans_Graves
 * 	Put limit on data used by Sv/SaDecompressBegin().
 * 	[1996/12/04  22:14:33  Hans_Graves]
 *
 * Revision 1.1.6.29  1996/12/03  23:15:13  Hans_Graves
 * 	MME-1498: Made seeks with PERCENT100 more accurate
 * 	[1996/12/03  23:10:43  Hans_Graves]
 *
 * Revision 1.1.6.28  1996/12/03  00:08:31  Hans_Graves
 * 	Handling of End Of Sequence points. Added PERCENT100 support.
 * 	[1996/12/03  00:05:59  Hans_Graves]
 *
 * Revision 1.1.6.27  1996/11/21  23:34:21  Hans_Graves
 * 	Handle MPEG B frames better when seeking.
 * 	[1996/11/21  23:28:18  Hans_Graves]
 *
 * Revision 1.1.6.26  1996/11/20  02:15:09  Hans_Graves
 * 	Added SEEK_AHEAD.  Removed old code.
 * 	[1996/11/20  02:10:43  Hans_Graves]
 *
 * Revision 1.1.6.25  1996/11/18  23:07:21  Hans_Graves
 * 	Remove MaxVideoLength usage.
 * 	[1996/11/18  22:55:56  Hans_Graves]
 *
 * 	Make use of presentation timestamps. Make seeking time-based.
 * 	[1996/11/18  22:47:30  Hans_Graves]
 *
 * Revision 1.1.6.24  1996/11/14  21:49:26  Hans_Graves
 * 	AC3 buffering fixes.
 * 	[1996/11/14  21:43:20  Hans_Graves]
 *
 * Revision 1.1.6.23  1996/11/13  16:10:54  Hans_Graves
 * 	AC3 recognition of byte reversed streams in slibGetDataFormat().
 * 	[1996/11/13  16:03:14  Hans_Graves]
 *
 * Revision 1.1.6.22  1996/11/11  18:21:03  Hans_Graves
 * 	More AC3 support changes.
 * 	[1996/11/11  17:59:01  Hans_Graves]
 *
 * Revision 1.1.6.21  1996/11/08  21:51:02  Hans_Graves
 * 	Added AC3 support. Better seperation of stream types.
 * 	[1996/11/08  21:27:57  Hans_Graves]
 *
 * Revision 1.1.6.20  1996/10/31  00:08:51  Hans_Graves
 * 	Fix skipping data after RESET with MPEG video only streams.
 * 	[1996/10/31  00:07:08  Hans_Graves]
 *
 * Revision 1.1.6.19  1996/10/28  23:16:42  Hans_Graves
 * 	MME-0145?, Fix artifacts when using SlibReadData() at a new position. Jump to first GOP.
 * 	[1996/10/28  23:13:01  Hans_Graves]
 *
 * Revision 1.1.6.18  1996/10/28  17:32:28  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:22:58  Hans_Graves]
 *
 * Revision 1.1.6.17  1996/10/17  00:23:32  Hans_Graves
 * 	Fix buffer problems after SlibQueryData() calls.
 * 	[1996/10/17  00:19:05  Hans_Graves]
 *
 * Revision 1.1.6.16  1996/10/15  17:34:09  Hans_Graves
 * 	Added MPEG-2 Program Stream support.
 * 	[1996/10/15  17:30:26  Hans_Graves]
 *
 * Revision 1.1.6.15  1996/10/12  17:18:51  Hans_Graves
 * 	Fixed some seeking problems. Moved render code to slib_render.c
 * 	[1996/10/12  17:00:49  Hans_Graves]
 *
 * Revision 1.1.6.14  1996/10/03  19:14:21  Hans_Graves
 * 	Added Presentation and Decoding timestamp support.
 * 	[1996/10/03  19:10:35  Hans_Graves]
 *
 * Revision 1.1.6.13  1996/09/29  22:19:37  Hans_Graves
 * 	Added stride support. Added SlibQueryData().
 * 	[1996/09/29  21:29:44  Hans_Graves]
 *
 * Revision 1.1.6.12  1996/09/25  19:16:44  Hans_Graves
 * 	Added DECOMPRESS_QUERY. Fix up support for YUY2.
 * 	[1996/09/25  19:00:45  Hans_Graves]
 *
 * Revision 1.1.6.11  1996/09/23  18:04:03  Hans_Graves
 * 	Added stats support. Scaleing and negative height fixes.
 * 	[1996/09/23  17:59:31  Hans_Graves]
 *
 * Revision 1.1.6.10  1996/09/18  23:46:32  Hans_Graves
 * 	Seek fixes. Added SlibReadData() and SlibAddBufferEx().
 * 	[1996/09/18  22:04:57  Hans_Graves]
 *
 * Revision 1.1.6.9  1996/08/09  20:51:42  Hans_Graves
 * 	Fix handle arg for SlibRegisterVideoBuffer()
 * 	[1996/08/09  20:10:11  Hans_Graves]
 *
 * Revision 1.1.6.8  1996/07/19  02:11:11  Hans_Graves
 * 	Added SlibRegisterVideoBuffer. Added YUV422i to RGB 16 rendering.
 * 	[1996/07/19  02:01:11  Hans_Graves]
 *
 * Revision 1.1.6.7  1996/06/03  21:41:12  Hans_Graves
 * 	Fix file seeking.  Always seeked to position 0.
 * 	[1996/06/03  21:40:44  Hans_Graves]
 *
 * Revision 1.1.6.6  1996/05/24  22:21:44  Hans_Graves
 * 	Merge MME-1221. Last SlibReadAudio() returned EndOfStream even if data read.
 * 	[1996/05/24  20:58:42  Hans_Graves]
 *
 * Revision 1.1.6.5  1996/05/23  18:46:35  Hans_Graves
 * 	Seperate global audio and video SInfo variables, to help multi-threaded apps
 * 	[1996/05/23  18:35:14  Hans_Graves]
 *
 * Revision 1.1.6.4  1996/05/23  18:16:31  Hans_Graves
 * 	Added more YUV Conversions. MPEG audio buffering fix.
 * 	[1996/05/23  18:16:11  Hans_Graves]
 *
 * Revision 1.1.6.3  1996/05/10  21:17:00  Hans_Graves
 * 	Added callback support. Also fill entire buffers when calling SlibReadAudio()
 * 	[1996/05/10  20:26:08  Hans_Graves]
 *
 * Revision 1.1.6.2  1996/05/07  19:56:16  Hans_Graves
 * 	Added SlibOpen() and SlibAddBuffer() framework. Added HUFF_SUPPORT.
 * 	[1996/05/07  17:20:12  Hans_Graves]
 *
 * Revision 1.1.4.16  1996/05/02  17:10:33  Hans_Graves
 * 	Be more specific about checking for MPEG-2 Systems file type. Fixes MME-01234
 * 	[1996/05/02  17:04:44  Hans_Graves]
 *
 * Revision 1.1.4.15  1996/04/24  22:33:44  Hans_Graves
 * 	MPEG encoding bitrate fixups.
 * 	[1996/04/24  22:27:09  Hans_Graves]
 *
 * Revision 1.1.4.14  1996/04/23  21:22:31  Hans_Graves
 * 	Added description for SlibErrorSettingNotEqual
 * 	[1996/04/23  21:16:09  Hans_Graves]
 *
 * Revision 1.1.4.13  1996/04/22  15:04:51  Hans_Graves
 * 	Fix bad frame counts and seeking under NT caused by int overflows
 * 	[1996/04/22  15:02:26  Hans_Graves]
 *
 * Revision 1.1.4.12  1996/04/19  21:52:22  Hans_Graves
 * 	MPEG 1 Systems writing enhancements
 * 	[1996/04/19  21:47:48  Hans_Graves]
 *
 * Revision 1.1.4.11  1996/04/15  14:18:37  Hans_Graves
 * 	Handle any audio buffer size during encoding.
 * 	[1996/04/15  14:16:11  Hans_Graves]
 *
 * Revision 1.1.4.10  1996/04/12  19:25:20  Hans_Graves
 * 	Add MPEG2_VIDEO type to Commit
 * 	[1996/04/12  19:24:19  Hans_Graves]
 *
 * Revision 1.1.4.9  1996/04/10  21:47:41  Hans_Graves
 * 	Fix in SlibIsEnd().
 * 	[1996/04/10  21:39:37  Hans_Graves]
 *
 * Revision 1.1.4.8  1996/04/09  16:04:42  Hans_Graves
 * 	Remove NT warnings
 * 	[1996/04/09  14:42:48  Hans_Graves]
 *
 * Revision 1.1.4.7  1996/04/04  23:35:07  Hans_Graves
 * 	Format conversion cleanup
 * 	[1996/04/04  23:16:20  Hans_Graves]
 *
 * Revision 1.1.4.6  1996/04/01  19:07:52  Hans_Graves
 * 	And some error checking
 * 	[1996/04/01  19:04:33  Hans_Graves]
 *
 * Revision 1.1.4.5  1996/04/01  16:23:12  Hans_Graves
 * 	NT porting
 * 	[1996/04/01  16:15:54  Hans_Graves]
 *
 * Revision 1.1.4.4  1996/03/29  22:21:30  Hans_Graves
 * 	Added MPEG/JPEG/H261_SUPPORT ifdefs
 * 	[1996/03/29  21:56:55  Hans_Graves]
 *
 * 	Added MPEG-I Systems encoding support
 * 	[1996/03/27  21:55:54  Hans_Graves]
 *
 * Revision 1.1.4.3  1996/03/12  16:15:45  Hans_Graves
 * 	Added seperate streams to SlibIsEnd()
 * 	[1996/03/12  15:56:28  Hans_Graves]
 *
 * Revision 1.1.4.2  1996/03/08  18:46:42  Hans_Graves
 * 	YUV conversions moved to slibRenderFrame()
 * 	[1996/03/08  18:14:47  Hans_Graves]
 *
 * Revision 1.1.2.18  1996/02/22  23:30:24  Hans_Graves
 * 	Update FPS on seeks
 * 	[1996/02/22  23:29:27  Hans_Graves]
 *
 * Revision 1.1.2.17  1996/02/22  22:23:56  Hans_Graves
 * 	Update frame numbers with timecode more often
 * 	[1996/02/22  22:23:07  Hans_Graves]
 *
 * Revision 1.1.2.16  1996/02/21  22:52:43  Hans_Graves
 * 	Fixed MPEG 2 systems stuff
 * 	[1996/02/21  22:50:55  Hans_Graves]
 *
 * Revision 1.1.2.15  1996/02/19  20:09:28  Hans_Graves
 * 	Debugging message clean-up
 * 	[1996/02/19  20:08:31  Hans_Graves]
 *
 * Revision 1.1.2.14  1996/02/19  18:03:54  Hans_Graves
 * 	Fixed a number of MPEG related bugs
 * 	[1996/02/19  17:57:36  Hans_Graves]
 *
 * Revision 1.1.2.13  1996/02/13  18:47:46  Hans_Graves
 * 	Fix some Seek related bugs
 * 	[1996/02/13  18:40:36  Hans_Graves]
 *
 * Revision 1.1.2.12  1996/02/07  23:23:54  Hans_Graves
 * 	Added SEEK_EXACT. Fixed most frame counting problems.
 * 	[1996/02/07  23:20:29  Hans_Graves]
 *
 * Revision 1.1.2.11  1996/02/06  22:54:05  Hans_Graves
 * 	Seek fix-ups. More accurate MPEG frame counts.
 * 	[1996/02/06  22:44:56  Hans_Graves]
 *
 * Revision 1.1.2.10  1996/02/02  17:36:02  Hans_Graves
 * 	Enhanced audio info. Cleaned up API
 * 	[1996/02/02  17:29:44  Hans_Graves]
 *
 * Revision 1.1.2.9  1996/01/30  22:23:08  Hans_Graves
 * 	Added AVI YUV support
 * 	[1996/01/30  22:21:38  Hans_Graves]
 *
 * Revision 1.1.2.8  1996/01/15  16:26:27  Hans_Graves
 * 	Removed debuging message
 * 	[1996/01/15  16:02:47  Hans_Graves]
 *
 * 	Added MPEG 1 Audio compression and SlibWriteAudio()
 * 	[1996/01/15  15:45:46  Hans_Graves]
 *
 * Revision 1.1.2.7  1996/01/11  16:17:29  Hans_Graves
 * 	Added MPEG II Systems decode support
 * 	[1996/01/11  16:12:33  Hans_Graves]
 *
 * Revision 1.1.2.6  1996/01/08  16:41:31  Hans_Graves
 * 	Added MPEG II decoding support
 * 	[1996/01/08  15:53:02  Hans_Graves]
 *
 * Revision 1.1.2.5  1995/12/08  20:01:20  Hans_Graves
 * 	Fixed SlibSetParam(). Added H.261 compression support.
 * 	[1995/12/08  19:53:52  Hans_Graves]
 *
 * Revision 1.1.2.4  1995/12/07  19:31:36  Hans_Graves
 * 	Added JPEG Decoding and MPEG encoding support
 * 	[1995/12/07  18:30:10  Hans_Graves]
 *
 * Revision 1.1.2.3  1995/11/09  23:14:05  Hans_Graves
 * 	Added MPEG audio decompression
 * 	[1995/11/09  23:08:33  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/11/06  18:47:52  Hans_Graves
 * 	First time under SLIB
 * 	[1995/11/06  18:36:01  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/


#include <fcntl.h>
#include <sys/stat.h>
#ifdef WIN32
#include <io.h>
#endif
#ifdef _SHM_
#include  <sys/ipc.h>  /* shared memory */
#endif
#define SLIB_INTERNAL
#include "slib.h"
#include "SC_err.h"
/* #include "SC_convert.h" */
#include "mpeg.h"
#include "ac3.h"
#include "avi.h"

#ifdef _SLIBDEBUG_
#include <stdio.h>
#include "sc_debug.h"

#define _DEBUG_     1  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#define _SEEK_      1  /* seek, frame counts/timecode info: 2=more detail */
#define _CALLBACK_  0  /* callback debugging */
#define _DUMP_      0  /* dump data in hex format */
#define _TIMECODE_  1  /* debug timecodes */
#endif

static SlibStatus_t slibOpen(SlibHandle_t *handle, SlibMode_t smode,
                             SlibType_t *stype);

/*
** Lists
*/
static SlibList_t _listTypes [] = {
  SLIB_TYPE_MPEG1_VIDEO,   "MPEG1_VIDEO", "MPEG-1 Video Stream",0,0,
  SLIB_TYPE_MPEG1_AUDIO,   "MPEG1_AUDIO", "MPEG-1 Audio Stream",0,0,
  SLIB_TYPE_MPEG2_VIDEO,   "MPEG2_VIDEO", "MPEG-2 Video Stream",0,0,
  SLIB_TYPE_MPEG2_AUDIO,   "MPEG2_AUDIO", "MPEG-2 Audio Stream",0,0,
  SLIB_TYPE_AC3_AUDIO,     "AC3", "Dolby Digital(AC-3) Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS,  "MPEG_SYSTEMS", "MPEG Systems Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS_MPEG2, "MPEG_SYSTEMS_MPEG2", "MPEG Systems (MPEG-2)",0,0,
  SLIB_TYPE_MPEG_TRANSPORT,"MPEG_TRANSPORT", "MPEG Transport Stream",0,0,
  SLIB_TYPE_MPEG_PROGRAM,  "MPEG_PROGRAM", "MPEG Program Stream",0,0,
  SLIB_TYPE_H261,          "H261", "H.261 Video Stream",0,0,
  SLIB_TYPE_RTP_H261,      "RTP_H261", "RTP (H.261) Stream",0,0,
  SLIB_TYPE_H263,          "H263", "H.263 Video Stream",0,0,
  SLIB_TYPE_RTP_H263,      "RTP_H263", "RTP (H.263) Stream",0,0,
  SLIB_TYPE_RIFF,          "RIFF", "RIFF File Format",0,0,
  SLIB_TYPE_AVI,           "AVI", "AVI File Format",0,0,
  SLIB_TYPE_PCM_WAVE,      "PCM_WAVE", "WAVE (PCM) File Format",0,0,
  SLIB_TYPE_JPEG_AVI,      "JPEG_AVI", "AVI (JPEG) Stream",0,0,
  SLIB_TYPE_MJPG_AVI,      "MJPG_AVI", "AVI (MJPG) Stream",0,0,
  SLIB_TYPE_YUV_AVI,       "YUV_AVI", "AVI (YUV) File Format",0,0,
  SLIB_TYPE_JFIF,          "JFIF",  "JPEG (JFIF) Stream",0,0,
  SLIB_TYPE_JPEG_QUICKTIME,"JPEG_QUICKTIME","JPEG (Quicktime) Stream",0,0,
  SLIB_TYPE_JPEG,          "JPEG",  "JPEG Stream",0,0,
  SLIB_TYPE_MJPG,          "MJPG",  "MJPG Stream",0,0,
  SLIB_TYPE_YUV,           "YUV",   "YUV Data",0,0,
  SLIB_TYPE_RGB,           "RGB",   "RGB Data",0,0,
  SLIB_TYPE_PCM,           "PCM",   "PCM Audio",0,0,
  SLIB_TYPE_SLIB,          "SLIB",  "SLIB Stream",0,0,
  SLIB_TYPE_SHUFF,         "SHUFF", "SLIB Huffman Stream",0,0,
  SLIB_TYPE_G723,          "G723",  "G.723 Audio Stream",0,0,
  SLIB_TYPE_RASTER,        "RASTER","Sun Raster",0,0,
  SLIB_TYPE_BMP,           "BMP",   "Windows Bitmap",0,0,
  0, NULL, "End of List",0,0
};

static SlibList_t _listCompressTypes [] = {
#ifdef MPEG_SUPPORT
  SLIB_TYPE_MPEG1_VIDEO,        "MPEG1_VIDEO",   "MPEG-1 Video Stream",0,0,
  SLIB_TYPE_MPEG1_AUDIO,        "MPEG1_AUDIO",   "MPEG-1 Audio Stream",0,0,
  SLIB_TYPE_MPEG2_VIDEO,        "MPEG2_VIDEO",   "MPEG-2 Video Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS,       "MPEG_SYSTEMS",  "MPEG Systems Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS_MPEG2, "MPEG2_SYSTEMS", "MPEG Systems (MPEG-2)",0,0,
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
  SLIB_TYPE_H261,          "H261",  "H.261 Video Stream",0,0,
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
  SLIB_TYPE_H263,          "H263",  "H.263 Video Stream",0,0,
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
  SLIB_TYPE_SHUFF,         "SHUFF", "SLIB Huffman Stream",0,0,
#endif /* HUFF_SUPPORT */
#ifdef G723_SUPPORT
  SLIB_TYPE_G723,          "G723",  "G.723 Audio Stream",0,0,
#endif /* G723_SUPPORT */
  0, NULL, "End of List",0,0
};

static SlibList_t _listDecompressTypes [] = {
#ifdef MPEG_SUPPORT
  SLIB_TYPE_MPEG1_VIDEO,   "MPEG1_VIDEO", "MPEG-1 Video Stream",0,0,
  SLIB_TYPE_MPEG1_AUDIO,   "MPEG1_AUDIO", "MPEG-1 Audio Stream",0,0,
  SLIB_TYPE_MPEG2_VIDEO,   "MPEG2_VIDEO", "MPEG-2 Video Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS,       "MPEG_SYSTEMS",   "MPEG Systems Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS_MPEG2, "MPEG2_SYSTEMS",  "MPEG Systems (MPEG-2)",0,0,
  SLIB_TYPE_MPEG_TRANSPORT,     "MPEG_TRANSPORT", "MPEG Transport Stream",0,0,
  SLIB_TYPE_MPEG_PROGRAM,       "MPEG_PROGRAM",   "MPEG Program Stream",0,0,
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
  SLIB_TYPE_AC3_AUDIO,     "AC3",         "Dolby Digital(AC-3) Stream",0,0,
#endif /* AC3_SUPPORT */
#ifdef H261_SUPPORT
  SLIB_TYPE_H261,          "H261",  "H.261 Video Stream",0,0,
  SLIB_TYPE_RTP_H261,      "RTP_H261", "RTP (H.261) Stream",0,0,
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
  SLIB_TYPE_H263,          "H263",     "H.263 Video Stream",0,0,
  SLIB_TYPE_RTP_H263,      "RTP_H263", "RTP (H.263) Stream",0,0,
#endif /* H261_SUPPORT */
#ifdef JPEG_SUPPORT
  SLIB_TYPE_JPEG_AVI,      "JPEG_AVI", "AVI (JPEG) Stream",0,0,
  SLIB_TYPE_MJPG_AVI,      "MJPG_AVI", "AVI (MJPG) Stream",0,0,
#endif /* JPEG_SUPPORT */
  SLIB_TYPE_RIFF,          "RIFF", "RIFF File Format",0,0,
  SLIB_TYPE_AVI,           "AVI", "AVI File Format",0,0,
  SLIB_TYPE_PCM_WAVE,      "PCM_WAVE", "WAVE (PCM) File Format",0,0,
  SLIB_TYPE_YUV_AVI,       "YUV_AVI", "AVI (YUV) File Format",0,0,
  SLIB_TYPE_RASTER,        "RASTER","Sun Raster",0,0,
  SLIB_TYPE_BMP,           "BMP",   "Windows Bitmap",0,0,
#ifdef HUFF_SUPPORT
  SLIB_TYPE_SHUFF,         "SHUFF", "SLIB Huffman Stream",0,0,
#endif /* HUFF_SUPPORT */
#ifdef G723_SUPPORT
  SLIB_TYPE_G723,          "G723",  "G.723 Audio Stream",0,0,
#endif /* G723_SUPPORT */
  0, NULL, "End of List",0,0
};

static SlibList_t _listErrors[] = {
  SlibErrorNone,        "SlibErrorNone",
                        "No Error",0,0,
  SlibErrorInternal,    "SlibErrorInternal",
                        "Internal SLIB error",0,0,
  SlibErrorMemory,      "SlibErrorMemory",
                        "Unable to allocated memory",0,0,
  SlibErrorBadArgument, "SlibErrorBadArgument",
                        "Invalid argument to function",0,0,
  SlibErrorBadHandle,   "SlibErrorBadHandle",
                        "Invalid SLIB handle",0,0,
  SlibErrorBadMode,     "SlibErrorBadMode",
                        "Invalid SLIB mode",0,0,
  SlibErrorUnsupportedFormat, "SlibErrorUnsupportedFormat",
                        "Unsupported format",0,0,
  SlibErrorReading,     "SlibErrorReading",
                        "Error reading from file",0,0,
  SlibErrorWriting,     "SlibErrorWriting",
                        "Error writing to file",0,0,
  SlibErrorBufSize,     "SlibErrorBufSize",
                        "Buffer size is too small",0,0,
  SlibErrorEndOfStream, "SlibErrorEndOfStream",
                        "End of data stream",0,0,
  SlibErrorForwardOnly, "SlibErrorForwardOnly",
                        "The decompressor can work only forward",0,0,
  SlibErrorUnsupportedParam, "SlibErrorUnsupportedParam",
                        "The parameter is invalid or unsupported",0,0,
  SlibErrorImageSize,   "SlibErrorImageSize",
                        "Invalid image height and/or width size",0,0,
  SlibErrorSettingNotEqual, "SlibErrorSettingNotEqual",
                        "The exact parameter setting was not used",0,0,
  SlibErrorInit,        "SlibErrorInit",
                        "Initializing CODEC failed",0,0,
  SlibErrorFileSize,    "SlibErrorFileSize",
                        "Error in file size",0,0,
  SlibErrorBadPosition, "SlibErrorBadPosition",
                        "Error in seek position",0,0,
  SlibErrorBadUnit,     "SlibErrorBadUnit",
                        "Error in seek units",0,0,
  SlibErrorNoData,      "SlibErrorNoData",
                        "No data available",0,0,
  0, NULL, "End of List",0,0
};

SlibList_t *SlibFindEnumEntry(SlibList_t *list, int enumval)
{
  if (!list)
    return(NULL);
  while (list->Name)
  {
    if (list->Enum==enumval)
      return(list);
    list++;
  }
  return(NULL);
}

char *SlibGetErrorText(SlibStatus_t status)
{
  SlibList_t *entry=SlibFindEnumEntry(_listErrors, status);
  if (entry)
    return(entry->Desc);
  else
    return(NULL);
}

int VCompressCallback(SvHandle_t Svh, SvCallbackInfo_t *CB,
                                      SvPictureInfo_t *pinfo)
{
  int status;
  SlibInfo_t *Info=(SlibInfo_t *)CB->UserData;
  _SlibDebug(_CALLBACK_, printf("VCompressCallback()\n") );

  switch (CB->Message)
  {
     case CB_END_BUFFERS:
            _SlibDebug(_CALLBACK_,
              printf("VCompressCallback received CB_END_BUFFER message\n") );
            if (CB->DataType==CB_DATA_COMPRESSED)
            {
              CB->DataSize=Info->CompBufSize;
              CB->Data=SlibAllocBuffer(CB->DataSize);
              status=SvAddBuffer(Svh, CB);
              _SlibDebug(_WARN_ && status!=NoErrors,
                        printf("SvAddBuffer() %s\n", ScGetErrorStr(status)) );
            }
            break;
     case CB_RELEASE_BUFFER:
            _SlibDebug(_CALLBACK_,
            printf("VCompressCallback received CB_RELEASE_BUFFER message\n"));
            if (CB->DataType==CB_DATA_COMPRESSED && CB->Data && CB->DataUsed)
            {
              SlibPin_t *dstpin=slibGetPin(Info, SLIB_DATA_VIDEO);
              if (dstpin)
              {
                slibAddBufferToPin(dstpin, CB->Data, CB->DataUsed,
                                           Info->VideoPTimeCode);
                Info->VideoPTimeCode=SLIB_TIME_NONE;
                if (!slibCommitBuffers(Info, FALSE))
                  CB->Action = CB_ACTION_END;
                break;
              }
            }
            if (CB->Data)
              SlibFreeBuffer(CB->Data);
            break;
     case CB_FRAME_START:
            _SlibDebug(_CALLBACK_||_TIMECODE_,
               printf("VCompress CB_FRAME_START: TimeCode=%ld TemporalRef=%d\n",
                        pinfo->TimeCode, pinfo->TemporalRef) );
            Info->VideoPTimeCode=pinfo->TimeCode;
#if 0
            if (pinfo->Type==SV_I_PICTURE || pinfo->Type==SV_P_PICTURE)
            {
              if (!SlibTimeIsValid(Info->LastVideoDTimeCode))
                Info->VideoDTimeCode=-1000/(long)Info->FramesPerSec;
              else
                Info->VideoDTimeCode=Info->LastVideoDTimeCode;
              Info->LastVideoDTimeCode=pinfo->TimeCode;
              _SlibDebug(_CALLBACK_||_TIMECODE_,
                printf("CB_FRAME_START: LastVideoDTimeCode=%ld VideoDTimeCode=%ld\n",
                           Info->LastVideoDTimeCode, Info->VideoDTimeCode));
            }
            else
              Info->VideoDTimeCode=-1;
#endif
            break;
  }
  CB->Action = CB_ACTION_CONTINUE;
  return(NoErrors);
}

int VDecompressCallback(SvHandle_t Svh, SvCallbackInfo_t *CB,
                                       SvPictureInfo_t *PictInfo)
{
  int status;
  unsigned dword size;
  SlibInfo_t *Info=(SlibInfo_t *)CB->UserData;
  _SlibDebug(_CALLBACK_, printf("VDecompressCallback()\n") );

  switch (CB->Message)
  {
     case CB_SEQ_END: /* reset presentation timestamps at end-of-sequence */
            _SlibDebug(_CALLBACK_ || _TIMECODE_,
              printf("VDecompressCallback received CB_SEQ_END message\n") );
            Info->VideoPTimeCode=SLIB_TIME_NONE;
            Info->AudioPTimeCode=SLIB_TIME_NONE;
            Info->VideoTimeStamp=SLIB_TIME_NONE;
            Info->AudioTimeStamp=SLIB_TIME_NONE;
            break;
     case CB_END_BUFFERS:
            _SlibDebug(_CALLBACK_,
              printf("VDecompressCallback received CB_END_BUFFER message\n") );
            if (CB->DataType==CB_DATA_COMPRESSED)
            {
              SlibTime_t ptimestamp, timediff;
              slibSetMaxInput(Info, 1500*1024); /* set limit for input data */
              CB->Data = SlibGetBuffer(Info, SLIB_DATA_VIDEO, &size,
                                        &ptimestamp);
              slibSetMaxInput(Info, 0); /* clear limit */
              CB->DataSize = size;
              if (SlibTimeIsValid(Info->AudioPTimeCode))
              {
                timediff=ptimestamp-Info->AudioPTimeCode;
                if (timediff>6000)
                {
                  /* Make sure a NEW audio time is not way out of
                   * sync with video time.
                   * This can happen after an End of Sequence.
                   */
                  /* assign audio time to video time */
                  Info->VideoPTimeCode=SLIB_TIME_NONE;
                  Info->VideoPTimeBase=Info->AudioPTimeBase;
                  ptimestamp=Info->AudioPTimeCode;
                }
              }
              if (SlibTimeIsValid(ptimestamp) &&
                  ptimestamp>Info->VideoPTimeCode)
              {
                SlibTime_t lasttime=Info->VideoPTimeCode;
                Info->VideoPTimeCode=ptimestamp;
                _SlibDebug(_CALLBACK_||_TIMECODE_,
                  printf("VideoPTimeCode=%ld\n", Info->VideoPTimeCode) );
                ptimestamp-=Info->VideoPTimeBase;
                timediff=ptimestamp-Info->VideoTimeStamp;
                if (SlibTimeIsInValid(lasttime) ||
                    SlibTimeIsInValid(Info->VideoTimeStamp))
                {
                  _SlibDebug(_TIMECODE_,
                     printf("Updating VideoTimeStamp none->%ld\n",
                           ptimestamp) );
                  Info->VideoTimeStamp=ptimestamp;
                  Info->AvgVideoTimeDiff=0;
                  Info->VarVideoTimeDiff=0;
                }
                else /* see if times are far off */
                {
                  SlibTime_t lastavg=Info->AvgVideoTimeDiff;
                  Info->AvgVideoTimeDiff=(lastavg*14+timediff)/15;
                  Info->VarVideoTimeDiff=(Info->VarVideoTimeDiff*3+
                        lastavg-Info->AvgVideoTimeDiff)/4;
                  _SlibDebug(_CALLBACK_||_TIMECODE_,
                    printf("Video timediff: Cur=%ld Avg=%ld Var=%ld\n",
                              timediff, Info->AvgVideoTimeDiff,
                                        Info->VarVideoTimeDiff));
                  if (Info->VarVideoTimeDiff==0)
                  {
                    _SlibDebug(_TIMECODE_,
                      printf("Updating VideoTimeStamp %ld->%ld (diff=%ld)\n",
                           Info->VideoTimeStamp, ptimestamp,
                           ptimestamp-Info->VideoTimeStamp) );
                    Info->VideoTimeStamp=ptimestamp;
                    Info->AvgVideoTimeDiff=0;
                  }
                  else if (Info->AvgVideoTimeDiff>=100
                           || Info->AvgVideoTimeDiff<=-100)
                  {
                    /* calculated time and timestamps are too far off */
                    float fps=Info->FramesPerSec;
                    if (Info->VarVideoTimeDiff>1 && fps>=15.5F)
                      fps-=0.25F;  /* playing too fast, slow frame rate */
                    else if (Info->VarVideoTimeDiff<-1 && fps<=59.0F)
                      fps+=0.25F;  /* playing too slow, speed up frame rate */
                    _SlibDebug(_WARN_ || _CALLBACK_||_TIMECODE_,
                        printf("Updating fps from %.4f -> %.4f\n",
                                 Info->FramesPerSec, fps) );
                    Info->FramesPerSec=fps;
                    Info->VideoFrameDuration=slibFrameToTime100(Info, 1);
                    Info->VideoTimeStamp=ptimestamp;
                    Info->AvgVideoTimeDiff=0;
                  }
                }
                Info->VideoFramesProcessed=0; /* reset frames processed */
              }
              if (CB->DataSize>0)
              {
                _SlibDebug(_DUMP_,
                  SlibPin_t *pin=slibGetPin(Info, SLIB_DATA_VIDEO);
                    printf("VDecompressCallback() Adding buffer of length %d\n",
                             CB->DataSize);
                  ScDumpChar(CB->Data, (int)CB->DataSize, (int)pin->Offset-CB->DataSize));
                CB->DataType = CB_DATA_COMPRESSED;
                _SlibDebug(_CALLBACK_,
                  printf("VDecompressCallback() Adding buffer of length %d\n",
                               CB->DataSize) );
                status = SvAddBuffer(Svh, CB);
              }
              else
              {
                _SlibDebug(_WARN_ || _CALLBACK_,
                   printf("VDecompressCallback() got no data\n") );
                CB->Action = CB_ACTION_END;
                return(NoErrors);
              }
            }
            break;
     case CB_RELEASE_BUFFER:
            _SlibDebug(_CALLBACK_,
            printf("VDecompressCallback received CB_RELEASE_BUFFER message\n"));
            if (CB->DataType==CB_DATA_COMPRESSED && CB->Data)
              SlibFreeBuffer(CB->Data);
            break;
     case CB_PROCESSING:
            _SlibDebug(_CALLBACK_,
              printf("VDecompressCallback received CB_PROCESSING message\n") );
            break;
     case CB_CODEC_DONE:
            _SlibDebug(_CALLBACK_,
              printf("VDecompressCallback received CB_CODEC_DONE message\n") );
            break;
  }
  CB->Action = CB_ACTION_CONTINUE;
  return(NoErrors);
}

int ACompressCallback(SaHandle_t Sah, SaCallbackInfo_t *CB, SaInfo_t *SaInfo)
{
  int status;
  SlibInfo_t *Info=(SlibInfo_t *)CB->UserData;
  _SlibDebug(_CALLBACK_, printf("ACompressCallback()\n") );

  CB->Action = CB_ACTION_CONTINUE;
  switch (CB->Message)
  {
     case CB_END_BUFFERS:
            _SlibDebug(_CALLBACK_,
              printf("ACompressCallback received CB_END_BUFFER message\n") );
            if (CB->DataType==CB_DATA_COMPRESSED)
            {
              CB->DataSize=Info->CompBufSize;
              CB->Data=SlibAllocBuffer(CB->DataSize);
              _SlibDebug(_CALLBACK_,
                printf("ACompressCallback() Adding buffer of length %d\n",
                             CB->DataSize) );
              status=SaAddBuffer(Sah, CB);
              _SlibDebug(_WARN_ && status!=NoErrors,
                        printf("SaAddBuffer() %s\n", ScGetErrorStr(status)) );
            }
            break;
     case CB_RELEASE_BUFFER:
            _SlibDebug(_CALLBACK_,
            printf("ACompressCallback received CB_RELEASE_BUFFER message\n"));
            if (CB->DataType==CB_DATA_COMPRESSED && CB->Data && CB->DataUsed)
            {
              SlibPin_t *dstpin=slibGetPin(Info, SLIB_DATA_AUDIO);
              if (dstpin)
              {
                slibAddBufferToPin(dstpin, CB->Data, CB->DataUsed,
                                           Info->AudioPTimeCode);
                Info->AudioPTimeCode=SLIB_TIME_NONE;
                if (!slibCommitBuffers(Info, FALSE))
                  CB->Action = CB_ACTION_END;
              }
            }
            else if (CB->Data)
              SlibFreeBuffer(CB->Data);
            break;
     case CB_FRAME_START:
            _SlibDebug(_CALLBACK_||_TIMECODE_,
                 printf("ACompress CB_FRAME_START: TimeStamp=%ld Frame=%d\n",
                                   CB->TimeStamp, Info->VideoFramesProcessed
                                     ) );
            if (SlibTimeIsInValid(Info->AudioPTimeCode))
            {
              Info->AudioPTimeCode=CB->TimeStamp;
              _SlibDebug(_TIMECODE_,
                 printf("AudioPTimeCode=%ld\n", Info->AudioPTimeCode) );
              _SlibDebug(_WARN_ && (Info->AudioTimeStamp-CB->TimeStamp>400 ||
                                    CB->TimeStamp-Info->AudioTimeStamp>400),
               printf("Bad Audio Time: AudioPTimeCode=%ld AudioTimestamp=%ld\n",
                     Info->AudioPTimeCode, Info->AudioTimeStamp) );
            }
            break;
  }
  return(NoErrors);
}

int ADecompressCallback(SvHandle_t Sah, SaCallbackInfo_t *CB, SaInfo_t *SaInfo)
{
  int status;
  unsigned dword size;
  SlibInfo_t *Info=(SlibInfo_t *)CB->UserData;
  _SlibDebug(_DEBUG_, printf("ADecompressCallback()\n") );

  switch (CB->Message)
  {
     case CB_END_BUFFERS:
            _SlibDebug(_CALLBACK_,
              printf("ADecompressCallback() CB_END_BUFFER\n") );
            if (CB->DataType==CB_DATA_COMPRESSED)
            {
              SlibTime_t ptimestamp, timediff;
              slibSetMaxInput(Info, 2000*1024); /* set limit for input data */
              CB->Data = SlibGetBuffer(Info, SLIB_DATA_AUDIO, &size,
                                                                &ptimestamp);
              slibSetMaxInput(Info, 0); /* clear limit */
              CB->DataSize = size;
              if (SlibTimeIsValid(ptimestamp))
              {
                Info->AudioPTimeCode=ptimestamp;
                _SlibDebug(_CALLBACK_||_TIMECODE_,
                  printf("AudioPTimeCode=%ld\n", Info->AudioPTimeCode) );
                ptimestamp-=Info->AudioPTimeBase;
                timediff=ptimestamp-Info->AudioTimeStamp;
                if (SlibTimeIsInValid(Info->AudioTimeStamp))
                  Info->AudioTimeStamp=ptimestamp;
                else if (timediff<-300 || timediff>300) /* time is far off */
                {
                  _SlibDebug(_WARN_||_TIMECODE_,
                    printf("Updating AudioTimeStamp %ld->%ld (diff=%ld)\n",
                         Info->AudioTimeStamp, ptimestamp,timediff) );
                  Info->AudioTimeStamp=ptimestamp;
                  if (SlibTimeIsValid(Info->VideoTimeStamp))
                  {
                    /* Make sure a NEW audio time is not way out of
                     * sync with video time.
                     * This can happen after an End of Sequence.
                     */
                    timediff=ptimestamp-Info->VideoTimeStamp;
                    if (timediff<-6000)
                    {
                      /* assign audio time to video time */
                      Info->VideoPTimeCode=SLIB_TIME_NONE;
                      Info->VideoPTimeBase=Info->AudioPTimeBase;
                      Info->VideoTimeStamp=ptimestamp;
                    }
                  }
                }
              }
              if (CB->Data)
              {
                if (CB->DataSize>0)
                {
                  CB->DataType = CB_DATA_COMPRESSED;
                  _SlibDebug(_CALLBACK_,
                    printf("ADecompressCallback() Adding buffer of length %d\n",
                               CB->DataSize) );
                  status = SaAddBuffer(Sah, CB);
                }
                else
                  SlibFreeBuffer(CB->Data);
              }
              else
              {
                _SlibDebug(_WARN_ || _CALLBACK_,
                   printf("ADecompressCallback() got no data\n") );
                CB->Action = CB_ACTION_END;
                return(NoErrors);
              }
            }
            break;
     case CB_RELEASE_BUFFER:
            _SlibDebug(_CALLBACK_,
            printf("ADecompressCallback() CB_RELEASE_BUFFER\n"));
            if (CB->DataType==CB_DATA_COMPRESSED && CB->Data)
              SlibFreeBuffer(CB->Data);
            break;
     case CB_PROCESSING:
            _SlibDebug(_CALLBACK_,
              printf("ADecompressCallback() CB_PROCESSING\n") );
            break;
     case CB_CODEC_DONE:
            _SlibDebug(_CALLBACK_,
              printf("ADecompressCallback() CB_CODEC_DONE\n") );
            break;
  }
  CB->Action = CB_ACTION_CONTINUE;
  return(NoErrors);
}

static void slibInitInfo(SlibInfo_t *Info)
{
  _SlibDebug(_DEBUG_, printf("slibInitInfo()\n") );
  Info->Type = SLIB_TYPE_UNKNOWN;
  Info->Mode = SLIB_MODE_NONE;
  Info->Svh = NULL;
  Info->Sah = NULL;
  Info->Sch = NULL;
  Info->NeedAccuracy = FALSE;
  Info->TotalBitRate = 0;
  Info->MuxBitRate = 0;
  Info->SystemTimeStamp = 0;
  /* Audio parameters */
  Info->AudioStreams = 0;
  Info->SamplesPerSec = 0;
  Info->BitsPerSample = 0;
  Info->Channels = 0;
  Info->AudioBitRate = 0;
  Info->AudioMainStream = 0;
  Info->AudioType = SLIB_TYPE_UNKNOWN;
  /* Video parameters */
  Info->VideoStreams = 0;
  Info->Width = 0;
  Info->Height = 0;
  Info->Stride = 0;
  Info->VideoBitRate = 0;
  Info->FramesPerSec = 0.0F;
  Info->ImageSize = 0;
  Info->AudioPID = -1;
  Info->VideoPID = -1;
  Info->VideoMainStream = 0;
  Info->VideoType = SLIB_TYPE_UNKNOWN;
  /* Data Exchange */
  Info->Offset = 0;
  Info->Pins = NULL;
  Info->PinCount = 0;
  Info->IOError = FALSE;
  Info->MaxBytesInput = 0;
  Info->BytesProcessed = 0;
  /* stream dependent stuff */
  Info->VideoLength = 0;
  Info->VideoLengthKnown = FALSE;
  Info->VideoTimeStamp = SLIB_TIME_NONE;
  Info->VideoFrameDuration = 0;
  Info->AudioLength = 0;
  Info->AudioLengthKnown = FALSE;
  Info->AudioTimeStamp = SLIB_TIME_NONE;
  Info->LastAudioTimeStamp = SLIB_TIME_NONE;
  Info->KeySpacing = 0;
  Info->SubKeySpacing = 0;
  Info->VideoPTimeBase = SLIB_TIME_NONE;
  Info->VideoPTimeCode = SLIB_TIME_NONE;
  Info->VideoDTimeCode = SLIB_TIME_NONE;
  Info->LastAudioPTimeCode = SLIB_TIME_NONE;
  Info->LastVideoPTimeCode = SLIB_TIME_NONE;
  Info->LastVideoDTimeCode = SLIB_TIME_NONE;
  Info->AvgVideoTimeDiff = 0;
  Info->VarVideoTimeDiff = 0;
  Info->AudioPTimeBase = SLIB_TIME_NONE;
  Info->AudioPTimeCode = SLIB_TIME_NONE;
  Info->AudioDTimeCode = SLIB_TIME_NONE;
  Info->VideoFramesProcessed=0;
  /* Encoding info */
  Info->HeaderProcessed = FALSE;
  Info->PacketCount = 0;
  Info->BytesSincePack = 0;
  /* Miscellaneous */
  Info->SlibCB = NULL;
  Info->SlibCBUserData = NULL;
  Info->Fd = -1;
  Info->FileSize = 0;
  Info->FileBufSize = 50*1024;
  Info->CompBufSize = 2*1024;
  Info->PacketSize = 512;
  Info->AudioFormat = NULL;
  Info->VideoFormat = NULL;
  Info->CompAudioFormat = NULL;
  Info->CompVideoFormat = NULL;
  Info->CodecVideoFormat = NULL;
  Info->VideoCodecState = SLIB_CODEC_STATE_NONE;
  Info->AudioCodecState = SLIB_CODEC_STATE_NONE;
  Info->Imagebuf = NULL;
  Info->IntImagebuf = NULL;
  Info->IntImageSize = 0;
  Info->CodecImagebuf = NULL;
  Info->CodecImageSize = 0;
  Info->Multibuf = NULL;
  Info->MultibufSize = 0;
  Info->Audiobuf = NULL;
  Info->AudiobufSize = 0;
  Info->AudiobufUsed = 0;
  Info->OverflowSize = 1500*1024;
  Info->VBVbufSize = 0;
  Info->stats = NULL;
  Info->dbg = NULL;
}

/*
** Name:    slibGetDataFormat
** Purpose: Find out the type of some multmedia data.
*/
static SlibType_t slibGetDataFormat(unsigned char *buf, int size,
                                             dword *headerstart,
                                             dword *headersize)
{
  dword i, count;
  unsigned char *bufptr;
  if (headersize)
    *headersize=0;
  if (size<4 || !buf)
    return(SLIB_TYPE_UNKNOWN);
  /*
  ** H261 video stream file
  */
  if ((buf[0] == 0x00) &&
      (buf[1] == 0x01) &&
      (buf[2] & 0xF0)==0x00)
    return(SLIB_TYPE_H261);
  /*
  ** H263 video stream file
  */
  if ((buf[0] == 0x00) &&
      (buf[1] == 0x00) &&
      (buf[2] == 0x80) &&
      (buf[3] & 0xF8)==0x00)
    return(SLIB_TYPE_H263);
  /*
  ** JFIF file (ffd8 = Start-Of-Image marker)
  */
  if (buf[0] == 0xff && buf[1] == 0xd8)
    return(SLIB_TYPE_JFIF);
  /*
  ** QUICKTIME JPEG file (4 ignored bytes, "mdat", ff, d8, ff)
  */
  if ((strncmp(&buf[4], "mdat", 4) == 0 ) &&
      (buf[8]  == 0xff) &&
      (buf[9]  == 0xd8) &&
      (buf[10] == 0xff))
    return(SLIB_TYPE_JPEG_QUICKTIME);
  /*
  ** AVI RIFF file
  */
  if ( strncmp(buf, "RIFF", 4) == 0 )
  {
    if (strncmp(&buf[8], "WAVE",4) == 0)
      return(SLIB_TYPE_PCM_WAVE);
    else if (strncmp(&buf[8], "AVI ",4) == 0)
      return(SLIB_TYPE_AVI);
    else
      return(SLIB_TYPE_RIFF);
  }
  /*
  ** BMP file
  */
  if (buf[0] == 'B' && buf[1]=='M')
    return(SLIB_TYPE_BMP);
  /*
  ** Dolby AC-3 stream
  */
  if ((buf[0]==0x77 && buf[1] == 0x0B) ||  /* may be byte reversed */
      (buf[0]==0x0B && buf[1] == 0x77))
    return(SLIB_TYPE_AC3_AUDIO);

  /*
  ** Sun Raster file
  */
  if ((buf[0]==0x59 && buf[1] == 0xA6) ||  /* may be byte reversed */
      (buf[0]==0x6A && buf[1] == 0x95))
    return(SLIB_TYPE_RASTER);

  /*
  ** SLIB file
  */
  if ((buf[0] == 'S') && (buf[1] == 'L') &&
      (buf[2] == 'I') && (buf[3] == 'B'))
  {
    if ((buf[4] == 'H') && (buf[5] == 'U') &&  /* SLIB Huffman Stream */
        (buf[6] == 'F') && (buf[7] == 'F'))
      return(SLIB_TYPE_SHUFF);
    else
      return(SLIB_TYPE_SLIB);
  }
  /*
  ** MPEG II Transport Stream
  */
  if (buf[0] == MPEG_TSYNC_CODE &&
        (buf[3]&0x30)!=0) /* adaptation field value is not reserved */
    return(SLIB_TYPE_MPEG_TRANSPORT);
  if (buf[0] == MPEG_TSYNC_CODE && buf[1] == 0x1F &&
        buf[2]==0xFF) /* NULL PID */
    return(SLIB_TYPE_MPEG_TRANSPORT);

  /* search for mpeg startcode 000001 */
  bufptr=buf;
  for (i=4, count=size;
          i<count && (bufptr[0]!=0x00 || bufptr[1]!=0x00 || bufptr[2]!=0x01); i++)
    bufptr++;
  count-=i-4;
  if (headerstart)
    *headerstart=i-4;
  /*
  ** MPEG video file
  */
  if (bufptr[0] == 0x00 && bufptr[1] == 0x00 &&
      bufptr[2] == 0x01 && bufptr[3] == 0xB3)
  {
    if (headersize) /* calculate the header size */
    {
      *headersize=12;  /* minimum size is twelve bytes */
      if (count>11 && (bufptr[11]&0x02)) /* load_intra_quantizer_matrixe */
      {
        *headersize+=64;
        if (count>75 && bufptr[64+11]&0x01) /* load_non_intra_quantizer_matrix */
          *headersize+=64;
      }
      else if (count>11 && (bufptr[11]&0x01)) /* load_non_intra_quant_matrix */
        *headersize+=64;
    }
    return(SLIB_TYPE_MPEG1_VIDEO);
  }
  /*
  ** MPEG I Systems file
  */
  if ((bufptr[0] == 0x00) && (bufptr[1] == 0x00) &&
      (bufptr[2] == 0x01) && (bufptr[3] == 0xba) &&
      ((bufptr[4]&0xF0) == 0x20))
    return(SLIB_TYPE_MPEG_SYSTEMS);
  /*
  ** MPEG II Program Stream
  */
  if ((bufptr[0] == 0x00) && (bufptr[1] == 0x00) &&
      (bufptr[2] == 0x01) && (bufptr[3] == 0xba) &&
      ((bufptr[4]&0xC0) == 0x40))
    return(SLIB_TYPE_MPEG_PROGRAM);
  /*
  ** H263 video stream file
  */
  /* search for H.263 picture startcode 000000000000000100000 */
  for (bufptr=buf, i=0, count=size-4; i<count; i++, bufptr++)
  {
    if ((bufptr[0] == 0x00) &&
        (bufptr[1] == 0x00) &&
        (bufptr[2] == 0x80) &&
        (bufptr[3] & 0xF8)==0x00)
      return(i>=12 ? SLIB_TYPE_RTP_H263 : SLIB_TYPE_H263);
  }
  /*
  ** H261 video stream file
  */
  /* search for H.261 picture startcode 00000000000000010000 */
  for (bufptr=buf, i=0, count=size-3; i<count; i++, bufptr++)
  {
    if ((bufptr[0] == 0x00) &&
        (bufptr[1] == 0x01) &&
        (bufptr[2] & 0xF0)==0x00)
      return(i>=12 ? SLIB_TYPE_RTP_H261 : SLIB_TYPE_H261);
  }
  /*
  ** MPEG audio stream file
  */
  if (buf[0]==0xFF && (buf[1] & 0xF0)==0xF0)
    return(SLIB_TYPE_MPEG1_AUDIO);

#ifdef G723_SUPPORT
  //Detect the RATEFLAG and VADFLAG in each frame in this
  //buffer.
  {
     int i,iFrameSize,iNoOfFrames;
     BOOL bRateFlag; //0 for High rate(6.3K 24bit), 1 for low rate(5.3K,20bit)
     BOOL bVADflag;  // 0 for Active speech  1 for Non-speech
     BOOL bTypeG723 = TRUE; //Initialized to say that it's a g723 media stream

     if(buf[0] & 0x1)
     {
        bRateFlag = TRUE; //Low rate 5.3K
        iFrameSize = 20;
     }
     else
     {
        bRateFlag = FALSE; //High Rate 6.3K
        iFrameSize = 24;
     }
     if(buf[0] & 0x2)
        bVADflag =TRUE;    //Non-Speech
     else
        bVADflag = FALSE;  //Active-Speech

     iNoOfFrames = size/iFrameSize;
     if (iNoOfFrames>15) iNoOfFrames=15; /* just check first 15 frames */
     //Leave the first frame.The first frame is used to extract
     // the above information.Check for this info in the remaining
     // frames.If it exists in all frames,the audio is G723 ,otherwise
     // audio type is Unknown.
     for(i =1; i < iNoOfFrames;i++)
     {
       //Search for RateFlag and bVADflag for each frame
       if(((buf[i*iFrameSize] & 0x1) == bRateFlag) &&
          ((buf[i*iFrameSize] & 0x2) == bVADflag))
         continue;
       //type is Unknown ,Set the flag to false and
       //break from the for loop
       bTypeG723 = FALSE;
       break;
     }
     if(bTypeG723)
       return(SLIB_TYPE_G723);
  }
#endif /* G723_SUPPORT */
  _SlibDebug(_WARN_, printf("slibGetDataFormat() Unknown file format\n") );
  return(SLIB_TYPE_UNKNOWN);
}

SlibStatus_t SlibQueryData(void *databuf, unsigned dword databufsize,
                              SlibQueryInfo_t *qinfo)
{
  SlibInfo_t *Info=NULL;
  SlibStatus_t status;
  if (!databuf)
    return(SlibErrorBadArgument);
  if (databufsize==0)
    return(SlibErrorBufSize);
  qinfo->Bitrate=0;
  qinfo->VideoStreams=0;
  qinfo->Width=0;
  qinfo->Height=0;
  qinfo->VideoBitrate=0;
  qinfo->FramesPerSec=0.0F;
  qinfo->VideoLength=0;
  qinfo->AudioStreams=0;
  qinfo->SamplesPerSec=0;
  qinfo->BitsPerSample=0;
  qinfo->Channels=0;
  qinfo->AudioBitrate=0;
  qinfo->AudioLength=0;
  qinfo->Type = slibGetDataFormat(databuf, databufsize,
                                  &qinfo->HeaderStart, &qinfo->HeaderSize);
  if (qinfo->Type!=SLIB_TYPE_UNKNOWN)
  {
    if ((Info = (SlibInfo_t *)ScAlloc(sizeof(SlibInfo_t))) == NULL)
      return(SlibErrorMemory);
    slibInitInfo(Info);
    Info->Mode = SLIB_MODE_DECOMPRESS;
    Info->Type = qinfo->Type;
    slibAddPin(Info, SLIB_DATA_COMPRESSED, "Compressed");
    status=slibManageUserBuffer(NULL, databuf, databufsize, NULL);
    if (status==SlibErrorNone)
      status=slibAddBufferToPin(slibGetPin(Info, SLIB_DATA_COMPRESSED),
                                       databuf, databufsize, SLIB_TIME_NONE);
    if (status!=SlibErrorNone)
    {
      SlibClose((SlibHandle_t)Info);
      return(status);
    }
    slibAddPin(Info, SLIB_DATA_AUDIO, "Audio");
    slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
    SlibUpdateAudioInfo(Info);
    SlibUpdateVideoInfo(Info);
    if (Info->TotalBitRate==0)
      qinfo->Bitrate=Info->AudioBitRate+
                     ((Info->VideoBitRate>100000000)?0:Info->VideoBitRate);
    else
      qinfo->Bitrate=Info->TotalBitRate;
    qinfo->VideoStreams=Info->VideoStreams;
    qinfo->Width=Info->Width;
    qinfo->Height=Info->Height;
    qinfo->VideoBitrate=Info->VideoBitRate;
    qinfo->FramesPerSec=Info->FramesPerSec;
    qinfo->VideoLength=Info->VideoLength;
    qinfo->AudioStreams=Info->AudioStreams;
    qinfo->SamplesPerSec=Info->SamplesPerSec;
    qinfo->BitsPerSample=Info->BitsPerSample;
    qinfo->Channels=Info->Channels;
    qinfo->AudioBitrate=Info->AudioBitRate;
    qinfo->AudioLength=Info->AudioLength;
    SlibClose((SlibHandle_t)Info);
    return(SlibErrorNone);
  }
  return(SlibErrorUnsupportedFormat);
}
/************************** The Main Slib API ***********************/

SlibStatus_t SlibOpen(SlibHandle_t *handle, SlibMode_t smode,
                   SlibType_t *stype, SlibMessage_t (*slibCB)(SlibHandle_t,
                         SlibMessage_t, SlibCBParam1_t, SlibCBParam2_t, void *),
                         void *cbuserdata)
{
  SlibInfo_t *Info=NULL;
  SlibStatus_t status;
  _SlibDebug(_VERBOSE_,printf("SlibOpen()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  *handle = NULL;
  if (!stype)
    return(SlibErrorBadArgument);
  if (!slibCB)
    return(SlibErrorBadArgument);
  if (smode == SLIB_MODE_COMPRESS)
  {
    if (SlibFindEnumEntry(_listCompressTypes, *stype)==NULL)
      return(SlibErrorUnsupportedFormat);
  }
  if ((Info = (SlibInfo_t *)ScAlloc(sizeof(SlibInfo_t))) == NULL)
     return(SlibErrorMemory);
  slibInitInfo(Info);
  slibAddPin(Info, SLIB_DATA_COMPRESSED, "Compressed");
  Info->SlibCB = slibCB;
  Info->SlibCBUserData = cbuserdata;
  *handle=(SlibHandle_t)Info;
  if ((status=slibOpen(handle, smode, stype))!=SlibErrorNone)
    *handle = NULL;
  return(status);
}

SlibStatus_t SlibOpenSync(SlibHandle_t *handle, SlibMode_t smode,
                          SlibType_t *stype, void *buffer, unsigned dword bufsize)
{
  SlibInfo_t *Info=NULL;
  SlibStatus_t status;
  _SlibDebug(_VERBOSE_,printf("SlibOpenSync()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  *handle = NULL;
  if (!stype)
    return(SlibErrorBadArgument);
  if (smode == SLIB_MODE_COMPRESS)
  {
    if (SlibFindEnumEntry(_listCompressTypes, *stype)==NULL)
      return(SlibErrorUnsupportedFormat);
  }
  else if (smode == SLIB_MODE_DECOMPRESS)
  {
    /* for decompression we need the first buffer to open the codecs */
    if (!buffer || bufsize==0)
      return(SlibErrorBadArgument);
  }
  if ((Info = (SlibInfo_t *)ScAlloc(sizeof(SlibInfo_t))) == NULL)
     return(SlibErrorMemory);
  slibInitInfo(Info);
  Info->Mode=smode;
  slibAddPin(Info, SLIB_DATA_COMPRESSED, "Compressed");
  if (smode == SLIB_MODE_DECOMPRESS)
  {
    status=SlibAddBuffer((SlibHandle_t *)Info, SLIB_DATA_COMPRESSED, buffer, bufsize);
    if (status!=SlibErrorNone)
      return(status);
  }
  *handle=(SlibHandle_t)Info;
  if ((status=slibOpen(handle, smode, stype))!=SlibErrorNone)
    *handle = NULL;
  return(status);
}

SlibStatus_t SlibOpenFile(SlibHandle_t *handle, SlibMode_t smode,
                          SlibType_t *stype, char *filename)
{
  SlibInfo_t *Info=NULL;
  SlibStatus_t status;
  _SlibDebug(_VERBOSE_,printf("SlibOpenFile()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  *handle = NULL;
  if (!stype)
    return(SlibErrorBadArgument);
  if (!filename)
    return(SlibErrorBadArgument);
  if (smode == SLIB_MODE_COMPRESS)
  {
    if (SlibFindEnumEntry(_listCompressTypes, *stype)==NULL)
      return(SlibErrorUnsupportedFormat);
    if ((Info = (SlibInfo_t *) ScAlloc(sizeof(SlibInfo_t))) == NULL)
       return(SlibErrorMemory);
    slibInitInfo(Info);
    Info->Fd = ScFileOpenForWriting(filename, TRUE);
    if (Info->Fd<0)
    {
      ScFree(Info);
      return(SlibErrorWriting);
    }
    *handle=(SlibHandle_t)Info;
    if ((status=slibOpen(handle, smode, stype))!=SlibErrorNone)
      *handle = NULL;
    return(status);
  }
  else if (smode == SLIB_MODE_DECOMPRESS)
  {
    if ((Info = (SlibInfo_t *)ScAlloc(sizeof(SlibInfo_t))) == NULL)
       return(SlibErrorMemory);
    slibInitInfo(Info);
    Info->Fd = ScFileOpenForReading(filename);
    if (Info->Fd<0)
    {
      ScFree(Info);
      return(SlibErrorReading);
    }
    ScFileSize(filename, &Info->FileSize);
    *handle=(SlibHandle_t)Info;
    if ((status=slibOpen(handle, smode, stype))!=SlibErrorNone)
      *handle = NULL;
    return(status);
  }
  else
    return(SlibErrorBadMode);
}

static SlibStatus_t slibOpen(SlibHandle_t *handle, SlibMode_t smode,
                             SlibType_t *stype)
{
  SlibInfo_t *Info=(SlibInfo_t *)*handle;
  unsigned char *buf;
  unsigned dword size;
  _SlibDebug(_VERBOSE_,printf("SlibOpenFile()\n") );
  if (!Info)
    return(SlibErrorMemory);
  if (!stype)
    return(SlibErrorBadArgument);
  if (Info->SlibCB)
  {
    SlibMessage_t result;
    _SlibDebug(_VERBOSE_,
      printf("slibOpen() SlibCB(SLIB_MSG_OPEN)\n") );
    result=(*(Info->SlibCB))((SlibHandle_t)Info,
                      SLIB_MSG_OPEN, (SlibCBParam1_t)0,
                    (SlibCBParam2_t)0, (void *)Info->SlibCBUserData);
  }
  if (smode == SLIB_MODE_COMPRESS)
  {
    Info->Mode = smode;
    Info->Type = *stype;
    SlibUpdateAudioInfo(Info);
    SlibUpdateVideoInfo(Info);
    switch (Info->Type)
    {
#ifdef MPEG_SUPPORT
      case SLIB_TYPE_MPEG_SYSTEMS:
      case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
      case SLIB_TYPE_MPEG1_VIDEO:
             Info->VideoStreams = 1;
             if (SvOpenCodec (Info->Type==SLIB_TYPE_MPEG_SYSTEMS_MPEG2 ?
                               SV_MPEG2_ENCODE : SV_MPEG_ENCODE,
                               &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
             if (Info->Type==SLIB_TYPE_MPEG1_VIDEO)
               break;
      case SLIB_TYPE_MPEG1_AUDIO:
             Info->AudioStreams = 1;
             if (SaOpenCodec (SA_MPEG_ENCODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_AUDIO, "Audio");
             break;
      case SLIB_TYPE_MPEG2_VIDEO:
             Info->VideoStreams = 1;
             if (SvOpenCodec (SV_MPEG2_ENCODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
             break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SLIB_TYPE_H261:
             Info->VideoStreams = 1;
             if (SvOpenCodec (SV_H261_ENCODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
             break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
      case SLIB_TYPE_H263:
             Info->VideoStreams = 1;
             if (SvOpenCodec (SV_H263_ENCODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
             break;
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
      case SLIB_TYPE_SHUFF:
             Info->VideoStreams = 1;
             if (SvOpenCodec (SV_HUFF_ENCODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
             break;
#endif /* HUFF_SUPPORT */
#ifdef G723_SUPPORT
      case SLIB_TYPE_G723:
             Info->AudioStreams = 1;
             if (SaOpenCodec (SA_G723_ENCODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_AUDIO, "Audio");
             break;

#endif /*G723_SUPPORT*/
      default:
             return(SlibErrorUnsupportedFormat);
    }
    slibAddPin(Info, SLIB_DATA_COMPRESSED, "Compressed");
  }
  else if (smode == SLIB_MODE_DECOMPRESS)
  {
    Info->Mode = smode;
    /*
    ** Determine the input data type
    */
    if (slibLoadPin(Info, SLIB_DATA_COMPRESSED)==NULL)
      return(SlibErrorReading);
    if ((buf=SlibPeekBuffer(Info, SLIB_DATA_COMPRESSED, &size, NULL))==NULL
             || size<=0)
    {
      /* couldn't get any compressed data */
      SlibClose((SlibHandle_t)Info);
      return(SlibErrorReading);
    }
    Info->Type = slibGetDataFormat(buf, size, NULL, NULL);
    /* if we can't determine the type, use stype as the type */
    if (Info->Type==SLIB_TYPE_UNKNOWN && stype)
      Info->Type=*stype;
    if (SlibFindEnumEntry(_listDecompressTypes, Info->Type)==NULL)
    {
      SlibClose((SlibHandle_t)Info);
      return(SlibErrorUnsupportedFormat);
    }

    slibAddPin(Info, SLIB_DATA_AUDIO, "Audio");
    slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
    if (SlibTypeIsMPEGMux(Info->Type))
    {
      /* need to select main streams for multiplexed streams */
      Info->AudioMainStream=MPEG_AUDIO_STREAM_START;
      Info->VideoMainStream=MPEG_VIDEO_STREAM_START;
      /* private data may be needed - i.e. AC3 */
      slibAddPin(Info, SLIB_DATA_PRIVATE, "Private");
    }
    SlibUpdateAudioInfo(Info);
    SlibUpdateVideoInfo(Info);
    if (Info->AudioStreams<=0)
      slibRemovePin(Info, SLIB_DATA_AUDIO);
    if (Info->VideoStreams<=0)
      slibRemovePin(Info, SLIB_DATA_VIDEO);

    slibRemovePin(Info, SLIB_DATA_PRIVATE); /* only used in init */
    if (Info->AudioBitRate && Info->VideoBitRate)
    {
      if (!Info->VideoLengthKnown)
      {
        qword ms=((qword)Info->FileSize*80L)/
                   (Info->AudioBitRate+Info->VideoBitRate);
        ms = (ms*75)/80; /* adjust for systems data */
        Info->AudioLength = Info->VideoLength = (SlibTime_t)ms*100;
        _SlibDebug(_SEEK_||_VERBOSE_,
            ScDebugPrintf(Info->dbg,"slibOpen() FileSize=%ld VideoLength=%ld\n",
                    Info->FileSize, Info->VideoLength) );
      }
      else if (Info->VideoLengthKnown && Info->FramesPerSec)
        Info->AudioLength = Info->VideoLength;
    }
    if (Info->TotalBitRate==0)
      Info->TotalBitRate=Info->AudioBitRate +
                     ((Info->VideoBitRate>100000000)?0:Info->VideoBitRate);
    _SlibDebug(_SEEK_||_VERBOSE_,
               ScDebugPrintf(Info->dbg,"AudioLength=%ld VideoLength=%ld %s\n",
                   Info->AudioLength, Info->VideoLength,
                   Info->VideoLengthKnown?"(known)":"") );

    if (Info->AudioType==SLIB_TYPE_UNKNOWN &&
        Info->VideoType==SLIB_TYPE_UNKNOWN)
      return(SlibErrorUnsupportedFormat);
    switch (Info->AudioType)
    {
      case SLIB_TYPE_UNKNOWN:
             break;
#ifdef MPEG_SUPPORT
      case SLIB_TYPE_MPEG1_AUDIO:
             if (SaOpenCodec (SA_MPEG_DECODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             break;
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
             if (SaOpenCodec (SA_GSM_DECODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             break;
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
	  case SLIB_TYPE_AC3_AUDIO:
             if (SaOpenCodec (SA_AC3_DECODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             break;
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
      case SLIB_TYPE_G723:
             if (SaOpenCodec (SA_G723_DECODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             break;
#endif /* G723_SUPPORT */
    } /* AudioType */
    switch (Info->VideoType)
    {
      case SLIB_TYPE_UNKNOWN:
             break;
#ifdef MPEG_SUPPORT
      case SLIB_TYPE_MPEG1_VIDEO:
             if (SvOpenCodec (SV_MPEG_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
      case SLIB_TYPE_MPEG2_VIDEO:
             if (SvOpenCodec (SV_MPEG2_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SLIB_TYPE_H261:
             if (SvOpenCodec (SV_H261_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
      case SLIB_TYPE_H263:
             if (SvOpenCodec (SV_H263_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
      case SLIB_TYPE_SHUFF:
             if (SvOpenCodec (SV_HUFF_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
#endif /* HUFF_SUPPORT */
#ifdef JPEG_SUPPORT
      case SLIB_TYPE_JPEG:
      case SLIB_TYPE_MJPG:
             if (SvOpenCodec (SV_JPEG_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
#endif /* JPEG_SUPPORT */
    } /* VideoType */
  }
  else
    return(SlibErrorBadMode);
  *stype = Info->Type;
  return(SlibErrorNone);
}

SlibStatus_t SlibAddBuffer(SlibHandle_t handle, SlibDataType_t dtype,
                                void *buffer, unsigned dword bufsize)
{
  SvStatus_t status;
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibPin_t *dstpin;
  if (!handle)
    return(SlibErrorBadHandle);
  dstpin = slibGetPin(Info, dtype);
  if (dstpin==NULL || buffer==NULL)
    return(SlibErrorBadArgument);
  if (Info->SlibCB)
  {
    status=slibManageUserBuffer(Info, buffer, bufsize, NULL);
    if (status!=SlibErrorNone)
      return(status);
    status=slibAddBufferToPin(dstpin, buffer, bufsize, SLIB_TIME_NONE);
  }
  else if (!SlibValidBuffer(buffer))
  {
    /* we need to create a SLIB allocated buffer to copy the
     * output to and then add to the compressed data pin
     */
    unsigned char *bufptr=SlibAllocBuffer(bufsize);
    if (!bufptr)
      return(SlibErrorMemory);
    memcpy(bufptr, buffer, bufsize);
    status=slibAddBufferToPin(dstpin, bufptr, bufsize, SLIB_TIME_NONE);
  }
  else
    status=slibAddBufferToPin(dstpin, buffer, bufsize, SLIB_TIME_NONE);
  if (Info->Mode==SLIB_MODE_DECOMPRESS)
  {
    ScBitstream_t *BS;
    Info->IOError=FALSE;
    /* reset end-of-input flags in bitstream objects */
    if (Info->Svh)
    {
      BS=SvGetDataSource(Info->Svh);
      if (BS && BS->EOI) ScBSReset(BS);
    }
    if (Info->Sah)
    {
      BS=SaGetDataSource(Info->Sah);
      if (BS && BS->EOI) ScBSReset(BS);
    }
  }
  return(status);
}

SlibStatus_t SlibAddBufferEx(SlibHandle_t handle, SlibDataType_t dtype,
                                void *buffer, unsigned dword bufsize,
                                void *userdata)
{
  SvStatus_t status;
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibPin_t *dstpin;
  if (!handle)
    return(SlibErrorBadHandle);
  dstpin = slibGetPin(Info, dtype);
  if (dstpin==NULL || buffer==NULL)
    return(SlibErrorBadArgument);
  status=slibManageUserBuffer(Info, buffer, bufsize, userdata);
  if (status!=SlibErrorNone)
    return(status);
  status=slibAddBufferToPin(dstpin, buffer, bufsize, SLIB_TIME_NONE);
  return(status);
}

SlibStatus_t slibStartVideo(SlibInfo_t *Info, SlibBoolean_t fillbuf)
{
  SvStatus_t status=SvErrorNone;
  _SlibDebug(_VERBOSE_,printf("slibStartVideo()\n") );
  if (Info->VideoCodecState==SLIB_CODEC_STATE_NONE ||
      Info->VideoCodecState==SLIB_CODEC_STATE_BEGUN)
  {
    _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"slibStartVideo(filebuf=%d) %s\n",
      fillbuf,Info->VideoCodecState==SLIB_CODEC_STATE_NONE ? "NONE" : "BEGUN") );
    return(SlibErrorNone);
  }
  if (Info->VideoCodecState==SLIB_CODEC_STATE_OPEN)
  {
    _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"slibStartVideo(filebuf=%d) OPEN\n",
                                                      fillbuf));
    if (Info->Mode==SLIB_MODE_DECOMPRESS)
    {
      if (Info->Type==SLIB_TYPE_YUV_AVI)
      {
        Info->VideoCodecState=SLIB_CODEC_STATE_BEGUN;
        _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"VideoCodecState=BEGUN\n"));
      }
      else if (Info->Svh)
      {
        _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"SvRegisterCallback()\n") );
        status = SvRegisterCallback(Info->Svh, VDecompressCallback, (void *)Info);
        /* if codec is not bitstreaming, don't use callbacks */
        if (status==SlibErrorNone && SvGetDataSource(Info->Svh)==NULL)
        {
          _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"SvRegisterCallback(NULL)\n") );
          status = SvRegisterCallback(Info->Svh, NULL, NULL);
        }
        _SlibDebug(_WARN_ && status!=SvErrorNone,
                           ScDebugPrintf(Info->dbg,"SvRegisterCallback() %s\n",
                             ScGetErrorStr(status)) );
        Info->VideoCodecState=SLIB_CODEC_STATE_INITED;
        _SlibDebug(_DEBUG_,printf("VideoCodecState=INITED\n"));
      }
    }
    else if (Info->Mode==SLIB_MODE_COMPRESS)
    {
      if (Info->TotalBitRate==0)
      {
#ifdef MPEG_SUPPORT
        if (Info->Type==SLIB_TYPE_MPEG_SYSTEMS || /* default to 1XCDROM rate */
            Info->Type==SLIB_TYPE_MPEG_SYSTEMS_MPEG2)
          SlibSetParamInt((SlibHandle_t)Info, SLIB_STREAM_ALL,
                          SLIB_PARAM_BITRATE, 44100*16*2);
#endif
        slibValidateBitrates(Info);  /* update bitrates */
      }
      if (Info->Svh)
      {
        status = SvRegisterCallback(Info->Svh, VCompressCallback, (void *)Info);
        _SlibDebug(_WARN_ && status!=SvErrorNone,
                      ScDebugPrintf(Info->dbg,"SvRegisterCallback() %s\n",
                           ScGetErrorStr(status)) );
        /* if codec is not bitstreaming, don't use callbacks */
        if (status==SlibErrorNone && SvGetDataDestination(Info->Svh)==NULL)
          status = SvRegisterCallback(Info->Svh, NULL, NULL);
        Info->VideoCodecState=SLIB_CODEC_STATE_INITED;
        _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"VideoCodecState=BEGUN\n"));
      }
    }
  }
  if (Info->VideoCodecState==SLIB_CODEC_STATE_INITED ||
      Info->VideoCodecState==SLIB_CODEC_STATE_REPOSITIONING)
  {
    _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,
           "slibStartVideo(fillbuf=%d) INITED || REPOSITIONING\n",fillbuf));
    if (Info->Mode==SLIB_MODE_DECOMPRESS)
    {
      if (Info->Type==SLIB_TYPE_YUV_AVI)
      {
        if (Info->CompVideoFormat->biCompression !=
             Info->VideoFormat->biCompression &&
             Info->Multibuf==NULL)
        {
          Info->MultibufSize=Info->ImageSize;
          Info->Multibuf = SlibAllocSharedBuffer(Info->MultibufSize, NULL);
        }
      }
      else if (Info->Svh)
      {
        int mbufsize;
        if (1) /* fillbuf && Info->CodecVideoFormat) */
        {
          Info->CodecVideoFormat->biCompression=
            SlibGetParamInt((SlibHandle_t)Info, SLIB_STREAM_MAINVIDEO,
                                       SLIB_PARAM_NATIVEVIDEOFORMAT);
          if (Info->CodecVideoFormat->biCompression==0)
            Info->CodecVideoFormat->biCompression=
                       Info->VideoFormat->biCompression;
        }
        else
        {
          Info->CodecVideoFormat->biCompression=
                       Info->VideoFormat->biCompression;
          Info->CodecVideoFormat->biBitCount=
                       Info->VideoFormat->biBitCount;
        }
        slibValidateVideoParams(Info);
        _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,
                    "SvDecompressBegin(%c%c%c%c/%d bits,%c%c%c%c/%d bits)\n",
                     (Info->CompVideoFormat->biCompression)&0xFF,
                     (Info->CompVideoFormat->biCompression>>8)&0xFF,
                     (Info->CompVideoFormat->biCompression>>16)&0xFF,
                     (Info->CompVideoFormat->biCompression>>24)&0xFF,
                      Info->CompVideoFormat->biBitCount,
                     (Info->CodecVideoFormat->biCompression)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>8)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>16)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>24)&0xFF,
                      Info->CodecVideoFormat->biBitCount) );
        status=SvDecompressBegin(Info->Svh, Info->CompVideoFormat,
                          Info->CodecVideoFormat);
        if (status==SvErrorNone)
        {
          Info->KeySpacing=(int)SvGetParamInt(Info->Svh, SV_PARAM_KEYSPACING);
          Info->SubKeySpacing=(int)SvGetParamInt(Info->Svh,
                                                        SV_PARAM_SUBKEYSPACING);
          Info->VideoCodecState=SLIB_CODEC_STATE_BEGUN;
          Info->HeaderProcessed=TRUE; /* we must have processed header info */
          _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"VideoCodecState=BEGUN\n"));
        }
        else if (status==SvErrorEndBitstream)
          return(SlibErrorNoBeginning);
        else
        {
          _SlibDebug(_WARN_, ScDebugPrintf(Info->dbg,"SvDecompressBegin() %s\n",
                                ScGetErrorStr(status)) );
          return(SlibErrorUnsupportedFormat);
        }
        _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"SvGetDecompressSize\n") );
        SvGetDecompressSize(Info->Svh, &mbufsize);
        if (Info->Multibuf==NULL || Info->MultibufSize<mbufsize)
        {
          if (Info->Multibuf) SlibFreeBuffer(Info->Multibuf);
          Info->MultibufSize=mbufsize;
          Info->Multibuf = SlibAllocSharedBuffer(Info->MultibufSize, NULL);
        }
      }
    }
    else if (Info->Mode==SLIB_MODE_COMPRESS && Info->Svh)
    {
      status=SvCompressBegin(Info->Svh, Info->CodecVideoFormat,
                             Info->CompVideoFormat);
      if (status==SvErrorNone)
      {
        Info->KeySpacing=(int)SvGetParamInt(Info->Svh, SV_PARAM_KEYSPACING);
        Info->SubKeySpacing=(int)SvGetParamInt(Info->Svh,
                                                        SV_PARAM_SUBKEYSPACING);
        Info->VideoCodecState=SLIB_CODEC_STATE_BEGUN;
        _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"VideoCodecState=BEGUN\n"));
      }
      else
      {
        _SlibDebug(_WARN_, ScDebugPrintf(Info->dbg,"SvCompressBegin() %s\n",
                                 ScGetErrorStr(status)) );
        return(SlibErrorUnsupportedFormat);
      }
    }
  }
  if (Info->VideoCodecState==SLIB_CODEC_STATE_BEGUN)
    return(SlibErrorNone);
  else
    return(SlibErrorInit);
}

static SlibStatus_t slibStartAudio(SlibInfo_t *Info)
{
  SvStatus_t status=SvErrorNone;
  _SlibDebug(_VERBOSE_,printf("slibStartAudio()\n") );
  if (Info->AudioCodecState==SLIB_CODEC_STATE_NONE ||
      Info->AudioCodecState==SLIB_CODEC_STATE_BEGUN)
  {
    _SlibDebug(_DEBUG_,printf("slibStartAudio() %s\n",
      Info->AudioCodecState==SLIB_CODEC_STATE_NONE ? "NONE" : "BEGUN") );
    return(SlibErrorNone);
  }
  if (Info->AudioCodecState==SLIB_CODEC_STATE_OPEN)
  {
    _SlibDebug(_DEBUG_,printf("slibStartAudio() OPEN\n"));
    if (Info->Sah)
    {
      if (Info->Mode==SLIB_MODE_DECOMPRESS)
      {
        status = SaRegisterCallback(Info->Sah, ADecompressCallback, (void *)Info);
        if (status!=SaErrorNone)
        {
          _SlibDebug(_WARN_, printf("SaRegisterCallback() ",
                         ScGetErrorStr(status)) );
          return(SlibErrorInternal);
        }
        status = SaSetDataSource(Info->Sah, SA_USE_BUFFER_QUEUE, 0, (void *)Info, 0);
        _SlibDebug(_WARN_ && status!=SaErrorNone,
                       printf("SaSetDataSource() ", ScGetErrorStr(status)) );
        Info->AudioCodecState=SLIB_CODEC_STATE_INITED;
        _SlibDebug(_DEBUG_,printf("AudioCodecState=INITED\n"));
      }
      else if (Info->Mode==SLIB_MODE_COMPRESS)
      {
        if (Info->TotalBitRate==0)
        {
#ifdef MPEG_SUPPORT
          /* default to 1X CDROM rate */
          if (Info->Type==SLIB_TYPE_MPEG_SYSTEMS ||
              Info->Type==SLIB_TYPE_MPEG_SYSTEMS_MPEG2)
            SlibSetParamInt((SlibHandle_t)Info, SLIB_STREAM_ALL,
                          SLIB_PARAM_BITRATE, 44100*16*2);
#endif
          slibValidateBitrates(Info);  /* update bitrates */
        }
        status = SaRegisterCallback(Info->Sah, ACompressCallback, (void *)Info);
        _SlibDebug(_WARN_ && status!=SaErrorNone,
                  printf("SaRegisterCallback() %s\n", ScGetErrorStr(status)) );
        status = SaSetDataDestination(Info->Sah, SA_USE_BUFFER_QUEUE, 0,
                                      (void *)Info, 0);
        _SlibDebug(_WARN_ && status!=SaErrorNone,
                        printf("SaSetDataDestination() %s\n",
                           ScGetErrorStr(status)) );
        Info->AudioCodecState=SLIB_CODEC_STATE_INITED;
        _SlibDebug(_DEBUG_,printf("AudioCodecState=INITED\n"));
      }
    }
  }
  if (Info->AudioCodecState==SLIB_CODEC_STATE_INITED ||
      Info->AudioCodecState==SLIB_CODEC_STATE_REPOSITIONING)
  {
    _SlibDebug(_DEBUG_,printf("slibStartAudio() INITED || REPOSITIONING\n"));
    if (Info->Sah)
    {
      if (Info->Mode==SLIB_MODE_DECOMPRESS)
      {
        Info->AudiobufUsed=0;
        /* don't want codec to search through to much data for start */
        status=SaDecompressBegin(Info->Sah, Info->CompAudioFormat,
                                 Info->AudioFormat);
        if (status==SaErrorNone)
        {
          Info->AudioCodecState=SLIB_CODEC_STATE_BEGUN;
          _SlibDebug(_DEBUG_,printf("AudioCodecState=BEGUN\n"));
        }
        else if (status==SlibErrorNoBeginning)
          return(SlibErrorEndOfStream);
        else
        {
          _SlibDebug(_WARN_, printf("SaDecompressBegin() %s\n",
                               ScGetErrorStr(status)) );
          return(SlibErrorUnsupportedFormat);
        }
      }
      else if (Info->Mode==SLIB_MODE_COMPRESS)
      {
        status=SaCompressBegin(Info->Sah, Info->AudioFormat,
                          Info->CompAudioFormat);
        if (status==SvErrorNone)
        {
          Info->AudioCodecState=SLIB_CODEC_STATE_BEGUN;
          _SlibDebug(_DEBUG_,printf("AudioCodecState=BEGUN\n"));
        }
        else
        {
          _SlibDebug(_WARN_, printf("SaCompressBegin() %s\n",
                               ScGetErrorStr(status)) );
          return(SlibErrorUnsupportedFormat);
        }
      }
    }
  }
  return(SlibErrorNone);
}


SlibStatus_t SlibRegisterVideoBuffer(SlibHandle_t handle,
                                void *buffer, unsigned dword bufsize)
{
  SvStatus_t status;
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  dword mbufsize;
  if (!handle)
    return(SlibErrorBadHandle);
  if (Info->Multibuf) SlibFreeBuffer(Info->Multibuf);
  Info->MultibufSize=bufsize;
  Info->Multibuf = buffer;
  status=slibManageUserBuffer(Info, buffer, bufsize, NULL);
  if (Info->Svh)
  {
    SvGetDecompressSize(Info->Svh, &mbufsize);
    if (bufsize<(unsigned dword)mbufsize)
      return(SlibErrorBufSize);
  }
  return(status);
}

SlibStatus_t SlibReadData(SlibHandle_t handle, SlibStream_t stream,
                          void **databuf, unsigned dword *databufsize,
                          SlibStream_t *readstream)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  int pinid;
  SlibPin_t *pin;
  SlibTime_t ptimestamp;
  _SlibDebug(_VERBOSE_, printf("SlibReadDATA()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  if (!databuf) /* we're querying to find out how much data is queued */
  {
    if (!databufsize)
      return(SlibErrorBadArgument);
    if (Info->Mode==SLIB_MODE_COMPRESS)
      pinid=SLIB_DATA_COMPRESSED;
    else if (stream==SLIB_STREAM_MAINVIDEO)
      pinid=SLIB_DATA_VIDEO;
    else if (stream==SLIB_STREAM_MAINAUDIO)
      pinid=SLIB_DATA_AUDIO;
    else
    {
      *databufsize=(unsigned dword)slibDataOnPins(Info); /* get amount of data on all pins */
      return(SlibErrorNone);
    }
    *databufsize=(unsigned dword)slibDataOnPin(Info, SLIB_DATA_COMPRESSED);
    return(SlibErrorNone);
  }
  if (Info->Mode==SLIB_MODE_COMPRESS)
  {
    pinid=SLIB_DATA_COMPRESSED;
    stream=SLIB_STREAM_ALL;
    /* flush out all compressed data */
    if (Info->Sah)
      ScBSFlush(SaGetDataDestination(Info->Sah));
    if (Info->Svh)
      ScBSFlush(SvGetDataDestination(Info->Svh));
  }
  else /* SLIB_MODE_DECOMPRESS */
  {
    if (stream==SLIB_STREAM_ALL && (Info->AudioStreams || Info->VideoStreams))
    {
      if (Info->AudioStreams==0) /* there's only video */
        stream=SLIB_STREAM_MAINVIDEO;
      else if (Info->VideoStreams==0) /* there's only audio */
        stream=SLIB_STREAM_MAINAUDIO;
      else if (slibDataOnPin(Info, SLIB_DATA_AUDIO)>
               slibDataOnPin(Info, SLIB_DATA_VIDEO)) /* more audio than video */
        stream=SLIB_STREAM_MAINAUDIO;
      else
        stream=SLIB_STREAM_MAINVIDEO;
    }
    switch (stream) /* translate stream to pin */
    {
      case SLIB_STREAM_MAINVIDEO:
          pinid=SLIB_DATA_VIDEO;
          break;
      case SLIB_STREAM_MAINAUDIO:
          pinid=SLIB_DATA_AUDIO;
          break;
      default:
          return(SlibErrorBadStream);
    }
  }
  if (readstream)
    *readstream=stream;
  pin=slibLoadPin(Info,  pinid);
  if (pin==NULL)
    return(Info->Mode==SLIB_MODE_COMPRESS?SlibErrorNoData:SlibErrorBadStream);
  if (stream==SLIB_STREAM_MAINVIDEO && Info->Mode==SLIB_MODE_DECOMPRESS &&
      Info->VideoPTimeCode==SLIB_TIME_NONE &&
      SlibTypeIsMPEG(Info->Type))
  {
    /* search from GOP start */
    dword i, iend;
    SlibTime_t nexttime;
    unsigned char *tmpbuf, *prevbuf=NULL;
    unsigned dword tmpsize, bytessearched=0;
    tmpbuf=SlibGetBuffer(Info, pinid, &tmpsize, &ptimestamp);
    if (tmpbuf==NULL)
      return(SlibErrorEndOfStream);
    do {
      for (i=0, iend=tmpsize-3; i<iend; i++)
        if (tmpbuf[i]==0&&tmpbuf[i+1]==0&&tmpbuf[i+2]==1&&
                      (tmpbuf[i+3]==0xB8||tmpbuf[i+3]==0xB3))
          break;
      if (i<iend)
      {
        slibInsertBufferOnPin(pin, tmpbuf+i, tmpsize-i, ptimestamp);
        tmpbuf=NULL;
        break;
      }
      else if (tmpbuf[i]==0 && tmpbuf[i+1]==0 && tmpbuf[i+2]==1)
      {
        prevbuf=tmpbuf+tmpsize-3;
        tmpbuf=SlibGetBuffer(Info, pinid, &tmpsize, &nexttime);
        if (tmpbuf==NULL)
          return(SlibErrorEndOfStream);
        if (nexttime!=SLIB_TIME_NONE)
          ptimestamp=nexttime;
        if (tmpbuf[0]==0xB8||tmpbuf[0]==0xB3)
        {
          slibInsertBufferOnPin(pin, tmpbuf, tmpsize, nexttime);
          slibInsertBufferOnPin(pin, prevbuf, 3, ptimestamp);
          tmpbuf=NULL;
          break;
        }
        else
          SlibFreeBuffer(prevbuf);
      }
      else if (tmpbuf[i+1]==0 && tmpbuf[i+2]==0)
      {
        prevbuf=tmpbuf+tmpsize-2;
        tmpbuf=SlibGetBuffer(Info, pinid, &tmpsize, &nexttime);
        if (tmpbuf==NULL)
          return(SlibErrorEndOfStream);
        if (nexttime!=SLIB_TIME_NONE)
          ptimestamp=nexttime;
        if (tmpbuf[0]==1 && (tmpbuf[1]==0xB8||tmpbuf[0]==0xB3))
        {
          slibInsertBufferOnPin(pin, tmpbuf, tmpsize, nexttime);
          slibInsertBufferOnPin(pin, prevbuf, 2, ptimestamp);
          tmpbuf=NULL;
          break;
        }
        else
          SlibFreeBuffer(prevbuf);
      }
      else if (tmpbuf[i+2]==0)
      {
        prevbuf=tmpbuf+tmpsize-1;
        tmpbuf=SlibGetBuffer(Info, pinid, &tmpsize, &nexttime);
        if (tmpbuf==NULL)
          return(SlibErrorEndOfStream);
        if (nexttime!=SLIB_TIME_NONE)
          ptimestamp=nexttime;
        if (tmpbuf[0]==0 && tmpbuf[1]==1 && (tmpbuf[2]==0xB8||tmpbuf[0]==0xB3))
        {
          slibInsertBufferOnPin(pin, tmpbuf, tmpsize, nexttime);
          slibInsertBufferOnPin(pin, prevbuf, 1, ptimestamp);
          tmpbuf=NULL;
          break;
        }
        else
          SlibFreeBuffer(prevbuf);
      }
      else
      {
        SlibFreeBuffer(tmpbuf);
        tmpbuf=SlibGetBuffer(Info, pinid, &tmpsize, &nexttime);
        if (tmpbuf==NULL)
          return(SlibErrorEndOfStream);
        if (nexttime!=SLIB_TIME_NONE)
          ptimestamp=nexttime;
      }
      bytessearched+=tmpsize;
    } while (tmpbuf && bytessearched<512*1024);
  }
  if (*databuf==NULL)
    *databuf=SlibGetBuffer(Info, pinid, databufsize, &ptimestamp);
  else
    *databufsize=slibFillBufferFromPin(Info, pin, *databuf, *databufsize,
                          &ptimestamp);
  if (Info->Mode==SLIB_MODE_DECOMPRESS)
  {
    if (ptimestamp!=SLIB_TIME_NONE)
      switch (stream) /* set presentation timecodes */
      {
        case SLIB_STREAM_MAINVIDEO:
            Info->VideoPTimeCode=ptimestamp;
            _SlibDebug(_TIMECODE_ || _VERBOSE_,
               printf("SlibReadData() VideoPTimeCode=%ld\n", ptimestamp) );
            break;
        case SLIB_STREAM_MAINAUDIO:
            Info->AudioPTimeCode=ptimestamp;
            _SlibDebug(_TIMECODE_ || _VERBOSE_,
               printf("SlibReadData() AudioPTimeCode=%ld\n", ptimestamp) );
            break;
      }
    else if (stream==SLIB_STREAM_MAINVIDEO &&
             Info->VideoPTimeCode==SLIB_TIME_NONE)
      Info->VideoPTimeCode=SLIB_TIME_UNKNOWN;
  }
  if (*databuf==NULL || *databufsize==0)
  {
    if (!slibDataOnPin(Info, pinid))
      return(SlibErrorEndOfStream);
    else
      return(SlibErrorReading);
  }
  return(SlibErrorNone);
}

SlibStatus_t SlibReadVideo(SlibHandle_t handle, SlibStream_t stream,
                      void **videobuf, unsigned dword *videobufsize)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SvStatus_t status=SvErrorNone;
  unsigned char *imagebuf=NULL;
  SlibTime_t startvideotime;
  _SlibDebug(_VERBOSE_, printf("SlibReadVideo()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  if (!videobuf)
    return(SlibErrorBadArgument);
/*
  imagesize=(Info->Width*Info->Height*3)/2;
  if (videobufsize<imagesize)
    return(SlibErrorBufSize);
*/
  if (Info->Mode!=SLIB_MODE_DECOMPRESS)
    return(SlibErrorBadMode);
  if (Info->VideoFormat==NULL || Info->CodecVideoFormat==NULL ||
               Info->CompVideoFormat==NULL)
    return(SlibErrorUnsupportedFormat);
  if ((status=slibStartVideo(Info, (SlibBoolean_t)((*videobuf==NULL)?FALSE:TRUE)))
                  !=SlibErrorNone)
    return(status);
  startvideotime=Info->VideoTimeStamp;
  switch(Info->VideoType)
  {
#ifdef MPEG_SUPPORT
    case SLIB_TYPE_MPEG1_VIDEO:
    case SLIB_TYPE_MPEG2_VIDEO:
        do {
          _SlibDebug(_DEBUG_, printf("SvDecompressMPEG()\n") );
          status = SvDecompressMPEG(Info->Svh, Info->Multibuf,
                             Info->MultibufSize, &imagebuf);
          _SlibDebug(_WARN_ && status!=SvErrorNone,
                             printf("SvDecompressMPEG() %s\n",
                               ScGetErrorStr(status)) );
        } while(status == SvErrorNotDecompressable);
        if (status==SvErrorNone)
          SlibAllocSubBuffer(imagebuf,  Info->CodecVideoFormat->biSizeImage);
        _SlibDebug(_SEEK_>1, printf("timecode=%d ms  framenum=%d\n",
                SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE),
                SvGetParamInt(Info->Svh, SV_PARAM_FRAME) ) );
        break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
    case SLIB_TYPE_H261:
        do {
          _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"SvDecompressH261()\n") );
          status = SvDecompressH261(Info->Svh, Info->Multibuf,
                                    Info->MultibufSize,
                                    &imagebuf);
        } while(status == SvErrorNotDecompressable);
        if (status==SvErrorNone)
          SlibAllocSubBuffer(imagebuf,  Info->CodecVideoFormat->biSizeImage);
        break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SLIB_TYPE_H263:
        _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"SvDecompress(%d bytes)\n", Info->MultibufSize) );
        status=SvDecompress(Info->Svh, NULL, 0,
                                 Info->Multibuf, Info->MultibufSize);
        imagebuf=Info->Multibuf;
        if (status==SvErrorNone)
          SlibAllocSubBuffer(imagebuf,  Info->CodecVideoFormat->biSizeImage);
        break;
#endif /* H263_SUPPORT */
#ifdef JPEG_SUPPORT
    case SLIB_TYPE_JPEG:
    case SLIB_TYPE_MJPG:
        {
          unsigned dword bufsize;
          unsigned char *buf;
          buf=SlibGetBuffer(Info, SLIB_DATA_VIDEO, &bufsize, NULL);
          if (buf)
          {
            /* ScDumpChar(buf, 10000, 0); */
            _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"SvDecompress(%d bytes)\n", bufsize) );
            status=SvDecompress(Info->Svh, buf, bufsize,
                                 Info->Multibuf, Info->MultibufSize);
            imagebuf=Info->Multibuf;
            SlibFreeBuffer(buf);
          }
          else
            status=SvErrorForeign;
          if (status==SvErrorNone)
            SlibAllocSubBuffer(imagebuf,  Info->CodecVideoFormat->biSizeImage);
        }
        break;
#endif /* JPEG_SUPPORT */
#ifdef HUFF_SUPPORT
    case SLIB_TYPE_SHUFF:
        if (*videobuf==NULL)
        {
          if (Info->Imagebuf==NULL &&
              (Info->Imagebuf=SlibAllocBuffer(Info->ImageSize))==NULL)
            return(SlibErrorMemory);
          imagebuf=Info->Imagebuf;
        }
        else
          imagebuf=*videobuf;
        do {
          _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"SvDecompress()\n") );
          status=SvDecompress(Info->Svh, NULL, 0,
                               imagebuf,  Info->CodecVideoFormat->biSizeImage);
        } while(status == SvErrorNotDecompressable);
        if (status==SvErrorNone)
          SlibAllocSubBuffer(imagebuf,  Info->CodecVideoFormat->biSizeImage);
        break;
#endif /* HUFF_SUPPORT */
    case SLIB_TYPE_RASTER:
    case SLIB_TYPE_YUV:
        if (*videobuf && videobufsize && *videobufsize==0)
          return(SlibErrorBadArgument);
        imagebuf=SlibGetBuffer(Info, SLIB_DATA_VIDEO, videobufsize, NULL);

        if (*videobufsize==0)
          status=SvErrorEndBitstream;
        _SlibDebug(_DEBUG_,
               ScDebugPrintf(Info->dbg,"Video frame size = %d ImageSize=%d\n",
                     *videobufsize, Info->ImageSize) );
        break;
    default:
        return(SlibErrorUnsupportedFormat);
  }

  if (status==SvErrorNone)
  {
    /* format conversion */
    if (Info->Sch==NULL) /* start the format converter */
    {
      if (Info->Svh) /* compressed video format */
      {
        unsigned dword fourcc=(unsigned dword)SvGetParamInt(Info->Svh, SV_PARAM_FINALFORMAT);
        if (fourcc)
        {
          Info->CodecVideoFormat->biCompression=fourcc;
          Info->CodecVideoFormat->biBitCount=
                (WORD)slibCalcBits(fourcc, Info->CodecVideoFormat->biBitCount);
        }
      }
      else /* uncompressed video format */
        memcpy(Info->CodecVideoFormat, Info->CompVideoFormat, sizeof(BITMAPINFOHEADER));
      if (SconOpen(&Info->Sch, SCON_MODE_VIDEO, (void *)Info->CodecVideoFormat, (void *)Info->VideoFormat)
           !=SconErrorNone)
        return(SlibErrorUnsupportedFormat);
      if (Info->Stride)
        SconSetParamInt(Info->Sch, SCON_OUTPUT, SCON_PARAM_STRIDE, Info->Stride);

    }
    if (SconIsSame(Info->Sch) && *videobuf == NULL) /* no conversion */
      *videobuf=imagebuf;
    else
    {
      if (*videobuf == NULL && (*videobuf=SlibAllocBuffer(Info->ImageSize))==NULL)
        return(SlibErrorMemory);
      if (SconConvert(Info->Sch, imagebuf, Info->CodecVideoFormat->biSizeImage,
                      *videobuf, Info->ImageSize) != SconErrorNone)
      {
        SlibFreeBuffer(imagebuf); /* free decompressed image */
        return(SlibErrorUnsupportedFormat);
      }
      SlibFreeBuffer(imagebuf); /* free decompressed image */
    }
    *videobufsize = Info->ImageSize;
    /* update stats */
    if (Info->stats && Info->stats->Record)
      Info->stats->FramesProcessed++;
    if (startvideotime==Info->VideoTimeStamp) /* video time hasn't changed */
      slibAdvancePositions(Info, 1);
  }
  else
  {
    if (status==ScErrorEndBitstream ||
        !slibDataOnPin(Info, SLIB_DATA_VIDEO))
    {
      if (Info->FileSize>0 && !Info->VideoLengthKnown)
        slibUpdateLengths(Info);
      _SlibDebug(_WARN_, ScDebugPrintf(Info->dbg,"SlibReadVideo() %s\n",
                           ScGetErrorStr(status)) );
      return(SlibErrorEndOfStream);
    }
    _SlibDebug(_WARN_, printf("SlibReadVideo() %s\n",
                           ScGetErrorStr(status)) );
    return(SlibErrorReading);
  }
  return(SlibErrorNone);
}

SlibStatus_t SlibReadAudio(SlibHandle_t handle, SlibStream_t stream,
                     void *audiobuf, unsigned dword *audiobufsize)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SvStatus_t status=SaErrorNone;
  unsigned dword totalbytes=0, bytes_since_timeupdate=0;
  SlibTime_t startaudiotime;
#ifdef _SLIBDEBUG_
  SlibTime_t calcaudiotime;
#endif

  _SlibDebug(_VERBOSE_, printf("SlibReadAudio(audiobufsize=%d, time=%d)\n",
                                  *audiobufsize, Info->AudioTimeStamp) );
  if (!handle)
    return(SlibErrorBadHandle);
  if (Info->Mode!=SLIB_MODE_DECOMPRESS)
    return(SlibErrorBadMode);
  if (Info->AudioFormat==NULL)
    return(SlibErrorUnsupportedFormat);
  if ((status=slibStartAudio(Info))!=SlibErrorNone)
    return(status);
#ifdef _SLIBDEBUG_
  calcaudiotime=Info->AudioTimeStamp;
#endif
  startaudiotime=Info->AudioTimeStamp;
  switch(Info->AudioType)
  {
    case SLIB_TYPE_PCM:
        totalbytes=slibFillBufferFromPin(Info,
                                   slibGetPin(Info, SLIB_DATA_AUDIO),
                                   (unsigned char *)audiobuf, *audiobufsize,
                                   NULL);
        if (totalbytes==0)
          status=ScErrorEndBitstream;
        *audiobufsize = totalbytes;
        bytes_since_timeupdate = totalbytes;
        break;
#ifdef MPEG_SUPPORT
    case SLIB_TYPE_MPEG1_AUDIO:
	{
	  unsigned dword bytes;
          /* see if some bytes of audio are left in the temp audio buffer */
          if (Info->Audiobuf && Info->AudiobufUsed>0)
          {
            _SlibDebug(_DEBUG_,
                 printf("SlibReadAudio() Audiobuf contains %d bytes\n",
                      Info->AudiobufUsed) );
            if (*audiobufsize>=Info->AudiobufUsed)
            {
              memcpy(audiobuf, Info->Audiobuf, Info->AudiobufUsed);
              totalbytes=Info->AudiobufUsed;
              Info->AudiobufUsed=0;
            }
            else
            {
              memcpy(audiobuf, Info->Audiobuf, *audiobufsize);
              totalbytes=*audiobufsize;
              Info->AudiobufUsed-=*audiobufsize;
              memcpy(Info->Audiobuf, Info->Audiobuf+*audiobufsize,
                                 Info->AudiobufUsed);
            }
          }
          /* need to alloc a temp audio buffer? */
          if (!Info->Audiobuf || Info->AudiobufSize<
                     *audiobufsize+MPEG1_AUDIO_FRAME_SIZE*4)
          {
            unsigned char *newbuf;
            /* enlarge Audiobuf or alloc it for the first time */
            _SlibDebug(_DEBUG_,
                printf("SlibReadAudio() enlarging Audiobuf: %d->%d bytes\n",
                 Info->AudiobufSize,*audiobufsize+MPEG1_AUDIO_FRAME_SIZE*4) );
            newbuf=SlibAllocBuffer(*audiobufsize+MPEG1_AUDIO_FRAME_SIZE*4);
            if (!newbuf)
              return(SlibErrorMemory);
            Info->AudiobufSize=*audiobufsize+MPEG1_AUDIO_FRAME_SIZE*4;
            if (Info->Audiobuf)
              SlibFreeBuffer(Info->Audiobuf);
            Info->Audiobuf=newbuf;
            Info->AudiobufUsed=0;
          }
          if (*audiobufsize>=MPEG1_AUDIO_FRAME_SIZE*4)
          {
            unsigned dword stopbytes=*audiobufsize-(MPEG1_AUDIO_FRAME_SIZE*4)+1;
            while (status==SaErrorNone && totalbytes<stopbytes)
            {
              bytes = *audiobufsize - totalbytes;
              _SlibDebug(_DEBUG_,
                  printf("SaDecompress(bytes=%d) in totalbytes=%d\n",
                                        bytes, totalbytes) );
              status = SaDecompress(Info->Sah, NULL, 0,
                           (unsigned char *)audiobuf+totalbytes, &bytes);
              _SlibDebug(_DEBUG_, printf("SaDecompress() out: bytes=%d\n",
                                            bytes) );
              totalbytes += bytes;
              if (Info->AudioTimeStamp!=startaudiotime)
              {
                startaudiotime=Info->AudioTimeStamp;
                bytes_since_timeupdate=bytes;
              }
              else
                bytes_since_timeupdate+=bytes;
            }
          }
          if (totalbytes<*audiobufsize && status==SaErrorNone)
          {
            unsigned dword neededbytes=*audiobufsize-totalbytes;
            while (status==SaErrorNone && Info->AudiobufUsed<neededbytes)
            {
              bytes = *audiobufsize - totalbytes;
              _SlibDebug(_DEBUG_, printf("SaDecompress() in totalbytes=%d\n",
                                          totalbytes) );
              status = SaDecompress(Info->Sah, NULL, 0,
                  (unsigned char *)Info->Audiobuf+Info->AudiobufUsed, &bytes);
              _SlibDebug(_DEBUG_, printf("SaDecompress() out, %d bytes\n",
                                            bytes) );
              Info->AudiobufUsed += bytes;
            }
            if (Info->AudiobufUsed>0)
            {
              if (Info->AudiobufUsed>neededbytes) /* complete buffer returned */
              {
                memcpy((unsigned char*)audiobuf+totalbytes,
                        Info->Audiobuf, neededbytes);
                Info->AudiobufUsed-=neededbytes;
                memcpy(Info->Audiobuf, Info->Audiobuf+neededbytes,
                                   Info->AudiobufUsed);
                totalbytes+=neededbytes;
                bytes_since_timeupdate+=neededbytes;
              }
              else  /* partially filled buffer */
              {
                memcpy((unsigned char*)audiobuf+totalbytes, Info->Audiobuf,
                       Info->AudiobufUsed);
                totalbytes+=Info->AudiobufUsed;
                Info->AudiobufUsed=0;
              }
            }
          }
          *audiobufsize = totalbytes;
          _SlibDebug(_WARN_>1 && totalbytes>0 &&
                       totalbytes!=*audiobufsize,
             printf("SlibReadAudio(audiobufsize=%d bytes) totalbytes=%d\n",
                   *audiobufsize, totalbytes) );
	}
        break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
    case SLIB_TYPE_AC3_AUDIO:
	{
	  unsigned dword bytes;
	  unsigned int framesize;
	  unsigned int buffersize;
	  int samplesize;
	  int buffers;
	  unsigned char *pointers[3];
	  int i;

	  if (Info->Channels>2)
	  {
            framesize = AC3_FRAME_SIZE*((Info->BitsPerSample+7)/8)
                                      *Info->Channels;
            samplesize=Info->Channels*((Info->BitsPerSample+7)/8);
            buffers = (Info->Channels+1)/2;
            buffersize = (*audiobufsize/samplesize/buffers)*samplesize;

            for(i=0; i<buffers; i++)
              pointers[i]=(unsigned char *)audiobuf+buffersize*i;

            if (*audiobufsize>=framesize)
            {
              while (status==SaErrorNone && totalbytes<buffersize)
              {
                bytes = buffersize - totalbytes;
                _SlibDebug(_DEBUG_,printf("SaDecompressEx() in totalbytes=%d\n",
                                   totalbytes) );
                status = SaDecompressEx(Info->Sah, NULL, 0, pointers, &bytes);
                _SlibDebug(_DEBUG_, printf("SaDecompress() out, %d bytes\n",
                                            bytes) );
                for(i=0;i<buffers;i++)
                  pointers[i]+=bytes;
                totalbytes += bytes;
                if (Info->AudioTimeStamp!=startaudiotime)
                {
                  startaudiotime=Info->AudioTimeStamp;
                  bytes_since_timeupdate=bytes;
                }
                else
                  bytes_since_timeupdate+=bytes;
              }
            }
	  }
	  else
	  {
            while (status==SaErrorNone && totalbytes<*audiobufsize)
            {
              bytes = *audiobufsize - totalbytes;
              _SlibDebug(_DEBUG_, printf("SaDecompress() in totalbytes=%d\n",
                                   totalbytes) );
              status = SaDecompress(Info->Sah, NULL, 0,
                             (unsigned char *)audiobuf+totalbytes, &bytes);
              _SlibDebug(_DEBUG_, printf("SaDecompress() out, %d bytes\n",
                                    bytes) );
              totalbytes += bytes;
              if (Info->AudioTimeStamp!=startaudiotime)
              {
                startaudiotime=Info->AudioTimeStamp;
                bytes_since_timeupdate=bytes;
              }
              else
                bytes_since_timeupdate+=bytes;
            }
	  }
          /*
          ** NOTE: The semantics are different here
          **       we return the size of just one stereo pair's buffer
          */
          *audiobufsize = totalbytes;
          _SlibDebug(_WARN_>1 && totalbytes>0 &&
                       totalbytes!=*audiobufsize,
             printf("SlibReadAudio(audiobufsize=%d bytes) totalbytes=%d\n",
                   *audiobufsize, totalbytes) );
	}
        break;
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
    case SLIB_TYPE_G723:
    //G723 decompresses in multiples of 480 samples.
    //To eliminate cumbersome buffer calculations,
    // Always fill the output buffer up to multiples
    // of 480 samples.To do this we iterate basically
    // the below "while" loop "audiobufsize/480 times.
    {
      int iTimes = (int)*audiobufsize/480;
      int iLoop =0;
	  unsigned dword bytes;
      if (slibInSyncMode(Info))
      {
        /* in synchronous mode we can't decompress past last frame
         * otherwise we may lose a frame
         */
        int iMaxTimes=(int)(slibDataOnPin(Info, SLIB_DATA_COMPRESSED)+
                           slibDataOnPin(Info, SLIB_DATA_AUDIO))/
                       SlibGetParamInt(handle, stream, SLIB_PARAM_MININPUTSIZE);
        if (iTimes>iMaxTimes)
          iTimes=iMaxTimes;
      }
      while (status==SaErrorNone && iLoop<iTimes)
      {
         bytes = *audiobufsize - totalbytes;
         _SlibDebug(_DEBUG_, printf("SaDecompress() in totalbytes=%d\n",
                                totalbytes) );
         status = SaDecompress(Info->Sah, NULL, 0,
            (unsigned char *)audiobuf+totalbytes, &bytes);
         _SlibDebug(_DEBUG_, printf("SaDecompress() out, %d bytes\n",
                                    bytes) );
         totalbytes += bytes;
         iLoop++;
         if (Info->AudioTimeStamp!=startaudiotime)
         {
            startaudiotime=Info->AudioTimeStamp;
            bytes_since_timeupdate=bytes;
         }
         else
            bytes_since_timeupdate+=bytes;
      }
      *audiobufsize = totalbytes;

      _SlibDebug(_WARN_>1 && totalbytes>0 &&
                  totalbytes!=*audiobufsize,
       printf("SlibReadAudio(audiobufsize=%d bytes) totalbytes=%d\n",
                   *audiobufsize, totalbytes) );
    }
    break;
#endif /* G723_SUPPORT */
    default:
        *audiobufsize = 0;
        return(SlibErrorUnsupportedFormat);
  }
  /* as we're decompressing audiotime may be updated with timecodes */
  if (Info->AudioTimeStamp==startaudiotime)
    Info->AudioTimeStamp = startaudiotime + (bytes_since_timeupdate*8000)/
           (Info->SamplesPerSec*Info->BitsPerSample*Info->Channels);
  _SlibDebug(_TIMECODE_||_VERBOSE_,
              calcaudiotime += (*audiobufsize*8000)/
                 (Info->SamplesPerSec*Info->BitsPerSample*Info->Channels);
              printf("AudioTimeStamp=%ld calcaudiotime=%ld (diff=%ld)\n",
                               Info->AudioTimeStamp, calcaudiotime,
                               calcaudiotime-Info->AudioTimeStamp);
              Info->AudioTimeStamp = calcaudiotime );

  _SlibDebug(_VERBOSE_||_TIMECODE_,
   printf("ReadAudio(%d) Time=%ld SamplesPerSec=%d BitsPerSample=%d Channels=%d\n",
         totalbytes,
         Info->AudioTimeStamp, Info->SamplesPerSec, Info->BitsPerSample,
         Info->Channels) );
  /* Info->SystemTimeStamp=Info->AudioTimeStamp; */
  if (status==SaErrorNone)
    return(SlibErrorNone);
  else if (status==ScErrorEndBitstream || status==ScErrorEOI)
  {
    if (*audiobufsize!=0)
      return(SlibErrorNone);
    else
      return(SlibErrorEndOfStream);
  }
  else
  {
    _SlibDebug(_WARN_ && status!=ScErrorEndBitstream
                      && status!=ScErrorEOI,
              printf("SlibReadAudio() %s\n", ScGetErrorStr(status)) );
    if (SlibIsEnd(handle, stream))
      return(SlibErrorEndOfStream);
    return(SlibErrorReading);
  }
}


SlibStatus_t SlibWriteVideo(SlibHandle_t handle, SlibStream_t stream,
                            void *videobuf, unsigned dword videobufsize)
{
  int compsize=0;
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SvStatus_t status;
  _SlibDebug(_DEBUG_, printf("SlibWriteVideo()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  if (!videobuf)
    return(SlibErrorBadArgument);
  if (videobufsize<(unsigned dword)Info->ImageSize)
    return(SlibErrorBufSize);
  if (Info->Mode!=SLIB_MODE_COMPRESS)
    return(SlibErrorBadMode);
  if (Info->VideoFormat==NULL || Info->CompVideoFormat==NULL)
    return(SlibErrorUnsupportedFormat);
  if (Info->IOError)
    return(SlibErrorWriting);
  if ((status=slibStartVideo(Info, FALSE))!=SlibErrorNone)
    return(status);
  if (Info->Sch==NULL) /* start the format converter */
  {
    if (SconOpen(&Info->Sch, SCON_MODE_VIDEO, (void *)Info->VideoFormat, (void *)Info->CodecVideoFormat)
         !=SconErrorNone)
      return(SlibErrorUnsupportedFormat);
  }
  if (!SconIsSame(Info->Sch)) /* need a conversion */
  {
    unsigned char *tmpbuf=NULL;
    if (Info->CodecImagebuf==NULL &&
        (Info->CodecImagebuf=SlibAllocBuffer(Info->CodecImageSize))==NULL)
      return(SlibErrorMemory);
    if (SconConvert(Info->Sch, videobuf, Info->ImageSize,
                      Info->CodecImagebuf, Info->CodecImageSize) != SconErrorNone)
      return(SlibErrorUnsupportedFormat);
    videobuf=Info->CodecImagebuf;
    videobufsize=Info->CodecImageSize;
  }
  switch(Info->Type)
  {
#ifdef H261_SUPPORT
    case SLIB_TYPE_H261:
        status = SvCompress(Info->Svh, NULL, 0, videobuf, videobufsize, &compsize);
        break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SLIB_TYPE_H263:
        status = SvCompress(Info->Svh, NULL, 0, videobuf, videobufsize, &compsize);
        break;
#endif /* H263_SUPPORT */
#ifdef MPEG_SUPPORT
    case SLIB_TYPE_MPEG1_VIDEO:
    case SLIB_TYPE_MPEG2_VIDEO:
    case SLIB_TYPE_MPEG_SYSTEMS:
    case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
        status = SvCompress(Info->Svh, NULL, 0, videobuf, videobufsize, &compsize);
        break;
#endif /* MPEG_SUPPORT */
#ifdef HUFF_SUPPORT
    case SLIB_TYPE_SHUFF:
        status = SvCompress(Info->Svh, NULL, 0, videobuf, videobufsize, &compsize);
        break;
#endif /* HUFF_SUPPORT */
    default:
        return(SlibErrorUnsupportedFormat);
  }


  if (status==SvErrorNone && !Info->IOError)
  {
    if (Info->stats && Info->stats->Record)
      Info->stats->FramesProcessed++;
    slibAdvancePositions(Info, 1);
  }
  else
  {
    _SlibDebug(_WARN_, printf("SlibWriteVideo() %s\n",
                         ScGetErrorStr(status)) );
    if (status==ScErrorEndBitstream || Info->IOError)
      return(SlibErrorEndOfStream);
    return(SlibErrorWriting);
  }
  return(SlibErrorNone);
}

SlibStatus_t SlibWriteAudio(SlibHandle_t handle, SlibStream_t stream,
                      void *audiobuf, unsigned dword audiobufsize)
{
  unsigned dword compsize=0;
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SvStatus_t status;
  _SlibDebug(_DEBUG_, printf("SlibAudioVideo()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  if (!audiobuf)
    return(SlibErrorBadArgument);
  if (Info->Mode!=SLIB_MODE_COMPRESS)
    return(SlibErrorBadMode);
  if (Info->AudioFormat==NULL || Info->CompAudioFormat==NULL)
  {
    _SlibDebug(_VERBOSE_ || _WARN_,
          printf("SlibWriteAudio() Audio Formats not setup\n") );
    return(SlibErrorUnsupportedFormat);
  }
  if (Info->IOError)
    return(SlibErrorWriting);
  if ((status=slibStartAudio(Info))!=SlibErrorNone)
    return(status);
  switch(Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SLIB_TYPE_MPEG1_AUDIO:
    case SLIB_TYPE_MPEG_SYSTEMS:
    case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
        {
          unsigned dword audiobytes;
          void *audiooutbuf=NULL;
          status=slibConvertAudio(Info, audiobuf, audiobufsize,
                              Info->SamplesPerSec, Info->BitsPerSample,
                              &audiooutbuf, &audiobytes,
                              Info->AudioFormat->nSamplesPerSec,
                              Info->AudioFormat->wBitsPerSample,
                              Info->Channels);
          if (status!=SlibErrorNone)
              return(status);
          audiobuf=audiooutbuf;
          audiobufsize=audiobytes;
          if (Info->AudiobufUsed && Info->Audiobuf) /* left over audio data */
          {
            if (Info->AudiobufSize<Info->AudiobufUsed+audiobufsize)
            {
              unsigned char *newbuf;
              /* enlarge Audiobuf */
              _SlibDebug(_DEBUG_, printf("enlarging Audiobuf: %d->%d bytes\n",
                        Info->AudiobufSize,audiobufsize+4608) );
              newbuf=SlibAllocBuffer(audiobufsize+4608);
              if (!newbuf)
                return(SlibErrorMemory);
              memcpy(newbuf, Info->Audiobuf, Info->AudiobufUsed);
              SlibFreeBuffer(Info->Audiobuf);
              Info->AudiobufSize+=audiobufsize;
              Info->Audiobuf=newbuf;
            }
            _SlibDebug(_DEBUG_,
               printf("Appending audio data: Info->AudiobufUsed=%d\n",
                                                 Info->AudiobufUsed) );
            memcpy(Info->Audiobuf+Info->AudiobufUsed, audiobuf, audiobufsize);
            audiobuf=Info->Audiobuf;
            audiobufsize+=Info->AudiobufUsed;
            audiobytes=audiobufsize;
            Info->AudiobufUsed=0;
          }
          status = SaCompress(Info->Sah, (unsigned char *)audiobuf,
                                        &audiobytes, NULL, &compsize);
          if (audiobytes<audiobufsize) /* save audio data not compressed */
          {
            _SlibDebug(_DEBUG_,
              printf("audiobytes(%d)<audiobufsize(%d)\n",
                                  audiobytes,audiobufsize) );
            if (!Info->Audiobuf)
            {
              Info->AudiobufSize=audiobufsize+(audiobufsize-audiobytes);
              Info->Audiobuf=SlibAllocBuffer(Info->AudiobufSize);
              if (!Info->Audiobuf)
              {
                Info->AudiobufSize=0;
                return(SlibErrorMemory);
              }
            }
            memcpy(Info->Audiobuf, (unsigned char *)audiobuf+audiobytes,
                                   audiobufsize-audiobytes);
            Info->AudiobufUsed=audiobufsize-audiobytes;
          }
          audiobufsize=audiobytes; /* actual amount written */
          if (audiooutbuf)
            SlibFreeBuffer(audiooutbuf);
        }
        break;
#endif /* MPEG_SUPPORT */
#ifdef G723_SUPPORT
    case SLIB_TYPE_G723:
    {
      unsigned int iNumBytesUnProcessed =0;
      unsigned int iNumBytesCompressed = 0;
      //You always compress in terms of frames (Frame is 480 bytes)
      //So,the files with sizes which are not exactly divisible by
      // 480 always leave some bytes at the end Unprocessed,Which is O.K

      //Check for any Unprocessed Audio stored in Temp buff
      //from the previous call to SlibWriteAudio.
      if (Info->AudiobufUsed && Info->Audiobuf) /* left over audio data */
      {
         if (Info->AudiobufSize < Info->AudiobufUsed+audiobufsize)
         {
            unsigned char *newbuf;
            /* enlarge Audiobuf to new Size (Current size + left over audio)*/
            _SlibDebug(_DEBUG_, printf("enlarging Audiobuf: %d->%d bytes\n",
                      Info->AudiobufSize,audiobufsize+Info->AudiobufUsed) );
            newbuf=SlibAllocBuffer(Info->AudiobufUsed+audiobufsize);
            if (!newbuf)
               return(SlibErrorMemory);
            memcpy(newbuf, Info->Audiobuf, Info->AudiobufUsed);
            SlibFreeBuffer(Info->Audiobuf);
            //Info->AudiobufSize+=audiobufsize;
            Info->Audiobuf=newbuf;
         }
         _SlibDebug(_DEBUG_,
           printf("Appending audio data: Info->AudiobufUsed=%d\n",
                                            Info->AudiobufUsed) );
         memcpy(Info->Audiobuf+Info->AudiobufUsed, audiobuf, audiobufsize);
         audiobuf=Info->Audiobuf;
         audiobufsize+=Info->AudiobufUsed;
         Info->AudiobufUsed=0;
      }

      iNumBytesCompressed = audiobufsize;
      status = SaCompress(Info->Sah,(unsigned char *)audiobuf,
                           &iNumBytesCompressed, NULL,&compsize);
      iNumBytesUnProcessed = audiobufsize - iNumBytesCompressed;
      //Store the Unprocessed Bytes into temp buffer
      if(iNumBytesUnProcessed)
      {
         //Allocate temp buff and store this audio.
         if (!Info->Audiobuf)
         {
            //MVP:To reduce ReAllocations and copying of memory
            //while checking for Unprocessed data (above),Allocate
            // now (normal audio buff size + Unprocessed bytes) more
            // memory upfront.
            Info->AudiobufSize=audiobufsize + iNumBytesUnProcessed;
            Info->Audiobuf=SlibAllocBuffer(Info->AudiobufSize);
            if (!Info->Audiobuf)
            {
               Info->AudiobufSize=0;
               return(SlibErrorMemory);
            }
         }
         memcpy(Info->Audiobuf, (unsigned char *)audiobuf+iNumBytesCompressed,
                                   iNumBytesUnProcessed);
         Info->AudiobufUsed=iNumBytesUnProcessed;
      }
      audiobufsize=iNumBytesCompressed; /* actual amount written */
    }
       break;
#endif /* G723_SUPPORT */
    default:
        _SlibDebug(_VERBOSE_ || _WARN_,
           printf("SlibWriteAudio() Unsupported Format\n") );
        return(SlibErrorUnsupportedFormat);
  }

  if (status==SaErrorNone && !Info->IOError)
  {
    if (Info->AudioFormat)
      Info->AudioTimeStamp += (audiobufsize*8000)/
        (Info->AudioFormat->nSamplesPerSec*Info->AudioFormat->wBitsPerSample*
             Info->Channels);
    else
      Info->AudioTimeStamp += (audiobufsize*8000)/
           (Info->SamplesPerSec*Info->BitsPerSample*Info->Channels);
    _SlibDebug(_VERBOSE_||_TIMECODE_,
    printf("WriteAudio(%d) Time=%ld SamplesPerSec=%d BitsPerSample=%d Channels=%d\n",
         audiobufsize,
         Info->AudioTimeStamp, Info->SamplesPerSec, Info->BitsPerSample,
         Info->Channels) );
  }
  else
  {
    _SlibDebug(_WARN_, printf("SlibWriteAudio() %s\n", ScGetErrorStr(status)) );
    if (status==ScErrorEndBitstream || Info->IOError)
      return(SlibErrorEndOfStream);
    return(SlibErrorWriting);
  }
  return(SlibErrorNone);
}

/*
** Name: slibPinReposition
** Purpose: Called when input data stream is to be repositioned.
*/
SlibStatus_t slibReposition(SlibInfo_t *Info, SlibPosition_t position)
{
  SlibPin_t *pin=slibGetPin(Info, SLIB_DATA_COMPRESSED);
  _SlibDebug(_DEBUG_, printf("slibReposition() VideoCodecState=%d\n",
                                                   Info->VideoCodecState));
  if (pin) pin->Offset=position;
  Info->VideoPTimeCode = SLIB_TIME_NONE;
  Info->VideoDTimeCode = SLIB_TIME_NONE;
  Info->AudioPTimeCode = SLIB_TIME_NONE;
  Info->AudioDTimeCode = SLIB_TIME_NONE;
  if (Info->Fd >= 0)
  {
    _SlibDebug(_SEEK_, printf("ScFileSeek(%d, %d)\n", Info->Fd, position) );
    if (ScFileSeek(Info->Fd, position)!=NoErrors)
      return(SlibErrorEndOfStream);
    return(SlibErrorNone);
  }
  else if (Info->SlibCB)
  {
    SlibMessage_t result;
    _SlibDebug(_VERBOSE_,
        printf("slibReposition() SlibCB(SLIB_MSG_REPOSITION, %d)\n",
                                   position) );
    result=(*(Info->SlibCB))((SlibHandle_t)Info,
                        SLIB_MSG_REPOSITION, (SlibCBParam1_t)position,
                        (SlibCBParam2_t)0, (void *)Info->SlibCBUserData);
    if (result!=SLIB_MSG_CONTINUE)
      return(SlibErrorEndOfStream);
    return(SlibErrorNone);
  }
  return(SlibErrorForwardOnly);
}

/*
** Name: slibPinPrepareReposition
** Purpose: Should be called when a stream is about to be repositioned (a seek).
**          This will empty any remaining buffers being used by the
**          CODECs and restart them.
*/
void slibPinPrepareReposition(SlibInfo_t *Info, int pinid)
{
  _SlibDebug(_DEBUG_, printf("slibPinPrepareReposition() VideoCodecState=%d\n",
                                                   Info->VideoCodecState));
  switch(pinid)
  {
     case SLIB_DATA_VIDEO:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinPrepareReposition(Video) in\n") );
             if (Info->VideoCodecState==SLIB_CODEC_STATE_BEGUN && Info->Svh &&
#ifdef JPEG_SUPPORT
                 Info->Type != SLIB_TYPE_JPEG_AVI &&
                 Info->Type != SLIB_TYPE_MJPG_AVI &&
#endif /* JPEG_SUPPORT */
                 Info->Type != SLIB_TYPE_YUV_AVI)
             {
               SvDecompressEnd(Info->Svh); /* this will reset the bitstream */
               Info->VideoCodecState=SLIB_CODEC_STATE_REPOSITIONING;
               _SlibDebug(_DEBUG_, printf("VideoCodecState=REPOSITIONING\n"));
               Info->IOError=FALSE;
             }
             Info->VideoPTimeCode = SLIB_TIME_NONE;
             Info->VideoDTimeCode = SLIB_TIME_NONE;
             Info->VideoTimeStamp = SLIB_TIME_NONE;
             Info->AvgVideoTimeDiff = 0;
             Info->VarVideoTimeDiff = 0;
             Info->VideoFramesProcessed=0; /* reset frames processed */
             break;
     case SLIB_DATA_AUDIO:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinPrepareReposition(Audio) in\n") );
             if (Info->AudioCodecState==SLIB_CODEC_STATE_BEGUN && Info->Sah)
             {
               SaDecompressEnd(Info->Sah); /* this will reset the bitstream */
               Info->AudioCodecState=SLIB_CODEC_STATE_REPOSITIONING;
               _SlibDebug(_DEBUG_, printf("AudioCodecState=REPOSITIONING\n"));
               Info->IOError=FALSE;
             }
             Info->AudioPTimeCode = SLIB_TIME_NONE;
             Info->AudioDTimeCode = SLIB_TIME_NONE;
             Info->AudioTimeStamp = SLIB_TIME_NONE;
             break;
     default:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinPrepareReposition(%d) in\n", pinid) );
  }
  _SlibDebug(_VERBOSE_||_SEEK_>1, printf("slibPinPrepareReposition(%d) out\n",
                                         pinid) );
}

void slibPinFinishReposition(SlibInfo_t *Info, int pinid)
{
  _SlibDebug(_DEBUG_, printf("slibPinFinishReposition() VideoCodecState=%d\n",
                                                   Info->VideoCodecState));
  switch(pinid)
  {
     case SLIB_DATA_VIDEO:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinFinishReposition(Video) in\n") );
             if (Info->VideoCodecState==SLIB_CODEC_STATE_REPOSITIONING &&
                   Info->Svh && slibGetPin(Info, SLIB_DATA_VIDEO) &&
#ifdef JPEG_SUPPORT
                 Info->Type != SLIB_TYPE_JPEG_AVI &&
                 Info->Type != SLIB_TYPE_MJPG_AVI &&
#endif /* JPEG_SUPPORT */
                 Info->Type != SLIB_TYPE_YUV_AVI)
               slibStartVideo(Info, FALSE);
             break;
     case SLIB_DATA_AUDIO:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinFinishReposition(Audio) in\n") );
             if (Info->AudioCodecState==SLIB_CODEC_STATE_REPOSITIONING &&
                  Info->Sah && slibGetPin(Info, SLIB_DATA_AUDIO))
               slibStartAudio(Info);
             break;
     default:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinFinishReposition(%d) in\n", pinid) );
  }
  _SlibDebug(_VERBOSE_||_SEEK_>1, printf("slibPinFinishReposition(%d) out\n",
                                         pinid) );
}

SlibBoolean_t slibUpdateLengths(SlibInfo_t *Info)
{
  if (Info->FileSize>0 && !Info->VideoLengthKnown &&
       (SlibTimeIsValid(Info->VideoPTimeCode) ||
        SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE)>=1000)
     )
  {
    if (Info->VideoTimeStamp>Info->VideoLength)
      Info->VideoLength=Info->VideoTimeStamp;
    Info->VideoLengthKnown=TRUE;
    _SlibDebug(_SEEK_ || _TIMECODE_,
    printf("slibUpdateLengths() AudioLength=%ld VideoLength=%ld\n",
                  Info->AudioLength, Info->VideoLength) );
    return(TRUE);
  }
  return(FALSE);
}

SlibBoolean_t slibUpdatePositions(SlibInfo_t *Info, SlibBoolean_t exactonly)
{
  SlibBoolean_t updated=FALSE;

  if (!exactonly)
  {
    if (SlibTimeIsValid(Info->VideoTimeStamp))
      updated=TRUE;
    else if (SlibTimeIsValid(Info->AudioTimeStamp))
    {
      if (slibHasVideo(Info))
        Info->VideoTimeStamp=Info->AudioTimeStamp;
      updated=TRUE;
    }
    else if (slibHasVideo(Info))
    {
      Info->VideoTimeStamp=slibGetNextTimeOnPin(Info, slibGetPin(Info, SLIB_DATA_VIDEO), 500*1024);
      if (SlibTimeIsValid(Info->VideoTimeStamp))
      {
        Info->VideoTimeStamp-=Info->VideoPTimeBase;
        updated=TRUE;
      }
    }
  }
  if (!updated && (!exactonly || SlibTimeIsInValid(Info->VideoPTimeBase)) &&
           SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE)>=1500 &&
            SvGetParamInt(Info->Svh, SV_PARAM_FRAME)>24)
  {
    _SlibDebug(_TIMECODE_, printf("slibUpdatePositions() using video time\n") );
    Info->VideoTimeStamp=SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE);
    updated=TRUE;
  }
  if (updated)
  {
    if (Info->VideoTimeStamp>Info->VideoLength)
      Info->VideoLength=Info->VideoTimeStamp;
    if (SlibTimeIsInValid(Info->AudioTimeStamp) && slibHasAudio(Info))
    {
      /* need to update audio time */
      Info->AudioTimeStamp=slibGetNextTimeOnPin(Info, slibGetPin(Info, SLIB_DATA_AUDIO), 100*1024);
      if (SlibTimeIsInValid(Info->AudioTimeStamp))
        Info->AudioTimeStamp=Info->VideoTimeStamp;
      else
        Info->AudioTimeStamp-=Info->AudioPTimeBase;
    }
    if (SlibTimeIsInValid(Info->VideoPTimeCode))
      Info->VideoFramesProcessed=slibTimeToFrame(Info, Info->VideoTimeStamp);
  }
  _SlibDebug(_SEEK_ || _TIMECODE_,
     printf("slibUpdatePositions() AudioTimeStamp=%ld VideoTimeStamp=%ld %s\n",
         Info->AudioTimeStamp, Info->VideoTimeStamp, updated?"updated":"") );
  return(updated);
}

void slibAdvancePositions(SlibInfo_t *Info, qword frames)
{
  Info->VideoFramesProcessed+=frames;
  if (Info->FramesPerSec)
  {
    if (Info->Mode==SLIB_MODE_COMPRESS ||
        SlibTimeIsInValid(Info->VideoPTimeCode))
      Info->VideoTimeStamp=slibFrameToTime(Info, Info->VideoFramesProcessed);
    else
      Info->VideoTimeStamp=Info->VideoPTimeCode - Info->VideoPTimeBase +
                           slibFrameToTime(Info, Info->VideoFramesProcessed);
    /* Info->VideoTimeStamp+=slibFrameToTime(Info, frames); */
    if (Info->VideoTimeStamp>Info->VideoLength)
      Info->VideoLength=Info->VideoTimeStamp;
    _SlibDebug(_TIMECODE_,
          printf("slibAdvancePositions(frames=%d) VideoTimeStamp=%ld\n",
             frames, Info->VideoTimeStamp) );
  }
}

SlibStatus_t SlibSeek(SlibHandle_t handle, SlibStream_t stream,
                      SlibSeekType_t seektype, SlibPosition_t frame)
{
  return(SlibSeekEx(handle, stream, seektype, frame, SLIB_UNIT_FRAMES, NULL));
}

SlibStatus_t SlibSeekEx(SlibHandle_t handle, SlibStream_t stream,
                      SlibSeekType_t seektype, SlibPosition_t seekpos,
                      SlibUnit_t seekunits, SlibSeekInfo_t *seekinfo)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SvStatus_t status=SlibErrorNone;
  SlibTime_t seektime, timediff;
  unsigned int tries=0;
  _SlibDebug(_SEEK_,
      printf("SlibSeekEx(stream=%d,seektype=%d,pos=%ld,units=%d)\n",
                     stream,seektype,seekpos,seekunits) );
  if (!handle)
    return(SlibErrorBadHandle);
  if (Info->Mode!=SLIB_MODE_DECOMPRESS && seektype!=SLIB_SEEK_RESET)
    return(SlibErrorBadMode);
  if (SlibSeekTypeUsesPosition(seektype))
  {
    switch (seekunits)
    {
      case SLIB_UNIT_FRAMES: /* frames */
            /* we need to convert the frame to the time */
            if (Info->FramesPerSec)
              seektime=slibFrameToTime(Info, seekpos);
            else
              seektime=SLIB_TIME_NONE;
            break;
      case SLIB_UNIT_MS:  /* milliseconds */
            seektime=(seekpos<0) ? 0 : seekpos;
            break;
      case SLIB_UNIT_PERCENT100:  /* 100th of a percent */
            if (seekpos<0 || seekpos>10000)
              return(SlibErrorBadPosition);
            if (Info->VideoStreams==0 || stream==SLIB_STREAM_MAINAUDIO)
              seektime=(seekpos * Info->AudioLength)/(SlibPosition_t)10000;
            else
              seektime=(seekpos * Info->VideoLength)/(SlibPosition_t)10000;
            break;
      default:
            return(SlibErrorBadUnit);
    }
    /* see if the new position is past the end of the file */
    if (Info->VideoLengthKnown && seektime>Info->VideoLength)
      return(SlibErrorBadPosition);
  }
  else
    seektime=(seekpos<0) ? 0 : seekpos;
  if (seekinfo)
    seekinfo->FramesSkipped=0;
  switch(seektype)
  {
    case SLIB_SEEK_AHEAD:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,AHEAD,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if (seektime<=0)
            return(SlibErrorNone);
          if (stream==SLIB_STREAM_MAINAUDIO || Info->VideoStreams<=0)
            seektime+=Info->AudioTimeStamp;
          else
            seektime+=Info->VideoTimeStamp;
          return(SlibSeekEx(handle, stream, SLIB_SEEK_NEXT_NEAR, seektime,
                       SLIB_UNIT_MS, seekinfo));
    case SLIB_SEEK_NEXT_NEAR:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,NEXT_NEAR,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          status=slibStartVideo(Info, FALSE);
          if (status==SlibErrorNone)
          {
            qword framesskipped=0;
            SlibBoolean_t atkey=FALSE; /* key's must be decoded */
            if (Info->Svh) /* update key spacing */
            {
              Info->KeySpacing=(int)SvGetParamInt(Info->Svh,
                                                        SV_PARAM_KEYSPACING);
              Info->SubKeySpacing=(int)SvGetParamInt(Info->Svh,
                                                        SV_PARAM_SUBKEYSPACING);
            }
            timediff=seektime-Info->VideoTimeStamp;
            while (status==SlibErrorNone &&
               (timediff>500 ||
                timediff>(Info->VideoFrameDuration*Info->KeySpacing*6)/1000))
            {
              status=SlibSeekEx(handle, stream, SLIB_SEEK_NEXT_KEY, 0,
                                SLIB_UNIT_NONE, seekinfo);
              if (seekinfo) framesskipped+=seekinfo->FramesSkipped;
              timediff=seektime-Info->VideoTimeStamp;
              atkey=TRUE;
            }
            if (!atkey && status==SlibErrorNone &&
               (timediff>150 ||
                timediff>(Info->VideoFrameDuration*Info->SubKeySpacing*6)/1000))
            {
              if (SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)!=FRAME_TYPE_I &&
                  SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)!=FRAME_TYPE_P)
              {
                /* we're seeking past more than one frame */
                status=SlibSeekEx(handle, stream, SLIB_SEEK_NEXT_SUBKEY, 0,
                                SLIB_UNIT_NONE, seekinfo);
                if (seekinfo) framesskipped+=seekinfo->FramesSkipped;
                timediff=seektime-Info->VideoTimeStamp;
              }
              atkey=TRUE;
            }
            while (!atkey && status==SlibErrorNone &&
                   timediff>Info->VideoFrameDuration/100)
            {
              if (SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_B ||
                  SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_NONE)
              {
                /* we can skip B frames without decompressing them */
                status=SlibSeekEx(handle, stream, SLIB_SEEK_NEXT, 0,
                                SLIB_UNIT_NONE, seekinfo);
                if (seekinfo) framesskipped+=seekinfo->FramesSkipped;
                timediff=seektime-Info->VideoTimeStamp;
              }
              else
                atkey=TRUE;
            }
            if (seekinfo) seekinfo->FramesSkipped=framesskipped;
          }
          return(status);
    case SLIB_SEEK_NEXT:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,NEXT,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if ((status=slibStartVideo(Info, FALSE))!=SlibErrorNone)
            return(status);
#ifdef MPEG_SUPPORT
          if (Info->VideoCodecState==SLIB_CODEC_STATE_BEGUN
              && Info->Svh && SlibTypeIsMPEGVideo(Info->Type))
          {
            SvPictureInfo_t mpegPictureInfo;
            unsigned char *videobuf;
            /* cannot skip I or B frames without decompressing them */
            if (SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_I ||
                SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_P)
            {
              _SlibDebug(_DEBUG_||_SEEK_, printf("SvDecompressMPEG()\n") );
              status = SvDecompressMPEG(Info->Svh, Info->Multibuf,
                                        Info->MultibufSize, &videobuf);
              _SlibDebug(_WARN_ && status!=SvErrorNone,
                   printf("SvDecompressMPEG() %s\n", ScGetErrorStr(status)) );
            }
            else
            {
              mpegPictureInfo.Type = SV_I_PICTURE|SV_P_PICTURE|SV_B_PICTURE;
              _SlibDebug(_VERBOSE_||_SEEK_>1,
                        printf("SvFindNextPicture(I|P|B)\n") );
              status = SvFindNextPicture(Info->Svh, &mpegPictureInfo);
              _SlibDebug(_WARN_ && status!=SvErrorNone,
                   printf("SvFindNextPicture() %s\n", ScGetErrorStr(status)) );
            }
            if (status==NoErrors)
            {
              slibAdvancePositions(Info, 1);
              if (Info->stats && Info->stats->Record)
                Info->stats->FramesSkipped++;
              if (seekinfo) seekinfo->FramesSkipped++;
            }
            else if (status==ScErrorEndBitstream)
            {
              if (Info->FileSize>0 && !Info->VideoLengthKnown)
                slibUpdateLengths(Info);
              return(SlibErrorEndOfStream);
            }
            return(SlibErrorNone);
          }
#endif /* MPEG_SUPPORT */
          return(SlibErrorReading);
    case SLIB_SEEK_EXACT:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,EXACT,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if (Info->FileSize<=0)
            return(SlibErrorFileSize);
          if (seektime==0 || Info->VideoStreams<=0)
            return(SlibSeekEx(handle, stream, SLIB_SEEK_KEY, 0, SLIB_UNIT_MS,
                                                                seekinfo));
          timediff=seektime-Info->VideoTimeStamp;
          if ((stream==SLIB_STREAM_MAINVIDEO || Info->AudioStreams==0) &&
             (timediff>=-20 && timediff<=20)) /* we're already near the frame */
            return(SlibErrorNone);
          if (Info->Svh) /* update key spacing */
            Info->KeySpacing=(int)SvGetParamInt(Info->Svh, SV_PARAM_KEYSPACING);
          if (timediff>(Info->KeySpacing*Info->VideoFrameDuration)/100 ||
                  timediff<0 ||
             (stream!=SLIB_STREAM_MAINVIDEO && Info->AudioStreams>0))
          {
            if (Info->KeySpacing>1)
            {
              const SlibTime_t keytime=
                   (Info->VideoFrameDuration*Info->KeySpacing)/100;
              if (seektime>=0 && seektime<keytime)
                status=SlibSeekEx(handle, stream, SLIB_SEEK_KEY, 0,
                                                SLIB_UNIT_MS, seekinfo);
              else
                status=SlibSeekEx(handle, stream, SLIB_SEEK_KEY,
                                  seektime-(keytime*2), SLIB_UNIT_MS, seekinfo);
            }
            else
              status=SlibSeekEx(handle, stream, SLIB_SEEK_KEY,
                                seektime-1000, SLIB_UNIT_MS, seekinfo);
            if (status!=NoErrors) return(status);
            timediff=seektime-Info->VideoTimeStamp;
          }
#if 0
          if (SvGetParamFloat(Info->Svh, SV_PARAM_FPS)>0)
            Info->FramesPerSec=SvGetParamFloat(Info->Svh, SV_PARAM_FPS);
#endif
          if (status==SlibErrorNone && timediff>=Info->VideoFrameDuration/100)
          {
            dword framesskipped=0;
            do {
              status=SlibSeekEx(handle, stream, SLIB_SEEK_NEXT, 0,
                                                SLIB_UNIT_NONE, seekinfo);
              framesskipped++;
              timediff=seektime-Info->VideoTimeStamp;
            } while (timediff>0 && status==SlibErrorNone);
            if (seekinfo) seekinfo->FramesSkipped+=framesskipped;
            /* if we skipped some frames, skip some audio too */
            if (framesskipped>5 && stream==SLIB_STREAM_ALL &&
                        Info->AudioStreams>0)
            {
              slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
              slibSkipAudio(Info, stream, (Info->VideoFrameDuration*
                                          framesskipped)/100);
              slibPinFinishReposition(Info, SLIB_DATA_AUDIO);
            }
          }
          return(status);
    case SLIB_SEEK_NEXT_KEY:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,NEXT_KEY,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if ((status=slibStartVideo(Info, FALSE))!=SlibErrorNone)
            return(status);
#ifdef MPEG_SUPPORT
          if (Info->Svh && SlibTypeIsMPEGVideo(Info->Type))
          {
            SvPictureInfo_t mpegPictureInfo;
            SlibTime_t vtime=Info->VideoTimeStamp;
            do {
              mpegPictureInfo.Type = SV_I_PICTURE;
              status = SvFindNextPicture(Info->Svh, &mpegPictureInfo);
              if (status==NoErrors && mpegPictureInfo.Type==SV_I_PICTURE)
              {
                if (Info->stats && Info->stats->Record)
                  Info->stats->FramesSkipped+=mpegPictureInfo.TemporalRef;
                if (vtime==Info->VideoTimeStamp)
                  /* timecode didn't update time */
                  slibAdvancePositions(Info, mpegPictureInfo.TemporalRef);
                vtime=Info->VideoTimeStamp;
                if (seekinfo)
                {
                  seekinfo->FramesSkipped+=mpegPictureInfo.TemporalRef;
                  seekinfo->VideoTimeStamp=Info->VideoTimeStamp;
                  seekinfo->AudioTimeStamp=Info->AudioTimeStamp;
                }
                return(SlibErrorNone);
              }
            } while (status==NoErrors);
            if (seekinfo)
            {
              seekinfo->VideoTimeStamp=Info->VideoTimeStamp;
              seekinfo->AudioTimeStamp=Info->AudioTimeStamp;
            }
            if (status==ScErrorEndBitstream)
            {
              if (Info->FileSize>0 && !Info->VideoLengthKnown)
                slibUpdateLengths(Info);
              return(SlibErrorEndOfStream);
            }
          }
          _SlibDebug(_WARN_, printf("SvFindNextPicture() %s\n",
                               ScGetErrorStr(status)) );
#endif /* MPEG_SUPPORT */
          /* do an absolute seek */
          status=SlibSeekEx(handle, stream, SLIB_SEEK_KEY,
              (Info->VideoStreams<=0?Info->AudioTimeStamp
                                    :Info->VideoTimeStamp)+1000,
              SLIB_UNIT_MS, seekinfo);
          return(status);
    case SLIB_SEEK_NEXT_SUBKEY:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,NEXT_SUBKEY,time=%d) VideoTime=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if ((status=slibStartVideo(Info, FALSE))!=SlibErrorNone)
            return(status);
#ifdef MPEG_SUPPORT
          if (Info->Svh && SlibTypeIsMPEGVideo(Info->Type))
          {
            SvPictureInfo_t mpegPictureInfo;
            unsigned char *videobuf;
            SlibTime_t vtime=Info->VideoTimeStamp;
            /* cannot skip I or B frames without decompressing them */
            if (SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_I ||
                SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_P)
            {
              _SlibDebug(_DEBUG_||_SEEK_, printf("SvDecompressMPEG()\n") );
              status = SvDecompressMPEG(Info->Svh, Info->Multibuf,
                                        Info->MultibufSize, &videobuf);
              if (vtime==Info->VideoTimeStamp  /* timecode didn't update time */
                  && status==SvErrorNone)
                slibAdvancePositions(Info, 1);
              vtime=Info->VideoTimeStamp;
              if (seekinfo)
                seekinfo->FramesSkipped+=mpegPictureInfo.TemporalRef;
              _SlibDebug(_WARN_ && status!=SvErrorNone,
                    printf("SvDecompressMPEG() %s\n", ScGetErrorStr(status)) );
            }
            do {
              mpegPictureInfo.Type = SV_I_PICTURE|SV_P_PICTURE;
              status = SvFindNextPicture(Info->Svh, &mpegPictureInfo);
              if (Info->stats && Info->stats->Record)
                Info->stats->FramesSkipped+=mpegPictureInfo.TemporalRef;
              if (vtime==Info->VideoTimeStamp) /* timecode didn't update time */
                slibAdvancePositions(Info, mpegPictureInfo.TemporalRef);
              vtime=Info->VideoTimeStamp;
              if (seekinfo)
                seekinfo->FramesSkipped+=mpegPictureInfo.TemporalRef;
              if (mpegPictureInfo.Type == SV_I_PICTURE ||
                  mpegPictureInfo.Type == SV_P_PICTURE)
              {
                /* found a subkey frame */
                if (seekinfo)
                {
                  seekinfo->VideoTimeStamp=Info->VideoTimeStamp;
                  seekinfo->AudioTimeStamp=Info->AudioTimeStamp;
                }
                return(SlibErrorNone);
              }
            } while(status==NoErrors);
            if (status==ScErrorEndBitstream)
            {
              if (Info->FileSize>0 && !Info->VideoLengthKnown)
                slibUpdateLengths(Info);
              if (seekinfo)
              {
                seekinfo->VideoTimeStamp=Info->VideoTimeStamp;
                seekinfo->AudioTimeStamp=Info->AudioTimeStamp;
              }
              return(SlibErrorEndOfStream);
            }
          }
          _SlibDebug(_WARN_, printf("SvFindNextPicture() %s\n",
                             ScGetErrorStr(status)) );
#endif /* MPEG_SUPPORT */
          /* do an absolute seek */
          status=SlibSeekEx(handle, stream, SLIB_SEEK_KEY,
              (Info->VideoStreams<=0?Info->AudioTimeStamp
                                    :Info->VideoTimeStamp)+500,
              SLIB_UNIT_MS, seekinfo);
          return(status);
    case SLIB_SEEK_KEY:
          _SlibDebug(_VERBOSE_||_SEEK_,
            printf("SlibSeekEx(stream=%d,KEY,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if (!Info->HeaderProcessed)
          {
            /* At very start of file we must Start the codecs since they
             * may need crucial header info
             */
            status=slibStartVideo(Info, FALSE);
            if (status!=SlibErrorNone) return(status);
          }
          if (Info->FileSize<=0)
            return(SlibErrorFileSize);
          if (seekpos!=0 && seekunits!=SLIB_UNIT_PERCENT100 &&
              (stream==SLIB_STREAM_MAINVIDEO || Info->AudioStreams==0) &&
               SlibTimeIsValid(Info->VideoTimeStamp))
          {
            /* see if we're already near the frame */
            timediff=seektime-Info->VideoTimeStamp;
            if (timediff>=-33 && timediff<=33)
              return(SlibErrorNone);
          }
          if ((seekunits==SLIB_UNIT_PERCENT100 && seekpos<=50)
                || seektime<=slibTimeToFrame(Info, 6))
          {
            /* close to beginning */
            if (seektime<=(Info->VideoFrameDuration*2)/100 &&
                  stream==SLIB_STREAM_MAINVIDEO) /* already close enough */
              return(SlibErrorNone);
seek_to_beginning:
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
              slibPinPrepareReposition(Info, SLIB_DATA_VIDEO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
              slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
              slibEmptyPin(Info, SLIB_DATA_VIDEO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
              slibEmptyPin(Info, SLIB_DATA_AUDIO);
            slibEmptyPin(Info, SLIB_DATA_COMPRESSED);
            if ((status=slibReposition(Info, 0))!=SlibErrorNone)
              return(status);
            Info->IOError=FALSE;
            Info->VideoTimeStamp = slibHasVideo(Info) ? 0 : SLIB_TIME_NONE;
            Info->AudioTimeStamp = slibHasAudio(Info) ? 0 : SLIB_TIME_NONE;
            return(SlibErrorNone);
          }
          else
          {
	    qword skippedframes=0;
            unsigned qword filepos;
            SlibTime_t vtime;
            const qword length=(Info->VideoStreams<=0) ? Info->AudioLength
                                                       : Info->VideoLength;
            if (seekunits==SLIB_UNIT_PERCENT100)
            {
              unsigned qword bytes_between_keys=Info->TotalBitRate/(8*2);
              filepos = (seekpos*Info->FileSize)/10000;
              /* seek a little before the desired point */
              if (bytes_between_keys>filepos)
                goto seek_to_beginning;
              else
                filepos-=bytes_between_keys;
            }
            else if (length==0)
              goto seek_to_beginning;
            else if (Info->FileSize<0x100000000)/* be careful of mul overflow */
              filepos = (seektime*Info->FileSize)/length;
            else
              filepos = ((seektime/100)*Info->FileSize)/(length/100);
seek_to_key:
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
              slibPinPrepareReposition(Info, SLIB_DATA_VIDEO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
              slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
              slibEmptyPin(Info, SLIB_DATA_VIDEO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
              slibEmptyPin(Info, SLIB_DATA_AUDIO);
            slibEmptyPin(Info, SLIB_DATA_COMPRESSED);
            if ((status=slibReposition(Info, filepos))!=SlibErrorNone)
              return(status);
            Info->IOError=FALSE;
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
              slibPinFinishReposition(Info, SLIB_DATA_VIDEO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
              slibPinFinishReposition(Info, SLIB_DATA_AUDIO);
            vtime=Info->VideoTimeStamp;
#ifdef MPEG_SUPPORT
            if (Info->Svh && SlibTypeIsMPEGVideo(Info->Type))
            {
              SvPictureInfo_t mpegPictureInfo;
              if ((status=slibStartVideo(Info, FALSE))!=SlibErrorNone)
                return(status);
              mpegPictureInfo.Type = SV_I_PICTURE;
              status = SvFindNextPicture(Info->Svh, &mpegPictureInfo);
              _SlibDebug(_WARN_ && status!=NoErrors,
                            printf("SvFindNextPicture() %s\n",
                              ScGetErrorStr(status)) );
              if (status!=NoErrors)
                return(SlibErrorEndOfStream);
              skippedframes=mpegPictureInfo.TemporalRef;
            }
#endif /* MPEG_SUPPORT */
            if (seekunits==SLIB_UNIT_PERCENT100)
            {
              /* See if we seeked to far ahead */
              SlibPosition_t posdiff=
                SlibGetParamInt(Info, SLIB_STREAM_ALL, SLIB_PARAM_PERCENT100)
                  -seekpos;
              if (filepos>0 && posdiff>0 && tries<2)
              {
                tries++;
                /* we're ahead by one percent or more */
                /* move filepos back in the proportion that we're off by */
                filepos-=(posdiff*Info->FileSize)/8000;
                if (filepos<0)
                  goto seek_to_beginning;
                goto seek_to_key;
              }
            }
            if (slibUpdatePositions(Info, FALSE)) /* timecoded */
            {
              /* timecoded */
              /*
               * See if we seeked to far ahead
               * Note: if times are way off then we should ignore them.
               */
              if (seekunits==SLIB_UNIT_PERCENT100) /* ignore times */
                timediff=0;
              else
              {
                timediff=seektime-Info->VideoTimeStamp;
                if (timediff>-5000 && timediff<-100 && tries<3)
                {
                  /* move filepos back in the proportion that we're off by */
                  filepos=(filepos*seektime)/Info->VideoTimeStamp;
                  if (filepos<0)
                    filepos=0;
                  tries++;
                  goto seek_to_key;
                }
              }
#ifdef MPEG_SUPPORT
              if (Info->Svh && SlibTypeIsMPEGVideo(Info->Type))
              {
                SvPictureInfo_t mpegPictureInfo;
                mpegPictureInfo.Type = SV_I_PICTURE;
                while (timediff>Info->VideoFrameDuration/100 &&status==NoErrors)
                {
                  _SlibDebug(_SEEK_>1,
                     printf("SlibSeekEx(KEY, %d) Find next I frame (%d/%d)\n",
                      seektime, SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE),
                      Info->VideoTimeStamp) );
                  status = SvFindNextPicture(Info->Svh, &mpegPictureInfo);
                  _SlibDebug(_WARN_ && status!=NoErrors,
                    printf("SvFindNextPicture() %s\n", ScGetErrorStr(status)) );
                  skippedframes+=mpegPictureInfo.TemporalRef;
                  if (vtime==Info->VideoTimeStamp)
                    /* timecode didn't update time */
                    slibAdvancePositions(Info, mpegPictureInfo.TemporalRef);
                  vtime=Info->VideoTimeStamp;
                  timediff=seektime-Info->VideoTimeStamp;
                }
              }
#endif /* MPEG_SUPPORT */
            }
            else
            {
              _SlibDebug(_SEEK_, printf("SlibSeekEx(KEY, %d) no timecode\n",
                                       seektime) );
              if (slibHasVideo(Info))
              {
                Info->VideoTimeStamp=seektime;
                Info->VideoFramesProcessed=slibTimeToFrame(Info, seektime);
              }
              if (slibHasAudio(Info))
                Info->AudioTimeStamp=seektime;
              slibAdvancePositions(Info, skippedframes);
              timediff=seektime-Info->VideoTimeStamp;
            }
            if (Info->stats && Info->stats->Record)
              Info->stats->FramesSkipped+=skippedframes;
            if (seekinfo) seekinfo->FramesSkipped=skippedframes;
#if 0
            if (Info->Svh)
              Info->FramesPerSec=SvGetParamFloat(Info->Svh, SV_PARAM_FPS);
#endif
            /* if we skipped some frames, skip some audio too */
            if (skippedframes>5 && stream==SLIB_STREAM_ALL && slibHasAudio(Info))
            {
              slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
              slibSkipAudio(Info, stream, (Info->VideoFrameDuration*
                                          skippedframes)/100);
              slibPinFinishReposition(Info, SLIB_DATA_AUDIO);
              if (SlibTimeIsInValid(Info->AudioTimeStamp))
              {
                Info->AudioTimeStamp=slibGetNextTimeOnPin(Info, slibGetPin(Info, SLIB_DATA_AUDIO), 100*1024);
                if (SlibTimeIsInValid(Info->AudioTimeStamp))
                  Info->AudioTimeStamp=Info->VideoTimeStamp;
                else
                  Info->AudioTimeStamp-=Info->AudioPTimeBase;
              }
            }
            if (status==ScErrorEndBitstream)
            {
              if (Info->FileSize>0 && !Info->VideoLengthKnown)
                slibUpdateLengths(Info);
              return(SlibErrorEndOfStream);
            }
            else if (status!=NoErrors)
              return(SlibErrorReading);
            return(SlibErrorNone);
          }
          break;
    case SLIB_SEEK_RESET:
          _SlibDebug(_VERBOSE_||_SEEK_,
            printf("SlibSeekEx(stream=%d,RESET,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
            slibPinPrepareReposition(Info, SLIB_DATA_VIDEO);
          if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
            slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
          if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
            slibEmptyPin(Info, SLIB_DATA_VIDEO);
          if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
            slibEmptyPin(Info, SLIB_DATA_AUDIO);
          if (stream==SLIB_STREAM_MAINAUDIO)
            slibPinFinishReposition(Info, SLIB_DATA_AUDIO);
          if (stream==SLIB_STREAM_ALL)
          {
            slibEmptyPin(Info, SLIB_DATA_COMPRESSED);
            Info->BytesProcessed = 0;
          }
          Info->HeaderProcessed = FALSE;
          return(SlibErrorNone);
      case SLIB_SEEK_RESYNC:
          seekpos=SlibGetParamInt(Info, SLIB_STREAM_ALL, SLIB_PARAM_PERCENT100);
          if (seekpos<0 ||
              (SlibTimeIsValid(Info->VideoTimeStamp) &&
               Info->VideoTimeStamp<slibFrameToTime(Info, 6)))
            seekpos=0;
          _SlibDebug(_VERBOSE_||_SEEK_,
             printf("SlibSeekEx(stream=%d,RESYNC) seekpos=%ld\n",
                        stream, seekpos) );
          return(SlibSeekEx(handle, SLIB_STREAM_ALL, SLIB_SEEK_KEY, seekpos,
                             SLIB_UNIT_PERCENT100, seekinfo));
      default:
          _SlibDebug(_VERBOSE_||_SEEK_||_WARN_,
             printf("SlibSeekEx(stream=%d,seektype=%d,time=%d) VideoTimeStamp=%ld Bad seek type\n",
                        stream,seektype,seektime,Info->VideoTimeStamp) );
  }
  return(SlibErrorForwardOnly);
}


SlibList_t *SlibQueryList(SlibQueryType_t qtype)
{
  switch(qtype)
  {
    case SLIB_QUERY_TYPES:        return(_listTypes);
    case SLIB_QUERY_COMP_TYPES:   return(_listCompressTypes);
    case SLIB_QUERY_DECOMP_TYPES: return(_listDecompressTypes);
    case SLIB_QUERY_ERRORS:       return(_listErrors);
    default:                      return(NULL);
  }
}

char *SlibQueryForDesc(SlibQueryType_t qtype, int enumval)
{
  SlibList_t *entry=SlibQueryList(qtype);
  if (entry)
    entry=SlibFindEnumEntry(entry, enumval);
  if (entry)
    return(entry->Desc);
  else
    return(NULL);
}

int SlibQueryForEnum(SlibQueryType_t qtype, char *name)
{
  SlibList_t *list=SlibQueryList(qtype);
  if (!list)
    return(-1);
  while (list->Name)
  {
    if (strcmp(list->Name, name)==0)
      return(list->Enum);
    list++;
  }
  return(-1);
}

SlibBoolean_t SlibIsEnd(SlibHandle_t handle, SlibStream_t stream)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibBoolean_t isend=FALSE;
  if (!handle)
    isend=TRUE;
  else if (stream==SLIB_STREAM_MAINAUDIO)
  {
    isend=SlibPeekBuffer(Info, SLIB_DATA_AUDIO, NULL, NULL)==NULL?TRUE:FALSE;
    if (isend && Info->Sah) /* see if the audio codec still has data */
    {
      ScBitstream_t *bs=SaGetDataSource(Info->Sah);
      if (bs && !bs->EOI) isend=FALSE;
    }
  }
  else if (stream==SLIB_STREAM_MAINVIDEO)
  {
    isend=SlibPeekBuffer(Info, SLIB_DATA_VIDEO, NULL, NULL)==NULL?TRUE:FALSE;
    if (isend && Info->Svh) /* see if the video codec still has data */
    {
      ScBitstream_t *bs=SvGetDataSource(Info->Svh);
      if (bs && !bs->EOI) isend=FALSE;
    }
  }
  else if (SlibPeekBuffer(Info, SLIB_DATA_AUDIO, NULL, NULL)==NULL &&
           SlibPeekBuffer(Info, SLIB_DATA_VIDEO, NULL, NULL)==NULL &&
           SlibPeekBuffer(Info, SLIB_DATA_COMPRESSED, NULL, NULL)==NULL)
  {
    ScBitstream_t *bs;
    isend=TRUE;
    if (Info->Svh) /* see if the video codec still has data */
    {
      bs=SvGetDataSource(Info->Svh);
      if (bs && !bs->EOI) isend=FALSE;
    }
    if (isend && Info->Sah) /* see if the audio codec still has data */
    {
      bs=SaGetDataSource(Info->Sah);
      if (bs && !bs->EOI) isend=FALSE;
    }
  }
  _SlibDebug(_VERBOSE_,
      printf("SlibIsEnd() %s\n",isend?"TRUE":"FALSE"));
  return(isend);
}

SlibStatus_t SlibClose(SlibHandle_t handle)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  _SlibDebug(_DEBUG_, printf("SlibClose\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  /* close video codec */
  if (Info->Svh)
  {
    if (Info->VideoCodecState==SLIB_CODEC_STATE_BEGUN)
    {
      _SlibDebug(_DEBUG_, printf("SvDecompress/CompressEnd()\n") );
      if (Info->Mode==SLIB_MODE_DECOMPRESS)
        SvDecompressEnd(Info->Svh);
      else if (Info->Mode==SLIB_MODE_COMPRESS)
        SvCompressEnd(Info->Svh);
      Info->VideoCodecState=SLIB_CODEC_STATE_INITED;
    }
    _SlibDebug(_DEBUG_, printf("SvCloseCodec()\n") );
    SvCloseCodec(Info->Svh);
  }
  Info->VideoCodecState=SLIB_CODEC_STATE_NONE;
  /* close audio codec */
  if (Info->Sah)
  {
    if (Info->AudioCodecState==SLIB_CODEC_STATE_BEGUN)
    {
      if (Info->Mode==SLIB_MODE_DECOMPRESS)
        SaDecompressEnd(Info->Sah);
      else if (Info->Mode==SLIB_MODE_COMPRESS)
        SaCompressEnd(Info->Sah);
      Info->AudioCodecState=SLIB_CODEC_STATE_INITED;
    }
    _SlibDebug(_DEBUG_, printf("SaCloseCodec()\n") );
    SaCloseCodec(Info->Sah);
  }
  Info->AudioCodecState=SLIB_CODEC_STATE_NONE;
  if (Info->Mode==SLIB_MODE_COMPRESS && Info->HeaderProcessed)
    slibCommitBuffers(Info, TRUE);
  /* close format converter */
  if (Info->Sch)
  {
    SconClose(Info->Sch);
    Info->Sch=NULL;
  }
  /* close data sources */
  if (Info->Fd>=0)
  {
    _SlibDebug(_DEBUG_, printf("ScFileClose(%d)\n",Info->Fd) );
    ScFileClose(Info->Fd);
    Info->Fd=-1;
  }
  slibRemovePins(Info);
  /* slibDumpMemory(); */
  if (Info->SlibCB)
  {
    SlibMessage_t result;
    _SlibDebug(_VERBOSE_,
      printf("SlibClose() SlibCB(SLIB_MSG_CLOSE)\n") );
    result=(*(Info->SlibCB))((SlibHandle_t)Info,
                        SLIB_MSG_CLOSE, (SlibCBParam1_t)0,
                      (SlibCBParam2_t)0, (void *)Info->SlibCBUserData);
    Info->SlibCB=NULL;
  }
  /* free memory */
  if (Info->stats)  ScFree(Info->stats);
  if (Info->CompVideoFormat) ScFree(Info->CompVideoFormat);
  if (Info->CodecVideoFormat) ScFree(Info->CodecVideoFormat);
  if (Info->VideoFormat)  ScFree(Info->VideoFormat);
  if (Info->AudioFormat) ScFree(Info->AudioFormat);
  if (Info->CompAudioFormat) ScFree(Info->CompAudioFormat);
  if (Info->Imagebuf) SlibFreeBuffer(Info->Imagebuf);
  if (Info->CodecImagebuf) SlibFreeBuffer(Info->CodecImagebuf);
  if (Info->IntImagebuf) SlibFreeBuffer(Info->IntImagebuf);
  if (Info->Audiobuf) SlibFreeBuffer(Info->Audiobuf);
  if (Info->Multibuf) /* free all outstanding allocations on Multibuf */
    while (SlibFreeBuffer(Info->Multibuf)==SlibErrorNone);
  ScFree(Info);
  _SlibDebug(_WARN_ && SlibMemUsed()>0, printf("SlibClose() mem used=%d\n",
                     SlibMemUsed()) );
  return(SlibErrorNone);
}

/*
SlibStatus_t SlibGetInfo(SlibHandle_t handle, SlibInfo_t *info)
{
  if (!handle)
    return(SlibErrorBadHandle);
  if (!info)
    return(SlibErrorBadArgument);
  memcpy(info, handle, sizeof(SlibInfo_t));
  return(SlibErrorNone);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\coder.h ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//

extern void  Init_Coder(CODDEF *CodStat);
extern Flag  Coder(float *DataBuff, Word32 *Vout,CODDEF  *CodStat,
  int quality, int UseCpuId, int UseMMX);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\decod.h ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//


extern void  Init_Decod(DECDEF *DecStat);

//Changed in v4.0f
extern Flag  Decod( float *DataBuff, Word32 *Vinp , Word16 Crc, DECDEF *DecStat);
//extern Flag  Decod( float *DataBuff, char *Vinp , Word16 Crc, DECDEF *DecStat);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//      This file contains definitions for DEBUG builds; all debugging
//      instructions are #define-d to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//
//
//
#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for 
    #define DEBUG_MODULE_NAME   "MSG7231"  // key name and prefix for output
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef _WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgGetLevel(void);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI _Assert( char * szFile, int iLine );

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPF         dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
    #define ASSERT(x)   if( !(x) )  _Assert( __FILE__, __LINE__)
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPF()
    #define DPI(sz)
    #define ASSERT(x)
#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\decod.c ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//
#include "timer.h"
#include "ctiming.h"
#include "opt.h"
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>
#include "typedef.h"
#include "cst_lbc.h"
#include "tab_lbc.h"
#include "decod.h"
#include "util_lbc.h"
#include "lpc.h"
#include "lsp.h"
#include "exc_lbc.h"

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
#pragma message ("Current log decode timing computations handle 2057 frames max")
void OutputDecodeTimingStatistics(char * szFileName, DEC_TIMING_INFO * pDecTimingInfo, unsigned long dwFrameCount);
void OutputDecTimingDetail(FILE * pFile, DEC_TIMING_INFO * pDecTimingInfo);
#endif // } LOG_DECODE_TIMINGS_ON

//  This file includes the decoder main functions


//--------------------------------------------------
void  Init_Decod(DECDEF *DecStat)
{
  int  i;

// Init prev Lsp to Dc
  for (i = 0; i < LpcOrder; i++)
    DecStat->dPrevLsp[i] = LspDcTable[i];

  DecStat->dp = 9;
  DecStat->dq = 9;	
 
}

//--------------------------------------------------
Flag  Decod(float *DataBuff, Word32 *Vinp, Word16 Crc, DECDEF *DecStat)
{
	int		i,j,g;

	float	QntLpc[SubFrames*LpcOrder];
	float	AcbkCont[SubFrLen];

	float	LspVect[LpcOrder];
	float	Temp[PitchMax+Frame];
	float	*Dpnt;

	LINEDEF	Line;

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	unsigned long dwStartLow;
	unsigned long dwStartHigh;
	unsigned long dwElapsed;
	unsigned long dwBefore;
	unsigned long dwDecode = 0;
	int bTimingThisFrame = 0;
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	unsigned long dwLine_Unpk = 0;
	unsigned long dwLsp_Inq = 0;
	unsigned long dwLsp_Int = 0;
	unsigned long dwVariousD = 0;
	unsigned long dwFcbk_UnpkD = 0;
	unsigned long dwDecod_AcbkD = 0;
	unsigned long dwComp_Info = 0;
	unsigned long dwRegen = 0;
	unsigned long dwSynt = 0;
	unsigned long dwFcbk_UnpkDTemp = 0;
	unsigned long dwDecod_AcbkDTemp = 0;
	unsigned long dwSyntTemp = 0;
#endif // } DETAILED_DECODE_TIMINGS_ON
#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	DEC_TIMING_INFO * pDecTimingInfo = NULL;
#endif // } LOG_DECODE_TIMINGS_ON

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	TIMER_START(bTimingThisFrame,dwStartLow,dwStartHigh);
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	if (DecStat->dwStatFrameCount < DEC_TIMING_INFO_FRAME_COUNT)
	{
		DecStat->dwStartLow = dwStartLow;
		DecStat->dwStartHigh = dwStartHigh;
	}
	DecStat->bTimingThisFrame = bTimingThisFrame;
#endif // } LOG_DECODE_TIMINGS_ON

	// Unpack the Line info
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

	Line_Unpk(&Line, Vinp, &DecStat->WrkRate, Crc);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwLine_Unpk);
#endif // } DETAILED_DECODE_TIMINGS_ON

	if(DecStat->WrkRate == Silent) {
		//HACK: For handling SID frames.
		//Until comfort noise generator is in place, we play
		//	out random noise frames.
		//In Line_unpck, reset WrkRate to original setting
		//	and decode.  We therefore should never reach this point.
		memset(DataBuff, 0, sizeof(float) * Frame);
		//exit having filled frame with zeros leave state alone
		//this will be fixed up in a later ITU release
		return (Flag) False; 
	}
	else if(DecStat->WrkRate == Lost) {
		Line.Crc = !0;
	}
/*
  Line.Crc equals one means that the line was corrupted. It shouldn't
  be reassigned. Otherwise, member of Line will be used uninitialized.
  Comment out the following two lines.                muhan, 5/26/98

  else {
    Line.Crc = Crc;
  }
*/
	if (Line.Crc != 0)
		DecStat->Ecount++;
	else
		DecStat->Ecount = 0;

	if (DecStat->Ecount >  ErrMaxNum)
		DecStat->Ecount = ErrMaxNum;

	// Inverse quantization of the LSP
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

	Lsp_Inq(LspVect, DecStat->dPrevLsp, Line.LspId, Line.Crc);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwLsp_Inq);
#endif // } DETAILED_DECODE_TIMINGS_ON

	// Interpolate the Lsp vectors
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

	Lsp_Int(QntLpc, LspVect, DecStat->dPrevLsp);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwLsp_Int);
#endif // } DETAILED_DECODE_TIMINGS_ON

	/* Copy the LSP vector for the next frame */
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

	for ( i = 0 ; i < LpcOrder ; i ++ )
		DecStat->dPrevLsp[i] = LspVect[i] ;

	/* 
	 * In case of no erasure, update the interpolation gain memory.
	 * Otherwise compute the interpolation gain (Text: Section 3.10)
	 */

	if (DecStat->Ecount == 0)
	{
		g = (Line.Sfs[SubFrames-2].Mamp + Line.Sfs[SubFrames-1].Mamp) >> 1;
		DecStat->InterGain = FcbkGainTable[g];
	}
	else
		DecStat->InterGain = DecStat->InterGain*0.75f;

	// Regenerate the excitation
	for (i = 0; i < PitchMax; i++)
		Temp[i] = DecStat->dPrevExc[i];

	Dpnt = &Temp[PitchMax];

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwVariousD);
#endif // } DETAILED_DECODE_TIMINGS_ON

	if (DecStat->Ecount == 0)
	{
		for (i = 0; i < SubFrames; i++)
		{
			// Unpack fixed code book
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

			Fcbk_Unpk(Dpnt, Line.Sfs[i], Line.Olp[i>>1], i, DecStat->WrkRate);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwFcbk_UnpkDTemp);
#endif // } DETAILED_DECODE_TIMINGS_ON

			// Reconstruct the excitation
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

			Decod_Acbk(AcbkCont, &Temp[SubFrLen*i], Line.Olp[i>>1],
			Line.Sfs[i].AcLg, Line.Sfs[i].AcGn, DecStat->WrkRate);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwDecod_AcbkDTemp);
#endif // } DETAILED_DECODE_TIMINGS_ON

			for (j = 0; j < SubFrLen; j++)
				Dpnt[j] = Dpnt[j]*2.0f + AcbkCont[j];

			Dpnt += SubFrLen;

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
			// Cumulate stats
			dwFcbk_UnpkD += dwFcbk_UnpkDTemp; dwFcbk_UnpkDTemp = 0;
			dwDecod_AcbkD+= dwDecod_AcbkDTemp; dwDecod_AcbkDTemp = 0;
#endif // } DETAILED_DECODE_TIMINGS_ON
		}

		// Save the Excitation
		for (j = 0; j < Frame; j++)
			DataBuff[j] = Temp[PitchMax+j];

		// Compute interpolation index, for future use in frame erasures
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

		DecStat->InterIndx = Comp_Info(Temp, Line.Olp[SubFrames/2-1]);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwComp_Info);
#endif // } DETAILED_DECODE_TIMINGS_ON

		// Reload back
		for (j = 0; j < PitchMax; j++)
			Temp[j] = DecStat->dPrevExc[j];
		for (j = 0; j < Frame; j++)
			Temp[PitchMax+j] = DataBuff[j];

#if 1 //do clipping
		/* Clip newly generated samples in Temp array */
		for(j = 0; j < Frame; j++)
		{
			//clip to +/- 32767.0 doing abs & compare with integer unit
			//if clipping is needed shift sign bit to use as lookup table index
#define FLTCLIP(x) \
			{\
			const float T[2] = {32767.0f, -32767.0f};\
			if ((asint(x) & 0x7fffffff) > asint(T[0]))\
			x = T[((unsigned)asint(x)) >> 31];\
			}

			FLTCLIP(Temp[PitchMax+j]);
		}
#endif //optclip
	}
	else
	{
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

		Regen(DataBuff, Temp, DecStat->InterIndx, DecStat->InterGain,
				DecStat->Ecount, &DecStat->Rseed);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwRegen);
#endif // } DETAILED_DECODE_TIMINGS_ON
	}

	// Update PrevExc for next frame
	for (j = 0; j < PitchMax; j++)
		DecStat->dPrevExc[j] = Temp[Frame+j];

	// Synthesis
	Dpnt = DataBuff;
	for (i = 0; i < SubFrames; i++)
	{
		// Synthesize output speech
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		TIMER_BEFORE(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore);
#endif // } DETAILED_DECODE_TIMINGS_ON

		Synt(Dpnt, &QntLpc[i*LpcOrder], DecStat);

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		TIMER_AFTER_P5(bTimingThisFrame,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwSyntTemp);
#endif // } DETAILED_DECODE_TIMINGS_ON

		Dpnt += SubFrLen;

#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		// Cumulate stats
		dwSynt += dwSyntTemp; dwSyntTemp = 0;
#endif // } DETAILED_DECODE_TIMINGS_ON
	}

#if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON) // { #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)
	TIMER_STOP(bTimingThisFrame,dwStartLow,dwStartHigh,dwDecode);
#endif // } DECODE_TIMINGS_ON

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	if (bTimingThisFrame && (DecStat->dwStatFrameCount < DEC_TIMING_INFO_FRAME_COUNT))
	{
		pDecTimingInfo = &DecStat->DecTimingInfo[DecStat->dwStatFrameCount];
		pDecTimingInfo->dwDecode		= dwDecode;
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		pDecTimingInfo->dwLine_Unpk		= dwLine_Unpk;
		pDecTimingInfo->dwLsp_Inq		= dwLsp_Inq;
		pDecTimingInfo->dwLsp_Int		= dwLsp_Int;
		pDecTimingInfo->dwVariousD		= dwVariousD;
		pDecTimingInfo->dwFcbk_UnpkD	= dwFcbk_UnpkD;
		pDecTimingInfo->dwDecod_AcbkD	= dwDecod_AcbkD;
		pDecTimingInfo->dwComp_Info		= dwComp_Info;
		pDecTimingInfo->dwRegen			= dwRegen;
		pDecTimingInfo->dwSynt			= dwSynt;
#endif // } DETAILED_DECODE_TIMINGS_ON
		DecStat->dwStatFrameCount++;
	}
	else
	{
		_asm int 3;
	}
#endif // } #if defined(DECODE_TIMINGS_ON) || defined(DETAILED_DECODE_TIMINGS_ON)

	return (Flag) True;
}

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
void OutputDecodeTimingStatistics(char * szFileName, DEC_TIMING_INFO * pDecTimingInfo, unsigned long dwFrameCount)
{
    FILE * pFile;
	DEC_TIMING_INFO * pTempDecTimingInfo;
	DEC_TIMING_INFO dtiTemp;
	int i;
	int iCount;

	pFile = fopen(szFileName, "a");
	if (pFile == NULL)
	    goto done;

#if 0
	// Too verbose !!!
	/* Output the detail information
	*/
	fprintf(pFile,"\nDetail Timing Information\n");
	for ( i = 0, pTempDecTimingInfo = pDecTimingInfo ; i < dwFrameCount ; i++, pTempDecTimingInfo++ )
	{
		fprintf(pFile, "Frame %d Detail Timing Information\n", i);
		OutputDecTimingDetail(pFile, pTempDecTimingInfo);
	}
#endif

	/* Compute the total information
	*/
	memset(&dtiTemp, 0, sizeof(DEC_TIMING_INFO));
	iCount = 0;

	for ( i = 0, pTempDecTimingInfo = pDecTimingInfo ; i < dwFrameCount ; i++, pTempDecTimingInfo++ )
	{
		iCount++;
		dtiTemp.dwDecode		+= pTempDecTimingInfo->dwDecode;
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		dtiTemp.dwLine_Unpk		+= pTempDecTimingInfo->dwLine_Unpk;
		dtiTemp.dwLsp_Inq		+= pTempDecTimingInfo->dwLsp_Inq;
		dtiTemp.dwLsp_Int		+= pTempDecTimingInfo->dwLsp_Int;
		dtiTemp.dwVariousD		+= pTempDecTimingInfo->dwVariousD;
		dtiTemp.dwFcbk_UnpkD	+= pTempDecTimingInfo->dwFcbk_UnpkD;
		dtiTemp.dwDecod_AcbkD	+= pTempDecTimingInfo->dwDecod_AcbkD;
		dtiTemp.dwComp_Info		+= pTempDecTimingInfo->dwComp_Info;
		dtiTemp.dwRegen			+= pTempDecTimingInfo->dwRegen;
		dtiTemp.dwSynt			+= pTempDecTimingInfo->dwSynt;
#endif // } DETAILED_DECODE_TIMINGS_ON
	}

	if (iCount > 0) 
	{
		/* Output the total information
		*/
		fprintf(pFile,"Total for %d frames\n", iCount);
		OutputDecTimingDetail(pFile, &dtiTemp);

		/* Compute the average
		*/
		dtiTemp.dwDecode		= (dtiTemp.dwDecode + (iCount / 2)) / iCount;
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
		dtiTemp.dwLine_Unpk		= (dtiTemp.dwLine_Unpk + (iCount / 2)) / iCount;
		dtiTemp.dwLsp_Inq		= (dtiTemp.dwLsp_Inq + (iCount / 2)) / iCount;
		dtiTemp.dwLsp_Int		= (dtiTemp.dwLsp_Int + (iCount / 2)) / iCount;
		dtiTemp.dwVariousD		= (dtiTemp.dwVariousD + (iCount / 2)) / iCount;
		dtiTemp.dwFcbk_UnpkD	= (dtiTemp.dwFcbk_UnpkD + (iCount / 2)) / iCount;
		dtiTemp.dwDecod_AcbkD	= (dtiTemp.dwDecod_AcbkD + (iCount / 2)) / iCount;
		dtiTemp.dwComp_Info		= (dtiTemp.dwComp_Info + (iCount / 2)) / iCount;
		dtiTemp.dwRegen			= (dtiTemp.dwRegen + (iCount / 2)) / iCount;
		dtiTemp.dwSynt			= (dtiTemp.dwSynt + (iCount / 2)) / iCount;
#endif // } DETAILED_DECODE_TIMINGS_ON

		/* Output the average information
		*/
		fprintf(pFile,"Average over %d frames\n", iCount);
		OutputDecTimingDetail(pFile, &dtiTemp);
	}

	fclose(pFile);
done:

    return;
}

void OutputDecTimingDetail(FILE * pFile, DEC_TIMING_INFO * pDecTimingInfo)
{
	unsigned long dwOther;
	unsigned long dwRoundUp;
	unsigned long dwDivisor;

	fprintf(pFile, "\tDecode =      %10u (%d milliseconds at 166Mhz)\n", pDecTimingInfo->dwDecode,
			(pDecTimingInfo->dwDecode + 83000) / 166000);
	dwOther = pDecTimingInfo->dwDecode;
	
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	/* This is needed because of the integer truncation.
	 */
	dwDivisor = pDecTimingInfo->dwDecode / 100; // to yield a percent
	dwRoundUp = dwDivisor / 2;
	
	if (dwDivisor)
	{
		fprintf(pFile, "\tLine_Unpk =   %10u (%2d%%)\n", pDecTimingInfo->dwLine_Unpk, 
				(pDecTimingInfo->dwLine_Unpk + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwLine_Unpk;
									   
		fprintf(pFile, "\tLsp_Inq =     %10u (%2d%%)\n", pDecTimingInfo->dwLsp_Inq, 
				(pDecTimingInfo->dwLsp_Inq + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwLsp_Inq;
									   
		fprintf(pFile, "\tLsp_Int =     %10u (%2d%%)\n", pDecTimingInfo->dwLsp_Int, 
				(pDecTimingInfo->dwLsp_Int + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwLsp_Int;
									   
		fprintf(pFile, "\tVariousD =    %10u (%2d%%)\n", pDecTimingInfo->dwVariousD, 
				(pDecTimingInfo->dwVariousD + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwVariousD;
									   
		fprintf(pFile, "\tFcbk_UnpkD =  %10u (%2d%%)\n", pDecTimingInfo->dwFcbk_UnpkD, 
				(pDecTimingInfo->dwFcbk_UnpkD + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwFcbk_UnpkD;
									   
		fprintf(pFile, "\tDecod_AcbkD = %10u (%2d%%)\n", pDecTimingInfo->dwDecod_AcbkD, 
				(pDecTimingInfo->dwDecod_AcbkD + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwDecod_AcbkD;
									   
		fprintf(pFile, "\tComp_Info =   %10u (%2d%%)\n", pDecTimingInfo->dwComp_Info, 
				(pDecTimingInfo->dwComp_Info + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwComp_Info;
									   
		fprintf(pFile, "\tRegen =       %10u (%2d%%)\n", pDecTimingInfo->dwRegen, 
				(pDecTimingInfo->dwRegen + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwRegen;
									   
		fprintf(pFile, "\tSynt =        %10u (%2d%%)\n", pDecTimingInfo->dwSynt, 
				(pDecTimingInfo->dwSynt + dwRoundUp) / dwDivisor);
		dwOther -= pDecTimingInfo->dwSynt;
									   
		fprintf(pFile, "\tOther =       %10u (%2d%%)\n", dwOther, 
				(dwOther + dwRoundUp) / dwDivisor);
	}
#endif // } DETAILED_DECODE_TIMINGS_ON

}
#endif // { LOG_DECODE_TIMINGS_ON
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\cst_lbc.h ===
/*
**
** File:        "cst_lbc.h"
**
** Description:  This file contains global definition of the SG15
**    LBC Coder for 6.3/5.3 kbps.
**
*/

/*
  	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 3.01

    Original fixed-point code copyright (c) 1995,
    AudioCodes, DSP Group, France Telecom, Universite de Sherbrooke.
    All rights reserved.

    Floating-point code copyright (c) 1995,
    Intel Corporation and France Telecom (CNET).
    All rights reserved.
*/

/*
   This file contains global definition of the SG15
      LBR Coder for 6.4/5.3 kbps.
*/
#include "typedef.h"
#define  False 0
#define  True  1
//#if NOTMINI
#define  FALSE 0
#define  TRUE  1
//#endif

/* Definition of the working mode */
enum  Wmode { Both, Cod, Dec } ;

/* Coder rate */
//enum  Crate    { Silent, Rate53, Rate63, Lost } ;
/* Changed in V4.1 */
enum  Crate    { Rate63, Rate53, Silent, Lost } ;


/* Coder global constants */
#define  Frame       240
#define  LpcFrame    180
#define  SubFrames   4
#define  SubFrLen    (Frame/SubFrames)

#define  LpcOrder          10
#define  RidgeFact         10
#define  CosineTableSize   512
#define  PreCoef           -0.25f

#define  LspPrd0           12288
#define  LspPrd1           23552

#define  LspPred0          (12.0f/32.0f)
#define  LspPred1          (23.0f/32.0f)

#define  LspQntBands       3
#define  LspCbSize         256
#define  LspCbBits         8

#define  PitchMin          18
#define  PitchMax          (PitchMin+127) 
#define PwRange            3
#define  ClPitchOrd        5
#define  Pstep             1

#define NbFilt085           85
#define NbFilt170           170

#define  Sgrid             2
#define  MaxPulseNum       6
#define  MlqSteps     	   2
/* acelp constants */
#define SubFrLen2    (SubFrLen +4)
#define DIM_RR   416
#define NB_POS   8
#define STEP     8
#define MSIZE    64
#define threshold  0.5f
#define max_time   120

#define  NumOfGainLev      24

#define  ErrMaxNum         3

/* Taming constants */
#define NbFilt085_min       51
#define NbFilt170_min       93
#define SizErr              5
#define Err0                0.00000381464f
#define ThreshErr           128.0f

#define SRCSTATELEN         16   // sample rate conversion state length

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
/* Encoder Timing Data - per frame
*/
typedef struct {
	unsigned long dwEncode;
#ifdef DETAILED_ENCODE_TIMINGS_ON // { DETAILED_ENCODE_TIMINGS_ON
	unsigned long dwRem_Dc;
	unsigned long dwComp_Lpc;
	unsigned long dwAtoLsp;
	unsigned long dwLsp_Qnt;
	unsigned long dwLsp_Inq;
	unsigned long dwLsp_Int;
	unsigned long dwMem_Shift;
	unsigned long dwWght_Lpc;
	unsigned long dwError_Wght;
	unsigned long dwFew_Lps_In_Coder;
	unsigned long dwFilt_Pw;
	unsigned long dwComp_Ir;
	unsigned long dwSub_Ring;
	unsigned long dwFind_Acbk;
	unsigned long dwFind_Fcbk;
	unsigned long dwDecode_Acbk;
	unsigned long dwReconstr_Excit;
	unsigned long dwUpd_Ring;
	unsigned long dwLine_Pack;
#endif // } DETAILED_ENCODE_TIMINGS_ON
} ENC_TIMING_INFO;
// 2057 frames will allow us to store stats
// for all of our Geo08kHz16BitMonoPCM.wav
// test file...
#define ENC_TIMING_INFO_FRAME_COUNT 2057
#endif // } LOG_ENCODE_TIMINGS_ON

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
/* Encoder Timing Data - per frame
*/
typedef struct {
	unsigned long dwDecode;
#ifdef DETAILED_DECODE_TIMINGS_ON // { DETAILED_DECODE_TIMINGS_ON
	unsigned long dwLine_Unpk;
	unsigned long dwLsp_Inq;
	unsigned long dwLsp_Int;
	unsigned long dwVariousD;
	unsigned long dwFcbk_UnpkD;
	unsigned long dwDecod_AcbkD;
	unsigned long dwComp_Info;
	unsigned long dwRegen;
	unsigned long dwSynt;
#endif // } DETAILED_DECODE_TIMINGS_ON
} DEC_TIMING_INFO;
// 2057 frames will allow us to store stats
// for all of our Geo08kHz16BitMonoPCM.wav
// test file...
#define DEC_TIMING_INFO_FRAME_COUNT 2057
#endif // } LOG_DECODE_TIMINGS_ON

/*
   Used structures
*/
typedef  struct   {

  float   HpfZdl;
  float   HpfPdl;
   /* Lsp previous vector */
   float   PrevLsp[LpcOrder] ;

   /* All pitch operation buffers */
   float    PrevWgt[PitchMax] ;
   float    PrevErr[PitchMax] ;
   float    PrevExc[PitchMax] ;

   /* Requered memory for the delay */
   float   PrevDat[LpcFrame-SubFrLen] ;

   /* Used delay lines */
   float    WghtFirDl[2*LpcOrder];
   float    WghtIirDl[2*LpcOrder];
   float    RingFirDl[2*LpcOrder];
   float    RingIirDl[2*LpcOrder];

   /* For taming procedure */

   int  	SinDet;
   float    Err[SizErr];

   //These entries are not part of the ITU 723 std.
   int      p;
   int      q;

   int      srccount;              // sampling rate conversion count
   short    srcstate[SRCSTATELEN]; // sampling rate conversion state
  
   // Lsp previous vector 

   /* All pitch operation buffers */
   int VadAct;
   Flag UseHp;
   enum Crate WrkRate;
   int quality;

#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	ENC_TIMING_INFO	EncTimingInfo[ENC_TIMING_INFO_FRAME_COUNT];
	unsigned long   dwStatFrameCount;
	int             bTimingThisFrame;
	unsigned long   dwStartLow;
	unsigned long   dwStartHigh;
#endif // } LOG_ENCODE_TIMINGS_ON

   } CODDEF  ;

 typedef  struct   {
   int     Ecount;
   float   InterGain;
   int     InterIndx;
   int     Rseed;
   
   // Lsp previous vector
   // Name changed to avoid confusion with encoder 
   //	previous LSPs 
   //float PrevLSP[LpcOrder];
   float   dPrevLsp[LpcOrder];

   /* All pitch operation buffers */
   // Name changed to avoid confusion with encoder 
   //	previous excitation
   //float PrevExc[PitchMax]; 
   float   dPrevExc[PitchMax] ;

   /* Used delay lines */
   float   SyntIirDl[2*LpcOrder] ;

   //These entries are not part of the ITU 723 std.
   int     dp;
   int     dq;

   int     srccount;              // sampling rate conversion count
   short   srcstate[SRCSTATELEN]; // sampling rate conversion state
   short   srcbuff[480];          // sampling rate conversion buffer
   int     i;

   int VadAct;
   Flag UsePf;
   enum Crate WrkRate;

#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	DEC_TIMING_INFO	DecTimingInfo[DEC_TIMING_INFO_FRAME_COUNT];
	unsigned long   dwStatFrameCount;
	int             bTimingThisFrame;
	unsigned long   dwStartLow;
	unsigned long   dwStartHigh;
#endif // } LOG_DECODE_TIMINGS_ON

   } DECDEF  ;

typedef  struct   {
   int   AcLg;
   int   AcGn;
   int   Mamp;
   int   Grid;
   int   Tran;
   int   Pamp;
   Word32   Ppos;
   } SFSDEF;

typedef  struct   {
   int     Crc   ;
   Word32  LspId ;
   int     Olp[SubFrames/2] ;
   SFSDEF  Sfs[SubFrames] ;
   } LINEDEF ;

typedef  struct   {
   int   Indx;
   float Gain;
   } PWDEF;

typedef  struct {
   float    MaxErr   ;
   int      GridId   ;
   int      MampId   ;
   int      UseTrn   ;
   int      Ploc[MaxPulseNum] ;
   float    Pamp[MaxPulseNum] ;
   } BESTDEF ;





/* Prototype used for the ACELP codebook */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code to support easy-to-use debugging support.
//      All code compiles to nothing if DEBUG is not defined.
//
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifndef _WIN32
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
#endif

//
//
//
BOOL    __gfDbgEnabled          = TRUE;         // master enable
UINT    __guDbgLevel            = 0;            // current debug level


//--------------------------------------------------------------------------;
//  
//  void DbgVPrintF
//  
//  Description:
//  
//  
//  Arguments:
//      LPSTR szFormat:
//  
//      va_list va:
//  
//  Return (void):
//      No value is returned.
//  
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef _WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
        DebugBreak();
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//  
//  void dprintf
//  
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//      
//  Arguments:
//      UINT uDbgLevel:
//  
//      LPSTR szFormat:
//  
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//  
//  BOOL DbgEnable
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (BOOL):
//      Returns the previous debugging state.
//  
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    BOOL                    fEnable
)
{
    BOOL                fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//  
//  UINT DbgSetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uLevel:
//  
//  Return (UINT):
//      Returns the previous debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT                    uLevel
)
{
    UINT                uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgGetLevel
//  
//  Description:
//  
//  
//  Arguments:
//      None.
//  
//  Return (UINT):
//      Returns the current debugging level.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    void
)
{
    return (__guDbgLevel);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//  
//  UINT DbgInitialize
//  
//  Description:
//  
//  
//  Arguments:
//      BOOL fEnable:
//  
//  Return (UINT):
//      Returns the debugging level that was set.
//  
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize
(
    BOOL                    fEnable
)
{
    UINT                uLevel;

    uLevel = GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
        //
        //  if the debug key is not present, then force debug output to
        //  be disabled. this way running a debug version of a component
        //  on a non-debugging machine will not generate output unless
        //  the debug key exists.
        //
        uLevel  = 0;
        fEnable = FALSE;
    }

    DbgSetLevel(uLevel);
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()


//--------------------------------------------------------------------------;
//  
//  void _Assert
//  
//  Description:
//      This routine is called if the ASSERT macro (defined in debug.h)
//      tests and expression that evaluates to FALSE.  This routine 
//      displays an "assertion failed" message box allowing the user to
//      abort the program, enter the debugger (the "retry" button), or
//      ignore the assertion and continue executing.  The message box
//      displays the file name and line number of the _Assert() call.
//  
//  Arguments:
//      char *  szFile: Filename where assertion occurred.
//      int     iLine:  Line number of assertion.
//  
//--------------------------------------------------------------------------;

void WINAPI _Assert
(
    char *  szFile,
    int     iLine
)
{
    static CHAR     ach[300];       // debug output (avoid stack overflow)
    int	            id;


    wsprintfA(ach, "Assertion failed in file %s, line %d.  [Press RETRY to debug.]", (LPSTR)szFile, iLine);

    id = MessageBoxA(NULL, ach, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE );

	switch (id)
	{

	case IDABORT:               // Kill the application.
        FatalAppExit(0, TEXT("Good Bye"));
		break;

	case IDRETRY:               // Break into the debugger.
		DebugBreak();
		break;

	case IDIGNORE:              // Ignore assertion, continue executing.
		break;
	}
} // _Assert

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\ctiming.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*
 * ctiming.h
 *
 * DESCRIPTION:
 *		Common timing functions.  
 *
 *		I extracted this code from meantime.h in HQV's decode directory.
 */

// $Header:   S:\h26x\src\common\ctiming.h_v   1.2   26 Dec 1995 17:43:06   DBRUCKS  $
// $Log:   S:\h26x\src\common\ctiming.h_v  $
;// 
;//    Rev 1.2   26 Dec 1995 17:43:06   DBRUCKS
;// changed bTimerIsOn to bTimerIsActive
;// 
;//    Rev 1.1   26 Dec 1995 12:40:54   DBRUCKS
;// added higher level macros to simplify use
;// 
;//    Rev 1.0   20 Dec 1995 15:06:14   DBRUCKS
;// Initial revision.

#ifndef __CTIMING_H__
#define __CTIMING_H__

/* The following timing overhead numbers were generated by Tom Walsh
 * based on static variables for startlow, starthigh, and elapsed.
 * 
 * When timing sections of code with low clock numbers be careful to
 * minimize the timing overhead.  Store the sub totals to a stack variable
 * instead of to the instance via a pointer indirection and offset.
 */
#define P5TIMING_OVERHEAD 13
#define P6TIMING_OVERHEAD 33

/* Low Level Macros
 */
#define __RDTSC__ __asm { __asm __emit 0Fh __asm __emit 31h }

#define STARTCLOCK(startlow,starthigh) { \
	__asm {	\
		__asm __RDTSC__ \
		__asm mov	startlow,	eax	\
		__asm mov	starthigh,	edx	\
	} \
}

#define STOPCLOCKP5(startlow,starthigh,elapsed) { \
	__asm {	\
		__asm __RDTSC__ \
		__asm sub	eax,	startlow	\
		__asm sbb	edx,	starthigh	\
		__asm sub	eax,	P5TIMING_OVERHEAD		\
		__asm sbb	edx,	0		\
		__asm mov	elapsed,eax		\
	} \
}

#define STOPCLOCKP6(startlow,starthigh,elapsed) { \
	__asm {	\
		__asm __RDTSC__ \
		__asm sub	eax,	startlow	\
		__asm sbb	edx,	starthigh	\
		__asm sub	eax,	P6TIMING_OVERHEAD		\
		__asm sbb	edx,	0		\
		__asm mov	elapsed,eax		\
	} \
}

/* High Level Macros
 *
 * Call TIMER_START and TIMER_STOP in the main function that you wish to time.
 * TIMER_BEFORE and TIMER_AFTER should be used inside of that main function.
 * Fo example:
 *
 *		TIMER_START
 *			TIMER_BEFORE
 *			TIMER_AFTER_P5
 *			TIMER_BEFORE
 *			TIMER_AFTER_P5
 *		TIMER_STOP
 * 
 * Variable Definitions
 *		DWORD dwStartLow;		 // temporary set in TIMER_START 
 *		DWORD dwStartHigh;		 // temporary set in TIMER_START
 *		DWORD dwElapsed;		 // temporary used in TIMER_AFTER_*
 *		DWORD dwBefore;			 // temporary used in TIMER_BEFORE and TIMER_AFTER_*
 *		DWORD dwResult;			 // result variable
 *		int   bTimerIsActive	 // boolean - true if timing this frame
 *
 * WARNING: TIMER_AFTER_P5 and TIMER_AFTER_P6 add to the result variable.
 */
#define	TIMER_START(bTimerIsActive,dwStartLow,dwStartHigh) \
{ \
	bTimerIsActive = 1; \
	STARTCLOCK(dwStartLow,dwStartHigh); \
}

#define TIMER_BEFORE(bTimerIsActive,dwStartLow,dwStartHigh,dwBefore) \
{ \
	if (bTimerIsActive)	\
	{	\
		STOPCLOCKP5(dwStartLow,dwStartHigh,dwBefore); \
	} \
}

#define TIMER_AFTER_P5(bTimerIsActive,dwStartLow,dwStartHigh,dwBefore,dwElapsed,dwResult) \
{ \
	if (bTimerIsActive)	\
	{ \
		STOPCLOCKP5(dwStartLow,dwStartHigh,dwElapsed); \
		dwResult += dwElapsed - dwBefore;	    \
	} \
}

#define TIMER_STOP(bTimerIsActive,dwStartLow,dwStartHigh,dwResult) \
{ \
	if (bTimerIsActive)	\
	{ \
		STOPCLOCKP5(dwStartLow,dwStartHigh,dwResult);	\
	} \
}

#endif /* __CTIMING_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\exc_lbc.h ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//


int Estim_Pitch( float *Dpnt, int Start );
int Estim_Int( float *Dpnt, int Start );
PWDEF Comp_Pw( float *Dpnt, int Start, int Olp );
void  Filt_Pw( float *DataBuff, float *Dpnt, int Start, PWDEF Pw );
void  Find_Fcbk( float *Dpnt, float *ImpResp, LINEDEF *Line, int Sfc, enum Crate WrkRate, int flags, int UseMMX );
int ACELP_LBC_code(float *X, float *h, int T0, float *code,
  int *ind_gain, int *shift, int *sign, float gain_T0, int flags);
int ACELP_LBC_code_int(float *X, float *h, int T0, float *code,
  int *ind_gain, int *shift, int *sign, float gain_T0, int flags);
void Cor_h(float *H, float *rr);
void Cor_h_X(float h[],float X[],float D[]);
int D4i64_LBC(float Dn[], float rr[], float h[], float cod[],
				 float y[], int *code_shift, int *sign, int flags);
int G_code(float X[], float Y[], float *gain_q);
void  Gen_Trn( float *Dst, float *Src, int Olp );
void  Find_Best( BESTDEF *Best, float *Tv, float *ImpResp, int Np,
int Olp );
void  Fcbk_Pack( float *Dpnt, SFSDEF *Sfs, BESTDEF *Best, int Np );
void  Fcbk_Unpk( float *Tv, SFSDEF Sfs, int Olp, int Sfc, enum Crate WrkRate );
void  Find_Acbk( float *Tv, float *ImpResp, float *PrevExc, LINEDEF
*Line, int Sfc, enum Crate WrkRate, int flags, CODDEF *CodStat);
void  Get_Rez( float *Tv, float *PrevExc, int Lag );
void  Decod_Acbk( float *Tv, float *PrevExc, int Olp, int Lid,
int Gid, enum Crate WrkRate );
int   Comp_Info( float *Buff, int Olp );
void     Regen( float *DataBuff, float *Buff, int Lag, float Gain,
int Ecount, int *Sd );
//Comp_Lpf
//Find_B
//Find_F
//Get_Ind
//Filt_Lpf
int  search_T0 ( int T0, int Gid, float *gain_T0);
void reset_max_time(void);

//This routine is not part of the ITU 723 standard

 int Find_L(float *OccPos, float *ImrCorr, float *WrkBlk, float Pamp, int k);

int Test_Err(int Lag1, int Lag2, CODDEF *CodStat);
void Update_Err(int Olp, int AcLg, int AcGn, CODDEF *CodStat);


void  Find_AcbkInt( float *Tv, float *ImpResp, float *PrevExc, LINEDEF
*Line, int Sfc, enum Crate WrkRate, int flags, CODDEF *CodStat);

short norm(long L_var1);
void FBufCalcInt(short *fi, short *fo, short *impresp, short *reztemp, int n);
void CodeBkSrch(short *lpint, short *spint, int numloops, int *gid, int *max);
void FloatToShort(float *fbuf, short *sbuf, int count);
int DotMMX60(short *ind, short *oud);
void DupRezBuf(short *rezbuf, short *reztemp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\g723.h ===
//==========================================================================;
//
//    INTEL Corporation Proprietary Information
//
//    This listing is supplied under the terms of a license
//    agreement with INTEL Corporation and may not be copied
//    nor disclosed except in accordance with the terms of
//    that agreement.
//
//    Copyright (c) 1996 Intel Corporation.
//    All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  g723.h
//
//  Description:
//      This file contains prototypes for the filtering routines.
//
//
//==========================================================================;
#include "cst_lbc.h"
#include "sdstruct.h"

#ifndef _G723_H_
#define _G723_H_

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern 
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif

#define  NETMEETING_MSG723_ACM_ID		82
#define  WAVE_FORMAT_MSG723				0x0042     /*  Microsoft Corporation  */
#define  G723MAGICWORD1					0xf7329ace
#define  G723MAGICWORD2					0xacdeaea2

typedef struct msg723waveformat_tag {
    WAVEFORMATEX wfx;
    WORD         wConfigWord;
    DWORD        dwCodeword1;
    DWORD        dwCodeword2;
} MSG723WAVEFORMAT;
typedef MSG723WAVEFORMAT       *PMSG723WAVEFORMAT;
typedef MSG723WAVEFORMAT NEAR  *NPMSG723WAVEFORMAT;
typedef MSG723WAVEFORMAT FAR   *LPMSG723WAVEFORMAT;

typedef struct {
    CODDEF  CodStat;
    INSTNCE SD_Instance;
} G723CODDEF;

#define RATE 0x1
#define POST_FILTER 0x2
#define SILENCE_ENABLE 0x4

//
//  array of sample rates supported
//
//
const UINT G723_SAMPLING_RATE[] =
{
    8000,
    8000,
    8000,
    8000
};
const UINT PCM_SAMPLING_RATE[] =
{
    11025,
    8000
};
const UINT G723_SAMPLES_PER_BLOCK_PCM[] =
{
    330,
    240
};

//
//
//
//
#define G723_MAX_CHANNELS       1
#define G723_BITS_PER_SAMPLE    0
#define G723_WFX_EXTRA_BYTES    (sizeof(MSG723WAVEFORMAT) - sizeof(WAVEFORMATEX))
#define G723_HEADER_LENGTH      0    // In bytes, per channel.

#ifdef G723_USECONFIG
#define G723_CONFIGTESTTIME     4   // seconds of PCM data for test.
#define G723_CONFIG_DEFAULT                             0x0000
#define G723_CONFIG_DEFAULT_MAXRTENCODESETTING          5
#define G723_CONFIG_DEFAULT_MAXRTDECODESETTING          6
#define G723_CONFIG_UNCONFIGURED                        0x0999
#define G723_CONFIG_TEXTLEN                             80
#define G723_CONFIG_DEFAULTKEY                          HKEY_CURRENT_USER
#define G723_CONFIG_MIN_ENCODE                          4
#define G723_CONFIG_MIN_DECODE                          5
#endif

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//  resource id's
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#define IDS_ACM_DRIVER_SHORTNAME    (1)     // ACMDRIVERDETAILS.szShortName
#define IDS_ACM_DRIVER_LONGNAME     (2)     // ACMDRIVERDETAILS.szLongName
#define IDS_ACM_DRIVER_COPYRIGHT    (3)     // ACMDRIVERDETAILS.szCopyright
#define IDS_ACM_DRIVER_LICENSING    (4)     // ACMDRIVERDETAILS.szLicensing
#define IDS_ACM_DRIVER_FEATURES     (5)     // ACMDRIVERDETAILS.szFeatures
#define	IDS_FORMAT_DETAILS_MONO_8KHZ_5333BIT_S (6)
#define	IDS_FORMAT_DETAILS_MONO_8KHZ_5333BIT_SID (7)
#define	IDS_FORMAT_DETAILS_MONO_8KHZ_6400BIT_S (8)
#define	IDS_FORMAT_DETAILS_MONO_8KHZ_6400BIT_SID (9)

#define IDS_ACM_DRIVER_TAG_NAME     (20)    // ACMFORMATTAGDETAILS.szFormatTag

#ifdef G723_USECONFIG
//
//  resource id's for the configuration dialog box
//

#define IDS_CONFIG_NORATES          (30)
#define IDS_CONFIG_ALLRATES         (31)
#define IDS_CONFIG_MONOONLY         (32)
#define IDS_CONFIG_STEREOONLY       (33)
#define IDS_CONFIG_MONOSTEREO       (34)
#define IDS_ERROR                   (35)
#define IDS_ERROR_NOMEM             (36)

#define IDD_CONFIG                      RCID(100)
#define IDC_BTN_AUTOCONFIG              1001
#define IDC_BTN_HELP                    1002
#define IDC_COMBO_MAXRTENCODE           1003
#define IDC_COMBO_MAXRTDECODE           1004
#define IDC_STATIC1                     1005
#define IDC_STATIC2                     1006
#define IDC_STATIC3                     1007

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif

#endif // _G723_H_


#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern 
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//  ACM Driver Version:
//
//  the version is a 32 bit number that is broken into three parts as 
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows (in decimal form):
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) & 
//      wBuild = LOWORD(dwVersion)
//
//  VERSION_ACM_DRIVER is the version of this driver.
//  VERSION_MSACM is the version of the ACM that this driver
//  was designed for (requires).
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
    
#ifdef _WIN32
//
//  32-bit versions
//
#if (WINVER >= 0x0400)
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(1,  2, 1)
#else
 #define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(3, 50, 0)
#endif
#define VERSION_MSACM       MAKE_ACM_VERSION(3, 50, 0)

#else
//
//  16-bit versions
//
#define VERSION_ACM_DRIVER  MAKE_ACM_VERSION(2, 3, 0)
#define VERSION_MSACM       MAKE_ACM_VERSION(2, 1, 0)

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
// 
//  Win 16/32 portability stuff...
// 
// 
// 
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef _WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
    #ifdef _WINDLL
        #define FNWCALLBACK FAR PASCAL __loadds
        #define FNEXPORT    FAR PASCAL __export
    #else
        #define FNWCALLBACK FAR PASCAL
        #define FNEXPORT    FAR PASCAL __export
    #endif
    #endif

    //
    //
    //
    //
    #ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
    #endif

    //
    //  based code makes since only in win 16 (to try and keep stuff out of
    //  our fixed data segment...
    //
    #define BCODE           _based(_segname("_CODE"))

    #define HUGE            _huge

    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)
    #define SIZEOFACMSTR(x) sizeof(x)
#else
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNWCALLBACK CALLBACK
        #define FNEXPORT    CALLBACK
    #endif

    #ifndef _CRTAPI1
    #define _CRTAPI1    __cdecl
    #endif
    #ifndef _CRTAPI2
    #define _CRTAPI2    __cdecl
    #endif
    #ifndef try
    #define try         __try
    #define leave       __leave
    #define except      __except
    #define finally     __finally
    #endif


    //
    //  there is no reason to have based stuff in win 32
    //
    #define BCODE

    #define HUGE
    #define HTASK                   HANDLE
    #define SELECTOROF(a)           (a)
    typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)   sizeof(x)
    #endif
    #define SIZEOFACMSTR(x)	(sizeof(x)/sizeof(WCHAR))
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//  Compilation options:
//
//      If G723_USECONFIG is defined, then the codec will be compiled
//      with a configuration dialog.  If not, then the codec will not be
//      configurable.  It is expected that the configuration is only
//      necessary for certain platforms...
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

//#define G723_USECONFIG


#ifdef G723_USECONFIG

//
//  See codec.c for a description of this structure and its use.
//
typedef struct tRATELISTFORMAT
{
    UINT        uFormatType;
    UINT        idsFormat;
    DWORD       dwMonoRate;
} RATELISTFORMAT;
typedef RATELISTFORMAT *PRATELISTFORMAT;

#define CONFIG_RLF_NONUMBER     1
#define CONFIG_RLF_MONOONLY     2
#define CONFIG_RLF_STEREOONLY   3
#define CONFIG_RLF_MONOSTEREO   4

#endif // G723_USECONFIG



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//
//
//
#define SIZEOF_ARRAY(ar)            (sizeof(ar)/sizeof((ar)[0]))

//
//
//
typedef BOOL FAR*   LPBOOL;


//
//  macros to compute block alignment and convert between samples and bytes
//  of PCM data. note that these macros assume:
//
//      wBitsPerSample  =  8 or 16
//      nChannels       =  1 or 2
//
//  the pwfx argument is a pointer to a WAVEFORMATEX structure.
//
#define PCM_BLOCKALIGNMENT(pwfx)        (UINT)(((pwfx)->wBitsPerSample >> 3) << ((pwfx)->nChannels >> 1))
#define PCM_AVGBYTESPERSEC(pwfx)        (DWORD)((pwfx)->nSamplesPerSec * (pwfx)->nBlockAlign)
#define PCM_BYTESTOSAMPLES(pwfx, cb)    (DWORD)(cb / PCM_BLOCKALIGNMENT(pwfx))
#define PCM_SAMPLESTOBYTES(pwfx, dw)    (DWORD)(dw * PCM_BLOCKALIGNMENT(pwfx))


#define FLOATTOSHORT(b) ((b < -32768.) ? (short)(-32768) : \
                        ((b >  32767.) ? (short)(32767)  : \
			((b <      0.) ? (short)(b-0.5)  : \
			                 (short)(b+0.5))))


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

typedef struct tDRIVERINSTANCE
{
    //
    //  although not required, it is suggested that the first two members
    //  of this structure remain as fccType and DriverProc _in this order_.
    //  the reason for this is that the driver will be easier to combine
    //  with other types of drivers (defined by AVI) in the future.
    //
    FOURCC          fccType;        // type of driver: 'audc'
    DRIVERPROC      fnDriverProc;   // driver proc for the instance

    //
    //  the remaining members of this structure are entirely open to what
    //  your driver requires.
    //
    HDRVR           hdrvr;          // driver handle we were opened with
    HINSTANCE       hinst;          // DLL module handle.
    DWORD           vdwACM;         // current version of ACM opening you
    DWORD           fdwOpen;        // flags from open description

    DWORD           fdwConfig;      // stream instance configuration flags

    BOOL            enabled;        // driver enabled flag

#ifdef G723_USECONFIG    
    LPDRVCONFIGINFO pdci;
    HKEY            hkey;
    UINT            nConfigMaxRTEncodeSetting;
    UINT            nConfigMaxRTDecodeSetting;
    UINT    	    nConfigPercentCPU;
    BOOL            fHelpRunning;           // Used by config DlgProc only.
#ifdef WIN4
    HBRUSH          hbrDialog;              // Used by config DlgProc only.
#endif
#endif

} DRIVERINSTANCE, *PDRIVERINSTANCE, FAR *LPDRIVERINSTANCE;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 


//
//  This define deals with unaligned data for Win32, and huge data for Win16.
//  Basically, any time you cast an HPBYTE to a non-byte variable (ie long or
//  short), you should cast it to ( {short,long} HUGE_T *).  This will cast
//  it to _huge for Win16, and make sure that there are no alignment problems
//  for Win32 on MIPS and Alpha machines.
//

typedef BYTE HUGE *HPBYTE;

#ifdef _WIN32
    #define HUGE_T  UNALIGNED
#else
    #define HUGE_T  _huge
#endif


//
//
//
//
typedef DWORD (FNGLOBAL *STREAMCONVERTPROC)
(
    HPBYTE                  pbSrc,
    DWORD                   cbSrcLength,
    HPBYTE                  pbDst
//    UINT                    nBlockAlignment,
//    UINT                    cSamplesPerBlock,
//    int                 *   pnStepIndexL,
//    int                 *   pnStepIndexR
);


//
//
//
//
typedef struct tSTREAMINSTANCE
{
    STREAMCONVERTPROC   fnConvert;  // stream instance conversion proc
    DWORD               fdwConfig;  // stream instance configuration flags


} STREAMINSTANCE, *PSTREAMINSTANCE, FAR *LPSTREAMINSTANCE;




//
//  global variables, etc...
//
#ifdef G723_USECONFIG

extern const UINT   gauFormatIndexToSampleRate[];
extern const UINT   ACM_DRIVER_MAX_SAMPLE_RATES;
extern const UINT   ACM_DRIVER_MAX_CHANNELS;
extern const RATELISTFORMAT gaRateListFormat[];
extern const UINT   G723_CONFIG_NUMSETTINGS;

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//  function prototypes
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

void convert11to8(short *in, short *out, short *prev, int len);
void convert8to11(short *in, short *out, short *prev, int len);

#ifdef G723_USECONFIG

BOOL FNGLOBAL acmdDriverConfigInit
(
    PDRIVERINSTANCE	    pdi,
    LPCTSTR		    pszAliasName
);

BOOL FNWCALLBACK acmdDlgProcConfigure
(
    HWND                    hwnd,
    UINT                    uMsg,
    WPARAM                  wParam,
    LPARAM                  lParam
);

LRESULT FNLOCAL acmdFormatSuggest
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVFORMATSUGGEST   padfs
);

LRESULT FNLOCAL acmdStreamSize
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
);

LRESULT FNLOCAL acmdStreamConvert
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
);

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ; 

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" { 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\g723.c ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
**  codec.c
**
**  Description:
**      This file contains the ACM wrapper code for the G.723.1 compressor.
**
**
****************************************************************************
*/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
//#include <mmddk.h>
#include <ctype.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#include "g723.h"
#include "debug.h"
//#include "cst_lbc.h"
#include "coder.h"
#include "decod.h"
#include "sdstuff.h"
#include "float.h"
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
#include "isrg.h"
#endif // } NO_DEBUGGING_OUTPUT
#endif

const UINT gauFormatTagIndexToTag[] =
{
    WAVE_FORMAT_PCM,
    WAVE_FORMAT_MSG723
};

#define ACM_DRIVER_MAX_FORMAT_TAGS      SIZEOF_ARRAY(gauFormatTagIndexToTag)
#define ACM_DRIVER_MAX_FILTER_TAGS      0


//
//  Required by config.c as well as codec.c.
//

#define ACM_DRIVER_MAX_BITSPERSAMPLE_PCM  1
#define ACM_DRIVER_MAX_BITSPERSAMPLE_G723 0

//extern void 	glblSDinitialize(CODDEF *CodStat);
//extern void 	prefilter(CODDEF *CodStat,int bufsize);
//extern void 	getParams(CODDEF *CodStat,int buffersize);
//extern int  	initializeSD(CODDEF *CodStat);
//extern int 		silenceDetect(CODDEF *CodStat);
//extern void		execSDloop(CODDEF *CodStat, int *isFrameSilent);
//
//  number of formats we enumerate per channel is number of sample rates
//  times number of channels times number of types (bits per sample).
//
#define ACM_DRIVER_MAX_FORMATS_PCM     2

#define ACM_DRIVER_MAX_FORMATS_G723    2


//==========================================================================;
//
//
//
//
//==========================================================================;
static float SDThreashold = 5.0f;		// silence converter threashold.
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
static WORD ghISRInst = 0;
#endif // } NO_DEBUGGING_OUTPUT
#endif
//--------------------------------------------------------------------------;
//
//  int LoadStringCodec
//
//  Description:
//      This function should be used by all codecs to load resource strings
//      which will be passed back to the ACM.  It works correctly for all
//      platforms, as follows:
//                                        
//          Win16:  Compiled to LoadString to load ANSI strings.
//
//          Win32:  The 32-bit ACM always expects Unicode strings.  Therefore,
//                  when UNICODE is defined, this function is compiled to
//                  LoadStringW to load a Unicode string.  When UNICODE is
//                  not defined, this function loads an ANSI string, converts
//                  it to Unicode, and returns the Unicode string to the
//                  codec.
//
//      Note that you may use LoadString for other strings (strings which
//      will not be passed back to the ACM), because these strings will
//      always be consistent with the definition of UNICODE.
//
//  Arguments:
//      Same as LoadString, except that it expects an LPSTR for Win16 and a
//      LPWSTR for Win32.
//
//  Return (int):
//      Same as LoadString.
//
//--------------------------------------------------------------------------;

#ifndef _WIN32
#define LoadStringCodec LoadString
#else

#ifdef UNICODE
#define LoadStringCodec LoadStringW
#else

int FNGLOBAL LoadStringCodec
(
 HINSTANCE  hinst,
 UINT	    uID,
 LPWSTR	    lpwstr,
 int	    cch)
{
    LPSTR   lpstr;
    int	    iReturn;

    lpstr = (LPSTR)GlobalAlloc(GPTR, cch);
    if (NULL == lpstr)
    {
	return 0;
    }

    iReturn = LoadStringA(hinst, uID, lpstr, cch);
    if (0 == iReturn)
    {
	if (0 != cch)
	{
	    lpwstr[0] = '\0';
	}
    }
    else
    {
    	MultiByteToWideChar( GetACP(), 0, lpstr, cch, lpwstr, cch );
    }

    GlobalFree((HGLOBAL)lpstr);

    return iReturn;
}

#endif  // UNICODE
#endif  // _WIN32


//--------------------------------------------------------------------------;
//
//  BOOL pcmIsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid PCM
//      header that we can deal with.  Right now we are limited to an 8k
//      sampling rate.  That should go to 8 and 11 shortly.
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL pcmIsValidFormat
(
    LPWAVEFORMATEX          pwfx
)
{
  int i;

    if (NULL == pwfx)
        return (FALSE);

    if (WAVE_FORMAT_PCM != pwfx->wFormatTag)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad pcm wave format tag:  %d",
	      pwfx->wFormatTag);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }

//
//  verify nChannels member is within the allowed range
//
    if ((pwfx->nChannels != G723_MAX_CHANNELS) )
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad pcm channels:  %d",pwfx->nChannels);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
//
//  only allow the bits per sample that we can encode and decode with
//
    if (16 != pwfx->wBitsPerSample )
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad pcm bits per sample:  %d",
	      pwfx->wBitsPerSample);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
//
//  only allow supported sampling rates
//
    for(i=0;i<ACM_DRIVER_MAX_FORMATS_PCM;i++)
      if (pwfx->nSamplesPerSec == PCM_SAMPLING_RATE[i])
	break;

    if (i == ACM_DRIVER_MAX_FORMATS_PCM)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad pcm sampling rate:  %d",
	      pwfx->nSamplesPerSec);
#endif // } NO_DEBUGGING_OUTPUT
#endif
      return(FALSE);
    }
//
//  now verify that the block alignment is correct..
//
    if (PCM_BLOCKALIGNMENT(pwfx) != pwfx->nBlockAlign)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad pcm block alignment:  %d",
	      pwfx->nBlockAlign);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
//
//  finally, verify that avg bytes per second is correct
//
    if (PCM_AVGBYTESPERSEC(pwfx) != pwfx->nAvgBytesPerSec)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad pcm avg bytes per sec:  %d",
	      pwfx->nAvgBytesPerSec);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
    return (TRUE);
}


//--------------------------------------------------------------------------;
//
//  BOOL G723IsValidFormat
//
//  Description:
//      This function verifies that a wave format header is a valid 
//      G.723.1 header that this ACM driver can deal with.
//  
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header to verify.
//
//  Return (BOOL):
//      The return value is non-zero if the format header looks valid. A
//      zero return means the header is not valid.
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL g723IsValidFormat
(
    LPWAVEFORMATEX          pwfx
)
{
//	LPMSG723WAVEFORMAT		pwfg723;

    if (NULL == pwfx)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad 723 format structure pointer");
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
    if (WAVE_FORMAT_MSG723 != pwfx->wFormatTag)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad 723 format tag:  %d",
	      pwfx->wFormatTag);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
//
//  check wBitsPerSample
//
    if (G723_BITS_PER_SAMPLE != pwfx->wBitsPerSample)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad 723 bits per sample:  %d",
	      pwfx->wBitsPerSample);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
//
//  check channels
//
    if (pwfx->nChannels != G723_MAX_CHANNELS)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad 723 channels:  %d",
	      pwfx->nChannels);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
//
//  Check block alignment - must be an integral number of DWORDs for
//  mono, or an even number of DWORDs for stereo.
//
    if( 0 != pwfx->nBlockAlign % (sizeof(DWORD)) )
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad 723 block alignment:  %d",
	      pwfx->nBlockAlign);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return FALSE;
    }
    if (G723_WFX_EXTRA_BYTES != pwfx->cbSize)
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Bad 723 extra bytes:  %d",
	      pwfx->cbSize);
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (FALSE);
    }
//	pwfg723 = (LPMSG723WAVEFORMAT)pwfx;

    return (TRUE);
}


//--------------------------------------------------------------------------;
//  
//  UINT g723BlockAlign
//  
//  Description:
//      This function computes the standard block alignment that should
//      be used given the WAVEFORMATEX structure.
//
//      NOTE! It is _assumed_ that the format is a valid G723 format
//      and that the following fields in the format structure are valid:
//
//          nChannels
//          nSamplesPerSec
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header.
//  
//  Return (UINT):
//      The return value is the block alignment that should be placed in
//      the pwfx->nBlockAlign field.
//
//--------------------------------------------------------------------------;

UINT FNLOCAL g723BlockAlign
(
    LPMSG723WAVEFORMAT         pwfg723
)
{
    UINT                uBlockAlign;

	if((pwfg723->wConfigWord&RATE) == Rate63)
    	uBlockAlign  = 24;
	else uBlockAlign = 20;

    return (uBlockAlign);

}



//--------------------------------------------------------------------------;
//  
//  UINT g723AvgBytesPerSec
//  
//  Description:
//      This function computes the Average Bytes Per Second (decoded!)
//      that should be used given the WAVEFORMATEX structure.
//
//      NOTE! It is _assumed_ that the format is a valid g723 format
//      and that the following fields in the format structure are valid:
//
//          nSamplesPerSec
//          nBlockAlign
//
//  Arguments:
//      LPWAVEFORMATEX pwfx: Pointer to format header.
//  
//  Return (DWORD):
//      The return value is the average bytes per second that should be
//      placed in the pwfx->nAvgBytesPerSec field.
//
//--------------------------------------------------------------------------;

DWORD FNLOCAL g723AvgBytesPerSec
(
    LPWAVEFORMATEX          pwfx
)
{
  int i;
  DWORD               dwAvgBytesPerSec;


//
//  compute bytes per second including header bytes
//
    dwAvgBytesPerSec = (pwfx->nSamplesPerSec * pwfx->nBlockAlign)
                       / G723_SAMPLES_PER_BLOCK_PCM[0];

    for(i=1;i<ACM_DRIVER_MAX_FORMATS_PCM;i++)
      if (pwfx->nSamplesPerSec == PCM_SAMPLING_RATE[i])
	dwAvgBytesPerSec = (pwfx->nSamplesPerSec * pwfx->nBlockAlign)
                           /  G723_SAMPLES_PER_BLOCK_PCM[i];

    return (dwAvgBytesPerSec);
}


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverOpen
//
//  Description:
//      This function is used to handle the DRV_OPEN message for the ACM
//      driver. The driver is 'opened' for many reasons with the most common
//      being in preperation for conversion work. It is very important that
//      the driver be able to correctly handle multiple open driver
//      instances.
//
//      Read the comments for this function carefully!
//
//      Note that multiple _streams_ can (and will) be opened on a single
//      open _driver instance_. Do not store/create instance data that must
//      be unique for each stream in this function. See the acmdStreamOpen
//      function for information on conversion streams.
//
//  Arguments:
//      HDRVR hdrvr: Driver handle that will be returned to caller of the
//      OpenDriver function. Normally, this will be the ACM--but this is
//      not guaranteed. For example, if an ACM driver is implemented within
//      a waveform driver, then the driver will be opened by both MMSYSTEM
//      and the ACM.
//
//      LPACMDRVOPENDESC paod: Open description defining how the ACM driver
//      is being opened. This argument may be NULL--see the comments below
//      for more information.
//
//  Return (LRESULT):
//      The return value is non-zero if the open is successful. A zero
//      return signifies that the driver cannot be opened.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverOpen
(
    HDRVR                   hdrvr,
    LPACMDRVOPENDESC        paod
)
{
    PDRIVERINSTANCE     pdi;

//
//  the [optional] open description that is passed to this driver can
//  be from multiple 'managers.' for example, AVI looks for installable
//  drivers that are tagged with 'vidc' and 'vcap'. we need to verify
//  that we are being opened as an Audio Compression Manager driver.
//
//  if paod is NULL, then the driver is being opened for some purpose
//  other than converting (that is, there will be no stream open
//  requests for this instance of being opened). the most common case
//  of this is the Control Panel's Drivers option checking for config
//  support (DRV_[QUERY]CONFIGURE).
//
//  we want to succeed this open, but be able to know that this
//  open instance is bogus for creating streams. for this purpose we
//  leave most of the members of our instance structure that we 
//  allocate below as zero...
//

  // for some reason, floating point exceptions will crash Win9x
  // machines.  They should be getting ignored.  The only work-around
  // is to call _fpreset to force the floating point control word to
  // be reinitialized
    _fpreset();

    if (NULL != paod)
    {
//
//  refuse to open if we are not being opened as an ACM driver.
//  note that we do NOT modify the value of paod->dwError in this
//  case.
//
        if (ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != paod->fccType)
            return (0L);
    }


//
//  we are being opened as an installable driver--we can allocate some
//  instance data to be returned in dwId argument of the DriverProc;
//  or simply return non-zero to succeed the open.
//
//  this driver allocates a small instance structure. note that we
//  rely on allocating the memory as zero-initialized!
//
    pdi = (PDRIVERINSTANCE)LocalAlloc(LPTR, sizeof(*pdi));
    if (NULL == pdi)
    {
//
//  if this open attempt was as an ACM driver, then return the
//  reason we are failing in the open description structure..
//
        if (NULL != paod)
        {
            paod->dwError = MMSYSERR_NOMEM;
        }

        return (0L);
    }

#ifdef NOTPRODUCT
    pdi->enabled        = TRUE;
#else
    pdi->enabled        = FALSE;
#endif

    pdi->hdrvr          = hdrvr;
    pdi->hinst          = GetDriverModuleHandle(hdrvr);  // Module handle.

    if (NULL != paod)
    {
        pdi->fnDriverProc = NULL;
        pdi->fccType      = paod->fccType;
        pdi->vdwACM       = paod->dwVersion;
        pdi->fdwOpen      = paod->dwFlags;

        paod->dwError     = MMSYSERR_NOERROR;
    }


#ifdef G723_USECONFIG
//
// Get config info for this driver.  If we're not passed an
// ACMDRVOPENDESC structure then we'll assume we are being
// opened for configuration and will put off getting the config
// info until we receive the DRV_CONFIGURE message.  Otherwise we
// get the config info now using the alias passed through the
// ACMDRVOPENDESC structure.
//
    pdi->hkey = NULL;           // This is important!

    if (NULL != paod)
    {
#if defined(_WIN32) && !defined(UNICODE)
//
//  We must translate the UNICODE alias name to an ANSI version
//  that we can use.
//
    	LPSTR	lpstr;
        int     iLen;

        //
        //  Calculate required length without calling UNICODE APIs or CRT.
        //
        iLen  = WideCharToMultiByte( GetACP(), 0, paod->pszAliasName,-1,
                                                    NULL, 0, NULL, NULL );

    	lpstr = (LPSTR)GlobalAllocPtr( GPTR, iLen );
	    if (NULL != lpstr)
	    {
            WideCharToMultiByte( GetACP(), 0, paod->pszAliasName, iLen,
                                    lpstr, iLen, NULL, NULL );
	    }
	    acmdDriverConfigInit(pdi, lpstr);	// Note: OK to pass lpstr==NULL
	    if (NULL != lpstr)
	    {
	        GlobalFreePtr( lpstr );
	    }
#else
    	acmdDriverConfigInit(pdi, paod->pszAliasName);
#endif // _WIN32 && !UNICODE
    }
#else
//
//  Actually, fdwConfig is not used - there is no configuration data.
//
	pdi->fdwConfig    = 0L;
#endif // G723_USECONFIG

//
//  non-zero return is success for DRV_OPEN
//
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
    ISRREGISTERMODULE(&ghISRInst,"G723ACM","G.723.1 ACM Driver");
    TTDBG(ghISRInst,TT_TRACE,"Driver Opened");
#endif // } NO_DEBUGGING_OUTPUT
#endif

    return ((LRESULT)(UINT)pdi);
}


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverClose
//
//  Description:
//      This function handles the DRV_CLOSE message for the ACM driver. The
//      driver receives a DRV_CLOSE message for each succeeded DRV_OPEN
//      message (see acmdDriverOpen). The driver will only receive a close
//      message for _successful_ opens.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//  Return (LRESULT):
//      The return value is non-zero if the open instance can be closed.
//      A zero return signifies that the ACM driver instance could not be
//      closed.
//
//      NOTE! It is _strongly_ recommended that the driver never fail to
//      close. Note that the ACM will never allow a driver instance to
//      be closed if there are open streams. An ACM driver does not need
//      to check for this case.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverClose
(
    PDRIVERINSTANCE         pdi
)
{
#ifdef G723_USECONFIG
//
//  Release the registry key, if we allocated one.
//
    if( NULL != pdi->hkey )
    {
        (void)RegCloseKey( pdi->hkey );
    }
#endif

//
//  check to see if we allocated instance data. if we did not, then
//  immediately succeed.
//
    if (NULL != pdi)
    {
//
//  close down the driver instance. this driver simply needs
//  to free the instance data structure... note that if this 
//  'free' fails, then this ACM driver probably trashed its
//  heap; assume we didn't do that.
//
        LocalFree((HLOCAL)pdi);
    }

    return (1L);
} // acmdDriverClose()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverConfigure
//
//  Description:
//      This function is called to handle the DRV_[QUERY]CONFIGURE messages.
//      These messages are for 'configuration' support of the driver.
//      Normally this will be for 'hardware'--that is, a dialog should be
//      displayed to configure ports, IRQ's, memory mappings, etc if it
//      needs to. However, a software only ACM driver may also require
//      configuration for 'what is real time' or other quality vs time
//      issues.
//
//      The most common way that these messages are generated under Win 3.1
//      and NT Product 1 is from the Control Panel's Drivers option. Other
//      sources may generate these messages in future versions of Windows.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for configuration support.
//
//      LPDRVCONFIGINFO pdci: Pointer to optional DRVCONFIGINFO structure.
//      If this argument is NULL, then the ACM driver should invent its own
//      storage location.
//
//  Return (LRESULT):
//      If the driver is being 'queried' for configuration support (that is,
//      hwnd == (HWND)-1), then non-zero should be returned specifying
//      the driver does support a configuration dialog--or zero should be
//      returned specifying that no configuration dialog is supported.
//
//      If the driver is being called to display the configuration dialog
//      (that is, hwnd != (HWND)-1), then one of the following values
//      should be returned:
//
//      DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
//      and canceled by the user. this value should also be returned if
//      no configuration information was modified.
//
//      DRVCNF_OK (0x0001): specifies that the dialog was displayed and
//      the user pressed OK.  This value should be returned even if the
//      user didn't change anything - otherwise, the driver may not
//      install properly.  
//
//      DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
//      and some configuration information was changed that requires 
//      Windows to be restarted before the changes take affect. the driver
//      should remain configured with current values until the driver
//      has been 'rebooted'.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverConfigure
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd,
    LPDRVCONFIGINFO         pdci
)
{
//    int         n;

    //
    //  first check to see if we are only being queried for configuration
    //  support. if hwnd == (HWND)-1 then we are being queried and should
    //  return zero for 'not supported' and non-zero for 'supported'.
    //
    if ((HWND)-1 == hwnd)
    {
#ifdef G723_USECONFIG
        //
        //  this ACM driver supports a configuration dialog box, so
        //  return non-zero...
        //
        return (1L);

#else
    return(0L);
#endif
    }

//
//  we are being asked to bring up our configuration dialog. if this
//  driver supports a configuration dialog box, then after the dialog
//  is dismissed we must return one of the following values:
//
//  DRVCNF_CANCEL (0x0000): specifies that the dialog was displayed
//  and canceled by the user. this value should also be returned if
//  no configuration information was modified.
//
//  DRVCNF_OK (0x0001): specifies that the dialog was displayed and
//  the user pressed OK.  This value should be returned even if the
//  user didn't change anything - otherwise, the driver may not
//  install properly.  
//
//  DRVCNF_RESTART (0x0002): specifies that the dialog was displayed
//  and some configuration information was changed that requires 
//  Windows to be restarted before the changes take affect. the driver
//  should remain configured with current values until the driver
//  has been 'rebooted'.
//
#ifdef G723_USECONFIG
    if (NULL == pdci)
    {
        //
        //  !!!
        //
        DPF(2,"acmdDriverConfigure returning CANCEL due to NULL==pdci.");
        return (DRVCNF_CANCEL);
    }

    pdi->pdci = pdci;

//
// We may not have our config info yet if the driver has only been
// opened specifically for configuration.  So, read our configuration
// using the alias passed in the DRVCONFIGINFO structure passed
// through the DRV_CONFIGURE message
//
#if (defined(_WIN32) && !defined(UNICODE))
    {
    //
    //  We must translate the UNICODE alias name to an ANSI version
    //  that we can use.
    //
    	LPSTR	lpstr;
        int     iLen;

//
//  Calculate required length without calling UNICODE APIs or CRT.
//
        iLen  = WideCharToMultiByte( GetACP(), 0, pdci->lpszDCIAliasName, -1,
                NULL, 0, NULL, NULL );

    	lpstr = (LPSTR)GlobalAllocPtr( GPTR, iLen );
	    if (NULL != lpstr)
	    {
            WideCharToMultiByte( GetACP(), 0, pdci->lpszDCIAliasName, iLen,
                                    lpstr, iLen, NULL, NULL );
	    }
	    acmdDriverConfigInit(pdi, lpstr);	// Note: OK to pass lpstr==NULL
	    if (NULL != lpstr)
	    {
	        GlobalFreePtr( lpstr );
	    }
    }
#else
    acmdDriverConfigInit(pdi, pdci->lpszDCIAliasName);
#endif // _WIN32 && !UNICODE

    n = DialogBoxParam(pdi->hinst,
                       IDD_CONFIG,
                       hwnd,
                       acmdDlgProcConfigure,
                       (LPARAM)(UINT)pdi);

    pdi->pdci = NULL;

    return ((LRESULT)n);
#else
    return(DRVCNF_CANCEL);
#endif // G723_USECONFIG

}


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverDetails
//
//  Description:
//      This function handles the ACMDM_DRIVER_DETAILS message. The ACM
//      driver is responsible for filling in the ACMDRIVERDETAILS structure
//      with various information.
//
//      NOTE! It is *VERY* important that you fill in your ACMDRIVERDETAILS
//      structure correctly. The ACM and applications must be able to 
//      rely on this information.
//
//      WARNING! The _reserved_ bits of any fields of the ACMDRIVERDETAILS
//      structure are _exactly that_: RESERVED. Do NOT use any extra
//      flag bits, etc. for custom information. The proper way to add
//      custom capabilities to your ACM driver is this:
//
//      o   define a new message in the ACMDM_USER range.
//
//      o   an application that wishes to use one of these extra features
//          should then:
//
//          o   open the driver with acmDriverOpen.
//
//          o   check for the proper wMid and wPid using acmDriverDetails.
//
//          o   send the 'user defined' message with acmDriverMessage
//              to retrieve additional information, etc.
//
//          o   close the driver with acmDriverClose.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRIVERDETAILS padd: Pointer to ACMDRIVERDETAILS structure to
//      fill in for the caller. This structure may be larger or smaller than
//      the current definition of ACMDRIVERDETAILS--cbStruct specifies the
//      valid size.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) for success. Non-zero
//      signifies that the driver details could not be retrieved.
//
//      NOTE THAT THIS FUNCTION SHOULD NEVER FAIL! There are two possible
//      error conditions:
//
//      o   if padd is NULL or an invalid pointer.
//
//      o   if cbStruct is less than four; in this case, there is not enough
//          room to return the number of bytes filled in.
//
//      Because these two error conditions are easily defined, the ACM
//      will catch these errors. The driver does NOT need to check for these
//      conditions.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMDRIVERDETAILS      padd
)
{
    ACMDRIVERDETAILS    add;
    DWORD               cbStruct;

//
//  it is easiest to fill in a temporary structure with valid info
//  and then copy the requested number of bytes to the destination
//  buffer.
//
    cbStruct            = min(padd->cbStruct, sizeof(ACMDRIVERDETAILS));
    add.cbStruct        = cbStruct;


//
//  for the current implementation of an ACM driver, the fccType and
//  fccComp members *MUST* always be ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC
//  ('audc') and ACMDRIVERDETAILS_FCCCOMP_UNDEFINED (0) respectively.
//
    add.fccType         = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
    add.fccComp         = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;


//
//  the manufacturer id (wMid) and product id (wPid) must be filled
//  in with your company's _registered_ identifier's. for more
//  information on these identifier's and how to get them registered
//  contact Microsoft and get the Multimedia Developer Registration Kit:
//
//      Microsoft Corporation
//      Multimedia Technology Group
//      One Microsoft Way
//      Redmond, WA 98052-6399
//
//      Developer Services Phone: (800) 227-4679 x11771
//
//  note that during the development phase or your ACM driver, you may
//  use the reserved value of '0' for both wMid and wPid. however it
//  is not acceptable to ship a driver with these values.
//
    add.wMid            = MM_MICROSOFT;
    add.wPid            = NETMEETING_MSG723_ACM_ID;


//
//  the vdwACM and vdwDriver members contain version information for
//  the driver.
//
//  vdwACM: must contain the version of the *ACM* that the driver was
//  _designed_ for. this is the _minimum_ version number of the ACM
//  that the driver will work with. this value must be >= V2.00.000.
//
//  vdwDriver: the version of this ACM driver.
//
//  ACM driver versions are 32 bit numbers broken into three parts as
//  follows (note these parts are displayed as decimal values):
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
    add.vdwACM          = VERSION_MSACM;
    add.vdwDriver       = VERSION_ACM_DRIVER;


//
//  the following flags are used to specify the type of conversion(s)
//  that the ACM driver supports. note that a driver may support one or
//  more of these flags in any combination.
//
//  ACMDRIVERDETAILS_SUPPORTF_CODEC: this flag is set if the driver 
//  supports conversions from one format tag to another format tag. for
//  example, if a converter compresses or decompresses WAVE_FORMAT_PCM
//  and WAVE_FORMAT_IMA_ADPCM, then this bit should be set. this is
//  true even if the data is not actually changed in size--for example
//  a conversion from u-Law to A-Law will still set this bit because
//  the format tags differ.
//
//  ACMDRIVERDETAILS_SUPPORTF_CONVERTER: this flags is set if the
//  driver supports conversions on the same format tag. as an example,
//  the PCM converter that is built into the ACM sets this bit (and only
//  this bit) because it converts only between PCM formats (bits, sample
//  rate).
//
//  ACMDRIVERDETAILS_SUPPORTF_FILTER: this flag is set if the driver 
//  supports transformations on a single format tag but does change
//  the base characteristics of the format (bit depth, sample rate, etc
//  will remain the same). for example, a driver that changed the
//  'volume' of PCM data or applied a low pass filter would set this bit.
//
    add.fdwSupport      = ACMDRIVERDETAILS_SUPPORTF_CODEC;

//
//  the number of individual format tags this ACM driver supports. for
//  example, if a driver uses the WAVE_FORMAT_IMA_ADPCM and
//  WAVE_FORMAT_PCM format tags, then this value would be two. if the
//  driver only supports filtering on WAVE_FORMAT_PCM, then this value
//  would be one. if this driver supported WAVE_FORMAT_ALAW,
//  WAVE_FORMAT_MULAW and WAVE_FORMAT_PCM, then this value would be
//  three. etc, etc.
//
    add.cFormatTags     = ACM_DRIVER_MAX_FORMAT_TAGS;

//
//  the number of individual filter tags this ACM driver supports. if
//  a driver supports no filters (ACMDRIVERDETAILS_SUPPORTF_FILTER is
//  NOT set in the fdwSupport member), then this value must be zero.
//
    add.cFilterTags     = ACM_DRIVER_MAX_FILTER_TAGS;


//
//  the remaining members in the ACMDRIVERDETAILS structure are sometimes
//  not needed. because of this we make a quick check to see if we
//  should go through the effort of filling in these members.
//
    if (FIELD_OFFSET(ACMDRIVERDETAILS, hicon) < cbStruct)
    {
//
//  fill in the hicon member will a handle to a custom icon for
//  the ACM driver. this allows the driver to be represented by
//  an application graphically (usually this will be a company
//  logo or something). if a driver does not wish to have a custom
//  icon displayed, then simply set this member to NULL and a
//  generic icon will be displayed instead.
//
//  See the MSFILTER sample for a codec which contains a custom icon.
//
        add.hicon = NULL;

//
//  the short name and long name are used to represent the driver
//  in a unique description. the short name is intended for small
//  display areas (for example, in a menu or combo box). the long
//  name is intended for more descriptive displays (for example,
//  in an 'about box').
//
//  NOTE! an ACM driver should never place formatting characters
//  of any sort in these strings (for example CR/LF's, etc). it
//  is up to the application to format the text.
//
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_SHORTNAME, add.szShortName, SIZEOFACMSTR(add.szShortName));
        LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LONGNAME,  add.szLongName,  SIZEOFACMSTR(add.szLongName));

//
//  the last three members are intended for 'about box' information.
//  these members are optional and may be zero length strings if
//  the driver wishes.
//
//  NOTE! an ACM driver should never place formatting characters
//  of any sort in these strings (for example CR/LF's, etc). it
//  is up to the application to format the text.
//
        if (FIELD_OFFSET(ACMDRIVERDETAILS, szCopyright) < cbStruct)
        {
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_COPYRIGHT, add.szCopyright, SIZEOFACMSTR(add.szCopyright));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_LICENSING, add.szLicensing, SIZEOFACMSTR(add.szLicensing));
            LoadStringCodec(pdi->hinst, IDS_ACM_DRIVER_FEATURES,  add.szFeatures,  SIZEOFACMSTR(add.szFeatures));
        }
    }


//
//  now copy the correct number of bytes to the caller's buffer
//
    _fmemcpy(padd, &add, (UINT)add.cbStruct);


//
//  success!
//
    return (MMSYSERR_NOERROR);
}


//--------------------------------------------------------------------------;
//
//  LRESULT acmdDriverAbout
//
//  Description:
//      This function is called to handle the ACMDM_DRIVER_ABOUT message.
//      An ACM driver has the option of displaying its own 'about box' or
//      letting the ACM (or calling application) display one for it. This
//      message is normally sent by the Control Panel's Sound Mapper
//      option.
//
//      It is recommended that an ACM driver allow a default about box
//      be displayed for it--there should be no reason to bloat the size
//      of a driver to simply display copyright, etc information when that
//      information is contained in the ACMDRIVERDETAILS structure.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      HWND hwnd: Handle to parent window to use when displaying the
//      configuration dialog box. An ACM driver is _required_ to display a
//      modal dialog box using this hwnd argument as the parent. This
//      argument may be (HWND)-1 which tells the driver that it is only
//      being queried for about box support.
//
//  Return (LRESULT):
//      The return value is MMSYSERR_NOTSUPPORTED if the ACM driver does
//      not support a custom dialog box. In this case, the ACM or calling
//      application will display a generic about box using the information
//      contained in the ACMDRIVERDETAILS structure returned by the
//      ACMDM_DRIVER_DETAILS message.
//
//      If the driver chooses to display its own dialog box, then after
//      the dialog is dismissed by the user, MMSYSERR_NOERROR should be
//      returned.
//
//      If the hwnd argument is equal to (HWND)-1, then no dialog should
//      be displayed (the driver is only being queried for support). The
//      driver must still return MMSYSERR_NOERROR (supported) or  
//      MMSYSERR_NOTSUPPORTED (no custom about box supported).
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdDriverAbout
(
    PDRIVERINSTANCE         pdi,
    HWND                    hwnd
)
{
//
//  first check to see if we are only being queried for custom about
//  box support. if hwnd == (HWND)-1 then we are being queried and
//  should return MMSYSERR_NOTSUPPORTED for 'not supported' and
//  MMSYSERR_NOERROR for 'supported'.
//
    if ((HWND)-1 == hwnd)
    {
//
//  this ACM driver does NOT support a custom about box, so
//  return MMSYSERR_NOTSUPPORTED...
//
        return (MMSYSERR_NOTSUPPORTED);
    }


//
//  this driver does not support a custom dialog, so tell the ACM or
//  calling application to display one for us. note that this is the
//  _recommended_ method for consistency and simplicity of ACM drivers.
//  why write code when you don't have to?
//
    return (MMSYSERR_NOTSUPPORTED);
} 


//--------------------------------------------------------------------------;
//
//  LRESULT acmdFormatSuggest
//
//  Description:
//      This function handles the ACMDM_FORMAT_SUGGEST message. The purpose
//      of this function is to provide a way for the ACM, a wave mapper or
//      an application to quickly get a destination format that this driver
//      can convert the source format to. The 'suggested' format should
//      be as close to a common format as possible. This message is normally
//      sent in response to an acmFormatSuggest function call.
//
//      Another way to think about this message is: what format would this
//      driver like to convert the source format to?
//
//      The caller may place restrictions on the destination format that
//      should be suggested. The padfs->fdwSuggest member contains the
//      restriction bits passed by the caller--see the description for
//      the return value for more information.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVFORMATSUGGEST padfs: Pointer to an ACMDRVFORMATSUGGEST
//      structure that describes the source and destination (possibly with
//      restrictions) for a conversion.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if one or more of
//      the destination restriction bits is not supported. It is strongly
//      recommended that the driver support at least the following suggestion
//      restriction bits:
//
//      ACM_FORMATSUGGESTF_WFORMATTAG: The destination format tag must be
//      the same as the wFormatTag member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NCHANNELS: The destination channel count must be
//      the same as the nChannels member in the destination format header.
//
//      ACM_FORMATSUGGESTF_NSAMPLESPERSEC: The destination samples per
//      second must be the same as the nSamplesPerSec member in the
//      destination format header.
//
//      ACM_FORMATSUGGESTF_WBITSPERSAMPLE: The destination bits per sample
//      must be the same as the wBitsPerSample member in the destination
//      format header.
//
//      If no destintation format can be suggested, then the driver should
//      return ACMERR_NOTPOSSIBLE.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatSuggest
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVFORMATSUGGEST   padfs
)
{
    #define ACMD_FORMAT_SUGGEST_SUPPORT (ACM_FORMATSUGGESTF_WFORMATTAG |    \
                                         ACM_FORMATSUGGESTF_NCHANNELS |     \
                                         ACM_FORMATSUGGESTF_NSAMPLESPERSEC |\
                                         ACM_FORMATSUGGESTF_WBITSPERSAMPLE)

    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
	LPMSG723WAVEFORMAT		pwfg723;
    DWORD                   fdwSuggest;
    int i;

//
//  grab the suggestion restriction bits and verify that we support
//  the ones that are specified... an ACM driver must return the
//  MMSYSERR_NOTSUPPORTED if the suggestion restriction bits specified
//  are not supported.
//
    fdwSuggest = (ACM_FORMATSUGGESTF_TYPEMASK & padfs->fdwSuggest);

    if (~ACMD_FORMAT_SUGGEST_SUPPORT & fdwSuggest)
        return (MMSYSERR_NOTSUPPORTED);


//
//  get the source and destination formats in more convenient variables
//
    pwfxSrc = padfs->pwfxSrc;
    pwfxDst = padfs->pwfxDst;
    

//
//
//
//
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
//
//  strictly verify that the source format is acceptable for
//  this driver
//
            if (!pcmIsValidFormat(pwfxSrc))
                break;

//
//  if the destination format tag is restricted, verify that
//  it is within our capabilities...
//
//  this driver is only able to encode to G.723.1
//
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                if (WAVE_FORMAT_MSG723 != pwfxDst->wFormatTag)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wFormatTag = WAVE_FORMAT_MSG723;
            }

//
//  if the destination channel count is restricted, verify that
//  it is within our capabilities...
//
//  this driver is not able to handle more than 1 channel
//
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if (pwfxSrc->nChannels != G723_MAX_CHANNELS)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = G723_MAX_CHANNELS;
            }

//
//  if the destination samples per second is restricted, verify
//  that it is within our capabilities...
//
//  G.723.1 is designed for 8000 Hz sampling rate
//
            if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
            {
                if (pwfxDst->nSamplesPerSec != 8000)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nSamplesPerSec = 8000;
            }

//
//  if the destination bits per sample is restricted, verify
//  that it is within our capabilities...
//
		    if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
            {
                if (G723_BITS_PER_SAMPLE != pwfxDst->wBitsPerSample)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wBitsPerSample = G723_BITS_PER_SAMPLE;
            }


//
//  at this point, we have filled in all fields except the
//  following for our 'suggested' destination format:
//
//      nAvgBytesPerSec
//      nBlockAlign
//      cbSize
//
//      wSamplesPerBlock    ->  G723 extended information
//
			pwfg723 = (LPMSG723WAVEFORMAT)pwfxDst;
			pwfg723->wConfigWord        = Rate63;

            pwfxDst->nBlockAlign     = g723BlockAlign(pwfg723);
            pwfxDst->nAvgBytesPerSec = g723AvgBytesPerSec(pwfxDst);
            pwfxDst->cbSize          = G723_WFX_EXTRA_BYTES;


            return (MMSYSERR_NOERROR);


        case WAVE_FORMAT_MSG723:
//
//  strictly verify that the source format is acceptable for
//  this driver
//
            if (!g723IsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);
      

//
//  if the destination format tag is restricted, verify that
//  it is within our capabilities...
//
//  this driver is only able to decode to PCM
//
            if (ACM_FORMATSUGGESTF_WFORMATTAG & fdwSuggest)
            {
                if (WAVE_FORMAT_PCM != pwfxDst->wFormatTag)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wFormatTag = WAVE_FORMAT_PCM;
            }


//
//  if the destination channel count is restricted, verify that
//  it is within our capabilities...
//
//  this driver is not able to change the number of channels
//
            if (ACM_FORMATSUGGESTF_NCHANNELS & fdwSuggest)
            {
                if (pwfxSrc->nChannels != G723_MAX_CHANNELS)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->nChannels = G723_MAX_CHANNELS;
            }

//
//  if the destination samples per second is restricted, verify
//  that it is within our capabilities...
//
//  G.723.1 produces PCM at 8000 Hz sampling rate
//
            if (ACM_FORMATSUGGESTF_NSAMPLESPERSEC & fdwSuggest)
            {
	      for(i=0;i<ACM_DRIVER_MAX_FORMATS_PCM;i++)
		if (pwfxDst->nSamplesPerSec == PCM_SAMPLING_RATE[i])
		  break;

	      if (i == ACM_DRIVER_MAX_FORMATS_PCM)
		return (ACMERR_NOTPOSSIBLE);

	      pwfxDst->nSamplesPerSec = pwfxSrc->nSamplesPerSec;
            }
            else
            {
	      //
	      // 11025 is the default since it is more common
	      // in the PC world than 8000.  Moreover, this
	      // prevents applications like MS Sound Recorder
	      // from using a low quality SRC in certain cases.
	      //
	      pwfxDst->nSamplesPerSec = 11025;
            }

//
//  if the destination bits per sample is restricted, verify
//  that it is within our capabilities...
//
//  this driver is only able to decode to 16 bit
//
            if (ACM_FORMATSUGGESTF_WBITSPERSAMPLE & fdwSuggest)
            {
                if (16 != pwfxDst->wBitsPerSample)
                    return (ACMERR_NOTPOSSIBLE);
            }
            else
            {
                pwfxDst->wBitsPerSample = 16;
            }


//
//  at this point, we have filled in all fields except the
//  following for our 'suggested' destination format:
//
//      nAvgBytesPerSec
//      nBlockAlign
//      cbSize              !!! not used for PCM !!!
//
            pwfxDst->nBlockAlign     = PCM_BLOCKALIGNMENT(pwfxDst);
            pwfxDst->nAvgBytesPerSec = pwfxDst->nSamplesPerSec *
                                       pwfxDst->nBlockAlign;

        // pwfxDst->cbSize       = not used;
	
            return (MMSYSERR_NOERROR);
    }


//
//  can't suggest anything because either the source format is foreign
//  or the destination format has restrictions that this ACM driver
//  cannot deal with.
//
    return (ACMERR_NOTPOSSIBLE);
}


//--------------------------------------------------------------------------;
//  
//  LRESULT acmdFormatTagDetails
//  
//  Description:
//      This function handles the ACMDM_FORMATTAG_DETAILS message. This
//      message is normally sent in response to an acmFormatTagDetails or
//      acmFormatTagEnum function call. The purpose of this function is
//      to get details about a specific format tag supported by this ACM
//      driver.
//  
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATTAGDETAILS padft: Pointer to an ACMFORMATTAGDETAILS
//      structure that describes what format tag to retrieve details for.
//
//      DWORD fdwDetails: Flags defining what format tag to retrieve the
//      details for.
//  
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATTAGDETAILSF_INDEX: Indicates that a format tag index
//      was given in the dwFormatTagIndex member of the ACMFORMATTAGDETAILS
//      structure. The format tag and details must be returned in the
//      structure specified by padft. The index ranges from zero to one less
//      than the cFormatTags member returned in the ACMDRIVERDETAILS
//      structure for this driver.
//
//      ACM_FORMATTAGDETAILSF_FORMATTAG: Indicates that a format tag
//      was given in the dwFormatTag member of the ACMFORMATTAGDETAILS
//      structure. The format tag details must be returned in the structure
//      specified by padft.
//
//      ACM_FORMATTAGDETAILSF_LARGESTSIZE: Indicates that the details
//      on the format tag with the largest format size in bytes must be
//      returned. The dwFormatTag member will either be WAVE_FORMAT_UNKNOWN
//      or the format tag to find the largest size for.
//
//      If the details for the specified format tag cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatTagDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATTAGDETAILS   padft,
    DWORD                   fdwDetails
)
{
    UINT                uFormatTag;

    switch (ACM_FORMATTAGDETAILSF_QUERYMASK & fdwDetails)
    {
        case ACM_FORMATTAGDETAILSF_INDEX:
            //
            //  if the index is too large, then they are asking for a 
            //  non-existant format.  return error.
            //
            if (ACM_DRIVER_MAX_FORMAT_TAGS <= padft->dwFormatTagIndex)
                return (ACMERR_NOTPOSSIBLE);

            uFormatTag = gauFormatTagIndexToTag[(UINT)padft->dwFormatTagIndex];
            break;


        case ACM_FORMATTAGDETAILSF_LARGESTSIZE:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_UNKNOWN:
                case WAVE_FORMAT_MSG723:
                    uFormatTag = WAVE_FORMAT_MSG723;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        case ACM_FORMATTAGDETAILSF_FORMATTAG:
            switch (padft->dwFormatTag)
            {
                case WAVE_FORMAT_MSG723:
                    uFormatTag = WAVE_FORMAT_MSG723;
                    break;

                case WAVE_FORMAT_PCM:
                    uFormatTag = WAVE_FORMAT_PCM;
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        //
        //  if this ACM driver does not understand a query type, then
        //  return 'not supported'
        //
        default:
            return (MMSYSERR_NOTSUPPORTED);
    }



    //
    //
    //
    //
    switch (uFormatTag)
    {
        case WAVE_FORMAT_PCM:
            padft->dwFormatTagIndex = 0;
            padft->dwFormatTag      = WAVE_FORMAT_PCM;
            padft->cbFormatSize     = sizeof(PCMWAVEFORMAT);
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_PCM;

            //
            //  the ACM is responsible for the PCM format tag name
            //
            padft->szFormatTag[0]   =  '\0';
            break;

        case WAVE_FORMAT_MSG723:
            padft->dwFormatTagIndex = 1;
            padft->dwFormatTag      = WAVE_FORMAT_MSG723;
            padft->cbFormatSize     = sizeof(WAVEFORMATEX) +
                                      G723_WFX_EXTRA_BYTES;
            padft->fdwSupport       = ACMDRIVERDETAILS_SUPPORTF_CODEC;
            padft->cStandardFormats = ACM_DRIVER_MAX_FORMATS_G723;

            LoadStringCodec(pdi->hinst,
			 IDS_ACM_DRIVER_TAG_NAME,
			 padft->szFormatTag,
			 SIZEOFACMSTR(padft->szFormatTag));
            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }


    //
    //  return only the requested info
    //
    //  the ACM will guarantee that the ACMFORMATTAGDETAILS structure
    //  passed is at least large enough to hold the base information of
    //  the details structure
    //
    padft->cbStruct = min(padft->cbStruct, sizeof(*padft));

    //
    return (MMSYSERR_NOERROR);
} // acmdFormatTagDetails()


//--------------------------------------------------------------------------;
//  
//  LRESULT acmdFormatDetails
//  
//  Description:
//      This function handles the ACMDM_FORMAT_DETAILS message. This
//      message is normally sent in response to an acmFormatDetails or
//      acmFormatEnum function call. The purpose of this function is
//      to get details about a specific format for a specified format tag
//      supported by this ACM driver.
//
//      Note that an ACM driver can return a zero length string for the
//      format name if it wishes to have the ACM create a format string
//      for it. This is strongly recommended to simplify internationalizing
//      the driver--the ACM will automatically take care of that. The
//      following formula is used to format a string by the ACM:
//
//      <nSamplesPerSec> kHz, <bit depth> bit, [Mono | Stereo | nChannels]
//
//      <bit depth> = <nAvgBytesPerSec> * 8 / nSamplesPerSec / nChannels;
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMFORMATDETAILS padf: Pointer to an ACMFORMATDETAILS structure
//      that describes what format (for a specified format tag) to retrieve
//      details for.
//
//      DWORD fdwDetails: Flags defining what format for a specified format
//      tag to retrieve the details for.
//  
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      The driver should return MMSYSERR_NOTSUPPORTED if the query type
//      specified in fdwDetails is not supported. An ACM driver must
//      support at least the following query types:
//
//      ACM_FORMATDETAILSF_INDEX: Indicates that a format index for the
//      format tag was given in the dwFormatIndex member of the
//      ACMFORMATDETAILS structure. The format details must be returned in
//      the structure specified by padf. The index ranges from zero to one
//      less than the cStandardFormats member returned in the
//      ACMFORMATTAGDETAILS structure for a format tag.
//
//      ACM_FORMATDETAILSF_FORMAT: Indicates that a WAVEFORMATEX structure
//      pointed to by pwfx of the ACMFORMATDETAILS structure was given and
//      the remaining details should be returned. The dwFormatTag member 
//      of the ACMFORMATDETAILS will be initialized to the same format
//      tag as the pwfx member specifies. This query type may be used to
//      get a string description of an arbitrary format structure.
//
//      If the details for the specified format cannot be retrieved
//      from this driver, then ACMERR_NOTPOSSIBLE should be returned.
//  
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdFormatDetails
(
    PDRIVERINSTANCE         pdi,
    LPACMFORMATDETAILS      padf,
    DWORD                   fdwDetails
)
{
    LPWAVEFORMATEX          pwfx;
    LPMSG723WAVEFORMAT		pwfg723;

    switch (ACM_FORMATDETAILSF_QUERYMASK & fdwDetails)
    {
        //
        //  enumerate by index
        //
        //  verify that the format tag is something we know about and
        //  return the details on the 'standard format' supported by
        //  this driver at the specified index...
        //
        case ACM_FORMATDETAILSF_INDEX:
            pwfx = padf->pwfx;

            switch (padf->dwFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (padf->dwFormatIndex >= ACM_DRIVER_MAX_FORMATS_PCM)
		      return (ACMERR_NOTPOSSIBLE);

                    pwfx->nSamplesPerSec
		      = PCM_SAMPLING_RATE[padf->dwFormatIndex]; 

                    pwfx->wFormatTag      = WAVE_FORMAT_PCM;

                    pwfx->nChannels       = 1;
                    pwfx->wBitsPerSample  = 16; 

                    pwfx->nBlockAlign     = PCM_BLOCKALIGNMENT(pwfx);
                    pwfx->nAvgBytesPerSec = pwfx->nSamplesPerSec * pwfx->nBlockAlign;

                    //
                    //  note that the cbSize field is NOT valid for PCM
                    //  formats
                    //
                    //  pwfx->cbSize      = 0;
                    break;

        
                case WAVE_FORMAT_MSG723:
                    if (padf->dwFormatIndex >= ACM_DRIVER_MAX_FORMATS_G723)
		      return (ACMERR_NOTPOSSIBLE);

                    pwfx->wFormatTag      = WAVE_FORMAT_MSG723;

                    pwfx->nSamplesPerSec
		      = G723_SAMPLING_RATE[padf->dwFormatIndex]; 

                    pwfx->nChannels       = G723_MAX_CHANNELS;
                    pwfx->wBitsPerSample  = G723_BITS_PER_SAMPLE;
                    pwfg723				  = (LPMSG723WAVEFORMAT)pwfx;

		    if(padf->dwFormatIndex == 0)
		    {
		      pwfx->nBlockAlign     = 24;
		      pwfx->nAvgBytesPerSec = 800;
		      pwfg723->wConfigWord  = Rate63+POST_FILTER;
		    }
		    if(padf->dwFormatIndex == 1)
		    {
		      pwfx->nBlockAlign     = 20;
		      pwfx->nAvgBytesPerSec = 666;
		      pwfg723->wConfigWord  = Rate53+POST_FILTER;
		    }
		    if(padf->dwFormatIndex == 2)
		    {
		      pwfx->nBlockAlign     = 24;
		      pwfx->nAvgBytesPerSec = 800;
		      pwfg723->wConfigWord=Rate63+POST_FILTER+SILENCE_ENABLE;
		    }
		    if(padf->dwFormatIndex == 3)
		    {
		      pwfx->nBlockAlign     = 20;
		      pwfx->nAvgBytesPerSec = 666;
		      pwfg723->wConfigWord=Rate53+POST_FILTER+SILENCE_ENABLE;
		    }
                    pwfx->cbSize          = G723_WFX_EXTRA_BYTES;

                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }

        //
        //  return details on specified format
        //
        //  the caller normally uses this to verify that the format is
        //  supported and to retrieve a string description...
        //
        case ACM_FORMATDETAILSF_FORMAT:
            pwfx = padf->pwfx;

            switch (pwfx->wFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    if (!pcmIsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                case WAVE_FORMAT_MSG723:
                    if (!g723IsValidFormat(pwfx))
                        return (ACMERR_NOTPOSSIBLE);
                    break;

                default:
                    return (ACMERR_NOTPOSSIBLE);
            }
            break;


        default:
            return (MMSYSERR_NOTSUPPORTED);
    }


    padf->cbStruct    = min(padf->cbStruct, sizeof(*padf));
    padf->fdwSupport  = ACMDRIVERDETAILS_SUPPORTF_CODEC;
    pwfg723	          = (LPMSG723WAVEFORMAT)pwfx;

	if(padf->dwFormatTag == WAVE_FORMAT_MSG723)
	{
		if((pwfg723->wConfigWord&5) == 0)
			LoadStringCodec(pdi->hinst, IDS_FORMAT_DETAILS_MONO_8KHZ_6400BIT_S,
			padf->szFormat,SIZEOFACMSTR(padf->szFormat));
		if((pwfg723->wConfigWord&5) == 4)
			LoadStringCodec(pdi->hinst, IDS_FORMAT_DETAILS_MONO_8KHZ_6400BIT_SID,
			padf->szFormat,SIZEOFACMSTR(padf->szFormat));
		if((pwfg723->wConfigWord&5) == 1)
			LoadStringCodec(pdi->hinst, IDS_FORMAT_DETAILS_MONO_8KHZ_5333BIT_S,
			padf->szFormat,SIZEOFACMSTR(padf->szFormat));
		if((pwfg723->wConfigWord&5) == 5)
			LoadStringCodec(pdi->hinst, IDS_FORMAT_DETAILS_MONO_8KHZ_5333BIT_SID,
			padf->szFormat,SIZEOFACMSTR(padf->szFormat));
	}
    else
	    padf->szFormat[0] = '\0';


    //
    //
    //
    return (MMSYSERR_NOERROR);
} // acmdFormatDetails()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamOpen
//
//  Description:
//      This function handles the ACMDM_STREAM_OPEN message. This message
//      is sent to initiate a new conversion stream. This is usually caused
//      by an application calling acmStreamOpen. If this function is
//      successful, then one or more ACMDM_STREAM_CONVERT messages will be
//      sent to convert individual buffers (user calls acmStreamConvert).
//
//      Note that an ACM driver will not receive open requests for ASYNC
//      or FILTER operations unless the ACMDRIVERDETAILS_SUPPORTF_ASYNC
//      or ACMDRIVERDETAILS_SUPPORTF_FILTER flags are set in the 
//      ACMDRIVERDETAILS structure. There is no need for the driver to
//      check for these requests unless it sets those support bits.
//
//      If the ACM_STREAMOPENF_QUERY flag is set in the padsi->fdwOpen
//      member, then no resources should be allocated. Just verify that
//      the conversion request is possible by this driver and return the
//      appropriate error (either ACMERR_NOTPOSSIBLE or MMSYSERR_NOERROR).
//      The driver will NOT receive an ACMDM_STREAM_CLOSE for queries.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      This structure will be passed back to all future stream messages
//      if the open succeeds. The information in this structure will never
//      change during the lifetime of the stream--so it is not necessary
//      to re-verify the information referenced by this structure.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//      A driver should return ACMERR_NOTPOSSIBLE if the conversion cannot
//      be performed due to incompatible source and destination formats.
//
//      A driver should return MMSYSERR_NOTSUPPORTED if the conversion
//      cannot be performed in real-time and the request does not specify
//      the ACM_STREAMOPENF_NONREALTIME flag.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamOpen
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi
)
{
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    LPMSG723WAVEFORMAT	pwfg723;
	CODDEF *CodStat;
	DECDEF *DecStat;
    G723CODDEF *g723Inst;
    INSTNCE *SD_Inst;

    UINT   psi;
	int i;

#ifdef G723_USECONFIG
    DWORD               nConfigMaxRTEncodeSamplesPerSec;
    DWORD               nConfigMaxRTDecodeSamplesPerSec;
    DWORD               dw;
#endif


    //
    //
    //
    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

//    fRealTime = (0 == (padsi->fdwOpen & ACM_STREAMOPENF_NONREALTIME));

    
    //
    //  this driver first verifies that the source and destination formats
    //  are acceptable...
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            if (!pcmIsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);

            if (!g723IsValidFormat(pwfxDst))
                return (ACMERR_NOTPOSSIBLE);

            break;

        case WAVE_FORMAT_MSG723:
            if (!g723IsValidFormat(pwfxSrc))
                return (ACMERR_NOTPOSSIBLE);

            if (!pcmIsValidFormat(pwfxDst))
                return (ACMERR_NOTPOSSIBLE);

            break;

        default:
            return (ACMERR_NOTPOSSIBLE);
    }

    //
    //  for this driver, we must also verify that the nChannels
    //  member is the same between the source and destination
    //  formats.
    //
    if (pwfxSrc->nChannels != pwfxDst->nChannels)
        return (MMSYSERR_NOTSUPPORTED);

    //
    //  we have determined that the conversion requested is possible by
    //  this driver. now check if we are just being queried for support.
    //  if this is just a query, then do NOT allocate any instance data
    //  or create tables, etc. just succeed the call.
    //
    if (0 != (ACM_STREAMOPENF_QUERY & padsi->fdwOpen))
    {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
		TTDBG(ghISRInst,TT_TRACE,"Stream open query");
#endif // } NO_DEBUGGING_OUTPUT
#endif
        return (MMSYSERR_NOERROR);
    }


    //
    //  we have decided that this driver can handle the conversion stream.
    //  so we want to do _AS MUCH WORK AS POSSIBLE_ right now to prepare
    //  for converting data. any resource allocation, table building, etc
    //  that can be dealt with at this time should be done.
    //
    //  THIS IS VERY IMPORTANT! all ACMDM_STREAM_CONVERT messages need to
    //  be handled as quickly as possible.
    //
    //  this driver allocates a small instance structure for each stream
    //
    //
    switch (pwfxSrc->wFormatTag)
    {
        case WAVE_FORMAT_PCM:

          g723Inst = LocalAlloc(LPTR,sizeof(G723CODDEF));
          if (NULL == g723Inst)
            return (MMSYSERR_NOMEM);

          CodStat = &g723Inst->CodStat;
          Init_Coder(CodStat);
          CodStat->UseHp = True;

          pwfg723 = (LPMSG723WAVEFORMAT)pwfxDst;

          CodStat->WrkRate = pwfg723->wConfigWord&RATE;

          CodStat->srccount = (int)0;
          for(i=0;i<SRCSTATELEN;i++)
            CodStat->srcstate[i] = (short)0;

/*****************************************************************
   Silence detector Init
*****************************************************************/

/* This value enables silence detection, early exit, and the default
** squelch value.
*/
			SD_Inst = &g723Inst->SD_Instance;
			SD_Inst->SDFlags = 0x00000005;
//			isFrameSilent = 0;		// initialize to "not silent"
/*
** Inintialize first OFFSET samples of storebuff
*/
			for(i=0;i<OFFSET;i++)SD_Inst->SDstate.Filt.storebuff[i] = 0.0f;
			glblSDinitialize(SD_Inst);

			psi = (DWORD)(UINT)g723Inst;

#ifndef NOTPRODUCT
            if ((pwfg723->dwCodeword1 == G723MAGICWORD1)
                && (pwfg723->dwCodeword2 == G723MAGICWORD2))
            {
              pdi->enabled = TRUE;
            }
#endif // NOTPRODUCT

			break;

        case WAVE_FORMAT_MSG723:

			DecStat = LocalAlloc(LPTR,sizeof(DECDEF));
		    if (NULL == DecStat)
        		return (MMSYSERR_NOMEM);

			Init_Decod(DecStat);				//low rate high pass and post filters enabled
            pwfg723 = (LPMSG723WAVEFORMAT)pwfxSrc;
			DecStat->UsePf = pwfg723->wConfigWord & POST_FILTER;

#ifndef NOTPRODUCT
          if ((pwfg723->dwCodeword1 == G723MAGICWORD1)
              && (pwfg723->dwCodeword2 == G723MAGICWORD2))
          {
            pdi->enabled = TRUE;
          }
#endif // NOTPRODUCT

//			DecStat->FrameSize = 20;
//			if((pwfg723->wConfigWord & RATE) == 0)
//				DecStat->FrameSize = 24;

			DecStat->srccount = (int)0;
			for(i=0;i<SRCSTATELEN;i++)
			  DecStat->srcstate[i] = (short)0;
			  DecStat->i = 0;
//			  DecStat->srcbuffend = DecStat->srcbuff;

			psi = (DWORD)(UINT)DecStat;
			break;
	}



    //
    //  fill out our instance structure
    //
    //  this driver stores a pointer to the conversion function that will
    //  be used for each conversion on this stream. we also store a 
    //  copy of the _current_ configuration of the driver instance we
    //  are opened on. this must not change during the life of the stream
    //  instance.
    //
    //  this is also very important! if the user is able to configure how
    //  the driver performs conversions, the changes should only affect
    //  future open streams. all current open streams should behave as
    //  they were configured during the open.
    //

//    psi->fnConvert      = fnConvert;
//   psi->fdwConfig      = pdi->fdwConfig;


    //
    //  fill in our instance data--this will be passed back to all stream
    //  messages in the ACMDRVSTREAMINSTANCE structure. it is entirely
    //  up to the driver what gets stored (and maintained) in the
    //  fdwDriver and dwDriver members.
    //
    padsi->fdwDriver = 0L;
    padsi->dwDriver  = psi;
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Stream Open padsi=%lx  psi=%lx",padsi,psi);
#endif // } NO_DEBUGGING_OUTPUT
#endif

    return (MMSYSERR_NOERROR);
} // acmdStreamOpen()


//--------------------------------------------------------------------------;
//
//  LRESULT acmdStreamClose
//
//  Description:
//      This function is called to handle the ACMDM_STREAM_CLOSE message.
//      This message is sent when a conversion stream is no longer being
//      used (the stream is being closed; usually by an application
//      calling acmStreamClose).
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//
//
//      An asyncronous conversion stream may fail with ACMERR_BUSY if there
//      are pending buffers. An application may call acmStreamReset to
//      force all pending buffers to be posted.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamClose
(
    LPACMDRVSTREAMINSTANCE  padsi
)
{
	UINT		psi;
#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
	CODDEF		*CodStat;
	G723CODDEF	*g723Inst;
#endif // } LOG_ENCODE_TIMINGS_ON
#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
	DECDEF		*DecStat;
#endif // } LOG_ENCODE_TIMINGS_ON

    //
    //  the driver should clean up all privately allocated resources that
    //  were created for maintaining the stream instance. if no resources
    //  were allocated, then simply succeed.
    //
    //  in the case of this driver, we need to free the stream instance
    //  structure that we allocated during acmdStreamOpen.
    //
    psi = (UINT)padsi->dwDriver;

#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Stream Close padsi=%lx  psi=%lx",padsi,psi);
#endif // } NO_DEBUGGING_OUTPUT
#endif
    if (0 != psi)
   {
#ifdef LOG_ENCODE_TIMINGS_ON // { LOG_ENCODE_TIMINGS_ON
		g723Inst = (G723CODDEF *)psi;
		CodStat = &g723Inst->CodStat;
		OutputEncodeTimingStatistics("c:\\encode.txt", CodStat->EncTimingInfo, CodStat->dwStatFrameCount);
#endif // } LOG_ENCODE_TIMINGS_ON
#ifdef LOG_DECODE_TIMINGS_ON // { LOG_DECODE_TIMINGS_ON
		DecStat = (DECDEF *)psi;
		OutputDecodeTimingStatistics("c:\\decode.txt", DecStat->DecTimingInfo, DecStat->dwStatFrameCount);
#endif // } LOG_DECODE_TIMINGS_ON

        //
        //  free the stream instance structure
        //
        LocalFree((HLOCAL)psi);
    }
    
    return (MMSYSERR_NOERROR);
} // acmdStreamClose()


//--------------------------------------------------------------------------;
//  
//  LRESULT acmdStreamSize
//  
//  Description:
//      This function handles the ACMDM_STREAM_SIZE message. The purpose
//      of this function is to provide the _largest size in bytes_ that
//      the source or destination buffer needs to be given the input and
//      output formats and the size in bytes of the source or destination
//      data buffer.
//
//      In other words: how big does my destination buffer need to be to
//      hold the converted data? (ACM_STREAMSIZEF_SOURCE)
//
//      Or: how big can my source buffer be given the destination buffer?
//      (ACM_STREAMSIZEF_DESTINATION)
//
//  Arguments:
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//  
//      LPACMDRVSTREAMSIZE padss: Specifies a pointer to the ACMDRVSTREAMSIZE
//      structure that defines the conversion stream size query attributes.
//  
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//  
//      An ACM driver should return MMSYSERR_NOTSUPPORTED if a query type
//      is requested that the driver does not understand. Note that a driver
//      must support both the ACM_STREAMSIZEF_DESTINATION and
//      ACM_STREAMSIZEF_SOURCE queries.
//
//      If the conversion would be 'out of range' given the input arguments,
//      then ACMERR_NOTPOSSIBLE should be returned.
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL acmdStreamSize
(
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMSIZE      padss
)
{
    PSTREAMINSTANCE         psi;
    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
    LPMSG723WAVEFORMAT		pwfg723;
    DWORD                   cb;
    DWORD                   cBlocks;
    DWORD                   cbBytesPerBlock;
    int i;

    pwfxSrc = padsi->pwfxSrc;
    pwfxDst = padsi->pwfxDst;

    psi = (PSTREAMINSTANCE)(UINT)padsi->dwDriver;

    //
    //
    //
    //
    //
    switch (ACM_STREAMSIZEF_QUERYMASK & padss->fdwSize)
    {
        case ACM_STREAMSIZEF_SOURCE:
            cb = padss->cbSrcLength;

            if (WAVE_FORMAT_MSG723 == pwfxSrc->wFormatTag)
            {
                //
                //  how many destination PCM bytes are needed to hold
                //  the decoded g723 data of padss->cbSrcLength bytes
                //
                //  always round UP
                //
                cBlocks = cb / pwfxSrc->nBlockAlign;
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                pwfg723 = (LPMSG723WAVEFORMAT)pwfxSrc;

		for(i=0;i<ACM_DRIVER_MAX_FORMATS_PCM;i++)
		  if (pwfxDst->nSamplesPerSec == PCM_SAMPLING_RATE[i])
		  {
		    cbBytesPerBlock = G723_SAMPLES_PER_BLOCK_PCM[i]
		                      * pwfxDst->nBlockAlign;
		    break;
		  }

                if (i == ACM_DRIVER_MAX_FORMATS_PCM)
		  return (ACMERR_NOTPOSSIBLE);

                if ((0xFFFFFFFFL / cbBytesPerBlock) < cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }
                if (0 == (cb % pwfxSrc->nBlockAlign))
                {
                    cb = cBlocks * cbBytesPerBlock;
                }
                else
                {
                    cb = (cBlocks + 1) * cbBytesPerBlock;
                }
		//
		// This ensures that there is enough room to adjust
		// from 11000 to 11025 Hz sampling rate when necessary
		//
		if (G723_SAMPLES_PER_BLOCK_PCM[i] == 330)
		  cb += (int)(1.0 + cBlocks / 440.0) * cbBytesPerBlock;
            }
            else
            {
                //
                //  how many destination g723 bytes are needed to hold
                //  the encoded PCM data of padss->cbSrcLength bytes
                //
                //  always round UP
                //
                pwfg723 = (LPMSG723WAVEFORMAT)pwfxDst;

		for(i=0;i<ACM_DRIVER_MAX_FORMATS_PCM;i++)
		  if (pwfxSrc->nSamplesPerSec == PCM_SAMPLING_RATE[i])
		  {
		    cbBytesPerBlock = G723_SAMPLES_PER_BLOCK_PCM[i]
		                      * pwfxSrc->nBlockAlign;
		    break;
		  }

                if (i == ACM_DRIVER_MAX_FORMATS_PCM)
		  return (ACMERR_NOTPOSSIBLE);

                cBlocks = cb / cbBytesPerBlock;

                if (0 == (cb % cbBytesPerBlock))
                {
                    cb = cBlocks * pwfxDst->nBlockAlign;
                }
                else
                {
                    cb = (cBlocks + 1) * pwfxDst->nBlockAlign;
                }

                if (0L == cb)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }
            }
            padss->cbDstLength = cb;
            return (MMSYSERR_NOERROR);


        case ACM_STREAMSIZEF_DESTINATION:
            cb = padss->cbDstLength;


            if (WAVE_FORMAT_MSG723 == pwfxDst->wFormatTag)
            {
                //
                //  how many source PCM bytes can be encoded into a
                //  destination buffer of padss->cbDstLength bytes
                //
                //  always round DOWN
                //
                cBlocks = cb / pwfxDst->nBlockAlign;
                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                pwfg723 = (LPMSG723WAVEFORMAT)pwfxDst;

		for(i=0;i<ACM_DRIVER_MAX_FORMATS_PCM;i++)
		  if (pwfxSrc->nSamplesPerSec == PCM_SAMPLING_RATE[i])
		  {
		    cbBytesPerBlock = G723_SAMPLES_PER_BLOCK_PCM[i]
		                      * pwfxSrc->nBlockAlign;
		    break;
		  }

                if (i == ACM_DRIVER_MAX_FORMATS_PCM)
		  return (ACMERR_NOTPOSSIBLE);

                if ((0xFFFFFFFFL / cbBytesPerBlock) < cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                cb = cBlocks * cbBytesPerBlock;
            }
            else
            {
                //
                //  how many source g723 bytes can be decoded into a
                //  destination buffer of padss->cbDstLength bytes
                //
                //  always round DOWN
                //
                pwfg723 = (LPMSG723WAVEFORMAT)pwfxSrc;

		for(i=0;i<ACM_DRIVER_MAX_FORMATS_PCM;i++)
		  if (pwfxDst->nSamplesPerSec == PCM_SAMPLING_RATE[i])
		  {
		    cbBytesPerBlock = G723_SAMPLES_PER_BLOCK_PCM[i]
		                      * pwfxDst->nBlockAlign;
		    break;
		  }

                if (i == ACM_DRIVER_MAX_FORMATS_PCM)
		  return (ACMERR_NOTPOSSIBLE);

                cBlocks = cb / cbBytesPerBlock;

		//
		// This ensures that there is enough room to adjust
		// from 11000 to 11025 Hz sampling rate when necessary
		//
		if (G723_SAMPLES_PER_BLOCK_PCM[i] == 330)
		  cBlocks -= (int)(1.0 + cBlocks / 440.0);

                if (0 == cBlocks)
                {
                    return (ACMERR_NOTPOSSIBLE);
                }

                cb = cBlocks * pwfxSrc->nBlockAlign;
            }

            padss->cbSrcLength = cb;
            return (MMSYSERR_NOERROR);
    }

    //
    //
    //
    return (MMSYSERR_NOTSUPPORTED);
} // acmdStreamSize()



//--------------------------------------------------------------------------;
//  
//  LRESULT acmdStreamConvert
//  
//  Description:
//      This function handles the ACMDM_STREAM_CONVERT message.
//
//  Arguments:
//      PDRIVERINSTANCE pdi: Pointer to private ACM driver instance structure.
//      This structure is [optionally] allocated during the DRV_OPEN message
//      which is handled by the acmdDriverOpen function.
//
//      LPACMDRVSTREAMINSTANCE padsi: Pointer to instance data for the
//      conversion stream. This structure was allocated by the ACM and
//      filled with the most common instance data needed for conversions.
//      The information in this structure is exactly the same as it was
//      during the ACMDM_STREAM_OPEN message--so it is not necessary
//      to re-verify the information referenced by this structure.
//  
//      LPACMDRVSTREAMHEADER padsh: Pointer to stream header structure
//      that defines the source data and destination buffer to convert.
//
//  Return (LRESULT):
//      The return value is zero (MMSYSERR_NOERROR) if this function
//      succeeds with no errors. The return value is a non-zero error code
//      if the function fails.
//  
//--------------------------------------------------------------------------;
LRESULT FNLOCAL acmdStreamConvert
(
    PDRIVERINSTANCE         pdi,
    LPACMDRVSTREAMINSTANCE  padsi,
    LPACMDRVSTREAMHEADER    padsh
)
{
    LPWAVEFORMATEX          pwfxSrc;
    LPWAVEFORMATEX          pwfxDst;
	LPMSG723WAVEFORMAT		pwfg723;

	UINT	psi;
	CODDEF *CodStat;
	DECDEF *DecStat;
    G723CODDEF *g723Inst;
    INSTNCE *SD_Inst;
	char	*Dst,*Src;
	short	*wDst;
	short	*wSrc;

	float Dbuf[240];
	short Ebuf[330];
	short Sbuf[240];
	int   i,k,m,cBlocks,temp,src_length,frame_size;
	int   Dst_length,isFrameSilent,silence,tmpbuf[24];
	int   pcm_format;

//__asm int 3
	psi = padsi->dwDriver;
   	pwfxSrc = padsi->pwfxSrc;
   	pwfxDst = padsi->pwfxDst;

    if (WAVE_FORMAT_PCM == pwfxSrc->wFormatTag) {
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
		TTDBG(ghISRInst,TT_TRACE,"Stream Encode padsi=%lx  psi=%lx",padsi,psi);
#endif // } NO_DEBUGGING_OUTPUT
#endif

        //
        //  Encode.
        //
	g723Inst = (G723CODDEF *)psi;
	CodStat = &g723Inst->CodStat;
	SD_Inst = &g723Inst->SD_Instance;

	pwfg723 = (LPMSG723WAVEFORMAT)padsi->pwfxDst;
	
	if(padsh->cbSrcLength == 0)
	  return (MMSYSERR_NOERROR);

      // *** compute # of frames that we can encode.***

      for(pcm_format=0;pcm_format<ACM_DRIVER_MAX_FORMATS_PCM;pcm_format++)
	if (pwfxSrc->nSamplesPerSec == PCM_SAMPLING_RATE[pcm_format])
	  break;
      if (pcm_format == ACM_DRIVER_MAX_FORMATS_PCM)
	return(MMSYSERR_INVALPARAM);

      cBlocks = padsh->cbSrcLength
	        / (pwfxSrc->nBlockAlign
		   * G723_SAMPLES_PER_BLOCK_PCM[pcm_format]);

      // check to see if there are enough extra samples to remove 
      // every 441st sample (to go from 11025 to 11000 Hz)

      if (G723_SAMPLES_PER_BLOCK_PCM[pcm_format] == 330)
      {
	i = padsh->cbSrcLength / pwfxSrc->nBlockAlign; // input samples
	k = cBlocks
	    * G723_SAMPLES_PER_BLOCK_PCM[pcm_format];  // used samples

	if (i - k < k / 441)          // if there aren't enough extra samples
	  cBlocks -= (1+k/(441*330)); // then decrement the number of blocks
      }

      if(cBlocks == 0)
      {
	padsh->cbDstLengthUsed = 0;
	padsh->cbSrcLengthUsed = 0;
	return (MMSYSERR_NOERROR);
      }

      wSrc = (short *)padsh->pbSrc;
      Dst = (char *)padsh->pbDst;
      frame_size = (CodStat->WrkRate == Rate63) ? 24 : 20;
      silence = 0;

      for(i=0;i<cBlocks;i++)
      {
	if (G723_SAMPLES_PER_BLOCK_PCM[pcm_format] == 330)
	{
	  for (k=0; k<330; k++)
	  {
	    Ebuf[k] = *wSrc++;

	    // *** code to adjust from 11025 Hz to 11000 Hz ***

	    if (++ CodStat->srccount == 441)
	    {
	      Ebuf[k] = *wSrc++;       // skip a sample
	      CodStat->srccount = 0;
	    }
	  }

	  convert11to8(Ebuf,Sbuf,CodStat->srcstate,330);

	  for (k=0; k<240; k++)
	    SD_Inst->SDstate.Filt.sbuff[k] = (float) Sbuf[k];
	}
	else
	  for (k=0; k<240; k++)
	    SD_Inst->SDstate.Filt.sbuff[k] = (float) *wSrc++;

        if(pwfg723->wConfigWord & SILENCE_ENABLE)
	{
	  prefilter(SD_Inst,SD_Inst->SDstate.Filt.sbuff,
		    SD_Inst->SDstate.Filt.storebuff,240);

	  getParams(SD_Inst, SD_Inst->SDstate.Filt.storebuff,240);

	  execSDloop(SD_Inst,&isFrameSilent,SDThreashold);
	}
	else isFrameSilent = 0;

	if(isFrameSilent)
	{
	  *Dst++ = 0x02;
	  *Dst++ = 0;
	  *Dst++ = 0;
	  *Dst++ = 0;

	  padsh->cbDstLengthUsed += 4;

	  silence++;
	}
	else
	{
	  Coder(SD_Inst->SDstate.Filt.sbuff,(Word32*)(long HUGE_T*)Dst,CodStat,0,1,0);

	  Dst += frame_size;

	  padsh->cbDstLengthUsed += frame_size;
	}
      }

      padsh->cbSrcLengthUsed = pwfxSrc->nBlockAlign
	                       * (wSrc - (short *)padsh->pbSrc);

      return (MMSYSERR_NOERROR);
    }
    else
    {

// Decode ---------------------------------------------

#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
      TTDBG(ghISRInst,TT_TRACE,"Stream Decode padsi=%lx  psi=%lx",padsi,psi);
#endif // } NO_DEBUGGING_OUTPUT
#endif

      for(pcm_format=0;pcm_format<ACM_DRIVER_MAX_FORMATS_PCM;pcm_format++)
	if (pwfxDst->nSamplesPerSec == PCM_SAMPLING_RATE[pcm_format])
	  break;
      if (pcm_format == ACM_DRIVER_MAX_FORMATS_PCM)
	return(MMSYSERR_INVALPARAM);

      DecStat = (DECDEF *)psi;

      cBlocks = 0;
      wDst = (short *)padsh->pbDst;
      Dst_length = padsh->cbDstLength;
      Src = (char *)padsh->pbSrc;
      src_length = padsh->cbSrcLength;
      padsh->cbSrcLengthUsed = 0;

      while(src_length > 0)
      {
	switch(*Src&3)
	{
          case 0 :
	    DecStat->WrkRate = Rate63;
	    frame_size = 24;
	    break;

	  case 1 :
	    DecStat->WrkRate = Rate53;
	    frame_size = 20;
	    break;

          case 2 :
//	    DecStat->WrkRate = Silent;  // Uncomment for V5.0 of G.723.1
	    frame_size = 4;		// this is an SID frame
            break;

         case 3 :
	   DecStat->WrkRate = Lost;
	   frame_size = 4;
	   break;
	}

	src_length-=frame_size;
	if(src_length < 0) break; // just in case we are given a partial frame

	memcpy(tmpbuf,(long HUGE_T *)Src,frame_size);
	Decod(Dbuf,(Word32*)(long HUGE_T*)tmpbuf,0,DecStat);
	Src += frame_size;
	padsh->cbSrcLengthUsed += frame_size;
	cBlocks++;
	
	if (G723_SAMPLES_PER_BLOCK_PCM[pcm_format] == 330)
	{
	  //
	  // Ouput Sampling rate is 11025 Hz
	  //
	  if (440 - DecStat->srccount <= 240)   // need to insert a sample?
	  {
	    DecStat->srcbuff[DecStat->i++] = FLOATTOSHORT(Dbuf[0]);
	    if (++ DecStat->srccount == 440) DecStat->srccount = 0;

	    DecStat->srcbuff[DecStat->i++] = FLOATTOSHORT(0.25 * Dbuf[0]
						    + 0.75 * Dbuf[1]);
	    if (++ DecStat->srccount == 440) DecStat->srccount = 0;

	    DecStat->srcbuff[DecStat->i++] = FLOATTOSHORT(0.50 * Dbuf[1]
						    + 0.50 * Dbuf[2]);
	    if (++ DecStat->srccount == 440) DecStat->srccount = 0;

	    DecStat->srcbuff[DecStat->i++] = FLOATTOSHORT(0.75 * Dbuf[2]
						    + 0.25 * Dbuf[3]);
	    if (++ DecStat->srccount == 440) DecStat->srccount = 0;

	    m = 3;
	  }
	  else m = 0;

	  for (k=m; k<240; k++)
	  {
	    DecStat->srcbuff[DecStat->i++] = FLOATTOSHORT(Dbuf[k]);
	    
	    if (++ DecStat->srccount == 440)
	      DecStat->srccount = 0;
	  }

	  if (DecStat->i == 480)
	  {
	    //
	    // *** 240 extra samples have accumulated ***
	    //
	    convert8to11(DecStat->srcbuff,wDst,DecStat->srcstate,480);
	    Dst_length -= 1320;   // two output frames (1320 bytes)
	    wDst += 660;

	    DecStat->i = 0;

	    if(Dst_length < 1320) break; // no more space in output buffer
	  }
	  else
	  {
	    //
	    // *** less than 240 extra samples have accumulated ***
	    //
	    convert8to11(DecStat->srcbuff,wDst,DecStat->srcstate,240);
	    Dst_length -= 660; 	       // one output frame (660 bytes)
	    wDst += 330;

	    //
	    // move partial frame to the front of the SRC buffer
	    //
            for(i=0;i<DecStat->i-240;i++)
	      DecStat->srcbuff[i] = DecStat->srcbuff[i+240];
	    DecStat->i -=240;

	    if(Dst_length < 1320) break; // no more space in output buffer
	  }
	}
	else
	{
	  //
	  // Ouput Sampling rate is 8000 Hz
	  //
	  for (k=0; k<240; k++)
	  {
	    temp = FLOATTOSHORT(Dbuf[k]);
	    *wDst++ = temp;
	  }

	  Dst_length -= 480;           // we just chewed up 480 bytes;
	  if(Dst_length < 480) break;  // we can't do any more!
	}
      }
      padsh->cbDstLengthUsed = pwfxDst->nBlockAlign * cBlocks
	                       * G723_SAMPLES_PER_BLOCK_PCM[pcm_format];
    }
	
    return (MMSYSERR_NOERROR);
} // acmdStreamConvert()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT DriverProc
//
//  Description:
//      
//
//  Arguments:
//      DWORD dwId: For most messages, dwId is the DWORD value that
//      the driver returns in response to a DRV_OPEN message. Each time
//      the driver is opened, through the OpenDriver API, the driver
//      receives a DRV_OPEN message and can return an arbitrary, non-zero
//      value. The installable driver interface saves this value and returns
//      a unique driver handle to the application. Whenever the application
//      sends a message to the driver using the driver handle, the interface
//      routes the message to this entry point and passes the corresponding
//      dwId. This mechanism allows the driver to use the same or different
//      identifiers for multiple opens but ensures that driver handles are
//      unique at the application interface layer.
//
//      The following messages are not related to a particular open instance
//      of the driver. For these messages, the dwId will always be zero.
//
//          DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
//
//      HDRVR hdrvr: This is the handle returned to the application 
//      by the driver interface.
//
//      UINT uMsg: The requested action to be performed. Message
//      values below DRV_RESERVED are used for globally defined messages.
//      Message values from DRV_RESERVED to DRV_USER are used for defined
//      driver protocols. Messages above DRV_USER are used for driver
//      specific messages.
//
//      LPARAM lParam1: Data for this message. Defined separately for
//      each message.
//
//      LPARAM lParam2: Data for this message. Defined separately for
//      each message.
//
//  Return (LRESULT):
//      Defined separately for each message. 
//
//--------------------------------------------------------------------------;

EXTERN_C LRESULT FNEXPORT DriverProc
(
    DWORD                   dwId, 
    HDRVR                   hdrvr,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    LRESULT             lr;
    PDRIVERINSTANCE     pdi;
    int	                k;

    //
    //  make pdi either NULL or a valid instance pointer. note that dwId
    //  is 0 for several of the DRV_* messages (ie DRV_LOAD, DRV_OPEN...)
    //  see acmdDriverOpen for information on what dwId is for other
    //  messages (instance data).
    //
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"DriverProc uMsg=%x lParam1=%lx lParam2=%lx",uMsg,lParam1,lParam2);
#endif // } NO_DEBUGGING_OUTPUT
#endif

    pdi = (PDRIVERINSTANCE)(UINT)dwId;
    switch (uMsg)
    {
        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_LOAD:
#ifdef _WIN32
            DbgInitialize(TRUE);
#endif
            return(1L);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_FREE:
            return (1L);
        
        //
        //  lParam1: Not used. Ignore this argument.
        //
        //  lParam2: Pointer to ACMDRVOPENDESC (or NULL).
        //
        case DRV_OPEN:
            lr = acmdDriverOpen(hdrvr, (LPACMDRVOPENDESC)lParam2);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_CLOSE:
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
		    TTDBG(ghISRInst,TT_TRACE,"Driver Closed");
#endif // } NO_DEBUGGING_OUTPUT
#endif
            lr = acmdDriverClose(pdi);
            return (lr);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_INSTALL:
            return ((LRESULT)DRVCNF_RESTART);

        //
        //  lParam1: Unused.
        //
        //  lParam2: Unused.
        //
        case DRV_REMOVE:
            return ((LRESULT)DRVCNF_RESTART);

            

        //
        //  lParam1: Not used.
        //
        //  lParam2: Not used.
        //
        case DRV_QUERYCONFIGURE:
            //
            //  set up lParam1 and lParam2 to values that can be used by
            //  acmdDriverConfigure to know that it is being 'queried'
            //  for configuration support.
            //
            lParam1 = -1L;
            lParam2 = 0L;

            //--fall through--//

        //
        //  lParam1: Handle to parent window for the configuration dialog
        //           box.
        //
        //  lParam2: Optional pointer to DRVCONFIGINFO structure.
        //
        case DRV_CONFIGURE:
            lr = acmdDriverConfigure(pdi, (HWND)lParam1, (LPDRVCONFIGINFO)lParam2);
            return (lr);


        //
        //  lParam1: Pointer to ACMDRIVERDETAILS structure.
        //
        //  lParam2: Size in bytes of ACMDRIVERDETAILS stucture passed.
        //
        case ACMDM_DRIVER_DETAILS:
            lr = acmdDriverDetails(pdi, (LPACMDRIVERDETAILS)lParam1);
            return (lr);

        //
        //  lParam1: Handle to parent window to use if displaying your own
        //           about box.
        //
        //  lParam2: Not used.
        //
        case ACMDM_DRIVER_ABOUT:
            lr = acmdDriverAbout(pdi, (HWND)lParam1);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVFORMATSUGGEST structure.
        //
        //  lParam2: Not used.
        //
       case ACMDM_FORMAT_SUGGEST:
            lr = acmdFormatSuggest(pdi, (LPACMDRVFORMATSUGGEST)lParam1);
            return (lr);


        //
        //  lParam1: Pointer to FORMATTAGDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMATTAG_DETAILS:
            lr = acmdFormatTagDetails(pdi, (LPACMFORMATTAGDETAILS)lParam1, lParam2);
            return (lr);

            
        //
        //  lParam1: Pointer to FORMATDETAILS structure.
        //
        //  lParam2: fdwDetails
        //
        case ACMDM_FORMAT_DETAILS:
            lr = acmdFormatDetails(pdi, (LPACMFORMATDETAILS)lParam1, lParam2);
            return (lr);

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not used.
        //
        case ACMDM_STREAM_OPEN:
            lr = acmdStreamOpen(pdi, (LPACMDRVSTREAMINSTANCE)lParam1);
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	  TTDBG(ghISRInst,TT_TRACE,"Stream open result:  %d",lr);
#endif // } NO_DEBUGGING_OUTPUT
#endif
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Not Used.
        //
        case ACMDM_STREAM_CLOSE:
            lr = acmdStreamClose((LPACMDRVSTREAMINSTANCE)lParam1);
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	  TTDBG(ghISRInst,TT_TRACE,"Stream close result:  %d",lr);
#endif // } NO_DEBUGGING_OUTPUT
#endif
            return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMSIZE structure.
        //
        case ACMDM_STREAM_SIZE:
          lr = acmdStreamSize((LPACMDRVSTREAMINSTANCE)lParam1,
                              (LPACMDRVSTREAMSIZE)lParam2);
          return (lr);

        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: Pointer to ACMDRVSTREAMHEADER structure.
        //
        case ACMDM_STREAM_CONVERT:
          if (pdi->enabled)
          {
            lr = acmdStreamConvert(pdi, (LPACMDRVSTREAMINSTANCE)lParam1,
                                   (LPACMDRVSTREAMHEADER)lParam2);
            return (lr);
          }
          else return(MMSYSERR_NOTSUPPORTED);


        //
        //  lParam1: Setting for Silence detector threashold.
        //
        //  lParam2: Not used. Ignore this argument.
	//
        case DRV_USER:
	  k = (int)SDThreashold;
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	  TTDBG(ghISRInst,TT_TRACE,"Old Threashold = %d",k);
#endif // } NO_DEBUGGING_OUTPUT
#endif
	  SDThreashold = (float)lParam1;
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	  TTDBG(ghISRInst,TT_TRACE,"Setting Threashold to %ld",lParam1);
#endif // } NO_DEBUGGING_OUTPUT
#endif
	  return (lParam1);
        
#ifndef NOTPRODUCT
        //
        //  DRV_USER+1
        //
        //  lParam1: Pointer to ACMDRVSTREAMINSTANCE structure.
        //
        //  lParam2: 0 = PCM stream, 1 = G.723.1 stream
        //
        case DRV_USER+1:
          if (lParam1 == G723MAGICWORD1 && lParam2 == G723MAGICWORD2)
            pdi->enabled = TRUE;
          else
            pdi->enabled = FALSE;

	  return (MMSYSERR_NOERROR);
#endif // NOTPRODUCT

    }

    //
    //  if we are executing the following code, then this ACM driver does not
    //  handle the message that was sent. there are two ranges of messages
    //  we need to deal with:
    //
    //  o   ACM specific driver messages: if an ACM driver does not answer a
    //      message sent in the ACM driver message range, then it must
    //      return MMSYSERR_NOTSUPPORTED. this applies to the 'user'
    //      range as well (for consistency).
    //
    //  o   other installable driver messages: if an ACM driver does not
    //      answer a message that is NOT in the ACM driver message range,
    //      then it must call DefDriverProc and return that result.
    //      the exception to this is ACM driver procedures installed as
    //      ACM_DRIVERADDF_FUNCTION through acmDriverAdd. in this case,
    //      the driver procedure should conform to the ACMDRIVERPROC
    //      prototype and also return zero instead of calling DefDriverProc.
    //
#ifdef DEBUG
#ifndef NO_DEBUGGING_OUTPUT // { NO_DEBUGGING_OUTPUT
	TTDBG(ghISRInst,TT_TRACE,"Unknown command %d / %d",uMsg,DRV_USER);
#endif // } NO_DEBUGGING_OUTPUT
#endif
    if (uMsg >= ACMDM_USER)
        return (MMSYSERR_NOTSUPPORTED);
    else
        return (DefDriverProc(dwId, hdrvr, uMsg, lParam1, lParam2));
} // DriverProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\isrg.h ===
/****************************************************************************

	INTEL CORPORATION PROPRIETARY INFORMATION
	Copyright (c) 1992 Intel Corporation
	All Rights Reserved

	This software is supplied under the terms of a license
	agreement or non-disclosure agreement with Intel Corporation
	and may not be copied or disclosed except in accordance
	with the terms of that agreement

    $Source: q:/prism/include/rcs/isrg.h $
  $Revision:   1.0  $
      $Date:   11 Jun 1996 11:05:20  $
    $Author:   KMILLS  $
    $Locker:  $

	Description
	-----------
	Interrupt Service Routine debug header file
	This module allows for a way of doing OutputDebugString()
	at interrupt time.

****************************************************************************/

#ifndef ISRG_H
#define ISRG_H

#ifdef __cplusplus
extern "C" {				// Assume C declarations for C++.
#endif // __cplusplus

// Use for Win16
//#define DllExport
//#define DllImport
//#define DLL_EXPORT	_export

// Use for Win32
#define DllExport		__declspec( dllexport )
#define DllImport		__declspec( dllimport )
#define DLL_EXPORT

//
//	directions
//		Pick a number (mod 100) and create a base for the next 
//		100 entries.  Do it this way so that your numbers can
//		be easily moved.  The string assigned to the base you select
//		will be displayed as the filter string in a list box when
//		viewing.  After defining your constants go to isrdsp.rc
//		and assign strings to them.  You will need to build the
//		isrdsp.exe but not the isrdbg.dll.  You only need to
//		inlude this h file and import the functions from this
//		file into your def file.  Happy debugging.


//------------------------------------------------------------------------------
#define kModSNameSize		16
#define kModLNameSize		32

//------------------------------------------------------------------------------
// defines for tISRModule.Flags
#define kCaptureOn			0x01

//------------------------------------------------------------------------------
typedef struct _tISRModule
{
	WORD	Flags;
	BYTE	CaptureFilter;
	BYTE	DisplayFilter;
	char	zSName[kModSNameSize];	// Short name of user registered debug module
	char	zLName[kModLNameSize];	// Long name of user registered debug module
} tISRModule, FAR *ptISRModule;

//------------------------------------------------------------------------------
#define kModuleBufSize		((DWORD) (16*1024L))
#define kMaxModules			((UINT) (kModuleBufSize/sizeof(tISRModule)))


//------------------------------------------------------------------------------
typedef struct _tISRItem
{
	WORD	hISRInst;		// Our handle to registered modules
	BYTE	DbgLevel;		// Caller determined debug level
	BYTE	Flags;
	UINT	IP;				// Callers Instruction Ptr address
	DWORD	Param1;
	DWORD	Param2;
} tISRItem, FAR *ptISRItem;

//------------------------------------------------------------------------------
#define kISRBufSize			((DWORD) (32*1024L))
#define kMaxISRItems		((UINT) (kISRBufSize/sizeof(tISRItem)))
#define kMaxStrTab			((UINT) (60*1024L))


//------------------------------------------------------------------------------
// defines for tISRItem.Flags
#define kParam1IsStr		0x01
#define kParam1IsRes		0x02
#define kParam1IsNum		0x04		// Use only if passed two numbers.


//------------------------------------------------------------------------------
// Supported DbgMsg state values.
//------------------------------------------------------------------------------
#define DBG 				0
#define ERR 				1

#define kISRCritical		0x01	// Progammer errors that should never happen
#define kISRError			0x02	// Errors that need to be fixed
#define kISRWarning			0x04	// The user could have problems if not corrected
#define kISRNotify			0x08	// Status, events, settings...
#define kISRTrace			0x10	// Trace info that will not overrun the system
#define kISRTemp			0x20	// Trace info that may be reproduced in heavy loops
#define kISRReserved1		0x40	// Future use
#define kISRReserved2		0x80	// Future use
#define kISRDefault			kISRReserved2	// Historical use only

#define TT_CRITICAL			kISRCritical
#define TT_ERROR			kISRError
#define TT_WARNING			kISRWarning
#define TT_NOTIFY			kISRNotify
#define TT_TRACE			kISRTrace
#define TT_TEMP				kISRTemp


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you want to output at interrupt time.
// The ISR_Hook*() functions are the same as their counterparts.  The only
// difference is that these functions need the Instruction Pointer passed
// in.  If you are using an intermediate library to encapsulate the debug
// functions then you must be responsible for pulling the IP off the stack.

// Register the module and get a handle for making debug calls.  If a debug
// call is made with an invalid handle then the results are not defined.
// It is possible to drop the debug event or to place the event into the 
// compatibility module.  If no more module handles are available then
// the handle returned will be the compatibility handle.
DllExport void WINAPI DLL_EXPORT
ISR_RegisterModule (LPWORD phISRInst, LPSTR zShortName, LPSTR zLongName);


// Allow two strings to be concatenated togeter.
DllExport void WINAPI DLL_EXPORT
ISR_HookDbgStrStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_HookDbgRes (UINT IP, WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_HookDbgStr (UINT IP, WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);

// Allow two strings to be concatenated togeter.
DllExport void WINAPI DLL_EXPORT
ISR_DbgStrStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, LPSTR pzStr2);

// Use a resource to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_DbgRes (WORD hISRInst, BYTE DbgLevel, UINT uResId, DWORD Param1);

// Use a str to format a number.
DllExport void WINAPI DLL_EXPORT
ISR_DbgStr (WORD hISRInst, BYTE DbgLevel, LPSTR pzStr1, DWORD Param1);


// WARNING: Call at task time only.  Not reentrant.
DllExport void FAR cdecl DLL_EXPORT
TTDbgMsg 
(
	WORD		hISRInst,	// Module's ISRDBG handle.
	BYTE		DbgLevel,	// Appropriate ISRDBG level.
	LPCSTR		zMsgFmt,	// Output format string (like printf).
	... 					// Optional parameter list.
);


// Old functions for compatibility only.
DllExport void WINAPI DLL_EXPORT
ISR_OutputDbgStr (LPSTR pzStr);

DllExport void WINAPI DLL_EXPORT
ISR_OutputStr (UINT uResId);

DllExport void WINAPI DLL_EXPORT
ISR_OutputNum (UINT uResId, DWORD Num);

// WARNING: Call at task time only.  Not reentrant.
DllExport void FAR cdecl DLL_EXPORT
DbgMsg
	(
	LPCSTR		module,
	int			state,
	LPCSTR		format_str,
	...
	);


//------------------------------------------------------------------------------
// exports from isrdbg.dll
// Include these in your def file if you need to know the state of isrdbg.dll.
// isrdsp.exe needs to do this to display the data at task time.

DllExport void WINAPI DLL_EXPORT
ISR_ClearItems (void);

DllExport UINT WINAPI DLL_EXPORT
ISR_GetNumItems (void);

DllExport UINT WINAPI DLL_EXPORT
ISR_GetNumModules (void);

DllExport ptISRItem WINAPI DLL_EXPORT
ISR_GetItem (UINT uItem,ptISRItem pItem);

DllExport ptISRModule WINAPI DLL_EXPORT
ISR_GetModule (UINT hISRInst);

DllExport int WINAPI DLL_EXPORT
ISR_SetCaptureFilter (WORD hISRInst, BYTE CaptureFilter,  BYTE DisplayFilter);


//------------------------------------------------------------------------------
//	The caller of ISR debug functions can call these Macros and then the
//	retail release will just drop all of the debug statement code.
//------------------------------------------------------------------------------
#if (DEBUG >= 1) || (_DEBUG >= 1)
#define ISRDEBUGINFO	1
extern WORD	ghISRInst;
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)	ISR_RegisterModule(pghISRInst, ShortName, LongName)
#define ISRNOTIFY(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRNotify, Str, Num)
#define ISRCRITICAL(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRCritical, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRError, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRWarning, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTrace, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)		ISR_DbgStr(ghISRInst, kISRTemp, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved1, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)	ISR_DbgStr(ghISRInst, kISRReserved2, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRNotify, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRCritical, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRError, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRWarning, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTrace, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)		ISR_DbgStrStr(ghISRInst, kISRTemp, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved1, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)	ISR_DbgStrStr(ghISRInst, kISRReserved2, Str, Str2)

#define TTDBG			TTDbgMsg

#else

#define ISRNOTIFY(ghISRInst, Str, Num)
#define ISRREGISTERMODULE(pghISRInst, ShortName, LongName)
#define ISRCRITICAL(ghISRInst, Str, Num)
#define ISRERROR(ghISRInst, Str, Num)
#define ISRWARNING(ghISRInst, Str, Num)
#define ISRTRACE(ghISRInst, Str, Num)
#define ISRTEMP(ghISRInst, Str, Num)
#define ISRRESERVED1(ghISRInst, Str, Num)
#define ISRRESERVED2(ghISRInst, Str, Num)

#define ISRSNOTIFY(ghISRInst, Str, Str2)
#define ISRSCRITICAL(ghISRInst, Str, Str2)
#define ISRSERROR(ghISRInst, Str, Str2)
#define ISRSWARNING(ghISRInst, Str, Str2)
#define ISRSTRACE(ghISRInst, Str, Str2)
#define ISRSTEMP(ghISRInst, Str, Str2)
#define ISRSRESERVED1(ghISRInst, Str, Str2)
#define ISRSRESERVED2(ghISRInst, Str, Str2)

#define ghISRInst		0
#define TTDBG			1 ? (void)0 : TTDbgMsg

#endif


//------------------------------------------------------------------------------
// Local Functions
static void
InitModules (void);

static UINT
ValidCaptureMsg (WORD hISRInst, BYTE DbgLevel);

// Local function but thunk needs to get to it
DllExport void WINAPI
OutputRec
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	DWORD	Param1,
	DWORD	Param2
	);

// Local function but thunk needs to get to it
DllExport void WINAPI
OutputRecStr
	(
	WORD	hISRInst,		// Our handle to registered modules
	BYTE	DbgLevel,		// Caller determined debug level
	BYTE	Flags,
	UINT	IP,				// Callers Instruction Ptr address
	LPSTR	pzStr1,
	LPSTR	pzStr2,
	DWORD	Param1
	);


//------------------------------------------------------------------------------
// do not use a base of 0.  Reserved for system use.
#define ID_SysBase			0
#define ID_SysStr			(ID_SysBase + 1)
#define ID_SysSInt			(ID_SysBase + 2)
#define ID_SysUInt			(ID_SysBase + 3)
#define ID_SysDWord			(ID_SysBase + 4)
#define ID_SysLong			(ID_SysBase + 5)
#define ID_SysHex			(ID_SysBase + 6)


//------------------------------------------------------------------------------
// IsrDbg.dll
#define ID_IsrDbgBase		100
#define ID_IsrDbgLibMain	(ID_IsrDbgBase + 1)
#define ID_IsrDbgWep		(ID_IsrDbgBase + 2)
#define ID_IsrDbgReentrant	(ID_IsrDbgBase + 3)


//------------------------------------------------------------------------------
// IsrDsp.exe
#define ID_IsrDspBase		200
#define ID_IsrDspInit		(ID_IsrDspBase + 1)
#define ID_IsrDspExit		(ID_IsrDspBase + 2)


//------------------------------------------------------------------------------
// stMem.dll
#define ID_stMemBase		300
#define ID_stMemLibMain		(ID_stMemBase + 1)
#define ID_stMemWep			(ID_stMemBase + 2)
#define ID_stMemPreAlloc	(ID_stMemBase + 3)
#define ID_stMemPageLock	(ID_stMemBase + 4)
#define ID_stMemNoPageLock	(ID_stMemBase + 5)
#define ID_stMemAlloc		(ID_stMemBase + 6)
#define ID_stMemTotMem		(ID_stMemBase + 7)
#define ID_stMemstFree		(ID_stMemBase + 8)

                                                      
//-------------------------------------------------------------------------------
// DLM.dll

// Errors
#define ID_DLMErrorBase		400
#define ID_DLMEnqError      (ID_DLMErrorBase + 1)
#define ID_DLMDeqError      (ID_DLMErrorBase + 2)
#define ID_DLMFreeError     (ID_DLMErrorBase + 3)
#define ID_DLMChanError     (ID_DLMErrorBase + 4)
#define ID_DLMChanNIUErr    (ID_DLMErrorBase + 5)
#define ID_DLMChanNumErr    (ID_DLMErrorBase + 6)
#define ID_DLMInConnErr     (ID_DLMErrorBase + 7)
#define ID_DLMInSessErr     (ID_DLMErrorBase + 8)
#define ID_DLMSessNIU       (ID_DLMErrorBase + 9)
#define ID_DLMSessNO        (ID_DLMErrorBase + 10)
#define ID_DLMConnNIU       (ID_DLMErrorBase + 11)
#define ID_DLMConnNO        (ID_DLMErrorBase + 12)
#define ID_DLMIDErr         (ID_DLMErrorBase + 13)
#define ID_DLMConnErr       (ID_DLMErrorBase + 14)
#define ID_DLMSessErr       (ID_DLMErrorBase + 15)
#define ID_DLMSessNF        (ID_DLMErrorBase + 16)
#define ID_DLMNoFreeConn    (ID_DLMErrorBase + 17)
#define ID_DLMConnCloseErr  (ID_DLMErrorBase + 18)
#define ID_DLMConnNF        (ID_DLMErrorBase + 19)
#define ID_DLMConnNC        (ID_DLMErrorBase + 20)
#define ID_DLMMDMError      (ID_DLMErrorBase + 21)
#define ID_DLMNoSess        (ID_DLMErrorBase + 22)
#define ID_DLMInvalidSess   (ID_DLMErrorBase + 23)
#define ID_DLMEventErr      (ID_DLMErrorBase + 24)
#define ID_DLMNoConn        (ID_DLMErrorBase + 25)
#define ID_DLMChanCloseErr  (ID_DLMErrorBase + 26) 
#define ID_DLMInvalidConn   (ID_DLMErrorBase + 27)
#define ID_DLMCorruptQueue  (ID_DLMErrorBase + 28)
#define ID_DLMInvChanID     (ID_DLMErrorBase + 29)
#define ID_DLMChanInUse     (ID_DLMErrorBase + 30)
#define ID_DLMInvalidChan   (ID_DLMErrorBase + 31)
#define ID_DLMNoBufHdr      (ID_DLMErrorBase + 32)
#define ID_DLMEnqueueErr    (ID_DLMErrorBase + 33)
#define ID_DLMNMBufInProg   (ID_DLMErrorBase + 34)
#define ID_DLMNoBuffer      (ID_DLMErrorBase + 35)
#define ID_DLMEnterDumping  (ID_DLMErrorBase + 36)
#define ID_DLMSizeError     (ID_DLMErrorBase + 37)
#define ID_DLMNoBuf         (ID_DLMErrorBase + 38)
#define ID_DLMInitAlready   (ID_DLMErrorBase + 39)
#define ID_DLMGDLError      (ID_DLMErrorBase + 40)
#define ID_DLMNoEntryPoint  (ID_DLMErrorBase + 41)
#define ID_DLMNoEvent       (ID_DLMErrorBase + 42)
#define ID_DLMNoPackets     (ID_DLMErrorBase + 43)

// Debug level 1 messages
#define ID_DLMDebug1Base         500
#define ID_DLMCloseAllEntered    (ID_DLMDebug1Base + 1)
#define ID_DLMEstabHEntered      (ID_DLMDebug1Base + 2)
#define ID_DLMEstabHExit         (ID_DLMDebug1Base + 3)
#define ID_DLMReqHEntered        (ID_DLMDebug1Base + 4)
#define ID_DLMReqHAlloc          (ID_DLMDebug1Base + 5)
#define ID_DLMReqHExit           (ID_DLMDebug1Base + 6)
#define ID_DLMRejHEntered        (ID_DLMDebug1Base + 7)
#define ID_DLMRejHExit           (ID_DLMDebug1Base + 8)
#define ID_DLMCNoteHEntered      (ID_DLMDebug1Base + 9)
#define ID_DLMCNoteHExit         (ID_DLMDebug1Base + 10)
#define ID_DLMCComHEntered       (ID_DLMDebug1Base + 11)
#define ID_DLMCComHExit          (ID_DLMDebug1Base + 12)
#define ID_DLMSessCloseHEntered  (ID_DLMDebug1Base + 13)
#define ID_DLMSessCloseHExit     (ID_DLMDebug1Base + 14)
#define ID_DLMSessHEntered       (ID_DLMDebug1Base + 15)
#define ID_DLMSessHExit          (ID_DLMDebug1Base + 16)
#define ID_DLMBegSessEntered     (ID_DLMDebug1Base + 17)
#define ID_DLMBegSessExit        (ID_DLMDebug1Base + 18)
#define ID_DLMEndSessEntered     (ID_DLMDebug1Base + 19)
#define ID_DLMEndSessExit        (ID_DLMDebug1Base + 20)
#define ID_DLMListenEntered      (ID_DLMDebug1Base + 21)
#define ID_DLMListenExit         (ID_DLMDebug1Base + 22)
#define ID_DLMDoCloseEntered     (ID_DLMDebug1Base + 23)
#define ID_DLMDoCloseExit        (ID_DLMDebug1Base + 24)
#define ID_DLMMakeConnEntered    (ID_DLMDebug1Base + 25)
#define ID_DLMMakeConnExit       (ID_DLMDebug1Base + 26)
#define ID_DLMRejEntered         (ID_DLMDebug1Base + 27)
#define ID_DLMRejExit            (ID_DLMDebug1Base + 28)
#define ID_DLMAccEntered         (ID_DLMDebug1Base + 29)
#define ID_DLMAccExit            (ID_DLMDebug1Base + 30)
#define ID_DLMCloseConnEntered   (ID_DLMDebug1Base + 31)
#define ID_DLMCloseConnExit      (ID_DLMDebug1Base + 32)
#define ID_DLMTryEntered         (ID_DLMDebug1Base + 33)
#define ID_DLMTryExit            (ID_DLMDebug1Base + 34)
#define ID_DLMOpenEntered        (ID_DLMDebug1Base + 35)
#define ID_DLMOpenExit           (ID_DLMDebug1Base + 36)
#define ID_DLMSendEntered        (ID_DLMDebug1Base + 37)
#define ID_DLMSendExit           (ID_DLMDebug1Base + 38)
#define ID_DLMSendComEntered     (ID_DLMDebug1Base + 39)
#define ID_DLMSendComExit        (ID_DLMDebug1Base + 40)
#define ID_DLMPostEntered        (ID_DLMDebug1Base + 41)
#define ID_DLMPostExit           (ID_DLMDebug1Base + 42)
#define ID_DLMNewMsgEntered      (ID_DLMDebug1Base + 43)
#define ID_DLMNewMsgExit         (ID_DLMDebug1Base + 44)
#define ID_DLMContMsgEntered     (ID_DLMDebug1Base + 45)
#define ID_DLMContMsgExit        (ID_DLMDebug1Base + 46)
#define ID_DLMRecEntered         (ID_DLMDebug1Base + 47)
#define ID_DLMRecExit            (ID_DLMDebug1Base + 48)
#define ID_DLMCloseEntered       (ID_DLMDebug1Base + 49)
#define ID_DLMCloseExit          (ID_DLMDebug1Base + 50)
#define ID_DLMGetCharEntered     (ID_DLMDebug1Base + 51)
#define ID_DLMGetCharExit        (ID_DLMDebug1Base + 52)
#define ID_DLMInitEntered        (ID_DLMDebug1Base + 53)
#define ID_DLMInitExit           (ID_DLMDebug1Base + 54)
#define ID_DLMDeInitEntered      (ID_DLMDebug1Base + 55)
#define ID_DLMDeInitExit         (ID_DLMDebug1Base + 56)
#define ID_DLMCloseAllExit       (ID_DLMDebug1Base + 57)
#define ID_DLMEnqEntered         (ID_DLMDebug1Base + 58)
#define ID_DLMEnqExit            (ID_DLMDebug1Base + 59)
#define ID_DLMDeqEntered         (ID_DLMDebug1Base + 60)
#define ID_DLMDeqExit            (ID_DLMDebug1Base + 61)
#define ID_DLMEnqPEntered        (ID_DLMDebug1Base + 62)
#define ID_DLMEnqPExit           (ID_DLMDebug1Base + 63)


// Debug level 2 messages
#define ID_DLMDebug2Base         600
#define ID_DLMCallback           (ID_DLMDebug2Base + 1)
#define ID_DLMConnection         (ID_DLMDebug2Base + 2)
#define ID_DLMBuffer             (ID_DLMDebug2Base + 3)
#define ID_DLMSize               (ID_DLMDebug2Base + 4)
#define ID_DLMRemaining          (ID_DLMDebug2Base + 5)
#define ID_DLMReceived           (ID_DLMDebug2Base + 6)
#define ID_DLMToken              (ID_DLMDebug2Base + 7)
#define ID_DLMOChannel           (ID_DLMDebug2Base + 8)
#define ID_DLMRChannel           (ID_DLMDebug2Base + 9)
#define ID_DLMStatus             (ID_DLMDebug2Base + 10)
#define ID_DLMEndSessClosing     (ID_DLMDebug2Base + 11)
#define ID_DLMBufferSize         (ID_DLMDebug2Base + 12)
#define ID_DLMLinkPacket         (ID_DLMDebug2Base + 13)
#define ID_DLMChannel            (ID_DLMDebug2Base + 14)
#define ID_DLMInDumping          (ID_DLMDebug2Base + 15)
#define ID_DLMByteCount          (ID_DLMDebug2Base + 16)
#define ID_DLMDeqNoBuf           (ID_DLMDebug2Base + 17)
#define ID_DLMEnqPSkip           (ID_DLMDebug2Base + 18)


//------------------------------------------------------------------------------
// MDM -> mdmnbios.dll

#define ID_mdmBase				700
#define ID_mdmLibMain			(ID_mdmBase + 1)
#define ID_mdmWep				(ID_mdmBase + 2)
#define ID_mdmBadhSesUser		(ID_mdmBase + 3)
#define ID_mdmBadhConUser		(ID_mdmBase + 4)
#define ID_mdmBadhSesFree		(ID_mdmBase + 5)
#define ID_mdmBadhConFree		(ID_mdmBase + 6)
#define ID_mdmBadhSesInt		(ID_mdmBase + 7)
#define ID_mdmBadhConInt		(ID_mdmBase + 8)
#define ID_mdmNoMorehSes		(ID_mdmBase + 9)
#define ID_mdmNoMorehCon		(ID_mdmBase + 10)
#define ID_mdmWepConFree		(ID_mdmBase + 11)
#define ID_mdmActiveCon			(ID_mdmBase + 12)
#define ID_mdmBBegSes			(ID_mdmBase + 13)
#define ID_mdmEBegSes			(ID_mdmBase + 14)
#define ID_mdmBEndSes			(ID_mdmBase + 15)
#define ID_mdmEEndSes			(ID_mdmBase + 16)
#define ID_mdmBListen			(ID_mdmBase + 17)
#define ID_mdmEListen			(ID_mdmBase + 18)
#define ID_mdmBMakeCon			(ID_mdmBase + 19)
#define ID_mdmEMakeCon			(ID_mdmBase + 20)
#define ID_mdmBAcceptCon		(ID_mdmBase + 21)
#define ID_mdmEAcceptCon		(ID_mdmBase + 22)
#define ID_mdmBRejectCon		(ID_mdmBase + 23)
#define ID_mdmERejectCon		(ID_mdmBase + 24)
#define ID_mdmBCloseCon			(ID_mdmBase + 25)
#define ID_mdmECloseCon			(ID_mdmBase + 26)
#define ID_mdmErrNetBios		(ID_mdmBase + 27)
#define ID_mdmNoSendNcb			(ID_mdmBase + 28)
#define ID_mdmNoFreeSndNcbSlot	(ID_mdmBase + 29)
#define ID_mdmInvalidConState	(ID_mdmBase + 30)
#define ID_mdmInvalidParams		(ID_mdmBase + 31)
#define ID_mdmToManyListens		(ID_mdmBase + 32)
#define ID_mdmKillTheListen		(ID_mdmBase + 33)
#define ID_mdmBListenCB			(ID_mdmBase + 34)
#define ID_mdmEListenCB			(ID_mdmBase + 35)
#define ID_mdmBConnectCB		(ID_mdmBase + 36)
#define ID_mdmEConnectCB		(ID_mdmBase + 37)
#define ID_mdmBCloseCB			(ID_mdmBase + 38)
#define ID_mdmECloseCB			(ID_mdmBase + 39)
#define ID_mdmBSndCB			(ID_mdmBase + 40)
#define ID_mdmESndCB			(ID_mdmBase + 41)
#define ID_mdmBRcvCB			(ID_mdmBase + 42)
#define ID_mdmERcvCB			(ID_mdmBase + 43)


//---------------------------------------------------------------------------------
// MDM -> MDM Teleos

// Errors
#define ID_MDMTEBASE               1000
#define ID_MDMTEDeqUnackNoHead     (ID_MDMTEBASE + 1)
#define ID_MDMTEDeqUnackNoNext     (ID_MDMTEBASE + 2)
#define ID_MDMTEDeqUnackNoPrev     (ID_MDMTEBASE + 3)
#define ID_MDMTEDeqArrNoTail       (ID_MDMTEBASE + 4)
#define ID_MDMTENullTCB            (ID_MDMTEBASE + 5)
#define ID_MDMTETCBRet             (ID_MDMTEBASE + 6)
#define ID_MDMTEWinSize            (ID_MDMTEBASE + 7)
#define ID_MDMTENoLinkPacket       (ID_MDMTEBASE + 8)
#define ID_MDMTETooLarge           (ID_MDMTEBASE + 9)
#define ID_MDMTELPNotFound         (ID_MDMTEBASE + 10)
#define ID_MDMTENoTCB              (ID_MDMTEBASE + 11)
#define ID_MDMTEInitAlready        (ID_MDMTEBASE + 12)
#define ID_MDMTETCBInitFail        (ID_MDMTEBASE + 13)
#define ID_MDMTELSNErr             (ID_MDMTEBASE + 14)
#define ID_MDMTESizeError          (ID_MDMTEBASE + 15)
#define ID_MDMTEReceived           (ID_MDMTEBASE + 16)
#define ID_MDMTEExpected           (ID_MDMTEBASE + 17)
#define ID_MDMTECorruptQ           (ID_MDMTEBASE + 18)
#define ID_MDMTENoInit             (ID_MDMTEBASE + 19)
#define ID_MDMTEAbanPack           (ID_MDMTEBASE + 20)
#define ID_MDMTESeqNum             (ID_MDMTEBASE + 21)
#define ID_MDMTESipPend            (ID_MDMTEBASE + 22)
#define ID_MDMTENoConn             (ID_MDMTEBASE + 23)
#define ID_MDMTEInvalidID          (ID_MDMTEBASE + 24)
#define ID_MDMTENoSess             (ID_MDMTEBASE + 25)
#define ID_MDMTENoLPM              (ID_MDMTEBASE + 26)
#define ID_MDMTESessID             (ID_MDMTEBASE + 27)
#define ID_MDMTESessNIU            (ID_MDMTEBASE + 28)
#define ID_MDMTESize               (ID_MDMTEBASE + 29)
#define ID_MDMTEState              (ID_MDMTEBASE + 30)
#define ID_MDMTEConnID             (ID_MDMTEBASE + 31)
#define ID_MDMTEConnNIU            (ID_MDMTEBASE + 32)
#define ID_MDMTETinyPacket         (ID_MDMTEBASE + 33)
#define ID_MDMTEPacketOOS          (ID_MDMTEBASE + 34)
#define ID_MDMTEECBNotFound        (ID_MDMTEBASE + 35)

// Trace Information
#define ID_MDMTTBASE               1100
#define ID_MDMTTB1CEnter         (ID_MDMTTBASE + 1)
#define ID_MDMTTB1CExit          (ID_MDMTTBASE + 2)
#define ID_MDMTTSB1Enter         (ID_MDMTTBASE + 3)
#define ID_MDMTTSB1Exit          (ID_MDMTTBASE + 4)
#define ID_MDMTTB2CEnter         (ID_MDMTTBASE + 5)
#define ID_MDMTTB2CExit          (ID_MDMTTBASE + 6)
#define ID_MDMTTSB2Enter         (ID_MDMTTBASE + 7)
#define ID_MDMTTSB2Exit          (ID_MDMTTBASE + 8)
#define ID_MDMTTSendEnter        (ID_MDMTTBASE + 9)
#define ID_MDMTTSendExit         (ID_MDMTTBASE + 10)
#define ID_MDMTTInitEnter        (ID_MDMTTBASE + 11)
#define ID_MDMTTInitExit         (ID_MDMTTBASE + 12)
#define ID_MDMTTDeInitEnter      (ID_MDMTTBASE + 13)
#define ID_MDMTTDeInitExit       (ID_MDMTTBASE + 14)
#define ID_MDMTTLB1Enter         (ID_MDMTTBASE + 15)
#define ID_MDMTTLB1Exit          (ID_MDMTTBASE + 16)
#define ID_MDMTTLB2Enter         (ID_MDMTTBASE + 17)
#define ID_MDMTTLB2Exit          (ID_MDMTTBASE + 18)
#define ID_MDMTTNBSEnter         (ID_MDMTTBASE + 19)
#define ID_MDMTTNBSExit          (ID_MDMTTBASE + 20)
#define ID_MDMTTRecEnter         (ID_MDMTTBASE + 21)
#define ID_MDMTTRecExit          (ID_MDMTTBASE + 22)
#define ID_MDMTTCTSEnter         (ID_MDMTTBASE + 23)
#define ID_MDMTTCTSExit          (ID_MDMTTBASE + 24)
#define ID_MDMTTGCEnter          (ID_MDMTTBASE + 25)
#define ID_MDMTTGCExit           (ID_MDMTTBASE + 26)
#define ID_MDMTTBegSessEnter     (ID_MDMTTBASE + 27)
#define ID_MDMTTBegSessExit      (ID_MDMTTBASE + 28)
#define ID_MDMTTEndSessEnter     (ID_MDMTTBASE + 29)
#define ID_MDMTTEndSessExit      (ID_MDMTTBASE + 30)
#define ID_MDMTTMakeConEnter     (ID_MDMTTBASE + 31)
#define ID_MDMTTMakeConExit      (ID_MDMTTBASE + 32)
#define ID_MDMTTCloseConEnter    (ID_MDMTTBASE + 33)
#define ID_MDMTTCloseConExit     (ID_MDMTTBASE + 34)
#define ID_MDMTTListEnter        (ID_MDMTTBASE + 35)
#define ID_MDMTTListExit         (ID_MDMTTBASE + 36)
#define ID_MDMTTAccEnter         (ID_MDMTTBASE + 37)
#define ID_MDMTTAccExit          (ID_MDMTTBASE + 38)
#define ID_MDMTTRejEnter         (ID_MDMTTBASE + 39)
#define ID_MDMTTRejExit          (ID_MDMTTBASE + 40)
#define ID_MDMTTRecLookEnter     (ID_MDMTTBASE + 41)
#define ID_MDMTTRecLookExit      (ID_MDMTTBASE + 42)

// Comment Information
#define ID_MDMTCBASE               1200
#define ID_MDMTCSeqNum             (ID_MDMTCBASE + 1)
#define ID_MDMTCFound              (ID_MDMTCBASE + 2)
#define ID_MDMTCWaiting            (ID_MDMTCBASE + 3)
#define ID_MDMTCCTSFail            (ID_MDMTCBASE + 4)
#define ID_MDMTCCTSPass            (ID_MDMTCBASE + 5)
#define ID_MDMTCCTSize             (ID_MDMTCBASE + 6)
#define ID_MDMTCCTSOut             (ID_MDMTCBASE + 7)
#define ID_MDMTCTCB                (ID_MDMTCBASE + 8)
#define ID_MDMTCECBPMAddr          (ID_MDMTCBASE + 9)
#define ID_MDMTCECBRMAddr          (ID_MDMTCBASE + 10)

#ifdef __cplusplus
}						// End of extern "C" {
#endif // __cplusplus

#endif	// h file included already
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\exc_lbc.c ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//


#include "opt.h"

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <memory.h>
#include "typedef.h"
#include "cst_lbc.h"
#include "tab_lbc.h"
#include "util_lbc.h"
#include "exc_lbc.h"
#include "timer.h"
#include "mmxutil.h"

// This file contains pitch and excitation related functions.
//------------------------------------------------------
#if COMPILE_MMX

int Estim_Int(float *Dpnt, int Start)
{
  int  i,k;

#define NCOR (PitchMax+1-PitchMin)   // = 128 (rounded up to mult of 4)
#define NTAPS (2*SubFrLen+12)        // = 132

  int Pr,Indx = PitchMin;
  float MaxE = 1.0f;
  float MaxC = 0.0f;
  float E,C2,E2,Diff;
  int corr[NCOR];

  typedef struct
  {
    short taps[4][NTAPS];                  //**  These two arrays need
    short temp[PitchMax-3+2*SubFrLen];     //**  to be 8-byte aligned
    double foo;
  } EstimStruct;

  EstimStruct est,*e;
  e = &est;

  ASM
  {
    mov eax,e;
    add e,7;
    and e,0fffffff8h;
    mov e,eax;
  }

// Convert just the necessary portion of Dpnt to 16-bit integers,
// store the result in 'temp'.  4 guard bits are needed since the
// correlations are length 120, which means 7 guard bits are needed.
// So we use 4 so that 4+4=8 guard bits are present in the product.

  FloatToShortScaled(&Dpnt[Start-PitchMax+3],e->temp,PitchMax-3+2*SubFrLen,4);

  MakeAligned4(&e->temp[PitchMax-3],e->taps[0],2*NTAPS);
  MakeAligned2(&e->temp[PitchMax-4],e->taps[1],2*NTAPS);
  MakeAligned0(&e->temp[PitchMax-5],e->taps[2],2*NTAPS);
  MakeAligned6(&e->temp[PitchMax-6],e->taps[3],2*NTAPS);

  for (i=0; i<4; i++)
  {
    for (k=0; k<i; k++)
      e->taps[i][k] = 0;
    for (k=NTAPS-12+i; k<NTAPS; k++)
      e->taps[i][k] = 0;
  }

// Compute cross-correlations, store in corr[] array

  CorrelateInt4(e->taps[0],e->temp,corr,NTAPS-12,NCOR>>2);
  for (i=1; i<4; i++)
    CorrelateInt4(e->taps[i],e->temp,&corr[i],NTAPS,NCOR>>2);


// Now do the actual pitch search.
  
  Pr = Start - PitchMin;
  k = PitchMax-PitchMin-3;
  E = DotProd(&Dpnt[Pr],&Dpnt[Pr],2*SubFrLen);  // first energy value

  for (i=0; i < (PitchMax-2-PitchMin); i++)
  {
// Update energy

    E = E - Dpnt[Pr+2*SubFrLen]*Dpnt[Pr+2*SubFrLen] + Dpnt[Pr]*Dpnt[Pr];

// Check for new maximum

    if (corr[k] > 0)
    {
      C2 = ((float)corr[k]) * ((float)corr[k]);
      E2 = C2*MaxE;
      Diff = (E2 - E*MaxC)*4.0f;
      if (asint(Diff) > asint(E2) || (Diff > 0.0f && ((i - Indx) < PitchMin)))
      {
        Indx = i;
        MaxE = E;
        MaxC = C2;
      }
    }
    Pr--;
    k--;
  }
  return(Indx+PitchMin);
}

#endif



//------------------------------------------------------
int Estim_Pitch(float *Dpnt, int Start)
{
  int  i;

  int Pr,Indx = PitchMin;
  float MaxE = 1.0f;
  float MaxC = 0.0f;
  float E,C,C2,E2,Diff;
  int *dptr,*eptr;

  dptr = (int *)&Diff;
  eptr = (int *)&E2;
  Pr = Start - PitchMin + 1;

// Init the energy estimate
  
  E = DotProd(&Dpnt[Pr],&Dpnt[Pr],2*SubFrLen);

// Main Open loop pitch search loop
  
  for (i=PitchMin; i <= PitchMax-3; i++)
  {
    Pr--;


// Update energy, compute cross

    C = DotProd(&Dpnt[Start],&Dpnt[Pr],2*SubFrLen);
    E = E - Dpnt[Pr+2*SubFrLen]*Dpnt[Pr+2*SubFrLen] + Dpnt[Pr]*Dpnt[Pr];
    C2 = C*C;

// Check for new maximum

    E2 = C2*MaxE;
    Diff = (E2 - E*MaxC)*4.0f;
    if (C > 0.0f && E > 0.0f &&
      (*dptr > *eptr || (Diff > 0.0f && ((i - Indx) < PitchMin))))
    {
      Indx = i;
      MaxE = E;
      MaxC = C2;
    }
  }
  return Indx;
}



//------------------------------------------------------
PWDEF Comp_Pw(float *Dpnt, int Start, int Olp)
{

  int  i,k;
  float Energy,C,E,C2,MaxE,MaxC2,MaxC,Gopt;
  PWDEF Pw;

// Compute target energy

  Energy = DotProd(&Dpnt[Start],&Dpnt[Start],SubFrLen);

// Find position with maximum C2/E value

  MaxE = 1.0f;
  MaxC = 0.0f;
  MaxC2 = 0.0f;
  Pw.Indx = -1;
  Pw.Gain = 0.0f;
  k = Start - (Olp-PwRange);
  E = DotProd(&Dpnt[k],&Dpnt[k],SubFrLen);
  
  for (i=0; i <= 2*PwRange; i++)
  {
    C = DotProd(&Dpnt[Start],&Dpnt[k],SubFrLen);

    if (E > 0.0f && C > 0.0f)
    {
      C2 = C*C;
      if (C2*MaxE > E*MaxC2)
      {
        Pw.Indx = i;
        MaxE = E;
        MaxC = C;
        MaxC2 = C2;
      }
    }
    k--;

    if (k < 0)
    {
      break;
    }

    E = E - Dpnt[k+SubFrLen]*Dpnt[k+SubFrLen] + Dpnt[k]*Dpnt[k];

  }

  if (Pw.Indx == -1)
  {
    Pw.Indx = Olp;
	return Pw;
  }

  Pw.Gain = 0.0f;
  if (MaxC2 > MaxE*Energy*0.375f)
  {
    if (MaxC > MaxE || MaxE == 0.0f)
      Gopt = 1.0f;
    else
      Gopt = (float) fabs(MaxC)/MaxE;

    Pw.Gain = 0.3125f*Gopt;
  }
  Pw.Indx = Olp - PwRange + Pw.Indx;
  return Pw;


}



//--------------------------------------------------------------
void  Filt_Pw(float *DataBuff, float *Dpnt, int Start, PWDEF Pw)
{
  int  i;

// Perform the harmonic weighting
  
  for (i=0; i < SubFrLen; i++)
    DataBuff[Start+i] = Dpnt[PitchMax+Start+i] -
                        Pw.Gain*Dpnt[PitchMax+Start-Pw.Indx+i];
}


//-----------------------------------------------------------------
void  Find_Fcbk(float *Dpnt, float *ImpResp, LINEDEF *Line, int Sfc, enum Crate WrkRate, int flags, int UseMMX)
{
  int  i;
  int  Srate,T0_acelp;
  float gain_T0;

  BESTDEF  Best = {0};

  switch(WrkRate)
  {
    case Rate63:
      Srate = Nb_puls[Sfc];
      Best.MaxErr = -99999999.9f;

      if (flags & SC_FINDB)
      {
        if ((*Line).Olp[Sfc>>1] < SubFrLen-2)
          Find_Best(&Best, Dpnt, ImpResp, Srate, (*Line).Olp[Sfc>>1]);
        else
          Find_Best(&Best, Dpnt, ImpResp, Srate, SubFrLen);
      }
      else
      {
        Find_Best(&Best, Dpnt, ImpResp, Srate, SubFrLen);
        if ((*Line).Olp[Sfc>>1] < SubFrLen-2)
          Find_Best(&Best, Dpnt, ImpResp, Srate, (*Line).Olp[Sfc>>1]);
      }

// Reconstruct the excitation
    
      for (i=0; i <  SubFrLen; i++)
        Dpnt[i] = 0.0f;

      for (i=0; i < Srate; i++)
        Dpnt[Best.Ploc[i]] = Best.Pamp[i];

// Code the excitation
    
      Fcbk_Pack(Dpnt, &((*Line).Sfs[Sfc]), &Best, Srate);

      if (Best.UseTrn == 1)
        Gen_Trn(Dpnt, Dpnt, (*Line).Olp[Sfc>>1]);
      break;
	 
    case Rate53:

      T0_acelp = search_T0 ((*Line).Olp[Sfc>>1]-1+(*Line).Sfs[Sfc].AcLg,
        (*Line).Sfs[Sfc].AcGn, &gain_T0);

      
#if COMPILE_MMX
      if (UseMMX)
	  {
		  (*Line).Sfs[Sfc].Ppos = ACELP_LBC_code_int(Dpnt, ImpResp, T0_acelp, Dpnt,
					&(*Line).Sfs[Sfc].Mamp,  &(*Line).Sfs[Sfc].Grid,
					&(*Line).Sfs[Sfc].Pamp, gain_T0, flags);
	  }
      else
#endif //COMPILE_MMX
	  {
		  (*Line).Sfs[Sfc].Ppos = ACELP_LBC_code(Dpnt, ImpResp, T0_acelp, Dpnt,
					&(*Line).Sfs[Sfc].Mamp,  &(*Line).Sfs[Sfc].Grid,
					&(*Line).Sfs[Sfc].Pamp, gain_T0, flags);

	  }
      (*Line).Sfs[Sfc].Tran = 0;
      break;
  }

  return;
}


//---------------------------------------------------------
void  Fcbk_Unpk(float *Tv, SFSDEF Sfs, int Olp, int Sfc, enum Crate WrkRate)
{
  int  i,j,Np;
  float  Tv_tmp[SubFrLen+4];
  float  acelp_gain,gain_T0;
  int acelp_sign, acelp_shift, acelp_pos;
  int offset, ipos, T0_acelp;
  Word32 Acc0;

	switch(WrkRate)
    {
		case Rate63:
        {
          Np = Nb_puls[Sfc];

          for (i=0; i < SubFrLen; i++)
            Tv[i] = 0.0f;

          if (Sfs.Ppos >= MaxPosTable[Sfc])
           return;

// Decode the amplitudes and positions
      
          j = MaxPulseNum - Np;
          Acc0 = Sfs.Ppos;

          for (i = 0; i < SubFrLen/Sgrid; i++)
          {
            Acc0 -= CombinatorialTable[j][i];

            if (Acc0 < (Word32) 0)
            {
              Acc0 += CombinatorialTable[j][i];
              j++;

            if ((Sfs.Pamp & (1 << (MaxPulseNum-j))) != 0)
              Tv[Sfs.Grid + Sgrid*i] = -FcbkGainTable[Sfs.Mamp];
            else
              Tv[Sfs.Grid + Sgrid*i] =  FcbkGainTable[Sfs.Mamp];

            if (j == MaxPulseNum)
              break;
           }
         }

         if (Sfs.Tran == 1)
           Gen_Trn(Tv, Tv, Olp);
         break;
    }

    case Rate53:
    {

      for (i = 0; i < SubFrLen+4; i++)
        Tv_tmp[i] = 0.0f;

      acelp_gain = FcbkGainTable[Sfs.Mamp];
      acelp_shift = Sfs.Grid;
      acelp_sign = Sfs.Pamp;
      acelp_pos = Sfs.Ppos;
      
      offset  = 0;
      for(i=0; i<4; i++)
      {
        ipos = (acelp_pos & 7);
        ipos = (ipos << 3) + acelp_shift + offset;
        
        if((acelp_sign & 1)== 1)
          Tv_tmp[ipos] = acelp_gain;
        else
          Tv_tmp[ipos] = -acelp_gain;
        
        offset += 2;
        acelp_pos = acelp_pos >> 3;
        acelp_sign = acelp_sign >> 1;
      }
      for (i = 0; i < SubFrLen; i++)
        Tv[i] = Tv_tmp[i];
      
      T0_acelp = search_T0(Olp-1+Sfs.AcLg, Sfs.AcGn, &gain_T0);
      if (T0_acelp < SubFrLen-2)
      {
        for (i = T0_acelp; i < SubFrLen; i++)
          Tv[i] += Tv[i-T0_acelp]*gain_T0;
      }
   break;
    }
  }
  return;
}


//---------------------------------------------------------------------
void Acbk_Filt(float *output,float *input,float fac,float *impresp)
{
#if OPT_ACBKF

  ASM
  {
    push esi;
    push edi;
    push ebx;

    mov eax,58;
    mov esi,input;
    mov edi,output;
    mov ebx,impresp;

loop1:
    fld  DP[ebx+4*eax];
    fmul fac;
    fld  DP[ebx+4*eax-4];
    fmul fac;
    fld  DP[ebx+4*eax-8];
    fmul fac;
    fld  DP[ebx+4*eax-12];
    fmul fac;                // a3 a2 a1 a0

    fxch ST(3);
    fadd DP[esi+4*eax];      // b0 a2 a1 a3
    fxch ST(2);
    fadd DP[esi+4*eax-4];    // b1 a2 b0 a3
    fxch ST(1);
    fadd DP[esi+4*eax-8];    // b2 b1 b0 a3
    fxch ST(3);
    fadd DP[esi+4*eax-12];   // b3 b1 b0 b2

    fxch ST(2);
    fstp DP[edi+4*eax];      // b1 b3 b2
    fstp DP[edi+4*eax-4];    // b3 b2
    fxch ST(1);
    fstp DP[edi+4*eax-8];
    fstp DP[edi+4*eax-12];

    sub eax,4;
    cmp eax,2;
    jg  loop1;

    pop ebx;
    pop edi;
    pop esi;
  }

#else

  int i;

  for (i=58; i>2; i-=4)
  {
    output[i-0] = fac*impresp[i-0] + input[i-0];
    output[i-1] = fac*impresp[i-1] + input[i-1];
    output[i-2] = fac*impresp[i-2] + input[i-2];
    output[i-3] = fac*impresp[i-3] + input[i-3];
  }
#endif
  
  output[2] = fac*impresp[2] + input[2];
  output[1] = fac*impresp[1] + input[1];
  output[0] = fac*impresp[0] + input[0];
}
//---------------------------------------------------------------------
#if COMPILE_MMX
void  Find_AcbkInt(float *Tv, float *ImpResp, float *PrevExc, LINEDEF
*Line, int Sfc, enum Crate WrkRate, int flags, CODDEF *CodStat)
{
  int  i,j,k;

  float RezBuf[SubFrLen+ClPitchOrd-1];

  short TvInt[SubFrLen];
  int   Tvxi[SubFrLen];

  short *lPntInt,*sPntInt,*PtrInt;

  int	CorBufInt[4*(2*ClPitchOrd + ClPitchOrd*(ClPitchOrd-1)/2)];
  int  *lPntd;

  long	Acc0l, Acc1l;
 
  int   Olp,Lid,Gid,Hb,t,k1,k2;
  int	Bound[3];
  int	Lag1, Lag2;
  int	MaxInt,off_filt;

  int shift,Tshift,mx;

  DECLARE_SHORT(FltBuf0Int,63);
  DECLARE_SHORT(FltBuf1Int,63);
  DECLARE_SHORT(FltBuf2Int,63);
  DECLARE_SHORT(FltBuf3Int,63);
  DECLARE_SHORT(FltBuf4Int,63) ;
  DECLARE_SHORT(CorVctInt,4*(2*ClPitchOrd + ClPitchOrd*(ClPitchOrd-1)/2)) ;
  DECLARE_SHORT(RezTmpInt,16) ;
  DECLARE_SHORT(RezBufInt,SubFrLen+ClPitchOrd-1) ;
  DECLARE_SHORT(ImpRespInt,63);

  DECLARE_SHORT(Ix,2*SubFrLen+16) ;
  DECLARE_SHORT(Rx,2*SubFrLen+16);
  DECLARE_INT(Temp,64);

  ALIGN_ARRAY(FltBuf0Int);
  ALIGN_ARRAY(FltBuf1Int);
  ALIGN_ARRAY(FltBuf2Int);
  ALIGN_ARRAY(FltBuf3Int);
  ALIGN_ARRAY(FltBuf4Int);
  ALIGN_ARRAY(RezBufInt);
  ALIGN_ARRAY(RezTmpInt);
  ALIGN_ARRAY(ImpRespInt);
  ALIGN_ARRAY(CorVctInt);

  ALIGN_ARRAY(Ix);
  ALIGN_ARRAY(Rx);
  ALIGN_ARRAY(Temp);


  Olp = (*Line).Olp[Sfc>>1];
  Lid = Pstep;
  Gid = 0;
  Hb  = 3 + (Sfc & 1);

// For even frames only
  
  if ((Sfc & 1) == 0)
  {
    if (Olp == PitchMin)
      Olp++;
    if (Olp > (PitchMax-5))
      Olp = PitchMax-5;
  }

  if (flags & SC_LAG1)
  {
   lPntInt = &CorVctInt[20];
    k1 = 1;
    k2 = 2;
  }
  else
  {
   lPntInt = CorVctInt;
    k1 = 0;
    k2 = Hb;
  }

//TIMER_SPOT_ON(Conversion);
  //Convert Tv to 16-bit
  ConstFloatToInt(Tv, Tvxi, SubFrLen, 32768.0f);
  for(i=0; i<SubFrLen; i++) TvInt[i] = (short)(((Tvxi[i]<<1)+0x00008000)>>16);

  //Convert ImpResp to 16-bit
  //Scale by 2^14 & truncate bits right of decimal
  ConstFloatToShort(ImpResp,ImpRespInt,SubFrLen,16384.0f);

  for (k=k1; k<k2; k++)
  {
   lPntd = &CorBufInt[k*20];

// Get residual from the excitation buffer
    
  	Get_Rez(RezBuf, PrevExc, Olp-Pstep+k);

	//Convert RezBuf to 16-bit
	ConstFloatToShort(RezBuf,RezBufInt,SubFrLen+ClPitchOrd-1,1.0f);

	// Filter the last one (ClPitchOrd-1) using the impulse responce
//TIMER_SPOT_OFF(Conversion);
//TIMER_SPOT_ON(Convolution);  
 
	ab2abbcw(&RezBufInt[ClPitchOrd-1], Rx, SubFrLen);

	j=0;
	for(i=0; i<SubFrLen;    i+=2){
		Ix[j]  =Ix[j+2]=ImpRespInt[SubFrLen-1-i];
		Ix[j+1]=Ix[j+3]=ImpRespInt[SubFrLen-2-i];
		j+=4;
	}
	for(i=0; i<16; i++)
		Ix[j+i]=0;
	
	ConvMMX(Rx, Ix, Temp, 60);
	for(i=0; i<SubFrLen; i++) FltBuf4Int[i] = (short)(((Temp[i]<<1)+0x00008000)>>16);

//TIMER_SPOT_OFF(Convolution);
//TIMER_SPOT_ON(FbufCalc);
    
	// Update the others (ClPitchOrd-2 down to 0)
	Acc0l = ((RezBufInt[3]<<13)+0x00004000)>>15;
	FltBuf3Int[0] = (short)Acc0l;

	Acc0l = ((RezBufInt[2]<<13)+0x00004000)>>15;
	FltBuf2Int[0] = (short)Acc0l;

	Acc0l = ((RezBufInt[1]<<13)+0x00004000)>>15;
	FltBuf1Int[0] = (short)Acc0l;

	Acc0l = ((RezBufInt[0]<<13)+0x00004000)>>15;
	FltBuf0Int[0] = (short)Acc0l;

	DupRezBuf(RezBufInt,RezTmpInt);

	FBufCalcInt(FltBuf4Int,FltBuf3Int,ImpRespInt,RezTmpInt,0);
	FBufCalcInt(FltBuf3Int,FltBuf2Int,ImpRespInt,RezTmpInt,1);
	FBufCalcInt(FltBuf2Int,FltBuf1Int,ImpRespInt,RezTmpInt,2);
	FBufCalcInt(FltBuf1Int,FltBuf0Int,ImpRespInt,RezTmpInt,3);

//TIMER_SPOT_OFF(FbufCalc);
//TIMER_SPOT_ON(Dots);
	// Compute the cross products with the signal

	*lPntd++ = DotMMX60(TvInt,FltBuf0Int)<<1;
	*lPntd++ = DotMMX60(TvInt,FltBuf1Int)<<1;
	*lPntd++ = DotMMX60(TvInt,FltBuf2Int)<<1;
	*lPntd++ = DotMMX60(TvInt,FltBuf3Int)<<1;
	*lPntd++ = DotMMX60(TvInt,FltBuf4Int)<<1;

// Compute the energies
   	 
	*lPntd++ = DotMMX60(FltBuf0Int,FltBuf0Int)<<1;
	*lPntd++ = DotMMX60(FltBuf1Int,FltBuf1Int)<<1;
	*lPntd++ = DotMMX60(FltBuf2Int,FltBuf2Int)<<1;
	*lPntd++ = DotMMX60(FltBuf3Int,FltBuf3Int)<<1;
	*lPntd++ = DotMMX60(FltBuf4Int,FltBuf4Int)<<1;

// Compute the between crosses

	*lPntd++ = DotMMX60(FltBuf1Int,FltBuf0Int)<<2;

	*lPntd++ = DotMMX60(FltBuf2Int,FltBuf0Int)<<2;
	*lPntd++ = DotMMX60(FltBuf2Int,FltBuf1Int)<<2;

	*lPntd++ = DotMMX60(FltBuf3Int,FltBuf0Int)<<2;
	*lPntd++ = DotMMX60(FltBuf3Int,FltBuf1Int)<<2;
	*lPntd++ = DotMMX60(FltBuf3Int,FltBuf2Int)<<2;

	*lPntd++ = DotMMX60(FltBuf4Int,FltBuf0Int)<<2;
	*lPntd++ = DotMMX60(FltBuf4Int,FltBuf1Int)<<2;
	*lPntd++ = DotMMX60(FltBuf4Int,FltBuf2Int)<<2;
	*lPntd++ = DotMMX60(FltBuf4Int,FltBuf3Int)<<2;

//TIMER_SPOT_OFF(Dots);

  }

  //Convert k1 through k2 indices of CorBufInt to 16-bit
  //	values
  Acc1l = 0L;
  for(j=k1; j<k2; j++)
  {
  	 for(i=0; i<20; i++)
	 {
  	 	Acc0l = abs(CorBufInt[j*20 + i]);
	 	if( Acc0l > Acc1l) Acc1l = Acc0l;
	 }
  }

  //Need a convert_long_to_short routine
  shift = norm(Acc1l);
  for(j=k1; j<k2; j++)
  {
	 for(i=0; i<20; i++)
	 {
  	  	CorBufInt[j*20 + i]=CorBufInt[j*20 + i]<<shift;
	  	CorBufInt[j*20 + i] += 0x00008000L; //round up to 16 MSBs
	  	*lPntInt++=(short)(CorBufInt[j*20 + i]>>16);
	  }
  }

  /* Test potential error */
  Lag1 = Olp - Pstep;
  Lag2 = Olp - Pstep + Hb - 1;

  off_filt = Test_Err(Lag1, Lag2, CodStat);

  Bound[0] =  NbFilt085_min + (off_filt << 2);
  if(Bound[0] > NbFilt085) Bound[0] = NbFilt085;
  Bound[1] =  NbFilt170_min + (off_filt << 3);
  if(Bound[1] > NbFilt170) Bound[1] = NbFilt170;

  Bound[2] = 85; //Use subset table in the case t=2

  MaxInt = 0;

  for (k=k1; k<k2; k++)
  {

// Select Quantization table
    
    t = 0;
    if (WrkRate == Rate63)
    {
      if ((Sfc & 1) == 0)
      {
        if (Olp-Pstep+k >= SubFrLen-2)
          t = 1;
      }
      else
      {
        if (Olp >= SubFrLen-2)
          t = 1;
      }
    }
    else
      t = 1;

	/* If Bound=170 and SC_GAIN=TRUE, use 170subset table.
	   Else, use full table with limited Bound.*/ 
    //if (t==1 && (flags & SC_GAIN) && Bound[t]==NbFilt170)
	if ((WrkRate == Rate53) && (flags & SC_GAIN) && (Bound[t]==NbFilt170))
      t = 2;
    
// Search for maximum
//t=1;

	sPntInt = AcbkGainTablePtrInt[t];
	PtrInt = &CorVctInt[k*20];

//TIMER_SPOT_ON(CodeBook);
   
	CodeBkSrch(PtrInt, sPntInt, Bound[t], &Gid, &MaxInt);

//TIMER_SPOT_OFF(CodeBook);
	  
    if (t==2)
	 Gid = GainScramble[Gid];
    //else
        //Gid = Gid;

	Lid = k;
  }

// Modify Olp for even sub frames
  
  if ((Sfc & 1) == 0)
  {
    Olp = Olp - Pstep + Lid;
    Lid = Pstep;
  }

// Save Lag, Gain and Olp
  
  (*Line).Sfs[Sfc].AcLg = Lid;
  (*Line).Sfs[Sfc].AcGn = Gid;
  (*Line).Olp[Sfc>>1] = Olp;

//ASM emms;

/* ------------------------------ FLOAT -----------------------*/


// Decode the Acbk contribution and subtract it
  
  Decod_Acbk(RezBuf, PrevExc, Olp, Lid, Gid, WrkRate);

//TIMER_SPOT_ON(LastConvolv);

  mx = FloatToShortScaled(RezBuf, RezBufInt, SubFrLen+ClPitchOrd-1, 3);
  Tshift = 11 - (mx-126);
  if(mx==0) Tshift = 0;

  ab2abbcw(RezBufInt, Rx, 60);
  ConvMMX(Rx, Ix, Temp, SubFrLen);

  //ASM emms;

  if (Tshift >=0) {
	for(j=0; j<SubFrLen; j++){
		Temp[j] = Temp[j]>>Tshift;
		Tv[j]=((float)(Tvxi[j] - Temp[j]))*0.00003052f;
	}
  }
  else
  {
    for(j=0; j<SubFrLen; j++){
		Temp[j] = Temp[j]<<(-Tshift);
		Tv[j]=((float)(Tvxi[j] - Temp[j]))*0.00003052f;
	}
  }

//TIMER_SPOT_OFF(LastConvolv);

}
#endif //COMPILE_MMX

short norm(long L_var1)
{
    short var_out;

    if (L_var1 == 0L) {
        var_out = (short)0;
    }
    else {
        if (L_var1 == (long)0xffffffffL) {
            var_out = (short)31;
        }
        else {
            if (L_var1 < 0L) {
                L_var1 = ~L_var1;
            }

            for(var_out = (short)0;L_var1 < 0x40000000L;var_out++) 
            {
                L_var1 <<= 1L;
            }
        }
    }

    return(var_out);
}
/*---------------------------------------------------------------------*/
void  Find_Acbk(float *Tv, float *ImpResp, float *PrevExc, LINEDEF
*Line, int Sfc, enum Crate WrkRate, int flags, CODDEF *CodStat)
{
  int  i,j,k;

  float Acc0,Max;

  float RezBuf[SubFrLen+ClPitchOrd-1];
  float FltBuf[ClPitchOrd][SubFrLen];
  float CorVct[4*(2*ClPitchOrd + ClPitchOrd*(ClPitchOrd-1)/2)];
  float *lPnt;
  float *sPnt,*Ptr;
  int   Olp,Lid,Gid,Hb,t,k1,k2;
  int	Bound[3];
  int	Lag1, Lag2;
  int	off_filt;

  Olp = (*Line).Olp[Sfc>>1];
  Lid = Pstep;
  Gid = 0;
  Hb  = 3 + (Sfc & 1);

// For even frames only
  
  if ((Sfc & 1) == 0)
  {
    if (Olp == PitchMin)
      Olp++;
    if (Olp > (PitchMax-5))
      Olp = PitchMax-5;
  }

  if (flags & SC_LAG1)
  {
    lPnt = &CorVct[20];
    k1 = 1;
    k2 = 2;
  }
  else
  {
    lPnt = CorVct;
    k1 = 0;
    k2 = Hb;
  }

  for (k=k1; k<k2; k++)
  {

// Get residual from the exitation buffer
    
    Get_Rez(RezBuf, PrevExc, Olp-Pstep+k);

// Filter the last one (ClPitchOrd-1) using the impulse responce
    
    for (i=0; i < SubFrLen; i++)
      FltBuf[ClPitchOrd-1][i] = DotRev(&RezBuf[ClPitchOrd-1],ImpResp,i+1);
    
// Update the others (ClPitchOrd-2 down to 0)
    
    for (i=ClPitchOrd-2; i >= 0; i --)
    {
      FltBuf[i][0] = RezBuf[i]*0.5f;
      Acbk_Filt(&FltBuf[i][1],&FltBuf[i+1][0],RezBuf[i],&ImpResp[1]);
//      for (j = 1; j < SubFrLen; j++)
//        FltBuf[i][j] = RezBuf[i]*ImpResp[j] + FltBuf[i+1][j-1];
    }

// Compute the cross products with the signal
    
    for (i=0; i < ClPitchOrd; i++)
      *lPnt++ = DotProd(Tv, FltBuf[i], SubFrLen);

// Compute the energies
    
    for (i=0; i < ClPitchOrd; i++)
      *lPnt++ = 0.5f*DotProd(FltBuf[i], FltBuf[i], SubFrLen);

// Compute the between crosses
    
    for (i=1; i < ClPitchOrd; i++)
      for (j = 0; j < i; j++)
        *lPnt++ = DotProd(FltBuf[i], FltBuf[j], SubFrLen);

  }

  /* Test potential error */
  Lag1 = Olp - Pstep;
  Lag2 = Olp - Pstep + Hb - 1;

  off_filt = Test_Err(Lag1, Lag2, CodStat);

  Bound[0] =  NbFilt085_min + (off_filt << 2);
  if(Bound[0] > NbFilt085) Bound[0] = NbFilt085;
  Bound[1] =  NbFilt170_min + (off_filt << 3);
  if(Bound[1] > NbFilt170) Bound[1] = NbFilt170;

  Bound[2] = 85; //Use subset table in the case t=2

  Max = 0.0f;

  for (k=k1; k<k2; k++)
  {

// Select Quantization table
    
    t = 0;
    if (WrkRate == Rate63)
    {
      if ((Sfc & 1) == 0)
      {
        if (Olp-Pstep+k >= SubFrLen-2)
          t = 1;
      }
      else
      {
        if (Olp >= SubFrLen-2)
          t = 1;
      }
    }
    else
      t = 1;

	/* If Bound=170 and SC_GAIN=TRUE, use 170subset table.
	   Else, use full table with limited Bound.*/ 
    if (t==1 && (flags & SC_GAIN) && Bound[t]==NbFilt170)
      t = 2;
    
// Search for maximum

	sPnt = AcbkGainTablePtr[t];
  	Ptr  = &CorVct[k*20];

    for (i=0; i < Bound[t]; i++)
    {
      Acc0 = Ptr[0]*sPnt[0] + Ptr[1]*sPnt[1] +
        Ptr[2]*sPnt[2] + Ptr[3]*sPnt[3] +
        Ptr[4]*sPnt[4] + Ptr[5]*sPnt[5] +
        Ptr[6]*sPnt[6] + Ptr[7]*sPnt[7] +
        Ptr[8]*sPnt[8] + Ptr[9]*sPnt[9] +
        Ptr[10]*sPnt[10] + Ptr[11]*sPnt[11] +
        Ptr[12]*sPnt[12] + Ptr[13]*sPnt[13] +
        Ptr[14]*sPnt[14] + Ptr[15]*sPnt[15] +
        Ptr[16]*sPnt[16] + Ptr[17]*sPnt[17] +
        Ptr[18]*sPnt[18] + Ptr[19]*sPnt[19];

      sPnt += 20;

      if (asint(Acc0) > asint(Max))  // integer cmp, since Max is not negative.
      {
        Max = Acc0;

        if (t==2)
          Gid = GainScramble[i];
        else
          Gid = i;

        Lid = k;
      }
    }
  }

// Modify Olp for even sub frames
  
  if ((Sfc & 1) == 0)
  {
    Olp = Olp - Pstep + Lid;
    Lid = Pstep;
  }

// Save Lag, Gain and Olp
  
  (*Line).Sfs[Sfc].AcLg = Lid;
  (*Line).Sfs[Sfc].AcGn = Gid;
  (*Line).Olp[Sfc>>1] = Olp;

// Decode the Acbk contribution and subtract it
  
  Decod_Acbk(RezBuf, PrevExc, Olp, Lid, Gid, WrkRate);

  for (i=0; i < SubFrLen; i++)
    Tv[i] -= DotRev(RezBuf,ImpResp,i+1);

}

//-----------------------------------------------------------------
void  Get_Rez(float *Tv, float *PrevExc, int Lag)
{
  int  i,n,div,mod;
  float *src,*dst;

  for (i=0; i < ClPitchOrd/2; i++)
    Tv[i] = PrevExc[PitchMax - Lag - ClPitchOrd/2 + i];

  n = SubFrLen+ClPitchOrd/2;
  div = n/Lag;
  mod = n%Lag;

  dst = &Tv[ClPitchOrd/2];
  src = &PrevExc[PitchMax-Lag];
  for (i=0; i<div; i++)
  {
    memcpy(dst,src,4*Lag);
    dst += Lag;
  }
  memcpy(dst,src,4*mod);
}


//-----------------------------------------------------------------
void  Decod_Acbk(float *Tv, float *PrevExc, int Olp, int Lid, int Gid, enum Crate WrkRate)
{
  int  i;

  float  RezBuf[SubFrLen+ClPitchOrd-1];
  float *sPnt;

  Get_Rez(RezBuf, PrevExc, (Olp + Lid) - Pstep);

// Select Quantization tables
  
  i = 0;
  if (WrkRate == Rate63)
  {
	if (Olp >= (SubFrLen-2))
      i++;
  }
  else
    i=1;

  sPnt = AcbkGainTablePtr[i] + Gid*20;

// Compute output vector

  for (i=0; i < SubFrLen; i++)
    Tv[i] = RezBuf[i]*sPnt[0] + RezBuf[i+1]*sPnt[1] + RezBuf[i+2]*sPnt[2] +
      RezBuf[i+3]*sPnt[3] + RezBuf[i+4]*sPnt[4];
}


//-----------------------------------------------
int  Comp_Info(float Buff[60], int Olp)
{
  int  i;

  float  Acc0;

  float  Tenr;
  float  Ccr,Enr;
  int  Indx;

  if (Olp > (PitchMax-3))
    Olp = (PitchMax-3);

  Indx = Olp;
  Ccr =  0.0f;

  for (i=Olp-3; i <= Olp+3; i++)
  {
    Acc0 = DotProd(&Buff[PitchMax+Frame-2*SubFrLen],
      &Buff[PitchMax+Frame-2*SubFrLen-i],2*SubFrLen);
    
    if (Acc0 > Ccr)
    {
      Ccr = Acc0;
      Indx = i;
    }
  }

// Compute target energy 
 
    Tenr = DotProd(&Buff[PitchMax+Frame-2*SubFrLen],
      &Buff[PitchMax+Frame-2*SubFrLen],2*SubFrLen);

// Compute best energy
    
    Enr = DotProd(&Buff[PitchMax+Frame-2*SubFrLen-Indx],
      &Buff[PitchMax+Frame-2*SubFrLen-Indx],2*SubFrLen);

  if (Ccr <= 0.0f)
    return 0;
	
  if (((0.125f*Enr*Tenr) - (Ccr*Ccr)) < 0.0f)
    return Indx;
  else
    return 0;
}


//------------------------------------------------------------------
void    Regen(float *DataBuff, float *Buff, int Lag, float Gain,
              int Ecount, int *Sd)
{
  int  i;

// Test for clearing

  if (Ecount >= ErrMaxNum)
  {
    for (i = 0; i < Frame; i++)
	  DataBuff[i] = 0.0f;
	for (i = 0; i < Frame+PitchMax; i++)
	  Buff[i] = 0.0f;
  }
  else
  {
    
// Interpolate accordingly to the voicing estimation

    if (Lag != 0)
    {
      // Voiced case
      for (i = 0; i < Frame; i++)
        Buff[PitchMax+i] = Buff[PitchMax-Lag+i];
      for (i = 0; i < Frame; i++)
        DataBuff[i] = Buff[PitchMax+i] = Buff[PitchMax+i] *  0.75f;
    }
    else
    {

//Unvoiced case

      for (i = 0; i < Frame; i++)
        DataBuff[i] = Gain*(float)Rand_lbc(Sd)*(1.0f/16384.0f);

//Clear buffer to reset memory
 
      for (i = 0; i < Frame+PitchMax; i++)
        Buff[i] = 0.0f;
     }
  }
}


//------------------------------------------------------
//Comp_Lpf

//------------------------------------------------------
//Find_B

//------------------------------------------------------
//Find_F

//------------------------------------------------------
//Get_Ind

//------------------------------------------------------
//Filt_Lpf

//---------------------------------------------------------------
int search_T0 (int T0, int Gid, float *gain_T0)
{

	int T0_mod;

	T0_mod = T0+epsi170[Gid];
    *gain_T0 = gain170[Gid];

	return(T0_mod);
}


/*
**
** Function:    Update_Err()
**
** Description:   Estimation of the excitation error associated
**          to the excitation signal when it is disturbed at
**          the decoder, the disturbing signal being filtered
**          by the long term synthesis filters
**          one value for (SubFrLen/2) samples
**          Updates the table CodStat.Err
**
** Links to text:   Section
**
** Arguments:
**
**  int Olp    Center value for pitch delay
**  int AcLg   Offset value for pitch delay
**  int AcGn   Index of Gain LT filter
**
** Outputs: None
**
** Return value:  None
**
*/

#define MAX 256.0f

void Update_Err(int Olp, int AcLg, int AcGn, CODDEF *CodStat)
{
  int i, iz, temp2;
  int Lag;
  float Worst1, Worst0, wtemp;
  float beta,*ptr_tab;

  Lag = Olp - Pstep + AcLg;

  /* Select Quantization tables */
  i = 0 ;
  ptr_tab = tabgain85;
  if ( CodStat->WrkRate == Rate63 ) {
    if ( Olp >= (SubFrLen-2) ) ptr_tab = tabgain170;
  }
  else {
    ptr_tab = tabgain170;
  }
  beta = ptr_tab[(int)AcGn];


  if(Lag <= (SubFrLen/2))
  {
    Worst0 = CodStat->Err[0]*beta + Err0;
    Worst1 = Worst0;
  }
  else
  {
    iz = (Lag*1092) >> 15;
    temp2 = 30*(iz+1);

    if (temp2 != Lag)
    {
      if(iz == 1)
      {
        Worst0 = CodStat->Err[0]*beta + Err0;
        Worst1 = CodStat->Err[1]*beta + Err0;

        if (Worst0 > Worst1)
          Worst1 = Worst0;
        else
          Worst0 = Worst1;
      }
      else
      {
        wtemp = CodStat->Err[iz-1]*beta + Err0;
        Worst0 = CodStat->Err[iz-2]*beta + Err0;
        if (wtemp > Worst0) Worst0 = wtemp;
        Worst1 = CodStat->Err[iz]*beta + Err0;
        if (wtemp > Worst1) Worst1 = wtemp;
      }
    }
    else
    {  
      Worst0 = CodStat->Err[iz-1]*beta + Err0;
      Worst1 = CodStat->Err[iz]*beta + Err0;
    }
  }

  if (Worst0 > MAX) Worst0 = MAX;
  if (Worst1 > MAX) Worst1 = MAX;

  for(i=4; i>=2; i--)
    CodStat->Err[i] = CodStat->Err[i-2];

  CodStat->Err[0] = Worst0;
  CodStat->Err[1] = Worst1;

  return;
}

/*
**
** Function:    Test_Err()
**
** Description:   Check the error excitation maximum for
**          the subframe and computes an index iTest used to
**          calculate the maximum nb of filters (in Find_Acbk) :
**          Bound = Min(Nmin + iTest x pas, Nmax) , with
**          AcbkGainTable085 : pas = 2, Nmin = 51, Nmax = 85
**          AcbkGainTable170 : pas = 4, Nmin = 93, Nmax = 170
**          iTest depends on the relative difference between
**          errmax and a fixed threshold
**
** Links to text:   Section
**
** Arguments:
**
**  Word16 Lag1    1st long term Lag of the tested zone
**  Word16 Lag2    2nd long term Lag of the tested zone
**
** Outputs: None
**
** Return value:
**  Word16      index iTest used to compute Acbk number of filters
*/

int Test_Err(int Lag1, int Lag2, CODDEF *CodStat)
{
  int i, i1, i2;
  int zone1, zone2, iTest;
  float Err_max;

  i2 = Lag2 + ClPitchOrd/2;
  zone2 = i2/30;

  i1 = - SubFrLen + 1 + Lag1 - ClPitchOrd/2;
  if (i1 <= 0) i1 = 1;
  zone1 = i1/30;

  Err_max = -1.0f;
  for(i=zone2; i>=zone1; i--)
  {
    if (CodStat->Err[i] > Err_max)
      Err_max = CodStat->Err[i];
  }
  if((Err_max > ThreshErr) || (CodStat->SinDet < 0 ) )
  {
    iTest = 0;
    //ount_clip++;
  }
  else
  {
    iTest = (int)(ThreshErr - Err_max);
  }

  return(iTest);
}


#if COMPILE_MMX

#if ASM_FACBK

int DotMMX60(short *ind, short *oud)
{
int dotprod;

#define reg0  mm0
#define reg1  mm1
#define reg2  mm2
#define acc0  mm6

#define inx	  esi
#define oux	  edi
#define dot   eax
#define jcnt  ebx

#define l(n)  ASM movq    reg##n,QP[inx+8*n]
#define m(n)  ASM pmaddwd reg##n,QP[oux+8*n]
#define a(n)  ASM paddd   acc0,reg##n

  ASM
  {
    mov		inx,ind;
    mov		oux,oud;
	mov		jcnt,5;
  }
  

//Begin loop

 ASM pxor	acc0,acc0;	
 ASM pxor	reg1,reg1;   //make first a(1) a nop
 ASM pxor	reg2,reg2;   //make first a(2) a nop

inner:				
//------------------
l(0);
		a(1);
m(0);
		l(1);
				a(2);
		m(1);
				l(2);
a(0);
				m(2);
//-------------------

			
ASM add inx,24;
ASM add oux,24;

ASM sub jcnt,1;
ASM jg inner;

a(1);
a(2);

ASM
{
	//Add the two halves of acc0
    movq  reg0,acc0;
    psrlq acc0,32;
    paddd acc0,reg0;
	movd  dot,acc0; //store
	mov   dotprod,dot
}

ASM emms;

 return(dotprod);
#undef reg0
#undef reg1
#undef reg2
#undef acc0

#undef inx
#undef oux
#undef dot
#undef jcnt

#undef l
#undef m
#undef a
  
}

#else

int DotMMX60(short *in, short *out)
{
int dotprod;
int j;

dotprod=0;
for(i=0; i < 60; i++)
{
	
  dotprod += in[j]*out[j];

}

return(dotprod);
}

#endif

#if ASM_FACBK

void DupRezBuf(short *rezbuf, short *reztemp)
{
  #define reg0	mm0
  #define reg1	mm1
  #define reg2	mm2
  #define reg3	mm3

  #define rbuf	edi
  #define rztmp esi

	//rezbuf duplication operations
  #define cr(r0,r1) ASM movq reg##r0,reg##r1
  #define uph(r0)   ASM punpckhwd reg##r0,reg##r0 
  #define upl(r0)   ASM punpcklwd reg##r0,reg##r0 
  #define sto(r0,i) ASM movq QP[rztmp+8*i],reg##r0
  #define sl(r0)	ASM psllw reg##r0,1
  #define l(r0)		ASM movq reg##r0,QP[rbuf]

  //Duplicate first 4 rezbuf values 4 times each
  //	and store into 4 QWORDS in reztemp
  //Multiply by two while we're at it
  ASM mov rbuf,rezbuf;
  ASM mov rztmp,reztemp;

	l(0);
	sl(0);
	cr(2,0);
	 uph(0);
	upl(2);
	 cr(1,0);
	cr(3,2);
	 uph(0);
	sto(0,0);
	 upl(1);
	sto(1,1);
	 uph(2);
	sto(2,2);
	 upl(3);
	sto(3,3);

ASM emms;

}
  #undef reg0
  #undef reg1
  #undef reg2
  #undef reg3

  #undef rbuf
  #undef rztmp

  #undef cr
  #undef uph
  #undef upl
  #undef sto
  #undef sl
  #undef l

#endif

#if ASM_FACBK

void FBufCalcInt(short *fi, short *fo, short *impresp, short *reztemp, int n)
{
  #define reg0	mm0
  #define reg1	mm1
  #define reg2	mm2
  #define reg3	mm3
  #define reg4	mm4
  #define reg5	mm5
  #define reg6	mm6
  #define reg7	mm1
  #define reg8	mm7

  #define fbufi	esi
  #define rbuf	edi
  #define imp	edx
  #define fbufo	ebx
  #define jcnt	ecx
  #define rzv   eax

  //Diagonal array operations
  #define l1(r0,j)  ASM movq reg##r0,QP[fbufi+8*j]
  #define l2(r0,j)  ASM movq reg##r0,QP[fbufi+8+8*j]
  #define c3(r0)    ASM movq reg##r0,QP[rbuf+8*rzv]
  #define m1(r0,j)  ASM pmulhw reg##r0,QP[imp+8+8*j]
  #define a1(r0,r1) ASM paddsw reg##r0,reg##r1
  #define sto(r0,j) ASM movq QP[fbufo+8+8*j], reg##r0
  #define s1(r0)    ASM psrlq reg##r0,48
  #define s2(r0)    ASM psllq reg##r0,16
  #define or(r0,r1) ASM por reg##r0,reg##r1


//Loop setup
ASM 
{
	mov rbuf,reztemp
	mov jcnt,5;
	mov fbufi,fi;
	mov fbufo,fo;
	mov imp,impresp;
	mov rzv,n
}
//Compute initial values
//Zero-th QWORD is different

ASM 
{
	movq	reg0,QP[fbufo];
	psllq	reg0,48;
	psrlq	reg0,48;

//zero-th part of fbufo now in reg0
	movq    reg2,QP[rbuf+8*rzv];
	pmulhw	reg2,QP[imp+2];
	paddsw	reg2,QP[fbufi];
	psllq	reg2,16;
	por		reg0,reg2;

	movq	QP[fbufo],reg0;
}
//begin loop 
	l2(0,0);		
	l1(1,0);
	s2(0);
	s1(1);
	c3(2);
	m1(2,0);
			l2(3,1);
			l1(4,1);
			s2(3);
			s1(4);
	or(0,1);
	
inner: 
 //-------------------------
					l2(6,2);
	a1(0,2);
			c3(5);
			m1(5,1);
			or(3,4);
					l1(7,2);
					s2(6);
	sto(0,0);
					s1(7);
	l2(0,3);
			a1(3,5);
					c3(8);
					m1(8,2);
					or(6,7);
	l1(1,3);
	s2(0);
			sto(3,1);
	s1(1);
			l2(3,4);
					a1(6,8);
	c3(2);
	m1(2,3);
	or(0,1);
			l1(4,4);
			s2(3);
					sto(6,2);
			s1(4);
 //-------------------------

 ASM add fbufo,24;
 ASM add fbufi,24;
 ASM add imp,24;

 ASM sub jcnt,1;
 ASM jg inner;

 ASM emms;
}
  #undef reg0
  #undef reg1
  #undef reg2
  #undef reg3
  #undef reg4
  #undef reg5
  #undef reg6
  #undef reg7
  #undef reg8

  #undef fbufi
  #undef rbuf
  #undef imp
  #undef fbufo
  #undef jcnt
  #undef rzv

  #undef l1
  #undef l2
  #undef c3
  #undef m1
  #undef a1
  #undef sto
  #undef s1
  #undef s2
  #undef or

#else

void FBufCalcInt(short *fi, short *fo, short *impresp, short *rezbuf, short *reztemp, int n)
{
  long Acc0l;
  int j;

  #define MAX16  32767
  #define MIN16 -32768

	for(j=1; j<SubFrLen; j++)
	{	
		Acc0l = fi[j-1];
		Acc0l += (((rezbuf[4-n]<<1)*impresp[j]))>>16;
		if	   (Acc0l > MAX16) Acc0l = MAX16;
	    else if(Acc0l < MIN16) Acc0l = MIN16;
		fo[j] = (short)(Acc0l);
	}	
}
#endif


#if ASM_FACBK
//#if 0

void CodeBkSrch(short *lpint, short *spint, int numvecs, int *gid, int *max)
{

#define reg0  mm0
#define reg1  mm1
#define reg2  mm2
#define reg3  mm3
#define reg4  mm4
#define acc1  mm5
#define acc0  mm6
#define gdx	  mm3
#define gd	  mm7
#define icx	  mm2

#define lp	  esi
#define sp	  edi
#define maxx  eax
#define gidx  edx
#define icnt  ebx

// In the following macros, 'n' is the column number.
#define l(n)  ASM movq    reg##n,QP[lp+8*n]
#define m(n)  ASM pmaddwd reg##n,QP[sp+8*n]
#define a(n)  ASM paddd   acc0,reg##n

  ASM
  {
    mov		sp,spint;
    mov		lp,lpint;
	mov		icnt,numvecs;
	mov		gidx,gid;
	mov	    maxx,max;
  }
  
  ASM movd	gd,numvecs;//load gd with top codebook index
  ASM movd  acc1,DP[maxx];//load acc1 with previous max

//Begin loop

outer:
//inner:
  ASM pxor  acc0,acc0;	
  ASM pxor	reg1,reg1;   //make first a(1) a nop
  ASM pxor	reg2,reg2;   //make first a(2) a nop
//--------------------------
l(0);
				a(1);
m(0);
		l(1);
						a(2);
		m(1);
				l(2);
a(0);
				m(2);
						l(3);
		a(1);
						m(3);
l(4);
				a(2);
m(4);

ASM add	 sp,40;
						a(3);
ASM movq  gdx,gd;
ASM movd  icx,icnt;

a(4);

  ASM
  {
    movq  reg0,acc0;
    psrlq acc0,32;

	pxor  gd,icx;//gd=MASK 
    paddd acc0,reg0;
	
	movq    reg0,acc0; //copy acc0
	movq    reg1,acc1; //copy old max
	
	pxor    reg1,acc0
	pcmpgtd reg0,acc1; //reg0=0xFF or 0x00
	pand    reg1,reg0; //reg1=MASK or 0x00
	pxor    acc1,reg1; //acc1=acc0 or acc1
	
	pand	gd,reg0; //gd=MASK or 0x00
	pxor	gd,gdx;  //gd=icnt or previous value	
 
    sub icnt,1;
    jg  outer;
  }

  ASM movd  reg0,numvecs;
  ASM psubd reg0,gd;
  ASM movd  DP[gidx],reg0;//return gid 
  ASM movd  DP[maxx],acc1;//return max
  ASM emms;
  
}
#undef reg0
#undef reg1
#undef reg2
#undef reg3
#undef reg4
#undef acc1
#undef acc0
#undef gdx
#undef gd
#undef icx

#undef lp
#undef sp
#undef maxx
#undef gidx
#undef icnt

#undef l
#undef m
#undef a

#else

void CodeBkSrch(short *lpint, short *spint, int numvecs, int *gid, int *max)
{
int acc0;
int i,j;


for(i=0; i < numvecs; i++)
{
	acc0 = 0;

	for(j=0; j<20; j++)
		acc0 += lpint[j]*spint[j];

	if (acc0 > *max)
	{
		*max = acc0;
		*gid = i;
	}

	spint += 20;
}


}

#endif

#endif //COMPILE_MMX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\lpc.c ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//
#include <stdio.h>
#include <math.h>
#include "opt.h"
#include "typedef.h"
#include "cst_lbc.h"
#include "tab_lbc.h"
#include "coder.h"
#include "decod.h"
#include "util_lbc.h"
#include "lpc.h"

#include "mmxutil.h"


#define Dot10m(x,y) \
  ( (*x)*(*y) + (*((x)+1))*(*((y)+1)) + (*((x)+2))*(*((y)+2)) + \
   (*((x)+3))*(*((y)+3)) + (*((x)+4))*(*((y)+4)) + (*((x)+5))*(*((y)+5)) + \
   (*((x)+6))*(*((y)+6)) + (*((x)+7))*(*((y)+7)) + (*((x)+8))*(*((y)+8)) + \
   (*((x)+9))*(*((y)+9)) )

//-----------------------------------------------------------------
void  Comp_Lpc(float *UnqLpc, float *PrevDat, float *DataBuff, CODDEF *CodStat)
{
  int   i,j,k;

  float  Dpnt[Frame+LpcFrame-SubFrLen];
  float  Vect[LpcFrame];
  float  Corr[LpcOrder+1];

// Form Buffer

  for (i=0; i < LpcFrame-SubFrLen; i++)
    Dpnt[i] = PrevDat[i];
  for (i=0; i < Frame; i++)
    Dpnt[i+LpcFrame-SubFrLen] = DataBuff[i];

// Do for all the sub frames
  
  for (k=0; k < SubFrames; k++)
  {
// Copy the current window, multiply by Hamming window
    
    for (i = 0; i < LpcFrame; i++)
      Vect[i] = Dpnt[k*SubFrLen+i]*HammingWindowTable[i];

// Compute correlation coefficients

    for (i=0; i<=LpcOrder; i++)
      Corr[i] = DotProd(Vect, &Vect[i], LpcFrame-i)/(LpcFrame*LpcFrame) *
        BinomialWindowTable[i];

// Do Ridge regression

    Corr[0] *= (1025.0f/1024.0f);

    Durbin(&UnqLpc[k*LpcOrder], &Corr[1], Corr[0], CodStat);
  }
  /* Update sine detector */
    CodStat->SinDet &= 0x7fff ;

    j = CodStat->SinDet ;
    k = 0 ;
    for ( i = 0 ; i < 15 ; i ++ ) {
        k += j & 1 ;
        j >>= 1 ;
    }
    if ( k >= 14 )
        CodStat->SinDet |= 0x8000 ;

}

#if COMPILE_MMX

void  Comp_LpcInt(float *UnqLpc, float *PrevDat, float *DataBuff, CODDEF *CodStat)
{
  int   i,j,k;

  float  Dpnt[Frame+LpcFrame-SubFrLen];
  float  Vect[LpcFrame];
  float  Corr[LpcOrder+1];
  float  Fshift;

  int	mx, Tshift;

  DECLARE_SHORT(VectShrt,LpcFrame+32);
  DECLARE_INT(Temp,12);

  ALIGN_ARRAY(VectShrt);
  ALIGN_ARRAY(Temp);

// Form Buffer

  for (i=0; i < LpcFrame-SubFrLen; i++)
    Dpnt[i] = PrevDat[i];
  for (i=0; i < Frame; i++)
    Dpnt[i+LpcFrame-SubFrLen] = DataBuff[i];

// Do for all the sub frames
  
  for (k=0; k < SubFrames; k++)
  {
// Copy the current window, multiply by Hamming window
    
    for (i = 0; i < LpcFrame; i++)
      Vect[i] = Dpnt[k*SubFrLen+i]*HammingWindowTable[i];

// Compute correlation coefficients

    mx = FloatToShortScaled(Vect,VectShrt,LpcFrame,3);
	for(j=0; j<31; j++) VectShrt[LpcFrame+j]=0;
	Tshift = 30 - (6+2*(mx-126));
    if(mx==0) Tshift = 0;

	CorrCoeff01(VectShrt, &VectShrt[0], Temp, LpcFrame);
	CorrCoeff23(VectShrt, &VectShrt[0], &Temp[2], LpcFrame);
	CorrCoeff01(VectShrt, &VectShrt[4], &Temp[4], LpcFrame);
	CorrCoeff23(VectShrt, &VectShrt[4], &Temp[6], LpcFrame);
	CorrCoeff01(VectShrt, &VectShrt[8], &Temp[8], LpcFrame);
	CorrCoeff23(VectShrt, &VectShrt[8], &Temp[10],LpcFrame);
	
	Fshift = 2.0f;

	if(Tshift>=0){
		for(j=1; j<Tshift; j++) Fshift *= 2.0f;
		Fshift = 1.0f/Fshift;
	}
	else
	{
		Tshift=-Tshift;
		for(j=1; j<Tshift; j++) Fshift *= 2.0f;
	}

	
	for (i=0; i<LpcOrder; i+=2){
		Corr[i]  =((float)Temp[i])*Fshift*BinomialWindowTable[i]  /(LpcFrame*LpcFrame);
		Corr[i+1]=((float)Temp[i+1])*Fshift*BinomialWindowTable[i+1]/(LpcFrame*LpcFrame);
	}
	Corr[10]  =((float)Temp[10])*Fshift*BinomialWindowTable[10]  /(LpcFrame*LpcFrame);
	

// Do Ridge regression

    Corr[0] *= (1025.0f/1024.0f);

    Durbin(&UnqLpc[k*LpcOrder], &Corr[1], Corr[0], CodStat);
  }
  /* Update sine detector */
    CodStat->SinDet &= 0x7fff ;

    j = CodStat->SinDet ;
    k = 0 ;
    for ( i = 0 ; i < 15 ; i ++ ) {
        k += j & 1 ;
        j >>= 1 ;
    }
    if ( k >= 14 )
        CodStat->SinDet |= 0x8000 ;

}

#endif

//----------------------------------------------------
float Durbin(float *Lpc, float *Corr, float Err, CODDEF *CodStat)
{
  int  i,j;
  float  Temp[LpcOrder];
  float  Pk,Tmp0;

// Clear the result lpc vector

  for (i=0; i < LpcOrder; i++)
    Lpc[i] = 0.0f;

  for (i=0; i < LpcOrder; i++)
  {
    Tmp0 = Corr[i];
    for (j=0; j<i; j++)
      Tmp0 -= Lpc[j]*Corr[i-j-1];
    
    if (fabs(Tmp0) >= Err)
      break;
    
    Lpc[i] = Pk = Tmp0/Err;
    Err -= Tmp0*Pk;
    
    for (j=0; j < i; j++)
      Temp[j] = Lpc[j];

    for (j=0; j < i; j++)
      Lpc[j] = Lpc[j] - Pk*Temp[i-j-1];

	/*
     * Sine detector
     */
     if ( i == 1 ) 
     {
       CodStat->SinDet <<= 1 ;
	   if ( Pk > 0.95f)
           CodStat->SinDet ++ ;
     }

  }

// Lpc[] values * 2^13 corresponds to fixed-point values
  return Err;

}


//---------------------------------------------------------
void  Wght_Lpc(float *PerLpc, float *UnqLpc)
{
  int  i,j;

  for (i=0; i < SubFrames; i++)
  {
    for (j=0; j < LpcOrder; j++)
    {
      PerLpc[j]          = UnqLpc[j]*PerFiltZeroTable[j];
      PerLpc[j+LpcOrder] = UnqLpc[j]*PerFiltPoleTable[j];
    }
    PerLpc += 2*LpcOrder;
    UnqLpc += LpcOrder;
  }
}


//----------------------------------------------------------
void  Error_Wght(float *Dpnt, float *PerLpc,CODDEF *CodStat)
{
  int  i,k;

  float Acc0;


  for (k=0; k < SubFrames; k++)
  {
    for (i=0; i < SubFrLen; i++)
    {
// FIR part

      Acc0 = *Dpnt - Dot10m(PerLpc,&CodStat->WghtFirDl[CodStat->p]);

// IIR part
      
      Acc0 += Dot10m(&PerLpc[LpcOrder],&CodStat->WghtIirDl[CodStat->p]);

      CodStat->p = minus1mod10[CodStat->p];       
      CodStat->WghtFirDl[CodStat->p] =
        CodStat->WghtFirDl[CodStat->p + LpcOrder] = *Dpnt;

      *Dpnt++ = CodStat->WghtIirDl[CodStat->p] =
        CodStat->WghtIirDl[CodStat->p + LpcOrder] = Acc0;
    }
    PerLpc += 2*LpcOrder;
  }
}



//-----------------------------------------------------------------------
void  Comp_Ir(float *ImpResp, float *QntLpc, float *PerLpc, PWDEF Pw)
{
  int  i;

  float  FirDl[2*LpcOrder];
  float  IirDl[2*LpcOrder];
  float  Temp[PitchMax+SubFrLen];
  float  Acc0,Acc1;
  int    p = 9;

// Clear all
  
  for (i=0; i < 2*LpcOrder; i++)
    FirDl[i] = IirDl[i] = 0.0f;

  for (i=0; i < PitchMax+SubFrLen; i++)
    Temp[i] = 0.0f;

// Compute impulse response
  
  Acc0 = 0.5f;

  for (i=0; i < SubFrLen; i++)
  {
// Synthesis filter
    
    Acc1 = Acc0 + Dot10m(QntLpc,&FirDl[p]);

// FIR, IIR part

    Acc0 = Acc1 - Dot10m(PerLpc,&FirDl[p])
      + Dot10m(&PerLpc[LpcOrder],&IirDl[p]);

    p = minus1mod10[p];
    FirDl[p] = FirDl[p  + LpcOrder] = Acc1;
    Temp[PitchMax+i] = IirDl[p] = IirDl[p + LpcOrder] = Acc0;

// Harmonic part

    ImpResp[i] = Acc0 - Pw.Gain*Temp[PitchMax-Pw.Indx+i];
    
    Acc0 = 0.0f;
  }
}


//------------------------------------------------------------------
void  Sub_Ring(float *Dpnt, float *QntLpc, float *PerLpc, float
               *PrevErr, PWDEF Pw,CODDEF *CodStat)
{
  int  i;
  float Acc0,Acc1;

  float  FirDl[2*LpcOrder];
  float  IirDl[2*LpcOrder];
  float  Temp[PitchMax+SubFrLen];
  int    p = 9;


// Initialize the delay lines
  
  for (i=0; i < PitchMax; i++)
    Temp[i] = PrevErr[i];

  for (i=0; i < 2*LpcOrder; i++)
  {
    FirDl[i] = CodStat->RingFirDl[i];
    IirDl[i] = CodStat->RingIirDl[i];
  }

// Main loop
  
  for (i=0; i < SubFrLen; i++)
  {
// Synthesis filter
    
    Acc1 = Acc0 = Dot10m(QntLpc,&FirDl[p]);

// FIR, IIR part
    
    Acc0 -= Dot10m(PerLpc,&FirDl[p]);
    Acc0 += Dot10m(&PerLpc[LpcOrder],&IirDl[p]);

    p = minus1mod10[p];
    FirDl[p] = FirDl[p + LpcOrder] = Acc1;
    Temp[PitchMax+i] = IirDl[p] = IirDl[p + LpcOrder] =  Acc0;

// Harmonic Part
    
    Dpnt[i] -= Acc0 - Pw.Gain*Temp[PitchMax-Pw.Indx+i];
  }
}


//-----------------------------------------------------------------
void  Upd_Ring(float *Dpnt, float *QntLpc, float *PerLpc, float
               *PrevErr, CODDEF *CodStat)
{
  int  i;

  float  Acc0,Acc1;

// Shift the PrevErr buffer
 
  for (i=SubFrLen; i < PitchMax; i++)
    PrevErr[i-SubFrLen] = PrevErr[i];

// Update the ring delay and PrevErr buffer 

  for (i=0; i < SubFrLen; i++) 
  {
// Synt filter 

    Acc1 = Acc0 = Dpnt[i] += Dot10m(QntLpc,&CodStat->RingFirDl[CodStat->q])*2.0f;

// Fir,Iir filter
 
    Acc0 -= Dot10m(PerLpc,&CodStat->RingFirDl[CodStat->q])*2.0f;
    Acc0 += Dot10m(&PerLpc[LpcOrder],&CodStat->RingIirDl[CodStat->q])*2.0f;

    CodStat->q = minus1mod10[CodStat->q];
    CodStat->RingFirDl[CodStat->q] =
      CodStat->RingFirDl[CodStat->q + LpcOrder] =  Acc1*0.5f;
    PrevErr[PitchMax-SubFrLen+i] = CodStat->RingIirDl[CodStat->q] =
      CodStat->RingIirDl[CodStat->q + LpcOrder] = Acc0*0.5f;
  }
}


//----------------------------------------------------
void Synt(float *Dpnt, float *Lpc, DECDEF *DecStat)
{
   int   i;

   float   Acc0  ;

   for (i=0 ; i < SubFrLen ; i++)
   {
     Acc0 = Dpnt[i] + Dot10m(Lpc,&DecStat->SyntIirDl[DecStat->dq]);

     DecStat->dq = minus1mod10[DecStat->dq];
     Dpnt[i] = DecStat->SyntIirDl[DecStat->dq] =
       DecStat->SyntIirDl[DecStat->dq + LpcOrder] = Acc0;
   }
}


//----------------------------------------------------
//Spf

#if COMPILE_MMX

void CorrCoeff01(short *samples, short *samples_offst, int *coeff, int buffsz)
{

#define reg0  mm0
#define reg1  mm1
#define reg2  mm2

#define reg3  mm3
#define reg4  mm4
#define reg5  mm5

#define acc0  mm6
#define acc1  mm7

#define s    esi
#define t    edi
#define cnt	 ecx
#define c0	 eax

#define  L1(i,r0)	ASM movq  reg##r0,QP[t+8*cnt+8*i]
#define  L2(i,r0)	ASM movq  reg##r0,QP[t+8*cnt+8+8*i]
#define  C1(r0,r1)  ASM movq  reg##r0,reg##r1
#define  M1(i,r0)	ASM pmaddwd reg##r0,QP[s+8*cnt+8*i]
#define  M2(i,r0)	ASM pmaddwd reg##r0,QP[s+8*cnt+8*i]
#define  O1(r0,r1)	ASM por reg##r0,reg##r1
#define  A1(r0)		ASM paddd acc0,reg##r0
#define  A2(r0)		ASM paddd acc1,reg##r0
#define  S1(r0)    ASM psrlq reg##r0,16
#define  S2(r0)    ASM psllq reg##r0,48

  ASM
  {
	mov c0, coeff;

	mov s,samples;
	mov t,samples_offst;

	mov cnt,buffsz;
	//assume that mod(buffsz,4)=0
	//this is very dangerous!!
	shr cnt,2;
	sub cnt,1;

	pxor acc0,acc0;
	pxor acc1,acc1;
	pxor reg2,reg2;
	pxor reg0,reg0;
	pxor reg3,reg3;
	pxor reg4,reg4;
	pxor reg5,reg5;
  }
			
looptop:
//----------------------------------
				 L2(1,5)
				 S1(4)
				 M1(1,3)
				 S2(5)
	   L1(0,0)
				 O1(5,4)
				 M2(1,5)
	   A2(2)
	   L2(0,2)
	   C1(1,0)
	   M1(0,0)
	   S1(1)
	   S2(2)
ASM						 sub cnt,2;
	   O1(2,1)
				 A1(3)
				 L1(1,3)
				 A2(5)
	   M2(2,2)
				 C1(4,3)
	   A1(0)
ASM						 jge looptop;
//----------------------------------
			
  ASM
  {
	movq  reg0,acc0;
    psrlq acc0,32;
    paddd acc0,reg0;
	movd  DP[c0],acc0;

	movq  reg1,acc1;
    psrlq acc1,32;
    paddd acc1,reg1;
	movd  DP[c0+4],acc1;

    emms;
  }  

}
#undef reg0
#undef reg1
#undef reg2
#undef acc0
#undef acc1
#undef cnt
#undef tmp

#undef L1
#undef L2
#undef C1
#undef M1
#undef M2
#undef A1
#undef A2
#undef S1
#undef S2
#undef O1


#else

void CorrCoeff01(short *samples, short *samples_offst, int *coeff, int buffsz)
{
 int i,j;
 int Acc0;

 for(i=0; i<=1; i++){
	Acc0=0;
	for(j=0; j<LpcFrame; j++)
		Acc0 += samples[j]*samples_offst[j+i];

	*coeff++ = Acc0;
 }
 
 
}
#endif 


#if COMPILE_MMX

void CorrCoeff23(short *samples, short *samples_offst, int *coeff, int buffsz)
{

#define reg0  mm0
#define reg1  mm1
#define reg2  mm2

#define reg3  mm3
#define reg4  mm4
#define reg5  mm5

#define acc0  mm6
#define acc1  mm7

#define s    esi
#define t    edi
#define cnt	 ecx
#define c0	 eax

#define  L1(i,r0)	ASM movq  reg##r0,QP[t+8*cnt+8*i]
#define  L2(i,r0)	ASM movq  reg##r0,QP[t+8*cnt+8+8*i]
#define  C1(r0,r1)  ASM movq  reg##r0,reg##r1
#define  M1(i,r0)	ASM pmaddwd reg##r0,QP[s+8*cnt+8*i]
#define  M2(i,r0)	ASM pmaddwd reg##r0,QP[s+8*cnt+8*i]
#define  O1(r0,r1)	ASM por reg##r0,reg##r1
#define  O2(r0,r1)	ASM por reg##r0,reg##r1
#define  A1(r0)		ASM paddd acc0,reg##r0
#define  A2(r0)		ASM paddd acc1,reg##r0
#define  S1(r0)     ASM psrlq reg##r0,48
#define  S2(r0)     ASM psllq reg##r0,16
#define  S3(r0)     ASM psrlq reg##r0,32
#define  S4(r0)     ASM psllq reg##r0,16

  ASM
  {
	mov c0, coeff;

	mov s,samples;
	mov t,samples_offst;

	mov cnt,buffsz;
	//assume that mod(buffsz,4)=0
	//this is very dangerous!!
	shr cnt,2;
	sub cnt,1;

	pxor acc0,acc0;
	pxor acc1,acc1;
	pxor reg2,reg2;
	pxor reg1,reg1;
	pxor reg0,reg0;
	pxor reg3,reg3;
	pxor reg4,reg4;
	pxor reg5,reg5;
  }
			
looptop:
//----------------------------------
	  O1(0,2)
	  S3(1)
	  M1(1,0)
				 A2(5)
				 L1(0,3)
	  S4(2)
				 L2(0,5)
	  O2(2,1)
	  M2(1,2)
				 C1(4,3)
				 S1(3)
	  A1(0)
				 S2(5)
ASM						  sub cnt,2;				 
				 
				 O1(3,5)
				 S3(4)
				 M1(2,3)
	  A2(2)
	  L1(1,0)
				 S4(5)
	  L2(1,2)
				 O2(5,4)
				 M2(2,5)
	  C1(1,0)
	  S1(0)
				 A1(3)
	  S2(2)
ASM						  jge looptop;
//------------------------------------
			
  ASM
  {
	movq  reg0,acc1;
    psrlq acc1,32;
    paddd acc1,reg0;
	movd  DP[c0],acc1;

	movq  reg1,acc0;
    psrlq acc0,32;
    paddd acc0,reg1;
	movd  DP[c0+4],acc0;

    emms;
  }  

}
#undef reg0
#undef reg1
#undef reg2
#undef acc0
#undef acc1
#undef cnt
#undef tmp

#undef L1
#undef L2
#undef C1
#undef M1
#undef M2
#undef A1
#undef A2
#undef S1
#undef S2
#undef S3
#undef S4
#undef O1
#undef O2


#else

void CorrCoeff23(short *samples, short *samples_offst, int *coeff, int buffsz)
{
 int i,j;
 int Acc0;

 for(i=2; i<=3; i++){
	Acc0=0;
	for(j=0; j<LpcFrame; j++)
		Acc0 += samples[j]*samples_offst[j+i];

    *coeff++ = Acc0;
 }	
	
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\lpc.h ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//

// prototypes for lpc 

float Durbin(float *Lpc, float *Corr, float Err, CODDEF *CodStat);
void  Wght_Lpc(float *PerLpc, float *UnqLpc );
void  Error_Wght(float *Dpnt, float *PerLpc, CODDEF *CodStat );
void  Comp_Ir(float *ImpResp, float *QntLpc, float *PerLpc, PWDEF Pw );
void  Sub_Ring(float *Dpnt, float *QntLpc, float *PerLpc, float
*PrevErr, PWDEF Pw, CODDEF *CodStat );
void  Upd_Ring( float *Dpnt, float *QntLpc, float *PerLpc, float
*PrevErr, CODDEF *CodStat );
void  Synt(float *Dpnt, float *Lpc, DECDEF *DecStat);
//Spf

void CorrCoeff01(short *samples, short *samples_offst, int *coeff, int buffsz);
void CorrCoeff23(short *samples, short *samples_offst, int *coeff, int buffsz);

void Comp_LpcInt( float *UnqLpc, float *PrevDat, float *DataBuff, CODDEF *CodStat );
void Comp_Lpc( float *UnqLpc, float *PrevDat, float *DataBuff, CODDEF *CodStat );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\lsp.c ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//


#include <stdio.h>
#include <math.h>
#include "opt.h"
#include "typedef.h"
#include "cst_lbc.h"
#include "tab_lbc.h"
#include "util_lbc.h"
#include "lsp.h"
#include "timer.h"
#include "mmxutil.h"

#if COMPILE_MMX
//  This file includes all the Lsp related functions

//--------------------------------------------------------------
int mult(short x, short y)
{
  return ( ((int)x)*((int)y) >> 16 );
}
//--------------------------------------------------------------
int LspSearchInt(short *Lspw, short *LspTab)
{

#if ASM_SVQ

  int mem8000[2] = {0x80008000,0x80008000}, zero[2] = {0,0};
  short maxes[4],mx;
  int retu;
  int *ptr,tmp,t,i,k;

#define lsp esi
#define tab edi
#define idx edx
#define pidx eax  // packed index: n+3 n+2 n+1 n
#define maxi ecx

#define r0   mm0
#define r1   mm1
#define r2   mm2
#define r3   mm3
#define r4   mm4
#define max  mm5


// Expand Lspw table so it's 0000 1111 2222 3333 4444 5555 6666 7777

  ptr = (int *)Lspw;
  k = 14;
  for (i=7; i>=0; i--)
  {
    t = Lspw[i]; t = t & 0xffff;
    tmp = t;
    tmp = (tmp << 16) | t;
    ptr[k] = ptr[k+1] = tmp;
    k -= 2;
  }

// Need LspTab to be ordered 0 4 8 12  1 5 9 13  etc.
// so that lo word of each qword sees 0123, next sees 4567, etc.
//
// 'idx' counts iterations, so it goes 0 to 256 in steps of 4.
// The 4 LspTab sets at any given time are 8*idx, 8*idx+8, +16, +24
// Lspw[n] is lsp+8*n, as defined below

#define a(n)  [tab+8*idx+8*n]
#define b(n)  [lsp+8*n]

  ASM
  {
    push lsp;
    push tab;
    push idx;
    push pidx;
    push maxi;

    mov lsp,Lspw;
    mov tab,LspTab;
    xor idx,idx;
    xor maxi,maxi;
    mov pidx,003020100h;
    movq max,mem8000;

/*
  The code below is interleaved with k=1.
  The structure is: four levels of indentation, one for each of the
  4 terms of the sum.  The instructions completely left-justified
  are the part of the loop that's wrapped around on itself.
  Note that the code reads 8 bytes past the end of the LspTab that's
  passed to it.  This is made o.k. by making the table that's passed
  to it have 8 dummy bytes at the end.
*/

// Start up the pipeline

    movq r0,a(0);
    movq r1,r0;
    pmulhw r0,b(4);
    psubsw r1,b(0);
      movq r2,a(1);
      movq r3,r2;
    psllw r0,2;
    pmulhw r0,r1;
      pmulhw r2,b(5);
      psubsw r3,b(1);
        movq r1,a(2);
      psllw r2,2;
      pmulhw r2,r3;  
        movq r3,r1;  
        pmulhw r1,b(6);
        psubsw r3,b(2);
      paddw r0,r2;   
          movq r2,a(3);
        psllw r1,2;
        pmulhw r1,r3;
          movq r3,r2;
          pmulhw r2,b(7);
          psubsw r3,b(3);
        paddw r1,r0;

loop1:
    movq r0,a(4);
          movq r4,r1;   // save accum so not wiped out by first half of loop

          psllw r2,2;
          
    movq r1,r0;
          pmulhw r2,r3;
    
    pmulhw r0,b(4);

    psubsw r1,b(0);
          paddw r4,r2;      // now final answer is in r4

      movq r2,a(5);

paddw r4,mem8000  // make final sum unsigned
      movq r3,r2;      // 0123

    psllw r0,2;
    
psubusw max,r4    // start to compute max
    pmulhw r0,r1;      // 0.23

      pmulhw r2,b(5);
paddw max,r4      // max now done

      psubsw r3,b(1);
pcmpeqw r4,max    // now 1111's means a new max was found

        movq r1,a(6);  // 0123
packsswb r4,r4;    // put all fields in low 32 bits

      psllw r2,2;
      
movd ebx,r4;
      pmulhw r2,r3;    // 012.

xor ebx,0ffffffffh;   // invert mask

and maxi,ebx;       // get old index to keep
        movq r3,r1;    // 0123

        pmulhw r1,b(6);

        psubsw r3,b(2);

xor ebx,0ffffffffh;   // invert mask

      paddw r0,r2;     // 01.3
and ebx,pidx;       // get new index

        psllw r1,2;
        
          movq r2,a(7);// 0123
        pmulhw r1,r3;  // 012.

          movq r3,r2;  // 0123
or maxi,ebx;       // now maxi is done

          pmulhw r2,b(7);

          psubsw r3,b(3);

        paddw r1,r0;   // .123
add idx,4;

add pidx,004040404h;

cmp idx,256;
jl loop1;

psubw max,mem8000;
mov retu,maxi;
movq maxes,max;

    pop maxi;
    pop pidx;
    pop idx;
    pop tab;
    pop lsp;
  }

// find which of the 4 maxes is the max, and return the appropriate
// one of the 4 maxindices.

  mx = maxes[0]; t = 0;
  if (maxes[1] >= mx) { mx = maxes[1]; t = 8; }
  if (maxes[2] >= mx) { mx = maxes[2]; t = 16; }
  if (maxes[3] >= mx) { mx = maxes[3]; t = 24; }

  ASM emms;
  retu = (retu >> t) & 0xff;

  return(retu);

#undef a
#undef b
#undef idx
#undef lsp
#undef tab
#undef max
#undef maxi

#else   // if assembly code not selected, use C code

  int Indx[4],i,s,ret;
  short Max[4],Err,mx;
  short m0,m1,m2,m3,m4,m5,m6,m7,t;

  for (i=0; i<4; i++)
  {
    Max[i] = Indx[i] = 0;
  }
    
  for (i=0; i < LspCbSize; i++)
  {
    s = (i&3);

    m0 = mult(Lspw[4],LspTab[s+0]);
    t = LspTab[s+0]-Lspw[0];  m1 = mult(t,m0<<2);
    m2 = mult(Lspw[5],LspTab[s+4]);
    t = LspTab[s+4]-Lspw[1];  m3 = mult(t,m2<<2);
    m4 = mult(Lspw[6],LspTab[s+8]);
    t = LspTab[s+8]-Lspw[2];  m5 = mult(t,m4<<2);
    m6 = mult(Lspw[7],LspTab[s+12]);
    t = LspTab[s+12]-Lspw[3];  m7 = mult(t,m6<<2);

    Err = m1+m3+m5+m7;

    if (Err >= Max[s])
    {
      Max[s] = Err;
      Indx[s] = i;
    }

    if (s==3)
      LspTab += 16;
  }
  mx = Max[0]; ret = Indx[0];
  if (Max[1] >= mx) { mx = Max[1]; ret = Indx[1]; }
  if (Max[2] >= mx) { mx = Max[2]; ret = Indx[2]; }
  if (Max[3] >= mx) { mx = Max[3]; ret = Indx[3]; }

  return(ret);

#endif
}
//--------------------------------------------------------------

Word32  Svq_Int(float *Lsp, float *Wvect)
{
#define LSP_SCALE 256

  int  i;

  Word32 Rez;
  int    z;
  short Wint[LpcOrder],LspTemp[LpcOrder];
  DECLARE_SHORT(Lspw,32);

  ALIGN_ARRAY(Lspw);

  for (i=0; i<LpcOrder; i++)
  {
    z = (int)(LSP_SCALE*2*Lsp[i]);
    if (z > 32767) LspTemp[i] = 32767;
    else if (z < -32768) LspTemp[i] = -32768;
    else LspTemp[i] = z;
  }
  FloatToShortScaled(Wvect,Wint,10,0);
  Rez = (Word32) 0;

// For each of the 3 bands
  
  Lspw[0] = LspTemp[0]; Lspw[1] = LspTemp[1]; Lspw[2] = LspTemp[2];
  Lspw[3] = 0;
  Lspw[4] = -Wint[0]; Lspw[5] = -Wint[1]; Lspw[6] = -Wint[2];
  Lspw[7] = 0;
  Rez = LspSearchInt(Lspw,LspTableInt);

  Lspw[0] = LspTemp[3]; Lspw[1] = LspTemp[4]; Lspw[2] = LspTemp[5];
  Lspw[3] = 0;
  Lspw[4] = -Wint[3]; Lspw[5] = -Wint[4]; Lspw[6] = -Wint[5];
  Lspw[7] = 0;
  Rez = (Rez<<8) + LspSearchInt(Lspw,&LspTableInt[1024]);

  Lspw[0] = LspTemp[6]; Lspw[1] = LspTemp[7]; Lspw[2] = LspTemp[8];
  Lspw[3] = LspTemp[9];
  Lspw[4] = -Wint[6]; Lspw[5] = -Wint[7]; Lspw[6] = -Wint[8];
  Lspw[7] = -Wint[9];
  Rez = (Rez<<8) + LspSearchInt(Lspw,&LspTableInt[2048]);

  return Rez;

}
#endif
//---------------------------------------------------------------
float Polynomial(float *Lpq, int CosPtr)
{
  return(Lpq[LpcOrder]*CosineTable[0] +
    Lpq[LpcOrder-2]*CosineTable[CosPtr] +
    Lpq[LpcOrder-4]*CosineTable[(CosPtr*2)&(CosineTableSize-1)] +
    Lpq[LpcOrder-6]*CosineTable[(CosPtr*3)&(CosineTableSize-1)] +
    Lpq[LpcOrder-8]*CosineTable[(CosPtr*4)&(CosineTableSize-1)] +
    Lpq[LpcOrder-10]*CosineTable[(CosPtr*5)&(CosineTableSize-1)]);
}


//--------------------------------------------------------------
void  AtoLsp(float *LspVect, float *Lpc, float *PrevLsp)
{
  int  i,j,k;
  int  LspCnt;
  float  Lpq[LpcOrder+2];
  float  PrevVal,CurrVal,AbsPrev,AbsCurr;

// Small additional bandwidth expansion
  
  for (i=0; i < LpcOrder; i++)
    LspVect[i] = Lpc[i]*BandExpTable[i];

// Compute Lp and Lq
 
  Lpq[0] = Lpq[1] = 1.0f;

  for (i=0; i < LpcOrder/2; i++)
  {
    Lpq[2*i+2] = -Lpq[2*i+0] - LspVect[i] - LspVect[LpcOrder-1-i];
    Lpq[2*i+3] =  Lpq[2*i+1] - LspVect[i] + LspVect[LpcOrder-1-i];
  }
  Lpq[LpcOrder+0] *= 0.5f;
  Lpq[LpcOrder+1] *= 0.5f;

// Do first evaluation
  
  k = 0;
  LspCnt = 0;
  PrevVal = Polynomial(Lpq,0);

  for (i=1; i < CosineTableSize/2; i++)
  {
// Evaluate the polynomial
    
    CurrVal = Polynomial(&Lpq[k],i);

// Test for sign change
    
    if ((asint(CurrVal) ^ asint(PrevVal)) < 0)
    {
      AbsPrev = (float)fabs(PrevVal);
      AbsCurr = (float)fabs(CurrVal);

      LspVect[LspCnt++] = (i-1 + AbsPrev/(AbsPrev+AbsCurr));

// Check if all found 

      if (LspCnt == LpcOrder)
        break;

// Switch the pointer, evaluate again
 
      k ^= 1;
      CurrVal = Polynomial(&Lpq[k],i);
    }
    PrevVal = CurrVal;
  }

// Check if all Lsp found

  if (LspCnt != LpcOrder)
  {
    for (j=0; j < LpcOrder; j++)
      LspVect[j] = PrevLsp[j];
    
  }
    return;
}
//--------------------------------------------------------------
Word32 Lsp_Qnt(float *CurrLsp, float *PrevLsp, int UseMMX)
{
  int  i;

  float Wvect[LpcOrder];
  float Min,Tmp;

// Compute the weighting vector
  
  Wvect[0] = 1.0f/(CurrLsp[1] - CurrLsp[0]);
  Wvect[LpcOrder-1] = 1.0f/(CurrLsp[LpcOrder-1] - CurrLsp[LpcOrder-2]);

  for (i=1; i < LpcOrder-1; i++)
  {
    Min = CurrLsp[i+1] - CurrLsp[i];
    Tmp = CurrLsp[i] - CurrLsp[i-1];
    
    if (Tmp < Min)
      Min = Tmp;

    if (Min > 0.0f)
      Wvect[i] = 1.0f/Min;
    else
      Wvect[i] = 1.0f;
  }

// Generate predicted vector as (DC-removed-Curr) - b*(DC-removed-Prev)

    CurrLsp[0] = (CurrLsp[0] - LspDcTable[0]) -
      LspPred0*(PrevLsp[0] - LspDcTable[0]);
	   CurrLsp[1] = (CurrLsp[1] - LspDcTable[1]) -
      LspPred0*(PrevLsp[1] - LspDcTable[1]);
	   CurrLsp[2] = (CurrLsp[2] - LspDcTable[2]) -
      LspPred0*(PrevLsp[2] - LspDcTable[2]);
	   CurrLsp[3] = (CurrLsp[3] - LspDcTable[3]) -
      LspPred0*(PrevLsp[3] - LspDcTable[3]);
	   CurrLsp[4] = (CurrLsp[4] - LspDcTable[4]) -
      LspPred0*(PrevLsp[4] - LspDcTable[4]);
	   CurrLsp[5] = (CurrLsp[5] - LspDcTable[5]) -
      LspPred0*(PrevLsp[5] - LspDcTable[5]);
	   CurrLsp[6] = (CurrLsp[6] - LspDcTable[6]) -
      LspPred0*(PrevLsp[6] - LspDcTable[6]);
	   CurrLsp[7] = (CurrLsp[7] - LspDcTable[7]) -
      LspPred0*(PrevLsp[7] - LspDcTable[7]);
	   CurrLsp[8] = (CurrLsp[8] - LspDcTable[8]) -
      LspPred0*(PrevLsp[8] - LspDcTable[8]);
	   CurrLsp[9] = (CurrLsp[9] - LspDcTable[9]) -
      LspPred0*(PrevLsp[9] - LspDcTable[9]);

// Do the SVQ
#if COMPILE_MMX
  	if (UseMMX)
    	return Svq_Int(CurrLsp, Wvect);
  	else
#endif
    	return Lsp_Svq(CurrLsp, Wvect);
}


//--------------------------------------------------------------
Word32  Lsp_Svq(float *Lsp, float *Wvect)
{
  int  i,k;

  Word32 Rez;
  int    Indx,Start,Dim;
  float *LspQntPnt;
  float  Max,Err,lsp0,lsp1,lsp2,lsp3,w0,w1,w2,w3;
  float LspTemp[LpcOrder];

  for (i=0; i<LpcOrder; i++)
    LspTemp[i] = 2.0f*Lsp[i];
  Rez = (Word32) 0;

// For each of the 3 bands
  
  for (k=0; k < LspQntBands; k++)
  {

// Initialize the search
    
    Max = 0.0f;  //-1.0f;
    Indx = 0;
    LspQntPnt = BandQntTable[k];
    Start = BandInfoTable[k][0];
    Dim = BandInfoTable[k][1];

    lsp0 = LspTemp[Start+0];
    lsp1 = LspTemp[Start+1];
    lsp2 = LspTemp[Start+2];
    w0 = Wvect[Start+0];
    w1 = Wvect[Start+1];
    w2 = Wvect[Start+2];
    
    if (k < 2)
    {
      for (i=0; i < LspCbSize; i++)
      {
        Err = (lsp0 - LspQntPnt[0])*w0*LspQntPnt[0] +
          (lsp1 - LspQntPnt[1])*w1*LspQntPnt[1] +
          (lsp2 - LspQntPnt[2])*w2*LspQntPnt[2];

        LspQntPnt += 3;

        if (asint(Err) > asint(Max))
        {
          Max = Err;
          Indx = i;
        }
      }
    }
    else
    {
      lsp3 = LspTemp[Start+3];
      w3 = Wvect[Start+3];
      for (i=0; i < LspCbSize; i++)
      {
        Err = (lsp0 - LspQntPnt[0])*w0*LspQntPnt[0] +
          (lsp1 - LspQntPnt[1])*w1*LspQntPnt[1] +
          (lsp2 - LspQntPnt[2])*w2*LspQntPnt[2] +
          (lsp3 - LspQntPnt[3])*w3*LspQntPnt[3];

        LspQntPnt += 4;

        if (asint(Err) > asint(Max))
        {
          Max = Err;
          Indx = i;
        }
      }
    }
    Rez = (Rez << 8) | Indx;
  }

  return Rez;
}


//--------------------------------------------------------------
Flag  Lsp_Inq(float *Lsp, float *PrevLsp, Word32 LspId, int Crc)
{
  int  i,j;

  float *LspQntPnt;
  float  Lprd,Scon,Tmpf,Scon2;
  int    Tmp;
  Flag   Test;

  if (Crc == 0)
  {
    Scon = 2.0f;
    Lprd = LspPred0;
  }
  else
  {
    LspId = (Word32) 0;
    Scon = 4.0f;
    Lprd = LspPred1;
  }
  Scon2 = Scon - 0.03125f;

// Reconstruct the LSP vector
  
  for (i=LspQntBands-1; i >= 0; i--)
  {
    Tmp = LspId & (Word32) 0x000000ff;
    LspId >>= 8;

    LspQntPnt = BandQntTable[i];

    for (j=0; j < BandInfoTable[i][1]; j++)
      Lsp[BandInfoTable[i][0] + j] = LspQntPnt[Tmp*BandInfoTable[i][1] + j];
  }

// Add predicted vector and DC to decoded vector
  
  for (j=0; j < LpcOrder; j++)
    Lsp[j] = Lsp[j] + (PrevLsp[j] - LspDcTable[j])*Lprd + LspDcTable[j];

// Perform the stability check
  
  for (i=0; i < LpcOrder; i++)
  {

// Test the first and last one

    if (Lsp[0] < 3.0) 
      Lsp[0] = 3.0f;

    if (Lsp[LpcOrder-1] > 252.0f)
      Lsp[LpcOrder-1] = 252.0f;

// Test the others
    
    for (j=1; j < LpcOrder; j++)
    {
      Tmpf = Scon + Lsp[j-1] - Lsp[j];
      if (Tmpf > 0)
      {
        Tmpf *= 0.5f;
        Lsp[j-1] -= Tmpf;
        Lsp[j] += Tmpf;
      }
    }
    
// Test if stable
    
    Test = False;
    for (j=1; j < LpcOrder; j++)
      if ((Lsp[j] - Lsp[j-1]) < Scon2)
        Test = True;

    if (Test == False)
      break;
  }
  if (Test == True)
  	for (j=0; j < LpcOrder; j++)
	  Lsp[j] = PrevLsp[j];
  return Test;
}


//--------------------------------------------------------------
void  Lsp_Int(float *QntLpc, float *CurrLsp, float *PrevLsp)
{
  int  i,j;

  float  *Dpnt;
  float  Fac[4] = {0.25f, 0.5f, 0.75f, 1.0f};

  Dpnt = QntLpc;
  for (i=0; i < SubFrames; i++)
  {
// Interpolate

    for (j=0; j < LpcOrder; j++)
      Dpnt[j] = (1.0f - Fac[i])*PrevLsp[j] + Fac[i]*CurrLsp[j];

// Convert to Lpc
    
	  LsptoA(Dpnt);
    Dpnt += LpcOrder;
  }

// Copy the Lsp vector
  
  for (i=0; i < LpcOrder; i++)
    PrevLsp[i] = CurrLsp[i];
}


//--------------------------------------------------------------
void  LsptoA(float *Lsp)
{
  int i,j;

  float P[LpcOrder/2+1];
  float Q[LpcOrder/2+1];
  float Fac[(LpcOrder/2)-2] = {1.0f,0.5f,0.25f};

// Convert Lsp's to cosines
  
  for (i=0; i < LpcOrder; i++)
  {
    j = MyFloor(Lsp[i]);
    Lsp[i] = -(CosineTable[j] +
      (CosineTable[j+1]-CosineTable[j])*(Lsp[i]-j));
  }

// Init P and Q.  Note that P,Q * 2^26 correspond to fixed-point code

  P[0] = 0.5f;
  P[1] = Lsp[0] + Lsp[2];
  P[2] = 1.0f + 2.0f*Lsp[0]*Lsp[2];

  Q[0] = 0.5f;
  Q[1] = Lsp[1] + Lsp[3];
  Q[2] = 1.0f + 2.0f*Lsp[1]*Lsp[3];

// Compute all the others
  
  for (i=2; i < LpcOrder/2; i++)
  {
    P[i+1] = P[i-1] + P[i]*Lsp[2*i+0];
    Q[i+1] = Q[i-1] + Q[i]*Lsp[2*i+1];

// All update
    
    for (j=i; j >= 2; j--)
    {
      P[j] = P[j-1]*Lsp[2*i+0] + 0.5f*(P[j]+P[j-2]);
      Q[j] = Q[j-1]*Lsp[2*i+1] + 0.5f*(Q[j]+Q[j-2]);
    }

// Update PQ[01]

    P[0] = P[0]*0.5f;
    Q[0] = Q[0]*0.5f;

    P[1] = (P[1] + Lsp[2*i+0]*Fac[i-2])*0.5f;
    Q[1] = (Q[1] + Lsp[2*i+1]*Fac[i-2])*0.5f;
  }

// Convert to Lpc
  
  for (i=0; i < LpcOrder/2; i++)
  {
    Lsp[i] =            (-P[i] - P[i+1] + Q[i] - Q[i+1])*8.0f;
    Lsp[LpcOrder-1-i] = (-P[i] - P[i+1] - Q[i] + Q[i+1])*8.0f;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\mmxutil.c ===
//  SAC MMx utilities
#include <memory.h>

#include "mmxutil.h"
#include "opt.h"
#define I2FTEST 0
#if I2FTEST
#include "stdio.h"
#endif

//------------------------------------------------------
int IsMMX()     // does the processor I'm running have MMX(tm) technology?
{
  int retu;

#ifdef _ALPHA_
    return 0;
#endif

#ifdef _X86_
  __asm
  {
	push ebx
    pushfd
    pop edx
    mov eax,edx
    xor edx,200000h
    push edx
    popfd
    pushfd
    pop edx
//
//  DON'T do this. This clears EAX, but the code is relying
//  on edx being 0 in the bail out case!!!
//
//  -mikeg
//
//    xor       eax,edx
//
//
    xor edx,eax     //This is the right way
    je  no_cpuid

    mov eax,1
    _emit 0x0f     //CPUID magic incantation
    _emit 0xa2
    and  edx,000800000h
    shr  edx,23
no_cpuid:
    mov  retu,edx
	pop ebx
  }
  return(retu);
#endif
}
//------------------------------------------------------
/* The following 4 routines make an 8-byte-aligned 'output' array
   from an 'input' array with various alignments.  MakeAlignedN assumes
   that 'input' starts on an address equal to N mod 8.  For now we
   only handle even N.
*/

//------------------------------------------------------
void MakeAligned0(void *input, void *output, int numbytes)
{
  memcpy(output,input,numbytes);
}
//------------------------------------------------------
void MakeAligned2(void *input, void *output, int numbytes)
{
  memcpy(output,input,numbytes);
}
//------------------------------------------------------
void MakeAligned4(void *input, void *output, int numbytes)
{
  memcpy(output,input,numbytes);
}
//------------------------------------------------------
void MakeAligned6(void *input, void *output, int numbytes)
{
  memcpy(output,input,numbytes);
}

//------------------------------------------------------
int FloatToShortScaled(float *input, short *output, int len, int guard)
{
  int max;

/* Convert an array of floats to an array of shorts with dynamic scaling.
   If guard=0 the array is scaled so that the largest power of 2 contained
   in the input comes out as 16384, which means all values fit in 16 bits
   without overflow.  If guard>0 the outputs are shifted an extra 'guard'
   bits to the right.
*/

  max = FloatMaxExp(input, len);
  ScaleFloatToShort(input, output, len, max + guard);

  return max;
}

int FloatToIntScaled(float *input, int *output, int len, int guard)
{
  int max;

/* Convert an array of floats to an array of shorts with dynamic scaling.
   If guard=0 the array is scaled so that the largest power of 2 contained
   in the input comes out as 2^30, which means all values fit in 32 bits
   without overflow.  If guard>0 the outputs are shifted an extra 'guard'
   bits to the right.
*/

  max = FloatMaxExp(input, len);
  ScaleFloatToInt(input, output, len, max + guard);

  return max;
}

int FloatMaxExp(float *input, int len)
{
  int max;

#if ASM_FTOSS

  ASM
  {
    mov esi,input;
    xor eax,eax;
    mov ebx,len;
    xor edi,edi;   // max

loop2:
    mov ecx,DP[esi+4*eax];
     mov edx,DP[esi+4*eax+4];

    and ecx,07f800000h;
     and edx,07f800000h;

    cmp edi,ecx;
     jge skip1;
    mov edi,ecx;
skip1:

    cmp edi,edx;
     jge skip2;
    mov edi,edx;
skip2:

    add eax,2;
    cmp eax,ebx;
    jl loop2;

    mov max,edi;
  }

#else

  int exp,i;

  max = 0;
  for (i=0; i<len; i++)
  {
    exp = (*((int *)(input + i))) & 0x7f800000;
    if (exp > max)
      max = exp;
  }
#endif

  return max >> 23;
}


void ScaleFloatToShort(float *input, short *output, int len, int newmax)
{
  int i;
  float scale;
/*
  If max exponent is 14, we want a scale factor of 1, since
  then values will be at most +/- 32727.  So scale factor multiplier
  should be 2^(14 - max - guard).  But 'max' has the exponent bias
  built in, so we must add BIAS once to the exponent to get a "real"
  exponent.  But then we want a FP exponent that has bias, so we
  need to add BIAS again!  So we get 2^(2*BIAS+14 - max - guard).
  2*BIAS+14 is 254 + 14 = 252+12, so it's 0x86000000 (first 9 bits 1 0000 1100)
*/

  i = 0x86000000 - (newmax << 23);
  scale = (*(float *)&i);

#if ASM_FTOSS

  ASM
  {
    mov esi,input;
    mov edi,output;
    xor eax,eax;
    mov ebx,len;

loop1:
    fld DP[esi+4*eax];
    fmul scale;
    fld DP[esi+4*eax+4];
    fmul scale;
    fxch(1);
    fistp WP[edi+2*eax];
    fistp WP[edi+2*eax+2];

    add eax,2;
    cmp eax,ebx;
    jl loop1;
  }

#else

  for (i=0; i<len; i++)
    output[i] = (short)(input[i]*scale);

#endif
  return;
}

void ConstFloatToShort(float *input, short *output, int len, float scale)
{

#if ASM_FTOSS

  ASM
  {
    mov esi,input;
    mov edi,output;
    xor eax,eax;
    mov ebx,len;

loop1:
    fld DP[esi+4*eax];
    fmul scale;
    fld DP[esi+4*eax+4];
    fmul scale;
    fxch(1);
    fistp WP[edi+2*eax];
    fistp WP[edi+2*eax+2];

    add eax,2;
    cmp eax,ebx;
    jl loop1;
  }

#else
  int i;

  for (i=0; i<len; i++)
    output[i] = (short)(input[i]*scale);

#endif
  return;
}


//------------------------------------------------------
void ScaleFloatToInt(float *input, int *output, int len, int newmax)
{
  int i;
  float scale;

  i = 0x8E000000 - (newmax << 23);
  scale = (*(float *)&i);

#if ASM_FTOSS

  ASM
  {
    mov esi,input;
    mov edi,output;
    xor eax,eax;
    mov ebx,len;

loop1:
    fld DP[esi+4*eax];
    fmul scale;
    fld DP[esi+4*eax+4];
    fmul scale;
    fxch(1);
    fistp DP[edi+4*eax];
    fistp DP[edi+4*eax+4];

    add eax,2;
    cmp eax,ebx;
    jl loop1;
  }

#else

  for (i=0; i<len; i++)
    output[i] = (int)(input[i]*scale);

#endif
  return;
}

void ConstFloatToInt(float *input, int *output, int len, float scale)
{

#if ASM_FTOSS

  ASM
  {
    mov esi,input;
    mov edi,output;
    xor eax,eax;
    mov ebx,len;

loop1:
    fld DP[esi+4*eax];
    fmul scale;
    fld DP[esi+4*eax+4];
    fmul scale;
    fxch(1);
    fistp DP[edi+4*eax];
    fistp DP[edi+4*eax+4];

    add eax,2;
    cmp eax,ebx;
    jl loop1;
  }

#else
  int i;

  for (i=0; i<len; i++)
    output[i] = (int)(input[i]*scale);

#endif
  return;
}


//------------------------------------------------------
void CorrelateInt(short *taps, short *array, int *corr, int len, int num)
{
  int i,j;

  for (i=0; i<num; i++)  // for each correlation
  {
    corr[i] = 0;
    for (j=0; j<len; j++)
      corr[i] += (int)taps[j] * (int)array[i+j];
  }
}

#if ASM_CORR
//------------------------------------------------------
void CorrelateInt4(short *taps, short *array, int *corr, int ntaps, int ncor)
{

#define rega0  mm0
#define regb0  mm1
#define rega1  mm2
#define regb1  mm3
#define rega2  mm4
#define regb2  mm5
#define acc0   mm6
#define acc1   mm7

#define arr    esi
#define tap    edi
#define cor    eax
#define icnt   ebx

// In the following macros, 'n' is the column number and 'i' is the
// iteration number.

#define la(n,i)  ASM movq  rega##n,QP[arr+8*i]
#define lb(n,i)  ASM movq  regb##n,QP[tap+8*i+8]
#define m0(n,i)  ASM pmaddwd regb##n,rega##n
#define m1(n,i)  ASM pmaddwd rega##n,QP[tap+8*i]
#define a0(n,i)  ASM paddd acc0,regb##n
#define a1(n,i)  ASM paddd acc1,rega##n

  ASM
  {
    shr ntaps,2;
    sub taps,8;  // point to 1 before start of taps array
    mov cor,corr;

ForEachCorrPair:

    mov icnt,ntaps;
    pxor acc0,acc0;
    pxor acc1,acc1;
    mov tap,taps;
    mov arr,array;
  }

// prime the pump

  la(0,0);
  lb(0,0);
  m0(0,0);
  ASM pxor rega0,rega0;   // to make first a1(0,0) a nop
	  la(1,1);
	  lb(1,1);

inner:
		  la(2,2);
	  m0(1,1);
	  m1(1,1);
  a0(0,0);
		  lb(2,2);
  a1(0,0);
  la(0,3);
		  m0(2,2);
		  m1(2,2);
	  a0(1,1);
  lb(0,3);
	  a1(1,1);
	  la(1,4);
  m0(0,3);
  m1(0,3);
		  a0(2,2);
	  lb(1,4);
		  a1(2,2);

  ASM add arr,24;
  ASM add tap,24;

  ASM sub icnt,3;
  ASM jg inner;

  a1(0,0);

// Done with one correlation pair.  First need to add halves of
// acc0 and acc1 together and then store 2 results in corr array

  ASM
  {
    movq  mm0,acc0;
    psrlq acc0,32;
    paddd acc0,mm0;
    movq  mm1,acc1;
    psrlq acc1,32;
    movd  DP[cor],acc0;
    paddd acc1,mm1;
    movd  DP[cor+16],acc1;

    add cor,32;
    add array,16;
    sub ncor,2;
    jg ForEachCorrPair;

    emms;
  }

}
#undef rega0
#undef regb0
#undef rega1
#undef regb1
#undef rega2
#undef regb2
#undef acc0
#undef acc1

#undef arr
#undef tap
#undef cor
#undef icnt
#undef la
#undef lb
#undef m0
#undef m1
#undef a0
#undef a1

#else
//------------------------------------------------------
void CorrelateInt4(short *taps, short *array, int *corr, int ntaps, int ncor)
{
  int i,j,k;

  k = 0;
  for (i=0; i<ncor; i++)  // for each correlation
  {
    corr[k] = 0;
    for (j=0; j<ntaps; j++)
      corr[k] += (int)taps[j] * (int)array[k+j];
    k += 4;
  }
}
#endif
#if COMPILE_MMX
#undef icnt
void ab2abbcw(const short *input, short *output, int n)
{

#define in edi
#define out esi
#define icnt ecx

#define L(m,i)  ASM movq mm##m,QP[in+8*(i/2)]
#define PL(m)   ASM punpcklwd mm##m,mm##m
#define PH(m)   ASM punpckhwd mm##m,mm##m
#define SL(m) ASM psllq mm##m,16
#define SR(m) ASM psrlq mm##m,48
#define O(m,n)  ASM por mm##m,mm##n
#define S(m,i)  ASM movq QP[out+8*i],mm##m
	ASM {
	mov in, input;
	mov out, output;
	mov icnt, n;
	ASM     pxor mm3,mm3;
	sub icnt, 8;
	jl odd_ends;
	}

	//prime pump
	L(0,0);
	PL(0);
			L(1,1);
	SL(0);
			PH(1);
			SL(1);
							O(3,0);
					L(2,2);
	SR(0);
							S(3,0);
					PL(2);

	ASM sub icnt, 8;
	ASM jl cleanup;
inner:
					SL(2);
	O(0,1);
							L(3,3)
			SR(1);
	S(0,1);
							PH(3);
							SL(3);
			O(1,2);
	L(0,4);
					SR(2);
			S(1,2);
	PL(0);
	SL(0);          
					O(2,3);
			L(1,5);
							SR(3);
					S(2,3);
			PH(1);
			SL(1);
							O(3,0);
					L(2,6);
	SR(0);
							S(3,4);
					PL(2);

	ASM add in, 16;
	ASM  add out, 32;
	ASM sub icnt, 8;
	ASM  jg inner;

cleanup:
					SL(2);
	O(0,1);
							L(3,2);
			SR(1);
	S(0,1);
							PH(3);
							SL(3);
			O(1,2);
					SR(2);
			S(1,2);
					O(2,3);
					S(2,3);

odd_ends:
	ASM add icnt, 8-4;
	ASM  jl end;     // jump if no sign change

	L(0,4);
							SR(3);
	PL(0);
			L(1,5);
	SL(0);          
			PH(1);
							O(3,0);
			SL(1);
	SR(0);
							S(3,4);
	O(0,1);
	S(0,5);

end:
	ASM emms;
#undef in
#undef out
#undef icnt

#undef L
#undef PL
#undef PH
#undef SL
#undef SR
#undef O
#undef S

	return;
}
void ab2ababw(const short *input, short *output, int n)
{

#define in edi
#define out esi
#define icnt ecx

#define L(m,i) ASM movq mm##m,QP[in+4*i]
#define C(m,n) ASM movq mm##m,mm##n
#define PL(m)  ASM punpckldq mm##m,mm##m
#define PH(m)  ASM punpckhdq mm##m,mm##m
#define S(m,i) ASM movq [out+8*i],mm##m

	ASM {
	mov in, input;
	mov out, output;
	mov icnt, n;
	sub icnt, 8;
	jl odd_ends;
	}
	//prime pump
	L(0,0);
			C(1,0);
	PL(0);
					L(2,2);
			PH(1);
	S(0,0);
							C(3,2);
			S(1,1);
					PL(2);
	ASM add in, 16;
	ASM  add out, 32;
	ASM sub icnt, 8;
	ASM  jl cleanup;

inner:
	L(0,0);
							PH(3);
					S(2,-2);
			C(1,0);
							S(3,-1);
	PL(0);
					L(2,2);
			PH(1);
	S(0,0);
					C(3,2);
			S(1,1);
					PL(2);
	ASM add in, 16;
	ASM  add out, 32;
	ASM sub icnt, 8;
	ASM  jg inner;

cleanup:
							PH(3);
					S(2,-2);
							S(3,-1);
odd_ends:
	ASM add icnt, 8-2;
	ASM  jl end;     // jump if no sign change

inner_by2:
	ASM movd mm0, DP[in];
	PL(0);
	S(0,0);
	ASM add in, 4;
	ASM  add out, 8;
	ASM sub icnt, 2;
	ASM  jge inner_by2;

end:
	ASM emms;

	return;
}
#undef in
#undef out
#undef icnt

#undef L
#undef C
#undef PL
#undef PH
#undef S

void ConvMMX(short *input1, short *input2, int *output, int ncor)
{
#define rega0  mm0
#define regb0  mm1
#define rega1  mm2
#define regb1  mm3
#define rega2  mm4
#define regb2  mm5
#define acc0   mm6
#define acc1   mm7

#define in2    esi
#define in1    edi
#define out    eax
#define icnt   ecx
#define tmp        ebx

// In the following macros, 'n' is the column number and 'i' is the
// iteration number.

// we use "the convolution trick" or using la twice so that one
// of the pmadd's is reg,reg and thus can be in the V-slot.

// NOTE: we have read ahead up to 2 quadwords
//   so we need QP[taps+8*ncor] = QP[taps+8*ncor+8] = [0 0 0 0]
//   and reading QP[array+8*ncor] or QP[array+8*ncor+8] must be legal

#define la(n,i)  ASM movq  rega##n,QP[in2+8*i]
#define lb(n,i)  ASM movq  regb##n,QP[in1+8*i-8]
#define m0(n,i)  ASM pmaddwd regb##n,rega##n
#define m1(n,i)  ASM pmaddwd rega##n,QP[in1+8*i]
#define a0(n,i)  ASM paddd acc0,regb##n
#define a1(n,i)  ASM paddd acc1,rega##n

  ASM
  {
	mov tmp,ncor;
	shl tmp,2;
    shr ncor,1;
    mov out,output;
	add out,tmp;
	add out,16;
    mov in1,input1;
    mov in2,input2;
    mov icnt,ncor;
  }

ForEachCorrPair:

// prime the pump

  la(0,0);
  ASM pxor regb0,regb0;   // to  avoid lb(0,0) reading taps[-1]
	  la(1,1);
  ASM pxor acc0,acc0;     // clear accumulator
  m1(0,0);
  ASM pxor acc1,acc1;     // clear accumulator
	  lb(1,1);
  ASM sub icnt, 1;        // account for pump priming
  ASM jle cleanup;        // bypass if only one to do

inner:
		  la(2,2);
	  m0(1,1);
	  m1(1,1);
  a0(0,0);
		  lb(2,2);
  a1(0,0);
  la(0,3);
		  m0(2,2);
		  m1(2,2);
	  a0(1,1);
  lb(0,3);
	  a1(1,1);
	  la(1,4);
  m0(0,3);
  m1(0,3);
		  a0(2,2);
	  lb(1,4);
		  a1(2,2);

  ASM add in2,24;
  ASM add in1,24;

  ASM sub icnt,3;
  ASM jg inner;

cleanup:  //  last two adds
  a0(0,0);
  a1(0,0);

// Done with one correlation pair.  Pack and store 2 results in corr array

  ASM
  {
    sub out,16;
	
     mov in2, input2;
    mov in1,input1;
	 add in2,16;
    mov icnt, ncor;
	
	mov input2, in2;
	 sub icnt,2;      //set flags for jump

	movq  QP[out-16],acc0;
	movq  QP[out-8],acc1;

	mov ncor, icnt;
    jg ForEachCorrPair;

    emms;
  }

}
#undef rega0
#undef regb0
#undef rega1
#undef regb1
#undef rega2
#undef regb2
#undef acc0
#undef acc1

#undef in2
#undef in1
#undef out
#undef icnt
#undef tmp

#undef la
#undef lb
#undef m0
#undef m1
#undef a0
#undef a1
// 16 bit output
//       psrad acc0,16;//this could be less in some cases
//       psrad acc1,16;
//       packssdw acc1,acc0;
//   movq  QP[cor-8],acc0;

//#else
//------------------------------------------------------
/*
void ConvMMX(short *in1, short *in2, int *out, int ncor)
{
  int i,j;

  for (i=0; i < 2*ncor; i+=4)    {
    int acc0 = 0, acc1 = 0;
    for (j=0; j < 2*ncor - i; j+=4) {
      acc0 += (int)taps[j]*array[i+j] + (int)taps[j+1]*array[i+j+1];
      acc1 += (int)taps[j+2]*array[i+j+2] + (int)taps[j+3]*array[i+j+3];
    }
    corr[i/2] = acc0 ;
    corr[i/2+1] = acc1 ;
  }

  return;
}*/

void ab2abzaw(const short *input, short *output, int n)
{
	register int i;
	register unsigned *in, *out;
	register unsigned x, y; //tread two words at a time as raw bits

	in = (unsigned *)input;
	out = (unsigned *)output;
	//unroll by two
	for (i = n/2 - 2; i>0; i-=2) {
		x = in[i];
		y = in[i+1];
		out[2*(i+1)] = y;
		out[2*(i+1)+1] = (y<<16 | x>>16);
		
		x = in[i-1];
		y = in[i];
		out[2*i] = y;
		out[2*i+1] = (y<<16 | x>>16);
	}
	//odd ends
	for (i++; i>=0; i--) {
		x = (i>0)?in[i-1]:0;
		y = in[i];
		out[2*i] = y;
		out[2*i+1] = (y<<16 | x>>16);
	}
	return;
}

void ShortToFloatScale(short *x, float scale, int N, float *y)
{

/*
	short i;
	float yy[100];
	for (i=0; i<N; i++)
	{ yy[i]=x[i]*scale; }


  ASM
	{       
    mov esi,x;
    mov edi,y;
	lea ecx,scale;
	mov     eax, N
	sub     eax, 2
loop1:
	fild    WORD PTR [esi+eax*2]
	fmul    DWORD PTR [ecx]
	fstp    DWORD PTR [edi+eax*4]

	fild    WORD PTR [esi+eax*2+2]
	fmul    DWORD PTR [ecx]
	fstp    DWORD PTR [edi+eax*4+4]

	sub     eax, 2
	jge loop1;
	}

*/

  ASM
	{
	mov esi,x;
	mov edi,y;
	lea ecx,scale;
	mov     eax, N
	sub     eax, 6
	fld     DP [ecx]        ;                     c

	fild    WORD PTR [esi+eax*2+8] ;          L0  c

	fild    WORD PTR [esi+eax*2+10] ;      L1 L0  c
	 fxch   ST(1) ;                        L0 L1  c
	fmul    ST(0), ST(2) ;                        M0 L1  c
	 fxch    ST(1) ;                       L1 M0  c
	fmul   ST(0),ST(2) ;                         M1 M0  c

	fild    WORD PTR [esi+eax*2+4] ;    L0 M1 M0  c

	fild    WORD PTR [esi+eax*2+6];  L1 L0 M1 M0  c
	 fxch    ST(3) ;                 M0 L0 M1 L1  c
	fstp    DWORD PTR [edi+eax*4+16];   L0 M1 L1  c
loop1:  ;                                   L0 M1 L1  c

	fmul    ST(0),ST(3) ;                     M0 M1 L1  c
	 fxch    ST(1) ;                    M1 M0 L1  c
	fstp    DWORD PTR [edi+eax*4+20];      M0 L1  c
	 fxch    ST(1) ;                       L1 M0  c
	fmul   ST(0),ST(2) ;                         M1 M0  c
	fild    WORD PTR [esi+eax*2] ;      L0 M1 M0  c

	fild    WORD PTR [esi+eax*2+2] ; L1 L0 M1 M0  c
	 fxch    ST(3) ;                 M0 L0 M1 L1  c
	fstp    DWORD PTR [edi+eax*4+8];    L0 M1 L1  c

	sub     eax, 2
	 jge loop1;
	fmul    ST(0),ST(3) ;eax==-2              M0 M1 L1  c
	 fxch    ST(1) ;                    M1 M0 L1  c
	fstp    DWORD PTR [edi+eax*4+20] ;     M0 L1  c
	 fxch    ST(1) ;                       L1 M0  c
	fmulp   ST(2), st(0) ;                           M0 M1

	fstp    DWORD PTR [edi+eax*4+8] ;            M1

	fstp    DWORD PTR [edi+eax*4+12] ;
	}
/*


for (i=0; i<N; i++)
{
if (y[i]!=yy[i])
{
fprintf(stdout,"\nfloat problem\n");
break;
}
}

*/


}

//assumes N is even
void IntToFloatScale(int *x, float scale, int N, float *y)
{
#if I2FTEST //test code
	int i;
	float yy[1000];
	for (i=0; i<N; i++)
	{ yy[i]=(float)x[i]*scale; }
#endif //test code

#if 0 //simple code
//simple assembly version       
	ASM
	{       
    mov esi,x;
    mov edi,y;
	lea ecx,scale;
	mov     eax, N
	sub     eax, 2
loop1:
	fild    DWORD PTR [esi+eax*4]
	fmul    DWORD PTR [ecx]
	fstp    DWORD PTR [edi+eax*4]

	fild    DWORD PTR [esi+eax*4+4]
	fmul    DWORD PTR [ecx]
	fstp    DWORD PTR [edi+eax*4+4]

	sub     eax, 2
	jge loop1;
	}
#endif //test code


  ASM
	{
	mov esi,x;
	mov edi,y;
	lea ecx,scale;
	mov     eax, N
	sub     eax, 6
	fld     DP [ecx]        ;                     c

	fild    DWORD PTR [esi+eax*4+16] ;        L0  c

	fild    DWORD PTR [esi+eax*4+20] ;     L1 L0  c
	 fxch   ST(1) ;                        L0 L1  c
	fmul    ST(0), ST(2) ;                 M0 L1  c
	 fxch    ST(1) ;                       L1 M0  c
	fmul   ST(0),ST(2) ;                   M1 M0  c

	fild    DWORD PTR [esi+eax*4+8] ;   L0 M1 M0  c

	fild    DWORD PTR [esi+eax*4+12];L1 L0 M1 M0  c
	 fxch    ST(3) ;                 M0 L0 M1 L1  c
	fstp    DWORD PTR [edi+eax*4+16];   L0 M1 L1  c
loop1:  ;                                   L0 M1 L1  c

	fmul    ST(0),ST(3) ;               M0 M1 L1  c
	 fxch    ST(1) ;                    M1 M0 L1  c
	fstp    DWORD PTR [edi+eax*4+20];      M0 L1  c
	 fxch    ST(1) ;                       L1 M0  c
	fmul   ST(0),ST(2) ;                   M1 M0  c
	fild    DWORD PTR [esi+eax*4] ;     L0 M1 M0  c

	fild    DWORD PTR [esi+eax*4+4] ;L1 L0 M1 M0  c
	 fxch    ST(3) ;                 M0 L0 M1 L1  c
	fstp    DWORD PTR [edi+eax*4+8];    L0 M1 L1  c

	sub     eax, 2
	 jge loop1;
	fmul    ST(0),ST(3) ;eax==-2        M0 M1 L1  c
	 fxch    ST(1) ;                    M1 M0 L1  c
	fstp    DWORD PTR [edi+eax*4+20] ;     M0 L1  c
	 fxch    ST(1) ;                       L1 M0  c
	fmulp   ST(2), st(0) ;                    M0 M1

	fstp    DWORD PTR [edi+eax*4+8] ;            M1

	fstp    DWORD PTR [edi+eax*4+12] ;
	}


#if I2FTEST
  for (i=0; i<N; i++)
  {
    if (y[i]!=yy[i])
    {
      printf("F2I %3d %8f %8f\n", i, y[i], yy[i]);
    }
  }
#endif //test code


}

//assumes N is even
void IntToFloat(int *x, int N, float *y)
{
#if I2FTEST //test code
	int i;
	float yy[1000];
	for (i=0; i<N; i++)
	{ yy[i]=(float)x[i]; }
#endif //test code

//simple assembly version       
	ASM
	{       
    mov esi,x;
    mov edi,y;
	mov     eax, N
	sub     eax, 2
loop1:
	fild    DWORD PTR [esi+eax*4]
	fild    DWORD PTR [esi+eax*4+4]
	 fxch    ST(1) ;
	fstp    DWORD PTR [edi+eax*4]
	fstp    DWORD PTR [edi+eax*4+4]

	sub     eax, 2
	jge loop1;
	}


#if I2FTEST
  for (i=0; i<N; i++)
  {
    if (y[i]!=yy[i])
    {
      printf("F2I %3d %8f %8f\n", i, y[i], yy[i]);
    }
  }
#endif //test code


}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\lsp.h ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//

void  AtoLsp( float *LspVect, float *Lpc, float *PrevLsp );
Word32 Lsp_Qnt( float *CurrLsp, float *PrevLsp, int UseMMX );
Word32 Lsp_Svq( float *Lsp, float *Wvect );
Word32 Svq_Int( float *Lsp, float *Wvect );
Flag  Lsp_Inq( float *Lsp, float *PrevLsp, Word32 LspId, int Crc );
void  Lsp_Int( float *QntLpc, float *CurrLsp, float *PrevLsp );
void  LsptoA( float *Lsp );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\opt.h ===
#define FILEIO  0

// Assembly switches for MMX code

#ifdef _X86_
#if !defined(COMPILE_MMX)
  #define COMPILE_MMX   1
#endif
#endif

#ifdef _ALPHA_
//No MMX on Alpha
#if defined(COMPILE_MMX)
  #undef COMPILE_MMX
#endif
#endif
#if COMPILE_MMX
  #define ASM_FTOSS   1
  #define ASM_CORR    1
  #define ASM_SVQ     1
  #define ASM_FACBK   1


#else
  #define ASM_FTOSS   0
  #define ASM_CORR    0
  #define ASM_SVQ     0
  #define ASM_FACBK   0

#endif

// These don't make a numerical difference (compared to model code)
// ...
#ifdef _X86_
#define OPT_PULSE4  1
#define OPT_FLOOR   1
#define OPT_ACBKF   1
#endif

// These are the tricks from FT

#define FT_FBFILT   1   // much faster Find_Best filter that exploits 0's
#define FT_FINDL    1   // faster Find_L with OccPos test removed

// These make a minor numerical difference (max diff = 1)

#ifdef _X86_
#define OPT_DOT 1      // assembly dot product
#define OPT_REV  1      // assembly reverse dot product
#define FIND_L_OPT 1
#endif

//These can't change for alpha
#ifdef _ALPHA_
#define OPT_DOT  0      // assembly dot product
#define OPT_REV  0      // assembly reverse dot product
#define FIND_L_OPT 0
#endif //Alpha
// Bits in "shortcut" flag

#define SC_FINDB 1    // only do 1 Find_Best per subframe
//#define SC_GAIN  2    // only search every other gain
#define SC_GAIN  0
#define SC_LAG1  4    // only search lag=1 in acbk gain search
#define SC_THRES 8    // use 75% of max instead of 50% for codebook threshold

#define SC_DEF (SC_LAG1 | SC_GAIN | SC_FINDB | SC_THRES)  // use all shortcuts

#define asint(x)   (*(int *)&(x))   // look as FP value as an int

#define ASM          __asm
#define QP           QWORD PTR
#define DP           DWORD PTR
#define WP           WORD PTR
#define fxch(n)      ASM fxch ST(n)

//no ';' at end of definition so that can be used as
//  DECLARE_CHAR(mybytes, 100);
//  DECLARE_SHORT(mywords, 32);
// ...
//  ALIGN_ARRAY(mybytes);
//  ALIGN_ARRAY(mywords);
#define DECLARE_CHAR(array,size)  \
  char array##_raw[size+8/sizeof(char)]; \
  char *array

#define DECLARE_SHORT(array,size)  \
  short array##_raw[size+8/sizeof(short)]; \
  short *array

#define DECLARE_INT(array,size)  \
  int array##_raw[size+8/sizeof(int)]; \
  int *array

#define ALIGN_ARRAY(array) \
  array = array##_raw; \
  __asm mov eax,array \
  __asm add eax,7 \
  __asm and eax,0fffffff8h \
  __asm mov array,eax

  #define ALIGN_SHORT_OFFSET(array,offset) \
  array = array##_raw; \
  __asm mov eax,array \
  __asm mov ebx,offset \
  __asm shl ebx,1 \
  __asm add eax, ebx \
  __asm add eax,7 \
  __asm and eax,0fffffff8h \
  __asm sub eax,ebx \
  __asm mov array,eax

#define DECLARE_STRUCTPTR(type,array)  \
  struct {type data; char dummy[8];} array##_raw; \
  type *array

#define ALIGN_STRUCTPTR(array) \
  array = &array##_raw.data; \
  __asm mov eax,array \
  __asm add eax,7 \
  __asm and eax,0fffffff8h \
  __asm mov array,eax
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\mmxutil.h ===
int  IsMMX();
void MakeAligned0(void *input, void *output, int numbytes);
void MakeAligned2(void *input, void *output, int numbytes);
void MakeAligned4(void *input, void *output, int numbytes);
void MakeAligned6(void *input, void *output, int numbytes);
void ShortToFloatScale(short *x, float scale, int N, float *y);
void IntToFloatScale(int *x, float scale, int N, float *y);
void IntToFloat(int *x, int N, float *y);
int FloatToShortScaled(float *in, short *out, int len, int guard);
int FloatToIntScaled(float *in, int *out, int len, int guard);
int FloatMaxExp(float *in, int len);
void ScaleFloatToShort(float *in, short *out, int len, int newmax);
void ScaleFloatToInt(float *in, int *out, int len, int newmax);
void CorrelateInt(short *taps, short *array, int *corr, int len, int num);
void CorrelateInt4(short *taps, short *array, int *corr, int len, int num);
void ab2abbcw(const short *input, short *output, int n);
void ab2ababw(const short *input, short *output, int n);
void ab2abzaw(const short *input, short *output, int n);
void ConvMMX(short *in1, short *in2, int *out, int ncor);
void ConstFloatToShort(float *input, short *output, int len, float scale) ;
void ConstFloatToInt(float *input, int *output, int len, float scale) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\sdstuff.c ===
#include <stdio.h>
#include <stdlib.h>
#include "sdstruct.h"
#include "sdstuff.h"
#include "tabl_ns.h"
#include <math.h>

/**************************************************************
***************************************************************
***************************************************************
***************************************************************
Silence Detection subroutines 
Mark R. Walker, 5/95
Copyright Intel Inc., 1995
***************************************************************
***************************************************************
***************************************************************/


/************************************************************************************************/
/************************************************************************************************/
/*******                                  get_params                             ************/
/************************************************************************************************/
/************************************************************************************************/
/* This subroutine computes the parameters used by the classifier to determine 
whether the current frame is silent*/
#if PLOTFILE	
	void getParams(INSTNCE *SD_inst, float *inbuff, int buffersize, float *p1, float *p2, float *p3)
#else
	void getParams(INSTNCE *SD_inst, float *inbuff, int buffersize)
#endif
{
	int		M, p, i, q, offset, index;
	float	*buffptr,R[12];
	float	gamma, delta, L[50], E[12];
	float 	alpha0;
	float	Energy;
	float	epsilon = 0.00001f;

		
	M = 6;

	buffptr = inbuff;
	offset = M;

	for(i=0; i<(M-1)*(M-1); i++) L[i] = 0.0f;

	Energy = DotProdSD(buffptr, buffptr, buffersize)/buffersize;

	/* Compute autocorrelation coeffs. */
	for(q=0; q<=M; q++) R[q] = DotProdSD(buffptr, buffptr+q, buffersize-q);
	
	for(i=0; i<=M; i++) R[i] = Binomial80[i]*R[i];

	/* Compute first linear predictor */
	L[0] = 1.0f;
	E[0] = R[0];

	/* Forward Levinson's recursion */
	for(p=1;p<=M;p++)
	{
		for(delta=0.0f, i=0;i<p;i++) delta += R[i+1]*L[(p-1)*offset + i]; 
		
		if (E[p-1]!=0.0) gamma = delta / E[p-1];
		else			 gamma = epsilon;
	
		L[p*offset+0] = -gamma;

		for(i=1;i<p;i++) L[p*offset + i] = L[(p-1)*offset + i-1] - gamma*L[(p-1)*offset + p-1-i];
		
		L[p*offset + p] = 1.0f;
		E[p] = E[p-1] * (1.0f-gamma*gamma);
	}
	alpha0 = -L[33];

	/* Load the calculated parameters into the SD data structure */

	/* Zero crossings */
	SD_inst->SDstate.FrameZCs = (float) zeroCross(inbuff, buffersize)/buffersize;
	/* Frame energy */
	if(Energy!=0.0f)
		SD_inst->SDstate.FrameEnergy = (float)(20.0f*log10(Energy));
	else {
		index = (SD_inst->SDFlags & MASK_SQUELCH) >> 8;
		SD_inst->SDstate.FrameEnergy = Squelch[index] - 9.0f
			+ SD_inst->SDstate.SDsettings.Energy_on
			+ SD_inst->SDstate.Mode0Ptr->Energy.Stdev;
	}

	/* First linear predictor */
	SD_inst->SDstate.FrameLinPred = 100.0f*alpha0;

#if PLOTFILE
	*p1 = SD_inst->SDstate.FrameZCs;
	*p2 = SD_inst->SDstate.FrameEnergy;
	*p3 = SD_inst->SDstate.FrameLinPred;
#endif

//end
}
/************************************************************************************************/
/************************************************************************************************/
/*******                               glblSDinitialize                              ************/
/************************************************************************************************/
/************************************************************************************************/
/* This routine is called once per session for setting global values needed for silence         */
/*	detection.																					*/
/************************************************************************************************/
/************************************************************************************************/
void glblSDinitialize(INSTNCE *SD_inst)
{
	int i, index, histSize, tauHistSize;
   	float squelch_level;

/* Set the mode pointers pointing to the mode structures - initially */
  SD_inst->SDstate.Mode0Ptr = &(SD_inst->SDstate.Mode0);
  SD_inst->SDstate.Mode1Ptr = &(SD_inst->SDstate.Mode1);

/* set history sizes based on buffersize, passed in from minifilter shell*/
  			    SD_inst->SDstate.SDsettings.BufferSize = BUFFERSIZE;
  histSize =    SD_inst->SDstate.SDsettings.HistSize = HIST_SIZE;
  tauHistSize = SD_inst->SDstate.SDsettings.TauHistSize = ENERGY_TAU_HIST_SIZE;
  				SD_inst->SDstate.SDsettings.MinStartupCount = (int)(MIN_STARTUP_TIME*8000.0/BUFFERSIZE);
  				SD_inst->SDstate.SDsettings.MaxStartupCount = (int)(MAX_STARTUP_TIME*8000.0/BUFFERSIZE);
  				SD_inst->SDstate.SDsettings.MaxSpeechFrameCount = (int)(MAX_SPEECH_TIME*8000.0/BUFFERSIZE);

  /* set silent/sound frame designation initially to silent */
  /* Class = 1, silent frame
     Class = 0, non-silent */
  SD_inst->SDstate.Class = 1;

  /*set silence detetction initally disabled */
  /* SD_enable =0, silence detection disabled - SD_initialize executes
     SD_enable =1, silence detection enabled */  
  SD_inst->SDstate.SD_enable = 0;

  /* The flags should be set in the minifilter audio format */
  //SD_inst->SDFlags = 0;
  //SD_inst->SDFlags |= MASK_SD_ENABLE;  /* set enable bit by default */

  /*The energy squelch level is acquired by unmasking some of
  the bits in SDFlags */
  index = (SD_inst->SDFlags & MASK_SQUELCH) >> 8;
  squelch_level = Squelch[index];

  SD_inst->SDstate.SDsettings.Squelch_set = squelch_level; 

  /*
   *Tau distributions initial values.  Tau is is the distance between the mean silent energy (mode 0),
   and the mean speech energy (mode 1).  It is only used in SD_initialize. 
   */
   /*TauStdev is used in SD_initialize to decide when to quit initializing*/
	SD_inst->SDstate.TauMode.TauEnergy.TauStdev = (float)INITL_STOPPING_STDEV; 

	/*Minimum acceptable Tau value used in SD_initialize to decide if silence detection is possible*/
	SD_inst->SDstate.SDsettings.Energy_MinTau 	= (float)INITL_MIN_TAU;

	for (i=0;i<tauHistSize;i++) SD_inst->SDstate.TauMode.TauEnergy.TauHistory[i] = 0.0f;

	/*Mode 0 & 1 distribution initial values.  Mode 0 is the statistical information for silence.
	Mode 1 is the statistical information for speech */ 
	for (i=0;i<histSize;i++)
	{
		SD_inst->SDstate.Mode1Ptr->Energy.History[i] = 0.0f;

		SD_inst->SDstate.Mode0Ptr->Energy.History[i] = 0.0f;
		SD_inst->SDstate.Mode0Ptr->Alpha1.History[i] = 0.0f;
		SD_inst->SDstate.Mode0Ptr->ZC.History[i] 	 = 0.0f;
	}
	/*set initial frame counts*/
	/*initFrameCount is only used to count frames in SD_initialize
	The Mode 0 and Mode 1 counters count continuous runs of 
	silent and non-silent frames, resepctively.  
	They are used in both SD_initialize and the main GSM encoder loop */
	SD_inst->SDstate.initFrameCount = 0;
    SD_inst->SDstate.Mode0Ptr->FrameCount=0;
    SD_inst->SDstate.Mode1Ptr->FrameCount=0;
	
	/*Mode 1 (speech) initial values*/
	SD_inst->SDstate.Mode1Ptr->Energy.Mean 		= squelch_level + 10.0f;
	SD_inst->SDstate.Mode1Ptr->Energy.Stdev 	= 1.0f;

	/*Mode 0 (silence) initial values*/
	SD_inst->SDstate.Mode0Ptr->Energy.Mean 		= squelch_level - 10.0f;
	SD_inst->SDstate.Mode0Ptr->Energy.Stdev 	= 1.0f;

	SD_inst->SDstate.Mode0Ptr->Alpha1.Mean 		= 0.0f;
	SD_inst->SDstate.Mode0Ptr->Alpha1.Stdev 	= 0.0f;

	SD_inst->SDstate.Mode0Ptr->ZC.Mean 			= 0.0f;
	SD_inst->SDstate.Mode0Ptr->ZC.Stdev			= 0.0f;

	/* class = 0 = speech frame = "off"
	/* class = 1 = silent frame = "on"

	/*"On" thresholds used by silence_detect and SD_initialize.
	These values either multiply or are added to the standard
	deviation of each of the three stat types.
	Making these values smaller makes the range of values
	smaller, and thus makes the transition from speech
	frame designation (Class=0) to silent frame designation (Class=1)
	less likely */
	
	SD_inst->SDstate.SDsettings.Energy_on		=INITL_ENERGY_ON;	
	SD_inst->SDstate.SDsettings.ZC_on			=INITL_ZC_ON;
	SD_inst->SDstate.SDsettings.Alpha1_on 		=INITL_ALPHA_ON;

	SD_inst->SDstate.HangCntr = 0;

	/*"Off" thresholds used by silence_detect.
	These values either multiply or are added to the standard
	deviation of each of the three stat types.
	Making these values smaller makes the transition from silent
	frame designation (Class=1) to speech frame designation (Class=0)
	harder, less likely */
	SD_inst->SDstate.SDsettings.Energy_off 		=INITL_ENERGY_OFF;
	SD_inst->SDstate.SDsettings.ZC_off 			=INITL_ZC_OFF;
	SD_inst->SDstate.SDsettings.Alpha1_off 		=INITL_ALPHA_OFF;


	/* Initialize circular buffers for prefiltering operations */
	for(i=0;i<4;i++) SD_inst->SDstate.Filt.nBuffer[i]=0.0f;
  	for(i=0;i<3;i++) SD_inst->SDstate.Filt.dBuffer[i]=0.0f;
  	for(i=0;i<6;i++){
  		SD_inst->SDstate.Filt.denom[i]=0.0f;
  		SD_inst->SDstate.Filt.num[i]=0.0f;
	}

}/*End global initalize SD*/


/***********************************************************************************************/
/************************************************************************************************/
/*******                                  silenceDetect                             ************/
/************************************************************************************************/
/************************************************************************************************/
/*	Mark R. Walker
	Copyright Intel inc., 1995*/

/*	Silence_Detect is executed once per frame if silence detection is enabled.  
	It employs three vocoder parameters (energy, zero crossings, first predictor) 
	to determine if a given frame is speech or background silence.  
	It returns the resulting frame classification. */
/************************************************************************************************/
/************************************************************************************************/
int silenceDetect(INSTNCE *SD_inst, float Energy_tx, float ZC_tx)
{	
	int	histSize, adaptEnable, i, Class;
	float	Alpha1_val, Energy_val, Zc_count;

/* set history sizes based on buffersize, passed in from minifilter shell*/
  histSize = SD_inst->SDstate.SDsettings.HistSize; 
 	
/*
 *	 -------state switch decision criteria -------
 *
 *	Class = 1, frame is silent
 *	Class = 0, frame is non-silent
 */
	adaptEnable = TRUE;

 	Alpha1_val = SD_inst->SDstate.FrameLinPred;
	Energy_val = SD_inst->SDstate.FrameEnergy;
	Zc_count   = SD_inst->SDstate.FrameZCs;

	if (Energy_val <= SD_inst->SDstate.Mode0Ptr->Energy.Mean)
	/* if current frame Energy_val <= mode0 energy mean, this is definitely a silent frame*/
	{
		/* In this case, do no further testing of the frame class */
		SD_inst->SDstate.Class = SILENCE;


		/* If the current frame energy is too low, this frame may be an
			outlier with respect to the silence statistics.  Test and
			do not allow adaptation if this is true.
		*/
		if(Energy_val < (SD_inst->SDstate.Mode0Ptr->Energy.Mean - 2.0*(SD_inst->SDstate.Mode0Ptr->Energy.Stdev))) 
			adaptEnable = FALSE;
	}
	else /* else test the frame class */
	{
		SD_inst->SDstate.Class = classify(Energy_val,Alpha1_val,Zc_count,
			SD_inst->SDstate.Mode0Ptr->Energy.Mean, SD_inst->SDstate.Mode0Ptr->Energy.Stdev,
			SD_inst->SDstate.Mode0Ptr->Alpha1.Mean, SD_inst->SDstate.Mode0Ptr->Alpha1.Stdev,
			SD_inst->SDstate.Mode0Ptr->ZC.Mean, SD_inst->SDstate.Mode0Ptr->ZC.Stdev,
			SD_inst->SDstate.Class, 
			Energy_tx, ZC_tx, SD_inst);
	}  

/*	------- update statistics-------
 *
 *	if frame class is silent, update silence stats only
 */
	if ((SD_inst->SDstate.Class!=SPEECH) && (SD_inst->SDstate.Class!=NONADAPT) && (adaptEnable==TRUE))
	{
/*		------- update history arrays------- 
 */
  		for(i=histSize-1; i>=1; i--)
		{
  			SD_inst->SDstate.Mode0Ptr->Alpha1.History[i] = SD_inst->SDstate.Mode0Ptr->Alpha1.History[i-1];
  			SD_inst->SDstate.Mode0Ptr->Energy.History[i] = SD_inst->SDstate.Mode0Ptr->Energy.History[i-1];
			SD_inst->SDstate.Mode0Ptr->ZC.History[i] 	= SD_inst->SDstate.Mode0Ptr->ZC.History[i-1];
  		}

/*		------- first linear predictor -------
 */
  		SD_inst->SDstate.Mode0Ptr->Alpha1.History[0] = Alpha1_val;
		update(SD_inst->SDstate.Mode0Ptr->Alpha1.History,histSize,
			&(SD_inst->SDstate.Mode0Ptr->Alpha1.Mean),
			&(SD_inst->SDstate.Mode0Ptr->Alpha1.Stdev));

/*		------- energy -------
 */
  		SD_inst->SDstate.Mode0Ptr->Energy.History[0] = Energy_val;
		update(SD_inst->SDstate.Mode0Ptr->Energy.History,histSize,
			&(SD_inst->SDstate.Mode0Ptr->Energy.Mean),
			&(SD_inst->SDstate.Mode0Ptr->Energy.Stdev));

/*		------- zero crossing -------
 */
  		SD_inst->SDstate.Mode0Ptr->ZC.History[0] 	= Zc_count;
		update(SD_inst->SDstate.Mode0Ptr->ZC.History,histSize,
			&(SD_inst->SDstate.Mode0Ptr->ZC.Mean),
			&(SD_inst->SDstate.Mode0Ptr->ZC.Stdev));
	}

if(SD_inst->SDstate.Class == NONADAPT)
	Class = SILENCE;
else Class = SD_inst->SDstate.Class; 
	
return(Class); /*return frame classification*/

} /*end silenceDetect*/

/************************************************************************************************/
/************************************************************************************************/
/*******                                  initializeSD                               ************/
/************************************************************************************************/
/************************************************************************************************/
/*	Mark R. Walker
	Copyright Intel inc., 1995*/

/*	 initializeSD is executed once per frame prior to the enabling of silence detection.
	It employs three vocoder parameters (energy, zero crossings, first predictor) 
		to determine if a given frame is speech or background silence.
	The first part simply fills all of the Mode 0 history arrays and the Mode 1
		energy history arrays with values.  
	The second part of SD_Initialize can take no less than MIN_STARTUP frames, and no more than
		MAX_STARTUP frames.  
	Initalization ends when the standard deviation of the distance between the Mode 0 mean
		(silence) and the Mode 1 mean (speech) drops below STOPPING_STDEV.
	When the second part of the subroutine has completed, two tests are performed before silence
		detection is enabled.  First, the distance between the Mode 0 and Mode 1 energy means must be
		greater than or equal to Energy_MinTau.  Second, the energy "on" threshold must be less
		than the energy squelch level.    */
/************************************************************************************************/
/************************************************************************************************/
/*-------------------------------------------------------------------------------------------------------------------
 */
int initializeSD(INSTNCE *SD_inst)
{
int			SD_enable, i, j;
int			mode1HistSize, mode0HistSize;
int			bufferSize, histSize, tauHistSize, minFrameCount, maxFrameCount;
float	    Energy_tau, squelch_level;
float		Alpha1_val, Energy_val, Zc_count;  
STATS	    TempPtr;


SD_inst->SDstate.initFrameCount++;

Alpha1_val = SD_inst->SDstate.FrameLinPred;
Energy_val = SD_inst->SDstate.FrameEnergy;
Zc_count   = SD_inst->SDstate.FrameZCs;

/* set local values of history size */
bufferSize = SD_inst->SDstate.SDsettings.BufferSize;
histSize = SD_inst->SDstate.SDsettings.HistSize;

/* set local values of min and max frame count */
minFrameCount = SD_inst->SDstate.SDsettings.MinStartupCount;
maxFrameCount = SD_inst->SDstate.SDsettings.MaxStartupCount;  

/*First part of SD_Initialize simply fills the history arrays with values */

if(SD_inst->SDstate.initFrameCount < SD_inst->SDstate.SDsettings.TauHistSize)
{	tauHistSize = SD_inst->SDstate.initFrameCount;
}
else
{	tauHistSize = SD_inst->SDstate.SDsettings.TauHistSize;
}

if (((SD_inst->SDstate.TauMode.TauEnergy.TauStdev > STOPPING_STDEV) || (SD_inst->SDstate.initFrameCount <= minFrameCount)) && (SD_inst->SDstate.initFrameCount <= maxFrameCount))
{
	/*-----Select Energy mode decision--------*/
	if ((Energy_val < SD_inst->SDstate.Mode0Ptr->Energy.Mean) || (fabs(Energy_val - SD_inst->SDstate.Mode0Ptr->Energy.Mean) < (SD_inst->SDstate.SDsettings.Energy_on + SD_inst->SDstate.Mode0Ptr->Energy.Stdev)))
	{ /*Energy mode = Mode0 (silence)*/
		
		/*increment mode zero frame counter*/
		SD_inst->SDstate.Mode0Ptr->FrameCount++;

		if(SD_inst->SDstate.Mode0Ptr->FrameCount < histSize)
		{	mode0HistSize = SD_inst->SDstate.Mode0Ptr->FrameCount;
		}
		else
		{	mode0HistSize = histSize;
		}

		/*update the history arrays*/
		for (i=mode0HistSize-1; i>=1; i--)
		{
  			SD_inst->SDstate.Mode0Ptr->Alpha1.History[i] = SD_inst->SDstate.Mode0Ptr->Alpha1.History[i-1];
			SD_inst->SDstate.Mode0Ptr->Energy.History[i] = SD_inst->SDstate.Mode0Ptr->Energy.History[i-1];
			SD_inst->SDstate.Mode0Ptr->ZC.History[i] 	 = SD_inst->SDstate.Mode0Ptr->ZC.History[i-1];
  		}
  		
  		/*load new frame values into history arrays and update statistics */	
		SD_inst->SDstate.Mode0Ptr->Energy.History[0] = Energy_val;
		update(SD_inst->SDstate.Mode0Ptr->Energy.History,mode0HistSize,&(SD_inst->SDstate.Mode0Ptr->Energy.Mean),&(SD_inst->SDstate.Mode0Ptr->Energy.Stdev));
			
		SD_inst->SDstate.Mode0Ptr->Alpha1.History[0] = Alpha1_val;
		update(SD_inst->SDstate.Mode0Ptr->Alpha1.History,mode0HistSize,&(SD_inst->SDstate.Mode0Ptr->Alpha1.Mean),&(SD_inst->SDstate.Mode0Ptr->Alpha1.Stdev));
			
		SD_inst->SDstate.Mode0Ptr->ZC.History[0] 	= Zc_count;
		update(SD_inst->SDstate.Mode0Ptr->ZC.History,mode0HistSize,&(SD_inst->SDstate.Mode0Ptr->ZC.Mean),&(SD_inst->SDstate.Mode0Ptr->ZC.Stdev));
	}
	else /*Energy mode = 1 (speech) - Update Mode1 energy statistics only*/
	{
		/*increment mode 1 frame counter*/
		SD_inst->SDstate.Mode1Ptr->FrameCount++;

		if(SD_inst->SDstate.Mode1Ptr->FrameCount < histSize)
		{	mode1HistSize = SD_inst->SDstate.Mode1Ptr->FrameCount;
		}
		else
		{	mode1HistSize = histSize;
		}
		/*update the history array*/
		for (i=mode1HistSize-1; i>=1; i--) SD_inst->SDstate.Mode1Ptr->Energy.History[i] = SD_inst->SDstate.Mode1Ptr->Energy.History[i-1];
		/*load new frame values into history arrays and update statistics */	
		SD_inst->SDstate.Mode1Ptr->Energy.History[0]= Energy_val;
		update(SD_inst->SDstate.Mode1Ptr->Energy.History,mode1HistSize,&(SD_inst->SDstate.Mode1Ptr->Energy.Mean),&(SD_inst->SDstate.Mode1Ptr->Energy.Stdev));
	}
	/*  ---------------------- Compute  Tau  -------------------------------- */
 	/* Tau is the difference between the Mode0 and Mode1 mean energy values */
	Energy_tau = (float)fabs(SD_inst->SDstate.Mode0Ptr->Energy.Mean - SD_inst->SDstate.Mode1Ptr->Energy.Mean);
		
	/*	---------------------- Update Tau history -------------------------- */
	for (i=tauHistSize-1; i>=1; i--) SD_inst->SDstate.TauMode.TauEnergy.TauHistory[i] = SD_inst->SDstate.TauMode.TauEnergy.TauHistory[i-1];
  	SD_inst->SDstate.TauMode.TauEnergy.TauHistory[0]= Energy_tau;
	update(SD_inst->SDstate.TauMode.TauEnergy.TauHistory,tauHistSize,&(SD_inst->SDstate.TauMode.TauEnergy.TauMean),&(SD_inst->SDstate.TauMode.TauEnergy.TauStdev));

	/*	Now check the energy means.*/  
	/*	The mode with the lowest mean energy is always set to Mode0 (silence)*/
	if((SD_inst->SDstate.Mode1Ptr->Energy.Mean) < (SD_inst->SDstate.Mode0Ptr->Energy.Mean))
	{
		TempPtr = SD_inst->SDstate.Mode0Ptr->Energy;
		SD_inst->SDstate.Mode0Ptr->Energy = SD_inst->SDstate.Mode1Ptr->Energy;
		SD_inst->SDstate.Mode1Ptr->Energy = TempPtr;
	}
	
	/* We are still initializing - silence detection is disabled */
	SD_enable = FALSE; 

} /* if TauEnergy.TauStdev > STOPPING_STDEV */
else
{
	/* At this point, either Tau stdev has dropped below STOPPING_STDEV, or
	   we have exceeded MAX_STARTUP */ 
	/* Now decide whether silence / sound discrimination is possible */
		
	/* Get the squelch level from the data structure */
	squelch_level = SD_inst->SDstate.SDsettings.Squelch_set;
	
	/* Disable silence detection if TauEnergy.TauMean is less than Energy_MinTau */
	/* Disable also if we have never seen a silent frame (Mode0) */
	/* Disable also if the difference between the silence energy mean and the squelch level */
	/*	is less than the "Energy_on" threshold */
	if(
		( SD_inst->SDstate.TauMode.TauEnergy.TauMean < SD_inst->SDstate.SDsettings.Energy_MinTau) ||
		( SD_inst->SDstate.Mode0Ptr->FrameCount	== 0) ||
		( SD_inst->SDstate.Mode1Ptr->Energy.Mean == squelch_level + 10) ||//This is the initial value
		( fabs((SD_inst->SDstate.Mode0Ptr->Energy.Mean) - squelch_level) 
			< (SD_inst->SDstate.SDsettings.Energy_on * SD_inst->SDstate.Mode0Ptr->Energy.Stdev)) 
	)   
	{
		SD_enable = FALSE;
	}
	else
	{ 
		SD_enable = TRUE;
	}

	/* If the Mode0 history arrays are not filled - fill them out by repeating the last value */
	if((SD_inst->SDstate.Mode0Ptr->FrameCount !=0) && (SD_inst->SDstate.Mode0Ptr->FrameCount < histSize))
	{
		j=SD_inst->SDstate.Mode0Ptr->FrameCount;
		for(i=j; i<histSize; i++) SD_inst->SDstate.Mode0Ptr->Energy.History[i] = SD_inst->SDstate.Mode0Ptr->Energy.History[j-1];
		for(i=j; i<histSize; i++) SD_inst->SDstate.Mode0Ptr->Alpha1.History[i] = SD_inst->SDstate.Mode0Ptr->Alpha1.History[j-1];
		for(i=j; i<histSize; i++) SD_inst->SDstate.Mode0Ptr->ZC.History[i]     = SD_inst->SDstate.Mode0Ptr->ZC.History[j-1];
		SD_inst->SDstate.Mode0Ptr->Energy.Stdev = (float)INITL_STDEV;
	}
		
	/* Set all frame counters = 0 */
	/* If SD initialization has failed, we are going to start over anyway */
	SD_inst->SDstate.initFrameCount=0;
	SD_inst->SDstate.Mode0Ptr->FrameCount=0;
	SD_inst->SDstate.Mode1Ptr->FrameCount=0;
 
} /*end if TauEnergy.TauStdev > STOPPING_STDEV */

return(SD_enable);

} /* end initializeSD */
/************************************************************************************************/
/************************************************************************************************/
/*******                                     classify                                ************/
/************************************************************************************************/
/************************************************************************************************/
/*	Mark R. Walker
	Copyright Intel inc., 1995
	
	classify is called by Silence_Detect.  */
/************************************************************************************************/
/************************************************************************************************/

 int classify(float Energy_val,float Alpha1_val,float Zc_count,
		float energy_mean,float energy_stdev,float alpha1_mean,
		float alpha1_stdev,float ZC_mean,float ZC_stdev,int s, 
		float Energy_tx, float ZC_tx, INSTNCE *SD_inst)
{
float 	C1, C2, C3, C4, C5, C6, C7, C8, C9, C10, C11;
int		Class;

/*	If all decision criteria below do not apply,
	just set current frame type to previous frame type */
Class = s;

C1 = (float)fabs(Energy_val - energy_mean);
C3 = (float)fabs(ZC_mean - Zc_count);
C5 = (float)fabs(alpha1_mean - Alpha1_val);

/* Note - Energy "on" threshold is unlike alpha and zero crossing */
C2 = SD_inst->SDstate.SDsettings.Energy_on + energy_stdev;
C10=							 Energy_tx + energy_stdev;

C4 = SD_inst->SDstate.SDsettings.ZC_on * ZC_stdev;
C11=							 ZC_tx * ZC_stdev;

C6 = SD_inst->SDstate.SDsettings.Alpha1_on * alpha1_stdev;

/* Note - Energy "off" threshold is unlike alpha and zero crossing */
C7 = SD_inst->SDstate.SDsettings.Energy_off + energy_stdev;
C8 = SD_inst->SDstate.SDsettings.ZC_off * ZC_stdev;
C9 = SD_inst->SDstate.SDsettings.Alpha1_off * alpha1_stdev;


if (s==SILENCE || s==NONADAPT) /* "Off" settings */
{
	/* Energy criteria for coded-frame designation.
	 * If energy indicator is above threshold, immediately
	 * switch from silent mode to coded frame mode. Do no additional tests
	 */
	if (C1 > C10)
	{ 
		Class = SPEECH;
	}
	/* Zero-crossing criteria for coded-frame designation.
	 * If ZC indicator is high, allow switch to coded
	 * frame mode only if alpha1 indicator is also high.
	 */
	else 
		if (C1 > C2)
		{ 
			Class = NONADAPT;
		}
		else 
			if ((C3 > C11) && (C5 > C6))
			{
				Class = SPEECH;
			}
			else 
				if ((C3 > C4)  && (C5 > C6))
				{
					Class = NONADAPT;
				}
}/* "On settings */

/* Only allow transition from coded to silent frame mode only if 
 * all three statistics are below threshold.
 */
else 
	if  ((C5 < C9) && (C1 < C7) && (C3 < C8))
	{
		Class = SILENCE;
	}

return(Class);

} /*end classify*/
/************************************************************************************************/
/************************************************************************************************/
/*******                                     update                                  ************/
/************************************************************************************************/
/************************************************************************************************/
/*	Mark R. Walker
	Copyright Intel inc., 1995*/
/************************************************************************************************/
/************************************************************************************************/
void update(float *hist_array,int hist_size,float *mean,float *stdev)
{
/*subroutine update
 *Mark Walker
 *
 *	inputs:		hist_array, hist_size
 *	outputs:	mean, stdev
 */
	float	sum, inv_size;
	int		i;

	sum = 0.0f;

	inv_size = 1.0f / ((float)hist_size);

	for (i=0; i<hist_size; i++) sum += hist_array[i];

	*mean = sum * inv_size;

	sum = 0.0f;

	for (i=0; i<hist_size; i++) sum += (float)fabs(hist_array[i] - (*mean));
  
	*stdev = sum * inv_size;

} /*end update*/



//compute the zero crossing for an array of floats
//the floats are treated as signed ints (32 bit)
//the sign bits are extracted and adjacent ones xored
//the xored values are accumulated in the result

int zeroCross(float x[], int n)
{
  int sgn0, sgn1;
  int zc = 0;
  int i = 0;

  sgn1 = ((int *)x)[0] >> 31; //initialize
  for (i = 0; i < n-1; i += 2)
  {
    sgn0 = ((int *)x)[i] >> 31;
    zc += sgn0 ^ sgn1;
    sgn1 = ((int *)x)[i+1] >> 31;
    zc += sgn0 ^ sgn1;
  }
  
  if (i == n-1) //odd case?
  {
    sgn0 = ((int *)x)[i] >> 31;
    zc += sgn0 ^ sgn1;
  }

  return -zc;
}

void prefilter(INSTNCE *SD_inst, float *sbuf, float *fbuf, int buffersize)
{
  float  *nBuffer, *dBuffer,*denom, *num;
  float  x,recip;
  int i;

  nBuffer = SD_inst->SDstate.Filt.nBuffer;
  dBuffer = SD_inst->SDstate.Filt.dBuffer;
  denom = SD_inst->SDstate.Filt.denom;
  num = SD_inst->SDstate.Filt.num;

  recip = (float)(1.0/MAX_SAMPLE);

  for (i=0; i<buffersize; i++)
  {
  	nBuffer[0] = nBuffer[1];
  	nBuffer[1] = nBuffer[2];
  	nBuffer[2] = nBuffer[3];
  	nBuffer[3] = sbuf[i]*recip;

  x = 	nBuffer[0]*HhpNumer[3] + 
  		nBuffer[1]*HhpNumer[2] + 
  		nBuffer[2]*HhpNumer[1] + 
  		nBuffer[3]*HhpNumer[0] +
  		dBuffer[0]*HhpDenom[2] + 
  		dBuffer[1]*HhpDenom[1] + 
  		dBuffer[2]*HhpDenom[0];

  dBuffer[0] = dBuffer[1];
  dBuffer[1] = dBuffer[2];
  dBuffer[2] = x;

/* a low pass filter to cut off input speech frequency contents
   beyond 3.5 kHz */

   //Update FIR memory
   	num[5] = num[4];
   	num[4] = num[3];
	num[3] = num[2];
	num[2] = num[1];
	num[1] = num[0];
	num[0] = x;
   
	x = num[0]*B[0] + 
		num[1]*B[1] + 
		num[2]*B[2] + 
		num[3]*B[3] + 
		num[4]*B[4] + 
		num[5]*B[5] +
		denom[0]*A[1] + 
		denom[1]*A[2] + 
		denom[2]*A[3] + 
		denom[3]*A[4] + 
		denom[4]*A[5];

	//Update IIR memory
	denom[4] = denom[3];
	denom[3] = denom[2];
	denom[2] = denom[1];
	denom[1] = denom[0];
	denom[0] = x;

   fbuf[i] = x;
  }

  return;

}

void execSDloop(INSTNCE *SD_inst, int *frameType, float sliderInput)
{ 
	float 	squelch, e0mean, e0stdev, e_on;
	float   Energy_tx, ZC_tx;
	int		m1count, maxcount, hangtime;
		
	//Slider input 
	    if(sliderInput > SLIDER_MAX) 
	    	sliderInput = SLIDER_MAX;
		else if(sliderInput < SLIDER_MIN) 
			sliderInput = SLIDER_MIN;   

		Energy_tx = INITL_ENERGY_ON + sliderInput;
		ZC_tx	  = INITL_ZC_ON     + ZC_SLOPE * sliderInput;
		hangtime  = INITL_HANGTIME  + (int)(HANG_SLOPE * sliderInput); 

    	if ( ! SD_inst->SDstate.SD_enable) //run the initializer until SD_enable is set
    	{
       		SD_inst->SDstate.SD_enable = initializeSD(SD_inst);
			*frameType = SPEECH;
			SD_inst->SDstate.Class = SPEECH;
    	} 
    	else if (SD_inst->SDstate.SD_enable ) 
    	{
      		*frameType = silenceDetect(SD_inst,Energy_tx,ZC_tx);

   	  		if(*frameType == SILENCE) 
   	  		{
				if(	   (SD_inst->SDstate.Mode0Ptr->FrameCount==0) 
					&& (SD_inst->SDstate.Mode1Ptr->FrameCount>MIN_SPEECH_INTERVAL)
					&& (SD_inst->SDstate.HangCntr != 0) )
				{
					SD_inst->SDstate.HangCntr--;
					*frameType = SPEECH;	//force this frame to be coded
				}
				else if (SD_inst->SDstate.HangCntr == hangtime  || SD_inst->SDstate.HangCntr == 0)
				{	
					SD_inst->SDstate.Mode0Ptr->FrameCount++;
			   		SD_inst->SDstate.Mode1Ptr->FrameCount=0;
			   		SD_inst->SDstate.HangCntr = hangtime;
				}
   	  		}
   	  		else
   	  		{
				if(SD_inst->SDstate.HangCntr != hangtime)
					SD_inst->SDstate.Mode1Ptr->FrameCount=0;

   	  			SD_inst->SDstate.Mode1Ptr->FrameCount++;
   				SD_inst->SDstate.Mode0Ptr->FrameCount=0;
				SD_inst->SDstate.HangCntr = hangtime;
   	  		}
   	  		/* 
   	  		If the adaptive threshold for switching from silence to coded frame ("Off") 
   	  		has risen above the squelch level, re-initialization will occur on the next frame.
   	  		Re-initialization will also occur when the Mode1FrameCount (continuous non-silent frame count)
   	    	exceeds 4 seconds. 
   	    	*/
      		squelch	= SD_inst->SDstate.SDsettings.Squelch_set;
	  		e0mean 	= SD_inst->SDstate.Mode0Ptr->Energy.Mean;
	  		e0stdev	= SD_inst->SDstate.Mode0Ptr->Energy.Stdev; 
	  		e_on	= SD_inst->SDstate.SDsettings.Energy_on;
	  		m1count	= SD_inst->SDstate.Mode1Ptr->FrameCount;
	  		maxcount= SD_inst->SDstate.SDsettings.MaxSpeechFrameCount;  

      		if ((fabs(e0mean - squelch) < (e_on + e0stdev)) || (m1count >= maxcount))
         	{	/* reinitialization will occur on next frame - reset global values now */
          		SD_inst->SDstate.SD_enable = FALSE;
          		SD_inst->SDstate.Mode0Ptr->FrameCount=0;
   		  		SD_inst->SDstate.Mode1Ptr->FrameCount=0;
   		  		SD_inst->SDstate.Mode0Ptr->Energy.Mean = squelch;
   		  		SD_inst->SDstate.Mode0Ptr->Energy.Stdev = (float) INITL_STDEV;
				SD_inst->SDstate.HangCntr = hangtime;
				*frameType = SPEECH;
         	}
      	}//end if SD_enable
		return;
}

float DotProdSD(float *in1, float *in2, int len)
{
  int i;
  float sum;

  sum = (float)0.0;
  for (i=0; i<len; i++)
    sum += in1[i]*in2[i];

  return(sum);
}

 __inline unsigned randBit()
{
    volatile static unsigned seed = 1;
    unsigned bit, temp;

    temp = seed;
    bit = 1 & ((temp) ^ (temp >> 2) ^ (temp >> 31));
    seed = (temp << 1) | bit;

	return( bit );
}

 extern __inline unsigned short getRand()
{
  return (short)(randBit() + (randBit()<<1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\sdstruct.h ===
/**********************************************************************/
/**********************************************************************/
/*********       Global constants used by silence detector      *******/
/**********************************************************************/
/**********************************************************************/

//BUFERSIZE is the size, in samples, of the speech encoder input buffer.
//This should be set to the same value as MYCODEC_BUFFER_SAMPS in mycodec.h 

#define BUFFERSIZE 	240

//HIST_TIME is the time period, in seconds, represented by the number of past values of SD
//	parameters kept in memory.  HIST_SIZE is the size of the history arrys and is set so 
//	that the size of the history arrays correspond to HIST_TIME seconds of stored SD parameters. 

#define HIST_TIME 	1.0
#define HIST_SIZE 	(int)(HIST_TIME*8000/BUFFERSIZE)

//ENERGY_TAU_HIST_TIME is the time period, in seconds, represented by the number of past 
// values of energy tau kept in memory.  Energy tau is used only by the SD initializer.

#define ENERGY_TAU_HIST_TIME  1.5
#define	ENERGY_TAU_HIST_SIZE  (int)(ENERGY_TAU_HIST_TIME*8000/BUFFERSIZE)

#define OFFSET					10
#define MAX_SAMPLE				32768.0

#define MASK_SILENCE_MARKED		0x01
#define MASK_EARLY_EXIT			0x02
#define MASK_SILENCE_CODED		0x04

#define MASK_SQUELCH			0xF00

//The following times (in seconds) are used by initializeSD to 
//	decide when to stop initializing.
//Initialization is not allowed to complete before the end of
//  MIN_STARTUP_TIME, in seconds.
//If initialization fails before the end of MAX_STARTUP_TIME,
//  silence detection is disabled
#define MIN_STARTUP_TIME		2
#define MAX_STARTUP_TIME		20

#define STOPPING_STDEV			3.0
#define INITL_STOPPING_STDEV	10.0
#define INITL_MIN_TAU			20.0

#define INITL_STDEV				2.0

//MAX_SPEECH_TIME time is the amount of time in seconds that the silence "off"
//  mode (no silent frames detected) is allowed to continue before
//  reinitialization is automatically invoked.
#define MAX_SPEECH_TIME			4.0

//SD_MIN_BUFFERSIZE is the smallest possible input buffersize
//	in bytes for silence detection (20 samples)  
#define SD_MIN_BUFFERSIZE		40

//Initial threshold settings
#define SLIDER_MAX				100.0f
#define SLIDER_MIN				0.0f

#define INITL_HANGTIME			0
#define MIN_SPEECH_INTERVAL		6
#define HANG_SLOPE				6.0f/14.0f

#define INITL_ENERGY_ON			3.8f
#define INITL_ENERGY_TX			INITL_ENERGY_ON

#define INITL_ZC_ON				2.0f
#define INITL_ZC_TX				INITL_ZC_ON
#define ZC_SLOPE				0.045f

#define INITL_ALPHA_ON			2.0f

#define INITL_ENERGY_OFF		2.8f

#define INITL_ZC_OFF			INITL_ZC_ON

#define INITL_ALPHA_OFF			INITL_ALPHA_ON
 
#define FALSE		0
#define TRUE		1

#define SPEECH		0
#define SILENCE		1
#define NONADAPT	3

/**********************************************************************/
/**********************************************************************/
/*********   Data structure for silence detector and prefilters *******/
/**********************************************************************/
/**********************************************************************/

typedef struct {

	float Mean;
	float Stdev;
	float History[HIST_SIZE];

} STATS;

typedef struct {

	STATS Energy;
	STATS Alpha1;
	STATS ZC;
	int   FrameCount;
	
} MODE0;

typedef struct {

	STATS Energy;
	int   FrameCount;
	
} MODE1;

typedef struct {

	float TauMean;
	float TauStdev;
	float TauHistory[ENERGY_TAU_HIST_SIZE];

} TAU_STATS;

typedef struct {

	TAU_STATS TauEnergy;
	TAU_STATS TauAlpha1;
	TAU_STATS TauZC;
	
} TAU_MODE;

typedef struct {

/*The following parameters are used to set thresholds for
 *	changing from silence to speechmode designation in Silence_Detect.  
 *	These are factors which are used to multiply the standard deviation of
 *	the energy, alpha1, & zero crossing, respectively.
 */
	float Energy_on;
	float ZC_on;
	float Alpha1_on;

	float Energy_tx;
	float ZC_tx;

/*The following parameters are used to set thresholds for
 *	changing from speech to silent mode designation in Silence_Detect.  
 *These are factors which are used to multiply the standard deviation of
 *	the energy & zero crossing, respectively.
 */
	float Energy_off;
	float ZC_off;
	float Alpha1_off;

/* Tau is the distance between the Mode0 (silence) and the Mode1 (speech) energy means.
	If the distance between mode 0 and mode 1 energy means is less than MIN_TAU, 
 	silence detection is impossible.  
 */
	float Energy_MinTau;

/* Energy squelch level */
	
	float Squelch_set;

	int   BufferSize;
	int   HistSize;
	int   TauHistSize;

	int	  MinStartupCount;
	int   MaxStartupCount;

	int	  MaxSpeechFrameCount;

} SETTINGS;

typedef struct {

	float nBuffer[4];
	float dBuffer[3];
	float denom[6];
	float num[6];
	float sbuff[BUFFERSIZE];
	float storebuff[BUFFERSIZE];

} FILTERS;

typedef struct {

  MODE0 Mode0;
  MODE1 Mode1;

  MODE0 *Mode0Ptr;
  MODE1 *Mode1Ptr;

  TAU_MODE TauMode; 
  
  int  	initFrameCount;
  int	Class;
  int	SD_enable;

  float	FrameEnergy;
  float	FrameLinPred;
  float	FrameZCs;

  SETTINGS SDsettings;

  FILTERS Filt;

  int	HangCntr;

} SD_STATE_VALS;

typedef struct {
  
  long SDFlags;

  //COMFORT_PARMS ComfortParms;

  SD_STATE_VALS SDstate;

} INSTNCE, *SD_INST;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\tabl_ns.c ===
//No CRC codes
// PhilF: Remove the three following arrays since the SID
// code does not know how to make a good use of them today.
#if 0
extern const unsigned r63Noise[6*4]={
 	
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,

	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,

	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,

	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000
 } ;

//padded with ABABABAB
extern const unsigned r53Noise[6*4] = {
 	
	0x00000001,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0xABABABAB,

	0x00000001,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0xABABABAB,

	0x00000001,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0xABABABAB,

	0x00000001,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0xABABABAB,
		   
 } ;

extern const unsigned SIDFrame[1] = { 0x00000002 };
#endif

 const float Squelch[16] = {70.0f, /* default */
 10.0f, 20.0f, 30.0f, 40.0f, 50.0f, 60.0f, 70.0f, 80.0f,
 90.0f, 100.0f, 110.0f, 120.0f, 130.0f, 140.0f, 150.0f};
 
const float A[6] = 
	{1.0f,
	-2.554910873842f,
	-3.054788425308f,
	-1.813794458661f,
	-0.521075856868f,
	0.0055927932689f};

const float B[6] = 
	{0.290838380294f,
	1.407780344969f,
	2.770702115733f,
	2.770702115733f,
	1.407780344969f,
	0.290838380294f};

const float HhpNumer[4]={
        0.959696f, -2.879088f, 2.879088f, -0.959696f};

const float HhpDenom[3]={
        2.918062872f, -2.838800222f, 0.9207012679f};	 

const float Binomial80[] = {
	1.000000f, 
	0.999644f, 0.998577f, 0.996802f, 0.994321f, 0.991141f, 
	0.987268f, 0.982710f, 0.977478f, 0.971581f, 0.965032f
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\sdstuff.h ===
int  	initializeSD(INSTNCE *SD_inst);
 int 	silenceDetect(INSTNCE *SD_inst, float Energy_tx, float ZC_tx);
 void 	glblSDinitialize(INSTNCE *SD_inst);
 int 	classify(float Energy_val,float Alpha1val,float Zc_count,
			float energymean,float energystdev,float alpha1_mean,
			float alpha1stdev,float ZC_mean,float ZC_stdev,int s, 
			float Energy_tx, float ZC_tx, INSTNCE *SD_inst);
 void 	update(float *histarray,int histsize,float *mean,float *stdev);
 int 	zeroCross(float x[], int n);
#if PLOTFILE
	void getParams(INSTNCE *SD_inst, float *storebuff, int currBuffSize, float *p1, float *p2, float *p3);
#else
	void getParams(INSTNCE *SD_inst, float *storebuff, int currBuffSize);
#endif

 void 	prefilter(INSTNCE *SD_inst, float *sbuf, float *fbuf, int buffersize);
 void	execSDloop(INSTNCE *SD_inst, int *isFrameSilent, float bigthreshold);
 float  DotProdSD(float *in1, float *in2, int len);

 extern __inline unsigned short getRand(); 
 __inline unsigned randBit();



 
/* End SDSTUFF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\typedef.h ===
//  typedef.h

/*	Original fixed-point code copyright (c) 1995,
    AudioCodes, DSP Group, France Telecom, Universite de Sherbrooke.
    All rights reserved.

    Floating-point code copyright (c) 1995,
    Intel Corporation and France Telecom (CNET).
    All rights reserved.
*/

/*
   Types definitions
*/
#if defined(__BORLANDC__) || defined (__WATCOMC__) || defined(_MSC_VER) || defined(__ZTC__)	|| defined(__HIGHC__)
typedef  long  int   Word32   ;
typedef  short int   Word16   ;
typedef  short int   Flag  ;
#define TST_COMPIL
#endif
#ifdef __sun
typedef short  Word16;
typedef long  Word32;
typedef int   Flag;
#define TST_COMPIL
#endif
#ifdef __unix__
typedef short Word16;
typedef int   Word32;
typedef int   Flag;
#define TST_COMPIL
#endif
#ifndef TST_COMPIL
#error  COMPILER NOT TESTED typedef.h needs to be updated, see readme
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\timer.h ===
//timer.h
#if TIMEIT	

  #if !defined(TIMEIT_STAMP) || TIMEIT_STAMP
    #define TimeStamp(n) TimerStamp(n) //for hands on types
    #define TIMER_STAMP(symb) {\
      extern const int TimerSymb ## symb ## Stamp; \
      extern const int TimerSymb ## TimerOverhead ## Stamp; \
	  TimerStamp(TimerSymb ## symb ## Stamp);\
	  TimerStamp(TimerSymb ## TimerOverhead ## Stamp);\
	  }

    void TimerStamp(int n);
  #else
    #define TIMER_STAMP(s) 
  #endif //TIMEIT_STAMP

  #if !defined(TIMEIT_SPOT) || TIMEIT_SPOT
    #define TIMER_SPOT_ON(symb) {\
      extern const int TimerSymb ## symb ## Spot; \
	  TimerSpotOn(TimerSymb ## symb ## Spot);\
	  }
    #define TIMER_SPOT_OFF(symb) {\
      extern const int TimerSymb ## symb ## Spot; \
	  TimerSpotOff(TimerSymb ## symb ## Spot);\
	  }

    void TimerSpotOn(int n);
    void TimerSpotOff(int n);
  #else
    #define TIMER_SPOT_ON(s)
    #define TIMER_SPOT_OFF(s)
  #endif //TIMEIT_SPOT

  #define TIMER_INITIALIZE TimerInitialize()
  #define TIMER_ON TimerBegin()
  #define TIMER_OFF TimerEnd()
  #define TIMER_REPORT(unitString, scale) TimerReport((unitString), (double)(scale), 1.)

  void TimerInitialize(void);
  void TimerBegin(void);
  void TimerEnd(void);
  void TimerReport(const char *unitName, double scaleSum, double scaleRatio);

#else
  #define TimeStamp(n)
  #define TIMER_INITIALIZE 
  #define TIMER_STAMP(s) 
  #define TIMER_SPOT_ON(s) 
  #define TIMER_SPOT_OFF(s) 
  #define TIMER_ON
  #define TIMER_OFF
  #define TIMER_REPORT(u,s)
#endif //TIMEIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\tab_lbc.c ===
#include "typedef.h"
#include "cst_lbc.h"
#include "tab_lbc.h"

#define 	FLOAT float
#define    	F 	float


/*
**
**
** Description: Tables used for G.723 encoding and decoding
**  
** Tables:      HammingWindowTable[180]
**
**              LPC Computation and Filtering
**
**                  BinomialWindowTable[10]
**                  BandExpTable[10]
**
**              LSP calculation and quantization
**
**                  CosineTable[512]
**                  LspDcTable[10]
**                  BandInfoTable[3][2]
**                  Band0Tb8[256*3]
**                  Band1Tb8[256*3]
**                  Band2Tb8[256*4]
**                  BandQntTable[3]
**
**              Perceptual Filtering and Post Filtering
**
**
**                  PerFiltZeroTable[10]
**                  PerFiltPoleTable[10]
**                  PostFiltZeroTable[10]
**                  PostFiltPoleTable[10]
**                  LpfConstTable[2] (pitch postfilter)
**
**              ACELP or MP-MLQ
**
**                  Nb_puls[4] (MP-MLQ)
**                  FcbkGainTable[24] (ACELP and MP-MLQ)
**                  MaxPosTable[4]  (MP-MLQ), Word32
**                  CombinatorialTable[6][30](MP-MLQ),Word32
**                  epsi170[170] (ACELP)
**                  gain170[170] (ACELP)
**
**              Pitch Prediction
**
**                  AcbkGainTable085[85*20]
**                  AcbkGainTable170[170*20]
**                  AcbkGainTablePtr[2]
**
**              Taming procedure
**
**                  tabgain170[170]
**                  tabgain85[85]
**
**              All tables are Word16 unless separately denoted
*/

/*
**  HammingWindowTable:
**
**  Hamming Window coefficients.
**
*/


int minus1mod10[LpcOrder] = {9,0,1,2,3,4,5,6,7,8};


FLOAT   HammingWindowTable[LpcFrame] = {
  (F)0.080000,
  (F)0.080283,
  (F)0.081133,
  (F)0.082548,
  (F)0.084527,
  (F)0.087067,
  (F)0.090164,
  (F)0.093816,
  (F)0.098018,
  (F)0.102764,
  (F)0.108049,
  (F)0.113866,
  (F)0.120208,
  (F)0.127067,
  (F)0.134435,
  (F)0.142303,
  (F)0.150660,
  (F)0.159498,
  (F)0.168804,
  (F)0.178567,
  (F)0.188775,
  (F)0.199417,
  (F)0.210478,
  (F)0.221944,
  (F)0.233803,
  (F)0.246039,
  (F)0.258637,
  (F)0.271582,
  (F)0.284857,
  (F)0.298447,
  (F)0.312335,
  (F)0.326502,
  (F)0.340933,
  (F)0.355609,
  (F)0.370513,
  (F)0.385625,
  (F)0.400927,
  (F)0.416401,
  (F)0.432026,
  (F)0.447785,
  (F)0.463658,
  (F)0.479624,
  (F)0.495665,
  (F)0.511761,
  (F)0.527891,
  (F)0.544037,
  (F)0.560177,
  (F)0.576292,
  (F)0.592363,
  (F)0.608369,
  (F)0.624291,
  (F)0.640109,
  (F)0.655804,
  (F)0.671356,
  (F)0.686747,
  (F)0.701956,
  (F)0.716966,
  (F)0.731758,
  (F)0.746314,
  (F)0.760616,
  (F)0.774645,
  (F)0.788386,
  (F)0.801821,
  (F)0.814933,
  (F)0.827706,
  (F)0.840125,
  (F)0.852174,
  (F)0.863839,
  (F)0.875104,
  (F)0.885957,
  (F)0.896384,
  (F)0.906371,
  (F)0.915907,
  (F)0.924980,
  (F)0.933579,
  (F)0.941693,
  (F)0.949312,
  (F)0.956426,
  (F)0.963028,
  (F)0.969109,
  (F)0.974660,
  (F)0.979677,
  (F)0.984151,
  (F)0.988079,
  (F)0.991454,
  (F)0.994273,
  (F)0.996533,
  (F)0.998230,
  (F)0.999363,
  (F)0.999929,
  (F)0.999929,
  (F)0.999363,
  (F)0.998230,
  (F)0.996533,
  (F)0.994273,
  (F)0.991454,
  (F)0.988079,
  (F)0.984151,
  (F)0.979677,
  (F)0.974660,
  (F)0.969109,
  (F)0.963028,
  (F)0.956427,
  (F)0.949312,
  (F)0.941693,
  (F)0.933579,
  (F)0.924980,
  (F)0.915907,
  (F)0.906371,
  (F)0.896384,
  (F)0.885957,
  (F)0.875104,
  (F)0.863839,
  (F)0.852174,
  (F)0.840125,
  (F)0.827706,
  (F)0.814933,
  (F)0.801821,
  (F)0.788386,
  (F)0.774645,
  (F)0.760616,
  (F)0.746314,
  (F)0.731758,
  (F)0.716966,
  (F)0.701956,
  (F)0.686747,
  (F)0.671356,
  (F)0.655804,
  (F)0.640110,
  (F)0.624291,
  (F)0.608369,
  (F)0.592363,
  (F)0.576292,
  (F)0.560177,
  (F)0.544037,
  (F)0.527891,
  (F)0.511761,
  (F)0.495665,
  (F)0.479624,
  (F)0.463658,
  (F)0.447785,
  (F)0.432027,
  (F)0.416401,
  (F)0.400927,
  (F)0.385625,
  (F)0.370513,
  (F)0.355609,
  (F)0.340933,
  (F)0.326502,
  (F)0.312335,
  (F)0.298447,
  (F)0.284857,
  (F)0.271582,
  (F)0.258637,
  (F)0.246039,
  (F)0.233803,
  (F)0.221945,
  (F)0.210478,
  (F)0.199417,
  (F)0.188775,
  (F)0.178567,
  (F)0.168804,
  (F)0.159498,
  (F)0.150660,
  (F)0.142303,
  (F)0.134435,
  (F)0.127067,
  (F)0.120208,
  (F)0.113866,
  (F)0.108049,
  (F)0.102764,
  (F)0.098018,
  (F)0.093816,
  (F)0.090164,
  (F)0.087067,
  (F)0.084527,
  (F)0.082548,
  (F)0.081133,
  (F)0.080283,
  (F)0.080000 
 } ;


/*
**  BinomialWindowTable:
**
**  Purpose:
**     Binomial Window coefficients used to weight the autocorrelation before
**     Levinson-Durbin in the LPC coefficient calculation.  
**
**
*/

FLOAT BinomialWindowTable[LpcOrder+1] = {
  (F)1.0,
  (F)0.999443,
  (F)0.997775,
  (F)0.995002,
  (F)0.991132,
  (F)0.986178,
  (F)0.980157,
  (F)0.973088,
  (F)0.964995,
  (F)0.955905,
  (F)0.945847 
  } ;

/*
**  BandExpTable:
**
**  Purpose:
**      Do bandwidth expansion on the LPC coefficients by scaling the
**      poles of the LPC synthesis filter by a factor of 0.994

**
**  Table Structure:
**      Table values correspond to (0.994) to the power of x,
**      where x = [0,..,10].
**
*/

FLOAT BandExpTable[LpcOrder] = {
  (F)0.994 ,
  (F)0.988036 ,
  (F)0.9821078 ,
  (F)0.9762151 ,
  (F)0.9703578 ,
  (F)0.9645357 ,
  (F)0.9587485 ,
  (F)0.9529960 ,
  (F)0.9472780 ,
  (F)0.9415944 ,
};



/*
**  CosineTable:
**
**  Purpose:
**      Used to evaluate polynomial for LSP-LPC conversion
**
**  Table Structure:
**      Contains one period of a cosine wave.
**
*/

FLOAT CosineTable[CosineTableSize] = {
   (F)1 ,
   (F)0.999939 ,
   (F)0.999695 ,
   (F)0.999329 ,
   (F)0.998779 ,
   (F)0.998108 ,
   (F)0.997314 ,
   (F)0.996338 ,
   (F)0.995178 ,
   (F)0.993896 ,
   (F)0.992493 ,
   (F)0.990906 ,
   (F)0.989197 ,
   (F)0.987305 ,
   (F)0.985291 ,
   (F)0.983093 ,
   (F)0.980774 ,
   (F)0.978333 ,
   (F)0.975708 ,
   (F)0.972961 ,
   (F)0.970032 ,
   (F)0.96698 ,
   (F)0.963806 ,
   (F)0.960449 ,
   (F)0.95697 ,
   (F)0.953308 ,
   (F)0.949524 ,
   (F)0.945618 ,
   (F)0.941528 ,
   (F)0.937317 ,
   (F)0.932983 ,
   (F)0.928528 ,
   (F)0.923889 ,
   (F)0.919128 ,
   (F)0.914185 ,
   (F)0.90918 ,
   (F)0.903992 ,
   (F)0.898682 ,
   (F)0.89325 ,
   (F)0.887634 ,
   (F)0.881897 ,
   (F)0.876099 ,
   (F)0.870117 ,
   (F)0.863953 ,
   (F)0.857727 ,
   (F)0.851379 ,
   (F)0.844849 ,
   (F)0.838196 ,
   (F)0.831482 ,
   (F)0.824585 ,
   (F)0.817566 ,
   (F)0.810486 ,
   (F)0.803223 ,
   (F)0.795837 ,
   (F)0.78833 ,
   (F)0.780762 ,
   (F)0.77301 ,
   (F)0.765198 ,
   (F)0.757202 ,
   (F)0.749146 ,
   (F)0.740967 ,
   (F)0.732666 ,
   (F)0.724243 ,
   (F)0.715759 ,
   (F)0.707092 ,
   (F)0.698364 ,
   (F)0.689514 ,
   (F)0.680603 ,
   (F)0.67157 ,
   (F)0.662415 ,
   (F)0.653198 ,
   (F)0.64386 ,
   (F)0.634399 ,
   (F)0.624878 ,
   (F)0.615234 ,
   (F)0.60553 ,
   (F)0.595703 ,
   (F)0.585815 ,
   (F)0.575806 ,
   (F)0.565735 ,
   (F)0.555542 ,
   (F)0.545349 ,
   (F)0.534973 ,
   (F)0.524597 ,
   (F)0.514099 ,
   (F)0.50354 ,
   (F)0.49292 ,
   (F)0.482178 ,
   (F)0.471375 ,
   (F)0.46051 ,
   (F)0.449585 ,
   (F)0.438599 ,
   (F)0.427551 ,
   (F)0.416443 ,
   (F)0.405212 ,
   (F)0.393982 ,
   (F)0.38269 ,
   (F)0.371338 ,
   (F)0.359924 ,
   (F)0.348389 ,
   (F)0.336914 ,
   (F)0.325317 ,
   (F)0.31366 ,
   (F)0.302002 ,
   (F)0.290283 ,
   (F)0.278503 ,
   (F)0.266724 ,
   (F)0.254883 ,
   (F)0.242981 ,
   (F)0.231079 ,
   (F)0.219116 ,
   (F)0.207092 ,
   (F)0.195068 ,
   (F)0.183044 ,
   (F)0.170959 ,
   (F)0.158875 ,
   (F)0.146729 ,
   (F)0.134583 ,
   (F)0.122437 ,
   (F)0.110229 ,
   (F)0.0980225 ,
   (F)0.0858154 ,
   (F)0.0735474 ,
   (F)0.0613403 ,
   (F)0.0490723 ,
   (F)0.0368042 ,
   (F)0.0245361 ,
   (F)0.0122681 ,
   (F)0 ,
   (F)-0.0122681 ,
   (F)-0.0245361 ,
   (F)-0.0368042 ,
   (F)-0.0490723 ,
   (F)-0.0613403 ,
   (F)-0.0735474 ,
   (F)-0.0858154 ,
   (F)-0.0980225 ,
   (F)-0.110229 ,
   (F)-0.122437 ,
   (F)-0.134583 ,
   (F)-0.146729 ,
   (F)-0.158875 ,
   (F)-0.170959 ,
   (F)-0.183044 ,
   (F)-0.195068 ,
   (F)-0.207092 ,
   (F)-0.219116 ,
   (F)-0.231079 ,
   (F)-0.242981 ,
   (F)-0.254883 ,
   (F)-0.266724 ,
   (F)-0.278503 ,
   (F)-0.290283 ,
   (F)-0.302002 ,
   (F)-0.31366 ,
   (F)-0.325317 ,
   (F)-0.336914 ,
   (F)-0.348389 ,
   (F)-0.359924 ,
   (F)-0.371338 ,
   (F)-0.38269 ,
   (F)-0.393982 ,
   (F)-0.405212 ,
   (F)-0.416443 ,
   (F)-0.427551 ,
   (F)-0.438599 ,
   (F)-0.449585 ,
   (F)-0.46051 ,
   (F)-0.471375 ,
   (F)-0.482178 ,
   (F)-0.49292 ,
   (F)-0.50354 ,
   (F)-0.514099 ,
   (F)-0.524597 ,
   (F)-0.534973 ,
   (F)-0.545349 ,
   (F)-0.555542 ,
   (F)-0.565735 ,
   (F)-0.575806 ,
   (F)-0.585815 ,
   (F)-0.595703 ,
   (F)-0.60553 ,
   (F)-0.615234 ,
   (F)-0.624878 ,
   (F)-0.634399 ,
   (F)-0.64386 ,
   (F)-0.653198 ,
   (F)-0.662415 ,
   (F)-0.67157 ,
   (F)-0.680603 ,
   (F)-0.689514 ,
   (F)-0.698364 ,
   (F)-0.707092 ,
   (F)-0.715759 ,
   (F)-0.724243 ,
   (F)-0.732666 ,
   (F)-0.740967 ,
   (F)-0.749146 ,
   (F)-0.757202 ,
   (F)-0.765198 ,
   (F)-0.77301 ,
   (F)-0.780762 ,
   (F)-0.78833 ,
   (F)-0.795837 ,
   (F)-0.803223 ,
   (F)-0.810486 ,
   (F)-0.817566 ,
   (F)-0.824585 ,
   (F)-0.831482 ,
   (F)-0.838196 ,
   (F)-0.844849 ,
   (F)-0.851379 ,
   (F)-0.857727 ,
   (F)-0.863953 ,
   (F)-0.870117 ,
   (F)-0.876099 ,
   (F)-0.881897 ,
   (F)-0.887634 ,
   (F)-0.89325 ,
   (F)-0.898682 ,
   (F)-0.903992 ,
   (F)-0.90918 ,
   (F)-0.914185 ,
   (F)-0.919128 ,
   (F)-0.923889 ,
   (F)-0.928528 ,
   (F)-0.932983 ,
   (F)-0.937317 ,
   (F)-0.941528 ,
   (F)-0.945618 ,
   (F)-0.949524 ,
   (F)-0.953308 ,
   (F)-0.95697 ,
   (F)-0.960449 ,
   (F)-0.963806 ,
   (F)-0.96698 ,
   (F)-0.970032 ,
   (F)-0.972961 ,
   (F)-0.975708 ,
   (F)-0.978333 ,
   (F)-0.980774 ,
   (F)-0.983093 ,
   (F)-0.985291 ,
   (F)-0.987305 ,
   (F)-0.989197 ,
   (F)-0.990906 ,
   (F)-0.992493 ,
   (F)-0.993896 ,
   (F)-0.995178 ,
   (F)-0.996338 ,
   (F)-0.997314 ,
   (F)-0.998108 ,
   (F)-0.998779 ,
   (F)-0.999329 ,
   (F)-0.999695 ,
   (F)-0.999939 ,
   (F)-1 ,
   (F)-0.999939 ,
   (F)-0.999695 ,
   (F)-0.999329 ,
   (F)-0.998779 ,
   (F)-0.998108 ,
   (F)-0.997314 ,
   (F)-0.996338 ,
   (F)-0.995178 ,
   (F)-0.993896 ,
   (F)-0.992493 ,
   (F)-0.990906 ,
   (F)-0.989197 ,
   (F)-0.987305 ,
   (F)-0.985291 ,
   (F)-0.983093 ,
   (F)-0.980774 ,
   (F)-0.978333 ,
   (F)-0.975708 ,
   (F)-0.972961 ,
   (F)-0.970032 ,
   (F)-0.96698 ,
   (F)-0.963806 ,
   (F)-0.960449 ,
   (F)-0.95697 ,
   (F)-0.953308 ,
   (F)-0.949524 ,
   (F)-0.945618 ,
   (F)-0.941528 ,
   (F)-0.937317 ,
   (F)-0.932983 ,
   (F)-0.928528 ,
   (F)-0.923889 ,
   (F)-0.919128 ,
   (F)-0.914185 ,
   (F)-0.90918 ,
   (F)-0.903992 ,
   (F)-0.898682 ,
   (F)-0.89325 ,
   (F)-0.887634 ,
   (F)-0.881897 ,
   (F)-0.876099 ,
   (F)-0.870117 ,
   (F)-0.863953 ,
   (F)-0.857727 ,
   (F)-0.851379 ,
   (F)-0.844849 ,
   (F)-0.838196 ,
   (F)-0.831482 ,
   (F)-0.824585 ,
   (F)-0.817566 ,
   (F)-0.810486 ,
   (F)-0.803223 ,
   (F)-0.795837 ,
   (F)-0.78833 ,
   (F)-0.780762 ,
   (F)-0.77301 ,
   (F)-0.765198 ,
   (F)-0.757202 ,
   (F)-0.749146 ,
   (F)-0.740967 ,
   (F)-0.732666 ,
   (F)-0.724243 ,
   (F)-0.715759 ,
   (F)-0.707092 ,
   (F)-0.698364 ,
   (F)-0.689514 ,
   (F)-0.680603 ,
   (F)-0.67157 ,
   (F)-0.662415 ,
   (F)-0.653198 ,
   (F)-0.64386 ,
   (F)-0.634399 ,
   (F)-0.624878 ,
   (F)-0.615234 ,
   (F)-0.60553 ,
   (F)-0.595703 ,
   (F)-0.585815 ,
   (F)-0.575806 ,
   (F)-0.565735 ,
   (F)-0.555542 ,
   (F)-0.545349 ,
   (F)-0.534973 ,
   (F)-0.524597 ,
   (F)-0.514099 ,
   (F)-0.50354 ,
   (F)-0.49292 ,
   (F)-0.482178 ,
   (F)-0.471375 ,
   (F)-0.46051 ,
   (F)-0.449585 ,
   (F)-0.438599 ,
   (F)-0.427551 ,
   (F)-0.416443 ,
   (F)-0.405212 ,
   (F)-0.393982 ,
   (F)-0.38269 ,
   (F)-0.371338 ,
   (F)-0.359924 ,
   (F)-0.348389 ,
   (F)-0.336914 ,
   (F)-0.325317 ,
   (F)-0.31366 ,
   (F)-0.302002 ,
   (F)-0.290283 ,
   (F)-0.278503 ,
   (F)-0.266724 ,
   (F)-0.254883 ,
   (F)-0.242981 ,
   (F)-0.231079 ,
   (F)-0.219116 ,
   (F)-0.207092 ,
   (F)-0.195068 ,
   (F)-0.183044 ,
   (F)-0.170959 ,
   (F)-0.158875 ,
   (F)-0.146729 ,
   (F)-0.134583 ,
   (F)-0.122437 ,
   (F)-0.110229 ,
   (F)-0.0980225 ,
   (F)-0.0858154 ,
   (F)-0.0735474 ,
   (F)-0.0613403 ,
   (F)-0.0490723 ,
   (F)-0.0368042 ,
   (F)-0.0245361 ,
   (F)-0.0122681 ,
   (F)0 ,
   (F)0.0122681 ,
   (F)0.0245361 ,
   (F)0.0368042 ,
   (F)0.0490723 ,
   (F)0.0613403 ,
   (F)0.0735474 ,
   (F)0.0858154 ,
   (F)0.0980225 ,
   (F)0.110229 ,
   (F)0.122437 ,
   (F)0.134583 ,
   (F)0.146729 ,
   (F)0.158875 ,
   (F)0.170959 ,
   (F)0.183044 ,
   (F)0.195068 ,
   (F)0.207092 ,
   (F)0.219116 ,
   (F)0.231079 ,
   (F)0.242981 ,
   (F)0.254883 ,
   (F)0.266724 ,
   (F)0.278503 ,
   (F)0.290283 ,
   (F)0.302002 ,
   (F)0.31366 ,
   (F)0.325317 ,
   (F)0.336914 ,
   (F)0.348389 ,
   (F)0.359924 ,
   (F)0.371338 ,
   (F)0.38269 ,
   (F)0.393982 ,
   (F)0.405212 ,
   (F)0.416443 ,
   (F)0.427551 ,
   (F)0.438599 ,
   (F)0.449585 ,
   (F)0.46051 ,
   (F)0.471375 ,
   (F)0.482178 ,
   (F)0.49292 ,
   (F)0.50354 ,
   (F)0.514099 ,
   (F)0.524597 ,
   (F)0.534973 ,
   (F)0.545349 ,
   (F)0.555542 ,
   (F)0.565735 ,
   (F)0.575806 ,
   (F)0.585815 ,
   (F)0.595703 ,
   (F)0.60553 ,
   (F)0.615234 ,
   (F)0.624878 ,
   (F)0.634399 ,
   (F)0.64386 ,
   (F)0.653198 ,
   (F)0.662415 ,
   (F)0.67157 ,
   (F)0.680603 ,
   (F)0.689514 ,
   (F)0.698364 ,
   (F)0.707092 ,
   (F)0.715759 ,
   (F)0.724243 ,
   (F)0.732666 ,
   (F)0.740967 ,
   (F)0.749146 ,
   (F)0.757202 ,
   (F)0.765198 ,
   (F)0.77301 ,
   (F)0.780762 ,
   (F)0.78833 ,
   (F)0.795837 ,
   (F)0.803223 ,
   (F)0.810486 ,
   (F)0.817566 ,
   (F)0.824585 ,
   (F)0.831482 ,
   (F)0.838196 ,
   (F)0.844849 ,
   (F)0.851379 ,
   (F)0.857727 ,
   (F)0.863953 ,
   (F)0.870117 ,
   (F)0.876099 ,
   (F)0.881897 ,
   (F)0.887634 ,
   (F)0.89325 ,
   (F)0.898682 ,
   (F)0.903992 ,
   (F)0.90918 ,
   (F)0.914185 ,
   (F)0.919128 ,
   (F)0.923889 ,
   (F)0.928528 ,
   (F)0.932983 ,
   (F)0.937317 ,
   (F)0.941528 ,
   (F)0.945618 ,
   (F)0.949524 ,
   (F)0.953308 ,
   (F)0.95697 ,
   (F)0.960449 ,
   (F)0.963806 ,
   (F)0.96698 ,
   (F)0.970032 ,
   (F)0.972961 ,
   (F)0.975708 ,
   (F)0.978333 ,
   (F)0.980774 ,
   (F)0.983093 ,
   (F)0.985291 ,
   (F)0.987305 ,
   (F)0.989197 ,
   (F)0.990906 ,
   (F)0.992493 ,
   (F)0.993896 ,
   (F)0.995178 ,
   (F)0.996338 ,
   (F)0.997314 ,
   (F)0.998108 ,
   (F)0.998779 ,
   (F)0.999329 ,
   (F)0.999695 ,
   (F)0.999939
};

/*
**  LspDcTable: LSP long term Dc component
**
*/

FLOAT LspDcTable[LpcOrder] = {
   (F)24.4609,
   (F)36.8828,
   (F)60.0781,
   (F)84.4219,
   (F)108.375,
   (F)128.867,
   (F)154.312,
   (F)173.906,
   (F)199.094,
   (F)216.547,
};

int BandInfoTable[LspQntBands][2] = {
/*
**  BandInfoTable:
**
**  Purpose:
**      Used to index in arrays. Called by LSP sub vector 
**      quantization routines.
**
**  Table Structure:
**      The unquantized LSP vector, quantized LSP vector, and residual
**      LSP error vector are each divided into three subvectors.  
**              The table format is as follows:
**
**      1st pair corresponds to subvector 0
**      2nd pair corresponds to subvector 1
**      3rd pair corresponds to subvector 2
**
**      The 1st slot in each pair is used to index the location of 
**      the vector in a 10-element array.  For example, for subvector
**      1, dimensions [0,..,2] get automatically mapped to array
**      location [3,..,5], and for subvector 3, dimensions
**      [0,..,3] automatically get mapped to array location [6,..,9].
**
**      The 2nd slot in each pair corresponds to the dimension of
**      the subvector
*/

   { 0,3},
   { 3,3},
   { 6,4}
   };

/*
**  Band0Tb8:
**
**  Purpose:
**      Vector Quantize the first 3-vector of the 10 LSP parameters.
**
**  Table Structure:
**      8 bit, 256 entry table.
*/

FLOAT Band0Tb8[LspCbSize*3] = {
	(F)0,  (F)0,  (F)0,
	(F)-2.10938,  (F)-10.7188,  (F)-8.0625,
	(F)-4.22656,  (F)-12.8906,  (F)-10.7969,
	(F)-5.64844,  (F)-15.7109,  (F)-17.2891,
	(F)-7.35156,  (F)-8.76562,  (F)-15.1719,
	(F)-6.09375,  (F)-8.94531,  (F)-19.1719,
	(F)-6.90625,  (F)-10.2266,  (F)-10.7266,
	(F)-8.21094,  (F)-11.8984,  (F)-13.7969,
	(F)-8.46094,  (F)-12.6719,  (F)-17.9688,
	(F)-6.07031,  (F)-10.7578,  (F)-16.7734,
	(F)-7.30469,  (F)-11.4609,  (F)-21.5859,
	(F)-6.26562,  (F)-10.3672,  (F)-27.1172,
	(F)-7.30469,  (F)-15.3047,  (F)-31.2422,
	(F)-1.875,  (F)-0.695312,  (F)1.73438,
	(F)-5.16406,  (F)-2.00781,  (F)-1.25,
	(F)-7.76562,  (F)-3.64062,  (F)-3.27344,
	(F)-1.46875,  (F)-1.28125,  (F)-2.17188,
	(F)-2.67188,  (F)-4,  (F)-3.24219,
	(F)-4.74219,  (F)-3.99219,  (F)-6.22656,
	(F) 0.125,  (F)0.148438,  (F)-5.59375,
	(F) 2.92188,  (F)3.32031,  (F)-7.59375,
	(F)-2.70312,  (F)1.91406,  (F)-2.20312,
	(F)-2.07031,  (F)3.95312,  (F)-5.89062,
	(F)-4.84375,  (F)-1.14844,  (F)15.2734,
	(F)-5.79688,  (F)-6.71875,  (F)20.2891,
	(F)-1.17188,  (F)-2.75,  (F)21.125,
	(F) 2.38281,  (F)6.875,  (F)15.2656,
	(F) 0.960938,  (F)5.71094,  (F)21.6094,
	(F)-2.71875,  (F)5.97656,  (F)25.9922,
	(F) 4.82812,  (F)1.72656,  (F)25.4531,
	(F)-1.39062,  (F)-0.367188,  (F)32.9609,
	(F) 3.07031,  (F)10.1875,  (F)30.0156,
	(F) 5.45312,  (F)13.2969,  (F)37.5078,
	(F) 0.492188,  (F)-4.5625,  (F)9.60156,
	(F)-1.67969,  (F)-5.71875,  (F)13.3125,
	(F) 1.34375,  (F)-2.61719,  (F)14.9141,
	(F)-0.015625,  (F)1.6875,  (F)14.0391,
	(F) 2.75781,  (F)0.992188,  (F)17.2266,
	(F)-9.4375,  (F)1.46875,  (F)0.0859375,
	(F)-4.00781,  (F)-0.585938,  (F)-5.33594,
	(F)-7.60156,  (F)1.73438,  (F)-5.04688,
	(F)-4.8125,  (F)-6.58594,  (F)-3.03125,
	(F)-7.42188,  (F)-8.69531,  (F)-2.80469,
	(F)-11.1797,  (F)-4.86719,  (F)-5.50781,
	(F)-10.9219,  (F)-8.30469,  (F)-1.39062,
	(F)-0.351562,  (F)-3.60156,  (F)0.273438,
	(F)-0.0703125,  (F)-5.13281,  (F)-1.6875,
	(F) 0.992188,  (F)-8.42188,  (F)0.742188,
	(F)-7.42188,  (F)-9.03125,  (F)4.5625,
	(F)-11.5625,  (F)-11.6719,  (F)3.50781,
	(F)-0.9375,  (F)-5.50781,  (F)4.03125,
	(F)-2.875,  (F)-7.50781,  (F)5.67969,
	(F)-2.95312,  (F)-4.10938,  (F)7.60156,
	(F)-6.19531,  (F)-4.79688,  (F)5.28125,
	(F)-6.25781,  (F)-5.89844,  (F)10.0547,
	(F)-11.5312,  (F)-2.65625,  (F)12.7812,
	(F)-3.94531,  (F)-9.79688,  (F)12.0547,
	(F)-9.71094,  (F)-12.6719,  (F)11.9688,
	(F)-6.0625,  (F)-11.5391,  (F)-5.11719,
	(F)-8.99219,  (F)-10.125,  (F)-6.42969,
	(F)-9.00781,  (F)-13.0625,  (F)-8.78125,
	(F)-10.0859,  (F)-15.6484,  (F)-13.2969,
	(F)-4.85938,  (F)-10.0234,  (F)0.445312,
	(F)-3.67969,  (F)-12.5859,  (F)3.97656,
	(F)-8.28125,  (F)-12.2656,  (F)-1.08594,
	(F)-6.82031,  (F)-16.8438,  (F)-4.1875,
	(F)-13.4062,  (F)-15.7891,  (F)-2.84375,
	(F)-16.7969,  (F)-25.1406,  (F)-10.0859,
	(F)-9.75,  (F)-15.1953,  (F)-22.6875,
	(F)-9.49219,  (F)-20.5703,  (F)-22.3047,
	(F) 1.30469,  (F)-1.90625,  (F)0.65625,
	(F) 2.72656,  (F)-3.21875,  (F)-1.69531,
	(F)-0.3125,  (F)-2.75,  (F)4.9375,
	(F) 1.77344,  (F)-4.13281,  (F)3.16406,
	(F) 0.53125,  (F)-2.99219,  (F)-3.46094,
	(F) 1.30469,  (F)-4.35938,  (F)-5.51562,
	(F)-2.14844,  (F)-6.67188,  (F)-0.109375,
	(F)-2.74219,  (F)-8.50781,  (F)-3.50781,
	(F) 2.66406,  (F)-0.5625,  (F)-2.25781,
	(F) 4.71094,  (F)-0.828125,  (F)-3.70312,
	(F) 2.51562,  (F)-1.71094,  (F)-5.07031,
	(F) 1.39844,  (F)-2.47656,  (F)-7.79688,
	(F) 3.51562,  (F)-2.27344,  (F)-7.78125,
	(F) 4.33594,  (F)1.52344,  (F)-4.10156,
	(F) 6.125,  (F)2.125,  (F)-6.49219,
	(F)-1.15625,  (F)-3,  (F)-6.63281,
	(F) 0.640625,  (F)-4.1875,  (F)-10.6016,
	(F) 1.85938,  (F)-1.34375,  (F)-10.5781,
	(F) 3.29688,  (F)-2.09375,  (F)-14.3828,
	(F) 2.32031,  (F)-5.75781,  (F)-16.2422,
	(F)-0.867188,  (F)-6.25781,  (F)-4.67188,
	(F) 0.0078125,  (F)-5.21875,  (F)-7.6875,
	(F)-1.02344,  (F)-6.39062,  (F)-10.1484,
	(F)-2.57031,  (F)-4.07031,  (F)-10.2344,
	(F)-1.17969,  (F)-6.07812,  (F)-14.3281,
	(F)-0.726562,  (F)-2.75,  (F)-13.6406,
	(F)-4.4375,  (F)-5,  (F)-14.2266,
	(F)-3.97656,  (F)-7.35156,  (F)-17.0547,
	(F) 3.625,  (F)-6.36719,  (F)-9.76562,
	(F) 0.617188,  (F)-8.85156,  (F)-12.4766,
	(F)-1.4375,  (F)-10.5703,  (F)-16.5859,
	(F)-1.53125,  (F)-3.20312,  (F)-18.9609,
	(F)-1.5,  (F)-6.50781,  (F)-21.9531,
	(F)-2.02344,  (F)-10.7969,  (F)-23.7891,
	(F)-1.69531,  (F)0.03125,  (F)-9.10938,
	(F)-6.25,  (F)-2.53906,  (F)-9.52344,
	(F)-2.83594,  (F)-6.48438,  (F)-7.01562,
	(F)-5.16406,  (F)-8.85938,  (F)-7.5,
	(F)-3.01562,  (F)-7.65625,  (F)-11.7266,
	(F)-4.89844,  (F)-9.05469,  (F)-13.4531,
	(F)-7.05469,  (F)-6.47656,  (F)-6.67969,
	(F)-5.35156,  (F)-6.47656,  (F)-10.2578,
	(F)-8.32031,  (F)-7.49219,  (F)-10.9766,
	(F) 3.44531,  (F)0.195312,  (F)-6.61719,
	(F) 5.11719,  (F)-0.210938,  (F)-9.22656,
	(F) 9.05469,  (F)-0.859375,  (F)-5.50781,
	(F) 6.6875,  (F)1.97656,  (F)-13.0547,
	(F) 3.24219,  (F)3.15625,  (F)-0.0078125,
	(F) 2.51562,  (F)7.05469,  (F)-3.10938,
	(F) 5.23438,  (F)3.89844,  (F)-2.28125,
	(F) 6.27344,  (F)4.61719,  (F)-4.76562,
	(F) 8.9375,  (F)4.61719,  (F)-6.35938,
	(F) 5.60156,  (F)1.42969,  (F)3.07031,
	(F) 6.69531,  (F)2.97656,  (F)0.828125,
	(F) 4.75781,  (F)0.484375,  (F)-0.210938,
	(F) 6.1875,  (F)1.54688,  (F)-2.53906,
	(F) 5.74219,  (F)6.28906,  (F)0.6875,
	(F) 8.92188,  (F)6.34375,  (F)0.609375,
	(F) 8.03125,  (F)2.85938,  (F)-2.28125,
	(F) 10.2266,  (F)5.80469,  (F)-1.85156,
	(F) 12.6172,  (F)4.60156,  (F)-0.617188,
	(F) 7.89062,  (F)4.99219,  (F)-1.89844,
	(F) 7.80469,  (F)7.53125,  (F)-2.42969,
	(F) 11.7188,  (F)8.88281,  (F)-4.80469,
	(F) 7.71875,  (F)2.78906,  (F)5.04688,
	(F) 9.58594,  (F)5.21094,  (F)5.33594,
	(F) 9.09375,  (F)12.2266,  (F)6.98438,
	(F) 10.875,  (F)15.7422,  (F)3.72656,
	(F) 8.89062,  (F)4.16406,  (F)1.95312,
	(F) 11.2266,  (F)7,  (F)3.05469,
	(F) 13.7891,  (F)8.73438,  (F)0.773438,
	(F) 8.6875,  (F)8.51562,  (F)6.26562,
	(F) 12.4688,  (F)6.60938,  (F)8.85938,
	(F) 7.32031,  (F)9.07031,  (F)2.17969,
	(F) 13.4297,  (F)9.79688,  (F)5.33594,
	(F) 10.4531,  (F)8.48438,  (F)0.273438,
	(F) 11.0859,  (F)10.3438,  (F)3.34375,
	(F) 11.1562,  (F)11.9062,  (F)0.3125,
	(F) 16.4688,  (F)12.4531,  (F)0.695312,
	(F) 7.92969,  (F)4.25,  (F)9.54688,
	(F) 8.75781,  (F)7.22656,  (F)9.86719,
	(F) 8.04688,  (F)10.2969,  (F)11.6016,
	(F) 10.1172,  (F)6.16406,  (F)14.1953,
	(F) 10.3359,  (F)9.9375,  (F)14.9141,
	(F) 13.4688,  (F)9.66406,  (F)14.0859,
	(F) 14.0391,  (F)13.1953,  (F)6.70312,
	(F) 16.7891,  (F)10.6797,  (F)10.1641,
	(F) 17.9844,  (F)14.5859,  (F)5.94531,
	(F) 22.3672,  (F)18.3672,  (F)8.22656,
	(F) 0.40625,  (F)1.27344,  (F)-0.59375,
	(F) 1.79688,  (F)2.41406,  (F)-3.84375,
	(F)-0.554688,  (F)4.83594,  (F)0.304688,
	(F)-1.70312,  (F)6.6875,  (F)3.89844,
	(F)-5.10938,  (F)5.75,  (F)-1.61719,
	(F)-4.17969,  (F)9.83594,  (F)1.21094,
	(F)-3.75,  (F)11.5312,  (F)5.02344,
	(F) 2.04688,  (F)8.44531,  (F)0.796875,
	(F) 2.41406,  (F)12.4375,  (F)-1.42188,
	(F) 4.89844,  (F)12.7266,  (F)4.17188,
	(F) 2.63281,  (F)5.02344,  (F)3.5625,
	(F) 5.92188,  (F)5.23438,  (F)5.57031,
	(F) 1.57812,  (F)8.79688,  (F)5.14062,
	(F) 4.78125,  (F)8.83594,  (F)5.20312,
	(F) 5.35938,  (F)9.55469,  (F)8.875,
	(F)-1.02344,  (F)2.94531,  (F)4.10156,
	(F) 0.328125,  (F)5.53125,  (F)7.08594,
	(F) 0.679688,  (F)11.625,  (F)8.08594,
	(F) 3.375,  (F)16.5391,  (F)7.0625,
	(F) 1.07031,  (F)7.66406,  (F)10.4062,
	(F)-3.49219,  (F)7.92188,  (F)8.875,
	(F)-6.55469,  (F)14.0078,  (F)9.73438,
	(F)-4.36719,  (F)2.32031,  (F)1.54688,
	(F)-6.64062,  (F)5.35156,  (F)3.48438,
	(F)-9.94531,  (F)4.9375,  (F)6.45312,
	(F)-3.13281,  (F)-4.25,  (F)1.35156,
	(F)-5.88281,  (F)-6.19531,  (F)1.125,
	(F)-3.40625,  (F)-0.0703125,  (F)6.03125,
	(F)-0.898438,  (F)-1.89844,  (F)10.2344,
	(F)-5.23438,  (F)-2.10156,  (F)2.92188,
	(F)-8.02344,  (F)-0.101562,  (F)4.99219,
	(F)-6.92969,  (F)-0.632812,  (F)8.88281,
	(F)-9.97656,  (F)-3.55469,  (F)1.23438,
	(F)-11.0234,  (F)-5.625,  (F)5.75,
	(F) 1.34375,  (F)0.6875,  (F)3.14844,
	(F) 3.01562,  (F)1.99219,  (F)5.90625,
	(F)-3.90625,  (F)4.07812,  (F)7.10938,
	(F)-7.48438,  (F)5.14844,  (F)10.8438,
	(F)-3.08594,  (F)2.35156,  (F)10.5,
	(F)-2.78125,  (F)6,  (F)14.1641,
	(F)-4.78906,  (F)6.57031,  (F)18.8984,
	(F) 3.47656,  (F)-0.953125,  (F)1.96875,
	(F) 4.91406,  (F)-0.679688,  (F)5.64844,
	(F) 2.21094,  (F)-1.97656,  (F)6.79688,
	(F) 3.5625,  (F)-0.90625,  (F)10.7891,
	(F) 5.91406,  (F)1.40625,  (F)8.27344,
	(F) 4.15625,  (F)3.1875,  (F)11.7891,
	(F) 7.39844,  (F)2.25,  (F)14.1094,
	(F) 10.3516,  (F)7.76562,  (F)19.7188,
	(F) 6.96875,  (F)9.52344,  (F)23.6172,
	(F) 10.9141,  (F)12.4688,  (F)26.6094,
	(F) 8.92969,  (F)12.125,  (F)19.8906,
	(F) 14.4531,  (F)11.1953,  (F)21.1719,
	(F)-0.078125,  (F)1.04688,  (F)7.82812,
	(F) 1.20312,  (F)3.89844,  (F)10.3359,
	(F) 3.96875,  (F)6.1875,  (F)8.72656,
	(F) 3.97656,  (F)10.4688,  (F)12.625,
	(F) 5.95312,  (F)6.73438,  (F)12.5625,
	(F) 6.14844,  (F)5.78125,  (F)18.125,
	(F) 6.20312,  (F)13.4922,  (F)10.0234,
	(F) 3.63281,  (F)16.4688,  (F)12.9688,
	(F)-0.9375,  (F)11.3359,  (F)12.6016,
	(F)-3.01562,  (F)15.75,  (F)16.9453,
	(F) 6.96094,  (F)9.57031,  (F)16.0156,
	(F) 3.5625,  (F)11.5625,  (F)17.0703,
	(F) 11.6641,  (F)10.0234,  (F)9.44531,
	(F) 10.9141,  (F)12.7812,  (F)11.8594,
	(F) 13.875,  (F)13.5781,  (F)12.125,
	(F) 12.2812,  (F)13.2656,  (F)16.7266,
	(F) 10.8516,  (F)16.6094,  (F)9.92969,
	(F) 15.3047,  (F)18.8516,  (F)8.74219,
	(F) 10.6641,  (F)22.5938,  (F)11.7578,
	(F) 17.2344,  (F)15.3984,  (F)12.6797,
	(F) 16.2188,  (F)15.2344,  (F)17.8125,
	(F) 13.4141,  (F)17.8984,  (F)14.5859,
	(F) 18.4844,  (F)19.6484,  (F)15.2578,
	(F) 22.3828,  (F)22.1719,  (F)19.7031,
	(F) 19.8047,  (F)27.0703,  (F)15.7109,
	(F) 26.4141,  (F)32.2422,  (F)20.6094,
	(F) 6.53125,  (F)20.8359,  (F)17.8828,
	(F) 13.7578,  (F)21.6641,  (F)18.2578,
	(F) 11.0547,  (F)25.9766,  (F)22.7422,
	(F) 18.3906,  (F)24.5156,  (F)24.4219,
	(F) 20.7734,  (F)32.75,  (F)31.3281,
	(F) 8.1875,  (F)13.9531,  (F)14.2031,
	(F) 9.70312,  (F)16.4922,  (F)17.5,
	(F) 11.8125,  (F)16.2422,  (F)21.7188,
	(F) 12.2891,  (F)19.4609,  (F)24.5156,
	(F) 17.4219,  (F)18.5703,  (F)21.7344,
	(F) 3.25,  (F)13.8516,  (F)21.125,
	(F) 5.66406,  (F)18.25,  (F)25.7578,
	(F) 9.78125,  (F)18.5391,  (F)31.0781,
	(F) 16.3594,  (F)17.7188,  (F)27.875,
	(F) 15.7109,  (F)21.1875,  (F)35.375,
	(F) 10.4766,  (F)27.3984,  (F)30.2812,
	(F) 9.5,  (F)30.6172,  (F)38.4531,
	(F) 13.2266,  (F)37.4453,  (F)46.9688,
};

/*
**  Band1Tb8:
**
**  Purpose:
**      Vector Quantize the second 3-vector of the 10 LSP parameters.
**
**  Table Structure:
**      8 bit, 256 entry table.
*/

FLOAT Band1Tb8[LspCbSize*3] = {
	(F)0,  (F)0,  (F)0,
	(F)-16.5156,  (F)-10.1719,  (F)0.59375,
	(F)-20.7188,  (F)-9.98438,  (F)-10.6875,
	(F)-22.2422,  (F)-6.46875,  (F)-2.72656,
	(F)-29.7812,  (F)-17.1094,  (F)-2.72656,
	(F)-30.8281,  (F)-2.84375,  (F)-3.50781,
	(F)-21.2891,  (F)-35.0938,  (F)-28.1797,
	(F)-27.3047,  (F)-37.2188,  (F)-13.625,
	(F)-0.398438,  (F)-5.90625,  (F)0.65625,
	(F)-1.19531,  (F)-9.30469,  (F)3.9375,
	(F) 0.84375,  (F)-11.0781,  (F)9.11719,
	(F)-6.52344,  (F)-7,  (F)3.04688,
	(F)-4.44531,  (F)-13.2969,  (F)0.679688,
	(F)-8.99219,  (F)-14.2031,  (F)7.28906,
	(F)-14.2656,  (F)-19.8984,  (F)3.21094,
	(F)-14.3906,  (F)-14.2031,  (F)11.3359,
	(F)-19.0469,  (F)-12.5859,  (F)6.10156,
	(F)-21.4609,  (F)-19.3516,  (F)10.2422,
	(F)-7.34375,  (F)9.78125,  (F)3.72656,
	(F)-12.7266,  (F)13.1875,  (F)4.70312,
	(F)-9.39062,  (F)4.82031,  (F)2.1875,
	(F)-13.5703,  (F)3.07031,  (F)4.53125,
	(F)-11.9375,  (F)8.41406,  (F)9.36719,
	(F)-16.9141,  (F)-1.25781,  (F)11,
	(F)-19.5625,  (F)-8.49219,  (F)18.5234,
	(F)-27.0156,  (F)-1.36719,  (F)10.8984,
	(F)-10.9141,  (F)-0.765625,  (F)-6.58594,
	(F)-17.5938,  (F)-1.38281,  (F)-8.97656,
	(F)-11.6328,  (F)-5.67188,  (F)-10.0234,
	(F)-12.1719,  (F)-2.07031,  (F)-13.625,
	(F)-14.5859,  (F)-6.41406,  (F)-14.8203,
	(F)-16.1094,  (F)-11.8438,  (F)-18.2812,
	(F)-20.2734,  (F)-8.92188,  (F)-22.3516,
	(F) 1.32812,  (F)0.359375,  (F)-6.39844,
	(F)-1.50781,  (F)-1.59375,  (F)-8.99219,
	(F) 2.54688,  (F)-1.53125,  (F)-11.9688,
	(F) 6.09375,  (F)2.57031,  (F)-6.375,
	(F) 1.57031,  (F)2.88281,  (F)-9.71094,
	(F) 5.07812,  (F)-1.63281,  (F)-8.28125,
	(F) 8.9375,  (F)-0.117188,  (F)-9.5,
	(F) 9.39844,  (F)-2.02344,  (F)-14.5859,
	(F)-6.95312,  (F)-4.40625,  (F)-11.1719,
	(F)-4.98438,  (F)-6.65625,  (F)-15.0078,
	(F) 1.38281,  (F)-5.77344,  (F)-10.6094,
	(F)-2.03906,  (F)-4.10938,  (F)-13.0156,
	(F) 1.60938,  (F)-3.17969,  (F)-17.6172,
	(F) 2.64062,  (F)-4.10938,  (F)-6.42188,
	(F) 3.28906,  (F)-8.55469,  (F)-7.88281,
	(F) 5.97656,  (F)-4.74219,  (F)-11,
	(F) 6.44531,  (F)-10.1172,  (F)-15.6562,
	(F) 2.78906,  (F)-7.07031,  (F)-14.1797,
	(F)-0.453125,  (F)-9.75,  (F)-12.4062,
	(F)-4.65625,  (F)-11.2188,  (F)-15.9844,
	(F)-0.570312,  (F)-9.05469,  (F)-16.5312,
	(F)-0.898438,  (F)-10.7969,  (F)-20.1641,
	(F)-1.25,  (F)-13.4609,  (F)-15.25,
	(F)-0.046875,  (F)-17.1562,  (F)-23.0781,
	(F)-5.07031,  (F)-13.3203,  (F)-20.3359,
	(F)-4.82031,  (F)-11.3516,  (F)-25.6406,
	(F)-7.41406,  (F)-15.7734,  (F)-24.2344,
	(F)-6.34375,  (F)12.0625,  (F)15.1328,
	(F)-14.4844,  (F)4.48438,  (F)15.625,
	(F)-11.4297,  (F)8.90625,  (F)20.6953,
	(F)-20.9609,  (F)13.6562,  (F)11.3438,
	(F)-19.4219,  (F)17.5078,  (F)19.7109,
	(F) 6.11719,  (F)14.9219,  (F)11.2109,
	(F) 4.53906,  (F)20.9531,  (F)10.75,
	(F) 1.84375,  (F)17.1641,  (F)14.7266,
	(F)-3.53906,  (F)22.9922,  (F)16.0703,
	(F)-5.32812,  (F)17.0156,  (F)20.0391,
	(F)-10.4844,  (F)25.0078,  (F)26,
	(F)-2.25,  (F)-1.4375,  (F)2.04688,
	(F) 0.945312,  (F)-1.16406,  (F)-1.42969,
	(F) 5.92188,  (F)-3.21875,  (F)1.60938,
	(F) 8.10938,  (F)-1.59375,  (F)6.66406,
	(F) 12.3203,  (F)-3.57031,  (F)5.46875,
	(F) 7.32031,  (F)-5,  (F)-4.42969,
	(F) 11.7812,  (F)-4.125,  (F)-8,
	(F)-1.75781,  (F)-4.11719,  (F)-3.33594,
	(F)-4.40625,  (F)-8.55469,  (F)-2.59375,
	(F)-5.79688,  (F)-2.75781,  (F)-1.45312,
	(F)-10.0625,  (F)-3.58594,  (F)0.65625,
	(F)-14.4766,  (F)-3.78125,  (F)-2.14062,
	(F)-12.1406,  (F)-5.71094,  (F)6.44531,
	(F)-18.9453,  (F)-1.82812,  (F)2.98438,
	(F)-13.4531,  (F)2.28906,  (F)-2.11719,
	(F)-19.6484,  (F)3.32031,  (F)-4.40625,
	(F)-20.3047,  (F)6.39062,  (F)3.625,
	(F)-2.79688,  (F)0.921875,  (F)-2.92969,
	(F)-4.78906,  (F)1.54688,  (F)-6.82812,
	(F)-5.39062,  (F)5.33594,  (F)-2.53125,
	(F)-10.5625,  (F)9.02344,  (F)-1.3125,
	(F)-8.53906,  (F)1.00781,  (F)-2.53125,
	(F)-9.25,  (F)4.77344,  (F)-6.70312,
	(F) 3.38281,  (F)3.01562,  (F)-2.90625,
	(F)-0.9375,  (F)3.79688,  (F)-4.95312,
	(F) 1.82812,  (F)6.64844,  (F)-4.92969,
	(F) 4.70312,  (F)1,  (F)0.359375,
	(F) 8.58594,  (F)3.20312,  (F)1.24219,
	(F) 5.58594,  (F)-1.13281,  (F)-3.3125,
	(F) 9.35938,  (F)-0.664062,  (F)-4.63281,
	(F) 10.8594,  (F)2.86719,  (F)-2.79688,
	(F) 13.1484,  (F)2.82812,  (F)-7.53125,
	(F) 13.3672,  (F)4.85938,  (F)0.351562,
	(F) 15.8828,  (F)6.50781,  (F)-2.99219,
	(F) 22.5781,  (F)4.28906,  (F)-3.95312,
	(F) 0.0546875,  (F)3.13281,  (F)0.40625,
	(F) 0.5625,  (F)6.33594,  (F)3.24219,
	(F) 4.42188,  (F)5.21875,  (F)0.320312,
	(F) 3.64844,  (F)9.51562,  (F)1.01562,
	(F) 0.53125,  (F)7.47656,  (F)-1.46094,
	(F)-0.195312,  (F)12.8828,  (F)-0.804688,
	(F)-5.16406,  (F)2.03125,  (F)1.67188,
	(F)-7.22656,  (F)-0.734375,  (F)4.78125,
	(F)-2.50781,  (F)-3.29688,  (F)7.53906,
	(F)-6.15625,  (F)-5.25,  (F)13.9297,
	(F) 3.125,  (F)-5.25781,  (F)6.08594,
	(F) 5.78906,  (F)-4.64844,  (F)12.7734,
	(F)-1.25781,  (F)2.39844,  (F)5.13281,
	(F)-2.98438,  (F)6.53125,  (F)6.80469,
	(F)-6.35938,  (F)3.125,  (F)9.55469,
	(F) 2.84375,  (F)4.73438,  (F)9.74219,
	(F) 0.445312,  (F)0.585938,  (F)12.2734,
	(F) 1.17969,  (F)3.67969,  (F)17.8672,
	(F)-0.632812,  (F)7.97656,  (F)11.7344,
	(F) 1.77344,  (F)11.4844,  (F)8.57031,
	(F) 5.14062,  (F)9.96094,  (F)12.9141,
	(F) 5.1875,  (F)11.5469,  (F)18.5703,
	(F) 2.05469,  (F)-0.992188,  (F)3.46875,
	(F) 2.0625,  (F)0.695312,  (F)7.57031,
	(F) 6.20312,  (F)1.33594,  (F)4.5,
	(F) 6.41406,  (F)1.45312,  (F)9.57812,
	(F) 3.15625,  (F)3.60938,  (F)4.03906,
	(F) 2.64844,  (F)7.17188,  (F)6.20312,
	(F) 10,  (F)11.1172,  (F)1.53125,
	(F) 11.3516,  (F)15.7734,  (F)2.85156,
	(F) 12.6172,  (F)11.5703,  (F)5.25,
	(F) 18.7031,  (F)13.3438,  (F)3.96875,
	(F) 6.29688,  (F)9.67188,  (F)4.47656,
	(F) 5.57031,  (F)9.04688,  (F)8.42188,
	(F) 10.0391,  (F)11.2188,  (F)9.625,
	(F) 13.9844,  (F)9.28125,  (F)8.91406,
	(F) 5.97656,  (F)5.02344,  (F)6.75,
	(F) 8.0625,  (F)6.22656,  (F)9.99219,
	(F) 7.03125,  (F)4.39844,  (F)14.2734,
	(F) 11.8281,  (F)5.25781,  (F)18.0625,
	(F) 12.0625,  (F)8.82031,  (F)25.3125,
	(F) 11.4766,  (F)8.20312,  (F)12.4531,
	(F) 15.1953,  (F)10.2969,  (F)15.5312,
	(F) 18.7266,  (F)15.8281,  (F)16.0938,
	(F) 27.6406,  (F)16.0703,  (F)20.4688,
	(F) 9.75781,  (F)-0.921875,  (F)0.578125,
	(F) 13.4922,  (F)1.51562,  (F)3.28906,
	(F) 16.2344,  (F)-0.390625,  (F)-3.61719,
	(F) 7.57812,  (F)5.375,  (F)-3.375,
	(F) 8.97656,  (F)7.4375,  (F)-0.859375,
	(F) 9.79688,  (F)9.96094,  (F)-5.08594,
	(F) 10.8281,  (F)7.25781,  (F)3.13281,
	(F) 15.3125,  (F)9.11719,  (F)1.8125,
	(F) 3.17969,  (F)-5.875,  (F)-1.89844,
	(F) 6.71094,  (F)-8.73438,  (F)1.34375,
	(F)-1.77344,  (F)-6.71875,  (F)-7.75,
	(F)-6.21875,  (F)-9.17969,  (F)-10.7812,
	(F) 0.0625,  (F)-10.0156,  (F)-3.03125,
	(F) 2.75781,  (F)-13.9141,  (F)-8.10156,
	(F)-5.71875,  (F)-3.10156,  (F)-6.30469,
	(F)-6.66406,  (F)-0.21875,  (F)-10.4844,
	(F)-9.60156,  (F)-9.42969,  (F)-15.3047,
	(F)-7.92969,  (F)-8.78906,  (F)-19.8672,
	(F)-11.3438,  (F)-13.9922,  (F)-21.2891,
	(F)-14.7734,  (F)-18.875,  (F)-25.5391,
	(F)-7.17188,  (F)-12.7266,  (F)-6.11719,
	(F)-4.53125,  (F)-16.8359,  (F)-5.45312,
	(F)-8.57031,  (F)-18.4688,  (F)-0.75,
	(F)-10.8359,  (F)-11.8203,  (F)0.0546875,
	(F)-12.4062,  (F)-16.2188,  (F)-5.1875,
	(F)-11.5078,  (F)-21.4062,  (F)-6.125,
	(F)-18.5781,  (F)-24.6016,  (F)-0.4375,
	(F)-22.3125,  (F)-16.3438,  (F)-1.32031,
	(F)-26.4922,  (F)-28.9688,  (F)2.46875,
	(F)-9.1875,  (F)-6.95312,  (F)-4.79688,
	(F)-15.1875,  (F)-8.28906,  (F)-6.25,
	(F)-2.33594,  (F)-11.8516,  (F)-7.8125,
	(F)-5,  (F)-14.4531,  (F)-11.9219,
	(F)-11.3594,  (F)-12,  (F)-9.63281,
	(F)-14.7656,  (F)-15.2734,  (F)-13.7188,
	(F)-8.48438,  (F)-15.0078,  (F)-16.5781,
	(F)-5.85938,  (F)-18.1641,  (F)-17.6562,
	(F)-10.3516,  (F)-18.8516,  (F)-20.8828,
	(F)-8.70312,  (F)-19.8594,  (F)-27.0234,
	(F)-10.4766,  (F)-22.6641,  (F)-30.9609,
	(F)-9.0625,  (F)-17.3906,  (F)-10.8828,
	(F)-7.82031,  (F)-21.6562,  (F)-12.2891,
	(F)-12.4531,  (F)-20.6328,  (F)-15.4531,
	(F)-11.9844,  (F)-23.7969,  (F)-20.5,
	(F)-17.375,  (F)-17.1562,  (F)-5.27344,
	(F)-21.9297,  (F)-23.8594,  (F)-8.60938,
	(F)-15.6875,  (F)-22.1875,  (F)-9.26562,
	(F)-15.4688,  (F)-26.0312,  (F)-13.2422,
	(F)-13.3984,  (F)-27.8281,  (F)-3.94531,
	(F)-19.7422,  (F)-31.25,  (F)-14.7422,
	(F)-18.2266,  (F)-21.3594,  (F)-17.9375,
	(F)-26.875,  (F)-18.7578,  (F)-25.0859,
	(F)-15.6875,  (F)-27.5625,  (F)-26.0703,
	(F)-17.5547,  (F)-25.7109,  (F)-35.2344,
	(F)-3.71094,  (F)7.41406,  (F)1.21094,
	(F)-1.16406,  (F)10.6641,  (F)4.25781,
	(F)-5.91406,  (F)12.8438,  (F)8.46094,
	(F)-1.69531,  (F)16.0391,  (F)10.5703,
	(F)-11.1953,  (F)17.9766,  (F)11.4219,
	(F) 3.86719,  (F)12.9766,  (F)4.13281,
	(F) 0.078125,  (F)15.9141,  (F)5.78125,
	(F) 16.2656,  (F)14.8281,  (F)7.64062,
	(F) 22.1172,  (F)17.9219,  (F)7.11719,
	(F) 6.57812,  (F)6.19531,  (F)3.28125,
	(F) 9.55469,  (F)7.99219,  (F)6.74219,
	(F) 9.66406,  (F)3.52344,  (F)6.09375,
	(F) 13.625,  (F)5.53125,  (F)6.42188,
	(F) 11.9766,  (F)2.21875,  (F)10.8125,
	(F) 16.6797,  (F)4.75781,  (F)12.0156,
	(F) 18.0078,  (F)4.89062,  (F)4.21875,
	(F) 18.5,  (F)9.27344,  (F)7.46094,
	(F) 20.2031,  (F)9.80469,  (F)-0.0546875,
	(F) 24.3438,  (F)8.83594,  (F)5.67188,
	(F) 26.8047,  (F)13.5156,  (F)3.34375,
	(F) 21.3594,  (F)12.875,  (F)10.2109,
	(F) 23.3438,  (F)9.61719,  (F)15.7031,
	(F) 27.5234,  (F)15.8125,  (F)11.625,
	(F) 8.07812,  (F)12.9453,  (F)6.80469,
	(F) 9.42188,  (F)16.8984,  (F)8.09375,
	(F) 14.1172,  (F)18.5312,  (F)9.63281,
	(F) 14.125,  (F)13.8203,  (F)11.6641,
	(F) 12.2891,  (F)18.2188,  (F)13.8984,
	(F) 9.5,  (F)12.5703,  (F)14.5781,
	(F) 11.5625,  (F)14.8281,  (F)19.6328,
	(F) 3.63281,  (F)21.1562,  (F)21.6875,
	(F) 6.02344,  (F)28.4219,  (F)26.0781,
	(F) 14.6016,  (F)20.3047,  (F)20.4922,
	(F) 22.0703,  (F)21.4453,  (F)19.2812,
	(F) 20.6094,  (F)19.0547,  (F)12.3828,
	(F) 16.3594,  (F)23.2031,  (F)10.2188,
	(F) 15.7969,  (F)23.8828,  (F)15.6172,
	(F) 26.7812,  (F)22.75,  (F)14.1875,
	(F) 35.4375,  (F)23.2344,  (F)16.6328,
	(F) 8.17188,  (F)20.0234,  (F)16.2969,
	(F) 10.6484,  (F)27.8281,  (F)18.1094,
	(F) 19.6172,  (F)14.7734,  (F)23.3125,
	(F) 14.5781,  (F)18.0156,  (F)31.1406,
	(F) 25.5625,  (F)22.8438,  (F)28.7656,
	(F) 24.5781,  (F)27.8438,  (F)17.75,
	(F) 28.0625,  (F)31,  (F)22.0469,
	(F) 18.9922,  (F)26.3203,  (F)23.9766,
	(F) 15.0859,  (F)36.7891,  (F)24.1406,
	(F) 20.5391,  (F)32.9688,  (F)31.1406,
	(F) 36.2422,  (F)31.6875,  (F)28.625,
	(F) 31.5234,  (F)41.6719,  (F)38.375,
};


/*
**  Band2Tb8:
**
**  Purpose:
**      Vector Quantize the last 4-vector of the 10 LSP parameters.
**
**  Table Structure:
**      8 bit, 256 entry table.
*/

FLOAT Band2Tb8[LspCbSize*4] = {
	(F) 0,  (F)0,  (F)0,  (F)0,
	(F) 4.69531,  (F)4,  (F)-4.23438,  (F)2.60938,
	(F) 3.34375,  (F)8.49219,  (F)-3.78125,  (F)-1.03125,
	(F) 5.09375,  (F)4.85938,  (F)-3.05469,  (F)-4.46875,
	(F) 2.95312,  (F)6.24219,  (F)1.10156,  (F)-6.71875,
	(F) 8.125,  (F)3.19531,  (F)0.875,  (F)-4.32812,
	(F) 8.77344,  (F)5.23438,  (F)-0.585938,  (F)-6.61719,
	(F) 11.1016,  (F)3.85938,  (F)-2.46094,  (F)-8.55469,
	(F) 6.14844,  (F)7.82031,  (F)0.890625,  (F)-3.59375,
	(F) 7.71875,  (F)13.0625,  (F)1.6875,  (F)-5.32031,
	(F) 7.86719,  (F)9.69531,  (F)-1.03125,  (F)-9.74219,
	(F) 8.38281,  (F)3.11719,  (F)1.45312,  (F)-0.0390625,
	(F) 9.85938,  (F)1.50781,  (F)-5.42188,  (F)-1.00781,
	(F) 2.53906,  (F)1.53125,  (F)0.398438,  (F)-5.00781,
	(F) 6.72656,  (F)-0.460938,  (F)2.73438,  (F)-3.57812,
	(F) 9.85156,  (F)4.42969,  (F)4.57812,  (F)-2.70312,
	(F) 11.9688,  (F)6.91406,  (F)1.64062,  (F)-4.03906,
	(F) 15.8359,  (F)7.32031,  (F)0.882812,  (F)-6.1875,
	(F) 10.8047,  (F)8.3125,  (F)2.60938,  (F)0.296875,
	(F) 15.3438,  (F)11.4688,  (F)3.58594,  (F)1.03906,
	(F) 16.1094,  (F)9.26562,  (F)-0.765625,  (F)-0.945312,
	(F) 20.1328,  (F)11.2891,  (F)3.95312,  (F)-2.91406,
	(F) 18.0469,  (F)13.1406,  (F)-0.015625,  (F)-7.5,
	(F) 22.4688,  (F)15.1484,  (F)5.97656,  (F)1.07812,
	(F) 27.9766,  (F)18.4375,  (F)5.07031,  (F)-3.23438,
	(F) 1.71094,  (F)1.375,  (F)-3.10938,  (F)-2.41406,
	(F) 3.39062,  (F)-0.609375,  (F)-3.39844,  (F)-6.875,
	(F)-2.6875,  (F)2.35156,  (F)2.07031,  (F)-4.3125,
	(F)-7.14844,  (F)3.67188,  (F)5.13281,  (F)-2.96875,
	(F) 3.27344,  (F)-3.375,  (F)-1.27344,  (F)-3.53906,
	(F) 2.74219,  (F)-7.44531,  (F)0.0625,  (F)-4.39062,
	(F) 6.16406,  (F)-0.335938,  (F)0.15625,  (F)-7.48438,
	(F) 2.35938,  (F)-4.64062,  (F)-2.75,  (F)-9.05469,
	(F) 8.125,  (F)0.84375,  (F)-5.21875,  (F)-7.21875,
	(F) 10.4141,  (F)1.64062,  (F)-9.50781,  (F)-12.9922,
	(F) 3.77344,  (F)4.60156,  (F)-2.73438,  (F)-8.90625,
	(F) 7.83594,  (F)6.4375,  (F)-6.26562,  (F)-9.25,
	(F) 5.82031,  (F)0.453125,  (F)-4.60156,  (F)-11.2734,
	(F) 2.70312,  (F)1.92969,  (F)-7.14844,  (F)-13.1484,
	(F) 2.10938,  (F)6.21875,  (F)-5.625,  (F)-15.9609,
	(F) 9.4375,  (F)5.64062,  (F)-1.73438,  (F)-1.50781,
	(F) 11.6094,  (F)9.21875,  (F)-3.21875,  (F)-5.25,
	(F) 13.4531,  (F)1.39844,  (F)-0.539062,  (F)-4.07031,
	(F) 15.9922,  (F)6.71875,  (F)-5.20312,  (F)-11.0156,
	(F)-1.14062,  (F)1.73438,  (F)-2.19531,  (F)-6.28906,
	(F)-1.47656,  (F)0.703125,  (F)-0.890625,  (F)-10.2109,
	(F)-1.1875,  (F)8.48438,  (F)-1.88281,  (F)-5.96875,
	(F)-3.42969,  (F)5.72656,  (F)-4.69531,  (F)-10.1719,
	(F)-6.50781,  (F)-1.30469,  (F)-2.74219,  (F)-4.69531,
	(F)-6.6875,  (F)-3.29688,  (F)-3.21094,  (F)-8.27344,
	(F)-5.83594,  (F)-2.77344,  (F)-4.54688,  (F)-12.8438,
	(F)-6.53906,  (F)1.64062,  (F)-7.15625,  (F)-8.9375,
	(F)-14.0625,  (F)0.25,  (F)-6.85938,  (F)-13.1797,
	(F)-0.375,  (F)-0.179688,  (F)-8.95312,  (F)0.40625,
	(F)-2.73438,  (F)-3.19531,  (F)-12.9375,  (F)-2.84375,
	(F) 2.07031,  (F)-5.6875,  (F)-6.70312,  (F)-4.50781,
	(F) 3.57812,  (F)-1.92969,  (F)-8.91406,  (F)-7.78906,
	(F) 5.39844,  (F)-3.17969,  (F)-15.5312,  (F)-9.07031,
	(F)-0.515625,  (F)-0.8125,  (F)-5.50781,  (F)-9.75781,
	(F)-3.36719,  (F)-0.726562,  (F)-9.30469,  (F)-14.4062,
	(F) 1.58594,  (F)-5.71875,  (F)-7.8125,  (F)-13.2266,
	(F) 0.078125,  (F)-6.5,  (F)-14.4219,  (F)-14.2109,
	(F) 3.85156,  (F)-1,  (F)-11.2188,  (F)-13.8125,
	(F) 3.8125,  (F)-2.42969,  (F)-13.5156,  (F)-19.8438,
	(F)-5.10156,  (F)-4.15625,  (F)-8.98438,  (F)-9.15625,
	(F)-8.48438,  (F)-2.25781,  (F)-13.3281,  (F)-11.9766,
	(F)-5.46094,  (F)-9.41406,  (F)-9.5,  (F)-13.7969,
	(F)-8.0625,  (F)-11.5703,  (F)-16.2031,  (F)-11.8984,
	(F)-5.63281,  (F)-9.53125,  (F)-17.7891,  (F)-20.3125,
	(F) 0.09375,  (F)-4.21094,  (F)-11.5938,  (F)-8.83594,
	(F)-0.3125,  (F)-7.11719,  (F)-16.4531,  (F)-3.44531,
	(F)-3.67969,  (F)-3.78125,  (F)-17.7109,  (F)-12.1016,
	(F)-1.10156,  (F)-7.71875,  (F)-23.4844,  (F)-13.4453,
	(F)-12.0703,  (F)-16.4219,  (F)-4.55469,  (F)2.67188,
	(F)-10.8047,  (F)-21.6562,  (F)-3.01562,  (F)-0.101562,
	(F)-16.5469,  (F)-20.2266,  (F)-9.41406,  (F)0.5625,
	(F)-16.7734,  (F)-25.2422,  (F)-7.53906,  (F)3.04688,
	(F)-23.0391,  (F)-25.7812,  (F)-4.85156,  (F)4.97656,
	(F)-30.5234,  (F)-32.3281,  (F)-6.75781,  (F)6.27344,
	(F)-10.0547,  (F)-6.60156,  (F)-2.92969,  (F)-4.28125,
	(F)-11.0625,  (F)-9.13281,  (F)-3.80469,  (F)-9.97656,
	(F)-10.9375,  (F)-13.2031,  (F)-8.02344,  (F)-3.26562,
	(F)-15.7656,  (F)-14.9141,  (F)-9.28125,  (F)-9.84375,
	(F)-11.0781,  (F)-17.3594,  (F)-15.8516,  (F)-1,
	(F)-16.1484,  (F)-23.4219,  (F)-21.0391,  (F)-2.42188,
	(F)-7.42188,  (F)-8.03125,  (F)-12.0156,  (F)1.44531,
	(F)-12.625,  (F)-7.14844,  (F)-17.2266,  (F)-4.28906,
	(F) 0.148438,  (F)-6.41406,  (F)-8.94531,  (F)2.75,
	(F) 1.4375,  (F)-9.17969,  (F)-10.5938,  (F)-4.89844,
	(F)-4.27344,  (F)-8.5,  (F)-12.9766,  (F)-7.11719,
	(F)-1.6875,  (F)-11.7344,  (F)-17.1641,  (F)-7.40625,
	(F)-6.21094,  (F)-10.2031,  (F)-18.5469,  (F)-3.52344,
	(F)-7.21875,  (F)-14.7578,  (F)-21.8438,  (F)-5.3125,
	(F)-4.6875,  (F)-12.6094,  (F)-28.1953,  (F)-6.91406,
	(F)-18.6875,  (F)-19.75,  (F)2.49219,  (F)2.36719,
	(F)-22.7188,  (F)-16.3672,  (F)-2.42188,  (F)4.47656,
	(F)-27.0312,  (F)-16.7266,  (F)0.382812,  (F)-0.882812,
	(F)-17.4297,  (F)-3.5,  (F)5.27344,  (F)-1.14062,
	(F)-21.9141,  (F)-4.15625,  (F)9.61719,  (F)3.74219,
	(F)-20.9688,  (F)-3.79688,  (F)-1.5625,  (F)4.77344,
	(F)-27.5391,  (F)-7.58594,  (F)-1.54688,  (F)5.5,
	(F)-28.9609,  (F)1.35156,  (F)2.72656,  (F)1.98438,
	(F)-36.9844,  (F)-11.3047,  (F)-0.265625,  (F)6.875,
	(F) 6.07031,  (F)-4,  (F)0.890625,  (F)-0.078125,
	(F) 9.76562,  (F)-0.515625,  (F)3.45312,  (F)-0.0390625,
	(F) 4.71875,  (F)4.78906,  (F)3.53125,  (F)-2.75,
	(F) 9.5625,  (F)6.07031,  (F)5.27344,  (F)-7.92188,
	(F)-10.7188,  (F)-0.617188,  (F)-9.4375,  (F)-1.85938,
	(F)-18.6641,  (F)-0.132812,  (F)-9.03906,  (F)-6.39062,
	(F)-11.75,  (F)-5.25781,  (F)-8.85156,  (F)-8.28125,
	(F)-15.5,  (F)-6.24219,  (F)-15.6641,  (F)-15.4141,
	(F)-15.9141,  (F)-6.23438,  (F)-8.34375,  (F)-0.820312,
	(F)-24.9219,  (F)-7.02344,  (F)-14.1953,  (F)-1.51562,
	(F)-1.21875,  (F)-6.92188,  (F)3.07812,  (F)-2.48438,
	(F)-2.01562,  (F)-10.0234,  (F)4.30469,  (F)1.57812,
	(F)-4.1875,  (F)-13.5078,  (F)7.10938,  (F)2.58594,
	(F)-6.61719,  (F)-8.66406,  (F)6.21094,  (F)-1.27344,
	(F)-9.14844,  (F)-8.8125,  (F)5.58594,  (F)4.05469,
	(F)-8.4375,  (F)-10.3047,  (F)13.1641,  (F)5.21875,
	(F)-7.8125,  (F)-15.0078,  (F)0.75,  (F)1.64844,
	(F)-11.6172,  (F)-16.7812,  (F)6.49219,  (F)1.35938,
	(F)-8.89844,  (F)-2.92188,  (F)3.23438,  (F)-0.03125,
	(F)-11.8516,  (F)-10.8047,  (F)3.09375,  (F)-2.75,
	(F)-7.90625,  (F)3.42969,  (F)-0.460938,  (F)-7.55469,
	(F)-14.1562,  (F)5.51562,  (F)-3.4375,  (F)-8.04688,
	(F)-15.3984,  (F)-2.57031,  (F)-0.265625,  (F)-6.46094,
	(F)-19.3125,  (F)-12.4062,  (F)-1.17969,  (F)-4.73438,
	(F)-16.8828,  (F)2.92188,  (F)-2.19531,  (F)0.59375,
	(F)-23.5312,  (F)1.80469,  (F)-0.117188,  (F)-5.39062,
	(F) 8.625,  (F)4.42188,  (F)5.63281,  (F)1.63281,
	(F) 13.1641,  (F)4.40625,  (F)2.99219,  (F)0.765625,
	(F) 14.8281,  (F)5.85938,  (F)6.1875,  (F)-0.757812,
	(F) 4.34375,  (F)-0.5,  (F)4.38281,  (F)-0.726562,
	(F) 6.84375,  (F)1.26562,  (F)7.13281,  (F)-0.171875,
	(F) 7.50781,  (F)5.27344,  (F)10.125,  (F)1.09375,
	(F) 5.90625,  (F)-3.09375,  (F)6.64844,  (F)4.25,
	(F) 2.8125,  (F)-2.36719,  (F)10.4766,  (F)3.09375,
	(F) 6.85938,  (F)-0.171875,  (F)11.4375,  (F)6.74219,
	(F)-2.41406,  (F)-2.13281,  (F)5.01562,  (F)-1.00781,
	(F)-5.35938,  (F)-0.640625,  (F)6.57812,  (F)3.54688,
	(F)-0.0390625,  (F)-0.367188,  (F)8.35156,  (F)7.79688,
	(F)-0.734375,  (F)7.55469,  (F)9.97656,  (F)2.32812,
	(F)-3.82031,  (F)3.00781,  (F)11.5078,  (F)5.82812,
	(F)-2.88281,  (F)-5.60156,  (F)10.4141,  (F)1.89062,
	(F) 2.19531,  (F)-7.75781,  (F)13.4844,  (F)7.21875,
	(F) 3.625,  (F)4.69531,  (F)12.3047,  (F)10.75,
	(F)-1.95312,  (F)1.60938,  (F)18.2734,  (F)9.17969,
	(F)-3.42188,  (F)2.94531,  (F)-4.66406,  (F)-2.22656,
	(F)-7.96875,  (F)6.14844,  (F)-6.17188,  (F)-2.24219,
	(F)-3.57812,  (F)-3.20312,  (F)1.67969,  (F)2.30469,
	(F)-4.60156,  (F)-6.71875,  (F)-0.945312,  (F)6.22656,
	(F)-9.17969,  (F)0.953125,  (F)-3.41406,  (F)3.64062,
	(F)-11.5625,  (F)-0.945312,  (F)2.86719,  (F)7.21875,
	(F) 1.82812,  (F)2.52344,  (F)6.01562,  (F)-4.33594,
	(F) 1.13281,  (F)0.234375,  (F)7.78125,  (F)0.203125,
	(F) 0.515625,  (F)6.63281,  (F)0.726562,  (F)-1.13281,
	(F)-0.914062,  (F)9.85156,  (F)3.70312,  (F)-3.11719,
	(F)-11.6797,  (F)8.21094,  (F)1.70312,  (F)-3.95312,
	(F)-10.8594,  (F)5.42188,  (F)7.76562,  (F)0.6875,
	(F) 4.8125,  (F)0.0546875,  (F)0.609375,  (F)2.375,
	(F) 8.28125,  (F)0.40625,  (F)-0.484375,  (F)6.52344,
	(F) 6.50781,  (F)3.54688,  (F)5.07031,  (F)10.6172,
	(F)-6.01562,  (F)3.625,  (F)0.367188,  (F)0.726562,
	(F)-4.48438,  (F)9.36719,  (F)-0.304688,  (F)2.96094,
	(F) 0.890625,  (F)-0.765625,  (F)3.8125,  (F)3.78906,
	(F) 5.67969,  (F)1.90625,  (F)4.73438,  (F)5.4375,
	(F)-0.59375,  (F)3.55469,  (F)5.24219,  (F)4.26562,
	(F)-4.41406,  (F)-0.101562,  (F)1.13281,  (F)6.39844,
	(F)-2.9375,  (F)4.44531,  (F)3.5,  (F)8.8125,
	(F) 1.70312,  (F)0.953125,  (F)2.07031,  (F)9.11719,
	(F) 1.79688,  (F)5.76562,  (F)7.28125,  (F)7.83594,
	(F) 1.07812,  (F)3.72656,  (F)0.28125,  (F)3.51562,
	(F) 3.15625,  (F)6.14844,  (F)-0.570312,  (F)7.8125,
	(F) 3.88281,  (F)9.83594,  (F)3.02344,  (F)9.61719,
	(F) 0.132812,  (F)1.61719,  (F)1.52344,  (F)-0.617188,
	(F) 4.39062,  (F)2.79688,  (F)0.414062,  (F)-1.23438,
	(F) 3.85156,  (F)3.02344,  (F)3.73438,  (F)1.47656,
	(F) 5.29688,  (F)6.49219,  (F)5,  (F)4.35938,
	(F)-1.53906,  (F)4.08594,  (F)4.78906,  (F)0.445312,
	(F) 3.35156,  (F)6.98438,  (F)6.00781,  (F)0.867188,
	(F) 0.523438,  (F)9.17188,  (F)4.4375,  (F)3.99219,
	(F) 9.70312,  (F)6.4375,  (F)1.96094,  (F)6.5625,
	(F) 11.0859,  (F)8.39062,  (F)6.75,  (F)3.75781,
	(F) 7.21875,  (F)11.5156,  (F)5.22656,  (F)5.65625,
	(F) 12.0234,  (F)14.6797,  (F)5.10938,  (F)12.4219,
	(F) 3.47656,  (F)2.63281,  (F)8.67969,  (F)4.22656,
	(F) 3.6875,  (F)11.1016,  (F)9.875,  (F)8.54688,
	(F) 6.20312,  (F)5.74219,  (F)8.61719,  (F)5.21875,
	(F) 8.24219,  (F)6.74219,  (F)9.3125,  (F)7.96875,
	(F) 6.07812,  (F)8.63281,  (F)6.29688,  (F)14.0469,
	(F) 8.21875,  (F)11.9297,  (F)12.3984,  (F)16.8047,
	(F) 6.88281,  (F)12.125,  (F)9.88281,  (F)3.05469,
	(F) 5.67188,  (F)6.8125,  (F)14.1562,  (F)4.69531,
	(F) 11.4766,  (F)2.1875,  (F)7.875,  (F)4.8125,
	(F) 10.9609,  (F)4.50781,  (F)14.0859,  (F)9.71875,
	(F) 12.8906,  (F)10.2656,  (F)8.96875,  (F)8.375,
	(F) 10.1328,  (F)13.0391,  (F)14.9297,  (F)8.01562,
	(F) 16.3516,  (F)8.15625,  (F)16.5234,  (F)9.28906,
	(F) 12.8438,  (F)15.3203,  (F)20.2109,  (F)11.8125,
	(F) 0.195312,  (F)-2.46094,  (F)-0.0703125,  (F)-0.828125,
	(F) 2.26562,  (F)-2.64844,  (F)3.34375,  (F)-3.46875,
	(F)-0.53125,  (F)-6.11719,  (F)5.74219,  (F)6.03125,
	(F) 1.91406,  (F)-4.33594,  (F)3.65625,  (F)0.367188,
	(F) 2.60938,  (F)-6.99219,  (F)6.35938,  (F)1.14062,
	(F) 1.83594,  (F)2.875,  (F)-7.53125,  (F)-7.49219,
	(F)-1.58594,  (F)2.46094,  (F)-12.2344,  (F)-9.50781,
	(F) 6.25781,  (F)0.132812,  (F)-2.15625,  (F)-2.76562,
	(F) 6.98438,  (F)-3.86719,  (F)-6.16406,  (F)-4.96094,
	(F) 5.59375,  (F)2.27344,  (F)-9.28906,  (F)-2.78906,
	(F) 4.375,  (F)-2.03125,  (F)-5.72656,  (F)-0.015625,
	(F) 5.30469,  (F)-3.96875,  (F)-11.1641,  (F)1.64844,
	(F)-0.398438,  (F)-0.484375,  (F)-3.34375,  (F)4.35156,
	(F) 2.51562,  (F)-4.98438,  (F)-1.64844,  (F)4.79688,
	(F)-6.85938,  (F)-8.25781,  (F)-0.65625,  (F)-0.554688,
	(F)-3.03125,  (F)-11.0547,  (F)-1.30469,  (F)-2.48438,
	(F)-5.89062,  (F)-12.2969,  (F)1.67188,  (F)-4.21094,
	(F)-11.0859,  (F)-15.6562,  (F)-0.71875,  (F)-6.14844,
	(F)-0.367188,  (F)-6.6875,  (F)-2.71094,  (F)-1.99219,
	(F) 0.179688,  (F)-9.46094,  (F)-1.35156,  (F)2.5,
	(F)-5.14062,  (F)-3.80469,  (F)-6.97656,  (F)2.75781,
	(F)-6.11719,  (F)-12.3984,  (F)-4.5625,  (F)3.96094,
	(F)-11.0938,  (F)-6.71094,  (F)-2.95312,  (F)3.44531,
	(F)-16.3672,  (F)-11.6484,  (F)-1.07031,  (F)3.42969,
	(F)-2.50781,  (F)-11.3281,  (F)-10.0625,  (F)-0.09375,
	(F)-2.80469,  (F)-16.5078,  (F)-4.32031,  (F)-0.0625,
	(F)-6.49219,  (F)-14.9844,  (F)-12.1953,  (F)0.25,
	(F)-7.92188,  (F)-19.4297,  (F)-10.6172,  (F)-7.33594,
	(F)-3.71094,  (F)-2.42969,  (F)-1.32031,  (F)-1.84375,
	(F)-7.08594,  (F)-3.32812,  (F)2.15625,  (F)-4.77344,
	(F)-0.75,  (F)-3.125,  (F)0.390625,  (F)-5.54688,
	(F)-3.32812,  (F)-7.98438,  (F)-0.078125,  (F)-7.69531,
	(F)-1.53906,  (F)-2.01562,  (F)-5.8125,  (F)-4.49219,
	(F)-4.77344,  (F)-7.26562,  (F)-6.02344,  (F)-3.07812,
	(F)-2.08594,  (F)-6.0625,  (F)-4.78125,  (F)-7.33594,
	(F)-2,  (F)-10.5156,  (F)-6.26562,  (F)-8.76562,
	(F)-6.21875,  (F)-12.2656,  (F)-6.44531,  (F)-5.89062,
	(F) 5.5625,  (F)6.84375,  (F)1.10156,  (F)1.77344,
	(F) 7.66406,  (F)11.7891,  (F)0.664062,  (F)0.96875,
	(F) 11.4219,  (F)9.59375,  (F)7.64844,  (F)-0.304688,
	(F) 13.5469,  (F)7.80469,  (F)11.5703,  (F)3.4375,
	(F) 17.9141,  (F)8.71875,  (F)6.00781,  (F)3.4375,
	(F) 19.5625,  (F)11.5625,  (F)9.69531,  (F)2.78125,
	(F) 19.3281,  (F)14.9141,  (F)12.1719,  (F)6.32812,
	(F) 7.16406,  (F)8.85938,  (F)4.74219,  (F)-1.04688,
	(F) 3.97656,  (F)14.1328,  (F)6.10156,  (F)-0.960938,
	(F) 13.375,  (F)11.7656,  (F)4.36719,  (F)-3.30469,
	(F) 15.9141,  (F)18.1016,  (F)5.67188,  (F)-1.21094,
	(F) 23.6797,  (F)20.9062,  (F)9.39844,  (F)2.58594,
	(F) 28.625,  (F)25.5781,  (F)13.8125,  (F)4.14844,
	(F) 12.5781,  (F)14.3672,  (F)6.77344,  (F)1.42969,
	(F) 13.8594,  (F)15.4062,  (F)12.0156,  (F)0.757812,
	(F) 14.2344,  (F)16.8594,  (F)10.0156,  (F)5.14844,
	(F) 17.3594,  (F)21.5469,  (F)14.2031,  (F)7.03125,
	(F) 25.3984,  (F)16.5938,  (F)13.4609,  (F)7.78125,
	(F) 28.3828,  (F)18.25,  (F)18.8125,  (F)11.3516,
	(F) 22.8359,  (F)27.4766,  (F)20.0547,  (F)10.2969,
};

/*
**  BandQntTable:
**
**  Purpose:
**      collects the three subvector tables.
*/

FLOAT *BandQntTable[LspQntBands] = {
   Band0Tb8 ,
   Band1Tb8 ,
   Band2Tb8 ,
   };

/*
**  PerFiltZeroTable:
**
**  Purpose:
**     Creates the FIR part of the formant perceptual weighting filter. 
**     Corresponds to gamma1 in section 2.8.
**
**  Table Structure:
**     (0.9) to the x power, where x = [1,..,10]
*/
 
FLOAT PerFiltZeroTable[LpcOrder] = {
   (F)0.9 ,
   (F)0.81 ,
   (F)0.729 ,
   (F)0.6561 ,
   (F)0.59049 ,
   (F)0.531441 ,
   (F)0.4781969 ,
   (F)0.43046721 ,
   (F)0.38742049 ,
   (F)0.34867844 ,
};

/*
**  PerFiltPoleTable:
**
**  Purpose:
**     Creates the IIR part of the formant perceptual weighting filter. 
**     Corresponds to gamma2 in section 2.8.
**
**  Table Structure:
**     (0.5) to the x power, where x = [1,..,10]
*/

FLOAT PerFiltPoleTable[LpcOrder] = {
   (F)0.5 ,
   (F)0.25 ,
   (F)0.125 ,
   (F)0.0625 ,
   (F)0.03125 ,
   (F)0.015625 ,
   (F)0.0078125 ,
   (F)0.00390625 ,
   (F)0.001953125 ,
   (F)0.0009765625 ,
};

/*
**  PostFiltZeroTable:
**
**  Purpose:
**     Creates the FIR part of the formant postfilter.  Corresponds to
**     lambda1 in section 3.8.
**
**  Table Structure:
**     (0.65) to the x power, where x = [1,..,10]
*/

//Code removed

/*
**  PostFiltPoleTable:
**
**  Purpose:
**     Creates the IIR part of the formant postfilter.  Corresponds to
**     lambda2 in section 3.8.
**
**  Table Structure:
**     (0.75) to the x power, where x = [1,..,10]
*/

//Code removed

/*
**  Nb_puls:
**
**  Purpose:
**      Indexing
**
**  Table Structure:
**      Table values are the number of non-zero pulses in the high-rate
**      excitation (MP-MLQ), indexed by subframe number (0,..,3).
*/

int Nb_puls[4] = { 6,5,6,5};

/*
**  FcbkGainTable:
**
**  Purpose:
**      Logarithmic scalar quantizer in 24 steps of 3.2 dB each
**
**  Table Structure:
**      Contains x where 20*log10(x) = 3.2*i,  i = 1,..,24
*/

float FcbkGainTable[NumOfGainLev] = {
    1.0f,
    2.0f,
    3.0f,
    4.0f,
    6.0f,
    9.0f,
   13.0f,
   18.0f,
   26.0f,
   38.0f,
   55.0f,
   80.0f,
  115.0f,
  166.0f,
  240.0f,
  348.0f,
  502.0f,
  726.0f,
 1050.0f,
 1517.0f,
 2193.0f,
 3170.0f,
 4582.0f,
 6623.0f,
   };

/*
**  MaxPosTable:
**
**  Purpose:
**      size of the high rate fixed excitation codebooks (MP-MLQ)
**
**  Table Structure:
**      Table values are the number of codewords in the high rate fixed
**      excitation codebook (MP-MLQ), indexed by subframe number (0,..,3).
**      MaxPosTable[i] is the number of combinations of i elements among 30
**      non-zero pulses in the high-rate
*/

Word32   MaxPosTable[4] = {
 0x00090f6fL,
 0x00022caaL,
 0x00090f6fL,
 0x00022caaL,
};

/*
**  CombinatorialTable:
**
**  Purpose:
**      used for the coding and the decoding of the pulses positions
**      for the high-rate fixed excitation codebook
**
**  Table Structure:
**      CombinatorialTable[i][j] is the number of combinations of
**      (MaxPulsNum-1-i) elements among (SubFrLen-2-j)
*/

Word32   CombinatorialTable[MaxPulseNum][SubFrLen/Sgrid] = {
 { 118755L,
  98280L,
  80730L,
  65780L,
  53130L,
  42504L,
  33649L,
  26334,
  20349,
  15504,
  11628,
   8568,
   6188,
   4368,
   3003,
   2002,
   1287,
    792,
	462,
    252,
	126,
     56,
     21,
      6,
      1,
      0,
      0,
	  0,
      0,
	  0 },

 { 23751,
  20475,
  17550,
  14950,
  12650,
  10626,
   8855,
   7315,
   5985,
   4845,
   3876,
   3060,
   2380,
   1820,
   1365,
   1001,
	715,
    495,
	330,
    210,
    126,
     70,
     35,
     15,
      5,
	  1,
      0,
	  0,
	  0,
	  0 },

  { 3654,
   3276,
   2925,
   2600,
   2300,
   2024,
   1771,
   1540,
   1330,
   1140,
    969,
    816,
	680,
    560,
    455,
    364,
	286,
    220,
	165,
    120,
     84,
	 56,
     35,
     20,
     10,
	  4,
      1,
	  0,
      0,
	  0 },

   {  406,
	378,
	351,
	325,
	300,
	276,
    253,
	231,
	210,
    190,
	171,
    153,
    136,
    120,
    105,
     91,
	 78,
	 66,
     55,
	 45,
     36,
     28,
     21,
     15,
     10,
	  6,
	  3,
	  1,
	  0,
	  0 },

   {   29,
     28,
     27,
	 26,
	 25,
     24,
	 23,
	 22,
     21,
	 20,
     19,
     18,
     17,
	 16,
     15,
     14,
	 13,
     12,
	 11,
     10,
      9,
      8,
	  7,
      6,
      5,
	  4,
      3,
	  2,
      1,
	  0  },

   {    1,
	  1,
	  1,
	  1,
	  1,
	  1,
      1,
      1,
      1,
      1,
      1,
      1,
	  1,
      1,
	  1,
      1,
      1,
      1,
      1,
      1,
      1,
	  1,
      1,
	  1,
      1,
      1,
      1,
      1,
      1,
	  1 }
   };

/*
**  AcbkGainTable085:
**
**  Purpose:
**      Used to calculate the error expression in pitch prediction
**      optimization (also described as an adaptive codebook approach)
**
**      Table Structure:
**      The table is structured as 85 20-element vectors.  These
**      vectors are structured as precalculated values in the error
**      expression for the pitch predictor.  Gi is the gain value
**      multiplying the signal delayed by a pitch period (+/- offset).
**      In equation 41.2, Gi would be equivalent to bij.
**      
**      1st 5 elements:   G1  G2  G3  G4  G5 in Q14
**      2nd 5 elements:  -G1^2  -G2^2  -G3^2  -G4^2  -G5^2
**      Next 10 elements: These are the off-diagonal elements
**           -G1*G2  -G1*G3  -G2*G3  -G1*G4  -G2*G4
**           -G3*G4  -G1*G5  -G2*G5  -G3*G5  -G4*G5
*/

 FLOAT   AcbkGainTable085[85*20] = {
 (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, 
(F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, 
(F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, 
(F)0.000000, (F)0.000000, 
(F)0.048828, (F)0.091309, (F)0.010193, (F)-0.015625, (F)-0.020630, (F)-0.002384, 
(F)-0.008337, (F)-0.000104, (F)-0.000244, (F)-0.000426, (F)-0.004458, (F)-0.000498, 
(F)-0.000931, (F)0.000763, (F)0.001427, (F)0.000159, (F)0.001007, (F)0.001884, 
(F)0.000210, (F)-0.000322, 
(F)-0.028198, (F)-0.041870, (F)0.030090, (F)0.157166, (F)0.018982, (F)-0.000795, 
(F)-0.001753, (F)-0.000905, (F)-0.024701, (F)-0.000360, (F)-0.001181, (F)0.000848, 
(F)0.001260, (F)0.004432, (F)0.006581, (F)-0.004729, (F)0.000535, (F)0.000795, 
(F)-0.000571, (F)-0.002983, 
(F)0.090515, (F)0.008789, (F)0.047852, (F)0.056641, (F)0.075867, (F)-0.008193, 
(F)-0.000077, (F)-0.002290, (F)-0.003208, (F)-0.005756, (F)-0.000796, (F)-0.004331, 
(F)-0.000421, (F)-0.005127, (F)-0.000498, (F)-0.002710, (F)-0.006867, (F)-0.000667, 
(F)-0.003630, (F)-0.004297, 
(F)-0.004700, (F)0.016785, (F)0.214966, (F)0.064453, (F)-0.076538, (F)-0.000022, 
(F)-0.000282, (F)-0.046210, (F)-0.004154, (F)-0.005858, (F)0.000079, (F)0.001010, 
(F)-0.003608, (F)0.000303, (F)-0.001082, (F)-0.013855, (F)-0.000360, (F)0.001285, 
(F)0.016453, (F)0.004933, 
(F)-0.007629, (F)-0.002441, (F)-0.016113, (F)0.023254, (F)0.306824, (F)-0.000058, 
(F)-0.000006, (F)-0.000260, (F)-0.000541, (F)-0.094141, (F)-0.000019, (F)-0.000123, 
(F)-0.000039, (F)0.000177, (F)0.000057, (F)0.000375, (F)0.002341, (F)0.000749, 
(F)0.004944, (F)-0.007135, 
(F)0.008423, (F)0.020264, (F)0.135193, (F)0.157104, (F)0.081726, (F)-0.000071, 
(F)-0.000411, (F)-0.018277, (F)-0.024682, (F)-0.006679, (F)-0.000171, (F)-0.001139, 
(F)-0.002740, (F)-0.001323, (F)-0.003184, (F)-0.021239, (F)-0.000688, (F)-0.001656, 
(F)-0.011049, (F)-0.012840, 
(F)0.224915, (F)0.175964, (F)-0.054138, (F)0.052856, (F)-0.100037, (F)-0.050587, 
(F)-0.030963, (F)-0.002931, (F)-0.002794, (F)-0.010007, (F)-0.039577, (F)0.012176, 
(F)0.009526, (F)-0.011888, (F)-0.009301, (F)0.002862, (F)0.022500, (F)0.017603, 
(F)-0.005416, (F)0.005288, 
(F)0.085205, (F)0.130981, (F)0.136414, (F)0.021057, (F)0.057495, (F)-0.007260, 
(F)-0.017156, (F)-0.018609, (F)-0.000443, (F)-0.003306, (F)-0.011160, (F)-0.011623, 
(F)-0.017868, (F)-0.001794, (F)-0.002758, (F)-0.002872, (F)-0.004899, (F)-0.007531, 
(F)-0.007843, (F)-0.001211, 
(F)0.000793, (F)0.273132, (F)0.216614, (F)-0.049072, (F)-0.039978, (F)-0.000001, 
(F)-0.074601, (F)-0.046922, (F)-0.002408, (F)-0.001598, (F)-0.000217, (F)-0.000172, 
(F)-0.059164, (F)0.000039, (F)0.013403, (F)0.010630, (F)0.000032, (F)0.010919, 
(F)0.008660, (F)-0.001962, 
(F)-0.044189, (F)0.015503, (F)0.014771, (F)0.369202, (F)0.150269, (F)-0.001953, 
(F)-0.000240, (F)-0.000218, (F)-0.136310, (F)-0.022581, (F)0.000685, (F)0.000653, 
(F)-0.000229, (F)0.016315, (F)-0.005724, (F)-0.005453, (F)0.006640, (F)-0.002330, 
(F)-0.002220, (F)-0.055479, 
(F)0.038208, (F)-0.104553, (F)0.373596, (F)0.278381, (F)-0.064758, (F)-0.001460, 
(F)-0.010931, (F)-0.139574, (F)-0.077496, (F)-0.004194, (F)0.003995, (F)-0.014274, 
(F)0.039061, (F)-0.010636, (F)0.029106, (F)-0.104002, (F)0.002474, (F)-0.006771, 
(F)0.024193, (F)0.018028, 
(F)-0.021362, (F)0.084900, (F)0.487366, (F)0.031189, (F)-0.024719, (F)-0.000456, 
(F)-0.007208, (F)-0.237525, (F)-0.000973, (F)-0.000611, (F)0.001814, (F)0.010411, 
(F)-0.041377, (F)0.000666, (F)-0.002648, (F)-0.015200, (F)-0.000528, (F)0.002099, 
(F)0.012047, (F)0.000771, 
(F)0.191895, (F)-0.032288, (F)0.037109, (F)0.154419, (F)0.236694, (F)-0.036824, 
(F)-0.001042, (F)-0.001377, (F)-0.023845, (F)-0.056024, (F)0.006196, (F)-0.007121, 
(F)0.001198, (F)-0.029632, (F)0.004986, (F)-0.005730, (F)-0.045420, (F)0.007642, 
(F)-0.008784, (F)-0.036550, 
(F)0.158020, (F)-0.042053, (F)0.185852, (F)0.341980, (F)-0.024658, (F)-0.024970, 
(F)-0.001768, (F)-0.034541, (F)-0.116950, (F)-0.000608, (F)0.006645, (F)-0.029368, 
(F)0.007816, (F)-0.054040, (F)0.014381, (F)-0.063558, (F)0.003896, (F)-0.001037, 
(F)0.004583, (F)0.008433, 
(F)0.189636, (F)0.031311, (F)0.083862, (F)-0.219360, (F)-0.300415, (F)-0.035962, 
(F)-0.000980, (F)-0.007033, (F)-0.048119, (F)-0.090249, (F)-0.005938, (F)-0.015903, 
(F)-0.002626, (F)0.041599, (F)0.006868, (F)0.018396, (F)0.056970, (F)0.009406, 
(F)0.025193, (F)-0.065899, 
(F)0.150635, (F)0.366821, (F)0.067566, (F)-0.023804, (F)0.119690, (F)-0.022691, 
(F)-0.134558, (F)-0.004565, (F)-0.000567, (F)-0.014326, (F)-0.055256, (F)-0.010178, 
(F)-0.024785, (F)0.003586, (F)0.008732, (F)0.001608, (F)-0.018029, (F)-0.043905, 
(F)-0.008087, (F)0.002849, 
(F)0.291321, (F)0.168823, (F)0.144531, (F)0.296753, (F)-0.246826, (F)-0.084868, 
(F)-0.028501, (F)-0.020889, (F)-0.088062, (F)-0.060923, (F)-0.049182, (F)-0.042105, 
(F)-0.024400, (F)-0.086450, (F)-0.050099, (F)-0.042890, (F)0.071906, (F)0.041670, 
(F)0.035674, (F)0.073246, 
(F)0.101624, (F)-0.114685, (F)0.088074, (F)0.103821, (F)0.522583, (F)-0.010327, 
(F)-0.013153, (F)-0.007757, (F)-0.010779, (F)-0.273093, (F)0.011655, (F)-0.008950, 
(F)0.010101, (F)-0.010551, (F)0.011907, (F)-0.009144, (F)-0.053107, (F)0.059932, 
(F)-0.046026, (F)-0.054255, 
(F)0.165771, (F)0.549988, (F)-0.061462, (F)0.046082, (F)-0.108948, (F)-0.027480, 
(F)-0.302487, (F)-0.003778, (F)-0.002124, (F)-0.011870, (F)-0.091172, (F)0.010189, 
(F)0.033804, (F)-0.007639, (F)-0.025344, (F)0.002832, (F)0.018060, (F)0.059920, 
(F)-0.006696, (F)0.005020, 
(F)-0.166443, (F)0.460693, (F)0.078430, (F)0.057251, (F)0.208740, (F)-0.027703, 
(F)-0.212238, (F)-0.006151, (F)-0.003278, (F)-0.043572, (F)0.076679, (F)0.013054, 
(F)-0.036132, (F)0.009529, (F)-0.026375, (F)-0.004490, (F)0.034743, (F)-0.096165, 
(F)-0.016372, (F)-0.011951, 
(F)0.224426, (F)0.053833, (F)0.247192, (F)0.073364, (F)0.141785, (F)-0.050367, 
(F)-0.002898, (F)-0.061104, (F)-0.005382, (F)-0.020103, (F)-0.012082, (F)-0.055476, 
(F)-0.013307, (F)-0.016465, (F)-0.003949, (F)-0.018135, (F)-0.031820, (F)-0.007633, 
(F)-0.035048, (F)-0.010402, 
(F)0.124878, (F)-0.045959, (F)0.007446, (F)0.616577, (F)0.036804, (F)-0.015594, 
(F)-0.002112, (F)-0.000055, (F)-0.380167, (F)-0.001355, (F)0.005739, (F)-0.000930, 
(F)0.000342, (F)-0.076997, (F)0.028338, (F)-0.004591, (F)-0.004596, (F)0.001692, 
(F)-0.000274, (F)-0.022693, 
(F)0.027405, (F)-0.110779, (F)0.652466, (F)0.236206, (F)-0.032166, (F)-0.000751, 
(F)-0.012272, (F)-0.425712, (F)-0.055793, (F)-0.001035, (F)0.003036, (F)-0.017881, 
(F)0.072279, (F)-0.006473, (F)0.026167, (F)-0.154116, (F)0.000881, (F)-0.003563, 
(F)0.020987, (F)0.007598, 
(F)-0.057434, (F)0.143555, (F)0.308167, (F)0.222778, (F)0.160950, (F)-0.003299, 
(F)-0.020608, (F)-0.094967, (F)-0.049630, (F)-0.025905, (F)0.008245, (F)0.017699, 
(F)-0.044239, (F)0.012795, (F)-0.031981, (F)-0.068653, (F)0.009244, (F)-0.023105, 
(F)-0.049599, (F)-0.035856, 
(F)-0.114685, (F)0.048584, (F)0.190247, (F)0.584045, (F)-0.024658, (F)-0.013153, 
(F)-0.002360, (F)-0.036194, (F)-0.341109, (F)-0.000608, (F)0.005572, (F)0.021818, 
(F)-0.009243, (F)0.066981, (F)-0.028375, (F)-0.111113, (F)-0.002828, (F)0.001198, 
(F)0.004691, (F)0.014402, 
(F)-0.104675, (F)0.124695, (F)-0.127930, (F)0.607056, (F)0.244202, (F)-0.010957, 
(F)-0.015549, (F)-0.016366, (F)-0.368517, (F)-0.059634, (F)0.013052, (F)-0.013391, 
(F)0.015952, (F)0.063544, (F)-0.075697, (F)0.077660, (F)0.025562, (F)-0.030451, 
(F)0.031241, (F)-0.148244, 
(F)-0.352295, (F)-0.037720, (F)-0.239319, (F)0.017334, (F)-0.192566, (F)-0.124112, 
(F)-0.001423, (F)-0.057274, (F)-0.000300, (F)-0.037082, (F)-0.013288, (F)-0.084311, 
(F)-0.009027, (F)0.006107, (F)0.000654, (F)0.004148, (F)-0.067840, (F)-0.007264, 
(F)-0.046085, (F)0.003338, 
(F)0.023315, (F)0.289795, (F)0.488464, (F)-0.125977, (F)0.134155, (F)-0.000544, 
(F)-0.083981, (F)-0.238597, (F)-0.015870, (F)-0.017998, (F)-0.006757, (F)-0.011389, 
(F)-0.141554, (F)0.002937, (F)0.036507, (F)0.061535, (F)-0.003128, (F)-0.038878, 
(F)-0.065530, (F)0.016900, 
(F)-0.052917, (F)0.184021, (F)0.727905, (F)-0.102234, (F)0.057800, (F)-0.002800, 
(F)-0.033864, (F)-0.529846, (F)-0.010452, (F)-0.003341, (F)0.009738, (F)0.038519, 
(F)-0.133950, (F)-0.005410, (F)0.018813, (F)0.074417, (F)0.003059, (F)-0.010636, 
(F)-0.042073, (F)0.005909, 
(F)-0.301086, (F)-0.026367, (F)0.412415, (F)0.230164, (F)0.082520, (F)-0.090653, 
(F)-0.000695, (F)-0.170086, (F)-0.052975, (F)-0.006809, (F)-0.007939, (F)0.124172, 
(F)0.010874, (F)0.069299, (F)0.006069, (F)-0.094923, (F)0.024846, (F)0.002176, 
(F)-0.034032, (F)-0.018993, 
(F)0.009277, (F)0.593628, (F)0.258240, (F)-0.117676, (F)0.090942, (F)-0.000086, 
(F)-0.352394, (F)-0.066688, (F)-0.013848, (F)-0.008271, (F)-0.005507, (F)-0.002396, 
(F)-0.153298, (F)0.001092, (F)0.069856, (F)0.030389, (F)-0.000844, (F)-0.053986, 
(F)-0.023485, (F)0.010702, 
(F)0.153320, (F)0.011780, (F)0.551331, (F)0.327209, (F)-0.192139, (F)-0.023507, 
(F)-0.000139, (F)-0.303965, (F)-0.107066, (F)-0.036917, (F)-0.001806, (F)-0.084530, 
(F)-0.006495, (F)-0.050168, (F)-0.003854, (F)-0.180401, (F)0.029459, (F)0.002263, 
(F)0.105932, (F)0.062870, 
(F)0.516602, (F)0.173584, (F)0.000732, (F)0.033508, (F)0.130127, (F)-0.266877, 
(F)-0.030131, (F)-0.000001, (F)-0.001123, (F)-0.016933, (F)-0.089674, (F)-0.000378, 
(F)-0.000127, (F)-0.017310, (F)-0.005817, (F)-0.000025, (F)-0.067224, (F)-0.022588, 
(F)-0.000095, (F)-0.004360, 
(F)0.130676, (F)-0.158813, (F)0.437378, (F)0.552124, (F)-0.082397, (F)-0.017076, 
(F)-0.025222, (F)-0.191299, (F)-0.304841, (F)-0.006789, (F)0.020753, (F)-0.057155, 
(F)0.069462, (F)-0.072150, (F)0.087685, (F)-0.241487, (F)0.010767, (F)-0.013086, 
(F)0.036039, (F)0.045494, 
(F)-0.014893, (F)0.016968, (F)0.812195, (F)0.074890, (F)-0.009827, (F)-0.000222, 
(F)-0.000288, (F)-0.659660, (F)-0.005609, (F)-0.000097, (F)0.000253, (F)0.012096, 
(F)-0.013781, (F)0.001115, (F)-0.001271, (F)-0.060825, (F)-0.000146, (F)0.000167, 
(F)0.007981, (F)0.000736, 
(F)-0.118835, (F)0.501526, (F)0.382629, (F)0.055969, (F)-0.156189, (F)-0.014122, 
(F)-0.251528, (F)-0.146405, (F)-0.003133, (F)-0.024395, (F)0.059599, (F)0.045470, 
(F)-0.191899, (F)0.006651, (F)-0.028070, (F)-0.021415, (F)-0.018561, (F)0.078333, 
(F)0.059762, (F)0.008742, 
(F)-0.110474, (F)0.125793, (F)-0.169739, (F)0.369629, (F)0.613892, (F)-0.012204, 
(F)-0.015824, (F)-0.028811, (F)-0.136626, (F)-0.376863, (F)0.013897, (F)-0.018752, 
(F)0.021352, (F)0.040834, (F)-0.046497, (F)0.062740, (F)0.067819, (F)-0.077224, 
(F)0.104201, (F)-0.226912, 
(F)0.477722, (F)0.559143, (F)-0.208069, (F)0.150940, (F)-0.092163, (F)-0.228218, 
(F)-0.312641, (F)-0.043293, (F)-0.022783, (F)-0.008494, (F)-0.267115, (F)0.099399, 
(F)0.116340, (F)-0.072107, (F)-0.084397, (F)0.031406, (F)0.044028, (F)0.051532, 
(F)-0.019176, (F)0.013911, 
(F)-0.087280, (F)0.507385, (F)0.582336, (F)-0.180359, (F)0.099243, (F)-0.007618, 
(F)-0.257440, (F)-0.339116, (F)-0.032529, (F)-0.009849, (F)0.044285, (F)0.050826, 
(F)-0.295469, (F)-0.015742, (F)0.091511, (F)0.105030, (F)0.008662, (F)-0.050355, 
(F)-0.057793, (F)0.017899, 
(F)0.172058, (F)-0.259216, (F)0.329041, (F)0.529358, (F)0.168213, (F)-0.029604, 
(F)-0.067193, (F)-0.108268, (F)-0.280220, (F)-0.028296, (F)0.044600, (F)-0.056614, 
(F)0.085293, (F)-0.091080, (F)0.137218, (F)-0.174180, (F)-0.028942, (F)0.043604, 
(F)-0.055349, (F)-0.089045, 
(F)0.008606, (F)0.888184, (F)0.042114, (F)0.015686, (F)-0.006836, (F)-0.000074, 
(F)-0.788870, (F)-0.001774, (F)-0.000246, (F)-0.000047, (F)-0.007644, (F)-0.000362, 
(F)-0.037405, (F)-0.000135, (F)-0.013932, (F)-0.000661, (F)0.000059, (F)0.006072, 
(F)0.000288, (F)0.000107, 
(F)0.728638, (F)-0.113464, (F)0.110229, (F)-0.058716, (F)-0.053955, (F)-0.530913, 
(F)-0.012874, (F)-0.012151, (F)-0.003448, (F)-0.002911, (F)0.082674, (F)-0.080317, 
(F)0.012507, (F)0.042783, (F)-0.006662, (F)0.006472, (F)0.039314, (F)-0.006122, 
(F)0.005947, (F)-0.003168, 
(F)0.227539, (F)0.120972, (F)0.138184, (F)0.279785, (F)0.191101, (F)-0.051774, 
(F)-0.014634, (F)-0.019095, (F)-0.078280, (F)-0.036520, (F)-0.027526, (F)-0.031442, 
(F)-0.016716, (F)-0.063662, (F)-0.033846, (F)-0.038662, (F)-0.043483, (F)-0.023118, 
(F)-0.026407, (F)-0.053467, 
(F)-0.072083, (F)0.046753, (F)0.043945, (F)0.872986, (F)-0.013184, (F)-0.005196, 
(F)-0.002186, (F)-0.001931, (F)-0.762104, (F)-0.000174, (F)0.003370, (F)0.003168, 
(F)-0.002055, (F)0.062927, (F)-0.040815, (F)-0.038364, (F)-0.000950, (F)0.000616, 
(F)0.000579, (F)0.011509, 
(F)-0.267639, (F)0.294556, (F)0.617188, (F)0.095764, (F)0.206787, (F)-0.071631, 
(F)-0.086763, (F)-0.380920, (F)-0.009171, (F)-0.042761, (F)0.078835, (F)0.165184, 
(F)-0.181796, (F)0.025630, (F)-0.028208, (F)-0.059104, (F)0.055344, (F)-0.060910, 
(F)-0.127626, (F)-0.019803, 
(F)-0.027344, (F)0.117920, (F)0.951599, (F)-0.112427, (F)0.040100, (F)-0.000748, 
(F)-0.013905, (F)-0.905541, (F)-0.012640, (F)-0.001608, (F)0.003224, (F)0.026020, 
(F)-0.112212, (F)-0.003074, (F)0.013257, (F)0.106985, (F)0.001096, (F)-0.004729, 
(F)-0.038159, (F)0.004508, 
(F)-0.252747, (F)0.112549, (F)0.241821, (F)0.336731, (F)0.379639, (F)-0.063881, 
(F)-0.012667, (F)-0.058478, (F)-0.113388, (F)-0.144126, (F)0.028446, (F)0.061120, 
(F)-0.027217, (F)0.085108, (F)-0.037899, (F)-0.081429, (F)0.095952, (F)-0.042728, 
(F)-0.091805, (F)-0.127836, 
(F)0.044495, (F)-0.140320, (F)0.900574, (F)0.223206, (F)-0.058105, (F)-0.001980, 
(F)-0.019690, (F)-0.811033, (F)-0.049821, (F)-0.003376, (F)0.006243, (F)-0.040071, 
(F)0.126368, (F)-0.009931, (F)0.031320, (F)-0.201013, (F)0.002585, (F)-0.008153, 
(F)0.052328, (F)0.012969, 
(F)-0.084534, (F)0.354065, (F)0.814148, (F)-0.191467, (F)0.082031, (F)-0.007146, 
(F)-0.125362, (F)-0.662837, (F)-0.036660, (F)-0.006729, (F)0.029930, (F)0.068823, 
(F)-0.288261, (F)-0.016185, (F)0.067792, (F)0.155883, (F)0.006934, (F)-0.029044, 
(F)-0.066786, (F)0.015706, 
(F)0.287476, (F)0.589661, (F)0.065491, (F)-0.150574, (F)0.199829, (F)-0.082642, 
(F)-0.347700, (F)-0.004289, (F)-0.022672, (F)-0.039932, (F)-0.169513, (F)-0.018827, 
(F)-0.038617, (F)0.043286, (F)0.088787, (F)0.009861, (F)-0.057446, (F)-0.117831, 
(F)-0.013087, (F)0.030089, 
(F)0.112488, (F)-0.221191, (F)0.758179, (F)0.421021, (F)-0.095154, (F)-0.012654, 
(F)-0.048926, (F)-0.574835, (F)-0.177258, (F)-0.009054, (F)0.024881, (F)-0.085286, 
(F)0.167703, (F)-0.047360, (F)0.093126, (F)-0.319209, (F)0.010704, (F)-0.021047, 
(F)0.072144, (F)0.040062, 
(F)0.087463, (F)0.146118, (F)0.153015, (F)0.084229, (F)0.535889, (F)-0.007650, 
(F)-0.021351, (F)-0.023414, (F)-0.007094, (F)-0.287177, (F)-0.012780, (F)-0.013383, 
(F)-0.022358, (F)-0.007367, (F)-0.012307, (F)-0.012888, (F)-0.046871, (F)-0.078303, 
(F)-0.081999, (F)-0.045137, 
(F)-0.104492, (F)0.788269, (F)0.359070, (F)-0.134094, (F)0.060486, (F)-0.010919, 
(F)-0.621368, (F)-0.128931, (F)-0.017981, (F)-0.003659, (F)0.082368, (F)0.037520, 
(F)-0.283044, (F)-0.014012, (F)0.105702, (F)0.048149, (F)0.006320, (F)-0.047679, 
(F)-0.021719, (F)0.008111, 
(F)0.919922, (F)0.131714, (F)-0.075989, (F)0.055542, (F)-0.030273, (F)-0.846256, 
(F)-0.017349, (F)-0.005774, (F)-0.003085, (F)-0.000916, (F)-0.121166, (F)0.069904, 
(F)0.010009, (F)-0.051094, (F)-0.007316, (F)0.004221, (F)0.027849, (F)0.003987, 
(F)-0.002300, (F)0.001681, 
(F)0.284119, (F)0.446716, (F)0.300049, (F)0.035767, (F)-0.206360, (F)-0.080723, 
(F)-0.199555, (F)-0.090029, (F)-0.001279, (F)-0.042584, (F)-0.126920, (F)-0.085249, 
(F)-0.134037, (F)-0.010162, (F)-0.015978, (F)-0.010732, (F)0.058631, (F)0.092184, 
(F)0.061918, (F)0.007381, 
(F)0.072693, (F)-0.130615, (F)0.312500, (F)0.823853, (F)-0.086548, (F)-0.005284, 
(F)-0.017060, (F)-0.097656, (F)-0.678733, (F)-0.007491, (F)0.009495, (F)-0.022717, 
(F)0.040817, (F)-0.059888, (F)0.107608, (F)-0.257454, (F)0.006291, (F)-0.011304, 
(F)0.027046, (F)0.071303, 
(F)-0.093384, (F)-0.049866, (F)0.499939, (F)0.587891, (F)-0.088623, (F)-0.008721, 
(F)-0.002487, (F)-0.249939, (F)-0.345615, (F)-0.007854, (F)-0.004657, (F)0.046686, 
(F)0.024930, (F)0.054899, (F)0.029316, (F)-0.293909, (F)-0.008276, (F)-0.004419, 
(F)0.044306, (F)0.052101, 
(F)-0.197510, (F)0.037048, (F)0.103516, (F)-0.128540, (F)0.700989, (F)-0.039010, 
(F)-0.001373, (F)-0.010715, (F)-0.016523, (F)-0.491385, (F)0.007317, (F)0.020445, 
(F)-0.003835, (F)-0.025388, (F)0.004762, (F)0.013306, (F)0.138452, (F)-0.025970, 
(F)-0.072563, (F)0.090105, 
(F)0.195496, (F)-0.116150, (F)-0.051086, (F)0.590759, (F)0.430725, (F)-0.038219, 
(F)-0.013491, (F)-0.002610, (F)-0.348997, (F)-0.185524, (F)0.022707, (F)0.009987, 
(F)-0.005934, (F)-0.115491, (F)0.068617, (F)0.030180, (F)-0.084205, (F)0.050029, 
(F)0.022004, (F)-0.254455, 
(F)0.013000, (F)-0.039978, (F)1.038513, (F)0.037842, (F)-0.023438, (F)-0.000169, 
(F)-0.001598, (F)-1.078510, (F)-0.001432, (F)-0.000549, (F)0.000520, (F)-0.013501, 
(F)0.041518, (F)-0.000492, (F)0.001513, (F)-0.039299, (F)0.000305, (F)-0.000937, 
(F)0.024340, (F)0.000887, 
(F)0.310547, (F)0.002136, (F)-0.203796, (F)0.227417, (F)0.518066, (F)-0.096439, 
(F)-0.000005, (F)-0.041533, (F)-0.051718, (F)-0.268393, (F)-0.000663, (F)0.063288, 
(F)0.000435, (F)-0.070624, (F)-0.000486, (F)0.046347, (F)-0.160884, (F)-0.001107, 
(F)0.105580, (F)-0.117817, 
(F)-0.060303, (F)0.088745, (F)-0.164062, (F)0.917908, (F)0.163696, (F)-0.003636, 
(F)-0.007876, (F)-0.026917, (F)-0.842555, (F)-0.026796, (F)0.005352, (F)-0.009893, 
(F)0.014560, (F)0.055352, (F)-0.081460, (F)0.150594, (F)0.009871, (F)-0.014527, 
(F)0.026856, (F)-0.150258, 
(F)-0.296936, (F)-0.173462, (F)-0.003235, (F)0.335388, (F)0.398132, (F)-0.088171, 
(F)-0.030089, (F)-0.000010, (F)-0.112485, (F)-0.158509, (F)-0.051507, (F)-0.000961, 
(F)-0.000561, (F)0.099589, (F)0.058177, (F)0.001085, (F)0.118220, (F)0.069061, 
(F)0.001288, (F)-0.133529, 
(F)0.187744, (F)0.919739, (F)-0.177856, (F)0.110474, (F)-0.059265, (F)-0.035248, 
(F)-0.845919, (F)-0.031633, (F)-0.012204, (F)-0.003512, (F)-0.172676, (F)0.033392, 
(F)0.163581, (F)-0.020741, (F)-0.101607, (F)0.019648, (F)0.011127, (F)0.054508, 
(F)-0.010541, (F)0.006547, 
(F)0.080017, (F)0.326843, (F)0.674683, (F)0.140320, (F)-0.223022, (F)-0.006403, 
(F)-0.106827, (F)-0.455197, (F)-0.019690, (F)-0.049739, (F)-0.026153, (F)-0.053986, 
(F)-0.220515, (F)-0.011228, (F)-0.045863, (F)-0.094671, (F)0.017846, (F)0.072893, 
(F)0.150469, (F)0.031294, 
(F)0.246277, (F)0.342957, (F)0.281860, (F)0.110779, (F)0.116699, (F)-0.060652, 
(F)-0.117619, (F)-0.079445, (F)-0.012272, (F)-0.013619, (F)-0.084462, (F)-0.069416, 
(F)-0.096666, (F)-0.027282, (F)-0.037992, (F)-0.031224, (F)-0.028740, (F)-0.040023, 
(F)-0.032893, (F)-0.012928, 
(F)-0.130066, (F)0.168091, (F)-0.274719, (F)0.786072, (F)0.453613, (F)-0.016917, 
(F)-0.028255, (F)-0.075471, (F)-0.617909, (F)-0.205765, (F)0.021863, (F)-0.035732, 
(F)0.046178, (F)0.102241, (F)-0.132131, (F)0.215949, (F)0.059000, (F)-0.076248, 
(F)0.124616, (F)-0.356573, 
(F)0.342896, (F)-0.031433, (F)0.196472, (F)-0.253235, (F)0.296448, (F)-0.117577, 
(F)-0.000988, (F)-0.038601, (F)-0.064128, (F)-0.087881, (F)0.010778, (F)-0.067369, 
(F)0.006176, (F)0.086833, (F)-0.007960, (F)0.049754, (F)-0.101651, (F)0.009318, 
(F)-0.058244, (F)0.075071, 
(F)0.112183, (F)-0.104309, (F)0.069519, (F)1.029480, (F)0.043701, (F)-0.012585, 
(F)-0.010880, (F)-0.004833, (F)-1.059829, (F)-0.001910, (F)0.011702, (F)-0.007799, 
(F)0.007251, (F)-0.115490, (F)0.107384, (F)-0.071568, (F)-0.004903, (F)0.004558, 
(F)-0.003038, (F)-0.044989, 
(F)0.120728, (F)-0.234680, (F)0.613403, (F)0.723511, (F)-0.152100, (F)-0.014575, 
(F)-0.055075, (F)-0.376264, (F)-0.523468, (F)-0.023134, (F)0.028332, (F)-0.074055, 
(F)0.143954, (F)-0.087348, (F)0.169794, (F)-0.443804, (F)0.018363, (F)-0.035695, 
(F)0.093298, (F)0.110046, 
(F)-0.158691, (F)0.686401, (F)0.689026, (F)-0.222595, (F)0.089294, (F)-0.025183, 
(F)-0.471147, (F)-0.474757, (F)-0.049549, (F)-0.007973, (F)0.108926, (F)0.109342, 
(F)-0.472948, (F)-0.035324, (F)0.152790, (F)0.153374, (F)0.014170, (F)-0.061292, 
(F)-0.061526, (F)0.019877, 
(F)0.210083, (F)0.055359, (F)0.166321, (F)0.547485, (F)0.222046, (F)-0.044135, 
(F)-0.003065, (F)-0.027663, (F)-0.299740, (F)-0.049304, (F)-0.011630, (F)-0.034941, 
(F)-0.009207, (F)-0.115017, (F)-0.030308, (F)-0.091058, (F)-0.046648, (F)-0.012292, 
(F)-0.036931, (F)-0.121567, 
(F)-0.007690, (F)1.067993, (F)0.212463, (F)-0.122253, (F)0.066528, (F)-0.000059, 
(F)-1.140609, (F)-0.045141, (F)-0.014946, (F)-0.004426, (F)0.008213, (F)0.001634, 
(F)-0.226909, (F)-0.000940, (F)0.130566, (F)0.025974, (F)0.000512, (F)-0.071052, 
(F)-0.014135, (F)0.008133, 
(F)-0.110718, (F)0.063965, (F)-0.132080, (F)0.248413, (F)0.993164, (F)-0.012258, 
(F)-0.004092, (F)-0.017445, (F)-0.061709, (F)-0.986375, (F)0.007082, (F)-0.014624, 
(F)0.008448, (F)0.027504, (F)-0.015890, (F)0.032810, (F)0.109961, (F)-0.063528, 
(F)0.131177, (F)-0.246715, 
(F)0.570923, (F)0.767822, (F)-0.114929, (F)0.058716, (F)-0.037659, (F)-0.325953, 
(F)-0.589551, (F)-0.013209, (F)-0.003448, (F)-0.001418, (F)-0.438367, (F)0.065616, 
(F)0.088245, (F)-0.033522, (F)-0.045083, (F)0.006748, (F)0.021500, (F)0.028915, 
(F)-0.004328, (F)0.002211, 
(F)0.104248, (F)0.256287, (F)0.450867, (F)0.386658, (F)0.061218, (F)-0.010868, 
(F)-0.065683, (F)-0.203281, (F)-0.149504, (F)-0.003748, (F)-0.026717, (F)-0.047002, 
(F)-0.115551, (F)-0.040308, (F)-0.099095, (F)-0.174331, (F)-0.006382, (F)-0.015689, 
(F)-0.027601, (F)-0.023671, 
(F)-0.160156, (F)0.343201, (F)1.056519, (F)-0.143616, (F)0.036133, (F)-0.025650, 
(F)-0.117787, (F)-1.116231, (F)-0.020625, (F)-0.001306, (F)0.054966, (F)0.169208, 
(F)-0.362598, (F)-0.023001, (F)0.049289, (F)0.151733, (F)0.005787, (F)-0.012401, 
(F)-0.038175, (F)0.005189, 
(F)0.073914, (F)-0.051880, (F)0.072815, (F)-0.117554, (F)0.976074, (F)-0.005463, 
(F)-0.002692, (F)-0.005302, (F)-0.013819, (F)-0.952721, (F)0.003835, (F)-0.005382, 
(F)0.003778, (F)0.008689, (F)-0.006099, (F)0.008560, (F)-0.072145, (F)0.050639, 
(F)-0.071073, (F)0.114741, 
(F)0.243103, (F)-0.125366, (F)0.702271, (F)-0.001160, (F)0.221069, (F)-0.059099, 
(F)-0.015717, (F)-0.493184, (F)-0.000001, (F)-0.048872, (F)0.030477, (F)-0.170724, 
(F)0.088041, (F)0.000282, (F)-0.000145, (F)0.000814, (F)-0.053743, (F)0.027715, 
(F)-0.155250, (F)0.000256, 
(F)-0.047974, (F)-0.082642, (F)0.982178, (F)0.442261, (F)-0.101624, (F)-0.002301, 
(F)-0.006830, (F)-0.964673, (F)-0.195595, (F)-0.010327, (F)-0.003965, (F)0.047119, 
(F)0.081169, (F)0.021217, (F)0.036549, (F)-0.434379, (F)-0.004875, (F)-0.008398, 
(F)0.099812, (F)0.044944, 
(F)-0.263428, (F)-0.031189, (F)0.407349, (F)0.711975, (F)0.282776, (F)-0.069394, 
(F)-0.000973, (F)-0.165933, (F)-0.506909, (F)-0.079962, (F)-0.008216, (F)0.107307, 
(F)0.012705, (F)0.187554, (F)0.022206, (F)-0.290022, (F)0.074491, (F)0.008819, 
(F)-0.115188, (F)-0.201329, 
(F)0.482910, (F)0.278137, (F)0.118225, (F)0.115051, (F)0.429504, (F)-0.233202, 
(F)-0.077360, (F)-0.013977, (F)-0.013237, (F)-0.184474, (F)-0.134315, (F)-0.057092, 
(F)-0.032883, (F)-0.055559, (F)-0.032000, (F)-0.013602, (F)-0.207412, (F)-0.119461, 
(F)-0.050778, (F)-0.049415, 
(F)0.209595, (F)0.181091, (F)0.358093, (F)0.500244, (F)0.535034, (F)-0.043930, 
(F)-0.032794, (F)-0.128231, (F)-0.250244, (F)-0.286262, (F)-0.037956, (F)-0.075054, 
(F)-0.064848, (F)-0.104849, (F)-0.090590, (F)-0.179134, (F)-0.112140, (F)-0.096890, 
(F)-0.191592, (F)-0.267648, 
(F)0.358948, (F)0.560059, (F)0.495544, (F)0.240112, (F)0.204773, (F)-0.128843, 
(F)-0.313666, (F)-0.245564, (F)-0.057654, (F)-0.041932, (F)-0.201032, (F)-0.177875, 
(F)-0.277534, (F)-0.086188, (F)-0.134477, (F)-0.118986, (F)-0.073503, (F)-0.114685, 
(F)-0.101474, (F)-0.049169 }; 

#if COMPILE_MMX

 short AcbkGainTable085Int[85*20] = {
     0,      0,      0,      0,      0,      0,      0,      0, 
     0,      0,      0,      0,      0,      0,      0,      0, 
     0,      0,      0,      0,    800,   1496,    167,   -256, 
  -338,    -39,   -136,     -1,     -4,     -6,    -73,     -8, 
   -15,     12,     23,      2,     16,     30,      3,     -5, 
  -462,   -686,    493,   2575,    311,    -13,    -28,    -14, 
  -404,     -5,    -19,     13,     20,     72,    107,    -77, 
     8,     13,     -9,    -48,   1483,    144,    784,    928,
  1243,   -134,     -1,    -37,    -52,    -94,    -13,    -71, 
    -6,    -84,     -8,    -44,   -112,    -10,    -59,    -70, 
   -77,    275,   3522,   1056,  -1254,      0,     -4,   -757, 
   -68,    -95,      1,     16,    -59,      4,    -17,   -227, 
    -5,     21,    269,     80,   -125,    -40,   -264,    381, 
  5027,      0,      0,     -4,     -8,  -1542,      0,     -2, 
     0,      2,      0,      6,     38,     12,     81,   -117, 
   138,    332,   2215,   2574,   1339,     -1,     -6,   -299, 
  -404,   -109,     -2,    -18,    -44,    -21,    -52,   -348,
   -11,    -27,   -181,   -210,   3685,   2883,   -887,    866, 
 -1639,   -828,   -507,    -48,    -45,   -164,   -648,    199, 
   156,   -194,   -152,     46,    368,    288,    -88,     86, 
  1396,   2146,   2235,    345,    942,   -118,   -281,   -305, 
    -7,    -54,   -182,   -190,   -292,    -29,    -45,    -47, 
   -80,   -123,   -128,    -19,     13,   4475,   3549,   -804, 
  -655,      0,  -1222,   -768,    -39,    -26,     -3,     -2, 
  -969,      0,    219,    174,      0,    179,    141,    -32, 
  -724,    254,    242,   6049,   2462,    -32,     -3,     -3, 
 -2233,   -370,     11,     10,     -3,    267,    -94,    -89, 
   108,    -38,    -36,   -909,    626,  -1713,   6121,   4561, 
 -1061,    -23,   -179,  -2287,  -1270,    -68,     65,   -233, 
   640,   -174,    477,  -1704,     40,   -111,    396,    295, 
  -350,   1391,   7985,    511,   -405,     -7,   -118,  -3892, 
   -15,    -10,     29,    170,   -678,     10,    -43,   -249, 
    -8,     34,    197,     12,   3144,   -529,    608,   2530, 
  3878,   -603,    -17,    -22,   -390,   -918,    101,   -116, 
    19,   -485,     81,    -93,   -744,    125,   -144,   -599, 
  2589,   -689,   3045,   5603,   -404,   -409,    -29,   -566, 
 -1916,    -10,    108,   -481,    128,   -885,    235,  -1041, 
    63,    -17,     75,    138,   3107,    513,   1374,  -3594, 
 -4922,   -589,    -16,   -115,   -788,  -1478,    -97,   -260, 
   -43,    681,    112,    301,    933,    154,    413,  -1079, 
  2468,   6010,   1107,   -390,   1961,   -372,  -2204,    -74, 
    -9,   -234,   -905,   -166,   -406,     58,    143,     26, 
  -295,   -719,   -132,     46,   4773,   2766,   2368,   4862, 
 -4044,  -1390,   -467,   -342,  -1443,   -998,   -806,   -690, 
  -399,  -1416,   -821,   -702,   1178,    682,    584,   1200, 
  1665,  -1879,   1443,   1701,   8562,   -169,   -215,   -127, 
  -176,  -4475,    190,   -146,    165,   -172,    195,   -149, 
  -870,    982,   -754,   -889,   2716,   9011,  -1007,    755, 
 -1785,   -450,  -4956,    -61,    -34,   -194,  -1493,    167, 
   554,   -125,   -415,     46,    296,    982,   -109,     82, 
 -2727,   7548,   1285,    938,   3420,   -453,  -3478,   -100, 
   -53,   -714,   1256,    213,   -592,    156,   -432,    -73, 
   569,  -1576,   -268,   -196,   3677,    882,   4050,   1202, 
  2323,   -825,    -47,  -1001,    -88,   -329,   -198,   -909, 
  -218,   -269,    -64,   -297,   -521,   -125,   -574,   -170, 
  2046,   -753,    122,  10102,    603,   -255,    -34,      0, 
 -6229,    -22,     94,    -15,      5,  -1261,    464,    -75, 
   -75,     27,     -4,   -372,    449,  -1815,  10690,   3870, 
  -527,    -12,   -201,  -6976,   -914,    -16,     49,   -293, 
  1184,   -106,    428,  -2525,     14,    -58,    344,    124, 
  -941,   2352,   5049,   3650,   2637,    -54,   -337,  -1556, 
  -813,   -424,    135,    290,   -725,    209,   -524,  -1125, 
   151,   -378,   -812,   -587,  -1879,    796,   3117,   9569, 
  -404,   -215,    -38,   -593,  -5589,     -9,     91,    357, 
  -151,   1097,   -464,  -1821,    -46,     19,     76,    236, 
 -1715,   2043,  -2096,   9946,   4001,   -179,   -254,   -268, 
 -6038,   -977,    213,   -219,    261,   1041,  -1240,   1272, 
   418,   -498,    511,  -2429,  -5772,   -618,  -3921,    284, 
 -3155,  -2033,    -23,   -938,     -4,   -607,   -218,  -1381, 
  -148,    100,     10,     68,  -1111,   -119,   -755,     54, 
   382,   4748,   8003,  -2064,   2198,     -8,  -1376,  -3909, 
  -260,   -294,   -110,   -186,  -2319,     48,    598,   1008, 
   -51,   -637,  -1073,    277,   -867,   3015,  11926,  -1675, 
   947,    -45,   -555,  -8681,   -171,    -54,    159,    631, 
 -2195,    -88,    308,   1219,     50,   -174,   -690,     96, 
 -4933,   -432,   6757,   3771,   1352,  -1485,    -11,  -2786, 
  -867,   -111,   -130,   2034,    178,   1135,     99,  -1555, 
   407,     35,   -557,   -311,    152,   9726,   4231,  -1928, 
  1490,     -1,  -5774,  -1092,   -226,   -135,    -90,    -39, 
 -2511,     17,   1144,    498,    -13,   -884,   -384,    175, 
  2512,    193,   9033,   5361,  -3148,   -385,     -2,  -4980, 
 -1754,   -605,    -29,  -1385,   -106,   -822,    -63,  -2956, 
   482,     37,   1735,   1030,   8464,   2844,     12,    549, 
  2132,  -4373,   -493,      0,    -18,   -277,  -1469,     -6, 
    -2,   -284,    -95,      0,  -1101,   -370,     -1,    -71, 
  2141,  -2602,   7166,   9046,  -1350,   -279,   -413,  -3134, 
 -4994,   -111,    340,   -936,   1138,  -1182,   1436,  -3957, 
   176,   -214,    590,    745,   -244,    278,  13307,   1227, 
  -161,     -3,     -4, -10808,    -91,     -1,      4,    198, 
  -226,     18,    -20,   -997,     -2,      2,    131,     12, 
 -1947,   8217,   6269,    917,  -2559,   -231,  -4121,  -2399, 
   -51,   -399,    976,    745,  -3144,    108,   -460,   -350, 
  -304,   1283,    979,    143,  -1810,   2061,  -2781,   6056, 
 10058,   -200,   -259,   -472,  -2238,  -6174,    227,   -307, 
   349,    669,   -761,   1028,   1111,  -1265,   1707,  -3717, 
  7827,   9161,  -3409,   2473,  -1510,  -3739,  -5122,   -709, 
  -373,   -139,  -4376,   1628,   1906,  -1181,  -1382,    514, 
   721,    844,   -314,    228,  -1430,   8313,   9541,  -2955, 
  1626,   -124,  -4218,  -5556,   -533,   -161,    725,    832, 
 -4841,   -257,   1499,   1721,    142,   -825,   -947,    293, 
  2819,  -4247,   5391,   8673,   2756,   -485,  -1101,  -1774, 
 -4591,   -463,    730,   -927,   1397,  -1492,   2248,  -2854, 
  -474,    714,   -907,  -1459,    141,  14552,    690,    257, 
  -112,     -1, -12926,    -29,     -4,      0,   -125,     -5, 
  -613,     -2,   -228,    -10,      0,     99,      4,      1, 
 11938,  -1859,   1806,   -962,   -884,  -8699,   -211,   -199, 
   -56,    -47,   1355,  -1316,    205,    701,   -109,    106, 
   644,   -100,     97,    -51,   3728,   1982,   2264,   4584, 
  3131,   -848,   -239,   -312,  -1282,   -598,   -451,   -515, 
  -273,  -1043,   -554,   -633,   -712,   -378,   -432,   -876, 
 -1181,    766,    720,  14303,   -216,    -85,    -35,    -31, 
-12486,     -2,     55,     51,    -33,   1031,   -668,   -628, 
   -15,     10,      9,    189,  -4385,   4826,  10112,   1569, 
  3388,  -1173,  -1421,  -6242,   -150,   -700,   1291,   2706, 
 -2979,    420,   -462,   -969,    906,   -998,  -2091,   -324, 
  -448,   1932,  15591,  -1842,    657,    -12,   -227, -14837, 
  -207,    -26,     52,    427,  -1838,    -50,    217,   1753, 
    18,    -77,   -626,     74,  -4141,   1844,   3962,   5517, 
  6220,  -1046,   -207,   -958,  -1858,  -2361,    466,   1001, 
  -446,   1394,   -621,  -1334,   1572,   -700,  -1504,  -2094, 
   729,  -2299,  14755,   3657,   -952,    -32,   -322, -13288, 
  -816,    -55,    102,   -656,   2071,   -162,    513,  -3294, 
    42,   -133,    857,    212,  -1385,   5801,  13339,  -3137, 
  1344,   -117,  -2054, -10861,   -600,   -110,    490,   1127, 
 -4723,   -265,   1111,   2554,    113,   -476,  -1094,    257, 
  4710,   9661,   1073,  -2467,   3274,  -1354,  -5697,    -70, 
  -371,   -654,  -2777,   -308,   -633,    709,   1455,    161, 
  -941,  -1930,   -214,    493,   1843,  -3624,  12422,   6898, 
 -1559,   -207,   -802,  -9419,  -2904,   -148,    407,  -1397, 
  2748,   -775,   1526,  -5230,    175,   -344,   1182,    656, 
  1433,   2394,   2507,   1380,   8780,   -125,   -349,   -383, 
  -116,  -4705,   -209,   -219,   -366,   -120,   -201,   -211, 
  -768,  -1283,  -1343,   -740,  -1712,  12915,   5883,  -2197, 
   991,   -179, -10181,  -2112,   -294,    -60,   1350,    615, 
 -4638,   -229,   1732,    789,    103,   -781,   -356,    133, 
 15072,   2158,  -1245,    910,   -496, -13865,   -284,    -94, 
   -50,    -15,  -1986,   1145,    164,   -837,   -119,     69, 
   456,     65,    -37,     27,   4655,   7319,   4916,    586, 
 -3381,  -1322,  -3270,  -1475,    -20,   -697,  -2079,  -1396, 
 -2196,   -166,   -261,   -175,    960,   1510,   1014,    120, 
  1191,  -2140,   5120,  13498,  -1418,    -86,   -279,  -1600, 
-11121,   -122,    155,   -372,    669,   -981,   1763,  -4218, 
   103,   -185,    443,   1168,  -1530,   -817,   8191,   9632, 
 -1452,   -143,    -40,  -4095,  -5663,   -128,    -76,    765, 
   408,    900,    480,  -4815,   -135,    -72,    726,    854, 
 -3236,    607,   1696,  -2106,  11485,   -639,    -22,   -175, 
  -270,  -8051,    119,    335,    -62,   -416,     78,    218, 
  2268,   -425,  -1189,   1476,   3203,  -1903,   -837,   9679, 
  7057,   -626,   -221,    -42,  -5718,  -3039,    372,    163, 
   -97,  -1892,   1124,    494,  -1380,    819,    360,  -4169, 
   213,   -655,  17015,    620,   -384,     -2,    -26, -17671, 
   -23,     -9,      8,   -221,    681,     -8,     24,   -644, 
     5,    -15,    399,     14,   5088,     35,  -3339,   3726, 
  8488,  -1580,      0,   -680,   -847,  -4397,    -10,   1037, 
     7,  -1157,     -8,    759,  -2636,    -18,   1730,  -1930, 
  -988,   1454,  -2688,  15039,   2682,    -59,   -129,   -441, 
-13805,   -439,     87,   -162,    238,    907,  -1335,   2467, 
   161,   -238,    440,  -2462,  -4865,  -2842,    -53,   5495, 
  6523,  -1445,   -493,      0,  -1843,  -2597,   -844,    -16, 
    -9,   1632,    953,     18,   1937,   1131,     21,  -2188, 
  3076,  15069,  -2914,   1810,   -971,   -577, -13860,   -518, 
  -200,    -57,  -2829,    547,   2680,   -339,  -1665,    322, 
   182,    893,   -172,    107,   1311,   5355,  11054,   2299, 
 -3654,   -105,  -1750,  -7458,   -322,   -814,   -428,   -885, 
 -3613,   -184,   -751,  -1551,    292,   1194,   2465,    512, 
  4035,   5619,   4618,   1815,   1912,   -994,  -1927,  -1301, 
  -201,   -223,  -1384,  -1137,  -1583,   -447,   -622,   -511, 
  -471,   -656,   -539,   -211,  -2131,   2754,  -4501,  12879, 
  7432,   -277,   -463,  -1236, -10124,  -3371,    358,   -585, 
   756,   1675,  -2165,   3538,    967,  -1249,   2042,  -5842, 
  5618,   -515,   3219,  -4149,   4857,  -1926,    -16,   -632, 
 -1050,  -1440,    176,  -1104,    101,   1422,   -130,    815, 
 -1666,    152,   -954,   1230,   1838,  -1709,   1139,  16867, 
   716,   -206,   -178,    -79, -17366,    -31,    191,   -127, 
   118,  -1892,   1759,  -1173,    -80,     74,    -49,   -737, 
  1978,  -3845,  10050,  11854,  -2492,   -238,   -902,  -6164, 
 -8576,   -379,    464,  -1213,   2358,  -1431,   2782,  -7271, 
   301,   -585,   1529,   1803,  -2600,  11246,  11289,  -3647, 
  1463,   -412,  -7720,  -7778,   -812,   -130,   1784,   1791, 
 -7749,   -578,   2504,   2513,    232,  -1004,  -1008,    325, 
  3442,    907,   2725,   8970,   3638,   -723,    -50,   -453, 
 -4911,   -808,   -190,   -572,   -150,  -1884,   -496,  -1492, 
  -764,   -201,   -605,  -1992,   -126,  17498,   3481,  -2003, 
  1090,      0, -18689,   -739,   -244,    -72,    135,     26, 
 -3717,    -15,   2139,    425,      8,  -1165,   -231,    133, 
 -1814,   1048,  -2164,   4070,  16272,   -200,    -67,   -285, 
 -1011, -16160,    116,   -239,    138,    450,   -260,    537, 
  1801,  -1041,   2149,  -4042,   9354,  12580,  -1883,    962, 
  -617,  -5341,  -9660,   -216,    -56,    -23,  -7183,   1075, 
  1446,   -549,   -738,    110,    352,    474,    -71,     36, 
  1708,   4199,   7387,   6335,   1003,   -178,  -1076,  -3330, 
 -2449,    -61,   -437,   -770,  -1893,   -660,  -1623,  -2856, 
  -104,   -257,   -452,   -388,  -2624,   5623,  17310,  -2353, 
   592,   -420,  -1930, -18288,   -338,    -21,    900,   2772, 
 -5941,   -376,    807,   2486,     94,   -203,   -625,     85, 
  1211,   -850,   1193,  -1926,  15992,    -89,    -44,    -86, 
  -226, -15609,     62,    -88,     61,    142,   -100,    140, 
 -1182,    830,  -1165,   1880,   3983,  -2054,  11506,    -19, 
  3622,   -968,   -257,  -8080,      0,   -801,    499,  -2797, 
  1442,      4,     -2,     13,   -880,    454,  -2544,      4, 
  -786,  -1354,  16092,   7246,  -1665,    -37,   -111, -15805, 
 -3205,   -169,    -65,    772,   1330,    348,    599,  -7117, 
   -80,   -137,   1636,    736,  -4316,   -511,   6674,  11665, 
  4633,  -1137,    -15,  -2719,  -8305,  -1310,   -134,   1758, 
   208,   3073,    364,  -4752,   1220,    144,  -1887,  -3299, 
  7912,   4557,   1937,   1885,   7037,  -3821,  -1267,   -229, 
  -216,  -3022,  -2200,   -935,   -538,   -910,   -524,   -222, 
 -3398,  -1957,   -832,   -809,   3434,   2967,   5867,   8196, 
  8766,   -720,   -537,  -2101,  -4100,  -4690,   -622,  -1230, 
 -1062,  -1718,  -1484,  -2935,  -1837,  -1588,  -3139,  -4385, 
  5881,   9176,   8119,   3934,   3355,  -2111,  -5139,  -4023, 
  -944,   -687,  -3294,  -2914,  -4547,  -1412,  -2203,  -1949, 
 -1204,  -1879,  -1662,   -805 };

#endif

/*
**  AcbkGainTable170:
**
**  Purpose:
**      Used to calculate the error expression in pitch prediction
**      optimization (also expressed as an adaptive codebook approach)
**
**  Table Structure:
**      The table is structured as 170 20-element vectors.  These
**      vectors are structured as precalculated values in the error
**      expression for the pitch
**      predictor.  Gi is the gain value multiplying the signal
**      delayed by a pitch period (+/- offset).  In equation 41.2,
**      Gi would be equivalent to bij.
**
**      1st 5 elements:   G1  G2  G3  G4  G5 in Q14
**      2nd 5 elements:  -G1^2  -G2^2  -G3^2  -G4^2  -G5^2
**      Next 10 elements: These are the off-diagonal elements
**           -G1*G2  -G1*G3  -G2*G3  -G1*G4  -G2*G4
**           -G3*G4  -G1*G5  -G2*G5  -G3*G5  -G4*G5
*/

 FLOAT   AcbkGainTable170[170*20] = {
 (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, 
(F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, 
(F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, (F)0.000000, 
(F)0.000000, (F)0.000000, 
(F)0.047363, (F)0.012939, (F)0.043640, (F)0.040894, (F)0.049377, (F)-0.002243, 
(F)-0.000167, (F)-0.001904, (F)-0.001672, (F)-0.002438, (F)-0.000613, (F)-0.002067, 
(F)-0.000565, (F)-0.001937, (F)-0.000529, (F)-0.001785, (F)-0.002339, (F)-0.000639, 
(F)-0.002155, (F)-0.002019, 
(F)0.079102, (F)0.080322, (F)-0.010254, (F)-0.019531, (F)-0.049744, (F)-0.006257, 
(F)-0.006452, (F)-0.000105, (F)-0.000381, (F)-0.002474, (F)-0.006354, (F)0.000811, 
(F)0.000824, (F)0.001545, (F)0.001569, (F)-0.000200, (F)0.003935, (F)0.003996, 
(F)-0.000510, (F)-0.000972, 
(F)-0.035950, (F)0.041504, (F)0.151245, (F)0.018799, (F)-0.036377, (F)-0.001292, 
(F)-0.001723, (F)-0.022875, (F)-0.000353, (F)-0.001323, (F)0.001492, (F)0.005437, 
(F)-0.006277, (F)0.000676, (F)-0.000780, (F)-0.002843, (F)-0.001308, (F)0.001510, 
(F)0.005502, (F)0.000684, 
(F)-0.044861, (F)-0.029724, (F)-0.000305, (F)0.179932, (F)0.028564, (F)-0.002012, 
(F)-0.000884, (F)0.000000, (F)-0.032375, (F)-0.000816, (F)-0.001333, (F)-0.000014, 
(F)-0.000009, (F)0.008072, (F)0.005348, (F)0.000055, (F)0.001281, (F)0.000849, 
(F)0.000009, (F)-0.005140, 
(F)0.063599, (F)0.105591, (F)0.065186, (F)0.020325, (F)0.038208, (F)-0.004045, 
(F)-0.011149, (F)-0.004249, (F)-0.000413, (F)-0.001460, (F)-0.006715, (F)-0.004146, 
(F)-0.006883, (F)-0.001293, (F)-0.002146, (F)-0.001325, (F)-0.002430, (F)-0.004034, 
(F)-0.002491, (F)-0.000777, 
(F)0.029663, (F)-0.046936, (F)0.248657, (F)0.172424, (F)-0.067566, (F)-0.000880, 
(F)-0.002203, (F)-0.061830, (F)-0.029730, (F)-0.004565, (F)0.001392, (F)-0.007376, 
(F)0.011671, (F)-0.005115, (F)0.008093, (F)-0.042875, (F)0.002004, (F)-0.003171, 
(F)0.016801, (F)0.011650, 
(F)0.092834, (F)-0.046814, (F)-0.007568, (F)0.263672, (F)0.062622, (F)-0.008618, 
(F)-0.002192, (F)-0.000057, (F)-0.069523, (F)-0.003922, (F)0.004346, (F)0.000703, 
(F)-0.000354, (F)-0.024478, (F)0.012344, (F)0.001996, (F)-0.005813, (F)0.002932, 
(F)0.000474, (F)-0.016512, 
(F)0.148010, (F)0.077332, (F)0.209900, (F)-0.005554, (F)-0.071167, (F)-0.021907, 
(F)-0.005980, (F)-0.044058, (F)-0.000031, (F)-0.005065, (F)-0.011446, (F)-0.031067, 
(F)-0.016232, (F)0.000822, (F)0.000430, (F)0.001166, (F)0.010533, (F)0.005503, 
(F)0.014938, (F)-0.000395, 
(F)-0.076355, (F)0.059509, (F)0.010559, (F)0.246521, (F)0.122375, (F)-0.005830, 
(F)-0.003541, (F)-0.000111, (F)-0.060773, (F)-0.014976, (F)0.004544, (F)0.000806, 
(F)-0.000628, (F)0.018823, (F)-0.014670, (F)-0.002603, (F)0.009344, (F)-0.007282, 
(F)-0.001292, (F)-0.030168, 
(F)0.111084, (F)0.038574, (F)0.080688, (F)0.125854, (F)0.062927, (F)-0.012340, 
(F)-0.001488, (F)-0.006511, (F)-0.015839, (F)-0.003960, (F)-0.004285, (F)-0.008963, 
(F)-0.003112, (F)-0.013980, (F)-0.004855, (F)-0.010155, (F)-0.006990, (F)-0.002427, 
(F)-0.005078, (F)-0.007920, 
(F)-0.027283, (F)0.299316, (F)0.014893, (F)-0.019226, (F)-0.124390, (F)-0.000744, 
(F)-0.089590, (F)-0.000222, (F)-0.000370, (F)-0.015473, (F)0.008166, (F)0.000406, 
(F)-0.004458, (F)-0.000525, (F)0.005755, (F)0.000286, (F)-0.003394, (F)0.037232, 
(F)0.001852, (F)-0.002392, 
(F)-0.012695, (F)-0.067261, (F)0.028259, (F)-0.027344, (F)0.345032, (F)-0.000161, 
(F)-0.004524, (F)-0.000799, (F)-0.000748, (F)-0.119047, (F)-0.000854, (F)0.000359, 
(F)0.001901, (F)-0.000347, (F)-0.001839, (F)0.000773, (F)0.004380, (F)0.023207, 
(F)-0.009750, (F)0.009434, 
(F)0.289246, (F)0.158691, (F)-0.113770, (F)0.052246, (F)-0.094849, (F)-0.083663, 
(F)-0.025183, (F)-0.012944, (F)-0.002730, (F)-0.008996, (F)-0.045901, (F)0.032907, 
(F)0.018054, (F)-0.015112, (F)-0.008291, (F)0.005944, (F)0.027435, (F)0.015052, 
(F)-0.010791, (F)0.004955, 
(F)0.115601, (F)0.215637, (F)0.002136, (F)-0.001587, (F)0.130920, (F)-0.013363, 
(F)-0.046499, (F)-0.000005, (F)-0.000003, (F)-0.017140, (F)-0.024928, (F)-0.000247, 
(F)-0.000461, (F)0.000183, (F)0.000342, (F)0.000003, (F)-0.015134, (F)-0.028231, 
(F)-0.000280, (F)0.000208, 
(F)-0.164734, (F)0.112366, (F)0.248535, (F)0.149109, (F)0.096558, (F)-0.027137, 
(F)-0.012626, (F)-0.061770, (F)-0.022233, (F)-0.009323, (F)0.018510, (F)0.040942, 
(F)-0.027927, (F)0.024563, (F)-0.016755, (F)-0.037059, (F)0.015906, (F)-0.010850, 
(F)-0.023998, (F)-0.014398, 
(F)-0.051514, (F)0.204956, (F)0.372681, (F)-0.064636, (F)-0.032776, (F)-0.002654, 
(F)-0.042007, (F)-0.138891, (F)-0.004178, (F)-0.001074, (F)0.010558, (F)0.019198, 
(F)-0.076383, (F)-0.003330, (F)0.013248, (F)0.024089, (F)-0.001688, (F)0.006718, 
(F)0.012215, (F)-0.002119, 
(F)0.076355, (F)0.062012, (F)0.184326, (F)0.134888, (F)0.088196, (F)-0.005830, 
(F)-0.003845, (F)-0.033976, (F)-0.018195, (F)-0.007778, (F)-0.004735, (F)-0.014074, 
(F)-0.011430, (F)-0.010299, (F)-0.008365, (F)-0.024863, (F)-0.006734, (F)-0.005469, 
(F)-0.016257, (F)-0.011897, 
(F)0.128113, (F)0.138977, (F)0.246460, (F)0.215637, (F)-0.175171, (F)-0.016413, 
(F)-0.019315, (F)-0.060743, (F)-0.046499, (F)-0.030685, (F)-0.017805, (F)-0.031575, 
(F)-0.034252, (F)-0.027626, (F)-0.029969, (F)-0.053146, (F)0.022442, (F)0.024345, 
(F)0.043173, (F)0.037773, 
(F)0.024414, (F)-0.067993, (F)0.519775, (F)0.147827, (F)-0.068176, (F)-0.000596, 
(F)-0.004623, (F)-0.270166, (F)-0.021853, (F)-0.004648, (F)0.001660, (F)-0.012690, 
(F)0.035341, (F)-0.003609, (F)0.010051, (F)-0.076837, (F)0.001664, (F)-0.004636, 
(F)0.035436, (F)0.010078, 
(F)-0.268433, (F)-0.122742, (F)0.238770, (F)-0.146912, (F)0.137817, (F)-0.072056, 
(F)-0.015066, (F)-0.057011, (F)-0.021583, (F)-0.018994, (F)-0.032948, (F)0.064094, 
(F)0.029307, (F)-0.039436, (F)-0.018032, (F)0.035078, (F)0.036995, (F)0.016916, 
(F)-0.032907, (F)0.020247, 
(F)0.107849, (F)-0.088318, (F)0.258789, (F)0.375977, (F)-0.046204, (F)-0.011631, 
(F)-0.007800, (F)-0.066972, (F)-0.141358, (F)-0.002135, (F)0.009525, (F)-0.027910, 
(F)0.022856, (F)-0.040549, (F)0.033205, (F)-0.097299, (F)0.004983, (F)-0.004081, 
(F)0.011957, (F)0.017371, 
(F)0.097290, (F)-0.089294, (F)0.063171, (F)0.423462, (F)0.117188, (F)-0.009465, 
(F)-0.007973, (F)-0.003991, (F)-0.179320, (F)-0.013733, (F)0.008687, (F)-0.006146, 
(F)0.005641, (F)-0.041199, (F)0.037813, (F)-0.026751, (F)-0.011401, (F)0.010464, 
(F)-0.007403, (F)-0.049624, 
(F)-0.034302, (F)0.287842, (F)0.249329, (F)-0.036072, (F)0.147766, (F)-0.001177, 
(F)-0.082853, (F)-0.062165, (F)-0.001301, (F)-0.021835, (F)0.009873, (F)0.008552, 
(F)-0.071767, (F)-0.001237, (F)0.010383, (F)0.008994, (F)0.005069, (F)-0.042533, 
(F)-0.036842, (F)0.005330, 
(F)0.094727, (F)0.535767, (F)-0.057068, (F)0.021606, (F)-0.086914, (F)-0.008973, 
(F)-0.287046, (F)-0.003257, (F)-0.000467, (F)-0.007554, (F)-0.050751, (F)0.005406, 
(F)0.030575, (F)-0.002047, (F)-0.011576, (F)0.001233, (F)0.008233, (F)0.046566, 
(F)-0.004960, (F)0.001878, 
(F)0.294861, (F)-0.270447, (F)0.002502, (F)-0.090271, (F)-0.181641, (F)-0.086943, 
(F)-0.073141, (F)-0.000006, (F)-0.008149, (F)-0.032993, (F)0.079744, (F)-0.000738, 
(F)0.000677, (F)0.026617, (F)-0.024413, (F)0.000226, (F)0.053559, (F)-0.049124, 
(F)0.000455, (F)-0.016397, 
(F)0.127563, (F)0.072754, (F)0.061401, (F)0.100403, (F)0.296204, (F)-0.016272, 
(F)-0.005293, (F)-0.003770, (F)-0.010081, (F)-0.087737, (F)-0.009281, (F)-0.007833, 
(F)-0.004467, (F)-0.012808, (F)-0.007305, (F)-0.006165, (F)-0.037785, (F)-0.021550, 
(F)-0.018187, (F)-0.029740, 
(F)0.145630, (F)0.348633, (F)0.087036, (F)-0.005737, (F)0.082397, (F)-0.021208, 
(F)-0.121545, (F)-0.007575, (F)-0.000033, (F)-0.006789, (F)-0.050771, (F)-0.012675, 
(F)-0.030344, (F)0.000836, (F)0.002000, (F)0.000499, (F)-0.012000, (F)-0.028726, 
(F)-0.007172, (F)0.000473, 
(F)-0.082336, (F)0.066589, (F)0.101257, (F)0.542664, (F)0.019104, (F)-0.006779, 
(F)-0.004434, (F)-0.010253, (F)-0.294484, (F)-0.000365, (F)0.005483, (F)0.008337, 
(F)-0.006743, (F)0.044681, (F)-0.036136, (F)-0.054949, (F)0.001573, (F)-0.001272, 
(F)-0.001934, (F)-0.010367, 
(F)0.609131, (F)0.055908, (F)-0.023254, (F)-0.049316, (F)0.005371, (F)-0.371040, 
(F)-0.003126, (F)-0.000541, (F)-0.002432, (F)-0.000029, (F)-0.034055, (F)0.014165, 
(F)0.001300, (F)0.030040, (F)0.002757, (F)-0.001147, (F)-0.003272, (F)-0.000300, 
(F)0.000125, (F)0.000265, 
(F)0.142700, (F)-0.062927, (F)-0.015137, (F)0.239746, (F)0.395752, (F)-0.020363, 
(F)-0.003960, (F)-0.000229, (F)-0.057478, (F)-0.156620, (F)0.008980, (F)0.002160, 
(F)-0.000953, (F)-0.034212, (F)0.015087, (F)0.003629, (F)-0.056474, (F)0.024904, 
(F)0.005990, (F)-0.094880, 
(F)0.376343, (F)-0.075684, (F)-0.020569, (F)0.224121, (F)-0.077942, (F)-0.141634, 
(F)-0.005728, (F)-0.000423, (F)-0.050230, (F)-0.006075, (F)0.028483, (F)0.007741, 
(F)-0.001557, (F)-0.084346, (F)0.016962, (F)0.004610, (F)0.029333, (F)-0.005899, 
(F)-0.001603, (F)0.017468, 
(F)0.267151, (F)-0.008057, (F)-0.157959, (F)0.103821, (F)0.296936, (F)-0.071370, 
(F)-0.000065, (F)-0.024951, (F)-0.010779, (F)-0.088171, (F)0.002152, (F)0.042199, 
(F)-0.001273, (F)-0.027736, (F)0.000836, (F)0.016399, (F)-0.079327, (F)0.002392, 
(F)0.046904, (F)-0.030828, 
(F)0.158325, (F)0.201111, (F)0.240723, (F)0.090393, (F)0.041626, (F)-0.025067, 
(F)-0.040446, (F)-0.057947, (F)-0.008171, (F)-0.001733, (F)-0.031841, (F)-0.038112, 
(F)-0.048412, (F)-0.014311, (F)-0.018179, (F)-0.021760, (F)-0.006590, (F)-0.008371, 
(F)-0.010020, (F)-0.003763, 
(F)0.253357, (F)0.038086, (F)0.049744, (F)0.273743, (F)0.136047, (F)-0.064190, 
(F)-0.001451, (F)-0.002474, (F)-0.074935, (F)-0.018509, (F)-0.009649, (F)-0.012603, 
(F)-0.001895, (F)-0.069355, (F)-0.010426, (F)-0.013617, (F)-0.034469, (F)-0.005181, 
(F)-0.006767, (F)-0.037242, 
(F)-0.218201, (F)-0.022034, (F)0.300537, (F)0.170349, (F)0.286743, (F)-0.047612, 
(F)-0.000485, (F)-0.090323, (F)-0.029019, (F)-0.082222, (F)-0.004808, (F)0.065577, 
(F)0.006622, (F)0.037170, (F)0.003753, (F)-0.051196, (F)0.062568, (F)0.006318, 
(F)-0.086177, (F)-0.048846, 
(F)-0.153687, (F)0.231384, (F)0.526306, (F)0.019226, (F)0.150452, (F)-0.023620, 
(F)-0.053539, (F)-0.276998, (F)-0.000370, (F)-0.022636, (F)0.035561, (F)0.080886, 
(F)-0.121779, (F)0.002955, (F)-0.004449, (F)-0.010119, (F)0.023122, (F)-0.034812, 
(F)-0.079184, (F)-0.002893, 
(F)-0.042175, (F)0.182434, (F)0.607727, (F)-0.025696, (F)-0.069702, (F)-0.001779, 
(F)-0.033282, (F)-0.369332, (F)-0.000660, (F)-0.004858, (F)0.007694, (F)0.025631, 
(F)-0.110870, (F)-0.001084, (F)0.004688, (F)0.015616, (F)-0.002940, (F)0.012716, 
(F)0.042360, (F)-0.001791, 
(F)-0.117065, (F)0.006348, (F)-0.194702, (F)-0.208130, (F)-0.270996, (F)-0.013704, 
(F)-0.000040, (F)-0.037909, (F)-0.043318, (F)-0.073439, (F)0.000743, (F)-0.022793, 
(F)0.001236, (F)-0.024365, (F)0.001321, (F)-0.040523, (F)-0.031724, (F)0.001720, 
(F)-0.052764, (F)-0.056402, 
(F)-0.205017, (F)-0.101807, (F)0.113159, (F)0.423523, (F)0.087280, (F)-0.042032, 
(F)-0.010365, (F)-0.012805, (F)-0.179372, (F)-0.007618, (F)-0.020872, (F)0.023200, 
(F)0.011520, (F)0.086829, (F)0.043117, (F)-0.047926, (F)0.017894, (F)0.008886, 
(F)-0.009877, (F)-0.036965, 
(F)0.002563, (F)0.592407, (F)0.193115, (F)-0.058105, (F)0.055359, (F)-0.000007, 
(F)-0.350946, (F)-0.037293, (F)-0.003376, (F)-0.003065, (F)-0.001519, (F)-0.000495, 
(F)-0.114403, (F)0.000149, (F)0.034422, (F)0.011221, (F)-0.000142, (F)-0.032795, 
(F)-0.010691, (F)0.003217, 
(F)0.098083, (F)0.047913, (F)0.174683, (F)0.264099, (F)0.201843, (F)-0.009620, 
(F)-0.002296, (F)-0.030514, (F)-0.069748, (F)-0.040741, (F)-0.004699, (F)-0.017133, 
(F)-0.008369, (F)-0.025904, (F)-0.012654, (F)-0.046134, (F)-0.019797, (F)-0.009671, 
(F)-0.035259, (F)-0.053307, 
(F)0.415100, (F)0.208496, (F)0.135925, (F)0.102661, (F)-0.196350, (F)-0.172308, 
(F)-0.043471, (F)-0.018476, (F)-0.010539, (F)-0.038553, (F)-0.086547, (F)-0.056423, 
(F)-0.028340, (F)-0.042615, (F)-0.021404, (F)-0.013954, (F)0.081505, (F)0.040938, 
(F)0.026689, (F)0.020158, 
(F)0.211121, (F)0.237915, (F)0.022217, (F)0.478577, (F)-0.161133, (F)-0.044572, 
(F)-0.056604, (F)-0.000494, (F)-0.229036, (F)-0.025964, (F)-0.050229, (F)-0.004690, 
(F)-0.005286, (F)-0.101037, (F)-0.113861, (F)-0.010632, (F)0.034018, (F)0.038336, 
(F)0.003580, (F)0.077114, 
(F)-0.360229, (F)-0.211060, (F)-0.150452, (F)-0.115112, (F)0.264526, (F)-0.129765, 
(F)-0.044546, (F)-0.022636, (F)-0.013251, (F)-0.069974, (F)-0.076030, (F)-0.054197, 
(F)-0.031754, (F)-0.041467, (F)-0.024296, (F)-0.017319, (F)0.095290, (F)0.055831, 
(F)0.039798, (F)0.030450, 
(F)-0.226440, (F)0.069153, (F)0.479065, (F)0.210144, (F)-0.013123, (F)-0.051275, 
(F)-0.004782, (F)-0.229503, (F)-0.044161, (F)-0.000172, (F)0.015659, (F)0.108480, 
(F)-0.033129, (F)0.047585, (F)-0.014532, (F)-0.100673, (F)-0.002971, (F)0.000907, 
(F)0.006287, (F)0.002758, 
(F)0.252197, (F)0.172607, (F)0.000122, (F)-0.257080, (F)-0.251221, (F)-0.063603, 
(F)-0.029793, (F)0.000000, (F)-0.066090, (F)-0.063112, (F)-0.043531, (F)-0.000031, 
(F)-0.000021, (F)0.064835, (F)0.044374, (F)0.000031, (F)0.063357, (F)0.043363, 
(F)0.000031, (F)-0.064584, 
(F)0.358582, (F)0.518555, (F)-0.109619, (F)0.083984, (F)-0.109009, (F)-0.128581, 
(F)-0.268899, (F)-0.012016, (F)-0.007053, (F)-0.011883, (F)-0.185944, (F)0.039307, 
(F)0.056844, (F)-0.030115, (F)-0.043550, (F)0.009206, (F)0.039089, (F)0.056527, 
(F)-0.011949, (F)0.009155, 
(F)0.191833, (F)0.212585, (F)0.216431, (F)-0.048401, (F)0.273987, (F)-0.036800, 
(F)-0.045193, (F)-0.046842, (F)-0.002343, (F)-0.075069, (F)-0.040781, (F)-0.041519, 
(F)-0.046010, (F)0.009285, (F)0.010289, (F)0.010475, (F)-0.052560, (F)-0.058246, 
(F)-0.059299, (F)0.013261, 
(F)0.173645, (F)0.486145, (F)0.225525, (F)-0.331543, (F)0.242798, (F)-0.030153, 
(F)-0.236337, (F)-0.050861, (F)-0.109921, (F)-0.058951, (F)-0.084417, (F)-0.039161, 
(F)-0.109638, (F)0.057571, (F)0.161178, (F)0.074771, (F)-0.042161, (F)-0.118035, 
(F)-0.054757, (F)0.080498, 
(F)0.093872, (F)0.009155, (F)0.435730, (F)0.125061, (F)0.189026, (F)-0.008812, 
(F)-0.000084, (F)-0.189861, (F)-0.015640, (F)-0.035731, (F)-0.000859, (F)-0.040903, 
(F)-0.003989, (F)-0.011740, (F)-0.001145, (F)-0.054493, (F)-0.017744, (F)-0.001731, 
(F)-0.082364, (F)-0.023640, 
(F)0.037720, (F)0.458984, (F)0.288635, (F)-0.014526, (F)-0.205872, (F)-0.001423, 
(F)-0.210667, (F)-0.083310, (F)-0.000211, (F)-0.042383, (F)-0.017313, (F)-0.010887, 
(F)-0.132479, (F)0.000548, (F)0.006667, (F)0.004193, (F)0.007765, (F)0.094492, 
(F)0.059422, (F)-0.002991, 
(F)0.180969, (F)-0.183899, (F)0.482910, (F)0.431885, (F)-0.121887, (F)-0.032750, 
(F)-0.033819, (F)-0.233202, (F)-0.186524, (F)-0.014856, (F)0.033280, (F)-0.087392, 
(F)0.088807, (F)-0.078158, (F)0.079423, (F)-0.208562, (F)0.022058, (F)-0.022415, 
(F)0.058861, (F)0.052641, 
(F)0.149109, (F)-0.056702, (F)-0.067932, (F)0.590637, (F)0.252563, (F)-0.022233, 
(F)-0.003215, (F)-0.004615, (F)-0.348852, (F)-0.063788, (F)0.008455, (F)0.010129, 
(F)-0.003852, (F)-0.088069, (F)0.033490, (F)0.040123, (F)-0.037659, (F)0.014321, 
(F)0.017157, (F)-0.149173, 
(F)0.119995, (F)0.201965, (F)0.615540, (F)-0.207458, (F)0.128479, (F)-0.014399, 
(F)-0.040790, (F)-0.378889, (F)-0.043039, (F)-0.016507, (F)-0.024235, (F)-0.073862, 
(F)-0.124318, (F)0.024894, (F)0.041899, (F)0.127699, (F)-0.015417, (F)-0.025948, 
(F)-0.079084, (F)0.026654, 
(F)-0.006836, (F)-0.083496, (F)0.541260, (F)0.294312, (F)0.125000, (F)-0.000047, 
(F)-0.006972, (F)-0.292962, (F)-0.086619, (F)-0.015625, (F)-0.000571, (F)0.003700, 
(F)0.045193, (F)0.002012, (F)0.024574, (F)-0.159299, (F)0.000854, (F)0.010437, 
(F)-0.067657, (F)-0.036789, 
(F)-0.158508, (F)0.026733, (F)-0.112244, (F)0.380188, (F)0.443481, (F)-0.025125, 
(F)-0.000715, (F)-0.012599, (F)-0.144543, (F)-0.196676, (F)0.004237, (F)-0.017792, 
(F)0.003001, (F)0.060263, (F)-0.010164, (F)0.042674, (F)0.070295, (F)-0.011856, 
(F)0.049778, (F)-0.168606, 
(F)0.210815, (F)0.033752, (F)0.557068, (F)0.301880, (F)-0.341553, (F)-0.044443, 
(F)-0.001139, (F)-0.310325, (F)-0.091131, (F)-0.116658, (F)-0.007116, (F)-0.117439, 
(F)-0.018802, (F)-0.063641, (F)-0.010189, (F)-0.168168, (F)0.072005, (F)0.011528, 
(F)0.190268, (F)0.103108, 
(F)-0.032471, (F)-0.040466, (F)0.748413, (F)0.152283, (F)-0.061279, (F)-0.001054, 
(F)-0.001638, (F)-0.560122, (F)-0.023190, (F)-0.003755, (F)-0.001314, (F)0.024301, 
(F)0.030286, (F)0.004945, (F)0.006162, (F)-0.113970, (F)-0.001990, (F)-0.002480, 
(F)0.045862, (F)0.009332, 
(F)-0.128174, (F)0.080383, (F)-0.092102, (F)0.697327, (F)0.182922, (F)-0.016429, 
(F)-0.006461, (F)-0.008483, (F)-0.486264, (F)-0.033461, (F)0.010303, (F)-0.011805, 
(F)0.007403, (F)0.089379, (F)-0.056053, (F)0.064225, (F)0.023446, (F)-0.014704, 
(F)0.016848, (F)-0.127557, 
(F)0.072815, (F)-0.164612, (F)0.687195, (F)0.327942, (F)-0.046570, (F)-0.005302, 
(F)-0.027097, (F)-0.472237, (F)-0.107546, (F)-0.002169, (F)0.011986, (F)-0.050038, 
(F)0.113120, (F)-0.023879, (F)0.053983, (F)-0.225360, (F)0.003391, (F)-0.007666, 
(F)0.032003, (F)0.015272, 
(F)0.146790, (F)-0.028748, (F)0.676208, (F)0.012390, (F)0.047729, (F)-0.021547, 
(F)-0.000826, (F)-0.457258, (F)-0.000154, (F)-0.002278, (F)0.004220, (F)-0.099260, 
(F)0.019439, (F)-0.001819, (F)0.000356, (F)-0.008378, (F)-0.007006, (F)0.001372, 
(F)-0.032275, (F)-0.000591, 
(F)-0.114197, (F)0.346985, (F)0.689087, (F)-0.162476, (F)0.082581, (F)-0.013041, 
(F)-0.120398, (F)-0.474841, (F)-0.026398, (F)-0.006820, (F)0.039625, (F)0.078692, 
(F)-0.239103, (F)-0.018554, (F)0.056377, (F)0.111960, (F)0.009430, (F)-0.028654, 
(F)-0.056905, (F)0.013417, 
(F)-0.229980, (F)0.361755, (F)-0.188782, (F)0.307678, (F)0.318115, (F)-0.052891, 
(F)-0.130867, (F)-0.035639, (F)-0.094666, (F)-0.101197, (F)0.083197, (F)-0.043416, 
(F)0.068293, (F)0.070760, (F)-0.111304, (F)0.058084, (F)0.073160, (F)-0.115080, 
(F)0.060054, (F)-0.097877, 
(F)-0.155396, (F)0.579956, (F)0.364319, (F)-0.148926, (F)0.117676, (F)-0.024148, 
(F)-0.336349, (F)-0.132728, (F)-0.022179, (F)-0.013848, (F)0.090123, (F)0.056614, 
(F)-0.211289, (F)-0.023142, (F)0.086370, (F)0.054256, (F)0.018286, (F)-0.068247, 
(F)-0.042872, (F)0.017525, 
(F)-0.302917, (F)0.217773, (F)0.280273, (F)0.336182, (F)0.210632, (F)-0.091759, 
(F)-0.047425, (F)-0.078553, (F)-0.113018, (F)-0.044366, (F)0.065967, (F)0.084900, 
(F)-0.061036, (F)0.101835, (F)-0.073211, (F)-0.094223, (F)0.063804, (F)-0.045870, 
(F)-0.059035, (F)-0.070811, 
(F)0.106506, (F)-0.157837, (F)0.243103, (F)0.665222, (F)-0.094666, (F)-0.011344, 
(F)-0.024912, (F)-0.059099, (F)-0.442521, (F)-0.008962, (F)0.016811, (F)-0.025892, 
(F)0.038371, (F)-0.070850, (F)0.104997, (F)-0.161718, (F)0.010082, (F)-0.014942, 
(F)0.023013, (F)0.062974, 
(F)0.052917, (F)-0.027832, (F)-0.044373, (F)0.205627, (F)0.721558, (F)-0.002800, 
(F)-0.000775, (F)-0.001969, (F)-0.042283, (F)-0.520645, (F)0.001473, (F)0.002348, 
(F)-0.001235, (F)-0.010881, (F)0.005723, (F)0.009124, (F)-0.038183, (F)0.020082, 
(F)0.032017, (F)-0.148372, 
(F)0.459900, (F)0.147827, (F)0.117554, (F)0.085754, (F)0.097595, (F)-0.211508, 
(F)-0.021853, (F)-0.013819, (F)-0.007354, (F)-0.009525, (F)-0.067986, (F)-0.054063, 
(F)-0.017378, (F)-0.039438, (F)-0.012677, (F)-0.010081, (F)-0.044884, (F)-0.014427, 
(F)-0.011473, (F)-0.008369, 
(F)0.063538, (F)-0.044861, (F)-0.008667, (F)0.806213, (F)0.092468, (F)-0.004037, 
(F)-0.002012, (F)-0.000075, (F)-0.649980, (F)-0.008550, (F)0.002850, (F)0.000551, 
(F)-0.000389, (F)-0.051225, (F)0.036167, (F)0.006987, (F)-0.005875, (F)0.004148, 
(F)0.000801, (F)-0.074549, 
(F)0.485229, (F)0.411682, (F)-0.088135, (F)-0.061523, (F)0.166077, (F)-0.235448, 
(F)-0.169482, (F)-0.007768, (F)-0.003785, (F)-0.027581, (F)-0.199760, (F)0.042766, 
(F)0.036284, (F)0.029853, (F)0.025328, (F)-0.005422, (F)-0.080585, (F)-0.068371, 
(F)0.014637, (F)0.010218, 
(F)-0.290161, (F)-0.084167, (F)0.276001, (F)-0.035278, (F)-0.349915, (F)-0.084193, 
(F)-0.007084, (F)-0.076177, (F)-0.001245, (F)-0.122440, (F)-0.024422, (F)0.080085, 
(F)0.023230, (F)-0.010236, (F)-0.002969, (F)0.009737, (F)-0.101532, (F)-0.029451, 
(F)0.096577, (F)-0.012344, 
(F)0.196533, (F)0.364868, (F)0.361511, (F)0.148315, (F)-0.164124, (F)-0.038625, 
(F)-0.133129, (F)-0.130690, (F)-0.021997, (F)-0.026937, (F)-0.071709, (F)-0.071049, 
(F)-0.131904, (F)-0.029149, (F)-0.054116, (F)-0.053618, (F)0.032256, (F)0.059883, 
(F)0.059333, (F)0.024342, 
(F)0.023010, (F)0.080078, (F)0.853149, (F)-0.089722, (F)0.041321, (F)-0.000529, 
(F)-0.006413, (F)-0.727864, (F)-0.008050, (F)-0.001707, (F)-0.001843, (F)-0.019631, 
(F)-0.068319, (F)0.002065, (F)0.007185, (F)0.076546, (F)-0.000951, (F)-0.003309, 
(F)-0.035253, (F)0.003707, 
(F)-0.209656, (F)0.413208, (F)0.019165, (F)-0.054016, (F)0.347046, (F)-0.043956, 
(F)-0.170741, (F)-0.000367, (F)-0.002918, (F)-0.120441, (F)0.086631, (F)0.004018, 
(F)-0.007919, (F)-0.011325, (F)0.022320, (F)0.001035, (F)0.072760, (F)-0.143402, 
(F)-0.006651, (F)0.018746, 
(F)0.193542, (F)0.535522, (F)-0.137939, (F)0.163513, (F)0.187317, (F)-0.037459, 
(F)-0.286784, (F)-0.019027, (F)-0.026737, (F)-0.035088, (F)-0.103646, (F)0.026697, 
(F)0.073870, (F)-0.031647, (F)-0.087565, (F)0.022555, (F)-0.036254, (F)-0.100312, 
(F)0.025838, (F)-0.030629, 
(F)0.339172, (F)0.092102, (F)0.330017, (F)-0.007629, (F)-0.450806, (F)-0.115038, 
(F)-0.008483, (F)-0.108911, (F)-0.000058, (F)-0.203226, (F)-0.031238, (F)-0.111933, 
(F)-0.030395, (F)0.002588, (F)0.000703, (F)0.002518, (F)0.152901, (F)0.041520, 
(F)0.148774, (F)-0.003439, 
(F)-0.173218, (F)0.158386, (F)0.807373, (F)0.016541, (F)0.109436, (F)-0.030004, 
(F)-0.025086, (F)-0.651851, (F)-0.000274, (F)-0.011976, (F)0.027435, (F)0.139851, 
(F)-0.127877, (F)0.002865, (F)-0.002620, (F)-0.013354, (F)0.018956, (F)-0.017333, 
(F)-0.088356, (F)-0.001810, 
(F)0.040527, (F)-0.016968, (F)0.913452, (F)0.058044, (F)-0.043396, (F)-0.001642, 
(F)-0.000288, (F)-0.834395, (F)-0.003369, (F)-0.001883, (F)0.000688, (F)-0.037020, 
(F)0.015499, (F)-0.002352, (F)0.000985, (F)-0.053021, (F)0.001759, (F)-0.000736, 
(F)0.039640, (F)0.002519, 
(F)0.049316, (F)0.108032, (F)0.528442, (F)0.357849, (F)-0.090698, (F)-0.002432, 
(F)-0.011671, (F)-0.279251, (F)-0.128056, (F)-0.008226, (F)-0.005328, (F)-0.026061, 
(F)-0.057089, (F)-0.017648, (F)-0.038659, (F)-0.189103, (F)0.004473, (F)0.009798, 
(F)0.047929, (F)0.032456, 
(F)0.186951, (F)0.093933, (F)0.122070, (F)-0.033081, (F)0.584473, (F)-0.034951, 
(F)-0.008823, (F)-0.014901, (F)-0.001094, (F)-0.341608, (F)-0.017561, (F)-0.022821, 
(F)-0.011466, (F)0.006185, (F)0.003107, (F)0.004038, (F)-0.109268, (F)-0.054901, 
(F)-0.071347, (F)0.019335, 
(F)0.031372, (F)0.859558, (F)-0.019714, (F)0.054688, (F)-0.054382, (F)-0.000984, 
(F)-0.738840, (F)-0.000389, (F)-0.002991, (F)-0.002957, (F)-0.026966, (F)0.000618, 
(F)0.016946, (F)-0.001716, (F)-0.047007, (F)0.001078, (F)0.001706, (F)0.046745, 
(F)-0.001072, (F)0.002974, 
(F)0.054443, (F)0.009644, (F)0.319641, (F)0.674866, (F)-0.097839, (F)-0.002964, 
(F)-0.000093, (F)-0.102170, (F)-0.455444, (F)-0.009573, (F)-0.000525, (F)-0.017402, 
(F)-0.003082, (F)-0.036742, (F)-0.006508, (F)-0.215715, (F)0.005327, (F)0.000944, 
(F)0.031273, (F)0.066028, 
(F)-0.098389, (F)0.156494, (F)-0.262207, (F)0.764526, (F)0.348511, (F)-0.009680, 
(F)-0.024490, (F)-0.068753, (F)-0.584501, (F)-0.121460, (F)0.015397, (F)-0.025798, 
(F)0.041034, (F)0.075221, (F)-0.119644, (F)0.200464, (F)0.034290, (F)-0.054540, 
(F)0.091382, (F)-0.266446, 
(F)0.298401, (F)-0.419800, (F)0.037354, (F)0.372864, (F)0.290100, (F)-0.089043, 
(F)-0.176232, (F)-0.001395, (F)-0.139027, (F)-0.084158, (F)0.125269, (F)-0.011146, 
(F)0.015681, (F)-0.111263, (F)0.156528, (F)-0.013928, (F)-0.086566, (F)0.121784, 
(F)-0.010836, (F)-0.108168, 
(F)0.186340, (F)-0.030884, (F)0.146667, (F)0.587463, (F)0.080688, (F)-0.034723, 
(F)-0.000954, (F)-0.021511, (F)-0.345113, (F)-0.006511, (F)0.005755, (F)-0.027330, 
(F)0.004530, (F)-0.109468, (F)0.018143, (F)-0.086162, (F)-0.015036, (F)0.002492, 
(F)-0.011834, (F)-0.047402, 
(F)-0.046021, (F)0.787598, (F)0.273438, (F)-0.128967, (F)0.089783, (F)-0.002118, 
(F)-0.620310, (F)-0.074768, (F)-0.016633, (F)-0.008061, (F)0.036246, (F)0.012584, 
(F)-0.215359, (F)-0.005935, (F)0.101574, (F)0.035264, (F)0.004132, (F)-0.070713, 
(F)-0.024550, (F)0.011579, 
(F)0.259705, (F)0.090088, (F)0.308533, (F)0.146057, (F)0.177734, (F)-0.067446, 
(F)-0.008116, (F)-0.095192, (F)-0.021333, (F)-0.031590, (F)-0.023396, (F)-0.080127, 
(F)-0.027795, (F)-0.037932, (F)-0.013158, (F)-0.045063, (F)-0.046158, (F)-0.016012, 
(F)-0.054837, (F)-0.025959, 
(F)-0.083679, (F)0.032654, (F)0.086487, (F)0.891357, (F)-0.060852, (F)-0.007002, 
(F)-0.001066, (F)-0.007480, (F)-0.794518, (F)-0.003703, (F)0.002732, (F)0.007237, 
(F)-0.002824, (F)0.074588, (F)-0.029106, (F)-0.077091, (F)-0.005092, (F)0.001987, 
(F)0.005263, (F)0.054241, 
(F)0.327637, (F)-0.106445, (F)0.249207, (F)-0.075439, (F)0.229065, (F)-0.107346, 
(F)-0.011331, (F)-0.062104, (F)-0.005691, (F)-0.052471, (F)0.034875, (F)-0.081649, 
(F)0.026527, (F)0.024717, (F)-0.008030, (F)0.018800, (F)-0.075050, (F)0.024383, 
(F)-0.057084, (F)0.017281, 
(F)0.096924, (F)-0.189026, (F)0.879822, (F)0.225769, (F)-0.071472, (F)-0.009394, 
(F)-0.035731, (F)-0.774086, (F)-0.050972, (F)-0.005108, (F)0.018321, (F)-0.085276, 
(F)0.166309, (F)-0.021882, (F)0.042676, (F)-0.198637, (F)0.006927, (F)-0.013510, 
(F)0.062883, (F)0.016136, 
(F)0.012939, (F)0.487610, (F)0.578064, (F)-0.204102, (F)0.122620, (F)-0.000167, 
(F)-0.237763, (F)-0.334158, (F)-0.041657, (F)-0.015036, (F)-0.006309, (F)-0.007480, 
(F)-0.281870, (F)0.002641, (F)0.099522, (F)0.117984, (F)-0.001587, (F)-0.059791, 
(F)-0.070882, (F)0.025027, 
(F)0.052246, (F)0.140015, (F)-0.038269, (F)0.422974, (F)0.422913, (F)-0.002730, 
(F)-0.019604, (F)-0.001465, (F)-0.178907, (F)-0.178855, (F)-0.007315, (F)0.001999, 
(F)0.005358, (F)-0.022099, (F)-0.059223, (F)0.016187, (F)-0.022096, (F)-0.059214, 
(F)0.016184, (F)-0.178881, 
(F)0.143860, (F)-0.255554, (F)0.437134, (F)0.468933, (F)0.205750, (F)-0.020696, 
(F)-0.065308, (F)-0.191086, (F)-0.219898, (F)-0.042333, (F)0.036764, (F)-0.062886, 
(F)0.111711, (F)-0.067461, (F)0.119838, (F)-0.204987, (F)-0.029599, (F)0.052580, 
(F)-0.089940, (F)-0.096483, 
(F)0.021362, (F)0.279846, (F)0.857727, (F)-0.233093, (F)0.074341, (F)-0.000456, 
(F)-0.078314, (F)-0.735696, (F)-0.054332, (F)-0.005527, (F)-0.005978, (F)-0.018323, 
(F)-0.240032, (F)0.004979, (F)0.065230, (F)0.199930, (F)-0.001588, (F)-0.020804, 
(F)-0.063764, (F)0.017328, 
(F)-0.198242, (F)0.215515, (F)0.028992, (F)0.130432, (F)0.714783, (F)-0.039300, 
(F)-0.046447, (F)-0.000841, (F)-0.017013, (F)-0.510914, (F)0.042724, (F)0.005747, 
(F)-0.006248, (F)0.025857, (F)-0.028110, (F)-0.003781, (F)0.141700, (F)-0.154046, 
(F)-0.020723, (F)-0.093231, 
(F)-0.184143, (F)0.235107, (F)0.105286, (F)0.515137, (F)0.320862, (F)-0.033909, 
(F)-0.055275, (F)-0.011085, (F)-0.265366, (F)-0.102952, (F)0.043293, (F)0.019388, 
(F)-0.024753, (F)0.094859, (F)-0.121112, (F)-0.054237, (F)0.059084, (F)-0.075437, 
(F)-0.033782, (F)-0.165288, 
(F)-0.055481, (F)0.195068, (F)0.946777, (F)-0.154297, (F)0.065063, (F)-0.003078, 
(F)-0.038052, (F)-0.896387, (F)-0.023808, (F)-0.004233, (F)0.010823, (F)0.052528, 
(F)-0.184686, (F)-0.008561, (F)0.030098, (F)0.146085, (F)0.003610, (F)-0.012692, 
(F)-0.061601, (F)0.010039, 
(F)0.058533, (F)-0.205688, (F)0.586975, (F)0.582581, (F)-0.107483, (F)-0.003426, 
(F)-0.042308, (F)-0.344540, (F)-0.339400, (F)-0.011553, (F)0.012040, (F)-0.034357, 
(F)0.120734, (F)-0.034100, (F)0.119830, (F)-0.341960, (F)0.006291, (F)-0.022108, 
(F)0.063090, (F)0.062617, 
(F)0.462341, (F)0.719971, (F)-0.295715, (F)0.198486, (F)-0.103943, (F)-0.213759, 
(F)-0.518358, (F)-0.087448, (F)-0.039397, (F)-0.010804, (F)-0.332872, (F)0.136721, 
(F)0.212906, (F)-0.091768, (F)-0.142904, (F)0.058695, (F)0.048057, (F)0.074836, 
(F)-0.030738, (F)0.020631, 
(F)0.391174, (F)0.105103, (F)0.107666, (F)-0.255798, (F)0.367126, (F)-0.153017, 
(F)-0.011047, (F)-0.011592, (F)-0.065433, (F)-0.134782, (F)-0.041113, (F)-0.042116, 
(F)-0.011316, (F)0.100062, (F)0.026885, (F)0.027541, (F)-0.143610, (F)-0.038586, 
(F)-0.039527, (F)0.093910, 
(F)-0.147705, (F)0.742249, (F)0.307495, (F)0.078491, (F)-0.128052, (F)-0.021817, 
(F)-0.550933, (F)-0.094553, (F)-0.006161, (F)-0.016397, (F)0.109634, (F)0.045419, 
(F)-0.228238, (F)0.011594, (F)-0.058260, (F)-0.024136, (F)-0.018914, (F)0.095046, 
(F)0.039375, (F)0.010051, 
(F)-0.136230, (F)-0.081848, (F)0.442261, (F)0.578003, (F)-0.120667, (F)-0.018559, 
(F)-0.006699, (F)-0.195595, (F)-0.334087, (F)-0.014560, (F)-0.011150, (F)0.060249, 
(F)0.036198, (F)0.078742, (F)0.047308, (F)-0.255628, (F)-0.016438, (F)-0.009876, 
(F)0.053366, (F)0.069746, 
(F)0.062866, (F)0.429321, (F)0.258240, (F)0.094666, (F)0.187805, (F)-0.003952, 
(F)-0.184317, (F)-0.066688, (F)-0.008962, (F)-0.035271, (F)-0.026990, (F)-0.016235, 
(F)-0.110868, (F)-0.005951, (F)-0.040642, (F)-0.024446, (F)-0.011807, (F)-0.080629, 
(F)-0.048499, (F)-0.017779, 
(F)0.312561, (F)0.722351, (F)-0.029114, (F)-0.106750, (F)0.140259, (F)-0.097694, 
(F)-0.521791, (F)-0.000848, (F)-0.011396, (F)-0.019673, (F)-0.225779, (F)0.009100, 
(F)0.021030, (F)0.033366, (F)0.077111, (F)-0.003108, (F)-0.043839, (F)-0.101316, 
(F)0.004083, (F)0.014973, 
(F)-0.203125, (F)0.233582, (F)0.361389, (F)0.608887, (F)-0.063782, (F)-0.041260, 
(F)-0.054560, (F)-0.130602, (F)-0.370743, (F)-0.004068, (F)0.047446, (F)0.073407, 
(F)-0.084414, (F)0.123680, (F)-0.142225, (F)-0.220045, (F)-0.012956, (F)0.014898, 
(F)0.023050, (F)0.038836, 
(F)0.232727, (F)0.348999, (F)-0.284790, (F)-0.208252, (F)0.346313, (F)-0.054162, 
(F)-0.121800, (F)-0.081105, (F)-0.043369, (F)-0.119933, (F)-0.081222, (F)0.066278, 
(F)0.099391, (F)0.048466, (F)0.072680, (F)-0.059308, (F)-0.080597, (F)-0.120863, 
(F)0.098627, (F)0.072120, 
(F)0.082275, (F)-0.224121, (F)0.802856, (F)0.423462, (F)-0.103149, (F)-0.006769, 
(F)-0.050230, (F)-0.644578, (F)-0.179320, (F)-0.010640, (F)0.018440, (F)-0.066055, 
(F)0.179937, (F)-0.034840, (F)0.094907, (F)-0.339979, (F)0.008487, (F)-0.023118, 
(F)0.082814, (F)0.043680, 
(F)0.131287, (F)-0.218872, (F)0.424133, (F)0.740417, (F)-0.074707, (F)-0.017236, 
(F)-0.047905, (F)-0.179889, (F)-0.548218, (F)-0.005581, (F)0.028735, (F)-0.055683, 
(F)0.092831, (F)-0.097207, (F)0.162057, (F)-0.314036, (F)0.009808, (F)-0.016351, 
(F)0.031686, (F)0.055314, 
(F)-0.176331, (F)0.588806, (F)0.627197, (F)-0.166504, (F)0.060730, (F)-0.031092, 
(F)-0.346693, (F)-0.393376, (F)-0.027724, (F)-0.003688, (F)0.103825, (F)0.110594, 
(F)-0.369298, (F)-0.029360, (F)0.098039, (F)0.104431, (F)0.010709, (F)-0.035758, 
(F)-0.038090, (F)0.010112, 
(F)0.377014, (F)0.133301, (F)0.033875, (F)0.121155, (F)0.402161, (F)-0.142140, 
(F)-0.017769, (F)-0.001147, (F)-0.014678, (F)-0.161733, (F)-0.050256, (F)-0.012771, 
(F)-0.004515, (F)-0.045677, (F)-0.016150, (F)-0.004104, (F)-0.151620, (F)-0.053608, 
(F)-0.013623, (F)-0.048724, 
(F)-0.030029, (F)0.023865, (F)1.047729, (F)-0.041565, (F)0.014648, (F)-0.000902, 
(F)-0.000570, (F)-1.097737, (F)-0.001728, (F)-0.000215, (F)0.000717, (F)0.031463, 
(F)-0.025004, (F)-0.001248, (F)0.000992, (F)0.043549, (F)0.000440, (F)-0.000350, 
(F)-0.015348, (F)0.000609, 
(F)0.770752, (F)0.332520, (F)-0.160522, (F)0.183777, (F)-0.164490, (F)-0.594059, 
(F)-0.110569, (F)-0.025767, (F)-0.033774, (F)-0.027057, (F)-0.256290, (F)0.123723, 
(F)0.053377, (F)-0.141646, (F)-0.061109, (F)0.029500, (F)0.126781, (F)0.054696, 
(F)-0.026404, (F)0.030229, 
(F)-0.221436, (F)-0.032593, (F)0.210388, (F)0.427368, (F)0.412048, (F)-0.049034, 
(F)-0.001062, (F)-0.044263, (F)-0.182644, (F)-0.169784, (F)-0.007217, (F)0.046587, 
(F)0.006857, (F)0.094635, (F)0.013929, (F)-0.089913, (F)0.091242, (F)0.013430, 
(F)-0.086690, (F)-0.176096, 
(F)-0.319763, (F)0.360168, (F)0.494812, (F)0.222778, (F)0.295776, (F)-0.102248, 
(F)-0.129721, (F)-0.244839, (F)-0.049630, (F)-0.087484, (F)0.115169, (F)0.158223, 
(F)-0.178216, (F)0.071236, (F)-0.080238, (F)-0.110233, (F)0.094578, (F)-0.106529, 
(F)-0.146354, (F)-0.065893, 
(F)0.375793, (F)0.407593, (F)0.250183, (F)-0.065552, (F)0.143311, (F)-0.141221, 
(F)-0.166132, (F)-0.062592, (F)-0.004297, (F)-0.020538, (F)-0.153171, (F)-0.094017, 
(F)-0.101973, (F)0.024634, (F)0.026718, (F)0.016400, (F)-0.053855, (F)-0.058412, 
(F)-0.035854, (F)0.009394, 
(F)0.065857, (F)0.982605, (F)0.014771, (F)-0.053772, (F)0.103149, (F)-0.004337, 
(F)-0.965513, (F)-0.000218, (F)-0.002891, (F)-0.010640, (F)-0.064711, (F)-0.000973, 
(F)-0.014514, (F)0.003541, (F)0.052837, (F)0.000794, (F)-0.006793, (F)-0.101355, 
(F)-0.001524, (F)0.005547, 
(F)-0.016968, (F)0.013855, (F)-0.063416, (F)0.099854, (F)1.034241, (F)-0.000288, 
(F)-0.000192, (F)-0.004022, (F)-0.009971, (F)-1.069654, (F)0.000235, (F)-0.001076, 
(F)0.000879, (F)0.001694, (F)-0.001383, (F)0.006332, (F)0.017549, (F)-0.014329, 
(F)0.065587, (F)-0.103273, 
(F)0.963013, (F)-0.088745, (F)0.035034, (F)-0.036804, (F)-0.006531, (F)-0.927393, 
(F)-0.007876, (F)-0.001227, (F)-0.001355, (F)-0.000043, (F)0.085463, (F)-0.033738, 
(F)0.003109, (F)0.035443, (F)-0.003266, (F)0.001289, (F)0.006289, (F)-0.000580, 
(F)0.000229, (F)-0.000240, 
(F)0.146851, (F)-0.051025, (F)0.807129, (F)0.487854, (F)-0.260376, (F)-0.021565, 
(F)-0.002604, (F)-0.651457, (F)-0.238002, (F)-0.067796, (F)0.007493, (F)-0.118527, 
(F)0.041184, (F)-0.071642, (F)0.024893, (F)-0.393761, (F)0.038236, (F)-0.013286, 
(F)0.210157, (F)0.127025, 
(F)0.194336, (F)0.876953, (F)-0.203613, (F)0.137634, (F)-0.109924, (F)-0.037766, 
(F)-0.769047, (F)-0.041458, (F)-0.018943, (F)-0.012083, (F)-0.170424, (F)0.039569, 
(F)0.178559, (F)-0.026747, (F)-0.120699, (F)0.028024, (F)0.021362, (F)0.096398, 
(F)-0.022382, (F)0.015129, 
(F)-0.103638, (F)1.042236, (F)0.152832, (F)-0.032898, (F)-0.039429, (F)-0.010741, 
(F)-1.086257, (F)-0.023358, (F)-0.001082, (F)-0.001555, (F)0.108015, (F)0.015839, 
(F)-0.159287, (F)-0.003409, (F)0.034287, (F)0.005028, (F)-0.004086, (F)0.041094, 
(F)0.006026, (F)-0.001297, 
(F)0.144958, (F)-0.048645, (F)-0.164551, (F)0.883972, (F)0.328552, (F)-0.021013, 
(F)-0.002366, (F)-0.027077, (F)-0.781407, (F)-0.107947, (F)0.007052, (F)0.023853, 
(F)-0.008005, (F)-0.128139, (F)0.043001, (F)0.145458, (F)-0.047626, (F)0.015982, 
(F)0.054064, (F)-0.290431, 
(F)-0.164246, (F)0.155884, (F)-0.275879, (F)0.584290, (F)0.650330, (F)-0.026977, 
(F)-0.024300, (F)-0.076109, (F)-0.341394, (F)-0.422929, (F)0.025603, (F)-0.045312, 
(F)0.043005, (F)0.095967, (F)-0.091081, (F)0.161193, (F)0.106814, (F)-0.101376, 
(F)0.179412, (F)-0.379981, 
(F)-0.264404, (F)-0.268494, (F)-0.101135, (F)0.297852, (F)0.450134, (F)-0.069910, 
(F)-0.072089, (F)-0.010228, (F)-0.088716, (F)-0.202621, (F)-0.070991, (F)-0.026741, 
(F)-0.027154, (F)0.078753, (F)0.079971, (F)0.030123, (F)0.119017, (F)0.120858, 
(F)0.045524, (F)-0.134073, 
(F)-0.213501, (F)0.451965, (F)0.607605, (F)0.164368, (F)-0.181335, (F)-0.045583, 
(F)-0.204273, (F)-0.369184, (F)-0.027017, (F)-0.032883, (F)0.096495, (F)0.129724, 
(F)-0.274616, (F)0.035093, (F)-0.074288, (F)-0.099871, (F)-0.038715, (F)0.081957, 
(F)0.110180, (F)0.029806, 
(F)0.409973, (F)-0.231445, (F)0.472351, (F)0.170776, (F)0.212952, (F)-0.168078, 
(F)-0.053567, (F)-0.223116, (F)-0.029165, (F)-0.045348, (F)0.094886, (F)-0.193651, 
(F)0.109323, (F)-0.070014, (F)0.039525, (F)-0.080666, (F)-0.087304, (F)0.049287, 
(F)-0.100588, (F)-0.036367, 
(F)0.321228, (F)0.596313, (F)0.211365, (F)0.065247, (F)-0.242371, (F)-0.103187, 
(F)-0.355590, (F)-0.044675, (F)-0.004257, (F)-0.058744, (F)-0.191553, (F)-0.067896, 
(F)-0.126040, (F)-0.020959, (F)-0.038907, (F)-0.013791, (F)0.077856, (F)0.144529, 
(F)0.051229, (F)0.015814, 
(F)0.075867, (F)-0.160767, (F)1.023682, (F)0.114197, (F)0.020264, (F)-0.005756, 
(F)-0.025846, (F)-1.047924, (F)-0.013041, (F)-0.000411, (F)0.012197, (F)-0.077663, 
(F)0.164574, (F)-0.008664, (F)0.018359, (F)-0.116901, (F)-0.001537, (F)0.003258, 
(F)-0.020744, (F)-0.002314, 
(F)0.164246, (F)0.173096, (F)0.189514, (F)0.348572, (F)0.294006, (F)-0.026977, 
(F)-0.029962, (F)-0.035916, (F)-0.121502, (F)-0.086440, (F)-0.028430, (F)-0.031127, 
(F)-0.032804, (F)-0.057251, (F)-0.060336, (F)-0.066059, (F)-0.048289, (F)-0.050891, 
(F)-0.055718, (F)-0.102482, 
(F)0.266479, (F)0.179688, (F)0.440063, (F)0.221375, (F)0.070862, (F)-0.071011, 
(F)-0.032288, (F)-0.193656, (F)-0.049007, (F)-0.005021, (F)-0.047883, (F)-0.117268, 
(F)-0.079074, (F)-0.058992, (F)-0.039778, (F)-0.097419, (F)-0.018883, (F)-0.012733, 
(F)-0.031184, (F)-0.015687, 
(F)0.847656, (F)0.241150, (F)-0.040955, (F)-0.140686, (F)0.204712, (F)-0.718521, 
(F)-0.058153, (F)-0.001677, (F)-0.019793, (F)-0.041907, (F)-0.204412, (F)0.034715, 
(F)0.009876, (F)0.119253, (F)0.033926, (F)-0.005762, (F)-0.173525, (F)-0.049366, 
(F)0.008384, (F)0.028800, 
(F)0.430481, (F)0.356873, (F)0.178772, (F)0.511353, (F)-0.292603, (F)-0.185314, 
(F)-0.127358, (F)-0.031959, (F)-0.261481, (F)-0.085616, (F)-0.153627, (F)-0.076958, 
(F)-0.063799, (F)-0.220128, (F)-0.182488, (F)-0.091416, (F)0.125960, (F)0.104422, 
(F)0.052309, (F)0.149623, 
(F)-0.133728, (F)0.783569, (F)0.560425, (F)-0.238953, (F)0.098694, (F)-0.017883, 
(F)-0.613981, (F)-0.314076, (F)-0.057098, (F)-0.009740, (F)0.104785, (F)0.074945, 
(F)-0.439132, (F)-0.031955, (F)0.187236, (F)0.133915, (F)0.013198, (F)-0.077333, 
(F)-0.055310, (F)0.023583, 
(F)-0.297913, (F)0.800415, (F)0.351990, (F)-0.026550, (F)0.253601, (F)-0.088752, 
(F)-0.640664, (F)-0.123897, (F)-0.000705, (F)-0.064314, (F)0.238454, (F)0.104862, 
(F)-0.281738, (F)-0.007910, (F)0.021251, (F)0.009345, (F)0.075551, (F)-0.202986, 
(F)-0.089265, (F)0.006733, 
(F)0.478699, (F)-0.076294, (F)0.012817, (F)0.433716, (F)-0.317566, (F)-0.229152, 
(F)-0.005821, (F)-0.000164, (F)-0.188109, (F)-0.100848, (F)0.036522, (F)-0.006136, 
(F)0.000978, (F)-0.207619, (F)0.033090, (F)-0.005559, (F)0.152018, (F)-0.024228, 
(F)0.004070, (F)0.137733, 
(F)-0.150330, (F)0.498535, (F)0.888123, (F)-0.238525, (F)0.111572, (F)-0.022599, 
(F)-0.248537, (F)-0.788762, (F)-0.056894, (F)-0.012448, (F)0.074945, (F)0.133511, 
(F)-0.442760, (F)-0.035857, (F)0.118913, (F)0.211840, (F)0.016773, (F)-0.055623, 
(F)-0.099090, (F)0.026613, 
(F)-0.096375, (F)0.021179, (F)-0.016602, (F)-0.166931, (F)0.978455, (F)-0.009288, 
(F)-0.000449, (F)-0.000276, (F)-0.027866, (F)-0.957373, (F)0.002041, (F)-0.001600, 
(F)0.000352, (F)-0.016088, (F)0.003535, (F)-0.002771, (F)0.094298, (F)-0.020723, 
(F)0.016244, (F)0.163335, 
(F)-0.386169, (F)0.081055, (F)0.310852, (F)-0.309998, (F)0.464905, (F)-0.149127, 
(F)-0.006570, (F)-0.096629, (F)-0.096098, (F)-0.216136, (F)0.031301, (F)0.120042, 
(F)-0.025196, (F)-0.119712, (F)0.025127, (F)0.096363, (F)0.179532, (F)-0.037683, 
(F)-0.144517, (F)0.144119, 
(F)0.200562, (F)-0.275208, (F)0.690063, (F)0.672913, (F)-0.160095, (F)-0.040225, 
(F)-0.075739, (F)-0.476188, (F)-0.452811, (F)-0.025630, (F)0.055196, (F)-0.138400, 
(F)0.189911, (F)-0.134960, (F)0.185191, (F)-0.464352, (F)0.032109, (F)-0.044059, 
(F)0.110476, (F)0.107730, 
(F)0.339783, (F)1.089661, (F)-0.229126, (F)0.071167, (F)-0.031677, (F)-0.115452, 
(F)-1.187360, (F)-0.052499, (F)-0.005065, (F)-0.001003, (F)-0.370248, (F)0.077853, 
(F)0.249670, (F)-0.024181, (F)-0.077548, (F)0.016306, (F)0.010763, (F)0.034517, 
(F)-0.007258, (F)0.002254, 
(F)-0.130371, (F)-0.025879, (F)0.933350, (F)0.311768, (F)-0.100586, (F)-0.016997, 
(F)-0.000670, (F)-0.871141, (F)-0.097199, (F)-0.010118, (F)-0.003374, (F)0.121682, 
(F)0.024154, (F)0.040645, (F)0.008068, (F)-0.290988, (F)-0.013113, (F)-0.002603, 
(F)0.093882, (F)0.031359, 
(F)0.138367, (F)-0.201233, (F)0.155579, (F)1.010925, (F)-0.048279, (F)-0.019145, 
(F)-0.040495, (F)-0.024205, (F)-1.021970, (F)-0.002331, (F)0.027844, (F)-0.021527, 
(F)0.031308, (F)-0.139878, (F)0.203431, (F)-0.157278, (F)0.006680, (F)-0.009715, 
(F)0.007511, (F)0.048806, 
(F)0.223083, (F)0.115906, (F)-0.205322, (F)0.383240, (F)0.763550, (F)-0.049766, 
(F)-0.013434, (F)-0.042157, (F)-0.146873, (F)-0.583008, (F)-0.025857, (F)0.045804, 
(F)0.023798, (F)-0.085494, (F)-0.044420, (F)0.078688, (F)-0.170335, (F)-0.088500, 
(F)0.156774, (F)-0.292623, 
(F)0.491455, (F)0.139465, (F)-0.377991, (F)0.313599, (F)0.366394, (F)-0.241528, 
(F)-0.019451, (F)-0.142877, (F)-0.098344, (F)-0.134245, (F)-0.068541, (F)0.185765, 
(F)0.052717, (F)-0.154120, (F)-0.043736, (F)0.118537, (F)-0.180066, (F)-0.051099, 
(F)0.138494, (F)-0.114901, 
(F)-0.023560, (F)-0.139832, (F)0.468689, (F)0.939148, (F)-0.166199, (F)-0.000555, 
(F)-0.019553, (F)-0.219669, (F)-0.881999, (F)-0.027622, (F)-0.003294, (F)0.011042, 
(F)0.065537, (F)0.022126, (F)0.131323, (F)-0.440168, (F)-0.003916, (F)-0.023240, 
(F)0.077896, (F)0.156085, 
(F)0.169495, (F)-0.071594, (F)0.243164, (F)0.798279, (F)0.153076, (F)-0.028728, 
(F)-0.005126, (F)-0.059129, (F)-0.637249, (F)-0.023432, (F)0.012135, (F)-0.041215, 
(F)0.017409, (F)-0.135304, (F)0.057152, (F)-0.194113, (F)-0.025946, (F)0.010959, 
(F)-0.037223, (F)-0.122197, 
(F)-0.114685, (F)0.108093, (F)-0.163818, (F)1.019592, (F)0.111877, (F)-0.013153, 
(F)-0.011684, (F)-0.026836, (F)-1.039568, (F)-0.012517, (F)0.012397, (F)-0.018788, 
(F)0.017708, (F)0.116932, (F)-0.110211, (F)0.167028, (F)0.012831, (F)-0.012093, 
(F)0.018328, (F)-0.114069, 
(F)0.064209, (F)0.274353, (F)0.947205, (F)0.089539, (F)-0.246094, (F)-0.004123, 
(F)-0.075270, (F)-0.897197, (F)-0.008017, (F)-0.060562, (F)-0.017616, (F)-0.060819, 
(F)-0.259868, (F)-0.005749, (F)-0.024565, (F)-0.084811, (F)0.015801, (F)0.067517, 
(F)0.233101, (F)0.022035, 
(F)0.183716, (F)0.155273, (F)0.425354, (F)0.461365, (F)0.121826, (F)-0.033752, 
(F)-0.024110, (F)-0.180926, (F)-0.212857, (F)-0.014842, (F)-0.028526, (F)-0.078144, 
(F)-0.066046, (F)-0.084760, (F)-0.071638, (F)-0.196243, (F)-0.022381, (F)-0.018916, 
(F)-0.051819, (F)-0.056206, 
(F)-0.317932, (F)-0.113953, (F)0.531799, (F)0.631775, (F)0.094543, (F)-0.101081, 
(F)-0.012985, (F)-0.282811, (F)-0.399140, (F)-0.008938, (F)-0.036229, (F)0.169076, 
(F)0.060600, (F)0.200862, (F)0.071992, (F)-0.335977, (F)0.030058, (F)0.010773, 
(F)-0.050278, (F)-0.059730, 
(F)-0.263306, (F)0.519592, (F)0.055725, (F)0.460632, (F)-0.166199, (F)-0.069330, 
(F)-0.269976, (F)-0.003105, (F)-0.212182, (F)-0.027622, (F)0.136812, (F)0.014673, 
(F)-0.028954, (F)0.121287, (F)-0.239341, (F)-0.025669, (F)-0.043761, (F)0.086356, 
(F)0.009261, (F)0.076557, 
(F)0.789124, (F)-0.074402, (F)0.149414, (F)0.107239, (F)0.384705, (F)-0.622716, 
(F)-0.005536, (F)-0.022325, (F)-0.011500, (F)-0.147998, (F)0.058712, (F)-0.117906, 
(F)0.011117, (F)-0.084625, (F)0.007979, (F)-0.016023, (F)-0.303579, (F)0.028623, 
(F)-0.057480, (F)-0.041255, 
(F)0.394592, (F)0.252197, (F)0.193298, (F)0.192871, (F)0.347717, (F)-0.155703, 
(F)-0.063603, (F)-0.037364, (F)-0.037199, (F)-0.120907, (F)-0.099515, (F)-0.076274, 
(F)-0.048749, (F)-0.076105, (F)-0.048642, (F)-0.037282, (F)-0.137207, (F)-0.087693, 
(F)-0.067213, (F)-0.067065, 
(F)-0.221924, (F)0.296570, (F)1.154419, (F)-0.081482, (F)0.049438, (F)-0.049250, 
(F)-0.087954, (F)-1.332683, (F)-0.006639, (F)-0.002444, (F)0.065816, (F)0.256193, 
(F)-0.342366, (F)-0.018083, (F)0.024165, (F)0.094064, (F)0.010972, (F)-0.014662, 
(F)-0.057073, (F)0.004028, 
(F)0.539795, (F)0.479980, (F)0.039917, (F)-0.247986, (F)-0.346680, (F)-0.291379, 
(F)-0.230381, (F)-0.001593, (F)-0.061497, (F)-0.120187, (F)-0.259091, (F)-0.021547, 
(F)-0.019159, (F)0.133861, (F)0.119028, (F)0.009899, (F)0.187136, (F)0.166399, 
(F)0.013838, (F)-0.085972, 
(F)0.113464, (F)0.160767, (F)0.563232, (F)0.060791, (F)0.577637, (F)-0.012874, 
(F)-0.025846, (F)-0.317231, (F)-0.003696, (F)-0.333664, (F)-0.018241, (F)-0.063907, 
(F)-0.090549, (F)-0.006898, (F)-0.009773, (F)-0.034239, (F)-0.065541, (F)-0.092865, 
(F)-0.325344, (F)-0.035115, 
(F)0.179993, (F)0.748291, (F)0.628052, (F)-0.030334, (F)-0.240662, (F)-0.032397, 
(F)-0.559939, (F)-0.394449, (F)-0.000920, (F)-0.057918, (F)-0.134687, (F)-0.113045, 
(F)-0.469965, (F)0.005460, (F)0.022699, (F)0.019052, (F)0.043317, (F)0.180085, 
(F)0.151148, (F)-0.007300, 
(F)-0.177185, (F)0.094727, (F)0.907410, (F)0.608521, (F)-0.030273, (F)-0.031395, 
(F)-0.008973, (F)-0.823392, (F)-0.370297, (F)-0.000916, (F)0.016784, (F)0.160779, 
(F)-0.085956, (F)0.107821, (F)-0.057643, (F)-0.552177, (F)-0.005364, (F)0.002868, 
(F)0.027470, (F)0.018422, 
(F)0.197937, (F)0.502563, (F)0.463013, (F)0.205872, (F)0.131287, (F)-0.039179, 
(F)-0.252570, (F)-0.214381, (F)-0.042383, (F)-0.017236, (F)-0.099476, (F)-0.091647, 
(F)-0.232693, (F)-0.040750, (F)-0.103464, (F)-0.095321, (F)-0.025986, (F)-0.065980, 
(F)-0.060787, (F)-0.027028, 
(F)-0.587830, (F)0.003662, (F)0.213684, (F)0.327087, (F)0.619507, (F)-0.345544, 
(F)-0.000013, (F)-0.045661, (F)-0.106986, (F)-0.383789, (F)0.002153, (F)0.125610, 
(F)-0.000783, (F)0.192272, (F)-0.001198, (F)-0.069893, (F)0.364164, (F)-0.002269, 
(F)-0.132379, (F)-0.202633, 
(F)-0.419556, (F)-0.155823, (F)-0.332397, (F)-0.133972, (F)-0.478577, (F)-0.176027, 
(F)-0.024281, (F)-0.110488, (F)-0.017949, (F)-0.229036, (F)-0.065376, (F)-0.139459, 
(F)-0.051795, (F)-0.056209, (F)-0.020876, (F)-0.044532, (F)-0.200790, (F)-0.074573, 
(F)-0.159078, (F)-0.064116, 
(F)-0.208313, (F)-0.069641, (F)0.282593, (F)0.830811, (F)0.481995, (F)-0.043394, 
(F)-0.004850, (F)-0.079859, (F)-0.690246, (F)-0.232319, (F)-0.014507, (F)0.058868, 
(F)0.019680, (F)0.173069, (F)0.057859, (F)-0.234781, (F)0.100406, (F)0.033567, 
(F)-0.136208, (F)-0.400446, 
(F)0.269165, (F)-0.346558, (F)0.488647, (F)-0.243652, (F)0.232605, (F)-0.072450, 
(F)-0.120102, (F)-0.238776, (F)-0.059366, (F)-0.054105, (F)0.093281, (F)-0.131527, 
(F)0.169344, (F)0.065583, (F)-0.084440, (F)0.119060, (F)-0.062609, (F)0.080611, 
(F)-0.113662, (F)0.056675, 
(F)0.345398, (F)0.704041, (F)0.134460, (F)-0.027588, (F)0.437561, (F)-0.119300, 
(F)-0.495673, (F)-0.018080, (F)-0.000761, (F)-0.191460, (F)-0.243174, (F)-0.046442, 
(F)-0.094666, (F)0.009529, (F)0.019423, (F)0.003709, (F)-0.151133, (F)-0.308061, 
(F)-0.058835, (F)0.012071, 
(F)0.177856, (F)-0.177856, (F)0.212708, (F)-0.242004, (F)0.834656, (F)-0.031633, 
(F)-0.031633, (F)-0.045244, (F)-0.058566, (F)-0.696650, (F)0.031633, (F)-0.037831, 
(F)0.037831, (F)0.043042, (F)-0.043042, (F)0.051476, (F)-0.148449, (F)0.148449, 
(F)-0.177538, (F)0.201990, 
(F)0.478699, (F)0.116394, (F)0.062378, (F)0.542114, (F)0.486572, (F)-0.229152, 
(F)-0.013548, (F)-0.003891, (F)-0.293888, (F)-0.236753, (F)-0.055718, (F)-0.029860, 
(F)-0.007260, (F)-0.259509, (F)-0.063099, (F)-0.033816, (F)-0.232922, (F)-0.056634, 
(F)-0.030351, (F)-0.263778, 
(F)0.842712, (F)0.581726, (F)0.087646, (F)0.098389, (F)0.108582, (F)-0.710164, 
(F)-0.338405, (F)-0.007682, (F)-0.009680, (F)-0.011790, (F)-0.490228, (F)-0.073861, 
(F)-0.050986, (F)-0.082913, (F)-0.057235, (F)-0.008623, (F)-0.091503, (F)-0.063165, 
(F)-0.009517, (F)-0.010683, 
(F)0.831299, (F)-0.325745, (F)0.332642, (F)-0.138123, (F)0.105164, (F)-0.691058, 
(F)-0.106110, (F)-0.110650, (F)-0.019078, (F)-0.011059, (F)0.270791, (F)-0.276525, 
(F)0.108356, (F)0.114821, (F)-0.044993, (F)0.045945, (F)-0.087422, (F)0.034256, 
(F)-0.034982, (F)0.014525, 
(F)0.323303, (F)0.511108, (F)0.541504, (F)0.469604, (F)0.399048, (F)-0.104525, 
(F)-0.261232, (F)-0.293226, (F)-0.220528, (F)-0.159239, (F)-0.165243, (F)-0.175070, 
(F)-0.276767, (F)-0.151825, (F)-0.240019, (F)-0.254293, (F)-0.129013, (F)-0.203957, 
(F)-0.216086, (F)-0.187395 };

#if COMPILE_MMX

short AcbkGainTable170Int[170*20] = {
     0,      0,      0,      0,      0,      0,      0,      0, 
     0,      0,      0,      0,      0,      0,      0,      0, 
     0,      0,      0,      0,    776,    212,    715,    670, 
   809,    -36,     -2,    -31,    -27,    -39,    -10,    -33, 
    -9,    -31,     -8,    -29,    -38,    -10,    -35,    -33, 
  1296,   1316,   -168,   -320,   -815,   -102,   -105,     -1, 
    -6,    -40,   -104,     13,     13,     25,     25,     -3, 
    64,     65,     -8,    -15,   -589,    680,   2478,    308, 
  -596,    -21,    -28,   -375,     -5,    -21,     24,     89, 
  -102,     11,    -12,    -46,    -21,     24,     90,     11, 
  -735,   -487,     -5,   2948,    468,    -33,    -14,      0, 
  -530,    -13,    -21,      0,      0,    132,     87,      0, 
    21,     13,      0,    -84,   1042,   1730,   1068,    333, 
   626,    -66,   -182,    -69,     -6,    -23,   -110,    -67, 
  -112,    -21,    -35,    -21,    -39,    -66,    -40,    -12, 
   486,   -769,   4074,   2825,  -1107,    -14,    -36,  -1013, 
  -487,    -74,     22,   -120,    191,    -83,    132,   -702, 
    32,    -52,    275,    191,   1521,   -767,   -124,   4320,
  1026,   -141,    -35,      0,  -1139,    -64,     71,     11, 
    -5,   -401,    202,     32,    -95,     48,      7,   -270, 
  2425,   1267,   3439,    -91,  -1166,   -359,    -98,   -722, 
     0,    -83,   -187,   -509,   -266,     13,      7,     19, 
   172,     90,    244,     -6,  -1251,    975,    173,   4039, 
  2005,    -95,    -58,     -1,   -996,   -245,     74,     13, 
   -10,    308,   -240,    -42,    153,   -119,    -21,   -494, 
  1820,    632,   1322,   2062,   1031,   -202,    -24,   -106, 
  -259,    -64,    -70,   -146,    -51,   -229,    -79,   -166, 
  -114,    -39,    -83,   -129,   -447,   4904,    244,   -315, 
 -2038,    -12,  -1467,     -3,     -6,   -253,    134,      6, 
   -73,     -8,     94,      4,    -55,    610,     30,    -39, 
  -208,  -1102,    463,   -448,   5653,     -2,    -74,    -13, 
   -12,  -1950,    -14,      5,     31,     -5,    -30,     12, 
    71,    380,   -159,    154,   4739,   2600,  -1864,    856, 
 -1554,  -1371,   -412,   -212,    -44,   -147,   -752,    539, 
   295,   -247,   -135,     97,    449,    246,   -176,     81, 
  1894,   3533,     35,    -26,   2145,   -219,   -762,      0, 
     0,   -280,   -408,     -4,     -7,      3,      5,      0,
  -248,   -462,     -4,      3,  -2699,   1841,   4072,   2443, 
  1582,   -444,   -207,  -1012,   -364,   -152,    303,    670, 
  -457,    402,   -274,   -607,    260,   -177,   -393,   -236, 
  -844,   3358,   6106,  -1059,   -537,    -43,   -688,  -2275, 
   -68,    -17,    173,    314,  -1251,    -54,    217,    395, 
   -27,    110,    200,    -34,   1251,   1016,   3020,   2210, 
  1445,    -95,    -63,   -556,   -298,   -127,    -77,   -230, 
  -187,   -168,   -137,   -407,   -110,    -89,   -266,   -194, 
  2099,   2277,   4038,   3533,  -2870,   -269,   -316,   -995, 
  -762,   -503,   -291,   -517,   -561,   -452,   -491,   -871, 
   367,    399,    707,    619,    400,  -1114,   8516,   2422, 
 -1117,     -9,    -75,  -4426,   -358,    -76,     27,   -208, 
   579,    -59,    164,  -1259,     27,    -75,    580,    165, 
 -4398,  -2011,   3912,  -2407,   2258,  -1180,   -247,   -934, 
  -353,   -311,   -540,   1050,    480,   -646,   -295,    575, 
   606,    277,   -539,    331,   1767,  -1447,   4240,   6160, 
  -757,   -190,   -127,  -1097,  -2316,    -35,    156,   -457, 
   374,   -664,    544,  -1594,     81,    -66,    195,    284, 
  1594,  -1463,   1035,   6938,   1920,   -155,   -130,    -65,
 -2938,   -225,    142,   -100,     92,   -675,    619,   -438, 
  -186,    171,   -121,   -813,   -562,   4716,   4085,   -591, 
  2421,    -19,  -1357,  -1018,    -21,   -357,    162,    140, 
 -1175,    -20,    170,    147,     83,   -696,   -603,     87, 
  1552,   8778,   -935,    354,  -1424,   -147,  -4703,    -53, 
    -7,   -123,   -831,     88,    501,    -33,   -189,     20, 
   134,    763,    -81,     30,   4831,  -4431,     41,  -1479, 
 -2976,  -1424,  -1198,      0,   -133,   -540,   1306,    -12, 
    11,    436,   -400,      3,    877,   -804,      7,   -268, 
  2090,   1192,   1006,   1645,   4853,   -266,    -86,    -61, 
  -165,  -1437,   -152,   -128,    -73,   -210,   -119,   -101, 
  -619,   -353,   -298,   -487,   2386,   5712,   1426,    -94, 
  1350,   -347,  -1991,   -124,      0,   -111,   -832,   -207, 
  -497,     13,     32,      8,   -196,   -470,   -117,      7, 
 -1349,   1091,   1659,   8891,    313,   -111,    -72,   -168, 
 -4825,     -5,     89,    136,   -110,    732,   -592,   -900, 
    25,    -20,    -31,   -170,   9980,    916,   -381,   -808, 
    88,  -6080,    -51,     -8,    -39,      0,   -558,    232, 
    21,    492,     45,    -18,    -53,     -4,      2,      4,
  2338,  -1031,   -248,   3928,   6484,   -333,    -64,     -3, 
  -942,  -2566,    147,     35,    -15,   -560,    247,     59, 
  -925,    408,     98,  -1555,   6166,  -1240,   -337,   3672, 
 -1277,  -2320,    -93,     -6,   -823,    -99,    466,    126, 
   -25,  -1382,    278,     75,    480,    -96,    -26,    286, 
  4377,   -132,  -2588,   1701,   4865,  -1169,     -1,   -409, 
  -176,  -1444,     35,    691,    -20,   -454,     13,    268, 
 -1299,     39,    768,   -505,   2594,   3295,   3944,   1481, 
   682,   -410,   -662,   -949,   -133,    -28,   -521,   -624, 
  -793,   -234,   -297,   -356,   -108,   -137,   -164,    -61, 
  4151,    624,    815,   4485,   2229,  -1052,    -23,    -40, 
 -1228,   -303,   -158,   -206,    -31,  -1136,   -170,   -223, 
  -565,    -84,   -111,   -610,  -3575,   -361,   4924,   2791, 
  4698,   -780,     -7,  -1480,   -475,  -1347,    -78,   1074, 
   108,    609,     61,   -839,   1025,    103,  -1412,   -800, 
 -2518,   3791,   8623,    315,   2465,   -387,   -877,  -4538, 
    -6,   -370,    582,   1325,  -1995,     48,    -73,   -166, 
   378,   -570,  -1297,    -47,   -691,   2989,   9957,   -421, 
 -1142,    -29,   -545,  -6051,    -10,    -79,    126,    420,
 -1817,    -17,     76,    256,    -48,    208,    694,    -29, 
 -1918,    104,  -3190,  -3410,  -4440,   -224,      0,   -621, 
  -709,  -1203,     12,   -373,     20,   -399,     21,   -664, 
  -519,     28,   -864,   -924,  -3359,  -1668,   1854,   6939, 
  1430,   -688,   -169,   -209,  -2939,   -124,   -341,    380, 
   188,   1422,    706,   -785,    293,    145,   -161,   -606, 
    42,   9706,   3164,   -952,    907,      0,  -5750,   -611, 
   -55,    -50,    -25,     -8,  -1874,      2,    564,    183, 
    -2,   -537,   -175,     52,   1607,    785,   2862,   4327, 
  3307,   -157,    -37,   -500,  -1143,   -667,    -77,   -280, 
  -137,   -424,   -207,   -756,   -324,   -158,   -577,   -873, 
  6801,   3416,   2227,   1682,  -3217,  -2823,   -712,   -302, 
  -172,   -631,  -1418,   -924,   -464,   -698,   -350,   -228, 
  1335,    670,    437,    330,   3459,   3898,    364,   7841, 
 -2640,   -730,   -927,     -8,  -3753,   -425,   -823,    -76, 
   -86,  -1655,  -1865,   -174,    557,    628,     58,   1263, 
 -5902,  -3458,  -2465,  -1886,   4334,  -2126,   -730,   -371, 
  -217,  -1146,  -1245,   -888,   -520,   -679,   -398,   -283, 
  1561,    915,    652,    499,  -3710,   1133,   7849,   3443,
  -215,   -840,    -78,  -3760,   -723,     -2,    256,   1777, 
  -543,    779,   -238,  -1649,    -48,     14,    103,     45, 
  4132,   2828,      2,  -4212,  -4116,  -1042,   -488,      0, 
 -1083,  -1034,   -713,      0,      0,   1062,    727,      0, 
  1038,    710,      0,  -1058,   5875,   8496,  -1796,   1376, 
 -1786,  -2107,  -4406,   -197,   -115,   -194,  -3047,    644, 
   931,   -493,   -713,    150,    640,    926,   -195,    150, 
  3143,   3483,   3546,   -793,   4489,   -603,   -740,   -767, 
   -38,  -1230,   -668,   -680,   -754,    152,    168,    171, 
  -861,   -954,   -971,    217,   2845,   7965,   3695,  -5432, 
  3978,   -494,  -3873,   -833,  -1801,   -966,  -1383,   -641, 
 -1796,    943,   2641,   1225,   -691,  -1934,   -897,   1319, 
  1538,    150,   7139,   2049,   3097,   -144,     -1,  -3110, 
  -256,   -585,    -14,   -670,    -65,   -192,    -18,   -892, 
  -290,    -28,  -1349,   -387,    618,   7520,   4729,   -238, 
 -3373,    -23,  -3452,  -1365,     -3,   -694,   -283,   -178, 
 -2170,      8,    109,     68,    127,   1548,    973,    -49, 
  2965,  -3013,   7912,   7076,  -1997,   -536,   -554,  -3821, 
 -3056,   -243,    545,  -1431,   1455,  -1280,   1301,  -3417,
   361,   -367,    964,    862,   2443,   -929,  -1113,   9677, 
  4138,   -364,    -52,    -75,  -5716,  -1045,    138,    166, 
   -63,  -1443,    549,    657,   -617,    234,    281,  -2444, 
  1966,   3309,  10085,  -3399,   2105,   -236,   -668,  -6207, 
  -705,   -270,   -397,  -1210,  -2037,    408,    686,   2092, 
  -252,   -425,  -1295,    436,   -112,  -1368,   8868,   4822, 
  2048,      0,   -114,  -4800,  -1419,   -256,     -9,     61, 
   740,     33,    402,  -2610,     14,    171,  -1108,   -602, 
 -2597,    438,  -1839,   6229,   7266,   -411,    -11,   -206, 
 -2368,  -3223,     69,   -291,     49,    987,   -166,    699, 
  1152,   -194,    816,  -2763,   3454,    553,   9127,   4946, 
 -5596,   -728,    -18,  -5084,  -1493,  -1911,   -116,  -1924, 
  -308,  -1042,   -166,  -2755,   1179,    188,   3117,   1689, 
  -532,   -663,  12262,   2495,  -1004,    -17,    -26,  -9177, 
  -380,    -61,    -21,    398,    496,     81,    101,  -1867, 
   -32,    -40,    751,    152,  -2100,   1317,  -1509,  11425, 
  2997,   -269,   -105,   -139,  -7967,   -548,    168,   -193, 
   121,   1464,   -918,   1052,    384,   -240,    276,  -2090, 
  1193,  -2697,  11259,   5373,   -763,    -86,   -444,  -7737,
 -1762,    -35,    196,   -819,   1853,   -391,    884,  -3692, 
    55,   -125,    525,    250,   2405,   -471,  11079,    203, 
   782,   -353,    -13,  -7491,     -2,    -37,     69,  -1626, 
   318,    -29,      5,   -137,   -114,     22,   -529,     -9, 
 -1871,   5685,  11290,  -2662,   1353,   -213,  -1972,  -7780, 
  -432,   -111,    649,   1289,  -3917,   -304,    923,   1834, 
   154,   -469,   -932,    220,  -3768,   5927,  -3093,   5041, 
  5212,   -866,  -2144,   -584,  -1551,  -1658,   1363,   -711, 
  1119,   1159,  -1824,    951,   1198,  -1885,    984,  -1603, 
 -2546,   9502,   5969,  -2440,   1928,   -395,  -5511,  -2175, 
  -363,   -226,   1477,    927,  -3462,   -379,   1415,    889, 
   299,  -1118,   -702,    287,  -4963,   3568,   4592,   5508, 
  3451,  -1503,   -777,  -1287,  -1851,   -727,   1080,   1391, 
 -1000,   1668,  -1199,  -1543,   1045,   -751,   -967,  -1160, 
  1745,  -2586,   3983,  10899,  -1551,   -186,   -408,   -968, 
 -7250,   -146,    275,   -424,    628,  -1161,   1720,  -2649, 
   165,   -244,    377,   1032,    867,   -456,   -727,   3369, 
 11822,    -45,    -12,    -32,   -692,  -8531,     24,     38, 
   -20,   -178,     93,    149,   -625,    329,    525,  -2431,
  7535,   2422,   1926,   1405,   1599,  -3466,   -358,   -226, 
  -120,   -156,  -1114,   -886,   -284,   -646,   -207,   -165, 
  -735,   -236,   -188,   -137,   1041,   -735,   -142,  13209, 
  1515,    -66,    -33,     -1, -10649,   -140,     46,      9, 
    -6,   -839,    593,    114,    -96,     68,     13,  -1222, 
  7950,   6745,  -1444,  -1008,   2721,  -3857,  -2777,   -127, 
   -62,   -452,  -3273,    700,    594,    489,    415,    -88, 
 -1320,  -1120,    239,    167,  -4754,  -1379,   4522,   -578, 
 -5733,  -1379,   -116,  -1248,    -20,  -2006,   -400,   1312, 
   380,   -167,    -48,    159,  -1663,   -482,   1582,   -202, 
  3220,   5978,   5923,   2430,  -2689,   -633,  -2181,  -2141, 
  -360,   -441,  -1175,  -1164,  -2161,   -477,   -886,   -878, 
   528,    981,    972,    398,    377,   1312,  13978,  -1470, 
   677,     -8,   -105, -11925,   -132,    -28,    -30,   -321, 
 -1119,     33,    117,   1254,    -15,    -54,   -577,     60, 
 -3435,   6770,    314,   -885,   5686,   -720,  -2797,     -6, 
   -47,  -1973,   1419,     65,   -129,   -185,    366,     16, 
  1192,  -2349,   -109,    307,   3171,   8774,  -2260,   2679, 
  3069,   -613,  -4699,   -312,   -438,   -575,  -1698,    437,
  1210,   -518,  -1435,    369,   -594,  -1643,    423,   -501, 
  5557,   1509,   5407,   -125,  -7386,  -1884,   -139,  -1784, 
     0,  -3330,   -511,  -1834,   -498,     42,     11,     41, 
  2505,    680,   2438,    -56,  -2838,   2595,  13228,    271, 
  1793,   -491,   -411, -10680,     -4,   -196,    449,   2291, 
 -2095,     47,    -42,   -219,    310,   -284,  -1447,    -29, 
   664,   -278,  14966,    951,   -711,    -26,     -4, -13672, 
   -55,    -30,     11,   -606,    253,    -38,     16,   -869, 
    28,    -12,    650,     41,    808,   1770,   8658,   5863, 
 -1486,    -39,   -191,  -4576,  -2098,   -134,    -87,   -427, 
  -935,   -289,   -633,  -3098,     73,    160,    785,    531, 
  3063,   1539,   2000,   -542,   9576,   -572,   -144,   -244, 
   -17,  -5597,   -287,   -374,   -188,    101,     51,     66, 
 -1790,   -900,  -1169,    317,    514,  14083,   -323,    896, 
  -891,    -16, -12106,     -6,    -49,    -48,   -442,     10, 
   277,    -28,   -770,     17,     27,    766,    -17,     48, 
   892,    158,   5237,  11057,  -1603,    -48,     -1,  -1674, 
 -7462,   -156,     -8,   -285,    -50,   -602,   -106,  -3534, 
    87,     15,    512,   1082,  -1612,   2564,  -4296,  12526,
  5710,   -158,   -401,  -1126,  -9576,  -1990,    252,   -422, 
   672,   1232,  -1960,   3284,    561,   -893,   1497,  -4365, 
  4889,  -6878,    612,   6109,   4753,  -1459,  -2887,    -22, 
 -2277,  -1379,   2052,   -182,    257,  -1823,   2564,   -228, 
 -1418,   1995,   -177,  -1772,   3053,   -506,   2403,   9625, 
  1322,   -569,    -15,   -352,  -5655,   -106,     94,   -448, 
    74,  -1794,    297,  -1412,   -246,     40,   -194,   -777, 
  -754,  12904,   4480,  -2113,   1471,    -34, -10163,  -1225, 
  -272,   -132,    594,    206,  -3529,    -97,   1664,    577, 
    67,  -1159,   -402,    189,   4255,   1476,   5055,   2393, 
  2912,  -1105,   -132,  -1559,   -349,   -517,   -383,  -1313, 
  -455,   -621,   -215,   -738,   -756,   -262,   -898,   -425, 
 -1371,    535,   1417,  14604,   -997,   -114,    -17,   -122, 
-13017,    -60,     44,    118,    -46,   1222,   -477,  -1263, 
   -83,     32,     86,    888,   5368,  -1744,   4083,  -1236, 
  3753,  -1758,   -185,  -1017,    -93,   -860,    571,  -1338, 
   434,    405,   -131,    308,  -1229,    399,   -935,    283, 
  1588,  -3097,  14415,   3699,  -1171,   -154,   -585, -12683, 
  -835,    -83,    300,  -1397,   2725,   -358,    699,  -3255,
   113,   -221,   1030,    264,    212,   7989,   9471,  -3344, 
  2009,     -2,  -3895,  -5475,   -682,   -246,   -103,   -123, 
 -4618,     43,   1630,   1933,    -26,   -979,  -1161,    410, 
   856,   2294,   -627,   6930,   6929,    -44,   -321,    -24, 
 -2931,  -2930,   -119,     32,     87,   -362,   -970,    265, 
  -362,   -970,    265,  -2931,   2357,  -4187,   7162,   7683, 
  3371,   -339,  -1070,  -3131,  -3603,   -693,    602,  -1030, 
  1830,  -1105,   1963,  -3359,   -485,    861,  -1474,  -1581, 
   350,   4585,  14053,  -3819,   1218,     -7,  -1283, -12054, 
  -890,    -90,    -97,   -300,  -3933,     81,   1068,   3275, 
   -26,   -341,  -1045,    284,  -3248,   3531,    475,   2137, 
 11711,   -644,   -761,    -13,   -278,  -8372,    700,     94, 
  -102,    423,   -460,    -62,   2322,  -2524,   -340,  -1528, 
 -3017,   3852,   1725,   8440,   5257,   -555,   -905,   -181, 
 -4348,  -1686,    709,    317,   -405,   1554,  -1984,   -889, 
   968,  -1236,   -553,  -2708,   -909,   3196,  15512,  -2528, 
  1066,    -50,   -623, -14686,   -390,    -69,    177,    861, 
 -3026,   -140,    493,   2393,     59,   -208,  -1009,    164, 
   959,  -3370,   9617,   9545,  -1761,    -56,   -693,  -5645,
 -5561,   -189,    197,   -563,   1978,   -558,   1963,  -5603, 
   103,   -362,   1034,   1026,   7575,  11796,  -4845,   3252, 
 -1703,  -3502,  -8493,  -1433,   -645,   -177,  -5454,   2240, 
  3488,  -1503,  -2341,    961,    787,   1226,   -503,    338, 
  6409,   1722,   1764,  -4191,   6015,  -2507,   -181,   -189, 
 -1072,  -2208,   -673,   -690,   -185,   1639,    440,    451, 
 -2353,   -632,   -647,   1538,  -2420,  12161,   5038,   1286, 
 -2098,   -357,  -9027,  -1549,   -100,   -268,   1796,    744, 
 -3740,    190,   -954,   -395,   -310,   1557,    645,    164, 
 -2232,  -1341,   7246,   9470,  -1977,   -304,   -109,  -3204, 
 -5474,   -238,   -182,    987,    593,   1290,    775,  -4188, 
  -269,   -161,    874,   1143,   1030,   7034,   4231,   1551, 
  3077,    -64,  -3019,  -1093,   -146,   -577,   -442,   -266, 
 -1816,    -97,   -666,   -400,   -193,  -1321,   -794,   -291, 
  5121,  11835,   -477,  -1749,   2298,  -1601,  -8549,    -13, 
  -186,   -322,  -3699,    149,    344,    546,   1264,    -50, 
  -718,  -1660,     66,    245,  -3328,   3827,   5921,   9976, 
 -1045,   -676,   -894,  -2140,  -6075,    -66,    777,   1203, 
 -1383,   2027,  -2330,  -3605,   -212,    244,    377,    636,
  3813,   5718,  -4666,  -3412,   5674,   -887,  -1995,  -1329, 
  -710,  -1965,  -1331,   1086,   1628,    794,   1191,   -972, 
 -1320,  -1980,   1616,   1181,   1348,  -3672,  13154,   6938, 
 -1690,   -110,   -823, -10561,  -2938,   -174,    302,  -1082, 
  2948,   -570,   1555,  -5570,    139,   -379,   1357,    716, 
  2151,  -3586,   6949,  12131,  -1224,   -282,   -785,  -2947, 
 -8982,    -91,    470,   -912,   1521,  -1592,   2655,  -5145, 
   160,   -268,    519,    906,  -2889,   9647,  10276,  -2728, 
   995,   -509,  -5680,  -6445,   -454,    -60,   1701,   1812, 
 -6051,   -481,   1606,   1711,    175,   -586,   -624,    165, 
  6177,   2184,    555,   1985,   6589,  -2329,   -291,    -18, 
  -240,  -2650,   -823,   -209,    -74,   -748,   -264,    -67, 
 -2484,   -878,   -223,   -798,   -492,    391,  17166,   -681, 
   240,    -14,     -9, -17987,    -28,     -3,     11,    515, 
  -410,    -20,     16,    713,      7,     -5,   -252,     10, 
 12628,   5448,  -2630,   3011,  -2695,  -9733,  -1811,   -422, 
  -553,   -443,  -4199,   2027,    874,  -2321,  -1001,    483, 
  2077,    896,   -432,    495,  -3628,   -534,   3447,   7002, 
  6751,   -803,    -17,   -725,  -2992,  -2782,   -118,    763,
   112,   1550,    228,  -1473,   1495,    220,  -1420,  -2885, 
 -5239,   5901,   8107,   3650,   4846,  -1675,  -2125,  -4012, 
  -813,  -1433,   1887,   2592,  -2920,   1167,  -1315,  -1806, 
  1550,  -1745,  -2398,  -1080,   6157,   6678,   4099,  -1074, 
  2348,  -2314,  -2722,  -1025,    -70,   -336,  -2509,  -1540, 
 -1670,    403,    437,    268,   -882,   -957,   -587,    153, 
  1079,  16099,    242,   -881,   1690,    -71, -15820,     -3, 
   -47,   -174,  -1060,    -16,   -238,     58,    865,     13, 
  -111,  -1661,    -25,     90,   -278,    227,  -1039,   1636, 
 16945,     -4,     -3,    -65,   -163, -17526,      3,    -17, 
    14,     27,    -22,    103,    287,   -234,   1074,  -1693, 
 15778,  -1454,    574,   -603,   -107, -15195,   -129,    -20, 
   -22,      0,   1400,   -553,     51,    581,    -53,     21, 
   103,     -9,      3,     -3,   2406,   -836,  13224,   7993, 
 -4266,   -353,    -42, -10673,  -3899,  -1111,    122,  -1942, 
   674,  -1174,    407,  -6451,    626,   -217,   3443,   2081, 
  3184,  14368,  -3336,   2255,  -1801,   -619, -12600,   -679, 
  -310,   -198,  -2793,    648,   2926,   -438,  -1977,    459, 
   350,   1580,   -366,    247,  -1698,  17076,   2504,   -539,
  -646,   -176, -17798,   -382,    -17,    -25,   1770,    259, 
 -2610,    -55,    561,     82,    -67,    673,     98,    -21, 
  2375,   -797,  -2696,  14483,   5383,   -344,    -38,   -443, 
-12803,  -1769,    115,    391,   -131,  -2100,    705,   2384, 
  -780,    262,    886,  -4759,  -2691,   2554,  -4520,   9573, 
 10655,   -442,   -398,  -1247,  -5594,  -6930,    419,   -742, 
   704,   1572,  -1492,   2641,   1750,  -1661,   2939,  -6226, 
 -4332,  -4399,  -1657,   4880,   7375,  -1145,  -1181,   -167, 
 -1453,  -3319,  -1163,   -438,   -444,   1290,   1310,    493, 
  1950,   1980,    745,  -2196,  -3498,   7405,   9955,   2693, 
 -2971,   -746,  -3347,  -6049,   -442,   -538,   1581,   2125, 
 -4499,    575,  -1217,  -1636,   -634,   1342,   1805,    488, 
  6717,  -3792,   7739,   2798,   3489,  -2754,   -877,  -3655, 
  -477,   -743,   1554,  -3173,   1791,  -1147,    647,  -1321, 
 -1430,    807,  -1648,   -595,   5263,   9770,   3463,   1069, 
 -3971,  -1690,  -5826,   -732,    -69,   -962,  -3138,  -1112, 
 -2065,   -343,   -637,   -226,   1275,   2368,    839,    259, 
  1243,  -2634,  16772,   1871,    332,    -94,   -423, -17169, 
  -213,     -6,    199,  -1273,   2696,   -142,    300,  -1915,
   -25,     53,   -339,    -37,   2691,   2836,   3105,   5711, 
  4817,   -442,   -491,   -588,  -1991,  -1416,   -465,   -510, 
  -537,   -938,   -988,  -1082,   -791,   -834,   -913,  -1679, 
  4366,   2944,   7210,   3627,   1161,  -1163,   -529,  -3172, 
  -803,    -82,   -784,  -1921,  -1295,   -966,   -651,  -1596, 
  -309,   -208,   -511,   -257,  13888,   3951,   -671,  -2305, 
  3354, -11773,   -953,    -27,   -324,   -686,  -3349,    569, 
   161,   1954,    556,    -94,  -2843,   -809,    137,    472, 
  7053,   5847,   2929,   8378,  -4794,  -3036,  -2086,   -523, 
 -4284,  -1403,  -2517,  -1261,  -1045,  -3607,  -2990,  -1498, 
  2064,   1711,    857,   2451,  -2191,  12838,   9182,  -3915, 
  1617,   -293, -10059,  -5146,   -935,   -159,   1717,   1228, 
 -7195,   -523,   3068,   2194,    216,  -1267,   -906,    386, 
 -4881,  13114,   5767,   -435,   4155,  -1454, -10498,  -2030, 
   -11,  -1054,   3907,   1718,  -4616,   -129,    348,    153, 
  1238,  -3326,  -1462,    110,   7843,  -1250,    210,   7106, 
 -5203,  -3754,    -95,     -2,  -3082,  -1652,    598,   -100, 
    16,  -3402,    542,    -91,   2491,   -397,     66,   2257, 
 -2463,   8168,  14551,  -3908,   1828,   -370,  -4072, -12923,
  -932,   -204,   1228,   2188,  -7254,   -587,   1948,   3471, 
   274,   -911,  -1623,    436,  -1579,    347,   -272,  -2735, 
 16031,   -152,     -7,     -4,   -456, -15686,     33,    -26, 
     5,   -263,     58,    -45,   1545,   -340,    266,   2676, 
 -6327,   1328,   5093,  -5079,   7617,  -2443,   -107,  -1583, 
 -1574,  -3541,    513,   1967,   -413,  -1961,    411,   1578, 
  2941,   -617,  -2367,   2361,   3286,  -4509,  11306,  11025, 
 -2623,   -659,  -1241,  -7802,  -7419,   -420,    904,  -2267, 
  3112,  -2211,   3034,  -7608,    526,   -722,   1810,   1765, 
  5567,  17853,  -3754,   1166,   -519,  -1892, -19455,   -860, 
   -83,    -16,  -6067,   1275,   4090,   -396,  -1271,    267, 
   176,    566,   -119,     37,  -2136,   -424,  15292,   5108, 
 -1648,   -278,    -10, -14273,  -1593,   -165,    -55,   1993, 
   396,    666,    132,  -4768,   -214,    -42,   1538,    514, 
  2267,  -3297,   2549,  16563,   -791,   -313,   -663,   -396, 
-16745,    -38,    456,   -352,    513,  -2291,   3333,  -2576, 
   109,   -159,    123,    799,   3655,   1899,  -3364,   6279, 
 12510,   -815,   -220,   -690,  -2406,  -9552,   -423,    750, 
   390,  -1400,   -728,   1289,  -2791,  -1450,   2568,  -4794,
  8052,   2285,  -6193,   5138,   6003,  -3957,   -318,  -2341, 
 -1611,  -2199,  -1123,   3044,    864,  -2525,   -716,   1942, 
 -2950,   -837,   2269,  -1882,   -386,  -2291,   7679,  15387, 
 -2723,     -9,   -320,  -3599, -14452,   -452,    -54,    181, 
  1074,    362,   2152,  -7212,    -64,   -380,   1276,   2557, 
  2777,  -1173,   3984,  13079,   2508,   -470,    -84,   -969, 
-10440,   -384,    198,   -675,    285,  -2217,    936,  -3180, 
  -425,    179,   -610,  -2002,  -1879,   1771,  -2684,  16705, 
  1833,   -215,   -191,   -439, -17032,   -205,    203,   -308, 
   290,   1916,  -1805,   2736,    210,   -198,    300,  -1869, 
  1052,   4495,  15519,   1467,  -4032,    -67,  -1233, -14700, 
  -131,   -992,   -288,   -997,  -4257,    -94,   -402,  -1389, 
   259,   1106,   3819,    361,   3010,   2544,   6969,   7559, 
  1996,   -553,   -395,  -2964,  -3487,   -243,   -467,  -1280, 
 -1082,  -1388,  -1174,  -3215,   -366,   -310,   -849,   -921, 
 -5209,  -1867,   8713,  10351,   1549,  -1656,   -212,  -4634, 
 -6540,   -146,   -593,   2770,    993,   3291,   1180,  -5505, 
   492,    176,   -824,   -979,  -4314,   8513,    913,   7547, 
 -2723,  -1135,  -4423,    -50,  -3476,   -452,   2241,    240,
  -474,   1987,  -3921,   -420,   -717,   1415,    151,   1254, 
 12929,  -1219,   2448,   1757,   6303, -10204,    -90,   -365, 
  -188,  -2425,    962,  -1932,    182,  -1386,    130,   -262, 
 -4974,    469,   -941,   -676,   6465,   4132,   3167,   3160, 
  5697,  -2551,  -1042,   -612,   -609,  -1981,  -1630,  -1249, 
  -798,  -1247,   -797,   -611,  -2248,  -1437,  -1101,  -1099, 
 -3636,   4859,  18914,  -1335,    810,   -807,  -1441, -21836, 
  -108,    -40,   1078,   4198,  -5609,   -296,    396,   1541, 
   179,   -240,   -936,     66,   8844,   7864,    654,  -4063, 
 -5680,  -4774,  -3774,    -26,  -1007,  -1969,  -4245,   -353, 
  -314,   2193,   1950,    162,   3066,   2726,    226,  -1408, 
  1859,   2634,   9228,    996,   9464,   -211,   -423,  -5197, 
   -60,  -5467,   -299,  -1047,  -1483,   -113,   -160,   -561, 
 -1074,  -1521,  -5330,   -575,   2949,  12260,  10290,   -497, 
 -3943,   -530,  -9174,  -6463,    -15,   -949,  -2206,  -1852, 
 -7700,     89,    372,    312,    709,   2950,   2476,   -119, 
 -2903,   1552,  14867,   9970,   -496,   -514,   -147, -13491, 
 -6068,    -15,    275,   2634,  -1408,   1766,   -944,  -9047, 
   -87,     47,    450,    302,   3243,   8234,   7586,   3373,
  2151,   -642,  -4138,  -3512,   -694,   -282,  -1630,  -1501, 
 -3812,   -667,  -1695,  -1561,   -425,  -1081,   -996,   -442, 
 -9631,     60,   3501,   5359,  10150,  -5662,      0,   -748, 
 -1752,  -6288,     35,   2058,    -12,   3150,    -19,  -1145, 
  5967,    -37,  -2169,  -3320,  -6874,  -2553,  -5446,  -2195, 
 -7841,  -2884,   -397,  -1810,   -294,  -3753,  -1071,  -2285, 
  -848,   -921,   -342,   -729,  -3290,  -1221,  -2606,  -1050, 
 -3413,  -1141,   4630,  13612,   7897,   -711,    -79,  -1308, 
-11310,  -3806,   -237,    964,    322,   2836,    948,  -3847, 
  1645,    550,  -2231,  -6561,   4410,  -5678,   8006,  -3992, 
  3811,  -1187,  -1968,  -3912,   -973,   -886,   1528,  -2155, 
  2775,   1074,  -1383,   1951,  -1025,   1321,  -1862,    928, 
  5659,  11535,   2203,   -452,   7169,  -1954,  -8121,   -296, 
   -12,  -3137,  -3984,   -761,  -1551,    156,    318,     60, 
 -2476,  -5048,   -964,    197,   2914,  -2914,   3485,  -3965, 
 13675,   -518,   -518,   -741,   -959, -11414,    518,   -620, 
   620,    705,   -705,    843,  -2433,   2432,  -2909,   3310, 
  7843,   1907,   1022,   8882,   7972,  -3755,   -222,    -63, 
 -4815,  -3879,   -913,   -489,   -119,  -4252,  -1034,   -554,
 -3816,   -928,   -497,  -4322,  13807,   9531,   1436,   1612,
  1779, -11636,  -5544,   -125,   -158,   -193,  -8032,  -1210,
  -835,  -1358,   -938,   -141,  -1499,  -1035,   -156,   -175,
 13620,  -5337,   5450,  -2263,   1723, -11322,  -1738,  -1813,
  -312,   -181,   4436,  -4531,   1775,   1881,   -737,    752,
 -1432,    561,   -573,    238,   5297,   8374,   8872,   7694,
  6538,  -1712,  -4280,  -4804,  -3613,  -2609,  -2707,  -2868,
 -4534,  -2487,  -3932,  -4166,  -2113,  -3341,  -3540,  -3070 };

#endif


 float AcbkGainTable170subset[85*20] = {
 0.323303f, 0.511108f, 0.541504f, 0.469604f, 0.399048f,
-0.104492f,-0.261230f,-0.293213f,-0.220520f,-0.159241f,
-0.165222f,-0.175049f,-0.276733f,-0.151794f,-0.239990f,
-0.254272f,-0.128967f,-0.203918f,-0.216064f,-0.187378f,
 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f,
 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f,
 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f,
 0.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f,
 0.096924f,-0.189026f, 0.879822f, 0.225769f,-0.071472f,
-0.009399f,-0.035706f,-0.774109f,-0.050964f,-0.005066f,
 0.018311f,-0.085266f, 0.166321f,-0.021851f, 0.042664f,
-0.198669f, 0.006897f,-0.013489f, 0.062866f, 0.016113f,
 0.082275f,-0.224121f, 0.802856f, 0.423462f,-0.103149f,
-0.006714f,-0.050232f,-0.644592f,-0.179321f,-0.010620f,
 0.018433f,-0.066040f, 0.179932f,-0.034790f, 0.094910f,
-0.339966f, 0.008484f,-0.023132f, 0.082825f, 0.043701f,
-0.133728f, 0.783569f, 0.560425f,-0.238953f, 0.098694f,
-0.017883f,-0.613953f,-0.314087f,-0.057068f,-0.009705f,
 0.104797f, 0.074951f,-0.439148f,-0.031921f, 0.187256f,
 0.133911f, 0.013184f,-0.077332f,-0.055298f, 0.023560f,
-0.419556f,-0.155823f,-0.332397f,-0.133972f,-0.478577f,
-0.176025f,-0.024231f,-0.110474f,-0.017944f,-0.229065f,
-0.065369f,-0.139465f,-0.051758f,-0.056213f,-0.020874f,
-0.044495f,-0.200806f,-0.074524f,-0.159058f,-0.064087f,
-0.030029f, 0.023865f, 1.047729f,-0.041565f, 0.014648f,
-0.000854f,-0.000549f,-1.097839f,-0.001709f,-0.000183f,
 0.000671f, 0.031433f,-0.025024f,-0.001221f, 0.000977f,
 0.043518f, 0.000427f,-0.000305f,-0.015381f, 0.000610f,
-0.055481f, 0.195068f, 0.946777f,-0.154297f, 0.065063f,
-0.003052f,-0.038025f,-0.896362f,-0.023804f,-0.004211f,
 0.010803f, 0.052551f,-0.184692f,-0.008545f, 0.030090f,
 0.146057f, 0.003601f,-0.012695f,-0.061584f, 0.010010f,
-0.268433f,-0.122742f, 0.238770f,-0.146912f, 0.137817f,
-0.072021f,-0.015076f,-0.057007f,-0.021545f,-0.018982f,
-0.032959f, 0.064087f, 0.029297f,-0.039429f,-0.018005f,
 0.035095f, 0.036987f, 0.016907f,-0.032898f, 0.020203f,
-0.130371f,-0.025879f, 0.933350f, 0.311768f,-0.100586f,
-0.016968f,-0.000610f,-0.871155f,-0.097229f,-0.010071f,
-0.003357f, 0.121643f, 0.024170f, 0.040649f, 0.008057f,
-0.291016f,-0.013062f,-0.002563f, 0.093872f, 0.031372f,
 0.294861f,-0.270447f, 0.002502f,-0.090271f,-0.181641f,
-0.086914f,-0.073120f, 0.000000f,-0.008118f,-0.032959f,
 0.079712f,-0.000732f, 0.000671f, 0.026611f,-0.024414f,
 0.000183f, 0.053528f,-0.049072f, 0.000427f,-0.016357f,
-0.044861f,-0.029724f,-0.000305f, 0.179932f, 0.028564f,
-0.002014f,-0.000854f, 0.000000f,-0.032349f,-0.000793f,
-0.001282f, 0.000000f, 0.000000f, 0.008057f, 0.005310f,
 0.000000f, 0.001282f, 0.000793f, 0.000000f,-0.005127f,
-0.027283f, 0.299316f, 0.014893f,-0.019226f,-0.124390f,
-0.000732f,-0.089539f,-0.000183f,-0.000366f,-0.015442f,
 0.008179f, 0.000366f,-0.004456f,-0.000488f, 0.005737f,
 0.000244f,-0.003357f, 0.037231f, 0.001831f,-0.002380f,
 0.075867f,-0.160767f, 1.023682f, 0.114197f, 0.020264f,
-0.005737f,-0.025818f,-1.047913f,-0.013000f,-0.000366f,
 0.012146f,-0.077698f, 0.164551f,-0.008667f, 0.018311f,
-0.116882f,-0.001526f, 0.003235f,-0.020691f,-0.002258f,
 0.079102f, 0.080322f,-0.010254f,-0.019531f,-0.049744f,
-0.006226f,-0.006409f,-0.000061f,-0.000366f,-0.002441f,
-0.006348f, 0.000793f, 0.000793f, 0.001526f, 0.001526f,
-0.000183f, 0.003906f, 0.003967f,-0.000488f,-0.000916f,
 0.047363f, 0.012939f, 0.043640f, 0.040894f, 0.049377f,
-0.002197f,-0.000122f,-0.001892f,-0.001648f,-0.002380f,
-0.000610f,-0.002014f,-0.000549f,-0.001892f,-0.000488f,
-0.001770f,-0.002319f,-0.000610f,-0.002136f,-0.002014f,
-0.290161f,-0.084167f, 0.276001f,-0.035278f,-0.349915f,
-0.084167f,-0.007080f,-0.076172f,-0.001221f,-0.122437f,
-0.024414f, 0.080078f, 0.023193f,-0.010193f,-0.002930f,
 0.009705f,-0.101501f,-0.029419f, 0.096558f,-0.012329f,
-0.098389f, 0.156494f,-0.262207f, 0.764526f, 0.348511f,
-0.009644f,-0.024475f,-0.068726f,-0.584473f,-0.121460f,
 0.015381f,-0.025757f, 0.041016f, 0.075195f,-0.119629f,
 0.200439f, 0.034241f,-0.054504f, 0.091370f,-0.266418f,
 0.179993f, 0.748291f, 0.628052f,-0.030334f,-0.240662f,
-0.032349f,-0.559937f,-0.394470f,-0.000916f,-0.057922f,
-0.134644f,-0.113037f,-0.469971f, 0.005432f, 0.022705f,
 0.019043f, 0.043274f, 0.180054f, 0.151123f,-0.007263f,
-0.114685f, 0.108093f,-0.163818f, 1.019592f, 0.111877f,
-0.013123f,-0.011658f,-0.026794f,-1.039551f,-0.012512f,
 0.012390f,-0.018799f, 0.017700f, 0.116943f,-0.110168f,
 0.166992f, 0.012817f,-0.012085f, 0.018311f,-0.114075f,
 0.138367f,-0.201233f, 0.155579f, 1.010925f,-0.048279f,
-0.019104f,-0.040466f,-0.024170f,-1.022034f,-0.002319f,
 0.027832f,-0.021484f, 0.031311f,-0.139832f, 0.203430f,
-0.157227f, 0.006653f,-0.009705f, 0.007507f, 0.048767f,
 0.040527f,-0.016968f, 0.913452f, 0.058044f,-0.043396f,
-0.001587f,-0.000244f,-0.834473f,-0.003357f,-0.001831f,
 0.000671f,-0.036987f, 0.015442f,-0.002319f, 0.000977f,
-0.053040f, 0.001709f,-0.000732f, 0.039673f, 0.002502f,
 0.063599f, 0.105591f, 0.065186f, 0.020325f, 0.038208f,
-0.004028f,-0.011108f,-0.004211f,-0.000366f,-0.001404f,
-0.006714f,-0.004089f,-0.006836f,-0.001282f,-0.002136f,
-0.001282f,-0.002380f,-0.004028f,-0.002441f,-0.000732f,
-0.173218f, 0.158386f, 0.807373f, 0.016541f, 0.109436f,
-0.029968f,-0.025085f,-0.651855f,-0.000244f,-0.011963f,
 0.027405f, 0.139832f,-0.127869f, 0.002869f,-0.002563f,
-0.013367f, 0.018921f,-0.017334f,-0.088318f,-0.001770f,
 0.146851f,-0.051025f, 0.807129f, 0.487854f,-0.260376f,
-0.021545f,-0.002563f,-0.651428f,-0.237976f,-0.067810f,
 0.007446f,-0.118530f, 0.041138f,-0.071655f, 0.024841f,
-0.393738f, 0.038208f,-0.013245f, 0.210144f, 0.127014f,
 0.023010f, 0.080078f, 0.853149f,-0.089722f, 0.041321f,
-0.000488f,-0.006409f,-0.727844f,-0.008057f,-0.001709f,
-0.001831f,-0.019592f,-0.068298f, 0.002014f, 0.007141f,
 0.076538f,-0.000916f,-0.003296f,-0.035217f, 0.003662f,
-0.150330f, 0.498535f, 0.888123f,-0.238525f, 0.111572f,
-0.022583f,-0.248535f,-0.788757f,-0.056885f,-0.012451f,
 0.074951f, 0.133545f,-0.442749f,-0.035828f, 0.118896f,
 0.211853f, 0.016724f,-0.055603f,-0.099060f, 0.026611f,
-0.218201f,-0.022034f, 0.300537f, 0.170349f, 0.286743f,
-0.047607f,-0.000427f,-0.090332f,-0.028992f,-0.082214f,
-0.004761f, 0.065552f, 0.006592f, 0.037170f, 0.003723f,
-0.051208f, 0.062561f, 0.006287f,-0.086182f,-0.048828f,
-0.012695f,-0.067261f, 0.028259f,-0.027344f, 0.345032f,
-0.000122f,-0.004517f,-0.000793f,-0.000732f,-0.119019f,
-0.000854f, 0.000305f, 0.001892f,-0.000305f,-0.001831f,
 0.000732f, 0.004333f, 0.023193f,-0.009705f, 0.009399f,
 0.131287f,-0.218872f, 0.424133f, 0.740417f,-0.074707f,
-0.017212f,-0.047913f,-0.179871f,-0.548218f,-0.005554f,
 0.028687f,-0.055664f, 0.092834f,-0.097168f, 0.162048f,
-0.314026f, 0.009766f,-0.016357f, 0.031677f, 0.055298f,
-0.221924f, 0.296570f, 1.154419f,-0.081482f, 0.049438f,
-0.049255f,-0.087952f,-1.332764f,-0.006592f,-0.002441f,
 0.065796f, 0.256226f,-0.342346f,-0.018066f, 0.024170f,
 0.094055f, 0.010925f,-0.014648f,-0.057129f, 0.004028f,
-0.360229f,-0.211060f,-0.150452f,-0.115112f, 0.264526f,
-0.129761f,-0.044556f,-0.022644f,-0.013245f,-0.069946f,
-0.075989f,-0.054199f,-0.031738f,-0.041443f,-0.024292f,
-0.017273f, 0.095276f, 0.055847f, 0.039795f, 0.030457f,
-0.208313f,-0.069641f, 0.282593f, 0.830811f, 0.481995f,
-0.043396f,-0.004822f,-0.079834f,-0.690308f,-0.232300f,
-0.014465f, 0.058838f, 0.019653f, 0.173096f, 0.057861f,
-0.234802f, 0.100403f, 0.033569f,-0.136169f,-0.400452f,
 0.158325f, 0.201111f, 0.240723f, 0.090393f, 0.041626f,
-0.025024f,-0.040405f,-0.057922f,-0.008118f,-0.001709f,
-0.031799f,-0.038086f,-0.048401f,-0.014282f,-0.018127f,
-0.021729f,-0.006592f,-0.008362f,-0.010010f,-0.003723f,
 0.065857f, 0.982605f, 0.014771f,-0.053772f, 0.103149f,
-0.004333f,-0.965576f,-0.000183f,-0.002869f,-0.010620f,
-0.064697f,-0.000977f,-0.014526f, 0.003540f, 0.052795f,
 0.000793f,-0.006775f,-0.101379f,-0.001526f, 0.005493f,
 0.021362f, 0.279846f, 0.857727f,-0.233093f, 0.074341f,
-0.000427f,-0.078308f,-0.735718f,-0.054321f,-0.005493f,
-0.005920f,-0.018311f,-0.240051f, 0.004944f, 0.065186f,
 0.199890f,-0.001587f,-0.020813f,-0.063782f, 0.017334f,
-0.035950f, 0.041504f, 0.151245f, 0.018799f,-0.036377f,
-0.001282f,-0.001709f,-0.022888f,-0.000305f,-0.001282f,
 0.001465f, 0.005432f,-0.006226f, 0.000671f,-0.000732f,
-0.002808f,-0.001282f, 0.001465f, 0.005493f, 0.000671f,
 0.098083f, 0.047913f, 0.174683f, 0.264099f, 0.201843f,
-0.009583f,-0.002258f,-0.030518f,-0.069763f,-0.040710f,
-0.004700f,-0.017090f,-0.008362f,-0.025879f,-0.012634f,
-0.046143f,-0.019775f,-0.009644f,-0.035217f,-0.053284f,
 0.377014f, 0.133301f, 0.033875f, 0.121155f, 0.402161f,
-0.142151f,-0.017761f,-0.001099f,-0.014648f,-0.161743f,
-0.050232f,-0.012756f,-0.004517f,-0.045654f,-0.016113f,
-0.004089f,-0.151611f,-0.053589f,-0.013611f,-0.048706f,
 0.842712f, 0.581726f, 0.087646f, 0.098389f, 0.108582f,
-0.710205f,-0.338379f,-0.007629f,-0.009644f,-0.011780f,
-0.490234f,-0.073853f,-0.050964f,-0.082886f,-0.057251f,
-0.008606f,-0.091492f,-0.063171f,-0.009521f,-0.010681f,
 0.269165f,-0.346558f, 0.488647f,-0.243652f, 0.232605f,
-0.072449f,-0.120117f,-0.238770f,-0.059387f,-0.054077f,
 0.093262f,-0.131531f, 0.169373f, 0.065552f,-0.084412f,
 0.119080f,-0.062561f, 0.080627f,-0.113647f, 0.056641f,
-0.032471f,-0.040466f, 0.748413f, 0.152283f,-0.061279f,
-0.001038f,-0.001587f,-0.560120f,-0.023193f,-0.003723f,
-0.001282f, 0.024292f, 0.030273f, 0.004944f, 0.006165f,
-0.113953f,-0.001953f,-0.002441f, 0.045837f, 0.009277f,
-0.117065f, 0.006348f,-0.194702f,-0.208130f,-0.270996f,
-0.013672f, 0.000000f,-0.037903f,-0.043274f,-0.073425f,
 0.000732f,-0.022766f, 0.001221f,-0.024353f, 0.001282f,
-0.040527f,-0.031677f, 0.001709f,-0.052734f,-0.056396f,
 0.177856f,-0.177856f, 0.212708f,-0.242004f, 0.834656f,
-0.031616f,-0.031616f,-0.045227f,-0.058533f,-0.696655f,
 0.031616f,-0.037842f, 0.037842f, 0.043030f,-0.043030f,
 0.051453f,-0.148499f, 0.148438f,-0.177551f, 0.202026f,
 0.143860f,-0.255554f, 0.437134f, 0.468933f, 0.205750f,
-0.020691f,-0.065308f,-0.191101f,-0.219910f,-0.042297f,
 0.036743f,-0.062866f, 0.111694f,-0.067444f, 0.119812f,
-0.205017f,-0.029602f, 0.052551f,-0.089966f,-0.096497f,
 0.186951f, 0.093933f, 0.122070f,-0.033081f, 0.584473f,
-0.034912f,-0.008789f,-0.014893f,-0.001038f,-0.341614f,
-0.017517f,-0.022827f,-0.011475f, 0.006165f, 0.003113f,
 0.004028f,-0.109253f,-0.054932f,-0.071350f, 0.019348f,
-0.083679f, 0.032654f, 0.086487f, 0.891357f,-0.060852f,
-0.006958f,-0.001038f,-0.007446f,-0.794495f,-0.003662f,
 0.002686f, 0.007202f,-0.002808f, 0.074585f,-0.029114f,
-0.077087f,-0.005066f, 0.001953f, 0.005249f, 0.054199f,
-0.046021f, 0.787598f, 0.273438f,-0.128967f, 0.089783f,
-0.002075f,-0.620300f,-0.074768f,-0.016602f,-0.008057f,
 0.036255f, 0.012573f,-0.215393f,-0.005920f, 0.101563f,
 0.035217f, 0.004089f,-0.070740f,-0.024536f, 0.011536f,
-0.319763f, 0.360168f, 0.494812f, 0.222778f, 0.295776f,
-0.102234f,-0.129700f,-0.244873f,-0.049622f,-0.087463f,
 0.115173f, 0.158203f,-0.178223f, 0.071228f,-0.080261f,
-0.110229f, 0.094604f,-0.106506f,-0.146362f,-0.065918f,
 0.148010f, 0.077332f, 0.209900f,-0.005554f,-0.071167f,
-0.021912f,-0.005981f,-0.044067f, 0.000000f,-0.005066f,
-0.011414f,-0.031067f,-0.016235f, 0.000793f, 0.000427f,
 0.001160f, 0.010498f, 0.005493f, 0.014893f,-0.000366f,
 0.391174f, 0.105103f, 0.107666f,-0.255798f, 0.367126f,
-0.153015f,-0.011047f,-0.011536f,-0.065430f,-0.134766f,
-0.041077f,-0.042114f,-0.011292f, 0.100037f, 0.026855f,
 0.027527f,-0.143616f,-0.038574f,-0.039490f, 0.093872f,
 0.076355f, 0.062012f, 0.184326f, 0.134888f, 0.088196f,
-0.005798f,-0.003845f,-0.033936f,-0.018188f,-0.007751f,
-0.004700f,-0.014038f,-0.011414f,-0.010254f,-0.008362f,
-0.024841f,-0.006714f,-0.005432f,-0.016235f,-0.011841f,
 0.267151f,-0.008057f,-0.157959f, 0.103821f, 0.296936f,
-0.071350f,-0.000061f,-0.024963f,-0.010742f,-0.088135f,
 0.002136f, 0.042175f,-0.001221f,-0.027710f, 0.000793f,
 0.016357f,-0.079285f, 0.002380f, 0.046875f,-0.030823f,
 0.266479f, 0.179688f, 0.440063f, 0.221375f, 0.070862f,
-0.070984f,-0.032288f,-0.193604f,-0.049011f,-0.005005f,
-0.047852f,-0.117249f,-0.079041f,-0.058960f,-0.039734f,
-0.097412f,-0.018860f,-0.012695f,-0.031189f,-0.015686f,
 0.183716f, 0.155273f, 0.425354f, 0.461365f, 0.121826f,
-0.033752f,-0.024109f,-0.180908f,-0.212830f,-0.014832f,
-0.028503f,-0.078125f,-0.066040f,-0.084717f,-0.071655f,
-0.196228f,-0.022339f,-0.018921f,-0.051819f,-0.056213f,
 0.164246f, 0.173096f, 0.189514f, 0.348572f, 0.294006f,
-0.026978f,-0.029968f,-0.035889f,-0.121521f,-0.086426f,
-0.028381f,-0.031128f,-0.032776f,-0.057251f,-0.060303f,
-0.066040f,-0.048279f,-0.050903f,-0.055725f,-0.102478f,
 0.186340f,-0.030884f, 0.146667f, 0.587463f, 0.080688f,
-0.034729f,-0.000916f,-0.021484f,-0.345154f,-0.006470f,
 0.005737f,-0.027344f, 0.004517f,-0.109497f, 0.018127f,
-0.086182f,-0.015015f, 0.002441f,-0.011841f,-0.047424f,
 0.321228f, 0.596313f, 0.211365f, 0.065247f,-0.242371f,
-0.103149f,-0.355591f,-0.044678f,-0.004211f,-0.058716f,
-0.191528f,-0.067871f,-0.126038f,-0.020935f,-0.038879f,
-0.013794f, 0.077820f, 0.144531f, 0.051208f, 0.015808f,
 0.144958f,-0.048645f,-0.164551f, 0.883972f, 0.328552f,
-0.020996f,-0.002319f,-0.027039f,-0.781433f,-0.107971f,
 0.007019f, 0.023865f,-0.007996f,-0.128174f, 0.043030f,
 0.145508f,-0.047607f, 0.015991f, 0.054077f,-0.290466f,
 0.339172f, 0.092102f, 0.330017f,-0.007629f,-0.450806f,
-0.114990f,-0.008484f,-0.108887f, 0.000000f,-0.203247f,
-0.031189f,-0.111938f,-0.030396f, 0.002563f, 0.000671f,
 0.002502f, 0.152893f, 0.041504f, 0.148804f,-0.003418f,
 0.200562f,-0.275208f, 0.690063f, 0.672913f,-0.160095f,
-0.040222f,-0.075745f,-0.476196f,-0.452820f,-0.025635f,
 0.055176f,-0.138367f, 0.189941f,-0.134949f, 0.185181f,
-0.464355f, 0.032104f,-0.044067f, 0.110474f, 0.107727f,
 0.058533f,-0.205688f, 0.586975f, 0.582581f,-0.107483f,
-0.003418f,-0.042297f,-0.344543f,-0.339417f,-0.011536f,
 0.012024f,-0.034363f, 0.120728f,-0.034058f, 0.119812f,
-0.341980f, 0.006287f,-0.022095f, 0.063110f, 0.062622f,
-0.177185f, 0.094727f, 0.907410f, 0.608521f,-0.030273f,
-0.031372f,-0.008972f,-0.823425f,-0.370361f,-0.000916f,
 0.016785f, 0.160767f,-0.085938f, 0.107788f,-0.057617f,
-0.552185f,-0.005310f, 0.002869f, 0.027466f, 0.018433f,
-0.103638f, 1.042236f, 0.152832f,-0.032898f,-0.039429f,
-0.010742f,-1.086304f,-0.023315f,-0.001038f,-0.001526f,
 0.108032f, 0.015808f,-0.159302f,-0.003357f, 0.034241f,
 0.005005f,-0.004089f, 0.041077f, 0.005981f,-0.001282f,
-0.114197f, 0.346985f, 0.689087f,-0.162476f, 0.082581f,
-0.013000f,-0.120361f,-0.474854f,-0.026367f,-0.006775f,
 0.039612f, 0.078674f,-0.239075f,-0.018555f, 0.056335f,
 0.111938f, 0.009399f,-0.028625f,-0.056885f, 0.013428f,
-0.176331f, 0.588806f, 0.627197f,-0.166504f, 0.060730f,
-0.031067f,-0.346680f,-0.393372f,-0.027710f,-0.003662f,
 0.103821f, 0.110596f,-0.369324f,-0.029358f, 0.098022f,
 0.104431f, 0.010681f,-0.035767f,-0.038086f, 0.010071f,
-0.302917f, 0.217773f, 0.280273f, 0.336182f, 0.210632f,
-0.091736f,-0.047424f,-0.078552f,-0.112976f,-0.044373f,
 0.065918f, 0.084900f,-0.061035f, 0.101807f,-0.073181f,
-0.094177f, 0.063782f,-0.045837f,-0.059021f,-0.070801f,
-0.317932f,-0.113953f, 0.531799f, 0.631775f, 0.094543f,
-0.101074f,-0.012939f,-0.282837f,-0.399170f,-0.008911f,
-0.036194f, 0.169067f, 0.060608f, 0.200867f, 0.072021f,
-0.335999f, 0.030029f, 0.010742f,-0.050293f,-0.059753f,
-0.155396f, 0.579956f, 0.364319f,-0.148926f, 0.117676f,
-0.024109f,-0.336365f,-0.132751f,-0.022156f,-0.013794f,
 0.090149f, 0.056580f,-0.211304f,-0.023132f, 0.086365f,
 0.054260f, 0.018250f,-0.068237f,-0.042847f, 0.017517f,
 0.252197f, 0.172607f, 0.000122f,-0.257080f,-0.251221f,
-0.063599f,-0.029785f, 0.000000f,-0.066101f,-0.063110f,
-0.043518f, 0.000000f, 0.000000f, 0.064819f, 0.044373f,
 0.000000f, 0.063354f, 0.043335f, 0.000000f,-0.064575f,
 0.052917f,-0.027832f,-0.044373f, 0.205627f, 0.721558f,
-0.002747f,-0.000732f,-0.001953f,-0.042236f,-0.520691f,
 0.001465f, 0.002319f,-0.001221f,-0.010864f, 0.005676f,
 0.009094f,-0.038147f, 0.020081f, 0.032043f,-0.148376f,
-0.164734f, 0.112366f, 0.248535f, 0.149109f, 0.096558f,
-0.027100f,-0.012634f,-0.061768f,-0.022217f,-0.009277f,
 0.018494f, 0.040894f,-0.027893f, 0.024536f,-0.016724f,
-0.037048f, 0.015869f,-0.010803f,-0.023987f,-0.014404f,
-0.184143f, 0.235107f, 0.105286f, 0.515137f, 0.320862f,
-0.033875f,-0.055237f,-0.011047f,-0.265381f,-0.102905f,
 0.043274f, 0.019348f,-0.024719f, 0.094849f,-0.121094f,
-0.054260f, 0.059082f,-0.075439f,-0.033752f,-0.165283f,
 0.253357f, 0.038086f, 0.049744f, 0.273743f, 0.136047f,
-0.064209f,-0.001404f,-0.002441f,-0.074951f,-0.018494f,
-0.009644f,-0.012573f,-0.001892f,-0.069336f,-0.010376f,
-0.013611f,-0.034485f,-0.005127f,-0.006775f,-0.037231f,
 0.169495f,-0.071594f, 0.243164f, 0.798279f, 0.153076f,
-0.028687f,-0.005127f,-0.059143f,-0.637207f,-0.023438f,
 0.012085f,-0.041199f, 0.017395f,-0.135315f, 0.057129f,
-0.194092f,-0.025940f, 0.010925f,-0.037231f,-0.122192f,
 0.491455f, 0.139465f,-0.377991f, 0.313599f, 0.366394f,
-0.241516f,-0.019409f,-0.142883f,-0.098328f,-0.134216f,
-0.068542f, 0.185791f, 0.052734f,-0.154114f,-0.043701f,
 0.118530f,-0.180054f,-0.051086f, 0.138489f,-0.114868f,
 0.063538f,-0.044861f,-0.008667f, 0.806213f, 0.092468f,
-0.004028f,-0.002014f,-0.000061f,-0.649963f,-0.008545f,
 0.002808f, 0.000549f,-0.000366f,-0.051208f, 0.036194f,
 0.006958f,-0.005859f, 0.004150f, 0.000793f,-0.074585f,
-0.264404f,-0.268494f,-0.101135f, 0.297852f, 0.450134f,
-0.069885f,-0.072083f,-0.010193f,-0.088684f,-0.202576f,
-0.070984f,-0.026733f,-0.027100f, 0.078735f, 0.079956f,
 0.030090f, 0.119019f, 0.120850f, 0.045471f,-0.134033f,
-0.203125f, 0.233582f, 0.361389f, 0.608887f,-0.063782f,
-0.041260f,-0.054565f,-0.130615f,-0.370789f,-0.004028f,
 0.047424f, 0.073425f,-0.084412f, 0.123718f,-0.142212f,
-0.220032f,-0.012939f, 0.014893f, 0.023010f, 0.038818f,
 0.478699f,-0.076294f, 0.012817f, 0.433716f,-0.317566f,
-0.229126f,-0.005798f,-0.000122f,-0.188110f,-0.100830f,
 0.036499f,-0.006104f, 0.000977f,-0.207642f, 0.033081f,
-0.005554f, 0.152039f,-0.024231f, 0.004028f, 0.137756f,
 0.142700f,-0.062927f,-0.015137f, 0.239746f, 0.395752f,
-0.020325f,-0.003906f,-0.000183f,-0.057495f,-0.156616f,
 0.008972f, 0.002136f,-0.000916f,-0.034180f, 0.015076f,
 0.003601f,-0.056458f, 0.024902f, 0.005981f,-0.094910f,
 0.149109f,-0.056702f,-0.067932f, 0.590637f, 0.252563f,
-0.022217f,-0.003174f,-0.004578f,-0.348877f,-0.063782f,
 0.008423f, 0.010132f,-0.003845f,-0.088074f, 0.033508f,
 0.040100f,-0.037659f, 0.014282f, 0.017151f,-0.149170f,
 0.259705f, 0.090088f, 0.308533f, 0.146057f, 0.177734f,
-0.067444f,-0.008057f,-0.095154f,-0.021301f,-0.031555f,
-0.023376f,-0.080139f,-0.027771f,-0.037903f,-0.013123f,
-0.045044f,-0.046143f,-0.015991f,-0.054810f,-0.025940f,
 0.064209f, 0.274353f, 0.947205f, 0.089539f,-0.246094f,
-0.004089f,-0.075256f,-0.897217f,-0.007996f,-0.060547f,
-0.017578f,-0.060852f,-0.259827f,-0.005737f,-0.024536f,
-0.084778f, 0.015808f, 0.067505f, 0.233093f, 0.022034f,
 0.289246f, 0.158691f,-0.113770f, 0.052246f,-0.094849f,
-0.083679f,-0.025146f,-0.012939f,-0.002686f,-0.008972f,
-0.045898f, 0.032898f, 0.018005f,-0.015076f,-0.008240f,
 0.005920f, 0.027405f, 0.015015f,-0.010742f, 0.004944f,
};

#if COMPILE_MMX

short AcbkGainTable170subsetInt[85 *20] =
  {-83,	  -187,	  -509,	  -266,	    13,	     7,	    19,	   172,	    90,	   244,	
    -6,	 -1251,	   975,	   173,	  4039,	  2005,	   -95,	   -58,	    -1,	  -996,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	
   -21,	     0,	     0,	   132,	    87,	     0,	    21,	    13,	     0,	   -84,	
  1042,	  1730,	  1068,	   333,	   626,	   -66,	  -182,	   -69,	    -6,	   -23,	
   -69,	    -6,	   -23,	  -110,	   -67,	  -112,	   -21,	   -35,	   -21,	   -39,	
   -66,	   -40,	   -12,	   486,	  -769,	  4074,	  2825,	 -1107,	   -14,	   -36,	
   -83,	   132,	  -702,	    32,	   -52,	   275,	   191,	  1521,	  -767,	  -124,	
  4320,	  1026,	  -141,	   -35,	     0,	 -1139,	   -64,	    71,	    11,	    -5,	
  1267,	  3439,	   -91,	 -1166,	  -359,	   -98,	  -722,	     0,	   -83,	  -187,	
  -509,	  -266,	    13,	     7,	    19,	   172,	    90,	   244,	    -6,	 -1251,	
   -67,	  -112,	   -21,	   -35,	   -21,	   -39,	   -66,	   -40,	   -12,	   486,	
  -769,	  4074,	  2825,	 -1107,	   -14,	   -36,	 -1013,	  -487,	   -74,	    22,	
    13,	     0,	   -84,	  1042,	  1730,	  1068,	   333,	   626,	   -66,	  -182,	
   -69,	    -6,	   -23,	  -110,	   -67,	  -112,	   -21,	   -35,	   -21,	   -39,	
   776,	   212,	   715,	   670,	   809,	   -36,	    -2,	   -31,	   -27,	   -39,	
   -10,	   -33,	    -9,	   -31,	    -8,	   -29,	   -38,	   -10,	   -35,	   -33,	
  -767,	  -124,	  4320,	  1026,	  -141,	   -35,	     0,	 -1139,	   -64,	    71,	
    11,	    -5,	  -401,	   202,	    32,	   -95,	    48,	     7,	  -270,	  2425,	
   -36,	    -2,	   -31,	   -27,	   -39,	   -10,	   -33,	    -9,	   -31,	    -8,	
   -29,	   -38,	   -10,	   -35,	   -33,	  1296,	  1316,	  -168,	  -320,	  -815,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	
     0,	     0,	     0,	     0,	     0,	     0,	   776,	   212,	   715,	   670,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	   776,	
   212,	   715,	   670,	   809,	   -36,	    -2,	   -31,	   -27,	   -39,	   -10,	
  -487,	   -74,	    22,	  -120,	   191,	   -83,	   132,	  -702,	    32,	   -52,	
   275,	   191,	  1521,	  -767,	  -124,	  4320,	  1026,	  -141,	   -35,	     0,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	   776,	   212,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	   776,	
    89,	  -102,	    11,	   -12,	   -46,	   -21,	    24,	    90,	    11,	  -735,	
  -487,	    -5,	  2948,	   468,	   -33,	   -14,	     0,	  -530,	   -13,	   -21,	
  2948,	   468,	   -33,	   -14,	     0,	  -530,	   -13,	   -21,	     0,	     0,	
   132,	    87,	     0,	    21,	    13,	     0,	   -84,	  1042,	  1730,	  1068,	
    48,	     7,	  -270,	  2425,	  1267,	  3439,	   -91,	 -1166,	  -359,	   -98,	
  -722,	     0,	   -83,	  -187,	  -509,	  -266,	    13,	     7,	    19,	   172,	
     0,	 -1139,	   -64,	    71,	    11,	    -5,	  -401,	   202,	    32,	   -95,	
    48,	     7,	  -270,	  2425,	  1267,	  3439,	   -91,	 -1166,	  -359,	   -98,	
  -124,	  4320,	  1026,	  -141,	   -35,	     0,	 -1139,	   -64,	    71,	    11,	
    -5,	  -401,	   202,	    32,	   -95,	    48,	     7,	  -270,	  2425,	  1267,	
    90,	    11,	  -735,	  -487,	    -5,	  2948,	   468,	   -33,	   -14,	     0,	
  -530,	   -13,	   -21,	     0,	     0,	   132,	    87,	     0,	    21,	    13,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	
     0,	     0,	     0,	     0,	     0,	   776,	   212,	   715,	   670,	   809,	
    24,	    90,	    11,	  -735,	  -487,	    -5,	  2948,	   468,	   -33,	   -14,	
     0,	  -530,	   -13,	   -21,	     0,	     0,	   132,	    87,	     0,	    21,	
   -12,	   486,	  -769,	  4074,	  2825,	 -1107,	   -14,	   -36,	 -1013,	  -487,	
   -74,	    22,	  -120,	   191,	   -83,	   132,	  -702,	    32,	   -52,	   275,	
    11,	   -12,	   -46,	   -21,	    24,	    90,	    11,	  -735,	  -487,	    -5,	
  2948,	   468,	   -33,	   -14,	     0,	  -530,	   -13,	   -21,	     0,	     0,	
    32,	   -52,	   275,	   191,	  1521,	  -767,	  -124,	  4320,	  1026,	  -141,	
   -35,	     0,	 -1139,	   -64,	    71,	    11,	    -5,	  -401,	   202,	    32,	
   -29,	   -38,	   -10,	   -35,	   -33,	  1296,	  1316,	  -168,	  -320,	  -815,	
  -102,	  -105,	    -1,	    -6,	   -40,	  -104,	    13,	    13,	    25,	    25,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	   776,	   212,	
   715,	   670,	   809,	   -36,	    -2,	   -31,	   -27,	   -39,	   -10,	   -33,	
    -6,	   -23,	  -110,	   -67,	  -112,	   -21,	   -35,	   -21,	   -39,	   -66,	
   -40,	   -12,	   486,	  -769,	  4074,	  2825,	 -1107,	   -14,	   -36,	 -1013,	
   202,	    32,	   -95,	    48,	     7,	  -270,	  2425,	  1267,	  3439,	   -91,	
 -1166,	  -359,	   -98,	  -722,	     0,	   -83,	  -187,	  -509,	  -266,	    13,	
  -815,	  -102,	  -105,	    -1,	    -6,	   -40,	  -104,	    13,	    13,	    25,	
    25,	    -3,	    64,	    65,	    -8,	   -15,	  -589,	   680,	  2478,	   308,	
  3439,	   -91,	 -1166,	  -359,	   -98,	  -722,	     0,	   -83,	  -187,	  -509,	
  -266,	    13,	     7,	    19,	   172,	    90,	   244,	    -6,	 -1251,	   975,	
   -31,	    -8,	   -29,	   -38,	   -10,	   -35,	   -33,	  1296,	  1316,	  -168,	
  -320,	  -815,	  -102,	  -105,	    -1,	    -6,	   -40,	  -104,	    13,	    13,	
   -39,	   -66,	   -40,	   -12,	   486,	  -769,	  4074,	  2825,	 -1107,	   -14,	
   -36,	 -1013,	  -487,	   -74,	    22,	  -120,	   191,	   -83,	   132,	  -702,	
    87,	     0,	    21,	    13,	     0,	   -84,	  1042,	  1730,	  1068,	   333,	
   626,	   -66,	  -182,	   -69,	    -6,	   -23,	  -110,	   -67,	  -112,	   -21,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	   776,	   212,	   715,	
  1316,	  -168,	  -320,	  -815,	  -102,	  -105,	    -1,	    -6,	   -40,	  -104,	
    13,	    13,	    25,	    25,	    -3,	    64,	    65,	    -8,	   -15,	  -589,	
  -110,	   -67,	  -112,	   -21,	   -35,	   -21,	   -39,	   -66,	   -40,	   -12,	
   486,	  -769,	  4074,	  2825,	 -1107,	   -14,	   -36,	 -1013,	  -487,	   -74,	
  -722,	     0,	   -83,	  -187,	  -509,	  -266,	    13,	     7,	    19,	   172,	
    90,	   244,	    -6,	 -1251,	   975,	   173,	  4039,	  2005,	   -95,	   -58,	
   -91,	 -1166,	  -359,	   -98,	  -722,	     0,	   -83,	  -187,	  -509,	  -266,	
    13,	     7,	    19,	   172,	    90,	   244,	    -6,	 -1251,	   975,	   173,	
    -8,	   -15,	  -589,	   680,	  2478,	   308,	  -596,	   -21,	   -28,	  -375,	
    -5,	   -21,	    24,	    89,	  -102,	    11,	   -12,	   -46,	   -21,	    24,	
   -35,	   -33,	  1296,	  1316,	  -168,	  -320,	  -815,	  -102,	  -105,	    -1,	
    -6,	   -40,	  -104,	    13,	    13,	    25,	    25,	    -3,	    64,	    65,	
  -359,	   -98,	  -722,	     0,	   -83,	  -187,	  -509,	  -266,	    13,	     7,	
    19,	   172,	    90,	   244,	    -6,	 -1251,	   975,	   173,	  4039,	  2005,	
   132,	    87,	     0,	    21,	    13,	     0,	   -84,	  1042,	  1730,	  1068,	
   333,	   626,	   -66,	  -182,	   -69,	    -6,	   -23,	  -110,	   -67,	  -112,	
  -735,	  -487,	    -5,	  2948,	   468,	   -33,	   -14,	     0,	  -530,	   -13,	
   -21,	     0,	     0,	   132,	    87,	     0,	    21,	    13,	     0,	   -84,	
  -530,	   -13,	   -21,	     0,	     0,	   132,	    87,	     0,	    21,	    13,	
     0,	   -84,	  1042,	  1730,	  1068,	   333,	   626,	   -66,	  -182,	   -69,	
   -14,	     0,	  -530,	   -13,	   -21,	     0,	     0,	   132,	    87,	     0,	
    21,	    13,	     0,	   -84,	  1042,	  1730,	  1068,	   333,	   626,	   -66,	
   -35,	   -21,	   -39,	   -66,	   -40,	   -12,	   486,	  -769,	  4074,	  2825,	
 -1107,	   -14,	   -36,	 -1013,	  -487,	   -74,	    22,	  -120,	   191,	   -83,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	     0,	
     0,	     0,	   776,	   212,	   715,	   670,	   809,	   -36,	    -2,	   -31,	
  1042,	  1730,	  1068,	   333,	   626,	   -66,	  -182,	   -69,	    -6,	   -23,	
  -110,	   -67,	  -112,	   -21,	   -35,	   -21,	   -39,	   -66,	   -40,	   -12,	
     0,	     0,	     0,	   776,	   212,	   715,	   670,	   809,	   -36,	    -2,	
   -31,	   -27,	   -39,	   -10,	   -33,	    -9,	   -31,	    -8,	   -29,	   -38,	
    -9,	   -31,	    -8,	   -29,	   -38,	   -10,	   -35,	   -33,	  1296,	  1316,	
  -168,	  -320,	  -815,	  -102,	  -105,	    -1,	    -6,	   -40,	  -104,	    13,	
    22,	  -120,	   191,	   -83,	   132,	  -702,	    32,	   -52,	   275,	   191,	
  1521,	  -767,	  -124,	  4320,	  1026,	  -141,	   -35,	     0,	 -1139,	   -64,	
   -64,	    71,	    11,	    -5,	  -401,	   202,	    32,	   -95,	    48,	     7,	
  -270,	  2425,	  1267,	  3439,	   -91,	 -1166,	  -359,	   -98,	  -722,	     0,	
   -74,	    22,	  -120,	   191,	   -83,	   132,	  -702,	    32,	   -52,	   275,	
   191,	  1521,	  -767,	  -124,	  4320,	  1026,	  -141,	   -35,	     0,	 -1139,	
   -33,	   -14,	     0,	  -530,	   -13,	   -21,	     0,	     0,	   132,	    87,	
     0,	    21,	    13,	     0,	   -84,	  1042,	  1730,	  1068,	   333,	   626,	
 -1013,	  -487,	   -74,	    22,	  -120,	   191,	   -83,	   132,	  -702,	    32,	
   -52,	   275,	   191,	  1521,	  -767,	  -124,	  4320,	  1026,	  -141,	   -35,	
  4074,	  2825,	 -1107,	   -14,	   -36,	 -1013,	  -487,	   -74,	    22,	  -120,	
   191,	   -83,	   132,	  -702,	    32,	   -52,	   275,	   191,	  1521,	  -767,	
   -21,	    24,	    90,	    11,	  -735,	  -487,	    -5,	  2948,	   468,	   -33,	
   -14,	     0,	  -530,	   -13,	   -21,	     0,	     0,	   132,	    87,	     0,	
   191,	  1521,	  -767,	  -124,	  4320,	  1026,	  -141,	   -35,	     0,	 -1139,	
   -64,	    71,	    11,	    -5,	  -401,	   202,	    32,	   -95,	    48,	     7,	
     0,	   -84,	  1042,	  1730,	  1068,	   333,	   626,	   -66,	  -182,	   -69,	
    -6,	   -23,	  -110,	   -67,	  -112,	   -21,	   -35,	   -21,	   -39,	   -66,	
     7,	  -270,	  2425,	  1267,	  3439,	   -91,	 -1166,	  -359,	   -98,	  -722,	
     0,	   -83,	  -187,	  -509,	  -266,	    13,	     7,	    19,	   172,	    90,	
  -769,	  4074,	  2825,	 -1107,	   -14,	   -36,	 -1013,	  -487,	   -74,	    22,	
  -120,	   191,	   -83,	   132,	  -702,	    32,	   -52,	   275,	   191,	  1521,	
  2478,	   308,	  -596,	   -21,	   -28,	  -375,	    -5,	   -21,	    24,	    89,	
  -102,	    11,	   -12,	   -46,	   -21,	    24,	    90,	    11,	  -735,	  -487,	
   -23,	  -110,	   -67,	  -112,	   -21,	   -35,	   -21,	   -39,	   -66,	   -40,	
   -12,	   486,	  -769,	  4074,	  2825,	 -1107,	   -14,	   -36,	 -1013,	  -487,	
   -21,	   -28,	  -375,	    -5,	   -21,	    24,	    89,	  -102,	    11,	   -12,	
   -46,	   -21,	    24,	    90,	    11,	  -735,	  -487,	    -5,	  2948,	   468,	
    71,	    11,	    -5,	  -401,	   202,	    32,	   -95,	    48,	     7,	  -270,	
  2425,	  1267,	  3439,	   -91,	 -1166,	  -359,	   -98,	  -722,	     0,	   -83,	
  -596,	   -21,	   -28,	  -375,	    -5,	   -21,	    24,	    89,	  -102,	    11,	
   -12,	   -46,	   -21,	    24,	    90,	    11,	  -735,	  -487,	    -5,	  2948,	
  -105,	    -1,	    -6,	   -40,	  -104,	    13,	    13,	    25,	    25,	    -3,	
    64,	    65,	    -8,	   -15,	  -589,	   680,	  2478,	   308,	  -596,	   -21,	
  -375,	    -5,	   -21,	    24,	    89,	  -102,	    11,	   -12,	   -46,	   -21,	
    24,	    90,	    11,	  -735,	  -487,	    -5,	  2948,	   468,	   -33,	   -14,	
     0,	     0,	     0,	     0,	     0,	   776,	   212,	   715,	   670,	   809,	
   -36,	    -2,	   -31,	   -27,	   -39,	   -10,	   -33,	    -9,	   -31,	    -8,	
    21,	    13,	     0,	   -84,	  1042,	  1730,	  1068,	   333,	   626,	   -66,	
  -182,	   -69,	    -6,	   -23,	  -110,	   -67,	  -112,	   -21,	   -35,	   -21,	
    -8,	   -29,	   -38,	   -10,	   -35,	   -33,	  1296,	  1316,	  -168,	  -320,	
  -815,	  -102,	  -105,	    -1,	    -6,	   -40,	  -104,	    13,	    13,	    25,	
   -35,	     0,	 -1139,	   -64,	    71,	    11,	    -5,	  -401,	   202,	    32,	
   -95,	    48,	     7,	  -270,	  2425,	  1267,	  3439,	   -91,	 -1166,	  -359,	
  1026,	  -141,	   -35,	     0,	 -1139,	   -64,	    71,	    11,	    -5,	  -401,	
   202,	    32,	   -95,	    48,	     7,	  -270,	  2425,	  1267,	  3439,	   -91,	
   -21,	    24,	    89,	  -102,	    11,	   -12,	   -46,	   -21,	    24,	    90,	
    11,	  -735,	  -487,	    -5,	  2948,	   468,	   -33,	   -14,	     0,	  -530,	
 -1107,	   -14,	   -36,	 -1013,	  -487,	   -74,	    22,	  -120,	   191,	   -83,	
   132,	  -702,	    32,	   -52,	   275,	   191,	  1521,	  -767,	  -124,	  4320,	
   -66,	  -182,	   -69,	    -6,	   -23,	  -110,	   -67,	  -112,	   -21,	   -35,	
   -21,	   -39,	   -66,	   -40,	   -12,	   486,	  -769,	  4074,	  2825,	 -1107,	
  -702,	    32,	   -52,	   275,	   191,	  1521,	  -767,	  -124,	  4320,	  1026,	
  -141,	   -35,	     0,	 -1139,	   -64,	    71,	    11,	    -5,	  -401,	   202,	
   -10,	   -33,	    -9,	   -31,	    -8,	   -29,	   -38,	   -10,	   -35,	   -33,	
  1296,	  1316,	  -168,	  -320,	  -815,	  -102,	  -105,	    -1,	    -6,	   -40,	
    25,	    25,	    -3,	    64,	    65,	    -8,	   -15,	  -589,	   680,	  2478,	
   308,	  -596,	   -21,	   -28,	  -375,	    -5,	   -21,	    24,	    89,	  -102,	
     0,	  -530,	   -13,	   -21,	     0,	     0,	   132,	    87,	     0,	    21,	
    13,	     0,	   -84,	  1042,	  1730,	  1068,	   333,	   626,	   -66,	  -182,	
 -1139,	   -64,	    71,	    11,	    -5,	  -401,	   202,	    32,	   -95,	    48,	
     7,	  -270,	  2425,	  1267,	  3439,	   -91,	 -1166,	  -359,	   -98,	  -722,	
     0,	     0,	     0,	     0,	     0,	     0,	     0,	   776,	   212,	   715,	
   670,	   809,	   -36,	    -2,	   -31,	   -27,	   -39,	   -10,	   -33,	    -9
   };	

#endif

/*
**  AcbkGainTablePtr:
**
**  Purpose:
**      Contains pointers to 85 and 170 element codebooks
**
*/
  float *AcbkGainTablePtr[3] = {
   AcbkGainTable085,
   AcbkGainTable170,
   AcbkGainTable170subset,
   };

#if COMPILE_MMX

short *AcbkGainTablePtrInt[3] = {
   AcbkGainTable085Int,
   AcbkGainTable170Int,
   AcbkGainTable170subsetInt,
   };

#endif

/*
**  LpfConstTable:
**
**  Purpose:
**      Sets the postfilter gain weighting factor.
**
**  Table Structure:
**      (0.1875 , 0.25) in Q15 ( i.e. scale by 32768 ).

*/

//Code removed

/*
**  epsi170:
**
**  Purpose:
**      At the lower bitrate, the pitch contribution is added
**      into the output vector of ACELP when the pitch period is
**      less than 60 samples (one subframe). The pitch contribution
**      is estimated by a 1 tap long term predictor (LTP) instead of
**      the 5 tap LTP used in pitch prediction. The values in epsi170
**      effectively choose one of the 5 vectors used in the 5 tap LTP.
**
**  Table Structure:
**      The table is indexed by the index into the AcbkGainTable170
**      table (determined in Find_Acbk). The value, 60, is used only
**      as a place holder. They correspond to zeros in the gain170
**      table, which is the coefficient of the 1 tap long term
**      preditor (LTP).  The rest of the values range from -2 to +2.
**      These values pick one vector among the 5 vectors centered one
**      pitch period behind the current vector. (In contrast, the 5
**      tap LTP uses all five vectors centered one pitch period back.)
*/

int epsi170[170] = {
    60,      0,     60,      0,      1,      0,      0,      1, 
    -1,      1,      0,     -1,      2,     -2,      0,      1, 
     0,      0,     -1,      0,      0,      0,      1,      0, 
    -1,     -1,      1,     -1,      1,     -2,      1,     -1,
    60,      0,      0,      1,      1,      0,      1,      1, 
    -1,      1,     -1,     -1,     -1,      0,     60,     -2, 
     0,      1,      0,     -1,      1,      1,      0,      1, 
     2,     -1,      0,      1,      0,      0,      0,     60, 
    -1,      1,      1,      2,     -1,      1,     -1,     60,
    -1,      0,      1,      0,     -1,      0,      0,      0, 
     1,     -1,      0,      1,     -1,      0,     -1,      0, 
     1,     60,      0,      0,      1,      1,      0,      2, 
     1,      0,      1,     -2,      0,     -1,      1,      0, 
    -1,      1,      0,      0,      1,      0,      0,      0, 
    60,      1,      1,     -1,     -1,      2,     -2,      0,
    -1,     -1,     60,      2,     60,      0,      0,     60, 
     0,      0,      0,     -2,     60,     -1,      0,     60,
     0,      2,      0,      0,     -1,      0,      1,      2,
    60,      1,      1,      1,      0,      0,     60,      0,
    60,      0,      0,     60,     60,     -1,      0,      0,
    60,     60,      1,      0,     60,      2,     60,     -2,
    -2,      0 };

/*
**  gain170:
**
**  Purpose:
**      At the lower bitrate, the pitch contribution is added into
**      the output vector of ACELP when the pitch period is less than
**      60 samples (one subframe). The pitch contribution
**      is estimated by a 1 tap long term predictor (LTP) instead of
**      the 5 tap LTP used in pitch prediction. This table holds the
**      coefficient for the one tap filter.
**      
**  Table Structure:
**      The table is indexed by the index into the AcbkGainTable170
**      table (determined in Find_Acbk). The values are in Q12.
*/

 FLOAT gain170[170] = {
(F)0.000000, 
(F)0.075958, 
(F)0.000000, 
(F)0.159210, 
(F)0.188324, 
(F)0.120636, 
(F)0.316284, 
(F)0.285553, 
(F)0.269867, 
(F)0.286743, 
(F)0.176819, 
(F)0.330078, 
(F)0.354187, 
(F)0.368408, 
(F)0.262939, 
(F)0.371399, 
(F)0.440674, 
(F)0.237640, 
(F)0.418732, 
(F)0.555573, 
(F)0.441620, 
(F)0.482391, 
(F)0.466156, 
(F)0.411377, 
(F)0.560760, 
(F)0.000000, 
(F)0.341614, 
(F)0.397034, 
(F)0.574829, 
(F)0.621155, 
(F)0.495392, 
(F)0.000000, 
(F)0.000000, 
(F)0.370178, 
(F)0.408478, 
(F)0.544250, 
(F)0.637054, 
(F)0.671265, 
(F)0.000000, 
(F)0.557770, 
(F)0.650665, 
(F)0.419250, 
(F)0.582703, 
(F)0.622162, 
(F)0.000000, 
(F)0.641113, 
(F)0.000000, 
(F)0.696014, 
(F)0.485229, 
(F)0.000000, 
(F)0.548981, 
(F)0.679291, 
(F)0.744476, 
(F)0.706116, 
(F)0.730835, 
(F)0.701813, 
(F)0.689819, 
(F)0.791687, 
(F)0.800964, 
(F)0.772736, 
(F)0.806366, 
(F)0.734283, 
(F)0.831512, 
(F)0.000000, 
(F)0.780396, 
(F)0.729919, 
(F)0.791321, 
(F)0.805908, 
(F)0.581329, 
(F)0.834869, 
(F)0.748840, 
(F)0.000000, 
(F)0.765778, 
(F)0.871246, 
(F)0.000000, 
(F)0.695587, 
(F)0.783051, 
(F)0.896515, 
(F)0.923950, 
(F)0.799500, 
(F)0.687286, 
(F)0.882538, 
(F)0.835693, 
(F)0.920471, 
(F)0.000000, 
(F)0.739655, 
(F)0.917419, 
(F)0.664154, 
(F)0.943512, 
(F)0.000000, 
(F)0.954712, 
(F)0.898224, 
(F)0.818512, 
(F)0.874481, 
(F)0.956024, 
(F)0.939911, 
(F)0.957916, 
(F)0.986389, 
(F)0.969238, 
(F)0.971375, 
(F)0.822021, 
(F)0.951538, 
(F)0.942230, 
(F)0.850616, 
(F)0.928619, 
(F)0.947571, 
(F)0.000000, 
(F)0.973877, 
(F)0.964691, 
(F)0.963287, 
(F)0.779938, 
(F)0.956940, 
(F)0.000000, 
(F)0.901367, 
(F)0.884552, 
(F)0.823486, 
(F)0.963959, 
(F)0.941040, 
(F)0.950104, 
(F)0.922943, 
(F)0.938171, 
(F)0.979309, 
(F)0.000000, 
(F)0.943054, 
(F)0.000000, 
(F)0.916351, 
(F)0.886292, 
(F)0.000000, 
(F)0.969116, 
(F)0.749298, 
(F)0.782349, 
(F)0.930817, 
(F)0.000000, 
(F)0.903839, 
(F)0.935333, 
(F)0.000000, 
(F)0.893372, 
(F)0.928192, 
(F)0.838623, 
(F)0.952545, 
(F)0.858978, 
(F)0.933838, 
(F)0.965942, 
(F)0.887085, 
(F)0.000000, 
(F)0.871918, 
(F)0.876770, 
(F)0.958923, 
(F)0.862335, 
(F)0.756744, 
(F)0.000000, 
(F)0.000000, 
(F)0.000000, 
(F)0.674591, 
(F)0.849976, 
(F)0.000000, 
(F)0.000000, 
(F)0.738953, 
(F)0.752014, 
(F)0.711212, 
(F)0.000000, 
(F)0.000000, 
(F)0.698334, 
(F)0.659210, 
(F)0.000000, 
(F)0.782776, 
(F)0.000000, 
(F)0.953766, 
(F)0.767334, 
(F)0.549255 };


/*
**  tabgain170:
**
**  Purpose:
**      In the taming procedure at the encoder the 170 5-taps LT filters
**      are modelled as 1-tap filter. This table gives the gain
**      value attributed to each filter as a worst case gain
**
**  Table Structure:
**      The table is indexed by the index into the AcbkGainTable170
**      table (determined in Find_Acbk). The values are in Q13.
*/

FLOAT tabgain170[170] = {
(F)0.125000,
(F)0.194214,
(F)0.204834,
(F)0.230835,
(F)0.258789,
(F)0.292847,
(F)0.362061,
(F)0.372192,
(F)0.388794,
(F)0.404907,
(F)0.419067,
(F)0.430054,
(F)0.455200,
(F)0.461304,
(F)0.462524,
(F)0.520264,
(F)0.543213,
(F)0.545532,
(F)0.575317,
(F)0.603516,
(F)0.604248,
(F)0.607910,
(F)0.611572,
(F)0.614258,
(F)0.646851,
(F)0.657837,
(F)0.657837,
(F)0.657837,
(F)0.689209,
(F)0.695923,
(F)0.699829,
(F)0.703735,
(F)0.732056,
(F)0.732056,
(F)0.750732,
(F)0.758179,
(F)0.773438,
(F)0.776367,
(F)0.783081,
(F)0.783081,
(F)0.784912,
(F)0.786133,
(F)0.788696,
(F)0.788696,
(F)0.794922,
(F)0.805786,
(F)0.828491,
(F)0.838867,
(F)0.846069,
(F)0.851074,
(F)0.852539,
(F)0.861328,
(F)0.861328,
(F)0.867310,
(F)0.868774,
(F)0.869507,
(F)0.871094,
(F)0.874146,
(F)0.874878,
(F)0.876465,
(F)0.876465,
(F)0.886475,
(F)0.892090,
(F)0.895264,
(F)0.895264,
(F)0.901733,
(F)0.904175,
(F)0.907471,
(F)0.908325,
(F)0.908325,
(F)0.913208,
(F)0.919922,
(F)0.923340,
(F)0.926758,
(F)0.938110,
(F)0.941650,
(F)0.947021,
(F)0.948730,
(F)0.951416,
(F)0.952393,
(F)0.954224,
(F)0.956909,
(F)0.960571,
(F)0.962524,
(F)0.965210,
(F)0.969971,
(F)0.975586,
(F)0.981323,
(F)0.984253,
(F)0.987183,
(F)0.987183,
(F)0.996948,
(F)0.999023,
(F)1.000977,
(F)1.000977,
(F)1.005981,
(F)1.009033,
(F)1.011108,
(F)1.014160,
(F)1.014160,
(F)1.017334,
(F)1.022461,
(F)1.025635,
(F)1.033081,
(F)1.039551,
(F)1.040527,
(F)1.041626,
(F)1.054810,
(F)1.058228,
(F)1.061523,
(F)1.068359,
(F)1.069458,
(F)1.074097,
(F)1.077637,
(F)1.091675,
(F)1.112305,
(F)1.113525,
(F)1.114868,
(F)1.117310,
(F)1.133789,
(F)1.135132,
(F)1.144165,
(F)1.145508,
(F)1.145508,
(F)1.148071,
(F)1.149414,
(F)1.156128,
(F)1.160034,
(F)1.166870,
(F)1.169556,
(F)1.179199,
(F)1.179199,
(F)1.186279,
(F)1.196167,
(F)1.199097,
(F)1.201904,
(F)1.201904,
(F)1.212158,
(F)1.225464,
(F)1.240723,
(F)1.248413,
(F)1.256226,
(F)1.273926,
(F)1.282104,
(F)1.283691,
(F)1.285400,
(F)1.293701,
(F)1.295288,
(F)1.296997,
(F)1.347656,
(F)1.351318,
(F)1.354980,
(F)1.356812,
(F)1.381226,
(F)1.383179,
(F)1.440918,
(F)1.477051,
(F)1.496948,
(F)1.496948,
(F)1.501465,
(F)1.505981,
(F)1.517456,
(F)1.562500,
(F)1.582275,
(F)1.594849,
(F)1.647461,
(F)1.686401,
(F)1.721191,
(F)1.733154,
(F)2.247192 };

/*
**  tabgain85:
**
**  Purpose:
**      In the taming procedure at the encoder the 85 5-taps LT filters
**      are modelled as 1-tap filter. This table gives the gain
**      value attributed to each filter as a worst case gain
**
**  Table Structure:
**      The table is indexed by the index into the AcbkGainTable085
**      table (determined in Find_Acbk). The values are in Q13.
*/


FLOAT tabgain85[85] = {
(F)0.125000,
(F)0.159668,
(F)0.232666,
(F)0.279663,
(F)0.306519,
(F)0.333984,
(F)0.402588,
(F)0.425903,
(F)0.431030,
(F)0.469238,
(F)0.532227,
(F)0.554321,
(F)0.571777,
(F)0.587524,
(F)0.618774,
(F)0.674805,
(F)0.680786,
(F)0.697388,
(F)0.723022,
(F)0.727295,
(F)0.727295,
(F)0.740234,
(F)0.748535,
(F)0.772827,
(F)0.777588,
(F)0.796753,
(F)0.797485,
(F)0.802612,
(F)0.809692,
(F)0.814331,
(F)0.833984,
(F)0.833984,
(F)0.851074,
(F)0.854004,
(F)0.878784,
(F)0.879517,
(F)0.905029,
(F)0.919067,
(F)0.920776,
(F)0.920776,
(F)0.938965,
(F)0.947021,
(F)0.956909,
(F)0.956909,
(F)0.960571,
(F)0.975586,
(F)0.976563,
(F)0.978516,
(F)0.983276,
(F)0.986206,
(F)0.991089,
(F)1.001953,
(F)1.007080,
(F)1.009033,
(F)1.012085,
(F)1.013184,
(F)1.016235,
(F)1.025635,
(F)1.030884,
(F)1.050415,
(F)1.052612,
(F)1.060425,
(F)1.068359,
(F)1.078735,
(F)1.079956,
(F)1.095337,
(F)1.098877,
(F)1.100098,
(F)1.121094,
(F)1.171021,
(F)1.180664,
(F)1.190430,
(F)1.201904,
(F)1.218018,
(F)1.237671,
(F)1.245361,
(F)1.259399,
(F)1.278809,
(F)1.293701,
(F)1.293701,
(F)1.305542,
(F)1.394653,
(F)1.424561,
(F)1.785767,
(F)1.862183 } ;

#if COMPILE_MMX

short LspTableInt[LspCbSize*12+4] = {
     0,  -540, -1082, -1446,
     0, -2744, -3300, -4022,
     0, -2064, -2764, -4426,
     0,     0,     0,     0,
 -1882, -1560, -1768, -2102,
 -2244, -2290, -2618, -3046,
 -3884, -4908, -2746, -3532,
     0,     0,     0,     0,
 -2166, -1554, -1870, -1604,
 -3244, -2754, -2934, -2654,
 -4600, -4294, -5526, -6942,
     0,     0,     0,     0,
 -1870,  -480, -1322, -1988,
 -3918,  -178,  -514,  -932,
 -7998,   444,  -320,  -838,
     0,     0,     0,     0,
  -376,  -684, -1214,    32,
  -328, -1024, -1022,    38,
  -556,  -830, -1594, -1432,
     0,     0,     0,     0,
   748,  -692,  -530, -1240,
   850,   490,  1012,  -294,
 -1944,  -564, -1508,  3910,
     0,     0,     0,     0,
 -1484,  -300,   610,   246,
 -1720,  -704,  1760,  1462,
  5194,  5408,  3908,  5532,
     0,     0,     0,     0,
  -696,  1236,  -356,   786,
  1530,   442,   -94,  2608,
  6654,  6516,  8438,  7684,
     0,     0,     0,     0,
  1396,   126,  -430,   344,
  3404, -1168, -1464,  -670,
  9602,  2458,  3408,  3818,
     0,     0,     0,     0,
    -4,   706, -2416, -1026,
   432,   254,   376,  -150,
  3594,  4410,    22, -1366,
     0,     0,     0,     0,
 -1946, -1232, -1900, -2862,
   444, -1686, -2226, -1246,
 -1292,  -776,  -718, -1410,
     0,     0,     0,     0,
 -2796,   -90,   -18,   254,
 -2126,  -922, -1314, -2156,
  -356,    70,  -432,   190,
     0,     0,     0,     0,
 -1900, -2960,  -240,  -736,
 -2312, -2988, -1410, -1922,
  1168,   898,  1032,  1454,
     0,     0,     0,     0,
  -756, -1586, -1602, -2952,
 -1052, -1228, -1510,  -680,
  1946,  1352,  2574,  3272,
     0,     0,     0,     0,
 -1010, -2486, -1552, -2302,
 -2508, -3244, -2954, -2592,
  3086,  3064, -1310, -1646,
     0,     0,     0,     0,
 -2306, -2582, -1244,  -942,
 -3344, -4006, -2566, -3222,
 -2248, -3404,   114,  1018,
     0,     0,     0,     0,
 -2120, -1746, -3432, -4300,
 -3140, -4312, -4042, -6436,
  -278, -1072,  -728, -2582,
     0,     0,     0,     0,
 -2496, -2430,   334,   698,
 -3890, -5266,  -488,  -824,
 -5808, -5710,   168,  -434,
     0,     0,     0,     0,
   -80,   454,   136,   334,
  -704, -1058,  -766, -1116,
  1264,   810,  -886, -1412,
     0,     0,     0,     0,
  -550,  -702,   682,  1206,
 -1708, -2178,  -144,  -212,
   -28,  -898,  -578,  -948,
     0,     0,     0,     0,
   644,   358,   900,  1110,
  -438,  -634,  -582,   390,
 -1298, -1996, -1992, -1050,
     0,     0,     0,     0,
  1568,  -296,   164,   476,
   544,  -768, -1072,  -344,
 -1662, -1698, -2714, -2708,
     0,     0,     0,     0,
   844,   594,  -222,     2,
  -536, -1474, -1602, -1336,
 -3682, -4158, -1196, -1968,
     0,     0,     0,     0,
  -262,  -658,  -302,  -186,
 -1636, -1042, -1556,  -704,
 -2598, -2620, -3668, -3492,
     0,     0,     0,     0,
 -1136, -1018,   928,   158,
 -1280, -1882, -1630, -2266,
 -3642, -4366, -2500, -3194,
     0,     0,     0,     0,
  -368,  -392,  -384,  -518,
 -2706,  -820, -1666, -2764,
 -4246, -4854, -5620, -6090,
     0,     0,     0,     0,
  -434, -1600,  -726, -1322,
     8,  -650, -1660, -2268,
 -2332, -2438, -1796, -1920,
     0,     0,     0,     0,
  -772, -1254, -1806, -1370,
 -1960, -2318, -1658, -1658,
 -3002, -3444, -1710, -2626,
     0,     0,     0,     0,
 -2130,   882,  1310,  2318,
 -1918,    50,   -54,  -220,
 -2810, -1694, -2362, -1410,
     0,     0,     0,     0,
  1712,   830,   644,  1340,
   506,   808,  1806,   998,
 -3342,    -2,  -796,  -584,
     0,     0,     0,     0,
  1606,  2288,  1434,  1714,
  1182,  1182,   366,   762,
 -1220, -1628,   786,   212,
     0,     0,     0,     0,
  1218,  1584,  1470,  2284,
   124,   396,  1610,  1624,
   -54,  -650,   176,   156,
     0,     0,     0,     0,
  2056,  2618,  3230,  2020,
   732,  1486,  1178,  1278,
  -584,  -474,  -158,  -486,
     0,     0,     0,     0,
  1998,  3000,  1976,  2454,
  1928,  2274,   714,  1334,
  -622, -1230,  1292,  1366,
     0,     0,     0,     0,
  2328,  2784,  2276,  2874,
  3130,  4030,  1066,  1792,
  1788,   954,   500,   782,
     0,     0,     0,     0,
  3530,  2224,  3192,  1874,
  2236,  2180,  1692,  2322,
   198,  1604,  2268,   558,
     0,     0,     0,     0,
  3438,  2676,  2838,  2856,
  2508,  2172,  2648,  3048,
  1366,    70,   856,    80,
     0,     0,     0,     0,
  4216,  2030,  2242,  2060,
  3188,  1088,  1850,  2636,
   178,  2444,  2526,  2970,
     0,     0,     0,     0,
  2590,  2646,  3448,  3594,
  1578,  2544,  2474,  3378,
  3634,  3818,  3606,  1716,
     0,     0,     0,     0,
  4298,  4604,  5726,   104,
  2734,  3734,  4702,   326,
  2602,  1522,  2106,  -152,
     0,     0,     0,     0,
   460,  -142,  -436, -1308,
   618,  1238,  1712,  1472,
  -984,    78,   998,  -414,
     0,     0,     0,     0,
 -1070,  -960,   524,   618,
  2518,  2952,  2162,  3184,
   310,  1286,   204,  -364,
     0,     0,     0,     0,
  1254,   674,  1516,   404,
  3258,  1286,  1340,  2252,
  1068,   912,  1426,  1316,
     0,     0,     0,     0,
  1224,  1372,  -262,    84,
  2262,  2446,   754,  1416,
  1332,  2272,  1050,  1814,
     0,     0,     0,     0,
   174,   864,   274,  -894,
  2976,  4234,  1962,  2028,
  2070,  1808,  2664,  2272,
     0,     0,     0,     0,
 -1678, -1118, -1700, -2546,
  3586,   594,  1370,  1264,
  2492,   396,   892,  1652,
     0,     0,     0,     0,
  -802, -1506,  -872,  -230,
 -1088, -1586,   -18,  -486,
   346,   288,  1544,  2620,
     0,     0,     0,     0,
 -1340, -2054, -1774, -2554,
  -538,   -26,  -162,  -910,
   748,  1278,  2274,   316,
     0,     0,     0,     0,
 -2822,   344,   772, -1000,
 -1440,   176,   510,  1044,
  1472,   806,  1512,  1820,
     0,     0,     0,     0,
 -1916,  -790,  -712, -1226,
  1318,   602,  1536,  1682,
  2776,  2688,  3626,  4838,
     0,     0,     0,     0,
   890,  1258,   566,   912,
  -244,  -174,  -506,  -232,
   504,  1446,  1740,  2762,
     0,     0,     0,     0,
  1514,  1064,  1894,  2650,
   360,   816,   576,  1988,
  2118,  3018,  3612,  5048,
     0,     0,     0,     0,
  1784,  2794,  2286,  3700,
  2438,  3192,  3104,  2866,
  6046,  6812,  5092,  5420,
     0,     0,     0,     0,
   -20,   308,  1016,  1018,
   268,   998,  1584,  2680,
  2004,  2646,  2234,  3232,
     0,     0,     0,     0,
  1524,  1574,  1588,   930,
  1724,  1480,  3454,  4216,
  3216,  4640,  2566,  3320,
     0,     0,     0,     0,
  -240,  -772,  1782,   912,
  2902,  4032,  2450,  2960,
  3226,  4338,  4100,  4370,
     0,     0,     0,     0,
  2986,  2794,  3552,  3144,
  2566,  3272,  3476,  3396,
  2418,  3036,  3104,  4282,
     0,     0,     0,     0,
  2778,  3918,  2730,  4412,
  4252,  4826,  5784,  3942,
  2542,  2238,  3010,  3246,
     0,     0,     0,     0,
  4152,  3434,  4732,  5730,
  3900,  4582,  5030,  5676,
  4560,  3734,  3906,  5044,
     0,     0,     0,     0,
  5070,  6762,  1672,  3522,
  6930,  8254,  5334,  5546,
  4022,  5276,  4578,  4674,
     0,     0,     0,     0,
  2830,  4708,  5318,  2096,
  6650,  6276,  8384,  3572,
  5822,  6252,  8020,  3636,
     0,     0,     0,     0,
  2484,  3024,  3146,  4460,
  4222,  4158,  4982,  4754,
  4480,  5560,  6276,  5564,
     0,     0,     0,     0,
   832,  1450,  2504,  4188,
  3546,  4672,  4746,  4536,
  5408,  6594,  7956,  7136,
     0,     0,     0,     0,
  4022,  2682,  2432,  3386,
  5424,  7014,  7838,  9586,
  9056,  7752,  9844, 12024,
     0,     0,     0,     0,
     0, -4228, -5304, -5694,
     0, -2604, -2556, -1656,
     0,   152, -2736,  -698,
     0,     0,     0,     0,
 -7624, -7892, -5450, -6990,
 -4380,  -728, -8984, -9528,
  -698,  -898, -7214, -3488,
     0,     0,     0,     0,
  -102,  -306,   216, -1670,
 -1512, -2382, -2836, -1792,
   168,  1008,  2334,   780,
     0,     0,     0,     0,
 -1138, -2302, -3652, -3684,
 -3404, -3636, -5094, -3636,
   174,  1866,   822,  2902,
     0,     0,     0,     0,
 -4876, -5494, -1880, -3258,
 -3222, -4954,  2504,  3376,
  1562,  2622,   954,  1204,
     0,     0,     0,     0,
 -2404, -3474, -3056, -4330,
  1234,   786,  2154,  -322,
   560,  1160,  2398,  2816,
     0,     0,     0,     0,
 -5008, -6916, -2794, -4504,
 -2174,  -350,  -196,  -354,
  4742,  2790, -1686, -2298,
     0,     0,     0,     0,
 -2978, -3116, -3734, -4124,
 -1452,  -530, -1642, -3032,
 -2566, -3488, -3794, -4680,
     0,     0,     0,     0,
 -5190,   340,  -386,   652,
 -2284,    92,  -408,  -392,
 -5722, -1638, -2302, -3064,
     0,     0,     0,     0,
  1560,   402,  1300,  2288,
   658,   738,  -418,   -30,
 -1632, -2486, -2120, -2432,
     0,     0,     0,     0,
  2406, -1780, -1276,   354,
  -518, -1128, -1704, -1478,
 -3734, -2860, -3842, -2716,
     0,     0,     0,     0,
  -522,   412,   676,   842,
 -1052,  -814, -1052, -2190,
 -3332, -4510, -1644, -2018,
     0,     0,     0,     0,
  1530,  1650,   714,  -116,
 -1214, -2590, -1810, -2496,
 -2816, -4008, -3630, -3176,
     0,     0,     0,     0,
 -1192,  -146,  -230,  -320,
 -2872, -2318, -2764, -3446,
 -4092, -4232, -5162, -3904,
     0,     0,     0,     0,
   -12, -1298, -1234, -1898,
 -4392, -3410, -2906, -4038,
 -5908, -5206, -6564, -6204,
     0,     0,     0,     0,
 -1624, -3708, -2926, -5366,
  3088,  1148,  2280,  3496,
  3874,  4000,  5298,  2904,
     0,     0,     0,     0,
 -4972,  1566,  1162,   472,
  4482,  3820,  5364,  4394,
  5046,  2870,  2752,  3770,
     0,     0,     0,     0,
  -906, -1364, -2684,  -576,
  5886,  4356,  6402,  -368,
  4114,  5130,  6656,   524,
     0,     0,     0,     0,
   242,  1516,  2076,  3154,
  -298,  -824,  -408,  -914,
  -366,   412,  1706,  1400,
     0,     0,     0,     0,
  1874,  3016,  -450, -1128,
 -1280, -1056, -1054, -2190,
 -1134, -2048,  -854,  -664,
     0,     0,     0,     0,
 -1484, -2576, -3706, -3108,
  -706,  -918,  -968, -1462,
  -372,   168,  -548,  1650,
     0,     0,     0,     0,
 -4850, -3444, -5030, -5198,
  -468,   586,   850,  1636,
   764,  -542, -1128,   928,
     0,     0,     0,     0,
  -716, -1226, -1380, -2704,
   236,   396,  1366,  2310,
  -750, -1748,  -648,  -336,
     0,     0,     0,     0,
 -2186, -2368,   866,  -240,
   258,  1222,   772,   972,
  -648, -1716,  -744, -1268,
     0,     0,     0,     0,
   468,  1204,  2198,  1430,
  1702,   256,   820,  -290,
 -1262,    92,   318,  -848,
     0,     0,     0,     0,
  2396,  2780,  3366,  3422,
  -170,   734,   724,  1244,
 -1186,  -716, -1928,    90,
     0,     0,     0,     0,
  4066,  5780,    14,   144,
  1666,  1098,   802,  1622,
  -766, -1012,   104,   830,
     0,     0,     0,     0,
  1132,   934,   136,   -50,
  1336,  2436,  1914,  3298,
    82,   260,  -374,  -206,
     0,     0,     0,     0,
 -1322, -1850,  -642, -1576,
   520,  -188,  -844, -1344,
   428,  1224,  1930,  3566,
     0,     0,     0,     0,
   800,  1482,  -322,  -764,
 -1346, -1190,   614,  1672,
  1558,  3270,  1314,  1742,
     0,     0,     0,     0,
 -1628,   728,   114,   302,
   800,  1212,   150,   942,
  2446,  2494,  3142,  4574,
     0,     0,     0,     0,
  -162,   454,  1316,  1328,
  2042,  2940,  2550,  2956,
  3004,  2194,  3306,  4754,
     0,     0,     0,     0,
   526,   528,  1588,  1642,
  -254,   178,   342,   372,
   888,  1938,  1152,  2452,
     0,     0,     0,     0,
   808,   678,  2560,  2906,
   924,  1836,  2846,  4038,
  1034,  1588,   392,   730,
     0,     0,     0,     0,
  3230,  4788,  1612,  1426,
  2962,  3416,  2476,  2316,
  1344,  1016,  1146,  2156,
     0,     0,     0,     0,
  2570,  3580,  1530,  2064,
  2872,  2376,  1286,  1594,
  2464,  2282,  1728,  2558,
     0,     0,     0,     0,
  1800,  3028,  3088,  2938,
  1126,  1346,  2258,  2100,
  3654,  4624,  6480,  3188,
     0,     0,     0,     0,
  3890,  4794,  7076,  2498,
  2636,  4052,  4114,  -236,
  3976,  4120,  5240,   148,
     0,     0,     0,     0,
  3454,  4156,  1940,  2298,
   388,  -100,  1376,  1904,
   842,  -926,  -864,  -220,
     0,     0,     0,     0,
  2508,  2772,  3920,   814,
  2550,  1858,  2334, -1504,
 -1302,   802,   464,  -486,
     0,     0,     0,     0,
  1718,  -454, -1592,    16,
 -2236, -1720, -2350, -2564,
   344, -1984, -2760,  -776,
     0,     0,     0,     0,
   706, -1464, -1706, -2458,
 -3562,  -794,   -56, -2414,
 -2074, -1614, -2684, -3918,
     0,     0,     0,     0,
 -2030, -2904, -3782, -1836,
 -2250, -3582, -4832, -3258,
 -5086, -5450, -6538, -1566,
     0,     0,     0,     0,
 -1160, -2194, -2774, -3176,
 -4310, -4728, -3026, -4152,
 -1396,  -192,    14, -1328,
     0,     0,     0,     0,
 -2946, -4756, -5712, -6782,
 -5480, -6298, -4184, -7416,
 -1568,  -112,  -338,   632,
     0,     0,     0,     0,
 -2352, -3888,  -598, -1280,
 -1780, -2122, -3034, -3700,
 -1228, -1600, -2000, -3052,
     0,     0,     0,     0,
 -2908, -3780, -2172, -1500,
 -3072, -3910, -3842, -4650,
 -2466, -3512, -4244, -4520,
     0,     0,     0,     0,
 -2650, -2228, -2682, -2320,
 -4826, -5084, -5802, -4452,
 -5346, -6918, -7926, -2786,
     0,     0,     0,     0,
 -2002, -3188, -3068, -4448,
 -5544, -5282, -6092, -4392,
 -3146, -3956, -5248, -1350,
     0,     0,     0,     0,
 -5614, -4016, -3960, -3430,
 -6108, -5680, -6664, -7124,
 -2204, -2372, -3390, -1010,
     0,     0,     0,     0,
 -5054, -4666, -6880, -4016,
 -8000, -5468, -4802, -7056,
 -3774, -4592, -6422, -6674,
     0,     0,     0,     0,
 -4494,  -950,  -298, -1514,
 -6582,  1898,  2730,  3288,
 -9020,   310,  1090,  2166,
     0,     0,     0,     0,
  -434, -2866,   990,    20,
  4106,  4602,  3322,  4074,
  2706,  2924,  1058,  1480,
     0,     0,     0,     0,
  4164,  5662,  1684,  2446,
  3796,  4588,  1586,  2046,
  1956,  1822,   840,  1726,
     0,     0,     0,     0,
  2474,  3488,  3066,  4270,
   902,  1416,   568,  1218,
  1560,  1644,  2768,  3076,
     0,     0,     0,     0,
  4610,  4736,  5172,  6232,
  1252,  2374,  2510,  2262,
  1080,  1910,   -14,  1452,
     0,     0,     0,     0,
  6862,  5468,  5976,  7046,
  3460,  3296,  2462,  4048,
   856,  2614,  4020,  2976,
     0,     0,     0,     0,
  2068,  2412,  3614,  3616,
  3314,  4326,  4744,  3538,
  1742,  2072,  2466,  2986,
     0,     0,     0,     0,
  3146,  2432,  2960,   930,
  4664,  3218,  3796,  5416,
  3558,  3732,  5026,  5552,
     0,     0,     0,     0,
  1542,  3738,  5650,  5276,
  7276,  5198,  5490,  4878,
  6676,  5246,  4936,  3170,
     0,     0,     0,     0,
  4188,  4044,  6856,  9072,
  5940,  6114,  5824,  5948,
  2616,  3998,  3632,  4258,
     0,     0,     0,     0,
  2092,  2726,  5022,  3732,
  5126,  7124,  3782,  4612,
  4172,  4636,  5968,  7972,
     0,     0,     0,     0,
  6544,  6292,  7184,  4862,
  5848,  7128,  7936,  6738,
  7364,  4544,  5644,  6138,
     0,     0,     0,     0,
  3862,  5258,  9278,  8070,
  9418,  8440,  8112, 10668,
  6180,  7972,  7328,  9824,
     0,     0,     0,     0,
     0,  1202,   856,  1304,
     0,  1024,  2174,  1244,
     0, -1084,  -968,  -782,
     0,   668,  -264, -1144,
   756,  2080,  2246,  2842,
  1598,   818,  1340,   988,
   282,   224,  -150,  -630,
 -1720, -1108, -1694, -2190,
  1574,  1976,  2014,  2146,
  2002,  3344,  2482,   798,
   228,   432,  -264,   372,
  -920, -1362, -2494,   -10,
  2524,   650,  1722,  2522,
   386,   392,  -118,  1134,
 -1388,   102,   700,  1172,
  -258, -1282,  -916,  -692,
  3064,  4054,  2766,  3928,
  1770,  1874,  2128,  2936,
   420,   226,   668,   918,
 -1034, -1584,    76,   266,
  4124,  5154,  4620,  5752,
  2372,  2890,  3364,  3878,
  -196,  1012,    -4,  1530,
  -242,  -746, -1920,   276,
  7162,   438,   868,  -688,
  4720,   352,  -156,   602,
  1298,  -796,  -870,   530,
  -828,  -618, -1760, -1104,
 -1830,   838,   702,  1578,
   940,  -864, -1906,   -86,
  1314,  -326,    16,    40,
  -760,  -906, -1124, -1916,
   604,  2080,  2666,   966,
 -1188,   216,   420,  1178,
  -704, -1336, -2434,  -700,
 -2318, -1848, -3326, -2280,
  2006,  1490,   692,   540,
  1648,   116,   494,  1592,
 -1604, -1178, -1830, -1440,
 -2368, -2886, -3366, -4086,
  2416,  2972,  3444,  4094,
  1444,  2360,   358,  1720,
  -444,  -824,  -138, -1332,
  -386, -1344, -1042, -2820,
  -292,  -378,  -304,  -878,
   444,   180,  2172,  1466,
  -562,  -228,  -482, -1202,
 -1610, -2614, -1528, -2604,
 -1666, -1712, -1494, -1674,
  -334,  -844,  -710,   420,
  -702,  -822, -1164, -1832,
 -1202, -2118, -3288, -2288,
 -3600,   -96,  -700,   530,
    64,   -46,  -818, -1456,
 -1756, -2292, -3312, -1716,
 -3374,   104,  -728, -1154,
   916,  1382,  -132,  -862,
  -494,  -814,  -208,  -186,
 -2282, -3976, -1410, -2382,
 -1994, -2322, -2498, -3688,
   406,    20,   986,   976,
 -1464, -1664,  -256,  -622,
 -2000, -3692, -2872, -3460,
 -3386, -3638, -3536, -5080,
 -1306, -2172, -1398, -2064,
 -1064,  -578, -2410, -2962,
 -2300, -3412, -2432, -4148,
 -2344, -3066, -3532, -3046,
 -1442,    24,   -80,  -942,
 -2440, -1078, -1822,  -968,
 -4554, -2968, -4212, -4534,
 -5200, -2262,  -882, -3098,
  -282, -3090, -2766, -4236,
 -1976, -4204, -5544, -5178,
 -6012, -1166,  -772, -2410,
 -3442,   684,   -26,   144,
 -4294, -5898, -7814, -2574,
 -6462, -6600, -8276, -1690,
 -1930, -1242, -1730,  -750,
   780,  1274,  1606, -1096,
 -2832, -2800, -4036, -2836,
 -2338, -3380, -3818, -4444,
  -974, -2054, -2376, -4058,
 -2554,  -836, -2520,  -256,
 -4134, -1900, -3232,    38,
 -5996, -2056, -1830, -1642,
 -5386, -3076, -4410, -2290,
  -620,   370, -1098,   704,
   368, -1094,  -432, -1590,
 -2350, -2176, -3004, -2612,
 -2712, -3322, -4394, -4748,
 -1254, -1822, -1896,  -902,
 -1848, -1200, -4784, -5816,
 -3778, -3228, -5056, -4190,
 -5592, -7218,   638,  -620,
 -1360, -1770,   606,  1146,
 -6920, -4462, -5610, -5368,
 -4282,  -896, -1064,  -972,
    98,  1350,  2462,  -400,
  -226,  -292,   958,  1222,
 -7050, -7414, -9468,  1554,
 -1942,   346, -2894, -1024,
  -396,   698,   -68,   228,
  1408,   508,  1760,   -20,
  2500,  1208,  2448, -2744,
  -132,  1226,  1554,  -158,
   884,   904,  1350, -2416,
   -10,  -704, -2028,  -476,
 -4778, -3008, -3968, -4074,
   -34, -1346, -1598, -1596,
 -2314, -2266, -4010, -2136,
 -1636, -2120, -3946,  -210,
 -6380,  -312,  -516, -1072,
 -1798, -1772, -2566, -3458,
 -3634,   788,  1102,  1820,
  -388,  -636,   404,   662,
 -1694, -2342, -2160, -2000,
 -2218, -2256, -2638, -3842,
  1590,  1430,  3370,   192,
  -326,  1038,  1336,   422,
 -2974, -2278, -3034, -2024,
 -4296,  -748, -2766,   878,
  1662,   828,   792,  -118,
   348,    -8,  -704, -1934,
 -3624, -3942, -4944, -4322,
  1412,  -658, -3176,   748,
  -880,   -68,  -302,  -562,
 -2060, -1654, -1212,   152,
 -6024,  2208,  3370,  3796,
   462,  1132,  1128,  1500,
   -30,  1442,   766,  1584,
 -1380,   418,   196,  -194,
  1112,  1752,  1922,  1512,
  -128,   324,  1350,  -792,
  1122,  1826,  2592,  1702,
  -186,   -44,   280,  1088,
   720,  1756,  -618, -1372,
  -606,   -44,  -546,  -164,
  2682,  2928,  1284,  1684,
   792,  1726,  -258,   908,
   -10,  -188,  -978,  -738,
   -94,  1934,   770, -1434,
  2138,  2554,  2946,  2666,
  1996,   596,  1492,   484,
   562,   928,  -500,  -876,
 -1986,  1202,   412,   754,
  3452,  3150,  4678, -1194,
  1848,  2752,  2350,  -570,
 -2040,  -916, -1178, -2350,
  1574,  -820, -1720,   244,
 -1580,   430,  -242,  -874,
  -574,   590,  1594,   932,
 -2960,   468,   290,   132,
  -242,   646,    60,  1698,
   734,  1540,  1992,   186,
  1848, -1110,    52,  -290,
  -234, -2990, -2780,  1232,
  2522,  2102,  1388,    14,
   948,   436,  1988,   156,
  -798, -1012,   176,   608,
  2120,  1666, -1540, -1148,
   104,   908,   928,  2398,
  -124,  1298,    94,   -78,
  1670,  2718,   186,   758,
   228,  1454,  -152, -1130,
  -196,   488,   910,   -26,
   976,  1212,  1342,   290,
   970,  1392,  1092,  1638,
  -752,   436,   460,   276,
  1138,   244,  1476,   954,
   896,   530,  1864,    72,
  2256,  2334,  2006,   900,
   808,   994,    34,  1124,
  1574,  2518,   414,   716,
  -146,   774,   390,   106,
  2000,  2462,  -158,  -316,
   986,  1356,  -394,   858,
   774,  1662,  1046,  1788,
   956,  1280,  1226,  1538,
   378,  1116,   114,   222,
   134,  2484,  2838,  1848,
  2348,  1648,  2148,  2948,
  1136,   502,  1728,  1338,
  1022,  1680,   962,  1448,
  3078,   890,   944,  1588,
  3758,   674,  2842,  1470,
  1308,  2222,  2528,  2206,
  3180,  1082,  2188,  1336,
  2110,  1556,  2104,  1762,
  1726,  2210,  3054,  3104,
  2384,  1612,  3174,  2530,
  2040,  3596,  4302,   782,
  1452,  2938,  2806,  3300,
  1744,   560,  1154,  2628,
  3624,  2016,  3606,  2296,
  1202,  1232,  2488,  2144,
  2594,  4186,  3288,    50,
  3338,  2088,  3922,  -630,
  3822,  4230,  5174,   -18,
  2052,  2378,  3024,  -212,
   580,  -136,   490,   668,
  -678, -1566, -1110, -1790,
   856,  1470,   936,  1628,
  -888,  1544,    94,   292,
   470,  -406,  1602,  1788,
   736,   630,    34,  -990,
 -1928, -3132,  -552, -1578,
 -1918, -2434,  -708, -1270,
  1432,  1120,  1358,  -102,
   582,  -520, -1016,  -124,
 -2378, -1466, -2858,  -856,
  -714,    -4,   422,  1114,
   644, -1756,  -776, -1508,
 -1276, -2114, -2830, -3148,
  -422,  -168,  -334,   428,
  1228,  -142,  -636, -1078,
 -2838,   -94,    46, -1316,
 -4008, -1712, -2422,  -974,
  -184,  -694,  -346, -1786,
 -1574,  -510,   640,   706,
 -1566, -2840, -4190,  -642,
 -3174, -1718, -2982, -2900,
 -1168,  -756,  -274, -2576,
  1014,   882,   878,   -24,
  -718, -1662, -2028,  -950,
 -4226, -3836, -4974,  -622,
 -1106, -3122, -2718,  -338,
   -16,    64, -1878,  -472,
 -1814,  -192,  -852,  -394,
  -852,  -800, -2044,  -516,
   552,   100,   -20, -1488,
 -1222, -1420, -1970, -1150,
 -1222,  -534,  -512, -1592,
 -1860, -1552, -2692, -3140,
 -1542, -1224, -1604, -1650,
  -788, -1878, -2244, -1508,
  1424,  1962,  2924,  3468,
  1752,  3018,  2456,  1998,
   282,   170,  1958,  2962,
   454,   248,   -78,   880,
  4586,  5008,  4948,  1834,
  2232,  2960,  3818,  2268,
  1538,  2482,  3116,  1214,
   880,   712,  1620,  -268,
  1018,  3424,  4074,  6062,
  3618,  3012,  4634,  5352,
  1562,  1118,  1452,  2406,
  -246,  -846,  -310,   662,
  7328,  3220,  3548,  3644,
  6548,  3678,  3944,  4316,
  3536,  1734,  3076,  2564,
  1062,   366,   194,  1318,
  4444,  6502,  7266,  5846,
  5516,  4248,  4672,  7034,
  3636,  3446,  4816,  5134,
  1800,  1992,  2906,  2636,
     0,     0,     0,     0   // dummys for pipelined read past end
  };

#endif

int GainScramble[85] = {
169,	0,		90,		107,	133,	161,	111,	97,		20,		141,	
25,		4,		11,		128,	2,		1,		71,		83,		157,	147,	
142,	78,		5,		77,		119,	73,		136,	35,		12,		108,	
154,	44,		162,	33,		116,	94,		3,		41,		110,	167,	
163,	58,		38,		165,	93,		80,		88,		86,		114,	8,	
100,	17,		32,		130,	149,	129,	85,		127,	122,	76,	
139,	98,		158,	121,	62,		109,	65,		150,	64,		46,	
67,		15,		96,		34,		146,	144,	69,		124,	105,	135,	
30,		53,		87,		148,	13
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\tab_lbc.h ===
/*
**
** File:        "tab_lbc.h"
**
** Description:  This file contains extern declarations tha tables used by
**              the SG15 LBC Coder for 6.3/5.3 kbps.
**
*/

/*
  	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 3.01

    Original fixed-point code copyright (c) 1995,
    AudioCodes, DSP Group, France Telecom, Universite de Sherbrooke.
    All rights reserved.

    Floating-point code copyright (c) 1995,
    Intel Corporation and France Telecom (CNET).
    All rights reserved.

*/

//This array is not part of the ITU 723 std.
extern int     minus1mod10[LpcOrder];

extern float   HammingWindowTable[LpcFrame];
extern float   BinomialWindowTable[LpcOrder+1] ;
extern float   BandExpTable[LpcOrder] ;
extern float   CosineTable[CosineTableSize] ;
extern float   LspDcTable[LpcOrder] ;
extern int     BandInfoTable[LspQntBands][2] ;
extern float   Band0Tb8[LspCbSize*3] ;
extern float   Band1Tb8[LspCbSize*3] ;
extern float   Band2Tb8[LspCbSize*4] ;
extern short   LspTableInt[LspCbSize*12+4] ;
extern float  *BandQntTable[LspQntBands] ;
extern float   PerFiltZeroTable[LpcOrder] ;
extern float   PerFiltPoleTable[LpcOrder] ;
//PostFiltZeroTable
//PostFiltPoleTable
extern int     Nb_puls[4];
extern float    FcbkGainTable[NumOfGainLev] ;
extern Word32   MaxPosTable[4] ;
extern Word32   CombinatorialTable[MaxPulseNum][SubFrLen/Sgrid] ;
extern float    AcbkGainTable085[85*20] ;
extern float    AcbkGainTable170[170*20] ;
extern float   *AcbkGainTablePtr[3] ;
extern int      AcbkGainBound[3] ;
extern int      GainScramble[85];
//LpfConstTable
extern int      epsi170[170] ;
extern float    gain170[170] ;
extern float   tabgain170[170];
extern float   tabgain85[85];


 extern short AcbkGainTable085Int[85*20] ;
 extern short AcbkGainTable170Int[170*20] ;
 extern short AcbkGainTable170subsetInt[85 *20]  ;
 extern short *AcbkGainTablePtrInt[3]  ;
 extern short LspTableInt[LspCbSize*12+4] ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\tabl_ns.h ===
// PhilF: Remove the three following arrays since the SID
// code does not know how to make a good use of them today.
#if 0
extern const unsigned r53Noise[6*4];
extern const unsigned r63Noise[6*4];
extern const unsigned SIDFrame[1];
#endif
extern const float Squelch[16];
extern const float A[6];
extern const float B[6];
extern const float HhpNumer[4];
extern const float HhpDenom[3];
extern const float Binomial80[11];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\util_lbc.c ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//

//no return value and unreferenced label are not interesting warnings
//occur in asm dot product because the compiler doesn't look at the asm code.
#pragma warning(4: 4035 4102) 

#include "opt.h"
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <memory.h>

#include "typedef.h"
#include "cst_lbc.h"
#include "sdstruct.h"

#include "coder.h"
#include "decod.h"
#include "tabl_ns.h"

#include "sdstuff.h"
#include "util_lbc.h"

//-----------------------------------------------------
int MyFloor(float x)
{
// Note: We fiddle with the FP control word to force it to round
// to -inf.  This way we get the right floor for either positive or
// negative x.

#if OPT_FLOOR

  int retu,fc_old,fc;

  ASM
  {
    fnstcw fc_old;
    mov eax,fc_old;
    and eax, 0f3ffh;
    or  eax, 00400h;
    mov fc,eax;
    fldcw fc;
    
    fld x;            // do the floor
    fistp retu;

    fldcw fc_old;
  }
  return(retu);

#else
  
  float f;

  f = (float)floor(x);
  return((int) f);
  
#endif
}
#if NOTMINI
//-----------------------------------------------------
void  Read_lbc (float *Dpnt, int Len, FILE *Fp)
{
  short Ibuf[Frame];
  int  i,n;

  n = fread (Ibuf, sizeof(short), Len, Fp);
  for (i=0; i<n; i++)
    Dpnt[i] = (float) Ibuf[i];
  for (i=n; i<Len; i++)
    Dpnt[i] = 0.0f;
}

//-----------------------------------------------------
void  Write_lbc(float *Dpnt, int Len, FILE *Fp)
{
  short Obuf[Frame];
  int i;

  for (i=0; i<Len; i++)
  {
    if (Dpnt[i] < -32768.)
      Obuf[i] = -32768;
    else if (Dpnt[i] > 32767)
      Obuf[i] = 32767;
    else
    {
      if (Dpnt[i] < 0)
        Obuf[i] = (short) (Dpnt[i]-0.5);
      else
        Obuf[i] = (short) (Dpnt[i]+0.5);

    }
  }
      
  fwrite(Obuf, sizeof(short), Len, Fp);
}

void	Line_Wr( char *Line, FILE *Fp )
{
	Word16	FrType ;
	int		Size  ;

	FrType = Line[0] & (Word16)0x0003 ;

	/* Check for Sid frame */
	if ( FrType == (Word16) 0x0002 ) {
		return ;
	}

	if ( FrType == (Word16) 0x0000 )
		Size = 24 ;
	else
		Size = 20 ;

	fwrite( Line, Size, 1, Fp ) ;
}

void	Line_Rd( char *Line, FILE *Fp )
{
	Word16	FrType ;
	int		Size  ;

	fread( Line, 1,1, Fp ) ;

	FrType = Line[0] & (Word16)0x0003 ;

	/* Check for Sid frame */
	if ( FrType == (Word16) 0x0002 ) {
		Size = 3 ;
		fread( &Line[1], Size, 1, Fp ) ;
		return ;
	}

	if ( FrType == (Word16) 0x0000 )
		Size = 23 ;
	else
		Size = 19 ;

	fread( &Line[1], Size, 1, Fp ) ;
}
#endif

//-----------------------------------------------------
void  Rem_Dc(float *Dpnt, CODDEF *CodStat)
{
  int  i;
  float acc0;

  if (CodStat->UseHp)
  {
    for (i=0; i < Frame; i++)
    {
      acc0 = (Dpnt[i] - CodStat->HpfZdl)*0.5f;
      CodStat->HpfZdl = Dpnt[i];
      
      Dpnt[i] = CodStat->HpfPdl = acc0 + CodStat->HpfPdl*(127.0f/128.0f);
  }
  }
  else
    for (i=0; i < Frame; i++)
      Dpnt[i] *= 0.5f;
}


//-----------------------------------------------------
void  Mem_Shift(float *PrevDat, float *DataBuff)
{
  int  i;

  float Dpnt[Frame+LpcFrame-SubFrLen];

// Form Buffer

  for (i=0; i < LpcFrame-SubFrLen; i++)
	  Dpnt[i] = PrevDat[i];
  for (i=0; i < Frame; i++)
    Dpnt[i+LpcFrame-SubFrLen] = DataBuff[i];

// Update PrevDat
  
  for (i=0; i < LpcFrame-SubFrLen; i++)
    PrevDat[i] = Dpnt[Frame+i];

// Update DataBuff
  
  for (i=0; i < Frame; i++)
    DataBuff[i] = Dpnt[(LpcFrame-SubFrLen)/2+i];
}

/*
**
** Function:        Line_Pack()
**
** Description:     Packing coded parameters in bitstream of 16-bit words
**
** Links to text:   Section 4
**
** Arguments:
**
**  LINEDEF *Line   Coded parameters for a frame
**  Word32 *Vout    bitstream words
**  Word16 VadAct   Voice Activity Indicator
**
** FILEIO - if defined, bitstream is generated as Big Endian words but little
**          endian bytes.  If not, then it is all little endian.
** 
** Outputs:
**
**  Word32 *Vout
**
** Return value:    None
**
*/
#define bswap(s) ASM mov eax,s ASM bswap eax ASM mov s,eax

//STUFF n bits of x at bit position k of *lp
//      if you fill up *lp, *++lp = leftovers
//WARNING!: as a side effect lp may be changed!
//lp must have an lvalue
//n and k must be compile time constants
#define OPT_STUFF 1
#if OPT_STUFF
#define STUFF(x, lp, n_in, k_in) {\
  register unsigned temp;\
  const int n = (n_in);\
  const int k = (k_in) & 31;\
  temp = (x) & ((1 << n) - 1);\
  *(lp) |= temp << k;\
  if (n+k >= 32)\
    *(++lp) |= temp >> (32-k);\
  }
#else
#define STUFF(x, lp, n_in, k_in) stuff(x, &(lp), n_in, k_in)
void stuff(unsigned x, unsigned **ptrlp, int n, int k_in) {
  unsigned temp;
  int k;

  k = k_in & 31;

  temp = (x) & ((1 << n) - 1);
  *(*ptrlp) |= temp << k;
  if (n+k >= 32)
    *(++*ptrlp) |= temp >> (32-k);
  
  return;
  }
#endif

#define DEBUG_DUMPLINE 0
#if DEBUG_DUMPLINE
#define DUMPLINE(lp) dumpline(lp)
void dumpsfs(SFSDEF *sfsptr)
{
  fprintf(stdout, "%1x ", sfsptr->AcLg);
  fprintf(stdout, "%2x ", sfsptr->AcGn);
  fprintf(stdout, "%2x", sfsptr->Mamp);
  fprintf(stdout, "%1x", sfsptr->Grid);
  fprintf(stdout, "%1x", sfsptr->Tran);
  fprintf(stdout, "%1x ", sfsptr->Pamp);
  fprintf(stdout, "%3x ", sfsptr->Ppos);
//  fprintf(stdout, "\n"); 
  return;
}

void dumpline(LINEDEF *lineptr)
{
  fprintf(stdout, "%6x ", lineptr->LspId);
  fprintf(stdout, "%2x ", lineptr->Olp[0]);
  fprintf(stdout, "%2x ", lineptr->Olp[1]);
//  fprintf(stdout, "\n"); 
  dumpsfs(&lineptr->Sfs[0]); 
  dumpsfs(&lineptr->Sfs[1]); 
  dumpsfs(&lineptr->Sfs[2]); 
  dumpsfs(&lineptr->Sfs[3]); 
  fprintf(stdout, "\n"); 
  return;
}
#else 
#define DUMPLINE(lp)
#endif


void Line_Pack( LINEDEF *Line, Word32 *Vout, int *VadBit, enum Crate WrkRate )
//4.0f void	Line_Pack( LINEDEF *Line, char *Vout, Word16 VadBit )
{
	int		i ;

	Word32 *Bsp;
	Word32	Temp ;

	/* Clear the output vector */
        if ( WrkRate == Rate63 )
	{
	  for ( i = 0 ; i < 6 ; i ++ )
	    Vout[i] = 0 ;
	}
	else
	{
	  for ( i = 0 ; i < 5 ; i ++ )
	    Vout[i] = 0 ;
	}

	Bsp = Vout; //running pointer into output buffer as Word32's

	/* 
	Add the coder rate info and the VAD status to the 2 msb
        of the first word of the frame.

	The signalling is as follows:
        00  :   High Rate
        01  :   Low Rate
        10  :   Non-speech
        11  :   Reserved for future use
	*/

	Temp = 0L ;
	if ( *VadBit == 1 ) {
		if ( WrkRate == Rate63 )
			Temp = 0x00000000L ;
		else
			Temp = 0x00000001L ;
	}

	/* Serialize Control info */
	STUFF( Temp, Bsp, 2, 0 ) ;

	/* 24 bit LspId */
	Temp = (*Line).LspId ;
	STUFF( Temp, Bsp, 24, 2 ) ;

	/* Check for Speech/NonSpeech case */
	if ( *VadBit == 1 ) {

		/*
		 	Do the part common to both rates
		*/

		/* Adaptive code book lags */
		Temp = (Word32) (*Line).Olp[0] - (Word32) PitchMin ;
		STUFF( Temp, Bsp, 7, 26 ) ;

		Temp = (Word32) (*Line).Sfs[1].AcLg ;
		STUFF( Temp, Bsp, 2, 33 ) ;

		Temp = (Word32) (*Line).Olp[1] - (Word32) PitchMin ;
		STUFF( Temp, Bsp, 7, 35 ) ;

		Temp = (Word32) (*Line).Sfs[3].AcLg ;
		STUFF( Temp, Bsp, 2, 42 ) ;

		/* Write combined 12 bit index of all the gains */
		Temp = (*Line).Sfs[0].AcGn*NumOfGainLev + (*Line).Sfs[0].Mamp ;
		if ( WrkRate == Rate63 )
			Temp += (Word32) (*Line).Sfs[0].Tran << 11 ;
		STUFF( Temp, Bsp, 12, 44 ) ;

		Temp = (*Line).Sfs[1].AcGn*NumOfGainLev + (*Line).Sfs[1].Mamp ;
		if ( WrkRate == Rate63 )
			Temp += (Word32) (*Line).Sfs[1].Tran << 11 ;
		STUFF( Temp, Bsp, 12, 56 ) ;

		Temp = (*Line).Sfs[2].AcGn*NumOfGainLev + (*Line).Sfs[2].Mamp ;
		if ( WrkRate == Rate63 )
			Temp += (Word32) (*Line).Sfs[2].Tran << 11 ;
		STUFF( Temp, Bsp, 12, 68 ) ;

		Temp = (*Line).Sfs[3].AcGn*NumOfGainLev + (*Line).Sfs[3].Mamp ;
		if ( WrkRate == Rate63 )
			Temp += (Word32) (*Line).Sfs[3].Tran << 11 ;
		STUFF( Temp, Bsp, 12, 80 ) ;

		/* Write all the Grid indices */
		STUFF( (*Line).Sfs[0].Grid, Bsp, 1, 92 ) ;
		STUFF( (*Line).Sfs[1].Grid, Bsp, 1, 93 ) ;
		STUFF( (*Line).Sfs[2].Grid, Bsp, 1, 94 ) ;
		STUFF( (*Line).Sfs[3].Grid, Bsp, 1, 95 ) ;

		/* High rate only part */
		if ( WrkRate == Rate63 ) {

			/* Write the reserved bit as 0 */
    		STUFF( 0, Bsp, 1, 96 ) ;

			/* Write 13 bit combined position index */
			Temp = (*Line).Sfs[0].Ppos >> 16 ;
			Temp = Temp * 9 + ( (*Line).Sfs[1].Ppos >> 14) ;
			Temp *= 90 ;
			Temp += ((*Line).Sfs[2].Ppos >> 16) * 9 + ( (*Line).Sfs[3].Ppos >> 14 ) ;
			STUFF( Temp, Bsp, 13, 97 ) ;

			/* Write all the pulse positions */
			Temp = (*Line).Sfs[0].Ppos & 0x0000ffffL ;
			STUFF( Temp, Bsp, 16, 110 ) ;

			Temp = (*Line).Sfs[1].Ppos & 0x00003fffL ;
			STUFF( Temp, Bsp, 14, 126 ) ;

			Temp = (*Line).Sfs[2].Ppos & 0x0000ffffL ;
			STUFF( Temp, Bsp, 16, 140 ) ;

			Temp = (*Line).Sfs[3].Ppos & 0x00003fffL ;
			STUFF( Temp, Bsp, 14, 156 ) ;

			/* Write pulse amplitudes */
			Temp = (Word32) (*Line).Sfs[0].Pamp ;
			STUFF( Temp, Bsp, 6, 170 ) ;

			Temp = (Word32) (*Line).Sfs[1].Pamp ;
			STUFF( Temp, Bsp, 5, 176 ) ;

			Temp = (Word32) (*Line).Sfs[2].Pamp ;
			STUFF( Temp, Bsp, 6, 181 ) ;

			Temp = (Word32) (*Line).Sfs[3].Pamp ;
			STUFF( Temp, Bsp, 5, 187 ) ;
		}
		/* Low rate only part */
		else {

			/* Write 12 bits of positions */
			STUFF( (*Line).Sfs[0].Ppos, Bsp, 12, 96 ) ;
			STUFF( (*Line).Sfs[1].Ppos, Bsp, 12, 108 ) ;
			STUFF( (*Line).Sfs[2].Ppos, Bsp, 12, 120 ) ;
			STUFF( (*Line).Sfs[3].Ppos, Bsp, 12, 132 ) ;

			/* Write 4 bit Pamps */
			STUFF( (*Line).Sfs[0].Pamp, Bsp, 4, 144 ) ;
			STUFF( (*Line).Sfs[1].Pamp, Bsp, 4, 148 ) ;
			STUFF( (*Line).Sfs[2].Pamp, Bsp, 4, 152 ) ;
			STUFF( (*Line).Sfs[3].Pamp, Bsp, 4, 156 ) ;
		}

	}
	else {
		/* Do Sid frame gain */
		
	}

	DUMPLINE(Line);
}

//UNSTUFF n bits of *lp at bit position k into x
//      if you run out of *lp, use *++lp for leftovers
//WARNING!: as a side effect lp may be changed!
//lp and x must have an lvalue
//n and k must be compile time constants
//temp must be unsigned for shifts to be logical
#define UNSTUFF(x, lp, n_in, k_in) {\
  register unsigned temp;\
  const int n = (n_in);\
  const int k = (k_in) & 31;\
  temp = *(lp);\
  temp=temp >> k;\
  if (n+k >= 32)\
    temp |= *(++lp) << (32-k);\
  temp &= ((1 << n) - 1);\
  (x) = temp;\
  }


/*
**
** Function:        Line_Upck()
**
** Description:     unpacking of bitstream, gets coding parameters for a frame
**
** Links to text:   Section 4
**
** Arguments:
**
**  Word32 *Vinp        bitstream words
**  int    *VadAct      Voice Activity Indicator
**
** Outputs:
**
**  Word16 *VadAct
**
** Return value:
**
**  LINEDEF             coded parameters
**     Word16   Crc
**     Word32   LspId
**     Word16   Olp[SubFrames/2]
**     SFSDEF   Sfs[SubFrames]
**
*/

void Line_Unpk(LINEDEF *LinePtr, Word32 *Vinp, enum Crate *WrkRatePtr, Word16 Crc )
{
	Word32 *Bsp;
	int	FrType ;
	Word32	Temp ;
	int		BadData = 0; //Set to TRUE if invalid data discovered
	Word16  Bound_AcGn ;

	//short index;

	LinePtr->Crc = Crc;
	if(Crc !=0) {
		*WrkRatePtr = Lost;
		return; //This occurs when external erasure file is used
	}

	Bsp = Vinp;

	/* Decode the first two bits */
	UNSTUFF( Temp, Bsp, 2, 0 ) ;
	FrType = Temp;

	/* Decode the LspId */
	UNSTUFF( LinePtr->LspId, Bsp, 24, 2 ) ;
										 
	switch ( FrType ) {
	    case 0:
                *WrkRatePtr = Rate63;
                    break;
	    case 1:
	        *WrkRatePtr = Rate53;
		    break;
	    case 2:
	        *WrkRatePtr = Silent;
            //return; //no need to unpact the rest
			//HACK: for SID frame handling
			//Keep WrkRate set to whatever the previous frame was
			//	and decode in a normal fashion
			 
			 //index=getRand();
			 //if(*WrkRatePtr==Rate53)
			 //{
                //memcpy((char *)(Vinp),&r53Noise[index*6],24);
             //}
             //else if(*WrkRatePtr==Rate63)
             //{
            	//memcpy((char *)(Vinp),&r63Noise[index*6],24);
           	 //}
			//Burn first two bits again, since we already got the frame type
			//UNSTUFF( Temp, Bsp, 2, 0 );
			  return;

            default:
                *WrkRatePtr = Lost;
                //??? unpack to rest to guess from?
				return;
	}

	/*
		Decode the common information to both rates
	*/

	/* Decode the adaptive codebook lags */
	UNSTUFF( Temp, Bsp, 7, 26 ) ;
	/* TEST if forbidden code */
    if( Temp <= 123) {
        LinePtr->Olp[0] = (Word16) Temp + (Word16)PitchMin ;
    }
    else {
        /* transmission error */
        LinePtr->Crc = 1;
        return;	/*what happens in the minfilter?*/
    }

	UNSTUFF( Temp, Bsp, 2, 33 ) ;
	LinePtr->Sfs[1].AcLg = Temp ;

	UNSTUFF( Temp, Bsp, 7, 35 ) ;
	/* TEST if forbidden code */
    if( Temp <= 123) {
        LinePtr->Olp[1] = (Word16) Temp + (Word16)PitchMin ;
    }
    else {
        /* transmission error */
        LinePtr->Crc = 1;
        return;
    }

	//UNSTUFF( Temp, Bsp, 2, 41 ) ;
	UNSTUFF( Temp, Bsp, 2, 42 ) ;
	LinePtr->Sfs[3].AcLg = (Word16) Temp ;

	LinePtr->Sfs[0].AcLg = 1 ;
	LinePtr->Sfs[2].AcLg = 1 ;

	/* Decode the combined gains accordingly to the rate */
	UNSTUFF( Temp, Bsp, 12, 44 ) ;
	LinePtr->Sfs[0].Tran = 0 ;

	Bound_AcGn = NbFilt170 ;
	if ( (*WrkRatePtr == Rate63) && (LinePtr->Olp[0>>1] < (SubFrLen-2) ) ) {
		LinePtr->Sfs[0].Tran = (Word16)(Temp >> 11) ;
		Temp &= 0x000007ffL ;
		Bound_AcGn = NbFilt085 ;
	}
	LinePtr->Sfs[0].AcGn = (Word16)(Temp / (Word16)NumOfGainLev) ;

	if(LinePtr->Sfs[0].AcGn < Bound_AcGn ) {
            LinePtr->Sfs[0].Mamp = (Word16)(Temp % (Word16)NumOfGainLev) ;
    }
    else {
            /* error detected */
            LinePtr->Crc = 1;
            return ;
    }

	UNSTUFF( Temp, Bsp, 12, 56 ) ;
	LinePtr->Sfs[1].Tran = 0 ;

	Bound_AcGn = NbFilt170 ;
	if ( (*WrkRatePtr == Rate63) && (LinePtr->Olp[1>>1] < (SubFrLen-2) ) ) {
		LinePtr->Sfs[1].Tran = (Word16)(Temp >> 11) ;
		Temp &= 0x000007ffL ;
		Bound_AcGn = NbFilt085 ;
	}
	LinePtr->Sfs[1].AcGn = (Word16)(Temp / (Word16)NumOfGainLev) ;

	if(LinePtr->Sfs[1].AcGn < Bound_AcGn ) {
            LinePtr->Sfs[1].Mamp = (Word16)(Temp % (Word16)NumOfGainLev) ;
    }
    else {
            /* error detected */
            LinePtr->Crc = 1;
            return ;
    }

	UNSTUFF( Temp, Bsp, 12, 68 ) ;
	LinePtr->Sfs[2].Tran = 0 ;

	Bound_AcGn = NbFilt170 ;
	if ( (*WrkRatePtr == Rate63) && (LinePtr->Olp[2>>1] < (SubFrLen-2) ) ) {
		LinePtr->Sfs[2].Tran = (Word16)(Temp >> 11) ;
		Temp &= 0x000007ffL ;
		Bound_AcGn = NbFilt085 ;
	}
	LinePtr->Sfs[2].AcGn = (Word16)(Temp / (Word16)NumOfGainLev) ;

	if(LinePtr->Sfs[2].AcGn < Bound_AcGn ) {
            LinePtr->Sfs[2].Mamp = (Word16)(Temp % (Word16)NumOfGainLev) ;
    }
    else {
            /* error detected */
            LinePtr->Crc = 1;
            return ;
    }

	UNSTUFF( Temp, Bsp, 12, 80 ) ;
	LinePtr->Sfs[3].Tran = 0 ;

	Bound_AcGn = NbFilt170 ;
	if ( (*WrkRatePtr == Rate63) && (LinePtr->Olp[3>>1] < (SubFrLen-2) ) ) {
		LinePtr->Sfs[3].Tran = (Word16)(Temp >> 11) ;
		Temp &= 0x000007ffL ;
		Bound_AcGn = NbFilt085 ;
	}
	LinePtr->Sfs[3].AcGn = (Word16)(Temp / (Word16)NumOfGainLev) ;

	if(LinePtr->Sfs[3].AcGn < Bound_AcGn ) {
            LinePtr->Sfs[3].Mamp = (Word16)(Temp % (Word16)NumOfGainLev) ;
    }
    else {
            /* error detected */
            LinePtr->Crc = 1;
            return ;
    }


	/* Decode the grids */
	UNSTUFF( LinePtr->Sfs[0].Grid, Bsp, 1, 92 ) ;
	UNSTUFF( LinePtr->Sfs[1].Grid, Bsp, 1, 93 ) ;
	UNSTUFF( LinePtr->Sfs[2].Grid, Bsp, 1, 94 ) ;
	UNSTUFF( LinePtr->Sfs[3].Grid, Bsp, 1, 95 ) ;

	if ( *WrkRatePtr == Rate63 ) {

		/* Skip the reserved bit */
   		UNSTUFF( Temp, Bsp, 1, 96 ) ;
		if(Temp != 0) 
		  BadData = 1;

		/* Decode 13 bit combined position index */
   		UNSTUFF( Temp, Bsp, 13, 97 ) ;
		LinePtr->Sfs[0].Ppos = ( Temp/90 ) / 9 ;
		LinePtr->Sfs[1].Ppos = ( Temp/90 ) % 9 ;
		LinePtr->Sfs[2].Ppos = ( Temp%90 ) / 9 ;
		LinePtr->Sfs[3].Ppos = ( Temp%90 ) % 9 ;

		/* Decode all the pulse positions */
   		UNSTUFF( Temp, Bsp, 16, 110 ) ;
		LinePtr->Sfs[0].Ppos = ( LinePtr->Sfs[0].Ppos << 16 ) + Temp ;
   		UNSTUFF( Temp, Bsp, 14, 126 ) ;
		LinePtr->Sfs[1].Ppos = ( LinePtr->Sfs[1].Ppos << 14 ) + Temp ;
   		UNSTUFF( Temp, Bsp, 16, 140 ) ;
		LinePtr->Sfs[2].Ppos = ( LinePtr->Sfs[2].Ppos << 16 ) + Temp ;
   		UNSTUFF( Temp, Bsp, 14, 156 ) ;
		LinePtr->Sfs[3].Ppos = ( LinePtr->Sfs[3].Ppos << 14 ) + Temp ;
		
		/* Decode pulse amplitudes */
   		UNSTUFF( LinePtr->Sfs[0].Pamp, Bsp, 6, 170 ) ;
   		UNSTUFF( LinePtr->Sfs[1].Pamp, Bsp, 5, 176 ) ;
   		UNSTUFF( LinePtr->Sfs[2].Pamp, Bsp, 6, 181 ) ;
   		UNSTUFF( LinePtr->Sfs[3].Pamp, Bsp, 5, 187 ) ;
	}

	else {
		/* Decode the positions */
   		UNSTUFF( LinePtr->Sfs[0].Ppos, Bsp, 12, 96 ) ;
   		UNSTUFF( LinePtr->Sfs[1].Ppos, Bsp, 12, 108 ) ;
   		UNSTUFF( LinePtr->Sfs[2].Ppos, Bsp, 12, 120 ) ;
   		UNSTUFF( LinePtr->Sfs[3].Ppos, Bsp, 12, 132 ) ;

		/* Decode the amplitudes */
   		UNSTUFF( LinePtr->Sfs[0].Pamp, Bsp, 4, 144 ) ;
   		UNSTUFF( LinePtr->Sfs[1].Pamp, Bsp, 4, 148 ) ;
   		UNSTUFF( LinePtr->Sfs[2].Pamp, Bsp, 4, 152 ) ;
   		UNSTUFF( LinePtr->Sfs[3].Pamp, Bsp, 4, 156 ) ;
	}
   DUMPLINE(LinePtr);
   return;
}


//-------------------------------------------
int Rand_lbc(int *p)
{
  *p = ((*p)*521L + 259) << 16 >> 16;
  return(*p);
}

//-------------------------------------------
//Scale


float DotProd(register const float in1[], register const float in2[], register int npts)
/************************************************************************/
/* in1[],in2[]; Input arrays                                            */
/* npts;        Number of samples in each (vector dimension)            */
/************************************************************************/
{
#if OPT_DOT
#define array1 esi
#define array2 edi
#define idx    ebx
#define prod2(n) ASM fld DP[array1+4*idx+4*n]  ASM fmul DP[array2+4*idx+4*n]
#define faddp(n) ASM faddp ST(n),ST(0)

// Do in groups of 8.  We do 4 before the loop, then groups
// of 8, and then the final leftovers.

ASM
{
#if 0 //npts of type short
  mov idx,0;
  mov bx,npts;
#else
  mov idx,npts;
#endif
mov array1,in1;
mov array2,in2;
sub idx,12;
jle small;
}

prod2(11);
prod2(10);
prod2(9)   fxch(2)  faddp(1);
prod2(8)   fxch(2)  faddp(1);

looop:
prod2(7)  fxch(2)   faddp(1);
prod2(6)  fxch(2)   faddp(1);
prod2(5)  fxch(2)   faddp(1);
prod2(4)  fxch(2)   faddp(1);
prod2(3)  fxch(2)   faddp(1);
prod2(2)  fxch(2)   faddp(1);
prod2(1)  fxch(2)   faddp(1);
prod2(0)  fxch(2)   faddp(1);
ASM sub idx,8;
ASM  jge looop;


ASM add idx,7;
ASM  jl done;

loop2:
prod2(0)  fxch(2)   faddp(1);
ASM dec idx;
ASM  jge loop2;

done:
faddp(1);
ASM jmp alldone;

small:   // handle Len<12 cases here
ASM add idx,9
ASM cmp idx,-1
ASM  jg MoreThan2
ASM je  Exactly2


prod2(2);
ASM jmp alldone;

Exactly2:
prod2(2);
prod2(1);
faddp(1);
ASM jmp alldone;

MoreThan2:
prod2(2);
prod2(1);
ASM jmp loop2;

alldone: ;
#else

 	register float accum;  /* Internal accumulator                 */
	int n=npts,i;

	accum = 0.0f;
	for (i=0; i<n; i++)
		accum += in1[i] * in2[i];
	return(accum);
#endif
//Ignore warning C4035 and C4102 for da_dot and da_dotr: due to use of __asm

}


//-------------------------------------------------------------
float DotRev(register const float in1[], register const float in2[], register int npts)
/************************************************************************/
/* in1[],in2[]; Input arrays                                            */
/* npts;        Number of samples in each (vector dimension)            */
/************************************************************************/
{
#if OPT_REV
#define array1 esi
#define array2 edi
#define idx    ebx
#define prod3(n) ASM fld DP[array1+4*idx+4*n]  ASM fmul DP[array2-4*n]
#define faddp(n) ASM faddp ST(n),ST(0)

// Do in groups of 8.  We do 4 before the loop, then groups
// of 8, and then the final leftovers.

ASM
{
mov idx,npts;
mov array1,in1;
mov array2,in2;
lea array2,[array2+4*11];   // point element array2[11]
sub idx,12;                 // point to array1[end-11]
jle small;
}

prod3(11);
prod3(10);
prod3(9)   fxch(2)  faddp(1);
prod3(8)   fxch(2)  faddp(1);

looop:
prod3(7)  fxch(2)   faddp(1);
prod3(6)  fxch(2)   faddp(1);
prod3(5)  fxch(2)   faddp(1);
prod3(4)  fxch(2)   faddp(1);
prod3(3)  fxch(2)   faddp(1);
prod3(2)  fxch(2)   faddp(1);
prod3(1)  fxch(2)   faddp(1);
prod3(0)  fxch(2)   faddp(1);
ASM add array2,32
ASM sub idx,8;
ASM  jge looop;

cleanup:
ASM sub array2,28
ASM add idx,7;
ASM  jl done;

loop2:
prod3(0)  fxch(2)   faddp(1);
ASM add array2,4
ASM dec idx;
ASM  jge loop2;

done:
faddp(1);
ASM jmp alldone;

small:   // handle Len<12 cases here
ASM sub array2,36
ASM add idx,9
ASM cmp idx,-1
ASM  jg MoreThan2
ASM je  Exactly2

Exactly1:
prod3(2);
ASM jmp alldone;

Exactly2:
prod3(2);
prod3(1);
faddp(1);
ASM jmp alldone;

MoreThan2:
prod3(2);
prod3(1);
ASM jmp loop2;

alldone: ;
#else
         
	register float accum;  /* Internal accumulator                 */
	int i;

	in2 += npts-1;
	accum = 0.0f;
	for (i=0; i<npts; i++)
		accum += in1[i] * (*in2--);
	return(accum);

#endif
//Ignore warning C4035 and C4102 for da_dotr: due to use of __asm

}

//-------------------------------------------------------------
float Dot10(float *in1, float *in2)
{
  return(
    in1[0]*in2[0] +
    in1[1]*in2[1] +
    in1[2]*in2[2] +
    in1[3]*in2[3] +
    in1[4]*in2[4] +
    in1[5]*in2[5] +
    in1[6]*in2[6] +
    in1[7]*in2[7] +
    in1[8]*in2[8] +
    in1[9]*in2[9]
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\verinfo.h ===
//
//    INTEL Corporation Proprietary Information
//
//    This listing is supplied under the terms of a license
//    agreement with INTEL Corporation and may not be copied
//    nor disclosed except in accordance with the terms of
//    that agreement.
//
//    Copyright (c) 1996 Intel Corporation.
//    All Rights Reserved.
//


#define APPVERSION		4
#define APPREVISION		0
#define APPRELEASE		0

#define VERSIONPRODUCTNAME	"Intel G.723 ACM Driver\0"
#define VERSIONCOPYRIGHT	"Copyright \251 Intel Corp. 1995-1999\0"

#define VERSIONSTR		"1.00.017\0"

#define VERSIONCOMPANYNAME	"Intel Corporation\0"

#ifndef OFFICIAL
#define VER_PRIVATEBUILD	VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD	0
#endif

#ifndef FINAL
#define VER_PRERELEASE		VS_FF_PRERELEASE
#else
#define VER_PRERELEASE		0
#endif

#if defined(DEBUG_RETAIL)
#define VER_DEBUG		VS_FF_DEBUG    
#elif defined(DEBUG)
#define VER_DEBUG		VS_FF_DEBUG    
#else
#define VER_DEBUG		0
#endif

#define VERSIONFLAGS		(VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)
#define VERSIONFILEFLAGSMASK	0x0030003FL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\g723\util_lbc.h ===
//
//	ITU-T G.723 Floating Point Speech Coder	ANSI C Source Code.	Version 1.00
//	copyright (c) 1995, AudioCodes, DSP Group, France Telecom,
//	Universite de Sherbrooke, Intel Corporation.  All rights reserved.
//

int  MyFloor (float);
#if NOTMINI
void Read_lbc ( float *Dpnt, int Len, FILE *Fp );
void Write_lbc( float *Dpnt, int Len, FILE *Fp );
#endif
void Rem_Dc( float *Dpnt, CODDEF *CodStat);
void Mem_Shift( float *PrevDat, float *DataBuff );
void Line_Pack( LINEDEF *Line, Word32 *Vout,int *VadAct, enum Crate WrkRate);
void Line_Unpk( LINEDEF *Line, Word32 *Vinp, enum Crate *WrkRatePtr, Word16 Crc );
int Rand_lbc( int *p );
//void Scale
float DotProd(register const float in1[], register const float in2[], register int npts);
float DotRev(register const float in1[], register const float in2[], register int npts);
float Dot10(float in1[], float in2[]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\ccodecid.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
////////////////////////////////////////////////////////////////////////////
//
// $Author:   RMCKENZX  $
// $Date:   27 Dec 1995 14:11:46  $
// $Archive:   S:\h26x\src\common\ccodecid.h_v  $
// $Header:   S:\h26x\src\common\ccodecid.h_v   1.2   27 Dec 1995 14:11:46   RMCKENZX  $
// $Log:   S:\h26x\src\common\ccodecid.h_v  $
;// 
;//    Rev 1.2   27 Dec 1995 14:11:46   RMCKENZX
;// 
;// Added copyright notice
//
////////////////////////////////////////////////////////////////////////////
#ifndef __CODECID_H__
#define __CODECID_H__

#define YVU9_CODEC   0
#define H263_CODEC   1
#define YUV12_CODEC  2

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\ccustmsg.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
////////////////////////////////////////////////////////////////////////////
//
// $Author:   KLILLEVO  $
// $Date:   10 Sep 1996 16:13:10  $
// $Archive:   S:\h26x\src\common\ccustmsg.h_v  $
// $Header:   S:\h26x\src\common\ccustmsg.h_v   1.10   10 Sep 1996 16:13:10   KLILLEVO  $
//	$Log:   S:\h26x\src\common\ccustmsg.h_v  $
;// 
;//    Rev 1.10   10 Sep 1996 16:13:10   KLILLEVO
;// added custom message in decoder to turn block edge filter on or off
;// 
;//    Rev 1.9   22 Jul 1996 14:46:16   BECHOLS
;// 
;// fixed last comment.
;// 
;//    Rev 1.8   22 Jul 1996 14:38:08   BECHOLS
;// 
;// Wrapped the comment section with /* ... */ /* so that Steve Ing won't
;// be hassled with changing this.
;// 
;//    Rev 1.7   22 May 1996 18:47:32   BECHOLS
;// 
;// Added EC_RESET_TO_FACTORY_DEFAULTS.
;// 
;//    Rev 1.6   28 Apr 1996 17:48:04   BECHOLS
;// Added CODEC_CUSTOM_ENCODER_CONTROL.
;// 
;//    Rev 1.5   04 Jan 1996 10:09:16   TRGARDOS
;// Added bit flag to signal still image.
;// 
;//    Rev 1.4   27 Dec 1995 14:11:52   RMCKENZX
;// 
;// Added copyright notice
// 
//    Rev 1.3   18 Dec 1995 13:49:06   TRGARDOS
// Added bit flags for H.263 options.
// 
//    Rev 1.2   01 Dec 1995 12:37:12   TRGARDOS
// Added defines for h.263 options.
// 
//    Rev 1.1   25 Oct 1995 20:12:42   TRGARDOS
// Added bit field mask for bitrate controller.
// 
//    Rev 1.0   31 Jul 1995 12:55:18   DBRUCKS
// rename files
// 
//    Rev 1.0   17 Jul 1995 14:43:54   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:18   CZHU
// Initial revision.
////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------
//
//  CODECUST.H include file for use with the Indeo codec.
//
//  This file defines custom messages that the driver recognizes.
//
//  Copyright 1994 - Intel Corporation
//
// ---------------------------------------------------------------------
*/

//  DRV_USER is defined in windows.h and mmsystem.h as 0x4000
#define ICM_RESERVED_HIGH			(DRV_USER+0x2000)
#define CUSTOM_START				(ICM_RESERVED_HIGH+1)

// ---------------------------------------------------------------------
// ---------------------------------------------------------------------
// CODEC_CUSTOM_VIDEO_EFFECTS:
//    This message is used to control custom video effects, most of
//    which are common between the capture drivers and the codec drivers.
//
//    See drvcomon.h (Supplied and maintained by Video Manager team)
// --------------------------------------------------------------------- 

#define CODEC_CUSTOM_VIDEO_EFFECTS      (CUSTOM_START+ 8)
#define CODEC_CUSTOM_ENCODER_CONTROL    (CUSTOM_START+ 9)
#define APPLICATION_IDENTIFICATION_CODE (CUSTOM_START+10)
#define CODEC_CUSTOM_DECODER_CONTROL    (CUSTOM_START+11)
#define CUSTOM_ENABLE_CODEC				(CUSTOM_START+200)

#define CODEC_CUSTOM_RATE_CONTROL	     0x10000
#define CODEC_CUSTOM_PB		 		     0x20000
#define CODEC_CUSTOM_AP				     0x40000
#define CODEC_CUSTOM_UMV			     0x80000
#define CODEC_CUSTOM_SAC			    0x100000
#define CODEC_CUSTOM_STILL              0x200000

#define	G723MAGICWORD1					0xf7329ace
#define	G723MAGICWORD2					0xacdeaea2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\c1rtp.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/
// $Author:   RHAZRA  $
// $Date:   07 Nov 1996 14:47:44  $
// $Archive:   S:\h26x\src\common\c1rtp.h_v  $
// $Header:   S:\h26x\src\common\c1rtp.h_v   1.1   07 Nov 1996 14:47:44   RHAZRA  $
// $Log:   S:\h26x\src\common\c1rtp.h_v  $
;// 
;//    Rev 1.1   07 Nov 1996 14:47:44   RHAZRA
;// Added function prototype for RTP buffer overhead estimation function
;// 
;//    Rev 1.0   21 Aug 1996 18:29:44   RHAZRA
;// Initial revision.
;// 
;//    Rev 1.1   03 May 1996 13:09:58   CZHU
;// 
;// 
;//    Rev 1.0   22 Apr 1996 16:38:30   BECHOLS
;// Initial revision.
;// 
;//    Rev 1.6   10 Apr 1996 13:32:50   CZHU
;// 
;// Moved testing packet loss into this module for common use by encoder or dec
;// 
;//    Rev 1.5   29 Mar 1996 13:33:16   CZHU
;// 
;// Moved bitstream verification from d3rtp.cpp to c3rtp.cpp
;// 
;//    Rev 1.4   23 Feb 1996 18:01:48   CZHU
;// 
;//    Rev 1.3   23 Feb 1996 17:23:58   CZHU
;// 
;// Changed packet size adjustment
;// 
;//    Rev 1.2   15 Feb 1996 12:02:14   CZHU
;// 
;//    Rev 1.1   14 Feb 1996 15:01:34   CZHU
;// clean up
;// 
;//    Rev 1.0   12 Feb 1996 17:06:42   CZHU
;// Initial revision.
;// 
;//    Rev 1.0   29 Jan 1996 13:50:26   CZHU
;// Initial revision.
;// 
;//    Rev 1.2   04 Dec 1995 16:50:52   CZHU
;// 
;//    Rev 1.1   01 Dec 1995 15:54:12   CZHU
;// Included Init() and Term() functions.
;// 
;//    Rev 1.0   01 Dec 1995 15:31:10   CZHU
;// Initial revision.

/*
 *	 This file is for RTP payload generation. See EPS for details
 *
 *
 */

#ifndef _H261_RTP_C1RTP_
#define  _H261_RTP_C1RTP_

const U32  DEFAULT_PACKET_SIZE               = 512;		        //over IP
const U32  DEFAULT_PACKET_SIZE_VARIANCE      = 100;
const U32  DEFAULT_FRAME_SIZE                = 64 * 1024 / 5;	//64KB at 5 fps

const U32  H261_RTP_BS_START_CODE = FOURCC_H263; 

const U32  RTP_H26X_INTRA_CODED   = 0x00000001;

const U32 H26X_RTP_PAYLOAD_VERSION=0;
const U32 RTP_H26X_PACKET_LOST   =0x00000001;

typedef struct {
  U32 uVersion;
  U32 uFlags;
  U32 uUniqueCode;
  U32 uCompressedSize;
  U32 uNumOfPackets;
  U8  u8Src;
  U8  u8TR;
  U8  u8TRB;
  U8  u8DBQ;

} T_H26X_RTP_BSINFO_TRAILER;


typedef struct {
	U32 uFlags;
	U32 uBitOffset;
	 U8 u8MBA;
	 U8 u8Quant;
	 U8 u8GOBN;
	 I8 i8HMV;
	 I8 i8VMV;
     U8 u8Padding0;
    U16 u16Padding1;
	 
} T_RTP_H261_BSINFO	;

extern  I32 H26XRTP_VerifyBsInfoStream(T_H263DecoderCatalog *,U8 *, U32 );
extern  DWORD H261EstimateRTPOverhead(LPCODINST, LPBITMAPINFOHEADER);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\c1rtp.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    Copyright (c) 1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
// $Header:   S:\h26x\src\common\c1rtp.cpv   1.5   02 Dec 1996 16:13:38   RHAZRA  $
// $Log:   S:\h26x\src\common\c1rtp.cpv  $
# 
#    Rev 1.5   02 Dec 1996 16:13:38   RHAZRA
# More adjustment to the H.261 RTp overhead estimation routine.
# 
#    Rev 1.4   22 Nov 1996 14:52:22   RHAZRA
# Changed RTP overhead estimation routine slightly.
# 
#    Rev 1.3   18 Nov 1996 17:10:48   MBODART
# Replaced all debug message invocations with Active Movie's DbgLog.
# 
#    Rev 1.2   07 Nov 1996 14:46:32   RHAZRA
# Added function to guestimate RTP overhead in bitstream buffer.
# 
#    Rev 1.1   23 Aug 1996 13:05:54   RHAZRA
# Added #ifdef RING0 .. #endif to avoid wsprintf and GlobalAlloc
# problems in RING0
# 
#    Rev 1.0   21 Aug 1996 18:29:04   RHAZRA
# Initial revision.
// 
//    Rev 1.2   02 May 1996 13:27:04   CZHU
// Adjust for merging with main database in the decoder
// 
//    Rev 1.1   28 Apr 1996 20:34:50   BECHOLS
// 
// Removed IFDEF -- RTP_HEADER.
// 
//    Rev 1.0   22 Apr 1996 17:47:54   BECHOLS
// Initial revision.
// 
//    Rev 1.3   10 Apr 1996 13:32:08   CZHU
// 
// Moved testing packet loss into this module 
// for common use by encoder or dec
// 
//    Rev 1.2   29 Mar 1996 14:45:06   CZHU
// 
//    Rev 1.1   29 Mar 1996 14:39:34   CZHU
// Some cleaning
// 
//    Rev 1.0   29 Mar 1996 13:32:42   CZHU
// Initial revision.
// 
*/
#include "precomp.h"

I32 H26XRTP_VerifyBsInfoStream(
	T_H263DecoderCatalog *DC,
    U8 *pu8Src,
    U32 uSize
)
{
  T_H26X_RTP_BSINFO_TRAILER *pBsTrailer;
  T_RTP_H261_BSINFO *pBsInfo;

#ifndef RING0
 #ifdef _DEBUG
  int  i;
 #endif
#endif

  ASSERT(!DC->iVerifiedBsExt);

  DC->iVerifiedBsExt=TRUE;
  pBsTrailer =(T_H26X_RTP_BSINFO_TRAILER *)(pu8Src + uSize);
  pBsTrailer--;

#ifndef RING0
 #ifdef _DEBUG
  {char msg[120];
   int iused;

   iused= wsprintf(msg,"StartCode = %ld, CompSize=%ld, No.Pack=%ld, SRC=%d, TR=%d, TRB=%d, DBQ=%d",
            pBsTrailer->uUniqueCode, pBsTrailer->uCompressedSize,
            pBsTrailer->uNumOfPackets,pBsTrailer->u8Src,
            pBsTrailer->u8TR,pBsTrailer->u8TRB,pBsTrailer->u8DBQ );
   ASSERT(iused < 120);
   DBOUT(msg);  
  }
  #endif
#endif          

  if (pBsTrailer->uUniqueCode != H261_RTP_BS_START_CODE)
  {
//#ifdef LOSS_RECOVERY
#ifndef RING0
 #ifdef _DEBUG
   DBOUT("No RTP BS Extension found");
 #endif
#endif
   DC->iValidBsExt   = FALSE;
   DC->uNumOfPackets = 0;
   DC->pBsInfo       = NULL;
   DC->pBsTrailer    = NULL;

//#endif

   goto ret;
  }
  //bitstream is valid, so...
  pBsInfo = (T_RTP_H261_BSINFO *)pBsTrailer; 
  pBsInfo -= pBsTrailer->uNumOfPackets;

//#ifdef LOSS_RECOVERY
  DC->pBsTrailer = (void *)pBsTrailer;
  DC->uNumOfPackets = pBsTrailer->uNumOfPackets;
  DC->iValidBsExt =TRUE;
  DC->pBsInfo     = (void *)pBsInfo;
//#endif

#ifndef RING0
 #ifdef _DEBUG
  for (i=0; i< (int)pBsTrailer->uNumOfPackets; i++)
  {
   char msg[120];
   int iused;

   iused= wsprintf(msg, 
       "uFlag =%d,BitOffset=%d, MBA=%d, uQuant=%d,GOBN=%d",
                 pBsInfo->uFlags,
                 pBsInfo->uBitOffset,
                 pBsInfo->u8MBA,
                 pBsInfo->u8Quant,
                 pBsInfo->u8GOBN);

	  ASSERT(iused < 120);
    DBOUT(msg);


	pBsInfo++;
  }
  #endif
#endif

ret:
 return TRUE;
}

DWORD H261EstimateRTPOverhead(LPCODINST lpInst, LPBITMAPINFOHEADER lParam1)
{
	DWORD dExtendedSize;
	DWORD dTargetFrameSize;
	DWORD dEffectivePacketSize;
    BOOL  bTargetSizeOK;
	DWORD dNumberOfGOBs;
	DWORD dNumberOfPacketsPerGOB;
	DWORD dGOBSize;
	DWORD dNormalBufferSize;

	extern U32 getRTPPacketSizeThreshold(U32);

	if (lParam1->biHeight == 288 && lParam1->biWidth == 352)
	{
		dNumberOfGOBs = 12;
		dNormalBufferSize = 32*1024;
	}
	else
	{
		dNumberOfGOBs = 3;
        dNormalBufferSize = 8 * 1024;
	}

	dEffectivePacketSize = getRTPPacketSizeThreshold(lpInst->Configuration.unPacketSize);
	if ( (lpInst->FrameRate > 0 ) && (lpInst->DataRate > 0) )
	{
		dTargetFrameSize = (DWORD) (lpInst->DataRate / lpInst->FrameRate);
        bTargetSizeOK = TRUE;
	}
	else
    {   
		bTargetSizeOK = FALSE;
	}
	
	if (bTargetSizeOK)
	{
		dGOBSize = dTargetFrameSize/dNumberOfGOBs;

		dNumberOfPacketsPerGOB = __max(1, dGOBSize/dEffectivePacketSize);
		dExtendedSize = ( dNumberOfPacketsPerGOB * dNumberOfGOBs * sizeof(T_RTP_H261_BSINFO) +
			             sizeof(T_H26X_RTP_BSINFO_TRAILER) ) * 2;
		
	}
	else

		dExtendedSize = dNormalBufferSize; 

	return (dExtendedSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\cdialogs.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

#include "precomp.h"

#ifndef MF_SHELL
#ifndef RING0
extern HINSTANCE hDriverModule;
#endif
#endif

/*****************************************************************************
 *
 * cdialog.cpp
 *
 * DESCRIPTION:
 *		Dialog functions.
 *
 * Routines:					Prototypes in:
 *  About						cdialog.h
 *  DrvConfigure				cdialog.h			
 *  GetConfigurationDefaults	cdialogs.h
 */

// $Header:   S:\h26x\src\common\cdialogs.cpv   1.25   06 Mar 1997 14:48:58   KLILLEVO  $
// $Log:   S:\h26x\src\common\cdialogs.cpv  $
// 
//    Rev 1.25   06 Mar 1997 14:48:58   KLILLEVO
// Added check for valid pComp for release version.
// 
//    Rev 1.24   05 Mar 1997 16:17:10   JMCVEIGH
// No longer support configuration dialog box.
// 
//    Rev 1.23   13 Feb 1997 14:13:34   MBODART
// 
// Made Active Movie constant definitions consistent with those in cdialogs.
// 
//    Rev 1.22   12 Feb 1997 15:51:10   AGUPTA2
// Decreased minimum packet size allowed to 64.
// 
//    Rev 1.21   05 Feb 1997 12:13:58   JMCVEIGH
// Support for improved PB-frames custom message handling.
// 
//    Rev 1.20   16 Dec 1996 17:37:28   JMCVEIGH
// Setting/getting of H.263+ optional mode states.
// 
//    Rev 1.19   11 Dec 1996 14:55:26   JMCVEIGH
// 
// Functions for setting/getting in-the-loop deblocking filter and
// true B-frame mode states.
// 
//    Rev 1.18   04 Dec 1996 14:38:18   RHAZRA
// Fixed a couple of bugs: (1) SetResiliencyParameters was never called when
// an application sent a custom message to us turning on resiliency and
// (ii) in ReadDialogBox() the resiliency parameters were being set from
// the defaults rather than the values set by the user.
// 
// Upon Chad's suggestion, I have decided NOT to tie RTP header generation
// and resiliency as per discussion with Ben. This is to stay compliant with
// existing applications such as AV phone and XnetMM that haven't gone to
// ActiveMovie yet.
// 
//    Rev 1.17   25 Nov 1996 09:12:40   BECHOLS
// Bumped packet size to 9600.
// 
//    Rev 1.16   13 Nov 1996 00:33:50   BECHOLS
// 
// Removed registry persistance.
// 
//    Rev 1.15   31 Oct 1996 10:12:46   KLILLEVO
// changed from DBOUT to DBgLog
// 
//    Rev 1.14   21 Oct 1996 10:50:08   RHAZRA
// fixed a problem with H.261 initialization of RTP BS info call
// 
//    Rev 1.13   16 Sep 1996 16:38:46   CZHU
// Extended the minimum packet size to 128 bytes. Fixed buffer overflow bug
// 
//    Rev 1.12   10 Sep 1996 16:13:00   KLILLEVO
// added custom message in decoder to turn block edge filter on or off
// 
//    Rev 1.11   29 Aug 1996 09:27:18   CZHU
// Simplified handling of packet loss settings.
// 
//    Rev 1.10   26 Aug 1996 13:38:18   BECHOLS
// Fixed 2 bugs: The first was where if -1 was entered, it would be changed
// to (unsigned) -1, both of which are illegal values.  The second is where
// if an invalid value is entered, and the checkbox is unchecked, the user
// would be required to check the box, enter a valid value, and then uncheck
// the checkbox.  The fixed code notifies the user of the problem if the box
// is checked, and fills in the previous good value.  If the box is unchecked
// it fills in the previous good value, and doesn't notify the user, since
// the value being unchecked is of no concern to the user.
// Finally, I added an IFDEF H261 to the Key path assignment so that H261
// would use a separate Registry Entry.
// 
//    Rev 1.9   21 Aug 1996 18:53:42   RHAZRA
// 
// Added #ifdef s to accomodate both H.261 and H.263 in RTP related
// tasks.
// 
//    Rev 1.7   13 Jun 1996 14:23:36   CZHU
// Fix bugs in custom message handing for RTP related tasks.
// 
//    Rev 1.6   22 May 1996 18:46:02   BECHOLS
// Added CustomResetToFactoryDefaults.
// 
//    Rev 1.5   08 May 1996 10:06:42   BECHOLS
// 
// Changed the checking of the Packet size raising the minimum acceptable to 
// 256 vs. 64.  This will hopefully kludge around a known bug.  I also fixed a
// by preventing field overflow on the numerics.
// 
//    Rev 1.4   06 May 1996 12:53:56   BECHOLS
// Changed the bits per second to bytes per second.
// 
//    Rev 1.3   06 May 1996 00:40:04   BECHOLS
// 
// Added code to support the bit rate control stuff in the resource file.
// I also added the code necessary to handle messages to control the new
// dialog features.
// 
//    Rev 1.2   28 Apr 1996 20:24:54   BECHOLS
// 
// Merged RTP code into the Main Base.
// 
//    Rev 1.1   17 Nov 1995 14:50:54   BECHOLS
// Made modifications to make this file as a mini-filter.  The flags
// RING0 and MF_SHELL were added.
// 
//    Rev 1.0   17 Oct 1995 15:07:22   DBRUCKS
// add about box files
// 
// Added code to process Custom messages, and also code to differentiate
//  between different values for packet loss, and set the defaults for no
//  RTP header or resiliency.
// Modified RTP dialog box.
// Add Configure dialog
// 

static BOOL AboutDialogProc(HWND hDlg, UINT message, UINT wParam, LONG lParam);

extern void SetResiliencyParams(T_CONFIGURATION * pConfiguration);

#define VALID_BOOLEAN(v) (v == 0 || v == 1)
#if defined(H261)
#define VALID_PACKET_SIZE(v) ((v) >= 128 && (v) <= 9600)
#else
#define VALID_PACKET_SIZE(v) ((v) >= 64 && (v) <= 9600)
#endif
#define VALID_PACKET_LOSS(v) (v >= 0 && v <= 100)
#define VALID_BITRATE(v) (v >= 1024 && v <= 13312)

/**************************************************************************
 * CustomGetRTPHeaderState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bRTPHeader.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetRTPHeaderState(LPCODINST pComp, DWORD FAR *pRTPHeaderState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pRTPHeaderState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetRTPHeaderState;
   }
   if(pComp && pRTPHeaderState)
   {
      *pRTPHeaderState = (DWORD)pComp->Configuration.bRTPHeader;
      lRet = ICERR_OK;
   }

EXIT_GetRTPHeaderState:
   return(lRet);
}

/**************************************************************************
 * CustomGetResiliencyState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bEncoderResiliency.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetResiliencyState(LPCODINST pComp, DWORD FAR *pResiliencyState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pResiliencyState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetResiliencyState;
   }
   if(pComp && pResiliencyState)
   {
      *pResiliencyState = (DWORD)pComp->Configuration.bEncoderResiliency;
      lRet = ICERR_OK;
   }

EXIT_GetResiliencyState:
   return(lRet);
}

/**************************************************************************
 * CustomGetBitRateState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bBitRateState.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetBitRateState(LPCODINST pComp, DWORD FAR *pBitRateState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pBitRateState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetBitRateState;
   }
   if(pComp && pBitRateState)
   {
      *pBitRateState = (DWORD)pComp->Configuration.bBitRateState;
      lRet = ICERR_OK;
   }

EXIT_GetBitRateState:
   return(lRet);
}

/**************************************************************************
 * CustomGetPacketSize() is called from CDRVPROC.CPP.
 *
 * Returns the Packet Size.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetPacketSize(LPCODINST pComp, DWORD FAR *pPacketSize)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pPacketSize);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetPacketSize;
   }
   if(pComp && pPacketSize)
   {
      *pPacketSize = (DWORD)pComp->Configuration.unPacketSize;
      lRet = ICERR_OK;
   }

EXIT_GetPacketSize:
   return(lRet);
}

/**************************************************************************
 * CustomGetPacketLoss() is called from CDRVPROC.CPP.
 *
 * Returns the Packet Loss.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetPacketLoss(LPCODINST pComp, DWORD FAR *pPacketLoss)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pPacketLoss);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetPacketLoss;
   }
   if(pComp && pPacketLoss)
   {
      *pPacketLoss = (DWORD)pComp->Configuration.unPacketLoss;
      lRet = ICERR_OK;
   }

EXIT_GetPacketLoss:
   return(lRet);
}

/**************************************************************************
 * CustomGetBitRate() is called from CDRVPROC.CPP.
 *
 * Returns the Bit Rate in bytes per second.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetBitRate(LPCODINST pComp, DWORD FAR *pBitRate)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pBitRate);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetBitRate;
   }
   if(pComp && pBitRate)
   {
      *pBitRate = (DWORD)pComp->Configuration.unBytesPerSecond;
      lRet = ICERR_OK;
   }

EXIT_GetBitRate:
   return(lRet);
}

#ifdef H263P
/**************************************************************************
 * CustomGetH263PlusState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bH263Plus
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetH263PlusState(LPCODINST pComp, DWORD FAR *pH263PlusState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pH263PlusState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetH263PlusState;
   }
   if(pComp && pH263PlusState)
   {
      *pH263PlusState = (DWORD)pComp->Configuration.bH263PlusState;
      lRet = ICERR_OK;
   }

EXIT_GetH263PlusState:
   return(lRet);
}

/**************************************************************************
 * CustomGetImprovedPBState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bImprovedPBState.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetImprovedPBState(LPCODINST pComp, DWORD FAR *pImprovedPBState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pImprovedPBState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetImprovedPBState;
   }
   if(pComp && pImprovedPBState)
   {
      *pImprovedPBState = (DWORD)pComp->Configuration.bImprovedPBState;
      lRet = ICERR_OK;
   }

EXIT_GetImprovedPBState:
   return(lRet);
}

/**************************************************************************
 * CustomGetDeblockingFilterState() is called from CDRVPROC.CPP.
 *
 * Returns the state of ->bDeblockingFilterState.
 *
 * Returns ICERR_BADPARAM if either parameter is zero, else ICERR_OK. 
 */
LRESULT CustomGetDeblockingFilterState(LPCODINST pComp, DWORD FAR *pDeblockingFilterState)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);
   ASSERT(pDeblockingFilterState);
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_GetDeblockingFilterState;
   }
   if(pComp && pDeblockingFilterState)
   {
      *pDeblockingFilterState = (DWORD)pComp->Configuration.bDeblockingFilterState;
      lRet = ICERR_OK;
   }

EXIT_GetDeblockingFilterState:
   return(lRet);
}

#endif // H263P

/**************************************************************************
 * CustomSetRTPHeaderState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bRTPHeader.
 *
 * Returns ICERR_BADPARAM if pComp is zero or RTPHeaderState is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetRTPHeaderState(LPCODINST pComp, DWORD RTPHeaderState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;

   bState = (BOOL)RTPHeaderState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetRTPHeaderState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
    T_H263EncoderInstanceMemory *P32Inst;
    T_H263EncoderCatalog 		*EC;
    LPVOID         EncoderInst;
  
    EncoderInst = pComp->hEncoderInst;
    if (EncoderInst == NULL)
    {
        DBOUT("ERROR :: H26XCompress :: ICERR_MEMORY");
        lRet = ICERR_MEMORY;
        goto  EXIT_SetRTPHeaderState;
    }

   /*
    * Generate the pointer to the encoder instance memory aligned to the
	* required boundary.
	*/

#ifndef H261
    P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
#else
   P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) pComp->EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
#endif
    EC = &(P32Inst->EC);

    // Get pointer to encoder catalog.
  
   	if (!pComp->Configuration.bRTPHeader && bState)
	{ 
#ifndef H261    
	   H263RTP_InitBsInfoStream(pComp,EC);
#else
       H261RTP_InitBsInfoStream(EC,pComp->Configuration.unPacketSize);
#endif
    }
   	if (pComp->Configuration.bRTPHeader && !bState)
	{ 
#ifndef H261
	   H263RTP_TermBsInfoStream(EC);
#else
       H261RTP_TermBsInfoStream(EC);
#endif

	}

    pComp->Configuration.bRTPHeader = bState;
    lRet = ICERR_OK;
   }

EXIT_SetRTPHeaderState:
   return(lRet);
}

/**************************************************************************
 * CustomSetResiliencyState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bEncoderResiliency.
 *
 * Returns ICERR_BADPARAM if pComp is zero or ResiliencyState is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetResiliencyState(LPCODINST pComp, DWORD ResiliencyState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;

   bState = (BOOL)ResiliencyState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetResiliencyState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bEncoderResiliency = bState;
	  SetResiliencyParams(&(pComp->Configuration));
      lRet = ICERR_OK;
   }

EXIT_SetResiliencyState:
   return(lRet);
}

/**************************************************************************
 * CustomSetBitRateState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bBitRateState.
 *
 * Returns ICERR_BADPARAM if pComp is zero or BitRateState is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetBitRateState(LPCODINST pComp, DWORD BitRateState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;

   bState = (BOOL)BitRateState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetBitRateState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bBitRateState = bState;
      lRet = ICERR_OK;
   }

EXIT_SetBitRateState:
   return(lRet);
}

/**************************************************************************
 * CustomSetPacketSize() is called from CDRVPROC.CPP.
 *
 * Sets the size of ->unPacketSize.
 *
 * Returns ICERR_BADPARAM if pComp is zero or PacketSize is not a valid size,
 *  else ICERR_OK. 
 */
LRESULT CustomSetPacketSize(LPCODINST pComp, DWORD PacketSize)
{
   LRESULT lRet = ICERR_BADPARAM;
   UINT unSize;

   unSize = (UINT)PacketSize;
   ASSERT(pComp);
   ASSERT(VALID_PACKET_SIZE(unSize));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetPacketSize;
   }
   if(pComp && VALID_PACKET_SIZE(unSize))
   {
   	T_H263EncoderInstanceMemory *P32Inst;
    T_H263EncoderCatalog 		*EC;
    LPVOID         EncoderInst;
  
    EncoderInst = pComp->hEncoderInst;
    if (EncoderInst == NULL)
    {
        DBOUT("ERROR :: H26XCompress :: ICERR_MEMORY");
        lRet = ICERR_MEMORY;
        goto  EXIT_SetPacketSize;
    }

   /*
    * Generate the pointer to the encoder instance memory aligned to the
	* required boundary.
	*/
#ifndef H261
  	P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
#else
    P32Inst = (T_H263EncoderInstanceMemory *)
  			  ((((U32) pComp->EncoderInst) + 
    	                    (sizeof(T_MBlockActionStream) - 1)) &
    	                   ~(sizeof(T_MBlockActionStream) - 1));
#endif
    // Get pointer to encoder catalog.
    EC = &(P32Inst->EC);
  
   	if (!pComp->Configuration.bRTPHeader)
	{   lRet = ICERR_ERROR;
        goto  EXIT_SetPacketSize;
    }
 
	if (pComp->Configuration.unPacketSize != unSize )
	{
#ifndef H261
		H263RTP_TermBsInfoStream(EC);
#else
        H261RTP_TermBsInfoStream(EC);
#endif
		pComp->Configuration.unPacketSize = unSize;
#ifndef H261
        H263RTP_InitBsInfoStream(pComp,EC);
#else
        H261RTP_InitBsInfoStream(EC,pComp->Configuration.unPacketSize);
#endif
	}

    lRet = ICERR_OK;
   }

EXIT_SetPacketSize:
   return(lRet);
}

/**************************************************************************
 * CustomSetPacketLoss() is called from CDRVPROC.CPP.
 *
 * Sets the amount of ->unPacketLoss.
 *
 * Returns ICERR_BADPARAM if pComp is zero or PacketLoss is not a valid size,
 *  else ICERR_OK. 
 */
LRESULT CustomSetPacketLoss(LPCODINST pComp, DWORD PacketLoss)
{
   LRESULT lRet = ICERR_BADPARAM;
   UINT unLoss;

   unLoss = (UINT)PacketLoss;
   ASSERT(pComp);
//   ASSERT(VALID_PACKET_LOSS(unLoss)); Always True
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetPacketLoss;
   }
   if(pComp) // && VALID_PACKET_LOSS(unLoss)) Always True
   {
      pComp->Configuration.unPacketLoss = unLoss;
	  SetResiliencyParams(&(pComp->Configuration));
      lRet = ICERR_OK;
   }

EXIT_SetPacketLoss:
   return(lRet);
}

/**************************************************************************
 * CustomSetBitRate() is called from CDRVPROC.CPP.
 *
 * Sets the amount of ->unBytesPerSecond.
 *
 * Returns ICERR_BADPARAM if pComp is zero or BitRate is not a valid size,
 *  else ICERR_OK. 
 */
LRESULT CustomSetBitRate(LPCODINST pComp, DWORD BitRate)
{
   LRESULT lRet = ICERR_BADPARAM;
   UINT unBitRate;

   unBitRate = (UINT)BitRate;
   ASSERT(pComp);
   ASSERT(VALID_BITRATE(unBitRate));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetBitRate;
   }
   if(pComp && VALID_BITRATE(unBitRate))
   {
      pComp->Configuration.unBytesPerSecond = unBitRate;
      lRet = ICERR_OK;
   }

EXIT_SetBitRate:
   return(lRet);
}

#ifdef H263P
/**************************************************************************
 * CustomSetH263PlusState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bH263PlusState.
 *
 * Returns ICERR_BADPARAM if pComp is zero or H263PlusState is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetH263PlusState(LPCODINST pComp, DWORD H263PlusState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;

   bState = (BOOL)H263PlusState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   if(pComp && (pComp->Configuration.bInitialized == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetH263PlusState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bH263PlusState = bState;
      lRet = ICERR_OK;
   }

EXIT_SetH263PlusState:
   return(lRet);
}

/**************************************************************************
 * CustomSetImprovedPBState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bImprovedPBState.
 *
 * Returns ICERR_BADPARAM if pComp is zero or ImprovedPB is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetImprovedPBState(LPCODINST pComp, DWORD ImprovedPBState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;
   BOOL bH263PlusState;

   bState = (BOOL)ImprovedPBState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   // ->bH263PlusState must be TRUE
   if(pComp && (pComp->Configuration.bInitialized == FALSE) ||
	  (CustomGetH263PlusState(pComp, (DWORD FAR *)&bH263PlusState) != ICERR_OK) ||
	  (bH263PlusState == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetImprovedPBState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bImprovedPBState = bState;
      lRet = ICERR_OK;
   }

EXIT_SetImprovedPBState:
   return(lRet);
}

/**************************************************************************
 * CustomSetDeblockingFilterState() is called from CDRVPROC.CPP.
 *
 * Sets the state of ->bDeblockingFilterState.
 *
 * Returns ICERR_BADPARAM if pComp is zero or DeblockingFilter is not a valid
 *  boolean, else ICERR_OK. 
 */
LRESULT CustomSetDeblockingFilterState(LPCODINST pComp, DWORD DeblockingFilterState)
{
   LRESULT lRet = ICERR_BADPARAM;
   BOOL bState;
   BOOL bH263PlusState;

   bState = (BOOL)DeblockingFilterState;
   ASSERT(pComp);
   ASSERT(VALID_BOOLEAN(bState));
   // ->bH263PlusState must be TRUE
   if(pComp && (pComp->Configuration.bInitialized == FALSE) ||
	  (CustomGetH263PlusState(pComp, (DWORD FAR *)&bH263PlusState) != ICERR_OK) ||
	  (bH263PlusState == FALSE))
   {
      lRet = ICERR_ERROR;
      goto EXIT_SetDeblockingFilterState;
   }
   if(pComp && VALID_BOOLEAN(bState))
   {
      pComp->Configuration.bDeblockingFilterState = bState;
      lRet = ICERR_OK;
   }

EXIT_SetDeblockingFilterState:
   return(lRet);
}
#endif // H263P

/**************************************************************************
 * CustomResetToFactoryDefaults() is called from CDRVPROC.CPP.
 *
 * Sets the amount of ->unBytesPerSecond.
 *
 * Returns ICERR_BADPARAM if pComp is zero or BitRate is not a valid size,
 *  else ICERR_OK. 
 */
LRESULT CustomResetToFactoryDefaults(LPCODINST pComp)
{
   LRESULT lRet = ICERR_BADPARAM;

   ASSERT(pComp);

   if(pComp)
   {
      GetConfigurationDefaults(&pComp->Configuration); /* Overwrite the configuration data */
      lRet = ICERR_OK;
   }

   return(lRet);
}

/**************************************************************************
 * CustomSetBlockEdgeFilter() is called from CDRVPROC.CPP.
 *
 * Turns block edge filter on or off.
 *
 * Returns ICERR_OK if successfull, ICERR_BADPARAM otherwise 
 */
LRESULT CustomSetBlockEdgeFilter(LPDECINST pDeComp, DWORD dwValue)
{
	LRESULT lRet = ICERR_BADPARAM;

	if (dwValue == 1) {
		pDeComp->bUseBlockEdgeFilter = 1;
		lRet = ICERR_OK;
	}
	else if (dwValue == 0) {
		pDeComp->bUseBlockEdgeFilter = 0;
		lRet = ICERR_OK;
	}
	return(lRet);
}

/**************************************************************************
 *
 * About() implements the ICM_ABOUT message.
 *
 * Puts up an about box.
 *
 */
I32 
About(
	HWND hwnd)
{
    int inResult = 0;
    I32 iStatus = ICERR_OK;
#ifndef MF_SHELL
#ifndef RING0
    
    if (hwnd != ((HWND)-1))
    {
        inResult = DialogBox(hDriverModule, "AboutDlg", hwnd, (DLGPROC)AboutDialogProc);
		if (inResult == -1) 
		{
			iStatus = ICERR_ERROR;
			DBOUT("\n DialogBox returned -1");
		}
    }
#endif
#endif
    return iStatus;
} /* end About() */

#ifdef QUARTZ
 void QTZAbout(U32 uData)
 {
	 About((HWND) uData);
 }
#endif

/**************************************************************************
 *
 * DrvConfigure() is called from the DRV_CONFIGURE message.
 *
 * Puts up an about box.
 *
 * Always returns DRV_CANCEL as nothing has changed and no action is required. 
 */
I32 DrvConfigure(
	HWND hwnd)
{  
	I32 iStatus = DRV_CANCEL;
#ifndef MF_SHELL
#ifndef RING0
	int inResult;

    inResult = DialogBox(hDriverModule, "SetupDlg", hwnd, (DLGPROC)AboutDialogProc);
	if (inResult == -1) 
	{
		DBOUT("\n DialogBox returned -1");
	}
#endif
#endif

    return iStatus;
} /* end DrvConfigure() */

/************************************************************************
 *
 * SetResiliencyParams
 *
 * If ->bEncoderResiliency is TRUE, then set the configuration
 * parameters according to the expected packet loss.
 */
extern void SetResiliencyParams(T_CONFIGURATION * pConfiguration)
{
   if (pConfiguration->bEncoderResiliency)
   {
      if(pConfiguration->unPacketLoss > 30)
      {	pConfiguration->bDisallowPosVerMVs = 1;
        pConfiguration->bDisallowAllVerMVs = 1;
        pConfiguration->unPercentForcedUpdate = 100; // rather severe eh Jeeves ?
        pConfiguration->unDefaultIntraQuant = 8;
        pConfiguration->unDefaultInterQuant = 16;
      }
      else if(pConfiguration->unPacketLoss > 0 )
      {	 
		pConfiguration->bDisallowPosVerMVs = 0;
        pConfiguration->bDisallowAllVerMVs = 0;
        pConfiguration->unPercentForcedUpdate = pConfiguration->unPacketLoss;
        pConfiguration->unDefaultIntraQuant = 16;
        pConfiguration->unDefaultInterQuant = 16;
      }
	  else // no packet loss
	  {	pConfiguration->bDisallowPosVerMVs = 0;
        pConfiguration->bDisallowAllVerMVs = 0;
        pConfiguration->unPercentForcedUpdate = 0;
        pConfiguration->unDefaultIntraQuant = 16;
        pConfiguration->unDefaultInterQuant = 16;
      }
   }

   return;
}

/************************************************************************
 *
 * GetConfigurationDefaults
 *
 * Get the hard-coded configuration defaults
 */
void GetConfigurationDefaults(
	T_CONFIGURATION * pConfiguration)
{
   pConfiguration->bRTPHeader = 0;
   pConfiguration->unPacketSize = 512L;
   pConfiguration->bEncoderResiliency = 0;
   //Moji says to tune the encoder for 10% packet loss.
   pConfiguration->unPacketLoss = 10L;
   pConfiguration->bBitRateState = 0;
   pConfiguration->unBytesPerSecond = 1664L;
   SetResiliencyParams(pConfiguration);  // Determine config values from packet loss.
   pConfiguration->bInitialized = TRUE;

#ifdef H263P
   pConfiguration->bH263PlusState = 0;
   pConfiguration->bImprovedPBState = 0;
   pConfiguration->bDeblockingFilterState = 0;
#endif 

} /* end GetConfigurationDefaults() */

/**************************************************************************
 *
 *  AboutDialogProc
 *
 *  Display the about box.
 */
static BOOL AboutDialogProc(HWND hDlg, UINT message, UINT wParam, LONG lParam)
{
#ifndef MF_SHELL
#ifndef RING0
    switch(message) {
      case WM_INITDIALOG:
		return TRUE;
		break;

      case WM_CLOSE:
        PostMessage(hDlg, WM_COMMAND, IDOK, 0L);
        return TRUE;
		
      case WM_COMMAND:
		switch(wParam) {
		  case IDOK:
			EndDialog(hDlg, TRUE);
			return TRUE;
		}
		
    }
    return FALSE;
#else
   return TRUE;
#endif
#else
    return TRUE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\cdialogs.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 *
 * cdialog.h
 *
 * DESCRIPTION:
 *		Interface to the dialog functions.
 *
 */

// $Header:   S:\h26x\src\common\cdialogs.h_v   1.11   05 Feb 1997 12:14:20   JMCVEIGH  $
// $Log:   S:\h26x\src\common\cdialogs.h_v  $
;// 
;//    Rev 1.11   05 Feb 1997 12:14:20   JMCVEIGH
;// Support for improved PB-frames custom message handling.
;// 
;//    Rev 1.10   16 Dec 1996 17:36:24   JMCVEIGH
;// Added custom messages for H.263+ options.
;// 
;//    Rev 1.9   11 Dec 1996 14:54:42   JMCVEIGH
;// Prototypes for setting/getting in-the-loop deblocking filter and
;// true B-frame modes.
;// 
;//    Rev 1.8   13 Nov 1996 00:33:30   BECHOLS
;// Removed registry stuff.
;// 
;//    Rev 1.7   16 Oct 1996 15:09:28   SCDAY
;// Added support for RTP AM interface
;// 
;//    Rev 1.6   10 Sep 1996 16:13:02   KLILLEVO
;// added custom message in decoder to turn block edge filter on or off
;// 
;//    Rev 1.5   10 Jul 1996 08:26:38   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.4   22 May 1996 18:46:54   BECHOLS
;// 
;// Added CustomResetToFactoryDefaults.
;// 
;//    Rev 1.3   06 May 1996 00:41:20   BECHOLS
;// 
;// Added bit rate control stuff for the configure dialog.
;// 
;//    Rev 1.2   26 Apr 1996 11:08:58   BECHOLS
;// 
;// Added RTP stuff.
;// 
;//    Rev 1.1   17 Oct 1995 15:07:10   DBRUCKS
;// add about box files
;//
;// Added declarations to support Encoder Control messages.
;// Add Configure dialog
;// 

#ifndef __CDIALOG_H__
#define __CDIALOG_H__

#define DLG_DRIVERCONFIGURE         300

extern I32 About(HWND hwnd);
extern I32 DrvConfigure(HWND hwnd);

extern void GetConfigurationDefaults(T_CONFIGURATION * pConfiguration);

LRESULT CustomGetRTPHeaderState(LPCODINST, DWORD FAR *);
LRESULT CustomGetResiliencyState(LPCODINST, DWORD FAR *);
LRESULT CustomGetBitRateState(LPCODINST, DWORD FAR *);
LRESULT CustomGetPacketSize(LPCODINST, DWORD FAR *);
LRESULT CustomGetPacketLoss(LPCODINST, DWORD FAR *);
LRESULT CustomGetBitRate(LPCODINST, DWORD FAR *);

LRESULT CustomSetRTPHeaderState(LPCODINST, DWORD);
LRESULT CustomSetResiliencyState(LPCODINST, DWORD);
LRESULT CustomSetBitRateState(LPCODINST, DWORD);
LRESULT CustomSetPacketSize(LPCODINST, DWORD);
LRESULT CustomSetPacketLoss(LPCODINST, DWORD);
LRESULT CustomSetBitRate(LPCODINST, DWORD);

#ifdef H263P
LRESULT CustomGetH263PlusState(LPCODINST, DWORD FAR *);
LRESULT CustomGetDeblockingFilterState(LPCODINST, DWORD FAR *);

LRESULT CustomSetH263PlusState(LPCODINST, DWORD);
LRESULT CustomSetDeblockingFilterState(LPCODINST, DWORD);
#endif // H263P

extern LRESULT CustomResetToFactoryDefaults(LPCODINST);

extern LRESULT CustomSetBlockEdgeFilter(LPDECINST, DWORD);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\cdrvbase.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   KLILLEVO  $
// $Date:   31 Oct 1996 10:12:46  $
// $Archive:   S:\h26x\src\common\cdrvbase.cpv  $
// $Header:   S:\h26x\src\common\cdrvbase.cpv   1.25   31 Oct 1996 10:12:46   KLILLEVO  $
//	$Log:   S:\h26x\src\common\cdrvbase.cpv  $
// 
//    Rev 1.25   31 Oct 1996 10:12:46   KLILLEVO
// changed from DBOUT to DBgLog
// 
//    Rev 1.24   04 Oct 1996 16:11:54   JMCVEIGH
// In DrvOpen(), DecompPtr is now allocated if dwFlags indicate
// ICMODE_DECOMPRESS *and* ICMODE_COMPRESS. After installing the ClearVideo
// encoder, Adobe's Premiere would crash when compressing with the off-line.
// Crash was due to accessing an unallocated version of DecompPtr.
// Raj believes ClearVideo installed DCI. Possible penalty of this fix
// is that we might allocate a decoder instance that is never used.
// 
//    Rev 1.23   26 Sep 1996 14:46:48   MBODART
// Simplified version number definitions.
// Bumped H.261 major version number to 4, reset build number to 001.
// 
//    Rev 1.22   12 Sep 1996 13:54:06   KLILLEVO
// changed to Win32 memory allocation
// 
//    Rev 1.21   03 Sep 1996 16:17:58   PLUSARDI
// updated for version 2.50 of 263 net 
// 
//    Rev 1.20   23 Aug 1996 13:44:56   SCDAY
// added version numbers for Quartz using #ifdef QUARTZ
// 
//    Rev 1.19   22 Aug 1996 10:17:14   PLUSARDI
// updated for quartz version 3.05 for h261
// 
//    Rev 1.18   16 Aug 1996 11:31:28   CPERGIEX
// updated not non-quartz build
// 
//    Rev 1.17   30 Jul 1996 12:57:22   PLUSARDI
// updated for RTP version string
// 
//    Rev 1.16   11 Jul 1996 07:54:18   PLUSARDI
// change the version number for h261 v3.05.003
// 
//    Rev 1.15   12 Jun 1996 09:47:22   KLILLEVO
// updated version number
// 
//    Rev 1.14   28 Apr 1996 20:25:36   BECHOLS
// 
// Merged the RTP code into the Main Base.
// 
//    Rev 1.13   21 Feb 1996 11:40:58   SCDAY
// cleaned up compiler build warnings by putting ifdefs around definition of b
// 
//    Rev 1.12   02 Feb 1996 18:52:22   TRGARDOS
// Added code to enable ICM_COMPRESS_FRAMES_INFO message.
// 
//    Rev 1.11   27 Dec 1995 14:11:36   RMCKENZX
// 
// Added copyright notice
// 
//    Rev 1.10   13 Dec 1995 13:21:52   DBRUCKS
// changed the h261 version string defintions to use V3.00
// 
//    Rev 1.9   01 Dec 1995 15:16:34   DBRUCKS
// added VIDCF_QUALITY to support the quality slider.
// 
//    Rev 1.8   15 Nov 1995 15:58:56   AKASAI
// Remove YVU9 from get info and return error "0" when unsupported.
// (Integration point)
// 
//    Rev 1.7   09 Oct 1995 11:46:56   TRGARDOS
// 
// Set VIDCF_CRUNCH flag to support bit rate control.
// 
//    Rev 1.6   20 Sep 1995 12:37:38   DBRUCKS
// save the fcc in uppercase
// 
//    Rev 1.5   19 Sep 1995 15:41:00   TRGARDOS
// Fixed four cc comparison code.
// 
//    Rev 1.4   19 Sep 1995 13:19:50   TRGARDOS
// Changed drv_open to check ICOPEN flags.
// 
//    Rev 1.3   12 Sep 1995 15:45:38   DBRUCKS
// add H261 ifdef to desc and name
// 
//    Rev 1.2   25 Aug 1995 11:53:00   TRGARDOS
// Debugging key frame encoder.
// 
//    Rev 1.1   23 Aug 1995 12:27:16   DBRUCKS
// 
// turn on color converter init
// 
//    Rev 1.0   31 Jul 1995 12:56:10   DBRUCKS
// rename files
// 
//    Rev 1.1   21 Jul 1995 18:20:36   DBRUCKS
// IsBadReadPtr fails with a NULL - protect against
// 
//    Rev 1.0   17 Jul 1995 14:43:58   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:28   CZHU
// Initial revision.
;////////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#ifdef H261
	#ifdef QUARTZ
		char    szDescription[] = "Microsoft H.261 Video Codec";
		char    szDesc_i420[] = "Intel 4:2:0 Video V3.05";
		char    szName[]        = "MS H.261";
	#else
		char    szDescription[] = "Microsoft H.261 Video Codec";
		char    szDesc_i420[] = "Intel 4:2:0 Video V3.00";
		char    szName[]        = "MS H.261";
	#endif
#else // is H263
	#ifdef QUARTZ
                char    szDescription[] = "Microsoft H.263 Video Codec";
                char    szDesc_i420[] = "Intel 4:2:0 Video V2.55";
                char    szName[]        = "MS H.263";
	#else
                char    szDescription[] = "Microsoft H.263 Video Codec";
                char    szDesc_i420[] = "Intel 4:2:0 Video V2.50";
                char    szName[]        = "MS H.263";
	#endif
#endif

static U32 MakeFccUpperCase(U32 fcc);

void MakeCode32(U16 selCode16)
{
    BYTE    desc[8];

#define DSC_DEFAULT     0x40
#define dsc_access      6

    GlobalReAlloc((HGLOBAL)selCode16, 0, GMEM_MODIFY|GMEM_MOVEABLE);

    _asm
    {
        mov     bx, selCode16       ; bx = selector

        lea     di, word ptr desc   ; ES:DI --> desciptor
        mov     ax,ss
        mov     es,ax

        mov     ax, 000Bh           ; DPMI get descriptor
        int     31h

        ; set DEFAULT bit to make it a 32-bit code segment
        or      desc.dsc_access,DSC_DEFAULT

        mov     ax,000Ch            ; DPMI set descriptor
        int     31h
    }
}

/******************************************************
 * DrvLoad()
 ******************************************************/
BOOL PASCAL DrvLoad(void)
{
    static int AlreadyInitialised = 0;

    if (!AlreadyInitialised) {
      AlreadyInitialised = 1;

//      H263InitDecoderGlobal();
      H263InitColorConvertorGlobal ();
      H263InitEncoderGlobal();

    }
    return TRUE;
}

;////////////////////////////////////////////////////////////////////////////
;// Function:       void PASCAL DrvFree(void);
;//
;// Description:    Added header.
;//
;// History:        02/23/94 -BEN-
;////////////////////////////////////////////////////////////////////////////
void PASCAL DrvFree(void)
{
    return;
}

/**********************************************************
 * DrvOpen()
 * Arguments:
 * 	Pointer to ICOPEN data structure passed by
 *	the system.
 * Returns:
 *  If successful, returns a pointer to our INSTINFO data structure. That
 *  will be passed back to us in the dwDriverID parameter on subsequent
 *  system calls.
 *  If unsuccessful, it returns NULL.
 **********************************************************/
LPINST PASCAL DrvOpen(ICOPEN FAR * icinfo)
{
    INSTINFO  *lpInst;
#ifdef _DEBUG
	char buf80[80];
#endif

    // Allocate memory for our instance information structure, INSTINFO.
    if((lpInst = (INSTINFO *) HeapAlloc(GetProcessHeap(), 0, sizeof(INSTINFO))) == NULL){
      DBOUT("DrvOpen: Unable to ALLOC INSTINFO")
      return NULL;
    }

    /*
	 * Store the four cc so we know which codec is open.
	 * TODO: handle both lower case and upper case fourcc's.
	 */
    lpInst->fccHandler = MakeFccUpperCase(icinfo->fccHandler);
#ifdef _DEBUG
	wsprintf(buf80,"fccHandler=0x%lx",lpInst->fccHandler);
	DBOUT(buf80);
#endif

    lpInst->CompPtr = NULL;
	lpInst->DecompPtr = NULL;

	// Check if being opened for decompression.
    if ( ((icinfo->dwFlags & ICMODE_DECOMPRESS) == ICMODE_DECOMPRESS) ||
		((icinfo->dwFlags & ICMODE_FASTDECOMPRESS) == ICMODE_FASTDECOMPRESS) ){

	  	// Allocate memory for our decompressor specific instance data, DECINSTINFO.
      	if((lpInst->DecompPtr = (DECINSTINFO *) 
				HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(DECINSTINFO))) == NULL){
        	DBOUT("DrvOpen: Unable to ALLOC DECINSTINFO")
        	HeapFree(GetProcessHeap(),0,lpInst);
        	return NULL;
      	}

	  	// Set flag indicating decoder instance is unitialized.
      	lpInst->DecompPtr->Initialized = FALSE;
	} 


	// Check if being opened for compression as H.263.
    if( (((icinfo->dwFlags & ICMODE_COMPRESS) == ICMODE_COMPRESS) ||
		((icinfo->dwFlags & ICMODE_FASTCOMPRESS) == ICMODE_FASTCOMPRESS)) &&
        (lpInst->fccHandler == FOURCC_H263) )
        {

		// Allocate memory for our compressor specific instance data, COMPINSTINFO.
      	if((lpInst->CompPtr = (COMPINSTINFO*) 
				HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(COMPINSTINFO))) == NULL){
        	DBOUT("DrvOpen: Unable to ALLOC COMPINSTINFO")
			if (lpInst->DecompPtr != NULL)
        		HeapFree(GetProcessHeap(),0,lpInst->DecompPtr);
        	HeapFree(GetProcessHeap(),0,lpInst);
        	return NULL;
      	}

	  	// Set flag indicating encoder instance is uninitialized.
      	lpInst->CompPtr->Initialized = FALSE;
		lpInst->CompPtr->FrameRate = (float) 0;
		lpInst->CompPtr->DataRate = 0;
#if 0
	  	// Allocate memory for our decompressor specific instance data, DECINSTINFO.
		// Previously we didn't force this - assumed application specified 
		// decompressor needed to be allocated in dwFlags.
		// After installing ClearVideo encoder, Adobe Premiere crashed using off-line without this code.
		// Put same work around here (DECINSTINFO is fairly small)
		// Might be due to installation of DCI? JM
		if (lpInst->DecompPtr == NULL) {
      		if((lpInst->DecompPtr = (DECINSTINFO *) 
					HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(DECINSTINFO))) == NULL){
        		DBOUT("DrvOpen: Unable to ALLOC DECINSTINFO")
       			HeapFree(GetProcessHeap(),0,lpInst);
       			return NULL;
    		}

	  		// Set flag indicating decoder instance is unitialized.
      		lpInst->DecompPtr->Initialized = FALSE;
		} 
#endif
	}

	// Assign instance info flag with ICOPEN flag.
    lpInst->dwFlags = icinfo->dwFlags;

	// Disable codec by default. The client will send us a private message
	// to enable it.
	lpInst->enabled = FALSE;

    return lpInst;
}

DWORD PASCAL DrvClose(LPINST lpInst)
{
    
    if(IsBadReadPtr((LPVOID)lpInst, sizeof(INSTINFO))){
      DBOUT("DrvClose: instance NULL")
      return 1;
    }

    if(lpInst->DecompPtr &&   // IsBadReadPtr errors on NT with NULL
       !IsBadReadPtr((LPVOID)lpInst->DecompPtr, sizeof(DECINSTINFO))){
      if(lpInst->DecompPtr->Initialized){
	    H263TermDecoderInstance(lpInst->DecompPtr);
      }
      HeapFree(GetProcessHeap(),0,lpInst->DecompPtr);
      lpInst->DecompPtr = NULL;
    }

    if(lpInst->CompPtr &&    // IsBadReadPtr errors on NT with NULL
       !IsBadReadPtr((LPVOID)lpInst->CompPtr, sizeof(COMPINSTINFO))){
      if(lpInst->CompPtr->Initialized){
	    H263TermEncoderInstance(lpInst->CompPtr);
      }
      HeapFree(GetProcessHeap(),0,lpInst->CompPtr);
      lpInst->CompPtr = NULL;
    }

    HeapFree(GetProcessHeap(),0,lpInst);
    
    return 1;
}


DWORD PASCAL DrvGetState(LPINST lpInst, LPVOID pv, DWORD dwSize)
{
    // Return current state of compression options
    if (pv == NULL) return (sizeof(COMPINSTINFO));
    
    // check that incoming buffer is big enough
    if (dwSize < sizeof(COMPINSTINFO)) return 0;

	// Check instance pointer
	if (lpInst && lpInst->CompPtr)
	{
		// fill the incoming buffer
		_fmemcpy(pv, lpInst->CompPtr, (int)sizeof(COMPINSTINFO));
		return sizeof(COMPINSTINFO);
	}
	else
		return 0;
}

DWORD PASCAL DrvSetState(LPINST lpInst, LPVOID pv, DWORD dwSize) 
{
    // check that there is enough incoming data
    if (dwSize < sizeof(COMPINSTINFO)) return 0;

	// Check instance pointer
	if (lpInst && lpInst->CompPtr && pv)
	{
		// get data out of incoming buffer
		_fmemcpy(lpInst->CompPtr, pv, (int)sizeof(COMPINSTINFO));
		return sizeof(COMPINSTINFO);
	}
	else
		return 0;
}

DWORD PASCAL DrvGetInfo(LPINST lpInst, ICINFO FAR *icinfo, DWORD dwSize)
{
    if (icinfo == NULL)
        return sizeof(ICINFO);

    if (dwSize < sizeof(ICINFO))
        return 0;

    if (!lpInst)
        return 0;

    icinfo->dwSize	= sizeof(ICINFO);
    icinfo->fccType	= ICTYPE_VIDEO;
    icinfo->fccHandler	= lpInst->fccHandler;
    icinfo->dwVersion	= 9002;
	MultiByteToWideChar(CP_ACP,0,szName,-1,icinfo->szName,128);
		
    if(lpInst->fccHandler == FOURCC_H263)
	{
    	icinfo->dwFlags	=  VIDCF_TEMPORAL;		// We support inter frame compression.
    	icinfo->dwFlags |= VIDCF_FASTTEMPORALC; // We do not need ICM to provide previous frames on compress
    	icinfo->dwFlags |= VIDCF_CRUNCH; 		// We support bit rate control
		icinfo->dwFlags |= VIDCF_QUALITY; 		// We support Quality
		MultiByteToWideChar(CP_ACP,0,szDescription,-1,icinfo->szDescription,128);
	}
    else if ((lpInst->fccHandler == FOURCC_YUV12) || (lpInst->fccHandler == FOURCC_IYUV))
	{
    	icinfo->dwFlags	=  0;
		MultiByteToWideChar(CP_ACP,0,szDesc_i420,-1,icinfo->szDescription,128);
	}
	else
	{
		DBOUT("Error: unsupported four cc.")
		return(0);
	}

    return sizeof(ICINFO);
}


/**************************************************************************
 *
 * MakeFccUpperCase().
 *
 * Convert the passed parameter to upper case. No change to chars not in
 * the set [a..z].
 *
 * returns input parameter in all upper case
 */
static U32
MakeFccUpperCase(
	U32 fcc)
{
U32 ret;
	unsigned char c;

	c = (unsigned char)(fcc & 0xFF); fcc >>= 8;
	ret = toupper(c);

	c = (unsigned char)(fcc & 0xFF); fcc >>= 8;
	ret += toupper(c) << 8;

	c = (unsigned char)(fcc & 0xFF); fcc >>= 8;
	ret += ((U32)toupper(c)) << 16;

	c = (unsigned char)(fcc & 0xFF);
	ret += ((U32)toupper(c)) << 24;
	return ret;
} /* end MakeFccUpperCase() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\cdrvcom.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
////////////////////////////////////////////////////////////////////////////
//
// $Author:   JMCVEIGH  $
// $Date:   05 Feb 1997 12:14:22  $
// $Archive:   S:\h26x\src\common\cdrvcom.h_v  $
// $Header:   S:\h26x\src\common\cdrvcom.h_v   1.21   05 Feb 1997 12:14:22   JMCVEIGH  $
// $Log:   S:\h26x\src\common\cdrvcom.h_v  $
;// 
;//    Rev 1.21   05 Feb 1997 12:14:22   JMCVEIGH
;// Support for improved PB-frames custom message handling.
;// 
;//    Rev 1.20   19 Dec 1996 16:44:08   MDUDA
;// Added custom messages to get machine type information.
;// 
;//    Rev 1.19   16 Dec 1996 17:36:46   JMCVEIGH
;// H.263+ custom message definitions.
;// 
;//    Rev 1.18   11 Dec 1996 14:56:08   JMCVEIGH
;// 
;// Added H.263+ field lengths for EPTYPE and custom message definitions.
;// 
;//    Rev 1.17   09 Dec 1996 17:42:46   JMCVEIGH
;// Added support for arbitrary frame size support.
;// 
;//    Rev 1.16   09 Dec 1996 09:25:22   MDUDA
;// 
;// Modified _CODEC_STATS stuff.
;// 
;//    Rev 1.15   11 Oct 1996 16:01:46   MDUDA
;// 
;// Added initial _CODEC_STATS stuff.
;// 
;//    Rev 1.14   10 Sep 1996 16:13:04   KLILLEVO
;// added custom message in decoder to turn block edge filter on or off
;// 
;//    Rev 1.13   22 Jul 1996 14:44:36   BECHOLS
;// fixed last comment.
;// 
;//    Rev 1.12   22 Jul 1996 14:36:20   BECHOLS
;// Wrapped the comment section with /* ... */ /* so that Steve Ing won't
;// be hassled with changing this.
;// 
;//    Rev 1.11   22 May 1996 18:48:08   BECHOLS
;// 
;// Added APPLICATION_IDENTIFICATION_CODE.
;// 
;//    Rev 1.10   06 May 1996 00:41:50   BECHOLS
;// 
;// Added the necessary message constants to allow the app to control
;// the bit rate dialog stuff.
;// 
;//    Rev 1.9   26 Apr 1996 11:10:44   BECHOLS
;// 
;// Added RTP stuff.
;// 
;//    Rev 1.8   27 Dec 1995 14:11:54   RMCKENZX
;// Added copyright notice
;// 
;// Added CODEC_CUSTOM_ENCODER_CONTROL.
;// Integrate with build 29
//
////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------
// ?_CUSTOM_VIDEO_EFFECTS:
//    This header defines the flags passed to lParam1 to determine what
//    function the driver (capture/codec) performs.  The actual message
//    is defined in a custom header provided by each driver team.
//
//    Parameters:
//    hdrvr   - Installable driver handle (must be the video in device 
//              channel for capture driver)
//    lParam1 - function selector
//    lParam2 - value/address to return value
//
//    HIWORD(lParam1) = VE_SET_CURRENT:
//        LOWORD(lParam1) = VE_CONTRAST, VE_HUE, VE_SATURATION, VE_BRIGHTNESS
//        lParam2 = value of corresponding value..
//
//    HIWORD(lParam1) = VE_GET_FACTORY_DEFAULT:
//        LOWORD(lParam1) = VE_CONTRAST, VE_HUE, VE_SATURATION, VE_BRIGHTNESS
//        lParam2 = (WORD FAR *)Address of the return value.
//
//    HIWORD(lParam1) = VE_GET_FACTORY_LIMITS:
//        LOWORD(lParam1) = VE_CONTRAST, VE_HUE, VE_SATURATION, VE_BRIGHTNESS
//        lParam2 = (DWORD FAR *)Address of the return value.
//            LOWORD(*lParam2) = lower limit
//            HIWORD(*lParam2) = upper limit
//
//    HIWORD(lParam1) = VE_SET_INPUT_CONNECTOR:
//        LOWORD(lParam1) = VE_INPUT_COMPOSITE_1, VE_INPUT_SVIDEO_1
//        lParam2 = 0 
// --------------------------------------------------------------------- 
*/

// CUSTOM_VIDEO_EFFECTS: LOWORD(lParam1)
#define VE_CONTRAST                 0
#define VE_HUE                      1
#define VE_SATURATION               2
#define VE_BRIGHTNESS               3

// CUSTOM_VIDEO_EFFECTS: HIWORD(lParam1)
#define VE_SET_CURRENT              0
#define VE_GET_FACTORY_DEFAULT      1
#define VE_GET_FACTORY_LIMITS       2
#define VE_SET_INPUT_CONNECTOR      3
#define VE_RESET_CURRENT            4

// CUSTOM_SET_INPUT_CONNECTOR: LOWORD(lParam1)
#define VE_INPUT_COMPOSITE_1        0
#define VE_INPUT_SVIDEO_1           1

////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------
// ?_CUSTOM_ENCODER_CONTROL:
//    This header defines the flags passed to lParam1 to determine what
//    function the driver (capture/codec) performs.  The actual message
//    is defined in a custom header provided by each driver team.
//
//    Parameters:
//    hdrvr   - Installable driver handle (must be the video in device 
//              channel for capture driver)
//    lParam1 - function selector
//    lParam2 - value/address to return value
//
//    HIWORD(lParam1) = EC_GET_FACTORY_DEFAULT:
//        LOWORD(lParam1) = EC_RTP_HEADER, EC_RESILIENCY, EC_BITRATE_CONTROL, EC_PACKET_SIZE, EC_PACKET_LOSS, EC_BITRATE
//        lParam2 = (DWORD FAR *)Address of the return value.
//
//    HIWORD(lParam1) = VE_GET_FACTORY_LIMITS:
//        LOWORD(lParam1) = EC_PACKET_SIZE, EC_PACKET_LOSS, EC_BITRATE
//        lParam2 = (DWORD FAR *)Address of the return value.
//            LOWORD(*lParam2) = lower limit
//            HIWORD(*lParam2) = upper limit
//
//    HIWORD(lParam1) = EC_GET_CURRENT:
//        LOWORD(lParam1) = EC_RTP_HEADER, EC_RESILIENCY, EC_BITRATE_CONTROL, EC_PACKET_SIZE, EC_PACKET_LOSS, EC_BITRATE
//        lParam2 = (DWORD FAR *)Address of the return value.
//
//    HIWORD(lParam1) = EC_SET_CURRENT:
//        LOWORD(lParam1) = EC_RTP_HEADER, EC_RESILIENCY, EC_BITRATE_CONTROL, EC_PACKET_SIZE, EC_PACKET_LOSS, EC_BITRATE
//        lParam2 = value of corresponding value..
// --------------------------------------------------------------------- 

// CUSTOM_ENCODER_CONTROL: LOWORD(lParam1)
#define EC_RTP_HEADER                0
#define EC_RESILIENCY                1
#define EC_PACKET_SIZE               2
#define EC_PACKET_LOSS               3
#define EC_BITRATE_CONTROL			 4
#define EC_BITRATE					 5

#ifdef H263P
// H.263+ options
#define EC_H263_PLUS				1000	// Must be sent before any option messages sent

// Numbering convention:
//	1xxx: H.263+ option
//  xBBx: Bit number of option in extended PTYPE field
// Numbers are spaced by 10 to allow for additional parameters related to each option
//#define EC_ADVANCED_INTRA			1040
#define EC_DEBLOCKING_FILTER		1050
//#define EC_SLICE_STRUCTURED		1060
//#define EC_CUSTOM_PCF				1070
//#define EC_BACK_CHANNEL			1080
//#define EC_SCALABILITY			1090	
//#define EC_TRUE_BFRAMES			1100
//#define EC_REF_RESAMPLING			1110
//#define EC_RES_UPDATE				1120
#define EC_IMPROVED_PB_FRAMES		1130

// Test support, stats monitoring, etc. messages are isolated here.
#define EC_MACHINE_TYPE				2000

// The use of the improved PB-frame mode is currently not signaled in the picture header.
// We assume that if EPTYPE is present and the frame was signaled as a PB-frame
// in PTYPE, then the improved PB-frame mode is used.

// end H.263+ options
#endif // H263P

// CUSTOM_ENCODER_CONTROL: HIWORD(lParam1)
#define EC_SET_CURRENT               0
#define EC_GET_FACTORY_DEFAULT       1
#define EC_GET_FACTORY_LIMITS        2
#define EC_GET_CURRENT               3
#define EC_RESET_TO_FACTORY_DEFAULTS 4

////////////////////////////////////////////////////////////////////////////
// ---------------------------------------------------------------------
// ?_CUSTOM_DECODER_CONTROL:
//    This header defines the flags passed to lParam1 to determine what
//    function the driver (capture/codec) performs.  The actual message
//    is defined in a custom header provided by each driver team.
//
//    Parameters:
//    hdrvr   - Installable driver handle (must be the video in device 
//              channel for capture driver)
//    lParam1 - function selector
//    lParam2 - value/address to return value
//
//    HIWORD(lParam1) = DC_SET_CURRENT:
//        LOWORD(lParam1) = DC_BLOCK_EDGE_FILTER;
//        lParam2 = 0:off, 1:on

// CUSTOM_DECODER_CONTROL: LOWORD(lParam1)
#define DC_BLOCK_EDGE_FILTER         0
#if defined(H263P)
// Test support, stats monitoring, etc. messages are isolated here.
#define DC_MACHINE_TYPE           2000
#endif

// CUSTOM_DECODER_CONTROL: HIWORD(lParam1)
#define DC_SET_CURRENT               0
#if defined(H263P)
// This was added simply to provide a consistent way to access
// machine type (see DC_MACHINE_TYPE).
#define DC_GET_CURRENT               1
#endif


/*
 * Bit stream field sizes
 */
#ifdef H261
const unsigned int FIELDLEN_PSC = 20;
const unsigned int FIELDLEN_TR = 5;		// temporal reference

const unsigned int FIELDLEN_PTYPE = 6;	// picture type
const unsigned int FIELDLEN_PTYPE_SPLIT = 1;
const unsigned int FIELDLEN_PTYPE_DOC = 1;
const unsigned int FIELDLEN_PTYPE_RELEASE = 1;
const unsigned int FIELDLEN_PTYPE_SRCFORMAT = 1;
const unsigned int FIELDLEN_PTYPE_STILL = 1;
const unsigned int FIELDLEN_PTYPE_SPARE = 1;
const unsigned int FIELDLEN_PEI = 1;	// extra insertion information.
const unsigned int FIELDLEN_PSPARE = 8;	// spare information

const unsigned int FIELDLEN_GBSC = 16;
const unsigned int FIELDLEN_GN = 4;
const unsigned int FIELDLEN_GQUANT = 5;
const unsigned int FIELDLEN_GEI = 1;

const unsigned int FIELDLEN_MQUANT = 5;
const unsigned int FIELDLEN_MBA_STUFFING = 11;

#else
const unsigned int FIELDLEN_PSC = 22;
const unsigned int FIELDLEN_TR = 8;		// temporal reference

const unsigned int FIELDLEN_PTYPE = 13;	// picture type
const unsigned int FIELDLEN_PTYPE_CONST = 2;
const unsigned int FIELDLEN_PTYPE_SPLIT = 1;
const unsigned int FIELDLEN_PTYPE_DOC = 1;
const unsigned int FIELDLEN_PTYPE_RELEASE = 1;
const unsigned int FIELDLEN_PTYPE_SRCFORMAT = 3;
const unsigned int FIELDLEN_PTYPE_CODINGTYPE = 1;
const unsigned int FIELDLEN_PTYPE_UMV = 1;
const unsigned int FIELDLEN_PTYPE_SAC = 1;
const unsigned int FIELDLEN_PTYPE_AP = 1;
const unsigned int FIELDLEN_PTYPE_PB = 1;

#ifdef H263P

const unsigned int FIELDLEN_EPTYPE_SRCFORMAT = 3;
const unsigned int FIELDLEN_EPTYPE_CPCF = 1;
const unsigned int FIELDLEN_EPTYPE_AI = 1;
const unsigned int FIELDLEN_EPTYPE_DF = 1;
const unsigned int FIELDLEN_EPTYPE_SS = 1;
const unsigned int FIELDLEN_EPTYPE_IPB = 1;
const unsigned int FIELDLEN_EPTYPE_BCO = 1;
const unsigned int FIELDLEN_EPTYPE_SCALE = 1;
const unsigned int FIELDLEN_EPTYPE_TB = 1;
const unsigned int FIELDLEN_EPTYPE_RPR = 1;
const unsigned int FIELDLEN_EPTYPE_RRU = 1;
const unsigned int FIELDLEN_EPTYPE_CONST = 5;

const unsigned int FIELDLEN_CSFMT_PARC = 4;
const unsigned int FIELDLEN_CSFMT_FWI = 9;
const unsigned int FIELDLEN_CSFMT_CONST = 1;
const unsigned int FIELDLEN_CSFMT_FHI = 9;

const unsigned int FIELDLEN_EPAR_WIDTH = 8;
const unsigned int FIELDLEN_EPAR_HEIGHT = 8;

#endif

const unsigned int FIELDLEN_PQUANT = 5;	// picture quant value
const unsigned int FIELDLEN_CPM = 1;	// continuous presence multipoint indicator
const unsigned int FIELDLEN_PLCI = 2;	// picture logical channel indicator.
const unsigned int FIELDLEN_TRB = 3;	// temporal reference for B frames
const unsigned int FIELDLEN_DBQUANT = 2;// B frame differential quant value
const unsigned int FIELDLEN_PEI = 1;	// extra insertion information.
const unsigned int FIELDLEN_PSPARE = 8;	// spare information

const unsigned int FIELDLEN_GBSC = 17;	// Group of blocks start code
const unsigned int FIELDLEN_GN = 5;		// GOB number.
const unsigned int FIELDLEN_GLCI = 2;	// GOB logical channel indicator
const unsigned int FIELDLEN_GFID = 2;	// GOB Frame ID
const unsigned int FIELDLEN_GQUANT = 5;	// GQUANT
#endif

/*
 * Bit stream field values
 */
#ifdef H261
const unsigned int FIELDVAL_PSC  = 0x00010;
const unsigned int FIELDVAL_GBSC = 0x0001;
const unsigned int FIELDVAL_MBA_STUFFING = 0x00F;
#else
const unsigned int FIELDVAL_PSC = 0x000020;
const unsigned int FIELDVAL_GBSC = 1;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\cldebug.cpp ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

/*****************************************************************************
 * 
 *  cldebug.cpp
 *
 *  Description:
 *		This modules contains the debug support routines
 *
 *	Routines:
 *		AssertFailed
 *		
 *  Data:
 */

/* $Header:   S:\h26x\src\common\cldebug.cpv   1.3   31 Oct 1996 10:12:50   KLILLEVO  $
 * $Log:   S:\h26x\src\common\cldebug.cpv  $
// 
//    Rev 1.3   31 Oct 1996 10:12:50   KLILLEVO
// changed from DBOUT to DBgLog
// 
//    Rev 1.2   27 Dec 1995 14:11:42   RMCKENZX
// 
// Added copyright notice
 */

#include "precomp.h"

#ifdef _DEBUG

UINT DebugH26x = 0;

/*****************************************************************************
 *
 *  AssertFailed
 *
 *  Print out a message indicating that the assertion failed.  If in Ring3
 *  give the user the option of aborting.  Otherwise just output the message.
 */
extern void 
AssertFailed(
	void FAR * fpFileName, 
	int iLine, 
	void FAR * fpExp)
{
#ifndef RING0
	char szBuf[500];
	int n;

	wsprintf(szBuf,"Assertion (%s) failed in file '%s' at line %d - Abort?",
	    	 fpExp, fpFileName, iLine);
	DBOUT(szBuf);
	n = MessageBox(GetFocus(), szBuf, "Assertion Failure", 
				   MB_ICONSTOP | MB_YESNO | MB_SETFOREGROUND);
	if (n == IDYES) 
		abort();
#else
	SYS_printf("Assertion (%s) failed in file '%s' at line %d",
	    	   fpExp, fpFileName, iLine);
   _asm int 3;
#endif
} /* end AssertFailed() */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\cresourc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Cq_h26x.rc
//
#define IDS_YVU9_DESC                   1
#define IDS_YVU9_NAME                   2
#define IDS_DRV_NAME                    5
#define IDS_INCOMPAT                    6
#define IDS_ERR_PACKET_SIZE             7
#define IDS_ERR_PACKET_LOSS             8
#define IDS_ERR_BITRATE                 9
#define IDS_ERR_TITLE                   11
#define IDS_ERR_NON_NUMERIC             12
#define IDS_QTZ_ERR_BRIGHTNESS_TITLE    13
#define IDS_QTZ_ERR_SATURATION_TITLE    14
#define IDS_QTZ_ERR_CONTRAST_TITLE      15
#define IDS_QTZ_ERR_BRIGHTNESS_MESSAGE  16
#define IDS_QTZ_ERR_SATURATION_MESSAGE  17
#define IDS_QTZ_ERR_CONTRAST_MESSAGE    18
#define IDS_QTZ_ERR_NON_NUMERIC_TITLE   19
#define IDS_QTZ_ERR_NON_NUMERIC_MESSAGE 20
#define IDS_QTZ_VIDEO_EFFECTS           21
#define IDS_QTZ_DIALOG_COMPRESS_NAME    22
#define IDS_QTZ_ERR_FRAMERATE_TITLE     23
#define IDS_QTZ_ERR_DATARATE_TITLE      24
#define IDS_QTZ_ERR_QUALITY_TITLE       25
#define IDS_QTZ_ERR_KEY_FRAME_INTERVAL_TITLE 26
#define IDS_QTZ_ERR_TARGET_FRAME_SIZE_TITLE 27
#define IDS_QTZ_ERR_FRAMERATE_MESSAGE   28
#define IDS_QTZ_ERR_DATARATE_MESSAGE    29
#define IDS_QTZ_ERR_QUALITY_MESSAGE     30
#define IDS_QTZ_ERR_KEY_FRAME_INTERVAL_MESSAGE 31
#define IDS_QTZ_ERR_TARGET_FRAME_SIZE_FCIF_MESSAGE 32
#define IDS_QTZ_ERR_TARGET_FRAME_SIZE_QCIF_MESSAGE 33
#define IDS_QTZ_RTP_COMPRESS_NAME       34
#define IDS_QTZ_ERR_PACKET_SIZE_TITLE   35
#define IDS_QTZ_ERR_PACKET_SIZE_MESSAGE 36
#define IDS_QTZ_ERR_PACKET_LOSS_TITLE   37
#define IDS_QTZ_ERR_PACKET_LOSS_MESSAGE 38
#define IDS_QTZ_ENCODE_OPTIONS          39
#define IDS_QTZ_ERR_ENCODE_OPTIONS_TITLE 40
#define IDS_QTZ_ERR_EXTENDEDMV          41
#define IDS_QTZ_ERR_EXTENDEDMV_MESSAGE  42
#define IDS_QTZ_ERR_PBFRAMES            43
#define IDS_QTZ_ERR_PBFRAMES_MESSAGE    44
#define IDS_QTZ_ERR_ADVPREDICTION       45
#define IDS_QTZ_ERR_ADVPREDICTION_MESSAGE 46
#define IDD_DIALOG1                     101
#define IDD_QTZ_VIDEO_EFFECTS           102
#define IDD_QTZ_DIALOG_COMPRESS         103
#define IDD_QTZ_RTP_COMPRESS            104
#define IDD_QTZ_ENCODE_OPTIONS          105
#define IDC_PACKET_SIZE                 1006
#define IDC_PACKET_SIZE_TEXT            1007
#define IDC_RTP_HEADER                  1008
#define IDC_ENCODER_RESILIENCY          1009
#define IDC_PACKET_LOSS                 1010
#define IDC_PACKET_LOSS_TEXT            1011
#define IDD_ABOUT                       1012
#define IDABOUT                         1013
#define IDDEFAULT                       1014
#define IDC_RESILIENCY_OPTIONS          1015
#define IDC_RTP_OPTIONS                 1016
#define IDC_ENCODER_BITRATE_CONTROL     1017
#define IDC_BITRATE_CONTROL             1018
#define IDC_BITRATE_CONTROL_TEXT        1019
#define IDC_QTZ_RESET                   1020
#define IDC_QTZ_LOAD_DEFAULT            1021
#define IDC_QTZ_ABOUT                   1022
#define IDC_QTZ_VE_BRIGHTNESS           1023
#define IDC_QTZ_VE_SATURATION           1024
#define IDC_QTZ_VE_CONTRAST             1025
#define IDC_QTZ_VE_MIRROR				1026
#define IDC_QTZ_SATURATION_TEXT         1029
#define IDC_QTZ_CONTRAST_TEXT           1030
#define IDC_QTZ_TEXT                    1031
#define IDC_QTZ_BRIGHTNESS_TEXT         1032
#define IDC_CMP_KEYFRAME_RATE_TEXT      1033
#define IDC_CMP_KEYFRAME_RATE           1034
#define IDC_CMP_DATA_RATE_TEXT          1035
#define IDC_CMP_DATA_RATE               1036
#define IDC_CMP_FRAME_RATE_TEXT         1037
#define IDC_CMP_FRAME_RATE              1038
#define IDC_CMP_QUALITY_TEXT            1039
#define IDC_CMP_QUALITY                 1040
#define IDC_CMP_GENERATE_KEY            1041
#define IDC_CMP_TARGET_TEXT             1042
#define IDC_CMP_TARGET_FRAME_SIZE       1043
#define IDC_CMP_FSIZE_BRC               1044
#define IDC_CMP_FRATE_BRC               1045
#define IDC_QTZ_RTP_HEADER              1046
#define IDC_QTZ_PACKET_SIZE             1047
#define IDC_QTZ_PACKET_SIZE_TEXT        1048
#define IDC_QTZ_PACKET_LOSS             1049
#define IDC_QTZ_PACKET_LOSS_TEXT        1050
#define IDC_QTZ_EXTENDEDMV              1051
#define IDC_QTZ_PBFRAMES                1052
#define IDC_QTZ_ADVPREDICTION			1053
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1054
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\cldebug.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

// $Author:   KLILLEVO  $
// $Date:   31 Oct 1996 10:21:06  $
// $Archive:   S:\h26x\src\common\cldebug.h_v  $
// $Header:   S:\h26x\src\common\cldebug.h_v   1.10   31 Oct 1996 10:21:06   KLILLEVO  $
// $Log:   S:\h26x\src\common\cldebug.h_v  $
;// 
;//    Rev 1.10   31 Oct 1996 10:21:06   KLILLEVO
;// removed DBOUT definition to verify that all occurences in the code
;// have been removed, and to prevent future usage of DBOUT
;// 
;//    Rev 1.9   18 Oct 1996 18:50:14   AGUPTA2
;// Changed DBOUT into DbgLog.  ASSERT is not changed to DbgAssert.
;// 
;// 
;//    Rev 1.8   18 Oct 1996 14:30:52   MDUDA
;// Added YUY2toYUV12 enumeration.
;// 
;//    Rev 1.7   11 Oct 1996 16:01:28   MDUDA
;// 
;// Added initial _CODEC_STATS stuff.
;// 
;//    Rev 1.6   27 Dec 1995 14:11:58   RMCKENZX
;// 
;// Added copyright notice
// 
//    Rev 1.5   17 Nov 1995 15:13:02   BECHOLS
// 
// Made modifications for ring 0.
// 
//    Rev 1.4   16 Nov 1995 17:34:08   AGANTZX
// Added TOUT macro to output timing data
// 
//    Rev 1.3   12 Sep 1995 15:44:50   DBRUCKS
// add H261 ifdef for debug statements
// 
//    Rev 1.2   03 Aug 1995 14:57:02   DBRUCKS
// Add ASSERT macro
// 
//    Rev 1.1   01 Aug 1995 12:24:40   DBRUCKS
// added TBD()
// 
//    Rev 1.0   31 Jul 1995 12:56:16   DBRUCKS
// rename files
// 
//    Rev 1.0   17 Jul 1995 14:44:04   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:48   CZHU
// Initial revision.

/*
 * Copyright (C) 1992, 1993 Intel Corporation.
 */
extern UINT DebugH26x;
extern void AssertFailed(void FAR * fpFileName, int iLine, void FAR * fpExp);

#ifndef __CLDEBUG_H__
#define __CLDEBUG_H__

  #ifdef _DEBUG
    #ifdef RING0
      #define DBOUT(x) {SYS_printf(x);}
      #define TOUT(x) {SYS_printf(x);}
    #else
      #ifdef H261
        #define DBOUT(x)  { if (DebugH26x) { \
                             OutputDebugString((LPSTR)"M261 : "); \
                             OutputDebugString((LPSTR)x);         \
                             OutputDebugString((LPSTR)"\n"); }}
      #else
         #define DBOUT(x) { if (DebugH26x) { \
                             OutputDebugString((LPSTR)"M263 : "); \
                             OutputDebugString((LPSTR)x);         \
                             OutputDebugString((LPSTR)"\n"); }}
      #endif
      #define TOUT(x)  { if (DebugH26x) { \
                          OutputDebugString((LPSTR)"TIMING : "); \
                          OutputDebugString((LPSTR)x);          \
                          OutputDebugString((LPSTR)"\n"); }}
    #endif //RING0
	#ifdef ASSERT
	#undef ASSERT
	#endif
    #define ASSERT(x) { if(!(x)) AssertFailed(__FILE__,__LINE__,#x); }
  #else
    #define TOUT(x) { } //  /##/
    #define DBOUT(x) { } //  /##/
	#ifdef ASSERT
	#undef ASSERT
	#endif
    #define ASSERT(x) { } //  /##/ 
  #endif
 
  #define TBD(s) DBOUT(s)

#ifdef _DEBUG // { _DEBUG

int WINAPI H261DbgPrintf ( LPTSTR lpszFormat, ... );
extern HDBGZONE  ghDbgZoneH261;

#define ZONE_BITRATE_CONTROL (GETMASK(ghDbgZoneH261) & 0x0001)
#define ZONE_BITRATE_CONTROL_DETAILS (GETMASK(ghDbgZoneH261) & 0x0002)

#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)	( (z) ? (H261DbgPrintf s ) : 0)
#endif // } DEBUGMSG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	static TCHAR _this_fx_ [] = (s);
#define _fx_		((LPTSTR) _this_fx_)
#endif // } FX_ENTRY
#define ERRORMESSAGE(m) (H261DbgPrintf m)
#else // }{ _DEBUG
#ifndef FX_ENTRY // { FX_ENTRY
#define FX_ENTRY(s)	
#endif // } FX_ENTRY
#ifndef DEBUGMSG // { DEBUGMSG
#define DEBUGMSG(z,s)
#define ERRORMESSAGE(m)
#endif  // } DEBUGMSG
#define _fx_		
#define ERRORMESSAGE(m)
#endif // } _DEBUG

#endif /* multi-inclusion protection */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\cproto.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   MDUDA  $
// $Date:   30 Dec 1996 19:59:06  $
// $Archive:   S:\h26x\src\common\cproto.h_v  $
// $Header:   S:\h26x\src\common\cproto.h_v   1.9   30 Dec 1996 19:59:06   MDUDA  $
// $Log:   S:\h26x\src\common\cproto.h_v  $
;// 
;//    Rev 1.9   30 Dec 1996 19:59:06   MDUDA
;// Modified H263InitEncoderInstance prototype.
;// 
;//    Rev 1.8   25 Sep 1996 17:23:28   BECHOLS
;// Added Snapshot declaration.
;// 
;//    Rev 1.7   24 Sep 1996 13:49:06   BECHOLS
;// Added Snapshot() prototype.
;// 
;//    Rev 1.6   10 Jul 1996 08:26:42   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.5   02 Feb 1996 18:52:56   TRGARDOS
;// Added code to enable ICM_COMPRESS_FRAMES_INFO message.
;// 
;//    Rev 1.4   27 Dec 1995 14:11:58   RMCKENZX
;// 
;// Added copyright notice
//
////////////////////////////////////////////////////////////////////////////

/*
 * Prototypes for Low Bitrate VFW Codec
 */

#ifndef LB3PROTOIZE_H
#define LB3PROTOIZE_H

#ifndef VOID
#define VOID void
#endif

#ifndef WIN32
#ifndef FAR
#define FAR __far
#endif
#endif



#ifndef INLINE
#define INLINE __inline
#endif

#ifndef STATIC
#define STATIC static
#endif

#ifndef SHORT
#define SHORT short
#endif

#ifndef S8
#define S8 signed char
#endif

DWORD PASCAL CompressBegin(LPCODINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL CompressQuery(LPCODINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL CompressFramesInfo( LPCODINST, ICCOMPRESSFRAMES *, int);

DWORD PASCAL CompressGetFormat(LPCODINST, LPBITMAPINFOHEADER ,
    LPBITMAPINFOHEADER );

DWORD PASCAL Compress(LPCODINST, ICCOMPRESS FAR *, DWORD );

DWORD PASCAL CompressGetSize(LPCODINST, LPBITMAPINFOHEADER,
    LPBITMAPINFOHEADER);

DWORD PASCAL CompressEnd(LPCODINST);

DWORD PASCAL DecompressQuery(LPDECINST, ICDECOMPRESSEX FAR *, BOOL);

DWORD PASCAL DecompressGetPalette(LPDECINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER); 

DWORD PASCAL DecompressSetPalette(LPDECINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);

DWORD PASCAL DecompressGetFormat(LPDECINST, LPBITMAPINFOHEADER, LPBITMAPINFOHEADER);

DWORD PASCAL DecompressBegin(LPDECINST, ICDECOMPRESSEX FAR *, BOOL);

DWORD PASCAL Decompress(LPDECINST, ICDECOMPRESSEX FAR *, DWORD, BOOL);

DWORD PASCAL DecompressEnd(LPDECINST);

DWORD PASCAL Snapshot(LPDECINST, LPVOID, DWORD);

VOID MakeCode32(U16);

BOOL PASCAL DrvLoad(VOID);

VOID PASCAL DrvFree(VOID);

LPINST PASCAL DrvOpen(ICOPEN FAR *);

DWORD PASCAL DrvClose(LPINST);

DWORD PASCAL DrvGetState(LPINST, LPVOID, DWORD);

DWORD PASCAL DrvSetState(LPINST, LPVOID, DWORD);

DWORD PASCAL DrvGetInfo(LPINST, ICINFO FAR *, DWORD);

#ifdef WIN32
LRESULT WINAPI DriverProc(DWORD, HDRVR, UINT, LPARAM, LPARAM);
#else
LRESULT FAR PASCAL _loadds DriverProc(DWORD, HDRVR, UINT, LPARAM, LPARAM);
#endif


LPCODINST PASCAL CompressOpen(VOID);

DWORD PASCAL CompressEnd(LPCODINST);

DWORD PASCAL CompressClose(DWORD);

// controls.c
#ifdef QUARTZ
LRESULT __cdecl CustomChangeBrightness(LPDECINST, BYTE);
LRESULT __cdecl CustomChangeContrast(LPDECINST, BYTE);
LRESULT __cdecl CustomChangeSaturation(LPDECINST, BYTE);
LRESULT __cdecl CustomGetBrightness(LPDECINST, BYTE *);
LRESULT __cdecl CustomGetContrast(LPDECINST, BYTE *);
LRESULT __cdecl CustomGetSaturation(LPDECINST, BYTE *);
LRESULT __cdecl CustomResetBrightness(LPDECINST);
LRESULT __cdecl CustomResetContrast(LPDECINST);
LRESULT __cdecl CustomResetSaturation(LPDECINST);
#else
LRESULT CustomChangeBrightness(LPDECINST, BYTE);
LRESULT CustomChangeContrast(LPDECINST, BYTE);
LRESULT CustomChangeSaturation(LPDECINST, BYTE);
LRESULT CustomResetBrightness(LPDECINST);
LRESULT CustomResetContrast(LPDECINST);
LRESULT CustomResetSaturation(LPDECINST);
#endif

#ifdef WIN32
//BOOL  DriverDialogProc(HWND, UINT, UINT, LONG);
BOOL APIENTRY DllMain(HINSTANCE , DWORD , LPVOID );
#else
INT WINAPI LibMain(HANDLE, WORD, LPSTR);
//BOOL FAR PASCAL _loadds _export DriverDialogProc(HWND, UINT, UINT, LONG);
#endif 

;// D3DEC.CPP 
LRESULT H263InitDecoderGlobal(void);
LRESULT H263Decompress(LPDECINST, ICDECOMPRESSEX FAR *, BOOL);
LRESULT H263InitDecoderInstance(LPDECINST, int);
LRESULT H263TermDecoderInstance(LPDECINST);

void FAR H26332BitEncoderCodeSegment (void);
void FAR H26332BitDecoderCodeSegment (void);
void FAR H26332BitColorConvertCodeSegment (void);

;// E3ENC.CPP
LRESULT H263InitEncoderGlobal(void);
LRESULT H263Compress(LPCODINST, ICCOMPRESS FAR *);
#if defined(H263P)
LRESULT H263InitEncoderInstance(LPBITMAPINFOHEADER, LPCODINST);
#else
LRESULT H263InitEncoderInstance(LPCODINST);
#endif
LRESULT H263TermEncoderInstance(LPCODINST);

;// D3COLOR.C
LRESULT H263InitColorConvertorGlobal (void);
LRESULT H263InitColorConvertor(LPDECINST, UINT);
LRESULT H263TermColorConvertor(LPDECINST);
#endif /* multi-inclusion protection */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\av\codecs\intel\h261\cdrvdefs.h ===
/* *************************************************************************
**    INTEL Corporation Proprietary Information
**
**    This listing is supplied under the terms of a license
**    agreement with INTEL Corporation and may not be copied
**    nor disclosed except in accordance with the terms of
**    that agreement.
**
**    Copyright (c) 1995,1996 Intel Corporation.
**    All Rights Reserved.
**
** *************************************************************************
*/

////////////////////////////////////////////////////////////////////////////
//
// $Author:   JMCVEIGH  $
// $Date:   05 Feb 1997 12:14:24  $
// $Archive:   S:\h26x\src\common\cdrvdefs.h_v  $
// $Header:   S:\h26x\src\common\cdrvdefs.h_v   1.39   05 Feb 1997 12:14:24   JMCVEIGH  $
// $Log:   S:\h26x\src\common\cdrvdefs.h_v  $
;// 
;//    Rev 1.39   05 Feb 1997 12:14:24   JMCVEIGH
;// Support for improved PB-frames custom message handling.
;// 
;//    Rev 1.38   14 Jan 1997 11:17:14   JMCVEIGH
;// Put flag for old still-frame mode backward compatibility under
;// #ifdef H263P
;// 
;//    Rev 1.37   06 Jan 1997 17:38:08   JMCVEIGH
;// Added flag in LPDECINST to ensure backward compatibility with
;// old still-frame mode (crop CIF image to 320x240).
;// 
;//    Rev 1.36   16 Dec 1996 17:37:00   JMCVEIGH
;// Added H263Plus state and changed name for true B-frame mode.
;// 
;//    Rev 1.35   16 Dec 1996 13:40:46   MDUDA
;// Added compression and bit width fields to compress info.
;// 
;//    Rev 1.34   11 Dec 1996 14:56:46   JMCVEIGH
;// 
;// Added H.263+ options to frame header structure and flags in
;// configuration structure.
;// 
;//    Rev 1.33   09 Dec 1996 17:43:10   JMCVEIGH
;// Added support for arbitrary frame size support.
;// 
;//    Rev 1.32   09 Dec 1996 09:24:42   MDUDA
;// 
;// Re-arranged for H263P.
;// 
;//    Rev 1.31   10 Sep 1996 16:13:06   KLILLEVO
;// added custom message in decoder to turn block edge filter on or off
;// 
;//    Rev 1.30   10 Sep 1996 10:32:10   KLILLEVO
;// changed GlobalAlloc/GlobalLock to HeapAlloc
;// 
;//    Rev 1.29   06 Sep 1996 15:00:20   MBODART
;// Added performance counters for NT's perfmon.
;// New files:  cxprf.cpp, cxprf.h and cxprf.cpp.
;// New directory:  src\perf
;// Updated files:  e1enc.{h,cpp}, d1dec.{h,cpp}, cdrvdefs.h, h261* makefiles.
;// 
;//    Rev 1.28   10 Jul 1996 08:26:38   SCDAY
;// H261 Quartz merge
;// 
;//    Rev 1.27   19 Jun 1996 14:37:26   RHAZRA
;// added #define FOURCC_YUY2
;// 
;//    Rev 1.26   06 May 1996 12:56:34   BECHOLS
;// changed unbitspersecond to unBytesPerSecond.
;// 
;//    Rev 1.25   06 May 1996 00:42:36   BECHOLS
;// 
;// Added support for the bit rate control in the configure dialog.
;// 
;//    Rev 1.24   26 Apr 1996 11:09:18   BECHOLS
;// 
;// Added RTP stuff.
;// 
;//    Rev 1.23   02 Feb 1996 18:52:52   TRGARDOS
;// Added code to enable ICM_COMPRESS_FRAMES_INFO message.
;// 
;//    Rev 1.22   19 Jan 1996 15:32:50   TRGARDOS
;// Added TRPrev field to PictureHeader structure.
;// 
;//    Rev 1.21   11 Jan 1996 16:52:24   DBRUCKS
;// added variables to store the aspect ratio correction boolean
;// 
;//    Rev 1.20   04 Jan 1996 18:07:54   TRGARDOS
;// Added boolean for 320x240 input into COMPINSTINFO.
;// 
;//    Rev 1.19   27 Dec 1995 14:11:54   RMCKENZX
;// 
;// Added copyright notice
// 
//    Rev 1.18   06 Dec 1995 09:22:56   DBRUCKS
// 
// Added blazer data rate, frame rate, and quality variables to 
// COMPINSTINFO inside an H261 ifdef
// 
//    Rev 1.17   30 Oct 1995 12:02:12   TRGARDOS
// Modified compressor instance structure to add
// 240x180 support.
// 
//    Rev 1.16   27 Sep 1995 19:09:30   TRGARDOS
// Changed enumeration name for picture code type.
// 
//    Rev 1.15   20 Sep 1995 12:37:40   DBRUCKS
// save the fcc in uppercase
// 
//    Rev 1.14   19 Sep 1995 15:41:28   TRGARDOS
// Fixed four cc comparison code.
// 
//    Rev 1.13   18 Sep 1995 08:42:46   CZHU
// 
// Define FOURCC for YUV12
// 
//    Rev 1.12   13 Sep 1995 17:08:26   TRGARDOS
// Finished adding encoder support for YVU9 160x120 frames.
// 
//    Rev 1.11   12 Sep 1995 17:01:38   DBRUCKS
// add twocc
// 
//    Rev 1.10   11 Sep 1995 11:14:48   DBRUCKS
// add h261 ifdef
// 
//    Rev 1.9   29 Aug 1995 17:18:48   TRGARDOS
// Padded H263HeaderStruct
// 
//    Rev 1.8   28 Aug 1995 17:45:04   DBRUCKS
// add size defines
// 
//    Rev 1.7   28 Aug 1995 11:45:52   TRGARDOS
// 
// Updated frame size bit field in PTYPE.
// 
//    Rev 1.6   25 Aug 1995 10:37:12   CZHU
// Changed PITCH from const int to #define, because of compiler bug for inline
// 
//    Rev 1.5   25 Aug 1995 09:02:32   TRGARDOS
// 
// Modified picture header structure.
// 
//    Rev 1.4   14 Aug 1995 11:34:52   TRGARDOS
// Finished writing picture frame header.
// 
//    Rev 1.3   11 Aug 1995 17:27:56   TRGARDOS
// Added bitstream writing and defined bitstream fields.
// 
//    Rev 1.2   07 Aug 1995 16:25:28   TRGARDOS
// 
// Moved PITCH definition here from c3dec.h.
// 
//    Rev 1.1   03 Aug 1995 10:38:40   TRGARDOS
// 
// Put picture header structure definition and GOB header 
// definition in here.
// 
//    Rev 1.0   31 Jul 1995 12:56:14   DBRUCKS
// rename files
// 
//    Rev 1.0   17 Jul 1995 14:43:58   CZHU
// Initial revision.
// 
//    Rev 1.0   17 Jul 1995 14:14:32   CZHU
// Initial revision.
;// 
;// Added encoder controls message support.
;// Modified RTP dialog box.
;// Change to PercentForcedUpdate
;// add T_CONFIGURATION
;// Integrate with build 29
;// 
////////////////////////////////////////////////////////////////////////////
#ifndef DRV_DEFS_H
#define DRV_DEFS_H

#ifndef WIN32

/*
 * Define standard data types.
 */
typedef BYTE __huge* HPBYTE;
typedef WORD __huge* HPWORD;
typedef BYTE __far*  LPBYTE;
typedef WORD __far*  LPWORD;
typedef int  __far*  LPSHORT;

typedef unsigned char U8;
#ifndef I8
typedef signed char I8;
#endif
#ifndef U16
typedef unsigned int  U16;
#endif
#ifndef I16
typedef signed int I16;
#endif
#ifndef U32
typedef unsigned long U32;
#endif
#ifndef INT
#define INT short int        /* signed 16 bit */
#endif
#else //WIN32
typedef BYTE        * HPBYTE;
typedef WORD        * HPWORD;
typedef BYTE        *  LPBYTE;
typedef WORD        *  LPWORD;
typedef short int   *  LPSHORT;

typedef unsigned char U8;
#ifndef I8
typedef signed char I8;
#endif
#ifndef U16
typedef unsigned short int  U16;
#endif
#ifndef I16
typedef signed short int I16;
#endif
#ifndef U32
typedef unsigned long U32;
#endif
#ifndef INT
#define INT int        /* signed 16 bit */
#endif
#endif //WIN32

/*
 * Define custom DRVPROC messages for playback.
 */
#define PLAYBACK_CUSTOM_START            (ICM_RESERVED_HIGH     + 1)
#define PLAYBACK_CUSTOM_END            (PLAYBACK_CUSTOM_START + 9)
#define PLAYBACK_CUSTOM_CHANGE_BRIGHTNESS    (PLAYBACK_CUSTOM_START + 0)
#define PLAYBACK_CUSTOM_CHANGE_CONTRAST        (PLAYBACK_CUSTOM_START + 1)
#define PLAYBACK_CUSTOM_CHANGE_SATURATION    (PLAYBACK_CUSTOM_START + 2)
#define PLAYBACK_CUSTOM_RESET_BRIGHTNESS    (PLAYBACK_CUSTOM_START + 3)
#define PLAYBACK_CUSTOM_RESET_SATURATION    (PLAYBACK_CUSTOM_START + 4)
#define PLAYBACK_CUSTOM_CHANGE_TINT        (PLAYBACK_CUSTOM_START + 5)
#define PLAYBACK_CUSTOM_RESET_TINT        (PLAYBACK_CUSTOM_START + 6)
#define PLAYBACK_CUSTOM_COLOR_CONVERT        (PLAYBACK_CUSTOM_START + 7)

typedef struct { char name[5]; HANDLE h; U16 FAR *log; U16 err; } TimeLog;

/*
 * Define various constants.
 */
#define TOTAL 0
#define OVERHEAD 1
#define HUFF 2
#define YSLANT 3
#define VSLANT 4
#define USLANT 5
#define YDIFF 6
#define VDIFF 7
#define UDIFF 8
#define TORQUE 9
#define FILTER 10
#define CSC 11

#ifdef H263P
enum FrameSize {FORBIDDEN=0, SQCIF=1, QCIF=2, CIF=3, fCIF=4, ssCIF=5, CUSTOM=6, EPTYPE=7};
#else
enum FrameSize {FORBIDDEN=0, SQCIF=1, QCIF=2, CIF=3, fCIF=4, ssCIF=5};
#endif

#define MAX_WIDTH 	352	   // CIF
#define MAX_HEIGHT	288	   // CIF
#define PITCH 		(MAX_WIDTH+32)

//** Decompressor Instance information
typedef struct {
    BOOL    Initialized;
	BOOL	bProposedCorrectAspectRatio;	// proposed
	BOOL    bCorrectAspectRatio;	// whether to correct the aspect ratio
#ifdef H263P
	BOOL    bCIFto320x240;          // whether to crop CIF frames to 320x240 (old still-frame mode)
#endif
    WORD    xres, yres;             // size of image within movie
	FrameSize FrameSz;		// Which of the supported frame sizes.
    int     pXScale, pYScale;       // proposed scaling (Query)
    int     XScale, YScale;         // current scaling (Begin)  
    UINT    uColorConvertor;        // Current Color Convertor
    WORD    outputDepth;            // and bit depth
    LPVOID  pDecoderInst;
    BOOL 				UseActivePalette;	/* decompress to active palette == 1 */
	BOOL				InitActivePalette;	/* active palette initialized == 1 */
	BOOL				bUseBlockEdgeFilter;/* switch for block edge filter */
	RGBQUAD     		ActivePalette[256];	/* stored active palette */
} DECINSTINFO, FAR *LPDECINST;

//** Configuration Information
typedef struct {
   BOOL    	bInitialized;               // Whether custom msgs can be rcv'd.
   BOOL		bCompressBegin;				// Whether the CompressBegin msg was rcv'd.
   BOOL    	bRTPHeader;                 // Whether to generate RTP header info
   /* used if bRTPHeader */
   UINT     unPacketSize;               // Maximum packet size
   BOOL     bEncoderResiliency;         // Whether to use resiliency restrictions
   /* used if bEncoderResiliency */
   UINT    	unPacketLoss;
   BOOL		bBitRateState;
   /* used if bBitRateState */
   UINT		unBytesPerSecond;
   /* The following information is determined from the packet loss value.   */
   /*  These values are calculated each time we receive a resiliency msg or */
   /*  the value is changed through the dialog box.  They are not stored in */
   /*  the registry.  Only the above elements are stored in the registry.   */
	BOOL    bDisallowPosVerMVs;   		// if true, disallow positive vertical MVs
	BOOL    bDisallowAllVerMVs;   		// if true, disallow all vertical MVs
	UINT    unPercentForcedUpdate;      // Percent Forced Update per Frame
	UINT    unDefaultIntraQuant;        // Default Intra Quant
	UINT    unDefaultInterQuant;        // Default Inter Quant

#ifdef H263P
	BOOL    bH263PlusState;				// Whether to use H.263+
	BOOL    bImprovedPBState;			// Whether to use improved PB-frames
	BOOL    bDeblockingFilterState;		// Whether to use in-the-loop deblocking filter
#endif
} T_CONFIGURATION;

//** Compressor Instance information
typedef struct{
    BOOL    Initialized;
    WORD    xres, yres;
	FrameSize FrameSz;		// Which of the supported frame sizes.
	float	FrameRate;
	U32		DataRate;		// Data rate in bytes per second.
    HGLOBAL hEncoderInst;   // Instance data private to encoder.
    LPVOID  EncoderInst;
    WORD    CompressedSize;
	BOOL	Is160x120;
	BOOL 	Is240x180;
	BOOL	Is320x240;
#if defined(H263P)
	U32		InputCompression;
	U32		InputBitWidth;
#endif
	T_CONFIGURATION Configuration;
} COMPINSTINFO, FAR *LPCODINST;

//**
//** Instance information
//**
typedef struct tagINSTINFO {
    DWORD   dwFlags;
	DWORD	fccHandler;		// So we know what codec has been opened.
	BOOL	enabled;
    LPCODINST CompPtr;          // ICM
    LPDECINST DecompPtr;        // ICM
} INSTINFO, FAR *LPINST;

//**  local name definitions ***
#ifdef H261
#ifdef QUARTZ
#define FOURCC_H26X mmioFOURCC('M','2','6','1')
#endif /* QUARTZ */
#define FOURCC_H263 mmioFOURCC('M','2','6','1')

#else /* is H263 */
#ifdef QUARTZ
#define FOURCC_H26X mmioFOURCC('M','2','6','3')
#endif /* QUARTZ */
#define FOURCC_H263 mmioFOURCC('M','2','6','3')
#endif /* else is H263 */

#define FOURCC_YUV12 mmioFOURCC('I','4','2','0')
#define FOURCC_IYUV  mmioFOURCC('I','Y','U','V')
#define FOURCC_YVU9  mmioFOURCC('Y','V','U','9')
#define FOURCC_IF09  mmioFOURCC('I','F','0','9')
#define FOURCC_YUY2  mmioFOURCC('Y','U','Y','2')
#define FOURCC_UYVY  mmioFOURCC('U','Y','V','Y')
#define TWOCC_H26X aviTWOCC('i','v');

#define MOD4(a)     ((a/4)*4)

typedef struct {
    unsigned short PictureStartCodeZeros:16;
    unsigned short PictureStartCode:6;
    unsigned short TR:8;
    unsigned short Const:2;
    unsigned short Split:1;
    unsigned short DocCamera:1;
    unsigned short PicFreeze:1;
    unsigned short SrcFormat:3;
    unsigned short Inter:1;
    unsigned short UMV:1;
    unsigned short SAC:1;
    unsigned short AP:1;
    unsigned short PB:1;
	unsigned short CPM:1;
} T_H263FrameHeader;

enum EnumPicCodType	{INTRAPIC=0, INTERPIC=1};
enum EnumOnOff	{OFF=0, ON=1};

/*
 * If the size of T_H263FrameHeaderStruct is changed, then
 * that change must be updated in T_H263EncoderCatalog in e3enc.h
 */
typedef struct {
    U32	PictureStartCodeZeros;	// 0..3
    U8 	TR;						// 4
   	// PTYPE;
	U8	Const;					// 5 -- two bit constant: 10
    U8	SrcFormat;				// 6 -- source format
	U8	Unassigned1;			// 7
 	EnumOnOff	Split;			// 8..11 -- split screen indicator
    EnumOnOff	DocCamera;		// 12..15 -- document camera indicator
    EnumOnOff	PicFreeze;		// 16..19 -- freeze picture release
    EnumPicCodType	PicCodType;	// 20 -- pictu