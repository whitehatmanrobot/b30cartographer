AM wParam, LPARAM lParam);
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP PopulateColumnsList();
		STDMETHODIMP AddColumnItemToList(CColumnItem* pszItem);
		STDMETHODIMP OnOK();

	protected:

		HWND m_hWnd;
		HWND m_hwndListView;
		CSimpleArray<CColumnItem*> *m_pArrayColumns;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\trustmon\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(_STDAFX_H_INCLUDED_)
#define _STDAFX_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#   define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#define STRICT
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#define NT_INCLUDED
#undef ASSERT
#undef ASSERTMSG

#define _ATL_NO_UUIDOF

#pragma warning(disable: 4100) // don't warn about unreferenced formal params (not all WMI interface params are used)
#pragma warning(disable: 4127) // don't warn about conditional expression is constant
#pragma warning(disable: 4514) // don't warn about unreferenced inline removal (ATL)
#pragma warning(disable: 4505) // don't warn about unreferenced local function (ATL)

#pragma warning(push, 3) // avoid warnings from system headers when compiling at W4

#include <afx.h>
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <vector>

using namespace std;

#include <malloc.h>
#include <process.h>
#include <wbemprov.h>
#include <ntdsapi.h>
#include <ntlsa.h>
#include <lm.h>
#include <dsgetdc.h>
#include <sddl.h>
#include <iads.h> // IADsPathname

#pragma warning(pop) // end: avoid warnings from system headers when compiling at W4

///////////////////////////////////////////
// ASSERT's and TRACE's without debug CRT's
#if defined (DBG)
  #if !defined (_DEBUG)
    #define _USE_ADMINPRV_TRACE
    #define _USE_ADMINPRV_ASSERT
    #define _USE_ADMINPRV_TIMER
  #endif
#endif

#define ADMINPRV_COMPNAME L"TrustMon"

#include "dbg.h"
///////////////////////////////////////////

#include "common.h"
#include "trust.h"
#include "domain.h"
#include "TrustPrv.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_STDAFX_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\columnmgrdlg.cpp ===
//-------------------------------------------------------------------------
// File: ColumnMgrDlg.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "ColumnMgrDlg.h"

CColumnManagerDlg * g_pColumnManagerDlg =  NULL;

//-------------------------------------------------------------------------

INT_PTR CALLBACK ColumnManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pColumnManagerDlg)
	{
		return g_pColumnManagerDlg->ColumnManagerDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CColumnManagerDlg::CColumnManagerDlg(CSimpleArray<CColumnItem*> *pArrayColumns)
{
	m_hWnd = NULL;
	m_hwndListView = NULL;
	m_pArrayColumns = pArrayColumns;
}

//-------------------------------------------------------------------------

CColumnManagerDlg::~CColumnManagerDlg()
{
}

//-------------------------------------------------------------------------

INT_PTR CALLBACK CColumnManagerDlg::ColumnManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();
				PopulateColumnsList();

				break;
			}

		case WM_DESTROY:
			{
				//DestroyDialog();
				break;
			}
		
		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
				case IDCANCEL:
					EndDialog(m_hWnd, IDCANCEL);
					return TRUE;

				case IDOK:
					OnOK();
					return TRUE;
					break;
				}

				break;
			}

		default:
			break;
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CColumnManagerDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	
	NTDM_BEGIN_METHOD()

	//Initialize the ListView Control

	m_hwndListView = GetDlgItem(m_hWnd, IDC_COLUMNS_LIST);
	NTDM_ERR_IF_NULL(m_hwndListView);

	ListView_SetExtendedListViewStyle(m_hwndListView, LVS_EX_FULLROWSELECT|LVS_EX_CHECKBOXES);

	lvColumn.mask = LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;

	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndListView, 0, &lvColumn));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndListView, 0, LVSCW_AUTOSIZE_USEHEADER));

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CColumnManagerDlg::PopulateColumnsList()
{
	HRESULT hr;
	long i;

	NTDM_BEGIN_METHOD()

	for(i=0; i<m_pArrayColumns->GetSize(); i++)
	{
		AddColumnItemToList((*m_pArrayColumns)[i]);
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CColumnManagerDlg::AddColumnItemToList(CColumnItem* pszItem)
{
	HRESULT hr;
	LVITEM lvItem;
	long lIndex = 10000;
	static TCHAR test[20] = _T("cool");

	NTDM_BEGIN_METHOD()

	lvItem.mask = LVIF_TEXT|LVIF_PARAM;
	lvItem.iItem = lIndex;
	lvItem.iSubItem = 0;
	lvItem.pszText = (LPTSTR)pszItem->GetName();
	lvItem.lParam = (LPARAM)pszItem;

	lIndex = ListView_InsertItem(m_hwndListView, &lvItem);
	NTDM_ERR_IF_MINUSONE(lIndex);
	ListView_SetCheckState(m_hwndListView, lIndex, pszItem->IsSelected());

	NTDM_END_METHOD()

	// cleanup
	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CColumnManagerDlg::OnOK()
{
	HRESULT hr;
	LVITEM lvItem;
	long lCount;
	BOOL bValue;

	NTDM_BEGIN_METHOD()

	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;
	
	lCount = ListView_GetItemCount(m_hwndListView);

	while(lCount > 0)
	{
		lCount--;

		lvItem.iItem = lCount;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));
		bValue = ListView_GetCheckState(m_hwndListView, lCount);
		((CColumnItem *)lvItem.lParam)->SetSelected(bValue);
	}	
	
	NTDM_END_METHOD()

	if SUCCEEDED(hr)
		EndDialog(m_hWnd, IDOK);

	// cleanup
	return hr;
}


//---------------------------------------------------------------------------
// CColumnItem
//---------------------------------------------------------------------------

CColumnItem::CColumnItem(LPCTSTR pcszName, LPCTSTR pcszPropertyName, bool bSelected) 
{
	m_bstrName = pcszName;
	m_bstrPropertyName = pcszPropertyName;
	m_bSelected = bSelected;
}

//---------------------------------------------------------------------------

CColumnItem::CColumnItem(const CColumnItem& colItem)
{
	m_bstrName = colItem.m_bstrName;
	m_bstrPropertyName = colItem.m_bstrPropertyName;
	m_bSelected = colItem.m_bSelected;
}

//---------------------------------------------------------------------------

CColumnItem& CColumnItem::operator=(const CColumnItem& colItem) 
{ 
	if(this != &colItem)
	{
		m_bstrName = colItem.m_bstrName;
		m_bstrPropertyName = colItem.m_bstrPropertyName;
		m_bSelected = colItem.m_bSelected;
	}

	return *this;
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\trustmon\trust.cpp ===
//+----------------------------------------------------------------------------
//
//  Windows 2000 Active Directory Service domain trust verification WMI provider
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       trust.cpp
//
//  Contents:   Trust class implementation
//
//  Classes:    CTrustInfo
//
//  History:    27-Mar-00 EricB created
//
//-----------------------------------------------------------------------------

#include <stdafx.h>

PCWSTR CSTR_PROP_TRUSTED_DOMAIN      = L"TrustedDomain";      // String
PCWSTR CSTR_PROP_FLAT_NAME           = L"FlatName";           // String
PCWSTR CSTR_PROP_SID                 = L"SID";                // String
PCWSTR CSTR_PROP_TRUST_DIRECTION     = L"TrustDirection";     // uint32
PCWSTR CSTR_PROP_TRUST_TYPE          = L"TrustType";          // uint32
PCWSTR CSTR_PROP_TRUST_ATTRIBUTES    = L"TrustAttributes";    // uint32
PCWSTR CSTR_PROP_TRUST_STATUS        = L"TrustStatus";        // uint32
PCWSTR CSTR_PROP_TRUST_STATUS_STRING = L"TrustStatusString";  // String
PCWSTR CSTR_PROP_TRUST_IS_OK         = L"TrustIsOk";          // Boolean
PCWSTR CSTR_PROP_TRUSTED_DC_NAME     = L"TrustedDCName";      // String

// Define NETLOGON_CONTROL_TC_VERIFY if not found so this will build for W2K.
// This constant is in the Whistler version of lmaccess.h
#if !defined(NETLOGON_CONTROL_TC_VERIFY)
#  define NETLOGON_CONTROL_TC_VERIFY (10)
#endif

//+----------------------------------------------------------------------------
//
//  Class:  CTrustInfo
//
//-----------------------------------------------------------------------------
CTrustInfo::CTrustInfo() : m_ulTrustDirection(0),
                           m_ulTrustType(0),
                           m_ulTrustAttributes(0),
                           m_trustStatus(ERROR_SUCCESS),
                           m_VerifyStatus(VerifyStatusNone),
                           m_fPwVerifySupported(TRUE)
{
   m_liLastVerified.QuadPart = 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustInfo::Verify
//
//  Synopsis:   Verify the status of the trust
//
//  Returns:    FALSE if the trust was not outbound.
//
//-----------------------------------------------------------------------------
BOOL
CTrustInfo::Verify(TrustCheckLevel CheckLevel)
{
   TRACE(L"CTrustInfo::Verify, verify level %d\n", CheckLevel);
   NET_API_STATUS netStatus = NERR_Success;
   NETLOGON_INFO_2 * pNetlogonInfo2 = NULL;
   VerifyStatus Status = VerifyStatusNone;
   PCWSTR pwzTrustedDomain = GetTrustedDomain();
   CString strDCName, strResetTarget = GetTrustedDomain();

   if (DONT_VERIFY == CheckLevel)
   {
      TRACE(L"\tCheck-Level set to not verify trust.\n");
      SetTrustStatus(NERR_Success, VerifyStatusTrustNotChecked);
      return TRUE;
   }

   TRACE(L"\tVerifying trust with %s\n", GetTrustedDomain());

   if ((TRUST_TYPE_MIT == GetTrustType()) ||
       (TRUST_TYPE_DCE == GetTrustType()))
   {
      // don't verify non-Windows trusts.
      //
      TRACE(L"\tNot a windows trust, returning.\n");
      SetTrustStatus(NERR_Success, VerifyStatusNotWindowsTrust);
      SetLastVerifiedTime();
      return TRUE;
   }

   if (!IsTrustOutbound())
   {
      // don't verify inbound-only trusts.
      //
      TRACE(L"\tInbound-only trust, returning.\n");
      SetTrustStatus(NERR_Success, VerifyStatusNotOutboundTrust);
      SetLastVerifiedTime();
      return FALSE;
   }

   //
   // NETLOGON_CONTROL_TC_QUERY - get the status (locally) and the name of trusted DC
   // Note that the secure channel is set up only on demand, so it is not an error if
   // it is not set up. The SC_QUERY will return ERROR_NO_LOGON_SERVERS if this is the
   // case.
   //

   netStatus = I_NetLogonControl2(NULL,
                                  NETLOGON_CONTROL_TC_QUERY,
                                  2,
                                  (LPBYTE)&pwzTrustedDomain,
                                  (LPBYTE *)&pNetlogonInfo2);

   if (NERR_Success == netStatus)
   {
      ASSERT(pNetlogonInfo2);

      netStatus = pNetlogonInfo2->netlog2_tc_connection_status;

      if (netStatus == NERR_Success)
      {
         SetTrustedDCName(pNetlogonInfo2->netlog2_trusted_dc_name);
         strDCName = pNetlogonInfo2->netlog2_trusted_dc_name;
#if !defined(NT4_BUILD)
          //
          // Compose the domain\dc string for the reset command so it will not change
          // DCs as a result of the reset. This only works with NT5 or later NetLogon.
          //
          strResetTarget += L"\\";
          strResetTarget += pNetlogonInfo2->netlog2_trusted_dc_name + 2; // skip the UNC double slashes
#endif
      }
      else
      {
         if (ERROR_NO_LOGON_SERVERS == netStatus)
         {
            // This is the error returned when the SC has not yet been set up.
            // It is also returned if no DCs are reachable. DsGetDcName is called with the
            // force flag to discover if any DCs are reachable on the net.
            //
            PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
            DWORD dwRet = NO_ERROR;

#if !defined(NT4_BUILD)
            dwRet = DsGetDcName(NULL, pwzTrustedDomain, NULL, NULL, DS_FORCE_REDISCOVERY, &pDCInfo);
#endif
            if (NO_ERROR == dwRet)
            {
               // A DC is reachable, so it is safe to assume that the SC has not yet been
               // set up. Treat this as success.
               //
               netStatus = NERR_Success;
               TRACE(L"SC_QUERY has returned ERROR_NO_LOGON_SERVERS, SC not yet set up.\n");
#if !defined(NT4_BUILD)
               SetTrustedDCName(pDCInfo->DomainControllerName);
               NetApiBufferFree(pDCInfo);
#endif
            }
            else
            {
               // If there are no DCs, there is nothing to be done except return the error.
               //
               TRACE(L"DsGetDcName /FORCE has returned %d, DC not found.\n", dwRet);
               // Save the error code and fixed by method
               SetTrustStatus(dwRet, VerifyStatusBroken);
               SetLastVerifiedTime();

               return TRUE;
            }
         }
         else
         {
             TRACE(L"SC_QUERY has returned %d.\n", netStatus);
         }
      }
      NetApiBufferFree(pNetlogonInfo2);
   }
   else
   {
      TRACE(L"I_NetLogonControl2 has returned %d.\n", netStatus);
   }

   //
   // Do a trust PW verification if the other domain supports it.
   //
   if (PW_VERIFY == CheckLevel)
   {
      if (m_fPwVerifySupported)
      {
         netStatus = I_NetLogonControl2(NULL,
                                        NETLOGON_CONTROL_TC_VERIFY,
                                        2,
                                        (LPBYTE)&pwzTrustedDomain,
                                        (LPBYTE *)&pNetlogonInfo2);

         if (NERR_Success == netStatus)
         {
            ASSERT(pNetlogonInfo2);
            netStatus = pNetlogonInfo2->netlog2_tc_connection_status;
            NetApiBufferFree(pNetlogonInfo2);
         }
         if (NERR_Success == netStatus)
         {
            TRACE(L"PW Verify successful on %s\n", pwzTrustedDomain);
            Status = VerifyStatusTrustOK;
         }
         else
         {
            if (ERROR_INVALID_LEVEL == netStatus ||
                ERROR_NOT_SUPPORTED == netStatus ||
                RPC_S_PROCNUM_OUT_OF_RANGE == netStatus ||
                RPC_NT_PROCNUM_OUT_OF_RANGE == netStatus)
            {
               TRACE(L"NETLOGON_CONTROL_TC_VERIFY is not supported on %s\n", pwzTrustedDomain);
               m_fPwVerifySupported = FALSE;
               Status = VerifyStatusPwCheckNotSupported;
               netStatus = NERR_Success; // call it success since we don't know the true state
            }
            else
            {
               TRACE(L"NETLOGON_CONTROL_TC_VERIFY returned 0x%08x on %s\n", netStatus, pwzTrustedDomain);
               Status = VerifyStatusBroken;
            }
         }
      }
      else
      {
         Status = VerifyStatusPwCheckNotSupported;
      }
   }

   //
   // Try an SC Reset against the DC returned by the SC query
   //
   if (SC_RESET == CheckLevel)
   {
      PCWSTR pwzResetTarget = strResetTarget;

      netStatus = I_NetLogonControl2(NULL,
                                     NETLOGON_CONTROL_REDISCOVER,
                                     2,
                                     (LPBYTE)&pwzResetTarget,
                                     (LPBYTE *)&pNetlogonInfo2);

      if (NERR_Success == netStatus)
      {
         ASSERT(pNetlogonInfo2);
         netStatus = pNetlogonInfo2->netlog2_tc_connection_status;
         NetApiBufferFree(pNetlogonInfo2);
      }
      if (NERR_Success == netStatus)
      {
         TRACE(L"SC_RESET successfull on %s\n", pwzResetTarget);
         Status = VerifyStatusRediscover;
      }
      else
      {
         TRACE(L"SC_RESET returned 0x%08x on %s\n", netStatus, pwzResetTarget);
      }
   }

#ifdef NT4_BUILD
   //
   // Force trust pw replication from PDC to BDCs; only works on pre-W2K.
   //
   if (netStatus != NERR_Success)
   {
      // perform only once, ignore the result
      ForceReplication();
   }
#endif

   //
   // If still in an error state, do an SC reset against any DC
   //
   if (netStatus != NERR_Success)
   {
      netStatus = ForceRediscover(NULL, &strDCName);

      if (NERR_Success == netStatus)
      {
         Status = VerifyStatusRediscover;

         SetTrustedDCName(const_cast<PWSTR>((PCWSTR)strDCName));
      }
   }

   //
   // Walk through the DCs trying to establish an SC: TRCHK_RETARGET_ON_ERROR
   //
   if (NERR_Success != netStatus)
   {
      vector<LPWSTR>    dcList;
      LPBYTE      pbuf	= NULL;
    
      TRACE(L"Attempting to retarget...\n");

      //
      // Enumerate all DCs in the trusted domain
      // Attempt reconnecting to another DC.
      //
      // The returned value is not recorded.
      // (if not enumerated, skip this step)
      //
      if( NERR_Success == GetDCList(strDCName,
                                    dcList,
                                    &pbuf))
      {
         //
         // Try to connect to every DC until success
         //
         for (vector<LPWSTR>::iterator  ppszDCName = dcList.begin();
              NERR_Success != netStatus && ppszDCName != dcList.end();
              ppszDCName++)
         {
            netStatus = ForceRediscover(*ppszDCName, &strDCName);
         }
      }

      if (NERR_Success == netStatus)
      {
         SetTrustedDCName(const_cast<PWSTR>((PCWSTR)strDCName));
         Status = VerifyStatusRetarget;
      }

      //
      // Clean up the DC list
      //
      if (pbuf)
      {
         VERIFY( NERR_Success == NetApiBufferFree(pbuf));
      }
   }

   // Save the error code and Status
   SetTrustStatus(netStatus, Status);
   SetLastVerifiedTime();

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustInfo::SetLastVerifiedTime
//
//  Synopsis:   Record the time of verification.
//
//-----------------------------------------------------------------------------
void
CTrustInfo::SetLastVerifiedTime(void)
{
   SYSTEMTIME st;

   GetSystemTime(&st);
   SystemTimeToFileTime(&st, (LPFILETIME)&m_liLastVerified);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustInfo::IsVerificationStale
//
//  Synopsis:  Checks to see if the last verification time is older than the
//             passed in criteria.
//
//  Returns:   TRUE if older.
//
//  Notes:     If the trust hasn't been verified (m_liLastVerified == 0),
//             then the verification is defined to be stale.
//
//-----------------------------------------------------------------------------
BOOL
CTrustInfo::IsVerificationStale(LARGE_INTEGER liMaxAge)
{
   TRACE(L"CTrustInfo::IsVerificationStale(0x%08x), MaxAge = %d\n",
         this, liMaxAge.QuadPart / TRUSTMON_FILETIMES_PER_MINUTE);
   BOOL fStale = FALSE;
   LARGE_INTEGER liCurrentTime;
   SYSTEMTIME st;

   GetSystemTime(&st);
   SystemTimeToFileTime(&st, (LPFILETIME)&liCurrentTime);

   //TRACE(L"\tlast: %I64d, cur: %I64d, max: %I64d\n", m_liLastVerified, liCurrentTime, liMaxAge);

   fStale = (m_liLastVerified.QuadPart + liMaxAge.QuadPart) < liCurrentTime.QuadPart;

   return fStale;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustInfo::GetDCList
//
//  Synopsis:   Enumerate all DCs in a domain and return a list in random order.
//
//-----------------------------------------------------------------------------
NET_API_STATUS
CTrustInfo::GetDCList(PCWSTR pszKnownServer,   // OPTIONAL The server name to be placed in the end of the list
                      vector<LPWSTR> & dcList, // Vector of PCWSTRs, pointing to the DC names inside pbufptr
                      LPBYTE * pbufptr )       // This buffer must be freed with NetApiBufferFree when done.
{
    TRACE(L"CTrustInfo::GetDCList\n");

    ASSERT( pbufptr );
    ASSERT( !(*pbufptr) );

    NET_API_STATUS  netStatus        = NERR_Success;
    DWORD           dwEntriesRead    = 0;
    DWORD           dwTotalEntries   = 0;
    DWORD           dwResumeHandle   = 0;
    DWORD           dwIndKnownServer = MAXDWORD;
    DWORD           dwInd            = 0;
    
    do
    {
        // Init
        dcList.clear();
    
        //
        //  Enumerate all the servers belonging to the specified domain
        //
        netStatus = NetServerEnum( NULL,
                                   100,       // SERVER_INFO_100
                                   pbufptr,
                                   MAX_PREFERRED_LENGTH,
                                   & dwEntriesRead,
                                   & dwTotalEntries,
                                   SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL,
                                   GetTrustedDomain(),
                                   & dwResumeHandle );

        TRACE(L"NetServerEnum returned 0x%08x! (%d entries)\n", netStatus, dwEntriesRead);

        if( netStatus == ERROR_MORE_DATA )
        {
            // should never happen (no enum handle)
            ASSERT( FALSE );

            // process whatever NetServerEnum returned.
            netStatus = NERR_Success;
        }

        if( netStatus != NERR_Success ||
            !dwEntriesRead ||
            !(*pbufptr) )
        {
            TRACE(L"Failure, exiting...\n");
            
            dcList.clear();

            if( *pbufptr )
            {
                VERIFY( NERR_Success == NetApiBufferFree( *pbufptr ) );
                *pbufptr = NULL;
            }

            break;
        }

        // To simplify buffer access...
        PSERVER_INFO_100 pServerInfo100 = PSERVER_INFO_100( *pbufptr );

        // Reserve enough space for all the entries
        dcList.reserve( dwEntriesRead );

        //
        // Create a list of Servers
        //
        for( dwInd = 0;  dwInd < dwEntriesRead;  dwInd++ )
        {
            if( pszKnownServer &&
                !_wcsicmp( pszKnownServer, pServerInfo100[dwInd].sv100_name ) )
            {
                dwIndKnownServer = dwInd;     // postpone until the end
            }
            else
            {
                dcList.push_back( pServerInfo100[dwInd].sv100_name );
            }
        }

        ASSERT( dwEntriesRead );

        //
        // Known server should go to the end of the list
        //
        if( MAXDWORD != dwIndKnownServer )
        {
            TRACE(L"Server %s placed @ the end\n", pszKnownServer);

            dcList.push_back( pServerInfo100[dwIndKnownServer].sv100_name );

            // Shuffling should not include the last entry
            dwEntriesRead--;
        }

        //
        // Initialize randomizer
        //
        srand( (unsigned) time( NULL ) );

        //
        // Shuffle by replacing each entry with another random entry
        //
        for( dwInd = 0;  dwInd < (int) dwEntriesRead;  dwInd++ )
        {
            DWORD  dwRandPos = DWORD( rand() % dwEntriesRead );

            if( dwRandPos == dwInd )
                continue;
                
            // Swap!
            LPWSTR     pstrTemp = dcList[ dwRandPos ];
            dcList[ dwRandPos ] = dcList[ dwInd ];
            dcList[ dwInd ]     = pstrTemp;
        }

    } while( FALSE );

    return netStatus;
}


//+----------------------------------------------------------------------------
//
//  Method:     CTrustInfo::ForceRediscover
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
NET_API_STATUS
CTrustInfo::ForceRediscover(PCWSTR pstrDCName, CString * pstrDCNameRet)
{
    TRACE(L"CTrustInfo::ForceRediscover\n");

    NET_API_STATUS    netStatus       = NERR_Success;
    NETLOGON_INFO_2 * pNetlogonInfo2  = NULL;
    CString           strTemp;
    PCWSTR pstrDomainName = GetTrustedDomain();

    if( pstrDCName )
    {
        //
        // Form domain\dc request
        //
        strTemp = pstrDomainName;
        strTemp += L"\\";
        strTemp += pstrDCName;

        // Retarget pstrDomainName to the new string
        pstrDomainName = strTemp;
    }
    
    //
    // Attempt to re-establish trust
    //
    netStatus = I_NetLogonControl2( NULL,
                                    NETLOGON_CONTROL_REDISCOVER,
                                    2,
                                    ( LPBYTE )  &pstrDomainName,
                                    ( LPBYTE *) &pNetlogonInfo2 );

    TRACE(L"I_NetLogonControl2:NETLOGON_CONTROL_REDISCOVER to %s returned 0x%08x\n",
          pstrDomainName, netStatus);
    //
    // Clean-up
    //
    if( pNetlogonInfo2 )
    {
        *pstrDCNameRet = pNetlogonInfo2->netlog2_trusted_dc_name;
        TRACE(L"netlog2_flags=0x%08x, netlog2_pdc_connection_status=0x%08x\n",
              pNetlogonInfo2->netlog2_flags,
              pNetlogonInfo2->netlog2_pdc_connection_status);

        TRACE(L"netlog2_trusted_dc_name=%s, netlog2_tc_connection_status=0x%08x\n",
              pNetlogonInfo2->netlog2_trusted_dc_name,
              pNetlogonInfo2->netlog2_tc_connection_status);

        NetApiBufferFree( pNetlogonInfo2 );
    }

    return netStatus;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustInfo::SetTrustStatus
//
//  Synopsis:  Set the status string based on the netStatus value if an error
//             else based on the VerifyStatus.
//
//-----------------------------------------------------------------------------
void
CTrustInfo::SetTrustStatus(ULONG netStatus, VerifyStatus Status)
{
   WCHAR wzBuf[512];

   m_trustStatus = netStatus;
   m_VerifyStatus = Status;

   if (NERR_Success == netStatus)
   {
      int nStrID;

      switch (Status)
      {
      case VerifyStatusNone:
         //
         // This is the default value for the Status parameter.
         //
      case VerifyStatusTrustOK:
         nStrID = IDS_TRUST_STATUS_OK;
         break;

      case VerifyStatusNotWindowsTrust:
         nStrID = IDS_MIT_TRUST_STATUS;
         break;

      case VerifyStatusNotOutboundTrust:
         nStrID = IDS_STATUS_INBOUND_ONLY;
         break;

      case VerifyStatusTrustNotChecked:
         nStrID = IDS_STATUS_NOT_CHECKED;
         break;

      case VerifyStatusPwCheckNotSupported:
         nStrID = IDS_PW_VERIFY_NOT_SUPPORTED;
         break;

      case VerifyStatusRetarget:
         nStrID = IDS_FIXED_BY_RETARGET;
         break;

      case VerifyStatusRediscover:
         nStrID = IDS_STATUS_REDISCOVER;
         break;

      case VerifyStatusBroken:
         ASSERT(FALSE); // shouldn't get here, fall through.
      default:
         nStrID = IDS_STATUS_UNKNOWN;
      }

      LoadString(_Module.GetModuleInstance(), nStrID, wzBuf, 512);
      m_strTrustStatus = wzBuf;
   }
   else
   {
      PWSTR pwzMsg;

      if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM |
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        netStatus,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (PWSTR)&pwzMsg,
                        0,
                        NULL))
      {
         PWSTR pwzSuffix = wcsstr(pwzMsg, L"\r\n");
         if (pwzSuffix)
         {
            *pwzSuffix = L'\0';
         }
         m_strTrustStatus = pwzMsg;
         LocalFree(pwzMsg);
      }
      else
      {
         LoadString(_Module.GetModuleInstance(), IDS_TRUST_STATUS_FAILED, wzBuf, 512);
         m_strTrustStatus = wzBuf;
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method: CTrustInfo::SetTrustDirectionFromFlags
//
//-----------------------------------------------------------------------------
void
CTrustInfo::SetTrustDirectionFromFlags(ULONG ulFlags)
{
   m_ulTrustDirection = 0;

   if (DS_DOMAIN_DIRECT_OUTBOUND & ulFlags)
   {
      m_ulTrustDirection = TRUST_DIRECTION_OUTBOUND;
   }

   if (DS_DOMAIN_DIRECT_INBOUND & ulFlags)
   {
      m_ulTrustDirection |= TRUST_DIRECTION_INBOUND;
   }
}

//+----------------------------------------------------------------------------
//
//  Method: CTrustInfo::SetSid
//
//-----------------------------------------------------------------------------
BOOL
CTrustInfo::SetSid(PSID pSid)
{
   if (!pSid)
   {
      return TRUE;
   }

#if !defined(NT4_BUILD)
   PWSTR buffer;

   BOOL fRet = ConvertSidToStringSid(pSid, &buffer);

   if (fRet)
   {
      m_strSid = buffer;
      LocalFree(buffer);
   }

   return fRet;
#else
// TODO: Code for NT4 ??
#pragma message("need ConvertSidToStringSid for NT4");
#endif
}

#ifdef NT4_BUILD

//+----------------------------------------------------------------------------
//
//  Function:   ForceReplication
//
//  Synopsis:   Force local Domain Replication -- works only for NT4 domains
//
//-----------------------------------------------------------------------------
NET_API_STATUS ForceReplication(void)
{
    TRACE(L"ForceReplication\n");

    NET_API_STATUS    netStatus       = NERR_Success;

    LPBYTE            pbInputDataPtr  = NULL;
    PNETLOGON_INFO_1  pNetlogonInfo1  = NULL;

    netStatus = I_NetLogonControl2( NULL,
                                    NETLOGON_CONTROL_REPLICATE,
                                    1,
                                    (LPBYTE )  &pbInputDataPtr,
                                    (LPBYTE *) &pNetlogonInfo1 );

    TRACE(L"I_NetLogonControl2:NETLOGON_CONTROL_REPLICATE returned 0x%08x\n", netStatus);

    if( pNetlogonInfo1 )
    {
        TRACE(L"netlog1_flags=0x%08x, netlog1_pdc_connection_status=0x%08x\n",
              pNetlogonInfo1->netlog1_flags,
              pNetlogonInfo1->netlog1_pdc_connection_status);
    
        NetApiBufferFree( pNetlogonInfo1 );
    }

    return netStatus;
}

#endif //NT4_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\trustmon\trustmon.cpp ===
//+----------------------------------------------------------------------------
//
//  Windows 2000 Active Directory Service domain trust verification WMI provider
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       trustmon.cpp
//
//  Contents:   Implementation of worker thread class and DLL Exports.
//
//  Classes:    CAsyncCallWorker
//
//  History:    22-Mar-00 EricB created
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>

CComModule _Module;

DEFINE_GUID(CLSID_TrustMonProvider,0x8065652F,0x4C29,0x4908,0xAA,0xE5,0x20,0x1C,0x89,0x19,0x04,0xC5);

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TrustMonProvider, CTrustPrv)
END_OBJECT_MAP()

WCHAR g_wzMofPath[] = L"\\system32\\wbem\\ADStatus\\TrustMon.mof";

//+----------------------------------------------------------------------------
//
//  Class: CAsyncCallWorker
//
//-----------------------------------------------------------------------------
CAsyncCallWorker::CAsyncCallWorker(CTrustPrv * pTrustPrv,
                                   long lFlags,
                                   IWbemClassObject * pClassDef,
                                   IWbemObjectSink * pResponseHandler,
                                   LPWSTR pwzInstanceName) :
   m_lFlags(lFlags),
   m_pwzInstanceName(pwzInstanceName) 
{
   TRACE(L"CAsyncCallWorker::CAsyncCallWorker(0x%08x)\n", this);
   m_sipTrustPrv.p = pTrustPrv; pTrustPrv->AddRef(); // ATL CComPtr is broken!
   m_sipClassDef = pClassDef;
   m_sipResponseHandler = pResponseHandler;
}

CAsyncCallWorker::~CAsyncCallWorker()
{
   TRACE(L"CAsyncCallWorker::~CAsyncCallWorker\n\n");
   if (m_pwzInstanceName)
   {
      delete m_pwzInstanceName;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CAsyncCallWorker::CreateInstEnum
//
//  Synopsis:   Provides the worker thread function for
//              IWbemServices::CreateInstanceEnumAsync
//
//-----------------------------------------------------------------------------
void __cdecl
CAsyncCallWorker::CreateInstEnum(PVOID pParam)
{
   TRACE(L"CAsyncCallWorker::CreateInstEnum\n");
   HRESULT hr = WBEM_S_NO_ERROR;
   DWORD dwWaitResult;
   CAsyncCallWorker * pWorker = (CAsyncCallWorker *)pParam;
   CDomainInfo * pDomain = &(pWorker->m_sipTrustPrv->m_DomainInfo);

   CoInitializeEx(NULL, COINIT_MULTITHREADED);

   do
   {
      BREAK_ON_NULL(pWorker);

      //
      // Try to get the mutex first without a wait. It is in the signalled state if
      // not owned.
      //
      dwWaitResult = WaitForSingleObject(pWorker->m_sipTrustPrv->m_hMutex, 0);

      if (WAIT_TIMEOUT == dwWaitResult)
      {
         // Mutex is owned by another thread. Rewait.

         dwWaitResult = WaitForSingleObject(pWorker->m_sipTrustPrv->m_hMutex,
                                            6000000); // timeout set to 10 minutes

         switch(dwWaitResult)
         {
         case WAIT_TIMEOUT:
            // mutex continues to be non-signalled (owned by another thread).
            hr = WBEM_E_SERVER_TOO_BUSY; // BUGBUG: returning an error.
                                         // BUGBUG: should the timeout be parameterized?
            break;

         case WAIT_OBJECT_0:
            // This thread now owns the mutex.
            break;

         case WAIT_ABANDONED: // this means the owning thread terminated without releasing the mutex.
            TRACE(L"Another thread didn't release the mutex!\n");
            break;
         }
      }

      BREAK_ON_FAIL;

      CoImpersonateClient();

      //
      // Re-read all the trust information if stale.
      // The trust list is not re-enumerated on every call because trusts are
      // rarely modified.
      //
      if (pDomain->IsTrustListStale(pWorker->m_sipTrustPrv->m_liTrustEnumMaxAge))
      {
         hr = pDomain->EnumerateTrusts();

         BREAK_ON_FAIL;
      }

      size_t cTrusts = pDomain->Size();

      for (size_t i = 0; i < cTrusts; i++)
      {
         if ((long)WBEM_FLAG_SEND_STATUS & pWorker->m_lFlags)
         {
            hr = pWorker->m_sipResponseHandler->SetStatus(WBEM_STATUS_PROGRESS, 
                                                          MAKELONG(i, cTrusts),
                                                          NULL, NULL);
            BREAK_ON_FAIL;
         }

         CTrustInfo * pTrust;

         //
         // Get trust Info
         //
         pTrust = pDomain->GetTrustByIndex(i);

         BREAK_ON_NULL_(pTrust, hr, WBEM_E_INVALID_OBJECT_PATH);

         //
         // Verify the trust if stale.
         //
         if (pTrust->IsVerificationStale(pWorker->m_sipTrustPrv->m_liVerifyMaxAge))
         {
            pTrust->Verify(pWorker->m_sipTrustPrv->GetTrustCheckLevel());
         }

         CoRevertToSelf();

         //
         // Create a new instance of the object if the trust is outbound or if
         // return-all is true.
         //
         if (pTrust->IsTrustOutbound() || pWorker->m_sipTrustPrv->GetReturnAll())
         {
            hr = CreateAndSendTrustInst(*pTrust, pWorker->m_sipClassDef,
                                        pWorker->m_sipResponseHandler);
         }

         BREAK_ON_FAIL;

         CoImpersonateClient();
      }

   } while (FALSE);

   CoRevertToSelf();

   //
   // Set status
   //
   pWorker->m_sipResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);

   ReleaseMutex(pWorker->m_sipTrustPrv->m_hMutex);

   delete pWorker;

   CoUninitialize();

   _endthread();
}

//+----------------------------------------------------------------------------
//
//  Method:     CAsyncCallWorker::GetObj
//
//  Synopsis:   Provides the worker thread function for
//              IWbemServices::GetObjectAsync
//
//-----------------------------------------------------------------------------
void __cdecl
CAsyncCallWorker::GetObj(PVOID pParam)
{
    TRACE(L"CAsyncCallWorker::GetObj\n");
    HRESULT hr = WBEM_S_NO_ERROR;
    CAsyncCallWorker * pWorker = (CAsyncCallWorker *)pParam;

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    CoImpersonateClient();

    do
    {

    } while (FALSE);

    CoRevertToSelf();

    //
    // Set status
    //
    pWorker->m_sipResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);

    delete pWorker;

    CoUninitialize();

    _endthread();
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateAndSendTrustInst
//
//  Purpose:    Creates a new instance and sets the inital values of the
//              properties.
//
//-----------------------------------------------------------------------------
HRESULT
CreateAndSendTrustInst(CTrustInfo & Trust, IWbemClassObject * pClassDef,
                       IWbemObjectSink * pResponseHandler)
{
   TRACE(L"CreateAndSendTrustInst\n");
   HRESULT hr = WBEM_S_NO_ERROR;

   do
   {
      CComPtr<IWbemClassObject> ipNewInst;
      CComVariant var;

      //
      // Create a new instance of the WMI class object
      //
      hr = pClassDef->SpawnInstance(0, &ipNewInst);
      BREAK_ON_FAIL;
      
      // Set the key property value (TrustedDomain)
      var = Trust.GetTrustedDomain();
      hr  = ipNewInst->Put(CSTR_PROP_TRUSTED_DOMAIN, 0, &var, 0);
      TRACE(L"\tCreating instance %s\n", var.bstrVal);
      BREAK_ON_FAIL;
       //Flat Name
      var = Trust.GetFlatName();
      hr  = ipNewInst->Put(CSTR_PROP_FLAT_NAME, 0, &var, 0);
      BREAK_ON_FAIL;
      //Sid
      var = Trust.GetSid();
      hr  = ipNewInst->Put(CSTR_PROP_SID, 0, &var, 0);
      BREAK_ON_FAIL;
      //Trust Direction
      var = (long)Trust.GetTrustDirection();
      hr  = ipNewInst->Put(CSTR_PROP_TRUST_DIRECTION, 0, &var, 0);
      BREAK_ON_FAIL;
      //Trust Type
      var = (long)Trust.GetTrustType();
      hr  = ipNewInst->Put(CSTR_PROP_TRUST_TYPE, 0, &var, 0);
      BREAK_ON_FAIL;
      //Trust Attributes
      var = (long)Trust.GetTrustAttributes();
      hr  = ipNewInst->Put(CSTR_PROP_TRUST_ATTRIBUTES, 0, &var, 0);
      BREAK_ON_FAIL;
      // Set the TrustStatus value.
      var = (long)Trust.GetTrustStatus();
      hr  = ipNewInst->Put(CSTR_PROP_TRUST_STATUS, 0, &var, 0);
      BREAK_ON_FAIL;
      var = Trust.GetTrustStatusString();
      hr  = ipNewInst->Put(CSTR_PROP_TRUST_STATUS_STRING, 0, &var, 0);
      BREAK_ON_FAIL;
      // Set the Trust Is OK value.
      var = Trust.IsTrustOK();
      hr  = ipNewInst->Put(CSTR_PROP_TRUST_IS_OK, 0, &var, 0);
      BREAK_ON_FAIL;
      //Trusted DC Name
      var = Trust.GetTrustedDCName();
      hr  = ipNewInst->Put(CSTR_PROP_TRUSTED_DC_NAME, 0, &var, 0);
      BREAK_ON_FAIL;

      //
      // Send the object to the caller
      //
      // [In] param, no need to addref.
      IWbemClassObject * pNewInstance = ipNewInst;
      hr = pResponseHandler->Indicate(1, &pNewInstance);

      BREAK_ON_FAIL;

   } while(FALSE);

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:  DllMain
//
//  Purpose:   DLL Entry Point
//
//-----------------------------------------------------------------------------
extern "C" BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
   if (dwReason == DLL_PROCESS_ATTACH)
   {
      _Module.Init(ObjectMap, hInstance);
      DisableThreadLibraryCalls(hInstance);
   }
   else if (dwReason == DLL_PROCESS_DETACH)
       _Module.Term();
   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:  DllCanUnloadNow
//
//  Purpose:   Used to determine whether the DLL can be unloaded by OLE
//
//-----------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
   return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  Function:  DllGetClassObject
//
//  Purpose:   Returns a class factory to create an object of the requested type
//
//-----------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
   return _Module.GetClassObject(rclsid, riid, ppv);
}

//+----------------------------------------------------------------------------
//
//  Function:  DllRegisterServer
//
//  Purpose:   Adds Class entries to the system registry
//
//-----------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
   // Add TrustMon to the registry as an event source.
   //
   HKEY hk; 
   DWORD dwData; 
   WCHAR wzFilePath[2*MAX_PATH];

   GetModuleFileName(_Module.GetModuleInstance(), wzFilePath, 2*MAX_PATH);

   if (RegCreateKey(HKEY_LOCAL_MACHINE, 
                    L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\" TM_PROV_NAME,
                    &hk))
   {
      TRACE(L"Could not create the registry key.");
   }
   else
   {
      // Set the name of the message file.
      //
      TRACE(L"Adding path %s to the registry\n", wzFilePath);

      // Add the name to the EventMessageFile subkey.

      if (RegSetValueEx(hk,
                        L"EventMessageFile",
                        0,
                        REG_EXPAND_SZ,
                        (LPBYTE)wzFilePath,
                        (ULONG)(wcslen(wzFilePath) + 1) * sizeof(WCHAR)))
      {
         TRACE(L"Could not set the event message file.");
      }
      else
      {
         // Set the supported event types in the TypesSupported subkey.

         dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
                  EVENTLOG_INFORMATION_TYPE; 

         if (RegSetValueEx(hk,
                           L"TypesSupported",
                           0,
                           REG_DWORD,
                           (LPBYTE)&dwData,
                           sizeof(DWORD)))
         {
            TRACE(L"Could not set the supported types.");
         }
      }

      RegCloseKey(hk);
   }

   // Add a RunOnce value to do the MOF compile.
   //
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
                    0,
                    KEY_WRITE,
                    &hk))
   {
      TRACE(L"Could not open the registry key.");
   }
   else
   {
      CString csCmd = L"rundll32.exe ";
      csCmd += wzFilePath;
      csCmd += L",DoMofComp";

      if (RegSetValueEx(hk,
                        L"TrustMon",
                        0,
                        REG_SZ,
                        (LPBYTE)csCmd.GetBuffer(0),
                        csCmd.GetLength() * sizeof(WCHAR)))
      {
         TRACE(L"Could not set the runonce value.");
      }

      RegCloseKey(hk);
   }

   return _Module.RegisterServer();
}

//+----------------------------------------------------------------------------
//
//  Function:  DllUnregisterServer
//
//  Purpose:   Removes Class entries from the system registry
//
//-----------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
   return _Module.UnregisterServer();
}

//+----------------------------------------------------------------------------
//
//  Function:  DoMofComp
//
//  Purpose:   Adds the provider classes to the WMI repository. Note that the
//             function signature is that required by rundll32.exe.
//
//-----------------------------------------------------------------------------
VOID WINAPI DoMofComp(HWND hWndParent,
                      HINSTANCE hModule,
                      PCTSTR ptzCommandLine,
                      INT nShowCmd)
{
   TRACE(L"DoMofComp\n");
   UNREFERENCED_PARAMETER(hWndParent);
   UNREFERENCED_PARAMETER(hModule);
   UNREFERENCED_PARAMETER(ptzCommandLine);
   UNREFERENCED_PARAMETER(nShowCmd);
   HRESULT hr;
   CComPtr<IMofCompiler> pmc;

   CoInitialize(NULL);

   hr = CoCreateInstance(CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER,
                         IID_IMofCompiler, (PVOID *)&pmc);

   CHECK_HRESULT(hr, return);

   WCHAR wzFilePath[2*MAX_PATH];
   UINT nLen = GetSystemWindowsDirectory(wzFilePath, 2*MAX_PATH);
   if (nLen == 0)
   {
      ASSERT(FALSE);
      return;
   }

   CString csMofPath = wzFilePath;

   csMofPath += g_wzMofPath;

   WBEM_COMPILE_STATUS_INFO Info;

   TRACE(L"Compiling MOF file %s\n", csMofPath.GetBuffer(0));

   hr = pmc->CompileFile(csMofPath.GetBuffer(0), NULL, NULL, NULL, NULL,
                         WBEM_FLAG_AUTORECOVER, 0, 0, &Info);

   HANDLE hEvent = RegisterEventSource(NULL, TM_PROV_NAME);

   if (!hEvent)
   {
      TRACE(L"RegisterEventSource failed with error  %d\n", GetLastError());
      return;
   }

   if (WBEM_S_NO_ERROR != hr)
   {
      TRACE(L"MofCompile failed with error 0x%08x (WMI error 0x%08x), line: %d, phase: %d\n",
            hr, Info.hRes, Info.FirstLine, Info.lPhaseError);
      //
      // Send failure to EventLog.
      //
      CString csHr, csLine;
      HMODULE hm = LoadLibrary(L"mofd.dll");

      if (hm)
      {
         WCHAR wzBuf[MAX_PATH];
         LoadString(hm, Info.hRes, wzBuf, MAX_PATH);
         csHr = wzBuf;
         FreeLibrary(hm);
      }
      else
      {
         csHr.Format(L"%d", Info.hRes);
      }

      csLine.Format(L"%d", Info.FirstLine);
      const PWSTR rgArgs[3] = {csHr.GetBuffer(0), csLine.GetBuffer(0), csMofPath.GetBuffer(0)};

      ReportEvent(hEvent,
                  EVENTLOG_ERROR_TYPE,
                  0,                       // wCategory
                  TRUSTMON_MOFCOMP_FAILED, // dwEventID
                  NULL,                    // lpUserSID
                  3,                       // wNumStrings
                  0,                       // dwDataSize
                  (PCWSTR *)rgArgs,        // lpStrings
                  NULL);                   // lpRawData
   }
   else
   {
      // Send success notice to EventLog.
      //
      ReportEvent(hEvent,
                  EVENTLOG_INFORMATION_TYPE,
                  0,                        // wCategory
                  TRUSTMON_MOFCOMP_SUCCESS, // dwEventID
                  NULL,                     // lpUserSID
                  0,                        // wNumStrings
                  0,                        // dwDataSize
                  NULL,                     // lpStrings
                  NULL);                    // lpRawData
   }

   DeregisterEventSource(hEvent);

   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\trustmon\trustprv.cpp ===
//+----------------------------------------------------------------------------
//
//  Windows 2000 Active Directory Service domain trust verification WMI provider
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       TrustPrv.cpp
//
//  Contents:   Trust Monitor provider WMI interface class implementation
//
//  Classes:    CTrustPrv
//
//  History:    22-Mar-00 EricB created
//
//-----------------------------------------------------------------------------

#include "stdafx.h"

#include "dbg.cpp"

PCWSTR CLASSNAME_STRING_PROVIDER = L"Microsoft_TrustProvider";
PCWSTR CLASSNAME_STRING_TRUST    = L"Microsoft_DomainTrustStatus";
PCWSTR CLASSNAME_STRING_LOCAL    = L"Microsoft_LocalDomainInfo";

PCWSTR CSTR_PROP_TRUST_LIST_LIFETIME   = L"TrustListLifetime";   // uint32
PCWSTR CSTR_PROP_TRUST_STATUS_LIFETIME = L"TrustStatusLifetime"; // uint32
PCWSTR CSTR_PROP_TRUST_CHECK_LEVEL     = L"TrustCheckLevel";     // uint32
PCWSTR CSTR_PROP_RETURN_ALL_TRUSTS     = L"ReturnAll";           // boolean

//WCHAR * const PROVIDER_CLASS_CHANGE_QUERY = L"select * from  __InstanceOperationEvent where TargetInstance.__Relpath = \"Microsoft_TrustProvider=@\"";
WCHAR * const PROVIDER_CLASS_CHANGE_QUERY = L"select * from __InstanceOperationEvent where TargetInstance isa \"Microsoft_TrustProvider\"";
WCHAR * const PROVIDER_CLASS_INSTANCE = L"Microsoft_TrustProvider=@";

//+----------------------------------------------------------------------------
//
//  class CTrustPrv
//
//-----------------------------------------------------------------------------
CTrustPrv::CTrustPrv(void) :
   m_hMutex(NULL),
   m_TrustCheckLevel(DEFAULT_TRUST_CHECK_LEVEL),
   m_fReturnAllTrusts(TRUE),
   m_fRegisteredForChanges(FALSE)
{
   TRACE(L"CTrustPrv::CTrustPrv(0x%08x)\n", this);
   m_liTrustEnumMaxAge.QuadPart = TRUSTMON_DEFAULT_ENUM_AGE;
   m_liVerifyMaxAge.QuadPart = TRUSTMON_DEFAULT_VERIFY_AGE;
}

CTrustPrv::~CTrustPrv(void)
{
   TRACE(L"CTrustPrv::~CTrustPrv\n");

   if (m_hMutex)
   {
      CloseHandle(m_hMutex);
   }

   if (m_fRegisteredForChanges)
   {
      m_sipNamespace->CancelAsyncCall(this);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPrv::IWbemProviderInit::Initialize
//
//  Synopsis:   Initialize the provider object.
//
//  Returns:    WMI error codes
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTrustPrv::Initialize(
         IN LPWSTR pszUser,
         IN LONG lFlags,
         IN LPWSTR pszNamespace,
         IN LPWSTR pszLocale,
         IN IWbemServices *pNamespace,
         IN IWbemContext *pCtx,
         IN IWbemProviderInitSink *pInitSink)
{
   WBEM_VALIDATE_INTF_PTR(pNamespace);
   WBEM_VALIDATE_INTF_PTR(pCtx);
   WBEM_VALIDATE_INTF_PTR(pInitSink);
   TRACE(L"\nCTrustPrv::Initialize\n");

   HRESULT hr = WBEM_S_NO_ERROR;

   do
   { 
      m_hMutex = CreateMutex(NULL, FALSE, NULL);

      BREAK_ON_NULL_(m_hMutex, hr, WBEM_E_OUT_OF_MEMORY);

      m_sipNamespace = pNamespace;

      CComPtr<IWbemClassObject> sipProviderInstance;
      IWbemClassObject * pLocalClassDef = NULL;

      //
      // Get pointers to the class definition objects. If a failure, re-compile
      // the MOF file and try once more.
      //
      for (int i = 0; i <= 1; i++)
      {
         CComBSTR sbstrObjectName = CLASSNAME_STRING_TRUST;
         hr = m_sipNamespace->GetObject(sbstrObjectName,
                                        WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                        pCtx,
                                        &m_sipClassDefTrustStatus,
                                        NULL);
         if (FAILED(hr))
         {
            TRACE(L"GetObject(%s) failed with error 0x%08x\n", sbstrObjectName, hr);
            DoMofComp(NULL, NULL, NULL, 0);
            continue;
         }

         sbstrObjectName = CLASSNAME_STRING_LOCAL;
         hr = m_sipNamespace->GetObject(sbstrObjectName,
                                        WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                        pCtx,
                                        &pLocalClassDef,
                                        NULL);
         if (FAILED(hr))
         {
            TRACE(L"GetObject(%s) failed with error 0x%08x\n", sbstrObjectName, hr);
            DoMofComp(NULL, NULL, NULL, 0);
            continue;
         }

         sbstrObjectName = CLASSNAME_STRING_PROVIDER;
         hr = m_sipNamespace->GetObject(sbstrObjectName,
                                        WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                        pCtx,
                                        &m_sipClassDefTrustProvider,
                                        NULL);
         if (FAILED(hr))
         {
            TRACE(L"GetObject(%s) failed with error 0x%08x\n", sbstrObjectName, hr);
            DoMofComp(NULL, NULL, NULL, 0);
            continue;
         }

         //
         // Get the instance of the provider class to read its properties.
         //

         sbstrObjectName = PROVIDER_CLASS_INSTANCE;
         hr = m_sipNamespace->GetObject(sbstrObjectName,
                                        WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                        pCtx,
                                        &sipProviderInstance,
                                        NULL);
         if (FAILED(hr))
         {
            TRACE(L"GetObject(%s) failed with error 0x%08x\n", sbstrObjectName, hr);
            DoMofComp(NULL, NULL, NULL, 0);
         }
         else
         {
            i = 2; // success, don't loop again.
         }
      }
      BREAK_ON_FAIL;

      //
      // Set this provider instance's runtime properties.
      //
      hr = SetProviderProps(sipProviderInstance);

      BREAK_ON_FAIL;

      //
      // Initialize the domain object.
      //
      hr = m_DomainInfo.Init(pLocalClassDef);

      BREAK_ON_FAIL;

      //
      // Register to recieve change notifications for the provider class
      // properties.
      //
      CComBSTR bstrLang(L"WQL");
      CComBSTR bstrClassQuery(PROVIDER_CLASS_CHANGE_QUERY);

      hr = m_sipNamespace->ExecNotificationQueryAsync(bstrLang,
                                                      bstrClassQuery,
                                                      0,
                                                      NULL,
                                                      this);
      BREAK_ON_FAIL;

      m_fRegisteredForChanges = TRUE;

      //
      // Let CIMOM know we are initialized.
      // Return value and SetStatus param should be consistent, so ignore
      // the return value from SetStatus itself (in retail builds).
      //
      HRESULT hr2;
      hr2 = pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
      ASSERT(!FAILED(hr2));

   } while (false);

   if (FAILED(hr))
   {
      TRACE(L"hr = 0x%08x\n", hr);
      pInitSink->SetStatus(WBEM_E_FAILED, 0);
   }

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPrv::IWbemObjectSink::Indicate
//
//  Synopsis:   Recieves provider object instance change notifications from WMI.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTrustPrv::Indicate(LONG lObjectCount,
                    IWbemClassObject ** rgpObjArray)
{
   TRACE(L"\nCTrustPrv::Indicate++++++++++++++++\n");

   if (1 > lObjectCount)
   {
      TRACE(L"\tno objects supplied!\n");
      return WBEM_S_NO_ERROR;
   }

   VARIANT var;

   HRESULT hr = (*rgpObjArray)->Get(L"TargetInstance", 0, &var, NULL, NULL);

   if (FAILED(hr) || VT_UNKNOWN != var.vt || !var.punkVal)
   {
      TRACE(L"Error, could not get the target instance, hr = 0x%08x\n", hr);
      return hr;
   }

   hr = SetProviderProps((IWbemClassObject *)var.punkVal);

   VariantClear(&var);

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustPrv::SetProviderProps
//
//  Synopsis:  Set the provider runtime instance values from the instance of
//             the Microsoft_TrustProvider class.
//
//-----------------------------------------------------------------------------
HRESULT
CTrustPrv::SetProviderProps(IWbemClassObject * pClass)
{
   WBEM_VALIDATE_INTF_PTR(pClass);
   TRACE(L"\nCTrustPrv::SetProviderProps\n");

   HRESULT hr = WBEM_S_NO_ERROR;

   do
   { 
      VARIANT var;

      hr = pClass->Get(CSTR_PROP_TRUST_LIST_LIFETIME, 0, &var, NULL, NULL);

      BREAK_ON_FAIL;

      SetTrustListLifetime(var.lVal);

      VariantClear(&var);

      hr = pClass->Get(CSTR_PROP_TRUST_STATUS_LIFETIME, 0, &var, NULL, NULL);

      BREAK_ON_FAIL;

      SetTrustStatusLifetime(var.lVal);

      VariantClear(&var);

      hr = pClass->Get(CSTR_PROP_TRUST_CHECK_LEVEL, 0, &var, NULL, NULL);

      BREAK_ON_FAIL;

      SetTrustCheckLevel(var.lVal);

      VariantClear(&var);

      hr = pClass->Get(CSTR_PROP_RETURN_ALL_TRUSTS, 0, &var, NULL, NULL);

      BREAK_ON_FAIL;

      SetReturnAll(var.boolVal);

      VariantClear(&var);

   } while (false);

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:  GetClass
//
//  Synopsis:  Determines if the first element of the passed in path is one
//             of the valid class names.
//
//  Returns:   TrustMonClass enum value.
//
//-----------------------------------------------------------------------------
TrustMonClass
GetClass(BSTR strClass)
{
   if (_wcsnicmp(strClass, CLASSNAME_STRING_PROVIDER, wcslen(CLASSNAME_STRING_PROVIDER)) == 0)
   {
      TRACE(L"GetClass returning %s\n", CLASSNAME_STRING_PROVIDER);
      return CLASS_PROVIDER;
   }
   else
   {
      if (_wcsnicmp(strClass, CLASSNAME_STRING_TRUST, wcslen(CLASSNAME_STRING_TRUST)) == 0)
      {
         TRACE(L"GetClass returning %s\n", CLASSNAME_STRING_TRUST);
         return CLASS_TRUST;
      }
      else
      {
         if (_wcsnicmp(strClass, CLASSNAME_STRING_LOCAL, wcslen(CLASSNAME_STRING_LOCAL)) == 0)
         {
            TRACE(L"GetClass returning %s\n", CLASSNAME_STRING_LOCAL);
            return CLASS_LOCAL;
         }
         else
         {
            TRACE(L"GetClass returning NO_CLASS\n");
            return NO_CLASS;
         }
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPrv::IWbemServices::GetObjectAsync
//
//  Synopsis:   Return the instance named by strObjectPath.
//
//  Returns:    WMI error codes
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTrustPrv::GetObjectAsync( 
        IN const BSTR strObjectPath,
        IN long lFlags,
        IN IWbemContext * pCtx,
        IN IWbemObjectSink * pResponseHandler)
{
   HRESULT hr = WBEM_S_NO_ERROR;
   CTrustInfo * pTrust;
   BOOL fReverted = FALSE;
   TRACE(L"\nCTrustsPrv::GetObjectAsync:\n"
         L"\tObject param = %s, flags = 0x%08x\n", strObjectPath, lFlags);
   do
   {
      WBEM_VALIDATE_IN_STRING_PTR(strObjectPath);
      WBEM_VALIDATE_INTF_PTR(pCtx);
      WBEM_VALIDATE_INTF_PTR(pResponseHandler);

      //
      // Determine which class is being requested.
      // A valid class object path has the form: class_name.key_name="key_value"
      //

      TrustMonClass Class = GetClass(strObjectPath);

      if (NO_CLASS == Class)
      {
         hr = WBEM_E_INVALID_OBJECT_PATH;
         BREAK_ON_FAIL(hr);
      }

      // Isolate the class name from the key name
      //

      PWSTR pwzInstance;
      PWSTR pwzKeyName = wcschr(strObjectPath, L'.');

      if (pwzKeyName)
      {
         // A request without a key name is only valid for a class that
         // is defined to have zero or only one dynamic instance (singleton).
         //
         // Isolate the key name from the class name
         //
         *pwzKeyName = L'\0'; // overwrite the period with a null
         pwzKeyName++;        // point to the first char of the key name
      }

      switch (Class)
      {
      case CLASS_PROVIDER:
         //
         // The provider class has no dynamic instances, return a copy of the
         // static instance.
         //
         fReverted = TRUE; // never impersonated

         hr = CreateAndSendProv(pResponseHandler);

         BREAK_ON_FAIL(hr);

         break;

      case CLASS_TRUST:
         //
         // There can be zero or more trusts. Thus the key name and value must
         // be specified.
         //
         CoImpersonateClient();

         if (!pwzKeyName)
         {
            hr = WBEM_E_INVALID_OBJECT_PATH;
            BREAK_ON_FAIL(hr);
         }

         pwzInstance = wcschr(pwzKeyName, L'=');

         if (!pwzInstance || L'\"' != pwzInstance[1])
         {
            // No equal sign found or the following char not a quote.
            //
            hr = WBEM_E_INVALID_OBJECT_PATH;
            BREAK_ON_FAIL(hr);
         }

         *pwzInstance = L'\0'; // isolate the key name.

         if (_wcsicmp(pwzKeyName, CSTR_PROP_TRUSTED_DOMAIN) != 0)
         {
            // Key name not correct.
            //
            hr = WBEM_E_INVALID_OBJECT_PATH;
            BREAK_ON_FAIL(hr);
         }

         pwzInstance++; // point to the first quote

         if (L'\0' == pwzInstance[1] || L'\"' == pwzInstance[1])
         {
            // No char following the quote or the next char a second quote
            //
            hr = WBEM_E_INVALID_OBJECT_PATH;
            BREAK_ON_FAIL(hr);
         }

         pwzInstance++; // point to the first char of the instance value;

         PWSTR pwzInstEnd;

         pwzInstEnd = wcschr(pwzInstance, L'\"');

         if (!pwzInstEnd)
         {
            // No terminating quote.
            //
            hr = WBEM_E_INVALID_OBJECT_PATH;
            BREAK_ON_FAIL(hr);
         }

         *pwzInstEnd = L'\0'; // replace ending quote with a null

         if (m_DomainInfo.IsTrustListStale(m_liTrustEnumMaxAge))
         {
            hr = m_DomainInfo.EnumerateTrusts();
         }

         BREAK_ON_FAIL(hr);

         pTrust = m_DomainInfo.FindTrust(pwzInstance);

         BREAK_ON_NULL_(pTrust, hr, WBEM_E_INVALID_OBJECT_PATH);

         //
         // Verify the trust.
         //
         if (pTrust->IsVerificationStale(m_liVerifyMaxAge))
         {
            pTrust->Verify(GetTrustCheckLevel());
         }

         CoRevertToSelf();
         fReverted = TRUE;

         //
         // Create a new instance of the object
         //
         hr = CreateAndSendTrustInst(*pTrust,
                                     m_sipClassDefTrustStatus,
                                     pResponseHandler);
         BREAK_ON_FAIL(hr);

         break;

      case CLASS_LOCAL:
         //
         // The local domain info class has only one instance, return that.
         //
         fReverted = TRUE; // never impersonated

         hr = m_DomainInfo.CreateAndSendInst(pResponseHandler);

         BREAK_ON_FAIL(hr);

         break;

      default:
         hr = WBEM_E_INVALID_OBJECT_PATH;
         BREAK_ON_FAIL(hr);
      }

   } while(FALSE);

   if (!fReverted)
   {
      CoRevertToSelf();
   }

	return pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPrv::IWbemServices::CreateInstanceEnumAsync
//
//  Synopsis:   Start an asyncronous enumeration of the instances of the class.
//
//  Returns:    WMI error codes
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTrustPrv::CreateInstanceEnumAsync( 
        IN const BSTR strClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
{
   TRACE(L"\nCTrustsPrv::CreateInstanceEnumAsync:\n"
         L"\tClass param = %s, flags = 0x%08x\n", strClass, lFlags);

   HRESULT hr = WBEM_S_NO_ERROR;

   do
   {
      WBEM_VALIDATE_IN_STRING_PTR(strClass);
      WBEM_VALIDATE_INTF_PTR(pCtx);
      WBEM_VALIDATE_INTF_PTR(pResponseHandler);

      //
      // Determine which class is being requested.
      // A valid class object path has the form: class_name.key_name="key_value"
      //

      TrustMonClass Class = GetClass(strClass);

      if (NO_CLASS == Class)
      {
         hr = WBEM_E_INVALID_OBJECT_PATH;
         BREAK_ON_FAIL(hr);
      }

      CAsyncCallWorker * pWorker;

      switch (Class)
      {
      case CLASS_PROVIDER:
         //
         // The provider class has no dynamic instances, return a copy of the
         // static instance.
         //

         hr = CreateAndSendProv(pResponseHandler);

         BREAK_ON_FAIL(hr);

         hr = pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);

         BREAK_ON_FAIL(hr);

         break;

      case CLASS_TRUST:
         //
         // Spawn the worker thread to enum and return the trust instances.
         // Note that the class definition pointer is not add-ref'd here
         // because it is add-ref'd separately in the CAsyncCallWorker ctor.
         //
         pWorker = new CAsyncCallWorker(this,
                                        lFlags,
                                        m_sipClassDefTrustStatus,
                                        pResponseHandler);

         BREAK_ON_NULL_(pWorker, hr, WBEM_E_OUT_OF_MEMORY);
         uintptr_t hThread;

         hThread = _beginthread(CAsyncCallWorker::CreateInstEnum, 0, (PVOID)pWorker);

         BREAK_ON_NULL_(hThread != -1, hr, WBEM_E_OUT_OF_MEMORY);

         break;

      case CLASS_LOCAL:
         //
         // The local domain info class has only one instance, return that.
         //

         hr = m_DomainInfo.CreateAndSendInst(pResponseHandler);

         BREAK_ON_FAIL(hr);

         hr = pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);

         BREAK_ON_FAIL(hr);

         break;

      default:
         hr = WBEM_E_INVALID_OBJECT_PATH;
         BREAK_ON_FAIL(hr);
      }

   } while(FALSE);

   if (FAILED(hr))
   {
       return pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hr, NULL, NULL);
   }

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustPrv::CreateAndSendProv
//
//  Synopsis:  Return the provider parameters.
//
//-----------------------------------------------------------------------------
HRESULT
CTrustPrv::CreateAndSendProv(IWbemObjectSink * pResponseHandler)
{
   TRACE(L"CTrustsPrv::CreateAndSendProv:\n");
   HRESULT hr = WBEM_S_NO_ERROR;

   do
   {
      CComPtr<IWbemClassObject> ipNewInst;
      VARIANT var;
      VariantInit(&var);

      //
      // Create a new instance of the WMI class object
      //
      hr = m_sipClassDefTrustProvider->SpawnInstance(0, &ipNewInst);

      BREAK_ON_FAIL;
      
      // Set the TrustListLifetime property value
      var.lVal = (long)GetTrustListLifetime();
      var.vt = VT_I4;
      hr = ipNewInst->Put(CSTR_PROP_TRUST_LIST_LIFETIME, 0, &var, 0);
      TRACE(L"\tTrustListLifetime %d\n", var.bstrVal);
      BREAK_ON_FAIL;

      // Set the TrustStatusLifetime property value
      var.lVal = (long)GetTrustStatusLifetime();
      hr = ipNewInst->Put(CSTR_PROP_TRUST_STATUS_LIFETIME, 0, &var, 0);
      TRACE(L"\tTrustStatusLifetime %d\n", var.bstrVal);
      BREAK_ON_FAIL;

      // Set the TrustCheckLevel property value
      var.lVal = (long)GetTrustCheckLevel();
      hr = ipNewInst->Put(CSTR_PROP_TRUST_CHECK_LEVEL, 0, &var, 0);
      TRACE(L"\tTrustCheckLevel %d\n", var.bstrVal);
      BREAK_ON_FAIL;

      // Set the ReturnAll property value
      var.boolVal = (GetReturnAll()) ? VARIANT_TRUE : VARIANT_FALSE;
      var.vt = VT_BOOL;
      hr = ipNewInst->Put(CSTR_PROP_RETURN_ALL_TRUSTS, 0, &var, 0);
      TRACE(L"\tReturnAll %d\n", var.bstrVal);
      BREAK_ON_FAIL;

      //
      // Send the object to the caller
      //
      // [In] param, no need to addref.

      IWbemClassObject * pNewInstance = ipNewInst;

      hr = pResponseHandler->Indicate(1, &pNewInstance);

      BREAK_ON_FAIL;

   } while(FALSE);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiprov\trustmon\trustprv.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service domain trust verification WMI provider
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       TrustPrv.h
//
//  Contents:   WMI provider class definition
//
//  Classes:    
//
//  History:    22-Mar-00 EricB created
//
//-----------------------------------------------------------------------------

#if !defined(_TRUSTPRV_H_INCLUDED_)
#define _TRUSTPRV_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h" // resource defines
#include "msg.h"

#define TM_PROV_NAME L"TrustMonitor"

extern PCWSTR CLASSNAME_STRING_PROVIDER;
extern PCWSTR CLASSNAME_STRING_TRUST;
extern PCWSTR CLASSNAME_STRING_LOCAL;

enum TrustMonClass {NO_CLASS, CLASS_PROVIDER, CLASS_TRUST, CLASS_LOCAL};
enum TrustCheckLevel {DONT_VERIFY = 0, SC_QUERY, PW_VERIFY, SC_RESET};
const DWORD MaxCheckLevel = (DWORD)SC_RESET; // update this if new check levels added

EXTERN_C const CLSID CLSID_TrustMonProvider;

const unsigned long TRUSTMON_FILETIMES_PER_MILLISECOND = 10000;
const DWORD TRUSTMON_FILETIMES_PER_SECOND = 1000 * TRUSTMON_FILETIMES_PER_MILLISECOND;
const __int64 TRUSTMON_FILETIMES_PER_MINUTE = 60 * (__int64)TRUSTMON_FILETIMES_PER_SECOND;
const __int64 TRUSTMON_FILETIMES_PER_HOUR = 60 * (__int64)TRUSTMON_FILETIMES_PER_MINUTE;

const __int64 TRUSTMON_DEFAULT_ENUM_AGE = 20 * TRUSTMON_FILETIMES_PER_MINUTE;
const __int64 TRUSTMON_DEFAULT_VERIFY_AGE = 3 * TRUSTMON_FILETIMES_PER_MINUTE;

const TrustCheckLevel DEFAULT_TRUST_CHECK_LEVEL = PW_VERIFY;

class CAsyncCallWorker; // forward declaration

//+----------------------------------------------------------------------------
//
// Class:   CTrustPrv
//
//-----------------------------------------------------------------------------

class CTrustPrv : 
   public IWbemServices,
   public IWbemProviderInit,
   public IWbemObjectSink,
   public CComObjectRoot,
   public CComCoClass<CTrustPrv, &CLSID_TrustMonProvider>
{
public:
   CTrustPrv(void);
   ~CTrustPrv(void);

BEGIN_COM_MAP(CTrustPrv)
   COM_INTERFACE_ENTRY(IWbemServices)
   COM_INTERFACE_ENTRY(IWbemProviderInit)
   COM_INTERFACE_ENTRY(IWbemObjectSink)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CTrustPrv) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_TrustPrv)

   //
   // IWbemProviderInit
   //

   STDMETHOD(Initialize)(
        IN LPWSTR pszUser,
        IN LONG lFlags,
        IN LPWSTR pszNamespace,
        IN LPWSTR pszLocale,
        IN IWbemServices *pNamespace,
        IN IWbemContext *pCtx,
        IN IWbemProviderInitSink *pInitSink);

   //
   // IWbemServices
   //

   // +++ Implemented +++

   STDMETHOD(GetObjectAsync)( 
       IN const BSTR strObjectPath,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler);

   STDMETHOD(CreateInstanceEnumAsync)( 
       IN const BSTR strClass,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler);

   // --- NOT Implemented ---

   STDMETHOD(OpenNamespace)( 
       IN const BSTR strNamespace,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN OUT IWbemServices **ppWorkingNamespace,
       IN OUT IWbemCallResult **ppResult)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(CancelAsyncCall)( 
       IN IWbemObjectSink *pSink)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(QueryObjectSink)( 
       IN long lFlags,
       OUT IWbemObjectSink **ppResponseHandler)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(GetObject)( 
       IN const BSTR strObjectPath,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN OUT IWbemClassObject **ppObject,
       IN OUT IWbemCallResult **ppCallResult)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(PutClass)( 
       IN IWbemClassObject *pObject,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN OUT IWbemCallResult **ppCallResult)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(PutClassAsync)( 
       IN IWbemClassObject *pObject,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(DeleteClass)( 
       IN const BSTR strClass,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN OUT IWbemCallResult **ppCallResult)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(DeleteClassAsync)( 
       IN const BSTR strClass,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(CreateClassEnum)( 
       IN const BSTR strSuperclass,
       IN long lFlags,
       IN IWbemContext *pCtx,
       OUT IEnumWbemClassObject **ppEnum)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(CreateClassEnumAsync)( 
       IN const BSTR strSuperclass,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(PutInstance)( 
       IN IWbemClassObject *pInst,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN OUT IWbemCallResult **ppCallResult)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(PutInstanceAsync)( 
       IN IWbemClassObject *pInst,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(DeleteInstance)( 
       IN const BSTR strObjectPath,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN OUT IWbemCallResult **ppCallResult)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(DeleteInstanceAsync)( 
       IN const BSTR strObjectPath,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(CreateInstanceEnum)( 
       IN const BSTR strClass,
       IN long lFlags,
       IN IWbemContext *pCtx,
       OUT IEnumWbemClassObject **ppEnum)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(ExecQuery)( 
       IN const BSTR strQueryLanguage,
       IN const BSTR strQuery,
       IN long lFlags,
       IN IWbemContext *pCtx,
       OUT IEnumWbemClassObject **ppEnum)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(ExecQueryAsync)( 
       IN const BSTR strQueryLanguage,
       IN const BSTR strQuery,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(ExecNotificationQuery)( 
       IN const BSTR strQueryLanguage,
       IN const BSTR strQuery,
       IN long lFlags,
       IN IWbemContext *pCtx,
       OUT IEnumWbemClassObject **ppEnum)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(ExecNotificationQueryAsync)( 
       IN const BSTR strQueryLanguage,
       IN const BSTR strQuery,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemObjectSink *pResponseHandler)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(ExecMethod)( 
       IN const BSTR strObjectPath,
       IN const BSTR strMethodName,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemClassObject *pInParams,
       IN OUT IWbemClassObject **ppOutParams,
       IN OUT IWbemCallResult **ppCallResult)
       { return WBEM_E_NOT_SUPPORTED; };

   STDMETHOD(ExecMethodAsync)( 
       IN const BSTR strObjectPath,
       IN const BSTR strMethodName,
       IN long lFlags,
       IN IWbemContext *pCtx,
       IN IWbemClassObject *pInParams,
       IN IWbemObjectSink *pResponseHandler)
       {return WBEM_E_NOT_SUPPORTED;};

   //
   // IWbemObjectSink
   //
   STDMETHOD(Indicate)(
      IN LONG lObjectCount,
      IN IWbemClassObject ** rgpObjArray);

   STDMETHOD(SetStatus)(
      IN LONG lFlags,
      IN HRESULT hr,
      IN BSTR strParam,
      IN IWbemClassObject * pObj)
      {TRACE(L"CTrustPrv::SetStatus\n");
       return WBEM_NO_ERROR;};

   void  SetTrustListLifetime(DWORD dwMins) {m_liTrustEnumMaxAge.QuadPart = dwMins * TRUSTMON_FILETIMES_PER_MINUTE;}
   DWORD GetTrustListLifetime(void) {return (DWORD)(m_liTrustEnumMaxAge.QuadPart / TRUSTMON_FILETIMES_PER_MINUTE);}
   void  SetTrustStatusLifetime(DWORD dwMins) {m_liVerifyMaxAge.QuadPart = dwMins * TRUSTMON_FILETIMES_PER_MINUTE;}
   DWORD GetTrustStatusLifetime(void) {return (DWORD)(m_liVerifyMaxAge.QuadPart / TRUSTMON_FILETIMES_PER_MINUTE);}
   void  SetTrustCheckLevel(DWORD dwLevel) {if (dwLevel > MaxCheckLevel) dwLevel = MaxCheckLevel; m_TrustCheckLevel = (TrustCheckLevel)dwLevel;}
   TrustCheckLevel GetTrustCheckLevel(void) {return m_TrustCheckLevel;}
   void  SetReturnAll(BOOL fReturnAll) {m_fReturnAllTrusts = fReturnAll;}
   BOOL  GetReturnAll(void) {return m_fReturnAllTrusts;}
   HRESULT SetProviderProps(IWbemClassObject * pClass);

protected:
   CComPtr<IWbemServices>      m_sipNamespace;
   CComPtr<IWbemClassObject>   m_sipClassDefTrustProvider;
   CComPtr<IWbemClassObject>   m_sipClassDefTrustStatus;

   friend class CAsyncCallWorker;

private:

   HRESULT CreateAndSendProv(IWbemObjectSink * pResponseHandler);

   CDomainInfo     m_DomainInfo;

   HANDLE          m_hMutex;
   LARGE_INTEGER   m_liTrustEnumMaxAge;
   LARGE_INTEGER   m_liVerifyMaxAge;
   TrustCheckLevel m_TrustCheckLevel;
   BOOL            m_fReturnAllTrusts;

   BOOL            m_fRegisteredForChanges;
};

//+----------------------------------------------------------------------------
//
//  class CAsyncCallWorker
//
//-----------------------------------------------------------------------------
class CAsyncCallWorker
{
public:
   CAsyncCallWorker(CTrustPrv * pTrustsImpl,
                    long lFlags,
                    IWbemClassObject * pClassDef,
                    IWbemObjectSink * pResponseHandler,
                    LPWSTR pwzInstanceName = NULL);
   ~CAsyncCallWorker();

   static VOID __cdecl CreateInstEnum(PVOID pParam);
   static VOID __cdecl GetObj(PVOID pParam);

private:
   CComPtr<CTrustPrv>          m_sipTrustPrv;
   CComPtr<IWbemObjectSink>    m_sipResponseHandler;
   CComPtr<IWbemClassObject>   m_sipClassDef;
   LPWSTR                      m_pwzInstanceName;
   long                        m_lFlags;
};

HRESULT CreateAndSendTrustInst(CTrustInfo & Trust,
                               IWbemClassObject * pClassDef,
                               IWbemObjectSink * pResponseHandler);

#define CHECK_HRESULT(hr, x) \
   if (FAILED(hr)) { \
      TRACE(L"***ERROR 0x%08x at %S line: %d\n", hr, __FILE__, __LINE__); \
      x; }

VOID WINAPI DoMofComp(HWND hWndParent,
                      HINSTANCE hModule,
                      PCTSTR ptzCommandLine,
                      INT nShowCmd);

#endif // !defined(_TRUSTPRV_H_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\dlgfilterproperties.cpp ===
//-------------------------------------------------------------------------
// File: DlgFilterProperties.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "DlgFilterProperties.h"

CFilterPropertiesDlg * g_pFilterProperties =  NULL;

//-------------------------------------------------------------------------

INT_PTR CALLBACK FilterPropertiesDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pFilterProperties)
	{
		return g_pFilterProperties->FilterPropertiesDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CFilterPropertiesDlg::CFilterPropertiesDlg(IWbemServices * pIWbemServices, IWbemClassObject * pIWbemClassObject)
{
	_ASSERT(pIWbemServices);
	_ASSERT(pIWbemClassObject);

	m_hWnd = NULL;
	m_hwndRulesListView = NULL;

	m_pIWbemServices = pIWbemServices;
	m_pIWbemServices->AddRef();

	m_pIWbemClassObject = pIWbemClassObject;
	m_pIWbemClassObject->AddRef();
}

//-------------------------------------------------------------------------

CFilterPropertiesDlg::~CFilterPropertiesDlg()
{
	NTDM_RELEASE_IF_NOT_NULL(m_pIWbemClassObject);
	NTDM_RELEASE_IF_NOT_NULL(m_pIWbemServices);
}

//-------------------------------------------------------------------------

INT_PTR CALLBACK CFilterPropertiesDlg::FilterPropertiesDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
				case IDOK:
				case IDCANCEL:
					EndDialog(m_hWnd, 0);
					return TRUE;
				}

				break;
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CFilterPropertiesDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	CComBSTR bstrTemp;

	NTDM_BEGIN_METHOD()

	// Set all the properties
	ShowProperty(m_pIWbemClassObject, _T("Name"), IDC_NAME);
	ShowProperty(m_pIWbemClassObject, _T("Author"), IDC_AUTHOR);
	ShowProperty(m_pIWbemClassObject, _T("SourceOrganization"), IDC_SOURCE_ORGANIZATION);
	ShowProperty(m_pIWbemClassObject, _T("CreationDate"), IDC_CREATION_DATE);
	ShowProperty(m_pIWbemClassObject, _T("ChangeDate"), IDC_CHANGE_DATE);
	ShowProperty(m_pIWbemClassObject, _T("DsPath"), IDC_DSPATH);
	ShowProperty(m_pIWbemClassObject, _T("ID"), IDC_ID);

	//Initialize the ListView Control
	m_hwndRulesListView = GetDlgItem(m_hWnd, IDC_RULES);
	NTDM_ERR_IF_NULL(m_hwndRulesListView);

	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_QUERY);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndRulesListView, 0, &lvColumn));

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_QUERY_LANGUAGE);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndRulesListView, 1, &lvColumn));

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_TARGET_NAMESPACE);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndRulesListView, 2, &lvColumn));

	PopulateRulesList();

	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndRulesListView, 0, LVSCW_AUTOSIZE_USEHEADER));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndRulesListView, 1, LVSCW_AUTOSIZE_USEHEADER));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndRulesListView, 2, LVSCW_AUTOSIZE_USEHEADER));

	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CFilterPropertiesDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	ClearRulesList();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CFilterPropertiesDlg::ClearRulesList()
{
	HRESULT hr;
	LVITEM lvItem;
	long lCount;

	NTDM_BEGIN_METHOD()

	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndRulesListView);

	while(lCount > 0)
	{
		lCount--;

		lvItem.iItem = lCount;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndRulesListView, &lvItem));

		if(lvItem.lParam)
		{
			((IWbemClassObject *)lvItem.lParam)->Release();
		}
	}

	ListView_DeleteAllItems(m_hwndRulesListView);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CFilterPropertiesDlg::PopulateRulesList()
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE vType;
	SAFEARRAY *psaRules = NULL;
	long lLower, lUpper, i;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(m_pIWbemClassObject->Get(_T("Rules"), 0, &vValue, &vType, NULL));

	// Value should be an array
	if(V_VT(&vValue) != (VT_UNKNOWN | VT_ARRAY))
	{
		NTDM_EXIT(E_FAIL);
	}

	psaRules = V_ARRAY(&vValue);
	NTDM_ERR_IF_FAIL(SafeArrayGetUBound(psaRules, 1, &lUpper));
	NTDM_ERR_IF_FAIL(SafeArrayGetLBound(psaRules, 1, &lLower));

	for(i=lLower; i<=lUpper; i++)
	{
		IUnknown * pUnk = NULL;
		CComPtr<IWbemClassObject> pIRulesClassObject;

		NTDM_ERR_IF_FAIL(SafeArrayGetElement(psaRules, &i, (void *)&pUnk));
		NTDM_ERR_IF_FAIL(pUnk->QueryInterface(IID_IWbemClassObject, (void **)&pIRulesClassObject));

		// Show Properties of this rule.
		NTDM_ERR_IF_FAIL(AddItemToList(pIRulesClassObject));
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CFilterPropertiesDlg::AddItemToList(IWbemClassObject * pIWbemClassObject)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE vType;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()


	NTDM_ERR_IF_FAIL(pIWbemClassObject->Get(_T("Query"), 0, &vValue, &vType, NULL));
	lvItem.mask = LVIF_TEXT|LVIF_PARAM;
	lvItem.iSubItem = 0;
	lvItem.pszText = vValue.bstrVal;
	lvItem.lParam = (LPARAM)pIWbemClassObject;

	lvItem.iItem = ListView_InsertItem(m_hwndRulesListView, &lvItem);
	NTDM_ERR_IF_MINUSONE(lvItem.iItem);

	NTDM_ERR_IF_FAIL(pIWbemClassObject->Get(_T("QueryLanguage"), 0, &vValue, &vType, NULL));
	lvItem.mask = LVIF_TEXT;
	lvItem.iSubItem = 1;
	lvItem.pszText = vValue.bstrVal;

	NTDM_ERR_IF_MINUSONE(ListView_SetItem(m_hwndRulesListView, &lvItem));

	NTDM_ERR_IF_FAIL(pIWbemClassObject->Get(_T("TargetNamespace"), 0, &vValue, &vType, NULL));
	lvItem.mask = LVIF_TEXT;
	lvItem.iSubItem = 2;
	lvItem.pszText = vValue.bstrVal;

	NTDM_ERR_IF_MINUSONE(ListView_SetItem(m_hwndRulesListView, &lvItem));


	pIWbemClassObject->AddRef();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CFilterPropertiesDlg::ShowProperty(IWbemClassObject * pIWbemClassObject, LPCTSTR pszPropertyName, long lResID)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE vType;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(pIWbemClassObject->Get(pszPropertyName, 0, &vValue, &vType, NULL));
	NTDM_ERR_IF_FAIL(VariantChangeType(&vValue, &vValue, VARIANT_ALPHABOOL|VARIANT_LOCALBOOL, VT_BSTR));

	SetDlgItemText(m_hWnd, lResID, (LPCTSTR)V_BSTR(&vValue));

	NTDM_END_METHOD()

	// cleanup

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\editpropertydlgs.cpp ===
//-------------------------------------------------------------------------
// File: EditPropertyDlgs.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "EditPropertyDlgs.h"


CEditStringPropertyDlg * g_pEditStringPropertyDlg =  NULL;
INT_PTR CALLBACK EditStringPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
CEditNumberPropertyDlg * g_pEditNumberPropertyDlg =  NULL;
INT_PTR CALLBACK EditNumberPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
CEditRulesPropertyDlg * g_pEditRulesPropertyDlg =  NULL;
INT_PTR CALLBACK EditRulesPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
CEditRulePropertyDlg * g_pEditRulePropertyDlg =  NULL;
INT_PTR CALLBACK EditRulePropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
CEditRangeParametersPropertyDlg * g_pEditRangeParametersPropertyDlg =  NULL;
INT_PTR CALLBACK EditRangeParametersPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
CEditRangeParameterPropertyDlg * g_pEditRangeParameterPropertyDlg =  NULL;
INT_PTR CALLBACK EditRangeParameterPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);

//-------------------------------------------------------------------------
// CEditPropertyDlg
//-------------------------------------------------------------------------

CEditProperty::CEditProperty(HWND hWndParent, LPCTSTR pszName, LPCTSTR pszType, VARIANT *pvValue, IWbemServices *pIWbemServices, long lSpecialCaseProperty)
{
	_ASSERT(pvValue);

	m_hWnd = hWndParent;
	pvSrcValue = pvValue;
	m_bstrName = pszName;
	m_bstrType = pszType;
	m_lSpecialCaseProperty = lSpecialCaseProperty;
	m_pIWbemServices = pIWbemServices;
}

//-------------------------------------------------------------------------

CEditProperty::~CEditProperty()
{
}


//---------------------------------------------------------------------------

long CEditProperty::Run()
{
	HRESULT hr;
	long lRetVal = IDCANCEL;
	VARIANT * pvTemp = NULL;
	long vtType;

	NTDM_BEGIN_METHOD()

	vtType = V_VT(pvSrcValue);

	if(VT_EMPTY == vtType || VT_NULL == vtType)
	{
		CNTDMUtils::GetVariantTypeFromString(m_bstrType, &vtType);
	}
	else if(m_lSpecialCaseProperty == psc_rule)
	{
		CComPtr<IWbemClassObject>pIWbemClassObject; 

		CEditRulePropertyDlg * pOld = g_pEditRulePropertyDlg;

		NTDM_ERR_MSG_IF_FAIL((V_UNKNOWN(pvSrcValue))->QueryInterface(IID_IWbemClassObject, (void **)&pIWbemClassObject));
		
		NTDM_ERR_IF_NULL((g_pEditRulePropertyDlg = new CEditRulePropertyDlg(pIWbemClassObject)));
		lRetVal = DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_EDIT_RULE), (HWND)m_hWnd, EditRulePropertyDlgProc);
		NTDM_DELETE_OBJECT(g_pEditRulePropertyDlg);
		g_pEditRulePropertyDlg = pOld;
	}
	else if(m_lSpecialCaseProperty == psc_range)
	{
		CComPtr<IWbemClassObject>pIWbemClassObject; 

		CEditRangeParameterPropertyDlg * pOld = g_pEditRangeParameterPropertyDlg;

		NTDM_ERR_MSG_IF_FAIL((V_UNKNOWN(pvSrcValue))->QueryInterface(IID_IWbemClassObject, (void **)&pIWbemClassObject));
		
		NTDM_ERR_IF_NULL((g_pEditRangeParameterPropertyDlg = new CEditRangeParameterPropertyDlg(pIWbemClassObject, m_pIWbemServices)));
		lRetVal = DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_EDIT_RANGE_PARAMETER), (HWND)m_hWnd, EditRangeParameterPropertyDlgProc);
		if(IDOK == lRetVal)
		{
			VariantClear(pvSrcValue);
			VariantCopy(pvSrcValue, &g_pEditRangeParameterPropertyDlg->m_vValue);
		}

		NTDM_DELETE_OBJECT(g_pEditRangeParameterPropertyDlg);
		g_pEditRangeParameterPropertyDlg = pOld;
	}
	else if(VT_BSTR == vtType)
	{
		// string
		CEditStringPropertyDlg * pOld = g_pEditStringPropertyDlg;

		NTDM_ERR_IF_NULL((g_pEditStringPropertyDlg = new CEditStringPropertyDlg(m_bstrName, m_bstrType, pvSrcValue)));
		lRetVal = DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_EDIT_STRING_PROPERTY), (HWND)m_hWnd, EditStringPropertyDlgProc);
		if(IDOK == lRetVal)
		{
			VariantClear(pvSrcValue);
			VariantCopy(pvSrcValue, &g_pEditStringPropertyDlg->m_vValue);
		}

		NTDM_DELETE_OBJECT(g_pEditStringPropertyDlg);
		g_pEditStringPropertyDlg = pOld;
	}
	else if(VT_ARRAY & V_VT(pvSrcValue))
	{
		if(m_lSpecialCaseProperty == psc_rules)
		{
			// Rules
			CEditRulesPropertyDlg * pOld = g_pEditRulesPropertyDlg;

			NTDM_ERR_IF_NULL((g_pEditRulesPropertyDlg = new CEditRulesPropertyDlg(m_bstrName, m_bstrType, pvSrcValue, m_pIWbemServices)));
			
			lRetVal = DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_EDIT_RULES_PROPERTY), (HWND)m_hWnd, EditRulesPropertyDlgProc);
			if(IDOK == lRetVal)
			{
				VariantClear(pvSrcValue);
				VariantCopy(pvSrcValue, &g_pEditRulesPropertyDlg->m_vValue);
			}

			NTDM_DELETE_OBJECT(g_pEditRulesPropertyDlg);
			g_pEditRulesPropertyDlg = pOld;
		}
		else if(m_lSpecialCaseProperty == psc_ranges)
		{
			// Ranges
			CEditRangeParametersPropertyDlg * pOld = g_pEditRangeParametersPropertyDlg;

			NTDM_ERR_IF_NULL((g_pEditRangeParametersPropertyDlg = new CEditRangeParametersPropertyDlg(m_bstrName, m_bstrType, pvSrcValue, m_pIWbemServices)));
			lRetVal = DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_EDIT_RANGE_PARAMETERS_PROPERTY), (HWND)m_hWnd, EditRangeParametersPropertyDlgProc);
			if(IDOK == lRetVal)
			{
				VariantClear(pvSrcValue);
				VariantCopy(pvSrcValue, &g_pEditRangeParametersPropertyDlg->m_vValue);
			}

			NTDM_DELETE_OBJECT(g_pEditRangeParametersPropertyDlg);
			g_pEditRangeParametersPropertyDlg = pOld;
		}
	}

	NTDM_END_METHOD()

	// cleanup

	return lRetVal;
}

//-------------------------------------------------------------------------
// CEditPropertyDlg
//-------------------------------------------------------------------------

CEditPropertyDlg::CEditPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue)
{
	_ASSERT(pvValue);

	m_hWnd = NULL;
	pvSrcValue = pvValue;
	m_vValue = *pvValue;
	m_bstrName = pszName;
	m_bstrType = pszType;
}

//-------------------------------------------------------------------------

CEditPropertyDlg::~CEditPropertyDlg()
{
}


//---------------------------------------------------------------------------

STDMETHODIMP CEditPropertyDlg::InitializeDialog()
{
	HRESULT hr;
	
	NTDM_BEGIN_METHOD()

	SetDlgItemText(m_hWnd, IDC_NAME, m_bstrName);
	SetDlgItemText(m_hWnd, IDC_TYPE, m_bstrType);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPropertyDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//-------------------------------------------------------------------------
// CEditStringPropertyDlg
//-------------------------------------------------------------------------

INT_PTR CALLBACK EditStringPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pEditStringPropertyDlg)
	{
		return g_pEditStringPropertyDlg->EditStringPropertyDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CEditStringPropertyDlg::CEditStringPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue)
:CEditPropertyDlg(pszName, pszType, pvValue)
{
}

//-------------------------------------------------------------------------

CEditStringPropertyDlg::~CEditStringPropertyDlg()
{
}

//-------------------------------------------------------------------------

INT_PTR CALLBACK CEditStringPropertyDlg::EditStringPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
					case IDOK:
					{
						OnOK();
						return TRUE;
						break;
					}
					case IDCANCEL:
					{
						EndDialog(m_hWnd, IDCANCEL);
						return TRUE;
						break;
					}
				}

				break;
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditStringPropertyDlg::InitializeDialog()
{
	HRESULT hr;
	
	NTDM_BEGIN_METHOD()
	
	CEditPropertyDlg::InitializeDialog();

	// Set the string property
	SetDlgItemText(m_hWnd, IDC_VALUE, V_BSTR(&m_vValue));	

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditStringPropertyDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	CEditPropertyDlg::DestroyDialog();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditStringPropertyDlg::OnOK()
{
	HRESULT hr;
	long lLength;
	TCHAR *pszTemp = NULL;

	NTDM_BEGIN_METHOD()

	lLength = GetWindowTextLength(GetDlgItem(m_hWnd, IDC_VALUE));
	if(lLength < 0)
	{
		NTDM_EXIT(E_FAIL);
	}
	else if(0 == lLength)
	{
		m_vValue = _T("");
	}
	else
	{
		pszTemp = new TCHAR[lLength+1];
		if(!pszTemp)
		{
			NTDM_EXIT(E_OUTOFMEMORY);
		}

		NTDM_ERR_GETLASTERROR_IF_NULL(GetDlgItemText(m_hWnd, IDC_VALUE, pszTemp, lLength+1));

		m_vValue = pszTemp;

		NTDM_DELETE_OBJECT(pszTemp);
	}


	hr = S_OK;

	NTDM_END_METHOD()

	// cleanup

	NTDM_DELETE_OBJECT(pszTemp);

	if(SUCCEEDED(hr))
	{
		EndDialog(m_hWnd, IDOK);
	}

	return hr;
}

//-------------------------------------------------------------------------
// CEditNumberPropertyDlg
//-------------------------------------------------------------------------

INT_PTR CALLBACK EditNumberPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pEditNumberPropertyDlg)
	{
		return g_pEditNumberPropertyDlg->EditNumberPropertyDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CEditNumberPropertyDlg::CEditNumberPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue)
:CEditPropertyDlg(pszName, pszType, pvValue)
{
}

//-------------------------------------------------------------------------

CEditNumberPropertyDlg::~CEditNumberPropertyDlg()
{
}

//-------------------------------------------------------------------------

INT_PTR CALLBACK CEditNumberPropertyDlg::EditNumberPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
					case IDOK:
					{
						OnOK();
						return TRUE;
						break;
					}
					case IDCANCEL:
					{
						EndDialog(m_hWnd, IDCANCEL);
						return TRUE;
						break;
					}
				}

				break;
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditNumberPropertyDlg::InitializeDialog()
{
	HRESULT hr;
	
	NTDM_BEGIN_METHOD()
	
	CEditPropertyDlg::InitializeDialog();

	// Set the number property
	NTDM_ERR_GETLASTERROR_IF_NULL(SetDlgItemInt(m_hWnd, IDC_VALUE, V_I4(&m_vValue), FALSE));	

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditNumberPropertyDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	CEditPropertyDlg::DestroyDialog();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditNumberPropertyDlg::OnOK()
{
	HRESULT hr;
	long lValue;
	BOOL bTranslated;

	NTDM_BEGIN_METHOD()

	lValue = GetDlgItemInt(m_hWnd, IDC_VALUE, &bTranslated, FALSE);
	NTDM_ERR_GETLASTERROR_IF_FALSE(bTranslated);

	m_vValue = lValue;

	hr = S_OK;

	NTDM_END_METHOD()

	// cleanup
	if(SUCCEEDED(hr))
	{
		EndDialog(m_hWnd, IDOK);
	}

	return hr;
}

//-------------------------------------------------------------------------
// CEditRulesPropertyDlg
//-------------------------------------------------------------------------

INT_PTR CALLBACK EditRulesPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pEditRulesPropertyDlg)
	{
		return g_pEditRulesPropertyDlg->EditRulesPropertyDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CEditRulesPropertyDlg::CEditRulesPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue, IWbemServices *pIWbemServices)
:CEditPropertyDlg(pszName, pszType, pvValue)
{
	m_pIWbemServices = pIWbemServices;
}

//-------------------------------------------------------------------------

CEditRulesPropertyDlg::~CEditRulesPropertyDlg()
{
}

//-------------------------------------------------------------------------

INT_PTR CALLBACK CEditRulesPropertyDlg::EditRulesPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
					case IDOK:
					{
						OnOK();
						return TRUE;
						break;
					}
					case IDCANCEL:
					{
						EndDialog(m_hWnd, IDCANCEL);
						return TRUE;
						break;
					}
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_ADD == LOWORD(wParam))
				{
					OnAdd();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EDIT == LOWORD(wParam))
				{
					OnEdit();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_DELETE == LOWORD(wParam))
				{
					OnDelete();
					return TRUE;
				}

				break;
			}

		case WM_NOTIFY:
			{
				LPNMHDR lpnm = (LPNMHDR) lParam;

				switch (lpnm->code)
				{
					case NM_DBLCLK :
					{
						if(lpnm->idFrom == IDC_FILTER_ELEMENTS_LIST)
						{
							OnEdit();
							return TRUE;
						}
						break;
					}

					default :
						break;
				}
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	CComBSTR bstrName;

	NTDM_BEGIN_METHOD()
	
	CEditPropertyDlg::InitializeDialog();

	bstrName.LoadString(_Module.GetResourceInstance(), IDS_NAME);

	m_hwndListView = GetDlgItem(m_hWnd, IDC_FILTER_ELEMENTS_LIST);
	NTDM_ERR_IF_NULL(m_hwndListView);

	ListView_SetExtendedListViewStyle(m_hwndListView, LVS_EX_FULLROWSELECT);

	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.pszText = bstrName;

	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndListView, 0, &lvColumn));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndListView, 0, LVSCW_AUTOSIZE_USEHEADER));
	
	
	NTDM_ERR_IF_FAIL(PopulateItems());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::ClearItems()
{
	HRESULT hr;
	LVITEM lvItem;
	long lCount;

	NTDM_BEGIN_METHOD()

	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndListView);

	while(lCount > 0)
	{
		lCount--;

		lvItem.iItem = lCount;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			((IWbemClassObject *)lvItem.lParam)->Release();
		}
	}

	ListView_DeleteAllItems(m_hwndListView);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::PopulateItems()
{
	HRESULT hr;
	CComVariant vValue;
	SAFEARRAY *psaRules = NULL;
	long lLower, lUpper, i;
	
	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearItems());
	
	// Set the Rules property
	psaRules = V_ARRAY(&m_vValue);
	NTDM_ERR_MSG_IF_FAIL(SafeArrayGetUBound(psaRules, 1, &lUpper));
	NTDM_ERR_MSG_IF_FAIL(SafeArrayGetLBound(psaRules, 1, &lLower));

	for(i=lLower; i<=lUpper; i++)
	{
		if(V_VT(&m_vValue) & VT_UNKNOWN)
		{
			// Rules or UNKNOWNS (i.e. IWbemClassObjects)
			IUnknown * pUnk = NULL;
			CComPtr<IWbemClassObject> pIWbemClassObject;
			NTDM_ERR_MSG_IF_FAIL(SafeArrayGetElement(psaRules, &i, (void *)&pUnk));
			NTDM_ERR_MSG_IF_FAIL(pUnk->QueryInterface(IID_IWbemClassObject, (void **)&pIWbemClassObject));

			// Show Properties of this object
			NTDM_ERR_IF_FAIL(AddItemToList(pIWbemClassObject));
		}
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()


	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("Query"), 0, &vValue, &cimType, NULL));
	lvItem.iItem = lIndex;
	lvItem.mask = LVIF_TEXT|LVIF_PARAM;
	lvItem.iSubItem = 0;
	lvItem.pszText = vValue.bstrVal;
	lvItem.lParam = (LPARAM)pIWbemClassObject;

	lvItem.iItem = ListView_InsertItem(m_hwndListView, &lvItem);
	NTDM_ERR_IF_MINUSONE(lvItem.iItem);

	pIWbemClassObject->AddRef();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	CEditPropertyDlg::DestroyDialog();
	NTDM_ERR_IF_FAIL(ClearItems());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::OnEdit()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_RULE_SELECTED);
		goto error;
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			VARIANT vValue;
			VariantInit(&vValue);
			IWbemClassObject *pIWbemClassObject;

			pIWbemClassObject = (IWbemClassObject *)lvItem.lParam;

			V_VT(&vValue) = VT_UNKNOWN;
			pIWbemClassObject->QueryInterface(IID_IUnknown, (void **)&V_UNKNOWN(&vValue));
			
			CEditProperty editProp(m_hWnd, _T(""), _T(""), &vValue, m_pIWbemServices, CEditProperty::psc_rule);
			if(IDOK == editProp.Run())
			{
				ListView_DeleteItem(m_hwndListView, lSelectionMark);
				AddItemToList(pIWbemClassObject, lSelectionMark);

				pIWbemClassObject->Release();
			}
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::OnAdd()
{
	HRESULT hr;
	CComPtr<IWbemClassObject>pIWbemClassObject;
	CComPtr<IWbemClassObject>pIWbemNewInstance;
	VARIANT vValue;
	CComBSTR bstrTemp;

	NTDM_BEGIN_METHOD()

	bstrTemp = _T("MSFT_Rule");

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->GetObject(bstrTemp, 0, NULL, &pIWbemClassObject, NULL));
	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->SpawnInstance(0, &pIWbemNewInstance));

	VariantInit(&vValue);
	V_VT(&vValue) = VT_UNKNOWN;
	pIWbemNewInstance->QueryInterface(IID_IUnknown, (void **)&V_UNKNOWN(&vValue));
			
	CEditProperty editProp(m_hWnd, _T(""), _T(""), &vValue, m_pIWbemServices, CEditProperty::psc_rule);
	if(IDOK == editProp.Run())
	{
		AddItemToList(pIWbemNewInstance);
	}

	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::OnDelete()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_RULE_SELECTED);
		goto error;
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			IWbemClassObject *pIWbemClassObject = NULL;
			pIWbemClassObject = (IWbemClassObject *)lvItem.lParam;
			pIWbemClassObject->Release();

			ListView_DeleteItem(m_hwndListView, lSelectionMark);
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulesPropertyDlg::OnOK()
{
	HRESULT hr;
	VARIANT vValue;
	SAFEARRAY *psaRules = NULL;
	long lCount = 0;
	SAFEARRAYBOUND rgsaBound[1];
	long rgIndices[1];
	long i;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()

	VariantInit(&vValue);

	// Get the size of the array
	lCount = ListView_GetItemCount(m_hwndListView);

	rgsaBound[0].lLbound = 0;
	rgsaBound[0].cElements = lCount;

	psaRules = SafeArrayCreate(VT_UNKNOWN, 1, rgsaBound);
	
	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndListView);

	i=0;
	while(i < lCount)
	{
		IUnknown * pUnk = NULL;

		lvItem.iItem = i;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			NTDM_ERR_MSG_IF_FAIL(((IWbemClassObject *)lvItem.lParam)->QueryInterface(IID_IUnknown, (void**)&pUnk));

			rgIndices[0] = i;
			NTDM_ERR_MSG_IF_FAIL(SafeArrayPutElement(psaRules, rgIndices, pUnk));

			pUnk->Release();
		}

		i++;
	}

	VariantClear(&vValue);
	V_VT(&vValue) = VT_ARRAY|VT_UNKNOWN;
	V_ARRAY(&vValue) = psaRules;

	m_vValue.Clear();
	m_vValue.Copy(&vValue);

	//m_vValue = vValue;

	hr = S_OK;

	NTDM_END_METHOD()

	// cleanup

	VariantClear(&vValue);

	if(SUCCEEDED(hr))
	{
		EndDialog(m_hWnd, IDOK);
	}

	return hr;
}

//-------------------------------------------------------------------------
// CEditRulePropertyDlg
//-------------------------------------------------------------------------

INT_PTR CALLBACK EditRulePropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pEditRulePropertyDlg)
	{
		return g_pEditRulePropertyDlg->EditRulePropertyDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CEditRulePropertyDlg::CEditRulePropertyDlg(IWbemClassObject* pIWbemClassObject)
{
	m_pIWbemClassObject = pIWbemClassObject;
}

//-------------------------------------------------------------------------

CEditRulePropertyDlg::~CEditRulePropertyDlg()
{
}

//-------------------------------------------------------------------------

INT_PTR CALLBACK CEditRulePropertyDlg::EditRulePropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
					case IDOK:
					{
						OnOK();
						return TRUE;
						break;
					}
					case IDCANCEL:
					{
						EndDialog(m_hWnd, IDCANCEL);
						return TRUE;
						break;
					}
				}

				break;
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulePropertyDlg::InitializeDialog()
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("QueryLanguage"), 0, &vValue, &cimType, NULL));

	if(vValue.bstrVal)
	{
		SetDlgItemText(m_hWnd, IDC_QUERY_LANGUAGE, vValue.bstrVal);
	}

	vValue.Clear();
	
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("TargetNamespace"), 0, &vValue, &cimType, NULL));

	if(vValue.bstrVal)
	{
		SetDlgItemText(m_hWnd, IDC_TARGET_NAMESPACE, vValue.bstrVal);
	}
	
	vValue.Clear();

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("Query"), 0, &vValue, &cimType, NULL));

	if(vValue.bstrVal)
	{
		SetDlgItemText(m_hWnd, IDC_QUERY, vValue.bstrVal);
	}
	
	vValue.Clear();


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulePropertyDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRulePropertyDlg::OnOK()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	// Set the Properties
	NTDM_ERR_IF_FAIL(CNTDMUtils::SetStringProperty(m_pIWbemClassObject, _T("QueryLanguage"), m_hWnd, IDC_QUERY_LANGUAGE));
	NTDM_ERR_IF_FAIL(CNTDMUtils::SetStringProperty(m_pIWbemClassObject, _T("TargetNamespace"), m_hWnd, IDC_TARGET_NAMESPACE));
	NTDM_ERR_IF_FAIL(CNTDMUtils::SetStringProperty(m_pIWbemClassObject, _T("Query"), m_hWnd, IDC_QUERY));
	
	NTDM_END_METHOD()

	// cleanup
	if(SUCCEEDED(hr))
	{
		EndDialog(m_hWnd, IDOK);
	}

	return hr;
}

//-------------------------------------------------------------------------
// CEditRangeParametersPropertyDlg
//-------------------------------------------------------------------------

INT_PTR CALLBACK EditRangeParametersPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pEditRangeParametersPropertyDlg)
	{
		return g_pEditRangeParametersPropertyDlg->EditRangeParametersPropertyDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CEditRangeParametersPropertyDlg::CEditRangeParametersPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue, IWbemServices *pIWbemServices)
:CEditPropertyDlg(pszName, pszType, pvValue)
{
	m_pIWbemServices = pIWbemServices;
}

//-------------------------------------------------------------------------

CEditRangeParametersPropertyDlg::~CEditRangeParametersPropertyDlg()
{
}

//-------------------------------------------------------------------------

INT_PTR CALLBACK CEditRangeParametersPropertyDlg::EditRangeParametersPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
					case IDOK:
					{
						OnOK();
						return TRUE;
						break;
					}
					case IDCANCEL:
					{
						EndDialog(m_hWnd, IDCANCEL);
						return TRUE;
						break;
					}
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_ADD == LOWORD(wParam))
				{
					OnAdd();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EDIT == LOWORD(wParam))
				{
					OnEdit();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_DELETE == LOWORD(wParam))
				{
					OnDelete();
					return TRUE;
				}

				break;
			}

		case WM_NOTIFY:
			{
				LPNMHDR lpnm = (LPNMHDR) lParam;

				switch (lpnm->code)
				{
					case NM_DBLCLK :
					{
						if(lpnm->idFrom == IDC_RANGE_PARAMETER_LIST)
						{
							OnEdit();
							return TRUE;
						}
						break;
					}

					default :
						break;
				}
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	CComBSTR bstrName;

	NTDM_BEGIN_METHOD()
	
	CEditPropertyDlg::InitializeDialog();

	bstrName.LoadString(_Module.GetResourceInstance(), IDS_NAME);

	m_hwndListView = GetDlgItem(m_hWnd, IDC_RANGE_PARAMETER_LIST);
	NTDM_ERR_IF_NULL(m_hwndListView);

	ListView_SetExtendedListViewStyle(m_hwndListView, LVS_EX_FULLROWSELECT);

	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.pszText = bstrName;

	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndListView, 0, &lvColumn));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndListView, 0, LVSCW_AUTOSIZE_USEHEADER));
	
	
	NTDM_ERR_IF_FAIL(PopulateItems());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::ClearItems()
{
	HRESULT hr;
	LVITEM lvItem;
	long lCount;

	NTDM_BEGIN_METHOD()

	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndListView);

	while(lCount > 0)
	{
		lCount--;

		lvItem.iItem = lCount;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			((IWbemClassObject *)lvItem.lParam)->Release();
		}
	}

	ListView_DeleteAllItems(m_hwndListView);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::PopulateItems()
{
	HRESULT hr;
	CComVariant vValue;
	SAFEARRAY *psaRangeParameters = NULL;
	long lLower, lUpper, i;
	
	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearItems());
	
	// Set the RangeParameters property
	psaRangeParameters = V_ARRAY(&m_vValue);
	NTDM_ERR_MSG_IF_FAIL(SafeArrayGetUBound(psaRangeParameters, 1, &lUpper));
	NTDM_ERR_MSG_IF_FAIL(SafeArrayGetLBound(psaRangeParameters, 1, &lLower));

	for(i=lLower; i<=lUpper; i++)
	{
		if(V_VT(&m_vValue) & VT_UNKNOWN)
		{
			// RangeParameters or UNKNOWNS (i.e. IWbemClassObjects)
			IUnknown * pUnk = NULL;
			CComPtr<IWbemClassObject> pIWbemClassObject;
			NTDM_ERR_MSG_IF_FAIL(SafeArrayGetElement(psaRangeParameters, &i, (void *)&pUnk));
			NTDM_ERR_MSG_IF_FAIL(pUnk->QueryInterface(IID_IWbemClassObject, (void **)&pIWbemClassObject));

			// Show Properties of this object
			NTDM_ERR_IF_FAIL(AddItemToList(pIWbemClassObject));
		}
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()


	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("PropertyName"), 0, &vValue, &cimType, NULL));
	lvItem.iItem = lIndex;
	lvItem.mask = LVIF_TEXT|LVIF_PARAM;
	lvItem.iSubItem = 0;
	lvItem.pszText = vValue.bstrVal;
	lvItem.lParam = (LPARAM)pIWbemClassObject;

	lvItem.iItem = ListView_InsertItem(m_hwndListView, &lvItem);
	NTDM_ERR_IF_MINUSONE(lvItem.iItem);

	pIWbemClassObject->AddRef();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	CEditPropertyDlg::DestroyDialog();
	NTDM_ERR_IF_FAIL(ClearItems());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::OnEdit()
{
	HRESULT hr;
	long lSelectionMark;
	VARIANT vValue;

	NTDM_BEGIN_METHOD()

	VariantInit(&vValue);

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_RANGE_SELECTED);
		goto error;
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			IWbemClassObject *pIWbemClassObject;

			pIWbemClassObject = (IWbemClassObject *)lvItem.lParam;

			V_VT(&vValue) = VT_UNKNOWN;
			pIWbemClassObject->QueryInterface(IID_IUnknown, (void **)&V_UNKNOWN(&vValue));
			
			CEditProperty editProp(m_hWnd, _T(""), _T(""), &vValue, m_pIWbemServices, CEditProperty::psc_range);
			if(IDOK == editProp.Run())
			{
				NTDM_ERR_IF_FAIL(V_UNKNOWN(&vValue)->QueryInterface(IID_IWbemClassObject, (void **)&pIWbemClassObject));
				ListView_DeleteItem(m_hwndListView, lSelectionMark);
				AddItemToList(pIWbemClassObject, lSelectionMark);

				pIWbemClassObject->Release();
			}

		}
	}


	NTDM_END_METHOD()

	// cleanup
	VariantClear(&vValue);

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::OnAdd()
{
	HRESULT hr;
	long lSelectionMark;
	VARIANT vValue;
	VARIANT vValue2;
	CComPtr<IWbemClassObject>pIWbemClassObject;
	CComPtr<IWbemClassObject>pIWbemInstanceObject;
	CComBSTR bstrTemp;
	CIMTYPE cimType;

	NTDM_BEGIN_METHOD()

	VariantInit(&vValue);

	bstrTemp = _T("MSFT_SintRangeParam");

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->GetObject(bstrTemp, 0, NULL, &pIWbemClassObject, NULL));
	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->SpawnInstance(0, &pIWbemInstanceObject));

	// Set some default values
	cimType = CIM_SINT32;
	VariantInit(&vValue2);
	V_VT(&vValue2) = VT_I4;
	V_I4(&vValue2) = 5;
	NTDM_ERR_MSG_IF_FAIL(pIWbemInstanceObject->Put(_T("Default"), 0, &vValue2, cimType));
	V_I4(&vValue2) = 0;
	NTDM_ERR_MSG_IF_FAIL(pIWbemInstanceObject->Put(_T("Min"), 0, &vValue2, cimType));
	V_I4(&vValue2) = 10;
	NTDM_ERR_MSG_IF_FAIL(pIWbemInstanceObject->Put(_T("Max"), 0, &vValue2, cimType));

	cimType = CIM_UINT8;
	V_VT(&vValue2) = VT_UI1;
	V_UI1(&vValue2) = 0;
	NTDM_ERR_MSG_IF_FAIL(pIWbemInstanceObject->Put(_T("TargetType"), 0, &vValue2, cimType));

	V_VT(&vValue) = VT_UNKNOWN;
	pIWbemInstanceObject->QueryInterface(IID_IUnknown, (void **)&V_UNKNOWN(&vValue));
	
	CEditProperty editProp(m_hWnd, _T(""), _T(""), &vValue, m_pIWbemServices, CEditProperty::psc_range);
	if(IDOK == editProp.Run())
	{
		NTDM_ERR_IF_FAIL(V_UNKNOWN(&vValue)->QueryInterface(IID_IWbemClassObject, (void **)&pIWbemInstanceObject));
		AddItemToList(pIWbemInstanceObject);
	}

	NTDM_END_METHOD()

	// cleanup
	VariantClear(&vValue);
	VariantClear(&vValue2);

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::OnDelete()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_RULE_SELECTED);
		goto error;
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			IWbemClassObject *pIWbemClassObject = NULL;
			pIWbemClassObject = (IWbemClassObject *)lvItem.lParam;
			pIWbemClassObject->Release();

			ListView_DeleteItem(m_hwndListView, lSelectionMark);
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParametersPropertyDlg::OnOK()
{
	HRESULT hr;
	VARIANT vValue;
	SAFEARRAY *psaRangeParameters = NULL;
	long lCount = 0;
	SAFEARRAYBOUND rgsaBound[1];
	long rgIndices[1];
	long i;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()

	VariantInit(&vValue);

	// Get the size of the array
	lCount = ListView_GetItemCount(m_hwndListView);

	rgsaBound[0].lLbound = 0;
	rgsaBound[0].cElements = lCount;

	psaRangeParameters = SafeArrayCreate(VT_UNKNOWN, 1, rgsaBound);
	
	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndListView);

	i=0;
	while(i < lCount)
	{
		IUnknown * pUnk = NULL;

		lvItem.iItem = i;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			NTDM_ERR_MSG_IF_FAIL(((IWbemClassObject *)lvItem.lParam)->QueryInterface(IID_IUnknown, (void**)&pUnk));

			rgIndices[0] = i;
			NTDM_ERR_MSG_IF_FAIL(SafeArrayPutElement(psaRangeParameters, rgIndices, pUnk));

			pUnk->Release();
		}

		i++;
	}

	VariantClear(&vValue);
	V_VT(&vValue) = VT_ARRAY|VT_UNKNOWN;
	V_ARRAY(&vValue) = psaRangeParameters;

	m_vValue.Clear();
	m_vValue.Copy(&vValue);

	//m_vValue = vValue;

	hr = S_OK;

	NTDM_END_METHOD()

	// cleanup

	VariantClear(&vValue);

	if(SUCCEEDED(hr))
	{
		EndDialog(m_hWnd, IDOK);
	}

	return hr;
}

//-------------------------------------------------------------------------
// CEditRangeParameterPropertyDlg
//-------------------------------------------------------------------------

INT_PTR CALLBACK EditRangeParameterPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pEditRangeParameterPropertyDlg)
	{
		return g_pEditRangeParameterPropertyDlg->EditRangeParameterPropertyDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CEditRangeParameterPropertyDlg::CEditRangeParameterPropertyDlg(IWbemClassObject* pIWbemClassObject, IWbemServices* pIWbemServices)
{
	m_pIWbemClassObject = pIWbemClassObject;
	m_pIWbemServices = pIWbemServices;
}

//-------------------------------------------------------------------------

CEditRangeParameterPropertyDlg::~CEditRangeParameterPropertyDlg()
{
}

//-------------------------------------------------------------------------

INT_PTR CALLBACK CEditRangeParameterPropertyDlg::EditRangeParameterPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
					case IDOK:
					{
						OnOK();
						return TRUE;
						break;
					}
					case IDCANCEL:
					{
						EndDialog(m_hWnd, IDCANCEL);
						return TRUE;
						break;
					}
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_ADD == LOWORD(wParam))
				{
					OnAdd();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EDIT == LOWORD(wParam))
				{
					OnEdit();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_DELETE == LOWORD(wParam))
				{
					OnDelete();
					return TRUE;
				}

			
				if(CBN_SELCHANGE == HIWORD(wParam) && IDC_PARAMETER_TYPE == LOWORD(wParam))
				{
					ShowControls();
					return TRUE;
				}

				break;
			}

		case WM_NOTIFY:
			{
				LPNMHDR lpnm = (LPNMHDR) lParam;

				switch (lpnm->code)
				{
					case NM_DBLCLK :
					{
						if(lpnm->idFrom == IDC_RANGE_PARAMETER_LIST)
						{
							OnEdit();
							return TRUE;
						}
						break;
					}

					default :
						break;
				}
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::InitializeDialog()
{
	HRESULT hr;
	CComBSTR bstrName;
	CComVariant vValue;
	CIMTYPE cimType;
	CSimpleArray<BSTR> bstrArrayRangeTypes;
	long lIndex;

	NTDM_BEGIN_METHOD()
	
	bstrName.LoadString(_Module.GetResourceInstance(), IDS_NAME);

	m_hwndListView = GetDlgItem(m_hWnd, IDC_VALUES_SET_LIST);
	NTDM_ERR_IF_NULL(m_hwndListView);

	ListView_SetExtendedListViewStyle(m_hwndListView, LVS_EX_FULLROWSELECT);

	// Set the standard props for all types of ranges
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("PropertyName"), 0, &vValue, &cimType, NULL));
	if(vValue.bstrVal)
	{
		SetDlgItemText(m_hWnd, IDC_PROPERTY_NAME, vValue.bstrVal);
	}

	vValue.Clear();
	
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("TargetClass"), 0, &vValue, &cimType, NULL));
	if(vValue.bstrVal)
	{
		SetDlgItemText(m_hWnd, IDC_TARGET_CLASS, vValue.bstrVal);
	}

	vValue.Clear();
	
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("TargetType"), 0, &vValue, &cimType, NULL));
	SetDlgItemInt(m_hWnd, IDC_TARGET_TYPE, V_UI1(&vValue), FALSE);

	vValue.Clear();

	NTDM_ERR_IF_FAIL(CNTDMUtils::GetValuesInList((long)IDS_RANGE_NAMES, bstrArrayRangeTypes));
	lIndex = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_ADDSTRING, 0, (LPARAM)bstrArrayRangeTypes[0]);
	NTDM_CHECK_CB_ERR(lIndex);
	NTDM_CHECK_CB_ERR(SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETITEMDATA, lIndex, (LPARAM)rt_sintrange));
	
	lIndex = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_ADDSTRING, 0, (LPARAM)bstrArrayRangeTypes[1]);
	NTDM_CHECK_CB_ERR(lIndex);
	NTDM_CHECK_CB_ERR(SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETITEMDATA, lIndex, (LPARAM)rt_uintrange));
	
	lIndex = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_ADDSTRING, 0, (LPARAM)bstrArrayRangeTypes[2]);
	NTDM_CHECK_CB_ERR(lIndex);
	NTDM_CHECK_CB_ERR(SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETITEMDATA, lIndex, (LPARAM)rt_realrange));
	
	lIndex = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_ADDSTRING, 0, (LPARAM)bstrArrayRangeTypes[3]);
	NTDM_CHECK_CB_ERR(lIndex);
	NTDM_CHECK_CB_ERR(SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETITEMDATA, lIndex, (LPARAM)rt_sintset));
	
	lIndex = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_ADDSTRING, 0, (LPARAM)bstrArrayRangeTypes[4]);
	NTDM_CHECK_CB_ERR(lIndex);
	NTDM_CHECK_CB_ERR(SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETITEMDATA, lIndex, (LPARAM)rt_uintset));
	
	lIndex = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_ADDSTRING, 0, (LPARAM)bstrArrayRangeTypes[5]);
	NTDM_CHECK_CB_ERR(lIndex);
	NTDM_CHECK_CB_ERR(SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETITEMDATA, lIndex, (LPARAM)rt_stringset));

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("__CLASS"), 0, &vValue, &cimType, NULL));
	if(_tcscmp(_T("MSFT_SintRangeParam"), vValue.bstrVal) == 0)
	{
		SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETCURSEL, 0, 0);
		GetSintRangeValues();
	}
	else if(_tcscmp(_T("MSFT_UintRangeParam"), vValue.bstrVal) == 0)
	{
		SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETCURSEL, 1, 0);
		GetUintRangeValues();
	}
	else if(_tcscmp(_T("MSFT_RealRangeParam"), vValue.bstrVal) == 0)
	{
		SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETCURSEL, 2, 0);
		GetRealRangeValues();
	}
	else if(_tcscmp(_T("MSFT_SintSetParam"), vValue.bstrVal) == 0)
	{
		SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETCURSEL, 3, 0);
		GetSintSetValues();
	}
	else if(_tcscmp(_T("MSFT_UintSetParam"), vValue.bstrVal) == 0)
	{
		SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETCURSEL, 4, 0);
		GetUintSetValues();
	}
	else
	{
		SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_SETCURSEL, 5, 0);
		GetStringSetValues();
	}

	ShowControls();

	
	NTDM_ERR_IF_FAIL(PopulateItems());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::ClearItems()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	ListView_DeleteAllItems(m_hwndListView);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::PopulateItems()
{
	HRESULT hr;
	
	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearItems());
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()


	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("PropertyName"), 0, &vValue, &cimType, NULL));
	lvItem.iItem = lIndex;
	lvItem.mask = LVIF_TEXT|LVIF_PARAM;
	lvItem.iSubItem = 0;
	lvItem.pszText = vValue.bstrVal;
	lvItem.lParam = (LPARAM)pIWbemClassObject;

	lvItem.iItem = ListView_InsertItem(m_hwndListView, &lvItem);
	NTDM_ERR_IF_MINUSONE(lvItem.iItem);

	pIWbemClassObject->AddRef();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearItems());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::OnEdit()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_RANGE_SELECTED);
		goto error;
	}
	else
	{
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::OnAdd()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::OnDelete()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	ListView_DeleteItem(m_hwndListView, lSelectionMark);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::OnOK()
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;
	CComBSTR bstrTemp;
	long lIndex;
	long lValue;
	CComPtr<IWbemClassObject>pIWbemClassObject;

	NTDM_BEGIN_METHOD()

	// TODO: check values to make sure all are valid

	// delete the old instance : no need to do this just replace the element in the array
	//NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("__PATH"), 0, &vValue, &cimType, NULL));
	//NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->DeleteInstance(V_BSTR(&vValue), 0, NULL, NULL));
	m_pIWbemClassObject = NULL;

	// create a new instance of the range parameter based on the Range Type combo box selection
	lIndex = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_GETCURSEL, 0, 0);
	NTDM_CHECK_CB_ERR(lIndex);
	lValue = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_GETITEMDATA, lIndex, 0);
	if(lValue == rt_sintrange)
	{
		bstrTemp = _T("MSFT_SintRangeParam");
	}
	else if(lValue == rt_uintrange)
	{
		bstrTemp = _T("MSFT_UintRangeParam");
	}
	else if(lValue == rt_realrange)
	{
		bstrTemp = _T("MSFT_RealRangeParam");
	}
	else if(lValue == rt_sintset)
	{
		bstrTemp = _T("MSFT_SintSetParam");
	}
	else if(lValue == rt_uintset)
	{
		bstrTemp = _T("MSFT_UintSetParam");
	}
	else if(lValue == rt_stringset)
	{
		bstrTemp = _T("MSFT_StringSetParam");
	}
	
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->GetObject(bstrTemp, 0, NULL, &pIWbemClassObject, NULL));
	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->SpawnInstance(0, &m_pIWbemClassObject));

	NTDM_ERR_IF_FAIL(SetRangeParamValues());

	if(lValue == rt_sintrange)
	{
		SetSintRangeValues();
	}
	else if(lValue == rt_uintrange)
	{
		SetUintRangeValues();
	}
	else if(lValue == rt_realrange)
	{
		SetRealRangeValues();
	}
	else if(lValue == rt_sintset)
	{
		SetSintSetValues();
	}
	else if(lValue == rt_uintset)
	{
		SetSintSetValues();
	}
	else if(lValue == rt_stringset)
	{
		SetStringSetValues();
	}

	m_vValue.Clear();
	V_VT(&m_vValue) = VT_UNKNOWN;
	NTDM_ERR_IF_FAIL(m_pIWbemClassObject->QueryInterface(IID_IUnknown, (void **)&V_UNKNOWN(&m_vValue)));

	NTDM_END_METHOD()

	// cleanup
	if(SUCCEEDED(hr))
	{
		EndDialog(m_hWnd, IDOK);
	}

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::ShowControls()
{
	HRESULT hr;
	bool bShowMinMax;
	long lIndex;
	long lVal;

	lIndex = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_GETCURSEL, 0, 0);
	NTDM_CHECK_CB_ERR(lIndex);
	lVal = SendDlgItemMessage(m_hWnd, IDC_PARAMETER_TYPE, CB_GETITEMDATA, lIndex, 0);
	if(lVal == rt_sintrange || lVal == rt_uintrange || lVal == rt_realrange)
		bShowMinMax = true;
	else
		bShowMinMax = false;


	NTDM_BEGIN_METHOD()

	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DEFAULT_RANGE_TEXT, bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DEFAULT_RANGE_VALUE, bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_MIN_RANGE_TEXT, bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_MIN_RANGE_VALUE, bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_MAX_RANGE_TEXT, bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_MAX_RANGE_VALUE, bShowMinMax);

	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DEFAULT_SET_TEXT, !bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DEFAULT_SET_VALUE, !bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_VALUES_SET_TEXT, !bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_VALUES_SET_LIST, !bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_ADD, !bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_EDIT, !bShowMinMax);
	CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DELETE, !bShowMinMax);

	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::GetSintRangeValues()
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("Default"), 0, &vValue, &cimType, NULL));
	SetDlgItemInt(m_hWnd, IDC_DEFAULT_RANGE_VALUE, vValue.intVal, FALSE);

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("Min"), 0, &vValue, &cimType, NULL));
	SetDlgItemInt(m_hWnd, IDC_MIN_RANGE_VALUE, vValue.intVal, FALSE);

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("Max"), 0, &vValue, &cimType, NULL));
	SetDlgItemInt(m_hWnd, IDC_MAX_RANGE_VALUE, vValue.intVal, FALSE);

	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::SetSintRangeValues()
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;
	long lValue;
	BOOL bTranslated;

	NTDM_BEGIN_METHOD()

	cimType = CIM_SINT32;

	V_VT(&vValue) = VT_I4;

	lValue = GetDlgItemInt(m_hWnd, IDC_DEFAULT_RANGE_VALUE, &bTranslated, FALSE);
	NTDM_ERR_GETLASTERROR_IF_FALSE(bTranslated);
	vValue.intVal = lValue;
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Put(_T("Default"), 0, &vValue, cimType));
	

	lValue = GetDlgItemInt(m_hWnd, IDC_MIN_RANGE_VALUE, &bTranslated, FALSE);
	NTDM_ERR_GETLASTERROR_IF_FALSE(bTranslated);
	vValue.intVal = lValue;
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Put(_T("Min"), 0, &vValue, cimType));
	
	lValue = GetDlgItemInt(m_hWnd, IDC_MAX_RANGE_VALUE, &bTranslated, FALSE);
	NTDM_ERR_GETLASTERROR_IF_FALSE(bTranslated);
	vValue.intVal = lValue;
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Put(_T("Max"), 0, &vValue, cimType));

	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::GetUintRangeValues()
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("Default"), 0, &vValue, &cimType, NULL));
	SetDlgItemInt(m_hWnd, IDC_DEFAULT_RANGE_VALUE, vValue.uiVal, FALSE);

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("Min"), 0, &vValue, &cimType, NULL));
	SetDlgItemInt(m_hWnd, IDC_MIN_RANGE_VALUE, vValue.uiVal, FALSE);

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Get(_T("Max"), 0, &vValue, &cimType, NULL));
	SetDlgItemInt(m_hWnd, IDC_MAX_RANGE_VALUE, vValue.uiVal, FALSE);

	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::SetUintRangeValues()
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;
	long lValue;
	BOOL bTranslated;

	NTDM_BEGIN_METHOD()

	cimType = CIM_UINT32;

	lValue = GetDlgItemInt(m_hWnd, IDC_DEFAULT_RANGE_VALUE, &bTranslated, FALSE);
	NTDM_ERR_GETLASTERROR_IF_FALSE(bTranslated);
	vValue.uiVal = lValue;
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Put(_T("Default"), 0, &vValue, cimType));
	

	lValue = GetDlgItemInt(m_hWnd, IDC_MIN_RANGE_VALUE, &bTranslated, FALSE);
	NTDM_ERR_GETLASTERROR_IF_FALSE(bTranslated);
	vValue.uiVal = lValue;
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Put(_T("Min"), 0, &vValue, cimType));
	
	lValue = GetDlgItemInt(m_hWnd, IDC_MAX_RANGE_VALUE, &bTranslated, FALSE);
	NTDM_ERR_GETLASTERROR_IF_FALSE(bTranslated);
	vValue.uiVal = lValue;
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Put(_T("Max"), 0, &vValue, cimType));
	
	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::GetRealRangeValues()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::SetRealRangeValues()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()
	
	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::GetSintSetValues()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::SetSintSetValues()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()
	
	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::GetUintSetValues()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::SetUintSetValues()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()
	
	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::GetStringSetValues()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::SetStringSetValues()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()
	
	NTDM_END_METHOD()

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditRangeParameterPropertyDlg::SetRangeParamValues()
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;
	long lValue;
	BOOL bTranslated;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(CNTDMUtils::SetStringProperty(m_pIWbemClassObject, _T("PropertyName"), m_hWnd, IDC_PROPERTY_NAME));
	NTDM_ERR_IF_FAIL(CNTDMUtils::SetStringProperty(m_pIWbemClassObject, _T("TargetClass"), m_hWnd, IDC_TARGET_CLASS));

	cimType = CIM_UINT8;
	lValue = GetDlgItemInt(m_hWnd, IDC_TARGET_TYPE, &bTranslated, FALSE);
	NTDM_ERR_GETLASTERROR_IF_FALSE(bTranslated);
	V_VT(&vValue) = VT_UI1;
	V_UI1(&vValue) = lValue;
	NTDM_ERR_MSG_IF_FAIL(m_pIWbemClassObject->Put(_T("TargetType"), 0, &vValue, cimType));
	
	NTDM_END_METHOD()

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\defines.h ===
//-----------------------------------------------------------------------
// defines.h
//
// Author: Kishnan Nedungadi
//-----------------------------------------------------------------------

#ifndef __DEFINES_H
#define __DEFINES_H

#include <vector>
#include <list>

typedef std::vector<double> arrayDouble;
typedef std::vector<double>::iterator arrayDoubleIter;
typedef std::list<double> listDouble;
typedef std::list<double>::iterator listDoubleIter;

#define SZ_MAX_SIZE	256
#define MAX_LIST_ITEMS 100000

#define NTDM_BEGIN_METHOD() try {\
								hr = NOERROR;

#define NTDM_END_METHOD()		}\
							catch(...)\
								{\
									hr = E_UNEXPECTED;\
									goto error;\
								}\
							error:;

#define NTDM_ERR_IF_FAIL(stmt) if FAILED(hr = stmt)\
								{\
									CNTDMUtils::ErrorHandler(NULL, hr, FALSE);\
									;\
									goto error;\
								}

#define NTDM_ERR_MSG_IF_FAIL(stmt)	if FAILED(hr = stmt)\
									{\
										CNTDMUtils::ErrorHandler(m_hWnd, hr);\
										;\
										goto error;\
									}


#define NTDM_Hr(hrCode)		MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, hrCode)

#define NTDM_EXIT(hrVal)		{\
									hr = hrVal;\
									CNTDMUtils::ErrorHandler(NULL, hr, FALSE);\
									goto error;\
								}

#define NTDM_ERR_GETLASTERROR_IF_NULL(stmt) if(NULL == stmt)\
											{\
												hr = NTDM_Hr(GetLastError());\
												CNTDMUtils::ErrorHandler(m_hWnd, hr);\
												goto error;\
											}

#define NTDM_ERR_GETLASTERROR_IF_FALSE(stmt) if(FALSE == stmt)\
											{\
												hr = NTDM_Hr(GetLastError());\
												CNTDMUtils::ErrorHandler(m_hWnd, hr);\
												goto error;\
											}

#define NTDM_ERR_IF_NULL(stmt)	if(NULL == stmt)\
								{\
									hr = E_FAIL;\
									CNTDMUtils::ErrorHandler(m_hWnd, hr);\
									goto error;\
								}

#define NTDM_ERR_IF_MINUSONE(stmt)	if(-1 == stmt)\
									{\
										hr = E_FAIL;\
										CNTDMUtils::ErrorHandler(m_hWnd, hr);\
										goto error;\
									}


#define NTDM_ERRID_IF_NULL(stmt, err)	if(NULL == stmt)\
										{\
											hr = err;\
											CNTDMUtils::ErrorHandler(m_hWnd, hr);\
											goto error;\
										}

#define NTDM_ERR_IF_FALSE(stmt)	if(!stmt)\
								{\
									hr = E_FAIL;\
									CNTDMUtils::ErrorHandler(m_hWnd, hr);\
									goto error;\
								}

#define NTDM_DELETE_OBJECT(object)	if(object)\
									{\
										delete object;\
										object = NULL;\
									}

#define NTDM_RELEASE_IF_NOT_NULL(object)	if(object)\
											{\
												object->Release();\
											}

#define NTDM_CHECK_CB_ERR(stmt)	{\
									long ntdm_idx = stmt;\
									if(CB_ERR == ntdm_idx)\
									{\
										NTDM_EXIT(E_FAIL);\
									}\
									else if(CB_ERRSPACE == ntdm_idx)\
									{\
										NTDM_EXIT(E_OUTOFMEMORY);\
									}\
								}\

#define NTDM_FREE_BSTR(bstr)if(bstr)\
							{\
								SysFreeString(bstr);\
								bstr = NULL;\
							}


#define RGB_WHITE	0xffffff
#define RGB_BLACK	0x0
#define RGB_GLASS	0x8a8a8a
#define RGB_RED		0xff
#define RGB_BLUE	0xff0000


#define NOTEMPTY_BSTR_VARIANT(pvValue) (V_VT(pvValue)==VT_BSTR && V_BSTR(pvValue) && wcslen(V_BSTR(pvValue)))

#endif //__DEFINES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\editpropertydlgs.h ===
//-------------------------------------------------------------------------
// File: EditPropertyDlgs.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

class CEditProperty
{
	public:
		CEditProperty(HWND hWndParent, LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue, IWbemServices *pIWbemServices, long lSpecialCaseProperty=0);
		~CEditProperty();

		long Run();

		enum prop_special_cases
		{
			psc_rules = 0,
			psc_rule = 1,
			psc_ranges = 2,
			psc_range = 3
		};

	protected:
		
		HWND m_hWnd;
		VARIANT * pvSrcValue;
		CComBSTR m_bstrName;
		CComBSTR m_bstrType;
		CComPtr<IWbemServices>m_pIWbemServices;

		long m_lSpecialCaseProperty;
};

//-------------------------------------------------------------------------

class CEditPropertyDlg
{
	public:
		CEditPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue);
		~CEditPropertyDlg();

		CComVariant m_vValue;
	protected:
		
		virtual STDMETHODIMP InitializeDialog();
		virtual STDMETHODIMP DestroyDialog();

		HWND m_hWnd;
		VARIANT * pvSrcValue;
		CComBSTR m_bstrName;
		CComBSTR m_bstrType;
};

//-------------------------------------------------------------------------

class CEditStringPropertyDlg : public CEditPropertyDlg
{
	public:
		CEditStringPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue);
		~CEditStringPropertyDlg();
		INT_PTR CALLBACK EditStringPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
		STDMETHODIMP OnOK();


	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
};

//-------------------------------------------------------------------------

class CEditNumberPropertyDlg : public CEditPropertyDlg
{
	public:
		CEditNumberPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue);
		~CEditNumberPropertyDlg();
		INT_PTR CALLBACK EditNumberPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
		STDMETHODIMP OnOK();


	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
};

//-------------------------------------------------------------------------

class CEditRulesPropertyDlg : public CEditPropertyDlg
{
	public:
		CEditRulesPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue, IWbemServices *pIWbemServices);
		~CEditRulesPropertyDlg();
		INT_PTR CALLBACK EditRulesPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
		STDMETHODIMP OnOK();
		STDMETHODIMP ClearItems();
		STDMETHODIMP PopulateItems();
		STDMETHODIMP AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex=MAX_LIST_ITEMS);
		STDMETHODIMP OnAdd();
		STDMETHODIMP OnEdit();
		STDMETHODIMP OnDelete();

	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();

		HWND m_hwndListView;
		CComPtr<IWbemServices>m_pIWbemServices;
};

//-------------------------------------------------------------------------

class CEditRulePropertyDlg
{
	public:
		CEditRulePropertyDlg(IWbemClassObject* pIWbemClassObject);
		~CEditRulePropertyDlg();

		INT_PTR CALLBACK EditRulePropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
		STDMETHODIMP OnOK();

	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();

		CComPtr<IWbemClassObject>m_pIWbemClassObject;

		HWND m_hWnd;
};

//-------------------------------------------------------------------------

class CEditRangeParametersPropertyDlg : public CEditPropertyDlg
{
	public:
		CEditRangeParametersPropertyDlg(LPCTSTR pszName, LPCTSTR pszType, VARIANT * pvValue, IWbemServices *pIWbemServices);
		~CEditRangeParametersPropertyDlg();
		INT_PTR CALLBACK EditRangeParametersPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
		STDMETHODIMP OnOK();
		STDMETHODIMP ClearItems();
		STDMETHODIMP PopulateItems();
		STDMETHODIMP AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex=MAX_LIST_ITEMS);
		STDMETHODIMP OnAdd();
		STDMETHODIMP OnEdit();
		STDMETHODIMP OnDelete();

	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();

		HWND m_hwndListView;
		CComPtr<IWbemServices>m_pIWbemServices;
};

//-------------------------------------------------------------------------

class CEditRangeParameterPropertyDlg
{
	public:
		CEditRangeParameterPropertyDlg(IWbemClassObject* pIWbemClassObject, IWbemServices* pIWbemServices);
		~CEditRangeParameterPropertyDlg();
		INT_PTR CALLBACK EditRangeParameterPropertyDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);
		STDMETHODIMP OnOK();
		STDMETHODIMP ClearItems();
		STDMETHODIMP PopulateItems();
		STDMETHODIMP AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex=MAX_LIST_ITEMS);
		STDMETHODIMP OnAdd();
		STDMETHODIMP OnEdit();
		STDMETHODIMP OnDelete();
		STDMETHODIMP GetSintRangeValues();
		STDMETHODIMP SetSintRangeValues();
		STDMETHODIMP GetUintRangeValues();
		STDMETHODIMP SetUintRangeValues();
		STDMETHODIMP GetRealRangeValues();
		STDMETHODIMP SetRealRangeValues();
		STDMETHODIMP GetSintSetValues();
		STDMETHODIMP SetSintSetValues();
		STDMETHODIMP GetUintSetValues();
		STDMETHODIMP SetUintSetValues();
		STDMETHODIMP GetStringSetValues();
		STDMETHODIMP SetStringSetValues();
		STDMETHODIMP SetRangeParamValues();

		enum range_types
		{
			rt_sintrange = 0,
			rt_uintrange = 1,
			rt_realrange = 2,
			rt_sintset = 3,
			rt_uintset = 4,
			rt_stringset = 5
		};

		CComVariant m_vValue;

	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
		STDMETHODIMP ShowControls();

		HWND m_hwndListView;
		HWND m_hWnd;
		CComPtr<IWbemClassObject>m_pIWbemClassObject;
		CComPtr<IWbemServices>m_pIWbemServices;
};

//-------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\dlgfilterproperties.h ===
//-------------------------------------------------------------------------
// File: DlgFilterProperties.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

INT_PTR CALLBACK FilterPropertiesDlgProc(HWND hDLG, UINT iMessage, WPARAM wParam, LPARAM lParam);

class CFilterPropertiesDlg
{
	public:
		CFilterPropertiesDlg(IWbemServices * pIWbemServices, IWbemClassObject * pIWbemClassObject);
		~CFilterPropertiesDlg();
		INT_PTR CALLBACK FilterPropertiesDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);

	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
		STDMETHODIMP PopulateRulesList();
		STDMETHODIMP ClearRulesList();
		STDMETHODIMP AddItemToList(IWbemClassObject * pIWbemClassObject);
		STDMETHODIMP ShowProperty(IWbemClassObject * pIWbemClassObject, LPCTSTR pszPropertyName, long lResID);

		HWND m_hWnd;
		IWbemServices * m_pIWbemServices;
		HWND m_hwndRulesListView;
		IWbemClassObject * m_pIWbemClassObject;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\ntdmutils.cpp ===
//-------------------------------------------------------------------------
// File: ntdmutils.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include "Commdlg.h"
#include "Cderr.h"
#include <wbemidl.h>
#include "defines.h"
#include "resource.h"
#include "ntdmutils.h"

//-------------------------------------------------------------------------
// Globals

USHORT g_CIMTypes[] = {
	CIM_ILLEGAL,
	CIM_EMPTY	,
	CIM_SINT8	,
	CIM_UINT8	,
	CIM_SINT16	,
	CIM_UINT16	,
	CIM_SINT32	,
	CIM_UINT32	,
	CIM_SINT64	,
	CIM_UINT64	,
	CIM_REAL32	,
	CIM_REAL64	,
	CIM_BOOLEAN	,
	CIM_STRING	,
	CIM_DATETIME	,
	CIM_REFERENCE	,
	CIM_CHAR16	,
	CIM_OBJECT	,
	CIM_FLAG_ARRAY
};

USHORT g_CIMToVARIANTTypes[] = {
	VT_EMPTY,
	VT_EMPTY,
	VT_I1	,
	VT_UI1	,
	VT_I2	,
	VT_UI2	,
	VT_I4	,
	VT_UI4	,
	VT_I8	,
	VT_UI8	,
	VT_R4	,
	VT_R8	,
	VT_BOOL	,
	VT_BSTR	,
	VT_BSTR	,
	VT_BYREF,
	VT_BSTR	,
	VT_DISPATCH	,
	VT_ARRAY
};

CSimpleArray<BSTR> g_bstrCIMTypes;

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::Initialize()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(GetValuesInList((long)IDS_CIMTYPES, g_bstrCIMTypes));

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::UnInitialize()
{
	HRESULT hr;
	long i;

	NTDM_BEGIN_METHOD()

	for(i=0; i<g_bstrCIMTypes.GetSize(); i++)
	{
		NTDM_FREE_BSTR(g_bstrCIMTypes[i]);
	}

	g_bstrCIMTypes.RemoveAll();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::ErrorHandler(HWND hWnd, HRESULT err_hr, bool bShowError)
{
	if(bShowError)
		DisplayErrorInfo(hWnd, err_hr);

	return S_OK;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::DisplayErrorInfo(HWND hWnd, HRESULT err_hr)
{
	HRESULT hr;
	CComBSTR bstrSource, bstrDescription;
	CComBSTR bstrTemp;
	CComBSTR bstrAllTogether;

	NTDM_BEGIN_METHOD()

	GetDetailedErrorInfo(hWnd, bstrSource, bstrDescription, err_hr);

	bstrAllTogether.LoadString(_Module.GetResourceInstance(), IDS_ERROR_SOURCE);
	bstrAllTogether += bstrSource;
	bstrAllTogether += _T("\r\n\r\n");

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_ERROR_DESCRIPTION);
	bstrAllTogether += bstrTemp;
	bstrAllTogether += bstrDescription;

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_ERROR);

	MessageBox(hWnd, bstrAllTogether, bstrTemp, MB_OK);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}


//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::GetDetailedErrorInfo(HWND hWnd, CComBSTR &bstrSource, CComBSTR &bstrDescription, HRESULT err_hr)
{
	HRESULT hr;
	CComPtr<IErrorInfo>pIErrorInfo;
	HWND m_hWnd = hWnd;

	NTDM_BEGIN_METHOD()

	bstrSource = _T("");
	bstrDescription = _T("");

	//Get Error Object
	hr = GetErrorInfo(0,&pIErrorInfo);
	if(S_OK == hr)
	{
		pIErrorInfo->GetDescription(&bstrDescription);
		pIErrorInfo->GetSource(&bstrSource);
	}

	if(S_OK == hr && !bstrDescription.Length())
	{
		CComPtr<IWbemClassObject> pIWbemClassObject;
		CComVariant vValue;
		CIMTYPE vType;

		// check if WMI error
		if SUCCEEDED(hr = pIErrorInfo->QueryInterface(IID_IWbemClassObject, (void **)&pIWbemClassObject))
		{
			CComPtr<IWbemStatusCodeText> pIWbemStatusCodeText;

			if SUCCEEDED(hr = CoCreateInstance(CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER, IID_IWbemStatusCodeText, (LPVOID *) &pIWbemStatusCodeText))
			{
				pIWbemStatusCodeText->GetErrorCodeText(err_hr, 0, 0, &bstrDescription);
				pIWbemStatusCodeText->GetFacilityCodeText(err_hr, 0, 0, &bstrSource);

				// check for Rule Validation Results
				if SUCCEEDED(hr = pIWbemClassObject->Get(_T("RuleValidationResults"), 0, &vValue, &vType, NULL))
				{
					if(VT_NULL != V_VT(&vValue))
					{
						SAFEARRAY *pValidationResults = NULL;
						long lLower, lUpper, i;

						if(	SUCCEEDED(hr = SafeArrayGetUBound(pValidationResults, 1, &lUpper)) &&
							SUCCEEDED(hr = SafeArrayGetLBound(pValidationResults, 1, &lLower)))
						{
							CComBSTR bstrErrors;

							for(i=lLower; i<=lUpper; i++)
							{
								if(V_VT(&vValue) & VT_HRESULT)
								{
									CComBSTR bstrError;
									HRESULT hr2;

									if SUCCEEDED(hr = SafeArrayGetElement(pValidationResults, &i, (void *)&hr2))
									{
										bstrErrors += _T("\r\n\r\n");

										pIWbemStatusCodeText->GetErrorCodeText(hr2, 0, 0, &bstrError);

										bstrErrors += bstrError;
									}
								}
							}

							bstrDescription += bstrErrors;
						}
					}				
				}
			}
		}
	}


	if(!bstrDescription.Length())
	{
		TCHAR pszTemp[SZ_MAX_SIZE];
		pszTemp[0] = NULL;

		if(!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
							NULL,
							err_hr,
							MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
							pszTemp,
							SZ_MAX_SIZE,
							NULL))
		{
			FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
							NULL,
							HRESULT_CODE(err_hr),
							MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
							pszTemp,
							SZ_MAX_SIZE,
							NULL);
		}

		bstrDescription = pszTemp;
	}

	if(!bstrDescription.Length())
	{
		bstrDescription.LoadString(_Module.GetResourceInstance(), IDS_NO_DESCRIPTION_PROVIDED);
	}

	if(!bstrSource.Length())
	{
		bstrSource.LoadString(_Module.GetResourceInstance(), IDS_NO_SOURCE_NAME_PROVIDED);
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::GetValuesInList(LPCTSTR strList, CSimpleArray<BSTR>&bstrArray, LPCTSTR pcszToken)
{
	HRESULT hr;
	BSTR bstrTemp = NULL;
	BSTR bstrItem = NULL;
	TCHAR * pszItem;

	NTDM_BEGIN_METHOD()

	if(!strList || !_tcslen(strList))
	{
		NTDM_EXIT(NOERROR);
	}

	bstrTemp = SysAllocString(strList);

	pszItem = _tcstok(bstrTemp, pcszToken);

	while(pszItem)
	{
		bstrItem = SysAllocString(pszItem);
		NTDM_ERR_IF_FAIL(bstrArray.Add(bstrItem));
		bstrItem = NULL;
		pszItem = _tcstok(NULL, pcszToken);
	}

	NTDM_END_METHOD()

	// cleanup
	NTDM_FREE_BSTR(bstrTemp);
	NTDM_FREE_BSTR(bstrItem);

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::GetValuesInList(long lResID, CSimpleArray<BSTR>&bstrArray, LPCTSTR pcszToken)
{
	HRESULT hr;
	CComBSTR bstrTemp;

	NTDM_BEGIN_METHOD()

	bstrTemp.LoadString(_Module.GetResourceInstance(), lResID);
	GetValuesInList(bstrTemp, bstrArray, pcszToken);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::GetCIMTypeFromString(LPCTSTR pcszCIMType, long *pCimTYPE)
{
	HRESULT hr;
	long i;

	NTDM_BEGIN_METHOD()

	for(i=0; i<g_bstrCIMTypes.GetSize(); i++)
	{
		if(_tcscmp(pcszCIMType, g_bstrCIMTypes[i]) == 0)
		{
			*pCimTYPE = g_CIMTypes[i];
			break;
		}
	}

	if(i >= g_bstrCIMTypes.GetSize())
	{
		NTDM_EXIT(E_FAIL);
	}

	hr = NOERROR;

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::GetVariantTypeFromString(LPCTSTR pcszCIMType, long *pVariantType)
{
	HRESULT hr;
	long i;

	NTDM_BEGIN_METHOD()

	for(i=0; i<g_bstrCIMTypes.GetSize(); i++)
	{
		if(_tcscmp(pcszCIMType, g_bstrCIMTypes[i]) == 0)
		{
			*pVariantType = g_CIMToVARIANTTypes[i];
			break;
		}
	}

	if(i >= g_bstrCIMTypes.GetSize())
	{
		NTDM_EXIT(E_FAIL);
	}

	hr = NOERROR;

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::SetStringProperty(IWbemClassObject* pIWbemClassObject, LPCTSTR pszPropName, HWND hwnd, long lResID)
{
	HRESULT hr;
	CComVariant vValue;
	CComBSTR bstrTemp;
	long lLength;
	TCHAR *pszTemp = NULL;
	HWND m_hWnd = hwnd;

	NTDM_BEGIN_METHOD()

	// Set the Query language
	lLength = GetWindowTextLength(GetDlgItem(hwnd, lResID));
	if(lLength < 0)
	{
		NTDM_EXIT(E_FAIL);
	}
	else if(0 == lLength)
	{
		bstrTemp = _T("");
	}
	else
	{
		pszTemp = new TCHAR[lLength+1];
		if(!pszTemp)
		{
			NTDM_EXIT(E_OUTOFMEMORY);
		}

		NTDM_ERR_GETLASTERROR_IF_NULL(GetDlgItemText(hwnd, lResID, pszTemp, lLength+1));

		bstrTemp = pszTemp;

		NTDM_DELETE_OBJECT(pszTemp);
	}

	vValue = bstrTemp;

	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Put(pszPropName, 0, &vValue, CIM_STRING));

	NTDM_END_METHOD()

	// cleanup
	NTDM_DELETE_OBJECT(pszTemp);

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::GetDlgItemString(HWND hwnd, long lResID, CComBSTR &bstrValue)
{
	HRESULT hr;
	CComBSTR bstrTemp;
	long lLength;
	TCHAR *pszTemp = NULL;
	HWND m_hWnd = hwnd;

	NTDM_BEGIN_METHOD()

	// Set the Query language
	lLength = GetWindowTextLength(GetDlgItem(hwnd, lResID));
	if(lLength < 0)
	{
		NTDM_EXIT(E_FAIL);
	}
	else if(0 == lLength)
	{
		bstrTemp = _T("");
	}
	else
	{
		pszTemp = new TCHAR[lLength+1];
		if(!pszTemp)
		{
			NTDM_EXIT(E_OUTOFMEMORY);
		}

		NTDM_ERR_GETLASTERROR_IF_NULL(GetDlgItemText(hwnd, lResID, pszTemp, lLength+1));

		bstrValue = pszTemp;

		NTDM_DELETE_OBJECT(pszTemp);
	}

	NTDM_END_METHOD()

	// cleanup
	NTDM_DELETE_OBJECT(pszTemp);

	return hr;
}

//-------------------------------------------------------------------------

STDMETHODIMP CNTDMUtils::GetStringProperty(IWbemClassObject* pIWbemClassObject, LPCTSTR pszPropName, HWND hwnd, long lResID)
{
	HRESULT hr;
	HWND m_hWnd = hwnd;
	CComVariant vValue;
	CIMTYPE cimType;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(pszPropName, 0, &vValue, &cimType, NULL));
	SetDlgItemText(hwnd, lResID, V_BSTR(&vValue));

	NTDM_END_METHOD()

	return hr;
}

//-----------------------------------------------------------------------------------------

BOOL CNTDMUtils::SaveFileNameDlg(LPCTSTR szFilter, LPCTSTR extension, HWND hwnd, LPTSTR pszFile)
{
	OPENFILENAME        ofn;
	BOOL                fRet;
	HANDLE              hFile = NULL;

	memset(&ofn, 0, sizeof(OPENFILENAME));
	ofn.lStructSize      =sizeof(OPENFILENAME);
	ofn.hwndOwner        =hwnd;
	ofn.lpstrFilter      =szFilter;
	ofn.nFilterIndex     =1L;
	ofn.lpstrFile        =pszFile;
	ofn.nMaxFile         =MAX_PATH;
	ofn.lpstrDefExt      =TEXT("*");
	ofn.Flags            =OFN_HIDEREADONLY;

	fRet=GetSaveFileName(&ofn);

	if(fRet == 0)
	{
		if(FNERR_INVALIDFILENAME == CommDlgExtendedError())
		{
			_tcscpy(pszFile, TEXT(""));
			fRet=GetSaveFileName(&ofn);
		}
	}

	return fRet;
}

//-----------------------------------------------------------------------------------------

BOOL CNTDMUtils::OpenFileNameDlg(LPCTSTR szFilter, LPCTSTR extension, HWND hwnd, LPTSTR pszFile)
{
	OPENFILENAME        ofn;
	BOOL                fRet;
	HANDLE              hFile = NULL;

	memset(&ofn, 0, sizeof(OPENFILENAME));
	ofn.lStructSize      =sizeof(OPENFILENAME);
	ofn.hwndOwner        =hwnd;
	ofn.lpstrFilter      =szFilter;
	ofn.nFilterIndex     =1L;
	ofn.lpstrFile        =pszFile;
	ofn.nMaxFile         =MAX_PATH;
	ofn.lpstrDefExt      =TEXT("*");
	ofn.Flags            =OFN_HIDEREADONLY;

	fRet=GetOpenFileName(&ofn);

	if(fRet == 0)
	{
		if(FNERR_INVALIDFILENAME == CommDlgExtendedError())
		{
			_tcscpy(pszFile, TEXT(""));
			fRet=GetOpenFileName(&ofn);
		}
	}

	return fRet;
}

//-----------------------------------------------------------------------------------------

void CNTDMUtils::ReplaceCharacter(TCHAR * string_val, const TCHAR replace_old, const TCHAR replace_new)
{
	TCHAR * p_cur = string_val;

	while(*p_cur)
	{
		if(replace_old == *p_cur)
			*p_cur = replace_new;

		p_cur++;
	}
}

//-------------------------------------------------------------------------

long CNTDMUtils::DisplayMessage(HWND hParent, long iMsgID, long iTitleID, long iType)
{
	CComBSTR bstrMsg, bstrTitle;
	
	bstrMsg.LoadString(_Module.GetResourceInstance(), iMsgID);
	bstrTitle.LoadString(_Module.GetResourceInstance(), iTitleID);

	return MessageBox(hParent, bstrMsg, bstrTitle, iType);
}

//-----------------------------------------------------------------------------------------

void CNTDMUtils::DisplayDlgItem(HWND hWndDlg, long item_id, BOOL show)
{
	if(show)
	{
		ShowWindow(GetDlgItem(hWndDlg, item_id), SW_SHOW);
		EnableWindow(GetDlgItem(hWndDlg, item_id), TRUE);
	}
	else
	{
		ShowWindow(GetDlgItem(hWndDlg, item_id), SW_HIDE);
		EnableWindow(GetDlgItem(hWndDlg, item_id), FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\policytemplateeditpropertiesdlg.cpp ===
//-------------------------------------------------------------------------
// File: PolicyTemplateEditPropertiesDlg.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "PolicyTemplateManager.h"
#include "PolicyTemplateEditPropertiesDlg.h"
#include "EditPropertyDlgs.h"


extern USHORT g_CIMTypes[];
extern CSimpleArray<BSTR> g_bstrCIMTypes;

CEditPolicyTemplatePropertiesPageDlg * g_pEditPolicyTemplatePropertiesPage =  NULL;

//-------------------------------------------------------------------------

INT_PTR CALLBACK EditPolicyTemplatePropertiesPageDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pEditPolicyTemplatePropertiesPage)
	{
		return g_pEditPolicyTemplatePropertiesPage->EditPolicyTemplatePropertiesPageDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CEditPolicyTemplatePropertiesPageDlg::CEditPolicyTemplatePropertiesPageDlg(IWbemClassObject * pIPolicyTemplateClassObject, IWbemServices * pIWbemServices)
{
	_ASSERT(pIPolicyTemplateClassObject);
	_ASSERT(pIWbemServices);

	m_hWnd = NULL;
	m_pIPolicyTemplateClassObject = pIPolicyTemplateClassObject;
	m_pIWbemServices = pIWbemServices;
}

//-------------------------------------------------------------------------

CEditPolicyTemplatePropertiesPageDlg::~CEditPolicyTemplatePropertiesPageDlg()
{
}


//-------------------------------------------------------------------------

INT_PTR CALLBACK CEditPolicyTemplatePropertiesPageDlg::EditPolicyTemplatePropertiesPageDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
					case IDOK:
					{
						OnOK();
						return TRUE;
						break;
					}
					case IDCANCEL:
					{
						EndDialog(m_hWnd, IDCANCEL);
						return TRUE;
						break;
					}
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EDIT == LOWORD(wParam))
				{
					OnEdit();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_IMPORT == LOWORD(wParam))
				{
					OnImport();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EXPORT == LOWORD(wParam))
				{
					OnExport();
					return TRUE;
				}

				break;
			}

		case WM_NOTIFY:
			{
				LPNMHDR lpnm = (LPNMHDR) lParam;

				switch (lpnm->code)
				{
					case NM_DBLCLK :
					{
						if(lpnm->idFrom == IDC_POLICY_TEMPLATE_PROPERTIES_LIST)
						{
							OnEdit();
							return TRUE;
						}
						break;
					}

					default :
						break;
				}
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	CComBSTR bstrTemp;
	
	NTDM_BEGIN_METHOD()

	//Initialize the Property List Control
	m_hwndPropertiesListView = GetDlgItem(m_hWnd, IDC_POLICY_TEMPLATE_PROPERTIES_LIST);
	NTDM_ERR_IF_NULL(m_hwndPropertiesListView);
	ListView_SetExtendedListViewStyle(m_hwndPropertiesListView, LVS_EX_FULLROWSELECT);

	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_NAME);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndPropertiesListView, 0, &lvColumn));

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_TYPE);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndPropertiesListView, 1, &lvColumn));

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_VALUE);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndPropertiesListView, 2, &lvColumn));

	PopulatePolicyTemplatePropertiesList();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearPolicyTemplatePropertiesList());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::ClearPolicyTemplatePropertiesList()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	ListView_DeleteAllItems(m_hwndPropertiesListView);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::PopulatePolicyTemplatePropertiesList()
{
	HRESULT hr;
	CComPtr<IEnumWbemClassObject> pEnumWbemClassObject;
	CComBSTR bstrName;
	CComVariant vValue;
	CIMTYPE cimType;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearPolicyTemplatePropertiesList());

	if(!m_pIWbemServices)
		NTDM_EXIT(E_FAIL);

	NTDM_ERR_MSG_IF_FAIL(m_pIPolicyTemplateClassObject->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY));

	while(true)
	{
		NTDM_ERR_MSG_IF_FAIL(m_pIPolicyTemplateClassObject->Next(0, &bstrName, &vValue, &cimType, NULL));

		if(WBEM_S_NO_MORE_DATA == hr)
			break;

		NTDM_ERR_IF_FAIL(AddItemToPropertyList(bstrName, &vValue, cimType));
	}


	NTDM_ERR_MSG_IF_FAIL(m_pIPolicyTemplateClassObject->EndEnumeration());

	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndPropertiesListView, 0, LVSCW_AUTOSIZE_USEHEADER));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndPropertiesListView, 1, LVSCW_AUTOSIZE_USEHEADER));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndPropertiesListView, 2, LVSCW_AUTOSIZE_USEHEADER));

	ListView_SetItemState(m_hwndPropertiesListView, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::AddItemToPropertyList(LPCTSTR pcszName, VARIANT * pvValue, CIMTYPE cimType, long lIndex)
{
	HRESULT hr;
	LVITEM lvItem;
	CComVariant vValue;
	long i;

	NTDM_BEGIN_METHOD()

	vValue = *pvValue;

	// Name
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = lIndex;
	lvItem.iSubItem = 0;
	lvItem.pszText = (LPTSTR)pcszName;

	lvItem.iItem = ListView_InsertItem(m_hwndPropertiesListView, &lvItem);
	NTDM_ERR_IF_MINUSONE(lvItem.iItem);

	// Type
	lvItem.mask = LVIF_TEXT;
	lvItem.iSubItem = 1;
	lvItem.pszText = _T("");
	for(i=0; i<g_bstrCIMTypes.GetSize(); i++)
	{
		// if Array and the type contains CIM_FLAG_ARRAY then show array
		if((g_CIMTypes[i] == cimType)||((g_CIMTypes[i] == CIM_FLAG_ARRAY) && (CIM_FLAG_ARRAY & cimType)))
		{
			lvItem.pszText = (LPTSTR)g_bstrCIMTypes[i];
			break;
		}
	}

	NTDM_ERR_IF_MINUSONE(ListView_SetItem(m_hwndPropertiesListView, &lvItem));


	// Value
	if FAILED(hr = VariantChangeType(&vValue, &vValue, VARIANT_ALPHABOOL|VARIANT_LOCALBOOL, VT_BSTR))
	{
		if(V_VT(&vValue) == VT_NULL)
		{
			vValue = _T("");
		}
		else
		{
			CComBSTR bstrTemp;
			bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_UNABLE_TO_DISPLAY);

			vValue = bstrTemp;
		}

		hr = NOERROR;
	}

	lvItem.mask = LVIF_TEXT;
	lvItem.iSubItem = 2;
	lvItem.pszText = vValue.bstrVal;

	NTDM_ERR_IF_MINUSONE(ListView_SetItem(m_hwndPropertiesListView, &lvItem));

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::OnEdit()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndPropertiesListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_PROPERTY_SELECTED);
		NTDM_EXIT(E_FAIL);
	}
	else
	{
		TCHAR pszBuffer[SZ_MAX_SIZE];
		VARIANT vValue;
		CComBSTR bstrName;
		CComBSTR bstrType;
		CIMTYPE cimType;
		LVITEM lvItem;
		long i;

		VariantInit(&vValue);

		// get the property info
		lvItem.mask = LVIF_TEXT;
		lvItem.iItem = lSelectionMark;
		lvItem.iSubItem = 0;
		lvItem.pszText = pszBuffer;
		lvItem.cchTextMax = SZ_MAX_SIZE;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndPropertiesListView, &lvItem));

		if(lvItem.pszText)
		{
			bstrName = lvItem.pszText;
			long lSpecialCaseProperty = 0;

			NTDM_ERR_MSG_IF_FAIL(m_pIPolicyTemplateClassObject->Get(bstrName, 0, &vValue, &cimType, NULL));

			if(_tcscmp(_T("RangeSettings"), bstrName) == 0)
			{
				lSpecialCaseProperty = CEditProperty::psc_ranges;
			}

			for(i=0; i<g_bstrCIMTypes.GetSize(); i++)
			{
				// if Array and the type contains CIM_FLAG_ARRAY then show array
				if((g_CIMTypes[i] == cimType)||((g_CIMTypes[i] == CIM_FLAG_ARRAY) && (CIM_FLAG_ARRAY & cimType)))
				{
					bstrType = (LPTSTR)g_bstrCIMTypes[i];
					break;
				}
			}

			CEditProperty dlgProps(m_hWnd, lvItem.pszText, bstrType, &vValue, m_pIWbemServices, lSpecialCaseProperty);
			if(IDOK == dlgProps.Run())
			{
				// delete the selected entry
				NTDM_ERR_MSG_IF_FAIL(m_pIPolicyTemplateClassObject->Put(bstrName, 0, &vValue, cimType));
				NTDM_ERR_IF_FALSE(ListView_DeleteItem(m_hwndPropertiesListView, lSelectionMark));
				NTDM_ERR_IF_FAIL(AddItemToPropertyList(bstrName, &vValue, cimType, lSelectionMark));
			}
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::OnOK()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->PutInstance(m_pIPolicyTemplateClassObject, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL));

	hr = S_OK;

	NTDM_END_METHOD()

	// cleanup
	if(SUCCEEDED(hr))
	{
		EndDialog(m_hWnd, IDOK);
	}

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::OnImport()
{
	HRESULT hr;
	CComBSTR bstrPolicyTemplate;
	TCHAR pszFile[MAX_PATH];
	CComBSTR bstrTemp;

	pszFile[0] = 0;

	NTDM_BEGIN_METHOD()

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_ALL_FILES_FILTER);
	bstrPolicyTemplate.LoadString(_Module.GetResourceInstance(), IDS_MOF_FILES_FILTER);
	bstrPolicyTemplate += bstrTemp;
	CNTDMUtils::ReplaceCharacter(bstrPolicyTemplate, L'@', L'\0');

	if(CNTDMUtils::OpenFileNameDlg(bstrPolicyTemplate, _T("*.*"), m_hWnd, pszFile) && pszFile)
	{
		CComPtr<IMofCompiler>pIMofCompiler;
		CComPtr<IWbemClassObject>pINamespaceClass;
		CComPtr<IWbemClassObject>pIWbemNewInstance;
		CComPtr<IWbemClassObject>pIWbemClassObject;
		CComVariant vValue = _T("DeleteThisNamespace");
		WBEM_COMPILE_STATUS_INFO pInfo;

		// Generate a temporary namespace
		bstrTemp = _T("__Namespace");
		NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->GetObject(bstrTemp, WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pINamespaceClass, NULL));
		NTDM_ERR_MSG_IF_FAIL(pINamespaceClass->SpawnInstance(0, &pIWbemNewInstance));
		NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("Name"), 0, &vValue, CIM_STRING));
		NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->PutInstance(pIWbemNewInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL));

		// mofcomp the file into that namespace
		NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER,IID_IMofCompiler, (void**)&pIMofCompiler));
		NTDM_ERR_IF_FAIL(pIMofCompiler->CompileFile(pszFile, _T("\\\\.\\root\\policy\\DeleteThisNamespace"), NULL, NULL, NULL, WBEM_FLAG_DONT_ADD_TO_LIST, WBEM_FLAG_CREATE_ONLY, WBEM_FLAG_CREATE_ONLY, &pInfo));

		if(hr != WBEM_S_NO_ERROR)
		{
			CNTDMUtils::DisplayMessage(m_hWnd, IDS_FAILED_COMPILING_MOF_FILE);
			NTDM_EXIT(E_FAIL);
		}

		// get the 1st instance of MSFT_PolicyTemplate from the newly created namespace
		NTDM_ERR_IF_FAIL(GetInstanceOfClass(bstrTemp, _T("MSFT_PolicyTemplate"), &pIWbemClassObject));

		// copy the properties
		m_pIPolicyTemplateClassObject = pIWbemClassObject;
		PopulatePolicyTemplatePropertiesList();
	}

	NTDM_END_METHOD()

	// finally delete the namespace that we created above
	{
		CComVariant vValue = "\\\\.\\root\\policy:__Namespace.Name=\"DeleteThisNamespace\"";
		m_pIWbemServices->DeleteInstance(V_BSTR(&vValue), 0, NULL, NULL);
	}

	return hr;
}


//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::GetInstanceOfClass(BSTR pszNamespace, LPCTSTR pszClass, IWbemClassObject ** ppWbemClassObject)
{
	HRESULT hr;
	CComPtr<IWbemLocator>pIWbemLocator;
	CComPtr<IWbemServices>pIWbemServices;
	CComPtr<IEnumWbemClassObject>pEnumWbemClassObject;
	CComBSTR bstrClass = _T("MSFT_PolicyTemplate");
	ULONG uReturned;

	NTDM_BEGIN_METHOD()

	// create the webm locator
	NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
			IID_IWbemLocator, (LPVOID *) &pIWbemLocator));

	NTDM_ERR_MSG_IF_FAIL(pIWbemLocator->ConnectServer(	pszNamespace,
													NULL,
													NULL,
													NULL,
													0,
													NULL,
													NULL,
													&pIWbemServices));

	NTDM_ERR_MSG_IF_FAIL(CoSetProxyBlanket(pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE  , 
        NULL, EOAC_NONE));

	NTDM_ERR_MSG_IF_FAIL(pIWbemServices->CreateInstanceEnum(bstrClass, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumWbemClassObject));
	NTDM_ERR_MSG_IF_FAIL(pEnumWbemClassObject->Next(WBEM_INFINITE, 1, ppWbemClassObject, &uReturned));

	if(!uReturned)
		NTDM_EXIT(E_FAIL);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}



//---------------------------------------------------------------------------

STDMETHODIMP CEditPolicyTemplatePropertiesPageDlg::OnExport()
{
	HRESULT hr;
	CComBSTR bstrTemp;
	CComBSTR bstrPolicyTemplate;
	TCHAR pszFile[MAX_PATH];
	CComBSTR bstrObjectText;
	HANDLE hFile = NULL;
	DWORD dwWritten;
	pszFile[0] = 0;

	NTDM_BEGIN_METHOD()

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_ALL_FILES_FILTER);
	bstrPolicyTemplate.LoadString(_Module.GetResourceInstance(), IDS_MOF_FILES_FILTER);
	bstrPolicyTemplate += bstrTemp;
	CNTDMUtils::ReplaceCharacter(bstrPolicyTemplate, L'@', L'\0');

	if(CNTDMUtils::SaveFileNameDlg(bstrPolicyTemplate, _T("*.mof"), m_hWnd, pszFile))
	{
		if(_tcslen(pszFile))
		{
			NTDM_ERR_MSG_IF_FAIL(m_pIPolicyTemplateClassObject->GetObjectText(0, &bstrObjectText));

			// save to pszFile
			hFile = CreateFile(pszFile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 
							   NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
			if(hFile == INVALID_HANDLE_VALUE)
			{
				NTDM_ERR_GETLASTERROR_IF_NULL(NULL);
				goto error;
			}

			if(hFile)
			{
				NTDM_ERR_GETLASTERROR_IF_NULL(WriteFile(hFile, bstrObjectText, _tcslen(bstrObjectText) * sizeof(TCHAR), &dwWritten, NULL));
				NTDM_ERR_GETLASTERROR_IF_NULL(CloseHandle(hFile));
				hFile = NULL;
			}
		}
	}

	NTDM_END_METHOD()

	// cleanup
	if(hFile)
	{
		CloseHandle(hFile);
		hFile = NULL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\policytemplatemanager.cpp ===
// PolicyTemplateManager.cpp : Implementation of CPolicyTemplateManager
#include "stdafx.h"
#include <wbemidl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "PolicyTemplateManager.h"
#include "PolicyTemplateMgrDlg.h"

extern CPolicyTemplateManagerDlg *g_pPolicyTemplateManagerDlg;

/////////////////////////////////////////////////////////////////////////////
// CPolicyTemplateManager

CPolicyTemplateManager::CPolicyTemplateManager()
{
	m_hWnd = NULL;
}

//---------------------------------------------------------------------------

CPolicyTemplateManager::~CPolicyTemplateManager()
{
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManager::ConnectToWMI()
{
	HRESULT hr;
	CComPtr<IWbemLocator>pIWbemLocator;

	NTDM_BEGIN_METHOD()

	m_pIWbemServices = NULL;

	// create the webm locator
	NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
			IID_IWbemLocator, (LPVOID *) &pIWbemLocator));

	NTDM_ERR_MSG_IF_FAIL(pIWbemLocator->ConnectServer(	_T("root\\policy"),
													NULL,
													NULL,
													NULL,
													0,
													NULL,
													NULL,
													&m_pIWbemServices));

	NTDM_ERR_MSG_IF_FAIL(CoSetProxyBlanket(m_pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE  , 
        NULL, EOAC_NONE));

	
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManager::RunManager(HWND hwndParent)
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	m_hWnd = hwndParent;

	NTDM_ERR_IF_FAIL(ConnectToWMI());

	g_pPolicyTemplateManagerDlg = new CPolicyTemplateManagerDlg(this);
	DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_POLICY_TEMPLATE_MANAGER), (HWND)hwndParent, PolicyTemplateManagerDlgProc);
	
	NTDM_END_METHOD()

	// cleanup
	NTDM_DELETE_OBJECT(g_pPolicyTemplateManagerDlg);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\policytemplatemanager.h ===
// PolicyTemplateManager.h : Declaration of the CPolicyTemplateManager

#ifndef __POLICYTEMPLATEMANAGER_H_
#define __POLICYTEMPLATEMANAGER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPolicyTemplateManager
class ATL_NO_VTABLE CPolicyTemplateManager : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPolicyTemplateManager, &CLSID_PolicyTemplateManager>,
	public IDispatchImpl<IPolicyTemplateManager, &IID_IPolicyTemplateManager, &LIBID_SCHEMAMANAGERLib>
{
public:
	CPolicyTemplateManager();
	~CPolicyTemplateManager();

DECLARE_REGISTRY_RESOURCEID(IDR_POLICYTEMPLATEMANAGER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPolicyTemplateManager)
	COM_INTERFACE_ENTRY(IPolicyTemplateManager)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISomFilterManager
public:
	STDMETHOD(RunManager)(/*[in]*/HWND hwndParent);
	STDMETHOD(ConnectToWMI)();

	CComPtr<IWbemServices>m_pIWbemServices;
	HWND m_hWnd;
};

#endif //__POLICYTEMPLATEMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\ntdmutils.h ===
//-------------------------------------------------------------------------
// File: ntdmutils.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

class CNTDMUtils
{
	public:
		static STDMETHODIMP Initialize();
		static STDMETHODIMP UnInitialize();
		static STDMETHODIMP ErrorHandler(HWND hWnd, HRESULT err_hr, bool bShowError=true);
		static STDMETHODIMP GetValuesInList(LPCTSTR strList, CSimpleArray<BSTR>&bstrArray, LPCTSTR pcszToken=L";");
		static STDMETHODIMP GetValuesInList(long lResID, CSimpleArray<BSTR>&bstrArray, LPCTSTR pcszToken=L";");
		static STDMETHODIMP GetCIMTypeFromString(LPCTSTR pcszCIMType, long *pCimTYPE);
		static STDMETHODIMP GetVariantTypeFromString(LPCTSTR pcszCIMType, long *pVariantTYPE);
		static STDMETHODIMP SetStringProperty(IWbemClassObject* pIWbemClassObject, LPCTSTR pszPropName, HWND hwnd, long lResID);
		static STDMETHODIMP GetStringProperty(IWbemClassObject* pIWbemClassObject, LPCTSTR pszPropName, HWND hwnd, long lResID);
		static BOOL SaveFileNameDlg(LPCTSTR szFilter, LPCTSTR extension, HWND hwnd, LPTSTR pszFile);
		static BOOL OpenFileNameDlg(LPCTSTR szFilter, LPCTSTR extension, HWND hwnd, LPTSTR pszFile);
		static void ReplaceCharacter(TCHAR * string_val, const TCHAR replace_old, const TCHAR replace_new);
		static long DisplayMessage(HWND hParent, long iMsgID, long iTitleID=IDS_ERROR, long iType=0);
		static void DisplayDlgItem(HWND hWndDlg, long item_id, BOOL show);
		static STDMETHODIMP GetDlgItemString(HWND hwnd, long lResID, CComBSTR &bstrValue);

	protected:
		static STDMETHODIMP DisplayErrorInfo(HWND hWnd, HRESULT err_hr);
		static STDMETHODIMP GetDetailedErrorInfo(HWND hWnd, CComBSTR &bstrSource, CComBSTR &bstrDescription, HRESULT err_hr);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\policytemplateeditpropertiesdlg.h ===
//-------------------------------------------------------------------------
// File: PolicyTemplateEditPropertiesDlg.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

INT_PTR CALLBACK EditPolicyTemplatePropertiesPageDlgProc(HWND hDLG, UINT iMessage, WPARAM wParam, LPARAM lParam);

class CPolicyTemplateManager;

class CEditPolicyTemplatePropertiesPageDlg
{
	public:
		CEditPolicyTemplatePropertiesPageDlg(IWbemClassObject * pIPolicyTemplateClassObject, IWbemServices * pIWbemServices);
		~CEditPolicyTemplatePropertiesPageDlg();
		INT_PTR CALLBACK EditPolicyTemplatePropertiesPageDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);

	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
		STDMETHODIMP PopulatePolicyTemplatePropertiesList();
		STDMETHODIMP AddItemToPropertyList(LPCTSTR pcszName, VARIANT * vValue, CIMTYPE cimType, long lIndex=MAX_LIST_ITEMS);
		STDMETHODIMP ClearPolicyTemplatePropertiesList();
		STDMETHODIMP OnEdit();
		STDMETHODIMP OnOK();
		STDMETHODIMP OnImport();
		STDMETHODIMP OnExport();
		STDMETHODIMP GetInstanceOfClass(BSTR pszNamespace, LPCTSTR pszClass, IWbemClassObject ** ppWbemClassObject);

		HWND m_hWnd;
		HWND m_hwndPropertiesListView;
		CPolicyTemplateManager *m_pPolicyTemplateManager;
		CComPtr<IWbemClassObject>m_pIPolicyTemplateClassObject;
		CComPtr<IWbemServices>m_pIWbemServices;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\policytemplatemgrdlg.cpp ===
//-------------------------------------------------------------------------
// File: PolicyTemplateMgrDlg.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "PolicyTemplateManager.h"
#include "PolicyTemplateMgrDlg.h"
#include "PolicyTemplateEditPropertiesDlg.h"

CPolicyTemplateManagerDlg * g_pPolicyTemplateManagerDlg =  NULL;
extern CEditPolicyTemplatePropertiesPageDlg * g_pEditPolicyTemplatePropertiesPage;

//-------------------------------------------------------------------------

INT_PTR CALLBACK PolicyTemplateManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pPolicyTemplateManagerDlg)
	{
		return g_pPolicyTemplateManagerDlg->PolicyTemplateManagerDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CPolicyTemplateManagerDlg::CPolicyTemplateManagerDlg(CPolicyTemplateManager * pPolicyTemplateManager)
{
	_ASSERT(pPolicyTemplateManager);

	m_hWnd = NULL;
	m_hwndListView = NULL;
	m_pPolicyTemplateManager = pPolicyTemplateManager;
}

//-------------------------------------------------------------------------

CPolicyTemplateManagerDlg::~CPolicyTemplateManagerDlg()
{
}


//-------------------------------------------------------------------------

INT_PTR CALLBACK CPolicyTemplateManagerDlg::PolicyTemplateManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();
				PopulatePolicyTypeList();
				OnPolicyTypeChange();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
				case IDOK:
				case IDCANCEL:
					EndDialog(m_hWnd, 0);
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_NEW == LOWORD(wParam))
				{
					OnNew();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EDIT == LOWORD(wParam))
				{
					OnEdit();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_DELETE == LOWORD(wParam))
				{
					OnDelete();
					return TRUE;
				}

				if(CBN_SELCHANGE == HIWORD(wParam) && IDC_POLICY_TYPE == LOWORD(wParam))
				{
					OnPolicyTypeChange();
					return TRUE;
				}


				break;
			}

		case WM_NOTIFY:
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;

			switch (lpnm->code)
			{
				case NM_DBLCLK :
				{
					if(lpnm->idFrom == IDC_SOM_FILTER_LIST)
					{
						OnEdit();
						return TRUE;
					}
					break;
				}

				default :
					break;
			}
		}

	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	CComBSTR bstrName;
	
	NTDM_BEGIN_METHOD()

	//Initialize the ListView Control

	m_hwndListView = GetDlgItem(m_hWnd, IDC_SOM_FILTER_LIST);
	NTDM_ERR_IF_NULL(m_hwndListView);

	ListView_SetExtendedListViewStyle(m_hwndListView, LVS_EX_FULLROWSELECT);

	bstrName.LoadString(_Module.GetResourceInstance(), IDS_NAME);
	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.pszText = bstrName;

	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndListView, 0, &lvColumn));

	bstrName.LoadString(_Module.GetResourceInstance(), IDS_POLICY_TYPE);
	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.pszText = bstrName;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndListView, 1, &lvColumn));

	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndListView, 0, LVSCW_AUTOSIZE_USEHEADER));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndListView, 1, LVSCW_AUTOSIZE_USEHEADER));
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearPolicyTemplateList());
	NTDM_ERR_IF_FAIL(ClearPolicyTypeList());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::ClearPolicyTemplateList()
{
	HRESULT hr;
	LVITEM lvItem;
	long lCount;

	NTDM_BEGIN_METHOD()

	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndListView);

	while(lCount > 0)
	{
		lCount--;

		lvItem.iItem = lCount;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			((IWbemClassObject *)lvItem.lParam)->Release();
		}
	}

	ListView_DeleteAllItems(m_hwndListView);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::PopulatePolicyTemplatesList()
{
	HRESULT hr;
	CComPtr<IEnumWbemClassObject> pEnumWbemClassObject;
	CComPtr<IWbemClassObject>pIWbemClassDefinitionObject;
	ULONG uReturned;
	CComVariant vValueClassName;
	CComBSTR bstrWQLStmt;
	CComBSTR bstrWQL;
	CComVariant vValue;
	CIMTYPE cimType;

	NTDM_BEGIN_METHOD()

	if(!m_pPolicyTemplateManager->m_pIWbemServices)
		NTDM_EXIT(E_FAIL);

	NTDM_ERR_IF_FAIL(ClearPolicyTemplateList());
	
	// Get the Policy Template Class
	NTDM_ERR_MSG_IF_FAIL(m_pIPolicyTypeClassObject->Get(_T("ClassDefinition"), 0, &vValue, &cimType, NULL));

	// Make sure we got a Class Object back
	if(V_VT(&vValue) != VT_UNKNOWN)
	{
		NTDM_EXIT(E_FAIL);
	}

	NTDM_ERR_MSG_IF_FAIL(V_UNKNOWN(&vValue)->QueryInterface(IID_IWbemClassObject, (void**)&pIWbemClassDefinitionObject));
	NTDM_ERR_MSG_IF_FAIL(pIWbemClassDefinitionObject->Get(_T("__CLASS"), 0, &vValueClassName, &cimType, NULL));

	//vValueClassName = _T("ified");

	// Get all the policy templates that have the TargetClass property = the class we got above.
	bstrWQLStmt = _T("SELECT * FROM MSFT_MergeablePolicyTemplate WHERE TargetClass='");
	bstrWQLStmt += V_BSTR(&vValueClassName);
	bstrWQLStmt += _T("'");

	bstrWQL = _T("WQL");

	NTDM_ERR_MSG_IF_FAIL(m_pPolicyTemplateManager->m_pIWbemServices->ExecQuery(bstrWQL, bstrWQLStmt, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumWbemClassObject));

	// Loop through each item in the enumeration and add it to the list
	while(true)
	{
		IWbemClassObject *pIWbemClassObject = NULL;

		NTDM_ERR_MSG_IF_FAIL(pEnumWbemClassObject->Next(WBEM_INFINITE, 1, &pIWbemClassObject, &uReturned));

		if(!uReturned)
			break;

		// Add current Item to the list
		AddItemToList(pIWbemClassObject);

		pIWbemClassObject->Release();
	}

	ListView_SetItemState(m_hwndListView, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE vType;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("Name"), 0, &vValue, &vType, NULL));

	lvItem.mask = LVIF_TEXT|LVIF_PARAM;
	lvItem.iItem = lIndex;
	lvItem.iSubItem = 0;
	lvItem.pszText = vValue.bstrVal;
	lvItem.lParam = (LPARAM)pIWbemClassObject;

	NTDM_ERR_IF_MINUSONE(ListView_InsertItem(m_hwndListView, &lvItem));

	pIWbemClassObject->AddRef();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::OnEdit()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
		NTDM_EXIT(E_FAIL);
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			g_pEditPolicyTemplatePropertiesPage = new CEditPolicyTemplatePropertiesPageDlg((IWbemClassObject *)lvItem.lParam, m_pPolicyTemplateManager->m_pIWbemServices);

			if(IDOK == DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_POLICY_TEMPLATE_PROPERTIES), m_hWnd, EditPolicyTemplatePropertiesPageDlgProc))
			{
				// Refresh the SOM filters
				NTDM_ERR_IF_FAIL(PopulatePolicyTemplatesList());
			}
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::OnDelete()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
		NTDM_EXIT(E_FAIL);
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			CComVariant vValue;
			CIMTYPE cimType;

			IWbemClassObject * pIWbemClassObject = (IWbemClassObject *)lvItem.lParam;
			
			NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("__PATH"), 0, &vValue, &cimType, NULL));
			NTDM_ERR_MSG_IF_FAIL(m_pPolicyTemplateManager->m_pIWbemServices->DeleteInstance(V_BSTR(&vValue), 0, NULL, NULL));

			// Refresh the SOM filters
			NTDM_ERR_IF_FAIL(PopulatePolicyTemplatesList());
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::OnNew()
{
	HRESULT hr;
	CComPtr<IWbemClassObject>pIWbemClassObject;
	CComPtr<IWbemClassObject>pIWbemNewInstance;
	CComBSTR bstrTemp;

	NTDM_BEGIN_METHOD()

	bstrTemp = _T("MSFT_PolicyTemplate");

	NTDM_ERR_MSG_IF_FAIL(m_pPolicyTemplateManager->m_pIWbemServices->GetObject(bstrTemp, 0, NULL, &pIWbemClassObject, NULL));
	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->SpawnInstance(0, &pIWbemNewInstance));

	g_pEditPolicyTemplatePropertiesPage = new CEditPolicyTemplatePropertiesPageDlg(pIWbemNewInstance, m_pPolicyTemplateManager->m_pIWbemServices);

	if(IDOK == DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_POLICY_TEMPLATE_PROPERTIES), m_hWnd, EditPolicyTemplatePropertiesPageDlgProc))
	{
		// Refresh the SOM filters
		NTDM_ERR_IF_FAIL(PopulatePolicyTemplatesList());
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::PopulatePolicyTypeList()
{
	HRESULT hr;
	CComPtr<IEnumWbemClassObject> pEnumWbemClassObject;
	CComBSTR bstrClass(_T("MSFT_PolicyType"));
	ULONG uReturned;

	NTDM_BEGIN_METHOD()

	if(!m_pPolicyTemplateManager->m_pIWbemServices)
		NTDM_EXIT(E_FAIL);

	NTDM_ERR_IF_FAIL(ClearPolicyTypeList());

	// Get the Enumeration
	NTDM_ERR_MSG_IF_FAIL(m_pPolicyTemplateManager->m_pIWbemServices->CreateInstanceEnum(bstrClass, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumWbemClassObject));

	// Loop through each item in the enumeration and add it to the list
	while(true)
	{
		IWbemClassObject *pIWbemClassObject = NULL;

		NTDM_ERR_MSG_IF_FAIL(pEnumWbemClassObject->Next(WBEM_INFINITE, 1, &pIWbemClassObject, &uReturned));

		if(!uReturned)
			break;

		// Add current Item to the list
		AddPolicyTypeToList(pIWbemClassObject);

		pIWbemClassObject->Release();
	}

	SendDlgItemMessage(m_hWnd, IDC_POLICY_TYPE, CB_SETCURSEL, 0, 0);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::AddPolicyTypeToList(IWbemClassObject * pIWbemClassObject)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE vType;
	long lIndex;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("ID"), 0, &vValue, &vType, NULL));

	lIndex = SendDlgItemMessage(m_hWnd, IDC_POLICY_TYPE, CB_ADDSTRING, 0, (LPARAM)vValue.bstrVal);

	NTDM_CHECK_CB_ERR(lIndex);
	NTDM_CHECK_CB_ERR(SendDlgItemMessage(m_hWnd, IDC_POLICY_TYPE, CB_SETITEMDATA, lIndex, (LPARAM)pIWbemClassObject));

	pIWbemClassObject->AddRef();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::ClearPolicyTypeList()
{
	HRESULT hr;
	long lCount;
	IWbemClassObject * pIWbemClassObject = NULL;

	NTDM_BEGIN_METHOD()

	// Release all the objects.
	lCount = SendDlgItemMessage(m_hWnd, IDC_POLICY_TYPE, CB_GETCOUNT, 0, 0);
	NTDM_CHECK_CB_ERR(lCount);

	while(lCount > 0)
	{
		lCount--;

		pIWbemClassObject = (IWbemClassObject *)SendDlgItemMessage(m_hWnd, IDC_POLICY_TYPE, CB_GETITEMDATA, lCount, 0);
		if(pIWbemClassObject)
		{
			pIWbemClassObject->Release();
		}
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CPolicyTemplateManagerDlg::OnPolicyTypeChange()
{
	HRESULT hr;
	long lIndex;
	IWbemClassObject * pIWbemClassObject = NULL;

	NTDM_BEGIN_METHOD()

	// Release all the objects.
	lIndex = SendDlgItemMessage(m_hWnd, IDC_POLICY_TYPE, CB_GETCURSEL, 0, 0);
	NTDM_CHECK_CB_ERR(lIndex);

	pIWbemClassObject = (IWbemClassObject *)SendDlgItemMessage(m_hWnd, IDC_POLICY_TYPE, CB_GETITEMDATA, lIndex, 0);

	if(pIWbemClassObject)
		m_pIPolicyTypeClassObject = pIWbemClassObject;

	NTDM_ERR_IF_FAIL(PopulatePolicyTemplatesList());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\schemamanager.cpp ===
// SchemaManager.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SchemaManagerps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <wbemidl.h>
#include "SchemaManager.h"
#include "ntdmutils.h"

#include "SchemaManager_i.c"
#include "WMIFilterManager.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_WMIFilterManager, CWMIFilterManager)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SCHEMAMANAGERLib);
        DisableThreadLibraryCalls(hInstance);
		CNTDMUtils::Initialize();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
        _Module.Term();
		CNTDMUtils::UnInitialize();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SchemaManager.rc
//
#define IDS_PROJNAME                    100
#define IDS_ERROR                       101
#define IDR_SOMFILTERMANAGER            102
#define IDS_WARN_OVERWRITE              102
#define IDR_POLICYTEMPLATEMANAGER       103
#define IDR_WMIFILTERBROWSER            104
#define IDS_QUERY                       105
#define IDS_NAME                        106
#define IDS_QUERY_LANGUAGE              107
#define IDS_TARGET_NAMESPACE            108
#define IDS_TYPE                        109
#define IDS_VALUE                       110
#define IDR_WMIFILTERMANAGER            111
#define IDS_UNABLE_TO_DISPLAY           113
#define IDS_CIMTYPES                    114
#define IDS_ERR_STORING_DATA            115
#define IDS_ERR_NO_FILTER_SELECTED      118
#define IDS_ERR_NO_PROPERTY_SELECTED    119
#define IDS_ERR_NO_RULE_SELECTED        120
#define IDS_ALL_FILES_FILTER            179
#define IDS_TEXT_FILES_FILTER           180
#define IDS_ERR_COULD_NOT_CREATE_FILE   181
#define IDS_ERROR_DESCRIPTION           182
#define IDS_ERROR_SOURCE                183
#define IDS_NO_SOURCE_NAME_PROVIDED     184
#define IDS_NO_DESCRIPTION_PROVIDED     185
#define IDS_FAILED_COMPILING_MOF_FILE   186
#define IDS_MOF_FILES_FILTER            187
#define IDS_ERR_NO_RANGE_SELECTED       188
#define IDS_RANGE_NAMES                 189
#define IDS_CONFIRM_DELETE_FILTER       190
#define IDS_DELETE_FILTER               191
#define IDS_DETAILS1                    192
#define IDS_DETAILS2                    193
#define IDS_NEW_FILTER_NAME             194
#define IDS_PROMPT_FOR_SAVE             195
#define IDS_WMI_FILTER_MANAGER          196
#define IDS_DESCRIPTION                 197
#define IDS_DSPATH                      198
#define IDS_AUTHOR                      199
#define IDS_SOURCE_ORGANIZATION         200
#define IDD_SOM_FILTER_MANAGER          201
#define IDC_POLICY_TYPE                 201
#define IDS_CREATION_DATE               201
#define IDI_SOM_FILTER_MANAGER          202
#define IDC_POLICY_TEMPLATE_PROPERTIES_LIST 202
#define IDC_ALL_FILTERS                 202
#define IDD_FILTER_PROPERTIES           202
#define IDS_CHANGE_DATE                 202
#define IDD_SOM_FILTER_PROPERTIES       203
#define IDC_RANGE_PARAMETER_LIST        203
#define IDS_POLICY_TYPE                 203
#define IDD_EDIT_STRING_PROPERTY        204
#define IDC_PROPERTY_NAME               204
#define IDS_HELP_ERR                    204
#define IDD_EDIT_NUMBER_PROPERTY        205
#define IDC_TARGET_CLASS                205
#define IDD_EDIT_ARRAY_PROPERTY         206
#define IDC_TARGET_TYPE                 206
#define IDC_VIEW                        206
#define IDD_EDIT_RULES_PROPERTY         207
#define IDC_PARAMETER_TYPE              207
#define IDD_EDIT_RULE                   208
#define IDC_DEFAULT_RANGE_TEXT          208
#define IDC_DSPATH                      208
#define IDD_POLICY_TEMPLATE_MANAGER     209
#define IDC_DEFAULT_RANGE_VALUE         209
#define IDC_ID                          209
#define IDD_POLICY_TEMPLATE_PROPERTIES  210
#define IDC_MIN_RANGE_TEXT              210
#define IDC_SOURCE_ORGANIZATION         210
#define IDD_EDIT_RANGE_PARAMETERS_PROPERTY 211
#define IDC_DEFAULT_SET_TEXT            211
#define IDC_AUTHOR                      211
#define IDD_EDIT_RANGE_PARAMETER        212
#define IDC_DEFAULT_SET_VALUE           212
#define IDC_CHANGE_DATE                 212
#define IDD_EDIT_RANGE_PARAMETER1       213
#define IDC_VALUES_SET_TEXT             213
#define IDC_CREATION_DATE               213
#define IDD_EDIT_RANGE_PARAMETER2       214
#define IDC_VALUES_SET_LIST             214
#define IDC_MIN_RANGE_VALUE             215
#define IDC_SOM_FILTER_LIST             215
#define IDC_RULES                       215
#define IDD_WMI_FILTER_BROWSER_OLD      215
#define IDC_MAX_RANGE_TEXT              216
#define IDD_WMI_FILTER_MANAGER          216
#define IDC_EDIT                        217
#define IDD_WMI_FILTER_MANAGER1         217
#define IDD_COLUMN_MANAGER              217
#define IDD_POLICY_TEMPLATE_PARAMETERS  218
#define IDC_MAX_RANGE_VALUE             219
#define IDC_WMI_FILTER_LIST             220
#define IDC_FILTER_PROPERTIES_LIST      221
#define IDC_SAVE                        221
#define IDC_COLUMNS_LIST                222
#define IDC_IMPORT                      223
#define IDC_MOVE_UP                     223
#define IDC_MOVE_DOWN                   224
#define IDC_ADVANCED                    225
#define IDC_TYPE                        226
#define IDC_EDIT1                       226
#define IDC_COLUMNS                     226
#define IDC_DEFAULT_VALUE               226
#define IDC_VALUE                       227
#define IDC_QUERIES                     227
#define IDC_EDIT3                       228
#define IDC_DESCRIPTION                 228
#define IDC_FILTER_ELEMENTS_LIST        229
#define IDC_QUERIES_LIST                229
#define IDC_DUPLICATE                   229
#define IDC_ADD                         230
#define IDC_QUERY_LANGUAGE              231
#define IDC_TARGET_NAMESPACE            232
#define IDC_QUERY                       233
#define IDC_PARAMETERS                  234
#define IDC_EXPORT                      235
#define IDC_PARAMETER_NAME              235
#define IDC_DELETE                      236
#define IDC_ENFORCED                    236
#define IDC_ADD_QUERY                   237
#define IDC_LIST                        237
#define IDC_EDIT_QUERY                  238
#define IDC_RANGE                       238
#define IDC_DELETE_QUERY                239
#define IDC_ANY                         239
#define IDC_NAME                        240
#define IDC_RANGE_BOX                   240
#define IDD_WMI_FILTER_BROWSER          241
#define IDD_WMI_FILTER_MANAGER2         242
#define IDC_LIST_VALUES                 242
#define IDD_POLICY_TEMPLATE_PARAMETERS1 243
#define IDC_LIST_VALUES_TITLE           243
#define IDD_POLICY_TEMPLATE_PARAMETERS2 244
#define IDC_MINIMUM_TEXT                244
#define IDC_MINIMUM                     245
#define IDC_MAXIMUM_TEXT                246
#define IDC_MAXIMUM                     247
#define IDC_NEW                         249
#define IDC_HELP2                       250

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        219
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         248
#define _APS_NEXT_SYMED_VALUE           112
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\policytemplatemgrdlg.h ===
//-------------------------------------------------------------------------
// File: PolicyTemplateMgrDlg.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

INT_PTR CALLBACK PolicyTemplateManagerDlgProc(HWND hDLG, UINT iMessage, WPARAM wParam, LPARAM lParam);

class CPolicyTemplateManager;

class CPolicyTemplateManagerDlg
{
	public:
		CPolicyTemplateManagerDlg(CPolicyTemplateManager * pPolicyTemplateManager);
		~CPolicyTemplateManagerDlg();
		INT_PTR CALLBACK PolicyTemplateManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);

	protected:
		
		STDMETHODIMP PopulatePolicyTemplatesList();
		STDMETHODIMP AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex=MAX_LIST_ITEMS);
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
		BOOL OnKillActive();
		STDMETHODIMP OnNew();
		STDMETHODIMP OnEdit();
		STDMETHODIMP OnDelete();
		STDMETHODIMP ClearPolicyTemplateList();
		STDMETHODIMP PopulatePolicyTypeList();
		STDMETHODIMP AddPolicyTypeToList(IWbemClassObject * pIWbemClassObject);
		STDMETHODIMP ClearPolicyTypeList();
		STDMETHODIMP OnPolicyTypeChange();

		HWND m_hWnd;
		CPolicyTemplateManager * m_pPolicyTemplateManager;
		CComPtr<IWbemClassObject>m_pIPolicyTypeClassObject;
		HWND m_hwndListView;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\somfiltermanager.h ===
// SomFilterManager.h : Declaration of the CSomFilterManager

#ifndef __SOMFILTERMANAGER_H_
#define __SOMFILTERMANAGER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CSomFilterManager
class ATL_NO_VTABLE CSomFilterManager : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSomFilterManager, &CLSID_SomFilterManager>,
	public IDispatchImpl<ISomFilterManager, &IID_ISomFilterManager, &LIBID_SCHEMAMANAGERLib>
{
public:
	CSomFilterManager();
	~CSomFilterManager();

DECLARE_REGISTRY_RESOURCEID(IDR_SOMFILTERMANAGER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSomFilterManager)
	COM_INTERFACE_ENTRY(ISomFilterManager)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISomFilterManager
public:
	STDMETHOD(SetMultiSelection)(VARIANT_BOOL vbValue);
	STDMETHOD(RunManager)(HWND hwndParent, VARIANT *vSelection);
	STDMETHOD(ConnectToWMI)();

	CComPtr<IWbemServices>m_pIWbemServices;
	HWND m_hWnd;
};

#endif //__SOMFILTERMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\somfiltermanager.cpp ===
// SomFilterManager.cpp : Implementation of CSomFilterManager
#include "stdafx.h"
#include <wbemidl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "SomFilterManager.h"
#include "SomFilterMgrDlg.h"

extern CSomFilterManagerDlg * g_pFilterManagerDlg;

/////////////////////////////////////////////////////////////////////////////
// CSomFilterManager

CSomFilterManager::CSomFilterManager()
{
	m_hWnd = NULL;
}

//---------------------------------------------------------------------------

CSomFilterManager::~CSomFilterManager()
{
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManager::ConnectToWMI()
{
	HRESULT hr;
	CComPtr<IWbemLocator>pIWbemLocator;

	NTDM_BEGIN_METHOD()

	m_pIWbemServices = NULL;

	// create the webm locator
	NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
			IID_IWbemLocator, (LPVOID *) &pIWbemLocator));

	NTDM_ERR_MSG_IF_FAIL(pIWbemLocator->ConnectServer(	_T("root\\policy"),
													NULL,
													NULL,
													NULL,
													0,
													NULL,
													NULL,
													&m_pIWbemServices));

	NTDM_ERR_MSG_IF_FAIL(CoSetProxyBlanket(m_pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE  , 
        NULL, EOAC_NONE));

	
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManager::RunManager(HWND hwndParent, VARIANT *vSelection)
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	m_hWnd = hwndParent;

	NTDM_ERR_IF_FAIL(ConnectToWMI());

	g_pFilterManagerDlg = new CSomFilterManagerDlg(this);
	DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_SOM_FILTER_MANAGER), (HWND)hwndParent, SomFilterManagerDlgProc);
	
	NTDM_END_METHOD()

	// cleanup
	NTDM_DELETE_OBJECT(g_pFilterManagerDlg);

	return hr;
}

//--------------------------------------------------------------------------

STDMETHODIMP CSomFilterManager::SetMultiSelection(VARIANT_BOOL vbValue)
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D8675B3F_E62E_41AE_BF56_5ABB01A74371__INCLUDED_)
#define AFX_STDAFX_H__D8675B3F_E62E_41AE_BF56_5ABB01A74371__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D8675B3F_E62E_41AE_BF56_5ABB01A74371__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\somfiltermgrdlg.cpp ===
//-------------------------------------------------------------------------
// File: CDlgSomFilterManager.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "SomFilterManager.h"
#include "SomFilterMgrDlg.h"
#include "SomFilterEditPropertiesDlg.h"

CSomFilterManagerDlg * g_pFilterManagerDlg =  NULL;
extern CEditSomFilterPropertiesPageDlg * g_pEditSomFilterPropertiesPage;

//-------------------------------------------------------------------------

INT_PTR CALLBACK SomFilterManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pFilterManagerDlg)
	{
		return g_pFilterManagerDlg->SomFilterManagerDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CSomFilterManagerDlg::CSomFilterManagerDlg(CSomFilterManager * pSomFilterManager)
{
	_ASSERT(pSomFilterManager);

	m_hWnd = NULL;
	m_hwndListView = NULL;
	m_pSomFilterManager = pSomFilterManager;
}

//-------------------------------------------------------------------------

CSomFilterManagerDlg::~CSomFilterManagerDlg()
{
}


//-------------------------------------------------------------------------

INT_PTR CALLBACK CSomFilterManagerDlg::SomFilterManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				PopulateFilterList();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
				case IDCANCEL:
					EndDialog(m_hWnd, 0);
					return TRUE;

				case IDOK:
					OnOK();
					return TRUE;
					break;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_NEW == LOWORD(wParam))
				{
					OnNew();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EDIT == LOWORD(wParam))
				{
					OnEdit();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_DELETE == LOWORD(wParam))
				{
					OnDelete();
					return TRUE;
				}

				break;
			}

		case WM_NOTIFY:
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;

			switch (lpnm->code)
			{
				case NM_DBLCLK :
				{
					if(lpnm->idFrom == IDC_SOM_FILTER_LIST)
					{
						OnEdit();
						return TRUE;
					}
					break;
				}

				default :
					break;
			}
		}

	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManagerDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	CComBSTR bstrName;
	
	NTDM_BEGIN_METHOD()

	bstrName.LoadString(_Module.GetResourceInstance(), IDS_NAME);

	//Initialize the ListView Control

	m_hwndListView = GetDlgItem(m_hWnd, IDC_SOM_FILTER_LIST);
	NTDM_ERR_IF_NULL(m_hwndListView);

	ListView_SetExtendedListViewStyle(m_hwndListView, LVS_EX_FULLROWSELECT);

	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.pszText = bstrName;

	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndListView, 0, &lvColumn));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndListView, 0, LVSCW_AUTOSIZE_USEHEADER));
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManagerDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearFilterList());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManagerDlg::ClearFilterList()
{
	HRESULT hr;
	LVITEM lvItem;
	long lCount;

	NTDM_BEGIN_METHOD()

	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndListView);

	while(lCount > 0)
	{
		lCount--;

		lvItem.iItem = lCount;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			((IWbemClassObject *)lvItem.lParam)->Release();
		}
	}

	ListView_DeleteAllItems(m_hwndListView);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManagerDlg::PopulateFilterList()
{
	HRESULT hr;
	CComPtr<IEnumWbemClassObject> pEnumWbemClassObject;
	CComBSTR bstrClass(_T("MSFT_SomFilter"));
	ULONG uReturned;

	NTDM_BEGIN_METHOD()

	if(!m_pSomFilterManager->m_pIWbemServices)
		NTDM_EXIT(E_FAIL);

	NTDM_ERR_IF_FAIL(ClearFilterList());

	// Get the Enumeration
	NTDM_ERR_MSG_IF_FAIL(m_pSomFilterManager->m_pIWbemServices->CreateInstanceEnum(bstrClass, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumWbemClassObject));

	// Loop through each item in the enumeration and add it to the list
	while(true)
	{
		IWbemClassObject *pIWbemClassObject = NULL;

		NTDM_ERR_MSG_IF_FAIL(pEnumWbemClassObject->Next(WBEM_INFINITE, 1, &pIWbemClassObject, &uReturned));

		if(!uReturned)
			break;

		// Add current Item to the list
		AddItemToList(pIWbemClassObject);

		pIWbemClassObject->Release();
	}

	ListView_SetItemState(m_hwndListView, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManagerDlg::AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE vType;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("Name"), 0, &vValue, &vType, NULL));

	lvItem.mask = LVIF_TEXT|LVIF_PARAM;
	lvItem.iItem = lIndex;
	lvItem.iSubItem = 0;
	lvItem.pszText = vValue.bstrVal;
	lvItem.lParam = (LPARAM)pIWbemClassObject;

	NTDM_ERR_IF_MINUSONE(ListView_InsertItem(m_hwndListView, &lvItem));

	pIWbemClassObject->AddRef();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManagerDlg::OnEdit()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
		NTDM_EXIT(E_FAIL);
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			g_pEditSomFilterPropertiesPage = new CEditSomFilterPropertiesPageDlg((IWbemClassObject *)lvItem.lParam, m_pSomFilterManager->m_pIWbemServices);

			if(IDOK == DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_SOM_FILTER_PROPERTIES), m_hWnd, EditSomFilterPropertiesPageDlgProc))
			{
				// Refresh the SOM filters
				NTDM_ERR_IF_FAIL(PopulateFilterList());
			}
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManagerDlg::OnDelete()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
		NTDM_EXIT(E_FAIL);
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			CComVariant vValue;
			CIMTYPE cimType;

			IWbemClassObject * pIWbemClassObject = (IWbemClassObject *)lvItem.lParam;
			
			NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("__PATH"), 0, &vValue, &cimType, NULL));
			NTDM_ERR_MSG_IF_FAIL(m_pSomFilterManager->m_pIWbemServices->DeleteInstance(V_BSTR(&vValue), 0, NULL, NULL));

			// Refresh the SOM filters
			NTDM_ERR_IF_FAIL(PopulateFilterList());
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CSomFilterManagerDlg::OnNew()
{
	HRESULT hr;
	CComPtr<IWbemClassObject>pIWbemClassObject;
	CComPtr<IWbemClassObject>pIWbemNewInstance;
	CComBSTR bstrTemp;

	NTDM_BEGIN_METHOD()

	bstrTemp = _T("MSFT_SomFilter");

	NTDM_ERR_MSG_IF_FAIL(m_pSomFilterManager->m_pIWbemServices->GetObject(bstrTemp, 0, NULL, &pIWbemClassObject, NULL));
	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->SpawnInstance(0, &pIWbemNewInstance));

	g_pEditSomFilterPropertiesPage = new CEditSomFilterPropertiesPageDlg(pIWbemNewInstance, m_pSomFilterManager->m_pIWbemServices);

	if(IDOK == DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_SOM_FILTER_PROPERTIES), m_hWnd, EditSomFilterPropertiesPageDlgProc))
	{
		// Refresh the SOM filters
		NTDM_ERR_IF_FAIL(PopulateFilterList());
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

BOOL CSomFilterManagerDlg::OnOK()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
		goto error;
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			m_pIWbemClassObject = (IWbemClassObject *)lvItem.lParam;
			m_pIWbemClassObject->AddRef();
		}
	}

	EndDialog(m_hWnd, IDOK);

	NTDM_END_METHOD()

	// cleanup

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\somfiltereditpropertiesdlg.h ===
//-------------------------------------------------------------------------
// File: SomFilterEditPropertiesDlg.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

INT_PTR CALLBACK EditSomFilterPropertiesPageDlgProc(HWND hDLG, UINT iMessage, WPARAM wParam, LPARAM lParam);

class CSomFilterManager;

class CEditSomFilterPropertiesPageDlg
{
	public:
		CEditSomFilterPropertiesPageDlg(IWbemClassObject * pISomFilterClassObject, IWbemServices * pIWbemServices);
		~CEditSomFilterPropertiesPageDlg();
		INT_PTR CALLBACK EditSomFilterPropertiesPageDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);

	protected:
		
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
		STDMETHODIMP PopulateSomFilterPropertiesList();
		STDMETHODIMP AddItemToPropertyList(LPCTSTR pcszName, VARIANT * vValue, CIMTYPE cimType, long lIndex=MAX_LIST_ITEMS);
		STDMETHODIMP ClearSomFilterPropertiesList();
		STDMETHODIMP OnEdit();
		STDMETHODIMP OnOK();
		STDMETHODIMP OnImport();
		STDMETHODIMP OnExport();
		STDMETHODIMP GetInstanceOfClass(BSTR pszNamespace, LPCTSTR pszClass, IWbemClassObject ** ppWbemClassObject);

		HWND m_hWnd;
		HWND m_hwndPropertiesListView;
		CSomFilterManager *m_pSomFilterManager;
		CComPtr<IWbemClassObject>m_pISomFilterClassObject;
		CComPtr<IWbemServices>m_pIWbemServices;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\wmifilterbrowser.cpp ===
// WMIFilterBrowser.cpp : Implementation of CWMIFilterBrowser
#include "stdafx.h"
#include <wbemidl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "WMIFilterBrowser.h"
#include "WMIFilterBrowserDlg.h"

extern CWMIFilterBrowserDlg * g_pWMIFilterBrowserDlg;

/////////////////////////////////////////////////////////////////////////////
// CWMIFilterBrowser

CWMIFilterBrowser::CWMIFilterBrowser()
{
}

//--------------------------------------------------------------------------

CWMIFilterBrowser::~CWMIFilterBrowser()
{
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterBrowser::ConnectToWMI()
{
	HRESULT hr;
	CComPtr<IWbemLocator>pIWbemLocator;

	NTDM_BEGIN_METHOD()

	m_pIWbemServices = NULL;

	// create the webm locator
	NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
			IID_IWbemLocator, (LPVOID *) &pIWbemLocator));

	NTDM_ERR_MSG_IF_FAIL(pIWbemLocator->ConnectServer(	_T("root\\policy"),
													NULL,
													NULL,
													NULL,
													0,
													NULL,
													NULL,
													&m_pIWbemServices));

	NTDM_ERR_MSG_IF_FAIL(CoSetProxyBlanket(m_pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE  , 
        NULL, EOAC_NONE));

	
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//--------------------------------------------------------------------------

STDMETHODIMP CWMIFilterBrowser::RunBrowser(HWND hwndParent, VARIANT *vSelection)
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	m_hWnd = hwndParent;

	NTDM_ERR_IF_FAIL(ConnectToWMI());

	g_pWMIFilterBrowserDlg = new CWMIFilterBrowserDlg(this);
	if(IDOK == DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_WMI_FILTER_BROWSER), (HWND)hwndParent, WMIFilterBrowserDlgProc))
	{
		VariantClear(vSelection);

		V_VT(vSelection) = VT_UNKNOWN;
		NTDM_ERR_IF_FAIL(g_pWMIFilterBrowserDlg->m_pIWbemClassObject->QueryInterface(IID_IUnknown, (void **)&(V_UNKNOWN(vSelection))));
	}
	
	NTDM_END_METHOD()

	// cleanup
	NTDM_DELETE_OBJECT(g_pWMIFilterBrowserDlg);

	return hr;
}

//--------------------------------------------------------------------------

STDMETHODIMP CWMIFilterBrowser::SetMultiSelection(VARIANT_BOOL vbValue)
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\somfiltereditpropertiesdlg.cpp ===
//-------------------------------------------------------------------------
// File: SomFilterEditPropertiesDlg.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "SomFilterManager.h"
#include "SomFilterEditPropertiesDlg.h"
#include "EditPropertyDlgs.h"


extern USHORT g_CIMTypes[];
extern CSimpleArray<BSTR> g_bstrCIMTypes;

CEditSomFilterPropertiesPageDlg * g_pEditSomFilterPropertiesPage =  NULL;

//-------------------------------------------------------------------------

INT_PTR CALLBACK EditSomFilterPropertiesPageDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pEditSomFilterPropertiesPage)
	{
		return g_pEditSomFilterPropertiesPage->EditSomFilterPropertiesPageDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CEditSomFilterPropertiesPageDlg::CEditSomFilterPropertiesPageDlg(IWbemClassObject * pISomFilterClassObject, IWbemServices * pIWbemServices)
{
	_ASSERT(pISomFilterClassObject);
	_ASSERT(pIWbemServices);

	m_hWnd = NULL;
	m_pISomFilterClassObject = pISomFilterClassObject;
	m_pIWbemServices = pIWbemServices;
}

//-------------------------------------------------------------------------

CEditSomFilterPropertiesPageDlg::~CEditSomFilterPropertiesPageDlg()
{
}


//-------------------------------------------------------------------------

INT_PTR CALLBACK CEditSomFilterPropertiesPageDlg::EditSomFilterPropertiesPageDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
					case IDOK:
					{
						OnOK();
						return TRUE;
						break;
					}
					case IDCANCEL:
					{
						EndDialog(m_hWnd, IDCANCEL);
						return TRUE;
						break;
					}
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EDIT == LOWORD(wParam))
				{
					OnEdit();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_IMPORT == LOWORD(wParam))
				{
					OnImport();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EXPORT == LOWORD(wParam))
				{
					OnExport();
					return TRUE;
				}

				break;
			}

		case WM_NOTIFY:
			{
				LPNMHDR lpnm = (LPNMHDR) lParam;

				switch (lpnm->code)
				{
					case NM_DBLCLK :
					{
						if(lpnm->idFrom == IDC_FILTER_PROPERTIES_LIST)
						{
							OnEdit();
							return TRUE;
						}
						break;
					}

					default :
						break;
				}
			}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	CComBSTR bstrTemp;
	
	NTDM_BEGIN_METHOD()

	//Initialize the Property List Control
	m_hwndPropertiesListView = GetDlgItem(m_hWnd, IDC_FILTER_PROPERTIES_LIST);
	NTDM_ERR_IF_NULL(m_hwndPropertiesListView);
	ListView_SetExtendedListViewStyle(m_hwndPropertiesListView, LVS_EX_FULLROWSELECT);

	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_NAME);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndPropertiesListView, 0, &lvColumn));

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_TYPE);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndPropertiesListView, 1, &lvColumn));

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_VALUE);
	lvColumn.pszText = bstrTemp;
	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndPropertiesListView, 2, &lvColumn));

	PopulateSomFilterPropertiesList();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearSomFilterPropertiesList());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::ClearSomFilterPropertiesList()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	ListView_DeleteAllItems(m_hwndPropertiesListView);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::PopulateSomFilterPropertiesList()
{
	HRESULT hr;
	CComPtr<IEnumWbemClassObject> pEnumWbemClassObject;
	CComBSTR bstrName;
	CComVariant vValue;
	CIMTYPE cimType;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearSomFilterPropertiesList());

	if(!m_pIWbemServices)
		NTDM_EXIT(E_FAIL);

	NTDM_ERR_MSG_IF_FAIL(m_pISomFilterClassObject->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY));

	while(true)
	{
		NTDM_ERR_MSG_IF_FAIL(m_pISomFilterClassObject->Next(0, &bstrName, &vValue, &cimType, NULL));

		if(WBEM_S_NO_MORE_DATA == hr)
			break;

		NTDM_ERR_IF_FAIL(AddItemToPropertyList(bstrName, &vValue, cimType));
	}


	NTDM_ERR_MSG_IF_FAIL(m_pISomFilterClassObject->EndEnumeration());

	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndPropertiesListView, 0, LVSCW_AUTOSIZE_USEHEADER));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndPropertiesListView, 1, LVSCW_AUTOSIZE_USEHEADER));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndPropertiesListView, 2, LVSCW_AUTOSIZE_USEHEADER));

	ListView_SetItemState(m_hwndPropertiesListView, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::AddItemToPropertyList(LPCTSTR pcszName, VARIANT * pvValue, CIMTYPE cimType, long lIndex)
{
	HRESULT hr;
	LVITEM lvItem;
	CComVariant vValue;
	long i;

	NTDM_BEGIN_METHOD()

	vValue = *pvValue;

	// Name
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = lIndex;
	lvItem.iSubItem = 0;
	lvItem.pszText = (LPTSTR)pcszName;

	lvItem.iItem = ListView_InsertItem(m_hwndPropertiesListView, &lvItem);
	NTDM_ERR_IF_MINUSONE(lvItem.iItem);

	// Type
	lvItem.mask = LVIF_TEXT;
	lvItem.iSubItem = 1;
	lvItem.pszText = _T("");
	for(i=0; i<g_bstrCIMTypes.GetSize(); i++)
	{
		// if Array and the type contains CIM_FLAG_ARRAY then show array
		if((g_CIMTypes[i] == cimType)||((g_CIMTypes[i] == CIM_FLAG_ARRAY) && (CIM_FLAG_ARRAY & cimType)))
		{
			lvItem.pszText = (LPTSTR)g_bstrCIMTypes[i];
			break;
		}
	}

	NTDM_ERR_IF_MINUSONE(ListView_SetItem(m_hwndPropertiesListView, &lvItem));


	// Value
	if FAILED(hr = VariantChangeType(&vValue, &vValue, VARIANT_ALPHABOOL|VARIANT_LOCALBOOL, VT_BSTR))
	{
		if(V_VT(&vValue) == VT_NULL)
		{
			vValue = _T("");
		}
		else
		{
			CComBSTR bstrTemp;
			bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_UNABLE_TO_DISPLAY);

			vValue = bstrTemp;
		}

		hr = NOERROR;
	}

	lvItem.mask = LVIF_TEXT;
	lvItem.iSubItem = 2;
	lvItem.pszText = vValue.bstrVal;

	NTDM_ERR_IF_MINUSONE(ListView_SetItem(m_hwndPropertiesListView, &lvItem));

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::OnEdit()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndPropertiesListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_PROPERTY_SELECTED);
		NTDM_EXIT(E_FAIL);
	}
	else
	{
		TCHAR pszBuffer[SZ_MAX_SIZE];
		VARIANT vValue;
		CComBSTR bstrName;
		CComBSTR bstrType;
		CIMTYPE cimType;
		LVITEM lvItem;
		long i;

		VariantInit(&vValue);

		// get the property info
		lvItem.mask = LVIF_TEXT;
		lvItem.iItem = lSelectionMark;
		lvItem.iSubItem = 0;
		lvItem.pszText = pszBuffer;
		lvItem.cchTextMax = SZ_MAX_SIZE;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndPropertiesListView, &lvItem));

		if(lvItem.pszText)
		{
			bstrName = lvItem.pszText;
			long lSpecialCaseProperty = 0;

			NTDM_ERR_MSG_IF_FAIL(m_pISomFilterClassObject->Get(bstrName, 0, &vValue, &cimType, NULL));

			if(_tcscmp(_T("RangeSettings"), bstrName) == 0)
			{
				lSpecialCaseProperty = CEditProperty::psc_rules;
			}

			for(i=0; i<g_bstrCIMTypes.GetSize(); i++)
			{
				// if Array and the type contains CIM_FLAG_ARRAY then show array
				if((g_CIMTypes[i] == cimType)||((g_CIMTypes[i] == CIM_FLAG_ARRAY) && (CIM_FLAG_ARRAY & cimType)))
				{
					bstrType = (LPTSTR)g_bstrCIMTypes[i];
					break;
				}
			}

			CEditProperty dlgProps(m_hWnd, lvItem.pszText, bstrType, &vValue, m_pIWbemServices, lSpecialCaseProperty);
			if(IDOK == dlgProps.Run())
			{
				// delete the selected entry
				NTDM_ERR_MSG_IF_FAIL(m_pISomFilterClassObject->Put(bstrName, 0, &vValue, cimType));
				NTDM_ERR_IF_FALSE(ListView_DeleteItem(m_hwndPropertiesListView, lSelectionMark));
				NTDM_ERR_IF_FAIL(AddItemToPropertyList(bstrName, &vValue, cimType, lSelectionMark));
			}
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::OnOK()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->PutInstance(m_pISomFilterClassObject, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL));

	hr = S_OK;

	NTDM_END_METHOD()

	// cleanup
	if(SUCCEEDED(hr))
	{
		EndDialog(m_hWnd, IDOK);
	}

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::OnImport()
{
	HRESULT hr;
	CComBSTR bstrFilter;
	TCHAR pszFile[MAX_PATH];
	CComBSTR bstrTemp;

	pszFile[0] = 0;

	NTDM_BEGIN_METHOD()

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_ALL_FILES_FILTER);
	bstrFilter.LoadString(_Module.GetResourceInstance(), IDS_MOF_FILES_FILTER);
	bstrFilter += bstrTemp;
	CNTDMUtils::ReplaceCharacter(bstrFilter, L'@', L'\0');

	if(CNTDMUtils::OpenFileNameDlg(bstrFilter, _T("*.*"), m_hWnd, pszFile) && pszFile)
	{
		CComPtr<IMofCompiler>pIMofCompiler;
		CComPtr<IWbemClassObject>pINamespaceClass;
		CComPtr<IWbemClassObject>pIWbemNewInstance;
		CComPtr<IWbemClassObject>pIWbemClassObject;
		CComVariant vValue = _T("DeleteThisNamespace");
		WBEM_COMPILE_STATUS_INFO pInfo;

		// Generate a temporary namespace
		bstrTemp = _T("__Namespace");
		NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->GetObject(bstrTemp, WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pINamespaceClass, NULL));
		NTDM_ERR_MSG_IF_FAIL(pINamespaceClass->SpawnInstance(0, &pIWbemNewInstance));
		NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("Name"), 0, &vValue, CIM_STRING));
		NTDM_ERR_MSG_IF_FAIL(m_pIWbemServices->PutInstance(pIWbemNewInstance, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL));

		// mofcomp the file into that namespace
		NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER,IID_IMofCompiler, (void**)&pIMofCompiler));
		NTDM_ERR_IF_FAIL(pIMofCompiler->CompileFile(pszFile, _T("\\\\.\\root\\policy\\DeleteThisNamespace"), NULL, NULL, NULL, WBEM_FLAG_DONT_ADD_TO_LIST, WBEM_FLAG_CREATE_ONLY, WBEM_FLAG_CREATE_ONLY, &pInfo));

		if(hr != WBEM_S_NO_ERROR)
		{
			CNTDMUtils::DisplayMessage(m_hWnd, IDS_FAILED_COMPILING_MOF_FILE);
			NTDM_EXIT(E_FAIL);
		}

		// get the 1st instance of MSFT_SomFilter from the newly created namespace
		NTDM_ERR_IF_FAIL(GetInstanceOfClass(bstrTemp, _T("MSFT_SomFilter"), &pIWbemClassObject));

		// copy the properties
		m_pISomFilterClassObject = pIWbemClassObject;
		PopulateSomFilterPropertiesList();
	}

	NTDM_END_METHOD()

	// finally delete the namespace that we created above
	{
		CComVariant vValue = "\\\\.\\root\\policy:__Namespace.Name=\"DeleteThisNamespace\"";
		m_pIWbemServices->DeleteInstance(V_BSTR(&vValue), 0, NULL, NULL);
	}

	return hr;
}


//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::GetInstanceOfClass(BSTR pszNamespace, LPCTSTR pszClass, IWbemClassObject ** ppWbemClassObject)
{
	HRESULT hr;
	CComPtr<IWbemLocator>pIWbemLocator;
	CComPtr<IWbemServices>pIWbemServices;
	CComPtr<IEnumWbemClassObject>pEnumWbemClassObject;
	CComBSTR bstrClass = _T("MSFT_SomFilter");
	ULONG uReturned;

	NTDM_BEGIN_METHOD()

	// create the webm locator
	NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
			IID_IWbemLocator, (LPVOID *) &pIWbemLocator));

	NTDM_ERR_MSG_IF_FAIL(pIWbemLocator->ConnectServer(	pszNamespace,
													NULL,
													NULL,
													NULL,
													0,
													NULL,
													NULL,
													&pIWbemServices));

	NTDM_ERR_MSG_IF_FAIL(CoSetProxyBlanket(pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE  , 
        NULL, EOAC_NONE));

	NTDM_ERR_MSG_IF_FAIL(pIWbemServices->CreateInstanceEnum(bstrClass, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumWbemClassObject));
	NTDM_ERR_MSG_IF_FAIL(pEnumWbemClassObject->Next(WBEM_INFINITE, 1, ppWbemClassObject, &uReturned));

	if(!uReturned)
		NTDM_EXIT(E_FAIL);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}



//---------------------------------------------------------------------------

STDMETHODIMP CEditSomFilterPropertiesPageDlg::OnExport()
{
	HRESULT hr;
	CComBSTR bstrTemp;
	CComBSTR bstrFilter;
	TCHAR pszFile[MAX_PATH];
	CComBSTR bstrObjectText;
	HANDLE hFile = NULL;
	DWORD dwWritten;
	pszFile[0] = 0;

	NTDM_BEGIN_METHOD()

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_ALL_FILES_FILTER);
	bstrFilter.LoadString(_Module.GetResourceInstance(), IDS_TEXT_FILES_FILTER);
	bstrFilter += bstrTemp;
	CNTDMUtils::ReplaceCharacter(bstrFilter, L'@', L'\0');

	if(CNTDMUtils::SaveFileNameDlg(bstrFilter, _T("*.txt"), m_hWnd, pszFile))
	{
		if(_tcslen(pszFile))
		{
			NTDM_ERR_MSG_IF_FAIL(m_pISomFilterClassObject->GetObjectText(0, &bstrObjectText));

			// save to pszFile
			hFile = CreateFile(pszFile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 
							   NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
			if(hFile == INVALID_HANDLE_VALUE)
			{
				NTDM_ERR_GETLASTERROR_IF_NULL(NULL);
				goto error;
			}

			if(hFile)
			{
				NTDM_ERR_GETLASTERROR_IF_NULL(WriteFile(hFile, bstrObjectText, _tcslen(bstrObjectText) * sizeof(TCHAR), &dwWritten, NULL));
				NTDM_ERR_GETLASTERROR_IF_NULL(CloseHandle(hFile));
				hFile = NULL;
			}
		}
	}

	NTDM_END_METHOD()

	// cleanup
	if(hFile)
	{
		CloseHandle(hFile);
		hFile = NULL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\somfiltermgrdlg.h ===
//-------------------------------------------------------------------------
// File: CDlgQuestionnaire.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

INT_PTR CALLBACK SomFilterManagerDlgProc(HWND hDLG, UINT iMessage, WPARAM wParam, LPARAM lParam);

class CSomFilterManager;

class CSomFilterManagerDlg
{
	public:
		CSomFilterManagerDlg(CSomFilterManager * pSomFilterManager);
		~CSomFilterManagerDlg();
		INT_PTR CALLBACK SomFilterManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);

		IWbemClassObject * m_pIWbemClassObject;

	protected:
		
		STDMETHODIMP PopulateFilterList();
		STDMETHODIMP AddItemToList(IWbemClassObject * pIWbemClassObject, long lIndex=MAX_LIST_ITEMS);
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
		BOOL OnKillActive();
		STDMETHODIMP OnNew();
		STDMETHODIMP OnEdit();
		STDMETHODIMP OnDelete();
		STDMETHODIMP ClearFilterList();
		BOOL OnOK();

		HWND m_hWnd;
		CSomFilterManager * m_pSomFilterManager;
		HWND m_hwndListView;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\wmifilterbrowser.h ===
// WMIFilterBrowser.h : Declaration of the CWMIFilterBrowser

#ifndef __WMIFILTERBROWSER_H_
#define __WMIFILTERBROWSER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWMIFilterBrowser
class ATL_NO_VTABLE CWMIFilterBrowser : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWMIFilterBrowser, &CLSID_WMIFilterBrowser>,
	public IDispatchImpl<IWMIFilterBrowser, &IID_IWMIFilterBrowser, &LIBID_SCHEMAMANAGERLib>
{
public:
	CWMIFilterBrowser();
	~CWMIFilterBrowser();

DECLARE_REGISTRY_RESOURCEID(IDR_WMIFILTERBROWSER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWMIFilterBrowser)
	COM_INTERFACE_ENTRY(IWMIFilterBrowser)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IWMIFilterBrowser
public:
	STDMETHOD(SetMultiSelection)(VARIANT_BOOL vbValue);
	STDMETHOD(RunBrowser)(HWND hwndParent, VARIANT *vSelection);
	STDMETHODIMP ConnectToWMI();

	CComPtr<IWbemServices>m_pIWbemServices;
	HWND m_hWnd;
};

#endif //__WMIFILTERBROWSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\wmifiltermanager.cpp ===
// WMIFilterManager.cpp : Implementation of CWMIFilterManager
#include "stdafx.h"
#include <wbemidl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "WMIFilterManager.h"
#include "WMIFilterMgrDlg.h"

extern CWMIFilterManagerDlg * g_pFilterManagerDlg;

/////////////////////////////////////////////////////////////////////////////
// CWMIFilterManager

CWMIFilterManager::CWMIFilterManager()
{
	m_hWnd = NULL;
}

//---------------------------------------------------------------------------

CWMIFilterManager::~CWMIFilterManager()
{
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManager::ConnectToWMI()
{
	HRESULT hr;
	CComPtr<IWbemLocator>pIWbemLocator;

	NTDM_BEGIN_METHOD()

	m_pIWbemServices = NULL;

	// create the webm locator
	NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
			IID_IWbemLocator, (LPVOID *) &pIWbemLocator));

	NTDM_ERR_MSG_IF_FAIL(pIWbemLocator->ConnectServer(	_T("root\\policy"),
													NULL,
													NULL,
													NULL,
													0,
													NULL,
													NULL,
													&m_pIWbemServices));

	NTDM_ERR_MSG_IF_FAIL(CoSetProxyBlanket(m_pIWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE  , 
        NULL, EOAC_NONE));

	
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManager::RunManager(HWND hwndParent, BSTR bstrDomain, VARIANT *vSelection)
{
	HRESULT hr;

	g_pFilterManagerDlg = NULL;

	NTDM_BEGIN_METHOD()

	m_hWnd = hwndParent;

	NTDM_ERR_IF_FAIL(ConnectToWMI());

	g_pFilterManagerDlg = new CWMIFilterManagerDlg(this, false, bstrDomain);
	NTDM_ERRID_IF_NULL(g_pFilterManagerDlg, E_OUTOFMEMORY);

	if(IDOK == DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_WMI_FILTER_MANAGER), (HWND)hwndParent, WMIFilterManagerDlgProc))
	{
		if(g_pFilterManagerDlg->m_pIWbemClassObject)
		{
			VariantClear(vSelection);

			V_VT(vSelection) = VT_UNKNOWN;
			NTDM_ERR_MSG_IF_FAIL(g_pFilterManagerDlg->m_pIWbemClassObject->QueryInterface(IID_IUnknown, (void **)&(V_UNKNOWN(vSelection))));
		}
		else
			hr = S_FALSE;
	}
	else
	{
		hr = S_FALSE;
	}
	
	NTDM_END_METHOD()

	// cleanup
	NTDM_DELETE_OBJECT(g_pFilterManagerDlg);

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManager::RunBrowser(HWND hwndParent, BSTR bstrDomain, VARIANT *vSelection)
{
	HRESULT hr;

	g_pFilterManagerDlg = NULL;

	NTDM_BEGIN_METHOD()

	m_hWnd = hwndParent;

	NTDM_ERR_IF_FAIL(ConnectToWMI());
	
	//brijeshb: wrap with macro for bug 228812 prefix bug. 	
	NTDM_ERR_IF_NULL((g_pFilterManagerDlg = new CWMIFilterManagerDlg(this, true, bstrDomain)));
	if(IDOK == DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_WMI_FILTER_BROWSER), (HWND)hwndParent, WMIFilterManagerDlgProc))
	{
		if(g_pFilterManagerDlg->m_pIWbemClassObject)
		{
			VariantClear(vSelection);

			V_VT(vSelection) = VT_UNKNOWN;
			NTDM_ERR_MSG_IF_FAIL(g_pFilterManagerDlg->m_pIWbemClassObject->QueryInterface(IID_IUnknown, (void **)&(V_UNKNOWN(vSelection))));
		}
		else
			hr = S_FALSE;
	}
	else
	{
		hr = S_FALSE;
	}
	
	
	NTDM_END_METHOD()

	// cleanup
	NTDM_DELETE_OBJECT(g_pFilterManagerDlg);

	return hr;
}

//--------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManager::SetMultiSelection(VARIANT_BOOL vbValue)
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\wmifilterbrowserdlg.h ===
//-------------------------------------------------------------------------
// File: CDlgQuestionnaire.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

INT_PTR CALLBACK WMIFilterBrowserDlgProc(HWND hDLG, UINT iMessage, WPARAM wParam, LPARAM lParam);

class CWMIFilterBrowser;

class CWMIFilterBrowserDlg
{
	public:
		CWMIFilterBrowserDlg(CWMIFilterBrowser * pWMIFilterBrowser);
		~CWMIFilterBrowserDlg();
		INT_PTR CALLBACK WMIFilterBrowserDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);

		IWbemClassObject * m_pIWbemClassObject;

	protected:
		
		STDMETHODIMP PopulateFilterList();
		STDMETHODIMP AddItemToList(IWbemClassObject * pIWbemClassObject);
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
		BOOL OnOK();
		STDMETHODIMP ViewSelectedItem();

		HWND m_hWnd;
		HWND m_hwndListView;
		CWMIFilterBrowser * m_pWMIFilterBrowser;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\wmifiltermanager.h ===
// WMIFilterManager.h : Declaration of the CWMIFilterManager

#ifndef __WMIFILTERMANAGER_H_
#define __WMIFILTERMANAGER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CWMIFilterManager
class ATL_NO_VTABLE CWMIFilterManager : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CWMIFilterManager, &CLSID_WMIFilterManager>,
	public IDispatchImpl<IWMIFilterManager, &IID_IWMIFilterManager, &LIBID_SCHEMAMANAGERLib>
{
public:
	CWMIFilterManager();
	~CWMIFilterManager();

DECLARE_REGISTRY_RESOURCEID(IDR_WMIFILTERMANAGER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWMIFilterManager)
	COM_INTERFACE_ENTRY(IWMIFilterManager)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IWMIFilterManager
public:
	STDMETHOD(SetMultiSelection)(VARIANT_BOOL vbValue);
	STDMETHOD(RunManager)(HWND hwndParent, BSTR bstrDomain, VARIANT *vSelection);
	STDMETHOD(RunBrowser)(HWND hwndParent, BSTR bstrDomain, VARIANT *vSelection);
	STDMETHOD(ConnectToWMI)();

	CComPtr<IWbemServices>m_pIWbemServices;
	HWND m_hWnd;
};

#endif //__WMIFILTERMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\prerelease.inc ===
#
# This file is used to control build options that should only appear in
# internal releases, and NOT the beta or RTM releases.  This controls
# features such as the GUI mode command prompt and the Win9x upgrade
# autostress option.
#
# To change, simply set PRERELEASE to 1 for private builds, or 0 for beta
# or RTM builds.
#
# **CHANGES HERE WILL REQUIRE A CLEAN BUILD OF THE SETUP, pnp and ntdll components **
#

!ifndef PRERELEASE
PRERELEASE=0
!endif

!ifndef PRERELEASE_IDWLOG
PRERELEASE_IDWLOG=0
!endif

!if $(PRERELEASE)
C_DEFINES=$(C_DEFINES) -DPRERELEASE
!endif

!if $(PRERELEASE_IDWLOG)
C_DEFINES=$(C_DEFINES) -DPRERELEASE_IDWLOG
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\wmifilterbrowserdlg.cpp ===
//-------------------------------------------------------------------------
// File: WMIFilterBrowserDlg.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "WMIFilterBrowser.h"
#include "WMIFilterBrowserDlg.h"
#include "DlgFilterProperties.h"

CWMIFilterBrowserDlg * g_pWMIFilterBrowserDlg =  NULL;
extern CFilterPropertiesDlg * g_pFilterProperties;

//-------------------------------------------------------------------------

INT_PTR CALLBACK WMIFilterBrowserDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pWMIFilterBrowserDlg)
	{
		return g_pWMIFilterBrowserDlg->WMIFilterBrowserDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CWMIFilterBrowserDlg::CWMIFilterBrowserDlg(CWMIFilterBrowser * pWMIFilterBrowser)
{
	_ASSERT(pWMIFilterBrowser);

	m_hWnd = NULL;
	m_hwndListView = NULL;
	m_pIWbemClassObject = NULL;
	m_pWMIFilterBrowser = pWMIFilterBrowser;
}

//-------------------------------------------------------------------------

CWMIFilterBrowserDlg::~CWMIFilterBrowserDlg()
{
	NTDM_RELEASE_IF_NOT_NULL(m_pIWbemClassObject);
}


//-------------------------------------------------------------------------

INT_PTR CALLBACK CWMIFilterBrowserDlg::WMIFilterBrowserDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();
				PopulateFilterList();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_COMMAND:
			{
				if(BN_CLICKED == HIWORD(wParam) && IDC_VIEW == LOWORD(wParam))
				{
					ViewSelectedItem();
				}

				switch(LOWORD(wParam))
				{
				case IDOK:
					OnOK();
					return TRUE;
					break;

				case IDCANCEL:
					EndDialog(m_hWnd, IDCANCEL);
					return TRUE;
				}

				break;
			}

		case WM_NOTIFY:
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;

			switch (lpnm->code)
			{
				case NM_DBLCLK :
				{
					if(lpnm->idFrom == IDC_ALL_FILTERS)
					{
						ViewSelectedItem();
						return TRUE;
					}
					break;
				}

				default :
					break;
			}
		}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterBrowserDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	CComBSTR bstrName;
	
	NTDM_BEGIN_METHOD()

	bstrName.LoadString(_Module.GetResourceInstance(), IDS_NAME);

	//Initialize the ListView Control

	m_hwndListView = GetDlgItem(m_hWnd, IDC_ALL_FILTERS);
	NTDM_ERR_IF_NULL(m_hwndListView);

	ListView_SetExtendedListViewStyle(m_hwndListView, LVS_EX_FULLROWSELECT);

	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.pszText = bstrName;

	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndListView, 0, &lvColumn));
	NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndListView, 0, LVSCW_AUTOSIZE_USEHEADER));
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterBrowserDlg::DestroyDialog()
{
	HRESULT hr;
	LVITEM lvItem;
	long lCount;

	NTDM_BEGIN_METHOD()

	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndListView);

	while(lCount > 0)
	{
		lCount--;

		lvItem.iItem = lCount;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			((IWbemClassObject *)lvItem.lParam)->Release();
		}
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

BOOL CWMIFilterBrowserDlg::OnOK()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
		goto error;
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			m_pIWbemClassObject = (IWbemClassObject *)lvItem.lParam;
			m_pIWbemClassObject->AddRef();
		}
	}

	EndDialog(m_hWnd, IDOK);

	NTDM_END_METHOD()

	// cleanup

	return TRUE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterBrowserDlg::PopulateFilterList()
{
	HRESULT hr;
	CComPtr<IEnumWbemClassObject> pEnumWbemClassObject;
	CComBSTR bstrClass(_T("MSFT_SomFilter"));
	ULONG uReturned;

	NTDM_BEGIN_METHOD()

	if(!m_pWMIFilterBrowser->m_pIWbemServices)
		NTDM_EXIT(E_FAIL);

	// Get the Enumeration
	NTDM_ERR_IF_FAIL(m_pWMIFilterBrowser->m_pIWbemServices->CreateInstanceEnum(bstrClass, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumWbemClassObject));

	// Loop through each item in the enumeration and add it to the list
	while(true)
	{
		IWbemClassObject *pIWbemClassObject = NULL;

		NTDM_ERR_IF_FAIL(pEnumWbemClassObject->Next(WBEM_INFINITE, 1, &pIWbemClassObject, &uReturned));

		if(!uReturned)
			break;

		// Add current Item to the list
		AddItemToList(pIWbemClassObject);

		pIWbemClassObject->Release();
	}

	ListView_SetItemState(m_hwndListView, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterBrowserDlg::AddItemToList(IWbemClassObject * pIWbemClassObject)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE vType;
	LVITEM lvItem;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(pIWbemClassObject->Get(_T("Name"), 0, &vValue, &vType, NULL));

	lvItem.mask = LVIF_TEXT|LVIF_PARAM;
	lvItem.iItem = 0;
	lvItem.iSubItem = 0;
	lvItem.pszText = vValue.bstrVal;
	lvItem.lParam = (LPARAM)pIWbemClassObject;

	NTDM_ERR_IF_MINUSONE(ListView_InsertItem(m_hwndListView, &lvItem));

	pIWbemClassObject->AddRef();

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterBrowserDlg::ViewSelectedItem()
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	lSelectionMark = ListView_GetSelectionMark(m_hwndListView);

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
		NTDM_EXIT(E_FAIL);
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndListView, &lvItem));

		if(lvItem.lParam)
		{
			g_pFilterProperties = new CFilterPropertiesDlg(m_pWMIFilterBrowser->m_pIWbemServices, (IWbemClassObject *)lvItem.lParam);
			DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_FILTER_PROPERTIES), m_hWnd, FilterPropertiesDlgProc);
		}
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\wmifiltermgrdlg.cpp ===
//-------------------------------------------------------------------------
// File: WMIFilterMgrDlg.cpp
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

#include "stdafx.h"
#include <wbemidl.h>
#include <commctrl.h>
#include "resource.h"
#include "defines.h"
#include "ntdmutils.h"
#include "SchemaManager.h"
#include "ColumnMgrDlg.h"
#include "WMIFilterManager.h"
#include "WMIFilterMgrDlg.h"
#include "EditPropertyDlgs.h"
#include "HtmlHelp.h"

CWMIFilterManagerDlg * g_pFilterManagerDlg =  NULL;
extern CColumnManagerDlg * g_pColumnManagerDlg;

//-------------------------------------------------------------------------

INT_PTR CALLBACK WMIFilterManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	if(g_pFilterManagerDlg)
	{
		return g_pFilterManagerDlg->WMIFilterManagerDlgProc(hDlg, iMessage, wParam, lParam);
	}

	return FALSE;
}

//-------------------------------------------------------------------------

CWMIFilterManagerDlg::CWMIFilterManagerDlg(CWMIFilterManager * pWMIFilterManager, bool bBrowsing, BSTR bstrDomain)
{
	_ASSERT(pWMIFilterManager);

	m_hWnd = NULL;
	m_hwndFilterListView = NULL;
	m_hwndQueryListView = NULL;
	m_pWMIFilterManager = pWMIFilterManager;
	m_bExpanded = true;
	m_lExpandedHeight = 0;
	m_pCurCWMIFilterContainer = NULL;
	m_bBrowsing = bBrowsing;
	m_bstrDomain = bstrDomain;
}

//-------------------------------------------------------------------------

CWMIFilterManagerDlg::~CWMIFilterManagerDlg()
{
	long i;
	HRESULT hr;
	
	NTDM_BEGIN_METHOD()

	for(i=0; i<m_ArrayColumns.GetSize(); i++)
	{
		NTDM_DELETE_OBJECT(m_ArrayColumns[i]);
	}

	NTDM_END_METHOD()

	// cleanup
}


//-------------------------------------------------------------------------

INT_PTR CALLBACK CWMIFilterManagerDlg::WMIFilterManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	LPPSHNOTIFY lppsn = NULL;
	HRESULT hr;

	switch(iMessage)
	{
		case WM_INITDIALOG:
			{
				m_hWnd = hDlg;

				InitializeDialog();

				PopulateFilterList();

				break;
			}

		case WM_KEYDOWN:
			{
				if(wParam == VK_F1)
					OnHelp();

				break;
			}

		case WM_DESTROY:
			{
				DestroyDialog();
				break;
			}

		case WM_CLOSE:
			{
				if(SUCCEEDED(hr=CheckDirtyFlags()))
				{
					EndDialog(m_hWnd, 0);
				}
				return 0;
			}

		case WM_COMMAND:
			{
				switch(LOWORD(wParam))
				{
				case IDCANCEL:
					if(SUCCEEDED(hr=CheckDirtyFlags()))
					{
						EndDialog(m_hWnd, 0);
					}
					return 0;

				case IDOK:
					OnOK();
					return TRUE;
					break;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_NEW == LOWORD(wParam))
				{
					OnNew();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_DELETE == LOWORD(wParam))
				{
					OnDelete();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_DUPLICATE == LOWORD(wParam))
				{
					OnDuplicate();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_ADVANCED == LOWORD(wParam))
				{
					ToggleExpandedMode();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_HELP2 == LOWORD(wParam))
				{
					OnHelp();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_SAVE == LOWORD(wParam))
				{
					OnSave();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_IMPORT == LOWORD(wParam))
				{
					OnImport();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_EXPORT == LOWORD(wParam))
				{
					OnExport();
					return TRUE;
				}

				if(BN_CLICKED == HIWORD(wParam) && IDC_COLUMNS == LOWORD(wParam))
				{
					OnManageColumns();
					return TRUE;
				}

				if(EN_KILLFOCUS == HIWORD(wParam) &&	(
														IDC_NAME == LOWORD(wParam) || 
														IDC_DESCRIPTION == LOWORD(wParam) || 
														IDC_QUERIES == LOWORD(wParam)
														))
				{
					SaveToMemory();
					return TRUE;
				}

				if(EN_CHANGE == HIWORD(wParam) &&	(
														IDC_NAME == LOWORD(wParam) || 
														IDC_DESCRIPTION == LOWORD(wParam) || 
														IDC_QUERIES == LOWORD(wParam)
														))
				{
					if(m_pCurCWMIFilterContainer)
					{
						m_pCurCWMIFilterContainer->SetDirtyFlag(true);
						m_pCurCWMIFilterContainer->SetMemoryDirtyFlag(true);
					}
					return TRUE;
				}

				break;
			}

		case WM_NOTIFY:
		{
			LPNMHDR lpnm = (LPNMHDR) lParam;

			if(IDC_WMI_FILTER_LIST == lpnm->idFrom)
			{
				switch (lpnm->code)
				{
					case LVN_ITEMCHANGED:
					{
						LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;

						if(pnmv->uChanged & LVIF_STATE)
						{
							if(LVIS_SELECTED & pnmv->uNewState && !(LVIS_SELECTED & pnmv->uOldState))
							{
								SaveToMemory();
								if FAILED(SelectFilterItem(pnmv->iItem))
									return TRUE;
								else
									return FALSE;
							}
						}

						break;
					}

					default :
						break;
				}
			}
		}
	}

	return FALSE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::InitializeDialog()
{
	HRESULT hr;
	LVCOLUMN lvColumn;
	CComBSTR bstrName;
	CComBSTR bstrQuery;
	CComBSTR bstrTemp;
	RECT rect;
	CColumnItem * pNewColumnItem;
	
	NTDM_BEGIN_METHOD()

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_DESCRIPTION);
	pNewColumnItem = new CColumnItem(bstrTemp, _T("Description"), true);
	m_ArrayColumns.Add(pNewColumnItem);
	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_AUTHOR);
	pNewColumnItem = new CColumnItem(bstrTemp, _T("Author"), false);
	m_ArrayColumns.Add(pNewColumnItem);
	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_CHANGE_DATE);
	pNewColumnItem = new CColumnItem(bstrTemp, _T("ChangeDate"), false);
	m_ArrayColumns.Add(pNewColumnItem);
	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_CREATION_DATE);
	pNewColumnItem = new CColumnItem(bstrTemp, _T("CreationDate"), false);
	m_ArrayColumns.Add(pNewColumnItem);
	
	bstrName.LoadString(_Module.GetResourceInstance(), IDS_NAME);
	bstrQuery.LoadString(_Module.GetResourceInstance(), IDS_QUERY);

	GetWindowRect(m_hWnd, &rect);
	m_lExpandedHeight = rect.bottom - rect.top;

	ToggleExpandedMode();

	//Initialize the ListView Control
	m_hwndFilterListView = GetDlgItem(m_hWnd, IDC_WMI_FILTER_LIST);
	NTDM_ERR_IF_NULL(m_hwndFilterListView);

	ListView_SetExtendedListViewStyle(m_hwndFilterListView, LVS_EX_FULLROWSELECT);

	lvColumn.mask = LVCF_TEXT|LVCF_FMT;
	lvColumn.fmt = LVCFMT_LEFT;
	lvColumn.pszText = bstrName;

	NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndFilterListView, 0, &lvColumn));

	NTDM_ERR_IF_FAIL(SetupColumns());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::DestroyDialog()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(ClearFilterList());

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::ClearFilterList()
{
	HRESULT hr;
	LVITEM lvItem;
	long lCount;

	NTDM_BEGIN_METHOD()

	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndFilterListView);

	while(lCount > 0)
	{
		lCount--;

		lvItem.iItem = lCount;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndFilterListView, &lvItem));

		if(lvItem.lParam)
		{
			CWMIFilterContainer * pCWMIFilterContainer = (CWMIFilterContainer *)lvItem.lParam;
			NTDM_DELETE_OBJECT(pCWMIFilterContainer);
		}
	}

	ListView_DeleteAllItems(m_hwndFilterListView);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::PopulateFilterList()
{
	HRESULT hr;
	CComPtr<IEnumWbemClassObject> pEnumWbemClassObject;
	CComBSTR bstrQueryLanguage(_T("WQL"));
	CComBSTR bstrQuery;
	ULONG uReturned;
	long i = 0;
	long lCount = 0;

	NTDM_BEGIN_METHOD()

	bstrQuery = _T("select * from MSFT_SomFilter where domain=\"");
	bstrQuery += m_bstrDomain;
	bstrQuery += _T("\"");

	if(!m_pWMIFilterManager->m_pIWbemServices)
		NTDM_EXIT(E_FAIL);

	NTDM_ERR_IF_FAIL(ClearFilterList());

	// Get the Enumeration
	// CComBSTR bstrClass(_T("MSFT_SomFilter"));
	// NTDM_ERR_MSG_IF_FAIL(m_pWMIFilterManager->m_pIWbemServices->CreateInstanceEnum(bstrClass, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumWbemClassObject));

	// Query for filters in provided domain
	NTDM_ERR_MSG_IF_FAIL(m_pWMIFilterManager->m_pIWbemServices->ExecQuery(bstrQueryLanguage, bstrQuery, WBEM_FLAG_FORWARD_ONLY, NULL, &pEnumWbemClassObject));

	// Loop through each item in the enumeration and add it to the list
	while(pEnumWbemClassObject)
	{
		IWbemClassObject *pIWbemClassObject = NULL;

		NTDM_ERR_MSG_IF_FAIL(pEnumWbemClassObject->Next(WBEM_INFINITE, 1, &pIWbemClassObject, &uReturned));

		if(!uReturned)
			break;

		// Add current Item to the list
		AddFilterItemToList(pIWbemClassObject);

		pIWbemClassObject->Release();

		lCount++;
	}

	// disable OK if 0 items
	//Also disable the name, description and query edit controls
	if(0 == lCount)
	{
		EnableWindow(GetDlgItem(m_hWnd, IDOK), FALSE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_NAME), FALSE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION), FALSE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_QUERIES), FALSE);

	}
	else
	{
		EnableWindow(GetDlgItem(m_hWnd, IDOK), TRUE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_NAME), TRUE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION), TRUE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_QUERIES), TRUE);
	}

	// auto size columns

	while(true)
	{
		if(!ListView_SetColumnWidth(m_hwndFilterListView, i++, LVSCW_AUTOSIZE_USEHEADER))
			break;
	}

	ListView_SetItemState(m_hwndFilterListView, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::AddFilterItemToList(IWbemClassObject * pIWbemClassObject, long lIndex, bool bSelect)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE vType;
	LVITEM lvItem;
	CWMIFilterContainer * pFilterContainer = NULL;

	NTDM_BEGIN_METHOD()

	pFilterContainer = new CWMIFilterContainer();
	pFilterContainer->SetIWbemClassObject(pIWbemClassObject);

	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("Name"), 0, &vValue, &vType, NULL));

	lvItem.mask = LVIF_TEXT|LVIF_PARAM;
	lvItem.iItem = lIndex;
	lvItem.iSubItem = 0;
	lvItem.pszText = vValue.bstrVal;
	lvItem.lParam = (LPARAM)pFilterContainer;

	lIndex = ListView_InsertItem(m_hwndFilterListView, &lvItem);
	NTDM_ERR_IF_MINUSONE(lIndex);

	UpdateFilterItem(lIndex);

	if(bSelect)
	{
		ListView_SetItemState(m_hwndFilterListView, lIndex, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
		ListView_SetSelectionMark(m_hwndFilterListView, lIndex);
	}

	pIWbemClassObject->AddRef();

	NTDM_END_METHOD()

	// cleanup
	if FAILED(hr)
		NTDM_DELETE_OBJECT(pFilterContainer);

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::UpdateFilterItem(long lIndex)
{
	HRESULT hr;
	LVITEM lvItem;
	CComVariant vValue;
	CIMTYPE cimType;
	long i;
	long lCount = 0;

	NTDM_BEGIN_METHOD()

	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iItem = lIndex;
	lvItem.iSubItem = 0;

	NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndFilterListView, &lvItem));

	if(lvItem.lParam)
	{
		CComPtr<IWbemClassObject>pIWbemClassObject;

		CWMIFilterContainer * pCWMIFilterContainer = (CWMIFilterContainer *)lvItem.lParam;
		NTDM_ERR_IF_FAIL(pCWMIFilterContainer->GetIWbemClassObject(&pIWbemClassObject));

		NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("Name"), 0, &vValue, &cimType, NULL));
		ListView_SetItemText(m_hwndFilterListView, lIndex, 0, V_BSTR(&vValue));

		// for each selected item in the columns array add the property
		for(i=0; i<m_ArrayColumns.GetSize(); i++)
		{
			if(m_ArrayColumns[i]->IsSelected())
			{
				lCount++;
				vValue.Clear();

				NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(m_ArrayColumns[i]->GetPropertyName(), 0, &vValue, &cimType, NULL));

				if(vValue.vt != VT_BSTR)
					continue;

				if(cimType != CIM_DATETIME)
				{
					ListView_SetItemText(m_hwndFilterListView, lIndex, lCount, V_BSTR(&vValue));
				}
				else
				{
					//convert to readable date
					CComBSTR bstrTemp;
					TCHAR *pszCur = V_BSTR(&vValue);
					TCHAR pszYear[5];
					TCHAR pszMonth[3];
					TCHAR pszDay[3];
					
					_tcsncpy(pszYear, pszCur, 4);
					pszYear[4] = 0;
					pszCur += 4;
					_tcsncpy(pszMonth, pszCur, 2);
					pszMonth[2] = 0;
					pszCur += 2;
					_tcsncpy(pszDay, pszCur, 2);
					pszDay[2] = 0;

					bstrTemp = pszMonth;
					bstrTemp += _T("\\");
					bstrTemp += pszDay;
					bstrTemp += _T("\\");
					bstrTemp += pszYear;

					vValue = bstrTemp;
					ListView_SetItemText(m_hwndFilterListView, lIndex, lCount, V_BSTR(&vValue));
				}
			}
		}
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::OnDelete()
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;
	long lSelectionMark;
	LVITEM lvItem;
	long lCount;

	NTDM_BEGIN_METHOD()

	if(!m_pCurIWbemClassObj)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
		NTDM_EXIT(E_FAIL);
	}

	if(IDNO == CNTDMUtils::DisplayMessage(m_hWnd, IDS_CONFIRM_DELETE_FILTER, IDS_DELETE_FILTER, MB_YESNO|MB_ICONWARNING))
	{
		NTDM_EXIT(E_FAIL);
	}

	NTDM_ERR_MSG_IF_FAIL(m_pCurIWbemClassObj->Get(_T("__PATH"), 0, &vValue, &cimType, NULL));

	if(NOTEMPTY_BSTR_VARIANT(&vValue))
	{
		NTDM_ERR_MSG_IF_FAIL(m_pWMIFilterManager->m_pIWbemServices->DeleteInstance(V_BSTR(&vValue), 0, NULL, NULL));
	}
	else
	{
		// This item was a new item that was never saved so no need to remove it from the CIM
	}

	lSelectionMark = ListView_GetSelectionMark(m_hwndFilterListView);
	lvItem.iItem = lSelectionMark;
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndFilterListView, &lvItem));

	if(lvItem.lParam)
	{
		CWMIFilterContainer * pCWMIFilterContainer = (CWMIFilterContainer *)lvItem.lParam;
		NTDM_DELETE_OBJECT(pCWMIFilterContainer);
	}

	ListView_DeleteItem(m_hwndFilterListView, lSelectionMark);
	m_pCurCWMIFilterContainer = NULL;
	m_pCurIWbemClassObj = NULL;
	
	ListView_SetItemState(m_hwndFilterListView, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
		
	// disable OK if last item
	lCount = ListView_GetItemCount(m_hwndFilterListView);
	if(0 == lCount)
	{
		EnableWindow(GetDlgItem(m_hWnd, IDOK), FALSE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_NAME), FALSE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION), FALSE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_QUERIES), FALSE);
	}
	else
	{
		EnableWindow(GetDlgItem(m_hWnd, IDOK), TRUE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_NAME), TRUE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION), TRUE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_QUERIES), TRUE);
	}


	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::OnNew()
{
	HRESULT hr;
	CComPtr<IWbemClassObject>pIWbemClassObject;
	CComPtr<IWbemClassObject>pIWbemNewInstance;
	CComBSTR bstrTemp;
	CComVariant vValue;
	TCHAR pszTemp[100];
	GUID guid;
	DWORD nSize = 100;
	SYSTEMTIME systemTime;
	long lCount = 0;

	NTDM_BEGIN_METHOD()

	bstrTemp = _T("MSFT_SomFilter");

	NTDM_ERR_MSG_IF_FAIL(m_pWMIFilterManager->m_pIWbemServices->GetObject(bstrTemp, 0, NULL, &pIWbemClassObject, NULL));
	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->SpawnInstance(0, &pIWbemNewInstance));

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_NEW_FILTER_NAME);
	vValue = bstrTemp;

	NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("Name"), 0, &vValue, CIM_STRING));
	NTDM_ERR_MSG_IF_FAIL(CoCreateGuid(&guid));
	StringFromGUID2(guid, pszTemp, 100);
	vValue = pszTemp;
	NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("ID"), 0, &vValue, CIM_STRING));

	vValue = m_bstrDomain;
	NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("domain"), 0, &vValue, CIM_STRING));

	// Set the user name
	pszTemp[0] = 0;
	if(GetUserName(pszTemp, &nSize) && _tcslen(pszTemp))
	{
		vValue = pszTemp;
		NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("Author"), 0, &vValue, CIM_STRING));
	}

	// Set the create and modified dates
	GetLocalTime(&systemTime);
	NTDM_ERR_GETLASTERROR_IF_NULL(GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, &systemTime, _T("yyyyMMdd000000.000000-000"), pszTemp, 100));

	if(_tcslen(pszTemp))
	{
		// Set the create date
		vValue = pszTemp;
		NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("CreationDate"), 0, &vValue, CIM_DATETIME));
		NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("ChangeDate"), 0, &vValue, CIM_DATETIME));
	}


	// Add current Item to the list
	AddFilterItemToList(pIWbemNewInstance, MAX_LIST_ITEMS, true);

	// set focus on the name edit box
	SetFocus(GetDlgItem(m_hWnd, IDC_NAME));

	NTDM_END_METHOD()

	// disable OK if last item
	lCount = ListView_GetItemCount(m_hwndFilterListView);
	if(0 == lCount)
	{
		EnableWindow(GetDlgItem(m_hWnd, IDOK), FALSE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_NAME), FALSE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION), FALSE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_QUERIES), FALSE);
	}
	else
	{
		EnableWindow(GetDlgItem(m_hWnd, IDOK), TRUE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_NAME), TRUE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION), TRUE);
		EnableWindow(GetDlgItem(m_hWnd, IDC_QUERIES), TRUE);
		
	}

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::OnDuplicate()
{
	HRESULT hr;
	CComPtr<IWbemClassObject>pIWbemNewInstance;
	CComVariant vValue;
	TCHAR pszTemp[100];
	GUID guid;
	CComBSTR bstrTemp;
	DWORD nSize = 100;
	SYSTEMTIME systemTime;

	NTDM_BEGIN_METHOD()

	if(!m_pCurIWbemClassObj)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
		NTDM_EXIT(E_FAIL);
	}

	NTDM_ERR_MSG_IF_FAIL(m_pCurIWbemClassObj->Clone(&pIWbemNewInstance));

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_NEW_FILTER_NAME);
	vValue = bstrTemp;

	NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("Name"), 0, &vValue, CIM_STRING));
	NTDM_ERR_MSG_IF_FAIL(CoCreateGuid(&guid));
	StringFromGUID2(guid, pszTemp, 100);
	vValue = pszTemp;
	NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("ID"), 0, &vValue, CIM_STRING));

	vValue = m_bstrDomain;
	NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("domain"), 0, &vValue, CIM_STRING));

	// set the name
	pszTemp[0] = 0;
	if(GetUserName(pszTemp, &nSize) && _tcslen(pszTemp))
	{
		vValue = pszTemp;
		NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("Author"), 0, &vValue, CIM_STRING));
	}

	// Set the create and modified dates
	GetLocalTime(&systemTime);
	NTDM_ERR_GETLASTERROR_IF_NULL(GetDateFormat(LOCALE_SYSTEM_DEFAULT, 0, &systemTime, _T("yyyyMMdd000000.000000-000"), pszTemp, 100));

	if(_tcslen(pszTemp))
	{
		// Set the create date
		vValue = pszTemp;
		NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("CreationDate"), 0, &vValue, CIM_DATETIME));
		NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("ChangeDate"), 0, &vValue, CIM_DATETIME));
	}

	// Add current Item to the list
	AddFilterItemToList(pIWbemNewInstance, MAX_LIST_ITEMS, true);
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

BOOL CWMIFilterManagerDlg::OnOK()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(CheckDirtyFlags());

	m_pCurCWMIFilterContainer = NULL;

	NTDM_ERR_IF_FAIL(GetSelectedFilter(&m_pCurCWMIFilterContainer));
	NTDM_ERR_IF_FAIL(m_pCurCWMIFilterContainer->GetIWbemClassObject(&m_pIWbemClassObject));

	EndDialog(m_hWnd, IDOK);

	NTDM_END_METHOD()

	// cleanup

	return TRUE;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::CheckDirtyFlags()
{
	HRESULT hr;
	LVITEM lvItem;
	bool bPrompt = true;
	long lCount;
	long lResult;

	NTDM_BEGIN_METHOD()

	//Release each item in the ListView Control
	lvItem.mask = LVIF_PARAM;
	lvItem.iSubItem = 0;

	lCount = ListView_GetItemCount(m_hwndFilterListView);

	while(lCount > 0)
	{
		lCount--;

		lvItem.iItem = lCount;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndFilterListView, &lvItem));

		if(lvItem.lParam)
		{
			CWMIFilterContainer * pCWMIFilterContainer = (CWMIFilterContainer *)lvItem.lParam;

			if(pCWMIFilterContainer->IsDirty())
			{
				if(bPrompt)
				{

					bPrompt = false;
					lResult = CNTDMUtils::DisplayMessage(m_hWnd, IDS_PROMPT_FOR_SAVE, IDS_WMI_FILTER_MANAGER, MB_YESNOCANCEL|MB_ICONQUESTION);
					if(IDNO == lResult)
					{
						NTDM_EXIT(NOERROR);
					}
					else if(IDCANCEL == lResult)
					{
						NTDM_EXIT(E_FAIL);
					}
				}

				// save the current piwbemobject
				NTDM_ERR_IF_FAIL(pCWMIFilterContainer->GetIWbemClassObject(&m_pCurIWbemClassObj));
				if FAILED(hr = m_pWMIFilterManager->m_pIWbemServices->PutInstance(m_pCurIWbemClassObj, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL))
				{
					ListView_SetItemState(m_hwndFilterListView, lCount, LVIS_SELECTED, LVIS_SELECTED);
					NTDM_ERR_MSG_IF_FAIL(hr);
				}

				pCWMIFilterContainer->SetDirtyFlag(false);
			}
		}
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::OnManageColumns()
{
	HRESULT hr;
	long lCount;

	NTDM_BEGIN_METHOD()

	g_pColumnManagerDlg = new CColumnManagerDlg(&m_ArrayColumns);
	if(IDOK == DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_COLUMN_MANAGER), (HWND)m_hWnd, ColumnManagerDlgProc))
	{
		SetupColumns();
		lCount = ListView_GetItemCount(m_hwndFilterListView);

		while(lCount > 0)
		{
			lCount--;
			UpdateFilterItem(lCount);
		}
	}
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::SetupColumns()
{
	HRESULT hr;
	HWND hwndHeader = NULL;
	long i = 0;
	long lCount = 0;
	LVCOLUMN lvColumn;

	NTDM_BEGIN_METHOD()

	// Delete all the columns but the 1st one.
	while(ListView_DeleteColumn(m_hwndFilterListView, 1));

	for(i=0; i<m_ArrayColumns.GetSize(); i++)
	{
		CColumnItem * pCColumnItem = m_ArrayColumns[i];

		if(!pCColumnItem->IsSelected())
			continue;

		lCount++;
		// Add all the selected columns
		lvColumn.mask = LVCF_TEXT|LVCF_FMT;
		lvColumn.fmt = LVCFMT_LEFT;
		lvColumn.pszText = (LPTSTR)pCColumnItem->GetName();

		NTDM_ERR_IF_MINUSONE(ListView_InsertColumn(m_hwndFilterListView, lCount, &lvColumn));
	}

	for(i=0; i<=lCount; i++)
	{
		NTDM_ERR_IF_FALSE(ListView_SetColumnWidth(m_hwndFilterListView, i, LVSCW_AUTOSIZE_USEHEADER));
	}

	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::GetSelectedFilter(CWMIFilterContainer ** ppCWMIFilterContainer, long lIndex)
{
	HRESULT hr;
	long lSelectionMark;

	NTDM_BEGIN_METHOD()

	if(-1 == lIndex)
	{
		lSelectionMark = ListView_GetSelectionMark(m_hwndFilterListView);
	}
	else
	{
		lSelectionMark = lIndex;
	}

	if(-1 == lSelectionMark)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_NO_FILTER_SELECTED);
		NTDM_EXIT(E_FAIL);
	}
	else
	{
		// get a pointer to the IWbemClassObject
		LVITEM lvItem;
		lvItem.mask = LVIF_PARAM;
		lvItem.iSubItem = 0;

		lvItem.iItem = lSelectionMark;

		NTDM_ERR_IF_FALSE(ListView_GetItem(m_hwndFilterListView, &lvItem));

		if(lvItem.lParam)
		{
			CComPtr<IWbemClassObject>pIWbemClassObject;
			CWMIFilterContainer * pCWMIFilterContainer;
			
			*ppCWMIFilterContainer = (CWMIFilterContainer *)lvItem.lParam;
		}
		else
		{
			NTDM_EXIT(E_FAIL);
		}

	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::OnExport()
{
	HRESULT hr;
	CComBSTR bstrTemp;
	CComBSTR bstrFilter;
	BYTE byteUnicodeHeader1 = 0xFF;
	BYTE byteUnicodeHeader2 = 0xFE;
	CComBSTR bstrNamespace = _T("#pragma namespace(\"\\\\\\\\.\\\\root\\\\policy\")");
	TCHAR pszFile[MAX_PATH];
	CComBSTR bstrObjectText;
	HANDLE hFile = NULL;
	DWORD dwWritten=0;
	pszFile[0] = 0;

	NTDM_BEGIN_METHOD()

	if(!m_pCurIWbemClassObj)
		NTDM_EXIT(E_FAIL);

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_ALL_FILES_FILTER);
	bstrFilter.LoadString(_Module.GetResourceInstance(), IDS_MOF_FILES_FILTER);
	bstrFilter += bstrTemp;
	CNTDMUtils::ReplaceCharacter(bstrFilter, L'@', L'\0');

	if(CNTDMUtils::SaveFileNameDlg(bstrFilter, _T("*.mof"), m_hWnd, pszFile))
	{
		if(_tcslen(pszFile))
		{
			// check if the file already exists
			WIN32_FIND_DATA FindFileData;
			HANDLE hFind;

			hFind = FindFirstFile(pszFile, &FindFileData);

			if (hFind != INVALID_HANDLE_VALUE) 
			{
				FindClose(hFind);

				if(IDYES != CNTDMUtils::DisplayMessage(m_hWnd, IDS_WARN_OVERWRITE, IDS_WMI_FILTER_MANAGER, MB_YESNO|MB_ICONQUESTION))
				{
					NTDM_EXIT(S_FALSE);
				}
			}
			

			NTDM_ERR_MSG_IF_FAIL(m_pCurIWbemClassObj->GetObjectText(0, &bstrObjectText));

			// save to pszFile
			hFile = CreateFile(pszFile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 
							   NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
			if(hFile == INVALID_HANDLE_VALUE)
			{
				NTDM_ERR_GETLASTERROR_IF_NULL(NULL);
				goto error;
			}

			if(hFile)
			{
				NTDM_ERR_GETLASTERROR_IF_NULL(WriteFile(hFile, &byteUnicodeHeader1, sizeof(BYTE), &dwWritten, NULL));				
				NTDM_ERR_GETLASTERROR_IF_NULL(WriteFile(hFile, &byteUnicodeHeader2, sizeof(BYTE), &dwWritten, NULL));				
				NTDM_ERR_GETLASTERROR_IF_NULL(WriteFile(hFile, bstrNamespace, _tcslen(bstrNamespace) * sizeof(TCHAR), &dwWritten, NULL));	
				NTDM_ERR_GETLASTERROR_IF_NULL(WriteFile(hFile, bstrObjectText, _tcslen(bstrObjectText) * sizeof(TCHAR), &dwWritten, NULL));
				NTDM_ERR_GETLASTERROR_IF_NULL(CloseHandle(hFile));
				hFile = NULL;
			}
		}
	}

	NTDM_END_METHOD()

	// cleanup
	if(hFile)
	{
		CloseHandle(hFile);
		hFile = NULL;
	}

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::OnImport()
{
	HRESULT hr;
	CComPtr<IMofCompiler>pIMofCompiler;
	CComBSTR bstrTemp;
	CComBSTR bstrFilter;
	TCHAR pszFile[MAX_PATH];
	pszFile[0] = 0;
	WBEM_COMPILE_STATUS_INFO pInfo;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_IF_FAIL(CheckDirtyFlags());

	bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_ALL_FILES_FILTER);
	bstrFilter.LoadString(_Module.GetResourceInstance(), IDS_MOF_FILES_FILTER);
	bstrFilter += bstrTemp;
	CNTDMUtils::ReplaceCharacter(bstrFilter, L'@', L'\0');

	if(CNTDMUtils::OpenFileNameDlg(bstrFilter, _T("*.mof"), m_hWnd, pszFile))
	{
		if(_tcslen(pszFile))
		{
			NTDM_ERR_MSG_IF_FAIL(CoCreateInstance(CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (void **)&pIMofCompiler));
			NTDM_ERR_MSG_IF_FAIL(pIMofCompiler->CompileFile(pszFile, NULL, NULL, NULL, NULL, 0, 0, 0, &pInfo));

			// check if pInfo is ok
			if(pInfo.lPhaseError != 0)
			{
				CNTDMUtils::DisplayMessage(m_hWnd, IDS_ERR_STORING_DATA);
			}

			NTDM_ERR_IF_FAIL(PopulateFilterList());
		}
	}

	NTDM_END_METHOD()

	// cleanup
	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::ToggleExpandedMode()
{
	HRESULT hr;
	RECT rect;
	CComBSTR bstrTemp;
	long lCount = 0;

	NTDM_BEGIN_METHOD()

	if(m_bExpanded)
	{
		GetWindowRect(m_hWnd, &rect);
		SetWindowPos(m_hWnd, HWND_NOTOPMOST, 0, 0, rect.right-rect.left, 240, SWP_NOZORDER|SWP_NOREPOSITION|SWP_NOMOVE);

		bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_DETAILS2);
		SetDlgItemText(m_hWnd, IDC_ADVANCED, bstrTemp);

		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_NEW, false);
		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DELETE, false);
		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DUPLICATE, false);
		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_IMPORT, false);
		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_EXPORT, false);
		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_NAME, false);
		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DESCRIPTION, false);
		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_QUERIES, false);
		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_SAVE, false);

		m_bExpanded = false;
	}
	else
	{
		GetWindowRect(m_hWnd, &rect);
		SetWindowPos(m_hWnd, HWND_NOTOPMOST, 0, 0, rect.right-rect.left, m_lExpandedHeight, SWP_NOZORDER|SWP_NOREPOSITION|SWP_NOMOVE);

		bstrTemp.LoadString(_Module.GetResourceInstance(), IDS_DETAILS1);
		SetDlgItemText(m_hWnd, IDC_ADVANCED, bstrTemp);

		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_NEW, true);
		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DELETE, true);
		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DUPLICATE, true);
		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_IMPORT, true);
		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_EXPORT, true);
		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_NAME, true);
		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_DESCRIPTION, true);
		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_QUERIES, true);
		CNTDMUtils::DisplayDlgItem(m_hWnd, IDC_SAVE, true);

		lCount = ListView_GetItemCount(m_hwndFilterListView);
		//If there are no items, make sure the name, description and query controls are disabled.
		if (0 == lCount)
		{
					
			EnableWindow(GetDlgItem(m_hWnd, IDC_NAME), FALSE);
			EnableWindow(GetDlgItem(m_hWnd, IDC_DESCRIPTION), FALSE);
			EnableWindow(GetDlgItem(m_hWnd, IDC_QUERIES), FALSE);

		}

		m_bExpanded = true;
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::SelectFilterItem(long lIndex)
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	bool bDirtyFlag = false, bMemoryDirtyFlag = false;

	m_pCurIWbemClassObj = NULL;
	m_pCurCWMIFilterContainer = NULL;

	NTDM_ERR_IF_FAIL(GetSelectedFilter(&m_pCurCWMIFilterContainer, lIndex));
	NTDM_ERR_IF_FAIL(m_pCurCWMIFilterContainer->GetIWbemClassObject(&m_pCurIWbemClassObj));

	bDirtyFlag = m_pCurCWMIFilterContainer->IsDirty();
	bMemoryDirtyFlag = m_pCurCWMIFilterContainer->IsMemoryDirty();

	NTDM_ERR_IF_FAIL(CNTDMUtils::GetStringProperty(m_pCurIWbemClassObj, _T("Name"), m_hWnd, IDC_NAME));
	NTDM_ERR_IF_FAIL(CNTDMUtils::GetStringProperty(m_pCurIWbemClassObj, _T("Description"), m_hWnd, IDC_DESCRIPTION));
	NTDM_ERR_IF_FAIL(PopulateQueryEdit());

	m_pCurCWMIFilterContainer->SetDirtyFlag(bDirtyFlag);
	m_pCurCWMIFilterContainer->SetMemoryDirtyFlag(bMemoryDirtyFlag);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::PopulateQueryEdit()
{
	HRESULT hr;
	CComVariant vValue;
	SAFEARRAY *psaRules = NULL;
	long lLower, lUpper, i;
	CIMTYPE cimType;
	CComBSTR bstrQueries;
	
	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(m_pCurIWbemClassObj->Get(_T("Rules"), 0, &vValue, &cimType, NULL));

	if(VT_NULL != V_VT(&vValue))
	{
		// Set the Rules property
		psaRules = V_ARRAY(&vValue);
		NTDM_ERR_MSG_IF_FAIL(SafeArrayGetUBound(psaRules, 1, &lUpper));
		NTDM_ERR_MSG_IF_FAIL(SafeArrayGetLBound(psaRules, 1, &lLower));

		for(i=lLower; i<=lUpper; i++)
		{
			if(V_VT(&vValue) & VT_UNKNOWN)
			{
				// Rules or UNKNOWNS (i.e. IWbemClassObjects)
				CComPtr<IUnknown>pUnk;
				CComPtr<IWbemClassObject> pIWbemClassObject;
				NTDM_ERR_MSG_IF_FAIL(SafeArrayGetElement(psaRules, &i, (void *)&pUnk));
				NTDM_ERR_MSG_IF_FAIL(pUnk->QueryInterface(IID_IWbemClassObject, (void **)&pIWbemClassObject));

				// Show Properties of this object
				if(i!= lLower)
				{
					bstrQueries += _T("\r\n\r\n");
				}

				NTDM_ERR_IF_FAIL(AddQueryItemToString(pIWbemClassObject, bstrQueries));
			}
		}
	}

	SendDlgItemMessage(m_hWnd, IDC_QUERIES, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)bstrQueries);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::AddQueryItemToString(IWbemClassObject * pIWbemClassObject, CComBSTR& bstrQueries)
{
	HRESULT hr;
	CComVariant vValue;
	CIMTYPE cimType;

	NTDM_BEGIN_METHOD()

	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("TargetNameSpace"), 0, &vValue, &cimType, NULL));
	if(vValue.bstrVal && _tcscmp(_T("root\\cimv2"), vValue.bstrVal) != 0)
	{
		bstrQueries += vValue.bstrVal;
		bstrQueries +=";";
	}

	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->Get(_T("Query"), 0, &vValue, &cimType, NULL));

	bstrQueries += vValue.bstrVal;

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::SaveQueryEdit()
{
	HRESULT hr;
	VARIANT vValue;
	SAFEARRAY *psaRules = NULL;
	SAFEARRAYBOUND rgsaBound[1];
	long rgIndices[1];
	long i;
	long lCount = 0;
	CSimpleArray<BSTR>bstrArray;
	CComBSTR bstrTemp;

	NTDM_BEGIN_METHOD()

	VariantInit(&vValue);

	//Split out the string into an array of query strings
	NTDM_ERR_IF_FAIL(CNTDMUtils::GetDlgItemString(m_hWnd, IDC_QUERIES, bstrTemp));
	NTDM_ERR_IF_FAIL(CNTDMUtils::GetValuesInList(bstrTemp, bstrArray, _T("\r\n\r\n")));

	// Get the size of the array
	lCount = bstrArray.GetSize();

	if(lCount)
	{
		rgsaBound[0].lLbound = 0;
		rgsaBound[0].cElements = lCount;

		psaRules = SafeArrayCreate(VT_UNKNOWN, 1, rgsaBound);
		
		for(i=0; i<lCount; i++)
		{
			CComPtr<IUnknown>pUnk;
			CSimpleArray<BSTR>bstrQueryDetails;

			NTDM_ERR_IF_FAIL(CNTDMUtils::GetValuesInList(bstrArray[i], bstrQueryDetails, _T(";")));
			if(bstrQueryDetails.GetSize() > 1)
			{
				NTDM_ERR_IF_FAIL(AddEditQueryString(bstrQueryDetails[1], (void**)&pUnk, bstrQueryDetails[0]));
			}
			else
			{
				NTDM_ERR_IF_FAIL(AddEditQueryString(bstrQueryDetails[0], (void**)&pUnk));
			}

			rgIndices[0] = i;
			NTDM_ERR_MSG_IF_FAIL(SafeArrayPutElement(psaRules, rgIndices, pUnk));
		}

		VariantClear(&vValue);
		V_VT(&vValue) = VT_ARRAY|VT_UNKNOWN;
		V_ARRAY(&vValue) = psaRules;
	}
	else
	{
		VariantClear(&vValue);
		V_VT(&vValue) = VT_NULL;
	}

	NTDM_ERR_MSG_IF_FAIL(m_pCurIWbemClassObj->Put(_T("Rules"), 0, &vValue, CIM_FLAG_ARRAY|CIM_OBJECT));

	hr = S_OK;

	NTDM_END_METHOD()

	// cleanup

	VariantClear(&vValue);

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::AddEditQueryString(BSTR bstrQuery, void **ppUnk, BSTR bstrNamespace)
{
	HRESULT hr;
	CComPtr<IWbemClassObject>pIWbemClassObject;
	CComPtr<IWbemClassObject>pIWbemNewInstance;
	CComBSTR bstrTemp;
	CComVariant vValueTemp;

	NTDM_BEGIN_METHOD()

	bstrTemp = _T("MSFT_Rule");

	NTDM_ERR_MSG_IF_FAIL(m_pWMIFilterManager->m_pIWbemServices->GetObject(bstrTemp, 0, NULL, &pIWbemClassObject, NULL));
	NTDM_ERR_MSG_IF_FAIL(pIWbemClassObject->SpawnInstance(0, &pIWbemNewInstance));

	vValueTemp = _T("WQL");
	NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("QueryLanguage"), 0, &vValueTemp, CIM_STRING));
	
	if(!bstrNamespace)
		vValueTemp = _T("root\\cimv2");
	else
		vValueTemp = bstrNamespace;
	NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("TargetNameSpace"), 0, &vValueTemp, CIM_STRING));

	vValueTemp = bstrQuery;
	NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->Put(_T("Query"), 0, &vValueTemp, CIM_STRING));

	NTDM_ERR_MSG_IF_FAIL(pIWbemNewInstance->QueryInterface(IID_IUnknown, ppUnk));
	
	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::OnSave()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	if(!m_pCurIWbemClassObj)
		NTDM_EXIT(E_FAIL);

	// save the current piwbemobject
	NTDM_ERR_MSG_IF_FAIL(m_pWMIFilterManager->m_pIWbemServices->PutInstance(m_pCurIWbemClassObj, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL));

	m_pCurCWMIFilterContainer->SetDirtyFlag(false);

	NTDM_END_METHOD()

	// cleanup

	return hr;
}


//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::OnHelp()
{
	HRESULT hr;

	NTDM_BEGIN_METHOD()

	HWND hwnd = HtmlHelp(NULL, _T("wmifiltr.chm"), 0, 0);

	if(!hwnd)
	{
		CNTDMUtils::DisplayMessage(m_hWnd, IDS_HELP_ERR);
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}

//---------------------------------------------------------------------------

STDMETHODIMP CWMIFilterManagerDlg::SaveToMemory()
{
	HRESULT hr;
	CComBSTR bstrTemp;
	long lSelectionMark;
	CComVariant vValue;

	NTDM_BEGIN_METHOD()

	if(m_pCurCWMIFilterContainer && m_pCurCWMIFilterContainer->IsMemoryDirty())
	{
		NTDM_ERR_IF_FAIL(CNTDMUtils::SetStringProperty(m_pCurIWbemClassObj, _T("Name"), m_hWnd, IDC_NAME));
		NTDM_ERR_IF_FAIL(CNTDMUtils::SetStringProperty(m_pCurIWbemClassObj, _T("Description"), m_hWnd, IDC_DESCRIPTION));
		NTDM_ERR_IF_FAIL(SaveQueryEdit());

		lSelectionMark = ListView_GetSelectionMark(m_hwndFilterListView);
		UpdateFilterItem(lSelectionMark);

		m_pCurCWMIFilterContainer->SetMemoryDirtyFlag(false);
	}

	NTDM_END_METHOD()

	// cleanup

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmiscmgr\wmifiltermgrdlg.h ===
//-------------------------------------------------------------------------
// File: WMIFilterMgrDlg.h
//
// Author : Kishnan Nedungadi
//
// created : 3/27/2000
//-------------------------------------------------------------------------

INT_PTR CALLBACK WMIFilterManagerDlgProc(HWND hDLG, UINT iMessage, WPARAM wParam, LPARAM lParam);

class CWMIFilterManager;
class CWMIFilterContainer;
class CColumnItem;

class CWMIFilterManagerDlg
{
	public:
		CWMIFilterManagerDlg(CWMIFilterManager * pWMIFilterManager, bool bBrowsing=false, BSTR bstrDomain=NULL);
		~CWMIFilterManagerDlg();
		INT_PTR CALLBACK WMIFilterManagerDlgProc(HWND hDlg, UINT iMessage, WPARAM wParam, LPARAM lParam);

		IWbemClassObject * m_pIWbemClassObject;

	protected:
		
		STDMETHODIMP PopulateFilterList();
		STDMETHODIMP AddFilterItemToList(IWbemClassObject * pIWbemClassObject, long lIndex=MAX_LIST_ITEMS, bool bSelect=false);
		STDMETHODIMP InitializeDialog();
		STDMETHODIMP DestroyDialog();
		BOOL OnKillActive();
		STDMETHODIMP OnNew();
		STDMETHODIMP OnDelete();
		STDMETHODIMP ClearFilterList();
		BOOL OnOK();
		STDMETHODIMP GetSelectedFilter(CWMIFilterContainer ** ppCWMIFilterContainer, long lIndex=-1);
		STDMETHODIMP SelectFilterItem(long lIndex);
		STDMETHODIMP ToggleExpandedMode();
		STDMETHODIMP OnSave();
		STDMETHODIMP OnExport();
		STDMETHODIMP OnImport();
		STDMETHODIMP CheckDirtyFlags();
		//STDMETHODIMP PopulateQueryList();
		//STDMETHODIMP UpdateQueryList();
		//STDMETHODIMP AddQueryItemToList(IWbemClassObject * pIWbemClassObject, long lIndex=MAX_LIST_ITEMS);
		//STDMETHODIMP OnEditQuery();
		//STDMETHODIMP OnAddQuery();
		//STDMETHODIMP OnDeleteQuery();
		//STDMETHODIMP ClearQueryList();
		STDMETHODIMP OnManageColumns();
		STDMETHODIMP SetupColumns();
		STDMETHODIMP UpdateFilterItem(long lIndex);
		STDMETHODIMP PopulateQueryEdit();
		STDMETHODIMP AddQueryItemToString(IWbemClassObject * pIWbemClassObject, CComBSTR& bstrQueries);
		STDMETHODIMP SaveQueryEdit();
		STDMETHODIMP AddEditQueryString(BSTR bstrQuery, void **ppUnk, BSTR bstrNamespace=NULL);
		STDMETHODIMP SaveToMemory();
		STDMETHODIMP OnDuplicate();
		STDMETHODIMP OnHelp();

		HWND m_hWnd;
		CWMIFilterManager * m_pWMIFilterManager;
		HWND m_hwndFilterListView;
		HWND m_hwndQueryListView;
		CComPtr<IWbemClassObject> m_pCurIWbemClassObj;
		bool m_bExpanded;
		long m_lExpandedHeight;
		CWMIFilterContainer * m_pCurCWMIFilterContainer;
		bool m_bBrowsing;
		CSimpleArray<CColumnItem*> m_ArrayColumns;
		CComBSTR m_bstrDomain;
};

class CWMIFilterContainer
{
	public:
		CWMIFilterContainer() { m_bDirty = false; m_bMemoryDirty = false;}
		~CWMIFilterContainer() {}

		bool IsDirty() { return m_bDirty; }
		void SetDirtyFlag(bool value) { m_bDirty = value; }
		bool IsMemoryDirty() { return m_bMemoryDirty; }
		void SetMemoryDirtyFlag(bool value) { m_bMemoryDirty = value; }
		
		STDMETHODIMP GetIWbemClassObject(IWbemClassObject ** ppIWbemClassObject) 
		{ 
			if(!m_pIWbemClassObject)
				return E_FAIL;

			return m_pIWbemClassObject->QueryInterface(IID_IWbemClassObject, (void **)ppIWbemClassObject);
		}

		STDMETHODIMP SetIWbemClassObject(IWbemClassObject * pIWbemClassObject)
		{
			if(!pIWbemClassObject)
			{
				m_pIWbemClassObject = NULL;
				return NOERROR;
			}
			else
			{
				return pIWbemClassObject->QueryInterface(IID_IWbemClassObject, (void **)&m_pIWbemClassObject);
			}
		}

	protected:
		bool m_bDirty;
		bool m_bMemoryDirty;
		CComPtr<IWbemClassObject>m_pIWbemClassObject;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\basedrv\pnpmem\memory.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module implements the routines which add and remove physical memory
    from the system.

Author:

    Dave Richards (daveri) 16-Aug-1999

Environment:

    Kernel mode only.

Revision History:

--*/

#include "pnpmem.h"

//
// MM uses STATUS_NOT_SUPPORTED to indicate that the memory manager is
// not configured for dynamic memory insertion/removal.
// Unfortunately, this same error code has special meaning to PNP, so
// propagating it blindly from MM is unwise.
//

#define MAP_MMERROR(x) (x == STATUS_NOT_SUPPORTED ? STATUS_UNSUCCESSFUL : x)

#define rgzReservedResources L"\\Registry\\Machine\\Hardware\\ResourceMap\\System Resources\\Loader Reserved"
#define rgzReservedResourcesValue L".Raw"

NTSTATUS
PmAddPhysicalMemoryRange(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONGLONG Start,
    IN ULONGLONG End
    );

VOID
PmLogAddError(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONGLONG Start,
    IN ULONGLONG Size,
    IN NTSTATUS Status
    );

NTSTATUS
PmRemovePhysicalMemoryRange(
    IN ULONGLONG Start,
    IN ULONGLONG End
    );

PPM_RANGE_LIST
PmRetrieveReservedMemoryResources(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PmAddPhysicalMemoryRange)
#pragma alloc_text(PAGE, PmAddPhysicalMemory)
#pragma alloc_text(PAGE, PmGetRegistryValue)
#pragma alloc_text(PAGE, PmLogAddError)
#pragma alloc_text(PAGE, PmRetrieveReservedMemoryResources)
#pragma alloc_text(PAGE, PmTrimReservedMemory)
#pragma alloc_text(PAGE, PmRemovePhysicalMemoryRange)
#pragma alloc_text(PAGE, PmRemovePhysicalMemory)
#endif

VOID
PmDumpOsMemoryRanges(PWSTR Prefix)
{
    PPHYSICAL_MEMORY_RANGE memoryRanges;
    ULONG i;
    ULONGLONG start, end;

    memoryRanges = MmGetPhysicalMemoryRanges();

    if (memoryRanges == NULL) {
        return;
    }
    for (i = 0; memoryRanges[i].NumberOfBytes.QuadPart != 0; i++) {
        start = memoryRanges[i].BaseAddress.QuadPart;
        end = start + (memoryRanges[i].NumberOfBytes.QuadPart - 1);
        
        PmPrint((PNPMEM_MEMORY, "%ws:  OS Range range 0x%16I64X to 0x%16I64X\n",
                Prefix, start, end));
    }
    ExFreePool(memoryRanges);
}

NTSTATUS
PmGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION *Information
    )

/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated Unicode name of the value.

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION infoBuffer;
    ULONG keyValueLength;

    PAGED_CODE();

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValuePartialInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );

    //
    // handle highly unlikely case of a value that is zero sized.
    //
    if (NT_SUCCESS(status)) {
        return STATUS_UNSUCCESSFUL;
    }

    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //

    infoBuffer = ExAllocatePool(PagedPool,
                                keyValueLength);
    if (!infoBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValuePartialInformation,
                              infoBuffer,
                              keyValueLength,
                              &keyValueLength );
    if (!NT_SUCCESS( status )) {
        ExFreePool( infoBuffer );
        return status;
    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //

    *Information = infoBuffer;
    return STATUS_SUCCESS;
}

PPM_RANGE_LIST
PmRetrieveReservedMemoryResources(
    VOID
    )
{
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION valueInfo = NULL;
    PPM_RANGE_LIST reservedResourceRanges = NULL;
    HANDLE hReserved = NULL;
    NTSTATUS status;

    PAGED_CODE();

    RtlInitUnicodeString (&unicodeString, rgzReservedResources);
    InitializeObjectAttributes (&objectAttributes,
                                &unicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,       // handle
                                NULL);
    status = ZwOpenKey(&hReserved, KEY_READ, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        goto Error;
    }

    status = PmGetRegistryValue(hReserved,
                                rgzReservedResourcesValue,
                                &valueInfo);
    if (!NT_SUCCESS(status)) {
        goto Error;
    }

    if (valueInfo->Type != REG_RESOURCE_LIST) {
        goto Error;
    }

    reservedResourceRanges =
      PmCreateRangeListFromCmResourceList((PCM_RESOURCE_LIST) valueInfo->Data);

    // fall through

Error:
   if (hReserved != NULL) {
       ZwClose(hReserved);
   }

   if (valueInfo != NULL) {
       ExFreePool(valueInfo);
   }

   return reservedResourceRanges;
}

VOID
PmTrimReservedMemory(
    IN PPM_DEVICE_EXTENSION DeviceExtension,
    IN PPM_RANGE_LIST *PossiblyNewMemory
    )
{
    PPM_RANGE_LIST reservedMemoryList = NULL, newList = NULL;
    ULONG i;
    NTSTATUS status;
    BOOLEAN bResult = FALSE;

    PAGED_CODE();

    if (*PossiblyNewMemory == NULL) {
        return;
    }

    reservedMemoryList = PmRetrieveReservedMemoryResources();
    if (reservedMemoryList == NULL) {
        goto Error;
    }

    newList = PmIntersectRangeList(reservedMemoryList, *PossiblyNewMemory);
    if (newList == NULL) {
        goto Error;
    }

    if (PmIsRangeListEmpty(newList)) {
        goto Cleanup;
    }
    
    DeviceExtension->FailQueryRemoves = TRUE;

    PmFreeRangeList(newList);

    newList = PmSubtractRangeList(*PossiblyNewMemory,
                                  reservedMemoryList);
    if (newList) {
        PmFreeRangeList(*PossiblyNewMemory);
        *PossiblyNewMemory = newList;
        newList = NULL;
        goto Cleanup;
    }

    //
    // Fall through to error case where we ensure that we don't
    // innocently tell the OS to use memory that is reserved.
    //

 Error:
    PmFreeRangeList(*PossiblyNewMemory);
    *PossiblyNewMemory = NULL;
    DeviceExtension->FailQueryRemoves = TRUE;

 Cleanup:

    if (reservedMemoryList != NULL) {
        PmFreeRangeList(reservedMemoryList);
    }

    if (newList != NULL) {
        PmFreeRangeList(newList);
    }

    return;
}

VOID
PmLogAddError(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONGLONG Start,
    IN ULONGLONG Size,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This function logs a failure to add memory

Arguments:

    DeviceObject - Device object object for which the memory add
    failed.

    Start - The start of the physical memory range.

    Size - The size of the physical memory range.

    Status - Status code returned by MM.

Return Value:

    None.

--*/
{
    PIO_ERROR_LOG_PACKET packet;
    PWCHAR stringBuffer;
    UCHAR packetSize;
    int offset;

    //
    // Allocate a packet with space for 2 16 character hex value
    // strings including null terminators for each.
    //

    packetSize = sizeof(IO_ERROR_LOG_PACKET) + (sizeof(WCHAR)*(16+1))*2;
    packet = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(DeviceObject,
                                                            packetSize);
    if (packet == NULL) {
        return;
    }

    packet->DumpDataSize = 0;
    packet->NumberOfStrings = 2;
    packet->StringOffset = sizeof(IO_ERROR_LOG_PACKET);
    packet->ErrorCode = PNPMEM_ERR_FAILED_TO_ADD_MEMORY;
    packet->FinalStatus = Status;
    
    stringBuffer = (PWCHAR) (packet + 1);
    offset = swprintf(stringBuffer, L"%I64X", Start);

    swprintf(stringBuffer + offset + 1, L"%I64X", Size);
    
    IoWriteErrorLogEntry(packet);
}


NTSTATUS
PmAddPhysicalMemoryRange(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONGLONG Start,
    IN ULONGLONG End
    )

/*++

Routine Description:

    This function uses MmAddPhysicalMemory to notify the memory manager that
    physical memory is available.

Arguments:

    DeviceObject - device object of the memory device this range is part of.

    Start - The start of the physical memory range.

    End - The end of the physical memory range.

Return Value:

    None.

--*/

{
    NTSTATUS PrevStatus;
    NTSTATUS Status;
    ULONGLONG Size;
    ULONGLONG CurrentSize;
    PHYSICAL_ADDRESS StartAddress;
    LARGE_INTEGER NumberOfBytes;

    PAGED_CODE();

    ASSERT((Start & (PAGE_SIZE - 1)) == 0);
    ASSERT((End & (PAGE_SIZE - 1)) == (PAGE_SIZE - 1));

    //
    // This loop attempts to add the memory specified in the
    // arguments:
    //
    // If an attempt to add memory fails, a chunk half as large will
    // be tried next iteration until a chunk succeeds or the whole add
    // operation fails.
    //
    // If an attempt to add memory succeeds, a chunk twice as large
    // (bounded by the original range) will be tried next iteration.
    //
    // Loop ends when the original range is exhausted or the
    // addition of a range fails completely.
    //

    PrevStatus = Status = STATUS_SUCCESS;
    CurrentSize = Size = End - Start + 1;

    while (Size > 0) {

        StartAddress.QuadPart = Start;
        NumberOfBytes.QuadPart = CurrentSize;

        //
        // MmAddPhysicalMemory() adds the specified physical address
        // range to the system.  If any bytes are added,
        // STATUS_SUCCESS is returned and the NumberOfBytes field is
        // updated to reflect the number of bytes actually added.
        //

        Status = MmAddPhysicalMemory(
                     &StartAddress,
                     &NumberOfBytes
                 );

        if (NT_SUCCESS(Status)) {

            ASSERT((ULONGLONG)StartAddress.QuadPart == Start);
            ASSERT((NumberOfBytes.QuadPart & (PAGE_SIZE - 1)) == 0);
            ASSERT((ULONGLONG)NumberOfBytes.QuadPart <= CurrentSize);

            Start += NumberOfBytes.QuadPart;
            Size -= NumberOfBytes.QuadPart;

            //
            // If successful this iteration and the previous, then add
            // twice as much next time.
            //
            // Trim next attempt to reflect the remaining memory.
            //

            if (NT_SUCCESS(PrevStatus)) {
                CurrentSize <<= 1;
            }

            if (CurrentSize > Size) {
                CurrentSize = Size;
            }

        } else {

            //
            // Failed to add a range.  Halve the amount we're going to
            // try to add next time.  Breaks out if we're trying to
            // add less than a page.
            //

            CurrentSize = (CurrentSize >> 1) & ~(PAGE_SIZE - 1);

            if (CurrentSize < PAGE_SIZE) {
                break;
            }

        }

        PrevStatus = Status;

    }

    //
    // If the last add operation we attempted failed completely, then
    // log the error for posterity.
    //

    if (!NT_SUCCESS(Status)) {
        PmLogAddError(DeviceObject, Start, Size, Status);
        PmPrint((DPFLTR_WARNING_LEVEL | PNPMEM_MEMORY,
                 "Failed to add physical range 0x%I64X for 0x%I64X bytes\n",
                 Start, Size));
    }

    //
    // We don't know what portion of the range we succeeded in adding,
    // and which we failed.  Attempt in this case is all that matters.
    //

    return STATUS_SUCCESS;
}

NTSTATUS
PmAddPhysicalMemory(
    IN PDEVICE_OBJECT DeviceObject,
    IN PPM_RANGE_LIST PossiblyNewMemory
    )

/*++

Routine Description:

    This function adds the physical memory in the PM_RANGE_LIST which
    the memory manager does not yet know about to the system.  This
    requires getting a snapshot of the physical page map, then computing
    the set difference between the range list and the snapshot.  The
    difference represents the memory the memory manager does not yet know
    about.

Arguments:

    PossiblyNewMemory - The range list of physical addresses to be
    added.  This memory may already be known to the system depending
    on whether the machine POSTed with this memory installed.

Return Value:

    NTSTATUS

--*/

{
    PPM_RANGE_LIST knownPhysicalMemory, newMemory;
    NTSTATUS Status;
    NTSTATUS AddStatus;
    PLIST_ENTRY ListEntry;
    PPM_RANGE_LIST_ENTRY RangeListEntry;

    PAGED_CODE();

    //
    // Find out what physical memory regions MM already knows about
    //

    knownPhysicalMemory = PmCreateRangeListFromPhysicalMemoryRanges();
    if (knownPhysicalMemory == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Any memory in the ranges provided by this device that is
    // already known to MM is assumed to come from this device.
    // Presumeably the OS was handed this memory by firmware/POST.
    //
    // Find out what memory is contained by this device that MM
    // doesn't already know about by subtracting the MM physical
    // ranges from our device's memory ranges.
    //

    newMemory = PmSubtractRangeList(
        PossiblyNewMemory,
        knownPhysicalMemory
        );

    PmFreeRangeList(knownPhysicalMemory);
    
    //
    // Either we succeeded in getting a list of memory ranges to add
    // (including a possible null list) or we failed due to
    // insufficient resources.  The latter represents a problem since
    // a memory shortage may be keeping us from adding memory to
    // relieve the memory shortage.
    // 

    if (newMemory != NULL) {

        for (ListEntry = newMemory->List.Flink;
             ListEntry != &newMemory->List;
             ListEntry = ListEntry->Flink) {

            RangeListEntry = CONTAINING_RECORD(
                ListEntry,
                PM_RANGE_LIST_ENTRY,
                ListEntry
                );

            AddStatus = PmAddPhysicalMemoryRange(
                DeviceObject,
                RangeListEntry->Start,
                RangeListEntry->End
                );

            if (!NT_SUCCESS(AddStatus)) {
                PmPrint((DPFLTR_WARNING_LEVEL | PNPMEM_MEMORY,
                        "Failed to add physical range 0x%I64X to 0x%I64X\n",
                        RangeListEntry->Start, RangeListEntry->End));
            }
        }

        PmFreeRangeList(newMemory);

    }
    return STATUS_SUCCESS;
}

NTSTATUS
PmRemovePhysicalMemoryRange(
    IN ULONGLONG Start,
    IN ULONGLONG End
    )

/*++

Routine Description:

    This function uses MmRemovePhysicalMemory to notify the memory manager that
    physical memory is no longer available.

Arguments:

    Start - The start of the physical memory range.

    End - The end of the physical memory range.

Return Value:

    None.

--*/

{
#if 0
    NTSTATUS PrevStatus;
    NTSTATUS Status;
    ULONGLONG Size;
    ULONGLONG CurrentSize;
    PHYSICAL_ADDRESS StartAddress;
    LARGE_INTEGER NumberOfBytes;

    ASSERT((Start & (PAGE_SIZE - 1)) == 0);
    ASSERT((End & (PAGE_SIZE - 1)) == (PAGE_SIZE - 1));

    PrevStatus = Status = STATUS_SUCCESS;

    CurrentSize = Size = End - Start + 1;

    while (Size > 0) {

        StartAddress.QuadPart = Start;
        NumberOfBytes.QuadPart = CurrentSize;

        Status = MmRemovePhysicalMemory(
                     &StartAddress,
                     &NumberOfBytes
                 );
        Status = MAP_MMERROR(Status);

        if (NT_SUCCESS(Status)) {

            ASSERT((ULONGLONG)StartAddress.QuadPart == Start);
            ASSERT((NumberOfBytes.QuadPart & (PAGE_SIZE - 1)) == 0);
            ASSERT((ULONGLONG)NumberOfBytes.QuadPart <= CurrentSize);

            Start += NumberOfBytes.QuadPart;
            Size -= NumberOfBytes.QuadPart;

            if (NT_SUCCESS(PrevStatus)) {
                CurrentSize <<= 1;
            }

            if (CurrentSize > Size) {
                CurrentSize = Size;
            }

        } else {

            CurrentSize = (CurrentSize >> 1) & ~(PAGE_SIZE - 1);

            if (CurrentSize < PAGE_SIZE) {
                break;
            }

        }

        PrevStatus = Status;

    }
#else
    ULONGLONG Size;
    PHYSICAL_ADDRESS StartAddress;
    LARGE_INTEGER NumberOfBytes;
    NTSTATUS Status;

    PAGED_CODE();

    Size = (End - Start) + 1;
    StartAddress.QuadPart = Start;
    NumberOfBytes.QuadPart = Size;

    Status = MmRemovePhysicalMemory(
                 &StartAddress,
                 &NumberOfBytes
             );

    Status = MAP_MMERROR(Status);

#endif

    //
    // If it failed, routine automatically readds the memory in
    // question.
    //

    return Status;
}

NTSTATUS
PmRemovePhysicalMemory(
    IN PPM_RANGE_LIST RemoveMemoryList
    )

/*++

Routine Description:

    This function removes the physical memory in the PM_RANGE_LIST which
    the memory manager is currently using from the system.  This
    requires getting a snapshot of the physical page map, then computing
    the set intersection between the source range list and the snapshot.
    The intersection represents the memory the memory manager needs to
    stop using.

Arguments:

    RemoveMemoryList - The range list of physical addresses to be removed.

Return Value:

    None.

--*/

{
    PPM_RANGE_LIST physicalMemoryList, inuseMemoryList;
    NTSTATUS Status;
    PLIST_ENTRY ListEntry;
    PPM_RANGE_LIST_ENTRY RangeListEntry;

    PAGED_CODE();

    //
    // Remove the intersection between what the OS knows about and
    // what we are providing.
    //

    physicalMemoryList = PmCreateRangeListFromPhysicalMemoryRanges();

    if (physicalMemoryList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    inuseMemoryList = PmIntersectRangeList(
        RemoveMemoryList,
        physicalMemoryList
        );

    if (inuseMemoryList != NULL) {

        Status = STATUS_SUCCESS;
    
        for (ListEntry = inuseMemoryList->List.Flink;
             ListEntry != &inuseMemoryList->List;
             ListEntry = ListEntry->Flink) {

            RangeListEntry = CONTAINING_RECORD(
                ListEntry,
                PM_RANGE_LIST_ENTRY,
                ListEntry
                );

            Status = PmRemovePhysicalMemoryRange(
                RangeListEntry->Start,
                RangeListEntry->End
                );

            if (!NT_SUCCESS(Status)) {
                //
                // If we failed to remove a particular range, bail
                // now.  Code above should re-add the memory list if
                // appropriate i.e assume that some ranges may have
                // been removed successfully.
                //
                break;
            }
        }

        PmFreeRangeList(inuseMemoryList);

    } else {

        Status = STATUS_INSUFFICIENT_RESOURCES;

    }

    PmFreeRangeList(physicalMemoryList);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\basedrv\pnpmem\pnpmem.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    pnpmem.h

Author:

    Dave Richards (daveri) 16-Aug-1999

Environment:

    Kernel mode only.

Revision History:

--*/

#ifndef _PNPMEM_H_
#define _PNPMEM_H_

#include <ntddk.h>
#include <stdarg.h>
#include <stdio.h>
#include "errlog.h"

//
// A Range List Entry.
//

typedef struct {
    LIST_ENTRY          ListEntry;
    ULONGLONG           Start;
    ULONGLONG           End;
} PM_RANGE_LIST_ENTRY, *PPM_RANGE_LIST_ENTRY;

//
// A Range List.
//

typedef struct {
    LIST_ENTRY          List;
} PM_RANGE_LIST, *PPM_RANGE_LIST;

//
// FDO Device Extension.
//

typedef struct {
    ULONG               Flags;

    IO_REMOVE_LOCK      RemoveLock;
    PDEVICE_OBJECT      AttachedDevice;

    DEVICE_POWER_STATE  PowerState;
    DEVICE_POWER_STATE  DeviceStateMapping[PowerSystemMaximum];

    PPM_RANGE_LIST      RangeList;
    BOOLEAN             FailQueryRemoves;
} PM_DEVICE_EXTENSION, *PPM_DEVICE_EXTENSION;

#define DF_SURPRISE_REMOVED 0x01

PPM_RANGE_LIST
PmAllocateRangeList(
    VOID
    );

NTSTATUS
PmInsertRangeInList(
    PPM_RANGE_LIST InsertionList,
    ULONGLONG Start,
    ULONGLONG End
    );

VOID
PmFreeRangeList(
    IN PPM_RANGE_LIST RangeList
    );

BOOLEAN
PmIsRangeListEmpty(
    IN PPM_RANGE_LIST RangeList
    );

PPM_RANGE_LIST
PmCopyRangeList(
    IN PPM_RANGE_LIST SrcRangeList
    );

PPM_RANGE_LIST
PmInvertRangeList(
    IN PPM_RANGE_LIST SrcRangeList
    );

PPM_RANGE_LIST
PmSubtractRangeList(
    IN PPM_RANGE_LIST SrcRangeList1,
    IN PPM_RANGE_LIST SrcRangeList2
    );

PPM_RANGE_LIST
PmIntersectRangeList(
    IN PPM_RANGE_LIST SrcRangeList1,
    IN PPM_RANGE_LIST SrcRangeList2
    );

PPM_RANGE_LIST
PmCreateRangeListFromCmResourceList(
    IN PCM_RESOURCE_LIST CmResourceList
    );

PPM_RANGE_LIST
PmCreateRangeListFromPhysicalMemoryRanges(
    VOID
    );

NTSTATUS
PmAddPhysicalMemory(
    IN PDEVICE_OBJECT DeviceObject,
    IN PPM_RANGE_LIST RangeList1
    );

NTSTATUS
PmRemovePhysicalMemory(
    IN PPM_RANGE_LIST RangeList1
    );

VOID
PmTrimReservedMemory(
    IN PPM_DEVICE_EXTENSION DeviceExtension,
    IN PPM_RANGE_LIST *PossiblyNewMemory
    );

NTSTATUS
PmGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION *Information
    );

VOID
PmDebugPrint(
    IN ULONG   DebugPrintLevel,
    IN PCCHAR  DebugMessage,
    ...
    );

VOID
PmDebugDumpRangeList(
    IN ULONG   DebugPrintLevel,
    IN PCCHAR  DebugMessage,
    PPM_RANGE_LIST RangeList
    );


#if DBG
#define PmPrint(x) PmDebugPrint x
#else
#define PmPrint(x)
#endif
    
#define PNPMEM_MEMORY (DPFLTR_INFO_LEVEL + 1)
#define PNPMEM_PNP    (DPFLTR_INFO_LEVEL + 2)

VOID
PmDumpOsMemoryRanges(
    IN PWSTR Prefix
    );

extern BOOLEAN MemoryRemovalSupported;

#endif /* _PNPMEM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\basedrv\pnpmem\pnp.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module implements the IRP_MJ_PNP IRP processing routines for the
    Plug and Play Memory driver.  Dispatch routines are invoked through
    tables located at the bottom of the module.

Author:

    Dave Richards (daveri) 16-Aug-1999

Environment:

    Kernel mode only.

Revision History:

--*/

#include "pnpmem.h"

NTSTATUS
PmPassIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmDeferProcessing(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PmStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PmSurpriseRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PmPassIrp)
#pragma alloc_text(PAGE, PmPnpDispatch)
#pragma alloc_text(PAGE, PmDeferProcessing)
#pragma alloc_text(PAGE, PmStartDevice)
#pragma alloc_text(PAGE, PmQueryRemoveDevice)
#pragma alloc_text(PAGE, PmRemoveDevice)
#pragma alloc_text(PAGE, PmCancelRemoveDevice)
#pragma alloc_text(PAGE, PmQueryStopDevice)
#pragma alloc_text(PAGE, PmCancelStopDevice)
#pragma alloc_text(PAGE, PmSurpriseRemoveDevice)
#pragma alloc_text(PAGE, PmQueryCapabilities)
#endif

PDRIVER_DISPATCH PmPnpDispatchTable[];
extern ULONG PmPnpDispatchTableSize;

NTSTATUS
PmPassIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PPM_DEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;
    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(deviceExtension->AttachedDevice, Irp);
}

NTSTATUS
PmPnpDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles IRP_MJ_PNP IRPs for FDOs.

Arguments:

    DeviceObject - Pointer to the FDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    NTSTATUS status;
    BOOLEAN isRemoveDevice;
    PIO_STACK_LOCATION irpSp;
    PPM_DEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    IoAcquireRemoveLock(&deviceExtension->RemoveLock, (PVOID) Irp);

    isRemoveDevice = irpSp->MinorFunction == IRP_MN_REMOVE_DEVICE;

    if ((irpSp->MinorFunction < PmPnpDispatchTableSize) &&
        PmPnpDispatchTable[irpSp->MinorFunction]) {

        status =
            PmPnpDispatchTable[irpSp->MinorFunction](DeviceObject,
                                                     Irp
                                                     );
    } else {
        status = PmPassIrp(DeviceObject, Irp);
    }

    if (!isRemoveDevice) {
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, (PVOID) Irp);
    }

    return status;
}

NTSTATUS
PmPnpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is used to defer processing of an IRP until drivers
    lower in the stack including the bus driver have done their
    processing.

    This routine triggers the event to indicate that processing of the
    irp can now continue.

Arguments:

    DeviceObject - Pointer to the FDO for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/

{
    KeSetEvent((PKEVENT) Context, EVENT_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
PmDeferProcessing(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine is used to defer processing of an IRP until drivers
    lower in the stack including the bus driver have done their
    processing.

    This routine uses an IoCompletion routine along with an event to
    wait until the lower level drivers have completed processing of
    the irp.

Arguments:

    Parent - FDO extension for the FDO devobj in question

    Irp - Pointer to the IRP_MJ_PNP IRP to defer

Return Value:

    NT status.

--*/
{
    PPM_DEVICE_EXTENSION deviceExtension;
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Set our completion routine
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           PmPnpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE
                           );
    status =  IoCallDriver(deviceExtension->AttachedDevice, Irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;
}

NTSTATUS
PmStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function handles IRP_MN_START_DEVICE IRPs.

Arguments:

    DeviceObject - The functional device object.

    Irp - The I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION irpSp;
    PPM_RANGE_LIST RangeList;
    PPM_DEVICE_EXTENSION deviceExtension;
    POWER_STATE power;
    NTSTATUS status;

    PAGED_CODE();

    status = PmDeferProcessing(DeviceObject, Irp);
    if (!NT_SUCCESS(status)) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    PmDumpOsMemoryRanges(L"Before Start");

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;
    ASSERT(deviceExtension->RangeList == NULL);
    
    if (irpSp->Parameters.StartDevice.AllocatedResources) {
        RangeList = PmCreateRangeListFromCmResourceList(
            irpSp->Parameters.StartDevice.AllocatedResources
            );
        if (RangeList == NULL) {
            //
            // The memory allocation failure here is more serious than
            // is intially obvious.  If we fail this allocation, we're
            // going to get removed from the stack before we find out
            // if the OS knows about this memory.  If the OS knows
            // about this memory already, then ejecting the PDO would
            // cause the memory underneath the OS to disappear.
            // Better to be on the stack, but not have added any
            // memory then to be off the stack and leave a dangerous
            // situation.
            //
            // Only solution is to arbitrarily fail
            // IRP_MN_QUERY_REMOVE.
            //
            deviceExtension->FailQueryRemoves = TRUE;
        }
    } else {
        RangeList = NULL;
    }

    PmTrimReservedMemory(deviceExtension, &RangeList);

    PmDebugDumpRangeList(PNPMEM_MEMORY, "Memory Ranges to be added:\n",
                         RangeList);
    if (deviceExtension->FailQueryRemoves) {
        PmPrint((DPFLTR_WARNING_LEVEL | PNPMEM_MEMORY, "PNPMEM device can't be removed\n"));
    }

    if (RangeList != NULL) {

        (VOID) PmAddPhysicalMemory(DeviceObject, RangeList);
        deviceExtension->RangeList = RangeList;
    }

    power.DeviceState = PowerDeviceD0;
    PoSetPowerState(DeviceObject, DevicePowerState, power);
    deviceExtension->PowerState = PowerDeviceD0;

    PmDumpOsMemoryRanges(L"After Start ");

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
PmQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function handles IRP_MN_QUERY_REMOVE_DEVICE IRPs.

Arguments:

    DeviceObject - The functional device object.

    Irp - The I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PPM_DEVICE_EXTENSION deviceExtension;
    NTSTATUS status;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    if (!MemoryRemovalSupported) {
        PmPrint((DPFLTR_WARNING_LEVEL | PNPMEM_MEMORY,
                 "QueryRemove vetoed because memory removal is not supported\n"));
        status = STATUS_UNSUCCESSFUL;
    } else if (deviceExtension->FailQueryRemoves) {
        PmPrint((DPFLTR_WARNING_LEVEL | PNPMEM_MEMORY,
                 "QueryRemove vetoed because removing this memory device may contain special memory\n"));
        status = STATUS_UNSUCCESSFUL;
    } else if (deviceExtension->RangeList != NULL) {
        status = PmRemovePhysicalMemory(deviceExtension->RangeList);
        if (!NT_SUCCESS(status)) {
            //
            // Some ranges may have been removed, before failure.  Add
            // them back.  Should be low-cost due to optimizations in
            // PmAddPhysicalMemory.
            //

            (VOID) PmAddPhysicalMemory(DeviceObject, deviceExtension->RangeList);
        }
    } else {
        status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = status;
    if (NT_SUCCESS(status)) {
        return PmPassIrp(DeviceObject, Irp);
    } else {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }
}

NTSTATUS
PmRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function handles IRP_MN_REMOVE_DEVICE IRPs.

Arguments:

    DeviceObject - The functional device object.

    Irp - The I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PPM_DEVICE_EXTENSION deviceExtension;
    PPM_RANGE_LIST RangeList;
    POWER_STATE power;
    NTSTATUS status;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    if ((deviceExtension->Flags & DF_SURPRISE_REMOVED) == 0) {
        power.DeviceState = PowerDeviceD3;
        PoSetPowerState(DeviceObject, DevicePowerState, power);
        deviceExtension->PowerState = PowerDeviceD0;

        if (deviceExtension->RangeList != NULL) {
            status = PmRemovePhysicalMemory(deviceExtension->RangeList);
            ASSERT(status == STATUS_SUCCESS);
            DbgBreakPoint();
        }
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    status = PmPassIrp(DeviceObject, Irp);

    IoReleaseRemoveLockAndWait(&deviceExtension->RemoveLock, (PVOID) Irp);

    IoDetachDevice(deviceExtension->AttachedDevice);
    deviceExtension->AttachedDevice = NULL;

    if (deviceExtension->RangeList != NULL) {
        PmFreeRangeList(deviceExtension->RangeList);
        deviceExtension->RangeList = NULL;
    }

    IoDeleteDevice(DeviceObject);

    return status;
}
    
NTSTATUS
PmCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function handles IRP_MN_CANCEL_REMOVE_DEVICE IRPs.

Arguments:

    DeviceObject - The functional device object.

    Irp - The I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PPM_DEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    (VOID) PmDeferProcessing(DeviceObject, Irp);

    deviceExtension = DeviceObject->DeviceExtension;

    if (deviceExtension->RangeList != NULL) {
        (VOID) PmAddPhysicalMemory(DeviceObject, deviceExtension->RangeList);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
PmQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function handles IRP_MN_QUERY_STOP_DEVICE IRPs.

Arguments:

    DeviceObject - The functional device object.

    Irp - The I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PAGED_CODE();

    Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_DEVICE_BUSY;
}

NTSTATUS
PmCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function handles IRP_MN_CANCEL_STOP_DEVICE IRPs.

Arguments:

    DeviceObject - The functional device object.

    Irp - The I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    (VOID) PmDeferProcessing(DeviceObject, Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
PmQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PPM_DEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    status = PmDeferProcessing(DeviceObject, Irp);
    if (!NT_SUCCESS(status)) {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (irpSp->Parameters.DeviceCapabilities.Capabilities->Version != 1) {
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_INVALID_PARAMETER;
    }

    for (i = 0; i < PowerSystemMaximum; i++) {
        deviceExtension->DeviceStateMapping[i] =
            irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[i];
    }

    //
    // Would *LIKE* to smash the eject supported, and removable bits
    // here but this isn't really supported.  The hot plug applet pops
    // up (because the device is marked removable or ejectable) and
    // then goes away a few seconds later when the driver is installed
    // (and the capabilities requeried).
    //

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}

NTSTATUS
PmSurpriseRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PPM_DEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    if (deviceExtension->RangeList != NULL) {
        // XXX
        // KeBugCheckEx(MEMORY_FATAL_ERROR,
        //              ....
    }

    deviceExtension->Flags |= DF_SURPRISE_REMOVED;

    if (deviceExtension->RangeList != NULL) {
        PmFreeRangeList(deviceExtension->RangeList);
        deviceExtension->RangeList = NULL;
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return PmPassIrp(DeviceObject, Irp);
}

PDRIVER_DISPATCH PmPnpDispatchTable[] = {
    PmStartDevice,          // IRP_MN_START_DEVICE                    
    PmQueryRemoveDevice,    // IRP_MN_QUERY_REMOVE_DEVICE             
    PmRemoveDevice,         // IRP_MN_REMOVE_DEVICE                   
    PmCancelRemoveDevice,   // IRP_MN_CANCEL_REMOVE_DEVICE            
    NULL,                   // IRP_MN_STOP_DEVICE (never get, fails query-stop)
    PmQueryStopDevice,      // IRP_MN_QUERY_STOP_DEVICE               
    PmCancelStopDevice,     // IRP_MN_CANCEL_STOP_DEVICE              
    NULL,                   // IRP_MN_QUERY_DEVICE_RELATIONS          
    NULL,                   // IRP_MN_QUERY_INTERFACE                 
    PmQueryCapabilities,    // IRP_MN_QUERY_CAPABILITIES              
    NULL,                   // IRP_MN_QUERY_RESOURCES                 
    NULL,                   // IRP_MN_QUERY_RESOURCE_REQUIREMENTS     
    NULL,                   // IRP_MN_QUERY_DEVICE_TEXT               
    NULL,                   // IRP_MN_FILTER_RESOURCE_REQUIREMENTS    
    NULL,                   // unused                                       
    NULL,                   // IRP_MN_READ_CONFIG                     
    NULL,                   // IRP_MN_WRITE_CONFIG                    
    NULL,                   // IRP_MN_EJECT                           
    NULL,                   // IRP_MN_SET_LOCK                        
    NULL,                   // IRP_MN_QUERY_ID                        
    NULL,                   // IRP_MN_QUERY_PNP_DEVICE_STATE          
    NULL,                   // IRP_MN_QUERY_BUS_INFORMATION           
    NULL,                   // IRP_MN_DEVICE_USAGE_NOTIFICATION       
    PmSurpriseRemoveDevice, // IRP_MN_SURPRISE_REMOVAL
};

ULONG PmPnpDispatchTableSize =
    sizeof (PmPnpDispatchTable) / sizeof (PmPnpDispatchTable[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\basedrv\pnpmem\pnpmem.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    pnpmem.c

Abstract:

    This module implements the Plug and Play Memory driver entry points.

Author:

    Dave Richards (daveri) 16-Aug-1999

Environment:

    Kernel mode only.

Revision History:

--*/

#include "pnpmem.h"
#include <initguid.h>
#include <poclass.h>

#define PM_DEBUG_BUFFER_SIZE   512
#define rgzMemoryManagement L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager\\Memory Management"
#define rgzMemoryRemovable L"Memory Removable"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );
    
NTSTATUS
PmAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
PmPnpDispatch(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    );

VOID
PmUnload(
    IN PDRIVER_OBJECT DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, PmAddDevice)
#pragma alloc_text(PAGE, PmUnload)
#endif

ULONG DbgMask = 0xFFFFFFFF;
BOOLEAN MemoryRemovalSupported;

#if DBG
VOID
PmDebugPrint(
    ULONG   DebugPrintLevel,
    PCCHAR  DebugMessage,
    ...
    )
/*++

Routine Description:

Arguments:

    DebugPrintLevel - The bit mask that when anded with the debuglevel, must
                        equal itself
    DebugMessage    - The string to feed through vsprintf

Return Value:

    None

--*/
{
    va_list ap;
    UCHAR   debugBuffer[PM_DEBUG_BUFFER_SIZE];

    //
    // Get the variable arguments
    //
    va_start( ap, DebugMessage );

    //
    // Call the kernel function to print the message
    //
    _vsnprintf( debugBuffer, PM_DEBUG_BUFFER_SIZE, DebugMessage, ap );

    if (DebugPrintLevel & DbgMask) {
        DbgPrint("%s", debugBuffer);
    }

    //
    // We are done with the varargs
    //
    va_end( ap );
}
#endif

NTSTATUS
PmAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This function creates a functional device object and attaches it to
    the physical device object (device stack).

Arguments:

    DriverObject - The driver object.

    Pdo - The physical device object.

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_OBJECT functionalDeviceObject;
    PDEVICE_OBJECT attachedDeviceObject;
    PPM_DEVICE_EXTENSION deviceExtension;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Create the FDO.
    //

    status = IoCreateDevice(
                 DriverObject,
                 sizeof (PM_DEVICE_EXTENSION),
                 NULL,
                 FILE_DEVICE_UNKNOWN | FILE_DEVICE_SECURE_OPEN,
                 0,
                 FALSE,
                 &functionalDeviceObject
                 );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Attach the FDO (indirectly) to the PDO.
    //
    
    deviceExtension = functionalDeviceObject->DeviceExtension;

    deviceExtension->AttachedDevice = IoAttachDeviceToDeviceStack(
                                          functionalDeviceObject,
                                          PhysicalDeviceObject
                                          );

    if (deviceExtension->AttachedDevice == NULL) {
        IoDeleteDevice(functionalDeviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }

    IoInitializeRemoveLock(&deviceExtension->RemoveLock, 0, 1, 20);

    functionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return status;
}

NTSTATUS
PmControlDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PPM_DEVICE_EXTENSION deviceExtension;

    deviceExtension = DeviceObject->DeviceExtension;
    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(deviceExtension->AttachedDevice, Irp);
}

VOID
PmPowerCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PPM_DEVICE_EXTENSION deviceExtension;
    PIRP Irp;
    NTSTATUS status;

    Irp = Context;
    deviceExtension = DeviceObject->DeviceExtension;

    Irp->IoStatus.Status = IoStatus->Status;
    PoStartNextPowerIrp(Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
}

NTSTATUS
PmPowerCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID NotUsed
    )
/*++

Routine Description:

   The completion routine for Power

Arguments:

   DeviceObject - pointer to a device object.

   Irp - pointer to an I/O Request Packet.

   Not used  - context pointer

Return Value:

   NT status code

--*/
{
    PIO_STACK_LOCATION irpStack;
    PPM_DEVICE_EXTENSION deviceExtension;
    NTSTATUS status;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    if (irpStack->Parameters.Power.Type == SystemPowerState) {
        SYSTEM_POWER_STATE system =
            irpStack->Parameters.Power.State.SystemState;
        POWER_STATE power;

        if (NT_SUCCESS(Irp->IoStatus.Status)) {

            power.DeviceState = deviceExtension->DeviceStateMapping[system];

            status = PoRequestPowerIrp(DeviceObject,
                              irpStack->MinorFunction,
                              power,
                              PmPowerCallback,
                              Irp, 
                              NULL);
            if (NT_SUCCESS(status)) {
                return STATUS_MORE_PROCESSING_REQUIRED;
            } else {
                Irp->IoStatus.Status = status;
            }
        }
        PoStartNextPowerIrp(Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        return STATUS_SUCCESS;
    } else {
        if (NT_SUCCESS(Irp->IoStatus.Status)) {
            PoSetPowerState(DeviceObject, DevicePowerState,
                            irpStack->Parameters.Power.State);
            deviceExtension->PowerState =
                irpStack->Parameters.Power.State.DeviceState;
        }
        PoStartNextPowerIrp(Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        return STATUS_SUCCESS;
    }
}
NTSTATUS
PmPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PPM_DEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS status;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    status = IoAcquireRemoveLock(&deviceExtension->RemoveLock, (PVOID) Irp);
    if (status == STATUS_DELETE_PENDING) {
        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
         PoStartNextPowerIrp(Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    if (irpStack->Parameters.Power.Type == SystemPowerState) {
        switch (irpStack->MinorFunction) {
        case IRP_MN_QUERY_POWER:
        case IRP_MN_SET_POWER:
            IoMarkIrpPending(Irp);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp,
                                   PmPowerCompletion,
                                   NULL,  //Context
                                   TRUE,  //InvokeOnSuccess
                                   TRUE,  //InvokeOnError
                                   TRUE   //InvokeOnCancel
                                   );
            (VOID) PoCallDriver(deviceExtension->AttachedDevice, Irp);
            return STATUS_PENDING;
        default:
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            status = PoCallDriver(deviceExtension->AttachedDevice, Irp);
            IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            return status;
        }
    } else {
        switch (irpStack->MinorFunction) {
        case IRP_MN_SET_POWER:

            if (irpStack->Parameters.Power.State.DeviceState <=
                deviceExtension->PowerState) {

                //
                // Powering up device
                //

                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       PmPowerCompletion,
                                       NULL,   //Context
                                       TRUE,   //InvokeOnSuccess
                                       TRUE,  //InvokeOnError
                                       TRUE   //InvokeOnCancel
                                       );
                (VOID) PoCallDriver(deviceExtension->AttachedDevice, Irp);
                return STATUS_PENDING;

            } else {

                //
                // Powering down device
                //

                PoSetPowerState(DeviceObject, DevicePowerState,
                                irpStack->Parameters.Power.State);
                deviceExtension->PowerState =
                    irpStack->Parameters.Power.State.DeviceState;
                // 
                // Fall through ...
                //
            }
        case IRP_MN_QUERY_POWER:
            //
            // Fall through as the bus driver will mark this
            // STATUS_SUCCESS and complete it, if it gets that far.
            //
        default:
            PoStartNextPowerIrp(Irp);
            IoSkipCurrentIrpStackLocation(Irp);
            break;
        }
        status = PoCallDriver(deviceExtension->AttachedDevice, Irp);
        IoReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        return status;
    }
}

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This function initializes the driver object.

Arguments:

    DriverObject - The driver object.

    RegistryPath - The registry path for the device.

Return Value:

    STATUS_SUCCESS

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING unicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION valueInfo;
    HANDLE hMemoryManagement;
    NTSTATUS status;
    
    PAGED_CODE();

    RtlInitUnicodeString (&unicodeString, rgzMemoryManagement);
    InitializeObjectAttributes (&objectAttributes,
                                &unicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,       // handle
                                NULL);
    status = ZwOpenKey(&hMemoryManagement, KEY_READ, &objectAttributes);
    if (NT_SUCCESS(status)) {
        status = PmGetRegistryValue(hMemoryManagement,
                                    rgzMemoryRemovable,
                                    &valueInfo);
        if (NT_SUCCESS(status)) {
            if ((valueInfo->Type == REG_DWORD) &&
                (valueInfo->DataLength >= sizeof(ULONG))) {
                MemoryRemovalSupported = (BOOLEAN) *((PULONG)valueInfo->Data);
            }
            ExFreePool(valueInfo);
        }
        ZwClose(hMemoryManagement);
    }

    DriverObject->MajorFunction[IRP_MJ_PNP] = PmPnpDispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER] = PmPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = PmControlDispatch;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = PmControlDispatch;
    DriverObject->DriverExtension->AddDevice = PmAddDevice;

    return STATUS_SUCCESS;
}

VOID
PmUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:
    
    This is called to reverse any operations performed in DriverEntry before a
    driver is unloaded.
        
Arguments:

    DriverObject - The system owned driver object for PNPMEM
    
--*/
{
    PAGED_CODE();
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\basedrv\pnpmem\range.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    range.c

Abstract:

    This module implements the range list routines for the Plug and Play Memory
    driver.

Author:

    Dave Richards (daveri) 16-Aug-1999

Environment:

    Kernel mode only.

Revision History:

--*/

#include "pnpmem.h"

PPM_RANGE_LIST_ENTRY
PmAllocateRangeListEntry(
    VOID
    );

VOID
PmFreeRangeListEntry(
    IN PPM_RANGE_LIST_ENTRY RangeListEntry
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PmAllocateRangeListEntry)
#pragma alloc_text(PAGE, PmInsertRangeInList)
#pragma alloc_text(PAGE, PmFreeRangeListEntry)
#pragma alloc_text(PAGE, PmAllocateRangeList)
#pragma alloc_text(PAGE, PmFreeRangeList)
#pragma alloc_text(PAGE, PmIsRangeListEmpty)
#pragma alloc_text(PAGE, PmDebugDumpRangeList)
#pragma alloc_text(PAGE, PmCopyRangeList)
#pragma alloc_text(PAGE, PmSubtractRangeList)
#pragma alloc_text(PAGE, PmIntersectRangeList)
#pragma alloc_text(PAGE, PmCreateRangeListFromCmResourceList)
#pragma alloc_text(PAGE, PmCreateRangeListFromPhysicalMemoryRanges)
#endif


PPM_RANGE_LIST_ENTRY
PmAllocateRangeListEntry(
    VOID
    )

/*++

Routine Description:

    This function allocates a range list entry from paged pool.

Arguments:

    None.

Return Value:

    Upon success a pointer to a PM_RANGE_LIST_ENTRY object is returned,
    otherwise NULL.

--*/

{
    PPM_RANGE_LIST_ENTRY RangeListEntry;

    PAGED_CODE();

    RangeListEntry = ExAllocatePool(
                         PagedPool,
                         sizeof (PM_RANGE_LIST_ENTRY)
                     );

    return RangeListEntry;
}

NTSTATUS
PmInsertRangeInList(
    PPM_RANGE_LIST InsertionList,
    ULONGLONG Start,
    ULONGLONG End
    )
{
    PPM_RANGE_LIST_ENTRY entry;

    entry = PmAllocateRangeListEntry();
    if (entry == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    entry->Start = Start;
    entry->End = End;

    InsertTailList(&InsertionList->List,
                   &entry->ListEntry);

    return STATUS_SUCCESS;
}

VOID
PmFreeRangeListEntry(
    IN PPM_RANGE_LIST_ENTRY RangeListEntry
    )

/*++

Routine Description:

    This function de-allocates a range list entry object.

Arguments:

    RangeListEntry - The PM_RANGE_LIST_ENTRY to be de-allocated.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ASSERT(RangeListEntry != NULL);

    ExFreePool(RangeListEntry);
}

PPM_RANGE_LIST
PmAllocateRangeList(
    VOID
    )

/*++

Routine Description:

    This function allocates and initializes a range list from paged pool.

Arguments:

    None.

Return Value:

    Upon success a pointer to a PM_RANGE_LIST object is returned, otherwise
    NULL.

--*/

{
    PPM_RANGE_LIST RangeList;

    PAGED_CODE();

    RangeList = ExAllocatePool(
                    PagedPool,
                    sizeof (PM_RANGE_LIST)
                );

    if (RangeList != NULL) {
        InitializeListHead(&RangeList->List);
    }

    return RangeList;
}

VOID
PmFreeRangeList(
    IN PPM_RANGE_LIST RangeList
    )

/*++

Routine Description:

    This function removes all entries from a range list and de-allocates it.

Arguments:

    RangeList - The PM_RANGE_LIST to be de-allocated.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListEntry;
    PPM_RANGE_LIST_ENTRY RangeListEntry;

    PAGED_CODE();

    for (ListEntry = RangeList->List.Flink;
         ListEntry != &RangeList->List;
         ListEntry = RangeList->List.Flink) {

        RangeListEntry = CONTAINING_RECORD(
                             ListEntry,
                             PM_RANGE_LIST_ENTRY,
                             ListEntry
                         );

        RemoveEntryList(ListEntry);

        PmFreeRangeListEntry(RangeListEntry);

    }

    ExFreePool(RangeList);
}

BOOLEAN
PmIsRangeListEmpty(
    IN PPM_RANGE_LIST RangeList
    )

/*++

Routine Description:

    This function determines whether the specified range list is empty.

Arguments:

    RangeList - The PM_RANGE_LIST.

Return Value:

    TRUE if the PM_RANGE_LIST has no PM_RANGE_LIST_ENTRYs, otherwise FALSE.

--*/

{
    PAGED_CODE();

    return IsListEmpty(&RangeList->List);
}

VOID
PmDebugDumpRangeList(
    IN ULONG   DebugPrintLevel,
    IN PCCHAR  DebugMessage,
    PPM_RANGE_LIST RangeList
    )
{
    PLIST_ENTRY listEntry;
    PPM_RANGE_LIST_ENTRY rangeListEntry;

    PmPrint((DebugPrintLevel, DebugMessage));

    if (RangeList == NULL) {
        PmPrint((DebugPrintLevel, "\tNULL\n"));
        return;
    } else if (PmIsRangeListEmpty(RangeList)) {
        PmPrint((DebugPrintLevel, "\tEmpty\n"));
        return;
    } else {
        for (listEntry = RangeList->List.Flink;
             listEntry != &RangeList->List;
             listEntry = listEntry->Flink) {

            rangeListEntry = CONTAINING_RECORD(
                listEntry,
                PM_RANGE_LIST_ENTRY,
                ListEntry
                );
            PmPrint((DebugPrintLevel, "\t0x%I64X - 0x%I64X\n",
                     rangeListEntry->Start, rangeListEntry->End));
        }
    }
}

PPM_RANGE_LIST
PmCopyRangeList(
    IN PPM_RANGE_LIST SrcRangeList
    )

/*++

Routine Description:

    This function creates a copy of a PM_RANGE_LIST and its supporting
    PM_RANGE_LIST_ENTRY objects.

Arguments:

    SrcRangeList - The PM_RANGE_LIST to be copied.

Return Value:

    Upon success a pointer to a PM_RANGE_LIST is returned, otherwise NULL.

--*/

{
    PPM_RANGE_LIST DstRangeList;
    PLIST_ENTRY ListEntry;
    PPM_RANGE_LIST_ENTRY SrcRangeListEntry;
    PPM_RANGE_LIST_ENTRY DstRangeListEntry;

    PAGED_CODE();

    DstRangeList = PmAllocateRangeList();

    if (DstRangeList != NULL) {

        for (ListEntry = SrcRangeList->List.Flink;
             ListEntry != &SrcRangeList->List;
             ListEntry = ListEntry->Flink) {

            SrcRangeListEntry = CONTAINING_RECORD(
                                    ListEntry,
                                    PM_RANGE_LIST_ENTRY,
                                    ListEntry
                                );

            DstRangeListEntry = PmAllocateRangeListEntry();

            if (DstRangeListEntry == NULL) {
                PmFreeRangeList(DstRangeList);
                DstRangeList = NULL;
                break;
            }

            DstRangeListEntry->Start = SrcRangeListEntry->Start;
            DstRangeListEntry->End = SrcRangeListEntry->End;

            InsertTailList(
                &DstRangeList->List,
                &DstRangeListEntry->ListEntry
            );

        }

    }

    return DstRangeList;
}

PPM_RANGE_LIST
PmSubtractRangeList(
    IN PPM_RANGE_LIST MinuendList,
    IN PPM_RANGE_LIST SubtrahendList
    )

/*++

Routine Description:

    This function creates a new range list which represents the set difference
    between MinuendList and SubtrahendList.

Arguments:

    MinuendList - The minuend range list.

    SubtrahendList - The subtrahend range list.

Return Value:

    Upon success a pointer to the destination (difference) PM_RANGE_LIST is
    returned, otherwise NULL.

--*/

{
    PPM_RANGE_LIST DstRangeList;
    PLIST_ENTRY DstListEntry;
    PPM_RANGE_LIST_ENTRY DstRangeListEntry;
    PLIST_ENTRY SrcListEntry;
    PPM_RANGE_LIST_ENTRY SrcRangeListEntry;
    ULONGLONG Start;
    ULONGLONG End;
    PLIST_ENTRY ListEntry;
    PPM_RANGE_LIST_ENTRY RangeListEntry;

    PAGED_CODE();

    ASSERT(MinuendList != NULL);
    ASSERT(SubtrahendList != NULL);

    //
    // Make a copy of the minuend.
    //

    DstRangeList = PmCopyRangeList(MinuendList);

    if (DstRangeList != NULL) {

        //
        // Loop through each range list entry in the minuend.
        //

        for (DstListEntry = DstRangeList->List.Flink;
             DstListEntry != &DstRangeList->List;
             DstListEntry = DstListEntry->Flink) {

            DstRangeListEntry = CONTAINING_RECORD(
                                    DstListEntry,
                                    PM_RANGE_LIST_ENTRY,
                                    ListEntry
                                );

            //
            // Loop through each range list entry in the subtrahend.
            //

            for (SrcListEntry = SubtrahendList->List.Flink;
                 SrcListEntry != &SubtrahendList->List;
                 SrcListEntry = SrcListEntry->Flink) {

                SrcRangeListEntry = CONTAINING_RECORD(
                                        SrcListEntry,
                                        PM_RANGE_LIST_ENTRY,
                                        ListEntry
                                    );

                //
                // Compute the intersection of the minuend and subtrahend
                // range list entries.
                //

                Start = DstRangeListEntry->Start;

                if (Start < SrcRangeListEntry->Start) {
                    Start = SrcRangeListEntry->Start;
                };

                End = DstRangeListEntry->End;

                if (End > SrcRangeListEntry->End) {
                    End = SrcRangeListEntry->End;
                };

                if (Start > End) {
                    continue;
                }

                //
                // There are 4 cases:
                //
                //   1. The intersection overlaps the minuend range completely.
                //   2. The intersection overlaps the start of the minuend
                //      range.
                //   3. The intersection overlaps the end of the minuend range.
                //   4. The intersection overlaps the middle of the minuend
                //      range.
                //

                if (DstRangeListEntry->Start == Start) {

                    if (DstRangeListEntry->End == End) {

                        //
                        // Case 1: Remove the minuend range list entry.
                        //

                        ListEntry = DstListEntry;
                        DstListEntry = DstListEntry->Blink;
                        RemoveEntryList(ListEntry);
                        PmFreeRangeListEntry(DstRangeListEntry);
                        break;

                    } else {

                        //
                        // Case 2: Increase the minuend's start.
                        //

                        DstRangeListEntry->Start = End + 1;

                    }

                } else {

                    if (DstRangeListEntry->End == End) {

                        //
                        // Case 3: Decrease the minend's end.
                        //

                        DstRangeListEntry->End = Start - 1;

                    } else {

                        //
                        // Case 4: Divide the range list entry into two
                        //   pieces.  The first range list entry's end should
                        //   be just before the intersection start.  The
                        //   second range list entry's start should be just
                        //   after the intersection end.
                        //

                        RangeListEntry = PmAllocateRangeListEntry();

                        if (RangeListEntry == NULL) {
                            PmFreeRangeList(DstRangeList);
                            return NULL;
                        }

                        RangeListEntry->Start = End + 1;
                        RangeListEntry->End = DstRangeListEntry->End;

                        //
                        // BUGBUG Break the list ordering but ensure that
                        //        we'll perform the subtraction against the
                        //        new range list entry as well.
                        //

                        InsertHeadList(
                            &DstRangeListEntry->ListEntry,
                            &RangeListEntry->ListEntry
                        );

                        DstRangeListEntry->End = Start - 1;

                    }
                }
            }
        }
    }

    return DstRangeList;
}

PPM_RANGE_LIST
PmIntersectRangeList(
    IN PPM_RANGE_LIST SrcRangeList1,
    IN PPM_RANGE_LIST SrcRangeList2
    )

/*++

Routine Description:

    This function creates a new range list which represents the intersection
    between SrcRangeList1 and SrcRangeList2.

Arguments:

    SrcRangeList1, SrcRangeList - The range lists upon which to compute the
        intersection.

Return Value:

    Upon success a pointer to the destination (intersection) PM_RANGE_LIST is
    returned, otherwise NULL.

--*/

{
    PPM_RANGE_LIST DstRangeList;
    PLIST_ENTRY SrcListEntry1;
    PPM_RANGE_LIST_ENTRY SrcRangeListEntry1;
    PLIST_ENTRY SrcListEntry2;
    PPM_RANGE_LIST_ENTRY SrcRangeListEntry2;
    ULONGLONG Start;
    ULONGLONG End;
    PPM_RANGE_LIST_ENTRY RangeListEntry;

    PAGED_CODE();

    ASSERT(SrcRangeList1 != NULL);
    ASSERT(SrcRangeList2 != NULL);

    DstRangeList = PmAllocateRangeList();

    if (DstRangeList != NULL) {

        for (SrcListEntry1 = SrcRangeList1->List.Flink;
             SrcListEntry1 != &SrcRangeList1->List;
             SrcListEntry1 = SrcListEntry1->Flink) {

            SrcRangeListEntry1 = CONTAINING_RECORD(
                                     SrcListEntry1,
                                     PM_RANGE_LIST_ENTRY,
                                     ListEntry
                                 );

            for (SrcListEntry2 = SrcRangeList2->List.Flink;
                 SrcListEntry2 != &SrcRangeList2->List;
                 SrcListEntry2 = SrcListEntry2->Flink) {

                SrcRangeListEntry2 = CONTAINING_RECORD(
                                         SrcListEntry2,
                                         PM_RANGE_LIST_ENTRY,
                                         ListEntry
                                     );

                Start = SrcRangeListEntry1->Start;

                if (Start < SrcRangeListEntry2->Start) {
                    Start = SrcRangeListEntry2->Start;
                };

                End = SrcRangeListEntry1->End;

                if (End > SrcRangeListEntry2->End) {
                    End = SrcRangeListEntry2->End;
                };

                if (Start > End) {
                    continue;
                }

                RangeListEntry = PmAllocateRangeListEntry();

                if (RangeListEntry == NULL) {
                    PmFreeRangeList(DstRangeList);
                    return NULL;
                }

                RangeListEntry->Start = Start;
                RangeListEntry->End = End;

                InsertTailList(
                    &DstRangeList->List,
                    &RangeListEntry->ListEntry
                );

            }
        }
    }

    return DstRangeList;
}

PPM_RANGE_LIST
PmCreateRangeListFromCmResourceList(
    IN PCM_RESOURCE_LIST CmResourceList
    )

/*++

Routine Description:

    This function converts a CM_RESOURCE_LIST to a PM_RANGE_LIST.  Only
    CmResourceTypeMemory descriptors are added to the PM_RANGE_LIST.

Arguments:

    CmResourceList - The CM_RESOURCE_LIST to convert.

Return Value:

    Upon success a pointer to the converted PM_RANGE_LIST is returned,
    otherwise NULL.

--*/

{
    PPM_RANGE_LIST RangeList;
    PCM_FULL_RESOURCE_DESCRIPTOR FDesc;
    ULONG FIndex;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PDesc;
    ULONG PIndex;
    ULONGLONG Start;
    ULONGLONG End;
    PPM_RANGE_LIST_ENTRY RangeListEntry;

    PAGED_CODE();

    RangeList = PmAllocateRangeList();

    if (RangeList == NULL) {
        return NULL;
    }

    FDesc = CmResourceList->List;

    //
    // Note: Any Device-Specific partial descriptor (which could be
    // variably sized) is defined to be at the end and thus this code
    // is safe.
    //

    for (FIndex = 0;
         FIndex < CmResourceList->Count;
         FIndex++) {

        PDesc = FDesc->PartialResourceList.PartialDescriptors;

        for (PIndex = 0;
             PIndex < FDesc->PartialResourceList.Count;
             PIndex++, PDesc++) {

            //
            // ISSUE Fix for ia64 (andy's change), IA32 large memory region
            //

            if (PDesc->Type == CmResourceTypeMemory) {

                Start = PDesc->u.Memory.Start.QuadPart;
                End = Start + PDesc->u.Memory.Length - 1;

                RangeListEntry = PmAllocateRangeListEntry();

                if (RangeListEntry == NULL) {
                    PmFreeRangeList(RangeList);
                    return NULL;
                }

                RangeListEntry->Start = Start;
                RangeListEntry->End = End;

                InsertTailList(
                    &RangeList->List,
                    &RangeListEntry->ListEntry
                );
            }
        }

        FDesc = (PCM_FULL_RESOURCE_DESCRIPTOR)PDesc;
    }

    return RangeList;
}

PPM_RANGE_LIST
PmCreateRangeListFromPhysicalMemoryRanges(
    VOID
    )

/*++

Routine Description:

    This function calls MmGetPhysicalRanges and converts the returned
    PHYSICAL_MEMORY_RANGE list to a PM_RANGE_LIST.

Arguments:

    None.

Return Value:

    Upon success a pointer to the converted PM_RANGE_LIST is returned,
    otherwise NULL.

--*/

{
    PPM_RANGE_LIST RangeList;
    PPHYSICAL_MEMORY_RANGE MemoryRange;
    ULONG Index;
    ULONGLONG Start;
    ULONGLONG End;
    PPM_RANGE_LIST_ENTRY RangeListEntry;

    PAGED_CODE();

    RangeList = PmAllocateRangeList();

    if (RangeList != NULL) {

        MemoryRange = MmGetPhysicalMemoryRanges();

        if (MemoryRange == NULL) {

            PmFreeRangeList(RangeList);
            RangeList = NULL;

        } else {

            for (Index = 0;
                 MemoryRange[Index].NumberOfBytes.QuadPart != 0;
                 Index++) {

                Start = MemoryRange[Index].BaseAddress.QuadPart;
                End = Start + (MemoryRange[Index].NumberOfBytes.QuadPart - 1);

                RangeListEntry = PmAllocateRangeListEntry();

                if (RangeListEntry == NULL) {
                    PmFreeRangeList(RangeList);
                    ExFreePool(MemoryRange);
                    return NULL;
                }

                RangeListEntry->Start = Start;
                RangeListEntry->End = End;

                InsertTailList(
                    &RangeList->List,
                    &RangeListEntry->ListEntry
                );

            }

            ExFreePool(MemoryRange);

        }
    }

    return RangeList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\loader.inc ===
!IF "$(ENABLE_LOADER_DEBUG)" != ""
C_DEFINES=$(C_DEFINES) -DENABLE_LOADER_DEBUG="\"$(ENABLE_LOADER_DEBUG)"\"
!else
# Only allow MSC_OPTIMIZATION to be changed if the debugger is enabled
# otherwise, no_opt razzle windows won't be able to boot (loader too big)
MSC_OPTIMIZATION=$(DEFAULT_MSC_OPT)
!ENDIF

C_DEFINES=$(C_DEFINES) -D_NTSYSTEM_

VC7_SYMBOLS=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\loader_dbg.inc ===
#
# set the flags necessary to build debug enabled boot loaders
#

#
# the ; is a temporary hack to make this compile until is made
# clear how to make the ##'s not get translated into CR's
#

!IF $(IA64)
ENABLE_LOADER_DEBUG=debugport=com1;debugbaudrate=19200
!ELSE                             
ENABLE_LOADER_DEBUG=debugport=com1;debugbaudrate=115200
!ENDIF

#
#
#

!include $(PROJECT_ROOT)\boot\loader.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\data.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This module contains global data for the boot debugger.

Author:

    David N. Cutler (davec) 27-Nov-1996

Revision History:

--*/

#include "bd.h"

//
// Define boot debugger data.
//
// Breakpoint instruction.
//

BD_BREAKPOINT_TYPE BdBreakpointInstruction;

//
// Break point table.
//

BREAKPOINT_ENTRY BdBreakpointTable[BREAKPOINT_TABLE_SIZE] = {0};

//
// Control C pressed and control C pending.
//

LOGICAL BdControlCPending = FALSE;
LOGICAL BdControlCPressed = FALSE;

//
// Debugger enabled and present.
//

LOGICAL BdDebuggerEnabled = FALSE;
LOGICAL BdDebuggerNotPresent = FALSE;

//
// Debug routine address.
//

PBD_DEBUG_ROUTINE BdDebugRoutine;

//
// Message buffer.
//
// N.B. The message buffer size is guaranteed to be 0 mod 8.
//

ULONGLONG BdMessageBuffer[BD_MESSAGE_BUFFER_SIZE / 8];

//
// Next packet id to send and next packet id to expect.
//

ULONG BdPacketIdExpected;
ULONG BdNextPacketIdToSend;

//
// Processor control block used to saved processor state.
//

KPRCB BdPrcb;

//
// Number of retries and the retry count.
//

ULONG BdNumberRetries = 5;
ULONG BdRetryCount = 5;

//
// NT build number.
//

#if DBG

ULONG NtBuildNumber = VER_PRODUCTBUILD | 0xc0000000;

#else

ULONG NtBuildNumber = VER_PRODUCTBUILD | 0xf0000000;

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\comio.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    comio.c

Abstract:

    This module implements the I/O comunications for the portable kernel
    debugger.

Author:

    David N. Cutler 27-July-1990

Revision History:

--*/

#include "bd.h"

ULONG
BdComputeChecksum (
    IN PUCHAR Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine computes the checksum of the specified buffer.

Arguments:

    Buffer - Supplies a pointer to the buffer.

    Length - Supplies the length of the buffer.

Return Value:

    A ULONG is return as the checksum for the input string.

--*/

{

    ULONG Checksum = 0;

    while (Length > 0) {
        Checksum = Checksum + (ULONG)*Buffer++;
        Length--;
    }

    return Checksum;
}

USHORT
BdReceivePacketLeader (
    IN ULONG PacketType,
    OUT PULONG PacketLeader
    )

/*++

Routine Description:

    This routine waits for a packet header leader.

Arguments:

    PacketType - supplies the type of packet we are expecting.

    PacketLeader - supplies a pointer to a ulong variable to receive
                   packet leader bytes.

Return Value:

    BD_PACKET_RESEND - if resend is required.
    BD_PAKCET_TIMEOUT - if timeout.
    BD_PACKET_RECEIVED - if packet received.

--*/

{

    UCHAR Input, PreviousByte = 0;
    ULONG PacketId = 0;
    ULONG Index;
    ULONG ReturnCode;
    BOOLEAN BreakinDetected = FALSE;

    //
    // NOTE - With all the interrupts being off, it is very hard
    // to implement the actual timeout code. (Maybe, by reading the CMOS.)
    // Here we use a loop count to wait about 3 seconds.  The CpGetByte
    // will return with error code = CP_GET_NODATA if it cannot find data
    // byte within 1 second. Kernel debugger's timeout period is 5 seconds.
    //

    Index = 0;
    do {
        ReturnCode = BlPortGetByte(BdFileId, &Input);
        if (ReturnCode == CP_GET_NODATA) {
            if (BreakinDetected) {
                BdControlCPending = TRUE;
                return BD_PACKET_RESEND;

            } else {
                return BD_PACKET_TIMEOUT;
            }

        } else if (ReturnCode == CP_GET_ERROR) {
            Index = 0;
            continue;

        } else {                    // if (ReturnCode == CP_GET_SUCCESS)
            if ( Input == PACKET_LEADER_BYTE ||
                 Input == CONTROL_PACKET_LEADER_BYTE ) {
                if ( Index == 0 ) {
                    PreviousByte = Input;
                    Index++;
                } else if (Input == PreviousByte ) {
                    Index++;
                } else {
                    PreviousByte = Input;
                    Index = 1;
                }
            } else {

                //
                // If we detect breakin character, we need to verify it
                // validity.  (It is possible that we missed a packet leader
                // and the breakin character is simply a data byte in the
                // packet.)
                // Since kernel debugger send out breakin character ONLY
                // when it is waiting for State Change packet.  The breakin
                // character should not be followed by any other character
                // except packet leader byte.
                //

                if ( Input == BREAKIN_PACKET_BYTE ) {
                    BreakinDetected = TRUE;
                } else {

                    //
                    // The following statement is ABSOLUTELY necessary.
                    //

                    BreakinDetected = FALSE;
                }
                Index = 0;
            }
        }
    } while ( Index < 4 );

    if (BreakinDetected) {
        BdControlCPending = TRUE;
    }

    //
    // return the packet leader and FALSE to indicate no resend is needed.
    //

    if ( Input == PACKET_LEADER_BYTE ) {
        *PacketLeader = PACKET_LEADER;

    } else {
        *PacketLeader = CONTROL_PACKET_LEADER;
    }

    BdDebuggerNotPresent = FALSE;
    return BD_PACKET_RECEIVED;
}

VOID
BdSendControlPacket (
    IN USHORT PacketType,
    IN ULONG PacketId OPTIONAL
    )

/*++

Routine Description:

    This routine sends a control packet to the host machine that is running the
    kernel debugger and waits for an ACK.

Arguments:

    PacketType - Supplies the type of packet to send.

    PacketId - Supplies packet id, optionally.

Return Value:

    None.

--*/

{

    KD_PACKET PacketHeader;

    //
    // Initialize and send the packet header.
    //

    PacketHeader.PacketLeader = CONTROL_PACKET_LEADER;
    if (ARGUMENT_PRESENT( (PVOID)(ULONG_PTR) PacketId )) {
        PacketHeader.PacketId = PacketId;
    }

    PacketHeader.ByteCount = 0;
    PacketHeader.Checksum = 0;
    PacketHeader.PacketType = PacketType;
    BdSendString((PCHAR)&PacketHeader, sizeof(KD_PACKET));
    return;
}

ULONG
BdReceivePacket (
    IN ULONG PacketType,
    OUT PSTRING MessageHeader,
    OUT PSTRING MessageData,
    OUT PULONG DataLength
    )

/*++

Routine Description:

    This routine receives a packet from the host machine that is running
    the kernel debugger UI.  This routine is ALWAYS called after packet being
    sent by caller.  It first waits for ACK packet for the packet sent and
    then waits for the packet desired.

    N.B. If caller is BdrintString, the parameter PacketType is
       PACKET_TYPE_KD_ACKNOWLEDGE.  In this case, this routine will return
       right after the ack packet is received.

Arguments:

    PacketType - Supplies the type of packet that is excepted.

    MessageHeader - Supplies a pointer to a string descriptor for the input
        message.

    MessageData - Supplies a pointer to a string descriptor for the input data.

    DataLength - Supplies pointer to ULONG to receive length of recv. data.

Return Value:

    BD_PACKET_RESEND - if resend is required.
    BD_PAKCET_TIMEOUT - if timeout.
    BD_PACKET_RECEIVED - if packet received.

--*/

{

    UCHAR Input;
    ULONG MessageLength;
    KD_PACKET PacketHeader;
    ULONG ReturnCode;
    ULONG Checksum;

WaitForPacketLeader:

    //
    // Read Packet Leader
    //

    ReturnCode = BdReceivePacketLeader(PacketType, &PacketHeader.PacketLeader);

    //
    // If we can successfully read packet leader, it has high possibility that
    // kernel debugger is alive.  So reset count.
    //

    if (ReturnCode != BD_PACKET_TIMEOUT) {
        BdNumberRetries = BdRetryCount;
    }
    if (ReturnCode != BD_PACKET_RECEIVED) {
        return ReturnCode;
    }

    //
    // Read packet type.
    //

    ReturnCode = BdReceiveString((PCHAR)&PacketHeader.PacketType,
                                 sizeof(PacketHeader.PacketType));

    if (ReturnCode == CP_GET_NODATA) {
        return BD_PACKET_TIMEOUT;

    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {

            //
            // If read error and it is for a control packet, simply
            // preptend that we have not seen this packet.  Hopefully
            // we will receive the packet we desire which automatically acks
            // the packet we just sent.
            //

            goto WaitForPacketLeader;

        } else {

            //
            // if read error while reading data packet, we have to ask
            // kernel debugger to resend us the packet.
            //

            goto SendResendPacket;
        }
    }

    //
    // if the packet we received is a resend request, we return true and
    // let caller resend the packet.
    //

    if ( PacketHeader.PacketLeader == CONTROL_PACKET_LEADER &&
         PacketHeader.PacketType == PACKET_TYPE_KD_RESEND ) {
        return BD_PACKET_RESEND;
    }

    //
    // Read data length.
    //

    ReturnCode = BdReceiveString((PCHAR)&PacketHeader.ByteCount,
                                 sizeof(PacketHeader.ByteCount));

    if (ReturnCode == CP_GET_NODATA) {
        return BD_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // Read Packet Id.
    //

    ReturnCode = BdReceiveString((PCHAR)&PacketHeader.PacketId,
                                 sizeof(PacketHeader.PacketId));

    if (ReturnCode == CP_GET_NODATA) {
        return BD_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // Read packet checksum.
    //

    ReturnCode = BdReceiveString((PCHAR)&PacketHeader.Checksum,
                                 sizeof(PacketHeader.Checksum));

    if (ReturnCode == CP_GET_NODATA) {
        return BD_PACKET_TIMEOUT;

    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // A complete packet header is received.  Check its validity and
    // perform appropriate action depending on packet type.
    //

    if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER ) {
        if (PacketHeader.PacketType == PACKET_TYPE_KD_ACKNOWLEDGE ) {

            //
            // If we received an expected ACK packet and we are not
            // waiting for any new packet, update outgoing packet id
            // and return.  If we are NOT waiting for ACK packet
            // we will keep on waiting.  If the ACK packet
            // is not for the packet we send, ignore it and keep on waiting.
            //

            if (PacketHeader.PacketId !=
                (BdNextPacketIdToSend & ~SYNC_PACKET_ID))  {
                goto WaitForPacketLeader;

            } else if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE) {
                BdNextPacketIdToSend ^= 1;
                return BD_PACKET_RECEIVED;

            } else {
                goto WaitForPacketLeader;
            }

        } else if (PacketHeader.PacketType == PACKET_TYPE_KD_RESET) {

            //
            // if we received Reset packet, reset the packet control variables
            // and resend earlier packet.
            //

            BdNextPacketIdToSend = INITIAL_PACKET_ID;
            BdPacketIdExpected = INITIAL_PACKET_ID;
            BdSendControlPacket(PACKET_TYPE_KD_RESET, 0L);
            return BD_PACKET_RESEND;

        } else if (PacketHeader.PacketType == PACKET_TYPE_KD_RESEND) {
            return BD_PACKET_RESEND;

        } else {

            //
            // Invalid packet header, ignore it.
            //

            goto WaitForPacketLeader;
        }

    //
    // The packet header is for data packet (not control packet).
    //

    } else if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE) {

        //
        // if we are waiting for ACK packet ONLY
        // and we receive a data packet header, check if the packet id
        // is what we expected.  If yes, assume the acknowledge is lost (but
        // sent), ask sender to resend and return with PACKET_RECEIVED.
        //

        if (PacketHeader.PacketId == BdPacketIdExpected) {
            BdSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            BdNextPacketIdToSend ^= 1;
            return BD_PACKET_RECEIVED;

        } else {
            BdSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                                PacketHeader.PacketId);

            goto WaitForPacketLeader;
        }
    }

    //
    // we are waiting for data packet and we received the packet header
    // for data packet. Perform the following checkings to make sure
    // it is the packet we are waiting for.
    //
    // Check ByteCount received is valid
    //

    MessageLength = MessageHeader->MaximumLength;
    if ((PacketHeader.ByteCount > (USHORT)PACKET_MAX_SIZE) ||
        (PacketHeader.ByteCount < (USHORT)MessageLength)) {
        goto SendResendPacket;
    }

    *DataLength = PacketHeader.ByteCount - MessageLength;

    //
    // Read the message header.
    //

    ReturnCode = BdReceiveString(MessageHeader->Buffer, MessageLength);
    if (ReturnCode != CP_GET_SUCCESS) {
        goto SendResendPacket;
    }

    MessageHeader->Length = (USHORT)MessageLength;

    //
    // Read the message data.
    //

    ReturnCode = BdReceiveString(MessageData->Buffer, *DataLength);
    if (ReturnCode != CP_GET_SUCCESS) {
        goto SendResendPacket;
    }

    MessageData->Length = (USHORT)*DataLength;

    //
    // Read packet trailing byte
    //

    ReturnCode = BlPortGetByte(BdFileId, &Input);
    if (ReturnCode != CP_GET_SUCCESS || Input != PACKET_TRAILING_BYTE) {
        goto SendResendPacket;
    }

    //
    // Check PacketType is what we are waiting for.
    //

    if (PacketType != PacketHeader.PacketType) {
        BdSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                             PacketHeader.PacketId
                             );
        goto WaitForPacketLeader;
    }

    //
    // Check PacketId is valid.
    //

    if (PacketHeader.PacketId == INITIAL_PACKET_ID ||
        PacketHeader.PacketId == (INITIAL_PACKET_ID ^ 1)) {
        if (PacketHeader.PacketId != BdPacketIdExpected) {
            BdSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                                 PacketHeader.PacketId
                                 );
            goto WaitForPacketLeader;
        }

    } else {
        goto SendResendPacket;
    }

    //
    // Check checksum is valid.
    //

    Checksum = BdComputeChecksum(MessageHeader->Buffer,
                                 MessageHeader->Length);


    Checksum += BdComputeChecksum(MessageData->Buffer,
                                  MessageData->Length);

    if (Checksum != PacketHeader.Checksum) {
        goto SendResendPacket;
    }

    //
    // Send Acknowledge byte and the Id of the packet received.
    // Then, update the ExpectId for next incoming packet.
    //

    BdSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                        PacketHeader.PacketId);

    //
    // We have successfully received the packet so update the
    // packet control variables and return sucess.
    //

    BdPacketIdExpected ^= 1;
    return BD_PACKET_RECEIVED;

SendResendPacket:
    BdSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);
    goto WaitForPacketLeader;
}

VOID
BdSendPacket (
    IN ULONG PacketType,
    IN PSTRING MessageHeader,
    IN PSTRING MessageData OPTIONAL
    )

/*++

Routine Description:

    This routine sends a packet to the host machine that is running the
    kernel debugger and waits for an ACK.

Arguments:

    PacketType - Supplies the type of packet to send.

    MessageHeader - Supplies a pointer to a string descriptor that describes
        the message information.

    MessageData - Supplies a pointer to a string descriptor that describes
        the optional message data.

Return Value:

    None.

--*/

{

    KD_PACKET PacketHeader;
    ULONG MessageDataLength;
    ULONG ReturnCode;
    PDBGKD_DEBUG_IO DebugIo;
    PDBGKD_WAIT_STATE_CHANGE64 StateChange;

    if (ARGUMENT_PRESENT(MessageData)) {
        MessageDataLength = MessageData->Length;
        PacketHeader.Checksum = BdComputeChecksum(MessageData->Buffer,
                                                  MessageData->Length);

    } else {
        MessageDataLength = 0;
        PacketHeader.Checksum = 0;
    }

    PacketHeader.Checksum += BdComputeChecksum(MessageHeader->Buffer,
                                               MessageHeader->Length);

    //
    // Initialize and send the packet header.
    //

    PacketHeader.PacketLeader = PACKET_LEADER;
    PacketHeader.ByteCount = (USHORT)(MessageHeader->Length + MessageDataLength);
    PacketHeader.PacketType = (USHORT)PacketType;
    BdNumberRetries = BdRetryCount;
    do {
        if (BdNumberRetries == 0) {

            //
            // If the packet is not for reporting exception, we give up
            // and declare debugger not present.
            //

            if (PacketType == PACKET_TYPE_KD_DEBUG_IO) {
                DebugIo = (PDBGKD_DEBUG_IO)MessageHeader->Buffer;
                if (DebugIo->ApiNumber == DbgKdPrintStringApi) {
                    BdDebuggerNotPresent = TRUE;
                    BdNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                    BdPacketIdExpected = INITIAL_PACKET_ID;
                    return;
                }

            } else if (PacketType == PACKET_TYPE_KD_STATE_CHANGE64) {
                StateChange = (PDBGKD_WAIT_STATE_CHANGE64)MessageHeader->Buffer;
                if (StateChange->NewState == DbgKdLoadSymbolsStateChange) {
                    BdDebuggerNotPresent = TRUE;
                    BdNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                    BdPacketIdExpected = INITIAL_PACKET_ID;
                    return;
                }
            } else if (PacketType == PACKET_TYPE_KD_FILE_IO) {
                PDBGKD_FILE_IO FileIo;
                
                FileIo = (PDBGKD_FILE_IO)MessageHeader->Buffer;
                if (FileIo->ApiNumber == DbgKdCreateFileApi) {
                    BdDebuggerNotPresent = TRUE;
                    BdNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                    BdPacketIdExpected = INITIAL_PACKET_ID;
                    return;
                }
            }
        }

        //
        // Setting PacketId has to be in the do loop in case Packet Id was
        // reset.
        //

        PacketHeader.PacketId = BdNextPacketIdToSend;
        BdSendString((PCHAR)&PacketHeader, sizeof(KD_PACKET));

        //
        // Output message header.
        //

        BdSendString(MessageHeader->Buffer, MessageHeader->Length);

        //
        // Output message data.
        //

        if ( MessageDataLength ) {
            BdSendString(MessageData->Buffer, MessageData->Length);
        }

        //
        // Output a packet trailing byte
        //

        BlPortPutByte(BdFileId, PACKET_TRAILING_BYTE);

        //
        // Wait for the Ack Packet
        //

        ReturnCode = BdReceivePacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                                     NULL,
                                     NULL,
                                     NULL);

        if (ReturnCode == BD_PACKET_TIMEOUT) {
            BdNumberRetries--;
        }

    } while (ReturnCode != BD_PACKET_RECEIVED);

    //
    // Reset Sync bit in packet id.  The packet we sent may have Sync bit set
    //

    BdNextPacketIdToSend &= ~SYNC_PACKET_ID;

    //
    // Since we are able to talk to debugger, the retrycount is set to
    // maximum value.
    //

    BdRetryCount = MAXIMUM_RETRIES;
}

ULONG
BdReceiveString (
    OUT PCHAR Destination,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine reads a string from the kernel debugger port.

Arguments:

    Destination - Supplies a pointer to the input string.

    Length - Supplies the length of the string to be read.

Return Value:

    CP_GET_SUCCESS is returned if string is successfully read from the
        kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{

    UCHAR Input;
    ULONG ReturnCode;

    //
    // Read bytes until either a error is encountered or the entire string
    // has been read.
    //
    while (Length > 0) {
        ReturnCode = BlPortGetByte(BdFileId, &Input);
        if (ReturnCode != CP_GET_SUCCESS) {
            return ReturnCode;
        } else {
            *Destination++ = Input;
            Length -= 1;
        }
    }

    return CP_GET_SUCCESS;
}

VOID
BdSendString (
    IN PCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine writes a string to the kernel debugger port.

Arguments:

    Source - Supplies a pointer to the output string.

    Length - Supplies the length of the string to be written.

Return Value:

    None.

--*/

{

    UCHAR Output;

    //
    // Write bytes to the kernel debugger port.
    //

    while (Length > 0) {
        Output = *Source++;
        BlPortPutByte(BdFileId, Output);
        Length -= 1;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\break.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    break.c

Abstract:

    This module implements machine dependent functions to add and delete
    breakpoints from the kernel debugger breakpoint table.

Author:

    David N. Cutler 2-Aug-1990

Revision History:

--*/

#include "bd.h"

LOGICAL BreakpointsSuspended = FALSE;

//
// Define external references.
//

LOGICAL
BdLowWriteContent(
    ULONG Index
    );

LOGICAL
BdLowRestoreBreakpoint(
    ULONG Index
    );


ULONG
BdAddBreakpoint (
    IN ULONG64 Address
    )

/*++

Routine Description:

    This routine adds an entry to the breakpoint table and returns a handle
    to the breakpoint table entry.

Arguments:

    Address - Supplies the address where to set the breakpoint.

Return Value:

    A value of zero is returned if the specified address is already in the
    breakpoint table, there are no free entries in the breakpoint table, the
    specified address is not correctly aligned, or the specified address is
    not valid. Otherwise, the index of the assigned breakpoint table entry
    plus one is returned as the function value.

--*/

{

    BD_BREAKPOINT_TYPE Content;
    ULONG Index;
    BOOLEAN Accessible;
#if defined(_IA64_)
    HARDWARE_PTE Opaque;
#endif

    //DPRINT(("KD: Setting breakpoint at 0x%08x\n", Address));
    //
    // If the specified address is not properly aligned, then return zero.
    //

    if (((ULONG_PTR)Address & BD_BREAKPOINT_ALIGN) != 0) {
        return 0;
    }

    //
    // Get the instruction to be replaced. If the instruction cannot be read,
    // then mark the breakpoint as not accessible.
    //

    if (BdMoveMemory((PCHAR)&Content,
                      (PCHAR)Address,
                      sizeof(BD_BREAKPOINT_TYPE) ) != sizeof(BD_BREAKPOINT_TYPE)) {
        Accessible = FALSE;
        //DPRINT(("KD: memory inaccessible\n"));

    } else {
        //DPRINT(("KD: memory readable...\n"));
        Accessible = TRUE;
    }

    //
    // If the specified address is not write accessible, then return zero.
    //

    if (Accessible && BdWriteCheck((PVOID)Address) == NULL) {
        //DPRINT(("KD: memory not writable!\n"));
        return 0;
    }

    //
    // Search the breakpoint table for a free entry and check if the specified
    // address is already in the breakpoint table.
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
        if (BdBreakpointTable[Index].Flags == 0) {
            break;
        }
    }

    //
    // If a free entry was found, then write breakpoint and return the handle
    // value plus one. Otherwise, return zero.
    //

    if (Index == BREAKPOINT_TABLE_SIZE) {
        //DPRINT(("KD: ran out of breakpoints!\n"));
        return 0;
    }

    //DPRINT(("KD: using Index %d\n", Index));

#if defined(_IA64_)
    if (Accessible) {
        BD_BREAKPOINT_TYPE mBuf;
        PVOID BundleAddress;

        // change template to type 0 if current instruction is MLI

        // read in intruction template if current instruction is NOT slot 0.
        // check for two-slot MOVL instruction. Reject request if attempt to
        // set break in slot 2 of MLI template.

        if (((ULONG_PTR)Address & 0xf) != 0) {
            (ULONG_PTR)BundleAddress = (ULONG_PTR)Address & ~(0xf);
            if (BdMoveMemory(
                    (PCHAR)&mBuf,
                    (PCHAR)BundleAddress,
                    sizeof(BD_BREAKPOINT_TYPE)
                    ) != sizeof(BD_BREAKPOINT_TYPE)) {
                //DPRINT(("KD: read 0x%08x template failed\n", BundleAddress));
                // MmDbgReleaseAddress((PVOID) Address, &Opaque);
                return 0;
            } else {
                if (((mBuf & INST_TEMPL_MASK) >> 1) == 0x2) {
                    if (((ULONG_PTR)Address & 0xf) == 4) {
                        // if template= type 2 MLI, change to type 0
                        mBuf &= ~((INST_TEMPL_MASK >> 1) << 1);
                        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_IA64_MOVL;
                        if (BdMoveMemory(
                                (PCHAR)BundleAddress,
                                (PCHAR)&mBuf,
                                sizeof(BD_BREAKPOINT_TYPE)
                                ) != sizeof(BD_BREAKPOINT_TYPE)) {
                            //DPRINT(("KD: write to 0x%08x template failed\n", BundleAddress));
                            // MmDbgReleaseAddress((PVOID) Address, &Opaque);
                            return 0;
                         }
                         else {
                             //DPRINT(("KD: change MLI template to type 0 at 0x%08x set\n", Address));
                         }
                    } else {
                         // set breakpoint at slot 2 of MOVL is illegal
                         //DPRINT(("KD: illegal to set BP at slot 2 of MOVL at 0x%08x\n", BundleAddress));
                         // MmDbgReleaseAddress((PVOID) Address, &Opaque);
                         return 0;
                    }
                }
            }
        }

        // insert break instruction

        BdBreakpointTable[Index].Address = Address;
        BdBreakpointTable[Index].Content = Content;
        BdBreakpointTable[Index].Flags &= ~(BD_BREAKPOINT_STATE_MASK);
        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_IN_USE;
#if 0
        if (Address < (PVOID)GLOBAL_BREAKPOINT_LIMIT) {
            BdBreakpointTable[Index].DirectoryTableBase =
                KeGetCurrentThread()->ApcState.Process->DirectoryTableBase[0];
            }
#endif
            switch ((ULONG_PTR)Address & 0xf) {
            case 0:
                Content = (Content & ~(INST_SLOT0_MASK)) | (BdBreakpointInstruction << 5);
                break;

            case 4:
                Content = (Content & ~(INST_SLOT1_MASK)) | (BdBreakpointInstruction << 14);
                break;

            case 8:
                Content = (Content & ~(INST_SLOT2_MASK)) | (BdBreakpointInstruction << 23);
                break;

            default:
                // MmDbgReleaseAddress((PVOID) Address, &Opaque);
                //DPRINT(("KD: BdAddBreakpoint bad instruction slot#\n"));
                return 0;
            }
            if (BdMoveMemory(
                    (PCHAR)Address,
                    (PCHAR)&Content,
                    sizeof(BD_BREAKPOINT_TYPE)
                    ) != sizeof(BD_BREAKPOINT_TYPE)) {

                // MmDbgReleaseAddress((PVOID) Address, &Opaque);
                //DPRINT(("KD: BdMoveMemory failed writing BP!\n"));
                return 0;
            }
            else {
                //DPRINT(("KD: breakpoint at 0x%08x set\n", Address));
            }
        // MmDbgReleaseAddress((PVOID) Address, &Opaque);

    } else {  // memory not accessible
        BdBreakpointTable[Index].Address = Address;
        BdBreakpointTable[Index].Flags &= ~(BD_BREAKPOINT_STATE_MASK);
        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_IN_USE;
        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_WRITE;
        //DPRINT(("KD: breakpoint write deferred\n"));
    }
#else    // _IA64_
    if (Accessible) {
        BdBreakpointTable[Index].Address = Address;
        BdBreakpointTable[Index].Content = Content;
        BdBreakpointTable[Index].Flags = BD_BREAKPOINT_IN_USE;
        if (BdMoveMemory((PCHAR)Address,
                          (PCHAR)&BdBreakpointInstruction,
                          sizeof(BD_BREAKPOINT_TYPE)) != sizeof(BD_BREAKPOINT_TYPE)) {

            //DPRINT(("KD: BdMoveMemory failed writing BP!\n"));
        }

    } else {
        BdBreakpointTable[Index].Address = Address;
        BdBreakpointTable[Index].Flags = BD_BREAKPOINT_IN_USE | BD_BREAKPOINT_NEEDS_WRITE;
        //DPRINT(("KD: breakpoint write deferred\n"));
    }
#endif // _IA64_

    return Index + 1;
}

LOGICAL
BdLowWriteContent (
    IN ULONG Index
    )

/*++

Routine Description:

    This routine attempts to replace the code that a breakpoint is
    written over.  This routine, BdAddBreakpoint,
    BdLowRestoreBreakpoint and KdSetOwedBreakpoints are responsible
    for getting data written as requested.  Callers should not
    examine or use BdOweBreakpoints, and they should not set the
    NEEDS_WRITE or NEEDS_REPLACE flags.

    Callers must still look at the return value from this function,
    however: if it returns FALSE, the breakpoint record must not be
    reused until KdSetOwedBreakpoints has finished with it.

Arguments:

    Index - Supplies the index of the breakpoint table entry
        which is to be deleted.

Return Value:

    Returns TRUE if the breakpoint was removed, FALSE if it was deferred.

--*/

{
#if defined(_IA64_)
    BD_BREAKPOINT_TYPE mBuf;
    PVOID BundleAddress;
#endif

    //
    // Do the contents need to be replaced at all?
    //

    if (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_NEEDS_WRITE) {

        //
        // The breakpoint was never written out.  Clear the flag
        // and we are done.
        //

        BdBreakpointTable[Index].Flags &= ~BD_BREAKPOINT_NEEDS_WRITE;
        //DPRINT(("KD: Breakpoint at 0x%08x never written; flag cleared.\n",
        //    BdBreakpointTable[Index].Address));
        return TRUE;
    }

#if !defined(_IA64_)
    if (BdBreakpointTable[Index].Content == BdBreakpointInstruction) {

        //
        // The instruction is a breakpoint anyway.
        //

        //DPRINT(("KD: Breakpoint at 0x%08x; instr is really BP; flag cleared.\n",
        //    BdBreakpointTable[Index].Address));

        return TRUE;
    }
#endif

    //
    // Restore the instruction contents.
    //

#if defined(_IA64_)
    // Read in memory since adjancent instructions in the same bundle may have
    // been modified after we save them.
    if (BdMoveMemory(
            (PCHAR)&mBuf,
            (PCHAR)BdBreakpointTable[Index].Address,
            sizeof(BD_BREAKPOINT_TYPE)) != sizeof(BD_BREAKPOINT_TYPE)) {
        //DPRINT(("KD: read 0x%08x failed\n", BdBreakpointTable[Index].Address));
        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_REPLACE;
        return FALSE;
    }
    else {

        switch ((ULONG_PTR)BdBreakpointTable[Index].Address & 0xf) {
        case 0:
            mBuf = (mBuf & ~(INST_SLOT0_MASK))
                         | (BdBreakpointTable[Index].Content & INST_SLOT0_MASK);
            break;

        case 4:
            mBuf = (mBuf & ~(INST_SLOT1_MASK))
                         | (BdBreakpointTable[Index].Content & INST_SLOT1_MASK);
            break;

        case 8:
            mBuf = (mBuf & ~(INST_SLOT2_MASK))
                         | (BdBreakpointTable[Index].Content & INST_SLOT2_MASK);
            break;

        default:
            //DPRINT(("KD: illegal instruction address 0x%08x\n", BdBreakpointTable[Index].Address));
            return FALSE;
        }

        if (BdMoveMemory(
                (PCHAR)BdBreakpointTable[Index].Address,
                (PCHAR)&mBuf,
                sizeof(BD_BREAKPOINT_TYPE)) != sizeof(BD_BREAKPOINT_TYPE)) {
            //DPRINT(("KD: write to 0x%08x failed\n", BdBreakpointTable[Index].Address));
            BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_REPLACE;
            return FALSE;
        }
        else {

            if (BdMoveMemory(
                    (PCHAR)&mBuf,
                    (PCHAR)BdBreakpointTable[Index].Address,
                    sizeof(BD_BREAKPOINT_TYPE)) == sizeof(BD_BREAKPOINT_TYPE)) {
                //DPRINT(("\tcontent after memory move = 0x%08x 0x%08x\n", (ULONG)(mBuf >> 32), (ULONG)mBuf));
            }

            // restore template to MLI if displaced instruction was MOVL

            if (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_IA64_MOVL) {
                (ULONG_PTR)BundleAddress = (ULONG_PTR)BdBreakpointTable[Index].Address & ~(0xf);
                if (BdMoveMemory(
                        (PCHAR)&mBuf,
                        (PCHAR)BundleAddress,
                        sizeof(BD_BREAKPOINT_TYPE)
                        ) != sizeof(BD_BREAKPOINT_TYPE)) {
                    //DPRINT(("KD: read template 0x%08x failed\n", BdBreakpointTable[Index].Address));
                    BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_REPLACE;
                    return FALSE;
                }
                else {
                    mBuf &= ~((INST_TEMPL_MASK >> 1) << 1); // set template to MLI
                    mBuf |= 0x4;

                    if (BdMoveMemory(
                          (PCHAR)BundleAddress,
                          (PCHAR)&mBuf,
                          sizeof(BD_BREAKPOINT_TYPE)
                          ) != sizeof(BD_BREAKPOINT_TYPE)) {
                        //DPRINT(("KD: write template to 0x%08x failed\n", BdBreakpointTable[Index].Address));
                        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_REPLACE;
                        return FALSE;
                    } else {
                        //DPRINT(("KD: Breakpoint at 0x%08x cleared.\n",
                         //   BdBreakpointTable[Index].Address));
                        return TRUE;
                    }
                }
            }
            else {   // not MOVL
                //DPRINT(("KD: Breakpoint at 0x%08x cleared.\n",
                 //  BdBreakpointTable[Index].Address));
                return TRUE;
            }
        }
    }
#else    // _IA64_
    if (BdMoveMemory( (PCHAR)BdBreakpointTable[Index].Address,
                        (PCHAR)&BdBreakpointTable[Index].Content,
                        sizeof(BD_BREAKPOINT_TYPE) ) != sizeof(BD_BREAKPOINT_TYPE)) {

        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_REPLACE;
        //DPRINT(("KD: Breakpoint at 0x%08x; unable to clear, flag set.\n",
            //BdBreakpointTable[Index].Address));
        return FALSE;
    } else {
        //DPRINT(("KD: Breakpoint at 0x%08x cleared.\n",
            //BdBreakpointTable[Index].Address));
        return TRUE;
    }
#endif // _IA64_

}

LOGICAL
BdDeleteBreakpoint (
    IN ULONG Handle
    )

/*++

Routine Description:

    This routine deletes an entry from the breakpoint table.

Arguments:

    Handle - Supplies the index plus one of the breakpoint table entry
        which is to be deleted.

Return Value:

    A value of FALSE is returned if the specified handle is not a valid
    value or the breakpoint cannot be deleted because the old instruction
    cannot be replaced. Otherwise, a value of TRUE is returned.

--*/

{
    ULONG Index = Handle - 1;

    //
    // If the specified handle is not valid, then return FALSE.
    //

    if ((Handle == 0) || (Handle > BREAKPOINT_TABLE_SIZE)) {
        //DPRINT(("KD: Breakpoint %d invalid.\n", Index));
        return FALSE;
    }

    //
    // If the specified breakpoint table entry is not valid, then return FALSE.
    //

    if (BdBreakpointTable[Index].Flags == 0) {
        //DPRINT(("KD: Breakpoint %d already clear.\n", Index));
        return FALSE;
    }

    //
    // If the breakpoint is already suspended, just delete it from the table.
    //

    if (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_SUSPENDED) {
        //DPRINT(("KD: Deleting suspended breakpoint %d \n", Index));
        if ( !(BdBreakpointTable[Index].Flags & BD_BREAKPOINT_NEEDS_REPLACE) ) {
            //DPRINT(("KD: already clear.\n"));
            BdBreakpointTable[Index].Flags = 0;
            return TRUE;
        }
    }

    //
    // Replace the instruction contents.
    //

    if (BdLowWriteContent(Index)) {

        //
        // Delete breakpoint table entry
        //

        //DPRINT(("KD: Breakpoint %d deleted successfully.\n", Index));
        BdBreakpointTable[Index].Flags = 0;
    }

    return TRUE;
}

LOGICAL
BdDeleteBreakpointRange (
    IN ULONG64 Lower,
    IN ULONG64 Upper
    )

/*++

Routine Description:

    This routine deletes all breakpoints falling in a given range
    from the breakpoint table.

Arguments:

    Lower - inclusive lower address of range from which to remove BPs.

    Upper - include upper address of range from which to remove BPs.

Return Value:

    TRUE if any breakpoints removed, FALSE otherwise.

--*/

{
    ULONG   Index;
    BOOLEAN ReturnStatus = FALSE;

    //
    // Examine each entry in the table in turn
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index++) {

        if ( (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_IN_USE) &&
             ((BdBreakpointTable[Index].Address >= Lower) &&
              (BdBreakpointTable[Index].Address <= Upper))
           ) {

            //
            // Breakpoint is in use and falls in range, clear it.
            //

            ReturnStatus = ReturnStatus || BdDeleteBreakpoint(Index+1);
        }
    }

    return ReturnStatus;
}

VOID
BdSuspendBreakpoint (
    ULONG Handle
    )
{
    ULONG Index = Handle - 1;

    if ( (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_IN_USE) &&
        !(BdBreakpointTable[Index].Flags & BD_BREAKPOINT_SUSPENDED) ) {

        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_SUSPENDED;
        BdLowWriteContent(Index);
    }

    return;

}

VOID
BdSuspendAllBreakpoints (
    VOID
    )

{
    ULONG Handle;

    BreakpointsSuspended = TRUE;

    for ( Handle = 1; Handle <= BREAKPOINT_TABLE_SIZE; Handle++ ) {
        BdSuspendBreakpoint(Handle);
    }

    return;

}

LOGICAL
BdLowRestoreBreakpoint (
    IN ULONG Index
    )

/*++

Routine Description:

    This routine attempts to write a breakpoint instruction.
    The old contents must have already been stored in the
    breakpoint record.

Arguments:

    Index - Supplies the index of the breakpoint table entry
        which is to be written.

Return Value:

    Returns TRUE if the breakpoint was written, FALSE if it was
    not and has been marked for writing later.

--*/

{
    BD_BREAKPOINT_TYPE Content;

#if defined(_IA64_)
    BD_BREAKPOINT_TYPE mBuf;
    PVOID BundleAddress;
#endif

    //
    // Does the breakpoint need to be written at all?
    //

    if (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_NEEDS_REPLACE) {

        //
        // The breakpoint was never removed.  Clear the flag
        // and we are done.
        //

        BdBreakpointTable[Index].Flags &= ~BD_BREAKPOINT_NEEDS_REPLACE;
        return TRUE;

    }

#if !defined(_IA64_)
    if (BdBreakpointTable[Index].Content == BdBreakpointInstruction) {

        //
        // The instruction is a breakpoint anyway.
        //

        return TRUE;
    }
#endif

    //
    // Replace the instruction contents.
    //

#if defined(_IA64_)

    // read in intruction in case the adjacent instruction has been modified.

    if (BdMoveMemory(
            (PCHAR)&mBuf,
            (PCHAR)BdBreakpointTable[Index].Address,
            sizeof(BD_BREAKPOINT_TYPE)
            ) != sizeof(BD_BREAKPOINT_TYPE)) {
        //DPRINT(("KD: read 0x%p template failed\n", BdBreakpointTable[Index].Address));
        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_WRITE;
        return FALSE;
    }

    switch ((ULONG_PTR)BdBreakpointTable[Index].Address & 0xf) {
        case 0:
            mBuf = (mBuf & ~(INST_SLOT0_MASK)) | (BdBreakpointInstruction << 5);
            break;

        case 4:
            mBuf = (mBuf & ~(INST_SLOT1_MASK)) | (BdBreakpointInstruction << 14);
            break;

        case 8:
            mBuf = (mBuf & ~(INST_SLOT2_MASK)) | (BdBreakpointInstruction << 23);
            break;

        default:
            //DPRINT(("KD: BdAddBreakpoint bad instruction slot#\n"));
            return FALSE;
    }
    if (BdMoveMemory(
            (PCHAR)BdBreakpointTable[Index].Address,
            (PCHAR)&mBuf,
            sizeof(BD_BREAKPOINT_TYPE)
            ) != sizeof(BD_BREAKPOINT_TYPE)) {

        //DPRINT(("KD: BdMoveMemory failed writing BP!\n"));
        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_WRITE;
        return FALSE;
    }
    else {

        // check for two-slot MOVL instruction. Reject request if attempt to
        // set break in slot 2 of MLI template.
        // change template to type 0 if current instruction is MLI

        if (((ULONG_PTR)BdBreakpointTable[Index].Address & 0xf) != 0) {
            (ULONG_PTR)BundleAddress = (ULONG_PTR)BdBreakpointTable[Index].Address & ~(0xf);
            if (BdMoveMemory(
                    (PCHAR)&mBuf,
                    (PCHAR)BundleAddress,
                    sizeof(BD_BREAKPOINT_TYPE)
                    ) != sizeof(BD_BREAKPOINT_TYPE)) {
                //DPRINT(("KD: read template failed at 0x%08x\n", BundleAddress));
                BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_WRITE;
                return FALSE;
            }
            else {
                if (((mBuf & INST_TEMPL_MASK) >> 1) == 0x2) {
                    if (((ULONG_PTR)BdBreakpointTable[Index].Address & 0xf) == 4) {
                        // if template= type 2 MLI, change to type 0
                        mBuf &= ~((INST_TEMPL_MASK >> 1) << 1);
                        BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_IA64_MOVL;
                        if (BdMoveMemory(
                                (PCHAR)BundleAddress,
                                (PCHAR)&mBuf,
                                sizeof(BD_BREAKPOINT_TYPE)
                                ) != sizeof(BD_BREAKPOINT_TYPE)) {
                            //DPRINT(("KD: write to 0x%08x template failed\n", BundleAddress));
                            BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_WRITE;
                            return FALSE;
                        }
                        else {
                             //DPRINT(("KD: change MLI template to type 0 at 0x%08x set\n", Address));
                        }
                    } else {
                         // set breakpoint at slot 2 of MOVL is illegal
                         //DPRINT(("KD: illegal to set BP at slot 2 of MOVL at 0x%08x\n", BundleAddress));
                         BdBreakpointTable[Index].Flags |= BD_BREAKPOINT_NEEDS_WRITE;
                         return FALSE;
                    }
                }
            }
        }
        //DPRINT(("KD: breakpoint at 0x%08x set\n", Address));
        return TRUE;
    }
#else     // _IA64_

    BdMoveMemory((PCHAR)BdBreakpointTable[Index].Address,
                 (PCHAR)&BdBreakpointInstruction,
                  sizeof(BD_BREAKPOINT_TYPE));
    return TRUE;
#endif  // _IA64_

}

VOID
BdRestoreAllBreakpoints (
    VOID
    )
{
    ULONG Index;

    BreakpointsSuspended = FALSE;

    for ( Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index++ ) {

        if ((BdBreakpointTable[Index].Flags & BD_BREAKPOINT_IN_USE) &&
            (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_SUSPENDED) ) {

            BdBreakpointTable[Index].Flags &= ~BD_BREAKPOINT_SUSPENDED;
            BdLowRestoreBreakpoint(Index);
        }
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\bd.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bd.h

Abstract:

    This module contains the data structures and function prototypes for the
    boot debugger.

Author:

    David N. Cutler (davec) 27-Nov-1996

Revision History:

--*/

#ifndef _BD_
#define _BD_

#include "bldr.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "ki.h"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"
#include "cpu.h"
#include "ntverp.h"

//
// Define message buffer size in bytes.
//
// N.B. This must be 0 mod 8.
//

#define BD_MESSAGE_BUFFER_SIZE 4096

//
// Define the maximum number of retries for packet sends.
//

#define MAXIMUM_RETRIES 20

//
// Define packet waiting status codes.
//

#define BD_PACKET_RECEIVED 0
#define BD_PACKET_TIMEOUT 1
#define BD_PACKET_RESEND 2

//
// Define break point table entry structure.
//

#define BD_BREAKPOINT_IN_USE 0x1
#define BD_BREAKPOINT_NEEDS_WRITE 0x2
#define BD_BREAKPOINT_SUSPENDED 0x4
#define BD_BREAKPOINT_NEEDS_REPLACE 0x8

typedef struct _BREAKPOINT_ENTRY {
    ULONG Flags;
    ULONG64 Address;
    BD_BREAKPOINT_TYPE Content;
} BREAKPOINT_ENTRY, *PBREAKPOINT_ENTRY;

extern ULONG BdFileId;

//
// Define function prototypes.
//

LOGICAL
BdPollBreakIn (
    VOID
    );

VOID
BdReboot (
    VOID
    );

//
// Breakpoint functions (break.c).
//

ULONG
BdAddBreakpoint (
    IN ULONG64 Address
    );

LOGICAL
BdDeleteBreakpoint (
    IN ULONG Handle
    );

LOGICAL
BdDeleteBreakpointRange (
    IN ULONG64 Lower,
    IN ULONG64 Upper
    );

VOID
BdRestoreBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdWriteBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdSuspendBreakpoint (
    ULONG Handle
    );

VOID
BdSuspendAllBreakpoints (
    VOID
    );

VOID
BdRestoreAllBreakpoints (
    VOID
    );

//
// Memory check functions (check.c)
//

PVOID
BdReadCheck (
    IN PVOID Address
    );

PVOID
BdWriteCheck (
    IN PVOID Address
    );

PVOID
BdTranslatePhysicalAddress (
    IN PHYSICAL_ADDRESS Address
    );

//
// Debugger initialization routine (port.c)
//
LOGICAL
BdPortInitialize(
    IN ULONG BaudRate,
    IN ULONG PortNumber,
    OUT PULONG BdFileId
    );


//
// Communication functions (comio.c)
//

ULONG
BdComputeChecksum (
    IN PUCHAR Buffer,
    IN ULONG Length
    );

USHORT
BdReceivePacketLeader (
    IN ULONG PacketType,
    OUT PULONG PacketLeader
    );

VOID
BdSendControlPacket (
    IN USHORT PacketType,
    IN ULONG PacketId OPTIONAL
    );

ULONG
BdReceivePacket (
    IN ULONG ExpectedPacketType,
    OUT PSTRING MessageHeader,
    OUT PSTRING MessageData,
    OUT PULONG DataLength
    );

VOID
BdSendPacket (
    IN ULONG PacketType,
    IN PSTRING MessageHeader,
    IN PSTRING MessageData OPTIONAL
    );

ULONG
BdReceiveString (
    OUT PCHAR Destination,
    IN ULONG Length
    );

VOID
BdSendString (
    IN PCHAR Source,
    IN ULONG Length
    );

VOID
BdSendControlPacket (
    IN USHORT PacketType,
    IN ULONG PacketId OPTIONAL
    );

//
// State change message functions (message.c)
//

LOGICAL
BdReportExceptionStateChange (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord
    );

LOGICAL
BdReportLoadSymbolsStateChange (
    IN PSTRING PathName,
    IN PKD_SYMBOLS_INFO SymbolInfo,
    IN LOGICAL UnloadSymbols,
    IN OUT PCONTEXT ContextRecord
    );

//
// Platform independent debugger APIs (xxapi.c)
//

VOID
BdGetVersion(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

VOID
BdRestoreBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

NTSTATUS
BdWriteBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdReadPhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdWritePhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdReadVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdWriteVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdGetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdSetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

//
// Move memory functions (move.c)
//

ULONG
BdMoveMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    );

VOID
BdCopyMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    );

//
// CPU specific interfaces (cpuapi.c)
//

VOID
BdSetContextState (
    IN OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PCONTEXT ContextRecord
    );

VOID
BdGetStateChange (
    IN PDBGKD_MANIPULATE_STATE64 ManipulateState,
    IN PCONTEXT ContextRecord
    );

VOID
BdSetStateChange (
    IN OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    );

VOID
BdReadControlSpace (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdWriteControlSpace (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdReadIoSpace (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdWriteIoSpace (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdReadMachineSpecificRegister (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

VOID
BdWriteMachineSpecificRegister (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    );

//
// Print and prompt functions (dbgio.c)
//

VOID
BdPrintf (
    IN PCHAR Format,
    ...
    );

LOGICAL
BdPrintString (
    IN PSTRING Output
    );

LOGICAL
BdPromptString (
    IN PSTRING Output,
    IN OUT PSTRING Input
    );

//
// Define external data.
//

extern BD_BREAKPOINT_TYPE BdBreakpointInstruction;
extern BREAKPOINT_ENTRY BdBreakpointTable[];
extern LOGICAL BdControlCPending;
extern LOGICAL BdControlCPressed;
extern LOGICAL BdDebuggerNotPresent;
extern PBD_DEBUG_ROUTINE BdDebugRoutine;
extern ULONGLONG BdMessageBuffer[];
extern ULONG BdNextPacketIdToSend;
extern ULONG BdNumberRetries;
extern ULONG BdPacketIdExpected;
extern KPRCB BdPrcb;
extern ULONG BdRetryCount;
extern ULONG NtBuildNumber;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\dbgio.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dbgio.c

Abstract:

    This module implements the boot debugger print and prompt functions.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

--*/

#include "bd.h"

LOGICAL
BdPrintString (
    IN PSTRING Output
    )

/*++

Routine Description:

    This routine prints a string.

Arguments:

    Output - Supplies a pointer to a string descriptor for the output string.

Return Value:

    TRUE if Control-C present in input buffer after print is done.
    FALSE otherwise.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_DEBUG_IO DebugIo;

    //
    // Move the output string to the message buffer.
    //

    Length = BdMoveMemory((PCHAR)BdMessageBuffer,
                          (PCHAR)Output->Buffer,
                          Output->Length);

    //
    // If the total message length is greater than the maximum packet size,
    // then truncate the output string.
    //

    if ((sizeof(DBGKD_DEBUG_IO) + Length) > PACKET_MAX_SIZE) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_DEBUG_IO);
    }

    //
    // Construct the print string message and message descriptor.
    //

    DebugIo.ApiNumber = DbgKdPrintStringApi;
    DebugIo.ProcessorLevel = 0;
    DebugIo.Processor = 0;
    DebugIo.u.PrintString.LengthOfString = Length;
    MessageHeader.Length = sizeof(DBGKD_DEBUG_IO);
    MessageHeader.Buffer = (PCHAR)&DebugIo;

    //
    // Construct the print string data and data descriptor.
    //

    MessageData.Length = (USHORT)Length;
    MessageData.Buffer = (PCHAR)(&BdMessageBuffer[0]);

    //
    // Send packet to the kernel debugger on the host machine.
    //

    BdSendPacket(PACKET_TYPE_KD_DEBUG_IO,
                 &MessageHeader,
                 &MessageData);

    return BdPollBreakIn();
}

LOGICAL
BdPromptString (
    IN PSTRING Output,
    IN OUT PSTRING Input
    )

/*++

Routine Description:

    This routine prints a string, then reads a reply string.

Arguments:

    Output - Supplies a pointer to a string descriptor for the output string.

    Input - Supplies a pointer to a string descriptor for the input string.
            (Length stored/returned in Input->Length)

Return Value:

    TRUE - A Breakin sequence was seen, caller should breakpoint and retry
    FALSE - No Breakin seen.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_DEBUG_IO DebugIo;
    ULONG ReturnCode;

    //
    // Move the output string to the message buffer.
    //

    Length = BdMoveMemory((PCHAR)BdMessageBuffer,
                          (PCHAR)Output->Buffer,
                          Output->Length);

    //
    // If the total message length is greater than the maximum packet size,
    // then truncate the output string.
    //

    if ((sizeof(DBGKD_DEBUG_IO) + Length) > PACKET_MAX_SIZE) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_DEBUG_IO);
    }

    //
    // Construct the prompt string message and message descriptor.
    //

    DebugIo.ApiNumber = DbgKdGetStringApi;
    DebugIo.ProcessorLevel = 0;
    DebugIo.Processor = 0;
    DebugIo.u.GetString.LengthOfPromptString = Length;
    DebugIo.u.GetString.LengthOfStringRead = Input->MaximumLength;
    MessageHeader.Length = sizeof(DBGKD_DEBUG_IO);
    MessageHeader.Buffer = (PCHAR)&DebugIo;

    //
    // Construct the prompt string data and data descriptor.
    //

    MessageData.Length = (USHORT)Length;
    MessageData.Buffer = (PCHAR)(&BdMessageBuffer[0]);

    //
    // Send packet to the kernel debugger on the host machine.
    //

    BdSendPacket(PACKET_TYPE_KD_DEBUG_IO,
                 &MessageHeader,
                 &MessageData);

    //
    // Receive packet from the kernel debugger on the host machine.
    //

    MessageHeader.MaximumLength = sizeof(DBGKD_DEBUG_IO);
    MessageData.MaximumLength = BD_MESSAGE_BUFFER_SIZE;
    do {
        ReturnCode = BdReceivePacket(PACKET_TYPE_KD_DEBUG_IO,
                                     &MessageHeader,
                                     &MessageData,
                                     &Length);

        if (ReturnCode == BD_PACKET_RESEND) {
            return TRUE;
        }

    } while (ReturnCode != BD_PACKET_RECEIVED);


    Length = min(Length, Input->MaximumLength);
    Input->Length = (USHORT)BdMoveMemory((PCHAR)Input->Buffer,
                                         (PCHAR)BdMessageBuffer,
                                         Length);

    return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\file.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    file.c

Abstract:

    This module contains kd host machine file I/O support.

Author:

    Matt Holle (matth) April-2001

Revision History:

--*/

#include "bd.h"
#include "bootlib.h"
#include "kddll.h"

#define TRANSFER_LENGTH 8192
#define KD_MAX_REMOTE_FILES 16

//
// Keep track of all the remote files.
typedef struct _KD_REMOTE_FILE {
    ULONG64 RemoteHandle;
} KD_REMOTE_FILE, *PKD_REMOTE_FILE;

KD_REMOTE_FILE BdRemoteFiles[KD_MAX_REMOTE_FILES];

// KD_CONTEXT KdContext;

// temporary buffer used for transferring data back and forth.
// UCHAR   TransferBuffer[TRANSFER_LENGTH];
UCHAR   BdFileTransferBuffer[TRANSFER_LENGTH];


ARC_STATUS
BdCreateRemoteFile(
    OUT PHANDLE Handle,
    OUT PULONG64 Length, OPTIONAL
    IN PCHAR FileName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions
    )
{
    DBGKD_FILE_IO Irp;
    ULONG       DownloadedFileIndex;
    ULONG       Index;
    STRING      MessageData;
    STRING      MessageHeader;
    ULONG       ReturnCode;
    ULONG       PacketLength;
    ANSI_STRING aString;
    UNICODE_STRING uString;

    if( !BdDebuggerEnabled ) {
        return STATUS_DEBUGGER_INACTIVE;
    }

    if( (!FileName) ||
        (strlen(FileName) > PACKET_MAX_SIZE) ) {
        
        DbgPrint( "BdCreateRemoteFile: Bad parameter\n" );
        return STATUS_INVALID_PARAMETER;
    }
    

    if (BdDebuggerNotPresent != FALSE) {
        Irp.Status = STATUS_DEBUGGER_INACTIVE;
        goto Exit;
    }


    //
    // Look for an open slot.
    //
    for (DownloadedFileIndex = 0; DownloadedFileIndex < KD_MAX_REMOTE_FILES; DownloadedFileIndex++) {
        if (BdRemoteFiles[DownloadedFileIndex].RemoteHandle == 0) {
            break;
        }
    }

    if (DownloadedFileIndex >= KD_MAX_REMOTE_FILES) {
        DbgPrint( "BdCreateRemoteFile: No more empty handles available for this file.\n" );
        Irp.Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    
    //
    // Fix up the packet that we'll send to the kernel debugger.
    //
    Irp.ApiNumber = DbgKdCreateFileApi;
    Irp.u.CreateFile.DesiredAccess = DesiredAccess;
    Irp.u.CreateFile.FileAttributes = FileAttributes;
    Irp.u.CreateFile.ShareAccess = ShareAccess;
    Irp.u.CreateFile.CreateDisposition = CreateDisposition;
    Irp.u.CreateFile.CreateOptions = CreateOptions;
    Irp.u.CreateFile.Handle = 0;
    Irp.u.CreateFile.Length = 0;

    MessageHeader.Length = sizeof(Irp);
    MessageHeader.MaximumLength = sizeof(Irp);
    MessageHeader.Buffer = (PCHAR)&Irp;


    //
    // Send him a unicode file name.
    //
    RtlInitString( &aString, FileName );
    uString.Buffer = (PWCHAR)BdFileTransferBuffer;
    uString.MaximumLength = sizeof(BdFileTransferBuffer);
    RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );
    MessageData.Length = (USHORT)((strlen(FileName)+1) * sizeof(WCHAR));
    MessageData.Buffer = BdFileTransferBuffer;


    //
    // Send packet to the kernel debugger on the host machine and ask him to
    // send us a handle to the file.
    //
    BdSendPacket(PACKET_TYPE_KD_FILE_IO,
                 &MessageHeader,
                 &MessageData);

    if (BdDebuggerNotPresent != FALSE) {
        Irp.Status = STATUS_DEBUGGER_INACTIVE;
        goto Exit;
    }



    //
    // We asked for the handle, now receive it.
    //
    MessageData.MaximumLength = sizeof(BdFileTransferBuffer);
    MessageData.Buffer = (PCHAR)BdFileTransferBuffer;
    
    ReturnCode = BD_PACKET_TIMEOUT;
    Index = 0;
    while( (ReturnCode == BD_PACKET_TIMEOUT) &&
           (Index < 10) ) {
        ReturnCode = BdReceivePacket(PACKET_TYPE_KD_FILE_IO,
                                     &MessageHeader,
                                     &MessageData,
                                     &PacketLength);

        Index++;
    }
    
    //
    // BdReceivePacket *may* return BD_PACKET_RECEIVED eventhough the kernel
    // debugger failed to actually find the file we wanted.  Therefore, we
    // need to check the Irp.Status value too before assuming we got the
    // information we wanted.
    //
    // Note: don't check for Irp.u.CreateFile.Length == 0 because we don't
    // want to exclude downloading zero-length files.
    //
    if( (ReturnCode == BD_PACKET_RECEIVED) &&
        (NT_SUCCESS(Irp.Status)) ) {
        Irp.Status = STATUS_SUCCESS;
    } else {
        Irp.Status = STATUS_INVALID_PARAMETER;
    }

Exit:

    if (NT_SUCCESS(Irp.Status)) {
        BdRemoteFiles[DownloadedFileIndex].RemoteHandle = Irp.u.CreateFile.Handle;
        // Add one so that zero is reserved for invalid-handle.
        *Handle = UlongToHandle(DownloadedFileIndex + 1);
        if (ARGUMENT_PRESENT(Length)) {
            *Length = Irp.u.CreateFile.Length;
        }
    }
    
    
    return Irp.Status;
}

ARC_STATUS
BdReadRemoteFile(
    IN HANDLE Handle,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Completed
    )
{
    DBGKD_FILE_IO Irp;
    ULONG Index;
    ULONG _Completed = 0;


    if( !BdDebuggerEnabled ) {
        return STATUS_DEBUGGER_INACTIVE;
    }


    Index = HandleToUlong(Handle) - 1;
    if( (Index >= KD_MAX_REMOTE_FILES) ||
        (BdRemoteFiles[Index].RemoteHandle == 0) ) {
        
        DbgPrint( "BdReadRemoteFile: Bad parameters!\n" );
        Irp.Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }
    


    Irp.ApiNumber = DbgKdReadFileApi;
    Irp.Status = STATUS_SUCCESS;
    Irp.u.ReadFile.Handle = BdRemoteFiles[Index].RemoteHandle;
    Irp.u.ReadFile.Offset = Offset;

    while (Length > 0) {
        
        STRING MessageData;
        STRING MessageHeader;
        ULONG ReturnCode;
        ULONG RecvLength;

        if (Length > PACKET_MAX_SIZE - sizeof(Irp)) {
            Irp.u.ReadFile.Length = PACKET_MAX_SIZE - sizeof(Irp);
        } else {
            Irp.u.ReadFile.Length = Length;
        }
    
        MessageHeader.Length = sizeof(Irp);
        MessageHeader.MaximumLength = sizeof(Irp);
        MessageHeader.Buffer = (PCHAR)&Irp;
    
        //
        // Send packet to the kernel debugger on the host machine.
        //

        BdSendPacket(PACKET_TYPE_KD_FILE_IO,
                     &MessageHeader,
                     NULL);

        //
        // Receive packet from the kernel debugger on the host machine.
        //

        MessageData.MaximumLength = (USHORT)Irp.u.ReadFile.Length;
        MessageData.Buffer = Buffer;

        do {
            ReturnCode = BdReceivePacket(PACKET_TYPE_KD_FILE_IO,
                                         &MessageHeader,
                                         &MessageData,
                                         &RecvLength);
        } while (ReturnCode == BD_PACKET_TIMEOUT);

        if (ReturnCode == BD_PACKET_RECEIVED) {
            if (!NT_SUCCESS(Irp.Status)) {
                break;
            }

            _Completed += RecvLength;
            Buffer = (PVOID)((PUCHAR)Buffer + RecvLength);
            Irp.u.ReadFile.Offset += RecvLength;
            Length -= RecvLength;
        }
    }
    
    *Completed = _Completed;
    
Exit:
    return Irp.Status;
}

ARC_STATUS
BdCloseRemoteFile(
    IN HANDLE Handle
    )
{
    DBGKD_FILE_IO Irp;
    ULONG Index;

    
    if( !BdDebuggerEnabled ) {
        return STATUS_DEBUGGER_INACTIVE;
    }

    
    Index = HandleToUlong(Handle) - 1;
    if (Index >= KD_MAX_REMOTE_FILES) {
        return STATUS_INVALID_PARAMETER;
    }
    
    if (BdRemoteFiles[Index].RemoteHandle == 0) {
        Irp.Status = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    Irp.ApiNumber = DbgKdCloseFileApi;
    Irp.u.CloseFile.Handle = BdRemoteFiles[Index].RemoteHandle;

    for (;;) {
        
        STRING MessageData;
        STRING MessageHeader;
        ULONG ReturnCode;
        ULONG RecvLength;

        MessageHeader.Length = sizeof(Irp);
        MessageHeader.MaximumLength = sizeof(Irp);
        MessageHeader.Buffer = (PCHAR)&Irp;
    
        //
        // Send packet to the kernel debugger on the host machine.
        //

        BdSendPacket(PACKET_TYPE_KD_FILE_IO,
                     &MessageHeader,
                     NULL);

        //
        // Receive packet from the kernel debugger on the host machine.
        //

        MessageData.MaximumLength = BD_MESSAGE_BUFFER_SIZE;
        MessageData.Buffer = (PCHAR)BdMessageBuffer;

        do {
            ReturnCode = BdReceivePacket(PACKET_TYPE_KD_FILE_IO,
                                         &MessageHeader,
                                         &MessageData,
                                         &RecvLength);
        } while (ReturnCode == BD_PACKET_TIMEOUT);

        if (ReturnCode == BD_PACKET_RECEIVED) {
            break;
        }
    }
    
    if (NT_SUCCESS(Irp.Status)) {
        BdRemoteFiles[Index].RemoteHandle = 0;
    }
    
 Exit:
    return Irp.Status;
}

ARC_STATUS
BdPullRemoteFile(
    IN PCHAR FileName,
    IN ULONG FileAttributes,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN ULONG FileId
    )
{
    ARC_STATUS      Status = ESUCCESS;
    PUCHAR          BaseFilePointer = NULL;
    PUCHAR          WorkingMemoryPointer = NULL;
    ULONG64         Length = 0;
    HANDLE          RemoteHandle = NULL;
    ULONG64         Offset = 0;
    ULONG           basePage = 0;
    PBL_FILE_TABLE  fileTableEntry = NULL;


    if( !BdDebuggerEnabled ) {
        return STATUS_DEBUGGER_INACTIVE;
    }

    
    // Open the remote file for reading.
    Status = BdCreateRemoteFile(&RemoteHandle, &Length, FileName,
                                FILE_GENERIC_READ, FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ, FILE_OPEN, 0);
    if (!NT_SUCCESS(Status)) {
        //
        // File probably doesn't exist on the debugger.
        //
        goto Exit;
    }
    

    //
    // Allocate memory for the file, then download it.
    //
    Status = BlAllocateAlignedDescriptor( LoaderFirmwareTemporary,
                                          0,
                                          (ULONG)((Length + PAGE_SIZE - 1) >> PAGE_SHIFT),
                                          0,
                                          &basePage );
    if ( Status != ESUCCESS ) {
        DbgPrint( "BdPullRemoteFile: BlAllocateAlignedDescriptor failed! (%x)\n", Status );
        goto Exit;
    }



    //
    // Keep track of our pointers.
    // BaseFilePointer will point to the starting address of the block
    // we're about to download the file into.
    //
    // Working MemoryPointer will move through memory as we download small
    // chunks of the file.
    //
    BaseFilePointer = (PUCHAR)ULongToPtr( (basePage << PAGE_SHIFT) );
    WorkingMemoryPointer = BaseFilePointer;


    //
    // Download the file.
    //
    Offset = 0;
    while( Offset < Length ) {
        ULONG ReqLength, ReqCompleted;

        if((Length - Offset) > TRANSFER_LENGTH) {
            ReqLength = TRANSFER_LENGTH;
        } else {
            ReqLength = (ULONG)(Length - Offset);
        }
        
        Status = BdReadRemoteFile( RemoteHandle, 
                                   Offset, 
                                   WorkingMemoryPointer,
                                   ReqLength, 
                                   &ReqCompleted );
        if (!NT_SUCCESS(Status) || ReqCompleted == 0) {
            DbgPrint( "BdPullRemoteFile: BdReadRemoteFile failed! (%x)\n", Status );
            goto Exit;
        }

        // Increment our working pointer so we copy the next chunk
        // into the next spot in memory.
        WorkingMemoryPointer += ReqLength;

        Offset += ReqLength;
    }
    
    
    //
    // We got the file, so setup the BL_FILE_TABLE
    // entry for this file.  We'll pretend that we got this file
    // off the network because that's pretty close, and it allows
    // us to conveniently record the memory block where we're about
    // to download this file.
    //
    {
        extern BL_DEVICE_ENTRY_TABLE NetDeviceEntryTable;
        fileTableEntry = &BlFileTable[FileId];
        fileTableEntry->Flags.Open = 1;
        fileTableEntry->DeviceId = NET_DEVICE_ID;
        fileTableEntry->u.NetFileContext.FileSize = (ULONG)Length;
        fileTableEntry->u.NetFileContext.InMemoryCopy = BaseFilePointer;
        fileTableEntry->Position.QuadPart = 0;
        fileTableEntry->Flags.Read = 1;
        fileTableEntry->DeviceEntryTable = &NetDeviceEntryTable;
        RtlZeroMemory( fileTableEntry->StructureContext,  sizeof(NET_STRUCTURE_CONTEXT) );
        
        //
        // If we've called NetIntialize before (like if we're really booting from
        // the net, or if we've come through here before), then he returns immediately
        // so the call isn't expensive.
        //
        // If we're not booting from the net, and we've never called NetInitialize before,
        // then this will do nothing but setup his function table and return quickly.
        //
        NetInitialize();
    }

    DbgPrint( "BD: Loaded remote file %s\n", FileName );
    
Exit:
    if (RemoteHandle != NULL) {
        BdCloseRemoteFile(RemoteHandle);
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\init.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module implements the initialization for the boot debgger.

Author:

    David N. Cutler (davec) 27-Nov-1996

Revision History:

--*/

#include "bd.h"

#if defined(EFI)
#include "bootefi.h"
#endif

//
// Define local data.
//

#define BAUD_OPTION "BAUDRATE"
#define PORT_OPTION "DEBUGPORT"

ULONG BdFileId;


VOID
BdInitDebugger (
    IN PCHAR LoaderName,
    IN PVOID LoaderBase,
    IN PCHAR Options
    )

/*++

Routine Description:

    This routine initializes the boot kernel debugger.

Arguments:

    Options - Supplies a pointer to the the boot options.

    Stop - Supplies a logical value that determines whether a debug message
        and breakpoint are generated.

Return Value:

    None.

--*/

{

    PCHAR BaudOption;
    ULONG BaudRate;
    ULONG Index;
    ULONG PortNumber;
    PCHAR PortOption;
    STRING String;

    //
    // If the boot debugger is not already initialized, then attempt to
    // initialize the debugger.
    //
   
    if (BdDebuggerEnabled == FALSE) {

        //
        // Set the address of the debug routine to the stub function and parse
        // any options if specified.
        //

        BdDebugRoutine = BdStub;
        if (Options != NULL) {
            _strupr(Options);

            //
            // If nodebug is not explicitly specified, then check if the baud
            // rate, com port, or debug is explicitly specified.
            //

            if (strstr(Options, "NODEBUG") == NULL) {
                PortNumber = 0;
                PortOption = strstr(Options, PORT_OPTION);
                BaudOption = strstr(Options, BAUD_OPTION);
                BaudRate = 0;
                if ((PortOption == NULL) && (BaudOption == NULL)) {
                    if (strstr(Options, "DEBUG") == NULL) {
                        return;
                    }

                } else {
                    if (PortOption != NULL) {
                        PortOption = strstr(PortOption, "COM");
                        if (PortOption != NULL) {
                            PortNumber = atol(PortOption + 3);
                        }
                    }

                    if (BaudOption != NULL) {
                        BaudOption += strlen(BAUD_OPTION);
                        while (*BaudOption == ' ') {
                            BaudOption++;
                        }

                        if (*BaudOption != '\0') {
                            BaudRate = atol(BaudOption + 1);
                        }
                    }
                }

                //
                // Attempt to initialize the debug port.
                //
                if (BdPortInitialize(BaudRate, PortNumber, &BdFileId) == FALSE) {
                    return;
                }

                //
                // Set the value of a break point instruction, set the address
                // of the debug routine to the trap function, set the debugger
                // enabled and initialize the breakpoint table.
                //

                BdBreakpointInstruction = BD_BREAKPOINT_VALUE;
                BdDebugRoutine = BdTrap;
                BdDebuggerEnabled = TRUE;
                for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
                    BdBreakpointTable[Index].Flags = 0;
                    BdBreakpointTable[Index].Address = 0;
                }

                //
                // Initialize the ID for the NEXT packet to send and the Expect
                // ID of next incoming packet.
                //

                BdNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                BdPacketIdExpected = INITIAL_PACKET_ID;

                //
                // Announce debugger initialized.
                //

                DbgPrint("BD: Boot Debugger Initialized\n");

                //
                // Notify the kernel debugger to load symbols for the loader.
                //

                String.Buffer = LoaderName;
                String.Length = (USHORT) strlen(LoaderName);
                DbgPrint("BD: %s base address %p\n", LoaderName, LoaderBase);
                DbgLoadImageSymbols(&String, LoaderBase, (ULONG_PTR)-1);

                if (strstr(Options, "DEBUGSTOP") != NULL) {

                    //
                    // Treat this like a request for initial breakpoint.
                    //

                    DbgBreakPoint();
                }

#if defined(EFI)
                //
                // if running under the debugger disable the watchdog so we 
                // don't get reset
                //
                DisableEFIWatchDog();
#endif

            }
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\move.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    move.c

Abstract:

    This module contains code to implement the portable kernel debugger
    memory mover.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

--*/

#include "bd.h"

ULONG
BdMoveMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine moves data to or from the message buffer and returns the
    actual length of the information that was moved. As data is moved, checks
    are made to ensure that the data is resident in memory and a page fault
    will not occur. If a page fault would occur, then the move is truncated.

Arguments:

    Destination  - Supplies a pointer to destination of the move operation.

    Source - Supplies a pointer to the source of the move operation.

    Length - Supplies the length of the move operation.

Return Value:

    The actual length of the move is returned as the fucntion value.

--*/

{

    PVOID Address1;
    PVOID Address2;
    ULONG ActualLength;

    //
    // If the length is greater than the size of the message buffer, then
    // reduce the length to the size of the message buffer.
    //

    if (Length > BD_MESSAGE_BUFFER_SIZE) {
        Length = BD_MESSAGE_BUFFER_SIZE;
    }

    //
    // Move the source information to the destination address.
    //

    ActualLength = Length;
    while (((ULONG_PTR)Source & 3) && (Length > 0)) {

    //
    // Check to determine if the move will succeed before actually performing
    // the operation.
    //

        Address1 = BdWriteCheck((PVOID)Destination);
        Address2 = BdReadCheck((PVOID)Source);
        if ((Address1 == NULL) || (Address2 == NULL)) {
            break;
        }

        *(PCHAR)Address1 = *(PCHAR)Address2;
        Destination += 1;
        Source += 1;
        Length -= 1;
    }

    while (Length > 3) {

    //
    // Check to determine if the move will succeed before actually performing
    // the operation.
    //

        Address1 = BdWriteCheck((PVOID)Destination);
        Address2 = BdReadCheck((PVOID)Source);
        if ((Address1 == NULL) || (Address2 == NULL)) {
            break;
        }

        *(ULONG UNALIGNED *)Address1 = *(PULONG)Address2;
        Destination += 4;
        Source += 4;
        Length -= 4;

    }

    while (Length > 0) {

    //
    // Check to determine if the move will succeed before actually performing
    // the operation.
    //

        Address1 = BdWriteCheck((PVOID)Destination);
        Address2 = BdReadCheck((PVOID)Source);
        if ((Address1 == NULL) || (Address2 == NULL)) {
            break;
        }

        *(PCHAR)Address1 = *(PCHAR)Address2;
        Destination += 1;
        Source += 1;
        Length -= 1;
    }

    //
    // Flush the instruction cache in case the write was into the instruction
    // stream.
    //

#if defined(_ALPHA_)

    BdSweepIcache();

#endif

    return ActualLength - Length;
}

VOID
BdCopyMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine duplicates the function pf RtlCopyMemory, but is private
    to the debugger. This allows breakpoints and watch points to be set
    RtlMoveMemory itself without risk of recursive debugger entry and the
    accompanying hang.

    N.B. Unlike BdMoveMemory, this routine does NOT check for accessability
      and may fault! Use it ONLY in the debugger and ONLY where you could
      use RtlMoveMemory.

Arguments:

    Destination  - Supplies a pointer to destination of the move operation.

    Source - Supplies a pointer to the source of the move operation.

    Length - Supplies the length of the move operation.

Return Value:

    None.

--*/

{

    while (Length > 0) {
        *Destination = *Source;
        Destination += 1;
        Source += 1;
        Length -= 1;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\message.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    message.c

Abstract:

    This module implements the debugger state change message functions.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

--*/

#include "bd.h"

#if ACCASM && !defined(_MSC_VER)

long asm(const char *,...);
#pragma intrinsic(asm)

#endif

KCONTINUE_STATUS
BdSendWaitContinue (
    IN ULONG OutPacketType,
    IN PSTRING OutMessageHeader,
    IN PSTRING OutMessageData OPTIONAL,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This function sends a packet and waits for a continue message. BreakIns
    received while waiting will always cause a resend of the packet originally
    sent out. While waiting state manipulate messages will be serviced.

    A resend always resends the original event sent to the debugger, not the
    last response to some debugger command.

Arguments:

    OutPacketType - Supplies the type of packet to send.

    OutMessageHeader - Supplies a pointer to a string descriptor that describes
        the message information.

    OutMessageData - Supplies a pointer to a string descriptor that describes
        the optional message data.

    ContextRecord - Exception context

Return Value:

    A value of TRUE is returned if the continue message indicates
    success, Otherwise, a value of FALSE is returned.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_MANIPULATE_STATE64 ManipulateState;
    ULONG ReturnCode;
    NTSTATUS Status;
    KCONTINUE_STATUS ContinueStatus;

    //
    // Loop servicing state manipulation message until a continue message
    // is received.
    //

    MessageHeader.MaximumLength = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)&ManipulateState;
    MessageData.MaximumLength = BD_MESSAGE_BUFFER_SIZE;
    MessageData.Buffer = (PCHAR)(&BdMessageBuffer[0]);

    //
    // Send event notification packet to debugger on host. Come back here
    // any time we see a breakin sequence.
    //

ResendPacket:
    BdSendPacket(OutPacketType,
                 OutMessageHeader,
                 OutMessageData);

    //
    // After sending packet, if there is no response from debugger and the
    // packet is for reporting symbol (un)load, the debugger will be declared
    // to be not present. Note If the packet is for reporting exception, the
    // BdSendPacket will never stop.
    //

    if (BdDebuggerNotPresent != FALSE) {
        return ContinueSuccess;
    }

    while (TRUE) {

        //
        // Wait for State Manipulate Packet without timeout.
        //

        do {
            ReturnCode = BdReceivePacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                                         &MessageHeader,
                                         &MessageData,
                                         &Length);

            if (ReturnCode == (USHORT)BD_PACKET_RESEND) {
                goto ResendPacket;
            }

        } while (ReturnCode == BD_PACKET_TIMEOUT);

        //
        // Switch on the return message API number.
        //

//        BlPrint("BdSendWait: api number %d\n", ManipulateState.ApiNumber);
        switch (ManipulateState.ApiNumber) {

        case DbgKdReadVirtualMemoryApi:
            BdReadVirtualMemory(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdWriteVirtualMemoryApi:
            BdWriteVirtualMemory(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdReadPhysicalMemoryApi:
            BdReadPhysicalMemory(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdWritePhysicalMemoryApi:
            BdWritePhysicalMemory(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdGetContextApi:
            BdGetContext(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdSetContextApi:
            BdSetContext(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdWriteBreakPointApi:
            BdWriteBreakpoint(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdRestoreBreakPointApi:
            BdRestoreBreakpoint(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdReadControlSpaceApi:
            BdReadControlSpace(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdWriteControlSpaceApi:
            BdWriteControlSpace(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdReadIoSpaceApi:
            BdReadIoSpace(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdWriteIoSpaceApi:
            BdWriteIoSpace(&ManipulateState, &MessageData, ContextRecord);
            break;

#if defined(_ALPHA_) || defined(_AXP64_)

        case DbgKdReadIoSpaceExtendedApi:
            BdReadIoSpaceExtended(&ManipulateState, &MessageData, ContextRecord);
            break;

        case DbgKdWriteIoSpaceExtendedApi:
            BdWriteIoSpaceExtended(&ManipulateState, &MessageData, ContextRecord);
            break;

#endif

        case DbgKdContinueApi:
            if (NT_SUCCESS(ManipulateState.u.Continue.ContinueStatus) != FALSE) {
                return ContinueSuccess;

            } else {
                return ContinueError;
            }

            break;

        case DbgKdContinueApi2:
            if (NT_SUCCESS(ManipulateState.u.Continue2.ContinueStatus) != FALSE) {
                BdGetStateChange(&ManipulateState, ContextRecord);
                return ContinueSuccess;

            } else {
                return ContinueError;
            }

            break;

        case DbgKdRebootApi:
            BdReboot();
            break;

        case DbgKdGetVersionApi:
            BdGetVersion(&ManipulateState);
            break;

        case DbgKdWriteBreakPointExApi:
            Status = BdWriteBreakPointEx(&ManipulateState,
                                          &MessageData,
                                          ContextRecord);

            if (Status) {
                ManipulateState.ApiNumber = DbgKdContinueApi;
                ManipulateState.u.Continue.ContinueStatus = Status;
                return ContinueError;
            }

            break;

        case DbgKdRestoreBreakPointExApi:
            BdRestoreBreakPointEx(&ManipulateState, &MessageData, ContextRecord);
            break;

            //
            // Invalid message.
            //

        default:
            MessageData.Length = 0;
            ManipulateState.ReturnStatus = STATUS_UNSUCCESSFUL;
            BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                         &MessageHeader,
                         &MessageData);

            break;
        }

#ifdef _ALPHA_

        //
        //jnfix
        // this is embarrasing, we have an icache coherency problem that
        // the following imb fixes, later we must track this down to the
        // exact offending API but for now this statement allows the stub
        // work to appropriately for Alpha.
        //

#if defined(_MSC_VER)

        __PAL_IMB();

#else

        asm( "call_pal 0x86" );   // x86 = imb

#endif

#endif

    }
}

VOID
BdpSetCommonState(
    IN ULONG NewState,
    IN PCONTEXT ContextRecord,
    OUT PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange
    )
{
    BOOLEAN DeletedBps;
    PCHAR PcMemory;
    USHORT InstrCount;
    PUCHAR InstrStream;
    
    WaitStateChange->NewState = NewState;
    WaitStateChange->ProcessorLevel = 0;
    WaitStateChange->Processor = 0;
    WaitStateChange->NumberProcessors = 1;
    WaitStateChange->Thread = 0;
    PcMemory = (PCHAR)CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
    WaitStateChange->ProgramCounter = (ULONG64)(LONG64)(LONG_PTR)PcMemory;

    RtlZeroMemory(&WaitStateChange->AnyControlReport,
                  sizeof(WaitStateChange->AnyControlReport));
    
    //
    // Copy instruction stream immediately following location of event.
    //

    InstrStream = WaitStateChange->ControlReport.InstructionStream;
    InstrCount = (USHORT)
        BdMoveMemory(InstrStream, PcMemory, DBGKD_MAXSTREAM);
    WaitStateChange->ControlReport.InstructionCount = InstrCount;

    //
    // Clear breakpoints in copied area.
    // If there were any breakpoints cleared, recopy the instruction area
    // without them.
    //

    if (BdDeleteBreakpointRange((ULONG_PTR)PcMemory,
                                (ULONG_PTR)PcMemory + InstrCount - 1)) {
        BdMoveMemory(InstrStream, PcMemory, InstrCount);
    }
}

LOGICAL
BdReportExceptionStateChange (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This routine sends an exception state change packet to the kernel
    debugger and waits for a manipulate state message.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise, a
    value of FALSE is returned.

--*/

{
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange;
    KCONTINUE_STATUS Status;

    do {

        //
        // Construct the wait state change message and message descriptor.
        //

        BdpSetCommonState(DbgKdExceptionStateChange, ContextRecord,
                          &WaitStateChange);
        
        if (sizeof(EXCEPTION_RECORD) ==
            sizeof(WaitStateChange.u.Exception.ExceptionRecord)) {
            BdCopyMemory((PCHAR)&WaitStateChange.u.Exception.ExceptionRecord,
                         (PCHAR)ExceptionRecord,
                         sizeof(EXCEPTION_RECORD));
        } else {
            ExceptionRecord32To64((PEXCEPTION_RECORD32)ExceptionRecord,
                                  &WaitStateChange.u.Exception.ExceptionRecord);
        }

        WaitStateChange.u.Exception.FirstChance = TRUE;
        
        BdSetStateChange(&WaitStateChange,
                         ExceptionRecord,
                         ContextRecord);

        MessageHeader.Length = sizeof(WaitStateChange);
        MessageHeader.Buffer = (PCHAR)&WaitStateChange;
        MessageData.Length = 0;

        //
        // Send packet to the kernel debugger on the host machine,
        // wait for answer.
        //

        Status = BdSendWaitContinue(PACKET_TYPE_KD_STATE_CHANGE64,
                                    &MessageHeader,
                                    &MessageData,
                                    ContextRecord);

    } while (Status == ContinueProcessorReselected) ;

    return (BOOLEAN) Status;
}

LOGICAL
BdReportLoadSymbolsStateChange (
    IN PSTRING PathName,
    IN PKD_SYMBOLS_INFO SymbolInfo,
    IN LOGICAL UnloadSymbols,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This routine sends a load symbols state change packet to the kernel
    debugger and waits for a manipulate state message.

Arguments:

    PathName - Supplies a pointer to the pathname of the image whose
        symbols are to be loaded.

    BaseOfDll - Supplies the base address where the image was loaded.

    ProcessId - Unique 32-bit identifier for process that is using
        the symbols.  -1 for system process.

    CheckSum - Unique 32-bit identifier from image header.

    UnloadSymbol - TRUE if the symbols that were previously loaded for
        the named image are to be unloaded from the debugger.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise, a
    value of FALSE is returned.

--*/

{

    PSTRING AdditionalData;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange;
    KCONTINUE_STATUS Status;

    do {

        //
        // Construct the wait state change message and message descriptor.
        //

        BdpSetCommonState(DbgKdLoadSymbolsStateChange, ContextRecord,
                          &WaitStateChange);
        BdSetContextState(&WaitStateChange, ContextRecord);

        WaitStateChange.u.LoadSymbols.UnloadSymbols = (BOOLEAN)UnloadSymbols;
        WaitStateChange.u.LoadSymbols.BaseOfDll = (ULONG64)SymbolInfo->BaseOfDll;
        WaitStateChange.u.LoadSymbols.ProcessId = SymbolInfo->ProcessId;
        WaitStateChange.u.LoadSymbols.CheckSum = SymbolInfo->CheckSum;
        WaitStateChange.u.LoadSymbols.SizeOfImage = SymbolInfo->SizeOfImage;
        if (ARGUMENT_PRESENT(PathName)) {
            WaitStateChange.u.LoadSymbols.PathNameLength =
                BdMoveMemory((PCHAR)BdMessageBuffer,
                             (PCHAR)PathName->Buffer,
                             PathName->Length) + 1;

            MessageData.Buffer = (PCHAR)(&BdMessageBuffer[0]);
            MessageData.Length = (USHORT)WaitStateChange.u.LoadSymbols.PathNameLength;
            MessageData.Buffer[MessageData.Length-1] = '\0';
            AdditionalData = &MessageData;

        } else {
            WaitStateChange.u.LoadSymbols.PathNameLength = 0;
            AdditionalData = NULL;
        }

        MessageHeader.Length = sizeof(WaitStateChange);
        MessageHeader.Buffer = (PCHAR)&WaitStateChange;

        //
        // Send packet to the kernel debugger on the host machine, wait
        // for the reply.
        //

        Status = BdSendWaitContinue(PACKET_TYPE_KD_STATE_CHANGE64,
                                     &MessageHeader,
                                     AdditionalData,
                                     ContextRecord);

    } while (Status == ContinueProcessorReselected);

    return (BOOLEAN) Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\poll.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    poll.c

Abstract:

    This module contains code to poll for debugger breakin.

Author:

    David N. Cutler (davec) 27-Nov-96

Revision History:

--*/

#include "bd.h"

LOGICAL
BdPollBreakIn(
    VOID
    )

/*++

Routine Description:

    This function checks to determine if a breakin packet is pending.
    If a packet is present.

    A packet is present if:

    There is a valid character which matches BREAK_CHAR.

Return Value:

    A function value of TRUE is returned if a breakin packet is present.
    Otherwise, a value of FALSE is returned.

--*/

{

    LOGICAL BreakIn;
    UCHAR Input;
    ULONG Status;

    //
    // If the debugger is enabled, check if a breakin by the kernel
    // debugger is pending.
    //

    BreakIn = FALSE;
    if (BdDebuggerEnabled != FALSE) {
        if (BdControlCPending != FALSE) {
            BdControlCPressed = TRUE;
            BreakIn = TRUE;
            BdControlCPending = FALSE;

        } else {
            Status = BlPortPollByte(BdFileId, &Input);
            if ((Status == CP_GET_SUCCESS) &&
                (Input == BREAKIN_PACKET_BYTE)) {
                BreakIn = TRUE;
                BdControlCPressed = TRUE;
            }
        }
    }

    return BreakIn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

TARGETNAME=bd
TARGETPATH=obj
TARGETTYPE=LIBRARY

!IF "$(BUILD_DEBUG_LOADER)" != ""
!include $(PROJECT_ROOT)\boot\loader_dbg.inc
!ELSE
!include $(PROJECT_ROOT)\boot\loader.inc
!ENDIF

INCLUDES=\
    ..;\
    ..\..\inc;\
    ..\..\lib;\
    $(PROJECT_ROOT)\ntos\inc;\
    $(PROJECT_ROOT)\ntos\ke;\
    ..\$(TARGET_DIRECTORY);\
    $(PROJECT_ROOT)\fs\fastfat;\
    $(PROJECT_ROOT)\fs\cdfs;\
    $(PROJECT_ROOT)\fs\udfs;\
    $(PROJECT_ROOT)\fs\ntfs;\
    $(SDKTOOLS_INC_PATH)

SOURCES=..\break.c   \
        ..\comio.c   \
        ..\data.c    \
        ..\dbgio.c   \
        ..\file.c    \
        ..\init.c    \
        ..\message.c \
        ..\move.c    \
        ..\poll.c    \
        ..\xxapi.c
        
!IF $(IA64)
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE -DEFI
!endif


PRECOMPILED_INCLUDE=..\bd.h
PRECOMPILED_PCH=bd.pch
PRECOMPILED_OBJ=bd.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\i386\cpu.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bdcpu.h

Abstract:

    Machine specific kernel debugger data types and constants.

Author:

    Mark Lucovsky (markl) 29-Aug-1990

Revision History:

--*/

#ifndef _BDCPU_
#define _BDCPU_
#include "bldrx86.h"

//
// Define debug routine prototypes.
//

typedef
LOGICAL
(*PBD_DEBUG_ROUTINE) (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

LOGICAL
BdTrap (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

LOGICAL
BdStub (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

#define BD_BREAKPOINT_TYPE  UCHAR
#define BD_BREAKPOINT_ALIGN 0
#define BD_BREAKPOINT_VALUE 0xcc

#endif // _BDCPU_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\i386\check.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This module implements memory check routine for the boot debugger.

Author:

    David N. Cutler (davec) 3-Dec-96

Environment:

    Kernel mode only.

Revision History:

--*/

#include "bd.h"

extern BOOLEAN PaeEnabled;



BOOLEAN
BdCheckPdeValid (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine determines if the PDE for the specified address has the
    valid bit set.

Agruments:

    Address - Supplies the virtual address to check.

Return Value:

    A value of TRUE indicates that the PDE for the supplied virtual address
    does have the valid bit set, FALSE if it does not.

--*/

{
    PHARDWARE_PTE_X86PAE PdePae;
    PHARDWARE_PTE_X86 PdeX86;

    if (PaeEnabled) {

        //
        // Physical address extenions are enabled.
        // 

        PdePae = (PHARDWARE_PTE_X86PAE)PDE_BASE_X86PAE;
        PdePae = &PdePae[ (ULONG)Address >> PDI_SHIFT_X86PAE ];

        if (PdePae->Valid == 0) {
            return FALSE;
        } else {
            return TRUE;
        }

    } else {

        //
        // Physical address extensions are not enabled.
        //

        PdeX86 = (PHARDWARE_PTE_X86)PDE_BASE;
        PdeX86 = &PdeX86[ (ULONG)Address >> PDI_SHIFT_X86 ];

        if (PdeX86->Valid == 0) {
            return FALSE;
        } else {
            return TRUE;
        }
    }
}

BOOLEAN
BdCheckPteValid (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine determines if the PTE for the specified address has the
    valid bit set.

Agruments:

    Address - Supplies the virtual address to check.

Return Value:

    A value of TRUE indicates that the PTE for the supplied virtual address
    does have the valid bit set, FALSE if it does not.

--*/

{
    PHARDWARE_PTE_X86PAE PtePae;
    PHARDWARE_PTE_X86 PteX86;

    if (PaeEnabled) {

        //
        // Physical address extenions are enabled.
        // 

        PtePae = (PHARDWARE_PTE_X86PAE)PTE_BASE;
        PtePae = &PtePae[ (ULONG)Address >> PTI_SHIFT ];

        if (PtePae->Valid == 0) {
            return FALSE;
        } else {
            return TRUE;
        }

    } else {

        //
        // Physical address extensions are not enabled.
        //

        PteX86 = (PHARDWARE_PTE_X86)PTE_BASE;
        PteX86 = &PteX86[ (ULONG)Address >> PTI_SHIFT ];

        if (PteX86->Valid == 0) {
            return FALSE;
        } else {
            return TRUE;
        }
    }
}


PVOID
BdReadCheck (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine determines if the specified address can be read.

Arguments:

    Address - Supplies the virtual address to check.

Return Value:

    A value of NULL is returned if the address is not valid or readable.
    Otherwise, the physical address of the corresponding virtual address
    is returned.

--*/

{
    //
    // Check if the page containing the specified address is valid.
    //
    // N.B. If the address is valid, it is readable.
    //

    if (BdCheckPdeValid( Address ) == FALSE) {

        //
        // The PDE is not valid.
        //

        return NULL;
    }

    if (BdCheckPteValid( Address ) == FALSE) {

        //
        // The PDE was valid but the PTE is not.
        //

        return NULL;
    }

    return Address;
}

PVOID
BdWriteCheck (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine determines if the specified address can be written.

Arguments:

    Address - Supplies the virtual address to check.

Return Value:

    A value of NULL is returned if the address is not valid or writeable.
    Otherwise, the physical address of the corresponding virtual address
    is returned.

--*/

{
    //
    // Check if the page containing the specified address is valid.
    //
    // N.B. If the address is valid, it is writeable since the WP bit
    //      is not set in cr0.
    //

    if (BdCheckPdeValid( Address ) == FALSE) {

        //
        // The PDE is not valid.
        //

        return NULL;
    }

    if (BdCheckPteValid( Address ) == FALSE) {

        //
        // The PDE was valid but the PTE is not.
        //

        return NULL;
    }

    return Address;
}

PVOID
BdTranslatePhysicalAddress (
    IN PHYSICAL_ADDRESS Address
    )

/*++

Routine Description:

    This routine returns the phyiscal address for a physical address
    which is valid (mapped).

Arguments:

    Address - Supplies the physical address to check.

Return Value:

    Returns NULL if the address is not valid or readable. Otherwise,
    returns the physical address of the corresponding virtual address.

--*/

{

    return (PVOID)Address.LowPart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\i386\cpuapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bdcpuapi.c

Abstract:

    This module implements CPU specific remote debug APIs.

Author:

    Mark Lucovsky (markl) 04-Sep-1990

Revision History:

--*/

#include "bd.h"

//
// Define end of control space.
//

#define END_OF_CONTROL_SPACE ((PCHAR)(sizeof(KPROCESSOR_STATE)))

VOID
BdSetContextState(
    IN PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    The function fills in the processor-specific portions of
    the wait state change message record.

Arguments:

    WaitStateChange - Supplies a pointer to record to fill in.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{
    //
    // Special registers for the x86.
    //

    WaitStateChange->ControlReport.Dr6 = BdPrcb.ProcessorState.SpecialRegisters.KernelDr6;
    WaitStateChange->ControlReport.Dr7 = BdPrcb.ProcessorState.SpecialRegisters.KernelDr7;
    WaitStateChange->ControlReport.SegCs = (USHORT)(ContextRecord->SegCs);
    WaitStateChange->ControlReport.SegDs = (USHORT)(ContextRecord->SegDs);
    WaitStateChange->ControlReport.SegEs = (USHORT)(ContextRecord->SegEs);
    WaitStateChange->ControlReport.SegFs = (USHORT)(ContextRecord->SegFs);
    WaitStateChange->ControlReport.EFlags = ContextRecord->EFlags;
    WaitStateChange->ControlReport.ReportFlags = X86_REPORT_INCLUDES_SEGS;
    return;
}

VOID
BdGetStateChange(
    IN PDBGKD_MANIPULATE_STATE64 ManipulateState,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    The function extracts continuation control data from a manipulate state
    message.

Arguments:

    ManipulateState - Supplies a pointer to the manipulate state packet.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{

    //
    // If the continuation status is success, then set control space value.
    //

    if (NT_SUCCESS(ManipulateState->u.Continue2.ContinueStatus) != FALSE) {

        //
        // Set trace flag.
        //

        if (ManipulateState->u.Continue2.ControlSet.TraceFlag == TRUE) {
            ContextRecord->EFlags |= 0x100L;

        } else {
            ContextRecord->EFlags &= ~0x100L;

        }

        //
        // Set debug registers in processor control block.
        //

        BdPrcb.ProcessorState.SpecialRegisters.KernelDr6 = 0L;
        BdPrcb.ProcessorState.SpecialRegisters.KernelDr7 =
                                     ManipulateState->u.Continue2.ControlSet.Dr7;
    }
}

VOID
BdSetStateChange(
    IN PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    Fill in the wait state change message record.

Arguments:

    WaitStateChange - Supplies pointer to record to fill in

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{
    BdSetContextState(WaitStateChange, ContextRecord);
}

VOID
BdReadControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function reads control space.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_READ_MEMORY64 a = &m->u.ReadMemory;
    ULONG Length;
    STRING MessageHeader;

    //
    // If the specified control registers are within control space, then
    // read the specified space and return a success status. Otherwise,
    // return an unsuccessful status.
    //

    Length = min(a->TransferCount,
                 PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64));

    if (((PCHAR)a->TargetBaseAddress + Length) <= END_OF_CONTROL_SPACE) {
        BdCopyMemory(AdditionalData->Buffer,
                     (PCHAR)&BdPrcb.ProcessorState + (ULONG)a->TargetBaseAddress,
                     Length);

        m->ReturnStatus = STATUS_SUCCESS;
        a->ActualBytesRead = Length;
        AdditionalData->Length = (USHORT)Length;

    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        a->ActualBytesRead = 0;
        AdditionalData->Length = 0;
    }

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 AdditionalData);

    return;
}

VOID
BdWriteControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function writes control space.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_WRITE_MEMORY64 a = &m->u.WriteMemory;
    ULONG Length;
    STRING MessageHeader;

    //
    // If the specified control registers are within control space, then
    // write the specified space and return a success status. Otherwise,
    // return an unsuccessful status.
    //

    Length = min(a->TransferCount, AdditionalData->Length);
    if (((PCHAR)a->TargetBaseAddress + Length) <= END_OF_CONTROL_SPACE) {
        BdCopyMemory((PCHAR)&BdPrcb.ProcessorState + (ULONG)a->TargetBaseAddress,
                     AdditionalData->Buffer,
                     Length);

        m->ReturnStatus = STATUS_SUCCESS;
        a->ActualBytesWritten = Length;

    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        a->ActualBytesWritten = 0;
    }

    //
    // Send reply message.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}

VOID
BdReadIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function reads I/O space.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_READ_WRITE_IO64 a = &m->u.ReadWriteIo;
    STRING MessageHeader;

    //
    // Case of data size and check alignment.
    //

    m->ReturnStatus = STATUS_SUCCESS;
    switch (a->DataSize) {
        case 1:
            a->DataValue = (ULONG)READ_PORT_UCHAR((PUCHAR)a->IoAddress);
            break;

        case 2:
            if (((ULONG)a->IoAddress & 1) != 0) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                a->DataValue = (ULONG)READ_PORT_USHORT((PUSHORT)a->IoAddress);
            }

            break;

        case 4:
            if (((ULONG)a->IoAddress & 3) != 0) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                a->DataValue = READ_PORT_ULONG((PULONG)a->IoAddress);
            }

            break;

        default:
            m->ReturnStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}

VOID
BdWriteIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function wrties I/O space.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_READ_WRITE_IO64 a = &m->u.ReadWriteIo;
    STRING MessageHeader;

    //
    // Case on data size and check alignment.
    //

    m->ReturnStatus = STATUS_SUCCESS;
    switch (a->DataSize) {
        case 1:
            WRITE_PORT_UCHAR((PUCHAR)a->IoAddress, (UCHAR)a->DataValue);
            break;

        case 2:
            if (((ULONG)a->IoAddress & 1) != 0) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                WRITE_PORT_USHORT((PUSHORT)a->IoAddress, (USHORT)a->DataValue);
            }

            break;

        case 4:
            if (((ULONG)a->IoAddress & 3) != 0) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                WRITE_PORT_ULONG((PULONG)a->IoAddress, a->DataValue);
            }

            break;

        default:
            m->ReturnStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\xxapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    api.c

Abstract:

    This module implements the boot bebugger platform independent remote APIs.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

--*/

#include "bd.h"

VOID
BdGetVersion(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This function returns to the caller a general information packet
    that contains useful information to a debugger.  This packet is also
    used for a debugger to determine if the writebreakpointex and
    readbreakpointex apis are available.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.

--*/

{

    STRING messageHeader;

    messageHeader.Length = sizeof(*m);
    messageHeader.Buffer = (PCHAR)m;
    RtlZeroMemory(&m->u.GetVersion64, sizeof(m->u.GetVersion64));

    //
    // the current build number
    //
    // - 4 - tells the debugger this is a "special" OS - the boot loader.
    // The boot loader has a lot of special cases associated with it, like
    // the lack of the DebuggerDataBlock, lack of ntoskrnl, etc ...
    //

    m->u.GetVersion64.MinorVersion = (short)NtBuildNumber;
    m->u.GetVersion64.MajorVersion = 0x400 |
                                     (short)((NtBuildNumber >> 28) & 0xFFFFFFF);

    //
    // Kd protocol version number.
    //

    m->u.GetVersion64.ProtocolVersion = DBGKD_64BIT_PROTOCOL_VERSION2;
    m->u.GetVersion64.Flags = DBGKD_VERS_FLAG_DATA;

#if defined(_M_IX86)

    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_I386;

#elif defined(_M_MRX000)

    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_R4000;

#elif defined(_M_ALPHA)

    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_ALPHA;

#elif defined(_M_PPC)

    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_POWERPC;

#elif defined(_IA64_)

    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_IA64;
    m->u.GetVersion64.Flags |= DBGKD_VERS_FLAG_PTR64;

#else

#error( "unknown target machine" );

#endif

    m->u.GetVersion64.MaxPacketType = (UCHAR)(PACKET_TYPE_KD_FILE_IO + 1);;
    m->u.GetVersion64.MaxStateChange = (UCHAR)(DbgKdLoadSymbolsStateChange + 1);;
    m->u.GetVersion64.MaxManipulate = (UCHAR)(DbgKdSetBusDataApi + 1);


    //
    // address of the loader table
    //

    m->u.GetVersion64.PsLoadedModuleList = 0;
    m->u.GetVersion64.KernBase = 0;
    //m->u.GetVersion64.ThCallbackStack = 0;
    //m->u.GetVersion64.KiCallUserMode = 0;
    //m->u.GetVersion64.KeUserCallbackDispatcher = 0;
    //m->u.GetVersion64.NextCallback = 0;

#if defined(_X86_)

    //m->u.GetVersion64.FramePointer = 0;

#endif

    //m->u.GetVersion64.BreakpointWithStatus = 0;
    m->u.GetVersion64.DebuggerDataList = 0;

    //
    // the usual stuff
    //

    m->ReturnStatus = STATUS_SUCCESS;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &messageHeader,
                 NULL);

    return;
}

VOID
BdGetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a get context state
    manipulation message.  Its function is to return the current
    context.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_GET_CONTEXT a = &m->u.GetContext;
    STRING MessageHeader;

    m->ReturnStatus = STATUS_SUCCESS;
    AdditionalData->Length = sizeof(CONTEXT);
    BdCopyMemory(AdditionalData->Buffer, (PCHAR)Context, sizeof(CONTEXT));

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 AdditionalData);

    return;
}

VOID
BdSetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a set context state
    manipulation message.  Its function is set the current
    context.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_SET_CONTEXT a = &m->u.SetContext;
    STRING MessageHeader;

    m->ReturnStatus = STATUS_SUCCESS;
    BdCopyMemory((PCHAR)Context, AdditionalData->Buffer, sizeof(CONTEXT));

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);
}

VOID
BdReadVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response to a read virtual memory 32-bit
    state manipulation message. Its function is to read virtual memory
    and return.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies a pointer to a descriptor for the data to read.

    Context - Supplies a pointer to the current context.

Return Value:

    None.

--*/

{

    ULONG Length;
    STRING MessageHeader;

    //
    // Trim the transfer count to fit in a single message.
    //

    Length = min(m->u.ReadMemory.TransferCount,
                 PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64));

    //
    // Move the data to the destination buffer.
    //

    AdditionalData->Length = (USHORT)BdMoveMemory((PCHAR)AdditionalData->Buffer,
                                                  (PCHAR)m->u.ReadMemory.TargetBaseAddress,
                                                  Length);

    //
    // If all the data is read, then return a success status. Otherwise,
    // return an unsuccessful status.
    //

    m->ReturnStatus = STATUS_SUCCESS;
    if (Length != AdditionalData->Length) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // Set the actual number of bytes read, initialize the message header,
    // and send the reply packet to the host debugger.
    //

    m->u.ReadMemory.ActualBytesRead = AdditionalData->Length;
    MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  AdditionalData);

    return;
}

VOID
BdWriteVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write virtual memory 32-bit
    state manipulation message. Its function is to write virtual memory
    and return.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies a pointer to a descriptor for the data to write.

    Context - Supplies a pointer to the current context.

Return Value:

    None.

--*/

{

    ULONG Length;
    STRING MessageHeader;

    //
    // Move the data to the destination buffer.
    //

    Length = BdMoveMemory((PCHAR)m->u.WriteMemory.TargetBaseAddress,
                          (PCHAR)AdditionalData->Buffer,
                          AdditionalData->Length);

    //
    // If all the data is written, then return a success status. Otherwise,
    // return an unsuccessful status.
    //

    m->ReturnStatus = STATUS_SUCCESS;
    if (Length != AdditionalData->Length) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // Set the actual number of bytes written, initialize the message header,
    // and send the reply packet to the host debugger.
    //

    m->u.WriteMemory.ActualBytesWritten = Length;
    MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}

VOID
BdWriteBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write breakpoint state
    manipulation message.  Its function is to write a breakpoint
    and return a handle to the breakpoint.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_WRITE_BREAKPOINT64 a = &m->u.WriteBreakPoint;
    STRING MessageHeader;


    a->BreakPointHandle = BdAddBreakpoint(a->BreakPointAddress);
    if (a->BreakPointHandle != 0) {
        m->ReturnStatus = STATUS_SUCCESS;

    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}

VOID
BdRestoreBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a restore breakpoint state
    manipulation message.  Its function is to restore a breakpoint
    using the specified handle.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_RESTORE_BREAKPOINT a = &m->u.RestoreBreakPoint;
    STRING MessageHeader;

    if (BdDeleteBreakpoint(a->BreakPointHandle)) {
        m->ReturnStatus = STATUS_SUCCESS;

    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);
}

VOID
BdReadPhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response to a read physical memory
    state manipulation message. Its function is to read physical memory
    and return.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_READ_MEMORY64 a = &m->u.ReadMemory;
    ULONG Length;
    STRING MessageHeader;
    PVOID VirtualAddress;
    PHYSICAL_ADDRESS Source;
    PUCHAR Destination;
    USHORT NumberBytes;
    USHORT BytesLeft;

    //
    // Trim transfer count to fit in a single message.
    //

    Length = min(a->TransferCount,
                 PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64));

    //
    // Since the BdTranslatePhysicalAddress only maps in one physical
    // page at a time, we need to break the memory move up into smaller
    // moves which don't cross page boundaries.  There are two cases we
    // need to deal with.  The area to be moved may start and end on the
    // same page, or it may start and end on different pages (with an
    // arbitrary number of pages in between)
    //

    Source.QuadPart = (ULONG_PTR)a->TargetBaseAddress;
    Destination = AdditionalData->Buffer;
    BytesLeft = (USHORT)Length;
    if(PAGE_ALIGN((PUCHAR)a->TargetBaseAddress) ==
       PAGE_ALIGN((PUCHAR)(a->TargetBaseAddress)+Length)) {

        //
        // Memory move starts and ends on the same page.
        //

        VirtualAddress=BdTranslatePhysicalAddress(Source);
        if (VirtualAddress == NULL) {
            AdditionalData->Length = 0;

        } else {
            AdditionalData->Length = (USHORT)BdMoveMemory(Destination,
                                                          VirtualAddress,
                                                          BytesLeft);

            BytesLeft -= AdditionalData->Length;
        }

    } else {

        //
        // Memory move spans page boundaries
        //

        VirtualAddress=BdTranslatePhysicalAddress(Source);
        if (VirtualAddress == NULL) {
            AdditionalData->Length = 0;

        } else {
            NumberBytes = (USHORT)(PAGE_SIZE - BYTE_OFFSET(VirtualAddress));
            AdditionalData->Length = (USHORT)BdMoveMemory(Destination,
                                                          VirtualAddress,
                                                          NumberBytes);

            Source.LowPart += NumberBytes;
            Destination += NumberBytes;
            BytesLeft -= NumberBytes;
            while(BytesLeft > 0) {

                //
                // Transfer a full page or the last bit,
                // whichever is smaller.
                //

                VirtualAddress = BdTranslatePhysicalAddress(Source);
                if (VirtualAddress == NULL) {
                    break;

                } else {
                    NumberBytes = (USHORT) ((PAGE_SIZE < BytesLeft) ? PAGE_SIZE : BytesLeft);
                    AdditionalData->Length += (USHORT)BdMoveMemory(
                                                    Destination,
                                                    VirtualAddress,
                                                    NumberBytes);

                    Source.LowPart += NumberBytes;
                    Destination += NumberBytes;
                    BytesLeft -= NumberBytes;
                }
            }
        }
    }

    if (Length == AdditionalData->Length) {
        m->ReturnStatus = STATUS_SUCCESS;

    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    a->ActualBytesRead = AdditionalData->Length;

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 AdditionalData);

    return;
}

VOID
BdWritePhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response to a write physical memory
    state manipulation message. Its function is to write physical memory
    and return.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_WRITE_MEMORY64 a = &m->u.WriteMemory;
    ULONG Length;
    STRING MessageHeader;
    PVOID VirtualAddress;
    PHYSICAL_ADDRESS Destination;
    PUCHAR Source;
    USHORT NumberBytes;
    USHORT BytesLeft;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // Since the BdTranslatePhysicalAddress only maps in one physical
    // page at a time, we need to break the memory move up into smaller
    // moves which don't cross page boundaries.  There are two cases we
    // need to deal with.  The area to be moved may start and end on the
    // same page, or it may start and end on different pages (with an
    // arbitrary number of pages in between)
    //

    Destination.QuadPart = (ULONG_PTR)a->TargetBaseAddress;
    Source = AdditionalData->Buffer;
    BytesLeft = (USHORT) a->TransferCount;
    if(PAGE_ALIGN(Destination.QuadPart) ==
       PAGE_ALIGN(Destination.QuadPart+BytesLeft)) {

        //
        // Memory move starts and ends on the same page.
        //

        VirtualAddress=BdTranslatePhysicalAddress(Destination);
        Length = (USHORT)BdMoveMemory(VirtualAddress,
                                      Source,
                                      BytesLeft);

        BytesLeft -= (USHORT) Length;

    } else {

        //
        // Memory move spans page boundaries
        //

        VirtualAddress=BdTranslatePhysicalAddress(Destination);
        NumberBytes = (USHORT) (PAGE_SIZE - BYTE_OFFSET(VirtualAddress));
        Length = (USHORT)BdMoveMemory(VirtualAddress,
                                      Source,
                                      NumberBytes);

        Source += NumberBytes;
        Destination.LowPart += NumberBytes;
        BytesLeft -= NumberBytes;
        while(BytesLeft > 0) {

            //
            // Transfer a full page or the last bit, whichever is smaller.
            //

            VirtualAddress = BdTranslatePhysicalAddress(Destination);
            NumberBytes = (USHORT) ((PAGE_SIZE < BytesLeft) ? PAGE_SIZE : BytesLeft);
            Length += (USHORT)BdMoveMemory(VirtualAddress,
                                           Source,
                                           NumberBytes);

            Source += NumberBytes;
            Destination.LowPart += NumberBytes;
            BytesLeft -= NumberBytes;
        }
    }


    if (Length == AdditionalData->Length) {
        m->ReturnStatus = STATUS_SUCCESS;

    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    a->ActualBytesWritten = Length;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}

NTSTATUS
BdWriteBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a write breakpoint state 'ex'
    manipulation message.  Its function is to clear breakpoints, write
    new breakpoints, and continue the target system.  The clearing of
    breakpoints is conditional based on the presence of breakpoint handles.
    The setting of breakpoints is conditional based on the presence of
    valid, non-zero, addresses.  The continueing of the target system
    is conditional based on a non-zero continuestatus.

    This api allows a debugger to clear breakpoints, add new breakpoint,
    and continue the target system all in one api packet.  This reduces the
    amount of traffic across the wire and greatly improves source stepping.


Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_BREAKPOINTEX         a = &m->u.BreakPointEx;
    PDBGKD_WRITE_BREAKPOINT64   b;
    STRING                      MessageHeader;
    ULONG                       i;
    DBGKD_WRITE_BREAKPOINT64    BpBuf[BREAKPOINT_TABLE_SIZE];


    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // verify that the packet size is correct
    //

    if (AdditionalData->Length !=
                         a->BreakPointCount*sizeof(DBGKD_WRITE_BREAKPOINT64)) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        BdSendPacket(
                      PACKET_TYPE_KD_STATE_MANIPULATE,
                      &MessageHeader,
                      AdditionalData
                      );
        return m->ReturnStatus;
    }

    BdMoveMemory((PUCHAR)BpBuf,
                  AdditionalData->Buffer,
                  a->BreakPointCount*sizeof(DBGKD_WRITE_BREAKPOINT64));

    //
    // assume success
    //
    m->ReturnStatus = STATUS_SUCCESS;

    //
    // loop thru the breakpoint handles passed in from the debugger and
    // clear any breakpoint that has a non-zero handle
    //

    b = BpBuf;
    for (i=0; i<a->BreakPointCount; i++,b++) {
        if (b->BreakPointHandle) {
            if (!BdDeleteBreakpoint(b->BreakPointHandle)) {
                m->ReturnStatus = STATUS_UNSUCCESSFUL;
            }

            b->BreakPointHandle = 0;
        }
    }

    //
    // loop thru the breakpoint addesses passed in from the debugger and
    // add any new breakpoints that have a non-zero address
    //

    b = BpBuf;
    for (i=0; i<a->BreakPointCount; i++,b++) {
        if (b->BreakPointAddress) {
            b->BreakPointHandle = BdAddBreakpoint( b->BreakPointAddress );
            if (!b->BreakPointHandle) {
                m->ReturnStatus = STATUS_UNSUCCESSFUL;
            }
        }
    }

    //
    // send back our response
    //

    BdMoveMemory(AdditionalData->Buffer,
                 (PUCHAR)BpBuf,
                 a->BreakPointCount*sizeof(DBGKD_WRITE_BREAKPOINT64));

    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 AdditionalData);

    //
    // return the caller's continue status value.  if this is a non-zero
    // value the system is continued using this value as the continuestatus.
    //

    return a->ContinueStatus;
}

VOID
BdRestoreBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a restore breakpoint state 'ex'
    manipulation message.  Its function is to clear a list of breakpoints.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_BREAKPOINTEX       a = &m->u.BreakPointEx;
    PDBGKD_RESTORE_BREAKPOINT b;
    STRING                    MessageHeader;
    ULONG                     i;
    DBGKD_RESTORE_BREAKPOINT  BpBuf[BREAKPOINT_TABLE_SIZE];


    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // verify that the packet size is correct
    //

    if (AdditionalData->Length !=
                       a->BreakPointCount*sizeof(DBGKD_RESTORE_BREAKPOINT)) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                     &MessageHeader,
                     AdditionalData);

        return;
    }

    BdMoveMemory((PUCHAR)BpBuf,
                  AdditionalData->Buffer,
                  a->BreakPointCount*sizeof(DBGKD_RESTORE_BREAKPOINT));

    //
    // assume success
    //

    m->ReturnStatus = STATUS_SUCCESS;

    //
    // loop thru the breakpoint handles passed in from the debugger and
    // clear any breakpoint that has a non-zero handle
    //

    b = BpBuf;
    for (i=0; i<a->BreakPointCount; i++,b++) {
        if (!BdDeleteBreakpoint(b->BreakPointHandle)) {
            m->ReturnStatus = STATUS_UNSUCCESSFUL;
        }
    }

    //
    // send back our response
    //

    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 AdditionalData);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\i386\port.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This modules implements com port code to support the boot debugger.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

--*/

#include "bd.h"

_TUCHAR DebugMessage[80];

LOGICAL
BdPortInitialize(
    IN ULONG BaudRate,
    IN ULONG PortNumber,
    OUT PULONG BdFileId
    )

/*++

Routine Description:

    This functions initializes the boot debugger com port.

Arguments:

    BaudRate - Supplies an optional baud rate.

    PortNumber - supplies an optinal port number.

Returned Value:

    TRUE - If a debug port is found.

--*/

{
    //
    // Initialize the specified port.
    //
    if (!BlPortInitialize(BaudRate, PortNumber, NULL, FALSE, BdFileId)) {
        return FALSE;
    }
    _stprintf(DebugMessage,
            TEXT("\nBoot Debugger Using: COM%d (Baud Rate %d)\n"),
            PortNumber,
            BaudRate);

    //
    // We cannot use BlPrint() at this time because BlInitStdIo() has not been called, which is
    // required to use the Arc emulator code.
    //    
    TextStringOut(DebugMessage);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\i386\debug.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bdtrap.c

Abstract:

    This module contains code to implement the target side of the boot debugger.

Author:

    David N. Cutler (davec) 30-Nov-96

Revision History:

--*/

#include "bd.h"

//
// Define forward referenced function prototypes.
//

VOID
BdRestoreKframe(
    IN OUT PKTRAP_FRAME TrapFrame,
    IN PCONTEXT ContextRecord
    );

VOID
BdSaveKframe(
    IN PKTRAP_FRAME TrapFrame,
    IN OUT PCONTEXT ContextRecord
    );

LOGICAL
BdTrap (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine is called whenever a exception is dispatched and the boot
    debugger is active.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ExceptionFrame - Supplies a pointer to an exception frame (NULL).

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{

    LOGICAL Completion;
    PCONTEXT ContextRecord;
    ULONG OldEip;
    STRING Input;
    STRING Output;
    PKD_SYMBOLS_INFO SymbolInfo;
    LOGICAL UnloadSymbols;

    //
    // Set address of context record and set context flags.
    //

    ContextRecord = &BdPrcb.ProcessorState.ContextFrame;
    ContextRecord->ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;

    //
    // Print, prompt, load symbols, and unload symbols are all special cases
    // of STATUS_BREAKPOINT.
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->ExceptionInformation[0] != BREAKPOINT_BREAK)) {

        //
        // Switch on the request type.
        //

        UnloadSymbols = FALSE;
        switch (ExceptionRecord->ExceptionInformation[0]) {

            //
            // Print:
            //
            //  ExceptionInformation[1] is a PSTRING which describes the string
            //  to print.
            //

            case BREAKPOINT_PRINT:
                Output.Buffer = (PCHAR)ExceptionRecord->ExceptionInformation[1];
                Output.Length = (USHORT)ExceptionRecord->ExceptionInformation[2];
                if (BdDebuggerNotPresent == FALSE) {
                    if (BdPrintString(&Output)) {
                        TrapFrame->Eax = (ULONG)(STATUS_BREAKPOINT);

                    } else {
                        TrapFrame->Eax = STATUS_SUCCESS;
                    }

                } else {
                    TrapFrame->Eax = (ULONG)STATUS_DEVICE_NOT_CONNECTED;
                }

                TrapFrame->Eip += 1;
                return TRUE;

            //
            // Prompt:
            //
            //  ExceptionInformation[1] is a PSTRING which describes the prompt
            //      string,
            //
            //  ExceptionInformation[2] is a PSTRING that describes the return
            //      string.
            //

            case BREAKPOINT_PROMPT:
                Output.Buffer = (PCHAR)ExceptionRecord->ExceptionInformation[1];
                Output.Length = (USHORT)ExceptionRecord->ExceptionInformation[2];
                Input.Buffer = (PCHAR)TrapFrame->Ebx;;
                Input.MaximumLength = (USHORT)TrapFrame->Edi;

                //
                // Prompt and keep prompting until no breakin seen.
                //

                do {
                } while (BdPromptString(&Output, &Input) != FALSE);

                TrapFrame->Eax = Input.Length;
                TrapFrame->Eip += 1;
                return TRUE;

            //
            // Unload symbols:
            //
            //  ExceptionInformation[1] is file name of a module.
            //  ExceptionInformaiton[2] is the base of the dll.
            //

            case BREAKPOINT_UNLOAD_SYMBOLS:
                UnloadSymbols = TRUE;

                //
                // Fall through to load symbols case.
                //

            case BREAKPOINT_LOAD_SYMBOLS:
                BdSaveKframe(TrapFrame, ContextRecord);
                OldEip = ContextRecord->Eip;
                SymbolInfo = (PKD_SYMBOLS_INFO)ExceptionRecord->ExceptionInformation[2];
                if (BdDebuggerNotPresent == FALSE) {
                    BdReportLoadSymbolsStateChange((PSTRING)ExceptionRecord->ExceptionInformation[1],
                                                   SymbolInfo,
                                                   UnloadSymbols,
                                                   ContextRecord);
                }

                //
                // If the kernel debugger did not update EIP, then increment
                // past the breakpoint instruction.
                //

                if (ContextRecord->Eip == OldEip) {
                    ContextRecord->Eip += 1;
                }

                BdRestoreKframe(TrapFrame, ContextRecord);
                return TRUE;

            //
            //  Unknown command
            //

            default:
                return FALSE;
        }

    } else {

        //
        // Report state change to kernel debugger on host.
        //

        BdSaveKframe(TrapFrame, ContextRecord);
        Completion =
            BdReportExceptionStateChange(ExceptionRecord,
                                         &BdPrcb.ProcessorState.ContextFrame);

        BdRestoreKframe(TrapFrame, ContextRecord);
        BdControlCPressed = FALSE;
        return TRUE;
    }
}

LOGICAL
BdStub (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine provides a kernel debugger stub routine to catch debug
    prints when the boot debugger is not active.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ExceptionFrame - Supplies a pointer to an exception frame (NULL).

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{

    //
    // If the exception is a breakpoint and the function is a load symbols,
    // unload symbols, or a print, then return TRUE. Otherwise, return FALSE.
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->NumberParameters > 0) &&
        ((ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_LOAD_SYMBOLS) ||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_UNLOAD_SYMBOLS) ||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_PRINT))) {
        TrapFrame->Eip += 1;
        return TRUE;

    } else {
        return FALSE;

    }
}

VOID
BdRestoreKframe(
    IN OUT PKTRAP_FRAME TrapFrame,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This functions copie the processor state from a context record and
    the processor control block into the trap frame.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{

    //
    // Copy information from context record to trap frame.
    //
    // Copy control information.
    //

    TrapFrame->Ebp = ContextRecord->Ebp;
    TrapFrame->Eip = ContextRecord->Eip;
    TrapFrame->SegCs = ContextRecord->SegCs;
    TrapFrame->EFlags = ContextRecord->EFlags;

    //
    // Copy segment register contents.
    //

    TrapFrame->SegDs = ContextRecord->SegDs;
    TrapFrame->SegEs = ContextRecord->SegEs;
    TrapFrame->SegFs = ContextRecord->SegFs;
    TrapFrame->SegGs = ContextRecord->SegGs;

    //
    // Copy integer registers contents.
    //

    TrapFrame->Edi = ContextRecord->Edi;
    TrapFrame->Esi = ContextRecord->Esi;
    TrapFrame->Ebx = ContextRecord->Ebx;
    TrapFrame->Ecx = ContextRecord->Ecx;
    TrapFrame->Edx = ContextRecord->Edx;
    TrapFrame->Eax = ContextRecord->Eax;

    //
    // Restore processor state.
    //

    KiRestoreProcessorControlState(&BdPrcb.ProcessorState);
    return;
}

VOID
BdSaveKframe(
    IN PKTRAP_FRAME TrapFrame,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This functions copis the processor state from a trap frame and the
    processor control block into a context record.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{

    //
    // Copy information from trap frame to context record.
    //
    // Copy control information.
    //

    ContextRecord->Ebp = TrapFrame->Ebp;
    ContextRecord->Eip = TrapFrame->Eip;
    ContextRecord->SegCs = TrapFrame->SegCs & SEGMENT_MASK;
    ContextRecord->EFlags = TrapFrame->EFlags;
    ContextRecord->Esp = TrapFrame->TempEsp;
    ContextRecord->SegSs = TrapFrame->TempSegCs;

    //
    // Copy segment register contents.
    //

    ContextRecord->SegDs = TrapFrame->SegDs & SEGMENT_MASK;
    ContextRecord->SegEs = TrapFrame->SegEs & SEGMENT_MASK;
    ContextRecord->SegFs = TrapFrame->SegFs & SEGMENT_MASK;
    ContextRecord->SegGs = TrapFrame->SegGs & SEGMENT_MASK;

    //
    // Copy the integer register contents.
    //

    ContextRecord->Eax = TrapFrame->Eax;
    ContextRecord->Ebx = TrapFrame->Ebx;
    ContextRecord->Ecx = TrapFrame->Ecx;
    ContextRecord->Edx = TrapFrame->Edx;
    ContextRecord->Edi = TrapFrame->Edi;
    ContextRecord->Esi = TrapFrame->Esi;

    //
    // Copy debug register contents.
    //

    ContextRecord->Dr0 = TrapFrame->Dr0;
    ContextRecord->Dr1 = TrapFrame->Dr1;
    ContextRecord->Dr2 = TrapFrame->Dr2;
    ContextRecord->Dr3 = TrapFrame->Dr3;
    ContextRecord->Dr6 = TrapFrame->Dr6;
    ContextRecord->Dr7 = TrapFrame->Dr7;

    //
    // Save processor control state.
    //

    KiSaveProcessorControlState(&BdPrcb.ProcessorState);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\i386\print.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    print.c

Abstract:

    This modules implements debug prints.

Author:

    David N. Cutler (davec) 30-Nov-96

Revision History:

--*/

#include "bd.h"

VOID
BdPrintf(
    IN PCHAR Format,
    ...
    )

/*++

Routine Description:

    Printf routine for the debugger that is safer than DbgPrint.  Calls
    the packet driver instead of reentering the debugger.

Arguments:

    Format - Supplies a pointer to a format string.

Return Value:

    None

--*/

{

    CHAR Buffer[100];
    va_list mark;
    STRING String;

    va_start(mark, Format);
    _vsnprintf(&Buffer[0], 100, Format, mark);
    va_end(mark);

    BlPrint(TEXT("%s"), &Buffer[0]);
    String.Buffer = &Buffer[0];
    String.Length = (USHORT) strlen(&Buffer[0]);
    BdPrintString(&String);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\ia64\check.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This module implements memory check routine for the boot debugger.

Author:

    David N. Cutler (davec) 3-Dec-96

Environment:

    Kernel mode only.

Revision History:

--*/

#include "bd.h"

extern BOOLEAN PaeEnabled;



BOOLEAN
BdCheckPdeValid (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine determines if the PDE for the specified address has the
    valid bit set.

Agruments:

    Address - Supplies the virtual address to check.

Return Value:

    A value of TRUE indicates that the PDE for the supplied virtual address
    does have the valid bit set, FALSE if it does not.

--*/

{
    return FALSE;
}

BOOLEAN
BdCheckPteValid (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine determines if the PTE for the specified address has the
    valid bit set.

Agruments:

    Address - Supplies the virtual address to check.

Return Value:

    A value of TRUE indicates that the PTE for the supplied virtual address
    does have the valid bit set, FALSE if it does not.

--*/

{
    return FALSE;
}


PVOID
BdReadCheck (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine determines if the specified address can be read.

Arguments:

    Address - Supplies the virtual address to check.

Return Value:

    A value of NULL is returned if the address is not valid or readable.
    Otherwise, the physical address of the corresponding virtual address
    is returned.

--*/

{
    return Address;
}

PVOID
BdWriteCheck (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine determines if the specified address can be written.

Arguments:

    Address - Supplies the virtual address to check.

Return Value:

    A value of NULL is returned if the address is not valid or writeable.
    Otherwise, the physical address of the corresponding virtual address
    is returned.

--*/

{
    return Address;
}

PVOID
BdTranslatePhysicalAddress (
    IN PHYSICAL_ADDRESS Address
    )

/*++

Routine Description:

    This routine returns the phyiscal address for a physical address
    which is valid (mapped).

Arguments:

    Address - Supplies the physical address to check.

Return Value:

    Returns NULL if the address is not valid or readable. Otherwise,
    returns the physical address of the corresponding virtual address.

--*/

{
    return (PVOID)UlongToPtr(Address.LowPart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\i386\reboot.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    bdreboot.c

Abstract:

    System reboot function.  Currently part of the debugger because
    that's the only place it's used.

Author:

    Bryan M. Willman (bryanwi) 4-Dec-90

Revision History:

--*/

#include "bd.h"

VOID
FwStallExecution(
    IN ULONG Microseconds
    );


#define CMOS_CTRL   (PUCHAR )0x70
#define CMOS_DATA   (PUCHAR )0x71

#define RESET       0xfe
#define KEYBPORT    (PUCHAR )0x64


VOID
HalpReboot (
    VOID
    )

/*++

Routine Description:

    This procedure resets the CMOS clock to the standard timer settings
    so the bios will work, and then issues a reset command to the keyboard
    to cause a warm boot.

    It is very machine dependent, this implementation is intended for
    PC-AT like machines.

    This code copied from the "old debugger" sources.

    N.B.

        Will NOT return.

--*/

{
    UCHAR   Scratch;
    PUSHORT   Magic;

    //
    // Turn off interrupts
    //

    _asm {
        cli
    }

    //
    // Reset the cmos clock to a standard value
    // (We are setting the periodic interrupt control on the MC147818)
    //

    //
    // Disable periodic interrupt
    //

    WRITE_PORT_UCHAR(CMOS_CTRL, 0x0b);      // Set up for control reg B.
    FwStallExecution(1);

    Scratch = READ_PORT_UCHAR(CMOS_DATA);
    FwStallExecution(1);

    Scratch &= 0xbf;                        // Clear periodic interrupt enable

    WRITE_PORT_UCHAR(CMOS_DATA, Scratch);
    FwStallExecution(1);

    //
    // Set "standard" divider rate
    //

    WRITE_PORT_UCHAR(CMOS_CTRL, 0x0a);      // Set up for control reg A.
    FwStallExecution(1);

    Scratch = READ_PORT_UCHAR(CMOS_DATA);
    FwStallExecution(1);

    Scratch &= 0xf0;                        // Clear rate setting
    Scratch |= 6;                           // Set default rate and divider

    WRITE_PORT_UCHAR(CMOS_DATA, Scratch);
    FwStallExecution(1);

    //
    // Set a "neutral" cmos address to prevent weirdness
    // (Why is this needed? Source this was copied from doesn't say)
    //

    WRITE_PORT_UCHAR(CMOS_CTRL, 0x15);
    FwStallExecution(1);

    //
    // If we return, send the reset command to the keyboard controller
    //

    WRITE_PORT_UCHAR(KEYBPORT, RESET);

    _asm {
        hlt
    }
}


VOID
BdReboot (
    VOID
    )

/*++

Routine Description:

    Just calls the HalReturnToFirmware function.

Arguments:

    None

Return Value:

    Does not return

--*/

{
    //
    // Never returns from HAL
    //

    HalpReboot();

    while (TRUE) {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\ia64\cpu.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bdcpu.h

Abstract:

    Machine specific kernel debugger data types and constants.

Author:

    Scott Brenden (v-sbrend) 28 October, 1997

Revision History:

--*/

#ifndef _BDCPU_
#define _BDCPU_
#include "bldria64.h"

//
// Define debug routine prototypes.
//

typedef
LOGICAL
(*PBD_DEBUG_ROUTINE) (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

LOGICAL
BdTrap (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

LOGICAL
BdStub (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

#define BD_BREAKPOINT_TYPE  ULONGLONG
#define BD_BREAKPOINT_ALIGN 0x3
#define BD_BREAKPOINT_VALUE (BREAK_INSTR | (BREAKPOINT_STOP << 6))
#define BD_BREAKPOINT_STATE_MASK    0x0000000f
#define BD_BREAKPOINT_IA64_MASK     0x000f0000
#define BD_BREAKPOINT_IA64_MODE     0x00010000   // IA64 mode
#define BD_BREAKPOINT_IA64_MOVL     0x00020000   // MOVL instruction displaced

VOID
BdIa64Init(
    );

BOOLEAN
BdSuspendBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    );

BOOLEAN
BdRestoreBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    );

LOGICAL
BdLowRestoreBreakpoint (
    IN ULONG Index
    );

#endif // _BDCPU_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\i386\state.asm ===
title  "Processor State Save Restore"
;++
;
; Copyright (c) 1996  Microsoft Corporation
;
; Module Name:
;
;    procstat.asm
;
; Abstract:
;
;    This module implements procedures for saving and restoring
;    processor control state.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 30-Aug-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.486p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
        .list

        page ,132
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page    ,132
        subttl  "Save Processor Control State"
;++
;
; KiSaveProcessorControlState(
;    PKPROCESSOR_STATE ProcessorState
;    );
;
; Routine Description:
;
;    This routine saves the control subset of the processor state.
;    (Saves the same information as KiSaveProcessorState EXCEPT that
;     data in TrapFrame/ExceptionFrame=Context record is NOT saved.)
;    Called by the debug subsystem, and KiSaveProcessorState()
;
;   N.B.  This procedure will save Dr7, and then 0 it.  This prevents
;         recursive hardware trace breakpoints and allows debuggers
;         to work.
;
; Arguments:
;
;    ProcessorState - Supplies the address of the processor state.

; Return Value:
;
;    None.
;
;--

cPublicProc _KiSaveProcessorControlState   ,1

        mov     edx, [esp+4]            ; get processor state address

;
; Save special registers for debugger
;
        xor     ecx,ecx

        mov     eax, cr0
        mov     [edx].PsSpecialRegisters.SrCr0, eax
        mov     eax, cr2
        mov     [edx].PsSpecialRegisters.SrCr2, eax
        mov     eax, cr3
        mov     [edx].PsSpecialRegisters.SrCr3, eax

        mov     [edx].PsSpecialRegisters.SrCr4, ecx

        mov     eax,dr0
        mov     [edx].PsSpecialRegisters.SrKernelDr0,eax
        mov     eax,dr1
        mov     [edx].PsSpecialRegisters.SrKernelDr1,eax
        mov     eax,dr2
        mov     [edx].PsSpecialRegisters.SrKernelDr2,eax
        mov     eax,dr3
        mov     [edx].PsSpecialRegisters.SrKernelDr3,eax
        mov     eax,dr6
        mov     [edx].PsSpecialRegisters.SrKernelDr6,eax

        mov     eax,dr7
        mov     dr7,ecx
        mov     [edx].PsSpecialRegisters.SrKernelDr7,eax

        sgdt    fword ptr [edx].PsSpecialRegisters.SrGdtr
        sidt    fword ptr [edx].PsSpecialRegisters.SrIdtr

        str     word ptr [edx].PsSpecialRegisters.SrTr
        sldt    word ptr [edx].PsSpecialRegisters.SrLdtr

        stdRET    _KiSaveProcessorControlState

stdENDP _KiSaveProcessorControlState

        page    ,132
        subttl  "Restore Processor Control State"
;++
;
; KiRestoreProcessorControlState(
;    PKPROCESSOR_STATE ProcessorState
;    );
;
; Routine Description:
;
;    This routine restores the control subset of the processor state.
;    (Restores the same information as KiRestoreProcessorState EXCEPT that
;     data in TrapFrame/ExceptionFrame=Context record is NOT restored.)
;    Called by the debug subsystem, and KiRestoreProcessorState()
;
; Arguments:
;
;    ProcessorState - Supplies the address of the processor state.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiRestoreProcessorControlState,1

        mov     edx, [esp+4]                    ; (edx)->ProcessorState

;
; Restore special registers for debugger
;

        mov     eax, [edx].PsSpecialRegisters.SrCr0
        mov     cr0, eax
        mov     eax, [edx].PsSpecialRegisters.SrCr2
        mov     cr2, eax
        mov     eax, [edx].PsSpecialRegisters.SrCr3
        mov     cr3, eax

        mov     eax, [edx].PsSpecialRegisters.SrKernelDr0
        mov     dr0, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr1
        mov     dr1, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr2
        mov     dr2, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr3
        mov     dr3, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr6
        mov     dr6, eax
        mov     eax, [edx].PsSpecialRegisters.SrKernelDr7
        mov     dr7, eax

        lgdt    fword ptr [edx].PsSpecialRegisters.SrGdtr
        lidt    fword ptr [edx].PsSpecialRegisters.SrIdtr

        lldt    word ptr [edx].PsSpecialRegisters.SrLdtr

        stdRET    _KiRestoreProcessorControlState

stdENDP _KiRestoreProcessorControlState

_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\ia64\debug.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bdtrap.c

Abstract:

    This module contains code to implement the target side of the boot debugger.

Author:

    David N. Cutler (davec) 30-Nov-96

Revision History:

--*/

#include "bd.h"


#define ALIGN_NATS(Result, Source, Start, AddressOffset, Mask)    \
    if (AddressOffset == Start) {                                       \
        Result = (ULONGLONG)Source;                                     \
    } else if (AddressOffset < Start) {                                 \
        Result = (ULONGLONG)(Source << (Start - AddressOffset));        \
    } else {                                                            \
        Result = (ULONGLONG)((Source >> (AddressOffset - Start)) |      \
                             (Source << (64 + Start - AddressOffset))); \
    }                                                                   \
    Result = Result & (ULONGLONG)Mask

#define EXTRACT_NATS(Result, Source, Start, AddressOffset, Mask)        \
    Result = (ULONGLONG)(Source & (ULONGLONG)Mask);                     \
    if (AddressOffset < Start) {                                        \
        Result = Result >> (Start - AddressOffset);                     \
    } else if (AddressOffset > Start) {                                 \
        Result = ((Result << (AddressOffset - Start)) |                 \
                  (Result >> (64 + Start - AddressOffset)));            \
    }

//
// Define forward referenced function prototypes.
//

VOID
BdRestoreKframe(
    IN OUT PKTRAP_FRAME TrapFrame,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN PCONTEXT ContextRecord
    );

VOID
BdSaveKframe(
    IN OUT PKTRAP_FRAME TrapFrame,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    OUT PCONTEXT ContextRecord
    );

LOGICAL
BdEnterDebugger(
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )
{
    return FALSE;
}

VOID
BdExitDebugger(
    IN LOGICAL Enable
    )
{
}


VOID
BdGetDebugContext (
    IN PKTRAP_FRAME TrapFrame,
    IN OUT PCONTEXT ContextFrame
    )

/*++

Routine Description:

    This routine moves the user mode h/w debug registers from the debug register
    save area in the kernel stack to the context record.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    ContextFrame - Supplies a pointer to the context frame that receives the
        context.

Return Value:

    None.

Note:
    
    PSR.db must be set to activate the debug registers.

    This is used for getting user mode debug registers.

--*/

{
    PKDEBUG_REGISTERS DebugRegistersSaveArea;

    if (TrapFrame->PreviousMode == UserMode) {
        DebugRegistersSaveArea = GET_DEBUG_REGISTER_SAVEAREA();

        BdCopyMemory((PVOID)&ContextFrame->DbI0, 
                     (PVOID)DebugRegistersSaveArea,
                     sizeof(KDEBUG_REGISTERS));
    }
}

VOID
BdSetDebugContext (
    IN OUT PKTRAP_FRAME TrapFrame,
    IN PCONTEXT ContextFrame,
    IN KPROCESSOR_MODE PreviousMode
    )
/*++

Routine Description:

    This routine moves the debug context from the specified context frame into
    the debug registers save area in the kernel stack.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ContextFrame - Supplies a pointer to a context frame that contains the
        context that is to be copied.

    PreviousMode - Supplies the processor mode for the target context.

Return Value:

    None.

Notes:

   PSR.db must be set to activate the debug registers.
   
   This is used for setting up debug registers for user mode.

--*/

{
    PKDEBUG_REGISTERS DebugRegistersSaveArea;  // User mode h/w debug registers

    if (PreviousMode == UserMode) {

        DebugRegistersSaveArea = GET_DEBUG_REGISTER_SAVEAREA();

        //
        // Sanitize the debug control regs. Leave the addresses unchanged.
        //

        DebugRegistersSaveArea->DbI0 = ContextFrame->DbI0;
        DebugRegistersSaveArea->DbI1 = SANITIZE_DR(ContextFrame->DbI1,UserMode);
        DebugRegistersSaveArea->DbI2 = ContextFrame->DbI2;
        DebugRegistersSaveArea->DbI3 = SANITIZE_DR(ContextFrame->DbI3,UserMode);
        DebugRegistersSaveArea->DbI4 = ContextFrame->DbI4;
        DebugRegistersSaveArea->DbI5 = SANITIZE_DR(ContextFrame->DbI5,UserMode);
        DebugRegistersSaveArea->DbI6 = ContextFrame->DbI6;
        DebugRegistersSaveArea->DbI7 = SANITIZE_DR(ContextFrame->DbI7,UserMode);

        DebugRegistersSaveArea->DbD0 = ContextFrame->DbD0;
        DebugRegistersSaveArea->DbD1 = SANITIZE_DR(ContextFrame->DbD1,UserMode);
        DebugRegistersSaveArea->DbD2 = ContextFrame->DbD2;
        DebugRegistersSaveArea->DbD3 = SANITIZE_DR(ContextFrame->DbD3,UserMode);
        DebugRegistersSaveArea->DbD4 = ContextFrame->DbD4;
        DebugRegistersSaveArea->DbD5 = SANITIZE_DR(ContextFrame->DbD5,UserMode);
        DebugRegistersSaveArea->DbD6 = ContextFrame->DbD6;
        DebugRegistersSaveArea->DbD7 = SANITIZE_DR(ContextFrame->DbD7,UserMode);

    }
}


LOGICAL
BdTrap (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine is called whenever a exception is dispatched and the boot
    debugger is active.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ExceptionFrame - Supplies a pointer to an exception frame (NULL).

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{

    LOGICAL Completion;
    PCONTEXT ContextRecord;
    ULONG OldEip;
    STRING Reply;
    STRING String;
    PKD_SYMBOLS_INFO SymbolInfo;
    LOGICAL UnloadSymbols;

    LOGICAL Enable;
    ULONGLONG OldStIIP, OldStIPSR;
    STRING Input;
    STRING Output;

    //
    // Set address of context record and set context flags.
    //

    ContextRecord = &BdPrcb.ProcessorState.ContextFrame;
    ContextRecord->ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG;

    BdSaveKframe(TrapFrame, ExceptionFrame, ContextRecord);

    //
    // Print, prompt, load symbols, and unload symbols are all special cases
    // of STATUS_BREAKPOINT.
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->ExceptionInformation[0] != KERNEL_BREAKPOINT)) {

        //
        // Switch on the breakpoint code.
        //

        switch (ExceptionRecord->ExceptionInformation[0]) {

            //
            // Print a debug string.
            //
            // Arguments: IA64 passes arguments via RSE not GR's. Since arguments are not
            //            part of CONTEXT struct, they need to be copies Temp registers.
            //            (see NTOS/RTL/IA64/DEBUGSTB.S)
            //
            //   T0 - Supplies a pointer to an output string buffer.
            //   T1 - Supplies the length of the output string buffer.
            //

        case BREAKPOINT_PRINT:

            //
            // Advance to next instruction slot so that the BREAK instruction
            // does not get re-executed
            //

            RtlIa64IncrementIP((ULONG_PTR)ExceptionRecord->ExceptionAddress >> 2,
                               ContextRecord->StIPSR,
                               ContextRecord->StIIP);

            Output.Buffer = (PCHAR)ContextRecord->IntT0;
            Output.Length = (USHORT)ContextRecord->IntT1;

            // KdLogDbgPrint(&Output);

            if (BdDebuggerNotPresent == FALSE) {

                Enable = BdEnterDebugger(TrapFrame, ExceptionFrame);
                if (BdPrintString(&Output)) {
                    ContextRecord->IntV0 = (ULONG)STATUS_BREAKPOINT;

                } else {
                    ContextRecord->IntV0 = (ULONG)STATUS_SUCCESS;
                }
                BdExitDebugger(Enable);

            } else {
                ContextRecord->IntV0 = (ULONG)STATUS_DEVICE_NOT_CONNECTED;
            }

            BdRestoreKframe(TrapFrame, ExceptionFrame, ContextRecord);
            return TRUE;

            //
            // Print a debug prompt string, then input a string.
            //
            //   T0 - Supplies a pointer to an output string buffer.
            //   T1 - Supplies the length of the output string buffer..
            //   T2 - supplies a pointer to an input string buffer.
            //   T3 - Supplies the length of the input string bufffer.
            //

        case BREAKPOINT_PROMPT:

            //
            // Advance to next instruction slot so that the BREAK instruction
            // does not get re-executed
            //

            RtlIa64IncrementIP((ULONG_PTR)ExceptionRecord->ExceptionAddress >> 2,
                               ContextRecord->StIPSR,
                               ContextRecord->StIIP);

            Output.Buffer = (PCHAR)ContextRecord->IntT0;
            Output.Length = (USHORT)ContextRecord->IntT1;
            Input.Buffer = (PCHAR)ContextRecord->IntT2;
            Input.MaximumLength = (USHORT)ContextRecord->IntT3;

            // BdPrintString(&Output);

            Enable = BdEnterDebugger(TrapFrame, ExceptionFrame);

            BdPromptString(&Output, &Input);

            ContextRecord->IntV0 = Input.Length;

            BdExitDebugger(Enable);
            BdRestoreKframe(TrapFrame, ExceptionFrame, ContextRecord);
            return TRUE;

            //
            // Load the symbolic information for an image.
            //
            // Arguments:
            //
            //    T0 - Supplies a pointer to an output string descriptor.
            //    T1 - Supplies a the base address of the image.
            //

        case BREAKPOINT_UNLOAD_SYMBOLS:
            UnloadSymbols = TRUE;

            //
            // Fall through
            //

        case BREAKPOINT_LOAD_SYMBOLS:
    
            //
            // Advance to next instruction slot so that the BREAK instruction
            // does not get re-executed
            //

            Enable = BdEnterDebugger(TrapFrame, ExceptionFrame);
            OldStIPSR = ContextRecord->StIPSR;
            OldStIIP = ContextRecord->StIIP;

            if (BdDebuggerNotPresent == FALSE) {
                BdReportLoadSymbolsStateChange((PSTRING)ContextRecord->IntT0,
                                                (PKD_SYMBOLS_INFO) ContextRecord->IntT1,
                                                UnloadSymbols,
                                                ContextRecord);

            }

            BdExitDebugger(Enable);

            //
            // If the kernel debugger did not update the IP, then increment
            // past the breakpoint instruction.
            //

            if ((ContextRecord->StIIP == OldStIIP) &&
                ((ContextRecord->StIPSR & IPSR_RI_MASK) == (OldStIPSR & IPSR_RI_MASK))) { 
            	RtlIa64IncrementIP((ULONG_PTR)ExceptionRecord->ExceptionAddress >> 2,
                               ContextRecord->StIPSR,
                               ContextRecord->StIIP);
            }

            BdRestoreKframe(TrapFrame, ExceptionFrame, ContextRecord);
            return TRUE;

            //
            // Kernel breakin break
            //

        case BREAKPOINT_BREAKIN:

            //
            // Advance to next instruction slot so that the BREAK instruction
            // does not get re-executed
            //

            RtlIa64IncrementIP((ULONG_PTR)ExceptionRecord->ExceptionAddress >> 2,
                               ContextRecord->StIPSR,
                               ContextRecord->StIIP);
            break;

            //
            // Unknown internal command.
            //

        default:
            break;
        }

    }

    //
    // Get here if single step or BREAKIN breakpoint
    //

    if  ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) ||
          (ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP) ) {

         //
         // Report state change to kernel debugger on host
         //

         Enable = BdEnterDebugger(TrapFrame, ExceptionFrame);
          
         Completion = BdReportExceptionStateChange(
                          ExceptionRecord,
                          &BdPrcb.ProcessorState.ContextFrame);
      
         BdExitDebugger(Enable);
      
         BdControlCPressed = FALSE;
     
    } else {

         //
         // This is real exception that user doesn't want to see,
         // so do NOT report it to debugger.
         //

         // return FALSE;
    }

    BdRestoreKframe(TrapFrame, ExceptionFrame, ContextRecord);
    return TRUE;
}

LOGICAL
BdStub (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine provides a kernel debugger stub routine to catch debug
    prints when the boot debugger is not active.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ExceptionFrame - Supplies a pointer to an exception frame (NULL).

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{
    ULONG_PTR BreakpointCode;

    //
    // Isolate the breakpoint code from the breakpoint instruction which
    // is stored by the exception dispatch code in the information field
    // of the exception record.
    //

    BreakpointCode = (ULONG) ExceptionRecord->ExceptionInformation[0];


    //
    // If the breakpoint is a debug print, debug load symbols, or debug
    // unload symbols, then return TRUE. Otherwise, return FALSE;
    //

    if ((BreakpointCode == BREAKPOINT_PRINT) ||
        (BreakpointCode == BREAKPOINT_LOAD_SYMBOLS) ||
        (BreakpointCode == BREAKPOINT_UNLOAD_SYMBOLS)) {

        //
        // Advance to next instruction slot so that the BREAK instruction
        // does not get re-executed
        //

        RtlIa64IncrementIP((ULONG_PTR)ExceptionRecord->ExceptionAddress >> 2,
                          TrapFrame->StIPSR,
                          TrapFrame->StIIP);
        return TRUE;

    } else {
        return FALSE;
    }
}

VOID
BdRestoreKframe(
    IN OUT PKTRAP_FRAME TrapFrame,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN PCONTEXT ContextFrame
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified context frame into
    the specified trap and exception frames according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that receives the volatile
        context from the context record.

    ExceptionFrame - Supplies a pointer to an exception frame that receives
        the nonvolatile context from the context record.

    ContextFrame - Supplies a pointer to a context frame that contains the
        context that is to be copied into the trap and exception frames.

Return Value:

    None.

--*/

{
    USHORT R1Offset, R4Offset;
    USHORT RNatSaveIndex; 
    SHORT BsFrameSize;
    SHORT TempFrameSize;
    ULONG ContextFlags=CONTEXT_FULL;

    //
    // Set control information if specified.
    //

    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        TrapFrame->IntGp = ContextFrame->IntGp;
        TrapFrame->IntSp = ContextFrame->IntSp;
        TrapFrame->ApUNAT = ContextFrame->ApUNAT;
        TrapFrame->BrRp = ContextFrame->BrRp;
        TrapFrame->ApCCV = ContextFrame->ApCCV;
        TrapFrame->ApDCR = ContextFrame->ApDCR;

        //
        // Set preserved applicaton registers in exception frame.
        //

        ExceptionFrame->ApLC = ContextFrame->ApLC;
        ExceptionFrame->ApEC &= ~(PFS_EC_MASK << PFS_EC_MASK);
        ExceptionFrame->ApEC |= ((ContextFrame->ApEC & PFS_EC_MASK) << PFS_EC_SHIFT);

        //
        // Set RSE control states in the trap frame.
        //

        TrapFrame->RsPFS = ContextFrame->RsPFS;

        BsFrameSize = (SHORT)(ContextFrame->StIFS & PFS_SIZE_MASK);
        RNatSaveIndex = (USHORT)((ContextFrame->RsBSP >> 3) & NAT_BITS_PER_RNAT_REG);

        TempFrameSize = RNatSaveIndex + BsFrameSize - NAT_BITS_PER_RNAT_REG;
        while (TempFrameSize >= 0) {
            BsFrameSize++;
            TempFrameSize -= NAT_BITS_PER_RNAT_REG;
        }

        TrapFrame->RsBSPSTORE = ContextFrame->RsBSPSTORE + BsFrameSize * 8;
        TrapFrame->RsBSP = TrapFrame->RsBSPSTORE;
        TrapFrame->RsRSC = ContextFrame->RsRSC;
        TrapFrame->RsRNAT = ContextFrame->RsRNAT;

#if DEBUG
        DbgPrint("KeContextToKFrames: RsRNAT = 0x%I64x\n", TrapFrame->RsRNAT);
#endif // DEBUG

        //
        // Set FPSR, IPSR, IIP, and IFS in the trap frame.
        //

        TrapFrame->StFPSR = ContextFrame->StFPSR;
        TrapFrame->StIPSR = ContextFrame->StIPSR;
        TrapFrame->StIFS  = ContextFrame->StIFS;
        TrapFrame->StIIP  = ContextFrame->StIIP;

#if 0
        //
        // DebugActive controls h/w debug registers. Set if new psr.db = 1
        //

        KeGetCurrentThread()->DebugActive = ((TrapFrame->StIPSR & (1I64 << PSR_DB)) != 0);

        //
        // Set application registers directly
        // *** TBD SANATIZE??
        //

        if (PreviousMode == UserMode ) {
            __setReg(CV_IA64_AR21, ContextFrame->StFCR);
            __setReg(CV_IA64_AR24, ContextFrame->Eflag);
            __setReg(CV_IA64_AR25, ContextFrame->SegCSD);
            __setReg(CV_IA64_AR26, ContextFrame->SegSSD);
            __setReg(CV_IA64_AR27, ContextFrame->Cflag);
            __setReg(CV_IA64_AR28, ContextFrame->StFSR);
            __setReg(CV_IA64_AR29, ContextFrame->StFIR);
            __setReg(CV_IA64_AR30, ContextFrame->StFDR);
        }
#endif
    }

    //
    // Set integer registers contents if specified.
    //

    if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        TrapFrame->IntT0 = ContextFrame->IntT0;
        TrapFrame->IntT1 = ContextFrame->IntT1;
        TrapFrame->IntT2 = ContextFrame->IntT2;
        TrapFrame->IntT3 = ContextFrame->IntT3;
        TrapFrame->IntT4 = ContextFrame->IntT4;
        TrapFrame->IntV0 = ContextFrame->IntV0;
        TrapFrame->IntTeb = ContextFrame->IntTeb;
        TrapFrame->Preds = ContextFrame->Preds;

        //
        // t5 - t22
        //

        memcpy(&TrapFrame->IntT5, &ContextFrame->IntT5, 18*sizeof(ULONGLONG));

        //
        // Set integer registers s0 - s3 in exception frame.
        //

        ExceptionFrame->IntS0 = ContextFrame->IntS0;
        ExceptionFrame->IntS1 = ContextFrame->IntS1;
        ExceptionFrame->IntS2 = ContextFrame->IntS2;
        ExceptionFrame->IntS3 = ContextFrame->IntS3;

        //
        // Set the integer nats field in the trap & exception frames
        //

        R1Offset = (USHORT)((ULONG_PTR)(&TrapFrame->IntGp) >> 3) & 0x3f;
        R4Offset = (USHORT)((ULONG_PTR)(&ExceptionFrame->IntS0) >> 3) & 0x3f;

        EXTRACT_NATS(TrapFrame->IntNats, ContextFrame->IntNats,
                     1, R1Offset, 0xFFFFFF0E);
        EXTRACT_NATS(ExceptionFrame->IntNats, ContextFrame->IntNats,
                     4, R4Offset, 0xF0);

#if DEBUG
        DbgPrint("KeContextToKFrames: TF->IntNats = 0x%I64x, ContestFrame->IntNats = 0x%I64x, R1OffSet = 0x%x\n",
                 TrapFrame->IntNats, ContextFrame->IntNats, R1Offset);
        DbgPrint("KeContextToKFrames: EF->IntNats = 0x%I64x, R4OffSet = 0x%x\n",
                 ExceptionFrame->IntNats, R4Offset);
#endif // DEBUG

        //
        // Set other branch registers in trap and exception frames
        //

        TrapFrame->BrT0 = ContextFrame->BrT0;
        TrapFrame->BrT1 = ContextFrame->BrT1;

        memcpy(&ExceptionFrame->BrS0, &ContextFrame->BrS0, 5*sizeof(ULONGLONG));

    }

    //
    // Set lower floating register contents if specified.
    //

    if ((ContextFlags & CONTEXT_LOWER_FLOATING_POINT) == CONTEXT_LOWER_FLOATING_POINT) {

        TrapFrame->StFPSR = ContextFrame->StFPSR;

        //
        // Set floating registers fs0 - fs19 in exception frame.
        //

        RtlCopyIa64FloatRegisterContext(&ExceptionFrame->FltS0, 
                                        &ContextFrame->FltS0,
                                        sizeof(FLOAT128) * (4));

        RtlCopyIa64FloatRegisterContext(&ExceptionFrame->FltS4, 
                                        &ContextFrame->FltS4,
                                        16*sizeof(FLOAT128));

        //
        // Set floating registers ft0 - ft9 in trap frame.
        //

        RtlCopyIa64FloatRegisterContext(&TrapFrame->FltT0, 
                                        &ContextFrame->FltT0,
                                        sizeof(FLOAT128) * (10));

    }

    //
    // Set higher floating register contents if specified.
    //

    if ((ContextFlags & CONTEXT_HIGHER_FLOATING_POINT) == CONTEXT_HIGHER_FLOATING_POINT) {

        TrapFrame->StFPSR = ContextFrame->StFPSR;

#if 0
        if (PreviousMode == UserMode) {

            //
            // Update the higher floating point save area (f32-f127) and 
            // set the corresponding modified bit in the PSR to 1.
            //

            RtlCopyIa64FloatRegisterContext(
                (PFLOAT128)GET_HIGH_FLOATING_POINT_REGISTER_SAVEAREA(),
                &ContextFrame->FltF32,
                96*sizeof(FLOAT128)
                );

            //
            // set the dfh bit to force a reload of the high fp register
            // set on the next user access
            //

            TrapFrame->StIPSR |= (1i64 << PSR_DFH);
        }
#endif

    }

#if 0
    //
    // Set debug registers.
    //

    if ((ContextFlags & CONTEXT_DEBUG) == CONTEXT_DEBUG) {
        BdSetDebugContext (TrapFrame, ContextFrame, 0);
    }
#endif

    return;
}

VOID
BdSaveKframe(
    IN OUT PKTRAP_FRAME TrapFrame,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN PCONTEXT ContextFrame
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified trap and exception
    frames into the specified context frame according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    ExceptionFrame - Supplies a pointer to an exception frame from which context
        should be copied into the context record.

    ContextFrame - Supplies a pointer to the context frame that receives the
        context copied from the trap and exception frames.

Return Value:

    None.

--*/

{
    ULONGLONG IntNats1, IntNats2;
    USHORT R1Offset, R4Offset;
    USHORT RNatSaveIndex;
    SHORT BsFrameSize;
    SHORT TempFrameSize;
    ULONG ContextFlags=CONTEXT_FULL;

    //
    // Set control information if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        ContextFrame->IntGp = TrapFrame->IntGp;
        ContextFrame->IntSp = TrapFrame->IntSp;
        ContextFrame->ApUNAT = TrapFrame->ApUNAT;
        ContextFrame->BrRp = TrapFrame->BrRp;
        ContextFrame->ApCCV = TrapFrame->ApCCV;
        ContextFrame->ApDCR = TrapFrame->ApDCR;

        ContextFrame->StFPSR = TrapFrame->StFPSR;
        ContextFrame->StIPSR = TrapFrame->StIPSR;
        ContextFrame->StIIP = TrapFrame->StIIP;
        ContextFrame->StIFS = TrapFrame->StIFS;


        //
        // Set RSE control states from the trap frame.
        //

        ContextFrame->RsPFS = TrapFrame->RsPFS;

        BsFrameSize = (SHORT)(TrapFrame->StIFS & PFS_SIZE_MASK);
        RNatSaveIndex = (USHORT) (TrapFrame->RsBSP >> 3) & NAT_BITS_PER_RNAT_REG;
        TempFrameSize = BsFrameSize - RNatSaveIndex;
        while (TempFrameSize > 0) {
            BsFrameSize++;
            TempFrameSize -= NAT_BITS_PER_RNAT_REG;
        }

        ContextFrame->RsBSP = TrapFrame->RsBSP - BsFrameSize * 8;
        ContextFrame->RsBSPSTORE = ContextFrame->RsBSP;
        ContextFrame->RsRSC = TrapFrame->RsRSC;
        ContextFrame->RsRNAT = TrapFrame->RsRNAT;

#if DEBUG
        DbgPrint("KeContextFromKFrames: RsRNAT = 0x%I64x\n",
                 ContextFrame->RsRNAT);
#endif // DEBUG

        //
        // Set preserved applicaton registers from exception frame.
        //

        ContextFrame->ApLC = ExceptionFrame->ApLC;
        ContextFrame->ApEC = (ExceptionFrame->ApEC >> PFS_EC_SHIFT) & PFS_EC_MASK;

        //
        // Get iA status from the application registers
        //

        ContextFrame->StFCR = __getReg(CV_IA64_AR21);
        ContextFrame->Eflag = __getReg(CV_IA64_AR24);
        ContextFrame->SegCSD = __getReg(CV_IA64_AR25);
        ContextFrame->SegSSD = __getReg(CV_IA64_AR26);
        ContextFrame->Cflag = __getReg(CV_IA64_AR27);
        ContextFrame->StFSR = __getReg(CV_IA64_AR28);
        ContextFrame->StFIR = __getReg(CV_IA64_AR29);
        ContextFrame->StFDR = __getReg(CV_IA64_AR30);

    }

    //
    // Set integer register contents if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        ContextFrame->IntT0 = TrapFrame->IntT0;
        ContextFrame->IntT1 = TrapFrame->IntT1;
        ContextFrame->IntT2 = TrapFrame->IntT2;
        ContextFrame->IntT3 = TrapFrame->IntT3;
        ContextFrame->IntT4 = TrapFrame->IntT4;
        ContextFrame->IntV0 = TrapFrame->IntV0;
        ContextFrame->IntTeb = TrapFrame->IntTeb;
        ContextFrame->Preds = TrapFrame->Preds;

        //
        // t5 - t22
        // 

        memcpy(&ContextFrame->IntT5, &TrapFrame->IntT5, 18*sizeof(ULONGLONG));

        //
        // Set branch registers from trap frame & exception frame
        //

        ContextFrame->BrT0 = TrapFrame->BrT0;
        ContextFrame->BrT1 = TrapFrame->BrT1;

        memcpy(&ContextFrame->BrS0, &ExceptionFrame->BrS0, 5*sizeof(ULONGLONG));

        //
        // Set integer registers s0 - s3 from exception frame.
        //

        ContextFrame->IntS0 = ExceptionFrame->IntS0;
        ContextFrame->IntS1 = ExceptionFrame->IntS1;
        ContextFrame->IntS2 = ExceptionFrame->IntS2;
        ContextFrame->IntS3 = ExceptionFrame->IntS3;

        //
        // Set the integer nats field in the context
        //

        R1Offset = (USHORT)((ULONG_PTR)(&TrapFrame->IntGp) >> 3) & 0x3f;
        R4Offset = (USHORT)((ULONG_PTR)(&ExceptionFrame->IntS0) >> 3) & 0x3f;

        ALIGN_NATS(IntNats1, TrapFrame->IntNats, 1, R1Offset, 0xFFFFFF0E);
        ALIGN_NATS(IntNats2, ExceptionFrame->IntNats, 4, R4Offset, 0xF0);
        ContextFrame->IntNats = IntNats1 | IntNats2;

#if DEBUG
        DbgPrint("KeContextFromKFrames: TF->IntNats = 0x%I64x, R1OffSet = 0x%x, R4Offset = 0x%x\n",
                 TrapFrame->IntNats, R1Offset, R4Offset);
        DbgPrint("KeContextFromKFrames: CF->IntNats = 0x%I64x, IntNats1 = 0x%I64x, IntNats2 = 0x%I64x\n",
                 ContextFrame->IntNats, IntNats1, IntNats2);
#endif // DEBUG

    }

    //
    // Set lower floating register contents if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_LOWER_FLOATING_POINT) == CONTEXT_LOWER_FLOATING_POINT) {

        //
        // Set EM + ia32 FP status
        //
        
        ContextFrame->StFPSR = TrapFrame->StFPSR;

        //
        // Set floating registers fs0 - fs19 from exception frame.
        //

        RtlCopyIa64FloatRegisterContext(&ContextFrame->FltS0,
                                        &ExceptionFrame->FltS0,
                                        sizeof(FLOAT128) * (4));

        RtlCopyIa64FloatRegisterContext(&ContextFrame->FltS4, 
                                        &ExceptionFrame->FltS4,
                                        16*sizeof(FLOAT128));

        //
        // Set floating registers ft0 - ft9 from trap frame.
        //

        RtlCopyIa64FloatRegisterContext(&ContextFrame->FltT0,
                                        &TrapFrame->FltT0,
                                        sizeof(FLOAT128) * (10));

    }

#if 0
    if ((ContextFrame->ContextFlags & CONTEXT_HIGHER_FLOATING_POINT) == CONTEXT_HIGHER_FLOATING_POINT) {

        ContextFrame->StFPSR = TrapFrame->StFPSR;

        //
        // Set floating regs f32 - f127 from higher floating point save area
        //

        if (TrapFrame->PreviousMode == UserMode) {

            RtlCopyIa64FloatRegisterContext(
                &ContextFrame->FltF32, 
                (PFLOAT128)GET_HIGH_FLOATING_POINT_REGISTER_SAVEAREA(),
                96*sizeof(FLOAT128)
                );
        }

    }

    //
    // Get user debug registers from save area in kernel stack.
    // Note: PSR.db must be set to activate the debug registers.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_DEBUG) == CONTEXT_DEBUG) {
        BdGetDebugContext(TrapFrame, ContextFrame);
    }
#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\i386\trap.asm ===
title  "Trap Processing"
;++
;
; Copyright (c) 1996  Microsoft Corporation
;
; Module Name:
;
;    trap.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process i386
;    trap conditions.
;
; Author:
;
;    David N. Cutler (davec) 1-Dec-96
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
        .xlist
KERNELONLY  equ     1
include ks386.inc
include callconv.inc
include i386\kimacro.inc
include mac386.inc
        .list

        extrn   _BdDebugRoutine:DWORD

        page ,132
        subttl "Equated Values"
;
; Debug register 6 (dr6) BS (single step) bit mask
;

DR6_BS_MASK                     EQU     4000H

;
; EFLAGS single step bit
;

EFLAGS_TF_BIT                   EQU     100h
EFLAGS_OF_BIT                   EQU     4000H

_TEXT$00   SEGMENT PUBLIC 'CODE'
        ASSUME  DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING

        page ,132
        subttl "Macros"
;++
;
; GENERATE_TRAP_FRAME
;
; Macro Dexcription:
;
;    This macro generates a trap frame and saves the current register state.
;
; Arguments:
;
;    None.
;
;--

GENERATE_TRAP_FRAME macro

;
; Build trap frame minus the V86 and privilege level transition arguments.
;
; N.B. It is assumed that the error code has already been pushed on the stack.
;

        push    ebp                     ; save nonvolatile registers
        push    ebx                     ;
        push    esi                     ;
        push    edi                     ;
        push    fs                      ; save FS segment register
        push    -1                      ; push dummy exception list
        push    -1                      ; dummy previous mode
        push    eax                     ; save the volatile registers
        push    ecx                     ;
        push    edx                     ;
        push    ds                      ; save segment registers
        push    es                      ;
        push    gs                      ;
        sub     esp, TsSegGs            ; allocate remainder of trap frame
        mov     ebp, esp                ; set ebp to base of trap frame
        cld                             ; clear direction bit

        endm

        page ,132
        subttl "Debug Exception"
;++
;
; Routine Description:
;
;    Handle debug exceptions.
;
;    This exception is generated for the following reasons:
;
;    Instruction breakpoint fault.
;    Data address breakpoint trap.
;    General detect fault.
;    Single-step trap.
;    Task-switch breadkpoint trap.
;
; Arguments:
;
;    On entry the stack contains:
;
;       eflags
;       cs
;       eip
;
;    N.B. There are no privilege transitions in the boot debugger. Therefore,
;         the none of the previous ss, esp, or V86 registers are saved.
;
; Return value:
;
;    None
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        align   16
        public  _BdTrap01@0
_BdTrap01@0 proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        push    0                       ; push dummy error code

        GENERATE_TRAP_FRAME             ; generate trap frame

;
; Set exception parameters.
;

        and     dword ptr [ebp] + TsEflags, not EFLAGS_TF_BIT ; clear TF flag
        mov     eax, STATUS_SINGLE_STEP ; set exception code
        mov     ebx, [ebp] + TsEip      ; set address of faulting instruction
        xor     ecx, ecx                ; set number of parameters
        call    _BdDispatch             ; dispatch exception
        jmp     _BdExit                 ; dummy

_BdTrap01@0 endp

        page ,132
        subttl "Int 3 Breakpoint"
;++
;
; Routine Description:
;
;    Handle int 3 (breakpoint).
;
;    This trap is caused by the int 3 instruction.
;
; Arguments:
;
;    On entry the stack contains:
;
;       eflags
;       cs
;       eip
;
;    N.B. There are no privilege transitions in the boot debugger. Therefore,
;         the none of the previous ss, esp, or V86 registers are saved.
;
; Return value:
;
;    None
;
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        align   16
        public  _BdTrap03@0
_BdTrap03@0 proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        push    0                       ; push dummy error code

        GENERATE_TRAP_FRAME             ; generate trap frame

;
; Set exception parameters.
;

        dec     dword ptr [ebp] + TsEip ; back up to int 3 instruction
        mov     eax, STATUS_BREAKPOINT  ; set exception code
        mov     ebx, [ebp] + TsEip      ; set address of faulting instruction
        mov     ecx, 1                  ; set number of parameters
        mov     edx, BREAKPOINT_BREAK   ; set service name
        call    _BdDispatch             ; dispatch exception
        jmp     _BdExit                 ; dummy

_BdTrap03@0 endp

        page ,132
        subttl "General Protect"
;++
;
; Routine Description:
;
;    General protect violation.
;
; Arguments:
;
;    On entry the stack contains:
;
;       eflags
;       cs
;       eip
;       error code
;
;    N.B. There are no privilege transitions in the boot debugger. Therefore,
;         the none of the previous ss, esp, or V86 registers are saved.
;
; Return value:
;
;    N.B. There is no return from this fault.
;
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        align   16
        public  _BdTrap0d@0
_BdTrap0d@0 proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        GENERATE_TRAP_FRAME             ; generate trap frame

;
; Set exception parameters.
;

_BdTrap0d10:                            ;
        mov     eax, STATUS_ACCESS_VIOLATION ; set exception code
        mov     ebx, [ebp] + TsEip      ; set address of faulting instruction
        mov     ecx, 1                  ; set number of parameters
        mov     edx, [ebp] + TsErrCode  ; set error code
        and     edx, 0FFFFH             ;
        call    _BdDispatch             ; dispatch exception
        jmp     _BdTrap0d10             ; repeat

_BdTrap0d@0 endp

        page ,132
        subttl "Page Fault"
;++
;
; Routine Description:
;
;    Page fault.
;
; Arguments:
;
;    On entry the stack contains:
;
;       eflags
;       cs
;       eip
;       error code
;
;    N.B. There are no privilege transitions in the boot debugger. Therefore,
;         the none of the previous ss, esp, or V86 registers are saved.
;
; Return value:
;
;    N.B. There is no return from this fault.
;
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        align   16
        public  _BdTrap0e@0
_BdTrap0e@0 proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        GENERATE_TRAP_FRAME             ; generate trap frame

;
; Set exception parameters.
;

_BdTrap0e10:                            ;
        mov     eax, STATUS_ACCESS_VIOLATION ; set exception code
        mov     ebx, [ebp] + TsEip      ; set address of faulting instruction
        mov     ecx, 3                  ; set number of parameters
        mov     edx, [ebp] + TsErrCode  ; set read/write code
        and     edx, 2                  ;
        mov     edi, cr2                ; set fault address
        xor     esi, esi                ; set previous mode
        call    _BdDispatch             ; dispatch exception
        jmp     _BdTrap0e10             ; repeat

_BdTrap0e@0 endp

        page ,132
        subttl "Debug Service"
;++
;
; Routine Description:
;
;    Handle int 2d (debug service).
;
;    The trap is caused by an int 2d instruction. This instruction is used
;    instead of an int 3 instruction so parameters can be passed to the
;    requested debug service.
;
;    N.B. An int 3 instruction must immediately follow the int 2d instruction.
;
; Arguments:
;
;    On entry the stack contains:
;
;       eflags
;       cs
;       eip
;
;    N.B. There are no privilege transitions in the boot debugger. Therefore,
;         the none of the previous ss, esp, or V86 registers are saved.
;
;     Service (eax) - Supplies the service to perform.
;     Argument1 (ecx) - Supplies the first argument.
;     Argument2 (edx) - Supplies the second argument.
;
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

        align   16
        public  _BdTrap2d@0
_BdTrap2d@0 proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

;
; Build trap frame minus the V86 and privilege level transition arguments.
;

        push    0                       ; push dummy error code

        GENERATE_TRAP_FRAME             ; generate trap frame

;
; Set exception parameters.
;

        mov     eax, STATUS_BREAKPOINT  ; set exception code
        mov     ebx, [ebp] + TsEip      ; set address of faulting instruction
        mov     ecx, 3                  ; set number of parameters
        mov     edx, [ebp] + TsEax      ; set service name
        mov     edi, [ebp] + TsEcx      ; set first argument value
        mov     esi, [ebp] + TsEdx      ; set second argument value
        call    _BdDispatch             ; dispatch exception
        jmp     _BdExit                 ; dummy

_BdTrap2d@0 endp

        page , 132
        subttl "Exception Dispatch"
;++
;
; Dispatch
;
; Routine Description:
;
;    This functions allocates an exception record, initializes the exception
;    record, and calls the general exception dispatch routine.
;
; Arguments:
;
;    Code (eax) - Suppplies the exception code.
;    Address (ebx) = Supplies the address of the exception.
;    Number (ecx) = Supplies the number of parameters.
;    Parameter1 (edx) - Supplies exception parameter 1;
;    Parameter2 (edi) - Supplies exception parameter 2;
;    Parameter3 (esi) - Supplies exception parameter 3.
;
; Return Value:
;
;    None.
;
;--

      align     16
      public _BdDispatch
_BdDispatch proc
.FPO (ExceptionRecordLength / 4, 0, 0, 0, 0, FPO_TRAPFRAME)

;
; Allocate and initialize exception record.
;

        sub     esp, ExceptionRecordLength ; allocate exception record
        mov     [esp] + ErExceptionCode, eax ; set exception code
        xor     eax, eax                ; zero register
        mov     [esp] + ErExceptionFlags, eax ; zero exception flags
        mov     [esp] + ErExceptionRecord, eax ; zero associated exception record
        mov     [esp] + ErExceptionAddress, ebx ; set exception address
        mov     [esp] + ErNumberParameters, ecx ; set number of parameters
        mov     [esp] + ErExceptionInformation + 0, edx ; set parameter 1
        mov     [esp] + ErExceptionInformation + 4, edi ; set parameter 2
        mov     [esp] + ErExceptionInformation + 8, esi ; set parameter 3

;
; Save debug registers in trap frame.
;

        mov     eax, dr0                ; save dr0
        mov     [ebp] + TsDr0, eax      ;
        mov     eax, dr1                ; save dr1
        mov     [ebp] + TsDr1, eax      ;
        mov     eax, dr2                ; save dr2
        mov     [ebp] + TsDr2, eax      ;
        mov     eax, dr3                ; save dr3
        mov     [ebp] + TsDr3, eax      ;
        mov     eax, dr6                ; save dr6
        mov     [ebp] + TsDr6, eax      ;
        mov     eax, dr7                ; save dr7
        mov     [ebp] + TsDr7, eax      ;

;
; Save previous stack address and segment selector.
;

        mov     eax, ss                 ; save stack segment register
        mov     [ebp] + TsTempSegCs, eax ;
        mov     [ebp] + TsTempEsp, ebp  ; compute previous stack address
        add     [ebp] + TsTempEsp, TsEFlags + 4 ;

;
; Call the general exception dispatcher.
;

        mov     ecx, esp                ; set address of exception record
        push    ebp                     ; push address of trap frame
        push    0                       ; push address of exception frame
        push    ecx                     ; push address of exception record
        call    [_BdDebugRoutine]       ; call dispatch routine
        add     esp, ExceptionRecordLength ; deallocate exception record
        ret                             ;

_BdDispatch endp

        page ,132
        subttl  "Common Trap Exit"
;++
;
; Exit
;
; Routine Description:
;
;    This code is transfered to at the end of the processing for an exception.
;    Its function is to restore machine state and continue execution.
;
; Arguments:
;
;    ebp - Supplies the address of the trap frame.
;
;   Return Value:
;
;    None.
;
;--

        align   16
        public  _BdExit
_BdExit proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        lea     esp, [ebp] + TsSegGs    ; get address of save area
        pop     gs                      ; restore segment registers
        pop     es                      ;
        pop     ds                      ;
        pop     edx                     ; restore volatile registers
        pop     ecx                     ;
        pop     eax                     ;
        add     esp, 8                  ; remove mode and exception list
        pop     fs                      ; restore FS segment register
        pop     edi                     ; restore nonvolatile registers
        pop     esi                     ;
        pop     ebx                     ;
        pop     ebp                     ;
        add     esp, 4                  ; remove error code
        iretd                           ; return

_BdExit endp

_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\ia64\cpuapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    bdcpuapi.c

Abstract:

    This module implements CPU specific remote debug APIs.

Author:

    Mark Lucovsky (markl) 04-Sep-1990

Revision History:

--*/

#include "bd.h"

//
// Define end of control space.
//

#define END_OF_CONTROL_SPACE ((PCHAR)(sizeof(KPROCESSOR_STATE)))

VOID
BdSetContextState(
    IN PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    The function fills in the process-specific portion of the
    wait state change message record.

Arguments:

    WaitStateChange - Supplies a pointer to record to fill in.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{
    // Nothing to do for IA64.
    return;
}

VOID
BdGetStateChange(
    IN PDBGKD_MANIPULATE_STATE64 ManipulateState,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    The function extracts continuation control data from a manipulate state
    message.

Arguments:

    ManipulateState - Supplies a pointer to the manipulate state packet.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{
}

VOID
BdSetStateChange(
    IN PDBGKD_ANY_WAIT_STATE_CHANGE WaitStateChange,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    Fill in the wait state change message record.

Arguments:

    WaitStateChange - Supplies pointer to record to fill in

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{
    BdSetContextState(WaitStateChange, ContextRecord);
    return;
}

VOID
BdReadControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function reads control space.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_READ_MEMORY64 a = &m->u.ReadMemory;
    ULONG Length;
    STRING MessageHeader;

    //
    // If the specified control registers are within control space, then
    // read the specified space and return a success status. Otherwise,
    // return an unsuccessful status.
    //

    Length = min(a->TransferCount,
                 PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64));

    ASSERT(sizeof(PVOID) == sizeof(ULONG_PTR));

    //
    // Case on address to determine what part of Control space is being read.
    //

    switch ( (ULONG_PTR)a->TargetBaseAddress ) {

        //
        // Return the pcr address for the current processor.
        //

    case DEBUG_CONTROL_SPACE_PCR:

        *(PKPCR *)(AdditionalData->Buffer) = (PKPCR)(BdPrcb.PcrPage << PAGE_SHIFT);
        AdditionalData->Length = sizeof( PKPCR );
        a->ActualBytesRead = AdditionalData->Length;
        m->ReturnStatus = STATUS_SUCCESS;
        break;

        //
        // Return the prcb address for the current processor.
        //

    case DEBUG_CONTROL_SPACE_PRCB:

        *(PKPRCB *)(AdditionalData->Buffer) = &BdPrcb;
        AdditionalData->Length = sizeof( PKPRCB );
        a->ActualBytesRead = AdditionalData->Length;
        m->ReturnStatus = STATUS_SUCCESS;
        break;

    case DEBUG_CONTROL_SPACE_KSPECIAL:

        BdMoveMemory (AdditionalData->Buffer, 
                      (PVOID)&(BdPrcb.ProcessorState.SpecialRegisters),
                      sizeof( KSPECIAL_REGISTERS )
                     );
        AdditionalData->Length = sizeof( KSPECIAL_REGISTERS );
        a->ActualBytesRead = AdditionalData->Length;
        m->ReturnStatus = STATUS_SUCCESS;
        break;

    default:

        AdditionalData->Length = 0;
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        a->ActualBytesRead = 0;

    }

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 AdditionalData);

    return;
}

VOID
BdWriteControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function writes control space.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_WRITE_MEMORY64 a = &m->u.WriteMemory;
    ULONG Length;
    STRING MessageHeader;

    //
    // If the specified control registers are within control space, then
    // write the specified space and return a success status. Otherwise,
    // return an unsuccessful status.
    //

    switch ( (ULONG_PTR)a->TargetBaseAddress ) {

    case DEBUG_CONTROL_SPACE_KSPECIAL:

        BdMoveMemory ( (PVOID)&(BdPrcb.ProcessorState.SpecialRegisters),
                       AdditionalData->Buffer,
                       sizeof( KSPECIAL_REGISTERS )
                      );
        AdditionalData->Length = sizeof( KSPECIAL_REGISTERS );
        a->ActualBytesWritten = AdditionalData->Length;
        m->ReturnStatus = STATUS_SUCCESS;
        break;

    default:

        AdditionalData->Length = 0;
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        a->ActualBytesWritten = 0;

    }

    //
    // Send reply message.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}

VOID
BdReadIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function reads I/O space.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_READ_WRITE_IO64 a = &m->u.ReadWriteIo;
    STRING MessageHeader;

    //
    // Case of data size and check alignment.
    //

    m->ReturnStatus = STATUS_SUCCESS;
    switch (a->DataSize) {
        case 1:
            a->DataValue = (ULONG)READ_PORT_UCHAR((PUCHAR)a->IoAddress);
            break;

        case 2:
            if (((ULONG)a->IoAddress & 1) != 0) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                a->DataValue = (ULONG)READ_PORT_USHORT((PUSHORT)a->IoAddress);
            }

            break;

        case 4:
            if (((ULONG)a->IoAddress & 3) != 0) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                a->DataValue = READ_PORT_ULONG((PULONG)a->IoAddress);
            }

            break;

        default:
            m->ReturnStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}

VOID
BdWriteIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PCONTEXT Context
    )

/*++

Routine Description:

    This function wrties I/O space.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{

    PDBGKD_READ_WRITE_IO64 a = &m->u.ReadWriteIo;
    STRING MessageHeader;

    //
    // Case on data size and check alignment.
    //

    m->ReturnStatus = STATUS_SUCCESS;
    switch (a->DataSize) {
        case 1:
            WRITE_PORT_UCHAR((PUCHAR)a->IoAddress, (UCHAR)a->DataValue);
            break;

        case 2:
            if (((ULONG)a->IoAddress & 1) != 0) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                WRITE_PORT_USHORT((PUSHORT)a->IoAddress, (USHORT)a->DataValue);
            }

            break;

        case 4:
            if (((ULONG)a->IoAddress & 3) != 0) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;

            } else {
                WRITE_PORT_ULONG((PULONG)a->IoAddress, a->DataValue);
            }

            break;

        default:
            m->ReturnStatus = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Send reply packet.
    //

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    BdSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                 &MessageHeader,
                 NULL);

    return;
}


BOOLEAN
BdSuspendBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    )

/*++

Routine Description:

    This routine suspend all breakpoints falling in a given range
    from the breakpoint table.

Arguments:

    Lower - inclusive lower address of range from which to suspend BPs.

    Upper - include upper address of range from which to suspend BPs.

Return Value:

    TRUE if any breakpoints suspended, FALSE otherwise.

Notes:
    The order of suspending breakpoints is opposite that of setting
    them in BdAddBreakpoint() in case of duplicate addresses.

--*/

{
    ULONG   Index;
    BOOLEAN ReturnStatus = FALSE;

    //DPRINT(("\nKD: entering BdSuspendBreakpointRange() at 0x%08x 0x%08x\n", Lower, Upper));

    //
    // Examine each entry in the table in turn
    //

    for (Index = BREAKPOINT_TABLE_SIZE - 1; Index != -1; Index--) {

        if ( (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_IN_USE) &&
             ((BdBreakpointTable[Index].Address >= (ULONG64) Lower) &&
              (BdBreakpointTable[Index].Address <= (ULONG64) Upper))
           ) {

            //
            // Breakpoint is in use and falls in range, suspend it.
            //

            BdSuspendBreakpoint(Index+1);
            ReturnStatus = TRUE;
        }
    }
    //DPRINT(("KD: exiting BdSuspendBreakpointRange() return 0x%d\n", ReturnStatus));

    return ReturnStatus;

} // BdSuspendBreakpointRange



BOOLEAN
BdRestoreBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    )

/*++

Routine Description:

    This routine writes back breakpoints falling in a given range
    from the breakpoint table.

Arguments:

    Lower - inclusive lower address of range from which to rewrite BPs.

    Upper - include upper address of range from which to rewrite BPs.

Return Value:

    TRUE if any breakpoints written, FALSE otherwise.

Notes:
    The order of writing breakpoints is opposite that of removing
    them in BdSuspendBreakpointRange() in case of duplicate addresses.

--*/

{
    ULONG   Index;
    BOOLEAN ReturnStatus = FALSE;

    //DPRINT(("\nKD: entering BdRestoreBreakpointRange() at 0x%08x 0x%08x\n", Lower, Upper));

    //
    // Examine each entry in the table in turn
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index++) {

        if ( (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_IN_USE) &&
             ((BdBreakpointTable[Index].Address >= (ULONG64) Lower) &&
              (BdBreakpointTable[Index].Address <= (ULONG64) Upper))
           ) {

            //
            // suspended breakpoint that falls in range, unsuspend it.
            //

            if (BdBreakpointTable[Index].Flags & BD_BREAKPOINT_SUSPENDED) {

                BdBreakpointTable[Index].Flags &= ~BD_BREAKPOINT_SUSPENDED;
                ReturnStatus = ReturnStatus || BdLowRestoreBreakpoint(Index);
            }
        }
    }

    //DPRINT(("KD: exiting BdRestoreBreakpointRange() return 0x%d\n", ReturnStatus));

    return ReturnStatus;

} // BdRestoreBreakpointRange
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\ia64\print.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    print.c

Abstract:

    This modules implements debug prints.

Author:

    David N. Cutler (davec) 30-Nov-96

Revision History:

--*/

#include "bd.h"

VOID
BdPrintf(
    IN PCHAR Format,
    ...
    )

/*++

Routine Description:

    Printf routine for the debugger that is safer than DbgPrint.  Calls
    the packet driver instead of reentering the debugger.

Arguments:

    Format - Supplies a pointer to a format string.

Return Value:

    None

--*/

{

    CHAR Buffer[100];
    va_list mark;
    STRING String;

    va_start(mark, Format);
    _vsnprintf(&Buffer[0], 100, Format, mark);
    va_end(mark);

    //bugbug UNICODE
    //BlPrint("%s", &Buffer[0]);

    String.Buffer = &Buffer[0];
    String.Length = strlen(&Buffer[0]);
    BdPrintString(&String);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\ia64\port.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This modules implements com port code to support the boot debugger.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

--*/

#include "bd.h"

extern BdInstallVectors();

_TUCHAR DebugMessage[80];

LOGICAL
BdPortInitialize(
    IN ULONG BaudRate,
    IN ULONG PortNumber,
    OUT PULONG BdFileId
    )

/*++

Routine Description:

    This functions initializes the boot debugger com port.

Arguments:

    BaudRate - Supplies an optional baud rate.

    PortNumber - supplies an optinal port number.

Returned Value:

    TRUE - If a debug port is found.

--*/

{
    //
    // Initialize the specified port.
    //
    if (!BlPortInitialize(BaudRate, PortNumber, NULL, FALSE, BdFileId)) {
        return FALSE;
    }
    _stprintf(DebugMessage,
            TEXT("\r\nBoot Debugger Using: COM%d (Baud Rate %d)\r\n"),
            PortNumber,
            BaudRate);

    //
    // Install exception vectors used by BD.
    //
    BdIa64Init();

#if 0
    //
    // We cannot use BlPrint() at this time because BlInitStdIo() has not been called, which is
    // required to use the Arc emulator code.
    //
    TextStringOut(DebugMessage);
#else  
    //
    // there's no reason not to use BlPrint since we're not using ARC calls to print
    // 
    BlPrint( DebugMessage );
#endif    

    return TRUE;
}

ULONG
BdPortGetByte (
    OUT PUCHAR Input
    )

/*++

Routine Description:

    This routine gets a byte from the serial port used by the kernel
    debugger.

Arguments:

    Input - Supplies a pointer to a variable that receives the input
        data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.

    CP_GET_ERROR is returned if an error is encountered during reading.

    CP_GET_NODATA is returned if timeout occurs.

--*/

{

    return BlPortGetByte(BdFileId, Input);
}

VOID
BdPortPutByte (
    IN UCHAR Output
    )

/*++

Routine Description:

    This routine puts a byte to the serial port used by the kernel debugger.

Arguments:

    Output - Supplies the output data byte.

Return Value:

    None.

--*/

{

    BlPortPutByte(BdFileId, Output);
    return;
}

ULONG
BdPortPollByte (
    OUT PUCHAR Input
    )

/*++

Routine Description:

    This routine gets a byte from the serial port used by the kernel
    debugger iff a byte is available.

Arguments:

    Input - Supplies a pointer to a variable that receives the input
        data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.

    CP_GET_ERROR is returned if an error encountered during reading.

    CP_GET_NODATA is returned if timeout occurs.

--*/

{

    return BlPortPollByte(BdFileId, Input);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\ia64\miscc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    trapc.c

Abstract:

    This module contains utility functions used by IA-64 Boot Debugger.

Author:

    Allen Kay 11-Nov-99    allen.m.kay@intel.com

Environment:


Revision History:

--*/

#include "bd.h"

extern ULONGLONG BdPcr;
extern VOID BdInstallVectors();



typedef struct _MOVL_INST {
    union {
        struct {
            ULONGLONG qp:          6;
            ULONGLONG r1:          7;
            ULONGLONG Imm7b:       7;
            ULONGLONG Vc:          1;
            ULONGLONG Ic:          1;
            ULONGLONG Imm5c:       5;
            ULONGLONG Imm9d:       9;
            ULONGLONG I:           1; 
            ULONGLONG OpCode:      4; 
            ULONGLONG Rsv:        23; 
        } i_field;
        ULONGLONG Ulong64;
    } u;
} MOVL_INST, *PMOVL_INST;

ULONGLONG
BdSetMovlImmediate (
    IN OUT PULONGLONG Ip,
    IN ULONGLONG VectorAddr
    )

/*++

Routine Description:

    Extract immediate operand from break instruction.

Arguments:

    Ip - Bundle address of instruction
    
Return Value:

    Value of immediate operand.

--*/

{
    PULONGLONG BundleAddress;
    ULONGLONG BundleLow;
    ULONGLONG BundleHigh;
    IN MOVL_INST MovlInst, Slot0, Slot1, Slot2;
    IN ULONGLONG Imm64;

    BundleAddress = (PULONGLONG)Ip;
    BundleLow = *BundleAddress;
    BundleHigh = *(BundleAddress+1);
    
    //
    // Extract Slot0
    //
    Slot0.u.Ulong64 = BundleLow & 0x3FFFFFFFFFFF;

    //
    // Now set immediate address from slot1
    //

    Slot1.u.Ulong64 = (BundleLow >> 46) | (BundleHigh << 18);
    Slot1.u.Ulong64 = (VectorAddr >> 22) & 0x1FFFFFFFFFF;

    //
    // First set immediate address from slot2
    //

    Slot2.u.Ulong64 = (BundleHigh >> 23);

    Slot2.u.i_field.I = (VectorAddr >> 63) & 0x1;
    Slot2.u.i_field.Ic = (VectorAddr >> 21) & 0x1;
    Slot2.u.i_field.Imm5c = (VectorAddr >> 16) & 0x1F;
    Slot2.u.i_field.Imm9d = (VectorAddr >> 7) & 0x1FF;
    Slot2.u.i_field.Imm7b = VectorAddr & 0x7F;

    //
    // Change the bundle
    //

    *BundleAddress = (BundleLow & 0x3FFFFFFFFFFF) |
                     Slot1.u.Ulong64 << 46;

    *(BundleAddress+1) = Slot2.u.Ulong64 << 23 |
                         (Slot1.u.Ulong64 & 0x1FFFFFC0000) >> 18;

    //
    // Now get the address.
    //
    BundleAddress = (PULONGLONG)Ip;
    BundleLow = *BundleAddress;
    BundleHigh = *(BundleAddress+1);

    //
    // First get immediate address from slot2
    //

    MovlInst.u.Ulong64 = (BundleHigh >> 23);
    Imm64 = MovlInst.u.i_field.I     << 63 |
            MovlInst.u.i_field.Ic    << 21 |
            MovlInst.u.i_field.Imm5c << 16 |
            MovlInst.u.i_field.Imm9d <<  7 |
            MovlInst.u.i_field.Imm7b;

    //
    // Now get immediate address from slot1
    //

    MovlInst.u.Ulong64 = (BundleLow >> 46) | (BundleHigh << 18);
    Imm64 = Imm64 | ( (MovlInst.u.Ulong64 & 0x1FFFFFFFFFF) << 22);

    return Imm64;

}

VOID
BdIa64Init()
{
    BdInstallVectors();
    BdPrcb.PcrPage = BdPcr >> PAGE_SIZE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\advboot.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    advboot.c

Abstract:

    Handles the advanced options boot menu screen.

Author:

    Wesley Wittt (wesw) 12-Dec-1997

Revision History:

--*/

#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#include <netboot.h>
#include "msg.h"
#include "ntdddisk.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include "bldrint.h"

#if 0
ULONG VerboseDebugging = 0;

#define dbg(x)              \
    if(VerboseDebugging) {  \
        DbgPrint x;         \
    }

#define dbgbrk()            \
    if(VerboseDebugging) {  \
        DbgBreakPoint();    \
    }
#else
#define dbg(x) /* x */
#define dbgbrk() /* */ 
#endif

//
// used to force the boot loader into
// using LKG even though the LKG menu
// wasn't used.
//
extern BOOLEAN ForceLastKnownGood;


#define ATTR_TEXT           0x07
#define ATTR_TEXT_REVERSE   0x70
#define HEADER_START_Y      0x01

//
// menu data structures and defines
//

#define MENU_ITEM           1
#define MENU_BLANK_LINE     2

typedef void (*PADVANCED_BOOT_PROCESSING)(void);
typedef int  (*PADVANCED_BOOT_ISVALID)(void);

typedef struct _ADVANCEDBOOT_OPTIONS {
    ULONG                       MenuType;
    ULONG                       MsgId;
    PTSTR                       DisplayStr;
    PSTR                        LoadOptions;
    LONG                        RemoveIfPresent;
    ULONG                       UseEntry;
    ULONG                       AutoAdvancedBootOption;
    PADVANCED_BOOT_PROCESSING   ProcessFunc;
    PADVANCED_BOOT_ISVALID      IsValid;
    BOOLEAN                     IsDefault;
} ADVANCEDBOOT_OPTIONS, PADVANCEDBOOT_OPTIONS;


//
// some prototypes that are needed for
// the menu definitions.
//

void
BlProcessLastKnownGoodOption(
    void
    );

int
BlIsReturnToOSChoicesValid(
    VOID
    );

#if defined(REMOTE_BOOT)
void
BlProcessOschooserOption(
    void
    );

void
BlProcessRepinOption(
    void
    );

void
BlDisableCSC(
    void
    );

void 
BlBootNormally(
    void
    );

void
BlReturnToOSChoiceMenu(
    void
    );

int
BlIsRemoteBootValid(
    void
    );
    
#endif // defined(REMOTE_BOOT)

//
// this table drives the advanced boot menu screen.
// of you need to add something to the screen then
// this is what you need to modify.
//

ADVANCEDBOOT_OPTIONS AdvancedBootOptions[] =
{
    { MENU_ITEM,       BL_SAFEBOOT_OPTION1,      NULL, "SAFEBOOT:MINIMAL SOS BOOTLOG NOGUIBOOT", -1, 0, 1, NULL, NULL, FALSE},
    { MENU_ITEM,       BL_SAFEBOOT_OPTION2,      NULL, "SAFEBOOT:NETWORK SOS BOOTLOG NOGUIBOOT", -1, 0, 1, NULL, NULL, FALSE},
    { MENU_ITEM,       BL_SAFEBOOT_OPTION4,      NULL, "SAFEBOOT:MINIMAL(ALTERNATESHELL) SOS BOOTLOG NOGUIBOOT", -1, 0, 1, NULL, NULL, FALSE},
//  { MENU_ITEM,       BL_SAFEBOOT_OPTION3,      NULL, "SAFEBOOT:STEPBYSTEP SOS BOOTLOG",        -1, 0, 1, NULL, NULL, FALSE},
    { MENU_BLANK_LINE, 0,                        NULL, NULL,                         -1, 0, 1, NULL, NULL, FALSE},
    { MENU_ITEM,       BL_BOOTLOG,               NULL, "BOOTLOG",                    -1, 0, 0, NULL, NULL, FALSE},
    { MENU_ITEM,       BL_BASEVIDEO,             NULL, "BASEVIDEO",                  -1, 0, 0, NULL, NULL, FALSE},
    { MENU_ITEM,       BL_LASTKNOWNGOOD_OPTION,  NULL, NULL,                         -1, 0, 1, BlProcessLastKnownGoodOption, NULL, FALSE},
    { MENU_ITEM,       BL_SAFEBOOT_OPTION6,      NULL, "SAFEBOOT:DSREPAIR SOS",      -1, 0, 0, NULL, NULL, FALSE},
    { MENU_ITEM,       BL_DEBUG_OPTION,          NULL, "DEBUG",                      -1, 0, 0, NULL, NULL, FALSE},
    
#if defined(REMOTE_BOOT)
    { MENU_BLANK_LINE, 0,                        NULL, NULL,                         -1, 0, 0, NULL, BlIsRemoteBootValid, FALSE},
    { MENU_ITEM,       BL_REMOTEBOOT_OPTION1,    NULL, NULL,                         -1, 0, 0, BlProcessOschooserOption, BlIsRemoteBootValid, FALSE},
    { MENU_ITEM,       BL_REMOTEBOOT_OPTION2,    NULL, NULL,                         -1, 0, 0, BlProcessRepinOption, BlIsRemoteBootValid, FALSE},
    { MENU_ITEM,       BL_REMOTEBOOT_OPTION3,    NULL, NULL,                         -1, 0, 0, BlDisableCSC, BlIsRemoteBootValid, FALSE},   
#endif // defined(REMOTE_BOOT)

    { MENU_BLANK_LINE, 0,                        NULL, NULL,                         -1, 0, 1, NULL, NULL, FALSE},
    { MENU_ITEM,       BL_MSG_BOOT_NORMALLY,     NULL, NULL,                         -1, 0, 1, NULL, NULL, TRUE},
    { MENU_ITEM,       BL_MSG_REBOOT,            NULL, NULL,                         -1, 0, 0, NULL, NULL, FALSE},
    { MENU_ITEM,       BL_MSG_OSCHOICES_MENU,   NULL, NULL,                          -1, 0, 0, NULL, BlIsReturnToOSChoicesValid, FALSE}
};

#define MaxAdvancedBootOptions  (sizeof(AdvancedBootOptions)/sizeof(ADVANCEDBOOT_OPTIONS))


PTSTR
BlGetAdvancedBootDisplayString(
    LONG BootOption
    )

/*++

Routine Description:

    Returns a pointer to the display string for a specific
    boot option.

Arguments:

    BootOption  - Desired boot option.  Must correspond to an entry
                  in the AdvancedBootOptions table.

Return Value:

    PSTR    - Pointer to the display string for the specified boot option.

--*/

{
    if (BootOption > MaxAdvancedBootOptions-1) {
        return TEXT("");
    }

    return AdvancedBootOptions[BootOption].DisplayStr;
}

ULONG
BlGetAdvancedBootID(
    LONG BootOption
    )

/*++

Routine Description:

    Returns a ULONG indicating the string ID for a specific
    boot option.

Arguments:

    BootOption  - Desired boot option.  Must correspond to an entry
                  in the AdvancedBootOptions table.

Return Value:
    MessageID for the string which is displayed for the
    the advanced boot option in the menu (unique ID).

--*/

{
    if (BootOption > MaxAdvancedBootOptions-1) {
        return -1;
    }

    return AdvancedBootOptions[BootOption].MsgId;
}

PSTR
BlGetAdvancedBootLoadOptions(
    LONG BootOption
    )

/*++

Routine Description:

    Returns a pointer to the load options string for a specific
    boot option.

Arguments:

    BootOption  - Desired boot option.  Must correspond to an entry
                  in the AdvancedBootOptions table.

Return Value:

    PSTR    - Pointer to the load options string for the specified boot option.

--*/

{
    if (BootOption > MaxAdvancedBootOptions-1) {
        return "";
    }

    return AdvancedBootOptions[BootOption].LoadOptions;
}


void
BlDoAdvancedBootLoadProcessing(
    LONG BootOption
    )

/*++

Routine Description:

    Performs any processing necessary for a
    boot option.  This is used if the necessary action
    needed for a specific boot option cannot be
    expressed in terms of a load option string.

Arguments:

    BootOption  - Desired boot option.  Must correspond to an entry
                  in the AdvancedBootOptions table.

Return Value:

    Nothing.

--*/

{
    if (BootOption > MaxAdvancedBootOptions-1 || AdvancedBootOptions[BootOption].ProcessFunc == NULL) {
        return;
    }

    AdvancedBootOptions[BootOption].ProcessFunc();
}


void
BlProcessLastKnownGoodOption(
    void
    )

/*++

Routine Description:

    Performs LKG processing by simply setting a
    global boolean to TRUE.

Arguments:

    None.

Return Value:

    Nothing.

--*/

{
    ForceLastKnownGood = TRUE;
}


#if defined(REMOTE_BOOT)
void
BlProcessOschooserOption(
    void
    )

/*++

Routine Description:

    Brings up OSchooser so user can do remote boot maintenance.

Arguments:

    None.

Return Value:

    Nothing.

--*/

{
    return; // not yet implemented
}


void
BlProcessRepinOption(
    void
    )

/*++

Routine Description:

    Sets NetBootRepin to cause the CSC to be repinned.

Arguments:

    None.

Return Value:

    Nothing.

--*/

{
    NetBootRepin = TRUE;
    NetBootCSC = FALSE;
}

void
BlDisableCSC(
    void
    )

/*++

Routine Description:

    Clears NetBootCSC to cause the CSC to be disabled so that the local CSC
    can be inspected.

Arguments:

    None.

Return Value:

    Nothing.

--*/

{
    NetBootCSC = FALSE;
}

int
BlIsRemoteBootValid(
    void
    )

/*++

Routine Description:

    Used for the remote boot options so that they
    can be displayed dynamically.

Arguments:

    None.

Return Value:

    TRUE or FALSE.

--*/

{
    return BlBootingFromNet;
}
#endif // defined(REMOTE_BOOT)


LONG
BlDoAdvancedBoot(
    IN ULONG MenuTitleId,
    IN LONG DefaultBootOption,
    IN BOOLEAN AutoAdvancedBoot,
    IN UCHAR Timeout
    )

/*++

Routine Description:

    Displays the menu of boot options and allows the user to select one
    by using the arrow keys.

Arguments:

    MenuTitleId         - the message ID of the title for the menu.  The title
                          will be different depending on whether the user 
                          selected advanced boot or whether the loader has 
                          determined that the system didn't boot or shutdown
                          correctly (auto advanced boot)
    
    DefaultBootOption   - menu selection to set the highligh on
                          when the menu is drawn the first time.

    AutoAdvancedBoot    - the menu is being displayed by the auto-advanced boot 
                          code.  In this case a simplified menu is displayed 
                          containing the options relevant to recovering from a 
                          detected crash.

    Timeout             - the number of seconds to wait for input before
                          simply returning the default boot option.
                          A timeout value of 0 means no timeout (the menu will
                          stay up until an option is chosen)

Return Value:

    LONG - The index of the advanced boot option that was selected
           or -1 to reset the selection to "nothing".

--*/

{
    PTCHAR Title;
    PTCHAR MoveHighlight;
    ULONG i,j;
    ULONG MaxLength;
    ULONG CurrentLength;
    ULONG Selection;
    ULONG Key;
    ULONG NumValidEntries = 0;
    BOOLEAN DisplayMenu;
    UCHAR ch;
    ULONG Count;

    PTCHAR TimeoutMessage;
    ULONG LastTime;
    ULONG TicksRemaining = -1;
    ULONG SecondsRemaining = -1;

    ULONG OptionStartY;
    ULONG CurrentX;
    ULONG CurrentY;

    ULONG MenuDefault;

    //
    // load any resource strings
    //

    Title = BlFindMessage(MenuTitleId);

    MoveHighlight = BlFindMessage(BL_MOVE_HIGHLIGHT);

    TimeoutMessage = BlFindMessage(BL_ADVANCEDBOOT_TIMEOUT);

    if (Title == NULL || MoveHighlight == NULL || TimeoutMessage == NULL) {
        return -1;
    }

    //
    // Remove the newline at the end of the timeout message.
    //

    {
        PTCHAR p;
        p=_tcschr(TimeoutMessage,TEXT('\r'));
        if (p!=NULL) {
            *p=TEXT('\0');
        }
    }

    //
    // print the screen header, etc.
    //
#ifdef EFI
    BlEfiSetAttribute( DEFATT );    
    BlClearScreen();
    BlEfiPositionCursor(0, HEADER_START_Y);
#else
    ARC_DISPLAY_CLEAR();
    ARC_DISPLAY_ATTRIBUTES_OFF();
    ARC_DISPLAY_POSITION_CURSOR(0, HEADER_START_Y);
#endif
    BlPrint(Title);

#ifdef EFI
    BlEfiGetCursorPosition(&CurrentX, &CurrentY);
#else
    TextGetCursorPosition(&CurrentX, &CurrentY);
#endif

    OptionStartY = CurrentY;

    //
    // check to see which boot options are valid.  While we're scanning save
    // the index of the default option.
    //

    for (i=0,MaxLength=0; i<MaxAdvancedBootOptions; i++) {
        if (AutoAdvancedBoot && !AdvancedBootOptions[i].AutoAdvancedBootOption) {
            AdvancedBootOptions[i].UseEntry = FALSE;
        } else if (AdvancedBootOptions[i].IsValid) {
            AdvancedBootOptions[i].UseEntry = AdvancedBootOptions[i].IsValid();
        } else {
            AdvancedBootOptions[i].UseEntry = TRUE;
        }
        
        if(AdvancedBootOptions[i].IsDefault) {
            MenuDefault = i;
        }
    }

    //
    // check to see which boot options are invalid based
    // on the presence of other boot options
    //

    for (i=0,MaxLength=0; i<MaxAdvancedBootOptions; i++) {
        if (AdvancedBootOptions[i].RemoveIfPresent != -1) {
            if (AdvancedBootOptions[AdvancedBootOptions[i].RemoveIfPresent].UseEntry) {
                AdvancedBootOptions[i].UseEntry = FALSE;
            }
        }
    }

    //
    // count the number of valid entries
    //

    for (i=0,MaxLength=0; i<MaxAdvancedBootOptions; i++) {
        if (AdvancedBootOptions[i].UseEntry) {
            NumValidEntries += 1;
        }
    }

    //
    // load all the string for the various boot options
    // Find the longest string in the selections, so we know how long to
    // make the highlight bar.
    //

    for (i=0,MaxLength=0; i<MaxAdvancedBootOptions; i++) {
        if (AdvancedBootOptions[i].MenuType == MENU_ITEM && AdvancedBootOptions[i].UseEntry) {
            if (AdvancedBootOptions[i].DisplayStr == NULL) {
                AdvancedBootOptions[i].DisplayStr = BlFindMessage(AdvancedBootOptions[i].MsgId);
                if (AdvancedBootOptions[i].DisplayStr == NULL) {
                    return -1;
                }
            }
            CurrentLength = _tcslen(AdvancedBootOptions[i].DisplayStr);
            if (CurrentLength > MaxLength) {
                MaxLength = CurrentLength;
            }
        }
    }

    //
    // print the trailer message
    //
#ifdef EFI
    BlEfiPositionCursor(0, OptionStartY + NumValidEntries);
#else
    ARC_DISPLAY_POSITION_CURSOR(0, OptionStartY + NumValidEntries);
#endif
    BlPrint(MoveHighlight);

    //
    // process the menu
    //

    Selection = ((DefaultBootOption == -1) ? 
                    MenuDefault : 
                    DefaultBootOption);

    while (AdvancedBootOptions[Selection].UseEntry == FALSE) {
        Selection += 1;
    }

    DisplayMenu = TRUE;

    if(Timeout) {
        
        //
        // according to the code in the boot loader there are roughly 18.2 
        // ticks per second from the counter.
        //

        TicksRemaining = Timeout * 182 / 10;

        //
        // Now that we've rounded, compute the number of seconds remaining as 
        // well.  We'll use this to determine if the menu needs updated.
        //

        SecondsRemaining = (TicksRemaining * 10) / 182;

        dbg(("Timeout = %#x, Ticks = %#x, Seconds = %#x\n", Timeout, TicksRemaining, SecondsRemaining));
    }

    //
    // Save the current time as the last time.
    //

    LastTime = GET_COUNTER();

    do {
        ULONG CurrentTime = 0;

        dbg(("*****"));

        //
        // Decrement the number of ticks remaining.  Compare the current time 
        // to the last time and subtract that many ticks.
        //

        if (Timeout) {
            ULONG CurrentTime;
            ULONG s;
            ULONG Delta;

            CurrentTime = GET_COUNTER();

            dbg(("%x - %x", CurrentTime, LastTime));

            //
            // The counter wraps at midnight.  However if current time is 
            // less than or equal to last time we'll just ignore this 
            // iteration.
            //

            if (CurrentTime >= LastTime) {
                Delta = CurrentTime - LastTime;
            } else {
                Delta = 1;
            }

            dbg(("= %x. %x - %x = ", Delta, TicksRemaining, Delta));

            TicksRemaining -= min(TicksRemaining, Delta);

            LastTime = CurrentTime;

            dbg(("%x. ", TicksRemaining));

            //
            // If there are no ticks left then terminate the loop.
            //

            if(TicksRemaining == 0) {
                dbg(("timeout\n"));
                dbgbrk();
                Selection = -1;
                break;
            }

            //
            // Compute the current number of seconds remaining.  If it's not
            // equal to what it was before then we'll need to update the 
            // menu.
            //

            s = (TicksRemaining * 10) / 182;

            dbg(("-> s %x/%x ", SecondsRemaining, s));

            if(SecondsRemaining > s) {
                SecondsRemaining = s;
                DisplayMenu = TRUE;
                dbg(("update "));
            }

            dbg(("\n"));
        }

        //
        // print the menu
        //
        if (DisplayMenu) {

            dbg(("Printing Menu: ticks = %#08lx.  Sec = %d.  Last = %#08lx  Current = %08lx\n", 
                 TicksRemaining, 
                 SecondsRemaining,
                 LastTime,
                 CurrentTime
                 ));

            for (i=0,j=1; i<MaxAdvancedBootOptions; i++) {
                if (AdvancedBootOptions[i].UseEntry) {
#ifdef EFI
                    BlEfiPositionCursor(0, OptionStartY + j);
#else
                    ARC_DISPLAY_POSITION_CURSOR(0, OptionStartY + j);
#endif
                    if (i==Selection) {
#ifdef EFI
                        //BlEfiSetInverseMode( TRUE );
                        BlEfiSetAttribute( INVATT );    
#else
                        ARC_DISPLAY_INVERSE_VIDEO();
#endif
                    } else {
#ifdef EFI
                        //BlEfiSetInverseMode( FALSE );
                        BlEfiSetAttribute( DEFATT );
#else
                        ARC_DISPLAY_ATTRIBUTES_OFF();
#endif
                    }

                    if (AdvancedBootOptions[i].MenuType == MENU_ITEM) {
                        BlPrint( TEXT("    %s"), AdvancedBootOptions[i].DisplayStr);
                    }

#ifdef EFI
                    if (i == Selection) {
                        //BlEfiSetInverseMode( FALSE );
                        BlEfiSetAttribute( DEFATT );
                    }
#else
                    ARC_DISPLAY_ATTRIBUTES_OFF();
#endif
                    j += 1;
                }
            }

#ifdef EFI
            BlEfiPositionCursor(0, OptionStartY + NumValidEntries + 3);
#else
            ARC_DISPLAY_POSITION_CURSOR(0, OptionStartY + NumValidEntries + 3);
#endif

            if(Timeout) {
                BlPrint( TEXT("%s"), TimeoutMessage);
                BlPrint(TEXT(" %d \n"),SecondsRemaining);
            } else {
#ifdef EFI
                BlEfiClearToEndOfLine();
#else
                ARC_DISPLAY_CLEAR_TO_EOL();
#endif
            }

            DisplayMenu = FALSE;
        }

        //
        // Poll for a key.
        //
        Key = BlGetKey();

        //
        // Any input cancels the timeout.
        //

        if(Key) {
            Timeout = 0;
        }

        //
        // Check for selection.
        //

        //
        // The ESCAPE_KEY does nothing if this is an auto advanced boot.
        //

        if ((AutoAdvancedBoot == FALSE) && (Key == ESCAPE_KEY)) {
            //
            // reset the selection to "nothing"
            //
            return -1;
        }        

        if ( (Key==UP_ARROW) || (Key==DOWN_ARROW) || (Key==HOME_KEY) || (Key==END_KEY)) {

            DisplayMenu = TRUE;

            if (Key==DOWN_ARROW) {
                Selection = (Selection+1) % MaxAdvancedBootOptions;
            } else if (Key==UP_ARROW) {
                Selection = (Selection == 0) ? (MaxAdvancedBootOptions-1) : (Selection - 1);
            } else if (Key==HOME_KEY) {
                Selection = 0;
            } else if (Key==END_KEY) {
                Selection = MaxAdvancedBootOptions-1;
                //
                // search for the last valid entry
                //
                i = Selection;
                while (AdvancedBootOptions[i].UseEntry == FALSE) {
                    i -= 1;
                }
                Selection = i;
            }

            //
            // don't let the highlight line rest on a blank line
            //

            while((AdvancedBootOptions[Selection].UseEntry == FALSE) ||
                  (AdvancedBootOptions[Selection].MenuType == MENU_BLANK_LINE)) {

                if(Key == DOWN_ARROW) {
                    Selection = (Selection + 1) % MaxAdvancedBootOptions;
                } else if (Key == UP_ARROW) {
                    Selection = (Selection == 0) ? (MaxAdvancedBootOptions - 1) : (Selection - 1);
                }
            }
        }

    } while ( ((Key&(ULONG)0xff) != ENTER_KEY) );

    //
    // If Return to OS Choices selected, go back to main menu
    //
    if ((Selection != -1) && 
            (AdvancedBootOptions[Selection].MsgId == BL_MSG_OSCHOICES_MENU)) {
        Selection = -1;                
    }        
    
    return Selection;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\ia64\trapc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    trapc.c

Abstract:

    This module implements the specific exception handlers for EM
    exceptions. Called by the BdGenericExceptionHandler.

Author:

    Bernard Lint 4-Apr-96

Environment:

    Kernel mode only.

Revision History:

--*/

#include "bd.h"


typedef struct _BREAK_INST {
    union {
        struct {
            ULONGLONG qp:    6;
            ULONGLONG imm20: 20;
            ULONGLONG x:     1;
            ULONGLONG x6:    6;
            ULONGLONG x3:    3;
            ULONGLONG i:     1;
            ULONGLONG Op:    4;
            ULONGLONG Rsv:   23; 
        } i_field;
        ULONGLONG Ulong64;
    } u;
} BREAK_INST;

ULONG
BdExtractImmediate (
    IN ULONGLONG Iip,
    IN ULONG SlotNumber
    )

/*++

Routine Description:

    Extract immediate operand from break instruction.

Arguments:

    Iip - Bundle address of instruction
    
    SlotNumber - Slot of break instruction within bundle

Return Value:

    Value of immediate operand.

--*/

{
    PULONGLONG BundleAddress;
    ULONGLONG BundleLow;
    ULONGLONG BundleHigh;
    BREAK_INST BreakInst;
    ULONG Imm21;

    BundleAddress = (PULONGLONG)Iip;

    BundleLow = *BundleAddress;
    BundleHigh = *(BundleAddress+1);
    
    //
    // Align instruction
    //
    
    switch (SlotNumber) {
        case 0:
            BreakInst.u.Ulong64 = BundleLow >> 5;
            break;

        case 1:
            BreakInst.u.Ulong64 = (BundleLow >> 46) | (BundleHigh << 18);
            break;

        case 2:
            BreakInst.u.Ulong64 = (BundleHigh >> 23);
            break;
    }
    
    //
    // Extract immediate value
    //

    Imm21 = (ULONG)(BreakInst.u.i_field.i<<20) | (ULONG)(BreakInst.u.i_field.imm20);

    return Imm21;
}


BOOLEAN
BdOtherBreakException (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    Handler for break exception other than the ones for fast and
    normal system calls. This includes debug break points.

Arguments:

    TrapFrame - Pointer to the trap frame.

Return Value:

    NT status code.

--*/

{
    PEXCEPTION_RECORD ExceptionRecord;
    ULONG BreakImmediate;
    ISR Isr;

    BreakImmediate = (ULONG)(TrapFrame->StIIM);

    //
    // Handle break.b case
    //
    if (BreakImmediate == 0) {
       Isr.ull = TrapFrame->StISR;
       BreakImmediate = BdExtractImmediate(TrapFrame->StIIP,
                                           (ULONG)Isr.sb.isr_ei);
       TrapFrame->StIIM = BreakImmediate;
    }

    //
    // Initialize exception record
    //

    ExceptionRecord = (PEXCEPTION_RECORD)&TrapFrame->ExceptionRecord;
    ExceptionRecord->ExceptionAddress = 
        (PVOID) RtlIa64InsertIPSlotNumber(TrapFrame->StIIP,
                                 ((TrapFrame->StISR & ISR_EI_MASK) >> ISR_EI));
 
    ExceptionRecord->ExceptionFlags = 0;
    ExceptionRecord->ExceptionRecord = (PEXCEPTION_RECORD)NULL;
 
    ExceptionRecord->NumberParameters = 5;
    ExceptionRecord->ExceptionInformation[0] = 0;
    ExceptionRecord->ExceptionInformation[1] = 0;
    ExceptionRecord->ExceptionInformation[2] = 0;
    ExceptionRecord->ExceptionInformation[3] = TrapFrame->StIIPA;
    ExceptionRecord->ExceptionInformation[4] = TrapFrame->StISR;
 
    switch (BreakImmediate) {

    case KERNEL_BREAKPOINT:
    case USER_BREAKPOINT:
    case BREAKPOINT_PRINT:
    case BREAKPOINT_PROMPT:
    case BREAKPOINT_STOP:
    case BREAKPOINT_LOAD_SYMBOLS:
    case BREAKPOINT_UNLOAD_SYMBOLS:
    case BREAKPOINT_BREAKIN:
        ExceptionRecord->ExceptionCode = STATUS_BREAKPOINT;
        ExceptionRecord->ExceptionInformation[0] = BreakImmediate;
        break;

    case INTEGER_DIVIDE_BY_ZERO_BREAK:
        ExceptionRecord->ExceptionCode = STATUS_INTEGER_DIVIDE_BY_ZERO;
        break;

    case INTEGER_OVERFLOW_BREAK:
        ExceptionRecord->ExceptionCode = STATUS_INTEGER_OVERFLOW;
        break;

    case MISALIGNED_DATA_BREAK:
        ExceptionRecord->ExceptionCode = STATUS_DATATYPE_MISALIGNMENT;
        break;

    case RANGE_CHECK_BREAK:
    case NULL_POINTER_DEFERENCE_BREAK:
    case DECIMAL_OVERFLOW_BREAK:
    case DECIMAL_DIVIDE_BY_ZERO_BREAK:
    case PACKED_DECIMAL_ERROR_BREAK:
    case INVALID_ASCII_DIGIT_BREAK:
    case INVALID_DECIMAL_DIGIT_BREAK:
    case PARAGRAPH_STACK_OVERFLOW_BREAK:

    default:
#if 0
#if DBG
        InbvDisplayString ("BdOtherBreakException: Unknown break code.\n");
#endif // DBG
#endif
        ExceptionRecord->ExceptionCode = STATUS_ILLEGAL_INSTRUCTION;
        break;
    }

    return TRUE;
}


BOOLEAN
BdSingleStep (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    Handler for single step trap. An instruction was successfully
    executed and the PSR.ss bit is 1.

Arguments:

    TrapFrame - Pointer to the trap frame.

Return Value:

    None.

Notes:

    ISR.ei bits indicate which instruction caused the exception.

    ISR.code{3:0} = 1000

--*/

{
    PEXCEPTION_RECORD ExceptionRecord;
    ULONG IpsrRi;

    //
    // Initialize the exception record
    //

    ExceptionRecord = (PEXCEPTION_RECORD)&TrapFrame->ExceptionRecord;

    //
    // We only want the low order 2 bits so typecast to ULONG
    //
    IpsrRi = (ULONG)(TrapFrame->StIPSR >> PSR_RI) & 0x3;

    ExceptionRecord->ExceptionAddress =
           (PVOID) RtlIa64InsertIPSlotNumber(TrapFrame->StIIP, IpsrRi);

    ExceptionRecord->ExceptionFlags = 0;
    ExceptionRecord->ExceptionRecord = (PEXCEPTION_RECORD)NULL;

    ExceptionRecord->NumberParameters = 5;
    ExceptionRecord->ExceptionInformation[0] = 0;
    ExceptionRecord->ExceptionInformation[1] = 0; // 0 for traps
    ExceptionRecord->ExceptionInformation[2] = 0;
    ExceptionRecord->ExceptionInformation[3] = TrapFrame->StIIPA;
    ExceptionRecord->ExceptionInformation[4] = TrapFrame->StISR;

    ExceptionRecord->ExceptionCode = STATUS_SINGLE_STEP;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\ia64\trap.s ===
//++
//
// Module Name:
//       trap.s
//
// Abstract:
//       Low level interruption handlers
//
// Author:
//       Bernard Lint      12-Jun-1995
//
// Environment:
//       Kernel mode only
//
// Revision History:
//
//
// Open Design Issues:
//
//       1. Optimizations for more than 2-way parallelism when 
//          regsiters available.
//--

#include "ksia64.h"

         .file "trap.s"

//
// Globals imported:
//

        .global BdPcr

        PublicFunction(BdSetMovlImmediate)
        PublicFunction(BdInstallVectors)
        PublicFunction(BdTrap)
        PublicFunction(BdOtherBreakException)
        PublicFunction(BdSingleStep)
        PublicFunction(BdIvtStart)
        PublicFunction(BdIvtEnd)
        PublicFunction(RtlCopyMemory)

//
// Register aliases used throughout the entire module
//

//
// Banked general registers
// 

//
// Register aliases used throughout the entire module
//

//
// Banked general registers
// 

//
// Register aliases used throughout the entire module
//

//
// Banked general registers
// 
// h16-h23 can only be used when psr.ic=1.
//
// h24-h31 can only be used when psr.ic=0 (these are reserved for tlb
// and pal/machine check handlers when psr.ic=1).
//

//
// Shown below are aliases of bank 0 registers used in the low level handlers
// by macros ALLOCATE_TRAP_FRAME, SAVE_INTERRUPTION_RESOURCES, and 
// NORMAL_KERNEL_EXIT.  When the code in the macros are changes, these
// register aliases must be reviewed.
//

        rHIPSR      = h16
        rHpT2       = h16

        rHIIPA      = h17
        rHRSC       = h17
        rHDfhPFS    = h17  // used to preserve pfs in BdDisabledFpRegisterVector

        rHIIP       = h18
        rHFPSR      = h18

        rHOldPreds  = h19
        rHBrp       = h19
        rHDCR       = h19

        rHIFS       = h20
        rHPFS       = h20
        rHBSP       = h20

        rHISR       = h21
        rHUNAT      = h21
        rHpT3       = h21
        
        rHSp        = h22
        rHDfhBrp    = h22  // used to preserve brp in BdDisabledFpRegisterVector
        rHpT4       = h22

        rHpT1       = h23
        
        rHIFA       = h24
        rTH3        = h24

        rHHandler   = h25
        rTH1        = h26
        rTH2        = h27
        rHIIM       = h28
        rHEPCVa     = h29

        rHEPCVa2    = h30
        rPanicCode  = h30

//
// General registers used through out module
//

        pApc      = ps0                         // User Apc Pending
        pUser     = ps1                         // mode on entry was user
        pKrnl     = ps2                         // mode on entry was kernel
        pUstk     = ps3
        pKstk     = ps4
        pEM       = ps5                         // EM ISA on kernel entry
        pIA       = ps6                         // X86 ISA on kernel entry

//
// Kernel registers used through out module
//
        rkHandler = k6                          // specific exception handler




//
// Macro definitions for this module only
//

//
// Define vector/exception entry/exit macros.
// N.B. All HANDLER_ENTRY functions go into .nsc section with
//      BdNormalSystemCall being the first.
//

#define HANDLER_ENTRY(Name)                     \
        .##global Name;                         \
        .##proc   Name;                         \
Name::

#define HANDLER_ENTRY_EX(Name, Handler)         \
        .##global Name;                         \
        .##proc   Name;                         \
        .##type   Handler, @function;           \
        .##personality Handler;                 \
Name::

#define  VECTOR_ENTRY(Offset, Name, Extra0)     \
        .##org Offset;                          \
        .##global Name;                         \
        .##proc   Name;                         \
Name::

#define VECTOR_EXIT(Name)                       \
        .##endp Name

#define HANDLER_EXIT(Name)                      \
        .##endp Name


//++
// Routine:
//
//       IO_END_OF_INTERRUPT(rVector,rT1,rT2,pEOI)
//
// Routine Description:
//
//       HalEOITable Entry corresponding to the vectorNo is tested.
//       If the entry is nonzero, then vectorNo is stored to the location
//       specified in the entry. If the entry is zero, return.
//
// Arguements:
//
//
// Notes:
//
//       MS preprocessor requires /*   */ style comments
//
//--

#define IO_END_OF_INTERRUPT(rVector,rT1,rT2,pEOI)                             ;\
        add         rT1 = @gprel(__imp_HalEOITable),gp                        ;\
        ;;                                                                    ;\
        ld8         rT1 = [rT1]                                               ;\
        ;;                                                                    ;\
        shladd      rT2 = rVector,3,rT1                                       ;\
        ;;                                                                    ;\
        ld8         rT1 = [rT2]                                               ;\
        ;;                                                                    ;\
        cmp.ne      pEOI = zero, rT1                                          ;\
        ;;                                                                    ;\
(pEOI)  st4.rel     [rT1] = rVector


//++
// Routine:
//
//       VECTOR_CALL_HANDLER(Handler, SpecificHandler)
//
// Routine Description:
//
//       Common code for transfer to heavyweight handlers from
//       interruption vectors. Put RSE in store intensive mode,
//       cover current frame and call handler.
//
// Arguments:
//
//       Handler: First level handler for this vector
//       SpecificHandler: Specific handler to be called by the generic
//                        exception handler.
//
// Return Value:
//
//       None
//
// Notes: 
//      Uses just the kernel banked registers (h16-h31)
//
//      MS preprocessor requires /* */ style comments
//--


#define VECTOR_CALL_HANDLER(Handler,SpecificHandler)                          ;\
        mov         rHIFA = cr##.##ifa                                        ;\
        movl        rTH1 = BdPcr+PcSavedIFA                                   ;\
        ;;                                                                    ;\
                                                                              ;\
        st8         [rTH1] = rHIFA                                            ;\
        movl        rHHandler = SpecificHandler                               ;\
        br##.##sptk Handler                                                   ;\
        ;;

//++
// Routine:
//
//       ALLOCATE_TRAP_FRAME
//
// Routine Description:
//
//       Common code for allocating trap frame on kernel entry for heavyweight
//       handler.
//
// On entry:
//
// On exit: sp -> trap frame; any instruction that depends on sp must be
//          placed in the new instruction group.  Interruption resources
//          ipsr, iipa, iip, predicates, isr, sp, ifs are captured in
//          seven of the banked registers h16-23.  The last one is used
//          by SAVE_INTERRUPTION_STATE as a pointer to save these resources
//          in the trap frame.
//
// Return Value:
//
//       None
//
// Notes: 
//      Uses just the kernel banked registers (h16-h31)
//
//      MS preprocessor requires /* */ style comments below
//--

#define ALLOCATE_TRAP_FRAME                                                   ;\
                                                                              ;\
        pOverflow   = pt2                                                     ;\
                                                                              ;\
        mov         rHIPSR = cr##.##ipsr                                      ;\
        mov         rHIIP = cr##.##iip                                        ;\
        cover                                   /* cover and save IFS       */;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHIIPA = cr##.##iipa                                      ;\
        movl        rTH2 = MM_EPC_VA                                          ;\
                                                                              ;\
        mov         rTH3 = ar##.##bsp                                         ;\
        mov         rHOldPreds = pr                                           ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHIFS = cr##.##ifs                                        ;\
        add         rHEPCVa = 0x30, rTH2                                      ;\
                                                                              ;\
        mov         rHISR = cr##.##isr                                        ;\
        movl        rTH2 = BdPcr+PcInitialStack                               ;\
                                                                              ;\
        tbit##.##z  pEM, pIA = rHIPSR, PSR_IS           /* set instr set    */;\
        extr##.##u  rTH1 = rHIPSR, PSR_CPL, PSR_CPL_LEN /* get mode         */;\
        mov         rHSp = sp                                                 ;\
        ;;                                                                    ;\
                                                                              ;\
        ssm         (1 << PSR_IC) | (1 << PSR_DFH) | (1 << PSR_AC)            ;\
        cmp4##.##eq pKrnl, pUser = PL_KERNEL, rTH1   /* set mode pred       */;\
        cmp4##.##eq pKstk, pUstk = PL_KERNEL, rTH1   /* set stack pred      */;\
        ;;                                                                    ;\
                                                                              ;\
.pred.rel "mutex",pUstk,pKstk                                                 ;\
        add         sp = -TrapFrameLength, sp           /* allocate TF      */;\
        ;;                                                                    ;\
        add         rHpT1 = TrStIPSR, sp                                      ;\
        ;;


//++
// Routine:
//
//       SAVE_INTERRUPTION_STATE(Label)
//
// Routine Description:
//
//       Common code for saving interruption state on entry to a heavyweight
//       handler.
//
// Arguments:
//
//       Label: label for branching around BSP switch
//
// On entry:
//
//       sp -> trap frame
//
// On exit:
//
//       Static registers gp, teb, sp, fpsr spilled into the trap frame.
//       Registers gp, teb, fpsr are set up for kernel mode execution.
//
// Return Value:
//
//       None
//
// Notes: 
//
//      Interruption resources already captured in bank 0 registers h16-h23.
//      It's safe to take data TLB fault when saving them into the trap
//      frame because kernel stack is always resident in memory.  This macro
//      is carefully constructed to save the bank registers' contents in
//      the trap frame and reuse them to capture other register states as
//      soon as they are available.  Until we have a virtual register
//      allocation scheme in place, the bank 0 register aliases defined at
//      the beginning of the file must be updated when this macro is modified.
//      
//      MS preprocessor requires /* */ style comments below
//--


#define SAVE_INTERRUPTION_STATE(Label)                                        ;\
                                                                              ;\
/* Save interruption resources in trap frame */                               ;\
                                                                              ;\
                                                                              ;\
        srlz##.##i                            /* I serialize required       */;\
        st8         [rHpT1] = rHIPSR, TrStISR-TrStIPSR /* save IPSR         */;\
        add         rHpT2 = TrPreds, sp               /* -> Preds           */;\
        ;;                                                                    ;\
                                                                              ;\
        st8         [rHpT1] = rHISR, TrStIIP-TrStISR  /* save ISR           */;\
        st8         [rHpT2] = rHOldPreds, TrBrRp-TrPreds                      ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHUNAT = ar##.##unat                                      ;\
        st8         [rHpT1] = rHIIP, TrStIFS-TrStIIP  /* save IIP           */;\
        mov         rHBrp = brp                                               ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHFPSR = ar##.##fpsr                                      ;\
        st8         [rHpT1] = rHIFS, TrStIIPA-TrStIFS /* save IFS           */;\
        mov         rHPFS = ar##.##pfs                                        ;\
        ;;                                                                    ;\
                                                                              ;\
        st8         [rHpT1] = rHIIPA, TrStFPSR-TrStIIPA /* save IIPA        */;\
        st8         [rHpT2] = rHBrp, TrRsPFS-TrBrRp                           ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHRSC = ar##.##rsc                                        ;\
        st8         [rHpT2] = rHPFS                   /* save PFS           */;\
        add         rHpT2 = TrApUNAT, sp                                      ;\
                                                                              ;\
        mov         rHBSP = ar##.##bsp                                        ;\
        mov         rHDCR = cr##.##dcr                                        ;\
        ;;                                                                    ;\
                                                                              ;\
        st8         [rHpT1] = rHFPSR, TrRsRSC-TrStFPSR /* save FPSR         */;\
        st8         [rHpT2] = rHUNAT, TrIntGp-TrApUNAT /* save UNAT         */;\
        ;;                                                                    ;\
                                                                              ;\
        st8         [rHpT1] = rHRSC, TrRsBSP-TrRsRSC  /* save RSC           */;\
        st8##.##spill [rHpT2] = gp, TrIntTeb-TrIntGp  /* spill GP           */;\
        ;;                                                                    ;\
                                                                              ;\
        st8##.##spill [rHpT2] = teb, TrIntSp-TrIntTeb /* spill TEB (r13)    */;\
        mov         teb = kteb                        /* sanitize teb       */;\
        ;;                                                                    ;\
                                                                              ;\
        st8         [rHpT1] = rHBSP                   /* save BSP           */;\
        movl        rHpT1 = BdPcr + PcKernelGP                                ;\
                                                                              ;\
(pUstk) mov         ar##.##rsc = RSC_KERNEL_DISABLED  /* turn off RSE       */;\
        st8##.##spill [rHpT2] = rHSp, TrApDCR-TrIntSp /* spill SP           */;\
        ;;                                                                    ;\
                                                                              ;\
        st8         [rHpT2] = rHDCR                   /* save DCR           */;\
(pKstk) br##.##dpnt Label                       /* br if on kernel stack    */;\
                                                                              ;\
                                                                              ;\
/*                                                                          */;\
/* Local register aliases for back store switch                             */;\
/* N.B. These must be below h24 since PSR.ic = 1 at this point              */;\
/*      h16-h23 are available                                               */;\
/*                                                                          */;\
                                                                              ;\
        rpRNAT    = h16                                                       ;\
        rpBSPStore= h17                                                       ;\
        rBSPStore = h18                                                       ;\
        rKBSPStore= h19                                                       ;\
        rRNAT     = h20                                                       ;\
        rKrnlFPSR = h21                                                       ;\
        rEFLAG    = h22                                                       ;\
                                                                              ;\
/*                                                                          */;\
/* If previous mode is user, switch to kernel backing store                 */;\
/* -- uses the "loadrs" approach. Note that we do not save the              */;\
/* BSP/BSPSTORE in the trap frame if prvious mode was kernel                */;\
/*                                                                          */;\
                                                                              ;\
                                                                              ;\
        mov       rBSPStore = ar##.##bspstore   /* get user bsp store point */;\
        mov       rRNAT = ar##.##rnat           /* get RNAT                 */;\
        add       rpRNAT = TrRsRNAT, sp         /* -> RNAT                  */;\
        ;;                                                                    ;\
                                                                              ;\
        ld8       rKBSPStore = [rHpT1]          /* load kernel bstore       */;\
        movl      rKrnlFPSR = FPSR_FOR_KERNEL   /* initial fpsr value       */;\
        ;;                                                                    ;\
                                                                              ;\
        mov       ar##.##fpsr = rKrnlFPSR       /* set fpsr                 */;\
        add       rpBSPStore = TrRsBSPSTORE, sp /* -> User BSPStore         */;\
        ;;                                                                    ;\
                                                                              ;\
        st8       [rpRNAT] = rRNAT              /* save user RNAT           */;\
        st8       [rpBSPStore] = rBSPStore      /* save user BSP Store      */;\
        ;;                                                                    ;\
        dep       rKBSPStore = rBSPStore, rKBSPStore, 0, 9                    ;\
                                                /* adjust kernel BSPSTORE   */;\
                                                /* for NAT collection       */;\
                                                                              ;\
        ;;                                                                    ;\
                                                                              ;\
/*                                                                          */;\
/* Now running on kernel backing store                                      */;\
/*                                                                          */;\
                                                                              ;\
Label:                                                                        ;\
(pUstk) mov       ar##.##bspstore = rKBSPStore  /* switch to kernel BSP     */;\
(pUstk) mov       ar##.##rsc = RSC_KERNEL       /* turn rse on, kernel mode */;\
        bsw##.##1                               /* switch back to user bank */;\
        ;;                                      /* stop bit required        */



//++
// Routine:
//
//       RETURN_FROM_INTERRUPTION
//
// Routine Description:
//
//       Common handler code to restore trap frame and resume execution
//       at the interruption address.
//
// Arguments:
//
//       Label
//
// Return Value:
//
//       None
//
// Note: 
//
//       On entry: interrrupts disabled, sp -> trap frame
//       On exit:
//       MS preprocessor requires /* */ style comments below
//--

#define RETURN_FROM_INTERRUPTION(Label)                                       ;\
                                                                              ;\
        .##regstk 0,3,2,0       /* must match the alloc instruction below */  ;\
                                                                              ;\
        rBSP      = loc0                                                      ;\
        rBSPStore = loc1                                                      ;\
        rRnat     = loc2                                                      ;\
                                                                              ;\
        rpT1      = t1                                                        ;\
        rpT2      = t2                                                        ;\
        rpT3      = t3                                                        ;\
        rpT4      = t4                                                        ;\
        rThread   = t6                                                        ;\
        rApcFlag  = t7                                                        ;\
        rT1       = t8                                                        ;\
        rT2       = t9                                                        ;\
                                                                              ;\
        alloc       rT1 = 0,4,2,0                                             ;\
        movl        rpT1 = BdPcr + PcCurrentThread     /* ->PcCurrentThread */;\
        ;;                                                                    ;\
                                                                              ;\
(pUstk) ld8         rThread = [rpT1]                   /* load thread ptr   */;\
        add         rBSP = TrRsBSP, sp                 /* -> user BSP       */;\
(pKstk) br##.##call##.##spnt brp = BdRestoreTrapFrame                         ;\
        ;;                                                                    ;\
                                                                              ;\
        add         rBSPStore = TrRsBSPSTORE, sp       /* -> user BSP Store */;\
        add         rRnat = TrRsRNAT, sp               /* -> user RNAT      */;\
(pKstk) br##.##spnt Label##ReturnToKernel                                     ;\
        ;;                                                                    ;\
                                                                              ;\
        add         rpT1 = ThApcState+AsUserApcPending, rThread               ;\
        ;;                                                                    ;\
        ld1         rApcFlag = [rpT1], ThAlerted-ThApcState-AsUserApcPending  ;\
        ;;                                                                    ;\
        st1.nta     [rpT1] = zero                                             ;\
        cmp##.##ne  pApc = zero, rApcFlag                                     ;\
        ;;                                                                    ;\
                                                                              ;\
        PSET_IRQL   (pApc, APC_LEVEL)                                         ;\
 (pApc) mov         out1 = sp                                                 ;\
        ;;                                                                    ;\
                                                                              ;\
 (pApc) FAST_DISABLE_INTERRUPTS                                               ;\
        PSET_IRQL   (pApc, zero)                                              ;\
                                                                              ;\
        ld8         rBSP = [rBSP]                      /* user BSP          */;\
        ld8         rBSPStore = [rBSPStore]            /* user BSP Store    */;\
        ld8         rRnat = [rRnat]                    /* user RNAT         */;\
        br##.##call##.##sptk brp = BdRestoreDebugRegisters                    ;\
        ;;                                                                    ;\
                                                                              ;\
        invala                                                                ;\
        br##.##call##.##sptk brp = BdRestoreTrapFrame                         ;\
        ;;                                                                    ;\
                                                                              ;\
                                                                              ;\
Label##CriticalExitCode:                                                      ;\
                                                                              ;\
        rHRscE = h17                                                          ;\
        rHRnat = h18                                                          ;\
        rHBSPStore = h19                                                      ;\
        rHRscD = h20                                                          ;\
        rHRscDelta = h24                                                      ;\
                                                                              ;\
        bsw##.##0                                                             ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         rHRscE = ar##.##rsc                /* save user RSC     */;\
        mov         rHBSPStore = rBSPStore                                    ;\
        mov         rHRscD = RSC_KERNEL_DISABLED                              ;\
                                                                              ;\
        sub         rHRscDelta = rBSP, rBSPStore /* delta = BSP - BSP Store */;\
        ;;                                                                    ;\
        mov         rHRnat  = rRnat                                           ;\
        dep         rHRscD = rHRscDelta, rHRscD, 16, 14  /* set RSC.loadrs  */;\
        ;;                                                                    ;\
                                                                              ;\
        alloc       rTH1 = 0,0,0,0                                            ;\
        mov         ar##.##rsc = rHRscD                /* RSE off       */    ;\
        ;;                                                                    ;\
        loadrs                                         /* pull in user regs */;\
                                                       /* up to tear point */ ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         ar##.##bspstore = rHBSPStore       /* restore user BSP */ ;\
        ;;                                                                    ;\
        mov         ar##.##rnat = rHRnat               /* restore user RNAT */;\
                                                                              ;\
Label##ReturnToKernel:                                                        ;\
                                                                              ;\
(pUstk) mov         ar.rsc = rHRscE                 /* restore user RSC     */;\
        bsw##.##0                                                             ;\
        ;;                                                                    ;\
                                                                              ;\
        add         rHpT2 = TrApUNAT, sp            /* -> previous UNAT     */;\
        add         rHpT1 = TrStFPSR, sp            /* -> previous Preds    */;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHUNAT = [rHpT2],TrPreds-TrApUNAT                         ;\
        ld8         rHFPSR = [rHpT1],TrRsPFS-TrStFPSR                         ;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHOldPreds = [rHpT2], TrIntSp-TrPreds                     ;\
        ld8         rHPFS = [rHpT1],TrStIIPA-TrRsPFS                          ;\
        ;;                                                                    ;\
                                                                              ;\
        ld8##.##fill rHSp = [rHpT2], TrBrRp-TrIntSp                           ;\
        ld8         rHIIPA = [rHpT1], TrStIIP-TrStIIPA                        ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         ar##.##fpsr = rHFPSR            /* restore FPSR         */;\
        ld8         rHIIP = [rHpT1], TrStIPSR-TrStIIP  /* load IIP          */;\
        mov         pr = rHOldPreds, -1             /* restore preds        */;\
                                                                              ;\
        mov         ar##.##unat = rHUNAT            /* restore UNAT         */;\
        ld8         rHBrp = [rHpT2], TrStIFS-TrBrRp                           ;\
        mov         ar##.##pfs = rHPFS              /* restore PFS          */;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHIFS = [rHpT2]                 /* load IFS             */;\
        ld8         rHIPSR = [rHpT1]                /* load IPSR            */;\
                                                                              ;\
        rsm         1 << PSR_IC                     /* reset ic bit         */;\
        ;;                                                                    ;\
        srlz##.##d                                  /* must serialize       */;\
        mov         brp = rHBrp                     /* restore brp          */;\
                                                                              ;\
/*                                                                          */;\
/* Restore status registers                                                 */;\
/*                                                                          */;\
                                                                              ;\
        mov         cr##.##ipsr = rHIPSR        /* restore previous IPSR    */;\
        mov         cr##.##iip = rHIIP          /* restore previous IIP     */;\
                                                                              ;\
        mov         cr##.##ifs = rHIFS          /* restore previous IFS     */;\
        mov         cr##.##iipa = rHIIPA        /* restore previous IIPA    */;\
        ;;                                                                    ;\
                                                                              ;\
/*                                                                          */;\
/* Resume at point of interruption (rfi must be at end of instruction group)*/;\
/*                                                                          */;\
        mov         sp = rHSp                   /* restore sp               */;\
        mov         h17 = r0                    /* clear TB loop count      */;\
        rfi                                                                   ;\
        ;;


//++
// Routine:
//
//       USER_APC_CHECK
//
// Routine Description:
//
//       Common handler code for requesting
//       pending APC if returning to user mode.
//
// Arguments:
//
// Return Value:
//
//       None
//
// Note: 
//
//       On entry: interrrupts disabled, sp -> trap frame
//       On exit:
//       MS preprocessor requires /* */ style comments below
//--


#define USER_APC_CHECK                                                        ;\
                                                                              ;\
/*                                                                          */;\
/* Check for pending APC's                                                  */;\
/*                                                                          */;\
                                                                              ;\
        movl        t22=BdPcr + PcCurrentThread        /* ->PcCurrentThread */;\
        ;;                                                                    ;\
                                                                              ;\
        LDPTR       (t22,t22)                                                 ;\
        ;;                                                                    ;\
        add         t22=ThApcState+AsUserApcPending, t22 /* -> pending flag */;\
        ;;                                                                    ;\
                                                                              ;\
        ld1         t8 = [t22], ThAlerted-ThApcState-AsUserApcPending         ;\
        ;;                                                                    ;\
        st1         [t22] = zero                                              ;\
        cmp##.##ne  pApc = zero, t8                  /* pApc = 1 if pending */;\
        ;;                                                                    ;\
                                                                              ;\
        PSET_IRQL   (pApc, APC_LEVEL)                                         ;\
(pApc)  mov         out1 = sp                                                 ;\
        ;;                                                                    ;\
(pApc)  FAST_DISABLE_INTERRUPTS                                               ;\
        PSET_IRQL   (pApc, zero)


//++
// Routine:
//
//       BSTORE_SWITCH
//
// Routine Description:
//
//       Common handler code for switching to user backing store, if
//       returning to user mode.
//
// On entry:
//
//      sp: pointer to trap frame
//
// On exit:
//
//      on user backing store, can't afford another alloc of any frame size
//      other than zero.  otherwise, the kernel may panic.
//
// Return Value:
//
//       None
//
// Note: 
//
//       MS preprocessor requires /* */ style comments below
//--


#define BSTORE_SWITCH                                                         ;\
/*                                                                          */;\
/* Set sp to trap frame and switch to kernel banked registers               */;\
/*                                                                          */;\
        rRscD     = t11                                                       ;\
        rpT2      = t12                                                       ;\
        rRNAT     = t13                                                       ;\
        rBSPStore = t14                                                       ;\
        rRscDelta = t15                                                       ;\
        rpT1      = t16                                                       ;\
                                                                              ;\
                                                                              ;\
        add       rpT1 = TrRsRNAT, sp                  /* -> user RNAT      */;\
        add       rpT2 = TrRsBSPSTORE, sp              /* -> user BSP Store */;\
        mov       rRscD = RSC_KERNEL_DISABLED                                 ;\
        ;;                                                                    ;\
                                                                              ;\
/*                                                                          */;\
/* Switch to user BSP -- put in load intensive mode to overlap RS restore   */;\
/* with volatile state restore.                                             */;\
/*                                                                          */;\
                                                                              ;\
        ld8       rRNAT = [rpT1], TrRsBSP-TrRsRNAT     /* user RNAT     */    ;\
        ld8       rBSPStore = [rpT2]                   /* user BSP Store*/    ;\
        ;;                                                                    ;\
                                                                              ;\
        alloc     t22 = 0,0,0,0                                               ;\
        ld8       rRscDelta = [rpT1]                   /* user BSP      */    ;\
        ;;                                                                    ;\
        sub       rRscDelta = rRscDelta, rBSPStore     /* delta = BSP - BSP Store */;\
        ;;                                                                    ;\
                                                                              ;\
        invala                                                                ;\
        dep       rRscD = rRscDelta, rRscD, 16, 14     /* set RSC.loadrs    */;\
        ;;                                                                    ;\
                                                                              ;\
        mov       ar##.##rsc = rRscD                   /* RSE off       */    ;\
        ;;                                                                    ;\
        loadrs                                         /* pull in user regs */;\
                                                       /* up to tear point */ ;\
        ;;                                                                    ;\
                                                                              ;\
        mov       ar##.##bspstore = rBSPStore          /* restore user BSP */ ;\
        ;;                                                                    ;\
        mov       ar##.##rnat = rRNAT                  /* restore user RNAT */


//++
// Routine:
//
//       NORMAL_KERNEL_EXIT
//
// Routine Description:
//
//       Common handler code for restoring previous state and rfi.
//
// On entry:
//
//      sp: pointer to trap frame
//      ar.unat: contains Nat for previous sp (restored by ld8.fill)
//
// Return Value:
//
//       None
//
// Note: 
//
//      Uses just the kernel banked registers (h16-h31)
//
//       MS preprocessor requires /* */ style comments below
//--

#define NORMAL_KERNEL_EXIT                                                    ;\
                                                                              ;\
        add         rHpT2 = TrApUNAT, sp            /* -> previous UNAT     */;\
        add         rHpT1 = TrStFPSR, sp            /* -> previous Preds    */;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHUNAT = [rHpT2],TrPreds-TrApUNAT                         ;\
        ld8         rHFPSR = [rHpT1],TrRsPFS-TrStFPSR                         ;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHOldPreds = [rHpT2], TrIntSp-TrPreds                     ;\
        ld8         rHPFS = [rHpT1],TrStIIPA-TrRsPFS                          ;\
        ;;                                                                    ;\
                                                                              ;\
        ld8##.##fill rHSp = [rHpT2], TrBrRp-TrIntSp                           ;\
        ld8         rHIIPA = [rHpT1], TrStIIP-TrStIIPA                        ;\
        ;;                                                                    ;\
                                                                              ;\
        mov         ar##.##fpsr = rHFPSR            /* restore FPSR         */;\
        ld8         rHIIP = [rHpT1], TrStIPSR-TrStIIP  /* load IIP          */;\
        mov         pr = rHOldPreds, -1             /* restore preds        */;\
                                                                              ;\
        mov         ar##.##unat = rHUNAT            /* restore UNAT         */;\
        ld8         rHBrp = [rHpT2], TrStIFS-TrBrRp                           ;\
        mov         ar##.##pfs = rHPFS              /* restore PFS          */;\
        ;;                                                                    ;\
                                                                              ;\
        ld8         rHIFS = [rHpT2]                 /* load IFS             */;\
        ld8         rHIPSR = [rHpT1]                /* load IPSR            */;\
                                                                              ;\
        rsm         1 << PSR_IC                     /* reset ic bit         */;\
        ;;                                                                    ;\
        srlz##.##d                                  /* must serialize       */;\
        mov         brp = rHBrp                     /* restore brp          */;\
                                                                              ;\
/*                                                                          */;\
/* Restore status registers                                                 */;\
/*                                                                          */;\
                                                                              ;\
        mov         cr##.##ipsr = rHIPSR        /* restore previous IPSR    */;\
        mov         cr##.##iip = rHIIP          /* restore previous IIP     */;\
                                                                              ;\
        mov         cr##.##ifs = rHIFS          /* restore previous IFS     */;\
        mov         cr##.##iipa = rHIIPA        /* restore previous IIPA    */;\
        ;;                                                                    ;\
                                                                              ;\
/*                                                                          */;\
/* Resume at point of interruption (rfi must be at end of instruction group)*/;\
/*                                                                          */;\
        mov         sp = rHSp                   /* restore sp               */;\
        mov         h17 = r0                    /* clear TB loop count      */;\
        rfi                                                                   ;\
        ;;

//++
// Routine:
//
//       GET_INTERRUPT_VECTOR(pGet, rVector)
//
// Routine Description:
//
//       Hook to get the vector for an interrupt. Currently just
//       reads the Interrupt Vector Control Register.
//
// Agruments:
//
//       pGet:    Predicate: if true then get, else skip.
//       rVector: Register for the vector number.
//
// Return Value:
//
//       The vector number of the highest priority pending interrupt.
//       Vectors number is an 8-bit value. All other bits 0.
//
//--

#define GET_INTERRUPT_VECTOR(pGet,rVector)                         \
        srlz##.##d                                                ;\
(pGet)  mov         rVector = cr##.##ivr

       
//--------------------------------------------------------------------
// Routine:
//
//       BdBreakVector
//
// Description:
//
//       Interruption vector for break instruction.
//
// On entry:
//
//       IIM contains break immediate value:
//                 -- BREAK_SYSCALL -> standard system call
//       interrupts disabled
//       r16-r31 switched to kernel bank
//       r16-r31 all available since no TLB faults at this point
//
// Return value:
//
//       if system call, sys call return value in v0.
//
// Process:
//--------------------------------------------------------------------

        VECTOR_ENTRY(0x2C00, BdBreakVector, cr.iim)

        mov       b7 = h30                     // restore the original value of b7
        mov       rHIIM = cr.iim               // get break value
        movl      rTH1 = BdPcr+PcSavedIIM
        ;;
        st8       [rTH1] = rHIIM

        VECTOR_CALL_HANDLER(BdGenericExceptionHandler, BdOtherBreakException)

//
// Do not return from handler
//

        VECTOR_EXIT(BdBreakVector)

//++
//
// BdTakenBranchVector
//
// Cause:       A taken branch was successfully execcuted and the PSR.tb
//              bit is 1. This trap is higher priority than single step trap.
//
// Parameters:  cr.iip  - address of bundle containing the instruction to
//                        be executed next.
//
//              cr.ipsr - copy of PSR at the time of interruption.
//
//              cr.iipa - address of bundle containing the last
//                        successfully executed instruction
//
//              cr.isr  - faulting status information. The ISR.code
//                        contains a bit vector for all traps which
//                        occurred in the trapping bundle. 
//              
//--
        
        VECTOR_ENTRY(0x5f00, BdTakenBranchVector, cr.iipa)
        
        mov       rHIIP = cr.iip
        movl      rHEPCVa = MM_EPC_VA+0x20     // user system call entry point

        mov       rHIPSR = cr.ipsr
        movl      rHpT1 = BdPcr+PcInitialStack
        ;;

        ld8       rHpT1 = [rHpT1]
        mov       rHOldPreds = pr
        mov       rPanicCode = UNEXPECTED_KERNEL_MODE_TRAP
        ;;

        cmp.eq    pt0 = rHEPCVa, rHIIP
        extr.u    rTH1 = rHIPSR, PSR_CPL, PSR_CPL_LEN
        ;;

        cmp4.eq   pKrnl, pUser = PL_KERNEL, rTH1
(pKrnl) br.spnt.few BdPanicHandler
        ;;

 (pt0)  ssm       1 << PSR_IC
 (pt0)  movl      rTH1 = 1 << PSR_LP
        ;;

 (pt0)  or        rHpT3 = rHIPSR, rTH1
        movl      rHHandler = BdSingleStep

 (pt0)  srlz.d
        add       rHpT1=-ThreadStateSaveAreaLength-TrapFrameLength+TrStIPSR,rHpT1
 (pt0)  br.spnt.few Ktbv10

        mov       pr = rHOldPreds, -2
        br.sptk   BdGenericExceptionHandler
        ;;


Ktbv10:

        st8       [rHpT1] = rHpT3
        movl      rTH1 = 1 << PSR_SS | 1 << PSR_TB | 1 << PSR_DB
        ;;

        rsm       1 << PSR_IC
        mov       pr = rHOldPreds, -2
        andcm     rHIPSR = rHIPSR, rTH1   // clear ss, tb, db bits
        ;;

        srlz.d
        mov       cr.ipsr = rHIPSR
        ;;
        rfi
        ;;

        VECTOR_EXIT(BdTakenBranchVector)

//++
//
// BdSingleStepVector
//
// Cause:       An instruction was successfully execcuted and the PSR.ss
//              bit is 1. 
//
// Parameters:  cr.iip  - address of bundle containing the instruction to
//                        be executed next.
//
//              cr.ipsr - copy of PSR at the time of interruption.
//
//              cr.iipa - address of bundle containing the last
//                        successfully executed instruction
//
//              cr.isr  - faulting status information. The ISR.code
//                        contains a bit vector for all traps which
//                        occurred in the trapping bundle. 
//              
//--
        
        VECTOR_ENTRY(0x6000, BdSingleStepVector, cr.iipa)
        
        mov       rHIIP = cr.iip
        movl      rHEPCVa = MM_EPC_VA+0x20     // user system call entry point

        mov       rHIPSR = cr.ipsr
        movl      rHpT1 = BdPcr+PcInitialStack
        ;;

        ld8       rHpT1 = [rHpT1]
        mov       rHOldPreds = pr
        mov       rPanicCode = UNEXPECTED_KERNEL_MODE_TRAP
        ;;

        cmp.eq    pt0 = rHEPCVa, rHIIP
        extr.u    rTH1 = rHIPSR, PSR_CPL, PSR_CPL_LEN
        ;;

        cmp4.eq   pKrnl, pUser = PL_KERNEL, rTH1
(pKrnl) br.spnt.few BdPanicHandler
        ;;

 (pt0)  ssm       1 << PSR_IC
 (pt0)  movl      rTH1 = 1 << PSR_LP
        ;;

 (pt0)  or        rHpT3 = rHIPSR, rTH1
        movl      rHHandler = BdSingleStep

 (pt0)  srlz.d
        add       rHpT1=-ThreadStateSaveAreaLength-TrapFrameLength+TrStIPSR,rHpT1
 (pt0)  br.spnt.few Kssv10

        mov       pr = rHOldPreds, -2
        br.sptk   BdGenericExceptionHandler
        ;;


Kssv10:

        st8       [rHpT1] = rHpT3
        movl      rTH1 = 1 << PSR_SS | 1 << PSR_DB
        ;;

        rsm       1 << PSR_IC
        mov       pr = rHOldPreds, -2
        andcm     rHIPSR = rHIPSR, rTH1   // clear ss, db bits
        ;;

        srlz.d
        mov       cr.ipsr = rHIPSR
        ;;
        rfi
        ;;

        VECTOR_EXIT(BdSingleStepVector)

        .text
//++
//--------------------------------------------------------------------
// Routine:
//
//       BdGenericExceptionHandler
//
// Description:
//
//       First level handler for heavyweight exceptions.
//
// On entry:
//
//       ic off
//       interrupts disabled
//       current frame covered
//
// Process:
//
// Notes:
//
//       PCR page mapped with TR
//--------------------------------------------------------------------

        HANDLER_ENTRY(BdGenericExceptionHandler)

        .prologue
        .unwabi     @nt,  EXCEPTION_FRAME

        ALLOCATE_TRAP_FRAME

//
// sp points to trap frame
//
// Save exception handler routine in kernel register
//

        mov       rkHandler = rHHandler
        ;;

//
// Save interruption state in trap frame and switch to user bank registers
// and switch to kernel backing store.
//

        SAVE_INTERRUPTION_STATE(Kgeh_SaveTrapFrame)

//
// Now running with user banked registers and on kernel stack.
//
// Can now take TLB faults
//
// sp -> trap frame
//

        br.call.sptk brp = BdSaveTrapFrame
        ;;

//
// setup debug registers if previous mode is user
//

(pUser) br.call.spnt brp = BdSetupDebugRegisters

//
// Register aliases
//

        rpT1        = t0
        rpT2        = t1
        rpT3        = t2
        rT1         = t3
        rT2         = t4
        rT3         = t5
        rPreviousMode = t6                      // previous mode
        rT4         = t7


        movl      gp = _gp                      // make sure we are using loader's GP
        mov       rT1 = rkHandler               // restore address of interruption routine
        movl      rpT1 = BdPcr+PcSavedIIM
        ;;

        ld8       rT2 = [rpT1], PcSavedIFA-PcSavedIIM  // load saved IIM
        add       rpT2 = TrEOFMarker, sp
        add       rpT3 = TrStIIM, sp
        ;;

        ld8       rT4 = [rpT1]                  // load saved IFA
        movl      rT3 = KTRAP_FRAME_EOF | EXCEPTION_FRAME
        ;;

        st8       [rpT2] = rT3, TrHandler-TrEOFMarker
        st8       [rpT3] = rT2, TrStIFA-TrStIIM // save IIM in trap frame
        mov       bt0 = rT1                     // set destination address
        ;;

        st8       [rpT3] = rT4                  // save IFA in trap frame
#if DBG
        st8       [rpT2] = rT1                  // save debug info in TrFrame
#endif // DBG
        ;;

        PROLOGUE_END

        .regstk     0, 1, 2, 0                  // must be in sync with BdExceptionExit
        alloc       out1 = 0,1,2,0              // alloc 0 in, 1 locals, 2 outs

//
// Dispatch the exception via call to address in rkHandler
//
.pred.rel "mutex",pUser,pKrnl
        add       rpT1 = TrPreviousMode, sp     // -> previous mode
(pUser) mov       rPreviousMode = UserMode      // set previous mode
(pKrnl) mov       rPreviousMode = KernelMode
        ;;

        st4       [rpT1] = rPreviousMode        // **** TBD 1 byte -- save in trap frame
        mov       out0 = sp                     // trap frame pointer
        br.call.sptk brp = bt0                  // call handler(tf) (C code)
        ;;

.pred.rel "mutex",pUser,pKrnl
        cmp.ne    pt0, pt1 = v0, zero
(pUser) mov       out1 = UserMode
(pKrnl) mov       out1 = KernelMode

        //
        // does not return
        //

        mov       out0 = sp
(pt1)   br.cond.sptk BdAlternateExit
(pt0)   br.call.spnt brp = BdExceptionDispatch

        nop.m     0
        nop.m     0
        nop.i     0
        ;;

        HANDLER_EXIT(BdGenericExceptionHandler)


//--------------------------------------------------------------------
// Routine:
//
//       BdPanicHandler
//
// Description:
//
//       Handler for panic. Call the bug check routine. A place
//       holder for now.
//
// On entry:
//
//       running on kernel memory stack and kernel backing store
//       sp: top of stack -- points to trap frame
//       interrupts enabled
//
//       IIP: address of bundle causing fault
//
//       IPSR: copy of PSR at time of interruption
//
// Output:
//
//       sp: top of stack -- points to trap frame
//
// Return value:
//
//       none
//
// Notes:
//
//       If ISR code out of bounds, this code will inovke the panic handler
//
//--------------------------------------------------------------------

        HANDLER_ENTRY(BdPanicHandler)

        movl      rTH1 = BdPcr+PcPanicStack
        ;;

        ld8       sp = [rTH1]
        movl      rTH2 = BdPcr+PcSystemReserved
        ;;

        st4       [rTH2] = rPanicCode
        add       sp = -TrapFrameLength, sp
        ;;

        SAVE_INTERRUPTION_STATE(Kph_SaveTrapFrame)

        rpRNAT    = t16
        rpBSPStore= t17
        rBSPStore = t18
        rKBSPStore= t19
        rRNAT     = t20
        rKrnlFPSR = t21

        mov       ar.rsc = RSC_KERNEL_DISABLED
        add       rpRNAT = TrRsRNAT, sp
        add       rpBSPStore = TrRsBSPSTORE, sp
        ;;

        mov       rBSPStore = ar.bspstore
        mov       rRNAT = ar.rnat
        ;;

        st8       [rpRNAT] = rRNAT
        st8       [rpBSPStore] = rBSPStore
        dep       rKBSPStore = rBSPStore, sp, 0, 9
        ;;

        mov       ar.bspstore = rKBSPStore
        mov       ar.rsc = RSC_KERNEL
        ;;

        alloc     t22 = ar.pfs, 0, 0, 5, 0
        movl      out0 = BdPcr+PcSystemReserved
        ;;

        ld4       out0 = [out0]                // 1st argument: panic code
        mov       out1 = sp                    // 2nd argument: trap frame
        //br.call.sptk.many brp = KeBugCheckEx
        ;;

        HANDLER_EXIT(BdPanicHandler)

//++
//--------------------------------------------------------------------
// Routine:
//
//      VOID
//      BdSaveTrapFrame(PKTRAP_FRAME)
//
// Description:
//
//       Save volatile application state in trap frame.
//       Note: sp, brp, UNAT, RSC, predicates, BSP, BSP Store,
//       PFS, DCR, and FPSR saved elsewhere.
//
// Input:
//
//       sp: points to trap frame
//       ar.unat: contains the Nats of sp, gp, teb, which have already
//                been spilled into the trap frame.
//
// Output:
//
//       None
//
// Return value:
//
//       none
//
//--------------------------------------------------------------------

        LEAF_ENTRY(BdSaveTrapFrame)

        .regstk    0, 3, 0, 0

//
// Local register aliases
//

        rpTF1     = loc0
        rpTF2     = loc1
        rL1       = t0
        rL2       = t1
        rL3       = t2
        rL4       = t3
        rL5       = t4


//
// (ar.unat unchanged from point of save)
// Spill temporary (volatile) integer registers
//
         
        alloc       loc2 = 0,3,0,0              // don't destroy static register
        add         rpTF1 = TrIntT0, sp         // -> t0 save area
        add         rpTF2 = TrIntT1, sp         // -> t1 save area
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t0, TrIntT2-TrIntT0 // spill t0 - t22
        .mem.offset 8,0
        st8.spill [rpTF2] = t1, TrIntT3-TrIntT1
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t2, TrIntT4-TrIntT2
        .mem.offset 8,0
        st8.spill [rpTF2] = t3, TrIntT5-TrIntT3
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t4, TrIntT6-TrIntT4
        .mem.offset 8,0
        st8.spill [rpTF2] = t5, TrIntT7-TrIntT5
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t6, TrIntT8-TrIntT6
        .mem.offset 8,0
        st8.spill [rpTF2] = t7, TrIntT9-TrIntT7
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t8, TrIntT10-TrIntT8
        .mem.offset 8,0
        st8.spill [rpTF2] = t9, TrIntT11-TrIntT9
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t10, TrIntT12-TrIntT10
        .mem.offset 8,0
        st8.spill [rpTF2] = t11, TrIntT13-TrIntT11
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t12, TrIntT14-TrIntT12
        .mem.offset 8,0
        st8.spill [rpTF2] = t13, TrIntT15-TrIntT13
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t14, TrIntT16-TrIntT14
        .mem.offset 8,0
        st8.spill [rpTF2] = t15, TrIntT17-TrIntT15
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t16, TrIntT18-TrIntT16
        .mem.offset 8,0
        st8.spill [rpTF2] = t17, TrIntT19-TrIntT17
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t18, TrIntT20-TrIntT18
        .mem.offset 8,0
        st8.spill [rpTF2] = t19, TrIntT21-TrIntT19
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t20, TrIntT22-TrIntT20
        .mem.offset 8,0
        st8.spill [rpTF2] = t21, TrIntV0-TrIntT21
        ;;
        .mem.offset 0,0
        st8.spill [rpTF1] = t22, TrBrT0-TrIntT22
        .mem.offset 8,0
        st8.spill [rpTF2] = v0, TrIntNats-TrIntV0       // spill old V0
        ;;

//
// Now save the Nats interger regsisters saved so far (includes Nat for sp)
//

        mov       rL1 = ar.unat
        mov       rL2 = bt0
        mov       rL3 = bt1
        ;;

        st8       [rpTF2] = rL1, TrBrT1-TrIntNats       // save Nats of volatile regs
        mov       rL4 = ar.ccv
        ;;

//
// Save temporary (volatile) branch registers
//

        st8       [rpTF1] = rL2, TrApCCV-TrBrT0         // save old bt0 - bt1
        st8       [rpTF2] = rL3
        ;;

        st8       [rpTF1] = rL4                         // save ar.ccv
        add       rpTF1 = TrFltT0, sp                   // point to FltT0
        add       rpTF2 = TrFltT1, sp                   // point to FltT1
        ;;

//
// Spill temporary (volatile) floating point registers
//

        stf.spill [rpTF1] = ft0, TrFltT2-TrFltT0        // spill float tmp 0 - 9
        stf.spill [rpTF2] = ft1, TrFltT3-TrFltT1
        ;;
        stf.spill [rpTF1] = ft2, TrFltT4-TrFltT2
        stf.spill [rpTF2] = ft3, TrFltT5-TrFltT3
        ;;
        stf.spill [rpTF1] = ft4, TrFltT6-TrFltT4
        stf.spill [rpTF2] = ft5, TrFltT7-TrFltT5
        ;;
        stf.spill [rpTF1] = ft6, TrFltT8-TrFltT6
        stf.spill [rpTF2] = ft7, TrFltT9-TrFltT7
        ;;
        stf.spill [rpTF1] = ft8
        stf.spill [rpTF2] = ft9
        ;;

        rum       1 << PSR_MFL                          // clear mfl bit

//
// TBD **** Debug/performance regs ** ?
// **** Performance regs not needed (either user or system wide)
// No performance regs switched on kernel entry
// **** Debug regs saved if in use
//

        LEAF_RETURN
        ;;
        LEAF_EXIT(BdSaveTrapFrame)

//++
//--------------------------------------------------------------------
// Routine:
//
//      VOID
//      BdRestoreTrapFrame(PKTRAP_FRAME)
//
// Description:
//
//       Restore volatile application state from trap frame. Restore DCR
//       Note: sp, brp, RSC, UNAT, predicates, BSP, BSP Store, PFS,
//       DCR and FPSR not restored here.
//
// Input:
//
//      sp: points to trap frame
//      RSE frame size is zero
//
// Output:
//
//      None
//
// Return value:
//
//       none
//
//--------------------------------------------------------------------

        LEAF_ENTRY(BdRestoreTrapFrame)

        LEAF_SETUP(0,2,0,0)

        rpTF1     = loc0
        rpTF2     = loc1

//
// **** TBD **** Restore debug/performance registers??
// **** Performance regs not needed (either user or system wide)
// No performance regs switched on kernel entry
// **** Debug regs saved if in use
//

//
// Restore RSC, CCV, DCR, and volatile branch, floating point, integer register
//

        mov       t21 = psr
        add       rpTF1 = TrRsRSC, sp
        add       rpTF2 = TrApCCV, sp
        ;;

        ld8       t5 = [rpTF1], TrIntNats-TrRsRSC
        ld8       t1 = [rpTF2], TrApDCR-TrApCCV
        ;;

        ld8       t0 = [rpTF1], TrBrT0-TrIntNats
        ld8       t3 = [rpTF2], TrBrT1-TrApDCR
        ;;

        ld8       t2 = [rpTF1]
        ld8       t4 = [rpTF2]

        mov       ar.rsc = t5
        mov       ar.ccv = t1
        add       rpTF1 = TrIntGp, sp

        mov       ar.unat = t0
        mov       cr.dcr = t3
        add       rpTF2 = TrIntT0, sp
        ;;

        ld8.fill  gp = [rpTF1], TrIntT1-TrIntGp
        ld8.fill  t0 = [rpTF2], TrIntT2-TrIntT0 
        mov       bt0 = t2
        ;;

        ld8.fill  t1 = [rpTF1], TrIntT3-TrIntT1
        ld8.fill  t2 = [rpTF2], TrIntT4-TrIntT2
        mov       bt1 = t4
        ;;

        ld8.fill  t3 = [rpTF1], TrIntT5-TrIntT3
        ld8.fill  t4 = [rpTF2], TrIntT6-TrIntT4
        tbit.z    pt1 = t21, PSR_MFL
        ;;

        ld8.fill  t5 = [rpTF1], TrIntT7-TrIntT5
        ld8.fill  t6 = [rpTF2], TrIntT8-TrIntT6
        ;;

        ld8.fill  t7 = [rpTF1], TrIntT9-TrIntT7
        ld8.fill  t8 = [rpTF2], TrIntT10-TrIntT8
        ;;

        ld8.fill  t9 = [rpTF1], TrIntT11-TrIntT9
        ld8.fill  t10 = [rpTF2], TrIntT12-TrIntT10
        ;;

        ld8.fill  t11 = [rpTF1], TrIntT13-TrIntT11
        ld8.fill  t12 = [rpTF2], TrIntT14-TrIntT12
        ;;

        ld8.fill  t13 = [rpTF1], TrIntT15-TrIntT13
        ld8.fill  t14 = [rpTF2], TrIntT16-TrIntT14
        ;;

        ld8.fill  t15 = [rpTF1], TrIntT17-TrIntT15
        ld8.fill  t16 = [rpTF2], TrIntT18-TrIntT16
        ;;

        ld8.fill  t17 = [rpTF1], TrIntT19-TrIntT17
        ld8.fill  t18 = [rpTF2], TrIntT20-TrIntT18
        ;;

        ld8.fill  t19 = [rpTF1], TrIntT21-TrIntT19
        ld8.fill  t20 = [rpTF2], TrIntT22-TrIntT20
        ;;

        ld8.fill  t21 = [rpTF1], TrIntTeb-TrIntT21
        ld8.fill  t22 = [rpTF2], TrIntV0-TrIntT22
        ;;

        ld8.fill  teb = [rpTF1], TrFltT1-TrIntTeb
        ld8.fill  v0 = [rpTF2], TrFltT0-TrIntV0
        ;;

        ldf.fill  ft0 = [rpTF2], TrFltT2-TrFltT0
        ldf.fill  ft1 = [rpTF1], TrFltT3-TrFltT1
        ;;
        
        ldf.fill  ft2 = [rpTF2], TrFltT4-TrFltT2
        ldf.fill  ft3 = [rpTF1], TrFltT5-TrFltT3
        ;;
        
        ldf.fill  ft4 = [rpTF2], TrFltT6-TrFltT4
        ldf.fill  ft5 = [rpTF1], TrFltT7-TrFltT5
        ;;
        
        ldf.fill  ft6 = [rpTF2], TrFltT8-TrFltT6
        ldf.fill  ft7 = [rpTF1], TrFltT9-TrFltT7
        ;;
        
        ldf.fill  ft8 = [rpTF2]
        ldf.fill  ft9 = [rpTF1]
        br.ret.sptk.many brp
        ;;
        
        LEAF_EXIT(BdRestoreTrapFrame)

//++
//--------------------------------------------------------------------
// Routine:
//
//      VOID
//      BdSetupDebugRegisters
//
// Description:
//
//      We maintain two debug register flags:
//         1. Thread DebugActive: Debug registers active for current thread
//         2. PCR KernelDebugActive: Debug registers active in kernel mode
//            (setup by kernel debugger)
//
//      On user -> kernel transitions there are four possibilities:
//
//               Thread        Kernel 
//               DebugActive   DebugActive   Action
//
//      1.       0             0             None
//
//      2.       1             0             None (kernel PSR.db = 0 by default)
//
//      3.       0             1             Set PSR.db = 1 for kernel
//
//      4.       1             1             Set PSR.db = 1 for kernel and
//                                           load kernel debug registers
//
//      Note we never save the user debug registers: 
//      the user cannot change the DRs so the values in the DR save area are 
//      always up-to-date (set by SetContext).
//
// Input:
//
//       None (Previous mode is USER)
//
// Output:
//
//       None
//
// Return value:
//
//       none
//
//--------------------------------------------------------------------

        LEAF_ENTRY(BdSetupDebugRegisters)

//
// *** TBD -- no support for kernel debug registers (KernelDebugActive = 0)
// All the calls to this function are removed and have to be reinstated
// when hardware debug support is implemented in the kernel debugger.
//

        LEAF_RETURN
        LEAF_EXIT(BdSetupDebugRegisters)

//++
//--------------------------------------------------------------------
// Routine:
//
//      VOID
//      BdRestoreDebugRegisters
//
// Description:
//
//      If debug active, restore user debug registers from DR save area in
//      kernel stack.
//
// Input:
//
//       None
//
// Output:
//
//       None
//
// Return value:
//
//       none
//
// Note:
//      We find the DR save are from the the StackBase not PCR->InitialStack,
//      which can be changed in BdCallUserMode().
//
//--------------------------------------------------------------------

        LEAF_ENTRY(BdRestoreDebugRegisters)

//
// Local register aliases
//

        rpSA0       = t0
        rpSA1       = t1
        rDebugActive = t2
        rpT1        = t3
        rPrcb       = t4
        rDr0        = t5
        rDr1        = t6
        rDrIndex0   = t7
        rDrIndex1   = t8
        rSaveLC     = t9
        rpCurrentThread = t10
        rStackBase  = t11

        pNoRestore  = pt0

//
// Restore debug registers, if debug active
//
         
        movl        rpT1 = BdPcr+PcCurrentThread
        ;;
        mov         rSaveLC = ar.lc             // save
        ld8         rpCurrentThread = [rpT1]    // get Current thread pointer
        ;;
        add         rpT1 = ThDebugActive, rpCurrentThread
        add         rStackBase = ThStackBase, rpCurrentThread
        ;;
        ld1         rDebugActive = [rpT1]       // get thread debug active flag
        ;;
        cmp.eq      pNoRestore = zero, rDebugActive
(pNoRestore) br.sptk Krdr_Exit                   // skip if not active
        ;;
        mov         rDrIndex0 = 0               
        mov         rDrIndex1 = 1
        ;;
        add         rpSA0 = -ThreadStateSaveAreaLength+TsDebugRegisters+DrDbI0,rStackBase
        add         rpSA1 = -ThreadStateSaveAreaLength+TsDebugRegisters+DrDbI1,rStackBase
        mov         ar.lc = 3                   // 4 pair of ibr
        ;;
Krdr_ILoop:
        ld8         rDr0 = [rpSA0], 16          // get ibr pair
        ld8         rDr1 = [rpSA1], 16          // step by 16 = 1 pair of DRs
        ;;
        .auto
        mov         ibr[rDrIndex0] = rDr0       // restore ibr pair
        mov         ibr[rDrIndex1] = rDr1
        ;;
        add         rDrIndex0 = 1, rDrIndex0    // next pair
        add         rDrIndex1 = 1, rDrIndex1
        br.cloop.sptk Krdr_ILoop
        ;;
        mov         ar.lc = 3                   // 4 pair of dbr
        mov         rDrIndex0 = 0
        mov         rDrIndex1 = 1
        ;;
Krdr_DLoop:
        ld8         rDr0 = [rpSA0], 16          // get dbr pair
        ld8         rDr1 = [rpSA1], 16          // step by 16 = 1 pair of DRs
        ;;
        mov         dbr[rDrIndex0] = rDr0       // restore dbr pair
        mov         dbr[rDrIndex1] = rDr1
        ;;
        .default
        add         rDrIndex0 = 1, rDrIndex0    // next pair
        add         rDrIndex1 = 1, rDrIndex1
        br.cloop.sptk Krdr_DLoop
        ;;
        mov         ar.lc = rSaveLC             // restore
Krdr_Exit:
        LEAF_RETURN
        LEAF_EXIT(BdRestoreDebugRegisters)

//++
//--------------------------------------------------------------------
// Routine:
//
//      VOID
//      BdSaveExceptionFrame(PKEXCEPTION_FRAME)
//
// Description:
//
//      Save preserved context in exception frame.
//
// Input:
//
//      a0: points to exception frame
//
// Output:
//
//      None
//
// Return value:
//
//      none
//
// Note: t0 may contain the trap frame address; don't touch it.
//
//--------------------------------------------------------------------

        LEAF_ENTRY(BdSaveExceptionFrame)

//
// Local register aliases
//

        rpEF1     = t10
        rpEF2     = t11

        add       rpEF1 = ExIntS0, a0            // -> ExIntS0
        add       rpEF2 = ExIntS1, a0            // -> ExIntS1
        mov       t3 = ar.ec
        ;;

        .mem.offset 0,0
        st8.spill [rpEF1] = s0, ExIntS2-ExIntS0
        .mem.offset 8,0
        st8.spill [rpEF2] = s1, ExIntS3-ExIntS1
        mov       t4 = ar.lc
        ;;

        .mem.offset 0,0
        st8.spill [rpEF1] = s2, ExApEC-ExIntS2
        .mem.offset 8,0
        st8.spill [rpEF2] = s3, ExApLC-ExIntS3
        mov       t5 = bs0
        ;;

        st8       [rpEF1] = t3, ExBrS0-ExApEC
        st8       [rpEF2] = t4, ExBrS1-ExApLC
        mov       t6 = bs1
        ;;

        mov       t2 = ar.unat                   // save user nat register for
        mov       t7 = bs2
        mov       t8 = bs3

        st8       [rpEF1] = t5, ExBrS2-ExBrS0
        st8       [rpEF2] = t6, ExBrS3-ExBrS1
        mov       t9 = bs4
        ;;

        st8       [rpEF1] = t7, ExBrS4-ExBrS2
        st8       [rpEF2] = t8, ExIntNats-ExBrS3
        ;;

        st8       [rpEF1] = t9, ExFltS0-ExBrS4
        st8       [rpEF2] = t2, ExFltS1-ExIntNats
        ;;

        stf.spill [rpEF1] = fs0, ExFltS2-ExFltS0
        stf.spill [rpEF2] = fs1, ExFltS3-ExFltS1
        ;;

        stf.spill [rpEF1] = fs2, ExFltS4-ExFltS2
        stf.spill [rpEF2] = fs3, ExFltS5-ExFltS3
        ;;

        stf.spill [rpEF1] = fs4, ExFltS6-ExFltS4
        stf.spill [rpEF2] = fs5, ExFltS7-ExFltS5
        ;;

        stf.spill [rpEF1] = fs6, ExFltS8-ExFltS6
        stf.spill [rpEF2] = fs7, ExFltS9-ExFltS7
        ;;

        stf.spill [rpEF1] = fs8, ExFltS10-ExFltS8
        stf.spill [rpEF2] = fs9, ExFltS11-ExFltS9
        ;;

        stf.spill [rpEF1] = fs10, ExFltS12-ExFltS10
        stf.spill [rpEF2] = fs11, ExFltS13-ExFltS11
        ;;

        stf.spill [rpEF1] = fs12, ExFltS14-ExFltS12
        stf.spill [rpEF2] = fs13, ExFltS15-ExFltS13
        ;;

        stf.spill [rpEF1] = fs14, ExFltS16-ExFltS14
        stf.spill [rpEF2] = fs15, ExFltS17-ExFltS15
        ;;

        stf.spill [rpEF1] = fs16, ExFltS18-ExFltS16
        stf.spill [rpEF2] = fs17, ExFltS19-ExFltS17
        ;;

        stf.spill [rpEF1] = fs18
        stf.spill [rpEF2] = fs19
        LEAF_RETURN
        ;;

        LEAF_EXIT(BdSaveExceptionFrame)

//--------------------------------------------------------------------
// Routine:
//
//      VOID
//      BdRestoreExceptionFrame(PKEXCEPTION_FRAME)
//
// Description:
//
//       Restores preserved context from the exception frame. Also
//       restore volatile part of floating point context not restored with
//       rest of volatile context.
//
// Input:
//
//      a0: points to exception frame
//
// Output:
//
//      None
//
// Return value:
//
//      none
//
//--------------------------------------------------------------------

        LEAF_ENTRY(BdRestoreExceptionFrame)

//
// Local register aliases
//

        rpEF1     = t10
        rpEF2     = t11

        add       rpEF1 = ExIntNats, a0
        add       rpEF2 = ExApEC, a0
        ;;

        ld8       t2 = [rpEF1], ExBrS0-ExIntNats
        ld8       t3 = [rpEF2], ExApLC-ExApEC
        ;;

        ld8       t5 = [rpEF1], ExBrS1-ExBrS0
        ld8       t4 = [rpEF2], ExBrS2-ExApLC
        ;;

        mov       ar.unat = t2
        mov       ar.ec = t3
        ;;

        ld8       t6 = [rpEF1], ExBrS3-ExBrS1
        ld8       t7 = [rpEF2], ExBrS4-ExBrS2
        mov       ar.lc = t4
        ;;

        ld8       t8 = [rpEF1], ExIntS0-ExBrS3
        ld8       t9 = [rpEF2], ExIntS1-ExBrS4
        mov       bs0 = t5
        ;;

        ld8.fill  s0 = [rpEF1], ExIntS2-ExIntS0
        ld8.fill  s1 = [rpEF2], ExIntS3-ExIntS1
        mov       bs1 = t6
        ;;

        ld8.fill  s2 = [rpEF1], ExFltS0-ExIntS2
        ld8.fill  s3 = [rpEF2], ExFltS1-ExIntS3
        mov       bs2 = t7
        ;;

        ldf.fill  fs0 = [rpEF1], ExFltS2-ExFltS0
        ldf.fill  fs1 = [rpEF2], ExFltS3-ExFltS1
        mov       bs3 = t8
        ;;

        ldf.fill  fs2 = [rpEF1], ExFltS4-ExFltS2
        ldf.fill  fs3 = [rpEF2], ExFltS5-ExFltS3
        mov       bs4 = t9
        ;;

        ldf.fill  fs4 = [rpEF1], ExFltS6-ExFltS4
        ldf.fill  fs5 = [rpEF2], ExFltS7-ExFltS5
        ;;

        ldf.fill  fs6 = [rpEF1], ExFltS8-ExFltS6
        ldf.fill  fs7 = [rpEF2], ExFltS9-ExFltS7
        ;;

        ldf.fill  fs8 = [rpEF1], ExFltS10-ExFltS8
        ldf.fill  fs9 = [rpEF2], ExFltS11-ExFltS9
        ;;

        ldf.fill  fs10 = [rpEF1], ExFltS12-ExFltS10
        ldf.fill  fs11 = [rpEF2], ExFltS13-ExFltS11
        ;;

        ldf.fill  fs12 = [rpEF1], ExFltS14-ExFltS12
        ldf.fill  fs13 = [rpEF2], ExFltS15-ExFltS13
        ;;

        ldf.fill  fs14 = [rpEF1], ExFltS16-ExFltS14
        ldf.fill  fs15 = [rpEF2], ExFltS17-ExFltS15
        ;;

        ldf.fill  fs16 = [rpEF1], ExFltS18-ExFltS16
        ldf.fill  fs17 = [rpEF2], ExFltS19-ExFltS17
        ;;

        ldf.fill  fs18 = [rpEF1]
        ldf.fill  fs19 = [rpEF2]
        LEAF_RETURN
        ;;
        LEAF_EXIT(BdRestoreExceptionFrame)

//++
//--------------------------------------------------------------------
// Routine:
//
//      BdSaveHigherFPVolatile(PKHIGHER_FP_SAVEAREA)
//
// Description:
//
//       Save higher FP volatile context in higher FP save area
//
// Input:
//
//       a0: pointer to higher FP save area
//       brp: return address
//
// Output:
//
//       None
//
// Return value:
//
//       None
//
//--------------------------------------------------------------------

        LEAF_ENTRY(BdSaveHigherFPVolatile)

//
// Local register aliases
//

        rpSA1     = t0
        rpSA2     = t1

//
// Spill higher floating point volatile registers f32-f127.
// Must add length of preserved area within FP save area to
// point to volatile save area.
//

//
// Clear DFH bit so the high floating point set may be saved by the kernel
// Disable interrupts so that save is atomic
//

        rsm       1 << PSR_DFH
        add       rpSA1 = HiFltF32, a0      // -> HiFltF32
        add       rpSA2 = HiFltF33, a0      // -> HiFltF33
        ;;

        srlz.d

        stf.spill [rpSA1] = f32, HiFltF34-HiFltF32
        stf.spill [rpSA2] = f33, HiFltF35-HiFltF33
        ;;
        stf.spill [rpSA1] = f34, HiFltF36-HiFltF34
        stf.spill [rpSA2] = f35, HiFltF37-HiFltF35
        ;;
        stf.spill [rpSA1] = f36, HiFltF38-HiFltF36
        stf.spill [rpSA2] = f37, HiFltF39-HiFltF37
        ;;
        stf.spill [rpSA1] = f38, HiFltF40-HiFltF38
        stf.spill [rpSA2] = f39, HiFltF41-HiFltF39
        ;;

        stf.spill [rpSA1] = f40, HiFltF42-HiFltF40
        stf.spill [rpSA2] = f41, HiFltF43-HiFltF41
        ;;
        stf.spill [rpSA1] = f42, HiFltF44-HiFltF42
        stf.spill [rpSA2] = f43, HiFltF45-HiFltF43
        ;;
        stf.spill [rpSA1] = f44, HiFltF46-HiFltF44
        stf.spill [rpSA2] = f45, HiFltF47-HiFltF45
        ;;
        stf.spill [rpSA1] = f46, HiFltF48-HiFltF46
        stf.spill [rpSA2] = f47, HiFltF49-HiFltF47
        ;;
        stf.spill [rpSA1] = f48, HiFltF50-HiFltF48
        stf.spill [rpSA2] = f49, HiFltF51-HiFltF49
        ;;

        stf.spill [rpSA1] = f50, HiFltF52-HiFltF50
        stf.spill [rpSA2] = f51, HiFltF53-HiFltF51
        ;;
        stf.spill [rpSA1] = f52, HiFltF54-HiFltF52
        stf.spill [rpSA2] = f53, HiFltF55-HiFltF53
        ;;
        stf.spill [rpSA1] = f54, HiFltF56-HiFltF54
        stf.spill [rpSA2] = f55, HiFltF57-HiFltF55
        ;;
        stf.spill [rpSA1] = f56, HiFltF58-HiFltF56
        stf.spill [rpSA2] = f57, HiFltF59-HiFltF57
        ;;
        stf.spill [rpSA1] = f58, HiFltF60-HiFltF58
        stf.spill [rpSA2] = f59, HiFltF61-HiFltF59
        ;;

        stf.spill [rpSA1] = f60, HiFltF62-HiFltF60
        stf.spill [rpSA2] = f61, HiFltF63-HiFltF61
        ;;
        stf.spill [rpSA1] = f62, HiFltF64-HiFltF62
        stf.spill [rpSA2] = f63, HiFltF65-HiFltF63
        ;;
        stf.spill [rpSA1] = f64, HiFltF66-HiFltF64
        stf.spill [rpSA2] = f65, HiFltF67-HiFltF65
        ;;
        stf.spill [rpSA1] = f66, HiFltF68-HiFltF66
        stf.spill [rpSA2] = f67, HiFltF69-HiFltF67
        ;;
        stf.spill [rpSA1] = f68, HiFltF70-HiFltF68
        stf.spill [rpSA2] = f69, HiFltF71-HiFltF69
        ;;

        stf.spill [rpSA1] = f70, HiFltF72-HiFltF70
        stf.spill [rpSA2] = f71, HiFltF73-HiFltF71
        ;;
        stf.spill [rpSA1] = f72, HiFltF74-HiFltF72
        stf.spill [rpSA2] = f73, HiFltF75-HiFltF73
        ;;
        stf.spill [rpSA1] = f74, HiFltF76-HiFltF74
        stf.spill [rpSA2] = f75, HiFltF77-HiFltF75
        ;;
        stf.spill [rpSA1] = f76, HiFltF78-HiFltF76
        stf.spill [rpSA2] = f77, HiFltF79-HiFltF77
        ;;
        stf.spill [rpSA1] = f78, HiFltF80-HiFltF78
        stf.spill [rpSA2] = f79, HiFltF81-HiFltF79
        ;;

        stf.spill [rpSA1] = f80, HiFltF82-HiFltF80
        stf.spill [rpSA2] = f81, HiFltF83-HiFltF81
        ;;
        stf.spill [rpSA1] = f82, HiFltF84-HiFltF82
        stf.spill [rpSA2] = f83, HiFltF85-HiFltF83
        ;;
        stf.spill [rpSA1] = f84, HiFltF86-HiFltF84
        stf.spill [rpSA2] = f85, HiFltF87-HiFltF85
        ;;
        stf.spill [rpSA1] = f86, HiFltF88-HiFltF86
        stf.spill [rpSA2] = f87, HiFltF89-HiFltF87
        ;;
        stf.spill [rpSA1] = f88, HiFltF90-HiFltF88
        stf.spill [rpSA2] = f89, HiFltF91-HiFltF89
        ;;

        stf.spill [rpSA1] = f90, HiFltF92-HiFltF90
        stf.spill [rpSA2] = f91, HiFltF93-HiFltF91
        ;;
        stf.spill [rpSA1] = f92, HiFltF94-HiFltF92
        stf.spill [rpSA2] = f93, HiFltF95-HiFltF93
        ;;
        stf.spill [rpSA1] = f94, HiFltF96-HiFltF94
        stf.spill [rpSA2] = f95, HiFltF97-HiFltF95
        ;;
        stf.spill [rpSA1] = f96, HiFltF98-HiFltF96
        stf.spill [rpSA2] = f97, HiFltF99-HiFltF97
        ;;
        stf.spill [rpSA1] = f98, HiFltF100-HiFltF98
        stf.spill [rpSA2] = f99, HiFltF101-HiFltF99
        ;;

        stf.spill [rpSA1] = f100, HiFltF102-HiFltF100
        stf.spill [rpSA2] = f101, HiFltF103-HiFltF101
        ;;
        stf.spill [rpSA1] = f102, HiFltF104-HiFltF102
        stf.spill [rpSA2] = f103, HiFltF105-HiFltF103
        ;;
        stf.spill [rpSA1] = f104, HiFltF106-HiFltF104
        stf.spill [rpSA2] = f105, HiFltF107-HiFltF105
        ;;
        stf.spill [rpSA1] = f106, HiFltF108-HiFltF106
        stf.spill [rpSA2] = f107, HiFltF109-HiFltF107
        ;;
        stf.spill [rpSA1] = f108, HiFltF110-HiFltF108
        stf.spill [rpSA2] = f109, HiFltF111-HiFltF109
        ;;

        stf.spill [rpSA1] = f110, HiFltF112-HiFltF110
        stf.spill [rpSA2] = f111, HiFltF113-HiFltF111
        ;;
        stf.spill [rpSA1] = f112, HiFltF114-HiFltF112
        stf.spill [rpSA2] = f113, HiFltF115-HiFltF113
        ;;
        stf.spill [rpSA1] = f114, HiFltF116-HiFltF114
        stf.spill [rpSA2] = f115, HiFltF117-HiFltF115
        ;;
        stf.spill [rpSA1] = f116, HiFltF118-HiFltF116
        stf.spill [rpSA2] = f117, HiFltF119-HiFltF117
        ;;
        stf.spill [rpSA1] = f118, HiFltF120-HiFltF118
        stf.spill [rpSA2] = f119, HiFltF121-HiFltF119
        ;;

        stf.spill [rpSA1] = f120, HiFltF122-HiFltF120
        stf.spill [rpSA2] = f121, HiFltF123-HiFltF121
        ;;
        stf.spill [rpSA1] = f122, HiFltF124-HiFltF122
        stf.spill [rpSA2] = f123, HiFltF125-HiFltF123
        ;;
        stf.spill [rpSA1] = f124, HiFltF126-HiFltF124
        stf.spill [rpSA2] = f125, HiFltF127-HiFltF125
        ;;
        stf.spill [rpSA1] = f126
        stf.spill [rpSA2] = f127

//
// Set DFH bit so the high floating point set may not be used by the kernel
// Must clear mfh after fp registers saved
//

        rsm       1 << PSR_MFH
        ssm       1 << PSR_DFH
        ;;
        srlz.d
        LEAF_RETURN

        LEAF_EXIT(BdSaveHigherFPVolatile)

//++
//--------------------------------------------------------------------
// Routine:
//
//      BdRestoreHigherFPVolatile()
//
// Description:
//
//       Restore higher FP volatile context from higher FP save area
//
//       N.B. This function is carefully constructed to use only scratch 
//            registers rHpT1, rHpT3, and rTH2.  This function may be
//            called by C code and the disabled fp vector when user
//            and kernel bank is used respectively.
//       N.B. Caller must ensure higher fp enabled (psr.dfh=0)
//       N.B. Caller must ensure no interrupt during restore
//
// Input:
//
//       None.
//
// Output:
//
//       None
//
// Return value:
//
//       None
//
//--------------------------------------------------------------------

        LEAF_ENTRY(BdRestoreHigherFPVolatile)

//
// rHpT1 & rHpT3 are 2 registers that are available as 
// scratch registers in this function.
//

        srlz.d
        movl      rHpT1 = BdPcr+PcInitialStack
        ;;

        ld8       rTH2 = [rHpT1]
        ;;
        add       rHpT1 = -ThreadStateSaveAreaLength+TsHigherFPVolatile+HiFltF32, rTH2
        add       rHpT3 = -ThreadStateSaveAreaLength+TsHigherFPVolatile+HiFltF33, rTH2
        ;;

        ldf.fill  f32 = [rHpT1], HiFltF34-HiFltF32
        ldf.fill  f33 = [rHpT3], HiFltF35-HiFltF33
        ;;

        ldf.fill  f34 = [rHpT1], HiFltF36-HiFltF34
        ldf.fill  f35 = [rHpT3], HiFltF37-HiFltF35
        ;;
        ldf.fill  f36 = [rHpT1], HiFltF38-HiFltF36
        ldf.fill  f37 = [rHpT3], HiFltF39-HiFltF37
        ;;
        ldf.fill  f38 = [rHpT1], HiFltF40-HiFltF38
        ldf.fill  f39 = [rHpT3], HiFltF41-HiFltF39
        ;;

        ldf.fill  f40 = [rHpT1], HiFltF42-HiFltF40
        ldf.fill  f41 = [rHpT3], HiFltF43-HiFltF41
        ;;
        ldf.fill  f42 = [rHpT1], HiFltF44-HiFltF42
        ldf.fill  f43 = [rHpT3], HiFltF45-HiFltF43
        ;;
        ldf.fill  f44 = [rHpT1], HiFltF46-HiFltF44
        ldf.fill  f45 = [rHpT3], HiFltF47-HiFltF45
        ;;
        ldf.fill  f46 = [rHpT1], HiFltF48-HiFltF46
        ldf.fill  f47 = [rHpT3], HiFltF49-HiFltF47
        ;;
        ldf.fill  f48 = [rHpT1], HiFltF50-HiFltF48
        ldf.fill  f49 = [rHpT3], HiFltF51-HiFltF49
        ;;

        ldf.fill  f50 = [rHpT1], HiFltF52-HiFltF50
        ldf.fill  f51 = [rHpT3], HiFltF53-HiFltF51
        ;;
        ldf.fill  f52 = [rHpT1], HiFltF54-HiFltF52
        ldf.fill  f53 = [rHpT3], HiFltF55-HiFltF53
        ;;
        ldf.fill  f54 = [rHpT1], HiFltF56-HiFltF54
        ldf.fill  f55 = [rHpT3], HiFltF57-HiFltF55
        ;;
        ldf.fill  f56 = [rHpT1], HiFltF58-HiFltF56
        ldf.fill  f57 = [rHpT3], HiFltF59-HiFltF57
        ;;
        ldf.fill  f58 = [rHpT1], HiFltF60-HiFltF58
        ldf.fill  f59 = [rHpT3], HiFltF61-HiFltF59
        ;;

        ldf.fill  f60 = [rHpT1], HiFltF62-HiFltF60
        ldf.fill  f61 = [rHpT3], HiFltF63-HiFltF61
        ;;
        ldf.fill  f62 = [rHpT1], HiFltF64-HiFltF62
        ldf.fill  f63 = [rHpT3], HiFltF65-HiFltF63
        ;;
        ldf.fill  f64 = [rHpT1], HiFltF66-HiFltF64
        ldf.fill  f65 = [rHpT3], HiFltF67-HiFltF65
        ;;
        ldf.fill  f66 = [rHpT1], HiFltF68-HiFltF66
        ldf.fill  f67 = [rHpT3], HiFltF69-HiFltF67
        ;;
        ldf.fill  f68 = [rHpT1], HiFltF70-HiFltF68
        ldf.fill  f69 = [rHpT3], HiFltF71-HiFltF69
        ;;

        ldf.fill  f70 = [rHpT1], HiFltF72-HiFltF70
        ldf.fill  f71 = [rHpT3], HiFltF73-HiFltF71
        ;;
        ldf.fill  f72 = [rHpT1], HiFltF74-HiFltF72
        ldf.fill  f73 = [rHpT3], HiFltF75-HiFltF73
        ;;
        ldf.fill  f74 = [rHpT1], HiFltF76-HiFltF74
        ldf.fill  f75 = [rHpT3], HiFltF77-HiFltF75
        ;;
        ldf.fill  f76 = [rHpT1], HiFltF78-HiFltF76
        ldf.fill  f77 = [rHpT3], HiFltF79-HiFltF77
        ;;
        ldf.fill  f78 = [rHpT1], HiFltF80-HiFltF78
        ldf.fill  f79 = [rHpT3], HiFltF81-HiFltF79
        ;;

        ldf.fill  f80 = [rHpT1], HiFltF82-HiFltF80
        ldf.fill  f81 = [rHpT3], HiFltF83-HiFltF81
        ;;
        ldf.fill  f82 = [rHpT1], HiFltF84-HiFltF82
        ldf.fill  f83 = [rHpT3], HiFltF85-HiFltF83
        ;;
        ldf.fill  f84 = [rHpT1], HiFltF86-HiFltF84
        ldf.fill  f85 = [rHpT3], HiFltF87-HiFltF85
        ;;
        ldf.fill  f86 = [rHpT1], HiFltF88-HiFltF86
        ldf.fill  f87 = [rHpT3], HiFltF89-HiFltF87
        ;;
        ldf.fill  f88 = [rHpT1], HiFltF90-HiFltF88
        ldf.fill  f89 = [rHpT3], HiFltF91-HiFltF89
        ;;

        ldf.fill  f90 = [rHpT1], HiFltF92-HiFltF90
        ldf.fill  f91 = [rHpT3], HiFltF93-HiFltF91
        ;;
        ldf.fill  f92 = [rHpT1], HiFltF94-HiFltF92
        ldf.fill  f93 = [rHpT3], HiFltF95-HiFltF93
        ;;
        ldf.fill  f94 = [rHpT1], HiFltF96-HiFltF94
        ldf.fill  f95 = [rHpT3], HiFltF97-HiFltF95
        ;;
        ldf.fill  f96 = [rHpT1], HiFltF98-HiFltF96
        ldf.fill  f97 = [rHpT3], HiFltF99-HiFltF97
        ;;
        ldf.fill  f98 = [rHpT1], HiFltF100-HiFltF98
        ldf.fill  f99 = [rHpT3], HiFltF101-HiFltF99
        ;;

        ldf.fill  f100 = [rHpT1], HiFltF102-HiFltF100
        ldf.fill  f101 = [rHpT3], HiFltF103-HiFltF101
        ;;
        ldf.fill  f102 = [rHpT1], HiFltF104-HiFltF102
        ldf.fill  f103 = [rHpT3], HiFltF105-HiFltF103
        ;;
        ldf.fill  f104 = [rHpT1], HiFltF106-HiFltF104
        ldf.fill  f105 = [rHpT3], HiFltF107-HiFltF105
        ;;
        ldf.fill  f106 = [rHpT1], HiFltF108-HiFltF106
        ldf.fill  f107 = [rHpT3], HiFltF109-HiFltF107
        ;;
        ldf.fill  f108 = [rHpT1], HiFltF110-HiFltF108
        ldf.fill  f109 = [rHpT3], HiFltF111-HiFltF109
        ;;

        ldf.fill  f110 = [rHpT1], HiFltF112-HiFltF110
        ldf.fill  f111 = [rHpT3], HiFltF113-HiFltF111
        ;;
        ldf.fill  f112 = [rHpT1], HiFltF114-HiFltF112
        ldf.fill  f113 = [rHpT3], HiFltF115-HiFltF113
        ;;
        ldf.fill  f114 = [rHpT1], HiFltF116-HiFltF114
        ldf.fill  f115 = [rHpT3], HiFltF117-HiFltF115
        ;;
        ldf.fill  f116 = [rHpT1], HiFltF118-HiFltF116
        ldf.fill  f117 = [rHpT3], HiFltF119-HiFltF117
        ;;
        ldf.fill  f118 = [rHpT1], HiFltF120-HiFltF118
        ldf.fill  f119 = [rHpT3], HiFltF121-HiFltF119
        ;;

        ldf.fill  f120 = [rHpT1], HiFltF122-HiFltF120
        ldf.fill  f121 = [rHpT3], HiFltF123-HiFltF121
        ;;
        ldf.fill  f122 = [rHpT1], HiFltF124-HiFltF122
        ldf.fill  f123 = [rHpT3], HiFltF125-HiFltF123
        ;;
        ldf.fill  f124 = [rHpT1], HiFltF126-HiFltF124
        ldf.fill  f125 = [rHpT3], HiFltF127-HiFltF125
        ;;
        ldf.fill  f126 = [rHpT1]
        ldf.fill  f127 = [rHpT3]
        ;;

        rsm       1 << PSR_MFH                 // clear psr.mfh bit
        br.ret.sptk brp
        ;;

        LEAF_EXIT(BdRestoreHigherFPVolatile)


//++
//
// Routine Description:
//
//     This routine begins the common code for raising an exception.
//     The routine saves the non-volatile state and dispatches to the
//     next level exception dispatcher.
//
// Arguments:
//
//      a0 - pointer to trap frame
//      a1 - previous mode
//
// Return Value:
//
//      None.
//
//--

        NESTED_ENTRY(BdExceptionDispatch)

//
// Build exception frame
//

        .regstk   2, 3, 5, 0
        .prologue 0xA, loc0
        alloc     t16 = ar.pfs, 2, 3, 5, 0
        mov       loc0 = sp
        cmp4.eq   pt0 = UserMode, a1                  // previous mode is user?

        mov       loc1 = brp 
        add       sp = -ExceptionFrameLength, sp
        ;;

        .save     ar.unat, loc2
        mov       loc2 = ar.unat
        add       t0 = ExFltS19+STACK_SCRATCH_AREA, sp
        add       t1 = ExFltS18+STACK_SCRATCH_AREA, sp
        ;;

        .save.gf  0x0, 0xC0000
        stf.spill [t0] = fs19, ExFltS17-ExFltS19
        stf.spill [t1] = fs18, ExFltS16-ExFltS18
        ;;

        .save.gf  0x0, 0x30000
        stf.spill [t0] = fs17, ExFltS15-ExFltS17
        stf.spill [t1] = fs16, ExFltS14-ExFltS16
        mov       t10 = bs4
        ;;

        .save.gf  0x0, 0xC000
        stf.spill [t0] = fs15, ExFltS13-ExFltS15
        stf.spill [t1] = fs14, ExFltS12-ExFltS14
        mov       t11 = bs3
        ;;

        .save.gf  0x0, 0x3000
        stf.spill [t0] = fs13, ExFltS11-ExFltS13
        stf.spill [t1] = fs12, ExFltS10-ExFltS12
        mov       t12 = bs2
        ;;

        .save.gf  0x0, 0xC00
        stf.spill [t0] = fs11, ExFltS9-ExFltS11
        stf.spill [t1] = fs10, ExFltS8-ExFltS10
        mov       t13 = bs1
        ;;

        .save.gf  0x0, 0x300
        stf.spill [t0] = fs9, ExFltS7-ExFltS9
        stf.spill [t1] = fs8, ExFltS6-ExFltS8
        mov       t14 = bs0
        ;;

        .save.gf  0x0, 0xC0
        stf.spill [t0] = fs7, ExFltS5-ExFltS7
        stf.spill [t1] = fs6, ExFltS4-ExFltS6
        mov       t15 = ar.lc
        ;;

        .save.gf  0x0, 0x30
        stf.spill [t0] = fs5, ExFltS3-ExFltS5
        stf.spill [t1] = fs4, ExFltS2-ExFltS4
        ;;

        .save.f   0xC
        stf.spill [t0] = fs3, ExFltS1-ExFltS3         // save fs3
        stf.spill [t1] = fs2, ExFltS0-ExFltS2         // save fs2
        ;;

        .save.f   0x3
        stf.spill [t0] = fs1, ExBrS4-ExFltS1          // save fs1
        stf.spill [t1] = fs0, ExBrS3-ExFltS0          // save fs0
        ;;

        .save.b   0x18
        st8       [t0] = t10, ExBrS2-ExBrS4           // save bs4
        st8       [t1] = t11, ExBrS1-ExBrS3           // save bs3
        ;;

        .save.b   0x6
        st8       [t0] = t12, ExBrS0-ExBrS2           // save bs2
        st8       [t1] = t13, ExIntS2-ExBrS1          // save bs1
        ;;

        .save.b   0x1
        st8       [t0] = t14, ExIntS3-ExBrS0          // save bs0
 (pt0)  add       out0 = TrapFrameLength+TsHigherFPVolatile, a0
        ;;

        .save.gf  0xC, 0x0
        .mem.offset 0,0
        st8.spill [t0] = s3, ExIntS1-ExIntS3          // save s3
        .mem.offset 8,0
        st8.spill [t1] = s2, ExIntS0-ExIntS2          // save s2
        ;;

        .save.gf  0x3, 0x0
        .mem.offset 0,0
        st8.spill [t0] = s1, ExApLC-ExIntS1           // save s1
        .mem.offset 8,0
        st8.spill [t1] = s0, ExApEC-ExIntS0           // save s0
        ;;

        .savepsp  ar.pfs, ExceptionFrameLength-ExApEC-STACK_SCRATCH_AREA
        st8       [t1] = t16, ExIntNats-ExApEC
        mov       t4 = ar.unat                        // captured Nats of s0-s3
        ;;

        .savepsp  ar.lc, ExceptionFrameLength-ExApLC-STACK_SCRATCH_AREA
        st8       [t0] = t15
        .savepsp  @priunat, ExceptionFrameLength-ExIntNats-STACK_SCRATCH_AREA
        st8       [t1] = t4                           // save Nats of s0-s3
 (pt0)  br.call.sptk brp = BdSaveHigherFPVolatile
        ;;


        PROLOGUE_END

        add       out0 = TrExceptionRecord, a0        // -> exception record
        add       out1 = STACK_SCRATCH_AREA, sp       // -> exception frame
        mov       out2 = a0                           // -> trap frame

        br.call.sptk.many brp = BdTrap

        add       t1 = ExApEC+STACK_SCRATCH_AREA, sp
        movl      t0 = BdExceptionExit
        ;;

        ld8       t1 = [t1]
        mov       brp = t0
        ;;

        mov       ar.unat = loc2
        mov       ar.pfs = t1

        add       s1 = STACK_SCRATCH_AREA, sp         // s1 -> exception frame
        mov       s0 = a0                             // s0 -> trap frame
        br.ret.sptk brp
        ;;

        ALTERNATE_ENTRY(BdExceptionExit)

//++
//
// Routine Description:
//
//     This routine is called to exit from an exception.
//
//     N.B. This transfer of control occurs from:
//
//         1. fall-through from above
//         2. exit from continue system service
//         3. exit from raise exception system service
//         4. exit into user mode from thread startup
//
// Arguments:
//
//     loc0 - pointer to trap frame
//     sp - pointer to high preserved float save area + STACK_SCRATCH_AREA
//
// Return Value:
//
//      Does not return.
//
//--

//
// upon entry of this block, s0 and s1 must be set to the address of
// the trap and the exception frames respectively.
//
// preserved state is restored here because they may have been modified
// by SetContext
//

     
        LEAF_SETUP(0, 1, 2, 0)                        // must be in sync with
                                                  // BdGenericExceptionHandler
        mov       loc0 = s0                       // -> trap frame
        mov       out0 = s1                       // -> exception frame
        ;;

        br.call.sptk brp = BdRestoreExceptionFrame
        ;;

        mov       sp = loc0                       // deallocate exception
                                                  // frame by restoring sp

        ALTERNATE_ENTRY(BdAlternateExit)

//
// sp -> trap frame addres
//
// Interrupts disabled from here to rfi
//

        FAST_DISABLE_INTERRUPTS
        ;;

        RETURN_FROM_INTERRUPTION(Ked)

        NESTED_EXIT(BdExceptionDispatch)



        NESTED_ENTRY(BdInstallVectors)
        NESTED_SETUP  (3,17,8,0)          

IpValue:
        mov         loc4 = ip
        movl        loc5 = IpValue
        ;;

        sub         loc6 = loc4, loc5           // relocation = runtime add - link addr
        mov         loc8 = cr.iva
        ;;

//
// Set Break Instrution Vector
//
        movl        loc7 = 0x2C00
        ;;

        add         out0 = loc7, loc8           // out0 = address of IVT vector
        movl        out1 = BdBreakVector        // out2 = address of exception handler 
                                                // (static value) to be plugged into IVT 
        mov         out2 = loc6                 // adjustment to go from static to runtime
        br.call.dpnt.few  brp = BdUpdateIvt     // Fill in the address of routine into IVT

//
// Set Taken Branch Vector
//
        movl        loc7 = 0x5F00
        ;;

        add         out0 = loc7, loc8           // out0 = address of IVT vector
        movl        out1 = BdTakenBranchVector  // out2 = address of exception handler 
                                                // (static value) to be plugged into IVT 
        mov         out2 = loc6                 // adjustment to go from static to runtime
        br.call.dpnt.few  brp = BdUpdateIvt     // Fill in the address of routine into IVT

//
// Set Single Step Vector
//
        movl        loc7 = 0x6000
        ;;

        add         out0 = loc7, loc8           // out0 = address of IVT vector
        movl        out1 = BdSingleStepVector   // out2 = address of exception handler 
                                                // (static value) to be plugged into IVT 
        mov         out2 = loc6                 // adjustment to go from static to runtime
        br.call.dpnt.few  brp = BdUpdateIvt     // Fill in the address of routine into IVT

        NESTED_RETURN
        NESTED_EXIT(BdInstallVectors)               // Return to caller using B0


//-------------------------------------------------
//
//  BdUpdateIvt : Routine to fill in an entry into the IVT. 
//  This is a leaf routine. 
//
//   in0 = address of IVT vector
//   in1 = address of exception handler (static value) to be plugged into IVT 
//   in2 = adjustment to go from static to runtime
//
//-------------------------------------------------
        NESTED_ENTRY(BdUpdateIvt)
        NESTED_SETUP  (8,16,4,0)          

        mov         out0 = in0
        movl        out1 = BdIvtStart
        movl        out2 = BdIvtEnd - BdIvtStart
        ;;

        br.call.sptk brp = RtlCopyMemory
        ;;

        mov         out0 = in0
        mov         out1 = in1
        ;;
        br.call.sptk brp = BdSetMovlImmediate

        NESTED_RETURN
        NESTED_EXIT(BdUpdateIvt)                  // Return to caller using B0


BdIvtStart:
{
        .mlx
        nop.m 0
        movl        h31 = BdIvtStart
        ;;
}
{
        .mii
        nop.m  0
        nop.i  0
        mov         h30 = b7
        ;;
}
{
        .mii
        nop.m  0
        nop.i  0
        mov         b7 = h31
        ;;
}
{
        .mib
        nop.m  0
        nop.i  0
(p0)    br.sptk.few b7   
        ;;
}
BdIvtEnd:

//
// All non-VECTOR_ENTRY functions must follow KiNormalSystemCall.
//
// N.B. KiNormalSystemCall must be the first function body in the .nsc
//      section.
//


//--------------------------------------------------------------------
// Routine:
//
//       KiNormalSystemCall
//
// Description:
//
//       Handler for normal (not fast) system calls
//
// On entry:
//
//       ic off
//       interrupts disabled
//       v0: contains sys call #
//       cover done by call
//       r32-r39: sys call arguments
//       CFM: sof = # args, ins = 0, outs = # args
//
// Return value:
//
//       v0: system call return value
//
// Process:
//
//--------------------------------------------------------------------

#if 0
        .section .drectve, "MI", "progbits"
         string " -section:.nsc,,align=0x4000"

        .section .nsc = "ax", "progbits"
#endif

        HANDLER_ENTRY_EX(KiNormalSystemCall, BdRestoreTrapFrame)

        .prologue
        .unwabi     @nt,  SYSCALL_FRAME

        rThread     = t1                  // current thread
        rIFS        = t1
        rIIP        = t2
        rPreds      = t3
        rIPSR       = t4
        rUNAT       = t5

        rSp         = t6

        rpT1        = t7
        rpT2        = t8
        rpT3        = t9
        rpT4        = t10
        rT0         = t11
        rT1         = t12
        rT2         = t13
        rT3         = t14
        rT4         = t15

        rIntNats    = t17

        rpSd        = t16                  /* -> service descriptor entry   */
        rSdOffset   = t17                  /* service descriptor offset     */
        rArgTable   = t18                  /* pointer to argument table     */
        rArgNum     = t20                  /* number of arguments     */
        rArgBytes   = t21

        rpBSPStore  = t16
        rRscD       = t16
        rRNAT       = t17
        rRscE       = t18
        rKBSPStore  = t18
        rBSPStore   = t19
        rpBSP       = t20
        rRscDelta   = t20

        rBSP        = t21
        rPreviousMode = t22

        pInvl       = pt0                  /* pInvl = not GUI service       */
        pVal        = pt1
        pGui        = pt2                  /* true if GUI call              */
        pNoGui      = pt3                  /* true if no GUI call           */
        pNatedArg   = pt4                  /* true if any input argument    */
                                           /* register is Nat'ed            */
        pNoCopy     = pt5                  /* no in-memory arguments to copy */
        pCopy       = pt6


        mov       rUNAT = ar.unat
        tnat.nz   pt0 = sp
        mov       rPreviousMode = KernelMode

        mov       rIPSR = psr
        rsm       1 << PSR_I | 1 << PSR_MFH
        br.sptk   BdRestoreTrapFrame

        HANDLER_EXIT(KiNormalSystemCall)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bd\ia64\reboot.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    bdreboot.c

Abstract:

    System reboot function.  Currently part of the debugger because
    that's the only place it's used.

Author:

    Bryan M. Willman (bryanwi) 4-Dec-90

Revision History:

--*/

#include "bd.h"

VOID
FwStallExecution(
    IN ULONG Microseconds
    );


#define CMOS_CTRL   (PUCHAR )0x70
#define CMOS_DATA   (PUCHAR )0x71

#define RESET       0xfe
#define KEYBPORT    (PUCHAR )0x64


VOID
HalpReboot (
    VOID
    )

/*++

Routine Description:

    This procedure resets the CMOS clock to the standard timer settings
    so the bios will work, and then issues a reset command to the keyboard
    to cause a warm boot.

    It is very machine dependent, this implementation is intended for
    PC-AT like machines.

    This code copied from the "old debugger" sources.

    N.B.

        Will NOT return.

--*/

{
}


VOID
BdReboot (
    VOID
    )

/*++

Routine Description:

    Just calls the HalReturnToFirmware function.

Arguments:

    None

Return Value:

    Does not return

--*/

{
    //
    // Never returns from HAL
    //

    HalpReboot();

    while (TRUE) {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\dcmpstub.c ===
#include "bldr.h"

VOID
DecompEnableDecompression(
    IN BOOLEAN Enable
    )
{
    UNREFERENCED_PARAMETER(Enable);

    return;
}


BOOLEAN
DecompGenerateCompressedName(
    IN  LPCSTR Filename,
    OUT LPSTR  CompressedName
    )
{
    UNREFERENCED_PARAMETER(Filename);
    UNREFERENCED_PARAMETER(CompressedName);

    //
    // Indicate that the caller shouldn't bother trying to locate
    // the compressed filename.
    //
    return(FALSE);
}


ULONG
DecompPrepareToReadCompressedFile(
    IN LPCSTR Filename,
    IN ULONG  FileId
    )
{
    UNREFERENCED_PARAMETER(Filename);
    UNREFERENCED_PARAMETER(FileId);

    //
    // No processing in osloader, only in setupldr.
    // Special return code of -1 takes care of this.
    //
    return((ULONG)(-1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\bldrint.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    bldrint.h

Abstract:

    This module is the internal header file for the NT boot loader.

Author:

    Andrew Ritz (andrewr) 12-Dec-2000

Revision History:

--*/

#ifndef _BLDRINT_
#define _BLDRINT_

                  
#define ASCI_CSI_OUT    TEXT("\033[")     // escape-leftbracket

#define ATT_FG_BLUE     4
#define ATT_FG_WHITE    7
#define ATT_BG_BLUE     (ATT_FG_BLUE    << 4)
#define ATT_BG_WHITE    (ATT_FG_WHITE   << 4)
#define DEFATT          (ATT_FG_WHITE | ATT_BG_BLUE)
#define INVATT          (ATT_FG_BLUE |  ATT_BG_WHITE)


#endif // _BLDRINT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\hiber.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hiber.c

Abstract:


Author:


Revision History:

   8/7/1998   Elliot Shmukler (t-ellios)    Added Hiber file compression

--*/

#include "bldr.h"
#include "msg.h"
#include "stdio.h"
#include "stdlib.h"
#include "xpress.h"


extern UCHAR WakeDispatcherStart;
extern UCHAR WakeDispatcherEnd;

//
//
// Hiber globals
//
// HiberFile    - File handle
// HiberBuffer  - PAGE of ram
// HiberIoError - Set to true to indicate an IO read error occured during restore
//

ULONG       HiberFile;
PUCHAR      HiberBuffer;
ULONG       HiberBufferPage;
BOOLEAN     HiberIoError;
BOOLEAN     HiberOutOfRemap;
BOOLEAN     HiberAbort;
LARGE_INTEGER HiberStartTime;
LARGE_INTEGER HiberEndTime;

//
// HiberImageFeatureFlags - Feature flags from hiber image header
// HiberBreakOnWake - BreakOnWake flag from hiber image header
//

BOOLEAN HiberBreakOnWake;
ULONG HiberImageFeatureFlags;

#if defined(_ALPHA_) || defined(_IA64_)

//
// On Alpha, the address of the KPROCESSOR_STATE read from the hiber file
// must be saved where WakeDispatch can find it (it's at a fixed offset
// relative to HiberVa on x86).
//

PKPROCESSOR_STATE HiberWakeState;

#else   // x86

//
// HiberPtes - Virtual address of ptes to use for restoriation.  There
// are at least HIBER_PTES consecutive ptes for use, and are for the
// address of HiberVa
//
// HiberVa - The virtual address the HiberPtes map
//
// HiberIdentityVa - The restoration images HiberVa
//
// HiberPageFrames - Page frames of the hiber ptes (does not include dest pte)
//

PVOID HiberPtes;
PUCHAR HiberVa;
PVOID HiberIdentityVa;
ULONG HiberPageFrames[HIBER_PTES];

#endif  // Alpha/x86

PFN_NUMBER HiberImagePageSelf;
ULONG HiberNoMappings;
ULONG HiberFirstRemap;
ULONG HiberLastRemap;

VOID
BlUpdateProgressBar(
    ULONG fPercentage
    );

VOID
BlOutputStartupMsg(
    ULONG   uMsgID
    );

VOID
BlOutputTrailerMsg(
    ULONG   uMsgID
    );

//
// Defines for Hiber restore UI
//

ULONG   HbCurrentScreen;

#define BAR_X                       7
#define BAR_Y                      10
#define PERCENT_BAR_WIDTH          66

#define PAUSE_X                     7
#define PAUSE_Y                     7

#define FAULT_X                     7
#define FAULT_Y                     7

UCHAR szHiberDebug[] = "debug";
UCHAR szHiberFileName[] = "\\hiberfil.sys";

//
// HiberFile Compression Related definnes
//

#define PAGE_MASK   (PAGE_SIZE - 1)
#define PAGE_PAGES(n)   (((n) + PAGE_MASK) >> PAGE_SHIFT)

//
// The size of the buffer for compressed data

#define COMPRESSION_BUFFER_SIZE     64 << PAGE_SHIFT

//

#define MAX_COMPRESSION_BUFFER_EXTRA_PAGES \
    PAGE_PAGES (PAGE_MASK + 2*XPRESS_HEADER_SIZE)
#define MAX_COMPRESSION_BUFFER_EXTRA_SIZE \
    (MAX_COMPRESSION_BUFFER_EXTRA_PAGES << PAGE_SHIFT)

#define LZNT1_COMPRESSION_BUFFER_PAGES  16
#define LZNT1_COMPRESSION_BUFFER_SIZE \
    (LZNT1_COMPRESSION_BUFFER_PAGES << PAGE_SHIFT)

#define XPRESS_COMPRESSION_BUFFER_PAGES \
    PAGE_PAGES (XPRESS_MAX_SIZE + MAX_COMPRESSION_BUFFER_EXTRA_SIZE)
#define XPRESS_COMPRESSION_BUFFER_SIZE \
    (XPRESS_COMPRESSION_BUFFER_PAGES << PAGE_SHIFT)

#define MAX_COMPRESSION_BUFFER_PAGES \
    max (LZNT1_COMPRESSION_BUFFER_PAGES, XPRESS_COMPRESSION_BUFFER_PAGES)
#define MAX_COMPRESSION_BUFFER_SIZE \
    (MAX_COMPRESSION_BUFFER_PAGES << PAGE_SHIFT)


// Buffer to store decoded data
typedef struct {
    PUCHAR DataPtr, PreallocatedDataBuffer;
    LONG   DataSize;

    struct {
        struct {
            LONG Size;
            ULONG Checksum;
        } Compressed, Uncompressed;

        LONG XpressEncoded;
    } Header;

    LONG DelayedCnt;      // # of delayed pages
    ULONG DelayedChecksum;    // last checksum value
    ULONG DelayedBadChecksum;

    struct {
        PUCHAR DestVa;  // delayed DestVa
        PFN_NUMBER DestPage;// delayed page number
        ULONG  RangeCheck;  // last range checksum
        LONG   Flags;   // 1 = clear checksum, 2 = compare checksum
    } Delayed[XPRESS_MAX_PAGES];
} DECOMPRESSED_BLOCK, *PDECOMPRESSED_BLOCK;

typedef struct {
    struct {
        PUCHAR Beg;
        PUCHAR End;
    } Current, Buffer, Aligned;
    PFN_NUMBER FilePage;
    BOOLEAN    NeedSeek;
} COMPRESSED_BUFFER, *PCOMPRESSED_BUFFER;

#define HIBER_PERF_STATS 0

//
// Internal prototypes
//

#if !defined (HIBER_DEBUG)
#define CHECK_ERROR(a,b)    if(a) { *Information = __LINE__; return b; }
#define DBGOUT(_x_)
#else
#define CHECK_ERROR(a,b) if(a) {HbPrintMsg(b);HbPrint(TEXT("\r\n")); *Information = __LINE__; HbPause(); return b; }
#define DBGOUT(_x_) BlPrint _x_
#endif


ULONG
HbRestoreFile (
    IN PULONG       Information,
    OUT OPTIONAL PCHAR       *BadLinkName
    );

VOID
HbPrint (
    IN _PTUCHAR   str
    );

BOOLEAN
HbReadNextCompressedPageLZNT1 (
    PUCHAR DestVa,
    PCOMPRESSED_BUFFER CompressedBuffer
    );

BOOLEAN
HbReadNextCompressedChunkLZNT1 (
    PUCHAR DestVa,
    PCOMPRESSED_BUFFER CompressedBuffer
    );

BOOLEAN
HbReadNextCompressedPages (
    LONG BytesNeeded,
    PCOMPRESSED_BUFFER CompressedBuffer
    );

BOOLEAN
HbReadNextCompressedBlock (
    PDECOMPRESSED_BLOCK Block,
    PCOMPRESSED_BUFFER CompressedBuffer
    );

BOOLEAN
HbReadDelayedBlock (
    BOOLEAN ForceDecoding,
    PFN_NUMBER DestPage,
    ULONG RangeCheck,
    PDECOMPRESSED_BLOCK Block,
    PCOMPRESSED_BUFFER CompressedBuffer
    );

BOOLEAN
HbReadNextCompressedBlockHeader (
    PDECOMPRESSED_BLOCK Block,
    PCOMPRESSED_BUFFER CompressedBuffer
    );

ULONG
BlHiberRestore (
    IN ULONG DriveId,
    OUT PCHAR *BadLinkName
    );

BOOLEAN
HbReadNextCompressedChunk (
    PUCHAR DestVa,
    PPFN_NUMBER FilePage,
    PUCHAR CompressBuffer,
    PULONG DataOffset,
    PULONG BufferOffset,
    ULONG MaxOffset
    );


#if defined (HIBER_DEBUG) || HIBER_PERF_STATS

// HIBER_DEBUG bit mask:
//  2 - general bogosity
//  4 - remap trace


VOID HbFlowControl(VOID)
{
    UCHAR c;
    ULONG count;

    if (ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
        ArcRead(ARC_CONSOLE_INPUT, &c, 1, &count);
        if (c == 'S' - 0x40) {
            ArcRead(ARC_CONSOLE_INPUT, &c, 1, &count);
        }
    }
}

VOID HbPause(VOID)
{
    UCHAR c;
    ULONG count;

#if defined(ENABLE_LOADER_DEBUG)
    DbgBreakPoint();
#else
    HbPrint(TEXT("Press any key to continue . . ."));
    ArcRead(ARC_CONSOLE_INPUT, &c, 1, &count);
    HbPrint(TEXT("\r\n"));
#endif
}

VOID HbPrintNum(ULONG n)
{
    TCHAR buf[9];

    _stprintf(buf, TEXT("%ld"), n);
    HbPrint(buf);
    HbFlowControl();
}

VOID HbPrintHex(ULONG n)
{
    TCHAR buf[11];

    _stprintf(buf, TEXT("0x%08lX"), n);
    HbPrint(buf);
    HbFlowControl();
}

#define SHOWNUM(x) ((void) (HbPrint(#x TEXT(" = ")), HbPrintNum((ULONG) (x)), HbPrint(TEXT("\r\n"))))
#define SHOWHEX(x) ((void) (HbPrint(#x TEXT(" = ")), HbPrintHex((ULONG) (x)), HbPrint(TEXT("\r\n"))))

#endif // HIBER_DEBUG

#if !defined(i386) && !defined(_ALPHA_)
ULONG
HbSimpleCheck (
    IN ULONG                PartialSum,
    IN PVOID                SourceVa,
    IN ULONG                Length
    );
#else

// Use the TCP/IP Check Sum routine if available

ULONG
tcpxsum(
   IN ULONG cksum,
   IN PUCHAR buf,
   IN ULONG len
   );

#define HbSimpleCheck(a,b,c) tcpxsum(a,(PUCHAR)b,c)

#endif


VOID
HbReadPage (
    IN PFN_NUMBER PageNo,
    IN PUCHAR Buffer
    );

VOID
HbSetImageSignature (
    IN ULONG    NewSignature
    );

VOID
HbPrint (
    IN _PTUCHAR   str
    )
{
    ULONG   Junk;

    ArcWrite (
        BlConsoleOutDeviceId,
        str,
        _tcslen(str)*sizeof(TCHAR),
        &Junk
        );
}

VOID HbPrintChar (_TUCHAR chr)
{
      ULONG Junk;

      ArcWrite(
               BlConsoleOutDeviceId,
               &chr,
               sizeof(_TUCHAR),
               &Junk
               );
}

VOID
HbPrintMsg (
    IN ULONG  MsgNo
    )
{
    PTCHAR  Str;

    Str = BlFindMessage(MsgNo);
    if (Str) {
        HbPrint (Str);
    }
}

VOID
HbScreen (
    IN ULONG Screen
    )
{

    UCHAR Buffer[100];
    int i, ii;

#if defined(HIBER_DEBUG)
    HbPrint(TEXT("\r\n"));
    HbPause();
#endif

    HbCurrentScreen = Screen;
    BlSetInverseMode (FALSE);
    BlPositionCursor (1, 1);
    BlClearToEndOfScreen();
    BlPositionCursor (1, 3);
    HbPrintMsg(Screen);
}

ULONG
HbSelection (
    ULONG   x,
    ULONG   y,
    PULONG  Sel,
    ULONG   Debug
    )
{
    ULONG   CurSel, MaxSel;
    ULONG   i;
    UCHAR   Key;
    PUCHAR  pDebug;

    for (MaxSel=0; Sel[MaxSel]; MaxSel++) ;
    MaxSel -= Debug;
    pDebug = szHiberDebug;

#if DBG
    MaxSel += Debug;
    Debug = 0;
#endif

    CurSel = 0;
    for (; ;) {
        //
        // Draw selections
        //

        for (i=0; i < MaxSel; i++) {
            BlPositionCursor (x, y+i);
            BlSetInverseMode ((BOOLEAN) (CurSel == i) );
            HbPrintMsg(Sel[i]);
        }

        //
        // Get a key
        //

        ArcRead(ARC_CONSOLE_INPUT, &Key, sizeof(Key), &i);
        if (Key == ASCI_CSI_IN) {
            ArcRead(ARC_CONSOLE_INPUT, &Key, sizeof(Key), &i);
            switch (Key) {
                case 'A':
                    //
                    // Cursor up
                    //
                    CurSel -= 1;
                    if (CurSel >= MaxSel) {
                        CurSel = MaxSel-1;
                    }
                    break;

                case 'B':
                    //
                    // Cursor down
                    //
                    CurSel += 1;
                    if (CurSel >= MaxSel) {
                        CurSel = 0;
                    }
                    break;
            }
        } else {
            if (Key == *pDebug) {
                pDebug++;
                if (!*pDebug) {
                    MaxSel += Debug;
                    Debug = 0;
                }
            } else {
                pDebug = szHiberDebug;
            }

            switch (Key) {
                case ASCII_LF:
                case ASCII_CR:
                    BlSetInverseMode (FALSE);
                    BlPositionCursor (1, 2);
                    BlClearToEndOfScreen ();
                    if (Sel[CurSel] == HIBER_DEBUG_BREAK_ON_WAKE) {
                        HiberBreakOnWake = TRUE;
                    }

                    return CurSel;
            }
        }
    }
}


VOID
HbCheckForPause (
    VOID
    )
{
    ULONG       uSel = 0;
    UCHAR       Key;
    ULONG       Sel[4];
    BOOLEAN     bPaused = FALSE;

    //
    // Check for space bar
    //

    if (ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
        ArcRead(ARC_CONSOLE_INPUT, &Key, sizeof(Key), &uSel);

        switch (Key) {
            // space bar pressed
            case ' ':
                bPaused = TRUE;
                break;

            // user pressed F5/F8 key
            case ASCI_CSI_IN:
                ArcRead(ARC_CONSOLE_INPUT, &Key, sizeof(Key), &uSel);

                if(Key == 'O') {
                    ArcRead(ARC_CONSOLE_INPUT, &Key, sizeof(Key), &uSel);
                    bPaused = (Key == 'r' || Key == 't');
                }

                break;

            default:
                bPaused = FALSE;
                break;
        }

        if (bPaused) {
            Sel[0] = HIBER_CONTINUE;
            Sel[1] = HIBER_CANCEL;
            Sel[2] = HIBER_DEBUG_BREAK_ON_WAKE;
            Sel[3] = 0;

            HbScreen(HIBER_PAUSE);

            uSel = HbSelection (PAUSE_X, PAUSE_Y, Sel, 1);

            if (uSel == 1) {
                HiberIoError = TRUE;
                HiberAbort = TRUE;
                return ;
            } else {
                BlSetInverseMode(FALSE);

                //
                // restore hiber progress screen
                //
                BlOutputStartupMsg(BL_MSG_RESUMING_WINDOWS);
                BlOutputTrailerMsg(BL_ADVANCED_BOOT_MESSAGE);
            }
        }
    }
}


ULONG
BlHiberRestore (
    IN ULONG DriveId,
    OUT PCHAR *BadLinkName
    )
/*++

Routine Description:

    Checks DriveId for a valid hiberfile.sys and if found start the
    restoration procedure

--*/
{
    extern BOOLEAN  BlOutputDots;
    NTSTATUS        Status;
    ULONG           Msg;
    ULONG           Information;
    ULONG           Sel[2];
    BOOLEAN         bDots = BlOutputDots;

    //
    // If restore was aborted once, don't bother
    //

#if defined (HIBER_DEBUG)
    HbPrint(TEXT("BlHiberRestore\r\n"));
#endif


    if (HiberAbort) {
        return ESUCCESS;
    }

    //
    // Get the hiber image. If not present, done.
    //

    Status = BlOpen (DriveId, szHiberFileName, ArcOpenReadWrite, &HiberFile);
    if (Status != ESUCCESS) {
#if defined (HIBER_DEBUG)
        HbPrint(TEXT("No hiber image file.\r\n"));
#endif
        return ESUCCESS;
    }

    //
    // Restore the hiber image
    //
    BlOutputDots = TRUE;
    //
    // Set the global flag to allow blmemory.c to grab from the right
    // part of the buffer
    //
    BlRestoring=TRUE;

    Msg = HbRestoreFile (&Information, BadLinkName);

    BlOutputDots = bDots;

    if (Msg) {
        BlSetInverseMode (FALSE);

        if (!HiberAbort) {
            HbScreen(HIBER_ERROR);
            HbPrintMsg(Msg);
            Sel[0] = HIBER_CANCEL;
            Sel[1] = 0;
            HbSelection (FAULT_X, FAULT_Y, Sel, 0);
        }
        HbSetImageSignature (0);
    }

    BlClose (HiberFile);
    BlRestoring=FALSE;
    return Msg ? EAGAIN : ESUCCESS;
}


#if !defined(i386) && !defined(_ALPHA_)
ULONG
HbSimpleCheck (
    IN ULONG                PartialSum,
    IN PVOID                SourceVa,
    IN ULONG                Length
    )
/*++

Routine Description:

    Computes a checksum for the supplied virtual address and length

    This function comes from Dr. Dobbs Journal, May 1992

--*/
{

    PUSHORT     Source;

    Source = (PUSHORT) SourceVa;
    Length = Length / 2;

    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xFFFF);
    }

    return PartialSum;
}
#endif // i386


VOID
HbReadPage (
    IN PFN_NUMBER PageNo,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This function reads the specified page from the hibernation file

Arguments:

    PageNo      - Page number to read

    Buffer      - Buffer to read the data

Return Value:

    On success Buffer, else HbIoError set to TRUE

--*/
{
    ULONG           Status;
    ULONG           Count;
    LARGE_INTEGER   li;

    li.QuadPart = PageNo << PAGE_SHIFT;
    Status = BlSeek (HiberFile, &li, SeekAbsolute);
    if (Status != ESUCCESS) {
        HiberIoError = TRUE;
    }

    Status = BlRead (HiberFile, Buffer, PAGE_SIZE, &Count);
    if (Status != ESUCCESS) {
        HiberIoError = TRUE;
    }
}


BOOLEAN
HbReadNextCompressedPages (
    LONG BytesNeeded,
    PCOMPRESSED_BUFFER CompressedBuffer
    )
/*++

Routine Description:

    This routine makes sure that BytesNeeded bytes are available
    in CompressedBuffer and brings in more pages from Hiber file
    if necessary.

    All reads from the Hiber file occurr at the file's
    current offset forcing compressed pages to be read
    in a continuous fashion without extraneous file seeks.

Arguments:

   BytesNeeded      - Number of bytes that must be present in CompressedBuffer
   CompressedBuffer - Descriptor of data already brought in

Return Value:

   TRUE if the operation is successful, FALSE otherwise.

--*/
{
    LONG BytesLeft;
    LONG BytesRequested;
    ULONG Status;
    LONG MaxBytes;

    // Obtain number of bytes left in buffer
    BytesLeft = (LONG) (CompressedBuffer->Current.End - CompressedBuffer->Current.Beg);

    // Obtain number of bytes that are needed but not available
    BytesNeeded -= BytesLeft;

    // Preserve amount of bytes caller needs (BytesNeeded may be changed later)
    BytesRequested = BytesNeeded;

    // Do we need to read more?
    if (BytesNeeded <= 0) {
        // No, do nothing
        return(TRUE);
    }

    // Align BytesNeeded on page boundary
    BytesNeeded = (BytesNeeded + PAGE_MASK) & ~PAGE_MASK;

    // Copy left bytes to the beginning of aligned buffer retaining page alignment
    if (BytesLeft == 0) {
        CompressedBuffer->Current.Beg = CompressedBuffer->Current.End = CompressedBuffer->Aligned.Beg;
    } else {
        LONG BytesBeforeBuffer = (LONG)(CompressedBuffer->Aligned.Beg - CompressedBuffer->Buffer.Beg) & ~PAGE_MASK;
        LONG BytesLeftAligned = (BytesLeft + PAGE_MASK) & ~PAGE_MASK;
        LONG BytesToCopy;
        PUCHAR Dst, Src;

        // Find out how many pages we may keep before aligned buffer
        if (BytesBeforeBuffer >= BytesLeftAligned) {
            BytesBeforeBuffer = BytesLeftAligned;
        }

        // Avoid misaligned data accesses during copy
        BytesToCopy = (BytesLeft + 63) & ~63;

        Dst = CompressedBuffer->Aligned.Beg + BytesLeftAligned - BytesBeforeBuffer - BytesToCopy;
        Src = CompressedBuffer->Current.End - BytesToCopy;

        if (Dst != Src) {
            RtlMoveMemory (Dst, Src, BytesToCopy);
            BytesLeftAligned = (LONG) (Dst - Src);
            CompressedBuffer->Current.Beg += BytesLeftAligned;
            CompressedBuffer->Current.End += BytesLeftAligned;
        }
    }

    //
    // Increase the number of bytes read to fill our buffer up to the next
    // 64K boundary.
    //
    MaxBytes = (LONG)((((ULONG_PTR)CompressedBuffer->Current.End + 0x10000) & 0xffff) - (ULONG_PTR)CompressedBuffer->Current.End);
    if (MaxBytes > CompressedBuffer->Buffer.End - CompressedBuffer->Current.End) {
        MaxBytes = (LONG)(CompressedBuffer->Buffer.End - CompressedBuffer->Current.End);
    }
    if (MaxBytes > BytesNeeded) {
        BytesNeeded = MaxBytes;
    }


#if 0
    // for debugging only
    if (0x10000 - (((LONG) CompressedBuffer->Current.End) & 0xffff) < BytesNeeded) {
        BlPrint (("Current.Beg = %p, Current.End = %p, Current.End2 = %p\n",
                  CompressedBuffer->Current.Beg,
                  CompressedBuffer->Current.End,
                  CompressedBuffer->Current.End + BytesNeeded
                 ));
    }
#endif

    // Make sure we have enough space
    if (BytesNeeded > CompressedBuffer->Buffer.End - CompressedBuffer->Current.End) {
        // Too many bytes to read -- should never happen, but just in case...
        DBGOUT (("Too many bytes to read -- corrupted data?\n"));
        return(FALSE);
    }

    // Issue seek if necessary
    if (CompressedBuffer->NeedSeek) {
        LARGE_INTEGER li;
        li.QuadPart = CompressedBuffer->FilePage << PAGE_SHIFT;
        Status = BlSeek (HiberFile, &li, SeekAbsolute);
        if (Status != ESUCCESS) {
            DBGOUT (("Seek to 0x%x error 0x%x\n", CompressedBuffer->FilePage, Status));
            HiberIoError = TRUE;
            return(FALSE);
        }
        CompressedBuffer->NeedSeek = FALSE;
    }

    // Read in stuff from the Hiber file into the available buffer space
    Status = BlRead (HiberFile, CompressedBuffer->Current.End, BytesNeeded, &BytesNeeded);

    // Check for I/O errors...
    if (Status != ESUCCESS || (BytesNeeded & PAGE_MASK) != 0 || BytesNeeded < BytesRequested) {
        // I/O Error - FAIL.
        DBGOUT (("Read error: Status = 0x%x, ReadBytes = 0x%x, Requested = 0x%x\n", Status, BytesNeeded, BytesRequested));
        HiberIoError = TRUE;
        return(FALSE);
    }

    // I/O was good - recalculate buffer offsets based on how much
    // stuff was actually read in

    CompressedBuffer->Current.End += BytesNeeded;
    CompressedBuffer->FilePage += (BytesNeeded >> PAGE_SHIFT);

    return(TRUE);
}


BOOLEAN
HbReadNextCompressedBlockHeader (
    PDECOMPRESSED_BLOCK Block,
    PCOMPRESSED_BUFFER CompressedBuffer
    )
/*++

Routine Description:

   Read next compressed block header if it's Xpress compression.

Arguments:
   Block            - Descriptor of compressed data block

   CompressedBuffer - Descriptor of data already brought in


Return Value:

   TRUE if block is not Xpress block at all or valid Xpress block, FALSE otherwise

--*/
{
    PUCHAR Buffer;
    LONG CompressedSize;         // they all must be signed -- do not change to ULONG
    LONG UncompressedSize;
    ULONG PackedSizes;

    // First make sure next compressed data block header is available
    if (!HbReadNextCompressedPages (XPRESS_HEADER_SIZE, CompressedBuffer)) {
        // I/O error or bad header -- FAIL
        return(FALSE);
    }


    // Set pointer to the beginning of buffer
    Buffer = CompressedBuffer->Current.Beg;

    // Check header magic
    Block->Header.XpressEncoded = (RtlCompareMemory (Buffer, XPRESS_HEADER_STRING, XPRESS_HEADER_STRING_SIZE) == XPRESS_HEADER_STRING_SIZE);

    if (!Block->Header.XpressEncoded) {
        // Not Xpress -- return OK
        return(TRUE);
    }

    // Skip magic string -- we will not need it anymore
    Buffer += XPRESS_HEADER_STRING_SIZE;

    // Read sizes of compressed and uncompressed data
    PackedSizes = Buffer[0] + (Buffer[1] << 8) + (Buffer[2] << 16) + (Buffer[3] << 24);
    CompressedSize = (LONG) (PackedSizes >> 10) + 1;
    UncompressedSize = ((LONG) (PackedSizes & 1023) + 1) << PAGE_SHIFT;

    Block->Header.Compressed.Size = CompressedSize;
    Block->Header.Uncompressed.Size = UncompressedSize;

    // Read checksums
    Block->Header.Uncompressed.Checksum = Buffer[4] + (Buffer[5] << 8);
    Block->Header.Compressed.Checksum = Buffer[6] + (Buffer[7] << 8);

    // Clear space occupied by compressed checksum
    Buffer[6] = Buffer[7] = 0;

    // Make sure sizes are in correct range
    if (UncompressedSize > XPRESS_MAX_SIZE ||
        CompressedSize > UncompressedSize ||
        CompressedSize == 0 ||
        UncompressedSize == 0) {
        // broken input data -- do not even try to decompress

        DBGOUT (("Corrupted header: %02x %02x %02x %02x %02x %02x %02x %02x\n",
                 Buffer[0], Buffer[1], Buffer[2], Buffer[3], Buffer[4], Buffer[5], Buffer[6], Buffer[7]));
        DBGOUT (("CompressedSize = %d, UncompressedSize = %d\n", CompressedSize, UncompressedSize));

        return(FALSE);
    }

    // Xpress header and it looks OK so far
    return(TRUE);
}


BOOLEAN
HbReadNextCompressedBlock (
    PDECOMPRESSED_BLOCK Block,
    PCOMPRESSED_BUFFER CompressedBuffer
    )
/*++

Routine Description:

   Reads and decompresses the next compressed chunk from the Hiber file
   and stores it in a designated region of virtual memory.

   Since no master data structure exists within the Hiber file to identify
   the location of all of the compression chunks, this routine operates
   by reading sections of the Hiber file into a compression buffer
   and extracting chunks from that buffer.

   Chunks are extracted by determining if a chunk is completely present in the buffer
   using the RtlDescribeChunk API. If the chunk is not completely present,
   more of the Hiber file is read into the buffer until the chunk can
   be extracted.

   All reads from the Hiber file occurr at its current offset, forcing
   compressed chunks to be read in a continous fashion with no extraneous
   seeks.

Arguments:

   Block            - Descriptor of compressed data block
   CompressedBuffer - Descriptor of data already brought in

Return Value:

   TRUE if a chunk has been succesfully extracted and decompressed, FALSE otherwise.

--*/
{
    PUCHAR Buffer;
    LONG CompressedSize;         // they all must be signed -- do not change to ULONG
    LONG AlignedCompressedSize;
    LONG UncompressedSize;


    // First make sure next compressed data block header is available
    if (!HbReadNextCompressedBlockHeader (Block, CompressedBuffer)) {
        // I/O error -- FAIL
        return(FALSE);
    }

    // It must be Xpress
    if (!Block->Header.XpressEncoded) {
#ifdef HIBER_DEBUG
        // Set pointer to the beginning of buffer
        Buffer = CompressedBuffer->Current.Beg;

        // wrong magic -- corrupted data
        DBGOUT (("Corrupted header: %02x %02x %02x %02x %02x %02x %02x %02x\n",
                 Buffer[0], Buffer[1], Buffer[2], Buffer[3], Buffer[4], Buffer[5], Buffer[6], Buffer[7]));
#endif /* HIBER_DEBUG */

        return(FALSE);
    }

    // Read sizes
    UncompressedSize = Block->Header.Uncompressed.Size;
    CompressedSize = Block->Header.Compressed.Size;

    // If not enough space supplied use preallocated buffer
    if (UncompressedSize != Block->DataSize) {
        Block->DataSize = UncompressedSize;
        Block->DataPtr = Block->PreallocatedDataBuffer;
    }

    // Evaluate aligned size of compressed data
    AlignedCompressedSize = (CompressedSize + (XPRESS_ALIGNMENT - 1)) & ~(XPRESS_ALIGNMENT - 1);

    // Make sure we have all compressed data and the header in buffer
    if (!HbReadNextCompressedPages (AlignedCompressedSize + XPRESS_HEADER_SIZE, CompressedBuffer)) {
        // I/O error -- FAIL
        return(FALSE);
    }

    // Set pointer to the beginning of buffer
    Buffer = CompressedBuffer->Current.Beg;

    // We will use some bytes out of buffer now -- reflect this fact
    CompressedBuffer->Current.Beg += AlignedCompressedSize + XPRESS_HEADER_SIZE;

    // evaluate and compare checksum of compressed data and header with written value
    if (Block->Header.Compressed.Checksum != 0) {
        ULONG Checksum;
        Checksum = HbSimpleCheck (0, Buffer, AlignedCompressedSize + XPRESS_HEADER_SIZE);
        if (((Checksum ^ Block->Header.Compressed.Checksum) & 0xffff) != 0) {
            DBGOUT (("Compressed data checksum mismatch (got %08lx, written %08lx)\n", Checksum, Block->Header.Compressed.Checksum));
            return(FALSE);
        }
    }

    // Was this buffer compressed at all?
    if (CompressedSize == UncompressedSize) {
        // Nope, do not decompress it -- set bounds and return OK
        Block->DataPtr = Buffer + XPRESS_HEADER_SIZE;
    } else {
        LONG DecodedSize;

        // Decompress the buffer
        DecodedSize = XpressDecode (NULL,
                                    Block->DataPtr,
                                    UncompressedSize,
                                    UncompressedSize,
                                    Buffer + XPRESS_HEADER_SIZE,
                                    CompressedSize);

        if (DecodedSize != UncompressedSize) {
            DBGOUT (("Decode error: DecodedSize = %d, UncompressedSize = %d\n", DecodedSize, UncompressedSize));
            return(FALSE);
        }
    }

#ifdef HIBER_DEBUG
    // evaluate and compare uncompressed data checksums (just to be sure)
    if (Block->Header.Uncompressed.Checksum != 0) {
        ULONG Checksum;
        Checksum = HbSimpleCheck (0, Block->DataPtr, UncompressedSize);
        if (((Checksum ^ Block->Header.Uncompressed.Checksum) & 0xffff) != 0) {
            DBGOUT (("Decoded data checksum mismatch (got %08lx, written %08lx)\n", Checksum, Block->Header.Uncompressed.Checksum));
            return(FALSE);
        }
    }
#endif /* HIBER_DEBUG */

    return(TRUE);
}


BOOLEAN
HbReadNextCompressedPageLZNT1 (
    PUCHAR DestVa,
    PCOMPRESSED_BUFFER CompressedBuffer
    )
/*++

Routine Description:

    This routine reads in the next compressed page from the
    Hiber file and decompresses it into a designated region
    of virtual memory.

    The page is recreated by assembling it from a series
    a compressed chunks that are assumed to be contiguously
    stored in the Hiber file.

    All reads from the Hiber file occurr at the file's
    current offset forcing compressed pages to be read
    in a continuous fashion without extraneous file seeks.

Arguments:

   DestVa         - The Virtual Address where the decompressed page should
                    be written.
   CompressedBuffer - Descriptor of data already brought in

Return Value:

   TRUE if the operation is successful, FALSE otherwise.

--*/
{
    ULONG ReadTotal;

    // Loop while page is incomplete

    for (ReadTotal = 0; ReadTotal < PAGE_SIZE; ReadTotal += PO_COMPRESS_CHUNK_SIZE) {

        // Get a chunk

        if (!HbReadNextCompressedChunkLZNT1(DestVa, CompressedBuffer)) {
            return FALSE;
        }

        // Move on to the next chunk of the page

        DestVa += PO_COMPRESS_CHUNK_SIZE;
    }

    return TRUE;
}

BOOLEAN
HbReadNextCompressedChunkLZNT1 (
    PUCHAR DestVa,
    PCOMPRESSED_BUFFER CompressedBuffer
    )
/*++

Routine Description:

   Reads and decompresses the next compressed chunk from the Hiber file
   and stores it in a designated region of virtual memory.

   Since no master data structure exists within the Hiber file to identify
   the location of all of the compression chunks, this routine operates
   by reading sections of the Hiber file into a compression buffer
   and extracting chunks from that buffer.

   Chunks are extracted by determining if a chunk is completely present in the buffer
   using the RtlDescribeChunk API. If the chunk is not completely present,
   more of the Hiber file is read into the buffer until the chunk can
   be extracted.

   All reads from the Hiber file occurr at its current offset, forcing
   compressed chunks to be read in a continous fashion with no extraneous
   seeks.

Arguments:

   DestVa            - The virtual address where the decompressed chunk
                       should be written.

   CompressedBuffer  - Descriptor of data already brought in


Return Value:

   TRUE if a chunk has been succesfully extracted and decompressed, FALSE otherwise.

--*/
{
    PUCHAR Buffer;
    NTSTATUS Status;
    ULONG ChunkSize;
    PUCHAR ChunkBuffer;
    ULONG SpaceLeft;

    // Loop until we have accomplished our goal since we may need
    // several operations before a chunk is extracted

    while (1) {

        Buffer = CompressedBuffer->Current.Beg;

        // Check the first unextracted chunk in the buffer

        Status = RtlDescribeChunk(COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_STANDARD,
                                  &Buffer,
                                  CompressedBuffer->Current.End,
                                  &ChunkBuffer,
                                  &ChunkSize);

        switch (Status) {
            case STATUS_SUCCESS:

                // A complete and valid chunk is present in the buffer

                // Decompress the chunk into the proper region of virtual memory

                Status = RtlDecompressBuffer (COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_STANDARD,
                                              DestVa,
                                              PO_COMPRESS_CHUNK_SIZE,
                                              CompressedBuffer->Current.Beg,
                                              (LONG) (CompressedBuffer->Current.End - CompressedBuffer->Current.Beg),
                                              &ChunkSize);

                if ((!NT_SUCCESS(Status)) || (ChunkSize != PO_COMPRESS_CHUNK_SIZE)) {
                    // Decompression failed

                    return(FALSE);
                } else {
                    // Decompression succeeded, indicate that the chunk following
                    // this one is the next unextracted chunk in the buffer

                    CompressedBuffer->Current.Beg = Buffer;
                    return(TRUE);
                }


            case STATUS_BAD_COMPRESSION_BUFFER:
            case STATUS_NO_MORE_ENTRIES:

                //
                // Buffer does not contain a complete and valid chunk
                //

                //
                // Check how much space remains in the buffer since
                // we will need to read some stuff from the Hiber file
                //

                SpaceLeft = (LONG) (CompressedBuffer->Aligned.End - CompressedBuffer->Aligned.Beg);
                if (SpaceLeft > LZNT1_COMPRESSION_BUFFER_SIZE) {
                    SpaceLeft = LZNT1_COMPRESSION_BUFFER_SIZE;
                }

                SpaceLeft -= (((LONG) (CompressedBuffer->Current.End - CompressedBuffer->Current.Beg)) + PAGE_MASK) & ~PAGE_MASK;
                if (SpaceLeft <= 0) {
                    // Should never happen
                    DBGOUT (("SpaceLeft = %d\n", SpaceLeft));
                    return(FALSE);
                }

                if (!HbReadNextCompressedPages (SpaceLeft, CompressedBuffer)) {
                    // IO error
                    return(FALSE);
                }
                break;

            default:

                //
                // Unhandled RtlDescribeChunk return code - have they changed the function on us?
                //

                return(FALSE);
        }

        //
        // try again with the bigger buffer
        //

    }

    return FALSE;
}


VOID
HexDump (
    IN ULONG    indent,
    IN ULONG    va,
    IN ULONG    len,
    IN ULONG    width,
    IN PUCHAR   buf
    )
{
    UCHAR   s[80], t[80], lstr[200];
    PUCHAR  ps, pt;
    ULONG   i;
    UCHAR   Key;
    static  UCHAR rgHexDigit[] = "0123456789abcdef";

    if (HiberIoError) {
        HbPrint (TEXT("*** HiberIoError\n"));
        return ;
    }
    if (HiberOutOfRemap) {
        HbPrint (TEXT("*** HiberOutOfRemap\n"));
        return ;
    }


    i = 0;
    while (len) {
        ps = s;
        pt = t;

        ps[0] = '\0';
        pt[0] = '*';
        pt++;

        for (i=0; i < 16; i++) {
            ps[0] = ' ';
            ps[1] = ' ';
            ps[2] = ' ';

            if (len) {
                ps[0] = rgHexDigit[buf[0] >> 4];
                ps[1] = rgHexDigit[buf[0] & 0xf];
                pt[0] = buf[0] < ' ' || buf[0] > 'z' ? '.' : buf[0];

                len -= 1;
                buf += 1;
                pt  += 1;
            }
            ps += 3;
        }

        ps[0] = 0;
        pt[0] = '*';
        pt[1] = 0;
        s[23] = '-';

        if (s[0]) {
            sprintf (lstr, "%*s%08lx: %s  %s\r\n", indent, "", va, s, t);
#ifdef UNICODE
            {
                WCHAR lstrW[200];
                ANSI_STRING aString;
                UNICODE_STRING uString;
                
                RtlInitString( &aString, lstr );
                uString.Buffer = lstrW;
                uString.MaximumLength = sizeof(lstrW);
                RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );

                HbPrint(lstrW);
            }
#else
            HbPrint (lstr);
#endif
            va += 16;
        }
    }

    ArcRead(ARC_CONSOLE_INPUT, &Key, sizeof(Key), &i);
}



BOOLEAN
HbReadDelayedBlock (
    BOOLEAN ForceDecoding,
    PFN_NUMBER DestPage,
    ULONG RangeCheck,
    PDECOMPRESSED_BLOCK Block,
    PCOMPRESSED_BUFFER CompressedBuffer
    )
{
    LONG i, j;
    BOOLEAN Contig;
    BOOLEAN Ret;

    if (ForceDecoding) {
        if (Block->DelayedCnt == 0) {
            return TRUE;
        }
    } else {
        // If first page to delay read next block info
        if (Block->DelayedCnt <= 0) {
            Ret = HbReadNextCompressedBlockHeader (Block, CompressedBuffer);

            if (HiberIoError || !Ret || !Block->Header.XpressEncoded) {
                // Something is wrong
                return FALSE;
            }
        }

        // remember page info
        Block->Delayed[Block->DelayedCnt].DestPage = DestPage;
        Block->Delayed[Block->DelayedCnt].RangeCheck = RangeCheck;

        // Update counter
        Block->DelayedCnt += 1;

        // Last page that may be delayed?
        if (Block->DelayedCnt != sizeof (Block->Delayed) / sizeof (Block->Delayed[0]) &&
            (Block->DelayedCnt << PAGE_SHIFT) < Block->Header.Uncompressed.Size) {
            // Nope, nothing to do
            return TRUE;
        }
    }

    // Make sure that size of encoded block and # of delayed pages are the same
    if ((Block->DelayedCnt << PAGE_SHIFT) != Block->Header.Uncompressed.Size) {
        DBGOUT (("DelayedCnt = %d, UncompressedSize = %d\n", Block->DelayedCnt, Block->Header.Uncompressed.Size));
        return FALSE;
    }

    // Prepare for mapping. Hopefully mapping will be contiguous
    Contig = TRUE;

    // Map new pages
    for (j = 0; j < Block->DelayedCnt; ++j) {
        i = HbPageDisposition (Block->Delayed[j].DestPage);
        if (i == HbPageInvalid) {
            // Should never happen
            return(FALSE);
        }
        if (i == HbPageNotInUse) {
            Block->Delayed[j].DestVa = HbMapPte(PTE_XPRESS_DEST_FIRST + j, Block->Delayed[j].DestPage);
        } else {
            Block->Delayed[j].DestVa = HbNextSharedPage(PTE_XPRESS_DEST_FIRST + j, Block->Delayed[j].DestPage);
        }
        if (j > 0 && Block->Delayed[j].DestVa != Block->Delayed[j-1].DestVa + PAGE_SIZE) {
            Contig = FALSE;
        }
    }

    // Set pointer to data. Try mapped pages if possible
    if (Contig) {
        Block->DataSize = Block->DelayedCnt << PAGE_SHIFT;
        Block->DataPtr = Block->Delayed[0].DestVa;
    } else {
        // Will have to used preallocated data buffer
        Block->DataSize = Block->Header.Uncompressed.Size;
        Block->DataPtr = Block->PreallocatedDataBuffer;
    }

    // Decode next block
    Ret = HbReadNextCompressedBlock (Block, CompressedBuffer);

    // Check for errors
    if (HiberIoError || !Ret) {
        // Something's seriousely wrong
        return FALSE;
    }

    for (j = 0; j < Block->DelayedCnt; ++j) {

        // Copy block to target address if necessary
        if (Block->Delayed[j].DestVa != Block->DataPtr) {
            RtlCopyMemory (Block->Delayed[j].DestVa, Block->DataPtr, PAGE_SIZE);
        }

        Block->DataPtr += PAGE_SIZE;
        Block->DataSize -= PAGE_SIZE;
    }

    // No more delayed blocks
    Block->DelayedCnt = 0;

    return TRUE;
}


// Allocate data aligned on page boundary
PVOID
HbAllocateAlignedHeap (
    ULONG Size
    )
{
    PCHAR Va;
    Va = BlAllocateHeap (Size + PAGE_MASK);
    if (Va != NULL) {
        Va += ((PAGE_SIZE - (((ULONG_PTR) Va) & PAGE_MASK)) & PAGE_MASK);
    }
    return (Va);
}


ULONG
HbRestoreFile (
    IN PULONG       Information,
    OUT PCHAR       *BadLinkName
    )
{
    PPO_MEMORY_IMAGE        MemImage;
    PPO_IMAGE_LINK          ImageLink;
    PPO_MEMORY_RANGE_ARRAY  Table;
    PHIBER_WAKE_DISPATCH    WakeDispatch;
    ULONG                   Length;
    ULONG                   Check;
    ULONG                   Count;
    PUCHAR                  p1;
    PUCHAR                  DestVa;
    ULONG                   Index, i;
    PFN_NUMBER              TablePage;
    PFN_NUMBER              DestPage;
    PFN_NUMBER              Scale;
    ULONG                   TotalPages;
    ULONG                   LastBar;
    ULONG                   Sel[4];
    ULONG                   LinkedDrive;
    COMPRESSED_BUFFER       CompressedBufferData;
    PCOMPRESSED_BUFFER      CompressedBuffer = &CompressedBufferData;
    BOOLEAN                 Ret;
    LONG                    XpressEncoded;
    PDECOMPRESSED_BLOCK     Block;
    PUCHAR                  msg;
    ULONG                   fPercentage = 0;
    ULONG                   LastPercentage = (ULONG)-1;
    PUCHAR                  Ptr;
    ARC_STATUS              Status;
    ULONG                   ActualBase;

#if HIBER_PERF_STATS

    ULONG StartTime, EndTime;
    StartTime = ArcGetRelativeTime();

#endif


#if defined (HIBER_DEBUG)
    HbPrint(TEXT("HbRestoreFile\r\n"));
#endif

    *Information = 0;
    HiberBufferPage = 0;
    BlAllocateAlignedDescriptor (LoaderFirmwareTemporary,
                                 0,
                                 1,
                                 1,
                                 &HiberBufferPage);

    CHECK_ERROR (!HiberBufferPage, HIBER_ERROR_NO_MEMORY);
    HiberBuffer = (PUCHAR) (KSEG0_BASE | (((ULONG)HiberBufferPage) << PAGE_SHIFT));


    //
    // Read image header
    //

    HbReadPage (PO_IMAGE_HEADER_PAGE, HiberBuffer);
    MemImage = (PPO_MEMORY_IMAGE) HiberBuffer;

    //
    // If the signature is a link, then follow it
    //

    if (MemImage->Signature == PO_IMAGE_SIGNATURE_LINK) {

        ImageLink = (PPO_IMAGE_LINK) HiberBuffer;

        //
        // Open target partition, and then the hiberfile image on that
        // partition.  If not found, then we're done
        //

        Status = ArcOpen ((char*)ImageLink->Name, ArcOpenReadOnly, &LinkedDrive);
        if (Status != ESUCCESS) {
            if (ARGUMENT_PRESENT(BadLinkName)) {
                *BadLinkName = (char *)(&ImageLink->Name);

                //
                // At this point we want to blast the link signature. The caller
                // may need to load NTBOOTDD to access the real hiberfile. Once
                // this happens there is no turning back as we cannot go back to
                // the BIOS to reread BOOT.INI. By zeroing the signature we ensure
                // that if the restore fails, the next boot will not try to restore
                // it again.
                //
                HbSetImageSignature(0);
            }
            return 0;
        }

        Status = BlOpen (LinkedDrive, szHiberFileName, ArcOpenReadWrite, &i);
        if (Status != ESUCCESS) {
            ArcClose(LinkedDrive);
            return 0;
        }

        //
        // Switch to linked HiberFile image and continue
        //

        BlClose (HiberFile);
        HiberFile = i;
        HbReadPage (PO_IMAGE_HEADER_PAGE, HiberBuffer);
    }


    //
    // If the image has the wake signature, then we've already attempted
    // to restart this image once.  Check if it should be attempted again
    //

    if (MemImage->Signature == PO_IMAGE_SIGNATURE_WAKE) {
        Sel[0] = HIBER_CANCEL;
        Sel[1] = HIBER_CONTINUE;
        Sel[2] = HIBER_DEBUG_BREAK_ON_WAKE;
        Sel[3] = 0;
        HbScreen(HIBER_RESTART_AGAIN);
        i = HbSelection(PAUSE_X, PAUSE_Y, Sel, 1);
        if (i == 0) {
            HiberAbort = TRUE;
            HbSetImageSignature (0);
            return 0;
        }

        MemImage->Signature = PO_IMAGE_SIGNATURE;
    }

    //
    // If the signature is not valid, then behave as if there's no
    // hibernated context
    //

    if (MemImage->Signature != PO_IMAGE_SIGNATURE) {
        return 0;
    }
    CHECK_ERROR (MemImage->LengthSelf > PAGE_SIZE, HIBER_ERROR_BAD_IMAGE);

    //
    // Copy the image out of the HiberBuffer
    //

    Length = MemImage->LengthSelf;
    MemImage = BlAllocateHeap(Length);
    CHECK_ERROR (!MemImage, HIBER_ERROR_NO_MEMORY);
    memcpy (MemImage, HiberBuffer, Length);
    HiberImageFeatureFlags = MemImage->FeatureFlags;

    //
    // Verify the checksum on the image header
    //

    Check = MemImage->CheckSum;
    MemImage->CheckSum = 0;
    Check = Check - HbSimpleCheck(0, MemImage, Length);
    CHECK_ERROR (Check, HIBER_ERROR_BAD_IMAGE);
    CHECK_ERROR (MemImage->Version  != 0, HIBER_IMAGE_INCOMPATIBLE);
    CHECK_ERROR (MemImage->PageSize != PAGE_SIZE, HIBER_IMAGE_INCOMPATIBLE);

    //
    // Setup mapping information for restore
    //

#if !defined (_ALPHA_) || defined(_IA64_)
    CHECK_ERROR (MemImage->NoHiberPtes > HIBER_PTES, HIBER_IMAGE_INCOMPATIBLE);
#endif

    HiberNoMappings = MemImage->NoFreePages;

#if defined (_ALPHA_) || defined(_IA64_)

    HiberImagePageSelf = MemImage->PageSelf;    // used in WakeDispatch to enable break-on-wake

#else

    HiberIdentityVa  = (PVOID) MemImage->HiberVa;
    HiberImagePageSelf = MemImage->PageSelf;

    //
    // Allocate a block of PTEs for restoration work which
    // do not overlap the same addresses needed for the
    // restoration
    //

    while (!HiberVa  ||  (MemImage->HiberVa >= (ULONG_PTR) HiberVa &&  MemImage->HiberVa <= (ULONG_PTR) p1)) {
        HbAllocatePtes (HIBER_PTES, &HiberPtes, &HiberVa);
        p1 = HiberVa + (HIBER_PTES << PAGE_SHIFT);
    }

#endif

    //
    // Read in the free page map
    //

    HbReadPage (PO_FREE_MAP_PAGE, HiberBuffer);
    Check = HbSimpleCheck(0, HiberBuffer, PAGE_SIZE);
    CHECK_ERROR (MemImage->FreeMapCheck != Check, HIBER_ERROR_BAD_IMAGE);

    // Set us up to decompress the contents of the hiber file


    // Allocate a buffer for compression work

    //
    // N.B. The compression buffer size must be at least the maximum
    //      compressed size of a single compression chunk.
    //

    // Initialize decompressed data buffer
    Ptr = HbAllocateAlignedHeap (sizeof (*Block) + XPRESS_MAX_SIZE);
    CHECK_ERROR(!Ptr, HIBER_ERROR_NO_MEMORY);
    Block = (PVOID) (Ptr + XPRESS_MAX_SIZE);
    Block->DataSize = 0;
    Block->PreallocatedDataBuffer = Ptr;

    //
    // Allocate compressed data buffer. Change the allocation policy
    // to lowest first in order to get a buffer under 1MB. This saves
    // us from double-buffering all the BIOS transfers.
    //
    Status = BlAllocateAlignedDescriptor(LoaderFirmwareTemporary,
                                         0,
                                         MAX_COMPRESSION_BUFFER_PAGES + MAX_COMPRESSION_BUFFER_EXTRA_PAGES,
                                         0x10000 >> PAGE_SHIFT,
                                         &ActualBase);
    if (Status == ESUCCESS) {
        Ptr = (PVOID)(KSEG0_BASE | (ActualBase  << PAGE_SHIFT));
    } else {
        Ptr = HbAllocateAlignedHeap (MAX_COMPRESSION_BUFFER_SIZE + MAX_COMPRESSION_BUFFER_EXTRA_SIZE);
    }
    CHECK_ERROR(!Ptr, HIBER_ERROR_NO_MEMORY);

    // Initialize compressed data buffer
    CompressedBuffer->Buffer.Beg = Ptr;
    CompressedBuffer->Buffer.End = Ptr + MAX_COMPRESSION_BUFFER_SIZE + MAX_COMPRESSION_BUFFER_EXTRA_SIZE;

    CompressedBuffer->Aligned.Beg = CompressedBuffer->Buffer.Beg;
    CompressedBuffer->Aligned.End = CompressedBuffer->Buffer.End;

    CompressedBuffer->FilePage = 0;
    CompressedBuffer->NeedSeek = TRUE;
    CompressedBuffer->Current.Beg = CompressedBuffer->Current.End = CompressedBuffer->Aligned.Beg;


    // ***************************************************************
    //
    // From here on, there's no memory allocation from the loaders
    // heap.  This is to simplify the booking of whom owns which
    // page.  If the hibernation process is aborted, then the
    // pages used here are simply forgoten and the loader continues.
    // If the hiberation processor completes, we forget about
    // the pages in use by the loader
    //
    // ***************************************************************

#if defined(_ALPHA_) || defined(_IA64_)

    //
    // Initialize the hibernation memory allocation and remap table,
    // using the free page map just read from the hibernation file.
    //

    HbInitRemap((PPFN_NUMBER) HiberBuffer);  // why can't HiberBuffer be a PVOID?

#else   // original (x86) code

    //
    // Set the loader map pointer to the tempory buffer, and get
    // a physical shared page to copy the map to.
    //

    HbMapPte(PTE_MAP_PAGE, HiberBufferPage);
    HbMapPte(PTE_REMAP_PAGE, HiberBufferPage);
    DestVa = HbNextSharedPage(PTE_MAP_PAGE, 0);
    memcpy (DestVa, HiberBuffer, PAGE_SIZE);
    DestVa = HbNextSharedPage(PTE_REMAP_PAGE, 0);

#endif  // Alpha/x86

    //
    // Map in and copy relocatable hiber wake dispatcher
    //

    Length = (ULONG) (&WakeDispatcherEnd - &WakeDispatcherStart);
    p1 = (PUCHAR) &WakeDispatcherStart;
    Index = 0;
    while (Length) {
        CHECK_ERROR(PTE_DISPATCHER_START+Index > PTE_DISPATCHER_END, HIBER_INTERNAL_ERROR);
        DestVa = HbNextSharedPage(PTE_DISPATCHER_START+Index, 0);
        if (Index == 0) {
            WakeDispatch = (PHIBER_WAKE_DISPATCH) DestVa;
        }

        i = Length > PAGE_SIZE ? PAGE_SIZE : Length;
        memcpy (DestVa, p1, i);
        Length -= i;
        p1 += i;
        Index += 1;
    }


    //
    // Read the hibernated processors context
    //
    // Note we read into the hiber buffer and then copy in order to
    // ensure that the destination of the I/O is legal to transfer into.
    // Busmaster ISA SCSI cards can only access the low 16MB of RAM.
    //

    DestVa = HbNextSharedPage(PTE_HIBER_CONTEXT, 0);
    HbReadPage (PO_PROCESSOR_CONTEXT_PAGE, HiberBuffer);
    memcpy(DestVa, HiberBuffer, PAGE_SIZE);
    Check = HbSimpleCheck(0, DestVa, PAGE_SIZE);
    CHECK_ERROR(MemImage->WakeCheck != Check, HIBER_ERROR_BAD_IMAGE);
#if defined(_ALPHA_)
    HiberWakeState = (PKPROCESSOR_STATE)DestVa;
#endif
    //
    // Perform architecture specific setup for dispatcher, then set
    // the location of first remap past the pages mapped so far
    //

    HiberSetupForWakeDispatch ();
    HiberFirstRemap = HiberLastRemap;

    //
    // Restore memory from hibernation image
    //

    TablePage = MemImage->FirstTablePage;
    Table = (PPO_MEMORY_RANGE_ARRAY) HiberBuffer;

    Scale = MemImage->TotalPages / PERCENT_BAR_WIDTH;
    LastBar = 0;
    TotalPages = 3;

    //
    // Popup "Resuming Windows 2000..." message
    //
    BlSetProgBarCharacteristics(HIBER_UI_BAR_ELEMENT, BLDR_UI_BAR_BACKGROUND);
    BlOutputStartupMsg(BL_MSG_RESUMING_WINDOWS);
    BlOutputTrailerMsg(BL_ADVANCED_BOOT_MESSAGE);

    XpressEncoded = -1;     // unknown encoding (either Xpress or LZNT1)
    Block->DataSize = 0;    // no data left in buffer
    Block->DelayedCnt = 0;  // no delayed blocks
    Block->DelayedChecksum = 0; // delayed checksum = 0;
    Block->DelayedBadChecksum = FALSE;

    while (TablePage) {

#if defined (HIBER_DEBUG) && (HIBER_DEBUG & 2)
        SHOWNUM(TablePage);
#endif
        //
        // Do not use HbReadPage if possible -- it issues extra seek
        // (usually 5-6 ms penalty) -- use sequential read if possible
        //
        if (CompressedBuffer->FilePage == 0 ||
            TablePage > CompressedBuffer->FilePage ||
            TablePage < CompressedBuffer->FilePage - (PFN_NUMBER) ((CompressedBuffer->Current.End - CompressedBuffer->Current.Beg) >> PAGE_SHIFT)) {
            //
            // Cannot read table page from current buffer -- need to seek
            // and reset the buffer (should happen on very first entry only)
            //

            CompressedBuffer->FilePage = TablePage;
            CompressedBuffer->Current.Beg = CompressedBuffer->Current.End = CompressedBuffer->Aligned.Beg;
            CompressedBuffer->NeedSeek = TRUE;
        }


        //
        // Shift current pointer to the page we need
        //
        CompressedBuffer->Current.Beg = CompressedBuffer->Current.End - ((CompressedBuffer->FilePage - TablePage) << PAGE_SHIFT);

        //
        // Make sure the page is in
        //
        Ret = HbReadNextCompressedPages (PAGE_SIZE, CompressedBuffer);

        CHECK_ERROR(HiberIoError, HIBER_READ_ERROR);
        CHECK_ERROR(!Ret, HIBER_ERROR_BAD_IMAGE);

        //
        // Copy table page to target location and adjust input pointer
        //
        RtlCopyMemory (Table, CompressedBuffer->Current.Beg, PAGE_SIZE);
        CompressedBuffer->Current.Beg += PAGE_SIZE;

        Check = Table[0].Link.CheckSum;
        if (Check) {
            Table[0].Link.CheckSum = 0;
            Check = Check - HbSimpleCheck(0, Table, PAGE_SIZE);
            CHECK_ERROR(Check, HIBER_ERROR_BAD_IMAGE);
        }

        // Check the first block magic to see whether it LZNT1 or Xpress
        if (XpressEncoded < 0) {
            Ret = HbReadNextCompressedBlockHeader (Block, CompressedBuffer);

            CHECK_ERROR(HiberIoError, HIBER_READ_ERROR);
            CHECK_ERROR(!Ret, HIBER_ERROR_BAD_IMAGE);

            // Remember the mode
            XpressEncoded = (BOOLEAN) (Block->Header.XpressEncoded);
        }

        for (Index=1; Index <= Table[0].Link.EntryCount; Index++) {
            Check = 0;
            DestPage = Table[Index].Range.StartPage;


            while (DestPage < Table[Index].Range.EndPage) {
                if (!XpressEncoded) {
                    // LZNT1 encoding -- do one page at a time

                    //
                    // If this page conflicts with something in the
                    // loader, then use the next mapping
                    //

                    i = HbPageDisposition (DestPage);
                    CHECK_ERROR(i == HbPageInvalid, HIBER_ERROR_BAD_IMAGE);
                    if (i == HbPageNotInUse) {
                        DestVa = HbMapPte(PTE_DEST, DestPage);
                    } else {
                        DestVa = HbNextSharedPage(PTE_DEST, DestPage);
                    }

                    Ret = HbReadNextCompressedPageLZNT1 (DestVa, CompressedBuffer);

                    CHECK_ERROR(HiberIoError, HIBER_READ_ERROR);
                    CHECK_ERROR(!Ret, HIBER_ERROR_BAD_IMAGE);
                    Check = HbSimpleCheck(Check, DestVa, PAGE_SIZE);
                } else {
                    Ret = HbReadDelayedBlock (FALSE,
                                              DestPage,
                                              Table[Index].Range.CheckSum,
                                              Block,
                                              CompressedBuffer);

                    CHECK_ERROR(HiberIoError, HIBER_READ_ERROR);
                    CHECK_ERROR(!Ret, HIBER_ERROR_BAD_IMAGE);
                }

                // Update counters
                DestPage += 1;
                TotalPages += 1;

                fPercentage = (ULONG)((TotalPages * 100) / MemImage->TotalPages);
                if (fPercentage != LastPercentage) {
                    BlUpdateProgressBar(fPercentage);
                    HbCheckForPause();
                    LastPercentage = fPercentage;
                }
            }

            CHECK_ERROR(HiberOutOfRemap, HIBER_ERROR_OUT_OF_REMAP);

            //
            // Verify checksum on range, but allow continuation with debug flag
            //

            if (!XpressEncoded && Check != Table[Index].Range.CheckSum) {
                Block->DelayedBadChecksum = TRUE;
            }

            if (Block->DelayedBadChecksum && !HiberBreakOnWake) {
                ChecksumError:

                Block->DelayedBadChecksum = FALSE;

#if defined (HIBER_DEBUG) && (HIBER_DEBUG & 2)

                {
                    TCHAR lstr[80];

                    HbPrint (TEXT("\r\n"));
                    _stprintf (lstr, 
                             TEXT("TP:%x  IDX:%x  FP:%x  SP:%x  EP:%x  CHK:%x-%x\r\n"),
                             TablePage,
                             Index,
                             Table[Index].Range.PageNo,
                             Table[Index].Range.StartPage,
                             Table[Index].Range.EndPage,
                             Table[Index].Range.CheckSum,
                             Check );
                    HbPrint(lstr);
                    HexDump (2, (DestPage-1) << PAGE_SHIFT, 0x100, 4, DestVa);
                }
#endif

#ifdef HIBER_DEBUG
                DBGOUT ((TEXT("Checksum error\n")));
                HbPause ();
#endif

                HbScreen(HIBER_ERROR);
                HbPrintMsg(HIBER_ERROR_BAD_IMAGE);
                Sel[0] = HIBER_CANCEL;
                Sel[1] = HIBER_DEBUG_BREAK_ON_WAKE;
                Sel[2] = 0;
                i = HbSelection (FAULT_X, FAULT_Y, Sel, 1);
                if (i == 0) {
                    HiberAbort = TRUE;
                    HbSetImageSignature (0);
                    return 0;
                }
            }
        }

        TablePage = Table[0].Link.NextTable;
    }

    // Process the rest of delayed pages if necessary
    if (XpressEncoded > 0) {
        Ret = HbReadDelayedBlock (TRUE,
                                  0,
                                  0,
                                  Block,
                                  CompressedBuffer);

        CHECK_ERROR(HiberIoError, HIBER_READ_ERROR);
        CHECK_ERROR(!Ret, HIBER_ERROR_BAD_IMAGE);

        if (Block->DelayedBadChecksum) {
            goto ChecksumError;
        }
    }

    //
    // Set the image signature to wake
    //

    HbSetImageSignature (PO_IMAGE_SIGNATURE_WAKE);

#if HIBER_PERF_STATS

    EndTime = ArcGetRelativeTime();
    BlPositionCursor(BAR_X, BAR_Y + 5);
    HbPrint(TEXT("HIBER: Restore File took "));
    HbPrintNum(EndTime - StartTime);
    HbPrint(TEXT("\r\n"));
    HbPause();

#endif

    //
    // Check hiber flags to see if it is necessary to reconnect APM
    //
    if (MemImage->HiberFlags & PO_HIBER_APM_RECONNECT) {
        //
        // attempt apm restart
        //
        DoApmAttemptReconnect();
    }

    //
    // Use architecture specific relocatable code to perform the final wake dispatcher
    //

    WakeDispatch();
    CHECK_ERROR (TRUE, HIBER_INTERNAL_ERROR);
}

VOID
HbSetImageSignature (
    IN ULONG    NewSignature
    )
{
    LARGE_INTEGER   li;
    ULONG           Count, Status;

    li.QuadPart = 0;
    Status = BlSeek (HiberFile, &li, SeekAbsolute);
    if (Status == ESUCCESS) {
        BlWrite (HiberFile, &NewSignature, sizeof(ULONG), &Count);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\diagload.h ===
//
//      Diagnostic loader messages.
//
//
// Defines for Class, Detail and Action are used to lookup
// text from DiagLoadClass, DiagLoadDetail and DiagLoadAction
// respectively.  One must change LOAD_CL_END, DIAG_BL_END
// and LOAD_ACT_END to reflect any change in the content of
// the tables.  They are used for bounds checking to avoid
// access violations.

//
// Class Definitions
//

#define LOAD_SW_INT_ERR_CLASS          0x00000000L
#define LOAD_SW_MISRQD_FILE_CLASS      0x00000001L
#define LOAD_SW_BAD_FILE_CLASS         0x00000002L
#define LOAD_SW_MIS_FILE_CLASS         0x00000003L
#define LOAD_HW_MEM_CLASS              0x00000004L
#define LOAD_HW_DISK_CLASS             0x00000005L
#define LOAD_HW_GEN_ERR_CLASS          0x00000006L
#define LOAD_HW_FW_CFG_CLASS           0x00000007L
#define LAOD_SW_MISMATCHED_KERNEL      0x00000008L
#define LOAD_CL_END                    0x00000009L


//
// Class Declarations
//

static PCHAR DiagLoadClass[] = {

"Windows 2000 could not start because of an error in the software.\r\nPlease report this problem as :\r\n\0",
"Windows 2000 could not start because the following file was not found\r\nand is required :\r\n\0",
"Windows 2000 could not start because of a bad copy of the following file :\r\n\0",
"Windows 2000 could not start because the following file is missing or corrupt:\r\n\0",
"Windows 2000 could not start because of a hardware memory configuration\r\nproblem.\r\n\0",
"Windows 2000 could not start because of a computer disk hardware\r\nconfiguration problem.\r\n\0",
"Windows 2000 could not start because of a general computer hardware\r\nconfiguration problem.\r\n\0",
"Windows 2000 could not start because of the following ARC firmware\r\nboot configuration problem :\r\n\0",
"Windows 2000 could not start because the specified kernel does not exist or\r\nis not compatible with this processor.\r\n\0"
};

//
// Detail Definitions
//

#define DIAG_BL_MEMORY_INIT            0L
#define DIAG_BL_CONFIG_INIT            1L
#define DIAG_BL_IO_INIT                2L
#define DIAG_BL_FW_GET_BOOT_DEVICE     3L
#define DIAG_BL_OPEN_BOOT_DEVICE       4L
#define DIAG_BL_FW_GET_SYSTEM_DEVICE   5L
#define DIAG_BL_FW_OPEN_SYSTEM_DEVICE  6L
#define DIAG_BL_GET_SYSTEM_PATH        7L
#define DIAG_BL_LOAD_SYSTEM_IMAGE      8L
#define DIAG_BL_FIND_HAL_IMAGE         9L
#define DIAG_BL_LOAD_HAL_IMAGE         10L
#define DIAG_BL_LOAD_SYSTEM_IMAGE_DATA 11L
#define DIAG_BL_LOAD_HAL_IMAGE_DATA    12L
#define DIAG_BL_LOAD_SYSTEM_DLLS       13L
#define DIAG_BL_LOAD_HAL_DLLS          14L
#define DIAG_BL_READ_SYSTEM_REGISTRY   15L
#define DIAG_BL_LOAD_SYSTEM_REGISTRY   16L
#define DIAG_BL_FIND_SYSTEM_DRIVERS    17L
#define DIAG_BL_READ_SYSTEM_DRIVERS    18L
#define DIAG_BL_LOAD_DEVICE_DRIVER     19L
#define DIAG_BL_LOAD_SYSTEM_HIVE       20L
#define DIAG_BL_SYSTEM_PART_DEV_NAME   21L
#define DIAG_BL_BOOT_PART_DEV_NAME     22L
#define DIAG_BL_ARC_BOOT_DEV_NAME      23L
#define DIAG_BL_ARC_HAL_NAME           24L
#define DIAG_BL_SETUP_FOR_NT           25L
#define DIAG_BL_KERNEL_INIT_XFER       26L
#define DIAG_BL_END                    27L

//
// Detail Declarations
//

static PCHAR DiagLoadDetail[] = {

// DIAG_BL_MEMORY_INIT            0L
"Check hardware memory configuration and amount of RAM.\r\n\0",

// DIAG_BL_CONFIG_INIT            1L
"Too many configuration entries.\r\n\0",

// DIAG_BL_IO_INIT                2L
"Could not access disk partition tables \r\n\0",

// DIAG_BL_FW_GET_BOOT_DEVICE     3L
"The 'osloadpartition' parameter setting is invalid.\r\n\0",

// DIAG_BL_OPEN_BOOT_DEVICE       4L
"Could not read from the selected boot disk.  Check boot path\r\nand disk hardware.\r\n\0",

// DIAG_BL_FW_GET_SYSTEM_DEVICE   5L
"The 'systempartition' parameter setting is invalid.\r\n\0",

// DIAG_BL_FW_OPEN_SYSTEM_DEVICE  6L
"Could not read from the selected system boot disk.\r\nCheck 'systempartition' path.\r\n\0",

// DIAG_BL_GET_SYSTEM_PATH        7L
"The 'osloadfilename' parameter does not point to a valid file.\r\n\0",

// DIAG_BL_LOAD_SYSTEM_IMAGE      8L
"<windows 2000 root>\\system32\\ntoskrnl.exe.\r\n\0",

// DIAG_BL_FIND_HAL_IMAGE         9L
"The 'osloader' parameter does not point to a valid file.\r\n\0",

// DIAG_BL_LOAD_HAL_IMAGE         10L
#if defined(i386)
"<windows 2000 root>\\system32\\hal.dll.\r\n\0",
#endif

#if defined(MIPS)
"'osloader'\\hal.dll\r\n\0",
#endif

// DIAG_BL_LOAD_SYSTEM_IMAGE_DATA 11L
"Loader error 1.\r\n\0",

// DIAG_BL_LOAD_HAL_IMAGE_DATA    12L
"Loader error 2.\r\n\0",

// DIAG_BL_LOAD_SYSTEM_DLLS       13L
"load needed DLLs for kernel.\r\n\0",

// DIAG_BL_LOAD_HAL_DLLS          14L
"load needed DLLs for HAL.\r\n\0",

// DIAG_BL_READ_SYSTEM_REGISTRY   15L
"<windows 2000 root>\\system32\\config\\system. \r\n\0",

// DIAG_BL_LOAD_SYSTEM_REGISTRY   16L
"<windows 2000 root>\\system32\\config\\system. \r\n\0",

// DIAG_BL_FIND_SYSTEM_DRIVERS    17L
"find system drivers.\r\n\0",

// DIAG_BL_READ_SYSTEM_DRIVERS    18L
"read system drivers.\r\n\0",

// DIAG_BL_LOAD_DEVICE_DRIVER     19L
"did not load system boot device driver.\r\n\0",

// DIAG_BL_LOAD_SYSTEM_HIVE       20L
"load system hardware configuration file.\r\n\0",

// DIAG_BL_SYSTEM_PART_DEV_NAME   21L
"find system partition name device name.\r\n\0",

// DIAG_BL_BOOT_PART_DEV_NAME     22L
"find boot partition name.\r\n\0",

// DIAG_BL_ARC_BOOT_DEV_NAME      23L
"did not properly generate ARC name for HAL and system paths.\r\n\0",

// DIAG_BL_ARC_HAL_NAME           24L
"did not properly generate ARC name for HAL and system paths.\r\n\0",

// DIAG_BL_SETUP_FOR_NT           25L
"Loader error 3.\r\n\0",

// DIAG_BL_KERNEL_INIT_XFER       26L
"<windows 2000 root>\\system32\\ntoskrnl.exe\r\n\0"

};


//
// Action Definitions
//

#define LOAD_SW_INT_ERR_ACT            0x00000000L
#define LOAD_SW_FILE_REST_ACT          0x00000001L
#define LOAD_SW_FILE_REINST_ACT        0x00000002L
#define LOAD_HW_MEM_ACT                0x00000003L
#define LOAD_HW_DISK_ACT               0x00000004L
#define LOAD_HW_GEN_ACT                0x00000005L
#define LOAD_HW_FW_CFG_ACT             0x00000006L
#define LOAD_ACT_END                   0x00000007L


//
// Action Declarations
//

static PCHAR DiagLoadAction[] = {

"Please contact your support person to report this problem.\r\n\0",
"You can attempt to repair this file by starting Windows 2000\r\n"
"Setup using the original Setup floppy disk or CD-ROM.\r\n"
"Select 'r' at the first screen to start repair.\r\n\0",
"Please re-install a copy of the above file.\r\n\0",
"Please check the Windows 2000(TM) documentation about hardware\r\nmemory requirements and your hardware reference manuals for\r\nadditional information.\r\n\0",
"Please check the Windows 2000(TM) documentation about hardware\r\ndisk configuration and your hardware reference manuals for\r\nadditional information.\r\n\0",
"Please check the Windows 2000(TM) documentation about hardware\r\nconfiguration and your hardware reference manuals for additional\r\ninformation.\r\n\0",
"Please check the Windows 2000(TM) documentation about ARC configuration\r\noptions and your hardware reference manuals for additional\r\ninformation.\r\n\0"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\bootstat.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    bootstat.c

Abstract:

    Manipulates the boot status data file.

Author:

    Peter Wieland (peterwie)    01-18-01

Revision History:

--*/

#include "bldr.h"
#include "bootstatus.h"

#include <stdio.h>

#define FIELD_SIZE(type, field)  sizeof(((type *)0)->field)
#define FIELD_OFFSET_AND_SIZE(n)   {FIELD_OFFSET(BSD_BOOT_STATUS_DATA, n), FIELD_SIZE(BSD_BOOT_STATUS_DATA, n)}

VOID
BlAutoAdvancedBoot(
    IN OUT PCHAR *LoadOptions, 
    IN BSD_LAST_BOOT_STATUS LastBootStatus,
    IN ULONG AdvancedBootMode
    )
{
    UCHAR bootStatusString[32];
    PUCHAR advancedBootString = NULL;

    ULONG newLoadOptionsLength;
    PUCHAR newLoadOptions;

    //
    // Write the last boot status into a string.
    //

    sprintf(bootStatusString, "LastBootStatus=%d", LastBootStatus);

    //
    // Based on the advanced boot mode indicated by the caller, adjust the 
    // boot options.
    //

    if (AdvancedBootMode != -1) {
        advancedBootString = BlGetAdvancedBootLoadOptions(AdvancedBootMode);
    }

    //
    // Determine the length of the new load options string.
    //

    newLoadOptionsLength = strlen(bootStatusString) + 1;

    if(*LoadOptions != NULL) {
        newLoadOptionsLength += strlen(*LoadOptions) + 1;
    }

    if(advancedBootString) {
        newLoadOptionsLength += strlen(advancedBootString) + 1;
    }

    newLoadOptions = BlAllocateHeap(newLoadOptionsLength * sizeof(UCHAR));

    if(newLoadOptions == NULL) {
        return;
    }

    //
    // Concatenate all the strings together.
    //

    sprintf(newLoadOptions, "%s %s %s",
            ((*LoadOptions != NULL) ? *LoadOptions : ""),
            ((advancedBootString != NULL) ? advancedBootString : ""),
            bootStatusString);

    if(AdvancedBootMode != -1) {
        BlDoAdvancedBootLoadProcessing(AdvancedBootMode);
    }

    *LoadOptions = newLoadOptions;

    return;
}

ARC_STATUS
BlGetSetBootStatusData(
    IN PVOID DataHandle,
    IN BOOLEAN Get,
    IN RTL_BSD_ITEM_TYPE DataItem,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLength,
    OUT PULONG BytesReturned OPTIONAL
    )
{
    ULONG fileId = (ULONG) ((ULONG_PTR) DataHandle);

    struct {
        ULONG FieldOffset;
        ULONG FieldLength;
    } bootStatusFields[] = {
        FIELD_OFFSET_AND_SIZE(Version),
        FIELD_OFFSET_AND_SIZE(ProductType),
        FIELD_OFFSET_AND_SIZE(AutoAdvancedBoot),
        FIELD_OFFSET_AND_SIZE(AdvancedBootMenuTimeout),
        FIELD_OFFSET_AND_SIZE(LastBootSucceeded),
        FIELD_OFFSET_AND_SIZE(LastBootShutdown)
    };

    ULONG dataFileVersion;

    LARGE_INTEGER fileOffset;
    ULONG itemLength;

    ULONG bytesRead;

    ARC_STATUS status;

    ASSERT(RtlBsdItemMax == (sizeof(bootStatusFields) / sizeof(bootStatusFields[0])));

    //
    // Read the version number out of the data file.
    //

    fileOffset.QuadPart = 0;

    status = BlSeek(fileId, &fileOffset, SeekAbsolute);

    if(status != ESUCCESS) {
        return status;
    }

    status = BlRead(fileId,
                    &dataFileVersion,
                    sizeof(ULONG),
                    &bytesRead);

    if(status != ESUCCESS) {
        return status;
    }

    //
    // If the data item requsted isn't one we have code to handle then 
    // return invalid parameter.
    //

    if(DataItem >= (sizeof(bootStatusFields) / sizeof(bootStatusFields[0]))) {
        return EINVAL;
    }

    fileOffset.QuadPart = bootStatusFields[DataItem].FieldOffset;
    itemLength = bootStatusFields[DataItem].FieldLength;

    //
    // If the data item offset is beyond the end of the file then return a 
    // versioning error.
    //

    if((fileOffset.QuadPart + itemLength) > dataFileVersion) {
        return STATUS_REVISION_MISMATCH;
    }

    if(DataBufferLength < itemLength) { 
        DataBufferLength = itemLength;
        return EINVAL;
    }

    status = BlSeek(fileId, &fileOffset, SeekAbsolute);

    if(status != ESUCCESS) {
        return status;
    }

    if(Get) {
        status = BlRead(fileId, 
                        DataBuffer,
                        itemLength,
                        &bytesRead);

    } else {
        status = BlWrite(fileId,
                         DataBuffer,
                         itemLength,
                         &bytesRead);
    }

    if((status == ESUCCESS) && ARGUMENT_PRESENT(BytesReturned)) {
        *BytesReturned = bytesRead;
    }

    return status;
}

ARC_STATUS
BlLockBootStatusData(
    IN ULONG SystemPartitionId,
    IN PCHAR SystemPartition,
    IN PCHAR SystemDirectory,
    OUT PVOID *DataHandle
    )
/*++

Routine Description:

    This routine opens the boot status data file.
    
Arguments:

    SystemPartitionId - if non-zero this is the arc file id of the system 
                        partition.  This will be used to locate the system 
                        directory instead of the system partition name (below).
    
    SystemPartition - the arc name of the system partition.  Ignored if 
                      SystemPartitionId is non-zero.
    
    SystemDirectory - the name of the system directory.

    DataHandle - returns a handle to the boot status data.
    
Return Value:

    ESUCCESS if the status data could be locked, or error indicating why not.
    
--*/
{
    ULONG driveId;

    UCHAR filePath[100];
    ULONG fileId;

    ARC_STATUS status;

    if(SystemPartitionId == 0) {

        //
        // Attempt to open the system partition
        //
    
        status = ArcOpen(SystemPartition, ArcOpenReadWrite, &driveId);
        
        if(status != ESUCCESS) {
            return status;
        }
    } else {
        driveId = SystemPartitionId;
    }

    //
    // Now attempt to open the file <SystemDirectory>\bootstat.dat
    //

    strcpy(filePath, SystemDirectory);
    strcat(filePath, BSD_FILE_NAME);

    status = BlOpen(driveId, filePath, ArcOpenReadWrite, &fileId);

    if(SystemPartitionId == 0) {
        //
        // Close the drive.
        //
    
        ArcClose(driveId);
    }

    //
    // The file doesn't exist so we don't know the state of the last boot.
    //

    if(status != ESUCCESS) {
        return status;
    }

    *DataHandle = (PVOID) ((ULONG_PTR) fileId);

    return ESUCCESS;
}


VOID
BlUnlockBootStatusData(
    IN PVOID DataHandle
    )
{
    ULONG fileId = (ULONG) ((ULONG_PTR) DataHandle);

    BlClose(fileId);
    return;
}

ULONG
BlGetLastBootStatus(
    IN PVOID DataHandle, 
    OUT BSD_LAST_BOOT_STATUS *LastBootStatus
    )
{
    UCHAR lastBootGood;
    UCHAR lastShutdownGood;
    UCHAR aabEnabled;

    ULONG advancedBootMode = -1;

    ARC_STATUS status;

    *LastBootStatus = BsdLastBootGood;

    //
    // The file contains a simple data structure so i can avoid parsing an 
    // INI file.  If this proves to be insufficient for policy management then 
    // we'll change it into an ini file.
    // 

    //
    // Read the last boot status.
    //

    status = BlGetSetBootStatusData(DataHandle,
                                    TRUE,
                                    RtlBsdItemBootGood,
                                    &lastBootGood,
                                    sizeof(UCHAR),
                                    NULL);

    if(status != ESUCCESS) {
        *LastBootStatus = BsdLastBootUnknown;
        return advancedBootMode;
    }

    status = BlGetSetBootStatusData(DataHandle,
                                    TRUE,
                                    RtlBsdItemBootShutdown,
                                    &lastShutdownGood,
                                    sizeof(UCHAR),
                                    NULL);

    if(status != ESUCCESS) {
        *LastBootStatus = BsdLastBootUnknown;
        return advancedBootMode;
    }

    status = BlGetSetBootStatusData(DataHandle,
                                    TRUE,
                                    RtlBsdItemAabEnabled,
                                    &aabEnabled,
                                    sizeof(UCHAR),
                                    NULL);

    if(status != ESUCCESS) {
        *LastBootStatus = BsdLastBootUnknown;
        return advancedBootMode;
    }

    //
    // If the system was shutdown cleanly then don't bother to check if the
    // boot was good.
    //

    if(lastShutdownGood) {
        return advancedBootMode;
    }

    //
    // Determine the last boot status & what action to take.
    //

    if(lastBootGood == FALSE) {

        //
        // Enable last known good.
        //

        advancedBootMode = 6;
        *LastBootStatus = BsdLastBootFailed;
    } else if(lastShutdownGood == FALSE) {

        //
        // Enable safe mode without networking.
        //

        advancedBootMode = 0;
        *LastBootStatus = BsdLastBootNotShutdown;
    }

    //
    // Now disable auto safemode actions if requested.
    //

    if(aabEnabled == FALSE) {
        advancedBootMode = -1;
    }

    return advancedBootMode;
}

VOID
BlWriteBootStatusFlags(
    IN ULONG SystemPartitionId,
    IN PUCHAR SystemDirectory,
    IN BOOLEAN LastBootSucceeded, 
    IN BOOLEAN LastBootShutdown
    )
{
    PVOID dataHandle;

    ARC_STATUS status;

    status = BlLockBootStatusData(SystemPartitionId,
                                  NULL,
                                  SystemDirectory,
                                  &dataHandle);

    if(status == ESUCCESS) {

        BlGetSetBootStatusData(dataHandle,
                               FALSE,
                               RtlBsdItemBootGood,
                               &LastBootSucceeded,
                               sizeof(UCHAR),
                               NULL);
    
        BlGetSetBootStatusData(dataHandle,
                               FALSE,
                               RtlBsdItemBootShutdown,
                               &LastBootShutdown,
                               sizeof(UCHAR),
                               NULL);

        BlUnlockBootStatusData(dataHandle);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\netboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    osloader.c

Abstract:

    This module contains the code that implements the NT operating system
    loader.

Author:

    David N. Cutler (davec) 10-May-1991

Revision History:

--*/

#include "bldr.h"
#include "haldtect.h"
#include "parseini.h"
#include "setupbat.h"
#include "ctype.h"
#include "stdio.h"
#include "string.h"
#include "msg.h"
#include <netboot.h>


#if defined(REMOTE_BOOT)


extern BOOLEAN NetFS_Cache;

UCHAR szRemoteBootCfgFile[] = "RemoteBoot.cfg";
CHAR KernelFileName[8+1+3+1]="ntoskrnl.exe";
CHAR HalFileName[8+1+3+1]="hal.dll";

VOID
BlWarnAboutFormat(
    IN BOOLEAN SecretValid,
    IN PUCHAR OsLoader
    );


ARC_STATUS
BlCheckMachineReplacement (
    IN PCHAR SystemDevice,
    IN ULONG SystemDeviceId,
    IN ULONGLONG NetRebootParameter,
    IN PUCHAR OsLoader
    )

/*++

Routine Description:

    This routine checks to see if a part of the machine has been replaced.  Specifically,
    it checks if:
        - Hal is different.
        - Physical Disk is different.

    If it finds either case, then it creates at SETUP_LOADER_BLOCK and sets the flags
    to pass to the kernel.

    Note: NetFS_Cache is a boolean which is used to turn on/off client side caching in the loader.
    When set to FALSE, the cache is turned off.

Arguments:

    SystemDevice - Character string of the ARC name of the system.

    SystemDeviceId - Handle to the server share where this machine account exists.

    NetRebootParameter - Any parameter that may have been passed during a soft reboot of the PC.

    OsLoader - TFTP path to osloader.exe

Return Value:

    Success or not.  Failure means to quit loading.

--*/

{
    ARC_DISK_SIGNATURE Signature;
    ARC_STATUS Status;
    BOOLEAN NetBootRequiresFormat = FALSE;
    BOOLEAN NetBootClientCacheStale = FALSE;
    BOOLEAN NetBootDisconnected = FALSE;
    BOOLEAN SkipHalCheck;
    ULONG FileId;
    ULONG CacheBootSerialNumber;
    ULONG CacheDiskSignature;
    ULONG ServerBootSerialNumber;
    ULONG ServerDiskSignature;
    UCHAR NetBootHalName[MAX_HAL_NAME_LENGTH + 1];
    PUCHAR NetBootDetectedHalName;
    UCHAR OutputBuffer[256];
    UCHAR DiskName[80];
    PUCHAR p;
    PUCHAR Guid;
    ULONG GuidLength;


    //
    // Detect which HAL we want to use.
    //
    NetBootDetectedHalName = SlDetectHal();
    SkipHalCheck = (NetBootDetectedHalName == NULL);

    if (!NetworkBootRom) {
        NetBootDisconnected = TRUE;
        goto EndTesting;
    }

    strcpy(OutputBuffer, NetBootPath);
    strcat(OutputBuffer, szRemoteBootCfgFile);

    if (BlOpen(SystemDeviceId, OutputBuffer, ArcOpenReadOnly, &FileId) == ESUCCESS) {

        Status = BlReadAtOffset(FileId, 0, sizeof(ULONG), &CacheBootSerialNumber);

        BlClose(FileId);

        if (Status != ESUCCESS) {
            NetBootClientCacheStale = TRUE;
            NetBootRequiresFormat = TRUE;
            NetFS_Cache = FALSE;
            goto EndTesting;
        }

        NetFS_Cache = FALSE;

        if (BlOpen(SystemDeviceId, OutputBuffer, ArcOpenReadOnly, &FileId) == ESUCCESS) {

            // Get parameters from each file
            Status = BlReadAtOffset(FileId, 0, sizeof(ULONG), &ServerBootSerialNumber);
            if (Status != ESUCCESS) {
                NetBootClientCacheStale = TRUE;
                NetBootRequiresFormat = TRUE;
                BlClose(FileId);
                goto EndTesting;
            }
            Status = BlReadAtOffset(FileId, sizeof(ULONG), sizeof(ULONG), &ServerDiskSignature);
            if (Status != ESUCCESS) {
                NetBootClientCacheStale = TRUE;
                NetBootRequiresFormat = TRUE;
                BlClose(FileId);
                goto EndTesting;
            }

            Signature.ArcName = OutputBuffer;

            strcpy(DiskName, NetBootActivePartitionName);
            p = strstr(DiskName, "partition");
            ASSERT( p != NULL );
            *p = '\0';

            if (!BlGetDiskSignature(DiskName,
                                    FALSE,
                                    &Signature
                                   )) {
                // Assume diskless PC
                BlClose(FileId);
                goto EndTesting;
            }

            CacheDiskSignature = Signature.Signature;
            if (CacheBootSerialNumber < ServerBootSerialNumber) {
                NetBootClientCacheStale = TRUE;
            }

            if (CacheDiskSignature != ServerDiskSignature) {
                NetBootClientCacheStale = TRUE;
                NetBootRequiresFormat = TRUE;
                BlClose(FileId);
                goto EndTesting;
            }

            Status = BlReadAtOffset(FileId,
                                    sizeof(ULONG) + sizeof(ULONG),
                                    sizeof(char) * (MAX_HAL_NAME_LENGTH+1),
                                    NetBootHalName
                                   );
            if (Status != ESUCCESS) {
                NetBootClientCacheStale = TRUE;
                NetBootRequiresFormat = TRUE;
                BlClose(FileId);
                goto EndTesting;
            }

            GetGuid(&Guid, &GuidLength);

            if (!SkipHalCheck && strncmp(NetBootHalName, NetBootDetectedHalName, MAX_HAL_NAME_LENGTH)) {
                if (!NT_SUCCESS(NetCopyHalAndKernel(NetBootDetectedHalName,
                                                    Guid,
                                                    GuidLength))) {
                    Status = EMFILE;
                    goto CleanUp;
                }
                NetBootClientCacheStale = TRUE;
            }

            BlClose(FileId);

        } else {
            // Running disconnected.  Assume everything is ok.
            NetBootDisconnected = TRUE;
        }

        if (!NetBootClientCacheStale) {
            NetFS_Cache = TRUE;
        }

    } else {

        NetFS_Cache = FALSE;
        NetBootClientCacheStale = TRUE;
        NetBootRequiresFormat = TRUE;

    }

EndTesting:

    Status = ESUCCESS;

    if (NetBootRequiresFormat) {
        BlWarnAboutFormat((BOOLEAN)(NetRebootParameter == NET_REBOOT_SECRET_VALID), OsLoader);
    }

    BlLoaderBlock->SetupLoaderBlock->Flags |= SETUPBLK_FLAGS_IS_REMOTE_BOOT;
    if (NetBootClientCacheStale) {
        NetBootRepin = TRUE;
    }
    if ( NetBootDisconnected ) {
        BlLoaderBlock->SetupLoaderBlock->Flags |= SETUPBLK_FLAGS_DISCONNECTED;
    }
    if ( NetBootRequiresFormat ) {
        BlLoaderBlock->SetupLoaderBlock->Flags |= SETUPBLK_FLAGS_FORMAT_NEEDED;
    }

    memcpy(BlLoaderBlock->SetupLoaderBlock->NetBootHalName,
           NetBootDetectedHalName,
           sizeof(BlLoaderBlock->SetupLoaderBlock->NetBootHalName)
          );
    BlLoaderBlock->SetupLoaderBlock->NetBootHalName[MAX_HAL_NAME_LENGTH] = '\0';

CleanUp:

    return Status;
}

VOID
BlWarnAboutFormat(
    IN BOOLEAN SecretValid,
    IN PUCHAR OsLoader
    )

/*++

Routine Description:

    This routine provides the user-interface for warning the user that
    a new harddisk has been detected and will be formatted.

Arguments:

    SecretValid - If TRUE, then return because there is no message for the user,
        otherwise display a message that the user must logon and the disk will be wiped out.

    OsLoader - Path for TFTP to the osloader.exe image.

Return Value:

    None.

--*/

{
    ULONG HeaderLines;
    ULONG TrailerLines;
    ULONG Count;
    UCHAR Key;
    PCHAR MenuHeader;
    PCHAR MenuTrailer;
    PCHAR Temp;
    ULONG DisplayLines;
    ULONG CurrentSelection = 0;
    UCHAR Buffer[16];

    if (SecretValid) {
        // We don't present the user with a screen in this case because we have already forced
        // a logon and a rewrite of the secret.
        return;
    } else {
        MenuHeader = BlFindMessage(BL_FORCELOGON_HEADER);
    }
    MenuTrailer = BlFindMessage(BL_WARNFORMAT_TRAILER);


    sprintf(Buffer, "%s%s", ASCI_CSI_OUT, ";44;37m"); // White on Blue
    ArcWrite(BlConsoleOutDeviceId, Buffer, strlen(Buffer), &Count);

    BlClearScreen();

    sprintf(Buffer, "%s%s", ASCI_CSI_OUT, ";37;44m"); // Blue on white
    ArcWrite(BlConsoleOutDeviceId, Buffer, strlen(Buffer), &Count);

    //
    // Count the number of lines in the header.
    //
    HeaderLines=BlCountLines(MenuHeader);

    //
    // Display the menu header.
    //

    ArcWrite(BlConsoleOutDeviceId,
             MenuHeader,
             strlen(MenuHeader),
             &Count);

    //
    // Count the number of lines in the trailer.
    //
    TrailerLines=BlCountLines(MenuTrailer);

    BlPositionCursor(1, ScreenHeight-TrailerLines);
    ArcWrite(BlConsoleOutDeviceId,
             MenuTrailer,
             strlen(MenuTrailer),
             &Count);

    //
    // Compute number of selections that can be displayed
    //
    DisplayLines = ScreenHeight-HeaderLines-TrailerLines-3;

    //
    // Start menu selection loop.
    //

    do {
        Temp = BlFindMessage(BL_WARNFORMAT_CONTINUE);
        if (Temp != NULL) {
            BlPositionCursor(5, HeaderLines+3);
            BlSetInverseMode(TRUE);
            ArcWrite(BlConsoleOutDeviceId,
                     Temp,
                     strlen(Temp),
                     &Count);
            BlSetInverseMode(FALSE);
        }

        //
        // Loop waiting for keypress or time change.
        //
        do {
            if (ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
                BlPositionCursor(1,ScreenHeight);
                BlClearToEndOfLine();
                ArcRead(ARC_CONSOLE_INPUT,
                        &Key,
                        sizeof(Key),
                        &Count);
                break;
            }

        } while ( TRUE );

        switch (Key) {
            case ASCI_CSI_IN:
                ArcRead(ARC_CONSOLE_INPUT,
                        &Key,
                        sizeof(Key),
                        &Count);
                break;

            default:
                break;
        }

    } while ( (Key != ASCII_CR) && (Key != ASCII_LF) );

    BlClearScreen();

    if (!SecretValid) {
        while ( TRUE ) {
            NetSoftReboot(
#if defined(_ALPHA_)
#if defined(_AXP64_)
                "OSChooser\\axp64\\startrom.com",
#else
                "OSChooser\\alpha\\startrom.com",
#endif
#endif
#if defined(_MIPS_)
                "OSChooser\\mips\\startrom.com",
#endif
#if defined(_PPC_)
                "OSChooser\\ppc\\startrom.com",
#endif
#if defined(_IA64_)
                "OSChooser\\ia64\\startrom.com",
#endif
#if defined(_X86_)
                "OSChooser\\i386\\startrom.com",
#endif
                NET_REBOOT_WRITE_SECRET_ONLY,
                OsLoader,
                NULL,    // SIF file
                NULL,    // user
                NULL,    // domain
                NULL    // password
            );
        }
    }
}


#endif // defined(REMOTE_BOOT)


//
// NOTE: [bassamt] Stubs for TextMode setup funtions. These 
// are needed so that we can call SlDetectHal during regular boot.
//

PVOID InfFile = NULL;
PVOID WinntSifHandle = NULL;
BOOLEAN DisableACPI = FALSE;


VOID
SlNoMemError(
    IN ULONG Line,
    IN PCHAR File
    )

/*++

Routine Description:

    This routine does nothing.

Arguments:

    Line - Line number of the error.

    File - Name of the file with the error.

Return Value:

    None.

--*/
{
}

VOID
SlBadInfLineError(
    IN ULONG Line,
    IN PCHAR INFFile
    )
/*++

Routine Description:

    This routine does nothing.

Arguments:

    Line - Line number of the error.

    INFFile - Supplies a pointer to the INF filename.

Return Value:

    None.

--*/
{
}

VOID
SlErrorBox(
    IN ULONG MessageId,
    IN ULONG Line,
    IN PCHAR File
    )
/*++

Routine Description:

    This routine does nothing.

Arguments:

    MessageId - Id of the text to display.

    Line - Line number of the of the warning.

    File - Name of the file where warning is coming from.

Return Value:

    None.

--*/
{
}

VOID
SlFriendlyError(
    IN ULONG uStatus,
    IN PCHAR pchBadFile,
    IN ULONG uLine,
    IN PCHAR pchCodeFile
    )

/*++

Routine Description:

    This routine does nothing.

Arguments:

    uStatus     - ARC error code

    pchBadFile  - Name of file causing error (Must be given for handled
                  ARC codes.  Optional for unhandled codes.)

    uLine       - Line # in source code file where error occurred (only
                  used for unhandled codes.)

    pchCodeFile - Name of souce code file where error occurred (only
                  used for unhandled codes.)

Return Value:

    None.

--*/

{
}


VOID
SlFatalError(
    IN ULONG MessageId,
    ...
    )

/*++

Routine Description:

    This routine does nothing.  In the context of dynamic HAL detection, we just ignore the
    error and hope everything is ok.

Arguments:

    MessageId - Supplies ID of message box to be presented.

    any sprintf-compatible arguments to be inserted in the
    message box.

Return Value:

    None.

--*/

{
}


ULONG
SlGetChar(
    VOID
    )
{
    return 0;
}



VOID
SlPrint(
    IN PTCHAR FormatString,
    ...
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

!IF "$(BUILD_DEBUG_LOADER)" != ""
DBG_LDR=_dbg
!ELSE
DBG_LDR=
!ENDIF

#
# BOOT_LIB_DIR is the relative path to boot.lib.
#
!IFNDEF BOOT_LIB_DIR
BOOT_LIB_DIR=daytona$(DBG_LDR)
!ENDIF

#
# RSP_DIR is the relative path to the linker response files.
#
!IFNDEF RSP_DIR
RSP_DIR=daytona
!ENDIF

$(O)\msg.mc : ..\msg.$(LANGUAGE)
    copy $** $@

!IF $(386)

OSLOADER_LIBS=\
    $(O)\bldr.lib \
    $(O)\osloader.res \
    $(O)\osloader.exp \
    $(PROJECT_ROOT)\boot\lib\$(BOOT_LIB_DIR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\bd\daytona$(DBG_LDR)\$(O)\bd.lib \
    $(PROJECT_ROOT)\boot\tftplib\$(O)\tftplib.lib \
    $(PROJECT_ROOT)\boot\bootssp\boot\$(O)\bootssp.lib \
    $(PROJECT_ROOT)\ntos\ke\up\$(O)\ke.lib \
    $(PROJECT_ROOT)\ntos\rtl\boot$(DBG_LDR)\$(O)\bldrrtl$(DBG_LDR).lib \
    $(PROJECT_ROOT)\ntos\config\boot\$(O)\bconfig.lib \
    $(SDK_LIB_PATH)\libcntpr.lib \
    $(DS_LIB_PATH)\rsa32.lib

$(O)\osloader.res: $(O)\msg.mc

$(O)\osloader.lib $(O)\osloader.exp: ..\daytona\i386\osloader.def
    $(LIB_NAME) -machine:i386 -out:$(O)\osloader.lib -def:..\daytona\i386\osloader.def ..\..\lib\$(BOOT_LIB_DIR)\$(O)\boot.lib $(O)\bldr.lib -ignore:4001

$(O)\link.rsp : ..\makefile.inc
    type << > $@
-machine:i386
-debug
-entry:NtProcessStartup@4
-fixed
-force:multiple
-ignore:4049,4001
-incremental:no
-map
-opt:ref
-opt:icf
-subsystem:native
$(LINK_TIME_CODE_GENERATION_LINKER_FLAGS)
$(LINK_LIB_IGNORE_FLAG)
$(OSLOADER_LIBS)
<<NOKEEP

LDR_ROOT=osloader$(DBG_LDR)
LDR_NAME=$(LDR_ROOT).exe

$(O)\$(LDR_NAME): $(OSLOADER_LIBS) makefile.inc $(O)\link.rsp
    -$(LINK_NAME) -out:$@ @$(O)\link.rsp

#
# Inject ntdetect.com as a PE data section into osloader.ntd. This
# is used on a remote boot to avoid downloading ntdetect.com
# over the network.
#
$(O)\$(LDR_ROOT).ntd: $(O)\$(LDR_NAME) $(PROJECT_ROOT)\boot\detect\fre\$(O)\ntdetect.com
    addsect /o:$(O)\$(LDR_ROOT).ntd /i:$(O)\$(LDR_NAME) /d:$(PROJECT_ROOT)\boot\detect\fre\$(O)\ntdetect.com /s:.detect

!if "$(LDR_NAME)" == "osloader$(DBG_LDR).exe"

#
# STARTUP_DIR is the relative path to startup.com.
# All languages and NEC_98 use their own startup.com,
# except FE langauges which use the US version when
# creating NTLDR.
#
!IFNDEF STARTUP_DIR
STARTUP_DIR=$(ALT_PROJECT)
!ENDIF

$(O)\NTLDR$(DBG_LDR): $(OSLOADER_LIBS) $(O)\$(LDR_NAME) ..\..\startup\$(STARTUP_DIR)\$(_OBJ_DIR)\i386\startup.com makefile.inc
    -copy $(O)\osloader$(DBG_LDR).exe $(O)\osloader.spl
    splitsym -a $(O)\osloader.spl
    -copy /b ..\..\startup\$(STARTUP_DIR)\$(_OBJ_DIR)\i386\startup.com+$(O)\osloader.spl $@
    -del /q $(O)\osloader.dbg
    -del /q $(O)\osloader.spl
!endif

!ELSE IF $(IA64)

OSLOADER_LIBS=\
    $(O)\bldr.lib \
    $(O)\osloader.res \
    $(PROJECT_ROOT)\boot\lib\$(BOOT_LIB_DIR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\bd\daytona$(DBG_LDR)\$(O)\bd.lib \
    $(PROJECT_ROOT)\boot\tftplib\$(O)\tftplib.lib \
    $(PROJECT_ROOT)\boot\bootssp\boot\$(O)\bootssp.lib \
    $(PROJECT_ROOT)\boot\efi\daytona$(DBG_LDR)\$(O)\efi.lib \
    $(PROJECT_ROOT)\ntos\ke\up\$(O)\ke.lib \
    $(PROJECT_ROOT)\ntos\rtl\boot$(DBG_LDR)\$(O)\bldrrtl$(DBG_LDR).lib \
    $(PROJECT_ROOT)\ntos\config\boot\$(O)\bconfig.lib \
    $(DS_LIB_PATH)\rsa32.lib \
    $(SDK_LIB_PATH)\libcntpr.lib \
#    $(SDK_LIB_PATH)\libssc.lib

!IFNDEF STARTUP_DIR
STARTROM_DIR=$(ALT_PROJECT)
!ENDIF

$(O)\link.rsp : ..\makefile.inc
   type << > $@
-subsystem:EFI_APPLICATION
-driver
-map
-machine:IA64
-debug:full
-last:.rdata
-last:.pdata
-last:.comment
-base:0x1040000
-entry:main
-ignore:4049,4001
-nodefaultlib
-opt:icf
-opt:ref
$(LINK_TIME_CODE_GENERATION_LINKER_FLAGS)
$(LINK_LIB_IGNORE_FLAG)
$(OSLOADER_LIBS)
<<NOKEEP

$(O)\osloader.res: $(O)\msg.mc

OSLOADER_LIB_COMPONENTS = \
    $(PROJECT_ROOT)\boot\lib\$(BOOT_LIB_DIR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\efi\daytona$(DBG_LDR)\$(O)\efi.lib \
    $(O)\bldr.lib

$(O)\osloader.lib $(O)\osloader.exp: ..\ia64\osloader.def
    $(LIB_NAME) -machine:ia64 -out:$(O)\osloader.lib -def:..\ia64\osloader.def $(OSLOADER_LIB_COMPONENTS) -ignore:4001

$(O)\ia64ldr$(DBG_LDR).efi: $(OSLOADER_LIBS) makefile.inc $(O)\link.rsp
    -$(LINK_NAME) -out:$@ @$(O)\link.rsp
        
!ELSE

OSLOADER_LIBS=\
    $(O)\bldr.lib \
    $(O)\osloader.res \
    $(PROJECT_ROOT)\boot\lib\$(BOOT_LIB_DIR)\$(O)\boot.lib \
    $(PROJECT_ROOT)\boot\bd\daytona$(DBG_LDR)\$(O)\bd.lib \
    $(PROJECT_ROOT)\boot\tftplib\$(O)\tftplib.lib \
    $(PROJECT_ROOT)\boot\bootssp\boot\$(O)\bootssp.lib \
    $(PROJECT_ROOT)\ntos\ke\up\$(O)\ke.lib \
    $(PROJECT_ROOT)\ntos\rtl\boot$(DBG_LDR)\$(O)\bldrrtl$(DBG_LDR).lib \
    $(PROJECT_ROOT)\ntos\config\boot\$(O)\bconfig.lib \
    $(SDK_LIB_PATH)\libcntpr.lib \
    $(DS_LIB_PATH)\rsa32.lib

$(O)\link.rsp : ..\makefile.inc 
    type << > $@
-rom
-debug:full
-fixed
-map
-align:0x200
!if $(AXP64)
-base:0xFFFFFFFF80600000
!else
-base:0x80600000
!endif
-entry:BlOsLoader
-ignore:4049,4001
-nodefaultlib
-opt:noicf
$(LINK_TIME_CODE_GENERATION_LINKER_FLAGS)
$(LINK_LIB_IGNORE_FLAG)
$(OSLOADER_LIBS)
<<NOKEEP

$(O)\osloader.res: $(O)\msg.mc

$(O)\osloader$(DBG_LDR).exe: $(OSLOADER_LIBS) makefile.inc $(O)\link.rsp
        -$(LINK_NAME) -out:$@ @$(O)\link.rsp
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\br\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\regboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regboot.c

Abstract:

    Provides a minimal registry implementation designed to be used by the
    osloader at boot time.  This includes loading the system hive
    ( <SystemRoot>\config\SYSTEM ) into memory, and computing the driver
    load list from it.

Author:

    John Vert  (jvert)  10-Mar-1992

Revision History:

    Doug Fritz (dFritz) 07-Oct-1997 & KenRay Feb 98

      - Filter hardware profiles based on detected hardware
        configuration (docking station) information

--*/
#include "bldr.h"
#include "msg.h"
#include "cmp.h"
#include "stdio.h"
#include "string.h"
#include <dockinfo.h>
#include <netboot.h>

#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#ifdef _WANT_MACHINE_IDENTIFICATION
#include <stdlib.h>
#include <ntverp.h>
#endif

#include "bldrint.h"
#include "vmode.h"



CMHIVE BootHive;
ULONG CmLogLevel=100;
ULONG CmLogSelect=0;

ULONG ScreenWidth=80;
#ifdef EFI 
ULONG ScreenHeight=24;
#else
ULONG ScreenHeight=25;
#endif

ULONG LkgStartTime;

//
// used by the advanced boot screen to force a LKG boot
//
BOOLEAN ForceLastKnownGood;

//
// Variable used to check whether to display
// "Return to OS Choices Menu" or not in adv. boot
//
BOOLEAN BlShowReturnToOSChoices = TRUE;


VOID
BlRedrawProgressBar(
    VOID
    );

VOID
BlOutputStartupMsg(
    ULONG   uMsgID
    );

ULONG
BlGetAdvancedBootID(
    LONG BootOption
    );

//
// Private function prototypes
//

BOOLEAN
BlInitializeHive(
    IN PVOID HiveImage,
    IN PCMHIVE Hive,
    IN BOOLEAN IsAlternate
    );

BOOLEAN
BlpCheckRestartSetup(
    VOID
    );

PVOID
BlpHiveAllocate(
    IN ULONG Length,
    IN BOOLEAN UseForIo,
    ULONG   Tag
    );

VOID
BlDockInfoFilterProfileList(
    IN OUT PCM_HARDWARE_PROFILE_LIST ProfileList,
    IN OUT PCM_HARDWARE_PROFILE_ALIAS_LIST  AliasList
);


VOID
BlStartConfigPrompt(
    VOID
    )

/*++

Routine Description:

    This routine displays the LKG prompt, records the current time,
    and returns. The prompt is displayed before the kernel and HAL
    are loaded, and then removed afterwards.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG Count;
    PTCHAR LkgPrompt;

    LkgPrompt = BlFindMessage(BL_LKG_MENU_PROMPT);
    if (LkgPrompt==NULL) {
        return;
    }
    //
    // display LKG prompt
    //
#if 0
    BlPositionCursor(1,3);
    ArcWrite(BlConsoleOutDeviceId,
             LkgPrompt,
             _tcslen(LkgPrompt)*sizeof(TCHAR),
             &Count);
    BlPositionCursor(1,2);
#endif
    LkgStartTime = ArcGetRelativeTime();

#if defined(REMOTE_BOOT) && defined(i386)
    //
    //  Wait to allow the user to type space or F8. If anything is typed then behave
    //  conservatively and load the kernel, etc., from the server just in case CSC or
    //  the local filesystem is broken.
    //
    if (BlBootingFromNet) {

        ULONG EndTime;
        ULONG Status;
        ULONG CurrentTime;

        EndTime = LkgStartTime + 3;
        if (EndTime <= ArcGetRelativeTime()) {
            EndTime = ArcGetRelativeTime()+1;
        }

        do {
            if (ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {

                //
                //  There is a key pending, assume it is CSC related. If it isn't
                //  CSC then it just means we laod a few extra files from the
                //  server. 
                //

                NetBootCSC = FALSE;
                break;

            }

            CurrentTime = ArcGetRelativeTime();

            //
            // Terminate the loop if the EndTime has been reached, or
            // if the CurrentTime has wrapped at midnight.
            //
        } while ((CurrentTime < EndTime) &&
                 (CurrentTime >= LkgStartTime));
    }
#endif // defined(REMOTE_BOOT) && defined(i386)

}


BOOLEAN
BlEndConfigPrompt(
    VOID
    )

/*++

Routine Description:

    This routine waits until the LKG timeout has expired or the
    user presses a key and then removes the LKG prompt.

Arguments:

    None.

Return Value:

    TRUE - Space bar pressed.

    FALSE - Space bar was not pressed.

--*/
{
    ULONG   EndTime;
    ULONG   Count;
    ULONG   Key;
    ULONG   Status;
    ULONG   CurrentTime;

    //
    // We do not wait for a keypress if there is not already one.
    //
    EndTime = 0;


    if( BlIsTerminalConnected() ) {
        //
        // If we're booting headless, give the user lots of time
        // to press any of the advanced options keys.
        //
        EndTime = ArcGetRelativeTime() + 5;
    }


#if defined(REMOTE_BOOT) && defined(i386)
    //
    //  If a key was detected and CSC turned off then re-enable CSC until
    //  we find out if it should be disabled for this whole boot.
    //

    NetBootCSC = TRUE;
#endif // defined(REMOTE_BOOT) && defined(i386)

    do {
        LONG        AdvancedBoot = -1;
        BOOLEAN     bOldState = BlShowReturnToOSChoices;
        BlShowReturnToOSChoices = FALSE;
        
        if ((Key = BlGetKey()) != 0) {
            
            //
            // return if the pending key was the spacebar.
            //
            if (Key == ' ') {
                return(TRUE);
            }

            //
            // look to see if the user pressed the F5 or F8 keys,
            // these keys trigger the advanced boot menu.  the advanced
            // boot menu can also be entered from the main boot menu by
            // pressing the same keys.
            //
            
            if (Key == F5_KEY || Key == F8_KEY) {
                //
                // present the menu and get the user's request
                //
                LONG        AdvancedBoot = -1;
                BOOLEAN     bOldState = BlShowReturnToOSChoices;

                BlShowReturnToOSChoices = FALSE;

                if (DisplayLogoOnBoot) {
                    if (!DbcsLangId)
                        HW_CURSOR(0x80000000,0x3);
                    else
                        HW_CURSOR(0x80000000,0x12);
                }
                
                AdvancedBoot = BlDoAdvancedBoot( BL_ADVANCEDBOOT_TITLE, 0, FALSE, 0 );

                if (DisplayLogoOnBoot) {

                    PSTR BootOption;

                    if ((AdvancedBoot != -1) &&
                        ((BootOption = BlGetAdvancedBootLoadOptions(AdvancedBoot)) != NULL ) &&
                        (!strncmp("SAFEBOOT",BootOption,8))) {
                            DisplayLogoOnBoot = FALSE;    // on safe boot let the "Checking file system" message
                                                          // appear as it appears today (in graphics mode)
                    } else {
#ifndef EFI
                        HW_CURSOR(0x80000000,0x12);
                        if (DbcsLangId)

                            TextClearDisplay();
                        VgaEnableVideo();
                        PaletteOn();
                        DrawBitmap ();
                        BlUpdateBootStatus();
#endif
                    }
                }

                BlShowReturnToOSChoices = bOldState;

                if (AdvancedBoot != -1) {
                    //
                    // they chose a valid boot option so append
                    // any os load options and perform any necessary
                    // option processing.
                    //
                    PSTR NewOptions = BlGetAdvancedBootLoadOptions(AdvancedBoot);

                    if( BlGetAdvancedBootID(AdvancedBoot) == BL_MSG_REBOOT ) {
                        BlClearScreen(); 
                        REBOOT_PROCESSOR();
                    }


                    if (NewOptions != NULL && strstr(BlLoaderBlock->LoadOptions,NewOptions) == NULL) {
                        ULONG len = strlen(NewOptions) +                 // new options
                                    1 +                                  // seperated by a space                 
                                    strlen(BlLoaderBlock->LoadOptions) + // old options
                                    1;                                   // null terminator
                        NewOptions = BlAllocateHeap(len * sizeof(PCHAR));
                        strcpy(NewOptions,BlLoaderBlock->LoadOptions);
                        strcat(NewOptions," ");
                        strcat(NewOptions,BlGetAdvancedBootLoadOptions(AdvancedBoot));
                        BlLoaderBlock->LoadOptions = NewOptions;

                        DBGTRACE(TEXT("Load Options = %S"), BlLoaderBlock->LoadOptions);
                    }

                    BlDoAdvancedBootLoadProcessing(AdvancedBoot);
                }
            }                            
        }

        CurrentTime = ArcGetRelativeTime();

        //
        // Terminate the loop if the EndTime has been reached, or
        // if the CurrentTime has wrapped at midnight.
        //
    } while ((CurrentTime < EndTime) &&
             (CurrentTime >= LkgStartTime));

    //
    // make LKG prompt go away, so as not to startle the user.
    // remote the trailer & update progress bar
    //
#if defined(_IA64_)
    BlOutputStartupMsg(BL_MSG_STARTING_WINDOWS);
#endif
    BlRedrawProgressBar();

    return(FALSE);
}


VOID
BlpSwitchControlSet(
    OUT PCM_HARDWARE_PROFILE_LIST *ProfileList,
    OUT PCM_HARDWARE_PROFILE_ALIAS_LIST *AliasList,
    IN BOOLEAN UseLastKnownGood,
    OUT PHCELL_INDEX ControlSet
    )

/*++

Routine Description:

    Switches the current control set to the specified control
    set and rebuilds the hardware profile list.

Arguments:

    ProfileList - Returns the new hardware profile list

    UseLastKnownGood - Supplies whether the LKG control set is to be used.

    ControlSet - Returns the HCELL_INDEX of the new control set.

Return Value:

    None.

--*/

{
    UNICODE_STRING ControlName;
    HCELL_INDEX NewControlSet;
    BOOLEAN AutoSelect;         // ignored
    ULONG ProfileTimeout;       // ignored

    //
    // Find the new control set.
    //
    if (UseLastKnownGood) {
        RtlInitUnicodeString(&ControlName, L"LastKnownGood");
    } else {
        RtlInitUnicodeString(&ControlName, L"Default");
    }
    NewControlSet = CmpFindControlSet(&BootHive.Hive,
                                      BootHive.Hive.BaseBlock->RootCell,
                                      &ControlName,
                                      &AutoSelect);
    if (NewControlSet == HCELL_NIL) {
        return;
    }

    CmpFindProfileOption(&BootHive.Hive,
                         NewControlSet,
                         ProfileList,
                         AliasList,
                         NULL);
    *ControlSet = NewControlSet;
}


ULONG
BlCountLines(
    IN PTCHAR Lines
    )

/*++

Routine Description:

    Counts the number of lines in the given string.

Arguments:

    Lines - Supplies a pointer to the start of the string

Return Value:

    The number of lines in the string.

--*/

{
    PTCHAR p;
    ULONG NumLines = 0;

    p=Lines;
    while (*p != TEXT('\0')) {
        if ((*p == TEXT('\r')) && (*(p+1) == TEXT('\n'))) {
            ++NumLines;
            ++p;            // move forward to \n
        }
        ++p;
    }
    return(NumLines);
}


BOOLEAN
BlConfigMenuPrompt(
    IN ULONG Timeout,
    IN OUT PBOOLEAN UseLastKnownGood,
    IN OUT PHCELL_INDEX ControlSet,
    OUT PCM_HARDWARE_PROFILE_LIST *ProfileList,
    OUT PCM_HARDWARE_PROFILE_ALIAS_LIST *AliasList,
    OUT PCM_HARDWARE_PROFILE *HardwareProfile
    )

/*++

Routine Description:

    This routine provides the user-interface for the configuration menu.
    The prompt is given if the user hits the break-in key, or if the
    LastKnownGood environment variable is TRUE and AutoSelect is FALSE, or
    if the timeout value on the hardware profile configuration is non-zero

Arguments:

    Timeout - Supplies the timeout value for the menu. -1 or 0 implies the menu
              will never timeout.

    UseLastKnownGood - Returns the LastKnownGood setting that should be
        used for the boot.

    ControlSet - Returns the control set (either Default or LKG)

    ProfileList - Supplies the default list of profiles.
                  Returns the current list of profiles.
                  (may change due to switching to/from the LKG controlset)

    HardwareProfile - Returns the hardware profile that should be used.

Return Value:

    TRUE - Boot should proceed.

    FALSE - The user has chosen to return to the firmware menu/flexboot menu.

--*/

{
    ULONG HeaderLines;
    ULONG TrailerLines;
    ULONG i;
    ULONG Count;
    ULONG flags;
    ULONG Key;
    PTCHAR MenuHeader;
    PTCHAR MenuTrailer1;
    PTCHAR MenuTrailer2;
    PTCHAR p;
    ULONG OptionLength;
    TCHAR MenuOption[80];
    PCM_HARDWARE_PROFILE Profile;
    ULONG ProfileCount;
    _TUCHAR LkgMnemonic;
    _TUCHAR DefaultMnemonic;
    PTCHAR Temp;
    ULONG DisplayLines;
    ULONG TopProfileLine=0;
    ULONG CurrentSelection = 0;
    ULONG CurrentProfile;
    ULONG EndTime;
    ULONG CurrentTime;
    PTCHAR TimeoutPrompt;

    if ((Timeout != (ULONG)-1) && (Timeout != 0)) {
        CurrentTime = ArcGetRelativeTime();
        EndTime = CurrentTime + Timeout;
        TimeoutPrompt = BlFindMessage(BL_LKG_TIMEOUT);

        if (TimeoutPrompt != NULL) {

            p=_tcschr(TimeoutPrompt, TEXT('\n'));
            if (p) {
                *p = TEXT('\0');
            }
            p=_tcschr(TimeoutPrompt, TEXT('\r'));
            if (p) {
                *p = TEXT('\0');
            }

        }

    } else {

        TimeoutPrompt = NULL;

    }

    MenuHeader = BlFindMessage(BL_LKG_MENU_HEADER);
    Temp = BlFindMessage(BL_LKG_SELECT_MNEMONIC);
    if (Temp == NULL) {
        return(TRUE);
    }
    LkgMnemonic = (_TUCHAR)_totupper(Temp[0]);
    Temp = BlFindMessage(BL_DEFAULT_SELECT_MNEMONIC);
    if (Temp == NULL) {
        return(TRUE);
    }
    DefaultMnemonic = (_TUCHAR)_totupper(Temp[0]);

    if ((*UseLastKnownGood) &&
        (*ProfileList) && ((*ProfileList)->CurrentProfileCount == 1)) {

        //
        // The user selected last known good via boot.ini/nvram/etc. Since this
        // was a concious decision, and we don't have more than one profile to
        // choose, just skip this UI altogether.
        //
        ASSERT(CurrentSelection == 0);
        goto ProcessSelection;
    }

Restart:

    if (*ProfileList == NULL) {
        ProfileCount = 0;
    } else {
        ProfileCount = (*ProfileList)->CurrentProfileCount;
    }
    if (ProfileCount == 0) {
        MenuTrailer1 = BlFindMessage(BL_LKG_MENU_TRAILER_NO_PROFILES);
    } else {
        MenuTrailer1 = BlFindMessage(BL_LKG_MENU_TRAILER);
    }
    if (*UseLastKnownGood) {
        MenuTrailer2 = BlFindMessage(BL_SWITCH_DEFAULT_TRAILER);
    } else {
        MenuTrailer2 = BlFindMessage(BL_SWITCH_LKG_TRAILER);
    }
    if ((MenuHeader==NULL) || (MenuTrailer1==NULL) || (MenuTrailer2==NULL)) {
        return(TRUE);
    }

    //
    // strip trailing /r/n from MenuTrailer2 to prevent it from scrolling
    // the screen when we output it.
    //
#if 0
    p=MenuTrailer2 + strlen(MenuTrailer2) - 1;
    while ((*p == TEXT('\r')) || (*p == TEXT('\n'))) {
        *p = TEXT('\0');
        --p;
    }
#endif
    BlClearScreen();
#ifdef EFI
    BlEfiSetAttribute( DEFATT );
#else
    BlSetInverseMode(FALSE);
#endif

    //
    // Count the number of lines in the header.
    //
    HeaderLines=BlCountLines(MenuHeader);

    //
    // Display the menu header.
    //

    ArcWrite(BlConsoleOutDeviceId,
             MenuHeader,
             _tcslen(MenuHeader)*sizeof(TCHAR),
             &Count);

    //
    // Count the number of lines in the trailer.
    //
    TrailerLines=BlCountLines(MenuTrailer1) + BlCountLines(MenuTrailer2);

    //
    // Display the trailing prompt.
    //
    if (TimeoutPrompt) {
        TrailerLines += 1;
    }

    BlPositionCursor(1, ScreenHeight-TrailerLines);
    ArcWrite(BlConsoleOutDeviceId,
             MenuTrailer1,
             _tcslen(MenuTrailer1)*sizeof(TCHAR),
             &Count);
    ArcWrite(BlConsoleOutDeviceId,
             MenuTrailer2,
             _tcslen(MenuTrailer2)*sizeof(TCHAR),
             &Count);

    //
    // Compute number of selections that can be displayed
    //
    DisplayLines = ScreenHeight-HeaderLines-TrailerLines-3;
    if (ProfileCount < DisplayLines) {
        DisplayLines = ProfileCount;
    }

    //
    // Start menu selection loop.
    //

    do {
        if (ProfileCount > 0) {
            //
            // Display options with current selection highlighted
            //
            for (i=0; i < DisplayLines; i++) {
                CurrentProfile = i+TopProfileLine;
                Profile = &(*ProfileList)->Profile[CurrentProfile];
                BlPositionCursor(5, HeaderLines+i+2);
#ifdef EFI
                BlEfiSetAttribute( (CurrentProfile == CurrentSelection) ? INVATT : DEFATT );
#else
                BlSetInverseMode((BOOLEAN)(CurrentProfile == CurrentSelection));
#endif
#ifdef UNICODE
                ArcWrite(BlConsoleOutDeviceId,
                         Profile->FriendlyName,
                         Profile->NameLength,
                         &Count );                                
#else
                RtlUnicodeToMultiByteN(MenuOption,
                                 sizeof(MenuOption),
                                 &OptionLength,
                                 Profile->FriendlyName,
                                 Profile->NameLength);                
                ArcWrite(BlConsoleOutDeviceId,
                         MenuOption,
                         OptionLength,
                         &Count);
#endif
#ifdef EFI
                BlEfiSetAttribute( DEFATT );
#else
                BlSetInverseMode(FALSE);
#endif
                BlClearToEndOfLine();
            }

        } else {
            //
            // No profile options available, just display the default
            // highlighted to indicate that ENTER will start the system.
            //
            Temp = BlFindMessage(BL_BOOT_DEFAULT_PROMPT);
            if (Temp != NULL) {
                BlPositionCursor(5, HeaderLines+3);
#ifdef EFI
                BlEfiSetAttribute( INVATT );
#else
                BlSetInverseMode(TRUE);
#endif                
                ArcWrite(BlConsoleOutDeviceId,
                         Temp,
                         _tcslen(Temp)*sizeof(TCHAR),
                         &Count);
#ifdef EFI
                BlEfiSetAttribute( INVATT );
#else
                BlSetInverseMode(TRUE);
#endif                
            }
        }
        if (TimeoutPrompt) {
            CurrentTime = ArcGetRelativeTime();
            _stprintf(MenuOption, TimeoutPrompt, EndTime-CurrentTime);
            BlPositionCursor(1, ScreenHeight);
            ArcWrite(BlConsoleOutDeviceId,
                     MenuOption,
                     _tcslen(MenuOption)*sizeof(TCHAR),
                     &Count);
            BlClearToEndOfLine();
        }

        //
        // Loop waiting for keypress or time change.
        //
        do {
            if ((Key = BlGetKey()) != 0) {
                TimeoutPrompt = NULL;               // turn off timeout prompt
                BlPositionCursor(1,ScreenHeight);
                BlClearToEndOfLine();
                break;
            }

            if (TimeoutPrompt) {
                if (ArcGetRelativeTime() != CurrentTime) {
                    //
                    // Time has changed, update the countdown and check for timeout
                    //

                    CurrentTime = ArcGetRelativeTime();
                    _stprintf(MenuOption, TimeoutPrompt, EndTime-CurrentTime);
                    BlPositionCursor(1, ScreenHeight);
                    ArcWrite(BlConsoleOutDeviceId,
                             MenuOption,
                             _tcslen(MenuOption)*sizeof(TCHAR),
                             &Count);
                    BlClearToEndOfLine();
                    if (EndTime == CurrentTime) {
                        goto ProcessSelection;
                    }
                }
            }

        } while ( TRUE );        

        switch (Key) {
        case UP_ARROW:
            //
            // Cursor up
            //
            if (ProfileCount > 0) {
                if (CurrentSelection==0) {
                    CurrentSelection = ProfileCount - 1;
                    if (TopProfileLine + DisplayLines <= CurrentSelection) {
                        TopProfileLine = CurrentSelection - DisplayLines + 1;
                    }
                } else {
                    if (--CurrentSelection < TopProfileLine) {
                        //
                        // Scroll up
                        //
                        TopProfileLine = CurrentSelection;
                    }
                }

            }

            break;

        case DOWN_ARROW:
            //
            // Cursor down
            //
            if (ProfileCount > 0) {
                CurrentSelection = (CurrentSelection+1) % ProfileCount;
                if (CurrentSelection == 0) {
                    TopProfileLine = 0;
                } else if (TopProfileLine + DisplayLines <= CurrentSelection) {
                    TopProfileLine = CurrentSelection - DisplayLines + 1;
                }
            }
            break;

        case F3_KEY:
            //
            // F3
            //
            *ControlSet = HCELL_NIL;                                
            return(FALSE);
        
        
        default:
            //
            // Check to see if the Key indicates the user selection LKG
            //  first, we have to make sure we are looking at an alpha char.
            //
            if ( ((Key >> 8) == 0) && _istalpha((TCHAR)Key) ) {
            
                if ((_totupper((TCHAR)Key) == LkgMnemonic) && (*UseLastKnownGood == FALSE)) {
                    *UseLastKnownGood = TRUE;
                    BlpSwitchControlSet(ProfileList,
                                        AliasList,
                                        TRUE,
                                        ControlSet);

                    if (NULL != *ProfileList) {
                        if ((*ProfileList)->CurrentProfileCount > 0) {
                            BlDockInfoFilterProfileList (*ProfileList, *AliasList);
                        }
                    }

                    goto Restart;
                    //
                    // regenerate profile list here
                    //
                } else if ((_totupper((TCHAR)Key) == DefaultMnemonic) && (*UseLastKnownGood)) {
                    *UseLastKnownGood = FALSE;
                    BlpSwitchControlSet(ProfileList,
                                        AliasList,
                                        FALSE,
                                        ControlSet);

                    if (NULL != *ProfileList) {
                        if ((*ProfileList)->CurrentProfileCount > 0) {
                            BlDockInfoFilterProfileList (*ProfileList, *AliasList);
                        }
                    }

                    goto Restart;
                }
            }
            break;

        } // switch

    } while ( (Key != ASCII_CR) && (Key != ASCII_LF) );

ProcessSelection:

    if (ProfileCount > 0) {

        if (HW_PROFILE_STATUS_SUCCESS == BlLoaderBlock->Extension->Profile.Status) {

            flags = ((*ProfileList)->Profile[CurrentSelection].Flags);

            if (flags & CM_HP_FLAGS_PRISTINE) {
                BlLoaderBlock->Extension->Profile.Status =
                    HW_PROFILE_STATUS_PRISTINE_MATCH;

            } else if (flags & CM_HP_FLAGS_TRUE_MATCH) {
                BlLoaderBlock->Extension->Profile.Status =
                    HW_PROFILE_STATUS_TRUE_MATCH;

            } else if (flags & CM_HP_FLAGS_ALIASABLE) {
                BlLoaderBlock->Extension->Profile.Status =
                    HW_PROFILE_STATUS_ALIAS_MATCH;
            }
        }

        CmpSetCurrentProfile(&BootHive.Hive,
                             *ControlSet,
                             &(*ProfileList)->Profile[CurrentSelection]);
    }

    return(TRUE);
}


ARC_STATUS
BlLoadBootDrivers(
    IN  PPATH_SET   DefaultPathSet,
    IN  PLIST_ENTRY BootDriverListHead,
    OUT PCHAR       BadFileName
    )

/*++

Routine Description:

    Walks the boot driver list and loads all the drivers

Arguments:

    DefaultPathSet - Describes the possible locations drivers could be loaded
        from.

    BootDriverListHead - Supplies the head of the boot driver list

    BadFileName - Returns the filename of the critical driver that
        did not load.  Not valid if ESUCCESS is returned.

Return Value:

    ESUCCESS is returned if all the boot drivers were successfully loaded.
        Otherwise, an unsuccessful status is returned.
--*/

{
    ULONG DeviceId;
    PBOOT_DRIVER_NODE DriverNode;
    PBOOT_DRIVER_LIST_ENTRY DriverEntry;
    PLIST_ENTRY NextEntry;
    CHAR DriverName[64];
    PCHAR NameStart;
    CHAR DriverDevice[128];
    CHAR DriverPath[128];
    ARC_STATUS Status;
    UNICODE_STRING DeviceName;
    UNICODE_STRING FileName;
    WCHAR SystemRootBuffer[] = L"\\SystemRoot\\";
    ULONG SystemRootLength;
    PWSTR p;
    ULONG Index;
    BOOLEAN AbsolutePath;
    FULL_PATH_SET LocalPathSet;
    PPATH_SOURCE PathSource;

    SystemRootLength = wcslen(SystemRootBuffer);

    NextEntry = BootDriverListHead->Flink;
    while (NextEntry != BootDriverListHead) {
        DriverNode = CONTAINING_RECORD(NextEntry,
                                       BOOT_DRIVER_NODE,
                                       ListEntry.Link);

        Status = ESUCCESS;

        DriverEntry = &DriverNode->ListEntry;

        if (DriverEntry->FilePath.Buffer[0] != L'\\') {

            //
            // This is a relative pathname, so generate the full pathname
            // relative to the boot partition.
            //
            sprintf(DriverPath, "%wZ", &DriverEntry->FilePath);
            AbsolutePath = FALSE;

        } else if (memcmp(DriverEntry->FilePath.Buffer,
                          SystemRootBuffer,
                          (SystemRootLength * sizeof(WCHAR))) == 0) {

            //
            // This is a pathname starting with "\SystemRoot\", so just ignore
            // that part and treat like the previous case.
            //
            FileName.Buffer = DriverEntry->FilePath.Buffer + SystemRootLength;
            FileName.Length = (USHORT)(DriverEntry->FilePath.Length - (SystemRootLength * sizeof(WCHAR)));

            sprintf(DriverPath, "%wZ", &FileName);
            AbsolutePath = FALSE;

        } else {

            //
            // This is an absolute pathname, of the form
            //    "\ArcDeviceName\dir\subdir\filename"
            //
            // We need to open the specified ARC device and pass that
            // to BlLoadDeviceDriver.
            //

            p = DeviceName.Buffer = DriverEntry->FilePath.Buffer+1;
            DeviceName.Length = 0;
            DeviceName.MaximumLength = DriverEntry->FilePath.MaximumLength-sizeof(WCHAR);

            while ((*p != L'\\') &&
                   (DeviceName.Length < DeviceName.MaximumLength)) {

                ++p;
                DeviceName.Length += sizeof(WCHAR);

            }

            DeviceName.MaximumLength = DeviceName.Length;
            sprintf(DriverDevice, "%wZ", &DeviceName);

            Status = ArcOpen(DriverDevice,ArcOpenReadOnly,&DeviceId);

            FileName.Buffer = p+1;
            FileName.Length = DriverEntry->FilePath.Length - DeviceName.Length - 2*sizeof(WCHAR);
            FileName.MaximumLength = FileName.Length;

            //
            // Device successfully opened, parse out the path and filename.
            //
            sprintf(DriverPath, "%wZ", &FileName);
            AbsolutePath = TRUE;
        }

        //
        // Parse out the driver name from the driver path
        //
        NameStart = strrchr(DriverPath, '\\');
        if (NameStart != NULL) {
            strcpy(DriverName, NameStart+1);
            *NameStart = '\0';

        } else if (DriverPath[0]) {

            strcpy(DriverName, DriverPath);
            *DriverPath = '\0';

        } else {

            NextEntry = DriverEntry->Link.Flink;
            continue;
        }

        //
        // Ensure DriverPath is terminated with a '\\' if it's filled out.
        //
        if (DriverPath[0]) {

            strcat(DriverPath, "\\");
        }

        if (AbsolutePath) {

            //
            // There is only one entry if an absolute path is specified (in
            // this case we cannot do last known good).
            //
            PathSource = &LocalPathSet.Source[0];
            PathSource->DeviceId = DeviceId;
            PathSource->DeviceName = DriverDevice;
            PathSource->DirectoryPath = "\\";

            LocalPathSet.PathCount = 1;
            LocalPathSet.AliasName = NULL;
            strcpy(LocalPathSet.PathOffset, DriverPath);

        } else {

            //
            // It's relative. Copy over the DefaultPathSet array so we can
            // edit our own local copy.
            //
            *((PSPARSE_PATH_SET) &LocalPathSet) = *((PSPARSE_PATH_SET) DefaultPathSet);

            for(Index=0; Index < DefaultPathSet->PathCount; Index++) {

                LocalPathSet.Source[Index] = DefaultPathSet->Source[Index];
            }

            //
            // Now append our relative path to the PathOffset already present
            // in our local copy.
            //
            strcat(LocalPathSet.PathOffset, DriverPath);
        }

        if (Status == ESUCCESS) {
            Status = BlLoadDeviceDriver(&LocalPathSet,
                                        DriverName,
                                        NULL,
                                        LDRP_ENTRY_PROCESSED,
                                        &DriverEntry->LdrEntry);
        }

        NextEntry = DriverEntry->Link.Flink;

        if (Status != ESUCCESS) {

            //
            // Attempt to load driver failed, remove it from the list.
            //
            RemoveEntryList(&DriverEntry->Link);

            //
            // Check the Error Control of the failed driver.  If it
            // was critical, fail the boot.  If the driver
            // wasn't critical, keep going.
            //
            if (DriverNode->ErrorControl == CriticalError) {

                strcpy(BadFileName, DriverPath);
                strcat(BadFileName, DriverName);
                return(Status);
            }

        }
    }

    return(ESUCCESS);

}

BOOLEAN
BlRecoverHive(
              PVOID         RegistryBase,
              ULONG_PTR     LogBase
              )
/*++

Routine Description:

    Applies log from LogBase over the RegistryBase

Arguments:


Return Value:

    ESUCCESS is returned if the system hive was successfully loaded.
        Otherwise, an unsuccessful status is returned.

--*/
{
    PHBASE_BLOCK    BaseBlockHive;
    PHBASE_BLOCK    BaseBlockLog;
    BOOLEAN         RecoverData = FALSE;
    ULONG           FileOffset = HSECTOR_SIZE;
    ULONG           DirtyVectorSignature = 0;
    PUCHAR          FlatLog;
    PUCHAR          FlatReg;
    ULONG           VectorSize;
    ULONG           Length;
    ULONG           ClusterSize;
    ULONG           HeaderLength;
    RTL_BITMAP      BitMap;
    PULONG          Vector;
    ULONG           Current;
    ULONG           Start;
    ULONG           End;
    PUCHAR          MemoryBlock;
    PUCHAR          Dest;
    ULONG           i;


    BaseBlockHive = (PHBASE_BLOCK)RegistryBase;
    BaseBlockLog = (PHBASE_BLOCK)LogBase;

    FlatLog = (PUCHAR)LogBase;
    FlatReg = (PUCHAR)RegistryBase;
    ClusterSize = BaseBlockLog->Cluster * HSECTOR_SIZE;
    HeaderLength = ROUND_UP(HLOG_HEADER_SIZE, ClusterSize);
    FileOffset = ClusterSize;
    FileOffset = ROUND_UP(FileOffset, HeaderLength);

    if(HvpHeaderCheckSum(BaseBlockHive) != BaseBlockHive->CheckSum ) {
        //
        // recover header case
        //
        RtlCopyMemory((PVOID)BaseBlockHive,(PVOID)BaseBlockLog,ClusterSize);
        BaseBlockHive->Type = HFILE_TYPE_PRIMARY;
    } else {
        //
        // if not recoverheader (which implies recoverdata)
        //
        ASSERT( BaseBlockHive->Sequence1 != BaseBlockHive->Sequence2 );
    }

    DirtyVectorSignature = *((PULONG)(FlatLog + FileOffset));
    FileOffset += sizeof(DirtyVectorSignature);

    if (DirtyVectorSignature != HLOG_DV_SIGNATURE) {
        return FALSE;
    }

    Length = BaseBlockHive->Length;
    VectorSize = Length / HSECTOR_SIZE;
    Vector = (PULONG)(FlatLog + FileOffset);

    RtlInitializeBitMap(&BitMap, Vector, VectorSize);

    FileOffset += VectorSize / 8;
    FileOffset = ROUND_UP(FileOffset, ClusterSize);

    //
    // step through the diry map, and copy from the log to the flat hive
    //
    Current = 0;

    while (Current < VectorSize) {

        //
        // find next contiguous block of entries to read in
        //
        for (i = Current; i < VectorSize; i++) {
            if (RtlCheckBit(&BitMap, i) == 1) {
                break;
            }
        }
        Start = i;

        for ( ; i < VectorSize; i++) {
            if (RtlCheckBit(&BitMap, i) == 0) {
                break;
            }
        }
        End = i;
        Current = End;

        //
        // Start == number of 1st sector, End == number of Last sector + 1
        //
        Length = (End - Start) * HSECTOR_SIZE;

        if( 0 == Length ) {
            // no more dirty blocks.
            break;
        }
        MemoryBlock = (PUCHAR)(FlatLog + FileOffset);
        FileOffset += Length;

        ASSERT((FileOffset % ClusterSize) == 0);

        Dest = (PUCHAR)(FlatReg + HBLOCK_SIZE + Start * HSECTOR_SIZE);

        //
        // copy recovered data in the right locations inside the flat hive image
        //
        RtlCopyMemory(Dest,MemoryBlock, Length);
    }

    BaseBlockHive->Sequence2 = BaseBlockHive->Sequence1;
    BaseBlockHive->CheckSum = HvpHeaderCheckSum(BaseBlockHive);
    return TRUE;
}

ARC_STATUS
BlLoadAndInitSystemHive(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PCHAR HiveName,
    IN BOOLEAN IsAlternate,
    OUT PBOOLEAN RestartSetup,
    OUT PBOOLEAN LogPresent
    )

/*++

Routine Description:

    Loads the registry SYSTEM hive, verifies it is a valid hive file,
    and inits the relevant registry structures.  (particularly the HHIVE)

Arguments:

    DeviceId - Supplies the file id of the device the system tree is on.

    DeviceName - Supplies the name of the device the system tree is on.

    DirectoryPath - Supplies a pointer to the zero-terminated directory path
        of the root of the NT tree.

    HiveName - Supplies the name of the system hive (ie, "SYSTEM",
        "SYSTEM.ALT", or "SYSTEM.SAV").

    IsAlternate - Supplies whether or not the hive to be loaded is the
        alternate hive.

    RestartSetup - if the hive to be loaded is not the alternate, then
        this routine will check for a value of RestartSetup in the Setup
        key. If present and non-0, then this variable receives TRUE.
        Otherwise it receives FALSE.

Return Value:

    ESUCCESS is returned if the system hive was successfully loaded.
        Otherwise, an unsuccessful status is returned.

--*/

{
    ARC_STATUS  Status;
    ULONG_PTR   LogData;

    *RestartSetup = FALSE;
    *LogPresent = FALSE;

    BlClearToEndOfLine();

    Status = BlLoadSystemHive(DeviceId,
                              DeviceName,
                              DirectoryPath,
                              HiveName);
    if (Status!=ESUCCESS) {
        return(Status);
    }

    if (!BlInitializeHive(BlLoaderBlock->RegistryBase,
                          &BootHive,
                          IsAlternate)) {
        if( !IsAlternate ) {
            //
            // try to recover the hive
            //
            Status = BlLoadSystemHiveLog(DeviceId,
                                    DeviceName,
                                    DirectoryPath,
                                    "system.log",
                                    &LogData );
            if (Status!=ESUCCESS) {
                return(Status);
            }

            *LogPresent = TRUE;

            if( !BlRecoverHive( BlLoaderBlock->RegistryBase,
                                LogData ) ) {
                BlFreeDescriptor( (ULONG)((ULONG_PTR)LogData & (~KSEG0_BASE)) >> PAGE_SHIFT );
                return(EINVAL);
            }
            BlFreeDescriptor( (ULONG)((ULONG_PTR)LogData & (~KSEG0_BASE)) >> PAGE_SHIFT );

            //
            // we successfully recovered. Try setting up the hive again
            //
            if (!BlInitializeHive(BlLoaderBlock->RegistryBase,
                                  &BootHive,
                                  IsAlternate)) {
                return(EINVAL);
            }
            //
            // mark the hive as "recovered"
            //
            BootHive.Hive.BaseBlock->BootRecover = 1;
        } else {
            return(EINVAL);
        }
    } else {
        //
        // mark the hive as "no-recovered"
        //
        BootHive.Hive.BaseBlock->BootRecover = 0;
    }
    //
    // See whether we need to switch to the backup setup hive.
    //
    *RestartSetup = BlpCheckRestartSetup();

    return(ESUCCESS);
}

HCELL_INDEX
BlpDetermineControlSet(
    IN OUT BOOLEAN *LastKnownGoodBoot
    )

/*++

Routine Description:

    Determines the appropriate control set and static hardware profile.
    This routine ends the configuration prompt. If the user has hit a
    key, the configuration menu is displayed. If the user has not hit
    a key, but the default controlset specifies a non-zero timeout for
    the configuration menu, the configuration menu is displayed.

    If the configuration menu is displayed, further modifications to the
    control set and hardware profile can be made by the user. If not,
    the default hardware profile is selected.

Arguments:

    LastKnownGoodBoot - On input, LastKnownGood indicates whether LKG has been
                        selected. This value is updated to TRUE if the user
                        chooses LKG via the profile configuration menu.

Return Value:

    On success, HCELL_INDEX is control the set to boot from.
    On error, HCELL_NIL is returned and LastKnownGoodBoot is unchanged.

--*/

{
    BOOLEAN UseLastKnownGood;
    BOOLEAN ConfigMenu = FALSE;
    HCELL_INDEX ControlSet;
    HCELL_INDEX ProfileControl;
    UNICODE_STRING DefaultControlName;
    UNICODE_STRING LkgControlName;
    PUNICODE_STRING ControlName;
    BOOLEAN AutoSelect;
    ULONG ProfileTimeout = (ULONG)0;
    PCM_HARDWARE_PROFILE_LIST ProfileList;
    PCM_HARDWARE_PROFILE_ALIAS_LIST AliasList;
    PCM_HARDWARE_PROFILE SelectedProfile;
    DOCKING_STATION_INFO dockInfo = { 0, 0, 0, FW_DOCKINFO_DOCK_STATE_UNKNOWN };
    PCONFIGURATION_COMPONENT_DATA dockInfoData;
    ULONG flags;
    
#if DOCKINFO_VERBOSE
    _TUCHAR Buffer[1024];
    ULONG count;
    USHORT dkState;
    PTCHAR stateTxt;
#endif

    //
    // Preinit for failure
    //
    RtlInitUnicodeString(&DefaultControlName, L"Default");
    RtlInitUnicodeString(&LkgControlName, L"LastKnownGood");

    UseLastKnownGood = (*LastKnownGoodBoot);

    if (ForceLastKnownGood) {
        //
        // last known good was selected from the
        // advanced boot menu.
        // this code path is entered when the user
        // enters the advanced boot menu via the
        // main boot menu.
        //
        UseLastKnownGood = TRUE;
    }

    if( !CmpValidateSelect(&BootHive.Hive,
                            BootHive.Hive.BaseBlock->RootCell) ) {
        //
        // some of the essential values (Current,Default,Failed,LastKnownGood)
        // does not exist under \SYSTEM\Select key
        //
        return HCELL_NIL;
    }

do_it_again:
    //
    // Get the appropriate control set
    // and check the hardware profile timeout value.
    //
    if (UseLastKnownGood) {
        ControlName = &LkgControlName;
    } else {
        ControlName = &DefaultControlName;
    }
    ControlSet = CmpFindControlSet(&BootHive.Hive,
                                   BootHive.Hive.BaseBlock->RootCell,
                                   ControlName,
                                   &AutoSelect);
    if (ControlSet == HCELL_NIL) {
        return(HCELL_NIL);
    }

    //
    // Check the hardware profile configuration options to
    // determine the timeout value for the config menu.
    //
    ProfileList = NULL;
    AliasList = NULL;
    ProfileControl = CmpFindProfileOption(&BootHive.Hive,
                                          ControlSet,
                                          &ProfileList,
                                          &AliasList,
                                          &ProfileTimeout);

    //
    // Pull the Docking information from the hardware tree.
    //

    dockInfoData = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                            PeripheralClass,
                                            DockingInformation,
                                            NULL);

    if (NULL == dockInfoData) {
        BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
        BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_UNKNOWN;
        BlLoaderBlock->Extension->Profile.Capabilities = 0;
        BlLoaderBlock->Extension->Profile.DockID = 0;
        BlLoaderBlock->Extension->Profile.SerialNumber = 0;

    } else if (sizeof (dockInfo) <=
               dockInfoData->ComponentEntry.ConfigurationDataLength) {

        RtlCopyMemory (
            &dockInfo,
            (PUCHAR) (dockInfoData->ConfigurationData) + sizeof(CM_PARTIAL_RESOURCE_LIST),
            sizeof (dockInfo));

        BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_FAILURE;

        switch (dockInfo.ReturnCode) {
        case FW_DOCKINFO_SUCCESS:
            BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
            BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_DOCKED;
            BlLoaderBlock->Extension->Profile.Capabilities = dockInfo.Capabilities;
            BlLoaderBlock->Extension->Profile.DockID = dockInfo.DockID;
            BlLoaderBlock->Extension->Profile.SerialNumber = dockInfo.SerialNumber;
            break;

        case FW_DOCKINFO_SYSTEM_NOT_DOCKED:
            BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
            BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_UNDOCKED;
            BlLoaderBlock->Extension->Profile.Capabilities = dockInfo.Capabilities;
            BlLoaderBlock->Extension->Profile.DockID = dockInfo.DockID;
            BlLoaderBlock->Extension->Profile.SerialNumber = dockInfo.SerialNumber;
            break;

        case FW_DOCKINFO_DOCK_STATE_UNKNOWN:
            BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
            BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_UNKNOWN;
            BlLoaderBlock->Extension->Profile.Capabilities = dockInfo.Capabilities;
            BlLoaderBlock->Extension->Profile.DockID = dockInfo.DockID;
            BlLoaderBlock->Extension->Profile.SerialNumber = dockInfo.SerialNumber;
            break;

        case FW_DOCKINFO_FUNCTION_NOT_SUPPORTED:
        case FW_DOCKINFO_BIOS_NOT_CALLED:
            BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
        default:
            BlLoaderBlock->Extension->Profile.DockingState = HW_PROFILE_DOCKSTATE_UNSUPPORTED;
            BlLoaderBlock->Extension->Profile.Capabilities = dockInfo.Capabilities;
            BlLoaderBlock->Extension->Profile.DockID = dockInfo.DockID;
            BlLoaderBlock->Extension->Profile.SerialNumber = dockInfo.SerialNumber;
            break;
        }

    } else {
        BlLoaderBlock->Extension->Profile.Status = HW_PROFILE_STATUS_SUCCESS;
        BlLoaderBlock->Extension->Profile.Capabilities = 0;
        BlLoaderBlock->Extension->Profile.DockID = 0;
        BlLoaderBlock->Extension->Profile.SerialNumber = 0;
    }

#ifdef DOCKINFO_VERBOSE

    dkState = BlLoaderBlock->Extension->Profile.DockingState;

    if ((dkState & HW_PROFILE_DOCKSTATE_UNKNOWN) == HW_PROFILE_DOCKSTATE_UNKNOWN) {
        stateTxt = TEXT("Unknown");
    } else if (dkState & HW_PROFILE_DOCKSTATE_DOCKED) {
        stateTxt = TEXT("Docked");
    } else if (dkState & HW_PROFILE_DOCKSTATE_UNDOCKED) {
        stateTxt = TEXT("Undocked");
    } else {
        stateTxt = TEXT("Truely unknown");
    }

    _stprintf(Buffer,
            TEXT("Profile Docking: <%x, %s> := %x [%x, %x] \r\n\0"),
            BlLoaderBlock->Extension->Profile.Status,
            stateTxt,
            BlLoaderBlock->Extension->Profile.Capabilities,
            BlLoaderBlock->Extension->Profile.DockID,
            BlLoaderBlock->Extension->Profile.SerialNumber);

    ArcWrite(BlConsoleOutDeviceId, Buffer, _tcslen(Buffer)*sizeof(TCHAR), &count);

    _stprintf(Buffer, TEXT("press 'y' (lowercase) to continue...\r\n\0"));
    ArcWrite(BlConsoleOutDeviceId, Buffer, _tcslen(Buffer)*sizeof(TCHAR), &count);
    while(BlGetKey() != 'y') {
        //
        // Nothing
        //
    }
#endif

    //
    // Filter the list of Hardware Profiles to
    // eliminate profiles that should not be considered
    //
    if (NULL != ProfileList) {
        if (ProfileList->CurrentProfileCount > 0) {
            BlDockInfoFilterProfileList (ProfileList, AliasList);
        }
    }

    //
    // Now check to see whether the config menu should be displayed.
    // Display the menu if:
    //  - user has pressed a key OR
    //  - we are booting from LKG and AutoSelect is FALSE. OR
    //  - ProfileTimeout != 0
    //
    if (!BlEndConfigPrompt()) {
        if (!UseLastKnownGood && ForceLastKnownGood) {
            //
            // last known good was selected from the
            // advanced boot menu.
            // this code path is entered when the user
            // enters the advanced boot menu by pressing
            // F8 while the cinfiguration hives are preparing to load.
            //
            // the currentcontrolset has already been set to the
            // "default" control set, so go back and try this again to
            // load the "lastknowngood" controlset.
            //
            UseLastKnownGood = TRUE;
            
            goto do_it_again;
        }

        ConfigMenu = FALSE;
         
    } else {
        ConfigMenu = TRUE;
    }

    if  (ConfigMenu || ForceLastKnownGood ||
         (UseLastKnownGood && !AutoSelect) ||
         ((ProfileTimeout != 0) &&
         (ProfileList != NULL) &&
         (ProfileList->CurrentProfileCount > 1))) {
        //
        // Display the configuration menu.
        //
        BlRebootSystem = !BlConfigMenuPrompt(ProfileTimeout,
                                             &UseLastKnownGood,
                                             &ControlSet,
                                             &ProfileList,
                                             &AliasList,
                                             &SelectedProfile);

        if (BlRebootSystem) {
            REBOOT_PROCESSOR();
        }
        BlClearScreen();
    } else {    
        if ((ProfileControl != HCELL_NIL) &&
            (ProfileList != NULL)) {
            //
            // The system is configured to boot the default
            // profile directly. Since the returned profile
            // list is sorted by priority, the first entry in
            // the list is our default.
            //
            if (HW_PROFILE_STATUS_SUCCESS ==
                BlLoaderBlock->Extension->Profile.Status) {

                flags = (ProfileList->Profile[0].Flags);

                if (flags & CM_HP_FLAGS_PRISTINE) {
                    BlLoaderBlock->Extension->Profile.Status =
                        HW_PROFILE_STATUS_PRISTINE_MATCH;

                } else if (flags & CM_HP_FLAGS_TRUE_MATCH) {
                    BlLoaderBlock->Extension->Profile.Status =
                        HW_PROFILE_STATUS_TRUE_MATCH;

                } else if (flags & CM_HP_FLAGS_ALIASABLE) {
                    BlLoaderBlock->Extension->Profile.Status =
                        HW_PROFILE_STATUS_ALIAS_MATCH;
                }
            }

            CmpSetCurrentProfile(&BootHive.Hive,
                                 ControlSet,
                                 &ProfileList->Profile[0]);

        }
    } 

    //
    // Update the passed in parameter. We should only be doing this if we have
    // something real to return.
    //
    //ASSERT(ControlSet != HCELL_NIL);
    *LastKnownGoodBoot = UseLastKnownGood;

    return(ControlSet);
}


BOOLEAN
BlpCheckRestartSetup(
    VOID
    )

/*++

Routine Description:

    Examine the system hive loaded and described by BootHive, to see
    whether it contains a Setup key, and if so, whether that key has
    a "RestartSetup" value that is non-0.

Arguments:

    None.

Return Value:

    Boolean value indicating whether the above condition is satisfied.

--*/

{
    HCELL_INDEX KeyCell;
    HCELL_INDEX ValueCell;
    UNICODE_STRING UnicodeString;
    PCM_KEY_VALUE Value;
    PULONG Data;
    ULONG DataSize;

    //
    // Address the Setup key
    //
    RtlInitUnicodeString(&UnicodeString,L"Setup");
    KeyCell = CmpFindSubKeyByName(
                &BootHive.Hive,
                (PCM_KEY_NODE)HvGetCell(&BootHive.Hive,BootHive.Hive.BaseBlock->RootCell),
                &UnicodeString
                );

    if(KeyCell == HCELL_NIL) {
        return(FALSE);
    }

    //
    // Find RestartSetup value in Setup key
    //
    RtlInitUnicodeString(&UnicodeString,L"RestartSetup");
    ValueCell = CmpFindValueByName(
                    &BootHive.Hive,
                    (PCM_KEY_NODE)HvGetCell(&BootHive.Hive,KeyCell),
                    &UnicodeString
                    );

    if(ValueCell == HCELL_NIL) {
        return(FALSE);
    }

    //
    // Validate value and check.
    //
    Value = (PCM_KEY_VALUE)HvGetCell(&BootHive.Hive,ValueCell);
    if(Value->Type != REG_DWORD) {
        return(FALSE);
    }

    Data = (PULONG)(CmpIsHKeyValueSmall(DataSize,Value->DataLength)
                  ? (struct _CELL_DATA *)&Value->Data
                  : HvGetCell(&BootHive.Hive,Value->Data));

    if(DataSize != sizeof(ULONG)) {
        return(FALSE);
    }

    return((BOOLEAN)(*Data != 0));
}


#if defined(REMOTE_BOOT)
BOOLEAN
BlpQueryRemoteBootParameter(
    IN HCELL_INDEX ControlSet,
    IN PWSTR ValueName,
    IN ULONG ValueType,
    OUT PVOID ValueBuffer,
    IN ULONG ValueBufferLength
    )

/*++

Routine Description:

    Query a parameter from under Control\RemoteBoot.

Arguments:

    ControlSet - The index of the current control set.

    ValueName - The name of the value to query.

    ValueType - The expected type of the value.

    ValueBuffer - The location to return the data.

    ValueBufferLength - The length of the buffer.

Return Value:

    Boolean value indicating whether the data was read successfully.

--*/

{

    UNICODE_STRING Name;
    HCELL_INDEX Control;
    HCELL_INDEX RemoteBoot;
    HCELL_INDEX ValueCell;
    PCM_KEY_VALUE Value;
    ULONG RealSize;
    BOOLEAN ValueSmall;

    //
    // Find Services node
    //
    RtlInitUnicodeString(&Name, L"Control");
    Control = CmpFindSubKeyByName(
                  &BootHive.Hive,
                  (PCM_KEY_NODE)HvGetCell(&BootHive.Hive,ControlSet),
                  &Name);
    if (Control == HCELL_NIL) {
        return(FALSE);
    }

    //
    // Find RemoteBoot node
    //
    RtlInitUnicodeString(&Name, L"RemoteBoot");
    RemoteBoot = CmpFindSubKeyByName(
                     &BootHive.Hive,
                     (PCM_KEY_NODE)HvGetCell(&BootHive.Hive,Control),
                     &Name);
    if (RemoteBoot == HCELL_NIL) {
        return(FALSE);
    }

    //
    // Find value
    //
    RtlInitUnicodeString(&Name, ValueName);
    ValueCell = CmpFindValueByName(
                    &BootHive.Hive,
                    (PCM_KEY_NODE)HvGetCell(&BootHive.Hive,RemoteBoot),
                    &Name);
    if (ValueCell == HCELL_NIL) {
        return(FALSE);
    }

    Value = (PCM_KEY_VALUE)HvGetCell(&BootHive.Hive, ValueCell);

    if (Value->Type != ValueType) {
        return(FALSE);
    }

    //
    // This determines if the value is small (stored right in Value)
    // or not, and also returns the real size of it.
    //

    ValueSmall = CmpIsHKeyValueSmall(RealSize,Value->DataLength);

    if (RealSize > ValueBufferLength) {
        return(FALSE);
    }

    RtlMoveMemory(
        ValueBuffer,
        (ValueSmall ?
          (struct _CELL_DATA *)&Value->Data :
          HvGetCell(&BootHive.Hive,Value->Data)),
        RealSize);

    return(TRUE);
}
#endif // defined(REMOTE_BOOT)


PTCHAR
BlScanRegistry(
    IN PWSTR BootFileSystemPath,
    IN OUT BOOLEAN *LastKnownGoodBoot,
    OUT PLIST_ENTRY BootDriverListHead,
    OUT PUNICODE_STRING AnsiCodepage,
    OUT PUNICODE_STRING OemCodepage,
    OUT PUNICODE_STRING LanguageTable,
    OUT PUNICODE_STRING OemHalFont,
#ifdef _WANT_MACHINE_IDENTIFICATION
    OUT PUNICODE_STRING Biosinfo,
#endif
    OUT PSETUP_LOADER_BLOCK SetupLoaderBlock,
    OUT BOOLEAN *ServerHive
    )

/*++

Routine Description:

    Scans the SYSTEM hive, determines the control set and static hardware
    profile (with appropriate input from the user) and finally
    computes the list of boot drivers to be loaded.

Arguments:

    BootFileSystemPath - Supplies the name of the image the filesystem
        for the boot volume was read from.  The last entry in
        BootDriverListHead will refer to this file, and to the registry
        key entry that controls it.

    LastKnownGoodBoot - On input, LastKnownGood indicates whether LKG has been
                        selected. This value is updated to TRUE if the user
                        chooses LKG via the profile configuration menu.

    BootDriverListHead - Receives a pointer to the first element of the
        list of boot drivers.  Each element in this singly linked list will
        provide the loader with two paths.  The first is the path of the
        file that contains the driver to load, the second is the path of
        the registry key that controls that driver.  Both will be passed
        to the system via the loader heap.

    AnsiCodepage - Receives the name of the ANSI codepage data file

    OemCodepage - Receives the name of the OEM codepage data file

    Language - Receives the name of the language case table data file

    OemHalfont - receives the name of the OEM font to be used by the HAL.

    SetupLoaderBlock - if non-NULL, used to return information about the
        net boot card.

    ServerHive - Returns TRUE if this is a server hive, else FALSE.

Return Value:

    NULL    if all is well.
    NON-NULL if the hive is corrupt or inconsistent.  Return value is a
        pointer to a string that describes what is wrong. On error LastKnownGood
        is unchanged.

--*/

{
    HCELL_INDEX     ControlSet;
    UNICODE_STRING  ControlName;
    BOOLEAN         AutoSelect;
    BOOLEAN         KeepGoing;
    UNICODE_STRING  TmpName;
    HCELL_INDEX     Control;
    HCELL_INDEX     ProductOptions;
    HCELL_INDEX     ValueCell;
    PCM_KEY_VALUE   Value;
    ULONG           RealSize;
    BOOLEAN         ValueSmall;
    PWCHAR          CellString;
    BOOLEAN         UsingLastKnownGood;
#ifdef _WANT_MACHINE_IDENTIFICATION
    UNICODE_STRING  regDate;
    CHAR            date[9];
    ANSI_STRING     ansiString;
    UNICODE_STRING  biosDate;
    WCHAR           buffer[9];
    BOOLEAN         biosDateChanged;
#endif

    //
    // Preinit.
    //
    UsingLastKnownGood = *LastKnownGoodBoot;

    //
    // Get the appropriate control set.
    //
    ControlSet = BlpDetermineControlSet(&UsingLastKnownGood);

    if (ControlSet == HCELL_NIL) {
        return(TEXT("CmpFindControlSet"));
    }

    if (!CmpFindNLSData(&BootHive.Hive,
                        ControlSet,
                        AnsiCodepage,
                        OemCodepage,
                        LanguageTable,
                        OemHalFont)) {
        return(TEXT("CmpFindNLSData"));
    }

    InitializeListHead(BootDriverListHead);
    if (!CmpFindDrivers(&BootHive.Hive,
                        ControlSet,
                        BootLoad,
                        BootFileSystemPath,
                        BootDriverListHead)) {
        return(TEXT("CmpFindDriver"));
    }

    if (!CmpSortDriverList(&BootHive.Hive,
                           ControlSet,
                           BootDriverListHead)) {
        return(TEXT("Missing or invalid Control\\ServiceGroupOrder\\List registry value"));
    }

    if (!CmpResolveDriverDependencies(BootDriverListHead)) {
        return(TEXT("CmpResolveDriverDependencies"));
    }

    if (ServerHive != NULL) {

        *ServerHive = FALSE;

        //
        // Find Control node
        //
        RtlInitUnicodeString(&TmpName, L"Control");

        Control = CmpFindSubKeyByName(&BootHive.Hive,
                                      (PCM_KEY_NODE)HvGetCell(&BootHive.Hive, ControlSet),
                                      &TmpName
                                     );
        if (Control == HCELL_NIL) {
            return(TEXT("Missing Control key"));
        }

        //
        // Find ProductOptions node
        //
        RtlInitUnicodeString(&TmpName, L"ProductOptions");
        ProductOptions = CmpFindSubKeyByName(&BootHive.Hive,
                                             (PCM_KEY_NODE)HvGetCell(&BootHive.Hive,Control),
                                             &TmpName
                                            );
        if (ProductOptions == HCELL_NIL) {
            return(TEXT("Missing ProductOptions key"));
        }

        //
        // Find value
        //
        RtlInitUnicodeString(&TmpName, L"ProductType");
        ValueCell = CmpFindValueByName(&BootHive.Hive,
                                       (PCM_KEY_NODE)HvGetCell(&BootHive.Hive, ProductOptions),
                                       &TmpName
                                      );

        if (ValueCell == HCELL_NIL) {
            return(TEXT("Missing ProductType value"));
        }

        Value = (PCM_KEY_VALUE)HvGetCell(&BootHive.Hive, ValueCell);

        if (Value->Type != REG_SZ) {
            return(TEXT("Bad ProductType value"));
        }

        //
        // This determines if the value is small (stored right in Value)
        // or not, and also returns the real size of it.
        //
        CellString = (PWCHAR)(CmpIsHKeyValueSmall(RealSize, Value->DataLength) ?
                                 (struct _CELL_DATA *)&Value->Data :
                                 HvGetCell(&BootHive.Hive, Value->Data)
                             );

        //
        // Now compare if this is a server hive or not.
        // The proper way to check this is to check the string against
        // the "professional" type 'WinNT'.  If it's not professional,
        // it must be a server.  (There are multiple strings for different
        // server flavours.)
        //
        *ServerHive = (_wcsicmp(L"WinNT", CellString) != 0);
    }

#if defined(REMOTE_BOOT)
    if (SetupLoaderBlock != NULL) {

        ULONG EnableIpSecurity;

        if (BlpQueryRemoteBootParameter(
                ControlSet,
                L"EnableIpSecurity",
                REG_DWORD,
                &EnableIpSecurity,
                sizeof(EnableIpSecurity))) {
            if (EnableIpSecurity != 0) {
                SetupLoaderBlock->Flags |= SETUPBLK_FLAGS_IPSEC_ENABLED;
            }
        }

        if (BlpQueryRemoteBootParameter(
                ControlSet,
                L"NetCardInfo",
                REG_BINARY,
                SetupLoaderBlock->NetbootCardInfo,
                SetupLoaderBlock->NetbootCardInfoLength)) {

            if (!BlpQueryRemoteBootParameter(
                     ControlSet,
                     L"HardwareId",
                     REG_SZ,
                     SetupLoaderBlock->NetbootCardHardwareId,
                     sizeof(SetupLoaderBlock->NetbootCardHardwareId))) {
                SetupLoaderBlock->NetbootCardHardwareId[0] = L'\0';
            }

            if (!BlpQueryRemoteBootParameter(
                     ControlSet,
                     L"DriverName",
                     REG_SZ,
                     SetupLoaderBlock->NetbootCardDriverName,
                     sizeof(SetupLoaderBlock->NetbootCardDriverName))) {
                SetupLoaderBlock->NetbootCardDriverName[0] = L'\0';
            }

            if (!BlpQueryRemoteBootParameter(
                     ControlSet,
                     L"ServiceName",
                     REG_SZ,
                     SetupLoaderBlock->NetbootCardServiceName,
                     sizeof(SetupLoaderBlock->NetbootCardServiceName))) {
                SetupLoaderBlock->NetbootCardServiceName[0] = L'\0';
            }
        }
    }
#endif // defined(REMOTE_BOOT)

#ifdef _WANT_MACHINE_IDENTIFICATION

    biosDateChanged = TRUE;
    if (CmpGetBiosDateFromRegistry(&BootHive.Hive, ControlSet, &regDate)) {

        //
        // Read the date from the BIOS ROM.
        //        
        memcpy(date, (PVOID)0xffff5, 8);
        date[8] = '\0';

        //
        // Convert the date into unicode string.
        //

        ansiString.Buffer = date;
        ansiString.Length = (USHORT) strlen(date);
        ansiString.MaximumLength = ansiString.Length + 1;
        biosDate.Buffer = buffer;
        biosDate.MaximumLength = (ansiString.Length << 1) + sizeof(UNICODE_NULL);
        RtlAnsiStringToUnicodeString(&biosDate, &ansiString, FALSE);

        //
        // Check if the dates are different.
        //

        if (RtlCompareUnicodeString(&biosDate, &regDate, FALSE) == 0) {

            biosDateChanged = FALSE;
        }
    }

    Biosinfo->Length = 0;
    if (biosDateChanged) {

        CmpGetBiosinfoFileNameFromRegistry(&BootHive.Hive, ControlSet, Biosinfo);
    }

#endif // defined(_WANT_MACHINE_IDENTIFICATION)

    *LastKnownGoodBoot = UsingLastKnownGood;
    return( NULL );
}


ARC_STATUS
BlAddToBootDriverList(
    IN PLIST_ENTRY BootDriverListHead,
    IN PWSTR DriverName,
    IN PWSTR Name,
    IN PWSTR Group,
    IN ULONG Tag,
    IN ULONG ErrorControl,
    IN BOOLEAN InsertAtHead
    )

/*++

Routine Description:

    Adds a single driver to the boot driver list. The list
    is NOT re-sorted.

Arguments:

    BootDriverListHead - Receives a pointer to the first element of the
        list of boot drivers.  Each element in this singly linked list will
        provide the loader with two paths.  The first is the path of the
        file that contains the driver to load, the second is the path of
        the registry key that controls that driver.  Both will be passed
        to the system via the loader heap.

    DriverName - The name of the driver. This will be stored with
        \system32\drivers on the front.

    Name - The service name of the driver. Typically will be DriverName
        without the ".sys".

    Group - The group this driver is in.

    Tag - The tag value within the group for this driver.

    ErrorControl - The error control value for this driver.

    InsertAtHead - Should this driver be inserted at the head of the list, otw tail.

Return Value:

    ESUCCESS if the driver is successfully inserted.
    ENOMEM if there is an allocation failure.

--*/

{
    PBOOT_DRIVER_NODE DriverNode;
    PBOOT_DRIVER_LIST_ENTRY DriverListEntry;
    USHORT Length;

    DriverNode = BlpHiveAllocate(sizeof(BOOT_DRIVER_NODE),FALSE,0);
    if (DriverNode == FALSE) {
        return ENOMEM;
    }

    DriverListEntry = &DriverNode->ListEntry;

    //
    // FilePath
    //

    Length = sizeof(L"System32\\Drivers\\") + (wcslen(DriverName) * sizeof(WCHAR));
    DriverListEntry->FilePath.Buffer = BlpHiveAllocate(Length,FALSE,0);
    if (DriverListEntry->FilePath.Buffer == NULL) {
        return ENOMEM;
    }
    DriverListEntry->FilePath.Length = 0;
    DriverListEntry->FilePath.MaximumLength = Length;
    RtlAppendUnicodeToString(&DriverListEntry->FilePath, L"System32\\Drivers\\");
    RtlAppendUnicodeToString(&DriverListEntry->FilePath, DriverName);

    //
    // Registry Path
    //

    Length = sizeof(L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\") + (wcslen(Name) * sizeof(WCHAR));
    DriverListEntry->RegistryPath.Buffer = BlpHiveAllocate(Length,FALSE,0);
    if (DriverListEntry->RegistryPath.Buffer == NULL) {
        return ENOMEM;
    }
    DriverListEntry->RegistryPath.Length = 0;
    DriverListEntry->RegistryPath.MaximumLength = Length;
    RtlAppendUnicodeToString(&DriverListEntry->RegistryPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\");
    RtlAppendUnicodeToString(&DriverListEntry->RegistryPath, Name);

    //
    // Group
    //

    Length = (wcslen(Group) + 1) * sizeof(WCHAR);
    DriverNode->Group.Buffer = BlpHiveAllocate(Length,FALSE,0);
    if (DriverNode->Group.Buffer == NULL) {
        return ENOMEM;
    }
    DriverNode->Group.Length = 0;
    DriverNode->Group.MaximumLength = Length;
    RtlAppendUnicodeToString(&DriverNode->Group, Group);

    //
    // Name
    //

    Length = (wcslen(Name) + 1) * sizeof(WCHAR);
    DriverNode->Name.Buffer = BlpHiveAllocate(Length,FALSE,0);
    if (DriverNode->Name.Buffer == NULL) {
        return ENOMEM;
    }
    DriverNode->Name.Length = 0;
    DriverNode->Name.MaximumLength = Length;
    RtlAppendUnicodeToString(&DriverNode->Name, Name);

    //
    // Tag/ErrorControl
    //

    DriverNode->Tag = Tag;
    DriverNode->ErrorControl = ErrorControl;

    if (InsertAtHead) {
        InsertHeadList(BootDriverListHead, &DriverListEntry->Link);
    } else {
        InsertTailList(BootDriverListHead, &DriverListEntry->Link);
    }

    return ESUCCESS;

}

#define HFILE_TYPE_ALTERNATE     1   // alternate, in order for boot to be able to boot downlevel OSes

BOOLEAN
BlInitializeHive(
    IN PVOID HiveImage,
    IN PCMHIVE Hive,
    IN BOOLEAN IsAlternate
    )

/*++

Routine Description:

    Initializes the hive data structure based on the in-memory hive image.

Arguments:

    HiveImage - Supplies a pointer to the in-memory hive image.

    Hive - Supplies the CMHIVE structure to be filled in.

    IsAlternate - Supplies whether or not the hive is the alternate hive,
        which indicates that the primary hive is corrupt and should be
        rewritten by the system.

Return Value:

    TRUE - Hive successfully initialized.

    FALSE - Hive is corrupt.

--*/
{
    NTSTATUS    status;
    ULONG       HiveCheckCode;

    status = HvInitializeHive(
                &Hive->Hive,
                HINIT_MEMORY_INPLACE,
                FALSE,
                IsAlternate ? HFILE_TYPE_ALTERNATE : HFILE_TYPE_PRIMARY,
                HiveImage,
                (PALLOCATE_ROUTINE)BlpHiveAllocate,     // allocate
                NULL,                                   // free
                NULL,                                   // setsize
                NULL,                                   // write
                NULL,                                   // read
                NULL,                                   // flush
                1,                                      // cluster
                NULL
                );

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    HiveCheckCode = CmCheckRegistry(Hive,CM_CHECK_REGISTRY_LOADER_CLEAN|CM_CHECK_REGISTRY_HIVE_CHECK);
    if (HiveCheckCode != 0) {
        return(FALSE);
    } else {
        return TRUE;
    }

}


PVOID
BlpHiveAllocate(
    IN ULONG    Length,
    IN BOOLEAN  UseForIo,
    IN ULONG    Tag
    )

/*++

Routine Description:

    Wrapper for hive allocation calls.  It just calls BlAllocateHeap.

Arguments:

    Length - Supplies the size of block required in bytes.

    UseForIo - Supplies whether or not the memory is to be used for I/O
               (this is currently ignored)

Return Value:

    address of the block of memory
        or
    NULL if no memory available

--*/

{
    return(BlAllocateHeap(Length));

}


NTSTATUS
HvLoadHive(
    PHHIVE  Hive
    )
{
    UNREFERENCED_PARAMETER(Hive);
    return(STATUS_SUCCESS);
}

NTSTATUS
HvMapHive(
    PHHIVE  Hive
    )
{
    UNREFERENCED_PARAMETER(Hive);
    return(STATUS_SUCCESS);
}

NTSTATUS
HvpAdjustHiveFreeDisplay(
    IN PHHIVE           Hive,
    IN ULONG            HiveLength,
    IN HSTORAGE_TYPE    Type
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(HiveLength);
    UNREFERENCED_PARAMETER(Type);
    return(STATUS_SUCCESS);
}

VOID
HvpAddFreeCellHint(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    ULONG           Index,
    HSTORAGE_TYPE   Type
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(Cell);
    UNREFERENCED_PARAMETER(Index);
    UNREFERENCED_PARAMETER(Type);
}

VOID
HvpRemoveFreeCellHint(
    PHHIVE          Hive,
    HCELL_INDEX     Cell,
    ULONG           Index,
    HSTORAGE_TYPE   Type
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(Cell);
    UNREFERENCED_PARAMETER(Index);
    UNREFERENCED_PARAMETER(Type);
}

HCELL_INDEX
HvpFindFreeCell(
    PHHIVE          Hive,
    ULONG           Index,
    ULONG           NewSize,
    HSTORAGE_TYPE   Type,
    HCELL_INDEX     Vicinity
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(Index);
    UNREFERENCED_PARAMETER(Type);
    UNREFERENCED_PARAMETER(NewSize);
    UNREFERENCED_PARAMETER(Vicinity);
    return HCELL_NIL;
}

VOID
CmpTouchView(
    IN PCMHIVE              CmHive,
    IN PCM_VIEW_OF_FILE     CmView,
    IN ULONG                Cell
            )
{
    UNREFERENCED_PARAMETER(CmHive);
    UNREFERENCED_PARAMETER(CmView);
    UNREFERENCED_PARAMETER(Cell);
}

NTSTATUS
CmpMapThisBin(
                PCMHIVE         CmHive,
                HCELL_INDEX     Cell,
                BOOLEAN         Touch
              )
{
    UNREFERENCED_PARAMETER(CmHive);
    UNREFERENCED_PARAMETER(Cell);
    UNREFERENCED_PARAMETER(Touch);
    return(STATUS_SUCCESS);
}

/*
NTSTATUS
CmpMapCmView(
    IN  PCMHIVE             CmHive,
    IN  ULONG               FileOffset,
    OUT PCM_VIEW_OF_FILE    *CmView
    )
{
    UNREFERENCED_PARAMETER(CmHive);
    UNREFERENCED_PARAMETER(FileOffset);
    UNREFERENCED_PARAMETER(CmView);
    return(STATUS_SUCCESS);
}

VOID
CmpPinCmView (
        IN  PCMHIVE             CmHive,
        PCM_VIEW_OF_FILE        CmView
                             )
{
    UNREFERENCED_PARAMETER(CmHive);
    UNREFERENCED_PARAMETER(CmView);
}

VOID
CmpUnPinCmView (
        IN  PCMHIVE             CmHive,
        IN  PCM_VIEW_OF_FILE    CmView,
        IN  BOOLEAN             SetClean
                             )
{
    UNREFERENCED_PARAMETER(CmHive);
    UNREFERENCED_PARAMETER(CmView);
    UNREFERENCED_PARAMETER(SetClean);
}

VOID
CmpLazyFlush(
    VOID
    )
{
}
*/

/*
NTSTATUS
CmpDoFileSetSize(
    PHHIVE      Hive,
    ULONG       FileType,
    ULONG       FileSize
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(FileType);
    UNREFERENCED_PARAMETER(FileSize);
    return(STATUS_SUCCESS);
}
*/

BOOLEAN
HvMarkCellDirty(
    PHHIVE      Hive,
    HCELL_INDEX Cell
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(Cell);
    return(TRUE);
}

BOOLEAN
HvMarkDirty(
    PHHIVE      Hive,
    HCELL_INDEX Start,
    ULONG       Length,
    BOOLEAN     DirtyAndPin
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(Start);
    UNREFERENCED_PARAMETER(Length);
    UNREFERENCED_PARAMETER(DirtyAndPin);
    return(TRUE);
}


BOOLEAN
HvpDoWriteHive(
    PHHIVE          Hive,
    ULONG           FileType
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(FileType);
    return(TRUE);
}

BOOLEAN
HvpGrowLog1(
    PHHIVE  Hive,
    ULONG   Count
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(Count);
    return(TRUE);
}

BOOLEAN
HvpGrowLog2(
    PHHIVE  Hive,
    ULONG   Size
    )
{
    UNREFERENCED_PARAMETER(Hive);
    UNREFERENCED_PARAMETER(Size);
    return(TRUE);
}

BOOLEAN
CmpValidateHiveSecurityDescriptors(
    IN PHHIVE Hive,
    OUT PBOOLEAN ResetSD
    )
{
    UNREFERENCED_PARAMETER(Hive);
    return(TRUE);
}

BOOLEAN
CmpTestRegistryLock()
{
    return TRUE;
}

BOOLEAN
CmpTestRegistryLockExclusive()
{
    return TRUE;
}


BOOLEAN
HvIsBinDirty(
IN PHHIVE Hive,
IN HCELL_INDEX Cell
)
{
    return(FALSE);
}
PHBIN
HvpAddBin(
    IN PHHIVE  Hive,
    IN ULONG   NewSize,
    IN HSTORAGE_TYPE   Type
    )
{
    return(NULL);
}
VOID
CmpReleaseGlobalQuota(
    IN ULONG    Size
    )
{
}


#if DOCKINFO_VERBOSE
VOID
BlDiagDisplayProfileList(
    IN PCM_HARDWARE_PROFILE_LIST ProfileList,
    IN PCM_HARDWARE_PROFILE_ALIAS_LIST AliasList,
    IN BOOLEAN WaitForUserInput
)
/*++

Routine Description:

    This is a diagnostic function only!

    Display hardware profile list on console, optionally wait for user
    input before proceeding.

Arguments:

    ProfileList - Supplies a list of hardware profiles to display

    WaitForUserInput - Prompt user to hit a key ('y') to continue, and wait
                       for user's input if TRUE. Don't wait if FALSE.

Return Value:

    None.

--*/
{
    TCHAR  Buffer[200];
    TCHAR  StrFriendlyName[30];
    PTCHAR AliasType [] = {
        TEXT("NotAliasable"), // 0
        TEXT("Aliasable   "), // 1
        TEXT("True Match  "), // 2
        TEXT("True & Alias"), // 3
        TEXT("Pristine    "), // 4
        TEXT("Pris & Alias"), // 5
        TEXT("Pris & True "), // 6
        TEXT("P & A & T   ")  // 7
    };

    ULONG Count;
    ULONG i;

    // display header
    _stprintf(Buffer, TEXT("Profiles: <PrefOrd, Id - Aliased FriendlyName>\r\n\0"));
    ArcWrite(BlConsoleOutDeviceId, Buffer, _tcslen(Buffer)*sizeof(TCHAR), &Count);


    // for each hardware profile
    for (i = 0; i < ProfileList->CurrentProfileCount; ++i) {
#ifdef UNICODE
        wcsncpy( 
            StrFriendlyName, 
            ProfileList->Profile[i].FriendlyName, 
            ProfileList->Profile[i].NameLength, 
            );
        StrFriendlyName[29] = L'\0';
        StrFriendlyName[ProfileList->Profile[i].NameLength] = L'\0';
#else

        // copy and convert unicode fields to ascii for output
        RtlUnicodeToMultiByteN(StrFriendlyName,
                         sizeof(StrFriendlyName),
                         &Count,
                         ProfileList->Profile[i].FriendlyName,
                         ProfileList->Profile[i].NameLength);
        StrFriendlyName[Count] = '\0';
#endif

        // display info for current profile
        _stprintf(Buffer, 
                TEXT("          <%2ld> %2ld - %s \"%s\"\r\n\0"),
                ProfileList->Profile[i].PreferenceOrder,
                ProfileList->Profile[i].Id,
                AliasType[ ProfileList->Profile[i].Flags ],
                StrFriendlyName);
        ArcWrite(
            BlConsoleOutDeviceId, 
            Buffer, 
            _tcslen(Buffer)*sizeof(TCHAR), 
            &Count );
    }

    // display header
    _stprintf(Buffer, TEXT("Aliases: <Profile #> DockState [DockID, SerialNumber]\r\n\0"));
    ArcWrite(BlConsoleOutDeviceId, Buffer, _tcslen(Buffer)*sizeof(TCHAR), &Count);

    if (AliasList) {
        for (i = 0; i < AliasList->CurrentAliasCount; i++) {
            _stprintf(Buffer, TEXT("         <%2ld> %x [%x, %x]\r\n\0"),
                    AliasList->Alias[i].ProfileNumber,
                    AliasList->Alias[i].DockState,
                    AliasList->Alias[i].DockID,
                    AliasList->Alias[i].SerialNumber);
            ArcWrite(BlConsoleOutDeviceId, Buffer, _tcslen(Buffer)*sizeof(TCHAR), &Count);
        }
    }

    if(WaitForUserInput) {
        // display prompt and wait for user input to continue
        _stprintf(Buffer, TEXT("press 'y' (lowercase) to continue...\r\n\0"));
        ArcWrite(BlConsoleOutDeviceId, Buffer, _tcslen(Buffer)*sizeof(TCHAR), &Count);
        while (BlGetKey() != 'y') {
            //
            // nothing
            //
        }
    }
}
#endif


VOID
BlDockInfoFilterDockingState(
    IN OUT PCM_HARDWARE_PROFILE_LIST ProfileList,
    IN OUT PCM_HARDWARE_PROFILE_ALIAS_LIST AliasList,
    IN ULONG DockingState,
    IN ULONG DockID,
    IN ULONG SerialNumber
)

/*++

Routine Description:

    Discard all hardware profiles that do not have the
    DOCKINFO_UNDOCKED bit set in the DockState field

Arguments:

    ProfileList - Supplies a list of hardware profiles.
                  Returns a list containing a subset of the supplied
                  hardware profiles.

Return Value:

    None.

--*/
{
    ULONG i = 0;
    ULONG j;
    ULONG len;
    ULONG mask = HW_PROFILE_DOCKSTATE_UNDOCKED | HW_PROFILE_DOCKSTATE_DOCKED;
    BOOLEAN trueMatch = FALSE;
#if DOCKINFO_VERBOSE
    TCHAR   buffer[200];
    ULONG   count;
#endif

    if (AliasList) {
        while (i < AliasList->CurrentAliasCount) {
            if (((AliasList->Alias[i].DockState & mask) != 0) &&
                ((AliasList->Alias[i].DockState & mask) != DockingState)) {

                //
                // This alias claims to be docked or undocked, but does not
                // match the current state.  Therefore skip it.
                //
                ;

            } else if ((AliasList->Alias[i].DockID == DockID) &&
                       (AliasList->Alias[i].SerialNumber == SerialNumber)) {

                //
                // This alias matches so mark the profile.
                //
                for (j = 0; j < ProfileList->CurrentProfileCount; j++) {
                    if (ProfileList->Profile[j].Id ==
                        AliasList->Alias[i].ProfileNumber) {

                        ProfileList->Profile[j].Flags =
                            CM_HP_FLAGS_TRUE_MATCH;

                        trueMatch = TRUE;
                    }
                }
            }
            i++;
        }
    }

#if DOCKINFO_VERBOSE
    _stprintf(buffer, TEXT("Filtering Profiles ...\r\n\0"));
    ArcWrite(BlConsoleOutDeviceId, buffer, _tcslen(buffer)*sizeof(TCHAR), &count);
#endif

    i = 0;
    while (i < ProfileList->CurrentProfileCount) {

        if ((ProfileList->Profile[i].Flags & CM_HP_FLAGS_PRISTINE) &&
            !trueMatch &&
            AliasList) {
            //
            // Leave this one in the list
            //
            i++;
            continue;

        } else if (ProfileList->Profile[i].Flags & CM_HP_FLAGS_ALIASABLE) {
            //
            // Leave this one in the list
            //
            i++;
            continue;

        } else if (ProfileList->Profile[i].Flags & CM_HP_FLAGS_TRUE_MATCH) {
            //
            // Leave this one in the list
            //
            i++;
            continue;
        }

        //
        // discard this profile by (1) shifting remaining profiles in
        //   array to fill in the space of this discarded profile
        //   and (2) decrementing profile count
        //
        len = ProfileList->CurrentProfileCount - i - 1;
        if (0 < len) {
            RtlMoveMemory(&ProfileList->Profile[i],
                          &ProfileList->Profile[i+1],
                          sizeof(CM_HARDWARE_PROFILE) * len);
        }

        --ProfileList->CurrentProfileCount;
    }
}


VOID
BlDockInfoFilterProfileList(
    IN OUT PCM_HARDWARE_PROFILE_LIST ProfileList,
    IN OUT PCM_HARDWARE_PROFILE_ALIAS_LIST AliasList
)

/*++

Routine Description:

    Filters hardware profile list by discarding hardware profiles that
    do not match the docking station information returned by NTDETECT.


Arguments:

    ProfileList - Supplies a list of hardware profiles.
                - Returns a list containing a subset of the supplied
                    hardware profiles.

Return Value:

    None.

--*/

{
#if DOCKINFO_VERBOSE
     // display ProfileList prior to filtering
    BlDiagDisplayProfileList(ProfileList, AliasList, TRUE);
#endif

    if (1 == ProfileList->CurrentProfileCount) {
        if (ProfileList->Profile[0].Flags & CM_HP_FLAGS_PRISTINE) {
            //
            // Nothing to filter.
            //
            return;
        }
    }
    BlDockInfoFilterDockingState (
                ProfileList,
                AliasList,
                BlLoaderBlock->Extension->Profile.DockingState,
                BlLoaderBlock->Extension->Profile.DockID,
                BlLoaderBlock->Extension->Profile.SerialNumber);

#if DOCKINFO_VERBOSE
     // display ProfileList prior to filtering
    BlDiagDisplayProfileList(ProfileList, AliasList, TRUE);
#endif

}

int
BlIsReturnToOSChoicesValid(
    VOID
    )
/*++

Routine Description:

    Indicates whether the "Return to OS Choices Menu" should
    be shown as advanced boot option or not.

Arguments:

    None


Return Value:

    1 if yes otherwise 0.

--*/
{
    return BlShowReturnToOSChoices;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\da\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\cs\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

TARGETNAME=bldr
TARGETPATH=obj
TARGETTYPE=LIBRARY

!IF "$(BUILD_DEBUG_LOADER)" != ""
DBG_LDR=_dbg
!ELSE
DBG_LDR=
!ENDIF

!include $(PROJECT_ROOT)\boot\loader$(DBG_LDR).inc


INCLUDES=\
    $(PROJECT_ROOT)\boot\inc;\
    $(PROJECT_ROOT)\ntos\inc;\
    $(PROJECT_ROOT)\ntos\config;\
    $(PROJECT_ROOT)\fs\fastfat;\
    $(SDKTOOLS_INC_PATH);\
    $(O)

MSC_WARNING_LEVEL=/W3 /WX

!IF $(IA64)
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE -DEFI
!ELSE
C_DEFINES=$(C_DEFINES) -D_WANT_MACHINE_IDENTIFICATION
!endif



SOURCES=..\osloader.c \
        ..\dcmpstub.c \
        ..\regboot.c  \
        ..\hiber.c    \
        ..\advboot.c  \
        ..\bootstat.c \
        ..\netboot.c  \
        $(O)\msg.mc   \
        ..\osloader.rc

PASS0_SOURCEDIR=$(O)
PASS0_HEADERDIR=$(O)
NTTARGETFILE0=$(O)\msg.mc

!IF $(386)
MC_FLAGS=-A
!ENDIF

!IF "$(NOLINK)" != "1"

!IF $(ALPHA) || $(AXP64)

NTTARGETFILES=$(O)\osloader$(DBG_LDR).exe

!ELSEIF $(386)

! if "$(ALT_PROJECT)" == "ArcI386"
NTTARGETFILES=$(O)\arcldr$(DBG_LDR).exe
! else
NTTARGETFILES=$(O)\osloader$(DBG_LDR)$(NTD_LDR).exe $(O)\ntldr$(DBG_LDR) $(O)\osloader$(DBG_LDR).ntd
! endif

!elseif $(IA64)

NTTARGETFILES=$(O)\ia64ldr$(DBG_LDR).efi

!endif

MISCFILES=$(NTTARGETFILES)

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\osloader.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    osloader.c

Abstract:

    This module contains the code that implements the NT operating system
    loader.

Author:

    David N. Cutler (davec) 10-May-1991

Revision History:

--*/

#include "bldr.h"
#include "bldrint.h"
#include "ctype.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "msg.h"
#include "cmp.h"
#include "ramdisk.h"

#include "cpyuchr.h"
#include "fat.h"

#include <netboot.h>
#include <ntverp.h>
#include <ntiodump.h>

#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif
#include "blcache.h"

#include "vmode.h"

#if defined(EFI)
#include "smbios.h"

extern PVOID SMBiosTable;
#endif


#define PAGEFILE_SYS    ("\\pagefile.sys")
typedef PUCHAR PBYTE;

#if defined(_WIN64) && defined(_M_IA64)
#pragma section(".base", long, read, write)
__declspec(allocate(".base"))
extern
PVOID __ImageBase;
#else
extern
PVOID __ImageBase;
#endif


#if DBG
#define NtBuildNumber   (VER_PRODUCTBUILD | 0xC0000000)
#else
#define NtBuildNumber (VER_PRODUCTBUILD | 0xF0000000)
#endif

//
// These are the paths we will search through during a LastKnownGood boot.
// Note that each LastKnownGood path must be of 8.3 form as the FastFat
// boot code currently doesn't support long file names (bletch).
//
// The temporary path exists only between SMSS's start and login. It contains
// everything that was saved as part of the last good boot. The working path
// contains all the backups from this boot, and is the path SetupApi saves
// things to.
//
#define LAST_KNOWN_GOOD_TEMPORARY_PATH  "LastGood.Tmp"
#define LAST_KNOWN_GOOD_WORKING_PATH    "LastGood"

//
// Long term work-item, make "system64" work on Win64.
//
#define SYSTEM_DIRECTORY_PATH "system32"


#ifdef ARCI386
TCHAR OutputBuffer[256];
char BreakInKey;
ULONG Count;
UCHAR OsLoaderVersion[] = "ARCx86 OS Loader V5.10\r\n";
WCHAR OsLoaderVersionW[] = L"ARCx86 OS Loader V5.10\r\n";
#else
UCHAR OsLoaderVersion[] = "OS Loader V5.10\r\n";
WCHAR OsLoaderVersionW[] = L"OS Loader V5.10\r\n";
#endif
#if defined(_IA64_)
UCHAR OsLoaderName[] = "ia64ldr.efi";
#else
UCHAR OsLoaderName[] = "osloader.exe";
#endif

CHAR KernelFileName[8+1+3+1]="ntoskrnl.exe";
CHAR HalFileName[8+1+3+1]="hal.dll";

CHAR KdFileName[8+1+3+1]="KDCOM.DLL";
BOOLEAN UseAlternateKdDll = FALSE;
#define KD_ALT_DLL_PREFIX_CHARS 2
#define KD_ALT_DLL_REPLACE_CHARS 6

//
// progress bar variables  (defined in blload.c)
//
extern int      BlNumFilesLoaded;
extern int      BlMaxFilesToLoad;
extern BOOLEAN  BlOutputDots;
extern BOOLEAN  BlShowProgressBar;
extern ULONG    BlStartTime;

BOOLEAN isOSCHOICE = FALSE;

#if defined(_X86_)

//
// XIP variables
//
BOOLEAN   XIPEnabled;
BOOLEAN   XIPBootFlag;
BOOLEAN   XIPReadOnlyFlag;
PCHAR     XIPLoadPath;

PFN_COUNT XIPPageCount;
PFN_COUNT XIPBasePage;

ARC_STATUS
Blx86CheckForPaeKernel(
    IN BOOLEAN UserSpecifiedPae,
    IN BOOLEAN UserSpecifiedNoPae,
    IN PCHAR UserSpecifiedKernelImage,
    IN PCHAR HalImagePath,
    IN ULONG LoadDeviceId,
    IN ULONG SystemDeviceId,
    OUT PULONG HighestSystemPage,
    OUT PBOOLEAN UsePaeMode,
    IN OUT PCHAR KernelPath
    );

ARC_STATUS
BlpCheckVersion(
    IN  ULONG    LoadDeviceId,
    IN  PCHAR    ImagePath
    );

#endif


//
// Define transfer entry of loaded image.
//

typedef
VOID
(*PTRANSFER_ROUTINE) (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );


PVOID
BlLoadDataFile(
    IN ULONG DeviceId,
    IN PCHAR LoadDevice,
    IN PCHAR SystemPath,
    IN PUNICODE_STRING Filename,
    IN MEMORY_TYPE MemoryType,
    OUT PULONG FileSize
    );

ARC_STATUS
BlLoadTriageDump(
    IN ULONG DriveId,
    OUT PVOID * DumpHeader
    );

VOID
putwS(
    PUNICODE_STRING String
    );

#if defined(_IA64_)

VOID
BuildArcTree();

#endif // defined(_IA64_)

//
// Define local static data.
//


PCHAR ArcStatusCodeMessages[] = {
    "operation was success",
    "E2BIG",
    "EACCES",
    "EAGAIN",
    "EBADF",
    "EBUSY",
    "EFAULT",
    "EINVAL",
    "EIO",
    "EISDIR",
    "EMFILE",
    "EMLINK",
    "ENAMETOOLONG",
    "ENODEV",
    "ENOENT",
    "ENOEXEC",
    "ENOMEM",
    "ENOSPC",
    "ENOTDIR",
    "ENOTTY",
    "ENXIO",
    "EROFS",
};

//
// Diagnostic load messages
//

VOID
BlFatalError(
    IN ULONG ClassMessage,
    IN ULONG DetailMessage,
    IN ULONG ActionMessage
    );

VOID
BlBadFileMessage(
    IN PCHAR BadFileName
    );

//
// Define external static data.
//

BOOLEAN BlConsoleInitialized = FALSE;
ULONG BlConsoleOutDeviceId = ARC_CONSOLE_OUTPUT;
ULONG BlConsoleInDeviceId = ARC_CONSOLE_INPUT;
ULONG BlDcacheFillSize = 32;

BOOLEAN BlRebootSystem = FALSE;
ULONG BlVirtualBias = 0;
BOOLEAN BlUsePae = FALSE;

//++
//
// PULONG
// IndexByUlong(
//     PVOID Pointer,
//     ULONG Index
//     )
//
// Routine Description:
//
//     Return the address Index ULONGs into Pointer. That is,
//     Index * sizeof (ULONG) bytes into Pointer.
//
// Arguments:
//
//     Pointer - Start of region.
//
//     Index - Number of ULONGs to index into.
//
// Return Value:
//
//     PULONG representing the pointer described above.
//
//--

#define IndexByUlong(Pointer,Index) (&(((ULONG*) (Pointer)) [Index]))


//++
//
// PBYTE
// IndexByByte(
//     PVOID Pointer,
//     ULONG Index
//     )
//
// Routine Description:
//
//     Return the address Index BYTEs into Pointer. That is,
//     Index * sizeof (BYTE) bytes into Pointer.
//
// Arguments:
//
//     Pointer - Start of region.
//
//     Index - Number of BYTEs to index into.
//
// Return Value:
//
//     PBYTE representing the pointer described above.
//
//--

#define IndexByByte(Pointer, Index) (&(((UCHAR*) (Pointer)) [Index]))


ARC_STATUS
BlLoadTriageDump(
    IN ULONG DriveId,
    OUT PVOID * TriageDumpOut
    )

/*++

Routine Description:

    Load the triage dump, if it exists; return an error value otherwise.

Arguments:

    DriveId - The device where we should check for the triage dump.

    TriageDumpOut - Where the triage dump pointer is copied to on success.

Return Value:

    ESUCCESS - If there was a triage dump and the dump information was
            successfully copied into pTriageDump.

    ARC_STATUS - Otherwise.

--*/


{
    ULONG i;
    ULONG BuildNumber;
    ARC_STATUS Status;
    PMEMORY_DUMP MemoryDump = NULL;
    ULONG PageFile = -1;
    ULONG Count, actualBase;
    PBYTE Buffer = NULL, NewBuffer = NULL;

    //
    // Fill in the TriageDump structure
    //

    Status = BlOpen (DriveId, PAGEFILE_SYS, ArcOpenReadOnly, &PageFile);

    if (Status != ESUCCESS) {
        goto _return;
    }

    //
    // Allocate the buffer for the triage dump.
    //

    Buffer = (PBYTE) BlAllocateHeap (SECTOR_SIZE);

    if (!Buffer) {
        Status = ENOMEM;
        goto _return;
    }

    //
    // Read the first SECTOR_SIZE of the pagefile.
    //

    Status = BlRead (PageFile, Buffer, SECTOR_SIZE, &Count);

    if (Status != ESUCCESS || Count != SECTOR_SIZE) {
        Status = EINVAL;
        goto _return;
    }

    MemoryDump = (PMEMORY_DUMP) Buffer;

    if (MemoryDump->Header.ValidDump != DUMP_VALID_DUMP ||
        MemoryDump->Header.Signature != DUMP_SIGNATURE ||
        MemoryDump->Header.DumpType != DUMP_TYPE_TRIAGE) {

        //
        // Not a valid dump file.
        //

        Status = EINVAL;
        goto _return;
    }

    Status = BlAllocateDescriptor (LoaderOsloaderHeap,0,BYTES_TO_PAGES(TRIAGE_DUMP_SIZE) ,&actualBase);

    if (!actualBase || (Status != STATUS_SUCCESS)) {
        Status = ENOMEM;
        goto _return;
    }

    NewBuffer = (PCHAR)(KSEG0_BASE | (actualBase << PAGE_SHIFT));

    //
    // Read the first TRIAGE_DUMP_SIZE of the pagefile.
    //

    Status = BlReadAtOffset (PageFile, 0,TRIAGE_DUMP_SIZE,NewBuffer);

    if (Status != ESUCCESS) {
        Status = EINVAL;
        goto _return;
    }

    MemoryDump = (PMEMORY_DUMP) NewBuffer;


    //
    // Does the dump have a valid signature.
    //

    if (MemoryDump->Triage.ValidOffset > (TRIAGE_DUMP_SIZE - sizeof (ULONG)) ||
        *(ULONG *)IndexByByte (Buffer, MemoryDump->Triage.ValidOffset) != TRIAGE_DUMP_VALID) {

        Status = EINVAL;
        goto _return;
    }


    Status = ESUCCESS;

_return:

    if (PageFile != -1) {
        BlClose (PageFile);
        PageFile = -1;
    }


    if (Status != ESUCCESS && Buffer) {

        Buffer = NULL;
        MemoryDump = NULL;
    }

    *TriageDumpOut = MemoryDump;

    return Status;
}


ARC_STATUS
BlInitStdio (
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv
    )

{

    PCHAR ConsoleOutDevice;
    PCHAR ConsoleInDevice;
    ULONG Status;

    if (BlConsoleInitialized) {
        return ESUCCESS;
    }

    //
    // initialize the progress bar
    //
    // BlShowProgressBar = TRUE;
    if( BlIsTerminalConnected() ) {
        BlShowProgressBar = TRUE;
        DisplayLogoOnBoot = FALSE;
    }

    //
    // Get the name of the console output device and open the device for
    // write access.
    //
    ConsoleOutDevice = BlGetArgumentValue(Argc, Argv, "consoleout");
    if ((ConsoleOutDevice == NULL) && !BlIsTerminalConnected()) {
        return ENODEV;
    }

    Status = ArcOpen(ConsoleOutDevice, ArcOpenWriteOnly, &BlConsoleOutDeviceId);
    if ((Status != ESUCCESS) && !BlIsTerminalConnected()) {
        return Status;
    }

    //
    // Get the name of the console input device and open the device for
    // read access.
    //
    ConsoleInDevice = BlGetArgumentValue(Argc, Argv, "consolein");
    if ((ConsoleInDevice == NULL) && !BlIsTerminalConnected()) {
        return ENODEV;
    }

    Status = ArcOpen(ConsoleInDevice, ArcOpenReadOnly, &BlConsoleInDeviceId);
    if ((Status != ESUCCESS) && !BlIsTerminalConnected()) {
        return Status;
    }

    BlConsoleInitialized = TRUE;

    return ESUCCESS;
}

int
Blatoi(
    char *s
    )
{
    int digval = 0;
    int num = 0;
    char *n;

    num = 0;
    for (n=s; *n; n++) {
        if (isdigit((int)(unsigned char)*n)) {
            digval = *n - '0';
        } else if (isxdigit((int)(unsigned char)*n)) {
            digval = toupper(*n) - 'A' + 10;
        } else {
            digval = 0;
        }
        num = num * 16 + digval;
    }

    return num;
}


PCHAR
BlTranslateSignatureArcName(
    IN PCHAR ArcNameIn
    )

/*++

Routine Description:

    This function's purpose is to translate a signature based arc
    name to a scsi based arc name.  The 2 different arc name syntaxes
    are as follows:

        scsi(28111684)disk(0)rdisk(0)partition(1)
        scsi(1)disk(0)rdisk(0)partition(1)

    Both of these arc names are really the same disk, the first uses
    the disk's signature and the second uses the scsi bus number.  This
    function translates the signature arc name by interating thru all
    of the scsi buses that the loaded scsi miniport supports.  If it
    finds a signature match then the arc name is changed to use the
    correct scsi bus number.  This problem occurs because the boot loader
    only loads one scsi miniport and therefore only sees the buses
    attached to it's devices.  If you have a system with multiple
    scsi adapters of differing type, like an adaptec and a symbios logic,
    then there is a high probability that the boot loader will see the
    buses in a different order than the nt executive will and the
    system will not boot.

Arguments:

    ArcNameIn - Supplies the signature based arc name

Return Value:

    Success - Valid pointer to a scsi based arcname.
    Failure - NULL pointer

--*/

{
#if defined(_X86_)
    extern ULONG ScsiPortCount;
    PCHAR s,p,n;
    PARC_DISK_INFORMATION DiskInfo;
    PLIST_ENTRY Entry;
    PARC_DISK_SIGNATURE DiskSignature;
    ULONG sigval,digval;
    ULONG Signature;
    int found = -1;
    ULONG i;
    ARC_STATUS Status;
    ULONG DriveId;
    UCHAR Buffer[2048+256];
    UCHAR ArcName[128];
    PUCHAR Sector;
    LARGE_INTEGER SeekValue;
    ULONG Count;
    PCONFIGURATION_COMPONENT target;
    PCONFIGURATION_COMPONENT lun;
    UCHAR devicePath[117];
    BOOLEAN gotPath;
    USHORT mbrSig;


    if (_strnicmp( ArcNameIn, "signature(", 10 ) != 0) {
        //
        // not a signature based name so leave
        //
        return NULL;
    }

    s = strchr( ArcNameIn, '(' );
    p = strchr( ArcNameIn, ')' );

    if (s == NULL || p == NULL) {
        return NULL;
    }

    *p = 0;
    sigval = Blatoi( s+1 );
    *p = ')';

    if (sigval == 0) {
        return NULL;
    }

    Sector = ALIGN_BUFFER(Buffer);

    for (i=0; i < ScsiPortCount; i++) {
        target = ScsiGetFirstConfiguredTargetComponent(i);
        while (target != NULL) {
            lun = ScsiGetFirstConfiguredLunComponent(target);
            while (lun != NULL) {
                gotPath = ScsiGetDevicePath(i, target, lun, devicePath);
                if (gotPath == FALSE) {
                    break;
                }
                sprintf(ArcName, "%spartition(0)", devicePath);
                Status = ArcOpen( ArcName, ArcOpenReadOnly, &DriveId );
                if (Status == ESUCCESS) {
                    SeekValue.QuadPart = 0;
                    Status = ArcSeek(DriveId, &SeekValue, SeekAbsolute);
                    if (Status == ESUCCESS) {
                        Status = ArcRead( DriveId, Sector, 512, &Count );
                        if (Status == ESUCCESS && Count == 512) {
                            mbrSig = 
                               ((PUSHORT)Sector)[BOOT_SIGNATURE_OFFSET];
                            Signature = 
                               ((PULONG)Sector)[PARTITION_TABLE_OFFSET/2-1];
                            if (mbrSig == BOOT_RECORD_SIGNATURE &&
                                Signature == sigval) {
                                found = i;
                                ArcClose(DriveId);
                                goto SigFound;
                            }
                        }
                    }
                    ArcClose(DriveId);
                }
                lun = ScsiGetNextConfiguredLunComponent(lun);
            } 
            target = ScsiGetNextConfiguredTargetComponent(target);
        }
    }

SigFound:

    if (found == -1) {
        //
        // the signature in the arcname is bogus
        //
        return NULL;
    }

    //
    // if we get here then we have an arc name with a
    // good signature in it, so now we can generate
    // a good arc name
    //

    sprintf(Buffer, "%s", devicePath);

    p = strstr(ArcNameIn, "partition(");
    if (p == NULL) {
        ASSERT(FALSE);
        return NULL;
    }

    strcat(Buffer, p);

    p = (PCHAR)BlAllocateHeap( strlen(Buffer) + 1 );
    if (p) {
        strcpy( p, Buffer );
    }

    return p;
#else
    return NULL;
#endif
}


#if defined(_X86_)
VOID FLUSH_TB();
VOID ENABLE_PSE();

#define _8kb         ( 8*1024)
#define _32kb        (32*1024)
#define _4mb         (4*1024*1024)
#define _4mb_pages   (_4mb >> PAGE_SHIFT)


ARC_STATUS
XipLargeRead(
    ULONG     FileId,
    PFN_COUNT BasePage,
    PFN_COUNT PageCount
    )
/*++

Routine Description:

    Initialize the XIP 'ROM' by reading from disk.

Arguments:

    FileId - The file used to initialize for XIP.

    BasePage - PFN of the first XIP Rom page.

    PageCount - Number of XIP Rom pages.

Return Value:

    ESUCCESS returned if all goes well.

--*/
{
    PHARDWARE_PTE PDE_VA = (PHARDWARE_PTE)PDE_BASE;

    ARC_STATUS    status;
    PHARDWARE_PTE pde;
    HARDWARE_PTE  zproto, proto;

    PBYTE         baseaddr, curraddr, copybuffer;
    ULONG         fileoffset;
    ULONG         count;

    ULONG         tcount;
    ULONG         paddingbytes;
    int           i, n;

    copybuffer = NULL;

    //
    // Look for a zero PDE entry starting at entry 128 (address 512MB).
    //

    pde = PDE_VA + 128;
    baseaddr = (PUCHAR)(128*_4mb);

    for (i = 0;  i < 32;  i++) {
        if (*(PULONG)pde == 0) {
            break;
        }
        pde++;
        baseaddr += _4mb;
    }

    if (i == 32) {
        return ENOMEM;
    }

    //
    // Have to enable 4MB pages in cr4 in order to use them in the PDE
    //
    ENABLE_PSE();

    //
    // Initialize the pte prototypes.
    //
    *(PULONG)&zproto = 0;
    proto = zproto;

    proto.Write = 1;
    proto.LargePage = 1;
    proto.Valid = 1;

    //
    //Use intermediate 8KB buffer and read in smaller chunks.
    //
    copybuffer = (PBYTE) BlAllocateHeap (TRIAGE_DUMP_SIZE);
    if (!copybuffer) {
        return ENOMEM;
    }

    //
    // Map the XIP memory 4MB at a time.
    // Read in the file 8KB at a time.
    // Don't exceed the PageCount.
    //
    fileoffset = 0;
    do {
        //
        // Reset the curraddr to the beginning of the buffer.
        // Set the PFN in the 4MB pte and flush the TLB
        //
        curraddr = baseaddr;

        proto.PageFrameNumber = BasePage;
        *pde = proto;
        FLUSH_TB();

        //
        // Adjust the BasePage and PageCount values for the next iteration
        //
        BasePage += _4mb_pages;

        if (PageCount < _4mb_pages) {
            PageCount = 0;
        } else {
            PageCount -= _4mb_pages;
        }

        //
        // Read in the next 4MB in 8KB chunks.
        //
        n = _4mb / _8kb;
        while (n--) {
            status = BlRead(FileId, (PVOID)copybuffer, _8kb, &count);

            //
            // Just give up on an error.
            //
            if (status != ESUCCESS) {
                goto done;
            }

            //
            // If not the first read (or a short read)
            // the copy is simple.
            //
            if (fileoffset > 0 || count < _8kb) {
                RtlCopyMemory( (PVOID)curraddr, (PVOID)copybuffer, count );
                curraddr += count;
                fileoffset += count;

                if (count < _8kb) {
                    goto done;
                }

            } else {
                //
                // Process boot sector.  Need to pad out ReservedSectors
                // to align clusters on a page boundary.
                //
                PPACKED_BOOT_SECTOR  pboot;
                BIOS_PARAMETER_BLOCK bios;
                ULONG                paddingbytes;
                ULONG                newReservedSectors;

                pboot = (PPACKED_BOOT_SECTOR)copybuffer;
                FatUnpackBios(&bios, &pboot->PackedBpb);

                if (bios.BytesPerSector != SECTOR_SIZE
                 || FatBytesPerCluster(&bios) != PAGE_SIZE) {
                    goto done;
                }

                //
                // Compute how much paddint is required and update the ReservedSectors field.
                //
                paddingbytes = PAGE_SIZE - (FatFileAreaLbo(&bios) & (PAGE_SIZE-1));
                if (paddingbytes < PAGE_SIZE) {
                    newReservedSectors = (FatReservedBytes(&bios) + paddingbytes) / SECTOR_SIZE;
                    pboot->PackedBpb.ReservedSectors[0] = (UCHAR) (newReservedSectors & 0xff);
                    pboot->PackedBpb.ReservedSectors[1] = (UCHAR) (newReservedSectors >> 8);
                }

                //
                // Copy the boot block.
                // Add padding.
                // Copy the rest of the read buffer.
                // Read in a short page to get us back on track.
                //
                RtlCopyMemory( (PVOID)curraddr, (PVOID)copybuffer, SECTOR_SIZE );
                curraddr += SECTOR_SIZE;

                RtlZeroMemory( (PVOID)curraddr, paddingbytes );
                curraddr += paddingbytes;

                RtlCopyMemory( (PVOID)curraddr, (PVOID) (copybuffer + SECTOR_SIZE), count - SECTOR_SIZE );
                curraddr += (count - SECTOR_SIZE);

                status = BlRead(FileId, (PVOID)copybuffer, count - paddingbytes, &tcount);
                if (status != ESUCCESS || tcount != count - paddingbytes) {
                    goto done;
                }

                RtlCopyMemory( (PVOID)curraddr, (PVOID)copybuffer, count - paddingbytes );
                curraddr += (count - paddingbytes);

                fileoffset += (2*count - paddingbytes);;

                //
                // We decrement n again, since we have eaten up another 8KB of the 4MB mapping.
                //
                n--;
            }
        }
    } while (PageCount);

done:
    //
    // Unmap the current 4MB chunk and flush the TB
    //
    *pde = zproto;
    FLUSH_TB();

    //
    // Free the temporary copy buffer
    //
    if (copybuffer) {
        ;
    }

    return status;
}
#endif //_X86_



#ifdef EFI
void SetupSMBiosInLoaderBlock(
    void
    )
{
    PSMBIOS_EPS_HEADER SMBiosEPSHeader;

    if (SMBiosTable != NULL)
    {
        SMBiosEPSHeader = BlAllocateHeap(sizeof(SMBIOS_EPS_HEADER));
        RtlCopyMemory(SMBiosEPSHeader, SMBiosTable, sizeof(SMBIOS_EPS_HEADER));
    } else {
        SMBiosEPSHeader = NULL;
    }
    BlLoaderBlock->Extension->SMBiosEPSHeader = SMBiosEPSHeader;
}
#endif


ARC_STATUS
BlOsLoader (
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Envp
    )

/*++

Routine Description:

    This is the main routine that controls the loading of the NT operating
    system on an ARC compliant system. It opens the system partition,
    the boot partition, the console input device, and the console output
    device. The NT operating system and all its DLLs are loaded and bound
    together. Control is then transfered to the loaded system.

Arguments:

    Argc - Supplies the number of arguments that were provided on the
        command that invoked this program.

    Argv - Supplies a pointer to a vector of pointers to null terminated
        argument strings.

    Envp - Supplies a pointer to a vector of pointers to null terminated
        environment variables.

Return Value:

    EBADF is returned if the specified OS image cannot be loaded.

--*/

{

    ULONG CacheLineSize;
    ULONG Count;
    PCONFIGURATION_COMPONENT_DATA DataCache;
    CHAR DeviceName[256];
    CHAR DevicePrefix[256];
    PCHAR DirectoryEnd;
    CHAR KdDllName[256];
    PCHAR FileName;
    ULONG FileSize;
    BOOLEAN KdDllLoadFailed;
    PKLDR_DATA_TABLE_ENTRY KdDataTableEntry;
    PKLDR_DATA_TABLE_ENTRY HalDataTableEntry;
    PCHAR LoadDevice;
    ULONG LoadDeviceId;
    CHAR LoadDevicePath[256];
    CHAR LoadDeviceLKG1Path[256];
    CHAR LoadDeviceLKG2Path[256];
    FULL_PATH_SET LoadDevicePathSet;
    PCHAR SystemDevice;
    ULONG SystemDeviceId;
    CHAR SystemDevicePath[256];
    FULL_PATH_SET SystemDevicePathSet;
    CHAR KernelDirectoryPath[256];
    FULL_PATH_SET KernelPathSet;
    CHAR KernelPathName[256];
    CHAR HalPathName[256];
    PVOID HalBase;
    PVOID KdDllBase;
    PVOID LoaderBase;
    PMEMORY_DESCRIPTOR ProgramDescriptor;
    PVOID SystemBase;
    ULONG Index;
    ULONG Limit;
    ULONG LinesPerBlock;
    PCHAR LoadFileName;
    PCHAR LoadOptions;
    PCHAR HeadlessOption;
    PCHAR OsLoader;
#if defined(_X86_)
    PCHAR x86SystemPartition;
    PCHAR userSpecifiedKernelName;
    ULONG highestSystemPage;
    BOOLEAN userSpecifiedPae;
    BOOLEAN userSpecifiedNoPae;    
#endif
    PCHAR SavedOsLoader;
    PCHAR SavedLoadFileName;
    ULONG i;
    ARC_STATUS Status;
    NTSTATUS NtStatus;
    PKLDR_DATA_TABLE_ENTRY SystemDataTableEntry;
    PTRANSFER_ROUTINE SystemEntry;
    PIMAGE_NT_HEADERS NtHeaders;
    PWSTR BootFileSystem;
    BOOLEAN BreakInKey;
    CHAR BadFileName[128];
    PBOOTFS_INFO FsInfo;
    PCHAR TmpPchar;
    BOOLEAN bDiskCacheInitialized = FALSE;
    BOOLEAN ServerHive = FALSE;
#if defined(REMOTE_BOOT)
    ULONGLONG NetRebootParameter;
    CHAR OutputBuffer[256];
#endif // defined(REMOTE_BOOT)
    BOOLEAN bLastKnownGood, bLastKnownGoodChosenLate;

    BOOLEAN safeBoot = FALSE;

    PBOOT_DRIVER_NODE       DriverNode = 0;
    PBOOT_DRIVER_LIST_ENTRY DriverEntry = 0;
    PLIST_ENTRY             NextEntry = 0;
    PLIST_ENTRY             BootDriverListHead = 0;

//    BlShowProgressBar = TRUE;
    BlShowProgressBar = FALSE;
    BlStartTime = ArcGetRelativeTime();

    //
    // Initialize the OS loader console input and output.
    //
    Status = BlInitStdio(Argc, Argv);
    if (Status != ESUCCESS) {
        return Status;
    }


    //
    // Initialize the boot debugger for platforms that directly load the
    // OS Loader.
    //
    // N.B. This must occur after the console input and output have been
    //      initialized so debug messages can be printed on the console
    //      output device.
    //

#if defined(_ALPHA_) || defined(ARCI386) || defined(_IA64_)
    //
    // Locate the memory descriptor for the OS Loader.
    //

    ProgramDescriptor = NULL;
    while ((ProgramDescriptor = ArcGetMemoryDescriptor(ProgramDescriptor)) != NULL) {
        if (ProgramDescriptor->MemoryType == MemoryLoadedProgram) {
            break;
        }
    }

    //
    // If the program memory descriptor was found, then compute the base
    // address of the OS Loader for use by the debugger.
    //

    LoaderBase = &__ImageBase;

    //
    // Initialize traps and the boot debugger.
    //
#if defined(ENABLE_LOADER_DEBUG)

#if defined(_ALPHA_)
    BdInitializeTraps();
#endif

    DBGTRACE( TEXT("About to BdInitDebugger.\r\n") );

    BdInitDebugger(OsLoaderName, LoaderBase, ENABLE_LOADER_DEBUG);

    DBGTRACE( TEXT("Back From BdInitDebugger.\r\n") );

#else

    BdInitDebugger(OsLoaderName, 0, NULL);

#endif

#endif

#if defined(REMOTE_BOOT)
    //
    // Get any parameters from a reboot on a Net PC.
    //

    if (BlBootingFromNet) {
        NetGetRebootParameters(&NetRebootParameter, NULL, NULL, NULL, NULL, NULL, TRUE);
    }
#endif // defined(REMOTE_BOOT)

#if 0 && !defined(_IA64_)
//
// AJR bugbug -- do we really need to do this twice? we already call in SuMain()
//
// ChuckL -- Turned this code off because it screws up remote boot, which
//           does some allocations before we get here.
//
    //
    // Initialize the memory descriptor list, the OS loader heap, and the
    // OS loader parameter block.
    //

    Status = BlMemoryInitialize();
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_HW_MEM_CLASS,
                     DIAG_BL_MEMORY_INIT,
                     LOAD_HW_MEM_ACT);

        goto LoadFailed;
    }
#endif

    
#if defined(_IA64_)
    //
    // Build required portion of ARC tree since we are not doing NTDETECT
    // anymore for IA-64.
    //
    BuildArcTree();
#endif

#ifdef EFI
    //
    // Establish SMBIOS information in the loader block
    //
    SetupSMBiosInLoaderBlock();
#endif

    //
    // Compute the data cache fill size. This value is used to align
    // I/O buffers in case the host system does not support coherent
    // caches.
    //
    // If a combined secondary cache is present, then use the fill size
    // for that cache. Otherwise, if a secondary data cache is present,
    // then use the fill size for that cache. Otherwise, if a primary
    // data cache is present, then use the fill size for that cache.
    // Otherwise, use the default fill size.
    //

    DataCache = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                         CacheClass,
                                         SecondaryCache,
                                         NULL);

    if (DataCache == NULL) {
        DataCache = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                             CacheClass,
                                             SecondaryDcache,
                                             NULL);

        if (DataCache == NULL) {
            DataCache = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                                 CacheClass,
                                                 PrimaryDcache,
                                                 NULL);
        }
    }

    if (DataCache != NULL) {
        LinesPerBlock = DataCache->ComponentEntry.Key >> 24;
        CacheLineSize = 1 << ((DataCache->ComponentEntry.Key >> 16) & 0xff);
        BlDcacheFillSize = LinesPerBlock * CacheLineSize;
    }


    //
    // Initialize the OS loader I/O system.
    //

    Status = BlIoInitialize();
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_HW_DISK_CLASS,
                     DIAG_BL_IO_INIT,
                     LOAD_HW_DISK_ACT);

        goto LoadFailed;
    }

    //
    // Try to make sure disk caching is initialized. Failure in
    // initializing the disk cache should not keep us from booting, so
    // Status is not set.
    //
    if (BlDiskCacheInitialize() == ESUCCESS) {
        bDiskCacheInitialized = TRUE;
    }

    //
    // Initialize the resource section.
    //

    Status = BlInitResources(Argv[0]);
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_HW_DISK_CLASS,
                     DIAG_BL_IO_INIT,
                     LOAD_HW_DISK_ACT);

        goto LoadFailed;
    }

    //
    // Initialize the progress bar
    //
    BlSetProgBarCharacteristics(HIBER_UI_BAR_ELEMENT, BLDR_UI_BAR_BACKGROUND);


    //
    // Initialize the NT configuration tree.
    //

    BlLoaderBlock->ConfigurationRoot = NULL;
    Status = BlConfigurationInitialize(NULL, NULL);
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_HW_FW_CFG_CLASS,
                     DIAG_BL_CONFIG_INIT,
                     LOAD_HW_FW_CFG_ACT);

        goto LoadFailed;
    }

    //
    // Copy the osloadoptions argument into the LoaderBlock.
    //
    LoadOptions = BlGetArgumentValue(Argc, Argv, "osloadoptions");

#if defined(_X86_)

    userSpecifiedPae = FALSE;
    userSpecifiedNoPae = FALSE;
    if (strstr(LoadOptions, "SAFEBOOT") != NULL) {
        safeBoot = TRUE;
    } else {
        safeBoot = FALSE;
    }

#endif

    if (LoadOptions != NULL) {
        FileSize = strlen(LoadOptions) + 1;
        FileName = (PCHAR)BlAllocateHeap(FileSize);
        strcpy(FileName, LoadOptions);
        BlLoaderBlock->LoadOptions = FileName;

        //
        // Check for the SOS switch that forces the output of filenames during
        // the boot instead of the progress dots.
        //

        if ((strstr(FileName, "SOS") != NULL) ||
            (strstr(FileName, "sos") != NULL)) {
            BlOutputDots = FALSE;
        }

#ifdef EFI
        GraphicsMode = FALSE;
#else
        GraphicsMode = (strstr(FileName, "BOOTLOGO") != NULL); // to display boot logo go to graphics mode
#endif


        //
        // Check for the 3gb user address space switch which causes the system
        // to load at the alternate base address if it is relocatable.
        //

#if defined(_X86_)

        if ((strstr(FileName, "3GB") != NULL) ||
            (strstr(FileName, "3gb") != NULL)) {
            BlVirtualBias = ALTERNATE_BASE - KSEG0_BASE;
        }

        if ((strstr(FileName, "PAE") != NULL) ||
            (strstr(FileName, "pae") != NULL)) {
            userSpecifiedPae = TRUE;
        }

        if ((strstr(FileName, "NOPAE") != NULL) ||
            (strstr(FileName, "nopae") != NULL)) {
            userSpecifiedNoPae = TRUE;
        }

        if (safeBoot != FALSE) {

            //
            // We're in safeboot mode.  Override the user's desire to boot into
            // PAE mode.
            //

            userSpecifiedPae = FALSE;
        }

#endif

        //
        // Check for an alternate HAL specification.
        //

        FileName = strstr(BlLoaderBlock->LoadOptions, "HAL=");
        if (FileName != NULL) {
            FileName += strlen("HAL=");
            for (i = 0; i < sizeof(HalFileName); i++) {
                if (FileName[i] == ' ') {
                    HalFileName[i] = '\0';
                    break;
                }

                HalFileName[i] = FileName[i];
            }
        }

        HalFileName[sizeof(HalFileName) - 1] = '\0';

        //
        // Check for an alternate kernel specification.
        //

        FileName = strstr(BlLoaderBlock->LoadOptions, "KERNEL=");
        if (FileName != NULL) {
            FileName += strlen("KERNEL=");
            for (i = 0; i < sizeof(KernelFileName); i++) {
                if (FileName[i] == ' ') {
                    KernelFileName[i] = '\0';
                    break;
                }

                KernelFileName[i] = FileName[i];
            }
#if defined(_X86_)
            userSpecifiedKernelName = KernelFileName;
#endif

        }
#if defined(_X86_)
        else {
            userSpecifiedKernelName = NULL;
        }
#endif

        KernelFileName[sizeof(KernelFileName) - 1] = '\0';

        //
        // Check for an alternate Kernel Debugger DLL, i.e.,
        // /debugport=1394 (kd1394.dll), /debugport=usb (kdusb.dll), etc...
        //

        FileName = strstr(BlLoaderBlock->LoadOptions, "DEBUGPORT=");
        if (FileName == NULL) {
            FileName = strstr(BlLoaderBlock->LoadOptions, "debugport=");
        }
        if (FileName != NULL) {
            _strupr(FileName);
            if (strstr(FileName, "COM") == NULL) {
                UseAlternateKdDll = TRUE;
                FileName += strlen("DEBUGPORT=");
                for (i = 0; i < KD_ALT_DLL_REPLACE_CHARS; i++) {
                    if (FileName[i] == ' ') {
                        break;
                    }

                    KdFileName[KD_ALT_DLL_PREFIX_CHARS + i] = FileName[i];
                }
                KdFileName[KD_ALT_DLL_PREFIX_CHARS + i] = '\0';
                strcat(KdFileName, ".DLL");
            }
        }

    } else {
        BlLoaderBlock->LoadOptions = NULL;
    }

#if defined(_X86_)
    if (LoadOptions != NULL) {
        //
        // Process XIP options
        //
        {
            PCHAR XIPBootOption, XIPRomOption, XIPRamOption, XIPSizeOption;
            PCHAR path, sizestr;
            ULONG nmegs = 0;
            PCHAR p, opts;
            ULONG n;

            opts = BlLoaderBlock->LoadOptions;

            (XIPBootOption = strstr(opts, "XIPBOOT"))  || (XIPBootOption = strstr(opts, "xipboot"));
            (XIPRomOption  = strstr(opts, "XIPROM="))  || (XIPRomOption  = strstr(opts, "xiprom="));
            (XIPRamOption  = strstr(opts, "XIPRAM="))  || (XIPRamOption  = strstr(opts, "xipram="));
            (XIPSizeOption = strstr(opts, "XIPMEGS=")) || (XIPSizeOption = strstr(opts, "xipmegs="));

            XIPEnabled = FALSE;

            if (XIPRomOption || XIPRamOption) {
                if (XIPRomOption && XIPRamOption) {
                    ;
                } else {
                    sizestr = XIPSizeOption? strchr(XIPSizeOption, '=') : NULL;
                    if (sizestr) {
                        sizestr++;
                        nmegs = 0;
                        while ('0' <= *sizestr && *sizestr <= '9') {
                            nmegs = 10*nmegs + (*sizestr - '0');
                            sizestr++;
                        }
                    }

                    path = strchr(XIPRomOption? XIPRomOption : XIPRamOption, '=');

                    if (nmegs && path) {
                        path++;

                        XIPBootFlag = XIPBootOption? TRUE : FALSE;
                        XIPPageCount = (1024*1024*nmegs) >> PAGE_SHIFT;

                        //
                        // strdup XIPLoadPath
                        //
                        for (p = path;  *p;  p++) {
                            if (*p == ' ') break;
                            if (*p == '/') break;
                            if (*p == '\n') break;
                            if (*p == '\r') break;
                            if (*p == '\t') break;
                        }

                        n = (p - path);
                        if (n > 1) {
                            XIPLoadPath = BlAllocateHeap(n+1);
                            if (XIPLoadPath) {
                                for (i = 0;  i < n;  i++) {
                                    XIPLoadPath[i] = path[i];
                                }
                                XIPLoadPath[i] = '\0';

                                XIPEnabled = TRUE;
                            }
                        }
                    }
                }
            }
        }
    }

    //
    // Allocate the XIP pages.
    //

    if (XIPEnabled) {

        ULONG OldBase;
        ULONG OldLimit;

        OldBase = BlUsableBase;
        OldLimit = BlUsableLimit;
        BlUsableBase = BL_XIPROM_RANGE_LOW;
        BlUsableLimit = BL_XIPROM_RANGE_HIGH;

        Status = BlAllocateAlignedDescriptor (LoaderXIPRom, 0, XIPPageCount, _4mb_pages, &XIPBasePage);
        if (Status != ESUCCESS) {
            XIPEnabled = FALSE;
        }

        BlUsableBase = OldBase;
        BlUsableLimit = OldLimit;
    }

#endif //_X86_


    //
    // Get the name of the OS loader (on i386 it's system32\NTLDR) and get
    // the OS path (on i386 it's <SystemRoot> such as "\winnt").
    //
    OsLoader = BlGetArgumentValue(Argc, Argv, "osloader");
    LoadFileName = BlGetArgumentValue(Argc, Argv, "osloadfilename");

    //
    // Check the load path to make sure it's valid.
    //
    if (LoadFileName == NULL) {
        Status = ENOENT;
        BlFatalError(LOAD_HW_FW_CFG_CLASS,
                     DIAG_BL_FW_GET_BOOT_DEVICE,
                     LOAD_HW_FW_CFG_ACT);

        goto LoadFailed;
    }

    //
    // Check the loader path to see if it's valid.
    //
    if (OsLoader == NULL) {
        Status = ENOENT;
        BlFatalError(LOAD_HW_FW_CFG_CLASS,
                     DIAG_BL_FIND_HAL_IMAGE,
                     LOAD_HW_FW_CFG_ACT);

        goto LoadFailed;
    }

#if defined(REMOTE_BOOT)
    //
    // If we're booting from the net, temporarily remove the server\share
    // from the front of the OsLoader and LoadFileName strings so that TFTP
    // works.
    //

    if (BlBootingFromNet) {

        NetServerShare = OsLoader; // Required for Client Side Cache.

        SavedOsLoader = OsLoader;               // save OsLoader pointer
        OsLoader++;                             // skip leading "\"
        OsLoader = strchr(OsLoader,'\\');       // find server\share separator
        if (OsLoader != NULL) {
            OsLoader++;                         // skip server\share separator
            OsLoader = strchr(OsLoader,'\\');   // find share\path separator
        }
        if (OsLoader == NULL) {                 // very bad if no \ found
            OsLoader = SavedOsLoader;
            goto LoadFailed;
        }
        SavedLoadFileName = LoadFileName;       // save LoadFileName pointer
        LoadFileName++;                         // skip leading "\"
        LoadFileName = strchr(LoadFileName,'\\'); // find server\share separator
        if (LoadFileName != NULL) {
            LoadFileName++;                     // skip server\share separator
            LoadFileName = strchr(LoadFileName,'\\'); // find share\path separator
        }
        if (LoadFileName == NULL) {             // very bad if no \ found
            LoadFileName = SavedLoadFileName;
            OsLoader = SavedOsLoader;
            goto LoadFailed;
        }
    }
#endif // defined(REMOTE_BOOT)

    //
    // Get the NTFT drive signatures to allow the kernel to create the
    // correct ARC name <=> NT name mappings.
    //

    BlGetArcDiskInformation(FALSE);

    //
    // Display the Configuration prompt for breakin at this point, but don't
    // check for key downstrokes. This gives the user a little more reaction
    // time.
    //
    BlStartConfigPrompt();

    //
    // Determine if we are going to do a last known good boot.
    //
    // ISSUE-2000/03/29-ADRIAO: LastKnownGood enhancements
    //     Note that last known kernel/hal support requires that we know we're
    // going into a lkg boot prior to initializing the loader. On an x86 system
    // with only one boot.ini option we will not present the user the lkg option
    // until *after* we've loaded the kernel, hal, registry, and kd-dlls. If we
    // decide to support last known kernel/hal, we'd probably have to do
    // something similar to what 9x does (ie look for a depressed CTRL key at
    // the earliest point in boot.)
    //
    bLastKnownGood = (LoadOptions && (strstr(LoadOptions, "LASTKNOWNGOOD") != NULL));

    //
    // Put together everything we need to describe the loader device. This is
    // where the OS is loaded from (ie some \winnt installation). The alias
    // for this path is \SystemRoot.
    //
    LoadDevice = BlGetArgumentValue(Argc, Argv, "osloadpartition");

    if (LoadDevice == NULL) {
        Status = ENODEV;
        BlFatalError(LOAD_HW_FW_CFG_CLASS,
                     DIAG_BL_FW_GET_BOOT_DEVICE,
                     LOAD_HW_FW_CFG_ACT);

        goto LoadFailed;
    }

    //
    // Initialize the Ramdisk if it is specified in LoadOptions
    //

    Status = RamdiskInitialize( LoadOptions, FALSE );
    if (Status != ESUCCESS) {
        // BlFatalError called inside RamdiskInitialize
        goto LoadFailed;
    }

    //
    // Translate it's signature based arc name
    //
    TmpPchar = BlTranslateSignatureArcName( LoadDevice );
    if (TmpPchar) {
        LoadDevice = TmpPchar;
    }

    //
    // Open the load device
    //
    Status = ArcOpen(LoadDevice, ArcOpenReadWrite, &LoadDeviceId);
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_HW_DISK_CLASS,
                     DIAG_BL_OPEN_BOOT_DEVICE,
                     LOAD_HW_DISK_ACT);

        goto LoadFailed;
    }

#if defined(_X86_)
    //
    // Check for the special SDIBOOT flag, which tells us to boot from an
    // SDI image in the root of the boot partition.
    //
    if ( BlLoaderBlock->LoadOptions != NULL ) {
        TmpPchar = strstr( BlLoaderBlock->LoadOptions, "SDIBOOT=" );
        if ( TmpPchar != NULL ) {
            TmpPchar = strchr( TmpPchar, '=' ) + 1;
            RamdiskSdiBoot( TmpPchar );
        }
    }
#endif

    if (GraphicsMode) {

        HW_CURSOR(0x80000000,0x12);
        VgaEnableVideo();

        LoadBootLogoBitmap (LoadDeviceId, LoadFileName);
        if (DisplayLogoOnBoot) {
            PrepareGfxProgressBar();
            BlUpdateBootStatus();
        }
    }

    //
    // Initiate filesystem metadata caching on the load device.
    //
    // NOTE: From here on access the LoadDevice only through the LoadDeviceId.
    // This way, your access will be faster because it is cached. Otherwise if
    // you make writes, you will have cache consistency issues.
    //
    if (bDiskCacheInitialized) {
        BlDiskCacheStartCachingOnDevice(LoadDeviceId);
    }

    //
    // Build the load device path set. We keep multiple paths so that we can
    // fall back to a last known driver set during a last known good boot.
    //
    strcpy(LoadDevicePath, LoadFileName);
    strcat(LoadDevicePath, "\\");
    strcpy(LoadDeviceLKG1Path, LoadDevicePath);
    strcat(LoadDeviceLKG1Path, LAST_KNOWN_GOOD_TEMPORARY_PATH "\\" );
    strcpy(LoadDeviceLKG2Path, LoadDevicePath);
    strcat(LoadDeviceLKG2Path, LAST_KNOWN_GOOD_WORKING_PATH "\\" );

#if defined(_X86_)
    //
    // Read in the XIP image
    //
    if (XIPEnabled) {
        ULONG_PTR addr = KSEG0_BASE | (XIPBasePage << PAGE_SHIFT);
        ULONG FileId;

        //
        // Read in the imagefile
        //
        Status = BlOpen(LoadDeviceId, XIPLoadPath, ArcOpenReadOnly, &FileId);
        if (Status == ESUCCESS) {
            Status = XipLargeRead(FileId, XIPBasePage, XIPPageCount);
            (void) BlClose(FileId);
        }

        if (Status != ESUCCESS) {
            XIPEnabled = FALSE;
        }
    }
#endif //_X86_

    i = 0;

    if (bLastKnownGood) {

        //
        // Add the last known good paths as if we are in a LastKnownGood boot.
        //
        LoadDevicePathSet.Source[i].DeviceId = LoadDeviceId;
        LoadDevicePathSet.Source[i].DeviceName = LoadDevice;
        LoadDevicePathSet.Source[i].DirectoryPath = LoadDeviceLKG1Path;
        i++;

        LoadDevicePathSet.Source[i].DeviceId = LoadDeviceId;
        LoadDevicePathSet.Source[i].DeviceName = LoadDevice;
        LoadDevicePathSet.Source[i].DirectoryPath = LoadDeviceLKG2Path;
        i++;
    }

    LoadDevicePathSet.Source[i].DeviceId = LoadDeviceId;
    LoadDevicePathSet.Source[i].DeviceName = LoadDevice;
    LoadDevicePathSet.Source[i].DirectoryPath = LoadDevicePath;

    //
    // The load path sources are all relative to \SystemRoot.
    //
    LoadDevicePathSet.AliasName = "\\SystemRoot";
    LoadDevicePathSet.PathOffset[0] = '\0';
    LoadDevicePathSet.PathCount = ++i;

    //
    // While here, form the kernel path set. This is the same as the boot path
    // set except that it's off of system32/64. Note also that we don't add in
    // the LKG path today.
    //
    KernelPathSet.PathCount = 1;
    KernelPathSet.AliasName = "\\SystemRoot";
    strcpy(KernelPathSet.PathOffset, SYSTEM_DIRECTORY_PATH "\\" );
    KernelPathSet.Source[0].DeviceId = LoadDeviceId;
    KernelPathSet.Source[0].DeviceName = LoadDevice;
    KernelPathSet.Source[0].DirectoryPath = LoadDevicePath;

    //
    // While here, form the fully qualified kernel path.
    //
    strcpy(KernelDirectoryPath, LoadFileName);
    strcat(KernelDirectoryPath, "\\" SYSTEM_DIRECTORY_PATH "\\" );

    //
    // Now put together everything we need to describe the system device. This
    // is where we get the hal and pal from. There is no alias for this path
    // (ie no equivalent to \SystemRoot.)
    //
    SystemDevice = BlGetArgumentValue(Argc, Argv, "systempartition");

    if (SystemDevice == NULL) {
        Status = ENODEV;
        BlFatalError(LOAD_HW_FW_CFG_CLASS,
                     DIAG_BL_FW_GET_SYSTEM_DEVICE,
                     LOAD_HW_FW_CFG_ACT);

        goto LoadFailed;
    }

    //
    // Translate it's signature based arc name
    //
    TmpPchar = BlTranslateSignatureArcName( SystemDevice );
    if (TmpPchar) {
        SystemDevice = TmpPchar;
    }

    //
    // Open the system device. If SystemDevice path and LoadDevice
    // path are the same [as on all x86 I have seen so far], do not
    // open the device under another device id so we can use disk
    // caching. Otherwise there may be a cache consistency issue.
    //
    if (!_stricmp(LoadDevice, SystemDevice))  {

        SystemDeviceId = LoadDeviceId;

    } else {

        Status = ArcOpen(SystemDevice, ArcOpenReadWrite, &SystemDeviceId);
        if (Status != ESUCCESS) {

            BlFatalError(LOAD_HW_FW_CFG_CLASS,
                         DIAG_BL_FW_OPEN_SYSTEM_DEVICE,
                         LOAD_HW_FW_CFG_ACT);

            goto LoadFailed;
        }
    }

    //
    // Initiate filesystem metadata caching on the system device.
    //
    // NOTE: From here on access the SystemDevice only through the
    // SystemDeviceId. This way, your access will be faster because it is
    // cached. Otherwise if you make writes, you will have cache consistency
    // issues.
    //
    if (bDiskCacheInitialized) {
        if (SystemDeviceId != LoadDeviceId) {
            BlDiskCacheStartCachingOnDevice(SystemDeviceId);
        }
    }

    //
    // Get the path name of the OS loader file and isolate the directory
    // path so it can be used to load the HAL DLL.
    //
    // Note well: We actually don't use this path to load the hal anymore 
    // -- we rely on the kernel path to load the hal as they are at the same
    //    location
    // -- we do use this path for identifying the system partition, so do not
    //    remove code related to systemdevicepath unless you know what you're
    //    doing.
    //

    FileName = OsLoader;

    DirectoryEnd = strrchr(FileName, '\\');
    FileName = strchr(FileName, '\\');
    SystemDevicePath[0] = 0;
    if (DirectoryEnd != NULL) {
        Limit = (ULONG)((ULONG_PTR)DirectoryEnd - (ULONG_PTR)FileName + 1);
        for (Index = 0; Index < Limit; Index += 1) {
            SystemDevicePath[Index] = *FileName++;
        }

        SystemDevicePath[Index] = 0;
    }


    //
    // Describe our hal paths.
    //
    // ISSUE-2000/03/29-ADRIAO: LastKnownGood enhancements
    //     On x86 we'd like to support LKG for hals way into the future. Ideally
    // we'd get them from \Winnt\LastGood\System32. Unfortunately, we get back
    // \Winnt\System32 from the Arc, making it kinda hard to splice in our
    // LKG path.
    //
    // ISSUE-2000/03/29-ADRIAO: Existant namespace polution
    //     We need to come up with an Alias for the Hal path so that it can
    // properly be inserted into the image namespace. Either that or we should
    // consider lying and saying it comes from \SystemRoot. Note that on x86
    // we probably *would* want it to say it was from \SystemRoot in case it
    // brings in its own DLL's!
    //

    SystemDevicePathSet.PathCount = 1;
    SystemDevicePathSet.AliasName = NULL;
    SystemDevicePathSet.PathOffset[0] = '\0';
    SystemDevicePathSet.Source[0].DeviceId = SystemDeviceId;
    SystemDevicePathSet.Source[0].DeviceName = SystemDevice;
    SystemDevicePathSet.Source[0].DirectoryPath = SystemDevicePath;
    //
    // Handle triage dump (if present).
    //

    Status = BlLoadTriageDump (LoadDeviceId,
                               &BlLoaderBlock->Extension->TriageDumpBlock);

    if (Status != ESUCCESS) {
        BlLoaderBlock->Extension->TriageDumpBlock = NULL;
    }

    //
    // Handle hibernation image (if present)
    //

#if defined(i386) || defined(_IA64_)

    Status = BlHiberRestore(LoadDeviceId, NULL);
    if (Status != ESUCCESS) {
        Status = ESUCCESS;
        goto LoadFailed;
    }

#endif

    //
    // Initialize the logging system. Note that we dump to the system device
    // and not the load device.
    //

    BlLogInitialize(SystemDeviceId);

#if defined(REMOTE_BOOT)
    //
    // If booting from the net, check for any of the following:
    //    - The client-side disk is incorrect for this NetPC.
    //    - The client-side cache is stale.
    //

    if (BlBootingFromNet) {

        BlLoaderBlock->SetupLoaderBlock = BlAllocateHeap(sizeof(SETUP_LOADER_BLOCK));
        if (BlLoaderBlock->SetupLoaderBlock == NULL) {
            Status = ENOMEM;
            BlFatalError(LOAD_HW_MEM_CLASS,
                         DIAG_BL_MEMORY_INIT,
                         LOAD_HW_MEM_ACT);
            goto LoadFailed;
        }

        //
        // ISSUE-1998/07/13-JVert (John Vert)
        //      Code below is ifdef'd out because net boot is no longer
        //      in the product. BlCheckMachineReplacement ends up calling
        //      SlDetectHAL, which now requires access to txtsetup.sif
        //      in order to see if an ACPI machine has a known "good" BIOS.
        //      Since there is no txtsetup.sif during a normal boot there
        //      is no point in getting all the INF processing logic into
        //      NTLDR.
        // ISSUE-1998/07/16-ChuckL (Chuck Lenzmeier)
        //      This means that if we ever reenable full remote boot, as
        //      opposed to just remote install, and we want to be able to
        //      do machine replacement, we're going to have to figure out
        //      how to make SlDetectHAL work outside of textmode setup.
        //

        strncpy(OutputBuffer, LoadFileName + 1, 256);
        TmpPchar = strchr(OutputBuffer, '\\');
        TmpPchar++;
        TmpPchar = strchr(TmpPchar, '\\');
        TmpPchar++;
        strcpy(TmpPchar, "startrom.com");

        BlCheckMachineReplacement(SystemDevice, SystemDeviceId, NetRebootParameter, OutputBuffer);

    } else
#endif // defined(REMOTE_BOOT)
    {
        BlLoaderBlock->SetupLoaderBlock = NULL;
    }



    //
    // See if we're redirecting.
    //
    if( LoaderRedirectionInformation.PortAddress ) {

        //
        // Yes, we are redirecting right now.  Use these settings.
        //
        BlLoaderBlock->Extension->HeadlessLoaderBlock = BlAllocateHeap(sizeof(HEADLESS_LOADER_BLOCK));

        RtlCopyMemory( BlLoaderBlock->Extension->HeadlessLoaderBlock,
                       &LoaderRedirectionInformation,
                       sizeof(HEADLESS_LOADER_BLOCK) );

    } else {

        BlLoaderBlock->Extension->HeadlessLoaderBlock = NULL;

    }


    //
    // Generate the full path name for the HAL DLL image and load it into
    // memory.
    //

    strcpy(HalPathName, KernelDirectoryPath);
    strcat(HalPathName, HalFileName);

    //
    // Prepare for building the full path name of the kernel
    //

    strcpy(KernelPathName, KernelDirectoryPath);

#if defined(_X86_) 

    //
    // On X86, there are two kernel images: one compiled for PAE mode,
    // and one not.  Call a routine that decides what to load.
    //
    // Upon successful return, KernelPathName contains the full path of
    // the kernel image.
    //

    
    Status = Blx86CheckForPaeKernel( userSpecifiedPae,
                                     userSpecifiedNoPae,
                                     userSpecifiedKernelName,
                                     HalPathName,
                                     LoadDeviceId,
                                     SystemDeviceId,
                                     &highestSystemPage,
                                     &BlUsePae,
                                     KernelPathName
                                     );
    if (Status != ESUCCESS) {

        //
        // A valid kernel compatible with this processor could not be located.
        // This is fatal.
        //
        BlFatalError(LOAD_SW_MIS_FILE_CLASS,
                     (Status == EBADF)
                      ? DIAG_BL_LOAD_HAL_IMAGE
                      : DIAG_BL_LOAD_SYSTEM_IMAGE,
                     LOAD_SW_FILE_REINST_ACT);
        goto LoadFailed;
    }

#else

    //
    // Generate the full pathname of ntoskrnl.exe
    //
    //      "\winnt\system32\ntoskrnl.exe"
    //
    strcat(KernelPathName, KernelFileName);

#endif

    //
    // Set allocatable range to the kernel-specific range
    //
    BlUsableBase  = BL_KERNEL_RANGE_LOW;
    BlUsableLimit = BL_KERNEL_RANGE_HIGH;

    //
    // Initialize the progress bar
    //
    if( BlIsTerminalConnected() ) {
        BlOutputStartupMsg(BL_MSG_STARTING_WINDOWS);    
        BlOutputTrailerMsg(BL_ADVANCED_BOOT_MESSAGE);

    }



#if defined (_X86_)

    BlpCheckVersion(LoadDeviceId,KernelPathName);


#endif


    //
    // Load the kernel image into memory.
    //
    BlOutputLoadMessage(LoadDevice, KernelPathName, NULL);

#ifdef i386
retrykernel:
#endif
    Status = BlLoadImage(LoadDeviceId,
                         LoaderSystemCode,
                         KernelPathName,
                         TARGET_IMAGE,
                         &SystemBase);
#ifdef i386
    //
    // If the kernel didn't fit in the preferred range, reset the range to
    // all of memory and try again.
    //
    if ((Status == ENOMEM) &&
        ((BlUsableBase != BL_DRIVER_RANGE_LOW) ||
         (BlUsableLimit != BL_DRIVER_RANGE_HIGH))) {
        BlUsableBase = BL_DRIVER_RANGE_LOW;
        BlUsableLimit = BL_DRIVER_RANGE_HIGH;

        goto retrykernel;
    }
#endif

    
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_SW_MIS_FILE_CLASS,
                     DIAG_BL_LOAD_SYSTEM_IMAGE,
                     LOAD_SW_FILE_REINST_ACT);

        goto LoadFailed;
    }

    BlUpdateBootStatus();

    //
    // Whatever filesystem was used to load the kernel image is the
    // one that needs to be loaded along with the boot drivers.
    //

#if defined(REMOTE_BOOT)
    if (BlBootingFromNet) {

        //
        // For a remote boot, the boot file system is always NTFS.
        //

        BootFileSystem = L"ntfs";

    } else
#endif // defined(REMOTE_BOOT)

    {
        FsInfo = BlGetFsInfo(LoadDeviceId);
        if (FsInfo != NULL) {
            BootFileSystem = FsInfo->DriverName;

        } else {
            BlFatalError(LOAD_SW_MIS_FILE_CLASS,
                         DIAG_BL_LOAD_SYSTEM_IMAGE,
                         LOAD_SW_FILE_REINST_ACT);

            goto LoadFailed;
        }
    }

    //
    // Load the HAL DLL image into memory.
    //

    BlOutputLoadMessage(LoadDevice, HalPathName, NULL);

#ifdef i386
retryhal:
#endif
    Status = BlLoadImage(LoadDeviceId,
                         LoaderHalCode,
                         HalPathName,
                         TARGET_IMAGE,
                         &HalBase);
#ifdef i386
    //
    // If the HAL didn't fit in the preferred range, reset the range to
    // all of memory and try again.
    //
    if ((Status == ENOMEM) &&
        ((BlUsableBase != BL_DRIVER_RANGE_LOW) ||
         (BlUsableLimit != BL_DRIVER_RANGE_HIGH))) {
        BlUsableBase = BL_DRIVER_RANGE_LOW;
        BlUsableLimit = BL_DRIVER_RANGE_HIGH;

        goto retryhal;
    }
#endif

    if (Status != ESUCCESS) {
        BlFatalError(LOAD_SW_MIS_FILE_CLASS,
                     DIAG_BL_LOAD_HAL_IMAGE,
                     LOAD_SW_FILE_REINST_ACT);

        goto LoadFailed;
    }

    BlUpdateBootStatus();

    //
    // Load the Kernel Debugger DLL image into memory.
    //
    KdDllLoadFailed = FALSE;
    strcpy(&KdDllName[0], KernelDirectoryPath);
    strcat(&KdDllName[0], KdFileName);

    BlOutputLoadMessage(LoadDevice, &KdDllName[0], NULL);

    Status = BlLoadImage(LoadDeviceId,
                         LoaderSystemCode,
                         &KdDllName[0],
                         TARGET_IMAGE,
                         &KdDllBase);

    if ((Status != ESUCCESS) && (UseAlternateKdDll == TRUE)) {
        UseAlternateKdDll = FALSE;

        strcpy(&KdDllName[0], KernelDirectoryPath);
        strcat(&KdDllName[0], "kdcom.dll");

        BlOutputLoadMessage(LoadDevice, &KdDllName[0], NULL);

        Status = BlLoadImage(LoadDeviceId,
                             LoaderSystemCode,
                             &KdDllName[0],
                             TARGET_IMAGE,
                             &KdDllBase);
    }

    //
    // Don't bugcheck if KDCOM.DLL is not present, we may be trying to dual-
    // boot an older OS.  If we really do require KDCOM.DLL, we will fail to
    // scan the import table for the system image, and bugcheck with kernel
    // needed DLLs to load
    //
    if (Status != ESUCCESS) {
        KdDllLoadFailed = TRUE;
    }

    BlUpdateBootStatus();

    //
    // Set allocatable range to the driver-specific range
    //
    BlUsableBase  = BL_DRIVER_RANGE_LOW;
    BlUsableLimit = BL_DRIVER_RANGE_HIGH;

    //
    // Generate a loader data entry for the system image.
    //

    Status = BlAllocateDataTableEntry("ntoskrnl.exe",
                                      KernelPathName,
                                      SystemBase,
                                      &SystemDataTableEntry);

    if (Status != ESUCCESS) {
        BlFatalError(LOAD_SW_INT_ERR_CLASS,
                     DIAG_BL_LOAD_SYSTEM_IMAGE,
                     LOAD_SW_INT_ERR_ACT);

        goto LoadFailed;
    }

    //
    // Generate a loader data entry for the HAL DLL.
    //

    Status = BlAllocateDataTableEntry("hal.dll",
                                      HalPathName,
                                      HalBase,
                                      &HalDataTableEntry);

    if (Status != ESUCCESS) {
        BlFatalError(LOAD_SW_INT_ERR_CLASS,
                     DIAG_BL_LOAD_HAL_IMAGE,
                     LOAD_SW_INT_ERR_ACT);

        goto LoadFailed;
    }

    //
    // Generate a loader data entry for the Kernel Debugger DLL.
    //

    if (!KdDllLoadFailed) {
        Status = BlAllocateDataTableEntry("kdcom.dll",
                                          KdDllName,
                                          KdDllBase,
                                          &KdDataTableEntry);

        if (Status != ESUCCESS) {
            BlFatalError(LOAD_SW_INT_ERR_CLASS,
                         DIAG_BL_LOAD_SYSTEM_DLLS,
                         LOAD_SW_INT_ERR_ACT);

            goto LoadFailed;
        }
    }

    //
    // Scan the import table for the system image and load all referenced
    // DLLs.
    //

    Status = BlScanImportDescriptorTable(&KernelPathSet,
                                         SystemDataTableEntry,
                                         LoaderSystemCode);

    if (Status != ESUCCESS) {
        BlFatalError(LOAD_SW_INT_ERR_CLASS,
                     DIAG_BL_LOAD_SYSTEM_DLLS,
                     LOAD_SW_INT_ERR_ACT);

        goto LoadFailed;
    }

    //
    // Scan the import table for the HAL DLL and load all referenced DLLs.
    //

    Status = BlScanImportDescriptorTable(&KernelPathSet,
                                         HalDataTableEntry,
                                         LoaderHalCode);

    if (Status != ESUCCESS) {
        BlFatalError(LOAD_SW_INT_ERR_CLASS,
                     DIAG_BL_LOAD_HAL_DLLS,
                     LOAD_SW_INT_ERR_ACT);

        goto LoadFailed;
    }

    //
    // Scan the import table for the Kernel Debugger DLL and load all
    // referenced DLLs.
    //

    if (!KdDllLoadFailed) {
        Status = BlScanImportDescriptorTable(&KernelPathSet,
                                             KdDataTableEntry,
                                             LoaderSystemCode);


        if (Status != ESUCCESS) {
            BlFatalError(LOAD_SW_INT_ERR_CLASS,
                         DIAG_BL_LOAD_SYSTEM_DLLS,
                         LOAD_SW_INT_ERR_ACT);

            goto LoadFailed;
        }
    }

    //
    // Relocate the system entry point and set system specific information.
    //

    NtHeaders = RtlImageNtHeader(SystemBase);
    SystemEntry = (PTRANSFER_ROUTINE)((ULONG_PTR)SystemBase +
                                NtHeaders->OptionalHeader.AddressOfEntryPoint);


#if defined(_IA64_)

    BlLoaderBlock->u.Ia64.KernelVirtualBase = (ULONG_PTR)SystemBase;
    BlLoaderBlock->u.Ia64.KernelPhysicalBase = (ULONG_PTR)SystemBase & 0x7fffffff;

#endif

    //
    // Allocate a structure for NLS data which will be loaded and filled
    // by BlLoadAndScanSystemHive.
    //

    BlLoaderBlock->NlsData = BlAllocateHeap(sizeof(NLS_DATA_BLOCK));
    if (BlLoaderBlock->NlsData == NULL) {
        Status = ENOMEM;
        BlFatalError(LOAD_HW_MEM_CLASS,
                     DIAG_BL_LOAD_SYSTEM_HIVE,
                     LOAD_HW_MEM_ACT);

        goto LoadFailed;
    }

#if defined(REMOTE_BOOT)
    //
    // If booting from the net, we use the SetupLoaderBlock to pass
    // information. BlLoadAndScanSystemHive fills in the netboot card
    // fields if present in the registry.
    //

    if (BlBootingFromNet) {

        BlLoaderBlock->SetupLoaderBlock->NetbootCardInfo = BlAllocateHeap(sizeof(NET_CARD_INFO));
        if ( BlLoaderBlock->SetupLoaderBlock->NetbootCardInfo == NULL ) {
            Status = ENOMEM;
            BlFatalError(LOAD_HW_MEM_CLASS,
                         DIAG_BL_MEMORY_INIT,
                         LOAD_HW_MEM_ACT);
            goto LoadFailed;
        }
        BlLoaderBlock->SetupLoaderBlock->NetbootCardInfoLength = sizeof(NET_CARD_INFO);
    }
#endif // defined(REMOTE_BOOT)

    //
    // Load the SYSTEM hive.
    //
    //
    bLastKnownGoodChosenLate = bLastKnownGood;
    Status = BlLoadAndScanSystemHive(LoadDeviceId,
                                     LoadDevice,
                                     LoadFileName,
                                     BootFileSystem,
                                     &bLastKnownGoodChosenLate,
                                     &ServerHive,
                                     BadFileName);

    if (Status != ESUCCESS) {
        if (BlRebootSystem != FALSE) {
            Status = ESUCCESS;

        } else {
            BlBadFileMessage(BadFileName);
        }

        goto LoadFailed;
    }

    if (bLastKnownGoodChosenLate) {

        //
        // The user may have selected last known good boot after the kernel and
        // friends were loaded. Update the boot path list here as neccessary.
        //
        if (!bLastKnownGood) {

            ASSERT((LoadDevicePathSet.PathCount < MAX_PATH_SOURCES) &&
                   (LoadDevicePathSet.PathCount == 1));

            //
            // Move the current boot path to the end of our last good array.
            //
            LoadDevicePathSet.Source[2] = LoadDevicePathSet.Source[0];

            //
            // Add the last known good paths as if we are in a LastKnownGood boot.
            //
            LoadDevicePathSet.Source[0].DeviceId = LoadDeviceId;
            LoadDevicePathSet.Source[0].DeviceName = LoadDevice;
            LoadDevicePathSet.Source[0].DirectoryPath = LoadDeviceLKG1Path;

            LoadDevicePathSet.Source[1].DeviceId = LoadDeviceId;
            LoadDevicePathSet.Source[1].DeviceName = LoadDevice;
            LoadDevicePathSet.Source[1].DirectoryPath = LoadDeviceLKG2Path;

            LoadDevicePathSet.PathCount = 3;

            bLastKnownGood = TRUE;
        }

    } else {

        //
        // The user might have changed his mind and deselected LKG. If so undo
        // the path work here.
        //
        if (bLastKnownGood) {

            ASSERT((LoadDevicePathSet.PathCount < MAX_PATH_SOURCES) &&
                   (LoadDevicePathSet.PathCount == 3));

            //
            // Move the current boot path to the end of our last good array.
            //
            LoadDevicePathSet.Source[0] = LoadDevicePathSet.Source[2];

            LoadDevicePathSet.PathCount = 1;

            bLastKnownGood = FALSE;
        }
    }

    //
    // Count the number of drivers we need to load
    //
    BlMaxFilesToLoad = BlNumFilesLoaded;

    BootDriverListHead = &(BlLoaderBlock->BootDriverListHead);
    NextEntry = BootDriverListHead->Flink ;

    while (NextEntry != BootDriverListHead) {
        DriverNode = CONTAINING_RECORD(NextEntry,
                                       BOOT_DRIVER_NODE,
                                       ListEntry.Link);

        DriverEntry = &DriverNode->ListEntry;
        NextEntry = DriverEntry->Link.Flink;
        BlMaxFilesToLoad++;
    }

    //
    // Rescale the progress bar
    //
    BlRedrawProgressBar();

    //
    // Insert the headless driver onto the boot driver list if this is supposed to be a
    // headless boot.
    //
    // The SAC is only availabe on server products, so we need to check the
    // product type.
    //

    if ((BlLoaderBlock->Extension->HeadlessLoaderBlock != NULL) && ServerHive) {

        BlAddToBootDriverList(
            &BlLoaderBlock->BootDriverListHead,
            L"sacdrv.sys",  // Driver name
            L"sacdrv",      // Service
            L"SAC",         // Group
            1,              // Tag
            NormalError,    // ErrorControl
            TRUE            // Insert at head of list
            );

    }


#if defined(REMOTE_BOOT)
    //
    // If booting from the net, then save the IP address and subnet mask,
    // and determine which net card driver we need to load. This may involve
    // doing an exchange with the server if the registry is not set up
    // correctly.
    //

    if (BlBootingFromNet && NetworkBootRom) {

        NET_CARD_INFO tempNetCardInfo;
        PSETUP_LOADER_BLOCK setupLoaderBlock = BlLoaderBlock->SetupLoaderBlock;

        //
        //  Pass DHCP information to OS for use by TCP/IP
        //

        setupLoaderBlock->IpAddress = NetLocalIpAddress;
        setupLoaderBlock->SubnetMask = NetLocalSubnetMask;
        setupLoaderBlock->DefaultRouter = NetGatewayIpAddress;
        setupLoaderBlock->ServerIpAddress = NetServerIpAddress;

        //
        // Get information about the net card from the ROM.
        //

        NtStatus = NetQueryCardInfo(
                     &tempNetCardInfo
                     );

        if (NtStatus != STATUS_SUCCESS) {
            Status = ENOMEM;
            BlFatalError(LOAD_HW_MEM_CLASS,
                         DIAG_BL_MEMORY_INIT,
                         LOAD_HW_MEM_ACT);
            goto LoadFailed;
        }

        //
        // If the net card info is the same as the one that BlLoadAndScanSystemHive
        // stored in the setup loader block, and it also read something into
        // the hardware ID and driver name parameters, then we are fine,
        // otherwise we need to do an exchange with the server to get
        // the information.
        //
        // If we don't do an exchange with the server, then NetbootCardRegistry
        // will stay NULL, which will be OK because even if the card has
        // moved to a different slot, the registry params still go in the
        // same place.
        //

        if ((memcmp(
                 &tempNetCardInfo,
                 setupLoaderBlock->NetbootCardInfo,
                 sizeof(NET_CARD_INFO)) != 0) ||
            (setupLoaderBlock->NetbootCardHardwareId[0] == L'\0') ||
            (setupLoaderBlock->NetbootCardDriverName[0] == L'\0') ||
            (setupLoaderBlock->NetbootCardServiceName[0] == L'\0')) {

            //
            // This call may allocate setupLoaderBlock->NetbootCardRegistry
            //

            //
            // If we ever do go back to remote boot land, we'll have
            // to fill the second parameter with the server setup path of the
            // flat NT image.  It doesn't look like we conveniently have it
            // here so we might have to store it in the setup loader block
            // so that we can pass it in here.  We'll postpone this work
            // until we do the full remote install work.  The path should be
            // set to \srv\reminst\setup\english\images\cd1911.
            //

            NtStatus = NetQueryDriverInfo(
                         &tempNetCardInfo,
                         NULL,
                         SavedLoadFileName,
                         setupLoaderBlock->NetbootCardHardwareId,
                         sizeof(setupLoaderBlock->NetbootCardHardwareId),
                         setupLoaderBlock->NetbootCardDriverName,
                         NULL,       // don't need NetbootCardDriverName in ANSI
                         sizeof(setupLoaderBlock->NetbootCardDriverName),
                         setupLoaderBlock->NetbootCardServiceName,
                         sizeof(setupLoaderBlock->NetbootCardServiceName),
                         &setupLoaderBlock->NetbootCardRegistry,
                         &setupLoaderBlock->NetbootCardRegistryLength);

            if (NtStatus != STATUS_SUCCESS) {
                Status = ENOMEM;
                BlFatalError(LOAD_HW_MEM_CLASS,
                             DIAG_BL_MEMORY_INIT,
                             LOAD_HW_MEM_ACT);
                goto LoadFailed;
            }

            //
            //  if we detected a new card, then remember to pin it later.
            //

            if (setupLoaderBlock->NetbootCardRegistry != NULL) {

                setupLoaderBlock->Flags |= SETUPBLK_FLAGS_PIN_NET_DRIVER;
            }
        }

        //
        // Add an entry to the BootDriverList for the netboot card,
        // because it will either not have a registry entry or else
        // will have one with Start set to 3.
        //
        // NOTE: This routine does NOT resort the list.
        //

        BlAddToBootDriverList(
            &BlLoaderBlock->BootDriverListHead,
            setupLoaderBlock->NetbootCardDriverName,
            setupLoaderBlock->NetbootCardServiceName,
            L"NDIS",        // Group
            1,              // Tag
            NormalError,    // ErrorControl
            FALSE           // Insert at Tail of list
            );

        RtlMoveMemory(
            setupLoaderBlock->NetbootCardInfo,
            &tempNetCardInfo,
            sizeof(NET_CARD_INFO)
            );

    }
#endif // defined(REMOTE_BOOT)

    //
    // Load boot drivers
    //
    Status = BlLoadBootDrivers(&LoadDevicePathSet,
                               &BlLoaderBlock->BootDriverListHead,
                               BadFileName);

    if (Status != ESUCCESS) {
        if (BlRebootSystem != FALSE) {
            Status = ESUCCESS;

        } else {
            BlBadFileMessage(BadFileName);
        }

        goto LoadFailed;
    }

#if defined(REMOTE_BOOT)
    if (BlBootingFromNet) {

        ARC_STATUS ArcStatus;
        ULONG FileId;

        //
        // Exchange with the server to set up for the future IPSEC conversation
        // we will have. Whether IPSEC is enabled is determined in BlLoadAndScanSystemHives.
        //

        if ((BlLoaderBlock->SetupLoaderBlock->Flags & SETUPBLK_FLAGS_IPSEC_ENABLED) != 0) {

            BlLoaderBlock->SetupLoaderBlock->IpsecInboundSpi = 0x11111111;

            NetPrepareIpsec(
                BlLoaderBlock->SetupLoaderBlock->IpsecInboundSpi,
                &BlLoaderBlock->SetupLoaderBlock->IpsecSessionKey,
                &BlLoaderBlock->SetupLoaderBlock->IpsecOutboundSpi
                );
        }

        //
        // Indicate whether the CSC needs to be repinned or disabled.
        //

        if ( NetBootRepin ) {
            BlLoaderBlock->SetupLoaderBlock->Flags |= SETUPBLK_FLAGS_REPIN;
        }
        if ( !NetBootCSC ) {
            BlLoaderBlock->SetupLoaderBlock->Flags |= SETUPBLK_FLAGS_DISABLE_CSC;
        }

        //
        // Restore the server\share at the front of the OsLoader and
        // LoadFileName strings.
        //

        OsLoader = SavedOsLoader;
        LoadFileName = SavedLoadFileName;

        //
        // Read the secret off the disk, if there is one, and store it
        // in the loader block.
        //

        ArcStatus = BlOpenRawDisk(&FileId);

        if (ArcStatus == ESUCCESS) {

            BlLoaderBlock->SetupLoaderBlock->NetBootSecret = BlAllocateHeap(sizeof(RI_SECRET));
            if (BlLoaderBlock->SetupLoaderBlock->NetBootSecret == NULL) {
                Status = ENOMEM;
                BlFatalError(LOAD_HW_MEM_CLASS,
                             DIAG_BL_MEMORY_INIT,
                             LOAD_HW_MEM_ACT);
                goto LoadFailed;
            }

            ArcStatus = BlReadSecret(
                            FileId,
                            (PRI_SECRET)(BlLoaderBlock->SetupLoaderBlock->NetBootSecret));
            if (Status != ESUCCESS) {
                BlFatalError(LOAD_HW_MEM_CLASS,
                             DIAG_BL_MEMORY_INIT,
                             LOAD_HW_MEM_ACT);
                goto LoadFailed;
            }

            ArcStatus = BlCloseRawDisk(FileId);

            //
            // By now we have TFTPed some files so this will be TRUE if it
            // is ever going to be.
            //

            BlLoaderBlock->SetupLoaderBlock->NetBootUsePassword2 = NetBootTftpUsedPassword2;
        }

    }
#endif // defined(REMOTE_BOOT)

    //
    // Generate the ARC boot device name and NT path name.
    //

    Status = BlGenerateDeviceNames(LoadDevice, &DeviceName[0], &DevicePrefix[0]);
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_HW_FW_CFG_CLASS,
                     DIAG_BL_ARC_BOOT_DEV_NAME,
                     LOAD_HW_FW_CFG_ACT);

        goto LoadFailed;
    }

    FileSize = strlen(&DeviceName[0]) + 1;
    FileName = (PCHAR)BlAllocateHeap(FileSize);
    strcpy(FileName, &DeviceName[0]);
    BlLoaderBlock->ArcBootDeviceName = FileName;

    FileSize = strlen(LoadFileName) + 2;
    FileName = (PCHAR)BlAllocateHeap( FileSize);
    strcpy(FileName, LoadFileName);
    strcat(FileName, "\\");
    BlLoaderBlock->NtBootPathName = FileName;

    //
    // Generate the ARC HAL device name and NT path name.
    //
    // On the x86, the systempartition variable lies, and instead points to
    // the location of the hal. Therefore, the variable, 'X86SystemPartition'
    // is defined for the real system partition.
    //

#if defined(_X86_)

    x86SystemPartition = BlGetArgumentValue(Argc, Argv, "x86systempartition");
    strcpy(&DeviceName[0], x86SystemPartition);

#else

    Status = BlGenerateDeviceNames(SystemDevice, &DeviceName[0], &DevicePrefix[0]);
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_HW_FW_CFG_CLASS,
                     DIAG_BL_ARC_BOOT_DEV_NAME,
                     LOAD_HW_FW_CFG_ACT);

        goto LoadFailed;
    }

#endif

    FileSize = strlen(&DeviceName[0]) + 1;
    FileName = (PCHAR)BlAllocateHeap(FileSize);
    strcpy(FileName, &DeviceName[0]);
    BlLoaderBlock->ArcHalDeviceName = FileName;

    //
    // On the x86, this structure is unfortunately named. What we really need
    // here is the osloader path. What we actually have is a path to the HAL.
    // Since this path is always at the root of the partition, hardcode it here.
    //

#if defined(_X86_)

    FileName = (PCHAR)BlAllocateHeap(2);
    FileName[0] = '\\';
    FileName[1] = '\0';

#else

    FileSize = strlen(&SystemDevicePath[0]) + 1;
    FileName = (PCHAR)BlAllocateHeap(FileSize);
    strcpy(FileName, &SystemDevicePath[0]);

#endif

    BlLoaderBlock->NtHalPathName = FileName;

    //
    // Close the open handles & stop caching on closed devices.
    //

    ArcClose(LoadDeviceId);
    if (bDiskCacheInitialized) {
        BlDiskCacheStopCachingOnDevice(LoadDeviceId);
    }

    //
    // Close the system device only if it is different from the
    // LoadDevice.
    //

    if (SystemDeviceId != LoadDeviceId) {
        ArcClose(SystemDeviceId);
        if (bDiskCacheInitialized) {
            BlDiskCacheStopCachingOnDevice(SystemDeviceId);
        }
    }

    //
    // Bump the progress bar all the way to 100% as this is our last chance
    // before we jump into the kernel.
    //
    BlUpdateProgressBar(100);

    if ( BlBootingFromNet ) {

        //
        // If booting from Network, we should save the network information
        // in the network loader block for use by the kernel.
        //

        BlLoaderBlock->Extension->NetworkLoaderBlock = BlAllocateHeap(sizeof(NETWORK_LOADER_BLOCK));
        if (BlLoaderBlock->Extension->NetworkLoaderBlock == NULL) {
            Status = ENOMEM;
            BlFatalError(LOAD_HW_MEM_CLASS,
                         DIAG_BL_MEMORY_INIT,
                         LOAD_HW_MEM_ACT);
            goto LoadFailed;
        }

        memset( BlLoaderBlock->Extension->NetworkLoaderBlock, 0, sizeof(NETWORK_LOADER_BLOCK) );

        //
        //  Pass DHCP information to OS for use by TCP/IP
        //

        NtStatus = NetFillNetworkLoaderBlock(BlLoaderBlock->Extension->NetworkLoaderBlock);
        if (NtStatus != STATUS_SUCCESS) {
            Status = NtStatus;
            BlFatalError(LOAD_HW_MEM_CLASS,
                         DIAG_BL_MEMORY_INIT,
                         LOAD_HW_MEM_ACT);
            goto LoadFailed;
        }

        //
        // Close down the remote boot network file system.
        //
        // NOTE: If BlBootingFromNet, don't do anything after this point
        // that would cause access to the boot ROM.
        //

        NetTerminate();
    }

#if defined(_X86_)

    //
    // Write out the boot status flags to disk so we can determine if the 
    // OS fails to boot.
    //

    BlWriteBootStatusFlags(LoadDeviceId, LoadFileName, FALSE, FALSE);

#endif

#if defined(_X86_)

    //
    // Close down the arc emulator's i/o system if we initialized it.
    // This cannot be done after BlSetupForNt becase that routine will
    // unmap the miniport code the arc emulator may need to shutdown.
    //

    AETerminateIo();
#endif

    //
    // Execute the architecture specific setup code.
    //

    Status = BlSetupForNt(BlLoaderBlock);
    if (Status != ESUCCESS) {
        BlFatalError(LOAD_SW_INT_ERR_CLASS,
                     DIAG_BL_SETUP_FOR_NT,
                     LOAD_SW_INT_ERR_ACT);

        goto LoadFailed;
    }

    //
    // Turn off the debugging system.
    //

    BlLogTerminate();

    //
    // Inform boot debugger that the boot phase is complete.
    //

#if defined(ENABLE_LOADER_DEBUG) || DBG
#if (defined(_X86_) || defined(_ALPHA_)) && !defined(ARCI386)

    {
        if (BdDebuggerEnabled == TRUE) {
            DbgUnLoadImageSymbols(NULL, (PVOID)-1, 0);
        }
    }

#endif
#endif

    //
    // Transfer control to loaded image.
    //

    (SystemEntry)(BlLoaderBlock);

    //
    // Any return from the system is an error.
    //

    Status = EBADF;
    BlFatalError(LOAD_SW_BAD_FILE_CLASS,
                 DIAG_BL_KERNEL_INIT_XFER,
                 LOAD_SW_FILE_REINST_ACT);

    //
    // The load failed.
    //

LoadFailed:

    //
    // We do not know if the devices we are caching will be
    // closed/reopened etc beyond this function. To be safe,
    // uninitialize the disk caching.
    //

    if (bDiskCacheInitialized) {
        BlDiskCacheUninitialize();
    }

    return Status;
}


VOID
BlOutputLoadMessage (
    IN PCHAR DeviceName,
    IN PCHAR FileName,
    IN PTCHAR FileDescription OPTIONAL
    )

/*++

Routine Description:

    This routine outputs a loading message to the console output device.

Arguments:

    DeviceName - Supplies a pointer to a zero terminated device name.

    FileName - Supplies a pointer to a zero terminated file name.

    FileDescription - Friendly name of the file in question.

Return Value:

    None.

--*/

{

    ULONG Count;
    CHAR OutputBuffer[256];
#ifdef UNICODE
    TCHAR OutputBufferUnicode[256];
    ANSI_STRING aString;
    UNICODE_STRING uString;
#endif
    PTCHAR p;

    UNREFERENCED_PARAMETER(FileDescription);

    if(!DisplayLogoOnBoot) {

        //
        // Proceed only if no logo is displayed.

        ///////////////////////////////////////////////

        //
        // Construct and output loading file message.
        //

        if (!BlOutputDots) {
            strcpy(&OutputBuffer[0], "  ");

            if (DeviceName)
                strcat(&OutputBuffer[0], DeviceName);

            if (FileName)
                strcat(&OutputBuffer[0], FileName);

            strcat(&OutputBuffer[0], "\r\n");

            BlLog((LOG_LOGFILE,OutputBuffer));
#ifdef UNICODE
            p = OutputBufferUnicode;
            uString.Buffer = OutputBufferUnicode;
            uString.MaximumLength = sizeof(OutputBufferUnicode);
            RtlInitAnsiString(&aString, OutputBuffer );
            RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );
#else
            p = OutputBuffer;
#endif
            ArcWrite(BlConsoleOutDeviceId,
                      p,
                      _tcslen(p)*sizeof(TCHAR),
                      &Count);
        }

    }

    return;
}

ARC_STATUS
BlLoadAndScanSystemHive(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PWSTR BootFileSystem,
    IN OUT BOOLEAN *LastKnownGoodBoot,
    OUT BOOLEAN *ServerHive,
    OUT PCHAR BadFileName
    )

/*++

Routine Description:

    This function loads the system hive into memory, verifies its
    consistency, scans it for the list of boot drivers, and loads
    the resulting list of drivers.

    If the system hive cannot be loaded or is not a valid hive, it
    is rejected and the system.alt hive is used. If this is invalid,
    the boot must fail.

Arguments:

    DeviceId - Supplies the file id of the device the system tree is on.

    DeviceName - Supplies the name of the device the system tree is on.

    DirectoryPath - Supplies a pointer to the zero-terminated directory path
        of the root of the NT system32 directory.

    HiveName - Supplies the name of the SYSTEM hive

    LastKnownGoodBoot - On input, LastKnownGood indicates whether LKG has been
                        selected. This value is updated to TRUE if the user
                        chooses LKG via the profile configuration menu.

    ServerHive - Return TRUE if this is a server hive, else FALSE.

    BadFileName - Returns the file required for booting that was corrupt
        or missing.  This will not be filled in if ESUCCESS is returned.

Return Value:

    ESUCCESS  - System hive valid and all necessary boot drivers successfully
           loaded.

    !ESUCCESS - System hive corrupt or critical boot drivers not present.
                LastKnownGoodBoot receives FALSE, BadFileName contains name
                of corrupted/missing file.

--*/

{

    ARC_STATUS Status;
    PTCHAR FailReason;
    CHAR Directory[256];
    CHAR FontDirectory[256];
    UNICODE_STRING AnsiCodepage;
    UNICODE_STRING OemCodepage;
    UNICODE_STRING OemHalFont;
    UNICODE_STRING LanguageTable;
    BOOLEAN RestartSetup;
    BOOLEAN LogPresent;
    UNICODE_STRING unicodeString;

    strcpy(Directory,DirectoryPath);
    strcat(Directory,"\\system32\\config\\");

    Status = BlLoadAndInitSystemHive(DeviceId,
                                     DeviceName,
                                     Directory,
                                     "system",
                                     FALSE,
                                     &RestartSetup,
                                     &LogPresent);

    if(Status != ESUCCESS) {

        if( !LogPresent ) {
            //
            // Bogus hive, try system.alt only if no log is present.
            //
            Status = BlLoadAndInitSystemHive(DeviceId,
                                             DeviceName,
                                             Directory,
                                             "system.alt",
                                             TRUE,
                                             &RestartSetup,
                                             &LogPresent);
        }

        if(Status != ESUCCESS) {
            strcpy(BadFileName,DirectoryPath);
            strcat(BadFileName,"\\SYSTEM32\\CONFIG\\SYSTEM");
            goto HiveScanFailed;
        }
    }

    if(RestartSetup) {

        //
        // Need to restart setup.
        //

        Status = BlLoadAndInitSystemHive(DeviceId,
                                         DeviceName,
                                         Directory,
                                         "system.sav",
                                         TRUE,
                                         &RestartSetup,
                                         &LogPresent);

        if(Status != ESUCCESS) {
            strcpy(BadFileName,DirectoryPath);
            strcat(BadFileName,"\\SYSTEM32\\CONFIG\\SYSTEM.SAV");
            goto HiveScanFailed;
        }
    }

    //
    // Hive is there, it's valid, go compute the driver list and NLS
    // filenames.  Note that if this fails, there is no point in switching
    // to system.alt, since it will always be the same as system.
    //

    FailReason = BlScanRegistry(BootFileSystem,
                                LastKnownGoodBoot,
                                &BlLoaderBlock->BootDriverListHead,
                                &AnsiCodepage,
                                &OemCodepage,
                                &LanguageTable,
                                &OemHalFont,
#ifdef _WANT_MACHINE_IDENTIFICATION
                                &unicodeString,
#endif
                                BlLoaderBlock->SetupLoaderBlock,
                                ServerHive);

    if (FailReason != NULL) {
        Status = EBADF;
        strcpy(BadFileName,Directory);
        strcat(BadFileName,"SYSTEM");
        goto HiveScanFailed;
    }

    strcpy(Directory,DirectoryPath);
    strcat(Directory,"\\system32\\");

    //
    // Load NLS data tables.
    //

    Status = BlLoadNLSData(DeviceId,
                           DeviceName,
                           Directory,
                           &AnsiCodepage,
                           &OemCodepage,
                           &LanguageTable,
                           BadFileName);

    if (Status != ESUCCESS) {
        goto HiveScanFailed;
    }

    //
    // Load the OEM font file to be used by the HAL for possible frame
    // buffer displays.
    //

#ifdef i386

    if (OemHalFont.Buffer == NULL) {
        goto oktoskipfont;
    }

#endif

    //
    // On newer systems fonts are in the FONTS directory.
    // On older systems fonts are in the SYSTEM directory.
    //

    strcpy(FontDirectory, DirectoryPath);
    strcat(FontDirectory, "\\FONTS\\");
    Status = BlLoadOemHalFont(DeviceId,
                              DeviceName,
                              FontDirectory,
                              &OemHalFont,
                              BadFileName);

    if(Status != ESUCCESS) {
        strcpy(FontDirectory, DirectoryPath);
        strcat(FontDirectory, "\\SYSTEM\\");
        Status = BlLoadOemHalFont(DeviceId,
                                  DeviceName,
                                  FontDirectory,
                                  &OemHalFont,
                                  BadFileName);
    }

    if (Status != ESUCCESS) {
#ifndef i386
        goto HiveScanFailed;
#endif

    }

#ifdef i386
oktoskipfont:
#endif
    if (BlLoaderBlock->Extension && BlLoaderBlock->Extension->Size >= sizeof(LOADER_PARAMETER_EXTENSION)) {

        ULONG   majorVersion;
        ULONG   minorVersion;
        CHAR    versionBuffer[64];
        PCHAR   major;
        PCHAR   minor;

        major = strcpy(versionBuffer, VER_PRODUCTVERSION_STR);
        minor = strchr(major, '.');
        *minor++ = '\0';
        majorVersion = atoi(major);
        minorVersion = atoi(minor);
        if (    BlLoaderBlock->Extension->MajorVersion > majorVersion ||
                (BlLoaderBlock->Extension->MajorVersion == majorVersion &&
                    BlLoaderBlock->Extension->MinorVersion >= minorVersion)) {

#ifdef i386
#ifdef _WANT_MACHINE_IDENTIFICATION

            if (unicodeString.Length) {
            
                //
                // For x86 machines, read in the inf into memory for processing
                // by the kernel.
                //
    
                strcpy(Directory,DirectoryPath);
                strcat(Directory,"\\inf\\");
    
                //
                // Fail to boot if there is any error in loading this
                // critical inf.
                //
    
                Status = BlLoadBiosinfoInf( DeviceId,
                                            DeviceName,
                                            Directory,
                                            &unicodeString,
                                            &BlLoaderBlock->Extension->InfFileImage,
                                            &BlLoaderBlock->Extension->InfFileSize,
                                            BadFileName);
                if (Status != ESUCCESS) {

                    goto HiveScanFailed;
                }
            }
#endif
#endif
            RtlInitUnicodeString(&unicodeString, L"drvmain.sdb");
            strcpy(Directory,DirectoryPath);
            strcat(Directory,"\\AppPatch\\");

            //
            // Let the kernel deal with failure to load this driver database.
            //

            BlLoaderBlock->Extension->DrvDBImage = NULL;
            BlLoaderBlock->Extension->DrvDBSize = 0;
            BlLoadDrvDB(    DeviceId,
                            DeviceName,
                            Directory,
                            &unicodeString,
                            &BlLoaderBlock->Extension->DrvDBImage,
                            &BlLoaderBlock->Extension->DrvDBSize,
                            BadFileName);
        }
    }

HiveScanFailed:

    if (Status != ESUCCESS) {

        *LastKnownGoodBoot = FALSE;
    }

    return(Status);
}

VOID
BlBadFileMessage(
    IN PCHAR BadFileName
    )

/*++

Routine Description:

    This function displays the error message for a missing or incorrect
    critical file.

Arguments:

    BadFileName - Supplies the name of the file that is missing or
                  corrupt.

Return Value:

    None.

--*/

{

    ULONG Count;
    PTCHAR Text;
    PTSTR  pBadFileName;
#ifdef UNICODE
    WCHAR BadFileNameW[128];
    ANSI_STRING aString;
    UNICODE_STRING uString;

    pBadFileName = BadFileNameW;
    uString.Buffer = BadFileNameW;
    uString.MaximumLength = sizeof(BadFileNameW);
    RtlInitAnsiString(&aString, BadFileName);
    RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );
#else
    pBadFileName = BadFileName;
#endif

    ArcWrite(BlConsoleOutDeviceId,
             TEXT("\r\n"),
             _tcslen(TEXT("\r\n"))*sizeof(TCHAR),
             &Count);


    //
    // Remove any remains from the last known good message.
    //

    BlClearToEndOfScreen();
    Text = BlFindMessage(LOAD_SW_MIS_FILE_CLASS);
    if (Text != NULL) {
        ArcWrite(BlConsoleOutDeviceId,
                 Text,
                 _tcslen(Text)*sizeof(TCHAR),
                 &Count);
    }
    
    ArcWrite(BlConsoleOutDeviceId,
             pBadFileName,
             _tcslen(pBadFileName)*sizeof(TCHAR),
             &Count);

    ArcWrite(BlConsoleOutDeviceId,
             TEXT("\r\n\r\n"),
             _tcslen(TEXT("\r\n\r\n"))*sizeof(TCHAR),
             &Count);

    Text = BlFindMessage(LOAD_SW_FILE_REST_ACT);
    if (Text != NULL) {
        ArcWrite(BlConsoleOutDeviceId,
                 Text,
                 _tcslen(Text)*sizeof(TCHAR),
                 &Count);
    }
}


VOID
BlClearToEndOfScreen(
    VOID
    );

VOID
BlFatalError(
    IN ULONG ClassMessage,
    IN ULONG DetailMessage,
    IN ULONG ActionMessage
    )

/*++

Routine Description:

    This function looks up messages to display at a error condition.
    It attempts to locate the string in the resource section of the
    osloader.  If that fails, it prints a numerical error code.

    The only time it should print a numerical error code is if the
    resource section could not be located.  This will only happen
    on ARC machines where boot fails before the osloader.exe file
    can be opened.

Arguments:

    ClassMessage - General message that describes the class of
                   problem.

    DetailMessage - Detailed description of what caused problem

    ActionMessage - Message that describes a course of action
                    for user to take.

Return Value:

    none

--*/


{

    PTCHAR Text;
    TCHAR Buffer[40];
    ULONG Count;

    ArcWrite(BlConsoleOutDeviceId,
             TEXT("\r\n"),
             _tcslen(TEXT("\r\n"))*sizeof(TCHAR),
             &Count);

    //
    // Remove any remains from the last known good message.
    //

    BlClearToEndOfScreen();
    Text = BlFindMessage(ClassMessage);
    if (Text == NULL) {
        _stprintf(Buffer,TEXT("%08lx\r\n"),ClassMessage);
        Text = Buffer;
    }

    ArcWrite(BlConsoleOutDeviceId,
             Text,
             _tcslen(Text)*sizeof(TCHAR),
             &Count);

    Text = BlFindMessage(DetailMessage);
    if (Text == NULL) {
        _stprintf(Buffer,TEXT("%08lx\r\n"),DetailMessage);
        Text = Buffer;
    }

    ArcWrite(BlConsoleOutDeviceId,
             Text,
             _tcslen(Text)*sizeof(TCHAR),
             &Count);

    Text = BlFindMessage(ActionMessage);
    if (Text == NULL) {
        _stprintf(Buffer,TEXT("%08lx\r\n"),ActionMessage);
        Text = Buffer;
    }

    ArcWrite(BlConsoleOutDeviceId,
             Text,
             _tcslen(Text)*sizeof(TCHAR),
             &Count);    

#if defined(ENABLE_LOADER_DEBUG) || DBG
#if (defined(_X86_) || defined(_ALPHA_) || defined(_IA64_)) && !defined(ARCI386) // everything but ARCI386
    if(BdDebuggerEnabled) {
        DbgBreakPoint();
    }
#endif
#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\msg.cs ===
;/*++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    msg.h
;
;Abstract:
;
;    This file contains the message definitions for osloader
;
;Author:
;
;    John Vert (jvert) 12-Nov-1993
;
;Revision History:
;
;Notes:
;

;    This file is generated from msg.mc
;
;--*/
;
;#ifndef _BLDR_MSG_
;#define _BLDR_MSG_
;
;

MessageID=9000 SymbolicName=BL_MSG_FIRST
Language=English
.

MessageID=9001 SymbolicName=LOAD_SW_INT_ERR_CLASS
Language=English
Systm Windows se nepodailo spustit z dvodu chyby softwaru.
Oznamte uveden pote:
.

MessageID=9002 SymbolicName=LOAD_SW_MISRQD_FILE_CLASS
Language=English
Systm Windows se nepodailo spustit, nebyl nalezen uveden
soubor, kter potebuje:
.

MessageID=9003 SymbolicName=LOAD_SW_BAD_FILE_CLASS
Language=English
Systm Windows nelze spustit z dvodu pokozenho souboru,
viz dle:
.

MessageID=9004 SymbolicName=LOAD_SW_MIS_FILE_CLASS
Language=English
Systm Windows nelze spustit. Uveden soubor je pokozen 
nebo nebyl nalezen:
.

MessageID=9005 SymbolicName=LOAD_HW_MEM_CLASS
Language=English
Systm Windows nelze spustit z dvodu pot 
s hardwarovou konfigurac pamti.
.

MessageID=9006 SymbolicName=LOAD_HW_DISK_CLASS
Language=English
Systm Windows nelze spustit z dvodu pot s hardwarovou 
konfigurac potaovho disku.
.

MessageID=9007 SymbolicName=LOAD_HW_GEN_ERR_CLASS
Language=English
Systm Windows nelze spustit z dvodu obecnch pot s hardwarovou
konfigurac potae.
.

MessageID=9008 SymbolicName=LOAD_HW_FW_CFG_CLASS
Language=English
Systm Windows nelze spustit z dvodu pot
s konfigurac startovacho firmwaru ARC:
.

MessageID=9009 SymbolicName=DIAG_BL_MEMORY_INIT
Language=English
Zkontrolujte hardwarovou konfiguraci pamti a velikost RAM.
.

MessageID=9010 SymbolicName=DIAG_BL_CONFIG_INIT
Language=English
Pli mnoho konfiguranch poloek
.

MessageID=9011 SymbolicName=DIAG_BL_IO_INIT
Language=English
Tabulky diskovch oddl nebyly pstupn
.

MessageID=9012 SymbolicName=DIAG_BL_FW_GET_BOOT_DEVICE
Language=English
Nastaven parametru 'osloadpartition' je neplatn.
.

MessageID=9013 SymbolicName=DIAG_BL_OPEN_BOOT_DEVICE
Language=English
Ze zadanho spoutcho disku nelze st. Zkontrolujte spoutc
cestu a hardware disku.
.

MessageID=9014 SymbolicName=DIAG_BL_FW_GET_SYSTEM_DEVICE
Language=English
Nastaven parametru 'systempartition' je neplatn.
.

MessageID=9015 SymbolicName=DIAG_BL_FW_OPEN_SYSTEM_DEVICE
Language=English
Ze zadanho spoutcho disku systmu nelze st.
Zkontrolujte cestu 'systempartition'.
.

MessageID=9016 SymbolicName=DIAG_BL_GET_SYSTEM_PATH
Language=English
Parametr 'osloadfilename' se neodkazuje na platn soubor.
.

MessageID=9017 SymbolicName=DIAG_BL_LOAD_SYSTEM_IMAGE
Language=English
<Windows root>\system32\ntoskrnl.exe.
.

MessageID=9018 SymbolicName=DIAG_BL_FIND_HAL_IMAGE
Language=English
Parametr 'osloader' neodkazuje na platn soubor.
.

MessageID=9019 SymbolicName=DIAG_BL_LOAD_HAL_IMAGE_X86
Language=English
<Windows root>\system32\hal.dll.
.

MessageID=9020 SymbolicName=DIAG_BL_LOAD_HAL_IMAGE_ARC
Language=English
'osloader'\hal.dll
.
;#ifdef _X86_
;#define DIAG_BL_LOAD_HAL_IMAGE DIAG_BL_LOAD_HAL_IMAGE_X86
;#else
;#define DIAG_BL_LOAD_HAL_IMAGE DIAG_BL_LOAD_HAL_IMAGE_ARC
;#endif

MessageID=9021 SymbolicName=DIAG_BL_LOAD_SYSTEM_IMAGE_DATA
Language=English
Zavad؟, chyba 1.
.

MessageID=9022 SymbolicName=DIAG_BL_LOAD_HAL_IMAGE_DATA
Language=English
Zavad؟, chyba 2.
.

MessageID=9023 SymbolicName=DIAG_BL_LOAD_SYSTEM_DLLS
Language=English
Zavad؟ poteboval knihovny DLL pro jdro systmu.
.

MessageID=9024 SymbolicName=DIAG_BL_LOAD_HAL_DLLS
Language=English
Zavad؟ poteboval knihovny DLL pro vrstvu HAL.
.

MessageID=9026 SymbolicName=DIAG_BL_FIND_SYSTEM_DRIVERS
Language=English
najt ovladae systmu.
.

MessageID=9027 SymbolicName=DIAG_BL_READ_SYSTEM_DRIVERS
Language=English
st ovladae systmu.
.

MessageID=9028 SymbolicName=DIAG_BL_LOAD_DEVICE_DRIVER
Language=English
nezavedl ovlada zazen spoutcho systmu.
.

MessageID=9029 SymbolicName=DIAG_BL_LOAD_SYSTEM_HIVE
Language=English
zavdt konfiguran soubor systmovho hardwaru.
.


MessageID=9030 SymbolicName=DIAG_BL_SYSTEM_PART_DEV_NAME
Language=English
najt nzev zazen systmovho oddlu.
.

MessageID=9031 SymbolicName=DIAG_BL_BOOT_PART_DEV_NAME
Language=English
najt nzev spoutcho oddlu.
.

MessageID=9032 SymbolicName=DIAG_BL_ARC_BOOT_DEV_NAME
Language=English
nevygeneroval sprvn nzev ARC pro HAL a systmov cesty.
.

MessageID=9034 SymbolicName=DIAG_BL_SETUP_FOR_NT
Language=English
Zavad؟, chyba 3.
.

MessageID=9035 SymbolicName=DIAG_BL_KERNEL_INIT_XFER
Language=English
<Windows root>\system32\ntoskrnl.exe
.

MessageID=9036 SymbolicName=LOAD_SW_INT_ERR_ACT
Language=English
Kontaktujte technickou podporu a nahlaste problm.
.

MessageID=9037 SymbolicName=LOAD_SW_FILE_REST_ACT
Language=English
Tento soubor mete zkusit opravit sputnm instalace systmu
Windows pomoc originln instalan diskety nebo disku CD-ROM.
Opravu spustte stisknutm klvesy R na prvn obrazovce.
.

MessageID=9038 SymbolicName=LOAD_SW_FILE_REINST_ACT
Language=English
Nainstalujte znovu uveden soubor.
.

MessageID=9039 SymbolicName=LOAD_HW_MEM_ACT
Language=English
Hardwarov poadavky na pam؜ naleznete v dokumentaci k systmu Windows.
Dal informace naleznete v prukch k hardwaru.
.

MessageID=9040 SymbolicName=LOAD_HW_DISK_ACT
Language=English
Poadavky na konfiguraci disku naleznete v dokumentaci k systmu Windows.
Dal informace naleznete v prukch k hardwaru.
.

MessageID=9041 SymbolicName=LOAD_HW_GEN_ACT
Language=English
Poadavky na hardwarovou konfiguraci naleznete v dokumentaci k systmu Windows.
Dal informace naleznete v prukch k hardwaru.
.

MessageID=9042 SymbolicName=LOAD_HW_FW_CFG_ACT
Language=English
Monosti konfigurace ARC naleznete v dokumentaci k systmu Windows.
Dal informace naleznete v prukch k hardwaru.
.

MessageID=9043 SymbolicName=BL_LKG_MENU_HEADER
Language=English
     Nabdka Profil hardwaru/Obnoven konfigurace

Nabdka umouje vybrat hardwarov profil,
kter se m pout pi sputn systmu Windows.

Pokud systm nen sputn sprvn, pak lze zvolit pedchoz
konfiguraci systmu, kter me pote pi spoutc odstranit.
Dleit: Zmny konfigurace systmu, kter byly provedeny
          po poslednm spnm sputn, budou odstranny.
.

MessageID=9044 SymbolicName=BL_LKG_MENU_TRAILER
Language=English
ipkami na klvesnici zvraznte poloku, kterou chcete vybrat.
Pak stisknte klvesu ENTER.
.

MessageID=9045 SymbolicName=BL_LKG_MENU_TRAILER_NO_PROFILES
Language=English
Zatm nejsou definovny dn hardwarov profily.
Hardwarov profily mete vytvoit pomoc ovldacho panelu Systm.
.

MessageID=9046 SymbolicName=BL_SWITCH_LKG_TRAILER
Language=English
Stisknutm klvesy P pepnete do posledn znm funkn konfigurace.
Stisknutm klvesy F3 tuto nabdku ukonte a restartujete pota.
.

MessageID=9047 SymbolicName=BL_SWITCH_DEFAULT_TRAILER
Language=English
Stisknutm klvesy V pepnete do vchoz konfigurace.
Stisknutm klvesy F3 tuto nabdku ukonte a restartujete pota.
.

;//
;// The following two messages are used to provide the mnemonic keypress
;// that toggles between the Last Known Good control set and the default
;// control set. (see BL_SWITCH_LKG_TRAILER and BL_SWITCH_DEFAULT_TRAILER)
;//
MessageID=9048 SymbolicName=BL_LKG_SELECT_MNEMONIC
Language=English
P
.

MessageID=9049 SymbolicName=BL_DEFAULT_SELECT_MNEMONIC
Language=English
V
.

MessageID=9050 SymbolicName=BL_LKG_TIMEOUT
Language=English
Doba, za kterou se zvraznn volba automaticky spust (sek.): %d
.

MessageID=9051 SymbolicName=BL_LKG_MENU_PROMPT
Language=English

Nabdku Profil hardwaru/Posledn funkn konfiguraci zskte 
stisknutm mezernku TE
.

MessageID=9052 SymbolicName=BL_BOOT_DEFAULT_PROMPT
Language=English
Sputn vchoz hardwarov konfigurace
.

;//
;// The following messages are used during hibernation restoration
;//
MessageID=9053 SymbolicName=HIBER_BEING_RESTARTED
Language=English
Systm je restartovn z pedchozho umstn.
Chcete-li proces peruit, stisknte mezernk.
.
MessageID=9054 SymbolicName=HIBER_ERROR
Language=English
Systm nemohl bt restartovn z pedchozho umstn
.
MessageID=9055 SymbolicName=HIBER_ERROR_NO_MEMORY
Language=English
kvli nedostatku pamti.
.
MessageID=9056 SymbolicName=HIBER_ERROR_BAD_IMAGE
Language=English
, protoe je obraz obnoven pokozen.
.
MessageID=9057 SymbolicName=HIBER_IMAGE_INCOMPATIBLE
Language=English
, protoe obraz obnoven nen kompatibiln s aktuln konfigurac.
.
MessageID=9058 SymbolicName=HIBER_ERROR_OUT_OF_REMAP
Language=English
kvli vnitn chyb.
.
MessageID=9059 SymbolicName=HIBER_INTERNAL_ERROR
Language=English
kvli vnitn chyb.
.
MessageID=9060 SymbolicName=HIBER_READ_ERROR
Language=English
kvli chyb pi ten.
.
MessageID=9061 SymbolicName=HIBER_PAUSE
Language=English
Restartovn systmu bylo pozastaveno:
.
MessageID=9062 SymbolicName=HIBER_CANCEL
Language=English
Odstrate obnovovac data a postupte k nabdce sputn systmu
.
MessageID=9063 SymbolicName=HIBER_CONTINUE
Language=English
Pokraovat v restartovn systmu
.
MessageID=9064 SymbolicName=HIBER_RESTART_AGAIN
Language=English
Posledn pokus o restartovn systmu z pedchozho umstn 
se nezdail. Chcete se o restartovn pokusit znovu?
.

MessageID=9065 SymbolicName=HIBER_DEBUG_BREAK_ON_WAKE
Language=English
Pokraovat s ladicmi zarkami v systmu
.
MessageID=9066 SymbolicName=LOAD_SW_MISMATCHED_KERNEL
Language=English
Systm Windows nelze spustit, protoe uren jdro
neexistuje nebo nen kompatibiln s tmto procesorem.
.
MessageID=9067 SymbolicName=BL_MSG_STARTING_WINDOWS
Language=English
Spoutn systmu Windows...
.
MessageID=9068 SymbolicName=BL_MSG_RESUMING_WINDOWS
Language=English
Obnoven innosti systmu Windows...
.

MessageID=9069 SymbolicName=BL_EFI_OPTION_FAILURE
Language=English
Systm Windows nebyl sputn z dvodu chyby pi ten nastaven
spoutn z pamti NVRAM.

Zkontrolujte nastaven firmwaru. Pravdpodobn budete muset obnovit
nastaven pamti NVRAM ze zlohy.
.

;
; //
; // Following messages are for the x86-specific
; // boot menu.
; //
;
MessageID=10001 SymbolicName=BL_ENABLED_KD_TITLE
Language=English
 [ladic program byl aktivovn]
.

MessageID=10002 SymbolicName=BL_DEFAULT_TITLE
Language=English
Windows (vchoz)
.

MessageID=10003 SymbolicName=BL_MISSING_BOOT_INI
Language=English
NTLDR: Soubor BOOT.INI nebyl nalezen.
.

MessageID=10004 SymbolicName=BL_MISSING_OS_SECTION
Language=English
NTLDR: Chyb oddl [operating systems] v souboru boot.txt.
.

MessageID=10005 SymbolicName=BL_BOOTING_DEFAULT
Language=English
Spoutn vchozho jdra z %s.
.

MessageID=10006 SymbolicName=BL_SELECT_OS
Language=English
Vyberte operan systm, kter chcete spustit:
.

MessageID=10007 SymbolicName=BL_MOVE_HIGHLIGHT
Language=English


ipkami nahoru nebo dol zvraznte poadovanou monost.
Stisknutm klvesy Enter ji potvrte.

.

MessageID=10008 SymbolicName=BL_TIMEOUT_COUNTDOWN
Language=English
Doba, za kterou se zvraznn volba automaticky spust (s):
.

MessageID=10009 SymbolicName=BL_INVALID_BOOT_INI
Language=English
Soubor BOOT.INI je neplatn
Probh sputn z %s
.

MessageID=10010 SymbolicName=BL_REBOOT_IO_ERROR
Language=English

Vstupn-vstupn chyba pstupu k souboru spoutcho sektoru
%s\BOOTSECT.DOS
.

MessageID=10011 SymbolicName=BL_DRIVE_ERROR
Language=English
NTLDR: Nelze otevt jednotku %s
.

MessageID=10012 SymbolicName=BL_READ_ERROR
Language=English
NTLDR: Kritick chyba %d pi ten souboru BOOT.INI
.

MessageID=10013 SymbolicName=BL_NTDETECT_MSG
Language=English

NTDETECT v5.0 kontroluje hardware...

.

MessageID=10014 SymbolicName=BL_NTDETECT_FAILURE
Language=English
Dolo k chyb v modulu NTDETECT.
.

MessageID=10015 SymbolicName=BL_DEBUG_SELECT_OS
Language=English
Aktuln vbr:
  Nzev...: %s
  Cesta...: %s
  Monosti: %s
.

MessageID=10016 SymbolicName=BL_DEBUG_NEW_OPTIONS
Language=English
Zadejte nov monosti zavdn:
.

MessageID=10017 SymbolicName=BL_HEADLESS_REDIRECT_TITLE
Language=English
 [EMS enabled]
.

MessageID=10018 SymbolicName=BL_INVALID_BOOT_INI_FATAL
Language=English
Neplatn soubor BOOT.INI
.
;
; //
; // Following messages are for the advanced boot menu
; //
;

MessageID=11001 SymbolicName=BL_ADVANCEDBOOT_TITLE
Language=English
Upesnit monosti sputn systmu Windows
Zvolte jednu z monost:
.

MessageID=11002 SymbolicName=BL_SAFEBOOT_OPTION1
Language=English
Stav nouze
.

MessageID=11003 SymbolicName=BL_SAFEBOOT_OPTION2
Language=English
Stav nouze s prac v sti
.

MessageID=11004 SymbolicName=BL_SAFEBOOT_OPTION3
Language=English
Potvrzovat krok za krokem
.

MessageID=11005 SymbolicName=BL_SAFEBOOT_OPTION4
Language=English
Stav nouze se systmem MS-DOS
.

MessageID=11006 SymbolicName=BL_SAFEBOOT_OPTION5
Language=English
Reim VGA
.

MessageID=11007 SymbolicName=BL_SAFEBOOT_OPTION6
Language=English
Obnoven adresov sluby (pouze pro adie domny Windows)
.

MessageID=11008 SymbolicName=BL_LASTKNOWNGOOD_OPTION
Language=English
Posledn znm funkn konfigurace
.

MessageID=11009 SymbolicName=BL_DEBUG_OPTION
Language=English
Reim ladn
.

;#if defined(REMOTE_BOOT)
;MessageID=11010 SymbolicName=BL_REMOTEBOOT_OPTION1
;Language=English
;drba a odstraovn chyb vzdlenho spoutn
;.
;
;MessageID=11011 SymbolicName=BL_REMOTEBOOT_OPTION2
;Language=English
;Vyistit mezipam؜ offline
;.
;
;MessageID=11012 SymbolicName=BL_REMOTEBOOT_OPTION3
;Language=English
;Pi spoutn pout pouze soubory ze serveru
;.
;#endif // defined(REMOTE_BOOT)

MessageID=11013 SymbolicName=BL_BOOTLOG
Language=English
Pi zaveden povolit pihlen
.

MessageID=11014 SymbolicName=BL_ADVANCED_BOOT_MESSAGE
Language=English
een pot nebo upesnn monost sputn - stisknte klvesu F8.
.

MessageID=11015 SymbolicName=BL_BASEVIDEO
Language=English
Zapnout reim VGA
.

MessageID=11016 SymbolicName=BL_DISABLE_SAFEBOOT
Language=English

Vypnut bezpenho zavdn systmu a normln zaveden systmu - klvesa ESC
.

MessageID=11017 SymbolicName=BL_MSG_BOOT_NORMALLY
Language=English
Spustit systm bاnm zpsobem
.
MessageID=11018 SymbolicName=BL_MSG_OSCHOICES_MENU
Language=English
Zpt k vbru operanho systmu
.
MessageID=11019 SymbolicName=BL_MSG_REBOOT

Language=English
Restartovat
.

MessageID=11020 SymbolicName=BL_ADVANCEDBOOT_AUTOLKG_TITLE
Language=English
Omlouvme se za nepjemnosti, ale systm Windows nebyl spn sputn 
pravdpodobn z dvodu zmny hardwaru nebo softwaru.

Pokud pota neodpovd, byl neekan restartovn nebo byl automaticky
vypnut, aby chrnil soubory a sloky, mete se vrtit k funknmu 
nastaven volbou Posledn znm funkn konfigurace.

Pokud bylo pedchoz sputn perueno z dvodu vpadku napjen nebo
vypnaem napjen nebo tlatkem Reset, nebo pokud je pina neznm,
zvolte poloku Spustit systm bاnm zpsobem.
.

MessageID=11021 SymbolicName=BL_ADVANCEDBOOT_AUTOSAFE_TITLE
Language=English
Systm nebyl spn vypnut. Jestlie se tak stalo, protoe systm
neodpovdal nebo byl vypnut, aby chrnil data, je mon jej obnovit
jednou z konfigurac Nouzovho reimu:
.

MessageID=11022 SymbolicName=BL_ADVANCEDBOOT_TIMEOUT
Language=English
Systm Windows se spust za (sekundy):
.

;
;//
;// Following messages are the symbols used
;// in the Hibernation Restore percent completed UI. 
;//
;// These symbols are here because they employ high-ASCII
;// line drawing characters, which need to be localized
;// for fonts that may not have such characters (or have
;// them in a different ASCII location). 
;//  
;// This primarily affects FE character sets. 
;//
;// Note that only the FIRST character of any of these
;// messages is ever looked at by the code.  
;//
;
; // Just a base message, contains nothing.
;
;

; //
; // NOTE : donot change the Message ID values for HIBER_UI_BAR_ELEMENT
; // and BLDR_UI_BAR_BACKGROUND from 11513 & 11514
;

;
; // The character used to draw the percent-complete bar
;
;
MessageID=11513 SymbolicName=HIBER_UI_BAR_ELEMENT
Language=English

.

;
; // The character used to draw the percent-complete bar
;
;

MessageID=11514 SymbolicName=BLDR_UI_BAR_BACKGROUND
Language=English

.


;#if defined(REMOTE_BOOT)
;;
;; //
;; // Following messages are for warning the user about
;; // an impending autoformat of the hard disk.
;; //
;;
;
;MessageID=12002 SymbolicName=BL_WARNFORMAT_TRAILER
;Language=English
;Stisknutm klvesy Enter pokraujte ve sputn systmu Windows,
;nebo vypnutm potae aktivujte vzdlen spoutn.
;.
;
;MessageID=12003 SymbolicName=BL_WARNFORMAT_CONTINUE
;Language=English
;Pokraovat
;.
;MessageID=12004 SymbolicName=BL_FORCELOGON_HEADER
;Language=English
;          Automatick formtovn
;
;Systm Windows rozpoznal v potai vzdlenho spoutn nov
;pevn disk. Systm neme tento disk pout, dokud se nepihlste
;a nepotvrdte, e mte oprvnn k disku pistupovat.
;
;UPOZORNN: Systm Windows automaticky nastav oddly a disk
;naformtuje tak, aby byl kompatibiln s novm operanm systmem.
;Budete-li pokraovat, budou vechna data na pevnm disku ztracena.
;Jestlie nechcete pokraovat, vypnte nyn pota a obrate se
;na sprvce systmu.
;.
;#endif // defined(REMOTE_BOOT)

;
; //
; // Ramdisk related messages. DO NOT CHANGE the message numbers
; // as they are kept in sync with \base\boot\inc\ramdisk.h.
; //
; // Note that some message numbers are skipped in order to retain
; // consistency with the .NET source base.
; //
;

MessageID=15000 SymbolicName=BL_RAMDISK_GENERAL_FAILURE
Language=English
Pi spoutn systmu z ramdisku dolo k chyb. Systm Windows nelze spustit.
.

MessageID=15003 SymbolicName=BL_RAMDISK_BOOT_FAILURE
Language=English
Oteven bitov kopie ramdisku se nezdailo.
.

MessageID=15010 SymbolicName=BL_RAMDISK_DOWNLOAD
Language=English
Natn bitov kopie ramdisku...
.

;#endif // _BLDR_MSG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\daytona_dbg\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\el_dbg\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\el\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\chs\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\es\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\fi\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\fr\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\hu\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\ger\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\cht\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\it\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\jpn\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\kor\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\nl\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\no\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\nl_dbg\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\pl\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\psu\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\pt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\spcrtest\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\ru\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\sv\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\tr\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\tst\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\i386\initx86.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initx86.c

Abstract:

    Does any x86-specific initialization, then starts the common ARC osloader

Author:

    John Vert (jvert) 4-Nov-1993

Revision History:

--*/
#include "bldrx86.h"
#include "acpitabl.h"
#include "msg.h"
#include "bootstatus.h"

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <netboot.h>
#include <ramdisk.h>

BOOLEAN
BlpPaeSupported(
    VOID
    );

BOOLEAN
BlpChipsetPaeSupported(
    VOID
    );

ARC_STATUS
Blx86GetImageProperties(
    IN  ULONG    LoadDeviceId,
    IN  PCHAR    ImagePath,
    OUT PBOOLEAN IsPae,
    OUT PBOOLEAN SupportsHotPlugMemory
    );

BOOLEAN
Blx86IsKernelCompatible(
    IN ULONG LoadDeviceId,
    IN PCHAR ImagePath,
    IN BOOLEAN ProcessorSupportsPae,
    IN OUT PBOOLEAN UsePae
    );

BOOLEAN
Blx86NeedPaeForHotPlugMemory(
    VOID
    );

UCHAR BootPartitionName[80];
UCHAR KernelBootDevice[80];
UCHAR OsLoadFilename[100];
UCHAR OsLoaderFilename[100];
UCHAR SystemPartition[100];
UCHAR OsLoadPartition[100];
UCHAR OsLoadOptions[100];
UCHAR ConsoleInputName[50];
UCHAR MyBuffer[SECTOR_SIZE+32];
UCHAR ConsoleOutputName[50];
UCHAR X86SystemPartition[sizeof("x86systempartition=") + sizeof(BootPartitionName)];

extern BOOLEAN ForceLastKnownGood;
extern ULONG    BlHighestPage;
extern PHARDWARE_PTE PDE;

extern ULONG    BootFlags;

extern PDESCRIPTION_HEADER
BlFindACPITable(
    IN PCHAR TableName,
    IN ULONG TableLength
    );



VOID
BlStartup(
    IN PCHAR PartitionName
    )

/*++

Routine Description:

    Does x86-specific initialization, particularly presenting the boot.ini
    menu and running NTDETECT, then calls to the common osloader.

Arguments:

    PartitionName - Supplies the ARC name of the partition (or floppy) that
        setupldr was loaded from.

Return Value:

    Does not return

--*/

{
    ULONG Argc = 0;
    PUCHAR Argv[10];
    ARC_STATUS Status;
    ULONG BootFileId;
    PCHAR BootFile = NULL;
    ULONG Read;
    PCHAR p,q;
    ULONG i;
    ULONG DriveId;
    ULONG FileSize;
    ULONG Count;
    LARGE_INTEGER SeekPosition;
    PCHAR LoadOptions = NULL;
    BOOLEAN UseTimeOut=TRUE;
    BOOLEAN AlreadyInitialized = FALSE;
    extern BOOLEAN FwDescriptorsValid;
    PCHAR BadLinkName = NULL;

    //
    // If this is an SDI boot, initialize the ramdisk "driver" now.
    //
    // NB. PartitionName is the name of the device from which the loader
    // was loaded. It is NOT the name of the device from which the OS will
    // be loaded. If we're doing a straight ramdisk boot, this will NOT be
    // ramdisk(0) -- it will be net(0) or a physical disk name. Only if
    // we're doing a real SDI boot will this be ramdisk(0). (See
    // NtProcessStartup() in boot\lib\i386\entry.c.)
    //

    if ( strcmp(PartitionName,"ramdisk(0)") == 0 ) {
        RamdiskInitialize( NULL, TRUE );
    }

    //
    // Open the boot partition so we can load boot drivers off it.
    //
    Status = ArcOpen(PartitionName, ArcOpenReadWrite, &DriveId);
    if (Status != ESUCCESS) {
        BlPrint(TEXT("Couldn't open drive %s\n"),PartitionName);
        BlPrint(BlFindMessage(BL_DRIVE_ERROR),PartitionName);
        goto BootFailed;
    }

    //
    // Initialize dbcs font and display support.
    //
    TextGrInitialize(DriveId, NULL);

    //
    // Initialize ARC StdIo functionality
    //

    strcpy(ConsoleInputName,"consolein=multi(0)key(0)keyboard(0)");
    strcpy(ConsoleOutputName,"consoleout=multi(0)video(0)monitor(0)");
    Argv[0]=ConsoleInputName;
    Argv[1]=ConsoleOutputName;
    BlInitStdio (2, Argv);

    //
    // Announce the loader
    //
    //BlPrint(OsLoaderVersion);    

    //
    // Check ntldr partition for hiberation image
    //

    BlHiberRestore(DriveId, &BadLinkName);

    //
    // Re-open the boot partition as a temporary work around
    // for NTFS caching bug.
    //
    ArcClose(DriveId);

    Status = ArcOpen(PartitionName, ArcOpenReadWrite, &DriveId);

    if (Status != ESUCCESS) {
        BlPrint(TEXT("Couldn't open drive %s\n"),PartitionName);
        BlPrint(BlFindMessage(BL_DRIVE_ERROR),PartitionName);
        goto BootFailed;
    }

    //
    // It is possible that the link file points to the hiber file on a scsi
    // disk. In that case, we need to load NTBOOTDD.SYS in order to access the
    // hiber file and try again.
    //
    if ((BadLinkName != NULL) &&
        ((_strnicmp(BadLinkName,"scsi(",5)==0) || (_strnicmp(BadLinkName,"signature(",10)==0))) {
        ULONG HiberDrive;

        //
        // Before loading NTBOOTDD we must load NTDETECT as that figures
        // out the PCI buses
        //
        if (BlDetectHardware(DriveId, "/fastdetect")) {
            if (AEInitializeIo(DriveId) == ESUCCESS) {
                AlreadyInitialized = TRUE;

                //
                // Now that NTBOOTDD.SYS is loaded, we can try again.
                //
                Status = ArcOpen(BadLinkName, ArcOpenReadWrite, &HiberDrive);
                if (Status == ESUCCESS) {
                    BlHiberRestore(HiberDrive, NULL);
                    ArcClose(HiberDrive);
                }
            }

        }

    }

    do {

        if (BlBootingFromNet) {
            PCHAR BootIniPath;

            //
            // If we are booting from the network and 
            // NetBootIniContents has been specified, we
            // will just its contents for boot.ini
            //
            if (NetBootIniContents[0] != '\0') {
                BootFile = NetBootIniContents;
            } else {
                //
                // NetBootIniContents is empty, therefore
                // we need to open the boot.ini file from the
                // network. The acutal file to open is either
                // specificied in NetBootIniPath or is the 
                // default of NetBootPath\boot.ini
                //
                if (NetBootIniPath[0] != '\0') {
                    BootIniPath = NetBootIniPath;
                } else {
                    strcpy(MyBuffer, NetBootPath);
                    strcat(MyBuffer, "boot.ini");
                    BootIniPath = MyBuffer;
                }
                Status = BlOpen( DriveId,
                                 BootIniPath,
                                 ArcOpenReadOnly,
                                 &BootFileId );
            }
        
        } else {
            Status = BlOpen( DriveId,
                             "\\boot.ini",
                             ArcOpenReadOnly,
                             &BootFileId );
        }

        if (BootFile == NULL) {

            BootFile = MyBuffer;
            RtlZeroMemory(MyBuffer, SECTOR_SIZE+32);

            if (Status != ESUCCESS) {
                BootFile[0]='\0';
            } else {
                //
                // Determine the length of the boot.ini file by reading to the end of
                // file.
                //

                FileSize = 0;
                do {
                    Status = BlRead(BootFileId, BootFile, SECTOR_SIZE, &Count);
                    if (Status != ESUCCESS) {
                        BlClose(BootFileId);
                        BlPrint(BlFindMessage(BL_READ_ERROR),Status);
                        BootFile[0] = '\0';
                        FileSize = 0;
                        Count = 0;
                        goto BootFailed;
                    }

                    FileSize += Count;
                } while (Count != 0);

                if (FileSize >= SECTOR_SIZE) {

                    //
                    // We need to allocate a bigger buffer, since the boot.ini file
                    // is bigger than one sector.
                    //

                    BootFile=FwAllocateHeap(FileSize);
                }

                if (BootFile == NULL) {
                    BlPrint(BlFindMessage(BL_READ_ERROR),ENOMEM);
                    BootFile = MyBuffer;
                    BootFile[0] = '\0';
                    goto BootFailed;
                } else {

                    SeekPosition.QuadPart = 0;
                    Status = BlSeek(BootFileId,
                                    &SeekPosition,
                                    SeekAbsolute);
                    if (Status != ESUCCESS) {
                        BlPrint(BlFindMessage(BL_READ_ERROR),Status);
                        BootFile = MyBuffer;
                        BootFile[0] = '\0';
                        goto BootFailed;
                    } else {
                        Status = BlRead( BootFileId,
                                         BootFile,
                                         FileSize,
                                         &Read );

                        SeekPosition.QuadPart = 0;
                        Status = BlSeek(BootFileId,
                                        &SeekPosition,
                                        SeekAbsolute);
                        if (Status != ESUCCESS) {
                            BlPrint(BlFindMessage(BL_READ_ERROR),Status);
                            BootFile = MyBuffer;
                            BootFile[0] = '\0';
                            goto BootFailed;
                        } else {
                            BootFile[Read]='\0';
                        }
                    }
                }

                //
                // Find Ctrl-Z, if it exists
                //

                p=BootFile;
                while ((*p!='\0') && (*p!=26)) {
                    ++p;
                }
                if (*p != '\0') {
                    *p='\0';
                }
                BlClose(BootFileId);
            }
        }

        MdShutoffFloppy();

        ARC_DISPLAY_CLEAR();

        // We require a boot.ini file when booting from the network
        if (BlBootingFromNet && *BootFile == '\0') {
            BlPrint(BlFindMessage(BL_READ_ERROR),Status);
            goto BootFailed;
        }

        p=BlSelectKernel(DriveId,BootFile, &LoadOptions, UseTimeOut);
        if ( p == NULL ) {
            BlPrint(BlFindMessage(BL_INVALID_BOOT_INI_FATAL));
            goto BootFailed;
        }

#if defined(REMOTE_BOOT)
        //
        //  We may have loaded boot.ini from the hard drive but if the selection was
        //  for a remote boot installation then we need to load the rest from the net.
        //

        if((DriveId != NET_DEVICE_ID) &&
            (!_strnicmp(p,"net(",4))) {
            BlPrint("\nWarning:Booting from CSC without access to server\n");
            strcpy(BootPartitionName,"net(0)");
            BlBootingFromNet = TRUE;
            NetworkBootRom = FALSE;

            //
            //  p points to something like: "net(0)\COLINW3\IMirror\Clients\cwintel\BootDrive\WINNT"
            //  NetBootPath needs to contain "\Clients\cwintel\"
            //  ServerShare is used inside lib\netboot.c to find the correct file if CSC
            //  is used.
            //

            q = strchr(p+sizeof("net(0)"), '\\');
            q = strchr(q+1, '\\');
            strcpy(NetBootPath,q);
            q = strrchr( NetBootPath, '\\' );
            q[1] = '\0';
        }
#endif // defined(REMOTE_BOOT)

        if (!AlreadyInitialized) {

//          BlPrint(BlFindMessage(BL_NTDETECT_MSG));
            if (!BlDetectHardware(DriveId, LoadOptions)) {
                BlPrint(BlFindMessage(BL_NTDETECT_FAILURE));
                return;
            }

            ARC_DISPLAY_CLEAR();

            //
            // Initialize SCSI boot driver, if necessary.
            //
            if (_strnicmp(p,"scsi(",5)==0 || _strnicmp(p,"signature(",10)==0) {
                AEInitializeIo(DriveId);
            }

            ArcClose(DriveId);
            //
            // Indicate that fw memory descriptors cannot be changed from
            // now on.
            //
            FwDescriptorsValid = FALSE;
        } else {
            ARC_DISPLAY_CLEAR();
        }

        //
        // Set AlreadyInitialized Flag to TRUE to indicate that ntdetect
        // routines have been run.
        //

        AlreadyInitialized = TRUE;

        //
        // Only time out the boot menu the first time through the boot.
        // For all subsequent reboots, the menu will stay up.
        //
        UseTimeOut=FALSE;

        i=0;
        while (*p !='\\') {
            KernelBootDevice[i] = *p;
            i++;
            p++;
        }
        KernelBootDevice[i] = '\0';

        //
        // If the user hasn't chosen an advanced boot mode then we will present
        // them with the menu and select our default.
        //

        if(BlGetAdvancedBootOption() == -1) {
            PVOID dataHandle;
            ULONG abmDefault;
            BSD_LAST_BOOT_STATUS LastBootStatus = BsdLastBootGood;

            //
            // Open the boot status data.
            //

            Status = BlLockBootStatusData(0, KernelBootDevice, p, &dataHandle);

            if(Status == ESUCCESS) {

                //
                // Check the status of the last boot.  This will return both the 
                // status and the advanced boot mode we should enter (based on the 
                // status and the "enable auto advanced boot" flag.
                //
        
                abmDefault = BlGetLastBootStatus(dataHandle, &LastBootStatus);
    
                if(LastBootStatus == BsdLastBootFailed) {
    
                    //
                    // If we should attempt an ABM mode then present the user with
                    // the menu.
                    //
    
                    if(abmDefault != -1) {
                        ULONG menuTitle;
                        UCHAR timeout;
    
                        if(LastBootStatus == BsdLastBootFailed) {
                            menuTitle = BL_ADVANCEDBOOT_AUTOLKG_TITLE;
                        } else if(LastBootStatus == BsdLastBootNotShutdown) {
                            menuTitle = BL_ADVANCEDBOOT_AUTOSAFE_TITLE;
                        }

                        //
                        // Read the timeout value.
                        //

                        Status = BlGetSetBootStatusData(dataHandle,
                                                        TRUE,
                                                        RtlBsdItemAabTimeout,
                                                        &timeout,
                                                        sizeof(UCHAR),
                                                        NULL);

                        if(Status != ESUCCESS) {
                            timeout = 30;
                        }
    
                        abmDefault = BlDoAdvancedBoot(menuTitle, 
                                                      -1, 
                                                      TRUE, 
                                                      timeout);
                    }
        
                    BlAutoAdvancedBoot(&LoadOptions, 
                                       LastBootStatus, 
                                       abmDefault);
                }

                BlUnlockBootStatusData(dataHandle);
            }
        }

        //
        // We are fooling the OS Loader here.  It only uses the osloader= variable
        // to determine where to load HAL.DLL from.  Since x86 systems have no
        // "system partition" we want to load HAL.DLL from \nt\system\HAL.DLL.
        // So we pass that it as the osloader path.
        //

        strcpy(OsLoaderFilename,"osloader=");
        strcat(OsLoaderFilename,p);
        strcat(OsLoaderFilename,"\\System32\\NTLDR");

        strcpy(SystemPartition,"systempartition=");
        strcat(SystemPartition,KernelBootDevice);

        strcpy(OsLoadPartition,"osloadpartition=");
        strcat(OsLoadPartition,KernelBootDevice);

        strcpy(OsLoadFilename, "osloadfilename=");
        strcat(OsLoadFilename, p);

        strcpy(OsLoadOptions,"osloadoptions=");
        if (LoadOptions) {
            strcat(OsLoadOptions,LoadOptions);
        }

        strcpy(ConsoleInputName,"consolein=multi(0)key(0)keyboard(0)");

        strcpy(ConsoleOutputName,"consoleout=multi(0)video(0)monitor(0)");

        strcpy(X86SystemPartition,"x86systempartition=");
        strcat(X86SystemPartition,PartitionName);

        Argv[Argc++]="load";

        Argv[Argc++]=OsLoaderFilename;
        Argv[Argc++]=SystemPartition;
        Argv[Argc++]=OsLoadFilename;
        Argv[Argc++]=OsLoadPartition;
        Argv[Argc++]=OsLoadOptions;
        Argv[Argc++]=X86SystemPartition;

        Status = BlOsLoader( Argc, Argv, NULL );

    BootFailed:
        ForceLastKnownGood = FALSE;
        if (Status != ESUCCESS) {

#if defined(ENABLE_LOADER_DEBUG)
            DbgBreakPoint();
#endif

            if (BootFlags & BOOTFLAG_REBOOT_ON_FAILURE) {
                ULONG StartTime = ArcGetRelativeTime();
                BlPrint(TEXT("\nRebooting in 5 seconds...\n"));
                while ( ArcGetRelativeTime() - StartTime < 5) {}
                ArcRestart();      
            }

            //
            // Boot failed, wait for reboot
            //
            while (TRUE) {
                while (!BlGetKey());  // BOOT FAILED!
                if (BlTerminalHandleLoaderFailure()) {
                    ArcRestart();
                }
            }

        } else {
            //
            // Need to reopen the drive
            //
            Status = ArcOpen(BootPartitionName, ArcOpenReadOnly, &DriveId);
            if (Status != ESUCCESS) {
                BlPrint(BlFindMessage(BL_DRIVE_ERROR),BootPartitionName);
                goto BootFailed;
            }
        }
    } while (TRUE);

}

VOID
DoApmAttemptReconnect(
    VOID
    )
{
    APM_ATTEMPT_RECONNECT();
}


BOOLEAN
Blx86NeedPaeForHotPlugMemory(
    VOID
    )
/*++

Routine Description:

    Determine whether any hot plug memory described in the SRAT table
    extends beyond the 4gb mark and thus implies a need for PAE.

Arguments:

    None

Return Value:

    TRUE: Machine supports hot plug memory beyond the 4gb mark, PAE should be
          turned on if possible.

    FALSE: Machine doesn't support hot plug memory beyond the 4gb mark.

--*/
{
    PACPI_SRAT SratTable;
    PACPI_SRAT_ENTRY SratEntry;
    PACPI_SRAT_ENTRY SratEnd;

    SratTable = (PACPI_SRAT) BlFindACPITable("SRAT", sizeof(ACPI_SRAT));
    if (SratTable == NULL) {
        return FALSE;
    }

    SratTable = (PACPI_SRAT) BlFindACPITable("SRAT", SratTable->Header.Length);
    if (SratTable == NULL) {
        return FALSE;
    }
                             
    SratEnd = (PACPI_SRAT_ENTRY)(((PUCHAR)SratTable) +
                                 SratTable->Header.Length);
    for (SratEntry = (PACPI_SRAT_ENTRY)(SratTable + 1);
         SratEntry < SratEnd;
         SratEntry = (PACPI_SRAT_ENTRY)(((PUCHAR) SratEntry) + SratEntry->Length)) {
        if (SratEntry->Type != SratMemory) {
            continue;
        }
        
        if (SratEntry->MemoryAffinity.Flags.HotPlug &&
            SratEntry->MemoryAffinity.Flags.Enabled) {
            ULONGLONG Extent;

            //
            // Check if hot plug region ends beyond the 4gb mark.
            //

            Extent = SratEntry->MemoryAffinity.Base.QuadPart +
                SratEntry->MemoryAffinity.Length;
            if (Extent > 0x100000000) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

ARC_STATUS
Blx86CheckForPaeKernel(
    IN BOOLEAN UserSpecifiedPae,
    IN BOOLEAN UserSpecifiedNoPae,
    IN PCHAR UserSpecifiedKernelImage,
    IN PCHAR HalImagePath,
    IN ULONG LoadDeviceId,
    IN ULONG SystemDeviceId,
    OUT PULONG HighestSystemPage,
    OUT PBOOLEAN UsePaeMode,
    IN OUT PCHAR KernelPath
    )

/*++

Routine Description:

    There are two kernels: one, ntkrnlpa.exe, is compiled for PAE mode.
    The other, ntoskrnl.exe, is not.

    This routine is responsible for deciding which one to load.

Arguments:

    UserSpecifiedPae - Indicates whether the user requested PAE mode
        via the /PAE loader switch.

    UserSpecifiedNoPae - Indicates whether the user requrested non-PAE mode
        via the /NOPAE loader switch.

    UserSpecifiedKernelImage - Points to the user-specified kernel image name,
        indicated via the /KERNEL= switch, or NULL if none was specified.

    HalImagePath - Points to the hal image that will be used.

    LoadDeviceId - The ARC device handle of the kernel load device.

    SystemDeviceId - The ARC device handle of the system device.

    HighestSystemPage - Out parameter returning the highest physical
        page found in the system.

    UsePaeMode - Indicates whether the kernel should be loaded in PAE mode.

    KernelPath - On input, the directory path of the kernel images.  Upon
        successful return, this will contain the full kernel image path.

Return Value:

    ESUCCESS : A compatible kernel has been located, and its path resides in
        the output buffer pointed to by KernelPath.

    EINVAL: A compatible kernel could not be located.  This will be a fatal
        condition.
        
    EBADF: hal is corrupt or missing.  This will be a fatal condition.

--*/

{
    BOOLEAN foundMemoryAbove4G;
    BOOLEAN usePae;
    BOOLEAN processorSupportsPae;
    BOOLEAN halSupportsPae;
    BOOLEAN osSupportsHotPlugMemory;
    BOOLEAN havePaeKernel;
    BOOLEAN compatibleKernel;
    ULONG lastPage;
    PLIST_ENTRY link;
    PLIST_ENTRY listHead;
    PMEMORY_ALLOCATION_DESCRIPTOR descriptor;
    PCHAR kernelImageNamePae;
    PCHAR kernelImageNameNoPae;
    PCHAR kernelImageName;
    PCHAR kernelImageNameTarget;
    ARC_STATUS status;
    ULONG highestSystemPage;
    ULONG pagesAbove4Gig;

    kernelImageNameNoPae = "ntoskrnl.exe";
    kernelImageNamePae = "ntkrnlpa.exe";
    kernelImageNameTarget = KernelPath + strlen( KernelPath );

    //
    // Determine the highest physical page.  Also, count the number of pages
    // at or above the 4G mark.
    //

    highestSystemPage = 0;
    pagesAbove4Gig = 0;
    listHead = &BlLoaderBlock->MemoryDescriptorListHead;
    link = listHead->Flink;
    while (link != listHead) {

        descriptor = CONTAINING_RECORD(link,
                                       MEMORY_ALLOCATION_DESCRIPTOR,
                                       ListEntry);

        lastPage = descriptor->BasePage + descriptor->PageCount - 1;
        if (lastPage > highestSystemPage) {

            //
            // We have a new highest system page, record it.
            //

            highestSystemPage = lastPage;
        }

        if (lastPage >= (1024 * 1024)) {

            //
            // This descriptor includes one or more pages at or above
            // the 4G mark.
            //

            if (descriptor->BasePage >= (1024 * 1024)) {

                //
                // All of the pages in this descriptor lie at or above 4G.
                //

                pagesAbove4Gig += descriptor->PageCount;

            } else {

                //
                // Only some of the pages in this descriptor lie at or above
                // 4G.
                //

                pagesAbove4Gig += lastPage - (1024 * 1024) + 1;
            }
        }

        link = link->Flink;
    }
    *HighestSystemPage = highestSystemPage;

    //
    // Record whether there is a non-trivial amount of memory above 4G on this
    // machine.  Note that most machines with "exactly" 4G of ram actually move
    // a small amount of ram to above the 4G mark.
    //
    // Because running a PAE kernel inflicts a performance hit, we would rather
    // ignore some amount of memory x rather than move into PAE mode to use it.
    //
    // Right now, x is set to 64MB, or 16384 pages.
    //

    if (pagesAbove4Gig > 16384) {
        foundMemoryAbove4G = TRUE;
    } else {
        foundMemoryAbove4G = FALSE;
    }

    //
    // Find out if this processor can handle PAE mode.
    //

    processorSupportsPae = BlpPaeSupported();

    //
    // Find out whether this chipset supports PAE
    //
    if (!BlpChipsetPaeSupported()) {
        processorSupportsPae = FALSE;
    }

    //
    // Start out with a pae flag based on whether memory above 4G was located
    // or whether a /PAE switch was passed on the command line.
    //

    //
    // It used to be the case that we would default to PAE mode if memory
    // above 4G physical was found in the machine.  The decision was made
    // to NEVER default to PAE mode, rather to use PAE only when the
    // user specifically asks for it.
    //
    // If we revert back to the previous way of doing things, uncomment the
    // following line and remove the subsequent one.
    //
    // if (foundMemoryAbove4G || UserSpecifiedPae) {
    //

    if (UserSpecifiedPae) {
        usePae = TRUE;
    } else {
        usePae = FALSE;
    }

    //
    // Determine whether the HAL image can support PAE mode and
    // whether the underlying OS supports hot plug memory.
    //

    status = Blx86GetImageProperties( SystemDeviceId,
                                      HalImagePath,
                                      &halSupportsPae,
                                      &osSupportsHotPlugMemory );
    if (status != ESUCCESS) {

        //
        // Apparently the HAL image supplied is invalid.
        //
        return(EBADF);
    }

    //
    // If machine has the ability for memory to be hot plugged over
    // the 4gb mark, then this is interpreted as a user request for
    // PAE support.  This request will be ignored if not supported by
    // the underlying hardware or operating system.
    //

    if (osSupportsHotPlugMemory && Blx86NeedPaeForHotPlugMemory()) {
        usePae = TRUE;
    }


    if (halSupportsPae == FALSE) {

        //
        // The HAL cannot support operation in PAE mode.  Override
        // processorSupportsPae to FALSE in this case, meaning that we must
        // not under any circumstances try to use PAE mode.
        //

        processorSupportsPae = FALSE;
    }

    //
    // If the processor doesn't handle PAE mode or if the user specified
    // a /NOPAE switch on the loader command line, then disable PAE mode.
    //

    if (processorSupportsPae == FALSE || UserSpecifiedNoPae) {

        usePae = FALSE;
    }

    //
    // Choose the image name based on the data accumulated thus far.
    //

    if (UserSpecifiedKernelImage != NULL) {
        kernelImageName = UserSpecifiedKernelImage;
    } else if (usePae != FALSE) {
        kernelImageName = kernelImageNamePae;
    } else {
        kernelImageName = kernelImageNameNoPae;
    }

    //
    // Build the path for this kernel and determine its suitability.
    //

    strcpy( kernelImageNameTarget, kernelImageName );
    compatibleKernel = Blx86IsKernelCompatible( LoadDeviceId,
                                                KernelPath,
                                                processorSupportsPae,
                                                &usePae );
    if (compatibleKernel == FALSE) {

        //
        // This kernel is not compatible or does not exist.  If the failed
        // kernel was user-specified, fall back to the default, non-PAE
        // kernel and see if that is compatible.
        //

        if (UserSpecifiedKernelImage != NULL) {

            kernelImageName = kernelImageNameNoPae;
            strcpy( kernelImageNameTarget, kernelImageName );
            compatibleKernel = Blx86IsKernelCompatible( LoadDeviceId,
                                                        KernelPath,
                                                        processorSupportsPae,
                                                        &usePae );

        }
    }

    if (compatibleKernel == FALSE) {

        //
        // At this point we have tried one of the default kernel image names,
        // as well as any user-specified kernel image name.  There remains
        // one final default image name that hasn't been tried.  Determine
        // which one that is and try it.
        //

        if (kernelImageName == kernelImageNameNoPae) {
            kernelImageName = kernelImageNamePae;
        } else {
            kernelImageName = kernelImageNameNoPae;
        }

        strcpy( kernelImageNameTarget, kernelImageName );
        compatibleKernel = Blx86IsKernelCompatible( LoadDeviceId,
                                                    KernelPath,
                                                    processorSupportsPae,
                                                    &usePae );
    }

    if (compatibleKernel != FALSE) {

        *UsePaeMode = usePae;
        status = ESUCCESS;
    } else {
        status = EINVAL;
    }

    return status;
}

BOOLEAN
Blx86IsKernelCompatible(
    IN ULONG LoadDeviceId,
    IN PCHAR ImagePath,
    IN BOOLEAN ProcessorSupportsPae,
    OUT PBOOLEAN UsePae
    )

/*++

Routine Description:

    This routine examines the supplied kernel image and determines whether
    it is valid and compatible with the current processor and, if so, whether
    PAE mode should be enabled.

Arguments:

    LoadDeviceId - The ARC device handle of the kernel load device.

    ImagePath - Pointer to a buffer containing the full path of the
        kernel to check.

    ProcessorSupportsPae - TRUE if the current processor supports PAE
        mode, FALSE otherwise.

    UsePae - Upon successful return, indicates whether the kernel is PAE
        enabled.

Return Value:

    TRUE: The supplied kernel image is compatible with the current processor,
        and *UsePae has been updated as appropriate.

    FALSE: The supplied kernel image is invalid or is not compatible with the
        current processor.

--*/

{
    BOOLEAN isPaeKernel;
    BOOLEAN supportsHotPlugMemory;
    ARC_STATUS status;

    status = Blx86GetImageProperties( LoadDeviceId,
                                      ImagePath,
                                      &isPaeKernel,
                                      &supportsHotPlugMemory );
    if (status != ESUCCESS) {

        //
        // This kernel is invalid or does not exist.  Therefore, it is
        // not compatible.
        //

        return FALSE;
    }

    if (isPaeKernel == FALSE) {

        //
        // This is a non-PAE kernel.  All supported processors can run in
        // non-PAE mode.  Indicate that PAE mode should not be used and that
        // this kernel is compatible.
        //

        *UsePae = FALSE;
        return TRUE;

    } else {

        //
        // This is a PAE kernel.
        //

        if (ProcessorSupportsPae == FALSE) {

            //
            // This is a PAE kernel but the processor will not run in that
            // mode.  Indicate that this kernel is not compatible.
            //

            return FALSE;

        } else {

            //
            // This is a PAE kernel and a PAE processor.  Indicate that PAE
            // mode should be used and that this kernel is compatible.
            //

            *UsePae = TRUE;
            return TRUE;
        }
    }
}

ARC_STATUS
Blx86GetImageProperties(
    IN  ULONG    LoadDeviceId,
    IN  PCHAR    ImagePath,
    OUT PBOOLEAN IsPae,
    OUT PBOOLEAN SupportsHotPlugMemory
    )

/*++

Routine Description:

    This routine examines the supplied image and determines whether
    it is valid and, if so, whether it is PAE compatible by examining
    the IMAGE_FILE_LARGE_ADDRESS_AWARE bit.

Arguments:

    LoadDeviceId - The ARC device handle of the image device.

    ImagePath - Pointer to a buffer containing the full path of the
        kernel to check.

    IsPae - Upon successful return, indicates whether the image is PAE
        compatible.

    SupportsHotPlugMemory - Upon successful return, indicates whether the
        image indicates an OS that supports hot plug memory.


Return Value:

    ESUCCESS - The supplied kernel image is valid, and *IsPae has been updated
        according to the image header.

    Otherwise, the Arc status of the failed operation is returned.

--*/

{
    CHAR localBufferSpace[ SECTOR_SIZE * 2 + SECTOR_SIZE - 1 ];
    PCHAR localBuffer;
    ARC_STATUS status;
    ULONG fileId;
    PIMAGE_NT_HEADERS ntHeaders;
    USHORT imageCharacteristics;
    ULONG bytesRead;

    //
    // File I/O here must be sector-aligned.
    //

    localBuffer = (PCHAR)
        (((ULONG)localBufferSpace + SECTOR_SIZE - 1) & ~(SECTOR_SIZE - 1));

    //
    // Read in the PE image header.
    //

    status = BlOpen( LoadDeviceId, ImagePath, ArcOpenReadOnly, &fileId );
    if (status != ESUCCESS) {
        return status;
    }

    status = BlRead( fileId, localBuffer, SECTOR_SIZE * 2, &bytesRead );
    BlClose( fileId );

    if (bytesRead != SECTOR_SIZE * 2) {
        status = EBADF;
    }

    if (status != ESUCCESS) {
        return status;
    }

    //
    // If the file header has the IMAGE_FILE_LARGE_ADDRESS_AWARE
    // characteristic set then this is a PAE image.
    //

    ntHeaders = RtlImageNtHeader( localBuffer );
    if (ntHeaders == NULL) {
        return EBADF;
    }

    imageCharacteristics = ntHeaders->FileHeader.Characteristics;
    if ((imageCharacteristics & IMAGE_FILE_LARGE_ADDRESS_AWARE) != 0) {

        //
        // This is a PAE image.
        //

        *IsPae = TRUE;

    } else {

        //
        // This is not a PAE image.
        //

        *IsPae = FALSE;
    }

    //
    // Hot Plug Memory is only supported post 5.0
    //
    if (ntHeaders->OptionalHeader.MajorOperatingSystemVersion > 5 ||
        ((ntHeaders->OptionalHeader.MajorOperatingSystemVersion == 5) &&
         (ntHeaders->OptionalHeader.MinorOperatingSystemVersion > 0 ))) {
        *SupportsHotPlugMemory = TRUE;
    } else {
        *SupportsHotPlugMemory = FALSE;        
    }

    return ESUCCESS;
}


BOOLEAN
BlpChipsetPaeSupported(
    VOID
    )
/*++

Routine Description:

    Scans PCI space to see if the current chipset is supported for PAE mode.

Arguments:

    None

Return Value:

    TRUE - PAE is supported

    FALSE - PAE is not supported

--*/

{
    ULONG DevVenId=0;
    ULONG i;

    typedef struct _PCIDEVICE {
        ULONG Bus;
        ULONG Device;
        ULONG DevVen;
    } PCIDEVICE, *PPCIDEVICE;

    PCIDEVICE BadChipsets[] = {
        {0, 0, 0x1a208086},     // MCH
        {0, 0, 0x1a218086},     // MCH
        {0, 0, 0x1a228086},     // MCH
        {0, 30, 0x24188086},    // ICH
        {0, 30, 0x24288086}     // ICH
    };


    for (i=0; i<sizeof(BadChipsets)/sizeof(PCIDEVICE); i++) {
        HalGetBusData(PCIConfiguration,
                      BadChipsets[i].Bus,
                      BadChipsets[i].Device,
                      &DevVenId,
                      sizeof(DevVenId));
        if (DevVenId == BadChipsets[i].DevVen) {
            return(FALSE);
        }
    }

    return(TRUE);
}

ARC_STATUS
BlpCheckVersion(
    IN  ULONG    LoadDeviceId,
    IN  PCHAR    ImagePath
    )
{
    CHAR localBufferSpace[ SECTOR_SIZE * 2 + SECTOR_SIZE - 1 ];
    PCHAR localBuffer;
    ARC_STATUS status;
    ULONG fileId;
    PIMAGE_NT_HEADERS ntHeaders;
    USHORT imageCharacteristics;
    ULONG bytesRead;
    ULONG i,j,Count;
    HARDWARE_PTE_X86 nullpte;


    //
    // File I/O here must be sector-aligned.
    //

    localBuffer = (PCHAR)
        (((ULONG)localBufferSpace + SECTOR_SIZE - 1) & ~(SECTOR_SIZE - 1));

    //
    // Read in the PE image header.
    //

    status = BlOpen( LoadDeviceId, ImagePath, ArcOpenReadOnly, &fileId );
    if (status != ESUCCESS) {
        return status;
    }

    status = BlRead( fileId, localBuffer, SECTOR_SIZE * 2, &bytesRead );
    BlClose( fileId );

    if (bytesRead != SECTOR_SIZE * 2) {
        status = EBADF;
    }

    if (status != ESUCCESS) {
        return status;
    }
    ntHeaders = RtlImageNtHeader( localBuffer );
    if (ntHeaders == NULL) {
        return EBADF;
    }
    //
    // Setup the mm remapping checks for post 5.0 or pre 5.0
    //
    if (ntHeaders->OptionalHeader.MajorOperatingSystemVersion < 5 ||
        ((ntHeaders->OptionalHeader.MajorOperatingSystemVersion == 5) &&
          (ntHeaders->OptionalHeader.MinorOperatingSystemVersion == 0 ))) {


            BlOldKernel=TRUE;
            BlKernelChecked=TRUE;
            BlHighestPage = ((16*1024*1024) >> PAGE_SHIFT) - 40;

            //
            // Virtual was moved up for the dynamic load case. It was 64MB off
            // in 5.0 and prior
            //
            RtlZeroMemory (&nullpte,sizeof (HARDWARE_PTE_X86));

            if (BlVirtualBias != 0 ) {

                BlVirtualBias = OLD_ALTERNATE-KSEG0_BASE;

                //
                // PDE entries represent 4MB. Zap the new ones.
                //
                i=(OLD_ALTERNATE) >> 22L;
                j=(ALTERNATE_BASE)>> 22L;

                for (Count = 0; Count < 4;Count++){
                    PDE[i++]= PDE[j++];
                }
                for (Count = 0; Count < 12; Count++) {
                    PDE[i++]= nullpte;
                }
            }
    }

    return (ESUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\ia64\initia64.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initia64.c

Abstract:

    Does any ia64-specific initialization, then starts the common ARC osloader

Author:

    John Vert (jvert) 4-Nov-1993

Revision History:

--*/
#include "bldria64.h"
#include "msg.h"
#include <netboot.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <efi.h>

UCHAR Argv0String[100];

UCHAR BootPartitionName[80];
UCHAR KernelBootDevice[80];
UCHAR OsLoadFilename[100];
UCHAR OsLoaderFilename[100];
UCHAR SystemPartition[100];
UCHAR OsLoadPartition[100];
UCHAR OsLoadOptions[100];
UCHAR ConsoleInputName[50];
UCHAR ConsoleOutputName[50];
UCHAR FullKernelPath[200];

ARC_STATUS
BlGetEfiBootOptions(
    OUT PUCHAR Argv0String OPTIONAL,
    OUT PUCHAR SystemPartition OPTIONAL,
    OUT PUCHAR OsLoaderFilename OPTIONAL,
    OUT PUCHAR OsLoadPartition OPTIONAL,
    OUT PUCHAR OsLoadFilename OPTIONAL,
    OUT PUCHAR FullKernelPath OPTIONAL,
    OUT PUCHAR OsLoadOptions OPTIONAL
    );

BlPreProcessLoadOptions(
    PCHAR szOsLoadOptions
    );

#define MAXBOOTVARSIZE      1024

VOID
BlpTruncateMemory (
    IN ULONG MaxMemory
    );

#if defined(_MERCED_A0_)
VOID
KiProcessorWorkAround(
    );
#endif

VOID
BlStartup(
    IN PCHAR PartitionName
    )

/*++

Routine Description:

    Does Intel-specific initialization, particularly presenting the boot.ini
    menu and running NTDETECT, then calls to the common osloader.

Arguments:

    PartitionName - Supplies the ARC name of the partition (or floppy) that
        setupldr was loaded from.

Return Value:

    Does not return

--*/

{
    ULONG  Argc = 0;
    PUCHAR Argv[10];
    ARC_STATUS Status;
    ULONG BootFileId;
    PCHAR BootFile;
    ULONG Read;
#if !defined(NO_LEGACY_DRIVERS)
    PCHAR p;
#endif

    ULONG i;
    ULONG DriveId;
    ULONG FileSize;
    ULONG Count;
    LARGE_INTEGER SeekPosition;
    PCHAR LoadOptions = NULL;
#ifdef FW_HEAP
    extern BOOLEAN FwDescriptorsValid;
#endif
    PCHAR BadLinkName = NULL;

    UNREFERENCED_PARAMETER( PartitionName );

    //
    // Initialize ARC StdIo functionality
    //

    strcpy(ConsoleInputName,"consolein=multi(0)key(0)keyboard(0)");
    strcpy(ConsoleOutputName,"consoleout=multi(0)video(0)monitor(0)");
    Argv[0]=ConsoleInputName;
    Argv[1]=ConsoleOutputName;
    BlInitStdio (2, Argv);

    //
    // Check ntldr partition for hiberation image
    //

    do {

        BlClearScreen();
        
        Status = BlGetEfiBootOptions(
                    Argv0String,
                    SystemPartition,
                    OsLoaderFilename,
                    OsLoadPartition,
                    OsLoadFilename,
                    FullKernelPath,
                    OsLoadOptions
                    );
        if ( Status != ESUCCESS ) {
            BlPrint(BlFindMessage(BL_EFI_OPTION_FAILURE));            
            goto BootFailed;
        }        
        
        BlClearScreen();
        
#if !defined(NO_LEGACY_DRIVERS)
        p = FullKernelPath;

        //
        // Initialize SCSI boot driver, if necessary.
        //
        if(!_strnicmp(p,"scsi(",5)) {
            AEInitializeIo(DriveId);
        }

#endif // NO_LEGACY_DRIVERS

#if  FW_HEAP
        //
        // Indicate that fw memory descriptors cannot be changed from
        // now on.
        //

        FwDescriptorsValid = FALSE;
#endif
        
        //
        // convert it to all one case
        //
        if (OsLoadOptions[0]) {
            _strupr(OsLoadOptions);
        }

        Argv[Argc++]=Argv0String;
        Argv[Argc++]=OsLoaderFilename;
        Argv[Argc++]=SystemPartition;
        Argv[Argc++]=OsLoadFilename;
        Argv[Argc++]=OsLoadPartition;
        Argv[Argc++]=OsLoadOptions;

        BlPreProcessLoadOptions( OsLoadOptions );

        //
        // In the x86 case, we would have already initialized the
        // headless port so that the user could actually make his
        // boot selection over the headless port.  However, on ia64,
        // that selection is happening during firmware.
        //
        // If the user wants us to redirect (via the OsLoadOptions), then
        // we should try to do it here.
        //
        if( strstr(OsLoadOptions, "/REDIRECT")) {

            //
            // Yep, then want us to redirect.  Try and initialize the
            // port.
            //
            BlInitializeHeadlessPort();

#if 0
            if( LoaderRedirectionInformation.PortNumber == 0 ) {

                //
                // We couldn't get any redirection information
                // from the firmware.  But the user really wants
                // us to redirect.  Better guess.
                //
                LoaderRedirectionInformation.PortNumber = 1;
                LoaderRedirectionInformation.BaudRate = 9600;

                //
                // Now try again, this time with feeling...
                //
                BlInitializeHeadlessPort();

            }
#endif

        }

        Status = BlOsLoader( Argc, Argv, NULL );

    BootFailed:

        if (Status != ESUCCESS) {

            //
            // Boot failed, wait for reboot
            //
            while (TRUE) {
                while (!BlGetKey());  // BOOT FAILED!
                if (BlTerminalHandleLoaderFailure()) {
                   ArcRestart();
                }
            }
        }
    } while (TRUE);

}

BlPreProcessLoadOptions(
    PCHAR szOsLoadOptions
    )
{
    CHAR szTemp[MAXBOOTVARSIZE];
    PCHAR p;
    ULONG MaxMemory = 0;
    ULONG ConfigFlagValue=0;


    strcpy( szTemp, szOsLoadOptions );
    _strupr( szTemp );

#if 0
    if( p = strstr( szTemp, ";" ) ) {
        *p = '\0';
    }
#endif

    //
    // Process MAXMEM
    //
    if( p = strstr( szTemp, "/MAXMEM=" ) ) {
        MaxMemory = atoi( p + sizeof("/MAXMEM=") - 1 );
        BlpTruncateMemory( MaxMemory );
    }

#if defined(_MERCED_A0_)
    //
    // Process CONFIGFLAG
    //
    if ( p = strstr(szTemp, "CONFIGFLAG") ) {
        if ( p = strstr(p, "=") ) {
            ConfigFlagValue = atol(p+1);
            KiProcessorWorkAround(ConfigFlagValue);
        }
    }
#endif

}

BOOLEAN
WillMemoryBeUsableByOs(
    IN MEMORY_TYPE  Type
    )
{
    BOOLEAN RetVal = FALSE;
    switch (Type) {
    case MemoryFree:
    case MemoryFreeContiguous:
    case MemoryFirmwareTemporary:
    case MemorySpecialMemory:
        RetVal = TRUE;
    }

    return(RetVal);
}


VOID
BlpTruncateMemory (
    IN ULONG MaxMemory
    )

/*++

Routine Description:

    Eliminates all the memory descriptors above a given boundary

Arguments:

    MaxMemory - Supplies the maximum memory boundary in megabytes

Return Value:

    None.

--*/

{
    ULONG MaxPage = (MaxMemory * _1MB );
    PLIST_ENTRY Current;
    PMEMORY_ALLOCATION_DESCRIPTOR  MemoryDescriptor;

    if (MaxMemory == 0) {
        return;
    }

    Current = BlLoaderBlock->MemoryDescriptorListHead.Flink;

    while (Current != &BlLoaderBlock->MemoryDescriptorListHead) {
        MemoryDescriptor = CONTAINING_RECORD(Current,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);

        Current = Current->Flink;

        if (WillMemoryBeUsableByOs(MemoryDescriptor->MemoryType)) {
            if (MemoryDescriptor->BasePage >= MaxPage) {
                //
                // This memory descriptor lies entirely above the boundary,
                // mark it as firmware permanent.  this is easier than 
                // unlinking the entry and has the same effect since no one
                // can use this memory.
                //
                MemoryDescriptor->MemoryType = MemoryFirmwarePermanent;
            
            } else if (MemoryDescriptor->BasePage + MemoryDescriptor->PageCount > MaxPage) {
                //
                // This memory descriptor crosses the boundary, truncate it.                
                //
                MemoryDescriptor->PageCount = MaxPage - MemoryDescriptor->BasePage;                
            } else {
                //
                // This one's ok, keep it.
                //                                
            }
        } else {
            //
            // skip it
            //            
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\i386\parsboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    parsboot.c

Abstract:

    Parses the boot.ini file, displays a menu, and provides a kernel
    path and name to be passed to osloader.

Author:

    John Vert (jvert) 22-Jul-1991

Revision History:

--*/
#include "bldrx86.h"
#include "msg.h"
#include "ntdddisk.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

VOID
BlpTruncateDescriptors (
    IN ULONG HighestPage
    );

#define MAX_SELECTIONS 10
#define MAX_TITLE_LENGTH 71

#define WIN95_DOS  1
#define DOS_WIN95  2

typedef struct _MENU_OPTION {
    PCHAR Title;
    PCHAR Path;
    BOOLEAN EnableDebug;
    ULONG MaxMemory;
    PCHAR LoadOptions;
    int ForcedScsiOrdinal;
    int Win95;
    BOOLEAN HeadlessRedirect;
} MENU_OPTION, *PMENU_OPTION;

PCHAR  pDefSwitches = NULL;

int ForcedScsiOrdinal = -1;
CHAR szDebug[] = "unsupporteddebug";
CHAR BlankLine[] = "                                                                      \r";

//
// global to hold the user's last
// selection from the advanced boot menu.
//
LONG AdvancedBoot = -1;

#define DEBUG_LOAD_OPTION_LENGTH    60
CHAR DebugLoadOptions[DEBUG_LOAD_OPTION_LENGTH];


//
// Defines for options for redirecting to a headless terminal
//
#define COM1_19_2 "com1at19200"
#define COM2_19_2 "com2at19200"


//
// Private function prototypes
//
VOID
BlpRebootDOS(
    IN PCHAR BootSectorImage OPTIONAL,
    IN PCHAR LoadOptions OPTIONAL
    );

PCHAR
BlpNextLine(
    IN PCHAR String
    );

VOID
BlpTranslateDosToArc(
    IN PCHAR DosName,
    OUT PCHAR ArcName
    );

VOID
BlpTruncateMemory(
    IN ULONG MaxMemory
    );

ULONG
BlpPresentMenu(
    IN PMENU_OPTION MenuOptions,
    IN ULONG NumberSelections,
    IN ULONG Default,
    IN LONG Timeout
    );

PCHAR *
BlpFileToLines(
    IN PCHAR File,
    OUT PULONG LineCount
    );

PCHAR *
BlpFindSection(
    IN PCHAR SectionName,
    IN PCHAR *BootFile,
    IN ULONG BootFileLines,
    OUT PULONG NumberLines
    );

VOID
BlpRenameWin95Files(
    IN ULONG DriveId,
    IN ULONG Type
    );

VOID
BlParseOsOptions (
    IN PMENU_OPTION MenuOption,
    IN PUCHAR pCurrent
    );

ULONG
BlGetAdvancedBootID(
    LONG BootOption
    );


PCHAR
BlSelectKernel(
    IN ULONG DriveId,
    IN PCHAR BootFile,
    OUT PCHAR *LoadOptions,
    IN BOOLEAN UseTimeOut
    )
/*++

Routine Description:

    Parses the boot.txt file and determines the fully-qualified name of
    the kernel to be booted.

Arguments:

    BootFile - Pointer to the beginning of the loaded boot.txt file

    Debugger - Returns the enable/disable state of the kernel debugger

    UseTimeOut - Supplies whether the boot menu should time out or not.

Return Value:

    Pointer to the name of a kernel to boot.

--*/

{
    PCHAR *MbLines;
    PCHAR *OsLines;
    PCHAR *FileLines;
#if DBG
    PCHAR *DebugLines;
    ULONG DebugLineCount;
#endif
    ULONG FileLineCount;
    ULONG OsLineCount;
    ULONG MbLineCount;
    PCHAR pCurrent;
    PCHAR Option;
    MENU_OPTION MenuOption[MAX_SELECTIONS+1];
    ULONG NumberSystems=0;
    ULONG i;
    LONG Timeout;
    ULONG Selection;
    ULONG DefaultSelection=0;
    static CHAR Kernel[128];
    CHAR DosName[3];
    PCHAR DefaultOldPath="C:\\winnt";
    PCHAR WinntDir = DefaultOldPath + 2;
    PCHAR DefaultNewPath="C:\\windows\\";
    CHAR  DefaultPathBuffer[128] = {0};
    PCHAR DefaultPath = DefaultPathBuffer;
    PCHAR DefaultTitle=BlFindMessage(BL_DEFAULT_TITLE);
    PCHAR p;
    ULONG DirId;

    //
    // Check to see if "winnt" directory exists on the boot
    // device. If it does not exist then make the default path point
    // to "windows" directory
    //
    if (BlOpen(DriveId, WinntDir, ArcOpenDirectory, &DirId) != ESUCCESS) {
        strcpy(DefaultPath, DefaultNewPath);
    } else {
        BlClose(DirId);
        strcpy(DefaultPath, DefaultOldPath);
        strcat(DefaultPath, "\\");
    }

    *LoadOptions = NULL;

    if (*BootFile == '\0') {
        //
        // No boot.ini file, so we boot the default.
        //
        BlPrint(BlFindMessage(BL_INVALID_BOOT_INI),DefaultPath);
        MenuOption[0].Path = DefaultPath;
        MenuOption[0].Title = DefaultTitle;
        MenuOption[0].MaxMemory = 0;
        MenuOption[0].LoadOptions = NULL;
        MenuOption[0].Win95 = 0;
        NumberSystems = 1;
        DefaultSelection = 0;
        MbLineCount = 0;
        OsLineCount = 0;
        MenuOption[0].EnableDebug = FALSE;
#if DBG
        DebugLineCount = 0;
#endif
    } else {
        FileLines = BlpFileToLines(BootFile, &FileLineCount);
        MbLines = BlpFindSection("[boot loader]",
                                 FileLines,
                                 FileLineCount,
                                 &MbLineCount);
        if (MbLines==NULL) {
            MbLines = BlpFindSection("[flexboot]",
                                     FileLines,
                                     FileLineCount,
                                     &MbLineCount);
            if (MbLines==NULL) {
                MbLines = BlpFindSection("[multiboot]",
                                         FileLines,
                                         FileLineCount,
                                         &MbLineCount);
            }
        }

        OsLines = BlpFindSection("[operating systems]",
                                 FileLines,
                                 FileLineCount,
                                 &OsLineCount);

        if (OsLineCount == 0) {

            if (BlBootingFromNet) {
                return NULL;
            }

            BlPrint(BlFindMessage(BL_INVALID_BOOT_INI),DefaultPath);
            MenuOption[0].Path = DefaultPath;
            MenuOption[0].Title = DefaultTitle;
            MenuOption[0].MaxMemory = 0;
            MenuOption[0].LoadOptions = NULL;
            MenuOption[0].Win95 = 0;
            MenuOption[0].HeadlessRedirect = FALSE;
            NumberSystems = 1;
            DefaultSelection = 0;
        }

#if DBG
        DebugLines = BlpFindSection("[debug]",
                                    FileLines,
                                    FileLineCount,
                                    &DebugLineCount);
#endif
    }

    //
    // Set default timeout value
    //
    if (UseTimeOut) {
        Timeout = 0;
    } else {
        Timeout = -1;
    }



    //
    // Before we look through the [boot loader] section, initialize
    // our headless redirection information so that the default is
    // to not redirect.
    //
    RtlZeroMemory( &LoaderRedirectionInformation, sizeof(HEADLESS_LOADER_BLOCK) );
    BlTerminalConnected = FALSE;



    //
    // Parse the [boot loader] section
    //
    for (i=0; i<MbLineCount; i++) {

        pCurrent = MbLines[i];

        //
        // Throw away any leading whitespace
        //
        pCurrent += strspn(pCurrent, " \t");
        if (*pCurrent == '\0') {
            //
            // This is a blank line, so we just throw it away.
            //
            continue;
        }

        //
        // Check for "DefSwitches" line
        //
        if (_strnicmp(pCurrent,"DefSwitches",sizeof("DefSwitches")-1) == 0) {
            pCurrent = strchr(pCurrent,'=');
            if (pCurrent != NULL) {
                pDefSwitches = pCurrent + 1;
            }
            continue;
        }

        //
        // Check for "timeout" line
        //
        if (_strnicmp(pCurrent,"timeout",7) == 0) {

            pCurrent = strchr(pCurrent,'=');
            if (pCurrent != NULL) {
                if (UseTimeOut) {
                    Timeout = atoi(++pCurrent);
                }
            }
        }


        //
        // Check for "redirectbaudrate" line
        //
        if (_strnicmp(pCurrent,"redirectbaudrate",16) == 0) {

            pCurrent = strchr(pCurrent,'=');

            if (pCurrent != NULL) {

                //
                // Skip whitespace
                //
                ++pCurrent;
                pCurrent += strspn(pCurrent, " \t");

                if (*pCurrent != '\0') {

                    //
                    // Fill in our global structure with the information.
                    //
                    if( _strnicmp(pCurrent,"115200",6) == 0 ) {
                        LoaderRedirectionInformation.BaudRate = BD_115200;
                    } else if( _strnicmp(pCurrent,"57600",5) == 0 ) {
                        LoaderRedirectionInformation.BaudRate = BD_57600;
                    } else if( _strnicmp(pCurrent,"19200",5) == 0 ) {
                        LoaderRedirectionInformation.BaudRate = BD_19200;
                    } else {
                        LoaderRedirectionInformation.BaudRate = BD_9600;
                    }
                }
            }

        } else if (_strnicmp(pCurrent,"redirect",8) == 0) {

            //
            // Check for "redirect" line
            //

            pCurrent = strchr(pCurrent,'=');

            if (pCurrent != NULL) {

                //
                // Skip whitespace
                //
                ++pCurrent;
                pCurrent += strspn(pCurrent, " \t");

                if (*pCurrent != '\0') {

                    //
                    // Fill in our global structure with the information.
                    //
#if 0

                    //
                    // Since we now support variable baudrates, there's no
                    // reason to support these hardcoded 19200 strings.
                    //


                    if (_strnicmp(pCurrent, COM1_19_2, sizeof(COM1_19_2)) == 0) {

                        pCurrent += sizeof(COM1_19_2);

                        LoaderRedirectionInformation.PortNumber = 1;
                        LoaderRedirectionInformation.BaudRate = 19200;

                    } else if (_strnicmp(pCurrent, COM2_19_2, sizeof(COM2_19_2)) == 0) {

                        pCurrent += sizeof(COM2_19_2);

                        LoaderRedirectionInformation.PortNumber = 2;
                        LoaderRedirectionInformation.BaudRate = 19200;

                    } else if (_strnicmp(pCurrent,"com",3) == 0) {
#else

                    if (_strnicmp(pCurrent,"com",3) == 0) {
#endif
                        pCurrent +=3;


                        LoaderRedirectionInformation.PortNumber = atoi(pCurrent);

                    } else if (_strnicmp(pCurrent, "usebiossettings", 15) == 0) {

                        BlRetrieveBIOSRedirectionInformation();

                    } else {

                        //
                        // See if they gave us a hardcoded address.
                        //
                        LoaderRedirectionInformation.PortAddress = (PUCHAR)ULongToPtr(strtoul(pCurrent,NULL,16));

                        if( LoaderRedirectionInformation.PortAddress != (PUCHAR)NULL ) {
                            LoaderRedirectionInformation.PortNumber = 3;
                        }

                    }

                }

            }

        }


        //
        // Check for "default" line
        //
        if (_strnicmp(pCurrent,"default",7) == 0) {

            pCurrent = strchr(pCurrent,'=');
            if (pCurrent != NULL) {
                DefaultPath = ++pCurrent;
                DefaultPath += strspn(DefaultPath," \t");
            }

        }

    }



    //
    // If we found any headless redirection settings, go initialize
    // the port now.
    //
    if( LoaderRedirectionInformation.PortNumber ) {

        // make sure we got a baudrate.
        if( LoaderRedirectionInformation.BaudRate == 0 ) {
            LoaderRedirectionInformation.BaudRate = 9600;
        }

        BlInitializeHeadlessPort();
    }



    //
    // Parse the [operating systems] section
    //

    for (i=0; i<OsLineCount; i++) {

        if (NumberSystems == MAX_SELECTIONS) {
            break;
        }

        pCurrent = OsLines[i];

        //
        // Throw away any leading whitespace
        //

        pCurrent += strspn(pCurrent, " \t");
        if (*pCurrent == '\0') {
            //
            // This is a blank line, so we just throw it away.
            //
            continue;
        }

        MenuOption[NumberSystems].Path = pCurrent;

        //
        // The first space or '=' character indicates the end of the
        // path specifier, so we need to replace it with a '\0'
        //
        while ((*pCurrent != ' ')&&
               (*pCurrent != '=')&&
               (*pCurrent != '\0')) {
            ++pCurrent;
        }
        *pCurrent = '\0';

        //
        // The next character that is not space, equals, or double-quote
        // is the start of the title.
        //

        ++pCurrent;
        while ((*pCurrent == ' ') ||
               (*pCurrent == '=') ||
               (*pCurrent == '"')) {
            ++pCurrent;
        }

        if (pCurrent=='\0') {
            //
            // No title was found, so just use the path as the title.
            //
            MenuOption[NumberSystems].Title = MenuOption[NumberSystems].Path;
        } else {
            MenuOption[NumberSystems].Title = pCurrent;
        }

        //
        // The next character that is either a double-quote or a \0
        // indicates the end of the title.
        //
        while ((*pCurrent != '\0')&&
               (*pCurrent != '"')) {
            ++pCurrent;
        }

        //
        // Parse the os load options for this selection
        //

        BlParseOsOptions (&MenuOption[NumberSystems], pCurrent);
        *pCurrent = 0;

        ++NumberSystems;
    }


#if DBG
    //
    // Parse the [debug] section
    //
    for (i=0; i<DebugLineCount; i++) {
        extern ULONG ScsiDebug;

        pCurrent = DebugLines[i];

        //
        // Throw away leading whitespace
        //
        pCurrent += strspn(pCurrent, " \t");
        if (*pCurrent == '\0') {
            //
            // throw away blank lines
            //
            continue;
        }

        if (_strnicmp(pCurrent,"scsidebug",9) == 0) {
            pCurrent = strchr(pCurrent,'=');
            if (pCurrent != NULL) {
                ScsiDebug = atoi(++pCurrent);
            }
        } else if (_strnicmp(pCurrent,"/debug ",7) == 0) {

            //
            // This line contains something to do with debug,
            // pass to BdInitDebugger to handle.
            //
            // Note: very strict rules, debug keyword begins with
            // a slash and is followed by a space.  "/debugport"
            // won't match, nor will "/debug" at the end of the
            // line.
            //
            // Note: If the debugger is hard compiled on, it
            // will already be enabled and these options will
            // have no effect.  Also, the first occurence is
            // the one that takes effect.
            //

            BdInitDebugger(OsLoaderName, (PVOID)OsLoaderBase, pCurrent);
        }
    }

#endif

    //
    // Now look for a Title entry from the [operating systems] section
    // that matches the default entry from the [multiboot] section.  This
    // will give us a title.  If no entry matches, we will add an entry
    // at the end of the list and provide a default Title.
    //
    i=0;
    while (_stricmp(MenuOption[i].Path,DefaultPath) != 0) {
        ++i;
        if (i==NumberSystems) {
            //
            // Create a default entry in the Title and Path arrays
            //
            MenuOption[NumberSystems].Path = DefaultPath;
            MenuOption[NumberSystems].Title = DefaultTitle;
            MenuOption[NumberSystems].EnableDebug = FALSE;
            MenuOption[NumberSystems].MaxMemory = 0;
            MenuOption[NumberSystems].LoadOptions = NULL;
            MenuOption[NumberSystems].Win95 = 0;
            ++NumberSystems;
        }
    }

    DefaultSelection = i;

    //
    // Display the menu of choices
    //

    Selection = BlpPresentMenu( MenuOption,
                                NumberSystems,
                                DefaultSelection,
                                Timeout);

    pCurrent = MenuOption[Selection].LoadOptions;
    if (pCurrent != NULL) {

        //
        // Remove '/' from LoadOptions string.
        //

        *LoadOptions = pCurrent + 1;
        while (*pCurrent != '\0') {
            if (*pCurrent == '/') {
                *pCurrent = ' ';
            }
            ++pCurrent;
        }
    } else {
        *LoadOptions = NULL;
    }

    if (MenuOption[Selection].Win95) {
        BlpRenameWin95Files( DriveId, MenuOption[Selection].Win95 );
    }



    //
    // We need to take care of the following cases:
    // 1. The user has asked us to redirect via the osload
    //    option entry, but did not ask the loader to redirect.
    //    In this case, we will default to COM1.
    //
    // 2. The loader was asked to redirect via the "redirect"
    //    specifier in the [boot loader] section.  But the
    //    user did NOT have a /redirect option on the osload
    //    options.  In this case, we need to kill the
    //    LoaderRedirectionInformation variable.
    //
    if( MenuOption[Selection].HeadlessRedirect ) {

#if 0
// matth (7/25/2000) Don't do this for now.  If the user has
//                   this configuration in their boot.ini, it's
//                   an error on their part.
        //
        // he's asked us to redirect the operating system.  Make
        // sure the Loader was also asked to redirect too.
        //
        if( LoaderRedirectionInformation.PortNumber == 0 ) {

            //
            // the loader wasn't asked to redirect.  The user
            // made a mistake here, but let's guess as to what
            // he wants.
            //
            RtlZeroMemory( &LoaderRedirectionInformation, sizeof(HEADLESS_LOADER_BLOCK) );
            LoaderRedirectionInformation.PortNumber = 1;
            LoaderRedirectionInformation.BaudRate = 9600;

        }
#endif

    } else {

        //
        // He's asked us to not redirect.  Make sure we don't pass
        // information to the OS so he won't be able to redirect.
        //
        RtlZeroMemory( &LoaderRedirectionInformation, sizeof(HEADLESS_LOADER_BLOCK) );

        BlTerminalConnected = FALSE;
    }



    if (_strnicmp(MenuOption[Selection].Path,"C:\\",3) == 0) {

        //
        // This syntax means that we are booting a root-based os
        // from an alternate boot sector image.
        // If no file name is specified, BlpRebootDos will default to
        // \bootsect.dos.
        //
        BlpRebootDOS(MenuOption[Selection].Path[3] ? &MenuOption[Selection].Path[2] : NULL,*LoadOptions);

        //
        // If this returns, it means that the file does not exist as a bootsector.
        // This allows c:\winnt35 to work as a boot path specifier as opposed to
        // a boot sector image filename specifier.
        //
    }

    if (MenuOption[Selection].Path[1]==':') {
        //
        // We need to translate the DOS name into an ARC name
        //
        DosName[0] = MenuOption[Selection].Path[0];
        DosName[1] = MenuOption[Selection].Path[1];
        DosName[2] = '\0';

        BlpTranslateDosToArc(DosName,Kernel);
        strcat(Kernel,MenuOption[Selection].Path+2);
    } else {
        strcpy(Kernel,MenuOption[Selection].Path);
    }

    //
    // the use made a valid selection from the
    // advanced boot menu so append the advanced
    // boot load options and perform any load
    // option processing.
    //
    if (AdvancedBoot != -1) {
        PSTR s = BlGetAdvancedBootLoadOptions(AdvancedBoot);
        if (s) {
            ULONG len = strlen(s) + (*LoadOptions ? strlen(*LoadOptions) : 0);
            s = BlAllocateHeap(len * sizeof(PCHAR));
            if (s) {
                *s = 0;
                if (*LoadOptions) {
                    strcat(s,*LoadOptions);
                    strcat(s," ");
                }
                strcat(s,BlGetAdvancedBootLoadOptions(AdvancedBoot));
                *LoadOptions = s;
            }
        }
        BlDoAdvancedBootLoadProcessing(AdvancedBoot);
    }

    //
    // Make sure there is no trailing slash
    //

    if (Kernel[strlen(Kernel)-1] == '\\') {
        Kernel[strlen(Kernel)-1] = '\0';
    }

    //
    // If MaxMemory is not zero, adjust the memory descriptors to eliminate
    // memory above the boundary line
    //
    // [chuckl 12/03/2001] Note that we use BlpTruncateDescriptors, not
    // BlpTruncateMemory. BlpTruncateMemory truncates the low-level MDArray
    // descriptors, while BlpTruncateDescriptors truncates the loader-level
    // memory descriptor list. Using BlpTruncateMemory worked when the loader
    // initialized its memory list twice. (BlMemoryInitialize was called twice.)
    // But this no longer happens, so we have to truncate the descriptors
    // directly here.
    //

    if (MenuOption[Selection].MaxMemory != 0) {
        ULONG MaxPage = (MenuOption[Selection].MaxMemory * ((1024 * 1024) / PAGE_SIZE)) - 1;
        BlpTruncateDescriptors(MaxPage);
    }

    ForcedScsiOrdinal = MenuOption[Selection].ForcedScsiOrdinal;

    return(Kernel);
}

VOID
BlParseOsOptions (
    IN PMENU_OPTION MenuOption,
    IN PUCHAR pCurrent
    )
{
    PUCHAR      p;

    //
    // Clear all settings
    //

    MenuOption->ForcedScsiOrdinal = -1;
    MenuOption->MaxMemory = 0;
    MenuOption->LoadOptions = NULL;
    MenuOption->Win95 = 0;
    MenuOption->EnableDebug = FALSE;
    MenuOption->HeadlessRedirect = FALSE;

    // If there are no switches specified for this line, use the DefSwitches

    if ((strchr(pCurrent,'/') == NULL) && (pDefSwitches)) {
        pCurrent = pDefSwitches;
    }

    //
    // Convert to all one case
    //

    _strupr(pCurrent);

    //
    // Look for a scsi(x) ordinal to use for opens on scsi ARC paths.
    // This spec must immediately follow the title and is not part
    // of the load options.
    //

    p = strstr(pCurrent,"/SCSIORDINAL:");
    if(p) {
        MenuOption->ForcedScsiOrdinal = atoi(p + sizeof("/SCSIORDINAL:") - 1);
    }

    //
    // If there is a REDIRECT parameter after the description, then
    // we need to pass this to the osloader.
    //

    p = strstr(pCurrent,"/REDIRECT");
    if(p) {
        MenuOption->HeadlessRedirect = TRUE;
    }

    //
    // If there is a DEBUG parameter after the description, then
    // we need to pass the DEBUG option to the osloader.
    //

    if (strchr(pCurrent,'/') != NULL) {
        pCurrent = strchr(pCurrent+1,'/');
        MenuOption->LoadOptions = pCurrent;

        if (pCurrent != NULL) {

            p = strstr(pCurrent,"/MAXMEM");
            if (p) {
                MenuOption->MaxMemory = atoi(p+8);
            }

            if (strstr(pCurrent, "/WIN95DOS")) {
                MenuOption->Win95 = WIN95_DOS;
            } else if (strstr(pCurrent, "/WIN95")) {
                MenuOption->Win95 = DOS_WIN95;
            }

            //
            // As long as /nodebug or /crashdebug is specified, this is NO debug system
            // If /NODEBUG is not specified, and either one of the
            // DEBUG or BAUDRATE is specified, this is debug system.
            //

            if ((strstr(pCurrent, "NODEBUG") == NULL) &&
                (strstr(pCurrent, "CRASHDEBUG") == NULL)) {
                if (strstr(pCurrent, "DEBUG") || strstr(pCurrent, "BAUDRATE")) {

                    if (_stricmp(MenuOption->Path, "C:\\")) {
                        MenuOption->EnableDebug = TRUE;
                    }
                }
            }
        }
    }
}

PCHAR *
BlpFileToLines(
    IN PCHAR File,
    OUT PULONG LineCount
    )

/*++

Routine Description:

    This routine converts the loaded BOOT.INI file into an array of
    pointers to NULL-terminated ASCII strings.

Arguments:

    File - supplies a pointer to the in-memory image of the BOOT.INI file.
           This will be converted in place by turning CR/LF pairs into
           null terminators.

    LineCount - Returns the number of lines in the BOOT.INI file.

Return Value:

    A pointer to an array of pointers to ASCIIZ strings.  The array will
    have LineCount elements.

    NULL if the function did not succeed for some reason.

--*/

{
    ULONG Line;
    PCHAR *LineArray;
    PCHAR p;
    PCHAR Space;

    p = File;

    //
    // First count the number of lines in the file so we know how large
    // an array to allocate.
    //
    *LineCount=1;
    while (*p != '\0') {
        p=strchr(p, '\n');
        if (p==NULL) {
            break;
        }
        ++p;

        //
        // See if there's any text following the CR/LF.
        //
        if (*p=='\0') {
            break;
        }

        *LineCount += 1;
    }

    LineArray = BlAllocateHeap(*LineCount * sizeof(PCHAR));

    //
    // Now step through the file again, replacing CR/LF with \0\0 and
    // filling in the array of pointers.
    //
    p=File;
    for (Line=0; Line < *LineCount; Line++) {
        LineArray[Line] = p;
        p=strchr(p, '\r');
        if (p != NULL) {
            *p = '\0';
            ++p;
            if (*p=='\n') {
                *p = '\0';
                ++p;
            }
        } else {
            p=strchr(LineArray[Line], '\n');
            if (p != NULL) {
                *p = '\0';
                ++p;
            }
        }

        //
        // remove trailing white space
        //
        Space = LineArray[Line] + strlen(LineArray[Line])-1;
        while ((*Space == ' ') || (*Space == '\t')) {
            *Space = '\0';
            --Space;
        }
    }

    return(LineArray);
}


PCHAR *
BlpFindSection(
    IN PCHAR SectionName,
    IN PCHAR *BootFile,
    IN ULONG BootFileLines,
    OUT PULONG NumberLines
    )

/*++

Routine Description:

    Finds a section ([multiboot], [operating systems], etc) in the boot.ini
    file and returns a pointer to its first line.  The search will be
    case-insensitive.

Arguments:

    SectionName - Supplies the name of the section.  No brackets.

    BootFile - Supplies the array of pointers to lines of the ini file.

    BootFileLines - Supplies the number of lines in the ini file.

    NumberLines - Returns the number of lines in the section.

Return Value:

    Pointer to an array of ASCIIZ strings, one entry per line.

    NULL, if the section was not found.

--*/

{
    ULONG cnt;
    ULONG StartLine;

    for (cnt=0; cnt<BootFileLines; cnt++) {

        //
        // Check to see if this is the line we are looking for
        //
        if (_stricmp(BootFile[cnt],SectionName) == 0) {

            //
            // found it
            //
            break;
        }
    }
    if (cnt==BootFileLines) {
        //
        // We ran out of lines, never found the right section.
        //
        *NumberLines = 0;
        return(NULL);
    }

    StartLine = cnt+1;

    //
    // Find end of section
    //
    for (cnt=StartLine; cnt<BootFileLines; cnt++) {
        if (BootFile[cnt][0] == '[') {
            break;
        }
    }

    *NumberLines = cnt-StartLine;

    return(&BootFile[StartLine]);
}

PCHAR
BlpNextLine(
    IN PCHAR String
    )

/*++

Routine Description:

    Finds the beginning of the next text line

Arguments:

    String - Supplies a pointer to a null-terminated string

Return Value:

    Pointer to the character following the first CR/LF found in String

        - or -

    NULL - No CR/LF found before the end of the string.

--*/

{
    PCHAR p;

    p=strchr(String, '\n');
    if (p==NULL) {
        return(p);
    }

    ++p;

    //
    // If there is no text following the CR/LF, there is no next line
    //
    if (*p=='\0') {
        return(NULL);
    } else {
        return(p);
    }
}

VOID
BlpRebootDOS(
    IN PCHAR BootSectorImage OPTIONAL,
    IN PCHAR LoadOptions OPTIONAL
    )

/*++

Routine Description:

    Loads up the bootstrap sectors and executes them (thereby rebooting
    into DOS or OS/2)

Arguments:

    BootSectorImage - If specified, supplies name of file on the C: drive
        that contains the boot sector image. In this case, this routine
        will return if that file cannot be opened (for example, if it's
        a directory).  If not specified, then default to \bootsect.dos,
        and this routine will never return.

Return Value:

    None.

--*/

{
    ULONG SectorId;
    ARC_STATUS Status;
    ULONG Read;
    ULONG DriveId;
    ULONG BootType;
    LARGE_INTEGER SeekPosition;
    extern UCHAR BootPartitionName[];

    //
    // HACKHACK John Vert (jvert)
    //     Some SCSI drives get really confused and return zeroes when
    //     you use the BIOS to query their size after the AHA driver has
    //     initialized.  This can completely tube OS/2 or DOS.  So here
    //     we try and open both BIOS-accessible hard drives.  Our open
    //     code is smart enough to retry if it gets back zeros, so hopefully
    //     this will give the SCSI drives a chance to get their act together.
    //
    Status = ArcOpen("multi(0)disk(0)rdisk(0)partition(0)",
                     ArcOpenReadOnly,
                     &DriveId);
    if (Status == ESUCCESS) {
        ArcClose(DriveId);
    }

    Status = ArcOpen("multi(0)disk(0)rdisk(1)partition(0)",
                     ArcOpenReadOnly,
                     &DriveId);
    if (Status == ESUCCESS) {
        ArcClose(DriveId);
    }

    //
    // Load the boot sector at address 0x7C00 (expected by Reboot callback)
    //
    Status = ArcOpen(BootPartitionName,
                     ArcOpenReadOnly,
                     &DriveId);
    if (Status != ESUCCESS) {
        BlPrint(BlFindMessage(BL_REBOOT_IO_ERROR),BootPartitionName);
        while (1) {
            BlGetKey();
        }
    }
    Status = BlOpen( DriveId,
                     BootSectorImage ? BootSectorImage : "\\bootsect.dos",
                     ArcOpenReadOnly,
                     &SectorId );

    if (Status != ESUCCESS) {
        if(BootSectorImage) {
            //
            // The boot sector image might actually be a directory.
            // Return to the caller to attempt standard boot.
            //
            ArcClose(DriveId);
            return;
        }
        BlPrint(BlFindMessage(BL_REBOOT_IO_ERROR),BootPartitionName);
        while (1) {
        }
    }

    Status = BlRead( SectorId,
                     (PVOID)0x7c00,
                     SECTOR_SIZE,
                     &Read );

    if (Status != ESUCCESS) {
        BlPrint(BlFindMessage(BL_REBOOT_IO_ERROR),BootPartitionName);
        while (1) {
        }
    }

    //
    // The FAT boot code is only one sector long so we just want
    // to load it up and jump to it.
    //
    // For HPFS and NTFS, we can't do this because the first sector
    // loads the rest of the boot sectors -- but we want to use
    // the boot code in the boot sector image file we loaded.
    //
    // For HPFS, we load the first 20 sectors (boot code + super and
    // space blocks) into d00:200.  Fortunately this works for both
    // NT and OS/2.
    //
    // For NTFS, we load the first 16 sectors and jump to d00:256.
    // If the OEM field of the boot sector starts with NTFS, we
    // assume it's NTFS boot code.
    //

    //
    // Try to read 8K from the boot code image.
    // If this succeeds, we have either HPFS or NTFS.
    //
    SeekPosition.QuadPart = 0;
    BlSeek(SectorId,&SeekPosition,SeekAbsolute);
    BlRead(SectorId,(PVOID)0xd000,SECTOR_SIZE*16,&Read);

    if(Read == SECTOR_SIZE*16) {

        if(memcmp((PVOID)0x7c03,"NTFS",4)) {

            //
            // HPFS -- we need to load the super block.
            //
            BootType = 1;       // HPFS

            SeekPosition.QuadPart = 16*SECTOR_SIZE;
            ArcSeek(DriveId,&SeekPosition,SeekAbsolute);
            ArcRead(DriveId,(PVOID)0xf000,SECTOR_SIZE*4,&Read);

        } else {

            //
            // NTFS -- we've loaded everything we need to load.
            //
            BootType = 2;   // NTFS
        }
    } else {

        BootType = 0;       // FAT

    }

    if (LoadOptions) {
        if (_stricmp(LoadOptions,"cmdcons") == 0) {
            strcpy( (PCHAR)(0x7c03), "cmdcons" );
        } else if (strcmp(LoadOptions,"ROLLBACK") == 0) {

            //
            // By definition, when /rollback is specified, it is the only load
            // option. It eventually gets parsed, gets upper-cased, and gets
            // its slash removed. So we check for the exact text "ROLLBACK".
            //
            // When rollback is specified, we have to write a token somewhere
            // in the boot sector. This is our only way to send runtime
            // options to the setup loader.
            //
            // There is a data buffer of 8 bytes at 0000:7C03 in all boot
            // sectors today. Fortunately we can overwrite it. So we hard-code
            // this address here and in the setup loader.
            //

            strcpy( (PCHAR)(0x7c03), "undo" );
        }
    }

    //
    // DX must be the drive to boot from
    //

    _asm {
        mov dx, 0x80
    }
    REBOOT(BootType);

}


ULONG
BlpPresentMenu(
    IN PMENU_OPTION MenuOption,
    IN ULONG NumberSelections,
    IN ULONG Default,
    IN LONG Timeout
    )

/*++

Routine Description:

    Displays the menu of boot options and allows the user to select one
    by using the arrow keys.

Arguments:

    MenuOption - Supplies array of menu options

    NumberSelections - Supplies the number of entries in the MenuOption array.

    Default - Supplies the index of the default operating system choice.

    Timeout - Supplies the timeout (in seconds) before the highlighted
              operating system choice is booted.  If this value is -1,
              the menu will never timeout.

Return Value:

    ULONG - The index of the operating system choice selected.

--*/

{
    ULONG i;
    ULONG Selection;
    ULONG StartTime;
    ULONG LastTime;
    ULONG BiasTime=0;
    ULONG CurrentTime;
    LONG SecondsLeft;
    LONG LastSecondsLeft = -1;
    ULONG EndTime;
    ULONG Key;
    ULONG MaxLength;
    ULONG CurrentLength;
    PCHAR DebugSelect;
    PCHAR SelectOs;
    PCHAR MoveHighlight;
    PCHAR TimeoutCountdown;
    PCHAR EnabledKd;
    PCHAR AdvancedBootMessage;
    PCHAR HeadlessRedirect;
    PCHAR p;
    BOOLEAN Moved;
    BOOLEAN ResetDisplay;
    BOOLEAN AllowNewOptions;
    BOOLEAN BlankLineDrawn;
    PCHAR pDebug;

    //
    // Get the strings we'll need to display.
    //
    SelectOs = BlFindMessage(BL_SELECT_OS);
    MoveHighlight = BlFindMessage(BL_MOVE_HIGHLIGHT);
    TimeoutCountdown = BlFindMessage(BL_TIMEOUT_COUNTDOWN);
    EnabledKd = BlFindMessage(BL_ENABLED_KD_TITLE);
    AdvancedBootMessage = BlFindMessage(BL_ADVANCED_BOOT_MESSAGE);
    HeadlessRedirect = BlFindMessage(BL_HEADLESS_REDIRECT_TITLE);
    if ((SelectOs == NULL)      ||
        (MoveHighlight == NULL) ||
        (EnabledKd == NULL)     ||
        (TimeoutCountdown==NULL)||
        (AdvancedBootMessage == NULL)) {

        return(Default);
    }

    p=strchr(TimeoutCountdown,'\r');
    if (p!=NULL) {
        *p='\0';
    }

    p=strchr(EnabledKd,'\r');
    if (p!=NULL) {
        *p='\0';
    }

    p=strchr(HeadlessRedirect,'\r');
    if (p!=NULL) {
        *p='\0';
    }

    if (NumberSelections<=1) {
        Timeout = 0;
    }

    if (Timeout == 0) {
        
        //
        // Check for F5 or F8 key
        //
        switch (BlGetKey()) {
        case F5_KEY:
        case F8_KEY:
            Timeout = -1;
            break;

        default:
            // 
            // Timeout is zero, and we didn't get a f5 or f8.  
            // immediately boot the default
            //
            return(Default);
        }
    }

    //
    // By default, on a free build of the loader only allow the
    // user to specify new options if there is some selection
    // which supports debugging or selection to boot dos.  If
    // all the selections are for non-debug versions of NT then
    // do not allow the user to change any of them
    //

    AllowNewOptions = FALSE;
#if DBG
    AllowNewOptions = TRUE;
#endif

    //
    // Find the longest string in the selections, so we know how long to
    // make the highlight bar.
    //

    MaxLength=0;
    for (i=0; i<NumberSelections; i++) {
        CurrentLength = strlen(MenuOption[i].Title);

        if (MenuOption[i].HeadlessRedirect == TRUE) {
            CurrentLength += strlen(HeadlessRedirect);
        }

        if (CurrentLength > MAX_TITLE_LENGTH) {
            //
            // This title is too long to fit on one line, so we have to
            // truncate it.
            //
            if (MenuOption[i].HeadlessRedirect == TRUE) {
                AllowNewOptions = TRUE;
                MenuOption[i].Title[MAX_TITLE_LENGTH - strlen(HeadlessRedirect)] = '\0';
            } else {
                MenuOption[i].Title[MAX_TITLE_LENGTH] = '\0';
            }

            CurrentLength = MAX_TITLE_LENGTH;
        }



        if (MenuOption[i].EnableDebug == TRUE) {
            CurrentLength += strlen(EnabledKd);

            if (CurrentLength > MAX_TITLE_LENGTH) {
                //
                // This title is too long to fit on one line, so we have to
                // truncate it.
                //
                AllowNewOptions = TRUE;
                MenuOption[i].Title[strlen(MenuOption[i].Title) - strlen(EnabledKd)] = '\0';
                CurrentLength = MAX_TITLE_LENGTH;
            }

        }

        if (MenuOption[i].EnableDebug == TRUE ||
            MenuOption[i].Win95 != 0 ||
            _stricmp(MenuOption[i].Path, "C:\\") == 0) {
                AllowNewOptions = TRUE;
        }

        if (CurrentLength > MaxLength) {
            MaxLength = CurrentLength;
        }
    }

    Selection = Default;
    CurrentTime = StartTime = GET_COUNTER();
    EndTime = StartTime + (Timeout * 182) / 10;
    pDebug = szDebug;
    DebugSelect = NULL;
    ResetDisplay = TRUE;
    Moved = TRUE;
    BlankLineDrawn = FALSE;
    do {

        if (ResetDisplay) {
            ARC_DISPLAY_ATTRIBUTES_OFF();
            ARC_DISPLAY_CLEAR();
//          ARC_DISPLAY_POSITION_CURSOR(0, 0);
//          BlPrint(OsLoaderVersion);
            ARC_DISPLAY_POSITION_CURSOR(0, 23);
            if (AdvancedBoot != -1) {
                ARC_DISPLAY_SET_COLOR("1;34"); // high-intensity red
                BlPrint(BlGetAdvancedBootDisplayString(AdvancedBoot));
                ARC_DISPLAY_ATTRIBUTES_OFF();
            } else {
                ARC_DISPLAY_CLEAR_TO_EOL();
            }
            ARC_DISPLAY_POSITION_CURSOR(0, 21);
            BlPrint(AdvancedBootMessage);
            ARC_DISPLAY_POSITION_CURSOR(0, 2);
            BlPrint(SelectOs);
            ResetDisplay = FALSE;
            ARC_DISPLAY_POSITION_CURSOR(0, 5+NumberSelections-1);
            BlPrint(MoveHighlight);
        }

        if(Moved) {
            for (i=0; i<NumberSelections; i++) {
                ARC_DISPLAY_POSITION_CURSOR(0, 5+i);
                if (i==Selection) {
                    ARC_DISPLAY_INVERSE_VIDEO();
                }
                BlPrint( "    %s", MenuOption[i].Title);

                if (MenuOption[i].HeadlessRedirect == TRUE) {
                    BlPrint(HeadlessRedirect);
                }

                if (MenuOption[i].EnableDebug == TRUE) {
                    BlPrint(EnabledKd);
                }
                ARC_DISPLAY_ATTRIBUTES_OFF();
            }

            if (DebugSelect) {
                ARC_DISPLAY_POSITION_CURSOR(0, 7+NumberSelections-1);
                ARC_DISPLAY_CLEAR_TO_EOD();
                DebugLoadOptions[0] = 0;
                DebugLoadOptions[DEBUG_LOAD_OPTION_LENGTH-1] = 0;
                if (MenuOption[Selection].LoadOptions) {
                    i = strlen(MenuOption[Selection].LoadOptions) + 1;
                    if (i > DEBUG_LOAD_OPTION_LENGTH-1) {
                        i = DEBUG_LOAD_OPTION_LENGTH-1;
                    }

                    memcpy (DebugLoadOptions, MenuOption[Selection].LoadOptions, i);
                }

                BlPrint (
                    DebugSelect,
                    MenuOption[Selection].Title,
                    MenuOption[Selection].Path,
                    DebugLoadOptions
                    );

            }

            Moved = FALSE;
        }


        if (!DebugSelect) {
            if (Timeout != -1) {
                LastTime = CurrentTime;
                CurrentTime = GET_COUNTER();

                //
                // deal with wraparound at midnight
                // We can't do it the easy way because there are not exactly
                // 18.2 * 60 * 60 * 24 tics/day.  (just approximately)
                //
                if (CurrentTime < StartTime) {
                    if (BiasTime == 0) {
                        BiasTime = LastTime + 1;
                    }
                    CurrentTime += BiasTime;
                }
                SecondsLeft = ((LONG)(EndTime - CurrentTime) * 10) / 182;

                if (SecondsLeft < 0) {

                    //
                    // Note that if the user hits the PAUSE key, the counter stops
                    // and, as a result, SecondsLeft can become < 0.
                    //

                    SecondsLeft = 0;
                }

                if (SecondsLeft != LastSecondsLeft) {

                    ARC_DISPLAY_POSITION_CURSOR(0, 5+NumberSelections-1);
                    BlPrint(MoveHighlight);
                    BlPrint(TimeoutCountdown);
                    BlPrint(" %d \n",SecondsLeft);
                    LastSecondsLeft = SecondsLeft;

                }

            } else if (!BlankLineDrawn) {
                BlankLineDrawn = TRUE;
                ARC_DISPLAY_POSITION_CURSOR(0, 5+NumberSelections-1);
                BlPrint(MoveHighlight);
                BlPrint(BlankLine);
            }

        }

        //
        // Poll for a key.
        //
        Key = BlGetKey();

        if (Key) {

            //
            // Any key stops timeout
            //

            Timeout = -1;

            //
            // Check for debug string
            //

            if ((UCHAR) Key == *pDebug) {
                pDebug++;
                if (!*pDebug) {
                    Moved = TRUE;
                    DebugSelect = BlFindMessage(BL_DEBUG_SELECT_OS);
                    SelectOs = DebugSelect;
                }
            } else {
                pDebug = szDebug;
            }
        }

#if defined(ENABLE_LOADER_DEBUG) || DBG

        //
        // for debugging only.
        // lets you break into the debugger
        // with the F10 key.
        //
        if (Key == F10_KEY) {
            extern LOGICAL BdDebuggerEnabled;

            if (BdDebuggerEnabled == TRUE) {
                DbgBreakPoint();
            }
        }
#endif

        //
        // check for advanced boot options
        //

        if (Key == F8_KEY || Key == F5_KEY) {

            AdvancedBoot = BlDoAdvancedBoot( BL_ADVANCEDBOOT_TITLE, AdvancedBoot, FALSE, 0 );

#if 0
            if ((AdvancedBoot != -1) &&
                    (BlGetAdvancedBootID(AdvancedBoot) == BL_MSG_BOOT_NORMALLY)) {
                AdvancedBoot = -1;
                // break;  // the current selection need to be booted (normally)
            }
#endif

            if ((AdvancedBoot != -1) &&
                    (BlGetAdvancedBootID(AdvancedBoot) == BL_MSG_REBOOT)) {
                BlClearScreen();
                REBOOT_PROCESSOR();
            }

            ResetDisplay = TRUE;
            Moved = TRUE;

        } else

        //
        // Check for selection
        //

        if ( (Key==UP_ARROW) ||
             (Key==DOWN_ARROW) ||
             (Key==HOME_KEY) ||
             (Key==END_KEY)
           ) {
            Moved = TRUE;
            ARC_DISPLAY_POSITION_CURSOR(0, 5+Selection);
            ARC_DISPLAY_ATTRIBUTES_OFF();
            BlPrint( "    %s", MenuOption[Selection].Title);
            if (Key==DOWN_ARROW) {
                Selection = (Selection+1) % NumberSelections;
            } else if (Key==UP_ARROW) {
                Selection = (Selection == 0) ? (NumberSelections-1)
                                             : (Selection - 1);
            } else if (Key==HOME_KEY) {
                Selection = 0;
            } else if (Key==END_KEY) {
                Selection = NumberSelections-1;
            }
        }

    } while ( ((Key&(ULONG)0xff) != ENTER_KEY) &&
              ((CurrentTime < EndTime) || (Timeout == -1)) );

    //
    // If debugging, prompt the user for new load options
    //

    if (DebugSelect  &&  AllowNewOptions) {
        ARC_DISPLAY_CLEAR();
        ARC_DISPLAY_POSITION_CURSOR(0, 2);
        ARC_DISPLAY_CLEAR_TO_EOD();

        BlPrint (
            DebugSelect,
            MenuOption[Selection].Title,
            MenuOption[Selection].Path,
            DebugLoadOptions
            );

        BlInputString (
            BL_DEBUG_NEW_OPTIONS,
            0, 7,
            DebugLoadOptions,
            DEBUG_LOAD_OPTION_LENGTH - 1
            );

        BlParseOsOptions (
            &MenuOption[Selection],
            DebugLoadOptions
            );
    }

    return(Selection);
}



ARC_STATUS
BlpRenameWin95SystemFile(
    IN ULONG DriveId,
    IN ULONG Type,
    IN PCHAR FileName,
    IN PCHAR Ext,
    IN PCHAR NewName
    )

/*++

Routine Description:

    Renames a file from one name to another.

Arguments:

    DriveId     - Open drive identifier
    Type        - WIN95_DOS or DOS_WIN95
    FileName    - Base file name
    Ext         - Base extension
    NewName     - Non-NULL value causes an override of a generated name

Return Value:

    Arc status of the failed opperation or E_SUCCESS.

--*/

{
    ARC_STATUS Status;
    ULONG FileId;
    ULONG FileIdCur;
    CHAR Fname[16];
    CHAR FnameCur[16];
    CHAR FnameNew[16];


    if (Type == WIN95_DOS) {
        sprintf( Fname, "%s.dos", FileName );
    } else {
        if (NewName) {
            strcpy( Fname, NewName );
        } else {
            sprintf( Fname, "%s.w40", FileName );
        }
    }

    Status = BlOpen(
        DriveId,
        Fname,
        ArcOpenReadOnly,
        &FileId
        );
    if (Status != ESUCCESS) {
        return Status;
    }

    sprintf( FnameCur, "%s.%s", FileName, Ext );

    Status = BlOpen(
        DriveId,
        FnameCur,
        ArcOpenReadOnly,
        &FileIdCur
        );
    if (Status != ESUCCESS) {
        BlClose( FileId );
        return Status;
    }

    if (Type == WIN95_DOS) {
        if (NewName) {
            strcpy( FnameNew, NewName );
        } else {
            sprintf( FnameNew, "%s.w40", FileName );
        }
    } else {
        sprintf( FnameNew, "%s.dos", FileName );
    }

    Status = BlRename(
        FileIdCur,
        FnameNew
        );

    BlClose( FileIdCur );

    if (Status != ESUCCESS) {
        BlClose( FileId );
        return Status;
    }

    Status = BlRename(
        FileId,
        FnameCur
        );

    BlClose( FileId );

    return Status;
}


VOID
BlpRenameWin95Files(
    IN ULONG DriveId,
    IN ULONG Type
    )

/*++

Routine Description:

    Renames all Windows 95 system files from either their
    Win95 DOS names to their Win95 name or the reverse.

Arguments:

    DriveId     - Open drive identifier
    Type        - 1=dos to win95, 2=win95 to dos

Return Value:

    None.

--*/

{
    BlpRenameWin95SystemFile( DriveId, Type, "command",  "com", NULL );
    BlpRenameWin95SystemFile( DriveId, Type, "msdos",    "sys", NULL  );
    BlpRenameWin95SystemFile( DriveId, Type, "io",       "sys", "winboot.sys" );
    BlpRenameWin95SystemFile( DriveId, Type, "autoexec", "bat", NULL  );
    BlpRenameWin95SystemFile( DriveId, Type, "config",   "sys", NULL  );
}

ULONG
BlGetAdvancedBootOption(
    VOID
    )
{
    return AdvancedBoot;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bldr\i386\spcrtest.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    initx86.c

Abstract:

    Does any x86-specific initialization, then starts the common ARC osloader

Author:

    John Vert (jvert) 4-Nov-1993

Revision History:

--*/
#include "bldrx86.h"
#include "msg.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#if defined(REMOTE_BOOT)
#include <netboot.h>
#endif // defined(REMOTE_BOOT)

BOOLEAN
BlpPaeSupported(
    VOID
    );

BOOLEAN
BlpChipsetPaeSupported(
    VOID
    );

ARC_STATUS
Blx86IsPaeImage(
    IN  ULONG    LoadDeviceId,
    IN  PCHAR    ImagePath,
    OUT PBOOLEAN IsPae
    );

BOOLEAN
Blx86IsKernelCompatible(
    IN ULONG LoadDeviceId,
    IN PCHAR ImagePath,
    IN BOOLEAN ProcessorSupportsPae,
    IN OUT PBOOLEAN UsePae
    );


UCHAR BootPartitionName[80];
UCHAR KernelBootDevice[80];
UCHAR OsLoadFilename[100];
UCHAR OsLoaderFilename[100];
UCHAR SystemPartition[100];
UCHAR OsLoadPartition[100];
UCHAR OsLoadOptions[100];
UCHAR ConsoleInputName[50];
UCHAR MyBuffer[SECTOR_SIZE+32];
UCHAR ConsoleOutputName[50];
UCHAR X86SystemPartition[sizeof("x86systempartition=") + sizeof(BootPartitionName)];

extern BOOLEAN ForceLastKnownGood;
extern ULONG    BlHighestPage;


VOID
BlStartup(
    IN PCHAR PartitionName
    )

/*++

Routine Description:

    Does x86-specific initialization, particularly presenting the boot.ini
    menu and running NTDETECT, then calls to the common osloader.

Arguments:

    PartitionName - Supplies the ARC name of the partition (or floppy) that
        setupldr was loaded from.

Return Value:

    Does not return

--*/

{
    ULONG Argc = 0;
    PUCHAR Argv[10];
    ARC_STATUS Status;
    ULONG BlLogFileId = (ULONG)-1;
    ULONG Read;
    PCHAR p,q;
    ULONG i;
    ULONG DriveId;
    ULONG FileSize;
    ULONG Count;
    LARGE_INTEGER SeekPosition;
    PCHAR LoadOptions = NULL;
    BOOLEAN UseTimeOut=TRUE;
    BOOLEAN AlreadyInitialized = FALSE;
    extern BOOLEAN FwDescriptorsValid;
    PCHAR BadLinkName = NULL;
    BOOLEAN SPCRTestSucceeded = FALSE;

    //
    // Open the boot partition so we can load boot drivers off it.
    //
    Status = ArcOpen(PartitionName, ArcOpenReadWrite, &DriveId);
    if (Status != ESUCCESS) {
        BlPrint("Couldn't open drive %s\n",PartitionName);
        BlPrint(BlFindMessage(BL_DRIVE_ERROR),PartitionName);
        goto BootFailed;
    }

    //
    // Initialize dbcs font and display support.
    //
    TextGrInitialize(DriveId, NULL);

    //
    // Initialize ARC StdIo functionality
    //

    strcpy(ConsoleInputName,"consolein=multi(0)key(0)keyboard(0)");
    strcpy(ConsoleOutputName,"consoleout=multi(0)video(0)monitor(0)");
    Argv[0]=ConsoleInputName;
    Argv[1]=ConsoleOutputName;
    BlInitStdio (2, Argv);

    //
    // Re-open the boot partition as a temporary work around
    // for NTFS caching bug.
    //
    ArcClose(DriveId);

    Status = ArcOpen(PartitionName, ArcOpenReadWrite, &DriveId);
    
    if (Status != ESUCCESS) {
        BlPrint("Couldn't open drive %s\n",PartitionName);
        BlPrint(BlFindMessage(BL_DRIVE_ERROR),PartitionName);
        goto BootFailed;
    }

    RtlZeroMemory( &LoaderRedirectionInformation,
                   sizeof(HEADLESS_LOADER_BLOCK) );


    //
    // See if we get something from the BIOS.
    //
    if( BlRetrieveBIOSRedirectionInformation() ) {

        BlInitializeHeadlessPort();

        BlPrint("SPCR table detected.\r\n" );
        BlPrint("         PortAddress: %lx\r\n", LoaderRedirectionInformation.PortAddress );
        BlPrint("          PortNumber: %d\r\n", LoaderRedirectionInformation.PortNumber );
        BlPrint("            BaudRate: %d\r\n", LoaderRedirectionInformation.BaudRate );
        BlPrint("              Parity: %d\r\n", LoaderRedirectionInformation.Parity ? 1 : 0 );
        BlPrint("        AddressSpace: %s\r\n", LoaderRedirectionInformation.IsMMIODevice ? "MMIO" : "SysIO" );
        BlPrint("            StopBits: %d\r\n", LoaderRedirectionInformation.StopBits );
        BlPrint("         PciDeviceId: %lx\r\n", LoaderRedirectionInformation.PciDeviceId );
        BlPrint("         PciVendorId: %lx\r\n", LoaderRedirectionInformation.PciVendorId );
        BlPrint("        PciBusNumber: %lx\r\n", LoaderRedirectionInformation.PciBusNumber );
        BlPrint("       PciSlotNumber: %lx\r\n", LoaderRedirectionInformation.PciSlotNumber );
        BlPrint("   PciFunctionNumber: %lx\r\n", LoaderRedirectionInformation.PciFunctionNumber );
        BlPrint("            PciFlags: %lx\r\n", LoaderRedirectionInformation.PciFlags );



        if( BlIsTerminalConnected() ) {
        ULONG   RandomNumber1 = 0;
        ULONG   RandomNumber2 = 0;
        ULONG   ch = 0;

            BlPrint("\r\nUART address verified.\r\n" );

TryAgain:
            //
            // Now generate a (semi)random string.
            //
            RandomNumber1 = (ArcGetRelativeTime() & 0x7FFF) << 16;
            RandomNumber1 += (ArcGetRelativeTime() & 0xFFFF) << 1;

            RandomNumber2 = 0;


            //
            // Send the string, then ask the user to send it back.
            //
            BlPrint( "\r\nPlease enter the following test string: '%d'\r\n", RandomNumber1 );

            do {

                // Get a key.
                while( !(ch = BlGetKey()) ) {
                }

                ch &= 0xFF;
                if( (ch <= '9') && (ch >= '0') ) {
                    RandomNumber2 = (RandomNumber2 * 10) + (ch - 0x30);
                }

            } while( (ch != 0) && (ch != '\r') && (ch != '\n') );

            if( RandomNumber1 == RandomNumber2 ) {
                BlPrint( "Identical string returned. '%d'\r\n", RandomNumber2 );

                SPCRTestSucceeded = TRUE;
                
                
            } else {

                //
                // We failed the check.  Inform the user and try again.
                //
                BlPrint( "Inconsistent string returned. '%d'\r\n", RandomNumber2 );

                // clear the input buffer
                while( (ch = BlGetKey()) );
                goto TryAgain;
            }




        } else {
            BlPrint("\r\nUnable to verify UART address.\r\n" );
        }
        
    } else {

        BlPrint("No SPCR table detected.\r\n");
    }



    //
    // Log the results.
    //
    Status = BlOpen( DriveId,
                     "\\spcrtest.txt",
                     ArcSupersedeReadWrite,
                     &BlLogFileId );

    if (Status != ESUCCESS) {
        BlPrint("Couldn't open logfile on boot drive.\n");
        goto BootFailed;
    } else {

        UCHAR   Buffer[30];
        LONG    Count;

        Count = sizeof(Buffer);
        RtlFillMemory( Buffer, Count, ' ' );
        if( SPCRTestSucceeded ) {
            sprintf( Buffer, "SPCR test succeeded." );
        } else {
            sprintf( Buffer, "SPCR test failed." );
        }
        BlWrite( BlLogFileId, Buffer, Count, &Count );

        BlClose( BlLogFileId );
    }

BootFailed:
    while(1);

}

VOID
DoApmAttemptReconnect(
    VOID
    )
{
}


BOOLEAN
Blx86CheckForPaeKernel(
    IN BOOLEAN UserSpecifiedPae,
    IN BOOLEAN UserSpecifiedNoPae,
    IN PCHAR UserSpecifiedKernelImage,
    IN PCHAR HalImagePath,
    IN ULONG LoadDeviceId,
    IN ULONG SystemDeviceId,
    OUT PULONG HighestSystemPage,
    OUT PBOOLEAN UsePaeMode,
    IN OUT PCHAR KernelPath
    )
{
    return TRUE;
}

BOOLEAN
Blx86IsKernelCompatible(
    IN ULONG LoadDeviceId,
    IN PCHAR ImagePath,
    IN BOOLEAN ProcessorSupportsPae,
    OUT PBOOLEAN UsePae
    )
{
    return TRUE;
}

ARC_STATUS
Blx86IsPaeImage(
    IN  ULONG    LoadDeviceId,
    IN  PCHAR    ImagePath,
    OUT PBOOLEAN IsPae
    )
{
    return ESUCCESS;
}


BOOLEAN
BlpChipsetPaeSupported(
    VOID
    )
{
    return(TRUE);
}

ARC_STATUS
BlpCheckVersion(
    IN  ULONG    LoadDeviceId,
    IN  PCHAR    ImagePath
    )
{
    return ESUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\makefile.inc ===
$(O)\bootfix.bin: ..\etfs\i386\bootfix.asm ..\etfs\i386\$(LANGUAGE)\bootfix.inc
    masm386 -I..\etfs\i386 -I..\etfs\i386\$(LANGUAGE) ..\etfs\i386\bootfix.asm,$(O)\bootfix.obj;
    link16 /tiny $(O)\bootfix.obj,$@;

$(O)\etfsboot.com: i386\etfsboot.asm i386\usa\etfsboot.inc
    masm386 -Ii386 -Ii386\usa i386\etfsboot.asm,$(O)\etfsboot.obj;
    link16 /tiny $(O)\etfsboot.obj,$@;
    
$(O)\bootefs.h: $(O)\etfsboot.com
    bin2c $(O)\etfsboot.com 2048 0 2048 $@ EtfsBootCode
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\br\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Pressione uma tecla para iniciar do CD."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\cs\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Libovolnou klvesou spustte systm z disku CD."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\da\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Tryk p en tast for at starte fra cd."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\es\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Presione cualquier tecla para iniciar desde el CD."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\bootfix.asm ===
;++
;
;Copyright (c) 1995  Microsoft Corporation
;
;Module Name:
;
; bootfix.asm
;
;Abstract:
;
; The code in this "image" is responsible for checking if is appropriate
; for us to boot from CD. We want to boot from CD whenever we don't have
; a valid active partition or when the user pressed CTRL key during the
; boot process.
;
;Author:
;
;    Calin Negreanu (calinn) 25-May-1998
;
;Environment:
;
;    Image has been loaded at 2000:0000 by ETFS boot code.
;    Real mode
;    ISO 9660 El Torito no-emulation CD-ROM Boot support
;    DL = El Torito drive number we booted from
;
;Revision History:
;
;    Calin Negreanu (calinn) 18-Feb-1999
;
;--
        page    ,132
        title   bootfix
        name    bootfix

.8086

CODE SEGMENT
ASSUME  CS:CODE,DS:CODE,SS:NOTHING,ES:NOTHING

ORG  0000H

_BootFix                label       byte

MaxCodeSize             EQU 1024

Part_Active             EQU 0
Part_Type               EQU 4

Data_PartType           EQU 0                   ;address of partition type inside BootData structure

LoadSeg                 EQU 3000H               ;we load MBR here
SectSize                EQU 512
EntriesOnMbr            EQU 4
MbrDataOff              EQU 01BEH
VolbootOrg              EQU 7c00h

JMPFAR  MACRO   DestOfs,DestSeg
        db      0eah
        dw      OFFSET  DestOfs
        dw      DestSeg
        endm

START:

;
; we already have a valid stack set by the original ETFS boot sector
; we only need to set ds and es
;
        push    ds
        push    es
        mov     ax,cs
        mov     ds,ax
        mov     es,ax
;
; read partition table from hdd 80h at LoadSeg:0000
;
        push    es
        mov     ax,LoadSeg
        mov     es,ax
        mov     bx,0000h
        mov     ax,0201h                                            ;read function, one sector
        mov     cx,0001h
        mov     dx,0080h
        int     13h
        jnc     MbrOk

;
; there was an error, boot from CD
;
        pop     es
        jmp     CdBoot

MbrOk:
        pop     es

;
; now it's the time to loop and find the active partition table
;
        push    es

        mov     ax,LoadSeg
        mov     es,ax
        mov     cx,EntriesOnMbr                                     ;number of partitions in partition table
        mov     bp,MbrDataOff                                       ;01beh

LoopActive:
;
; 00 - inactive, 80h active, others-invalid
;
        cmp     BYTE PTR es:[bp].Part_Active,00H
        jl      CheckInactive
        jne     BadMbr
        add     bp,16
        loop    LoopActive

;
; no active partition found. boot from CD
;
        pop     es
        jmp     CdBoot

CheckInactive:
        push    bp
InactiveLoop:
        add     bp,16
        dec     cx
        jz      ActiveFound
        cmp     BYTE PTR es:[bp].Part_Active,00H
        je      InactiveLoop
        pop     bp

BadMbr:
;
; bad mbr was found. boot from CD
;
        pop     es
        jmp     CdBoot

ActiveFound:
        pop     bp
        pop     es

;
; let's see if we can display UI (that is if MsgPressKey is not empty
;
        mov     si, OFFSET MsgPressKey
        lodsb
        mov     UIAllowed, al

        push    si
        mov     si,OFFSET MsgPressKey
        call    PrintMsg
        pop     si

;
; read all available keys from the queue (prevents us from booting from CD when there
; is some garbage there
;
        mov     cx, 80h
FlushQueue:
        mov     ah, 01h
        int     16h
        jz      QueueEmpty
        mov     ah, 00h
        int     16h
        loop    FlushQueue
QueueEmpty:

;
; hook int08
;
        cli
        push    es
        xor     ax,ax
        mov     es,ax
        mov     bx,08h * 4
        mov     ax,es:[bx]
        mov     WORD PTR [OldInt08  ], ax
        mov     ax,es:[bx+2]
        mov     WORD PTR [OldInt08+2], ax
        mov     WORD PTR es:[bx],OFFSET NewInt08
        mov     WORD PTR es:[bx+2],cs
        pop     es
        sti

;
; loop until the delay ticks is 0. Check for a key pressed (if UI), or for CTRL pressed (if no UI)
;
CheckKey:
        cmp     UIAllowed, 0
        je      CheckCTRL
        mov     ah, 01h
        int     16h
        jnz     KeyPressed
CheckCTRL:
        mov     ah,02h
        int     16h
        and     al,00000100b
        jnz     KeyPressed
NotPressed:
        cmp     DotTicks, 0
        jg      AddDot
        push    si
        mov     si,OFFSET MsgDot
        call    PrintMsg
        pop     si
        mov     DotTicks, 18
AddDot:
        cmp     DelayTicks, 0
        jne     CheckKey
        call    UnhookInt08
        jmp     BootFromHD

UnhookInt08:
        cli
        push    es
        xor     ax,ax
        mov     es,ax
        mov     bx,08h * 4
        mov     ax,WORD PTR [OldInt08]
        mov     es:[bx],ax
        mov     ax,WORD PTR [OldInt08+2]
        mov     es:[bx+2],ax
        pop     es
        sti
        ret

KeyPressed:
        call    UnhookInt08
        jmp     CdBoot

BootFromHD:

;
; let's move the mbr code to 0000:7c00 and jump there
;
        mov     ax,LoadSeg
        mov     ds,ax
        xor     ax,ax
        mov     es,ax
        xor     si,si
        mov     di,VolBootOrg
        mov     cx,SectSize
        cld
        rep     movsb

        mov     dl,80h
        JMPFAR  VolbootOrg,0000H

CdBoot:
;
; return to caller code
;
        pop     es
        pop     ds
        retf

NewInt08:
        pushf
        cli
        cmp     WORD PTR cs:[DelayTicks], 0
        je      default08
        dec     WORD PTR cs:[DotTicks]
        dec     WORD PTR cs:[DelayTicks]
default08:
        popf
        push    WORD PTR cs:[OldInt08+2]
        push    WORD PTR cs:[OldInt08]
        retf

;
;EXPECTS DS:SI - MESSAGE ADDR
;
PrintMsg proc    near
        push    ax
        push    bx
        cmp     UIAllowed, 0
        je      PrintMsgEnd
PrintMsgLoop:
        lodsb
        cmp     al,0
        je      PrintMsgEnd
        mov     ah,0eh
        mov     bx,0007h
        int     10h
        jmp     PrintMsgLoop
PrintMsgEnd:
        pop     bx
        pop     ax
        ret
PrintMsg endp


include bootfix.inc                            ; message text

        UIAllowed   db      0
        MsgDot      db      "."
                    db      0
        OldInt08    dd      ?
        DelayTicks  dw      4*18+1              ; 4 seconds
        DotTicks    dw      18

.errnz  ($-_BootFix) GT (MaxCodeSize - 2)    ;FATAL: bootfix code is too large

        org     MaxCodeSize - 2
        db      55h,0aah


CODE ENDS
END  START
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\etfsboot.asm ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
; etfsboot.asm
;
;Abstract:
;
; The ROM in the IBM PC starts the boot process by performing a hardware
; initialization and a verification of all external devices.  If an El
; Torito CD-ROM with no-emulation support is detected, it will then load
; the "image" pointed to in the Boot Catalog.  This "image" is placed at
; the physical address specified in the Boot Catalog (which should be 07C00h).
;
; The code in this "image" is responsible for locating NTLDR, loading the
; first sector of NTLDR into memory at 2000:0000, and branching to it.
;
; There are only two errors possible during execution of this code.
;       1 - NTLDR does not exist
;       2 - BIOS read error
;
; In both cases, a short message is printed, and the user is prompted to
; reboot the system.
;
;
;Author:
;
;    Steve Collins (stevec) 25-Oct-1995
;
;Environment:
;
;    Image has been loaded at 7C0:0000 by BIOS. (or 0000:7C00 to support some broken BIOSes)
;    Real mode
;    ISO 9660 El Torito no-emulation CD-ROM Boot support
;    DL = El Torito drive number we booted from
;
;Revision History:
;
;    Calin Negreanu (calinn) 25-May-1998 - added safety check at the beginning of the code
;                                        - added code for loading and executing BOOTFIX.BIN
;                                        - modified error path
;--
        page    ,132
        title   boot - NTLDR ETFS loader
        name    etfsboot

EtfsCodeSize    EQU     2048

BootSeg segment at 07c0h
BootSeg ends

DirSeg  segment at 1000h
DirSeg  ends

LoadSeg segment at 2000h
LoadSeg ends

BootCode        segment                         ;would like to use BootSeg here, but LINK flips its lid
    ASSUME  CS:BootCode,DS:NOTHING,ES:NOTHING,SS:NOTHING

        public  ETFSBOOT
ETFSBOOT proc    far

        cli

        ;WARNING!!! DO NOT CHANGE THE STACK SETUP. BOOTFIX NEEDS THIS TO BE HERE.

        xor     ax,ax                           ; Setup the stack to a known good spot
        mov     ss,ax                           ; Stack is set to 0000:7c00, which is just below this code
        mov     sp,7c00h

        sti

        mov     ax,cs                           ; Set DS to our code segment (should be 07C0h)
        mov     ds,ax
assume DS:BootCode

;
; Save the Drive Number for later use
;
        push    dx
;
; Let's do some safety checks here. We are going to check for three things:
; 1. We are loaded at 07c0:0000 or 0000:7C00
; 2. Boot Drive Number looks good (80h-FFh)
; 3. Our code was completely loaded by the BIOS
;

        call    NextInstr
NextInstr:

        pop     si                              ; Get IP from the stack
        sub     si,OFFSET NextInstr             ; See if we run with ORIGIN 0
        jz      NormalCase                      ; Yes
        cmp     si,7C00h                        ; See if, at least we run with ORIGIN 7C00H
        jne     BootErr$wof1                    ; If not, try to display some message
        mov     ax,cs                           ; If offset is 7C00H, segment should be 0
        cmp     ax,0000h
        jne     BootErr$wof2                    ; If not, try to display some message

        ; We are loaded at 0000:7C00 instead of 07C0:0000. This could mess up
        ; some stuff so we are going to fix it.

        ; hack to execute JMP 07c0:BootOK
        db      0eah
        dw      OFFSET  BootOK
        dw      BootSeg

NormalCase:
        mov     MSG_BAD_BIOS_CODE, '3'
        mov     ax,cs                           ; See if segment is 07C0H
        cmp     ax,07c0h
        jne     BootErr$wnb                     ; If not, try to display some message

BootOK:

;
; Reset ds in case we needed to change code segment
;
        mov     ax,cs
        mov     ds,ax
;
; OK so far. Let's try to see if drive letter looks good (80h-FFh)
;
        mov     MSG_BAD_BIOS_CODE, '4'
        cmp     dl,80h
        jb      BootErr$wnb

;
; OK so far. Let's try to see if all our code was loaded.
; We look for our signature at the end of the code.
;
        mov     MSG_BAD_BIOS_CODE, '5'
        mov     bx, EtfsCodeSize - 2
        mov     ax, WORD PTR DS:[bx]
        cmp     ax, 0AA55h
        jne     BootErr$wnb

;
; Finally, everything looks good.
;

;
; Save the Drive Number for later use - right now drive number is pushed on the stack
;
        pop     dx
        mov     DriveNum,dl
;
; Let's try to load and run BOOTFIX.BIN
;
.386
        push    OFFSET BOOTFIXNAME
        push    11
        push    LoadSeg
        call    LoadFile
        jc      FindSetupLdr

;
; We have BOOTFIX.BIN loaded. We call that code to see if we should boot from CD. If we shouldn't
; we'll not come back here.
;
.286
        pusha
        push    ds
        push    es

;
; BOOTFIX requires:
;   DL = INT 13 drive number we booted from
;
        mov     dl, DriveNum                    ; DL = CD drive number

        ;hack to execute CALL LoadSeg:0000
        db      9Ah
        dw      0000h
        dw      LoadSeg

        pop     es
        pop     ds
        popa

.8086

FindSetupldr:

;
; Scan for the presence of SETUPLDR.BIN
;
.386
        push    OFFSET LOADERNAME
        push    12
        push    LoadSeg
        call    LoadFile
        jc      BootErr$bnf

;
; SETUPLDR requires:
;   DL = INT 13 drive number we booted from
;
        mov     dl, DriveNum                    ; DL = CD drive number
        xor     ax,ax
.386
        push    LoadSeg
        push    ax
        retf                                    ; "return" to NTLDR (LoadSeg:0000h). Will not come back here.

ETFSBOOT endp

;
; BootErr - print error message and hang the system.
;
BootErr proc
BootErr$wof1:                                   ; we were loaded at a wrong address - Code 1
        PUSH    SI
        MOV     BX, SI
        ADD     BX, OFFSET MSG_BAD_BIOS_CODE
        MOV     BYTE PTR DS:[BX], '1'
        ADD     SI, OFFSET MSG_BAD_BIOS
        JMP     BootErr2
BootErr$wof2:                                   ; we were loaded at a wrong address - Code 2
        PUSH    SI
        MOV     BX, SI
        ADD     BX, OFFSET MSG_BAD_BIOS_CODE
        MOV     BYTE PTR DS:[BX], '2'
        ADD     SI, OFFSET MSG_BAD_BIOS
        JMP     BootErr2
BootErr$wnb:                                    ; some other BIOS problem
        PUSH    0
        MOV     SI, OFFSET MSG_BAD_BIOS
        JMP     BootErr2
BootErr$bnf:                                    ; NTLDR not found
        PUSH    0
        MOV     SI, OFFSET MSG_NO_NTLDR
        JMP     BootErr2
BootErr$mof:                                    ; memory overflow
        PUSH    0
        MOV     SI, OFFSET MSG_MEM_OVERFLOW
        JMP     BootErr2
BootErr2:
        CALL    BootErrPrint
        POP     SI
        JMP     BootFromHD

BootErrPrint:

        LODSB                                   ; Get next character
        OR      AL, AL
        JZ      BEdone

        MOV     AH, 14                          ; Write teletype
        MOV     BX, 7                           ; Attribute
        INT     10H                             ; Print it
        JMP     BootErrPrint
BEdone:
        RET
BootErr endp

;
; we are trying to boot from HD. We need to move ourself out of
; this area because we are going to load MBR here
;
BootFromHD:

;
; let's wait here for two seconds, so the user gets a chance to see the message
;

;
; hook INT08
;
        MOV     [SI+TicksCount], 24H                 ; two seconds delay
        CLI
        PUSH    ES
        XOR     AX, AX
        MOV     ES, AX
        MOV     BX, 0020H
        MOV     AX, ES:[BX]
        MOV     WORD PTR [SI+OldInt08], AX
        MOV     AX, ES:[BX+2]
        MOV     WORD PTR [SI+OldInt08+2], AX
        MOV     ES:[BX], SI
        ADD     ES:[BX], OFFSET NewInt08
        MOV     ES:[BX+2], CS
        POP     ES
        STI
;
; now let's actively wait for TicksCount to become zero
;
Delay:
        CMP     [SI+TicksCount], 0
        JNE     Delay
;
; unhook INT08
;
        cli
        push    es
        xor     ax,ax
        mov     es,ax
        mov     bx,08h * 4
        mov     ax,WORD PTR [SI+OldInt08]
        mov     es:[bx],ax
        mov     ax,WORD PTR [SI+OldInt08+2]
        mov     es:[bx+2],ax
        pop     es
        sti
;
; now let's move ourselves away from here because we are going to load MBR here
;
MoveCode:
        push    ds
        push    es
        mov     ax, LoadSeg
        mov     es, ax
        mov     ax, cs
        mov     ds, ax
        ;si is already set
        xor     di, di
        mov     cx, EtfsCodeSize
        rep     movsb
        pop     es
        pop     ds

        ;hack to execute JMP LoadSeg:AfterMoveLabel
        db      0eah
        dw      OFFSET  AfterMoveLabel
        dw      LoadSeg

AfterMoveLabel:
;
; finally load MBR
;
        push    es
        mov     ax, BootSeg
        mov     es, ax
        mov     bx, 0000h
        mov     ax, 0201h                                           ;read function, one sector
        mov     cx, 0001h
        mov     dx, 0080h
        int     13h
        jnc     MbrOk
;
; there was an error, nothing else to do
;
        jmp     $
MbrOk:
        pop     es
;
; now let's return into MBR code
;
        mov     dl,80h
        ;hack to execute JMP 0000:7C00
        db      0eah
        dw      7c00h
        dw      0000h

;
; We rely on the fact that SI is not changed when this INT occurs
; This is a pretty good assumption since this code is active only
; within the tight loop near Delay label. The odds are that some
; other IRQ occures, enables interrupts, changes SI and then INT08
; occures. This should not happen.
;
NewInt08:
        PUSHF
        CLI
        CMP     CS:[SI+TicksCount], 0
        JE      Default08
        DEC     WORD PTR CS:[SI+TicksCount]
Default08:
        POPF
        PUSH    WORD PTR CS:[SI+OldInt08+2]
        PUSH    WORD PTR CS:[SI+OldInt08]
        RETF

include etfsboot.inc                            ; message text

;
; ScanForEntry - Scan for an entry in a directory
;
; Entry:
;     ES:0 points to the beginning of the directory to search
;     Directory length in bytes is in ExtentLen1 and Extend_Len_0
;
; Exit:
;     CF set on error, clear on success.
;     ES:BX points to record containing entry if match is found
;
ScanForEntry proc near
        mov     ScanIncCount, 0
        mov     cx,ExtentLen0                   ; CX = length of root directory in bytes (low word only)
        cld                                     ; Work up for string compares
        xor     bx,bx
        xor     dx,dx
ScanLoop:
        mov     si, EntryToFind
        mov     dl,byte ptr es:[bx]             ; directory record length -> DL
        cmp     dl,0
        jz      Skip00                          ; if the "record length" assume it is "system use" and skip it
        mov     ax,bx
        add     ax,021h                         ; file identifier is at offset 21h in directory record
        mov     di,ax                           ; ES:DI now points to file identifier
        push    cx
        xor     cx,cx
        mov     cl,EntryLen                     ; compare bytes
        repe    cmpsb
        pop     cx
        jz      ScanEnd                         ; do we have a match?

CheckCountUnderFlow:
        ; If CX is about to underflow or be 0 we need to reset CX, ES and BX if ExtentLen1 is non-0
        cmp     dx,cx
        jae     ResetCount0

        sub     cx,dx                           ; update CX to contain number of bytes left in directory
        cmp     ScanIncCount, 1
        je      ScanAdd1ToCount

AdjustScanPtr:                                  ; Adjust ES:BX to point to next record
        add     dx,bx
        mov     bx,dx
        and     bx,0fh
        push    cx
        mov     cl,4
        shr     dx,cl
        pop     cx
        mov     ax,es
        add     ax,dx
        mov     es,ax
        jmp     ScanLoop

Skip00:
        mov     dx,1                            ; Skip past this byte
        jmp     CheckCountUnderFlow

ScanAdd1ToCount:
        inc     cx
        mov     ScanIncCount,0
        jmp     AdjustScanPtr

S0:
        mov     ScanIncCount,1                  ; We'll need to increment Count next time we get a chance
        jmp     SetNewCount

ResetCount0:
        cmp     ExtentLen1,0                    ; Do we still have at least 64K bytes left to scan?
        jne     ResetContinue
        stc                                     ; We overran the end of the directory - corrupt/invalid directory
        ret
ResetContinue:
        sub     ExtentLen1,1

        add     bx,dx                           ; Adjust ES:BX to point to next record - we cross seg boundary here
        push    bx
        push    cx
        mov     cl,4
        shr     bx,cl
        pop     cx
        mov     ax,es
        add     ax,bx
        mov     es,ax
        pop     bx
        and     bx,0fh

        sub     dx,cx                           ; Get overflow amount
        je      S0                              ; If we ended right on the boundary we need to make special adjustments
        dec     dx
SetNewCount:
        mov     ax,0ffffh
        sub     ax,dx                           ;   and subtract it from 10000h
        mov     cx,ax                           ;   - this is the new count
        jmp     ScanLoop

ScanEnd:
        cmp     IsDir,1
        je      CheckDir

        test    byte ptr es:[bx][25],2          ; Is this a file?
        jnz     CheckCountUnderFlow             ;    No - go to next record
        jmp     CheckLen

CheckDir:
        test    byte ptr es:[bx][25],2          ; Is this a directory?
        jz      CheckCountUnderFlow             ;    No - go to next record

CheckLen:
        mov     al,EntryLen
        cmp     byte ptr es:[bx][32],al         ; Is the identifier length correct?
        jnz     CheckCountUnderFlow             ;    No - go to next record

        clc
        ret
ScanForEntry endp

;
; ExtRead - Do an INT 13h extended read
; NOTE: I force the offset of the Transfer buffer address to be 0
;       I force the high 2 words of the Starting absolute block number to be 0
;       - This allows for a max 4 GB medium - a safe assumption for now
;
; Entry:
;   Arg1 - word 0 (low word) of Number of 2048-byte blocks to transfer
;   Arg2 - word 1 (high word) of Number of 2048-byte blocks to transfer
;   Arg3 - segment of Transfer buffer address
;   Arg4 - word 0 (low word) of Starting absolute block number
;   Arg5 - word 1 of Starting absolute block number
;
; Exit
;   The following are modified:
;      Count0
;      Count1
;      Dest
;      Source0
;      Source1
;      PartialRead
;      NumBlocks
;      Disk Address Packet [DiskAddPack]
;
ExtRead proc near
        push    bp                              ; set up stack frame so we can get args
        mov     bp,sp

        push    bx                              ; Save registers used during this routine
        push    si
        push    dx
        push    ax

        mov     bx,offset DiskAddPack           ; Use BX as base to index into Disk Address Packet

        ; Set up constant fields
        mov     [bx][0],byte ptr 010h           ; Offset 0: Packet size = 16 bytes
        mov     [bx][1],byte ptr 0h             ; Offset 1: Reserved (must be 0)
        mov     [bx][3],byte ptr 0h             ; Offset 3: Reserved (must be 0)
        mov     [bx][4],word ptr 0h             ; Offset 4: Offset of Transfer buffer address (force 0)
        mov     [bx][12],word ptr 0h            ; Offset 12: Word 2 of Starting absolute block number (force 0)
        mov     [bx][14],word ptr 0h            ; Offset 14: Word 3 (high word) of Starting absolute block number (force 0)

;
; Initialize loop variables
;
        mov     ax,[bp][12]                     ; set COUNT to number of blocks to transfer
        mov     Count0,ax
        mov     ax,[bp][10]
        mov     Count1,ax

        mov     ax,[bp][8]                      ; set DEST to destination segment
        mov     Dest,ax

        mov     ax,[bp][6]                      ; set SOURCE to source lbn
        mov     Source0,ax
        mov     ax,[bp][4]
        mov     Source1,ax

ExtReadLoop:
;
; First check if COUNT <= 32
;
        cmp     Count1,word ptr 0h              ; Is upper word 0?
        jne     SetupPartialRead                ;   No - we're trying to read at least 64K blocks (128 MB)
        cmp     Count0,word ptr 20h             ; Is lower word greater than 32?
        jg      SetupPartialRead                ;   Yes - only read in 32-block increments

        mov     PartialRead,0                   ; Clear flag to indicate we are doing a full read

        mov     ax,Count0                       ; NUMBLOCKS = COUNT
        mov     NumBlocks,al                    ; Since Count0 < 32 we're OK just using low byte

        jmp     DoExtRead                       ; Do read

SetupPartialRead:
;
; Since COUNT > 32,
; Set flag indicating we are only doing a partial read
;
        mov     PartialRead,1

        mov     NumBlocks,20h                   ; NUMBYTES = 32

DoExtRead:
;
; Perform Extended Read
;
        mov     al,NumBlocks                    ; Offset 2: Number of 2048-byte blocks to transfer
        mov     [bx][2],al
        mov     ax,Dest                         ; Offset 6: Segment of Transfer buffer address
        mov     [bx][6],ax
        mov     ax,Source0                      ; Offset 8: Word 0 (low word) of Starting absolute block number
        mov     [bx][8],ax
        mov     ax,Source1                      ; Offset 10: Word 1 of Starting absolute block number
        mov     [bx][10],ax

        mov     si,offset DiskAddPack           ; Disk Address Packet in DS:SI
        mov     ah,042h                         ; Function = Extended Read
        mov     dl,DriveNum                     ; CD-ROM drive number
        int     13h

;
; Determine if we are done reading
;
        cmp     PartialRead,1                   ; Did we just do a partial read?
        jne     ExtReadDone                     ;   No - we're done

ReadjustValues:
;
; We're not done reading yet, so
; COUNT = COUNT - 32
;
        sub     Count0,020h                     ; Subtract low-order words
        sbb     Count1,0h                       ; Subtract high-order words

;
; Just read 32 blocks and have more to read
; Increment DEST to next 64K segment (this equates to adding 1000h to the segment)
;
        add     Dest,1000h
        jc      BootErr$mof                     ; Error if we overflowed

;
; SOURCE = SOURCE + 32 blocks
;
        add     Source0,word ptr 020h           ; Add low order words
        adc     Source1,word ptr 0h             ; Add high order words
        ; NOTE - I don't account for overflow - probably OK now since we already account for 4 GB medium

;
; jump back to top of loop to do another read
;
        jmp     ExtReadLoop

ExtReadDone:

        pop     ax                              ; Restore registers used during this routine
        pop     dx
        pop     si
        pop     bx

        mov     sp,bp                           ; restore BP and SP
        pop     bp

        ret
ExtRead endp

;
; ReadExtent - Read in an extent
;
;   Arg1 - segment to transfer extent to
;
; Entry:
;   ExtentLen0 = word 0 (low word) of extent length in bytes
;   ExtentLen1 = word 1 (high word) of extent length in bytes
;   ExtentLoc0 = word 0 (low word) of starting absolute block number of extent
;   ExtentLoc1 = word 1 of starting absolute block number of extent
;
; Exit:
;   ExtRead exit mods
;
ReadExtent proc near
        push    bp                              ; set up stack frame so we can get args
        mov     bp,sp

        push    cx                              ; Save registers used during this routine
        push    bx
        push    ax

        mov     cl,11                           ; Convert length in bytes to 2048-byte blocks
        mov     bx,ExtentLen1                   ; Directory length = BX:AX
        mov     ax,ExtentLen0

.386
        shrd    ax,bx,cl                        ; Shift AX, filling with BX
.8086
        shr     bx,cl                           ; BX:AX = number of blocks (rounded down)
        test    ExtentLen0,07ffh                ; If any of the low-order 11 bits are set we need to round up
        jz      ReadExtentNoRoundUp
        add     ax,1                            ; We need to round up by incrementing AX, and
        adc     bx,0                            ;   adding the carry to BX
ReadExtentNoRoundUp:

        push    ax                              ; Word 0 (low word) of Transfer size = AX
        push    bx                              ; Word 1 (high word) of Transfer size = BX
.286
        push    [bp][4]                         ; Segment used to transfer extent
.8086
        push    ExtentLoc0                      ; Word 0 (low word) of Starting absolute block number
        push    ExtentLoc1                      ; Word 1 of Starting absolute block number
        call    ExtRead
        add     sp,10                           ; Clean 5 arguments off the stack

        pop     ax                              ; Restore registers used during this routine
        pop     bx
        pop     cx

        mov     sp,bp                           ; restore BP and SP
        pop     bp

        ret
ReadExtent endp

;
; GetExtentInfo - Get extent location
;
; Entry:
;   ES:BX points to record
; Exit:
;   Location -> ExtentLoc1 and ExtentLoc0
;   Length -> ExtentLen1 and ExtentLen0
;
GetExtentInfo proc near
        push    ax                              ; Save registers used during this routine

        mov     ax,es:[bx][2]                   ; 32-bit LBN of extent
        mov     ExtentLoc0,ax                   ;   store low word
        mov     ax,es:[bx][4]
        mov     ExtentLoc1,ax                   ;   store high word
        mov     ax,es:[bx][10]                  ; 32-bit file length in bytes
        mov     ExtentLen0,ax                   ;   store low word
        mov     ax,es:[bx][12]
        mov     ExtentLen1,ax                   ;   store high word

        pop     ax                              ; Restore registers used during this routine

        ret
GetExtentInfo endp

LoadFile proc near
        push    bp
        mov     bp, sp
;
; First thing, we need to read in the Primary Volume Descriptor so we can locate the root directory
;
.286
        push    01h                             ; Word 0 (low word) of Transfer size = 1 block (2048 bytes)
        push    0h                              ; Word 1 (high word) of Transfer size = 0
        push    DirSeg                          ; Segment of Transfer buffer = DirSeg
        push    010h                            ; Word 0 (low word) of Starting absolute block number = 10h
        push    0h                              ; Word 1 of Starting absolute block number = 0
.8086
        call    ExtRead
        add     sp,10                           ; Clean 5 arguments off the stack

;
; Determine the root directory location LBN -> ExtentLoc1:ExtentLoc0
; determine the root directory data length in bytes -> ExtentLen1:ExtentLen0
;
        mov     ax,DirSeg                       ; ES is set to segment used for storing PVD and directories
        mov     es,ax
ASSUME  ES:DirSeg
        mov     ax,es:[09eh]                    ; 32-bit LBN of extent at offset 158 in Primary Volume Descriptor
        mov     ExtentLoc0,ax                   ;   store low word
        mov     ax,es:[0a0h]
        mov     ExtentLoc1,ax                   ;   store high word
        mov     ax,es:[0a6h]                    ; 32-bit Root directory data length in bytes at offset 166 in Primary Volume Descriptor
        mov     ExtentLen0,ax                   ;   store low word
        mov     ax,es:[0a8h]
        mov     ExtentLen1,ax                   ;   store high word

;
; Now read in the root directory
;
.286
        push    DirSeg                          ; Segment used for transfer = DirSeg
.8086
        call    ReadExtent
        add     sp,2                            ; Clean 1 argument off the stack

;
; Scan for the presence of the I386 directory
; ES points to directory segment
;
        mov     EntryToFind, offset I386DIRNAME
        mov     EntryLen,4
        mov     IsDir,1
        call    ScanForEntry
        jc      EntryNotFound
;
; We found the I386 directory entry, so now get its extent location (offset -31 from filename ID)
; ES:[BX] still points to the directory record for the I386 directory
;
        call    GetExtentInfo

;
; Now read in the I386 directory
;
.286
        push    DirSeg                          ; Segment used for transfer = DirSeg
.8086
        call    ReadExtent
        add     sp,2                            ; Clean 1 argument off the stack

;
; Scan for the presence of the file that we need
; ES points to directory segment
;

        mov     ax, DirSeg
        mov     es, ax
        mov     ax, [bp][8]
        mov     EntryToFind, ax
        mov     al, [bp][6]
        mov     EntryLen, al
        mov     IsDir,0
        call    ScanForEntry
        jc      EntryNotFound
;
; We found the needed file, so now get its extent location (offset -31 from filename ID)
; ES:[BX] still points to the directory record for that code
;
        call    GetExtentInfo

;
; Now, go read the file
;
.286
        push    [bp][4]                         ; Segment used for transfer
.8086
        call    ReadExtent
        add     sp,2                            ; Clean 1 argument off the stack

EntryNotFound:
        pop     bp
        ret

LoadFile endp


OldInt08       DD  ?                            ; Default Int08 vector
TicksCount     dw  24H                          ; two seconds
DiskAddPack    db  16 dup (?)                   ; Disk Address Packet
PartialRead    db  0                            ; Boolean indicating whether or not we are doing a partial read
LOADERNAME     db  "SETUPLDR.BIN"
BOOTFIXNAME    db  "BOOTFIX.BIN"
I386DIRNAME    db  "I386"
DriveNum       db  ?                            ; Drive number used for INT 13h extended reads
ExtentLoc0     dw  ?                            ; Loader LBN - low word
ExtentLoc1     dw  ?                            ; Loader LBN - high word
ExtentLen0     dw  ?                            ; Loader Length - low word
ExtentLen1     dw  ?                            ; Loader Length - high word
Count0         dw  ?                            ; Read Count - low word
Count1         dw  ?                            ; Read Count - high word
Dest           dw  ?                            ; Read Destination segment
Source0        dw  ?                            ; Read Source - word 0 (low word)
Source1        dw  ?                            ; Read Source - word 1
NumBlocks      db  ?                            ; Number of blocks to Read
EntryToFind    dw  ?                            ; Offset of string trying to match in ScanForEntry
EntryLen       db  ?                            ; Length in bytes of entry to match in ScanForEntry
IsDir          db  ?                            ; Boolean indicating whether or not entry to match in ScanForEntry is a directory
ScanIncCount   db  ?                            ; Boolean indicating if we need to add 1 to Count after adjustment in ScanForEntry

    .errnz  ($-ETFSBOOT) GT (EtfsCodeSize - 2)  ; FATAL PROBLEM: boot sector is too large

        org     (EtfsCodeSize - 2)
        db      55h,0aah

BootSectorEnd   label   dword

BootCode        ends


        END     ETFSBOOT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\fi\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Kynnist CD-levylt painamalla jotain nppint."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\ger\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Drcken Sie eine beliebige Taste, um von der CD zu starten."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\hu\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "CD-ROM-rl val indtshoz nyomjon meg egy gombot."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\fr\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Appuyez sur n'importe quelle touche pour dmarrer du CD-ROM."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\it\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Premere un tasto per avviare da CD-ROM."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\pl\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Dowolny klawisz spowoduje rozruch z dysku CD."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\no\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Trykk en tast for  starte opp fra CD-ROM."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\nl\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Druk op een toets als u de computer vanaf cd-rom wilt opstarten."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\tr\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "CD'den onyukleme icin bir tusa basin."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\pt\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Prima qualquer tecla para arrancar a partir do CD."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\sv\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Tryck ned valfri tangent om du vill starta med CD-skivan."
                        db      0
; t-jholm: prolly this is displayed in OEM. I avoided swedish chars.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\usa\bootfix.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    bootfix.inc
;
;Abstract:
;
;    This contains the message text that the ETFS boot sector prints out
;
;Author:
;
;    Calin Negreanu (calinn) 24-Feb-1999
;
;Revision History:
;
;--

MsgPressKey             db      0dh, 0ah, "Press any key to boot from CD."
                        db      0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs.br\makefile.inc ===
!include ..\etfs\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs\i386\usa\etfsboot.inc ===
;++
;
;Copyright (c) 1995  Compaq Computer Corporation
;
;Module Name:
;
;    etfsboot.inc
;
;Abstract:
;
;    This contains the message text that the boot sector prints out on
;    error conditions
;
;Author:
;
;    Steve Collins (stevec) 25-Oct-1995
;
;Revision History:
;
;    Calin Negreanu (calinn) 25-May-1998 - added MSG_BAD_BIOS
;    Calin Negreanu (calinn) 20-Apr-1999 - added MSG_BAD_BIOS_CODE
;           1 - Wrong load address (offset is not 0 or 7c00h)
;           2 - Wrong load address (offset is 7c00h but segment is not 0)
;           3 - Wrong load address (offset is 0 but segment is not 07c0h)
;           4 - Wrong drive letter (should be 80h-FFh)
;           5 - Boot sector was not completely loaded
;
;--

MSG_BAD_BIOS            db      "CDBOOT: Cannot boot from CD - Code: "
MSG_BAD_BIOS_CODE       db      "0"
                        db      0dh, 0ah, 0
MSG_NO_NTLDR            db      "CDBOOT: Couldn't find NTLDR"
                        db      0dh, 0ah, 0
MSG_MEM_OVERFLOW        db      "CDBOOT: Memory overflow error"
                        db      0dh, 0ah, 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs.ger\makefile.inc ===
!include ..\etfs\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs.cs\makefile.inc ===
!include ..\etfs\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs.hu\makefile.inc ===
!include ..\etfs\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs.it\makefile.inc ===
!include ..\etfs\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs.nl\makefile.inc ===
!include ..\etfs\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs.el\makefile.inc ===
!include ..\etfs\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs.no\makefile.inc ===
!include ..\etfs\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs.fi\makefile.inc ===
!include ..\etfs\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs.es\makefile.inc ===
!include ..\etfs\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs.pl\makefile.inc ===
!include ..\etfs\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs.fr\makefile.inc ===
!include ..\etfs\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs.ru\makefile.inc ===
!include ..\etfs\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs.pt\makefile.inc ===
!include ..\etfs\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs.da\makefile.inc ===
!include ..\etfs\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs.sv\makefile.inc ===
!include ..\etfs\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\etfs.tr\makefile.inc ===
!include ..\etfs\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\fat\i386\dirent.inc ===
DIR_ENTRY	STRUC
dir_name	DB	11 DUP (?)
dir_attr	DB	?
dir_pad	DB	6 DUP (?)
dir_lastaccessdate	DW	?
dir_firstHigh	DW	?
dir_time	DW	?
dir_date	DW	?
dir_first	DW	?
dir_size_l	DW	?
dir_size_h	DW	?
DIR_ENTRY	ENDS
ATTR_READ_ONLY	EQU	01H
ATTR_HIDDEN	EQU	02H
ATTR_SYSTEM	EQU	04H
ATTR_VOLUME_ID	EQU	08H
ATTR_DIRECTORY	EQU	10H
ATTR_ARCHIVE	EQU	20H
ATTR_LONG_NAME	EQU	(ATTR_READ_ONLY OR ATTR_HIDDEN OR ATTR_SYSTEM OR ATTR_VOLUME_ID)
ATTR_DEVICE	EQU	40H
ATTR_ALL	EQU	(ATTR_HIDDEN OR ATTR_SYSTEM OR ATTR_DIRECTORY)
ATTR_IGNORE	EQU	(ATTR_READ_ONLY OR ATTR_ARCHIVE OR ATTR_DEVICE)
ATTR_CHANGEABLE	EQU	(ATTR_READ_ONLY OR ATTR_HIDDEN OR ATTR_SYSTEM OR ATTR_ARCHIVE)
DIRFREE	EQU	0E5H
MAXDIRENTRIES	EQU	65536
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\fat\i386\boot98f.h ===
#define PC98FATBOOTCODE_SIZE 512


unsigned char PC98FatBootCode[] = {
235,60,144,77,83,87,73,78,52,46,49,0,2,8,4,0,
2,0,12,0,0,248,112,0,35,0,7,0,245,0,0,0,
196,105,3,0,128,0,41,0,0,0,0,78,79,32,78,65,
77,69,32,32,32,32,70,65,84,49,50,32,32,32,51,192,
142,208,188,0,124,14,31,184,64,0,142,192,38,160,132,1,
162,36,0,86,139,54,11,0,168,16,117,32,180,132,51,219,
205,27,114,4,133,219,117,3,187,0,1,139,198,51,210,247,
243,163,64,0,184,0,128,247,246,162,66,0,184,32,0,247,
38,17,0,78,3,198,131,210,0,70,247,246,139,200,160,16,
0,50,228,247,38,22,0,3,6,14,0,131,210,0,163,75,
0,137,22,77,0,3,193,163,62,0,81,86,187,0,16,142,
195,51,219,51,210,184,0,64,247,246,80,14,232,149,0,88,
114,115,51,219,185,0,2,139,251,81,185,11,0,190,227,1,
243,166,89,116,5,131,195,32,226,237,133,201,94,89,117,16,
1,6,75,0,131,22,77,0,0,43,200,119,189,235,70,144,
38,139,87,26,184,1,0,129,62,11,0,0,1,117,1,64,
187,0,32,142,195,51,219,82,14,232,47,0,91,114,38,141,
54,11,0,141,62,67,0,140,216,163,69,0,199,6,67,0,
59,1,163,73,0,199,6,71,0,84,1,138,22,36,0,93,
234,3,0,0,32,176,6,230,55,235,254,80,74,74,160,13,
0,50,228,247,226,3,6,62,0,131,210,0,163,75,0,137,
22,77,0,88,50,228,61,0,0,117,2,254,196,86,87,85,
139,240,139,235,139,14,75,0,139,22,77,0,82,81,160,36,
0,168,16,116,39,80,139,193,139,30,24,0,247,243,246,54,
26,0,138,244,138,200,160,12,0,50,237,60,0,116,6,254,
197,208,232,235,246,88,42,218,254,194,235,28,36,127,139,30,
64,0,209,235,114,6,209,225,209,210,235,246,3,14,28,0,
19,22,30,0,138,30,66,0,50,255,59,243,115,2,139,222,
83,82,147,247,38,11,0,147,90,83,180,86,205,27,95,91,
89,90,114,11,3,203,131,210,0,3,239,43,243,117,141,93,
95,94,203,78,84,76,68,82,32,32,32,32,32,32,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,170
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\fat\i386\bpb.inc ===
BPB	STRUC
BPB_BytesPerSector	DW	?
BPB_SectorsPerCluster	DB	?
BPB_ReservedSectors	DW	?
BPB_NumberOfFATs	DB	?
BPB_RootEntries	DW	?
BPB_TotalSectors	DW	?
BPB_MediaDescriptor	DB	?
BPB_SectorsPerFAT	DW	?
BPB_SectorsPerTrack	DW	?
BPB_Heads	DW	?
BPB_HiddenSectors	DW	?
BPB_HiddenSectorsHigh	DW	?
BPB_BigTotalSectors	DW	?
BPB_BigTotalSectorsHigh	DW	?
BPB	ENDS

BIGFATBPB	STRUC
oldBPB	DB	SIZE BPB DUP (?)
BGBPB_BigSectorsPerFat	DW	?
BGBPB_BigSectorsPerFatHi	DW	?
BGBPB_ExtFlags	DW	?
BGBPB_FS_Version	DW	?
BGBPB_RootDirStrtClus	DW	?
BGBPB_RootDirStrtClusHi	DW	?
BGBPB_FSInfoSec	DW	?
BGBPB_BkUpBootSec	DW	?
BGBPB_Reserved	DW	6 DUP (?)
BIGFATBPB	ENDS
BGBPB_F_ActiveFATMsk	EQU	000FH
BGBPB_F_NoFATMirror	EQU	0080H
BGBPB_F_CompressedVol	EQU	0100H
FAT32_Curr_FS_Version	EQU	0000H
FAT32_Curr_Version	EQU	FAT32_Curr_FS_Version

A_BPB	STRUC
A_BPB_BytesPerSector	DW	?
A_BPB_SectorsPerCluster	DB	?
A_BPB_ReservedSectors	DW	?
A_BPB_NumberOfFATs	DB	?
A_BPB_RootEntries	DW	?
A_BPB_TotalSectors	DW	?
A_BPB_MediaDescriptor	DB	?
A_BPB_SectorsPerFAT	DW	?
A_BPB_SectorsPerTrack	DW	?
A_BPB_Heads	DW	?
A_BPB_HiddenSectors	DW	?
A_BPB_HiddenSectorsHigh	DW	?
A_BPB_BigTotalSectors	DW	?
A_BPB_BigTotalSectorsHigh	DW	?
A_BPB_Reserved	DB	6 DUP (?)
A_BPB	ENDS

A_BF_BPB	STRUC
A_BF_BPB_BytesPerSector	DW	?
A_BF_BPB_SectorsPerCluster	DB	?
A_BF_BPB_ReservedSectors	DW	?
A_BF_BPB_NumberOfFATs	DB	?
A_BF_BPB_RootEntries	DW	?
A_BF_BPB_TotalSectors	DW	?
A_BF_BPB_MediaDescriptor	DB	?
A_BF_BPB_SectorsPerFAT	DW	?
A_BF_BPB_SectorsPerTrack	DW	?
A_BF_BPB_Heads	DW	?
A_BF_BPB_HiddenSectors	DW	?
A_BF_BPB_HiddenSectorsHigh	DW	?
A_BF_BPB_BigTotalSectors	DW	?
A_BF_BPB_BigTotalSectorsHigh	DW	?
A_BF_BPB_BigSectorsPerFat	DW	?
A_BF_BPB_BigSectorsPerFatHi	DW	?
A_BF_BPB_ExtFlags	DW	?
A_BF_BPB_FS_Version	DW	?
A_BF_BPB_RootDirStrtClus	DW	?
A_BF_BPB_RootDirStrtClusHi	DW	?
A_BF_BPB_FSInfoSec	DW	?
A_BF_BPB_BkUpBootSec	DW	?
A_BF_BPB_Reserved	DW	6 DUP (?)
A_BF_BPB	ENDS

EXT_BPB_INFO	STRUC
EBPB_BYTESPERSECTOR	DW	?
EBPB_SECTORSPERCLUSTER	DB	?
EBPB_RESERVEDSECTORS	DW	?
EBPB_NUMBEROFFATS	DB	?
EBPB_ROOTENTRIES	DW	?
EBPB_TOTALSECTORS	DW	?
EBPB_MEDIADESCRIPTOR	DB	?
EBPB_SECTORSPERFAT	DW	?
EBPB_SECTORSPERTRACK	DW	?
EBPB_HEADS	DW	?
EBPB_HIDDENSECTOR	DD	?
EBPB_BIGTOTALSECTORS	DD	?
EXT_BPB_INFO	ENDS

EXT_BIGBPB_INFO	STRUC
EBGBPB_BYTESPERSECTOR	DW	?
EBGBPB_SECTORSPERCLUSTER	DB	?
EBGBPB_RESERVEDSECTORS	DW	?
EBGBPB_NUMBEROFFATS	DB	?
EBGBPB_ROOTENTRIES	DW	?
EBGBPB_TOTALSECTORS	DW	?
EBGBPB_MEDIADESCRIPTOR	DB	?
EBGBPB_SECTORSPERFAT	DW	?
EBGBPB_SECTORSPERTRACK	DW	?
EBGBPB_HEADS	DW	?
EBGBPB_HIDDENSECTOR	DD	?
EBGBPB_BIGTOTALSECTORS	DD	?
EBGBPB_BIGSECTORSPERFAT	DD	?
EBGBPB_EXTFLAGS	DW	?
EBGBPB_FS_VERSION	DW	?
EBGBPB_ROOTDIRSTRTCLUS	DD	?
EBGBPB_FSINFOSEC	DW	?
EBGBPB_BKUPBOOTSEC	DW	?
EBGBPB_RESERVED	DD	3 DUP (?)
EXT_BIGBPB_INFO	ENDS
.errnz  EXT_BPB_INFO.EBPB_BYTESPERSECTOR            NE  BPB.BPB_BytesPerSector
.errnz  EXT_BPB_INFO.EBPB_SECTORSPERCLUSTER         NE  BPB.BPB_SectorsPerCluster
.errnz  EXT_BPB_INFO.EBPB_RESERVEDSECTORS           NE  BPB.BPB_ReservedSectors
.errnz  EXT_BPB_INFO.EBPB_NUMBEROFFATS              NE  BPB.BPB_NumberOfFATs
.errnz  EXT_BPB_INFO.EBPB_ROOTENTRIES               NE  BPB.BPB_RootEntries
.errnz  EXT_BPB_INFO.EBPB_TOTALSECTORS              NE  BPB.BPB_TotalSectors
.errnz  EXT_BPB_INFO.EBPB_MEDIADESCRIPTOR           NE  BPB.BPB_MediaDescriptor
.errnz  EXT_BPB_INFO.EBPB_SECTORSPERFAT             NE  BPB.BPB_SectorsPerFAT
.errnz  EXT_BPB_INFO.EBPB_SECTORSPERTRACK           NE  BPB.BPB_SectorsPerTrack
.errnz  EXT_BPB_INFO.EBPB_HEADS                     NE  BPB.BPB_Heads
.errnz  EXT_BPB_INFO.EBPB_HIDDENSECTOR              NE  BPB.BPB_HiddenSectors
.errnz  EXT_BPB_INFO.EBPB_BIGTOTALSECTORS           NE  BPB.BPB_BigTotalSectors
.errnz  (SIZE EXT_BPB_INFO) NE  (SIZE BPB)

.errnz  EXT_BIGBPB_INFO.EBGBPB_BYTESPERSECTOR       NE  EXT_BPB_INFO.EBPB_BYTESPERSECTOR
.errnz  EXT_BIGBPB_INFO.EBGBPB_SECTORSPERCLUSTER    NE  EXT_BPB_INFO.EBPB_SECTORSPERCLUSTER
.errnz  EXT_BIGBPB_INFO.EBGBPB_RESERVEDSECTORS      NE  EXT_BPB_INFO.EBPB_RESERVEDSECTORS
.errnz  EXT_BIGBPB_INFO.EBGBPB_NUMBEROFFATS         NE  EXT_BPB_INFO.EBPB_NUMBEROFFATS
.errnz  EXT_BIGBPB_INFO.EBGBPB_ROOTENTRIES          NE  EXT_BPB_INFO.EBPB_ROOTENTRIES
.errnz  EXT_BIGBPB_INFO.EBGBPB_TOTALSECTORS         NE  EXT_BPB_INFO.EBPB_TOTALSECTORS
.errnz  EXT_BIGBPB_INFO.EBGBPB_MEDIADESCRIPTOR      NE  EXT_BPB_INFO.EBPB_MEDIADESCRIPTOR
.errnz  EXT_BIGBPB_INFO.EBGBPB_SECTORSPERFAT        NE  EXT_BPB_INFO.EBPB_SECTORSPERFAT
.errnz  EXT_BIGBPB_INFO.EBGBPB_SECTORSPERTRACK      NE  EXT_BPB_INFO.EBPB_SECTORSPERTRACK
.errnz  EXT_BIGBPB_INFO.EBGBPB_HEADS                NE  EXT_BPB_INFO.EBPB_HEADS
.errnz  EXT_BIGBPB_INFO.EBGBPB_HIDDENSECTOR         NE  EXT_BPB_INFO.EBPB_HIDDENSECTOR
.errnz  EXT_BIGBPB_INFO.EBGBPB_BIGTOTALSECTORS      NE  EXT_BPB_INFO.EBPB_BIGTOTALSECTORS



EXT_IBMBOOT_HEADER	STRUC
EXT_BOOT_JUMP	DB	3 DUP (?)
EXT_BOOT_OEM	DB	8 DUP (?)
EXT_BOOT_BPB	DB	SIZE EXT_BPB_INFO DUP (?)
EXT_PHYDRV	DB	?
EXT_CURHD	DB	?
EXT_BOOT_SIG	DB	?
EXT_BOOT_SERIAL	DD	?
EXT_BOOT_VOL_LABEL	DB	11 DUP (?)
EXT_SYSTEM_ID	DB	8 DUP (?)
EXT_IBMBOOT_HEADER	ENDS

EXT_BIGIBMBOOT_HEADER	STRUC
EXT_BGBOOT_JUMP	DB	3 DUP (?)
EXT_BGBOOT_OEM	DB	8 DUP (?)
EXT_BGBOOT_BPB	DB	SIZE EXT_BIGBPB_INFO DUP (?)
EXT_BGPHYDRV	DB	?
EXT_BGCURHD	DB	?
EXT_BGBOOT_SIG	DB	?
EXT_BGBOOT_SERIAL	DD	?
EXT_BGBOOT_VOL_LABEL	DB	11 DUP (?)
EXT_BGSYSTEM_ID	DB	8 DUP (?)
EXT_BIGIBMBOOT_HEADER	ENDS
.errnz  EXT_BIGIBMBOOT_HEADER.EXT_BGBOOT_JUMP   NE  EXT_IBMBOOT_HEADER.EXT_BOOT_JUMP
.errnz  EXT_BIGIBMBOOT_HEADER.EXT_BGBOOT_OEM    NE  EXT_IBMBOOT_HEADER.EXT_BOOT_OEM
.errnz  EXT_BIGIBMBOOT_HEADER.EXT_BGBOOT_BPB    NE  EXT_IBMBOOT_HEADER.EXT_BOOT_BPB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\fat\i386\bootfat.h ===
#define FATBOOTCODE_SIZE 512


unsigned char FatBootCode[] = {
235,60,144,77,83,87,73,78,52,46,49,0,2,8,1,0,
2,0,2,3,81,248,8,0,17,0,4,0,1,0,0,0,
0,0,0,0,128,0,41,0,0,0,0,78,79,32,78,65,
77,69,32,32,32,32,70,65,84,49,50,32,32,32,51,201,
142,209,188,240,123,142,217,184,0,32,142,192,252,189,0,124,
56,78,36,125,36,139,193,153,232,60,1,114,28,131,235,58,
102,161,28,124,38,102,59,7,38,138,87,252,117,6,128,202,
2,136,86,2,128,195,16,115,235,51,201,138,70,16,152,247,
102,22,3,70,28,19,86,30,3,70,14,19,209,139,118,17,
96,137,70,252,137,86,254,184,32,0,247,230,139,94,11,3,
195,72,247,243,1,70,252,17,78,254,97,191,0,0,232,230,
0,114,57,38,56,45,116,23,96,177,11,190,161,125,243,166,
97,116,50,78,116,9,131,199,32,59,251,114,230,235,220,160,
251,125,180,125,139,240,172,152,64,116,12,72,116,19,180,14,
187,7,0,205,16,235,239,160,253,125,235,230,160,252,125,235,
225,205,22,205,25,38,139,85,26,82,176,1,187,0,0,232,
59,0,114,232,91,138,86,36,190,11,124,139,252,199,70,240,
61,125,199,70,244,41,125,140,217,137,78,242,137,78,246,198,
6,150,125,203,234,3,0,0,32,15,182,200,102,139,70,248,
102,3,70,28,102,139,208,102,193,234,16,235,94,15,182,200,
74,74,138,70,13,50,228,247,226,3,70,252,19,86,254,235,
74,82,80,6,83,106,1,106,16,145,139,70,24,150,146,51,
210,247,246,145,247,246,66,135,202,247,118,26,138,242,138,232,
192,204,2,10,204,184,1,2,128,126,2,14,117,4,180,66,
139,244,138,86,36,205,19,97,97,114,11,64,117,1,66,3,
94,11,73,117,6,248,195,65,187,0,0,96,102,106,0,235,
176,78,84,76,68,82,32,32,32,32,32,32,13,10,78,84,
76,68,82,32,105,115,32,109,105,115,115,105,110,103,255,13,
10,68,105,115,107,32,101,114,114,111,114,255,13,10,80,114,
101,115,115,32,97,110,121,32,107,101,121,32,116,111,32,114,
101,115,116,97,114,116,13,10,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,172,191,204,85,170
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\fat\i386\boot98f2.h ===
#define PC98FAT32BOOTCODE_SIZE 1536


unsigned char PC98Fat32BootCode[] = {
235,88,144,77,83,87,73,78,52,46,49,0,2,2,8,0,
1,0,4,0,0,248,0,0,17,0,4,0,1,0,0,0,
0,0,32,0,224,31,0,0,0,0,0,0,0,0,0,0,
1,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,
128,0,41,0,0,0,0,78,79,32,78,65,77,69,32,32,
32,32,70,65,84,51,50,32,32,32,86,87,140,200,142,216,
190,0,0,252,185,0,1,51,192,142,192,191,0,124,243,165,
95,94,184,0,0,80,184,0,124,5,127,0,144,80,203,51,
201,142,209,188,244,123,142,193,142,217,189,0,124,86,160,132,
5,136,70,64,131,126,22,0,117,73,131,126,42,0,119,67,
102,139,70,28,102,131,192,12,187,0,128,185,1,0,232,64,
0,233,76,3,160,250,125,180,125,5,2,0,191,0,0,139,
240,184,0,160,142,192,50,228,172,60,13,116,27,60,255,116,
3,171,235,237,160,251,125,180,125,5,2,0,139,240,191,160,
0,235,222,160,249,125,235,207,184,0,0,205,24,176,0,230,
240,102,96,102,15,164,194,16,139,200,139,235,187,0,2,30,
51,192,142,216,160,132,5,31,36,127,180,6,205,27,102,97,
114,162,129,195,0,2,102,64,73,117,214,195,78,84,76,68,
82,32,32,32,32,32,32,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,13,10,78,84,
76,68,82,32,105,115,32,109,105,115,115,105,110,103,255,13,
10,68,105,115,107,32,101,114,114,111,114,255,13,10,80,114,
101,115,115,32,97,110,121,32,107,101,121,32,116,111,32,114,
101,115,116,97,114,116,13,10,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,172,191,204,0,0,85,170,
82,82,97,65,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,114,114,65,97,255,255,255,255,2,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,170,
102,15,182,70,16,102,139,78,36,102,247,225,102,3,70,28,
102,15,183,86,14,102,3,194,102,137,70,252,102,199,70,244,
255,255,255,255,102,139,70,44,102,131,248,2,15,130,179,252,
102,61,248,255,255,15,15,131,169,252,102,80,102,131,232,2,
102,15,182,94,13,139,243,102,247,227,102,3,70,252,187,0,
130,139,251,185,1,0,232,152,252,56,45,116,30,177,11,86,
190,28,125,243,166,94,116,27,3,249,131,199,21,59,251,114,
232,78,117,218,102,88,232,105,0,114,191,131,196,4,233,98,
252,0,32,131,196,4,139,117,9,139,125,15,139,198,102,193,
224,16,139,199,102,131,248,2,15,130,71,252,102,61,248,255,
255,15,15,131,61,252,102,80,102,131,232,2,102,15,182,78,
13,102,247,225,102,3,70,252,187,0,0,6,142,6,129,128,
232,46,252,7,102,88,193,235,4,1,30,129,128,232,18,0,
15,131,2,0,114,208,138,86,64,141,118,11,93,234,0,0,
0,32,102,193,224,2,232,17,0,38,102,139,1,102,37,255,
255,255,15,102,61,248,255,255,15,195,191,0,126,102,15,183,
78,11,102,51,210,102,247,241,102,59,70,244,116,58,102,137,
70,244,102,3,70,28,102,15,183,78,14,102,3,193,102,15,
183,94,40,131,227,15,116,22,58,94,16,15,131,180,251,82,
102,139,200,102,139,70,36,102,247,227,102,3,193,90,82,139,
223,185,1,0,232,170,251,90,139,218,195,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,170
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\fat\i386\9xboot32.h ===
unsigned char Fat32BootCode9x[] =
{
    0xEB,0x58,0x90,0x4D,0x53,0x57,0x49,0x4E,
    0x34,0x2E,0x31,0x00,0x02,0x02,0x08,0x00,
    0x01,0x00,0x04,0x00,0x00,0xF8,0x00,0x00,
    0x11,0x00,0x04,0x00,0x01,0x00,0x00,0x00,
    0x00,0x00,0x20,0x00,0xE0,0x1F,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x01,0x00,0x06,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x80,0x00,0x29,0x00,0x00,0x00,0x00,0x4E,
    0x4F,0x20,0x4E,0x41,0x4D,0x45,0x20,0x20,
    0x20,0x20,0x46,0x41,0x54,0x33,0x32,0x20,
    0x20,0x20,0xFA,0x33,0xC9,0x8E,0xD1,0xBC,
    0xF8,0x7B,0x8E,0xC1,0xBD,0x78,0x00,0xC5,
    0x76,0x00,0x1E,0x56,0x16,0x55,0xBF,0x22,
    0x05,0x89,0x7E,0x00,0x89,0x4E,0x02,0xB1,
    0x0B,0xFC,0xF3,0xA4,0x8E,0xD9,0xBD,0x00,
    0x7C,0xC6,0x45,0xFE,0x0F,0x8B,0x46,0x18,
    0x88,0x45,0xF9,0x38,0x4E,0x40,0x7D,0x25,
    0x8B,0xC1,0x99,0xBB,0x00,0x07,0xE8,0x97,
    0x00,0x72,0x1A,0x83,0xEB,0x3A,0x66,0xA1,
    0x1C,0x7C,0x66,0x3B,0x07,0x8A,0x57,0xFC,
    0x75,0x06,0x80,0xCA,0x02,0x88,0x56,0x02,
    0x80,0xC3,0x10,0x73,0xED,0xBF,0x02,0x00,
    0x83,0x7E,0x16,0x00,0x75,0x45,0x8B,0x46,
    0x1C,0x8B,0x56,0x1E,0xB9,0x03,0x00,0x49,
    0x40,0x75,0x01,0x42,0xBB,0x00,0x7E,0xE8,
    0x5F,0x00,0x73,0x26,0xB0,0xF8,0x4F,0x74,
    0x1D,0x8B,0x46,0x32,0x33,0xD2,0xB9,0x03,
    0x00,0x3B,0xC8,0x77,0x1E,0x8B,0x76,0x0E,
    0x3B,0xCE,0x73,0x17,0x2B,0xF1,0x03,0x46,
    0x1C,0x13,0x56,0x1E,0xEB,0xD1,0x73,0x0B,
    0xEB,0x27,0x83,0x7E,0x2A,0x00,0x77,0x03,
    0xE9,0xFD,0x02,0xBE,0x7E,0x7D,0xAC,0x98,
    0x03,0xF0,0xAC,0x84,0xC0,0x74,0x17,0x3C,
    0xFF,0x74,0x09,0xB4,0x0E,0xBB,0x07,0x00,
    0xCD,0x10,0xEB,0xEE,0xBE,0x81,0x7D,0xEB,
    0xE5,0xBE,0x7F,0x7D,0xEB,0xE0,0x98,0xCD,
    0x16,0x5E,0x1F,0x66,0x8F,0x04,0xCD,0x19,
    0x41,0x56,0x66,0x6A,0x00,0x52,0x50,0x06,
    0x53,0x6A,0x01,0x6A,0x10,0x8B,0xF4,0x60,
    0x80,0x7E,0x02,0x0E,0x75,0x04,0xB4,0x42,
    0xEB,0x1D,0x91,0x92,0x33,0xD2,0xF7,0x76,
    0x18,0x91,0xF7,0x76,0x18,0x42,0x87,0xCA,
    0xF7,0x76,0x1A,0x8A,0xF2,0x8A,0xE8,0xC0,
    0xCC,0x02,0x0A,0xCC,0xB8,0x01,0x02,0x8A,
    0x56,0x40,0xCD,0x13,0x61,0x8D,0x64,0x10,
    0x5E,0x72,0x0A,0x40,0x75,0x01,0x42,0x03,
    0x5E,0x0B,0x49,0x75,0xB4,0xC3,0x03,0x18,
    0x01,0x27,0x0D,0x0A,0x49,0x6E,0x76,0x61,
    0x6C,0x69,0x64,0x20,0x73,0x79,0x73,0x74,
    0x65,0x6D,0x20,0x64,0x69,0x73,0x6B,0xFF,
    0x0D,0x0A,0x44,0x69,0x73,0x6B,0x20,0x49,
    0x2F,0x4F,0x20,0x65,0x72,0x72,0x6F,0x72,
    0xFF,0x0D,0x0A,0x52,0x65,0x70,0x6C,0x61,
    0x63,0x65,0x20,0x74,0x68,0x65,0x20,0x64,
    0x69,0x73,0x6B,0x2C,0x20,0x61,0x6E,0x64,
    0x20,0x74,0x68,0x65,0x6E,0x20,0x70,0x72,
    0x65,0x73,0x73,0x20,0x61,0x6E,0x79,0x20,
    0x6B,0x65,0x79,0x0D,0x0A,0x00,0x00,0x00,
    0x49,0x4F,0x20,0x20,0x20,0x20,0x20,0x20,
    0x53,0x59,0x53,0x4D,0x53,0x44,0x4F,0x53,
    0x20,0x20,0x20,0x53,0x59,0x53,0x7E,0x01,
    0x00,0x57,0x49,0x4E,0x42,0x4F,0x4F,0x54,
    0x20,0x53,0x59,0x53,0x00,0x00,0x55,0xAA,
    0x52,0x52,0x61,0x41,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x72,0x72,0x41,0x61,
    0xFF,0xFF,0xFF,0xFF,0x02,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x55,0xAA,
    0xFA,0x66,0x0F,0xB6,0x46,0x10,0x66,0x8B,
    0x4E,0x24,0x66,0xF7,0xE1,0x66,0x03,0x46,
    0x1C,0x66,0x0F,0xB7,0x56,0x0E,0x66,0x03,
    0xC2,0x33,0xC9,0x66,0x89,0x46,0xFC,0x66,
    0xC7,0x46,0xF8,0xFF,0xFF,0xFF,0xFF,0xFA,
    0x66,0x8B,0x46,0x2C,0x66,0x83,0xF8,0x02,
    0x0F,0x82,0xCF,0xFC,0x66,0x3D,0xF8,0xFF,
    0xFF,0x0F,0x0F,0x83,0xC5,0xFC,0x66,0x0F,
    0xA4,0xC2,0x10,0xFB,0x52,0x50,0xFA,0x66,
    0xC1,0xE0,0x10,0x66,0x0F,0xAC,0xD0,0x10,
    0x66,0x83,0xE8,0x02,0x66,0x0F,0xB6,0x5E,
    0x0D,0x8B,0xF3,0x66,0xF7,0xE3,0x66,0x03,
    0x46,0xFC,0x66,0x0F,0xA4,0xC2,0x10,0xFB,
    0xBB,0x00,0x07,0x8B,0xFB,0xB9,0x01,0x00,
    0xE8,0xBE,0xFC,0x0F,0x82,0xAA,0xFC,0x38,
    0x2D,0x74,0x1E,0xB1,0x0B,0x56,0xBE,0xD8,
    0x7D,0xF3,0xA6,0x5E,0x74,0x19,0x03,0xF9,
    0x83,0xC7,0x15,0x3B,0xFB,0x72,0xE8,0x4E,
    0x75,0xD6,0x58,0x5A,0xE8,0x66,0x00,0x72,
    0xAB,0x83,0xC4,0x04,0xE9,0x64,0xFC,0x83,
    0xC4,0x04,0x8B,0x75,0x09,0x8B,0x7D,0x0F,
    0x8B,0xC6,0xFA,0x66,0xC1,0xE0,0x10,0x8B,
    0xC7,0x66,0x83,0xF8,0x02,0x72,0x3B,0x66,
    0x3D,0xF8,0xFF,0xFF,0x0F,0x73,0x33,0x66,
    0x48,0x66,0x48,0x66,0x0F,0xB6,0x4E,0x0D,
    0x66,0xF7,0xE1,0x66,0x03,0x46,0xFC,0x66,
    0x0F,0xA4,0xC2,0x10,0xFB,0xBB,0x00,0x07,
    0x53,0xB9,0x04,0x00,0xE8,0x52,0xFC,0x5B,
    0x0F,0x82,0x3D,0xFC,0x81,0x3F,0x4D,0x5A,
    0x75,0x08,0x81,0xBF,0x00,0x02,0x42,0x4A,
    0x74,0x06,0xBE,0x80,0x7D,0xE9,0x0E,0xFC,
    0xEA,0x00,0x02,0x70,0x00,0x03,0xC0,0x13,
    0xD2,0x03,0xC0,0x13,0xD2,0xE8,0x18,0x00,
    0xFA,0x26,0x66,0x8B,0x01,0x66,0x25,0xFF,
    0xFF,0xFF,0x0F,0x66,0x0F,0xA4,0xC2,0x10,
    0x66,0x3D,0xF8,0xFF,0xFF,0x0F,0xFB,0xC3,
    0xBF,0x00,0x7E,0xFA,0x66,0xC1,0xE0,0x10,
    0x66,0x0F,0xAC,0xD0,0x10,0x66,0x0F,0xB7,
    0x4E,0x0B,0x66,0x33,0xD2,0x66,0xF7,0xF1,
    0x66,0x3B,0x46,0xF8,0x74,0x44,0x66,0x89,
    0x46,0xF8,0x66,0x03,0x46,0x1C,0x66,0x0F,
    0xB7,0x4E,0x0E,0x66,0x03,0xC1,0x66,0x0F,
    0xB7,0x5E,0x28,0x83,0xE3,0x0F,0x74,0x16,
    0x3A,0x5E,0x10,0x0F,0x83,0xA4,0xFB,0x52,
    0x66,0x8B,0xC8,0x66,0x8B,0x46,0x24,0x66,
    0xF7,0xE3,0x66,0x03,0xC1,0x5A,0x52,0x66,
    0x0F,0xA4,0xC2,0x10,0xFB,0x8B,0xDF,0xB9,
    0x01,0x00,0xE8,0xB4,0xFB,0x5A,0x0F,0x82,
    0x9F,0xFB,0xFB,0x8B,0xDA,0xC3,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x55,0xAA
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\fat\i386\bootf32.h ===
#define FAT32BOOTCODE_SIZE 1536


unsigned char Fat32BootCode[] = {
235,88,144,77,83,87,73,78,52,46,49,0,2,2,8,0,
1,0,4,0,0,248,0,0,17,0,4,0,1,0,0,0,
0,0,32,0,224,31,0,0,0,0,0,0,0,0,0,0,
1,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,
128,0,41,0,0,0,0,78,79,32,78,65,77,69,32,32,
32,32,70,65,84,51,50,32,32,32,51,201,142,209,188,244,
123,142,193,142,217,189,0,124,136,78,2,138,86,64,180,8,
205,19,115,5,185,255,255,138,241,102,15,182,198,64,102,15,
182,209,128,226,63,247,226,134,205,192,237,6,65,102,15,183,
201,102,247,225,102,137,70,248,131,126,22,0,117,56,131,126,
42,0,119,50,102,139,70,28,102,131,192,12,187,0,128,185,
1,0,232,43,0,233,72,3,160,250,125,180,125,139,240,172,
132,192,116,23,60,255,116,9,180,14,187,7,0,205,16,235,
238,160,251,125,235,229,160,249,125,235,224,152,205,22,205,25,
102,96,102,59,70,248,15,130,74,0,102,106,0,102,80,6,
83,102,104,16,0,1,0,128,126,2,0,15,133,32,0,180,
65,187,170,85,138,86,64,205,19,15,130,28,0,129,251,85,
170,15,133,20,0,246,193,1,15,132,13,0,254,70,2,180,
66,138,86,64,139,244,205,19,176,249,102,88,102,88,102,88,
102,88,235,42,102,51,210,102,15,183,78,24,102,247,241,254,
194,138,202,102,139,208,102,193,234,16,247,118,26,134,214,138,
86,64,138,232,192,228,6,10,204,184,1,2,205,19,102,97,
15,130,84,255,129,195,0,2,102,64,73,15,133,113,255,195,
78,84,76,68,82,32,32,32,32,32,32,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,13,10,78,84,
76,68,82,32,105,115,32,109,105,115,115,105,110,103,255,13,
10,68,105,115,107,32,101,114,114,111,114,255,13,10,80,114,
101,115,115,32,97,110,121,32,107,101,121,32,116,111,32,114,
101,115,116,97,114,116,13,10,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,172,191,204,0,0,85,170,
82,82,97,65,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,114,114,65,97,255,255,255,255,2,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,170,
102,15,182,70,16,102,139,78,36,102,247,225,102,3,70,28,
102,15,183,86,14,102,3,194,102,137,70,252,102,199,70,244,
255,255,255,255,102,139,70,44,102,131,248,2,15,130,166,252,
102,61,248,255,255,15,15,131,156,252,102,80,102,131,232,2,
102,15,182,94,13,139,243,102,247,227,102,3,70,252,187,0,
130,139,251,185,1,0,232,135,252,56,45,116,30,177,11,86,
190,112,125,243,166,94,116,27,3,249,131,199,21,59,251,114,
232,78,117,218,102,88,232,101,0,114,191,131,196,4,233,85,
252,0,32,131,196,4,139,117,9,139,125,15,139,198,102,193,
224,16,139,199,102,131,248,2,15,130,58,252,102,61,248,255,
255,15,15,131,48,252,102,80,102,131,232,2,102,15,182,78,
13,102,247,225,102,3,70,252,187,0,0,6,142,6,129,128,
232,29,252,7,102,88,193,235,4,1,30,129,128,232,14,0,
15,131,2,0,114,208,138,86,64,234,0,0,0,32,102,193,
224,2,232,17,0,38,102,139,1,102,37,255,255,255,15,102,
61,248,255,255,15,195,191,0,126,102,15,183,78,11,102,51,
210,102,247,241,102,59,70,244,116,58,102,137,70,244,102,3,
70,28,102,15,183,78,14,102,3,193,102,15,183,94,40,131,
227,15,116,22,58,94,16,15,131,171,251,82,102,139,200,102,
139,70,36,102,247,227,102,3,193,90,82,139,223,185,1,0,
232,157,251,90,139,218,195,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,170
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\fat\i386\bootsec.inc ===
BOOT_SIZE	EQU	512

BOOTSEC	STRUC
bsJump	DB	3 DUP (?)
bsOemName	DB	8 DUP (?)
bsBPB	DB	SIZE BPB DUP (?)
bsDriveNumber	DB	?
bsReserved1	DB	?
bsBootSignature	DB	?
bsVolumeID	DD	?
bsVolumeLabel	DB	11 DUP (?)
bsFileSysType	DB	8 DUP (?)
BOOTSEC	ENDS

BIGFATBOOTSEC	STRUC
bgbsJump	DB	3 DUP (?)
bgbsOemName	DB	8 DUP (?)
bgbsBPB	DB	SIZE BIGFATBPB DUP (?)
bgbsDriveNumber	DB	?
bgbsReserved1	DB	?
bgbsBootSignature	DB	?
bgbsVolumeID	DD	?
bgbsVolumeLabel	DB	11 DUP (?)
bgbsFileSysType	DB	8 DUP (?)
BIGFATBOOTSEC	ENDS
BOOTSECTRAILSIGL	EQU	0000H
BOOTSECTRAILSIGH	EQU	0AA55H
BOOTSECTRAILSIG	EQU	0AA550000H
OFFSETTRLSIG	EQU	<(BOOT_SIZE-4)>
BOOT_SIGNATURE	EQU	<(BOOT_SIZE-2)>
BOOT_TRAILSIG	EQU	BOOTSECTRAILSIGH
DOREAD_OFFSET	EQU	014BH
DOREAD_MOVDL_OFFSET	EQU	0016H
DOREAD_LENGTH	EQU	0035H
MBR_BOOTFAILBACKUP	EQU	6
MBR_BOOTFLBCKUP	EQU	MBR_BOOTFAILBACKUP
SECONDBOOTSECSIG	EQU	41615252H
SECONDBOOTSECSIGL	EQU	5252H
SECONDBOOTSECSIGH	EQU	4161H

BIGFATBOOTFSINFO	STRUC
bfFSInf_Sig	DD	?
bfFSInf_free_clus_cnt	DD	?
bfFSInf_next_free_clus	DD	?
bfFSInf_resvd	DD	3 DUP (?)
BIGFATBOOTFSINFO	ENDS
EXT_BIGIBMBOOT_FSINFO	EQU	<BIGFATBOOTFSINFO>
EXT_BGFSInf_Sig	EQU	<bfFSInf_Sig>
EXT_BGFSInf_free_clus_cnt	EQU	<bfFSInf_free_clus_cnt>
EXT_BGFSInf_resvd	EQU	<bfFSInf_next_free_clus>
FSINFOSIG	EQU	61417272H
FSINFOSIGL	EQU	7272H
FSINFOSIGH	EQU	6141H
OFFSETFSINFOFRMSECSTRT	EQU	<(OFFSETTRLSIG-SIZE BIGFATBOOTFSINFO)>
OFFSETEXTFSINFOFRMSECSTRT	EQU	<OFFSETFSINFOFRMSECSTRT>
BS2BYTJMP	EQU	0EBH
BS3BYTJMP	EQU	0E9H
BOOT_2BYTJMP	EQU	BS2BYTJMP
BOOT_3BYTJMP	EQU	BS3BYTJMP
BSEXTSIG	EQU	29H
EXT_BOOT_SIGNATURE	EQU	BSEXTSIG
BSFSTYPFAT12	EQU	<"FAT12   ">
BSFSTYPFAT16	EQU	<"FAT16   ">
BSFSTYPFAT32	EQU	<"FAT32   ">
ifdef NOTFAT32
IBMLOADSIZE	EQU	3
else
IBMLOADSIZE	EQU	4
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\fat\i386\msgstub.inc ===
MSG_NOSYS       DB      13,10,"NTLDR is missing",255
MSG_IOERROR     DB      13,10,"Disk error",255
MSG_COMMON      DB      13,10,"Press any key to restart",13,10,0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\fat\i386\fatnec98.asm ===
;++
;
;Module Name:
;
; fatnec98.asm
;
;Abstract:
;
; The ROM in NEC PC-9800 starts the boot process by performing a hardware
; initialization and a verification of all external devices.  If all goes
; well, it will then load from the boot drive the sector from track 0, head 0,
; sector 1.  This sector is placed at physical address 1FC00h or 1FE00h.
; This start address is decided by boot device.
;
; The code in this sector is responsible for locating NTLDR and
; for placing the directory sector with this information at DirSeg:0.
; After loading in this sector, it reads in the entirety of the BIOS at
; BiosSeg:0 and does a long jump to the entry point at BiosSeg:0.
;
; There are no error message during execution of this code.
; In case of NTLDR does not exist or BIOS read error, will sound beep.
;
; At the beginning of the boot sector, there is a table which describes the
; structure of the media.  This is equivalent to the BPB with some
; additional information describing the physical layout of the driver (heads,
; tracks, sectors)
;
;Author:
;
;
;Environment:
;
;    Real mode
;    FAT file system
;
;Revision History:
;
;     6/12/97    Tochizawa(NEC) support booting from 1.44MB FD
;
;--
        page    ,132
        title   boot - NTLDR FAT loader
        name    fatboot

.8086

DIR_ENT struc
        Filename        db 11 dup(?)
        Attribute       db ?
        Reserved        db 10 dup(?)
        Time            dw 2 dup(?)
        StartCluster    dw ?
        FileSize        dd ?
DIR_ENT ends

;
; This is the structure used to pass all shared data between the boot sector
; and NTLDR.
;

SHARED  struc
        ReadClusters            dd      ?               ; function pointer
        ReadSectors             dd      ?               ; function pointer
        SectorBase              dd      ?               ; starting sector
SHARED  ends



DoubleWord      struc
lsw     dw      ?
msw     dw      ?
DoubleWord      ends

SectorSize      equ     512             ; sector size

HiRes           equ     00001000b
DAFloppy        equ     00010000b       ; floppy bit in DA
DASCSI          equ     00100000b       ; SCSI bit in DA
SYS_PORT        equ     37h

BootSeg segment at 1fc0h
BootSeg ends

SysSeg  segment at 0040h
        org     100h
BIOS_FLAG   label byte
        org     184h
BootDrive98 label byte
SysSeg  ends

DirSeg  segment at 1000h
DirSeg  ends

NtLdrSeg segment at 2000h
NtLdrSeg ends

BootCode        segment ;would like to use BootSeg here, but LINK flips its lid
    ASSUME  CS:BootCode,DS:NOTHING,ES:NOTHING,SS:NOTHING

        public  FATBOOT
FATBOOT proc    far

        jmp     short   Start
        nop
;
;       THE FOLLOWING DATA CONFIGURES THE BOOT PROGRAM
;       FOR ANY TYPE OF DRIVE OR HARDFILE
;
; Note that this data is just a place-holder here.  The actual values will
; be filled in by FORMAT or SYS.  When installing the boot sector, only the
; code following the BPB (from Start to the end) should be copied into the
; first sector.
;

OsName                  db      "MSWIN"
OsVersion               db      "4.1"
BPB                     label   byte
BytesPerSector          dw      SectorSize      ; Size of a physical sector
SectorsPerCluster       db      8               ; Sectors per allocation unit
ReservedSectors         dw      4               ; Number of reserved sectors
Fats                    db      2               ; Number of fats
DirectoryEntries        dw      0c00h           ; Number of directory entries
Sectors                 dw      0               ; No. of sectors - no. of hidden sectors
Media                   db      0F8H            ; Media byte
FatSectors              dw      70h             ; Number of fat sectors
SectorsPerTrack         dw      23h             ; Sectors per track
Heads                   dw      7               ; Number of surfaces
HiddenSectors           dd      0f5h            ; Number of hidden sectors
SectorsLong             dd      369c4h          ; Number of sectors iff Sectors = 0

;
; The following byte is NOT part of the BPB but is set by SYS and format
; We should NOT change its position.
;

; keep order of DriveNumber and CurrentHead!
DriveNumber     db      80h             ; Physical drive number (0 or 80h)
CurrentHead     db      0               ; Unitialized

Signature       db      41              ; Signature Byte for bootsector
BootID          dd      0               ; Boot ID field.
Boot_Vol_Label  db      "NO NAME    "
Boot_System_ID  db      'FAT12   '      ;

;
; We need a shred data area with ntldr/setupldr.
; But we don't have memory for using data area. Because bootcode size is 512KB.
; There is nothing for it but to use this area.
;
NtldrSharedData   label   dword
Start:
    assume  DS:nothing,ES:nothing

        xor     ax, ax                  ; Setup the stack to a known good spot
        mov     ss, ax
        mov     sp, 7c00h

        push    cs
        pop     ds
    assume DS:BootCode
        mov     ax, SysSeg
        mov     es, ax
    assume ES:SysSeg

        mov     al, BootDrive98
        mov     DriveNumber, al         ; boot drive

        push    si                      ; save partition info

; We need some intialization.
        mov     si, BytesPerSector      ; keep it in reg

        test    al, DAFloppy
        jnz     Flg00
; Boot is from hard disk.
; Our BPB tells us BytesPerSector, but it is a logical value
; that may differ from the physical value.
; We need SectorShiftFactor that is used to convert logical sector address
; to phisical sector address.

        mov     ah, 84h                 ; ROM BIOS sense command
        xor     bx, bx                  ; initialize bx to 0
        int     1Bh                     ;
        jc      Flg01

        test    bx, bx                  ; physical sector length returned ?
        jnz     Flg02                   ; if not,
Flg01:
        mov     bx, 256                 ;   we assume 256 bytes per sector
Flg02:
        mov     ax, si                  ; BytesPerSector
        xor     dx, dx
        div     bx
        mov     NtldrSharedData.SectorShiftFactor, ax
        mov     ax, 32*1024             ; 32KB
;       xor     dx, dx                  ; dx must be 0 here.
        div     si                      ; BytesPerSector
        mov     NtldrSharedData.LogicalSectorsIn32KByte, al
Flg00:

; The system is now prepared for us to begin reading.  First, determine
; logical sector numbers of the start of the directory and the start of the
; data area.
;

; We read all the directory entries into DirSeg.
; It might be more than 64KB if hard disk.

        mov     ax, size DIR_ENT
        mul     DirectoryEntries    ; (dx:ax) = # of bytes in directory
        dec     si                  ; (si) = BytesPerSector -1
        add     ax, si
        adc     dx, 0
        inc     si                  ; (si) = BytesPerSector
        div     si                  ; (ax) = # of sectors in directory
        mov     cx, ax              ; save it in cx for later

        mov     al, Fats
        xor     ah, ah              ; (ax) = # of FATs
        mul     FatSectors          ; (ax) = # of FAT sectors
        add     ax, ReservedSectors ; (ax) = sector # directory starts
        adc     dx, 0
                                    ; save it in "Arguments" for later 'Read'
        mov     NtldrSharedData.Arguments.SectorBase.lsw, ax
        mov     NtldrSharedData.Arguments.SectorBase.msw, dx

        add     ax, cx              ; next sector after directory
        mov     NtldrSharedData.ClusterBase, ax   ; save it for later use

Rpt00:
        push    cx                  ; (cx) = # of sectors in directory
        push    si                  ; (si) = BytesPerSector

        mov     bx, DirSeg
        mov     es, bx
    assume  es:DirSeg
        xor     bx, bx              ; (es:bx) -> directory segment

; NTLDR is supposed to occupy 1st 512 entries
; in the root directory.

        xor     dx, dx
        mov     ax, (512*32)        ; (dx:ax) = 4000h
        div     si                  ; (si) = BytesPerSector

;
; DoRead does a RETF, but LINK pukes if we do a FAR call in a /tiny program.
;
; (ax) = # of sectors to read
;

        push    ax
        push    cs                  ; make retern frame
        call    DoRead              ; read directory
        pop     ax
        jc      BootErr$he

; Now we scan for the presence of NTLDR

        xor     bx, bx              ; offset
        mov     cx, 512             ; # of entries to search (only 512)

Rpt01:
        mov     di, bx              ; (es:di) = filespec in directory entry
        push    cx
        mov     cx, 11              ; (cx) = filespec size
        mov     si, offset LOADERNAME   ; (ds:si) = filespec we are searching
        repe    cmpsb
        pop     cx
        je      @F                  ; if matches, exit loop
        add     bx, size DIR_ENT    ; else next entry
        loop    Rpt01
@@:
        test    cx, cx
        pop     si
        pop     cx
        jnz     Rpt02

        add     NtldrSharedData.Arguments.SectorBase.lsw, ax
        adc     NtldrSharedData.Arguments.SectorBase.msw, 0
        sub     cx, ax
        ja      Rpt00
        jmp     BootErr$bnf

Rpt02:
; We have found NTLDR
; We read it into NtLdrSeg.

        mov     dx, es:[bx].StartCluster    ; (dx) = starting cluster number
        mov     ax, 1               ; (ax) = sectors to read
        cmp     BytesPerSector, 256
        jne     @F

        inc     ax                  ; We need to read 2 sectors
@@:
;
; Now, go read the file
;

        mov     bx, NtLdrSeg
        mov     es, bx
    assume  es:NtLdrSeg
        xor     bx, bx              ; (es:bx) -> start of NTLDR

;
; LINK barfs if we do a FAR call in a TINY program, so we have to fake it
; out by pushing CS.
;

        push    dx                  ; save starting cluster number

        push    cs                  ; make retern frame
        call    ClusterRead

        pop     bx                  ; (bx) = Starting Cluster Number
        jc      BootErr$he

;
; NTLDR requires:
;   BX = Starting Cluster Number of NTLDR
;   DL = INT 1B drive number we booted from  <- DA/UA in 98
;   DS:SI -> the boot media's BPB
;   DS:DI -> argument structure
;   1000:0000 - entire DIR is loaded
; On PC-9801 we have one more parameter...
;   (bp) = partition info
;

        lea     si, BPB             ; ds:si -> BPB
        lea     di, NtldrSharedData.Arguments ; ds:di -> Arguments

        mov     ax,ds
        mov     NtldrSharedData.Arguments.ReadClusters.msw, ax
        mov     NtldrSharedData.Arguments.ReadClusters.lsw, offset ClusterRead

        mov     NtldrSharedData.Arguments.ReadSectors.msw, ax
        mov     NtldrSharedData.Arguments.ReadSectors.lsw, offset DoRead
        mov     dl, DriveNumber     ; dl = boot drive

        pop     bp                  ; partition info
;
; FAR JMP to 2000:0003.  This is hand-coded, because I can't figure out
; how to make MASM do this for me.  By entering NTLDR here, we skip the
; initial jump and execute the FAT-specific code to load the rest of
; NTLDR.
;
        db      0EAh                ; JMP FAR PTR
        dw      3                   ; 2000:3
        dw      02000h
FATBOOT endp

;
; BootErr - print error message and hang the system.
;
BootErr proc
BootErr endp

; BootError - print error message and hang the system.
;
BootError proc
    assume  DS:BootCode,ES:nothing
;
; Am I display message that is reason of the ERROR ?
; Ofcourse. but no room available.

BootErr$bnf:
BootErr$he:
        mov     al, 06h
        out     37h, al

        jmp     $

BootError endp

;
; ClusterRead - read AL sectors into ES:BX starting from
;       cluster DX
;
ClusterRead proc
        push    ax                  ; (TOS) = # of sectors to read
        dec     dx
        dec     dx                  ; adjust for reserved clusters 0 and 1
        mov     al, SectorsPerCluster
        xor     ah, ah
        mul     dx                  ; DX:AX = starting sector number
        add     ax, NtldrSharedData.ClusterBase   ; adjust for FATs, root dir, boot sec.
        adc     dx, 0
        mov     NtldrSharedData.Arguments.SectorBase.lsw, ax
        mov     NtldrSharedData.Arguments.SectorBase.msw, dx
        pop     ax                  ; (al) = # of sectors to read

;
; Now we've converted the cluster number to a SectorBase, so just fall
; through into DoRead
;

ClusterRead endp


;
; DoRead - read AL sectors into ES:BX starting from sector
;          SectorBase.
;
DoRead  proc
        xor     ah, ah
        cmp     ax, 0
        jnz     @F

        inc     ah                  ; read 256 Sectors
@@:
        push    si
        push    di
        push    bp

        mov     si, ax
        mov     bp, bx
        mov     cx, NtldrSharedData.Arguments.SectorBase.lsw  ; Starting sector
        mov     dx, NtldrSharedData.Arguments.SectorBase.msw  ; Starting sector

;    (dx:cx) = logical sector # relative to partition
;    (si)    = # of sectors to read
;    (es:bp) = read buffer

Rpt03:
        push    dx
        push    cx

;   [sp]   = logical sector number LSW
;   [sp+2] = logical sector number MSW

        mov     al, DriveNumber

        test    al, DAFloppy
        jz      Flg03

;   We are reading floppy disk.
;   We don't care about DMA boundary, as no PC-9801 DOS floppy disk
;   has more than 2048 directory entries, we never read
;   more than 64 KB.

        push    ax
        mov     ax, cx              ; (dx:ax) = lsn
        mov     bx, SectorsPerTrack
        div     bx                  ; (dx) = sector # (0-based)
                                    ; (ax) = cylinder # * # of heads + head #
        div     byte ptr Heads      ;(ah) = head address
                                    ; (al) = cylinder address
        mov     dh, ah
        mov     cl, al
        mov     al, byte ptr BytesPerSector + 1     ; convert Bytes/Sector to
        xor     ch, ch                              ;            SectorLengthID
whl00:                                              ; Bytes/Sect |  ID (ch)
        cmp     al, 0
        jz      @f

        inc     ch                  ;      128   ->   0
        shr     al, 1               ;      256   ->   1
        jmp     short   whl00       ;      512   ->   2
@@:                                 ;     1024   ->   3
        pop     ax

        sub     bl, dl              ; sectors in THIS track
        inc     dl                  ; sector # (1-based)

;   We have prepared following ROM BIOS parameters
;   (al) = drive
;   (cl) = cylinder address
;   (ch) = sector size
;   (dl) = sector address
;   (dh) = head address
;   (es:bp) -> buffer
;
;   And we have some more.
;   (bl) = # of sectors we can read with 1 time ROM call
;   (si) = # of sectors we need to read
;
        jmp     short   Flg04

Flg03:
;   We are reading hard disk.
;   We don't care about DMA boundary
;   as length we read is 64KB max.
;

        and     al, 7FH                 ; drive #
        mov     bx,NtldrSharedData.SectorShiftFactor

Rpt04:                                  ; logical sector address to
        shr     bx, 1
        jc      @F

        shl     cx, 1                   ; physical sector address
        rcl     dx, 1
        jmp     short   Rpt04
@@:
        add     cx, HiddenSectors.lsw
        adc     dx, HiddenSectors.msw   ; (dx:cx) -> relative to drive
        mov     bl, NtldrSharedData.LogicalSectorsIn32KByte
                                        ; sectors we can read (32KB)
                                        ; this is not optimum on performance

;   We have prepared following ROM BIOS parameters
;   (al) = drive
;   (dx:cx) = relative sector number
;   (es:bp) -> buffer
;
;   And we have some more.
;   (bl) = # of sectors we can read with 1 time ROM call
;   (si) = # of sectors we need to read
;
Flg04:

        xor     bh, bh

        cmp     si, bx
        jnb     @F

        mov     bx, si
@@:
        push    bx              ; # of sectors we are reading this call
        push    dx
        xchg    ax, bx
        mul     BytesPerSector
        xchg    ax, bx
        pop     dx
        push    bx              ; # of bytes.

;   [sp]   = # of bytes to read
;   [sp+2] = # of sectors
;   [sp+4] = logical sector number LSW
;   [sp+6] = logical sector number MSW

        mov     ah, 01010110b   ; read
        int     1BH

        pop     di              ; # of bytes
        pop     bx              ; # of sectors
        pop     cx              ; lsn (LSW)
        pop     dx              ; lsn (MSW)

        jc      @F              ; return Carry

;   prepare for next call

        add     cx, bx          ; advance lsn
        adc     dx, 0           ;
        add     bp, di          ; advance offset
        sub     si, bx          ; decrement # of sectors
        jnz     Rpt03           ; CarryFlag is Clear
@@:

        pop     bp
        pop     di
        pop     si
        retf
DoRead  endp

LOADERNAME      DB      "NTLDR      "

;       .errnz  ($-FATBOOT) GT 510,<FATAL PROBLEM: boot sector is too large>

        org     510
        db      55h, 0aah

BootCode        ends

;Unitialized variables go here--beyond the end of the boot sector in free memory
UninitializedWork       struc
ClusterBase                 dw    ?                     ; first sector of cluster # 2
SectorShiftFactor           dw    ?
LogicalSectorsIn32KByte     db    ?
Arguments                   db    (size SHARED) dup (?) ; structure passed to NTLDR
UninitializedWork       ends

        END     FATBOOT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\fat\i386\fat32nec.asm ===
NEC_98=1
        Page ,132
TITLE BOOT      SECTOR 1 OF TRACK 0 - BOOT LOADER
;++
;
;Module Name:
;
; fat32nec.asm
;
;Abstract:
;
; The ROM in NEC PC-9800 starts the boot process by performing a hardware
; initialization and a verification of all external devices.  If all goes
; well, it will then load from the boot drive the sector from track 0, head 0,
; sector 1.  This sector is placed at physical address 1FE00h.
;
; We need to load NTLDR at 2000:0. But the bootcode of FAT32 is 600h bytes.
; If we start at physical address 1FE0:0, the bootcode is broken by loaded NTLDR.
; At first, we move the bootcode to 0:7C00 from 1FE0:0 by oneself.
; The next, we jump to new Segment:Offset and start real bootcode procedure.
;
; The code is responsible for locating NTLDR and for placing the directory sector
; with this information.
;
; If WINBOOT.SYS is not found, an error message is displayed and the user is
; prompted to insert another disk.  If there is a disk error during the
; process, a message is displayed and things are halted.
;
; At the beginning of the boot sector, there is a table which describes the
; structure of the media.  This is equivalent to the BPB with some
; additional information describing the physical layout of the driver (heads,
; tracks, sectors)
;
;Author:
;
;
;Environment:
;
;    Real mode
;    FAT32 file system
;
;Revision History:
;
;     7/01/97    Tochizawa(NEC) support FAT32
;
;--

        .xlist
        include bpb.inc
        include bootsec.inc
        include dirent.inc
        ;include version.inc
        .list

; ==========================================================================
ORIGIN          EQU     7C00H           ; Origin of bootstrap LOADER

BIO_SEG         EQU     2000H           ; Destination segment of BIOS
BIO_OFFSET      EQU     0000H           ; Offset of bios

SECTOR_SIZE     EQU     512             ; Sector size in bytes
DIR_ENTRY_SIZE  EQU     SIZE DIR_ENTRY  ; Size of directory entry in bytes

ROM_DISKRD      EQU     2

SIZEBIGBOOTINSEC EQU    3

ifdef NEC_98
BOOTCODE_SEG    EQU     0000H           ; Destination segment of BOOTCODE
DAUA            EQU     584h
endif
; ==========================================================================

SEGBIOS SEGMENT AT BIO_SEG

        ; Define the destination segment of the BIOS, including the
        ; initialization label
        ORG     BIO_OFFSET
WINLOAD LABEL   BYTE

SEGBIOS ENDS

; ==========================================================================

        ; Local (on stack) Data storage between temp stack and start of
        ; boot sector

CurrBuffFatSecL EQU     -12
CurrBuffFatSecH EQU     -10
Int13Sectors    EQU     -8
DataSecL        EQU     -4
DataSecH        EQU     -2

; ==========================================================================

CODE    SEGMENT
        ASSUME  CS:CODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
        ORG     ORIGIN


        Public  $START
$START  Label   byte

        jmp     short Main
GotXint13:
        nop                             ; used to store xint13 flag

GotXint13Offset = (offset GotXint13 - offset $START)

; ==========================================================================

        ; Start of BPB area of the boot record

OsName          DB      "MSWIN"
OsVersion       DB      "4.1"           ; Windows version number

BytesPerSector  DW      SECTOR_SIZE     ; Size of a physical sector
SecsPerClust    DB      2               ; Sectors per allocation unit
ReservedSecs    DW      8               ; Number of reserved sectors
NumFats         DB      1               ; Number of fats
NumDirEntries   DW      1024            ; Number of direc entries
TotalSectors    DW      0               ; Number of sectors - number of hidden
                                        ; sectors (0 when 32 bit sector number)
MediaByte       DB      0F8H            ; MediaByte byte
NumFatSecs      DW      0               ; Number of fat sectors (0 when 32 bit)
SecPerTrack     DW      17              ; Sectors per track
NumHeads        DW      4               ; Number of drive heads

HiddenSecs      DD      1               ; Number of hidden sectors
BigTotalSecs    DD      00200000h       ; 32 bit version of number of sectors
BigNumFatSecs   DD      00001FE0h       ; 32 bit version of number of FAT sectors
ExtFlags        DW      0
BPBReserved1    DW      0
RootStrtClus    DD      0
FSInfoSec       dw      ((FSInfoSecSig - $START) / SECTOR_SIZE)
BkUpBootSec     dw      MBR_BOOTFAILBACKUP
BPBReserved2    DD      3 DUP (0)
        .errnz  ($-BytesPerSector) NE SIZE BIGFATBPB

BootDrv         DB      80h
CurrentHead     DB      0h              ; Current Head
ExtBootSig      DB      41
SerialNum       DD      0
VolumeLabel     DB      'NO NAME    '
FatId           DB      'FAT32   '

        .errnz  ($-$START) NE SIZE BIGFATBOOTSEC


; =========================================================================

;
;   First thing is to reset the stack to a better and more known
;   place. The ROM may change, but we'd like to get the stack
;   in the correct place.
;
Main:
ifdef NEC_98
        push    si                      ; Save Partition Information
;
; We moved bootcode to 0:ORIGIN from 1fe0:0.
;
        push    di
        mov     ax, cs
        mov     ds, ax                  ; DS = CS
        mov     si, 0                   ; DS:SI = 1fe0:0
        cld
        mov     cx, 256
        xor     ax, ax
        mov     es, ax
        mov     di, ORIGIN              ; ES:DI = 0:7c00
        rep     movsw
        pop     di
        pop     si                      ; Restore Partition Information
;
; We jump to 0:ORIGIN+RealBootStart
;
        mov     ax, BOOTCODE_SEG
        push    ax
        mov     ax, ORIGIN
        add     ax, RealBootStart
        push    ax
        retf

RealBootStart = (offset $ - offset $START)
endif
        xor     CX,CX
        mov     SS,CX                   ;Work in stack just below this routine
        mov     SP,ORIGIN+CurrBuffFatSecL
        mov     es,cx
        mov     ds,cx                   ; DS = ES = SS = 0
        ASSUME  DS:CODE,ES:CODE,SS:CODE
        mov     BP,ORIGIN

IFDEF NEC_98
.386
        push    si                          ; Save Partition Information
        mov     al, ds:[DAUA]               ;
        mov     [BP].bgbsDriveNumber, al    ; Save DriveNumber
else
;
; Determine the number of sectors addressable via
; conventional int13. If we can't get drive params for some reason
; then something is very wrong -- we'll try to force the caller
; to use conventional int13 by maxing out the sector count.
;
        mov     [bp].GotXint13Offset,cl ; no xint13 yet
        mov     dl,[bp].bgbsDriveNumber ; int13 unit number
        mov     ah,8                    ; get drive params
        int     13h                     ; call BIOS
        jnc     @f                      ; no error, procede
        mov     cx,-1                   ; strange case, fake registers to force
        mov     dh,cl                   ; use of standard int13 (set all vals to max)
@@:
.386
        movzx   eax,dh                  ; eax = max head # (0-255)
        inc     ax                      ; eax = heads (1-256)
        movzx   edx,cl                  ; edx = sectors per track + cyl bits
        and     dl,3fh                  ; edx = sectors per track (1-63)
        mul     dx                      ; eax = sectors per cylinder, edx = 0
        xchg    cl,ch
        shr     ch,6                    ; cx = max cylinder # (0-1023)
        inc     cx                      ; cx = cylinders (1-1024)
        movzx   ecx,cx                  ; ecx = cylinders (1-1024)
        mul     ecx                     ; eax = sectors visible via int13, edx = 0
        mov     [bp].Int13Sectors,eax   ; save # sectors addressable via int13
ENDIF
.8086

;
; The MBR (or boot ROM) only reads one boot sector. Thus the first order
; of business is to read the rest of ourself in by reading the second
; boot sector of the 2-sector boot record.
;
; The second sector in the NT case is at sector 12. This preserves
; the bootsect.dos logic and eliminates a special case for fat32.
;
ReadBoot:
        cmp     [BP].bgbsBPB.oldBPB.BPB_SectorsPerFAT,0 ; FAT32 BPB?
        jne     short NoSysMsg          ; No, invalid, messed up
        cmp     [BP].bgbsBPB.BGBPB_FS_Version,FAT32_Curr_FS_Version
        ja      short NoSysMsg          ; boot code too old for this volume
.386
        mov     eax,dword ptr [BP].bgbsBPB.oldBPB.BPB_HiddenSectors
        add     eax,12                  ; read in the second boot sector
.8086
        mov     BX,ORIGIN + (SECTOR_SIZE * 2)
        mov     cx,1
        call    DoRead                  ; doesn't return if err
        jmp     DirRead                 ; no error, continue boot in sector 2

DiskError:
        mov     al,byte ptr [MSGOFF_IOERROR]

;
; Al is the offset - 256 of the message within the boot sector.
; So we first calculate the real segment-based offset to the message
; and stick it in si so lodsb will work later.
;
DisplayError:
        .ERRNZ  ORIGIN MOD 256
        mov     ah,(ORIGIN / 256) + 1
ifdef NEC_98
        add     ax, 2
        mov     di, 0
endif
        mov     si,ax

DisplayError1:
ifdef NEC_98
        mov     ax, 0a000h              ; set V-RAM
        mov     es, ax
        xor     ah, ah
        lodsb                           ; Get next character
        cmp     AL,0Dh                  ; end of message?
        jz      WaitForKey              ; yes
        cmp     AL,0FFh                 ; end of sub-message?
        je      DisplayWait             ; yes, switch to final message now
        stosw                           ; move to vram
        jmp     short DisplayError1
else
        lodsb                           ; get next character
        test    AL,AL                   ; end of message?
        jz      WaitForKey              ; yes
        cmp     AL,0FFh                 ; end of sub-message?
        je      DisplayWait             ; yes, switch to final message now
        mov     AH,14                   ; write character & attribute
        mov     BX,7                    ; attribute (white char on black)
        int     10h                     ; print the character
        jmp     short DisplayError1
endif

DisplayWait:
        mov     al,byte ptr [MSGOFF_COMMON]
ifdef NEC_98
        mov     ah,(ORIGIN / 256) + 1
        add     ax, 2
        mov     si,ax
        mov     di, 160
        jmp     short DisplayError1
else
        jmp     short DisplayError
endif

NoSysMsg:
        mov     al,byte ptr [MSGOFF_NOSYS] ; point to no system file message
        jmp     short DisplayError

WaitForKey:
ifdef NEC_98
        mov     ax, 0h
        int     18h
        mov     al, 0h
        out     0f0h, al
else
        cbw                             ;warning assumes al is zero!
        int     16h                     ; get character from keyboard
        int     19h                     ; Continue in loop till good disk
endif

; =========================================================================
;
; Read disk sector(s). This routine cannot transfer more than 64K!
;
;   Inputs:  EAX == physical sector #
;            CL == # sectors (CH == 0)
;            ES:BX == transfer address
;
;   Outputs: EAX next physical sector #
;            CX == 0
;            ES:BX -> byte after last byte of read
;            Does not return if error
;
;   Reads sectors, switching to extended int13 if necessary and
;   available. The note below is for the conventional int13 case.
;
;   Notes:   Reads sectors one at a time in case they straddle a
;            track boundary.  Performs full 32-bit division on the
;            first decomposition (of logical sector into track+sector)
;            but not on the second (of track into cylinder+head),
;            since (A) we don't have room for it, and (B) the results
;            of that division must yield a quotient < 1024 anyway, because
;            the CHS-style INT 13h interface can't deal with cylinders
;            larger than that.
;
; =========================================================================

DoRead:
.386
        pushad

IFDEF NEC_98
        shld    edx,eax,16              ; EAX -> DX:AX
        mov     CX,AX                   ; We've gotten Phy.Sector# in DX:CX
        mov     bp,bx                   ; Buffer addr -> bp
        mov     bx,SECTOR_SIZE          ; Sector size -> bx
        push    ds
        xor     ax,ax
        mov     ds,ax                   ; DS = 0
        mov     al,ds:[DAUA]            ; set booting da/ua
        pop     ds                      ; Restore DS
        and     al,7fh                  ; strip high 1 bit
                                        ; SCSI HD
        mov     ah,06h                  ; set read command
        int     1bh
else
;
; Determine if the sector we're about to read is available via
; conventional int13.
;
        cmp     eax,[bp].Int13Sectors   ; determine if standard int13 is ok
        jb      stdint13

;
; Need extended int13. First set up parameter packet on stack.
; Then, if we don't know whether xint13 is available for the drive yet,
; find out. If not, error out since we know we can't read the sector
; we need.
;
        db      66h                     ; hand-coded 32-bit push of 8-bit immediate
        push    0                       ; high 32 bits of sector #
        push    eax                     ; low 32 bits of sector #
        push    es
        push    bx                      ; transfer address
        push    dword ptr 10010h        ; transfer 1 sector, packet size = 16

        cmp     byte ptr [bp].GotXint13Offset,0  ; have xint13?
        jnz     xint13ok                ; yes, do the read
        mov     ah,41h
        mov     bx,055aah
        mov     dl,[bp].bgbsDriveNumber
        int     13h                     ; check availability
        jc      xint13err               ; error from int13 means no xint13
        cmp     bx,0aa55h               ; absence of sig means no xint13
        jne     xint13err
        test    cl,1                    ; bit 0 off means no xint13
        jz      xint13err
        inc     byte ptr [bp].GotXint13Offset ; have xint13, remember for next time

xint13ok:
        mov     ah,42h                  ; extended read
        mov     dl,[bp].bgbsDriveNumber ; dl = int13 unit #
        mov     si,sp                   ; ds:si -> param packet
        int     13h                     ; perform the read
        db 0b0h                         ; HACK: avoid stc by making next
                                        ; byte part of mov al,xx instruction
xint13err:
        stc                             ; this instruction MUST follow previous byte!
        pop     eax                     ; throw away param packet without
        pop     eax                     ; clobbering carry flag
        pop     eax
        pop     eax

        jmp     short did_read

stdint13:
;
; Read via conventional int13
;
        xor     edx,edx                 ; edx:eax = absolute sector number
        movzx   ecx,[bp].bgbsBPB.oldBPB.BPB_SectorsPerTrack  ; ecx = sectors per track
        div     ecx                     ; eax = track, edx = sector within track (0-62)
        inc     dl                      ; dl = sector within track (1-63)
        mov     cl,dl                   ; cl = sector within track
        mov     edx,eax
        shr     edx,16                  ; dx:ax = track
        div     [bp].bgbsBPB.oldBPB.BPB_Heads ; ax = cylinder (0-1023), dx = head (0-255)
        xchg    dl,dh                   ; dh = head
        mov     dl,[bp].bgbsDriveNumber ; dl = int13 unit #
        mov     ch,al                   ; ch = bits 0-7 of cylinder
        shl     ah,6
        or      cl,ah                   ; bits 6-7 of cl = bits 8-9 of cylinder
        mov     ax,201h                 ; read 1 sector
        int     13h

did_read:
ENDIF
        popad

        jc      DiskError

        add     bx,SECTOR_SIZE          ; advance transfer address
        inc     eax                     ; next sector number
        dec     cx                      ; loop instruction is out of range,
        jnz     DoRead                  ; have to do it manually
        ret
.8086

        Public  WinBoot                 ; System boot file (11 bytes)
WinBoot DB      "NTLDR      "

;
; Message table.
;
; We put English messages here as a placeholder only, so that in case
; anyone uses bootf32.h without patching new messages in, things will
; still be correct (in English, but at least functional).
;
        .errnz ($-$START) GT 1ACH
        ORG     ORIGIN + 01ACH          ; shift message to coincide with that in FAT
                                        ; this will help driver to think the MBR
                                        ; is empty when dealing with FAT32 superfloppy
        include msgstub.inc

;
; Now build a table with the low byte of the offset to each message.
; Code that patches the boot sector messages updates this table.
;
        .errnz ($-$START) GT (SECTOR_SIZE-7)
        ORG     ORIGIN + SECTOR_SIZE - 7
MSGOFF_NOSYS:
        db OFFSET (MSG_NOSYS - ORIGIN) - 256
MSGOFF_IOERROR:
        db OFFSET (MSG_IOERROR - ORIGIN) - 256
MSGOFF_COMMON:
        db OFFSET (MSG_COMMON - ORIGIN) - 256

        ORG     ORIGIN + (SECTOR_SIZE - 4)
        DD      BOOTSECTRAILSIG         ; Boot sector signature (4 bytes)


        .errnz  ($-$START) NE SECTOR_SIZE
SecndSecStart label byte
;
; The second boot sector contains nothing but data. This sector is re-written
; by MS-DOS with a fairly high frequency due to changes made to the fsinfo
; structure. We don't want the actual boot code to get accidentally corrupted.
;
FSInfoSecSig label byte
        .errnz  ($-SecndSecStart) NE 0
        DD      SECONDBOOTSECSIG

        db      (SECTOR_SIZE - ($-FSInfoSecSig) - 4 - (SIZE BIGFATBOOTFSINFO)) DUP (0)

        .errnz  ($-SecndSecStart) NE (OFFSETFSINFOFRMSECSTRT)

fsinfo  BIGFATBOOTFSINFO <FSINFOSIG,0FFFFFFFFh,000000002h>

        .errnz  ($-FSInfoSecSig) NE OFFSETTRLSIG
        DD      BOOTSECTRAILSIG         ; Boot sector signature (4 bytes)

        .errnz  ($-$START) NE (SECTOR_SIZE * 2)
StrtThirdBootSector     LABEL BYTE

DirRead:
.386
        movzx   eax,[BP].bgbsBPB.oldBPB.BPB_NumberOfFATs  ; Determine sector dir starts on (NumFats)
        mov     ecx,dword ptr [BP].bgbsBPB.BGBPB_BigSectorsPerFat
        mul     ecx                     ; EAX = (NumFatSecs)
        add     EAX,dword ptr [BP].bgbsBPB.oldBPB.BPB_HiddenSectors ; (HiddenSecs)
        movzx   edx,[BP].bgbsBPB.oldBPB.BPB_ReservedSectors         ;(ReservedSecs)
        add     EAX,EDX
;
;   EAX = NumFats * NumFatSecs + ReservedSecs + cSecHid
;         (first physical sector of cluster area)
;
        mov     dword ptr [BP].DataSecL,EAX
        mov     dword ptr [BP].CurrBuffFatSecL,0FFFFFFFFh
DirReRead:
        mov     eax,dword ptr [BP].bgbsBPB.BGBPB_RootDirStrtClus
        cmp     eax,2
        jb      NoSysMsg
        cmp     eax,00FFFFFF8h
        jae     NoSysMsg

; EAX is starting cluster of root directory

DirCluster:
        push    eax                     ; save starting cluster number
        sub     eax,2                   ; Convert to 0 based cluster #
        movzx   EBX,[BP].bgbsBPB.oldBPB.BPB_SectorsPerCluster
        mov     si,bx                   ; Sector count to SI for sector loop
        mul     EBX                     ; compute logical sector in EAX
        add     EAX,dword ptr [BP].DataSecL ; Add data start bias
DirSector:
        mov     BX,ORIGIN+(SIZEBIGBOOTINSEC*SECTOR_SIZE)
        mov     DI,BX                   ; save address in DI for comparisons
        mov     CX,1
        call    DoRead                  ; doesn't return if error
                                        ; relies on return cx=0
DirEntry:
        cmp     byte ptr [di],ch        ; empty, NUL directory entry?
        je      short MissingFile       ; yes, that's the end

        mov     CL,11
        push    SI
        mov     si,offset WinBoot
        repz    cmpsb                   ; see if the same
        pop     SI
        jz      short DoLoad            ; if so, continue booting

        add     DI,CX                   ; Finish advance to end of name field
        add     DI,DIR_ENTRY_SIZE-11    ; Next dir entry
        cmp     DI,BX                   ; exhausted this root dir sector yet?
        jb      DirEntry                ; no, check next entry
        dec     SI                      ; decrement # dir sectors
        jnz     DirSector               ; More dir sectors in this cluster
        pop     eax                     ; recover current root dir cluster
        call    GetNextFatEntry
        jc      DirCluster              ; Do next Root dir cluster
MissingFile:
        add     sp,4                    ; Discard EAX saved on stack
        jmp     NoSysMsg

CurrentSegment  dw      BIO_SEG
;
;   We now load NTLDR
;
;   All we have to do is multiply the file's starting cluster
;   (whose directory entry is at DS:DI-11) by sectors per cluster and
;   add that to the disk's starting data sector. We read ntldr into
;   2000:0, and begin execution there.
;
DoLoad:
        add     sp,4                    ; Discard DX:AX saved on stack above
        mov     si,[DI-11].DIR_FIRSTHIGH
        mov     di,[DI-11].DIR_FIRST    ; SI:DI = NTLDR starting cluster
        mov     ax,si
        shl     eax,16
        mov     ax,di                   ; EAX = NTLDR starting cluster
        cmp     eax,2                   ; valid cluster #?
        jb      NoSysMsg                ; NO!
        cmp     eax,00FFFFFF8h
        jae     NoSysMsg                ; NO!

ReadAcluster:
        push    eax                     ; save cluster number
        sub     eax,2                   ; Subtract first 2 reserved clusters
        movzx   ecx,[BP].bgbsBPB.oldBPB.BPB_SectorsPerCluster ; ECX = Sectors per cluster (SecsPerClust)
        mul     ecx                     ; EAX = logical sector #

        add     eax,dword ptr [BP].DataSecL  ; EAX = physical sector #

        mov     bx,BIO_OFFSET
        push    es
        mov     es,CurrentSegment       ; ES:BX = destination for read
        call    DoRead                  ; read all sectors in cluster, doesn't return if error
        pop     es
        pop     eax                     ; recover current 0-based cluster#
        shr     bx,4                    ; updated offset -> paragraphs
        add     CurrentSegment,bx       ; update segment for next read

        call    GetNextFatEntry         ; get 2-based successor cluster in EAX
        jnc     StartItUp               ; if end of cluster chain reached
        jc      ReadACluster            ; keep sucking up clusters
.8086

;
; NTLDR requires the following input conditions:
;
;       DL = boot drive #
;

StartItUp:
        mov     DL,[BP].bgbsDriveNumber
ifdef NEC_98
        lea     si,[BP].bgbsBPB
        pop     bp                      ; Restore Partition Information
endif
        jmp     FAR PTR WINLOAD         ; CRANK UP THE WINDOWS NT BOOT LOADER

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   GetNextFatEntry
;
;   Given the last cluster found, this will return the next cluster
;   of a chain of clusters. If the last cluster is (ffff)(f)ff8 - (ffff)(f)fff,
;   then the final cluster has been loaded.
;
;   INPUTS:
;       EAX = CurrentCluster (0 based cluster #)
;
;   OUTPUTS:
;       EAX = Next cluster (2 based cluster #)
;       Carry CLEAR if all done, SET if not
;
;   USES:
;   EAX,EBX,ECX,EDX,ESI,DI es
;

GetNextFatEntry PROC NEAR

        ; NOTE For following... FAT32 cluster numbers are 28 bits not 32,
        ; so we know the following multiply (shl DX:AX by 2) will never
        ; overflow into carry.
.386
        shl     eax,2
        call    GetFatSector
        mov     EAX,dword ptr ES:[DI+BX]
        and     EAX,0FFFFFFFh           ; Mask to valid FAT32 cluster # bits
        cmp     EAX,00FFFFFF8h          ; carry CLEAR if all done, SET if not
.8086
        ret

GetNextFatEntry ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   GetFatSector
;
;   Read the corresponding FAT sector into the second boot sector
;
;   INPUTS:
;       EAX == offset (from FAT entry 0) of entry to find
;
;   OUTPUTS:
;       ES:DI+BX -> corresponding FAT entry in the FAT sector
;
;   USES:
;       BX,EAX,ECX,EDX,DI
;

GetFatSector    PROC    NEAR
.386
        mov     DI,ORIGIN + SECTOR_SIZE
        movzx   ECX,[BP].bgbsBPB.oldBPB.BPB_BytesPerSector
        xor     edx,edx
        div     ECX                     ; EAX = Sector number, (E)DX = Offset
        cmp     EAX,dword ptr [BP].CurrBuffFatSecL  ; The same fat sector?
        je      short SetRet            ; Don't need to read it again
        mov     dword ptr [BP].CurrBuffFatSecL,EAX
        add     EAX,dword ptr [BP].bgbsBPB.oldBPB.BPB_HiddenSectors
        movzx   ecx,[BP].bgbsBPB.oldBPB.BPB_ReservedSectors
        add     eax,ecx                 ; Point at 1st (0th) FAT
        movzx   ebx,[BP].bgbsBPB.BGBPB_ExtFlags
        and     bx,BGBPB_F_ACTIVEFATMSK
        jz      short GotFatSec
        cmp     bl,[BP].bgbsBPB.oldBPB.BPB_NumberOfFATs
        jae     NoSysMsg
        push    dx                      ; Save offset of cluster in the FAT sec
        mov     ecx,eax                 ; Save FAT sector # in 0th FAT
        mov     eax,dword ptr [BP].bgbsBPB.BGBPB_BigSectorsPerFat
        mul     ebx                     ; EAX = Sector offset to active FAT
                                        ;       from 0th FAT
        add     eax,ecx
        pop     dx
GotFatSec:
        push    dx                      ; Save offset of cluster in the FAT sec
        mov     BX,DI
        mov     CX,1
        call    DoRead                  ; do the disk read, doesn't return if error
        pop     dx
SetRet:
        mov     BX,DX                   ; set BX to the offset of the cluster
.8086
        ret

GetFatSector    ENDP

        db      ((SECTOR_SIZE - ($-StrtThirdBootSector)) - 4) DUP (0)

        .errnz  ($-StrtThirdBootSector) NE OFFSETTRLSIG
        DD      BOOTSECTRAILSIG         ; Boot sector signature (4 bytes)

        .errnz  ($-$START) NE (SECTOR_SIZE * 3)
        .errnz  SIZEBIGBOOTINSEC NE 3

$BigEnd label byte

CODE    ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\fat\i386\fatboot.asm ===
Page ,132
TITLE BOOT      SECTOR 1 OF TRACK 0 - BOOT LOADER
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;   Rev 1.0 ChrisP, AaronR and others.  2.0 format boot
;
;   Rev 3.0 MarkZ   PC/AT enhancements
;                   2.50 in label
;   Rev 3.1 MarkZ   3.1 in label due to vagaries of SYSing to IBM drive D's
;                   This resulted in the BPB being off by 1.  So we now trust
;                   2.0 and 3.1 boot sectors and disbelieve 3.0.
;
;   Rev 3.2 LeeAc   Modify layout of extended BPB for >32M support
;                   Move PHYDRV to 3rd byte from end of sector
;                   so that it won't have to be moved again
;                   FORMAT and SYS count on PHYDRV being in a known location
;
;   Rev 3.3 D.C.L.  Changed Sec 9 EOT field from 15 to 18. May 29, 1986.
;
;   Rev 3.31 MarkT  The COUNT value has a bogus check (JBE????) to determine
;                   if we've loaded in all the sectors of IBMBIO. This will
;                   cause too big of a load if the sectors per track is high
;                   enough, causing either a stack overflow or the boot code
;                   to be overwritten.
;
;   Rev 4.00 J. K.  For DOS 4.00 Modified to handle the extended BPB, and
;                   32 bit sector number calculation to enable the primary
;                   partition be started beyond 32 MB boundary.
;
;   Rev 7.0 JeffPar Loads WINBOOT.SYS from anywhere in the root of the boot
;                   drive.  WINBOOT.SYS must be an EXE with exactly 1 sector
;                   of header information, followed by a series of binary
;                   images imbedded in the EXE, as follows:
;
;                    1. WINLOAD module (ORGed at 200h, loaded at 70:200h)
;                    2. IO.SYS module
;                    3. MSDOS.SYS module
;
;                   The WINLOAD module should fit within WINLOAD_SIZE sectors,
;                   which includes 1 sector for the EXE header, so the code
;                   and data for the WINLOAD bootstrap should fit in 3 sectors.
;
;   Rev 7.1 ScottQ  removed Winboot.sys stuff, add support for extended int 13
;           MSliger bootable partitions implemented by scanning the MBR.
;
;   Rev 8.0 ScottQ  re-implement winboot.sys dual-boot as JO.SYS dual boot
;           MSliger
;
; The ROM in the IBM PC starts the boot process by performing a hardware
; initialization and a verification of all external devices.  If all goes
; well, it will then load from the boot drive the sector from track 0, head 0,
; sector 1.  This sector is placed at physical address 07C00h.  The initial
; registers are presumably set up as follows:  CS=DS=ES=SS=0, IP=7C00h, and
; SP=0400h.  But all we rely on is the BIOS being loaded at linear 07C00h.
;
; If IO.SYS is not found, an error message is displayed and the user is
; prompted to insert another disk.  If there is a disk error during the
; process, a message is displayed and things are halted.
;
; At the beginning of the boot sector, there is a table which describes the
; MSDOS structure of the media.  This is equivalent to the BPB with some
; additional information describing the physical layout of the driver (heads,
; tracks, sectors)
;
;==============================================================================
;REALLY OLD REVISION HISTORY which has no meaning but hey its nostalgic
;AN000 - New for DOS Version 4.00 - J.K.
;AC000 - Changed for DOS Version 4.00 - J.K.
;AN00x - PTM number for DOS Version 4.00 - J.K.
;==============================================================================
;AN001; d52 Make the fixed positioned variable "CURHD" to be local.  7/6/87 J.K.
;AN002; d48 Change head settle at boot time.                         7/7/87 J.K.
;AN003; P1820 New message SKL file                                 10/20/87 J.K.
;AN004; D304 New structrue of Boot record for OS2.                 11/09/87 J.K.
;AN005; Changed version to 5.0                                     03/08/90 E.A.
;AN006; Changed to remove MSLOAD in first cluster restriction      04/23/90 J.H.
;==============================================================================

        .xlist
        include bpb.inc
        include bootsec.inc
        include dirent.inc
        ;include version.inc
        .list

; ==========================================================================

ORIGIN          EQU     7C00H           ; Origin of bootstrap LOADER
BIO_SEG         EQU     2000H           ; Destination segment of ntldr
BIO_OFFSET      EQU     0               ; Offset of ntldr
SECTOR_SIZE     EQU     512             ; Sector size in bytes
DIR_ENTRY_SIZE  EQU     SIZE DIR_ENTRY  ; Size of directory entry in bytes
DSK_PARMS       EQU     1EH*4           ; POINTER TO DRIVE PARMS
SEC9            EQU     522h            ; ADDRESS OF NEW DRIVE PARM TABLE

ROM_DISKRD      EQU     2
ROM_DISKRDX     EQU     42h

; ==========================================================================

;
; This little set of directives establishes the address
; where we'll jump to once the first sector of ntldr has been
; loaded. The first 3 bytes of that sector are used for non-FAT
; filesystems, so we must skip over them.
;
SEGBIOS SEGMENT AT BIO_SEG

        ORG     3
NTLOAD  LABEL   BYTE

SEGBIOS ENDS

; ==========================================================================

        ; Data storage between temp. stack and start of boot sector

pReadClustersO  EQU     -16
pReadClustersS  EQU     -14
pReadSectorsO   EQU     -12
pReadSectorsS   EQU     -10
SectorBase      EQU     -8

DataSecL        EQU     -4      ; absolute sector # of first sector in data area
DataSecH        EQU     -2

; ==========================================================================

CODE    SEGMENT
        ASSUME  CS:CODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
        ORG     ORIGIN


        Public  $START
$START  Label   byte

        jmp     short Main
PartitionType:                  ;the in-memory copy of this will leave
        nop                     ;the partition type in this NOP's place
                                ;so IO.SYS can tell if it needs x13

PartitionTypeOffset = (offset PartitionType - offset $START)

; ==========================================================================

        ; Start of BPB area of the boot record

OsName          DB      "MSWIN"
OsVersion       DB      "4.1"           ; Windows version number

CoreBpb         label   byte
BytesPerSector  DW      SECTOR_SIZE     ; Size of a physical sector
SecsPerClust    DB      8               ; Sectors per allocation unit
ReservedSecs    DW      1               ; Number of reserved sectors
NumFats         DB      2               ; Number of fats
NumDirEntries   DW      512             ; Number of direc entries
TotalSectors    DW      4*17*305-1      ; Number of sectors - number of hidden
                                        ; sectors (0 when 32 bit sector number)
MediaByte       DB      0F8H            ; MediaByte byte
NumFatSecs      DW      8               ; Number of fat sectors
SecPerTrack     DW      17              ; Sectors per track
NumHeads        DW      4               ; Number of drive heads

HiddenSecs      DD      1               ; Number of hidden sectors
BigTotalSecs    DD      0               ; 32 bit version of number of sectors

        .errnz  ($-BytesPerSector) NE SIZE BPB

BootDrv         DB      80h
CurrentHead     DB      0h              ; Current Head
ExtBootSig      DB      41
SerialNum       DD      0
VolumeLabel     DB      'NO NAME    '
FatId           DB      'FAT12   '

        .errnz  ($-$START) NE SIZE BOOTSEC

; =========================================================================

;
;   First thing is to reset the stack to a better and more known
;   place. The ROM may change, but we'd like to get the stack
;   in the correct place.
;
Main:
        xor     CX,CX
        mov     SS,CX                   ;Work in stack just below this routine
        mov     SP,ORIGIN+pReadClustersO
        ASSUME  SS:CODE

        mov     ds,cx
        assume  DS:CODE

;
; Set up es for sector reads
;
        mov     ax,BIO_SEG
        mov     es,ax
        ASSUME  ES:NOTHING

        cld
        mov     BP,ORIGIN

;   The system is now prepared for us to begin reading.

;   First we read the master boot record (MBR) if this is a
;   harddisk so we can get our partion type.  Types E and C
;   need extended int13 calls.

        cmp     [BP].bsDriveNumber,cl   ;assert cl == 0 from above
        jnl     failed                  ;dont check for MBR on floppies!

        mov     ax,cx                   ;read sector zero
        cwd

        call    DoReadOne               ;note! assume cx==0 for DoReadOne
        jc      failed
        sub     bx,(42h - 12 +4)        ;bx comes back point it end of sector,
                                        ;we want hidden sector field of first
                                        ;partition entry
.386
        mov     eax,dword ptr HiddenSecs;get the hidden sectors for us
scan:
        cmp     eax,dword ptr es:[bx]   ;is it the same as this partition entry?
.286
        mov     dl,byte ptr es:[bx-4]   ;put the entry's type in dl

        jne     short dontgotit         ;its our partition, go write it down
        or      dl,2                    ;turn C's into E's
        mov     [bp+2],dl               ;put our partition type at byte 2's nop
dontgotit:
        add     bl,10h                  ; 8CA - 8DA - 8EA - 8FA - 90A : carry
        jnc     short scan              ; we scan 4 partition entries

failed:
                                        ;if we failed, leave nop alone; we
                                        ;will use old int13 and so will IO.SYS
        xor      cx,cx                  ;later code needs CX to still be zero

.286

;   Next, determine logical sector numbers of the start of the
;   directory and the start of the data area.
;

DirRead:
        mov     AL,[BP].bsBPB.BPB_NumberOfFATs  ; Determine sector dir starts on (NumFats)
        cbw                                     ;

        mul     [BP].bsBPB.BPB_SectorsPerFAT    ; DX:AX (NumFatSecs)
        add     AX,[BP].bsBPB.BPB_HiddenSectors ; (HiddenSecs)
        adc     DX,[BP].bsBPB.BPB_HiddenSectorsHigh
        add     AX,[BP].bsBPB.BPB_ReservedSectors;(ReservedSecs)
        adc     DX,CX
;
;   DX:AX = NumFats * NumFatSecs + ReservedSecs + cSecHid
;
        mov     SI,[BP].bsBPB.BPB_RootEntries
        pusha

        mov     [BP].DataSecL,AX
        mov     [BP].DataSecH,DX


        mov     AX,DIR_ENTRY_SIZE       ; bytes per directory entry
        mul     SI                      ; convert to bytes in directory (NumDirEntries)

        mov     BX,[BP].bsBPB.BPB_BytesPerSector; add in sector size
        add     AX,BX
        dec     AX                      ; decrement so that we round up
        div     BX                      ; convert to sector number
        add     [BP].DataSecL,AX        ; Start sector # of Data area
        adc     [BP].DataSecH,CX        ;
        popa

DirSector:
        mov     DI,BIO_OFFSET           ; address in DI for comparisons

        call    DoReadOne               ;NOTE assumes CX==0!


DiskErrorJump:
        jc      DiskError               ; if errors try to recover

DirEntry:
        cmp     byte ptr es:[di],ch     ; empty directory entry?
        je      MissingFile             ; yes, that's the end
        pusha
        mov     cl,11
        mov     si,offset BootFilename

        repz    cmpsb                   ; see if the same
        popa

        jz      DoLoad                  ; if so, continue booting

        dec     SI                      ; decrement # root entries
        jz      MissingFile             ; hmmm, file doesn't exist in root
next_entry:
        add     DI,DIR_ENTRY_SIZE

        cmp     DI,BX                   ; exhausted this root dir sector yet?
        jb      DirEntry                ; no, check next entry
        jmp     DirSector               ; yes, check next sector

MissingFile:
        mov     al,byte ptr [MSGOFF_NOSYS] ; point to no system file message

;
; There has been some recoverable error. Display a message
; and wait for a keystroke. Al is the offset - 256 of the
; message within the boot sector. So we first calculate
; the real segment-based offset to the message and stick it in si
; so lodsb will work later.
;
DisplayError:
        .ERRNZ  ORIGIN MOD 256

        mov     ah,(ORIGIN / 256) + 1
        mov     si,ax

DisplayError1:
        lodsb                           ; get next character
        cbw                             ; make 00->0000, FF->FFFF
        inc     ax                      ; end of sub-message?  (0xFF?)
        jz      DisplayWait             ;   if so, get tail
        dec     ax                      ; end of message?  (0x00?)
        jz      WaitForKey              ;   if so, get key

        mov     AH,14                   ; write character & attribute
        mov     BX,7                    ; attribute (white char on black)
        int     10h                     ; print the character
        jmp     short DisplayError1

DisplayWait:
        mov     al,byte ptr [MSGOFF_COMMON]
        jmp     short DisplayError

DiskError:
        mov     al,byte ptr [MSGOFF_IOERROR]
        jmp     short DisplayError

WaitForKey:
                                        ;we know ax is zero, thats how we got here
        int     16h                     ; get character from keyboard
        int     19h                     ; Continue in loop till good disk
;
;   We now load the first sector of ntldr.
;
;   All we have to do is multiply the file's starting cluster
;   (whose directory entry is at ES:DI-11) by sectors per cluster and
;   add that to the disk's starting data sector.
;
;   Note that after we're read the sector into 2000:0 the directory sector
;   will get blown away. So we need to save the starting cluster number.
;
DoLoad:

        mov     dx,es:[di].dir_first    ; dx = ntldr starting cluster
        push    dx                      ; save for later
        mov     al,1                    ; 1 sector
        mov     bx,BIO_OFFSET           ; into 2000:0
        call    NtldrClusterRead
        jc      DiskError

; =========================================================================
;
; NTLDR requires the following input conditions:
;
;       BX == starting cluster number of NTLDR
;       DL == int13 unit number of boot drive
;       DS:SI -> BPB
;       DS:DI -> arg structure
;
; =========================================================================

        pop     bx                      ; starting cluster number
        mov     dl,[bp].bsDriveNumber
        mov     si,OFFSET CoreBpb
        mov     di,sp                   ; we should be at TOS now

        mov     [bp].pReadClustersO,OFFSET NtldrClusterRead
        mov     [bp].pReadSectorsO,OFFSET NtldrSectorRead
        mov     cx,ds
        mov     [bp].pReadClustersS,cx
        mov     [bp].pReadSectorsS,cx

;
; We do something nasty. Ntldr is expecting the readcluster and readsector
; routines to do a far return. Since ntldr is now the only guy who will be
; reading via those routines, we patch the return instruction from a near
; return to a far return.
;
        mov     byte ptr DoReadExit,0cbh      ; retf
        jmp     FAR PTR NTLOAD          ; Crank up NTLDR

;
; Sector read routine required by ntldr
;
;       Read al sectors into es:bx starting from sector SectorBase
;               (SectorBase is logical sector # from start of partition)
;
NtldrSectorRead label near
.386
        movzx   cx,al
        mov     eax,[bp].SectorBase
        add     eax,dword ptr [bp].bsBPB.BPB_HiddenSectors
        mov     edx,eax
        shr     edx,16
.286
        jmp short DoReadMore

;
; Cluster read routine required by ntldr
;
;       Read al sectors into es:bx starting from cluster dx
;
NtldrClusterRead label near
.386
        movzx   cx,al                   ; cx = # of sectors to read
.286
        dec     dx
        dec     dx                      ; adjust for reserved clusters 0 and 1
        mov     al,[BP].bsBPB.BPB_SectorsPerCluster
        xor     ah,ah
        mul     dx                      ; DX:AX = starting sector number
        add     ax,[bp].DataSecL        ; adjust for FATs, root dir, boot sec.
        adc     dx,[bp].DataSecH
DoPush:
        jmp short DoReadMore

; =========================================================================
;
; Read disk sector(s).
;
;   Inputs:  DX:AX == logical sector #
;            CL == # sectors (CH == 0)
;            ES:BX == transfer address
;
;   Outputs: DX:AX next logical sector #
;            CX == 0 (assuming no errors)
;            ES:BX -> byte after last byte of read
;            Carry set if error, else clear if success
;
;   Preserves: BP, SI, DI
;
;   New Notes: This function will now use extended int 13 if
;            necessary. The next note is correct for standard int 13
;
;   Notes:   Reads sectors one at a time in case they straddle a
;            track boundary.  Performs full 32-bit division on the
;            first decomposition (of logical sector into track+sector)
;            but not on the second (of track into cylinder+head),
;            since (A) we don't have room for it, and (B) the results
;            of that division must yield a quotient < 1024 anyway, because
;            the CHS-style INT 13h interface can't deal with cylinders
;            larger than that.
;
; =========================================================================

switchx13:      ;setup for x13 read, and switch to old if not needed

        push    dx                      ;
        push    ax                      ; block number
        push    es
        push    bx                      ; transfer address
        push    1                       ; count of one, because we're looping
        push    16                      ; packet size

        xchg    AX,CX                   ; AX -> CX

        mov     ax,[bp].bsBPB.BPB_SectorsPerTrack  ; get sectors/track
        xchg    ax,si                   ; save for divides

        xchg    AX,DX                   ; DX -> AX
        xor     DX,DX                   ; divide 0:AX
        div     si                      ; AX = high word of track

        xchg    AX,CX                   ; save AX in CX and restore old AX
        div     si                      ; CX:AX = track, DX = sector

        inc     DX                      ; sector is 1-based
        xchg    CX,DX                   ; CX = sector, DX = high word of track
        div     [BP].bsBPB.BPB_Heads    ; AX = cylinder, DX = head

        mov     DH,DL                   ; head # < 255

        mov     CH,AL                   ; CH = cyl #
        ror     AH,2                    ; move bits 8,9 of AX to bits 14,15
                                        ; (the rest has to be zero, since
                                        ;  cyls cannot be more than 10 bits)
        or      CL,AH                   ; CL = sector # plus high bits of cyl #
        mov     AX,(ROM_DISKRD SHL 8)+1 ; disk read 1 sector

        cmp     byte ptr [bp].PartitionTypeOffset,0Eh ;set flag to be tested
        jne     short doio              ;use extended calls if E (or C)
        mov     ah,ROM_DISKRDX          ;x13, we're ready to rock
        mov     si,sp                   ; DS:SI -> X13 packet
doio:
        mov     dl,[bp].bsDriveNumber   ; DL == drive #
        int     13h

        popa                            ; throw away packet on stack (8 words)
        popa                            ; get real registers back

        jc      DoReadExit              ; disk error

        inc     ax
        jnz     DoReadNext
        inc     dx

DoReadNext:                             ; Adjust buffer address
        add     BX,[BP].bsBPB.BPB_BytesPerSector

        dec     cx
        jnz     DoReadMore
        clc

DoReadExit:

        ret

DoReadOne:
        inc     cx              ;assumes cx == 0! to set to 1 sector read
DoRead:
        mov     bx,BIO_OFFSET
DoReadMore:

        pusha
.386
        db      66h                     ;push a dword of 0 on the stack
        push    0                       ;hand coded for 386
.286
        jmp     switchx13

;
; This string can go anywhere. NT and NT Setup are not picky about it.
;
        Public  BootFilename

BootFilename db "NTLDR      ";

;
; Message table.
;
; We put English messages here as a placeholder only, so that in case
; anyone uses bootfat.h without patching new messages in, things will
; still be correct (in English, but at least functional).
;
        include msgstub.inc

;
; Now build a table with the low byte of the offset to each message.
; Code that patches the boot sector messages updates this table.
;
        .errnz ($-$START) GT (SECTOR_SIZE-5)
        ORG     ORIGIN + SECTOR_SIZE - 5
MSGOFF_NOSYS:
        db OFFSET (MSG_NOSYS - ORIGIN) - 256
MSGOFF_IOERROR:
        db OFFSET (MSG_IOERROR - ORIGIN) - 256
MSGOFF_COMMON:
        db OFFSET (MSG_COMMON - ORIGIN) - 256

        .errnz ($-$START) NE (SECTOR_SIZE-2)
        DB      55h,0AAh                ; Boot sector signature


CODE    ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\fat\i386\fat32bt.asm ===
Page ,132
TITLE BOOT      SECTOR 1 OF TRACK 0 - BOOT LOADER
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;   Rev 1.0 ChrisP, AaronR and others.  2.0 format boot
;
;   Rev 3.0 MarkZ   PC/AT enhancements
;                   2.50 in label
;   Rev 3.1 MarkZ   3.1 in label due to vagaries of SYSing to IBM drive D's
;                   This resulted in the BPB being off by 1.  So we now trust
;                   2.0 and 3.1 boot sectors and disbelieve 3.0.
;
;   Rev 3.2 LeeAc   Modify layout of extended BPB for >32M support
;                   Move PHYDRV to 3rd byte from end of sector
;                   so that it won't have to be moved again
;                   FORMAT and SYS count on PHYDRV being in a known location
;
;   Rev 3.3 D.C.L.  Changed Sec 9 EOT field from 15 to 18. May 29, 1986.
;
;   Rev 3.31 MarkT  The COUNT value has a bogus check (JBE????) to determine
;                   if we've loaded in all the sectors of IBMBIO. This will
;                   cause too big of a load if the sectors per track is high
;                   enough, causing either a stack overflow or the boot code
;                   to be overwritten.
;
;   Rev 4.00 J. K.  For DOS 4.00 Modified to handle the extended BPB, and
;                   32 bit sector number calculation to enable the primary
;                   partition be started beyond 32 MB boundary.
;
;   Rev 7.0 JeffPar Loads WINBOOT.SYS from anywhere in the root of the boot
;                   drive.  WINBOOT.SYS must be an EXE with exactly 1 sector
;                   of header information, followed by a series of binary
;                   images imbedded in the EXE, as follows:
;
;                    1. WINLOAD module (ORGed at 200h, loaded at 70:200h)
;                    2. IO.SYS module
;                    3. MSDOS.SYS module
;
;                   The WINLOAD module should fit within WINLOAD_SIZE sectors,
;                   which includes 1 sector for the EXE header, so the code
;                   and data for the WINLOAD bootstrap should fit in 3 sectors.
;
;   Rev 7.1 ARR     Multi sector version of boot record for booting off 32-bit
;                   BigFAT media.
;
; The ROM in the IBM PC starts the boot process by performing a hardware
; initialization and a verification of all external devices.  If all goes
; well, it will then load from the boot drive the sector from track 0, head 0,
; sector 1.  This sector is placed at physical address 07C00h.  The initial
; registers are presumably set up as follows:  CS=DS=ES=SS=0, IP=7C00h, and
; SP=0400h.  But all we rely on is the BIOS being loaded at linear 07C00h.
;
; If WINBOOT.SYS is not found, an error message is displayed and the user is
; prompted to insert another disk.  If there is a disk error during the
; process, a message is displayed and things are halted.
;
; At the beginning of the boot sector, there is a table which describes the
; MSDOS structure of the media.  This is equivalent to the BPB with some
; additional information describing the physical layout of the driver (heads,
; tracks, sectors)
;
;==============================================================================
;REVISION HISTORY:
;AN000 - New for DOS Version 4.00 - J.K.
;AC000 - Changed for DOS Version 4.00 - J.K.
;AN00x - PTM number for DOS Version 4.00 - J.K.
;==============================================================================
;AN001; d52 Make the fixed positioned variable "CURHD" to be local.  7/6/87 J.K.
;AN002; d48 Change head settle at boot time.                         7/7/87 J.K.
;AN003; P1820 New message SKL file                                 10/20/87 J.K.
;AN004; D304 New structrue of Boot record for OS2.                 11/09/87 J.K.
;AN005; Changed version to 5.0                                     03/08/90 E.A.
;AN006; Changed to remove MSLOAD in first cluster restriction      04/23/90 J.H.
;==============================================================================

        .xlist
        include bpb.inc
        include bootsec.inc
        include dirent.inc
        ;include version.inc
        .list

; ==========================================================================
ORIGIN          EQU     7C00H           ; Origin of bootstrap LOADER

BIO_SEG         EQU     2000H           ; Destination segment of BIOS
BIO_OFFSET      EQU     0000H           ; Offset of bios

SECTOR_SIZE     EQU     512             ; Sector size in bytes
DIR_ENTRY_SIZE  EQU     SIZE DIR_ENTRY  ; Size of directory entry in bytes

ROM_DISKRD      EQU     2

SIZEBIGBOOTINSEC EQU    3

; ==========================================================================

SEGBIOS SEGMENT AT BIO_SEG

        ; Define the destination segment of the BIOS, including the
        ; initialization label
        ORG     BIO_OFFSET
WINLOAD LABEL   BYTE

SEGBIOS ENDS

; ==========================================================================

        ; Local (on stack) Data storage between temp stack and start of
        ; boot sector

CurrBuffFatSecL EQU     -12
CurrBuffFatSecH EQU     -10
Int13Sectors    EQU     -8
DataSecL        EQU     -4
DataSecH        EQU     -2

; ==========================================================================

CODE    SEGMENT
        ASSUME  CS:CODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
        ORG     ORIGIN


        Public  $START
$START  Label   byte

        jmp     short Main
GotXint13:
        nop                             ; used to store xint13 flag

GotXint13Offset = (offset GotXint13 - offset $START)

; ==========================================================================

        ; Start of BPB area of the boot record

OsName          DB      "MSWIN"
OsVersion       DB      "4.1"           ; Windows version number

BytesPerSector  DW      SECTOR_SIZE     ; Size of a physical sector
SecsPerClust    DB      2               ; Sectors per allocation unit
ReservedSecs    DW      8               ; Number of reserved sectors
NumFats         DB      1               ; Number of fats
NumDirEntries   DW      1024            ; Number of direc entries
TotalSectors    DW      0               ; Number of sectors - number of hidden
                                        ; sectors (0 when 32 bit sector number)
MediaByte       DB      0F8H            ; MediaByte byte
NumFatSecs      DW      0               ; Number of fat sectors (0 when 32 bit)
SecPerTrack     DW      17              ; Sectors per track
NumHeads        DW      4               ; Number of drive heads

HiddenSecs      DD      1               ; Number of hidden sectors
BigTotalSecs    DD      00200000h       ; 32 bit version of number of sectors
BigNumFatSecs   DD      00001FE0h       ; 32 bit version of number of FAT sectors
ExtFlags        DW      0
BPBReserved1    DW      0
RootStrtClus    DD      0
FSInfoSec       dw      ((FSInfoSecSig - $START) / SECTOR_SIZE)
BkUpBootSec     dw      MBR_BOOTFAILBACKUP
BPBReserved2    DD      3 DUP (0)
        .errnz  ($-BytesPerSector) NE SIZE BIGFATBPB

BootDrv         DB      80h
CurrentHead     DB      0h              ; Current Head
ExtBootSig      DB      41
SerialNum       DD      0
VolumeLabel     DB      'NO NAME    '
FatId           DB      'FAT32   '

        .errnz  ($-$START) NE SIZE BIGFATBOOTSEC


; =========================================================================

;
;   First thing is to reset the stack to a better and more known
;   place. The ROM may change, but we'd like to get the stack
;   in the correct place.
;
Main:
        xor     CX,CX
        mov     SS,CX                   ;Work in stack just below this routine
        mov     SP,ORIGIN+CurrBuffFatSecL
        mov     es,cx
        mov     ds,cx                   ; DS = ES = SS = 0
        ASSUME  DS:CODE,ES:CODE,SS:CODE
        mov     BP,ORIGIN

;
; Determine the number of sectors addressable via
; conventional int13. If we can't get drive params for some reason
; then something is very wrong -- we'll try to force the caller
; to use conventional int13 by maxing out the sector count.
;
        mov     [bp].GotXint13Offset,cl ; no xint13 yet
        mov     dl,[bp].bgbsDriveNumber ; int13 unit number
        mov     ah,8                    ; get drive params
        int     13h                     ; call BIOS
        jnc     @f                      ; no error, procede
        mov     cx,-1                   ; strange case, fake registers to force
        mov     dh,cl                   ; use of standard int13 (set all vals to max)
@@:
.386
        movzx   eax,dh                  ; eax = max head # (0-255)
        inc     ax                      ; eax = heads (1-256)
        movzx   edx,cl                  ; edx = sectors per track + cyl bits
        and     dl,3fh                  ; edx = sectors per track (1-63)
        mul     dx                      ; eax = sectors per cylinder, edx = 0
        xchg    cl,ch
        shr     ch,6                    ; cx = max cylinder # (0-1023)
        inc     cx                      ; cx = cylinders (1-1024)
        movzx   ecx,cx                  ; ecx = cylinders (1-1024)
        mul     ecx                     ; eax = sectors visible via int13, edx = 0
        mov     [bp].Int13Sectors,eax   ; save # sectors addressable via int13
.8086

;
; The MBR (or boot ROM) only reads one boot sector. Thus the first order
; of business is to read the rest of ourself in by reading the second
; boot sector of the 2-sector boot record.
;
; The second sector in the NT case is at sector 12. This preserves
; the bootsect.dos logic and eliminates a special case for fat32.
;
ReadBoot:
        cmp     [BP].bgbsBPB.oldBPB.BPB_SectorsPerFAT,0 ; FAT32 BPB?
        jne     short NoSysMsg          ; No, invalid, messed up
        cmp     [BP].bgbsBPB.BGBPB_FS_Version,FAT32_Curr_FS_Version
        ja      short NoSysMsg          ; boot code too old for this volume
.386
        mov     eax,dword ptr [BP].bgbsBPB.oldBPB.BPB_HiddenSectors
        add     eax,12                  ; read in the second boot sector
.8086
        mov     BX,ORIGIN + (SECTOR_SIZE * 2)
        mov     cx,1

        call    DoRead                  ; doesn't return if err

        jmp     DirRead                 ; no error, continue boot in sector 2

DiskError:
        mov     al,byte ptr [MSGOFF_IOERROR]

;
; Al is the offset - 256 of the message within the boot sector.
; So we first calculate the real segment-based offset to the message
; and stick it in si so lodsb will work later.
;
DisplayError:
        .ERRNZ  ORIGIN MOD 256

        mov     ah,(ORIGIN / 256) + 1
        mov     si,ax

DisplayError1:
        lodsb                           ; get next character
        test    AL,AL                   ; end of message?
        jz      WaitForKey              ; yes
        cmp     AL,0FFh                 ; end of sub-message?
        je      DisplayWait             ; yes, switch to final message now
        mov     AH,14                   ; write character & attribute
        mov     BX,7                    ; attribute (white char on black)
        int     10h                     ; print the character
        jmp     short DisplayError1

DisplayWait:
        mov     al,byte ptr [MSGOFF_COMMON]
        jmp     short DisplayError

NoSysMsg:
        mov     al,byte ptr [MSGOFF_NOSYS] ; point to no system file message
        jmp     short DisplayError

WaitForKey:
        cbw                             ;warning assumes al is zero!
        int     16h                     ; get character from keyboard
        int     19h                     ; Continue in loop till good disk

; =========================================================================
;
; Read disk sector(s). This routine cannot transfer more than 64K!
;
;   Inputs:  EAX == physical sector #
;            CL == # sectors (CH == 0)
;            ES:BX == transfer address
;
;   Outputs: EAX next physical sector #
;            CX == 0
;            ES:BX -> byte after last byte of read
;            Does not return if error
;
;   Reads sectors, switching to extended int13 if necessary and
;   available. The note below is for the conventional int13 case.
;
;   Notes:   Reads sectors one at a time in case they straddle a
;            track boundary.  Performs full 32-bit division on the
;            first decomposition (of logical sector into track+sector)
;            but not on the second (of track into cylinder+head),
;            since (A) we don't have room for it, and (B) the results
;            of that division must yield a quotient < 1024 anyway, because
;            the CHS-style INT 13h interface can't deal with cylinders
;            larger than that.
;
; =========================================================================

DoRead:
.386
        pushad

;
; Determine if the sector we're about to read is available via
; conventional int13.
;
        cmp     eax,[bp].Int13Sectors   ; determine if standard int13 is ok
        jb      stdint13

;
; Need extended int13. First set up parameter packet on stack.
; Then, if we don't know whether xint13 is available for the drive yet,
; find out. If not, error out since we know we can't read the sector
; we need.
;
        db      66h                     ; hand-coded 32-bit push of 8-bit immediate
        push    0                       ; high 32 bits of sector #
        push    eax                     ; low 32 bits of sector #
        push    es
        push    bx                      ; transfer address
        push    dword ptr 10010h        ; transfer 1 sector, packet size = 16

        cmp     byte ptr [bp].GotXint13Offset,0  ; have xint13?
        jnz     xint13ok                ; yes, do the read
        mov     ah,41h
        mov     bx,055aah
        mov     dl,[bp].bgbsDriveNumber
        int     13h                     ; check availability
        jc      xint13err               ; error from int13 means no xint13
        cmp     bx,0aa55h               ; absence of sig means no xint13
        jne     xint13err
        test    cl,1                    ; bit 0 off means no xint13
        jz      xint13err
        inc     byte ptr [bp].GotXint13Offset ; have xint13, remember for next time

xint13ok:
        mov     ah,42h                  ; extended read
        mov     dl,[bp].bgbsDriveNumber ; dl = int13 unit #
        mov     si,sp                   ; ds:si -> param packet
        int     13h                     ; perform the read
        db 0b0h                         ; HACK: avoid stc by making next
                                        ; byte part of mov al,xx instruction
xint13err:
        stc                             ; this instruction MUST follow previous byte!
        pop     eax                     ; throw away param packet without
        pop     eax                     ; clobbering carry flag
        pop     eax
        pop     eax

        jmp     short did_read

stdint13:
;
; Read via conventional int13
;
        xor     edx,edx                 ; edx:eax = absolute sector number
        movzx   ecx,[bp].bgbsBPB.oldBPB.BPB_SectorsPerTrack  ; ecx = sectors per track
        div     ecx                     ; eax = track, edx = sector within track (0-62)
        inc     dl                      ; dl = sector within track (1-63)
        mov     cl,dl                   ; cl = sector within track
        mov     edx,eax
        shr     edx,16                  ; dx:ax = track
        div     [bp].bgbsBPB.oldBPB.BPB_Heads ; ax = cylinder (0-1023), dx = head (0-255)
        xchg    dl,dh                   ; dh = head
        mov     dl,[bp].bgbsDriveNumber ; dl = int13 unit #
        mov     ch,al                   ; ch = bits 0-7 of cylinder
        shl     ah,6
        or      cl,ah                   ; bits 6-7 of cl = bits 8-9 of cylinder
        mov     ax,201h                 ; read 1 sector
        int     13h

did_read:
        popad

        jc      DiskError

        add     bx,SECTOR_SIZE          ; advance transfer address
        inc     eax                     ; next sector number
        dec     cx                      ; loop instruction is out of range,
        jnz     DoRead                  ; have to do it manually
        ret
.8086

        Public  WinBoot                 ; System boot file (11 bytes)

WinBoot DB      "NTLDR      "

;
; Message table.
;
; We put English messages here as a placeholder only, so that in case
; anyone uses bootf32.h without patching new messages in, things will
; still be correct (in English, but at least functional).
;

        .errnz ($-$START) GT 1ACH
        ORG     ORIGIN + 01ACH          ; shift message to coincide with that in FAT
                                        ; this will help driver to think the MBR
                                        ; is empty when dealing with FAT32 superfloppy
        include msgstub.inc

;
; Now build a table with the low byte of the offset to each message.
; Code that patches the boot sector messages updates this table.
;
        .errnz ($-$START) GT (SECTOR_SIZE-7)
        ORG     ORIGIN + SECTOR_SIZE - 7
MSGOFF_NOSYS:
        db OFFSET (MSG_NOSYS - ORIGIN) - 256
MSGOFF_IOERROR:
        db OFFSET (MSG_IOERROR - ORIGIN) - 256
MSGOFF_COMMON:
        db OFFSET (MSG_COMMON - ORIGIN) - 256

        ORG     ORIGIN + (SECTOR_SIZE - 4)
        DD      BOOTSECTRAILSIG         ; Boot sector signature (4 bytes)


        .errnz  ($-$START) NE SECTOR_SIZE
SecndSecStart label byte
;
; The second boot sector contains nothing but data. This sector is re-written
; by MS-DOS with a fairly high frequency due to changes made to the fsinfo
; structure. We don't want the actual boot code to get accidentally corrupted.
;
FSInfoSecSig label byte
        .errnz  ($-SecndSecStart) NE 0
        DD      SECONDBOOTSECSIG

        db      (SECTOR_SIZE - ($-FSInfoSecSig) - 4 - (SIZE BIGFATBOOTFSINFO)) DUP (0)

        .errnz  ($-SecndSecStart) NE (OFFSETFSINFOFRMSECSTRT)

fsinfo  BIGFATBOOTFSINFO <FSINFOSIG,0FFFFFFFFh,000000002h>

        .errnz  ($-FSInfoSecSig) NE OFFSETTRLSIG
        DD      BOOTSECTRAILSIG         ; Boot sector signature (4 bytes)

        .errnz  ($-$START) NE (SECTOR_SIZE * 2)
StrtThirdBootSector     LABEL BYTE

DirRead:
.386
        movzx   eax,[BP].bgbsBPB.oldBPB.BPB_NumberOfFATs  ; Determine sector dir starts on (NumFats)
        mov     ecx,dword ptr [BP].bgbsBPB.BGBPB_BigSectorsPerFat
        mul     ecx                     ; EAX = (NumFatSecs)
        add     EAX,dword ptr [BP].bgbsBPB.oldBPB.BPB_HiddenSectors ; (HiddenSecs)
        movzx   edx,[BP].bgbsBPB.oldBPB.BPB_ReservedSectors         ;(ReservedSecs)
        add     EAX,EDX
;
;   EAX = NumFats * NumFatSecs + ReservedSecs + cSecHid
;         (first physical sector of cluster area)
;
        mov     dword ptr [BP].DataSecL,EAX
        mov     dword ptr [BP].CurrBuffFatSecL,0FFFFFFFFh
DirReRead:
        mov     eax,dword ptr [BP].bgbsBPB.BGBPB_RootDirStrtClus
        cmp     eax,2
        jb      NoSysMsg
        cmp     eax,00FFFFFF8h
        jae     NoSysMsg

; EAX is starting cluster of root directory

DirCluster:
        push    eax                     ; save starting cluster number
        sub     eax,2                   ; Convert to 0 based cluster #
        movzx   EBX,[BP].bgbsBPB.oldBPB.BPB_SectorsPerCluster
        mov     si,bx                   ; Sector count to SI for sector loop
        mul     EBX                     ; compute logical sector in EAX
        add     EAX,dword ptr [BP].DataSecL ; Add data start bias
DirSector:
        mov     BX,ORIGIN+(SIZEBIGBOOTINSEC*SECTOR_SIZE)
        mov     DI,BX                   ; save address in DI for comparisons
        mov     CX,1
        call    DoRead                  ; doesn't return if error
                                        ; relies on return cx=0
DirEntry:
        cmp     byte ptr [di],ch        ; empty, NUL directory entry?
        je      short MissingFile       ; yes, that's the end

        mov     CL,11
        push    SI
        mov     si,offset WinBoot
        repz    cmpsb                   ; see if the same
        pop     SI
        jz      short DoLoad            ; if so, continue booting

        add     DI,CX                   ; Finish advance to end of name field
        add     DI,DIR_ENTRY_SIZE-11    ; Next dir entry
        cmp     DI,BX                   ; exhausted this root dir sector yet?
        jb      DirEntry                ; no, check next entry
        dec     SI                      ; decrement # dir sectors
        jnz     DirSector               ; More dir sectors in this cluster
        pop     eax                     ; recover current root dir cluster
        call    GetNextFatEntry
        jc      DirCluster              ; Do next Root dir cluster
MissingFile:
        add     sp,4                    ; Discard EAX saved on stack
        jmp     NoSysMsg

CurrentSegment  dw      BIO_SEG
;
;   We now load NTLDR
;
;   All we have to do is multiply the file's starting cluster
;   (whose directory entry is at DS:DI-11) by sectors per cluster and
;   add that to the disk's starting data sector. We read ntldr into
;   2000:0, and begin execution there.
;
DoLoad:

        add     sp,4                    ; Discard DX:AX saved on stack above
        mov     si,[DI-11].DIR_FIRSTHIGH
        mov     di,[DI-11].DIR_FIRST    ; SI:DI = NTLDR starting cluster
        mov     ax,si
        shl     eax,16
        mov     ax,di                   ; EAX = NTLDR starting cluster
        cmp     eax,2                   ; valid cluster #?
        jb      NoSysMsg                ; NO!
        cmp     eax,00FFFFFF8h
        jae     NoSysMsg                ; NO!

ReadAcluster:
        push    eax                     ; save cluster number
        sub     eax,2                   ; Subtract first 2 reserved clusters
        movzx   ecx,[BP].bgbsBPB.oldBPB.BPB_SectorsPerCluster ; ECX = Sectors per cluster (SecsPerClust)
        mul     ecx                     ; EAX = logical sector #

        add     eax,dword ptr [BP].DataSecL  ; EAX = physical sector #

        mov     bx,BIO_OFFSET
        push    es
        mov     es,CurrentSegment       ; ES:BX = destination for read
        call    DoRead                  ; read all sectors in cluster, doesn't return if error
        pop     es
        pop     eax                     ; recover current 0-based cluster#
        shr     bx,4                    ; updated offset -> paragraphs
        add     CurrentSegment,bx       ; update segment for next read

        call    GetNextFatEntry         ; get 2-based successor cluster in EAX
        jnc     StartItUp               ; if end of cluster chain reached
        jc      ReadACluster            ; keep sucking up clusters
.8086

;
; NTLDR requires the following input conditions:
;
;       DL = boot drive #
;

StartItUp:
        mov     DL,[BP].bgbsDriveNumber
        jmp     FAR PTR WINLOAD         ; CRANK UP THE WINDOWS NT BOOT LOADER

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   GetNextFatEntry
;
;   Given the last cluster found, this will return the next cluster
;   of a chain of clusters. If the last cluster is (ffff)(f)ff8 - (ffff)(f)fff,
;   then the final cluster has been loaded.
;
;   INPUTS:
;       EAX = CurrentCluster (0 based cluster #)
;
;   OUTPUTS:
;       EAX = Next cluster (2 based cluster #)
;       Carry CLEAR if all done, SET if not
;
;   USES:
;   EAX,EBX,ECX,EDX,ESI,DI es
;

GetNextFatEntry PROC NEAR

        ; NOTE For following... FAT32 cluster numbers are 28 bits not 32,
        ; so we know the following multiply (shl DX:AX by 2) will never
        ; overflow into carry.
.386
        shl     eax,2
        call    GetFatSector
        mov     EAX,dword ptr ES:[DI+BX]
        and     EAX,0FFFFFFFh           ; Mask to valid FAT32 cluster # bits
        cmp     EAX,00FFFFFF8h          ; carry CLEAR if all done, SET if not
.8086
        ret

GetNextFatEntry ENDP


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   GetFatSector
;
;   Read the corresponding FAT sector into the second boot sector
;
;   INPUTS:
;       EAX == offset (from FAT entry 0) of entry to find
;
;   OUTPUTS:
;       ES:DI+BX -> corresponding FAT entry in the FAT sector
;
;   USES:
;       BX,EAX,ECX,EDX,DI
;

GetFatSector    PROC    NEAR
.386
        mov     DI,ORIGIN + SECTOR_SIZE
        movzx   ECX,[BP].bgbsBPB.oldBPB.BPB_BytesPerSector
        xor     edx,edx
        div     ECX                     ; EAX = Sector number, (E)DX = Offset
        cmp     EAX,dword ptr [BP].CurrBuffFatSecL  ; The same fat sector?
        je      short SetRet            ; Don't need to read it again
        mov     dword ptr [BP].CurrBuffFatSecL,EAX
        add     EAX,dword ptr [BP].bgbsBPB.oldBPB.BPB_HiddenSectors
        movzx   ecx,[BP].bgbsBPB.oldBPB.BPB_ReservedSectors
        add     eax,ecx                 ; Point at 1st (0th) FAT
        movzx   ebx,[BP].bgbsBPB.BGBPB_ExtFlags
        and     bx,BGBPB_F_ACTIVEFATMSK
        jz      short GotFatSec
        cmp     bl,[BP].bgbsBPB.oldBPB.BPB_NumberOfFATs
        jae     NoSysMsg
        push    dx                      ; Save offset of cluster in the FAT sec
        mov     ecx,eax                 ; Save FAT sector # in 0th FAT
        mov     eax,dword ptr [BP].bgbsBPB.BGBPB_BigSectorsPerFat
        mul     ebx                     ; EAX = Sector offset to active FAT
                                        ;       from 0th FAT
        add     eax,ecx
        pop     dx
GotFatSec:
        push    dx                      ; Save offset of cluster in the FAT sec
        mov     BX,DI
        mov     CX,1
        call    DoRead                  ; do the disk read, doesn't return if error
        pop     dx
SetRet:
        mov     BX,DX                   ; set BX to the offset of the cluster
.8086
        ret

GetFatSector    ENDP

        db      ((SECTOR_SIZE - ($-StrtThirdBootSector)) - 4) DUP (0)

        .errnz  ($-StrtThirdBootSector) NE OFFSETTRLSIG
        DD      BOOTSECTRAILSIG         ; Boot sector signature (4 bytes)

        .errnz  ($-$START) NE (SECTOR_SIZE * 3)
        .errnz  SIZEBIGBOOTINSEC NE 3

$BigEnd label byte

CODE    ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\nlspatch\patchbc.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    Patchbc.c

Abstract:

    Implementation for a module that knows how to patch translated
    messages into arrays that constitute Windows NT file system boot code.

Author:

    Ted Miller (tedm) 6 May 1997

Revision History:

--*/


/*

    Various modules in the Windows NT need to lay the mbr or file system
    boot records, such as format, setup, etc. Boot code for fat, fat32,
    ntfs, and the mbr is each built into a corresponding header file
    in sdk\inc. Each header file has an array of bytes that constitute
    the boot code itself. The code has no text in it, but instead has some
    placeholders for text that needs to be patched in at run-time by
    users of those header files. This allows localization of the
    boot messages without recompiles.

    As built, each boot code array has a table in a known place that
    indicates where in the array the messages are supposed to start.
    The boot code expects to look there to find the offset of any
    message it needs.

    For the file system boot code, the message offset table is located
    immediately before the 2-byte 55aa sig (for fat) or the 4-byte 000055aa
    sig (for fat32 and ntfs).

    Fat/Fat32 share 3 messages, whose offsets are expected to be in the
    following order in the offset table:

        NTLDR is missing
        Disk error
        Press any key to restart

    NTFS has 4 messages, whose offsets are expected to be in the following
    order in the offset table:

        A disk read error occurred
        NTLDR is missing
        NTLDR is compressed
        Press Ctrl+Alt+Del to restart

    For the master boot code, the message offset table is immediately before
    the NTFT signature and has 3 messages (thus it starts at offset 0x1b5).
    The offsets are expected to be in the following order:

        Invalid partition table
        Error loading operating system
        Missing operating system

    Finally note that to allow one-byte values to be stored in the message
    offset tables we store the offset - 256.

*/

#include <nt.h>
#include <patchbc.h>
#include <string.h>

BOOLEAN
DoPatchMessagesIntoBootCode(
    IN OUT PUCHAR   BootCode,
    IN     unsigned TableOffset,
    IN     BOOLEAN  WantCrLfs,
    IN     BOOLEAN  WantTerminating255,
    IN     unsigned MessageCount,
    ...
    )
{
    va_list arglist;
    unsigned Offset;
    unsigned i;
    LPCSTR text;

    va_start(arglist,MessageCount);

    Offset = (unsigned)BootCode[TableOffset] + 256;

    for(i=0; i<MessageCount; i++) {

        text = va_arg(arglist,LPCSTR);

        BootCode[TableOffset+i] = (UCHAR)(Offset - 256);

        if(WantCrLfs) {
            BootCode[Offset++] = 13;
            BootCode[Offset++] = 10;
        }

        strcpy(BootCode+Offset,text);
        Offset += strlen(text);

        if(i == (MessageCount-1)) {
            //
            // Last message gets special treatment.
            //
            if(WantCrLfs) {
                BootCode[Offset++] = 13;
                BootCode[Offset++] = 10;
            }
            BootCode[Offset++] = 0;
        } else {
            //
            // Not last message.
            //
            if(WantTerminating255) {
                BootCode[Offset++] = 255;
            } else {
                BootCode[Offset++] = 0;
            }
        }
    }

    va_end(arglist);

    return(Offset <= TableOffset);
}


BOOLEAN
PatchMessagesIntoFatBootCode(
    IN OUT PUCHAR  BootCode,
    IN     BOOLEAN IsFat32,
    IN     LPCSTR  MsgNtldrMissing,
    IN     LPCSTR  MsgDiskError,
    IN     LPCSTR  MsgPressKey
    )
{
    BOOLEAN b;

    b = DoPatchMessagesIntoBootCode(
            BootCode,
            IsFat32 ? 505 : 507,
            TRUE,
            TRUE,
            3,
            MsgNtldrMissing,
            MsgDiskError,
            MsgPressKey
            );

    return(b);
}


BOOLEAN
PatchMessagesIntoNtfsBootCode(
    IN OUT PUCHAR  BootCode,
    IN     LPCSTR  MsgNtldrMissing,
    IN     LPCSTR  MsgNtldrCompressed,
    IN     LPCSTR  MsgDiskError,
    IN     LPCSTR  MsgPressKey
    )
{
    BOOLEAN b;

    b = DoPatchMessagesIntoBootCode(
            BootCode,
            504,
            TRUE,
            FALSE,
            4,
            MsgDiskError,
            MsgNtldrMissing,
            MsgNtldrCompressed,
            MsgPressKey
            );

    return(b);
}


BOOLEAN
PatchMessagesIntoMasterBootCode(
    IN OUT PUCHAR  BootCode,
    IN     LPCSTR  MsgInvalidTable,
    IN     LPCSTR  MsgIoError,
    IN     LPCSTR  MsgMissingOs
    )
{
    BOOLEAN b;

    b = DoPatchMessagesIntoBootCode(
            BootCode,
            0x1b5,
            FALSE,
            FALSE,
            3,
            MsgInvalidTable,
            MsgIoError,
            MsgMissingOs
            );

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\mbr\i386\x86mboot.asm ===
page    ,132
;
;   Microsoft Confidential
;   Copyright (C) Microsoft Corporation 1983-1997
;   All Rights Reserved.
;
;
;   This is the standard boot record that will be shipped on all hard disks.
;   It contains:
;
;   1.  Code to load (and give control to) the active boot record for 1 of 4
;       possible operating systems.
;
;   2.  A partition table at the end of the boot record, followed by the
;       required signature.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

VOLBOOT_ORG             EQU 7c00h
SIZE_SECTOR             EQU 512

;
; Partition table entry structure and other related stuff
;
Part_Active             EQU 0
Part_StartHead          EQU 1
Part_StartSector        EQU 2
Part_StartCylinder      EQU 3
Part_Type               EQU 4
Part_EndHead            EQU 5
Part_EndSector          EQU 6
Part_EndCylinder        EQU 7
Part_AbsoluteSector     EQU 8
Part_AbsoluteSectorH    EQU 10
Part_SectorCount        EQU 12
Part_SectorCountH       EQU 14

SIZE_PART_TAB_ENT       EQU 16
NUM_PART_TAB_ENTS       EQU 4

PART_TAB_OFF            EQU (SIZE_SECTOR - 2 - (SIZE_PART_TAB_ENT * NUM_PART_TAB_ENTS))
MBR_NT_OFFSET           EQU (PART_TAB_OFF - 6)
MBR_MSG_TABLE_OFFSET    EQU (PART_TAB_OFF - 9)

;
; Space we use for temp storage, beyond the end of
; the active partition table entry, and thus safe.
;
UsingBackup             EQU SIZE_PART_TAB_ENT

;
; Partition types
;
PART_IFS                EQU 07h
PART_FAT32              EQU 0bh
PART_FAT32_XINT13       EQU 0ch
PART_XINT13             EQU 0eh

;
; Filesystem and pbr stuff
;
BOOTSECTRAILSIGH        EQU 0aa55h
FAT32_BACKUP            EQU 6



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

RELOCATION_ORG  EQU     600h

READ_RETRY_CNT  EQU     5


_data   segment public
        assume  cs:_data,ds:nothing,es:nothing,ss:nothing

        org     100h
start100 label near
        org     RELOCATION_ORG

;   Move ourselves so that we can load the partition boot record from
;   the active partition at 0:VOLBOOT_ORG without trashing our own code.
;
;   WARNING: We are not executing at 0:RELOCATION_ORG until the far
;   immediate jump, below.  This basically means beware of OFFSETs of
;   any labels until we get there.  Until then, we're still executing at
;   0:VOLBOOT_ORG.

reloc_delta = 1Bh

start:
        xor     ax,ax
        mov     ss,ax
        mov     sp,VOLBOOT_ORG          ; new stack at 0:7c00
        sti
        push    ax
        pop     es
        assume  es:_data
        push    ax
        pop     ds
        assume  ds:_data
        cld
        mov     si,VOLBOOT_ORG + reloc_delta
        mov     di,RELOCATION_ORG + reloc_delta
        push    ax
        push    di
        mov     cx,SIZE_SECTOR - reloc_delta
        rep     movsb                   ; relocate to 0:0600
        retf

;   We are now RELOCATED and are now executing at 0:RELOCATION_ORG.
;
;   Find the active partition.  Once we find it, we also make sure that the
;   remaining partitions are INACTIVE, too.

        .errnz  reloc_delta NE $-start  ; make sure reloc_delta is correct

        mov     bp,offset tab           ; partition table
        mov     cl,NUM_PART_TAB_ENTS    ; number of table entries (CH==0)

active_loop:
        cmp     [bp].Part_Active,ch     ; is this the active entry?
        jl      check_inactive          ; yes
        jne     display_bad             ; no, it must be "00" or "8x"

        add     bp,SIZE_PART_TAB_ENT    ; yes, go to next entry
        loop    active_loop

        int     18h                     ; no active entries - go to ROM BASIC

;   Now make sure the remaining partitions are INACTIVE.
check_inactive:
        mov     si,bp                   ; si = active entry
inactive_loop:
        add     si,SIZE_PART_TAB_ENT    ; point si to next entry
        dec     cx                      ; # entries left
        jz      StartLoad               ; all entries look ok, start load
        cmp     [si],ch                 ; all remaining entries should be zero
        je      inactive_loop           ; this one is ok

display_bad:
        mov     al,byte ptr [m1]        ; partition table is bad

display_msg:
;
; Al is the offset-256 of the message text. Adjust and
; stick in si so lodsb below will work.
;
        .ERRNZ  RELOCATION_ORG MOD 256
        mov     ah,(RELOCATION_ORG / 256) + 1
        mov     si,ax

display_msg1:
        lodsb                           ; get a message character
@@:     cmp     al,0                    ; end of string?
        je      @b                      ; yes, loop infinitely
        mov     bx,7
        mov     ah,14
        int     10h                     ; and display it
        jmp     display_msg1            ; do the entire message

;
; Now attempt to read the sector.
;
; We store a data byte indicating whether this is the backup
; sector, at the byte just beyond the end of the partition table entry.
; We know there's nothing there we care about any more, so this
; is harmless.
;
; BP is the address of the active partition entry.
; AX and CX are currently zero.
;
StartLoad:
        mov     byte ptr [bp].UsingBackup,cl    ; not backup sector
        call    ReadSector
        jnc     CheckPbr
trybackup:
        inc     byte ptr [bp].UsingBackup

;
; Switch to backup sector for NTFS and FAT32.
;
if 0
;
; (tedm) for NTFS this code is actually worthless since other code,
; such as ntldr and the filesystem itself won't all do the right thing.
; For example the filesystem won't recognize the volume if sector 0
; can be read but is bad.
;
        cmp     byte ptr [bp].Part_Type,PART_IFS
        jne     tryfat32
;
; We assume here that type 7 is NTFS.
; Back up to end of partition by using the end CHS and subtracting 1
; from the sector #. There is no check for the case where we underflow
; and wrap a head -- it is assumed that partitions are at least head-aligned.
; There is also no check for the case where the start sector and sector count
; are both maxdword and so adding them overflows.
;
        mov     al,[bp].Part_EndHead    ; make start head same as end head
        mov     [bp].Part_StartHead,al
        mov     ax,[bp].Part_EndSector  ; ax = end sector and cylinder
        dec     al                      ; start sector = end sector minus 1
        mov     [bp].Part_StartSector,ax
        mov     ax,[bp].Part_SectorCount
        mov     dx,[bp].Part_SectorCountH
        add     [bp].Part_AbsoluteSector,ax
        adc     [bp].Part_AbsoluteSectorH,dx
        sub     word ptr [bp].Part_AbsoluteSector,1
        sbb     word ptr [bp].Part_AbsoluteSectorH,0
        jmp     short RestartLoad
endif

tryfat32:
        cmp     byte ptr [bp].Part_Type,PART_FAT32
        je      fat32backup
        cmp     byte ptr [bp].Part_Type,PART_FAT32_XINT13
        je      fat32backup
        mov     al,byte ptr [m2]        ; unknown fs, so no backup sector
        jne     display_msg

fat32backup:
;
; There is no check for the case where adding to the sector value
; in the start CHS overflows and wraps to the next head. It is assumed
; that partitions are at least head-aligned and that hard drives have
; at least FAT32_BACKUP+1 sectors per track.
;
        add     byte ptr [bp].Part_StartSector,FAT32_BACKUP
        add     word ptr [bp].Part_AbsoluteSector,FAT32_BACKUP
        adc     word ptr [bp].Part_AbsoluteSectorH,0

RestartLoad:
        call    ReadSector
        jnc     CheckPbr
        mov     al,byte ptr [m2]        ; can't load, we're done.
        jmp     short display_msg

CheckPbr:
        cmp     word ptr ds:[VOLBOOT_ORG + SIZE_SECTOR - 2],BOOTSECTRAILSIGH
        je      done
;
; Not a valid filesystem boot sector. Switch to backup if this
; isn't already the backup.
;
        cmp     byte ptr [bp].UsingBackup,0
        je      trybackup
        mov     al,byte ptr [m3]
        jmp     short display_msg

;
; Jump to PBR. We pass a pointer to the table entry that booted us
; in bp. If we used the backup boot sector, then that table entry
; will have been altered, but neither NTFS not FAT32 use the pointer
; in BP, and no other fs type will have been loaded via the backup
; boot sector, so this isn't an issue.
;
done:
        mov     di,sp                   ; DI -> start of PBR
        push    ds                      ; prepare for RETF, which is
        push    di                      ; smaller than JMP 0:VOLBOOT_ORG
        mov     si,bp                   ; pass boot partition table entry address
        retf                            ; start executing PBR


ReadSector proc near

        mov     di,5                    ; retry count
;
; Calculate the maximum sector # that can be addressed via
; conventional int13. Note that the max # of heads is 256
; and the maximum # of sectors per track is 63. Thus the maximum
; # of sectors per cylinder is something less than a 16-bit quantity.
;
        mov     dl,[bp].Part_Active     ;
        mov     ah,8                    ; get disk params
        int     13h
        jc      nonxint13               ; strange case, fall back to std int13

        mov     al,cl
        and     al,3fh                  ; al = # of sectors per track
        cbw                             ; ax = # of sectors per track (ah=0)

        mov     bl,dh                   ; bl = max head # (0-based)
        mov     bh,ah                   ; bh = 0
        inc     bx                      ; bx = # of heads

        mul     bx                      ; ax = sectors per cylinder, dx = 0

        mov     dx,cx                   ; dx = cylinder/sector in int13 format
        xchg    dl,dh                   ; dl = low 8 bits of cylinder
        mov     cl,6
        shr     dh,cl                   ; dx = max cylinder # (0-based)
        inc     dx                      ; dx = # cylinders

        mul     dx                      ; dx:ax = # sectors visible via int13

;
; If the sector # we're reading is less than the than number of
; addressable sectors, use conventional int 13
;
        cmp     [bp].Part_AbsoluteSectorH,dx
        ja      xint13
        jb      nonxint13
        cmp     [bp].Part_AbsoluteSector,ax
        jae     xint13

nonxint13:
        mov     ax,201h
        mov     bx,VOLBOOT_ORG          ; es:bx = read address (0:7c00)
        mov     cx,[bp].Part_StartSector
        mov     dx,[bp].Part_Active
        int     13h
        jnc     endread
        dec     di                      ; retry? (does not affect carry)
        jz      endread                 ; carry set for return
        xor     ah,ah                   ; ah = 0 (reset disk system)
        mov     dl,[bp].Part_Active     ; dl = int13 unit #
        int     13h
        jmp     short nonxint13

xint13:
;
; We want to avoid calling xint13 unless we know it's available
; since we don't trust all BIOSes to not hang if we attempt an xint13 read.
; If xint13 isn't supported we won't be able to boot, but at least
; we'll give an error message instead of just a black screen.
;
        mov     dl,[bp].Part_Active     ; unit #
.286
        pusha
        mov     bx,055AAh               ; signature
        mov     ah,41h                  ; perform X13 interrogation
        int     13h                     ;
        jc      endread1                ; call failed
        cmp     bx,0AA55h               ; did our signature get flipped?
        jne     endread1                ; no
        test    cl,1                    ; is there X13 support?
        jz      endread1                ; no
        popa

doxint13:
        pusha                           ; save regs
        push    0                       ; push dword of 0
        push    0                       ; (high 32 bits of sector #)
        push    [bp].Part_AbsoluteSectorH
        push    [bp].Part_AbsoluteSector ; low 32 bits of sector #
        push    0
        push    VOLBOOT_ORG             ; transfer address
        push    1                       ; 1 sector
        push    16                      ; packet size and reserved byte

        mov     ah,42h                  ; extended read
        mov     si,sp                   ; ds:si points to parameter packet
        int     13h                     ; dl already set from above

        popa                            ; pop param packet off stack
        popa                            ; get real registers back
        jnc     endread
        dec     di                      ; retry? (does not affect carry)
        jz      endread                 ; carry set for return
        xor     ah,ah                   ; ah = 0 (reset disk system)
        mov     dl,[bp].Part_Active     ; dl = int13 unit #
        int     13h
        jmp     short doxint13

endread1:
        popa
        stc                             ; this is the error case
.8086
endread:
        ret
ReadSector endp

;
; Message table.
;
; We put English messages here as a placeholder only, so that in case
; anyone uses bootmbr.h without patching new messages in, things will
; still be correct (in English, but at least functional).
;
_m1:    db      "Invalid partition table",0
_m2:    db      "Error loading operating system",0
_m3:    db      "Missing operating system",0

;
; Now build a table with the low byte of the offset to each message.
; Code that patches the boot sector messages updates this table.
;
        .errnz  ($ - start) GT MBR_MSG_TABLE_OFFSET
        org     RELOCATION_ORG + MBR_MSG_TABLE_OFFSET

m1:     db (OFFSET _m1 - RELOCATION_ORG) - 256
m2:     db (OFFSET _m2 - RELOCATION_ORG) - 256
m3:     db (OFFSET _m3 - RELOCATION_ORG) - 256


        .errnz  ($ - start) NE MBR_NT_OFFSET
        dd      0                       ; NT disk administrator signature
        dw      0

        .errnz  ($ - start) GT PART_TAB_OFF

        org     RELOCATION_ORG + PART_TAB_OFF
tab:                            ;partition table
        dw      0,0             ;partition 1 begin
        dw      0,0             ;partition 1 end
        dw      0,0             ;partition 1 relative sector (low, high parts)
        dw      0,0             ;partition 1 # of sectors (low, high parts)
        dw      0,0             ;partition 2 begin
        dw      0,0             ;partition 2 end
        dw      0,0             ;partition 2 relative sector
        dw      0,0             ;partition 2 # of sectors
        dw      0,0             ;partition 3 begin
        dw      0,0             ;partition 3 end
        dw      0,0             ;partition 3 relative sector
        dw      0,0             ;partition 3 # of sectors
        dw      0,0             ;partition 4 begin
        dw      0,0             ;partition 4 end
        dw      0,0             ;partition 4 relative sector
        dw      0,0             ;partition 4 # of sectors

    .errnz  ($ - tab)   NE (SIZE_PART_TAB_ENT * NUM_PART_TAB_ENTS)
    .errnz  ($ - start) NE (SIZE_SECTOR - 2)

signa   dw      BOOTSECTRAILSIGH ;signature

    .errnz  ($ - start) NE SIZE_SECTOR

_data   ends

        end start100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\mbr\i386\bootmbr.h ===
#define X86BOOTCODE_SIZE 512


unsigned char x86BootCode[] = {
51,192,142,208,188,0,124,251,80,7,80,31,252,190,27,124,
191,27,6,80,87,185,229,1,243,164,203,189,190,7,177,4,
56,110,0,124,9,117,19,131,197,16,226,244,205,24,139,245,
131,198,16,73,116,25,56,44,116,246,160,181,7,180,7,139,
240,172,60,0,116,252,187,7,0,180,14,205,16,235,242,136,
78,16,232,70,0,115,42,254,70,16,128,126,4,11,116,11,
128,126,4,12,116,5,160,182,7,117,210,128,70,2,6,131,
70,8,6,131,86,10,0,232,33,0,115,5,160,182,7,235,
188,129,62,254,125,85,170,116,11,128,126,16,0,116,200,160,
183,7,235,169,139,252,30,87,139,245,203,191,5,0,138,86,
0,180,8,205,19,114,35,138,193,36,63,152,138,222,138,252,
67,247,227,139,209,134,214,177,6,210,238,66,247,226,57,86,
10,119,35,114,5,57,70,8,115,28,184,1,2,187,0,124,
139,78,2,139,86,0,205,19,115,81,79,116,78,50,228,138,
86,0,205,19,235,228,138,86,0,96,187,170,85,180,65,205,
19,114,54,129,251,85,170,117,48,246,193,1,116,43,97,96,
106,0,106,0,255,118,10,255,118,8,106,0,104,0,124,106,
1,106,16,180,66,139,244,205,19,97,97,115,14,79,116,11,
50,228,138,86,0,205,19,235,214,97,249,195,73,110,118,97,
108,105,100,32,112,97,114,116,105,116,105,111,110,32,116,97,
98,108,101,0,69,114,114,111,114,32,108,111,97,100,105,110,
103,32,111,112,101,114,97,116,105,110,103,32,115,121,115,116,
101,109,0,77,105,115,115,105,110,103,32,111,112,101,114,97,
116,105,110,103,32,115,121,115,116,101,109,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,44,68,99,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,170
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\ntfs\i386\ntfs.inc ===
;
;   Copyright (c) 1991  Microsoft Corporation
;
;   Module Name:
;
;       ntfs.inc
;
;   Abstract:
;
;       This module contains declarations for the NTFS on-disk
;       structures needed by the boot code.
;
;   Author:
;
;       Bill McJohn (billmc) 12-May-1992
;
MASTER_FILE_TABLE_NUMBER         EQU 0d
MASTER_FILE_TABLE2_NUMBER        EQU 1d
LOG_FILE_NUMBER                  EQU 2d
VOLUME_DASD_NUMBER               EQU 3d
ATTRIBUTE_DEF_TABLE_NUMBER       EQU 4d
ROOT_FILE_NAME_INDEX_NUMBER      EQU 5d
BIT_MAP_FILE_NUMBER              EQU 6d
BOOT_FILE_NUMBER                 EQU 7d
BAD_CLUSTER_FILE_NUMBER          EQU 8d
QUOTA_TABLE_NUMBER               EQU 9d
UPCASE_TABLE_NUMBER              EQU 10d

$STANDARD_INFORMATION            EQU 010h
$ATTRIBUTE_LIST                  EQU 020h
$FILE_NAME                       EQU 030h
$VOLUME_VERSION                  EQU 040h
$SECURITY_DESCRIPTOR             EQU 050h
$VOLUME_NAME                     EQU 060h
$VOLUME_INFORMATION              EQU 070h
$DATA                            EQU 080h
$INDEX_ROOT                      EQU 090h
$INDEX_ALLOCATION                EQU 0A0h
$BITMAP                          EQU 0B0h
$SYMBOLIC_LINK                   EQU 0C0h
$EA_INFORMATION                  EQU 0D0h
$EA_DATA                         EQU 0E0h
$FIRST_USER_DEFINED_ATTRIBUTE    EQU 0100h
$END                             EQU 0FFFFFFFFh

SEQUENCE_NUMBER_STRIDE           EQU 512d


LARGE_INTEGER struc
    LowPart     dd ?;
    HighPart    dd ?;
LARGE_INTEGER ends;

MFT_SEGMENT_REFERENCE struc
    REF_LowPart     dd ?;
    REF_HighPart    dw ?;
    REF_SeqNo       dw ?;
MFT_SEGMENT_REFERENCE ends;

MULTI_SECTOR_HEADER struc
    MSH_Signature       dd ?;
    MSH_UpdateArrayOfs  dw ?;
    MSH_UpdateArraySize dw ?;
MULTI_SECTOR_HEADER ends;

FILE_RECORD_SEGMENT struc
    FRS_Header          db (size MULTI_SECTOR_HEADER) dup (?);
    FRS_Lsn             db (size LARGE_INTEGER) dup (?);
    FRS_SequenceNumber  dw ?;
    FRS_ReferenceCount  dw ?;
    FRS_FirstAttribute  dw ?;
    FRS_Flags           dw ?;
    FRS_FirstFreeByte   dd ?;
    FRS_BytesAvailable  dd ?;
    FRS_BaseFRS         db (size MFT_SEGMENT_REFERENCE) dup (?);
    FRS_NextInstance    dw ?;
FILE_RECORD_SEGMENT ends;

FILE_RECORD_SEGMENT_IN_USE       EQU 0001h
FILE_FILE_NAME_INDEX_PRESENT     EQU 0002h

ATTRIBUTE_RECORD struc
    ATTR_TypeCode       dd ?;
    ATTR_RecordLength   dd ?;
    ATTR_FormCode       db ?;
    ATTR_NameLength     db ?;
    ATTR_NameOffset     dw ?;
    ATTR_Flags          dw ?;
    ATTR_Instance       dw ?;
    ATTR_FormUnion      db ?;
ATTRIBUTE_RECORD ends

RESIDENT_ATTRIBUTE_FORM struc
    RES_ValueLength     dd ?;
    RES_ValueOffset     dw ?;
    RES_ResidentFlags   db ?;
    RES_Reserved        db ?;
RESIDENT_ATTRIBUTE_FORM ends

NONRESIDENT_ATTRIBUTE_FORM struc
    NONRES_LowestVcn            db (size LARGE_INTEGER) dup (?);
    NONRES_HighestVcn           db (size LARGE_INTEGER) dup (?);
    NONRES_MappingPairOffset    dw ?;
    NONRES_Reserved             dw 3 dup (?);
    NONRES_AllocatedLength      db (size LARGE_INTEGER) dup (?);
    NONRES_FileSize             db (size LARGE_INTEGER) dup (?);
    NONRES_ValidDataLength      db (size LARGE_INTEGER) dup (?);
NONRESIDENT_ATTRIBUTE_FORM ends

;   Attribute Form Codes

RESIDENT_FORM       EQU 0
NONRESIDENT_FORM    EQU 1

;   Attribute Record Flag Values

ATTRIBUTE_FLAG_COMPRESSION_MASK  EQU 00FFh


;   Attribute list entry structure:
;
ATTRIBUTE_LIST_ENTRY struc
    ATTRLIST_TypeCode           dd  ?;
    ATTRLIST_Length             dw  ?;
    ATTRLIST_NameLength         db  ?;
    ATTRLIST_NameOffset         db  ?;
    ATTRLIST_LowestVcn          db (size LARGE_INTEGER) dup (?);
    ATTRLIST_SegmentReference   db (size MFT_SEGMENT_REFERENCE) dup (?);
    ATTRLIST_Instance           dw  ?;
    ATTRLIST_Name               dw  ?;
ATTRIBUTE_LIST_ENTRY ends


FAT_DIRENT_ATTR_READ_ONLY        EQU 01h
FAT_DIRENT_ATTR_HIDDEN           EQU 02h
FAT_DIRENT_ATTR_SYSTEM           EQU 04h
FAT_DIRENT_ATTR_VOLUME_ID        EQU 08h
FAT_DIRENT_ATTR_ARCHIVE          EQU 20h
FAT_DIRENT_ATTR_DEVICE           EQU 40h

DUPLICATED_INFORMATION struc
    DUPINFO_CreationTime            db (size LARGE_INTEGER) dup (?);
    DUPINFO_LastModificationTime    db (size LARGE_INTEGER) dup (?);
    DUPINFO_LastChangeTime          db (size LARGE_INTEGER) dup (?);
    DUPINFO_LastAccessTime          db (size LARGE_INTEGER) dup (?);
    DUPINFO_AllocatedLength         db (size LARGE_INTEGER) dup (?);
    DUPINFO_FileSize                db (size LARGE_INTEGER) dup (?);
    DUPINFO_FileAttributes          dd ?;
    DUPINFO_PackedEaSize            dw ?;
DUPLICATED_INFORMATION ends


FILE_NAME struc
    FN_ParentDirectory              db (size MFT_SEGMENT_REFERENCE) dup (?);
    FN_Info                         db (size DUPLICATED_INFORMATION) dup (?);
    FN_Pad                          dw ?;
    FN_FileNameLength               db ?;   Length in chars
    FN_Flags                        db ?;
    FN_FileName                     dw ?;   First char of name.
FILE_NAME ends

FILE_NAME_NTFS  EQU     1
FILE_NAME_DOS   EQU     2
FILE_NAME_LINK  EQU     4


INDEX_HEADER struc

    IH_FirstIndexEntry      dd ?;
    IH_FirstFreeByte        dd ?;
    IH_BytesAvailable       dd ?;
    IH_Flags                db ?;   INDEX_xxx flags
    IH_Reserved             db 3 dup (?);
INDEX_HEADER ends

; INDEX_xxx flags

INDEX_NODE  EQU 1


INDEX_ROOT struc

    IR_IndexedAttributeType dd ?;
    IR_CollationRule        dd ?;
    IR_BytesPerBuffer       dd ?;
    IR_ClustersPerBuffer    db ?;
    IR_Reserved             db 3 dup (?);
    IR_IndexHeader	    db (size INDEX_HEADER) dup (?);
INDEX_ROOT ends;

INDEX_ALLOCATION_BUFFER struc

    IB_Header               db (size MULTI_SECTOR_HEADER) dup (?);
    IB_Lsn                  db (size LARGE_INTEGER) dup (?);
    IB_ThisVcn              db (size LARGE_INTEGER) dup (?);
    IB_IndexHeader          db (size INDEX_HEADER) dup (?);
INDEX_ALLOCATION_BUFFER ends;


INDEX_ENTRY struc

    IE_FileReference    db (size MFT_SEGMENT_REFERENCE) dup (?);
    IE_Length           dw ?;
    IE_AttributeLength  dw ?;
    IE_Flags            dw ?;
    IE_Reserved         dw ?;
    IE_Value            db ?;
INDEX_ENTRY ends;


;   INDEX_ENTRY_xxx flags
;
INDEX_ENTRY_NODE    EQU 1
INDEX_ENTRY_END     EQU 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\ntfs\i386\bootntfs.h ===
#define NTFSBOOTCODE_SIZE 8192


unsigned char NtfsBootCode[] = {
235,82,144,78,84,70,83,32,32,32,32,0,2,1,0,0,
0,0,0,0,0,248,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,250,51,192,142,208,188,0,124,251,184,192,7,
142,216,232,22,0,184,0,13,142,192,51,219,198,6,14,0,
16,232,83,0,104,0,13,104,106,2,203,138,22,36,0,180,
8,205,19,115,5,185,255,255,138,241,102,15,182,198,64,102,
15,182,209,128,226,63,247,226,134,205,192,237,6,65,102,15,
183,201,102,247,225,102,163,32,0,195,180,65,187,170,85,138,
22,36,0,205,19,114,15,129,251,85,170,117,9,246,193,1,
116,4,254,6,20,0,195,102,96,30,6,102,161,16,0,102,
3,6,28,0,102,59,6,32,0,15,130,58,0,30,102,106,
0,102,80,6,83,102,104,16,0,1,0,128,62,20,0,0,
15,133,12,0,232,179,255,128,62,20,0,0,15,132,97,0,
180,66,138,22,36,0,22,31,139,244,205,19,102,88,91,7,
102,88,102,88,31,235,45,102,51,210,102,15,183,14,24,0,
102,247,241,254,194,138,202,102,139,208,102,193,234,16,247,54,
26,0,134,214,138,22,36,0,138,232,192,228,6,10,204,184,
1,2,205,19,15,130,25,0,140,192,5,32,0,142,192,102,
255,6,16,0,255,14,14,0,15,133,111,255,7,31,102,97,
195,160,248,1,232,9,0,160,251,1,232,3,0,251,235,254,
180,1,139,240,172,60,0,116,9,180,14,187,7,0,205,16,
235,242,195,13,10,65,32,100,105,115,107,32,114,101,97,100,
32,101,114,114,111,114,32,111,99,99,117,114,114,101,100,0,
13,10,78,84,76,68,82,32,105,115,32,109,105,115,115,105,
110,103,0,13,10,78,84,76,68,82,32,105,115,32,99,111,
109,112,114,101,115,115,101,100,0,13,10,80,114,101,115,115,
32,67,116,114,108,43,65,108,116,43,68,101,108,32,116,111,
32,114,101,115,116,97,114,116,13,10,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,131,160,179,201,0,0,85,170,
5,0,78,0,84,0,76,0,68,0,82,0,4,0,36,0,
73,0,51,0,48,0,0,224,0,0,0,48,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,235,18,144,144,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,140,200,142,216,193,224,
4,250,139,224,251,232,3,254,102,15,183,6,11,0,102,15,
182,30,13,0,102,247,227,102,163,78,2,102,139,14,64,0,
128,249,0,15,143,14,0,246,217,102,184,1,0,0,0,102,
211,224,235,8,144,102,161,78,2,102,247,225,102,163,82,2,
102,15,183,30,11,0,102,51,210,102,247,243,102,163,86,2,
232,13,4,102,139,14,74,2,102,137,14,34,2,102,3,14,
82,2,102,137,14,38,2,102,3,14,82,2,102,137,14,42,
2,102,3,14,82,2,102,137,14,58,2,102,3,14,82,2,
102,137,14,66,2,102,184,144,0,0,0,102,139,14,34,2,
232,236,8,102,11,192,15,132,87,254,102,163,46,2,102,184,
160,0,0,0,102,139,14,38,2,232,211,8,102,163,50,2,
102,184,176,0,0,0,102,139,14,42,2,232,193,8,102,163,
54,2,102,161,46,2,102,11,192,15,132,36,254,103,128,120,
8,0,15,133,27,254,103,102,141,80,16,103,3,66,4,103,
102,15,182,72,12,102,137,14,98,2,103,102,139,72,8,102,
137,14,94,2,102,161,94,2,102,15,183,14,11,0,102,51,
210,102,247,241,102,163,102,2,102,161,66,2,102,3,6,94,
2,102,163,70,2,102,131,62,50,2,0,15,132,25,0,102,
131,62,54,2,0,15,132,200,253,102,139,30,54,2,30,7,
102,139,62,70,2,232,146,1,102,15,183,14,0,2,102,184,
2,2,0,0,232,150,7,102,11,192,15,132,10,9,103,102,
139,0,30,7,102,139,62,58,2,232,206,5,102,161,58,2,
102,187,128,0,0,0,102,185,0,0,0,0,102,186,0,0,
0,0,232,172,0,102,11,192,15,133,62,0,102,185,128,0,
0,0,102,161,58,2,232,89,8,102,11,192,15,132,200,8,
30,7,102,139,62,58,2,232,144,5,102,161,58,2,102,187,
128,0,0,0,102,185,0,0,0,0,102,186,0,0,0,0,
232,110,0,102,11,192,15,132,158,8,103,102,15,183,88,12,
102,129,227,255,0,0,0,15,133,147,8,102,139,216,104,0,
32,7,102,43,255,232,242,0,138,22,36,0,184,232,3,142,
192,141,54,11,0,43,192,104,0,32,80,203,6,30,102,96,
102,139,218,102,15,182,14,13,0,102,247,225,102,163,16,0,
102,139,195,102,247,225,163,14,0,139,223,131,227,15,140,192,
102,193,239,4,3,199,80,7,232,60,252,102,97,144,31,7,
195,103,3,64,20,103,102,131,56,255,15,132,76,0,103,102,
57,24,15,133,51,0,102,11,201,15,133,10,0,103,128,120,
9,0,15,133,35,0,195,103,58,72,9,15,133,26,0,102,
139,240,103,3,112,10,232,89,6,102,81,30,7,102,139,250,
243,167,102,89,15,133,1,0,195,103,102,131,120,4,0,15,
132,7,0,103,102,3,64,4,235,171,102,43,192,195,102,139,
243,232,46,6,103,102,3,0,103,247,64,12,2,0,15,133,
52,0,103,102,141,80,16,103,58,74,64,15,133,24,0,103,
102,141,114,66,232,11,6,102,81,30,7,102,139,251,243,167,
102,89,15,133,1,0,195,103,131,120,8,0,15,132,6,0,
103,3,64,8,235,194,102,51,192,195,103,128,123,8,0,15,
133,28,0,6,30,102,96,103,102,141,83,16,103,102,139,10,
102,139,243,103,3,114,4,243,164,102,97,144,31,7,195,103,
102,141,83,16,103,102,139,74,8,102,65,102,43,192,232,1,
0,195,6,30,102,96,103,128,123,8,1,15,132,3,0,233,
223,251,102,131,249,0,15,133,6,0,102,97,144,31,7,195,
102,83,102,80,102,81,102,87,6,232,115,4,102,139,209,7,
102,95,102,89,102,59,202,15,141,3,0,102,139,209,232,171,
254,102,43,202,102,139,218,102,139,194,102,15,182,22,13,0,
102,247,226,102,15,183,22,11,0,102,247,226,102,3,248,102,
88,102,3,195,102,91,235,170,6,30,102,96,103,128,123,8,
1,15,132,3,0,233,121,251,102,131,249,0,15,133,6,0,
102,97,144,31,7,195,102,83,102,80,102,81,102,87,6,102,
81,102,51,210,102,15,182,14,13,0,102,247,241,102,82,232,
253,3,102,15,182,30,13,0,102,247,227,102,90,102,3,194,
102,80,102,15,182,6,13,0,102,247,225,102,139,208,102,88,
102,89,7,102,95,102,89,102,59,202,15,141,3,0,102,139,
209,102,163,16,0,137,22,14,0,6,30,102,96,139,223,131,
227,15,140,192,102,193,239,4,3,199,80,7,232,104,250,102,
97,144,31,7,102,43,202,102,139,218,102,139,194,102,15,183,
22,11,0,102,247,226,102,3,248,102,88,102,3,195,102,91,
233,101,255,6,30,102,96,38,103,102,15,183,95,4,38,103,
102,15,183,79,6,102,11,201,15,132,197,250,102,3,223,102,
131,195,2,102,129,199,254,1,0,0,102,73,102,11,201,15,
132,23,0,38,103,139,3,38,103,137,7,102,131,195,2,102,
129,199,0,2,0,0,102,73,235,226,102,97,144,31,7,195,
6,30,102,96,102,184,1,0,0,0,102,163,30,2,102,161,
26,2,102,3,6,82,2,102,163,90,2,102,3,6,82,2,
102,163,74,2,102,161,48,0,102,15,182,30,13,0,102,247,
227,102,139,30,74,2,102,137,7,102,163,16,0,131,195,4,
102,161,86,2,102,137,7,163,14,0,131,195,4,102,137,30,
74,2,102,139,30,26,2,30,7,232,155,249,102,139,251,232,
81,255,102,161,26,2,102,187,32,0,0,0,102,185,0,0,
0,0,102,186,0,0,0,0,232,70,253,102,11,192,15,132,
22,1,102,139,216,30,7,102,139,62,22,2,232,219,253,102,
139,30,22,2,102,129,63,128,0,0,0,15,132,235,0,3,
95,4,235,240,102,83,102,139,71,16,102,247,38,86,2,102,
80,102,51,210,102,15,182,30,13,0,102,247,243,102,82,232,
220,0,102,11,192,15,132,200,249,102,139,14,86,2,102,15,
182,30,13,0,102,247,227,102,90,102,3,194,102,139,30,74,
2,102,137,7,131,195,4,102,15,182,6,13,0,102,43,194,
102,59,193,15,134,3,0,102,139,193,102,137,7,102,43,200,
102,90,15,132,117,0,102,3,194,102,80,102,51,210,102,15,
182,30,13,0,102,247,243,102,81,232,130,0,102,89,102,11,
192,15,132,108,249,102,15,182,30,13,0,102,247,227,102,139,
30,74,2,102,139,23,131,195,4,102,3,23,102,59,208,15,
133,21,0,102,15,182,6,13,0,102,59,193,15,134,3,0,
102,139,193,102,1,7,235,165,131,195,4,102,137,30,74,2,
102,137,7,131,195,4,102,15,182,6,13,0,102,59,193,15,
134,3,0,102,139,193,102,137,7,235,130,131,195,4,102,255,
6,30,2,102,137,30,74,2,102,91,3,95,4,102,129,63,
128,0,0,0,15,132,12,255,102,97,144,31,7,195,102,139,
208,102,139,14,30,2,102,139,54,90,2,102,3,54,82,2,
102,82,102,81,102,82,102,139,30,90,2,102,139,62,86,2,
102,139,4,102,163,16,0,131,198,4,102,139,4,163,14,0,
131,198,4,30,7,232,31,248,102,43,248,15,132,8,0,247,
38,11,0,3,216,235,217,102,139,62,90,2,30,7,232,194,
253,102,161,90,2,102,187,128,0,0,0,102,185,0,0,0,
0,102,139,209,232,186,251,102,11,192,15,132,131,248,102,139,
216,102,88,102,86,232,39,1,102,94,102,11,192,15,132,5,
0,102,91,102,91,195,102,89,102,90,226,132,102,51,192,195,
6,30,102,96,102,80,102,81,102,51,210,102,15,182,30,13,
0,102,247,243,102,82,102,87,232,83,255,102,95,102,11,192,
15,132,61,248,102,15,182,30,13,0,102,247,227,102,90,102,
3,194,102,163,16,0,102,89,102,15,182,30,13,0,102,59,
203,15,142,19,0,137,30,14,0,102,43,203,102,88,102,3,
195,102,80,102,81,235,20,144,102,88,102,3,193,102,80,137,
14,14,0,102,185,0,0,0,0,102,81,6,102,87,139,223,
131,227,15,140,192,102,193,239,4,3,199,80,7,232,71,247,
102,95,7,102,3,62,78,2,102,89,102,88,102,131,249,0,
15,143,112,255,102,97,144,31,7,195,6,30,102,96,102,247,
38,86,2,102,139,14,86,2,232,85,255,232,213,252,102,97,
144,31,7,195,6,30,102,96,102,247,38,102,2,102,139,30,
50,2,102,139,14,102,2,30,7,102,139,62,66,2,232,7,
252,232,175,252,102,97,144,31,7,195,102,80,102,83,102,81,
102,139,30,70,2,102,139,200,102,193,232,3,102,131,225,7,
102,3,216,102,184,1,0,0,0,102,211,224,103,132,3,15,
132,4,0,248,235,2,144,249,102,89,102,91,102,88,195,103,
128,123,8,1,15,132,4,0,102,43,192,195,103,102,141,115,
16,103,102,139,86,8,102,59,194,15,135,11,0,103,102,139,
22,102,59,194,15,131,4,0,102,43,192,195,103,3,94,16,
102,43,246,103,128,59,0,15,132,62,0,232,129,0,102,3,
241,232,57,0,102,3,202,102,59,193,15,140,33,0,102,139,
209,102,80,103,102,15,182,11,102,139,193,102,131,224,15,102,
193,233,4,102,3,217,102,3,216,102,67,102,88,235,196,102,
43,200,102,43,194,102,3,198,195,102,43,192,195,102,43,201,
103,138,11,128,225,15,102,131,249,0,15,133,4,0,102,43,
201,195,102,83,102,82,102,3,217,103,102,15,190,19,102,73,
102,75,102,131,249,0,15,132,13,0,102,193,226,8,103,138,
19,102,75,102,73,235,235,102,139,202,102,90,102,91,195,102,
83,102,82,102,43,210,103,138,19,102,131,226,15,102,43,201,
103,138,11,192,233,4,102,131,249,0,15,133,8,0,102,43,
201,102,90,102,91,195,102,3,218,102,3,217,103,102,15,190,
19,102,73,102,75,102,131,249,0,15,132,13,0,102,193,226,
8,103,138,19,102,75,102,73,235,235,102,139,202,102,90,102,
91,195,102,11,201,15,133,1,0,195,102,81,102,86,103,131,
62,97,15,140,12,0,103,131,62,122,15,143,4,0,103,131,
46,32,102,131,198,2,226,230,102,94,102,89,195,102,80,102,
81,102,139,208,102,161,46,2,103,102,141,88,16,103,3,67,
4,103,102,141,64,16,102,139,218,232,130,249,102,11,192,15,
132,5,0,102,89,102,89,195,102,161,50,2,102,11,192,15,
133,8,0,102,89,102,89,102,51,192,195,102,139,22,50,2,
103,102,141,82,16,103,102,139,66,8,102,64,102,139,30,78,
2,102,247,227,102,51,210,102,247,54,94,2,102,80,102,88,
102,11,192,15,132,48,0,102,72,102,80,232,28,254,114,238,
232,241,253,102,90,102,89,102,91,102,83,102,81,102,82,102,
161,66,2,103,102,141,64,24,232,19,249,102,11,192,116,206,
102,89,102,89,102,89,195,102,89,102,89,102,51,192,195,102,
81,102,80,102,184,5,0,0,0,30,7,102,139,249,232,153,
253,102,139,193,102,91,102,83,102,15,183,14,12,2,102,186,
14,2,0,0,232,122,248,102,91,102,89,102,11,192,15,133,
47,0,102,139,193,102,139,203,102,80,102,83,232,35,0,102,
91,102,95,102,11,192,15,132,23,0,30,7,232,91,253,102,
139,199,102,15,183,14,12,2,102,186,14,2,0,0,232,64,
248,195,102,81,102,187,32,0,0,0,102,185,0,0,0,0,
102,186,0,0,0,0,232,40,248,102,11,192,15,132,82,0,
102,139,216,30,7,102,139,62,22,2,232,189,248,30,7,102,
139,30,22,2,102,89,38,102,57,15,15,132,46,0,38,102,
131,63,255,15,132,45,0,38,131,127,4,0,15,132,36,0,
38,102,15,183,71,4,3,216,139,195,37,0,128,116,215,140,
192,5,0,8,142,192,129,227,255,127,235,202,38,102,139,71,
16,195,102,89,102,51,192,195,160,249,1,233,150,244,160,250,
1,233,144,244,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\ntfs\i386\boot98n.h ===
#define PC98NTFSBOOTCODE_SIZE 8192


unsigned char PC98NtfsBootCode[] = {
235,82,0,78,84,70,83,32,32,32,32,0,2,1,0,0,
0,0,0,0,0,248,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,250,51,192,142,208,188,0,124,251,86,140,200,
142,216,102,51,192,142,192,38,160,132,5,162,36,0,199,6,
28,0,0,0,199,6,30,0,0,0,199,6,16,0,0,0,
199,6,18,0,0,0,199,6,14,0,2,0,184,0,13,142,
192,102,51,219,232,68,0,161,26,0,38,139,92,10,102,247,
227,139,30,24,0,102,247,227,102,163,28,0,199,6,16,0,
0,0,199,6,18,0,0,0,198,6,14,0,16,184,0,13,
142,192,51,219,232,20,0,138,14,36,0,139,30,28,0,139,
22,30,0,94,104,0,13,104,106,2,203,96,6,139,54,14,
0,139,235,139,14,16,0,139,22,18,0,82,81,184,64,0,
59,240,115,2,139,198,80,82,247,38,11,0,90,80,139,216,
3,14,28,0,19,22,30,0,160,36,0,36,127,180,86,205,
27,95,91,89,90,114,11,3,203,131,210,0,3,239,43,243,
117,201,137,54,14,0,137,14,16,0,137,22,18,0,7,97,
195,80,83,81,82,6,255,54,14,0,255,54,16,0,255,54,
18,0,139,195,193,232,4,140,193,3,193,37,255,15,45,0,
16,247,216,80,161,14,0,139,14,11,0,193,233,4,247,225,
139,200,88,81,59,193,118,2,139,193,80,139,14,11,0,193,
233,4,51,210,247,241,163,14,0,232,95,255,88,89,43,200,
118,11,140,194,3,208,142,194,184,0,16,235,214,143,6,18,
0,143,6,16,0,143,6,14,0,7,90,89,91,88,195,160,
248,1,180,1,5,2,0,139,240,232,3,0,251,235,254,184,
0,160,142,192,50,228,172,60,0,116,3,171,235,241,195,13,
10,65,32,100,105,115,107,32,114,101,97,100,32,101,114,114,
111,114,32,111,99,99,117,114,114,101,100,0,13,10,78,84,
76,68,82,32,105,115,32,109,105,115,115,105,110,103,0,0,
0,0,0,0,0,0,0,0,191,220,0,0,0,0,85,170,
5,0,78,0,84,0,76,0,68,0,82,0,4,0,36,0,
73,0,51,0,48,0,0,224,0,0,0,48,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,235,18,144,144,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,140,200,142,216,193,224,
4,250,139,224,251,138,193,162,36,0,137,30,28,0,137,22,
30,0,86,102,15,183,6,11,0,102,15,182,30,13,0,102,
247,227,102,163,78,2,102,139,14,64,0,128,249,0,15,143,
14,0,246,217,102,184,1,0,0,0,102,211,224,235,8,144,
102,161,78,2,102,247,225,102,163,82,2,102,15,183,30,11,
0,102,51,210,102,247,243,102,163,86,2,232,14,4,102,139,
14,74,2,102,137,14,34,2,102,3,14,82,2,102,137,14,
38,2,102,3,14,82,2,102,137,14,42,2,102,3,14,82,
2,102,137,14,58,2,102,3,14,82,2,102,137,14,66,2,
102,184,144,0,0,0,102,139,14,34,2,232,237,8,102,11,
192,15,132,138,254,102,163,46,2,102,184,160,0,0,0,102,
139,14,38,2,232,212,8,102,163,50,2,102,184,176,0,0,
0,102,139,14,42,2,232,194,8,102,163,54,2,102,161,46,
2,102,11,192,15,132,87,254,103,128,120,8,0,15,133,78,
254,103,102,141,80,16,103,3,66,4,103,102,15,182,72,12,
102,137,14,98,2,103,102,139,72,8,102,137,14,94,2,102,
161,94,2,102,15,183,14,11,0,102,51,210,102,247,241,102,
163,102,2,102,161,66,2,102,3,6,94,2,102,163,70,2,
102,131,62,50,2,0,15,132,25,0,102,131,62,54,2,0,
15,132,251,253,102,139,30,54,2,30,7,102,139,62,70,2,
232,147,1,102,15,183,14,0,2,102,184,2,2,0,0,232,
151,7,102,11,192,15,132,11,9,103,102,139,0,30,7,102,
139,62,58,2,232,207,5,102,161,58,2,102,187,128,0,0,
0,102,185,0,0,0,0,102,186,0,0,0,0,232,173,0,
102,11,192,15,133,62,0,102,185,128,0,0,0,102,161,58,
2,232,90,8,102,11,192,15,132,201,8,30,7,102,139,62,
58,2,232,145,5,102,161,58,2,102,187,128,0,0,0,102,
185,0,0,0,0,102,186,0,0,0,0,232,111,0,102,11,
192,15,132,159,8,103,102,15,183,88,12,102,129,227,255,0,
0,0,15,133,142,8,102,139,216,104,0,32,7,102,43,255,
232,243,0,138,22,36,0,184,232,3,142,192,141,54,11,0,
43,192,93,104,0,32,80,203,6,30,102,96,102,139,218,102,
15,182,14,13,0,102,247,225,102,163,16,0,102,139,195,102,
247,225,163,14,0,139,223,131,227,15,140,192,102,193,239,4,
3,199,80,7,232,154,252,102,97,144,31,7,195,103,3,64,
20,103,102,131,56,255,15,132,76,0,103,102,57,24,15,133,
51,0,102,11,201,15,133,10,0,103,128,120,9,0,15,133,
35,0,195,103,58,72,9,15,133,26,0,102,139,240,103,3,
112,10,232,89,6,102,81,30,7,102,139,250,243,167,102,89,
15,133,1,0,195,103,102,131,120,4,0,15,132,7,0,103,
102,3,64,4,235,171,102,43,192,195,102,139,243,232,46,6,
103,102,3,0,103,247,64,12,2,0,15,133,52,0,103,102,
141,80,16,103,58,74,64,15,133,24,0,103,102,141,114,66,
232,11,6,102,81,30,7,102,139,251,243,167,102,89,15,133,
1,0,195,103,131,120,8,0,15,132,6,0,103,3,64,8,
235,194,102,51,192,195,103,128,123,8,0,15,133,28,0,6,
30,102,96,103,102,141,83,16,103,102,139,10,102,139,243,103,
3,114,4,243,164,102,97,144,31,7,195,103,102,141,83,16,
103,102,139,74,8,102,65,102,43,192,232,1,0,195,6,30,
102,96,103,128,123,8,1,15,132,3,0,233,17,252,102,131,
249,0,15,133,6,0,102,97,144,31,7,195,102,83,102,80,
102,81,102,87,6,232,115,4,102,139,209,7,102,95,102,89,
102,59,202,15,141,3,0,102,139,209,232,171,254,102,43,202,
102,139,218,102,139,194,102,15,182,22,13,0,102,247,226,102,
15,183,22,11,0,102,247,226,102,3,248,102,88,102,3,195,
102,91,235,170,6,30,102,96,103,128,123,8,1,15,132,3,
0,233,171,251,102,131,249,0,15,133,6,0,102,97,144,31,
7,195,102,83,102,80,102,81,102,87,6,102,81,102,51,210,
102,15,182,14,13,0,102,247,241,102,82,232,253,3,102,15,
182,30,13,0,102,247,227,102,90,102,3,194,102,80,102,15,
182,6,13,0,102,247,225,102,139,208,102,88,102,89,7,102,
95,102,89,102,59,202,15,141,3,0,102,139,209,102,163,16,
0,137,22,14,0,6,30,102,96,139,223,131,227,15,140,192,
102,193,239,4,3,199,80,7,232,198,250,102,97,144,31,7,
102,43,202,102,139,218,102,139,194,102,15,183,22,11,0,102,
247,226,102,3,248,102,88,102,3,195,102,91,233,101,255,6,
30,102,96,38,103,102,15,183,95,4,38,103,102,15,183,79,
6,102,11,201,15,132,247,250,102,3,223,102,131,195,2,102,
129,199,254,1,0,0,102,73,102,11,201,15,132,23,0,38,
103,139,3,38,103,137,7,102,131,195,2,102,129,199,0,2,
0,0,102,73,235,226,102,97,144,31,7,195,6,30,102,96,
102,184,1,0,0,0,102,163,30,2,102,161,26,2,102,3,
6,82,2,102,163,90,2,102,3,6,82,2,102,163,74,2,
102,161,48,0,102,15,182,30,13,0,102,247,227,102,139,30,
74,2,102,137,7,102,163,16,0,131,195,4,102,161,86,2,
102,137,7,163,14,0,131,195,4,102,137,30,74,2,102,139,
30,26,2,30,7,232,249,249,102,139,251,232,81,255,102,161,
26,2,102,187,32,0,0,0,102,185,0,0,0,0,102,186,
0,0,0,0,232,70,253,102,11,192,15,132,22,1,102,139,
216,30,7,102,139,62,22,2,232,219,253,102,139,30,22,2,
102,129,63,128,0,0,0,15,132,235,0,3,95,4,235,240,
102,83,102,139,71,16,102,247,38,86,2,102,80,102,51,210,
102,15,182,30,13,0,102,247,243,102,82,232,220,0,102,11,
192,15,132,250,249,102,139,14,86,2,102,15,182,30,13,0,
102,247,227,102,90,102,3,194,102,139,30,74,2,102,137,7,
131,195,4,102,15,182,6,13,0,102,43,194,102,59,193,15,
134,3,0,102,139,193,102,137,7,102,43,200,102,90,15,132,
117,0,102,3,194,102,80,102,51,210,102,15,182,30,13,0,
102,247,243,102,81,232,130,0,102,89,102,11,192,15,132,158,
249,102,15,182,30,13,0,102,247,227,102,139,30,74,2,102,
139,23,131,195,4,102,3,23,102,59,208,15,133,21,0,102,
15,182,6,13,0,102,59,193,15,134,3,0,102,139,193,102,
1,7,235,165,131,195,4,102,137,30,74,2,102,137,7,131,
195,4,102,15,182,6,13,0,102,59,193,15,134,3,0,102,
139,193,102,137,7,235,130,131,195,4,102,255,6,30,2,102,
137,30,74,2,102,91,3,95,4,102,129,63,128,0,0,0,
15,132,12,255,102,97,144,31,7,195,102,139,208,102,139,14,
30,2,102,139,54,90,2,102,3,54,82,2,102,82,102,81,
102,82,102,139,30,90,2,102,139,62,86,2,102,139,4,102,
163,16,0,131,198,4,102,139,4,163,14,0,131,198,4,30,
7,232,125,248,102,43,248,15,132,8,0,247,38,11,0,3,
216,235,217,102,139,62,90,2,30,7,232,194,253,102,161,90,
2,102,187,128,0,0,0,102,185,0,0,0,0,102,139,209,
232,186,251,102,11,192,15,132,181,248,102,139,216,102,88,102,
86,232,39,1,102,94,102,11,192,15,132,5,0,102,91,102,
91,195,102,89,102,90,226,132,102,51,192,195,6,30,102,96,
102,80,102,81,102,51,210,102,15,182,30,13,0,102,247,243,
102,82,102,87,232,83,255,102,95,102,11,192,15,132,111,248,
102,15,182,30,13,0,102,247,227,102,90,102,3,194,102,163,
16,0,102,89,102,15,182,30,13,0,102,59,203,15,142,19,
0,137,30,14,0,102,43,203,102,88,102,3,195,102,80,102,
81,235,20,144,102,88,102,3,193,102,80,137,14,14,0,102,
185,0,0,0,0,102,81,6,102,87,139,223,131,227,15,140,
192,102,193,239,4,3,199,80,7,232,165,247,102,95,7,102,
3,62,78,2,102,89,102,88,102,131,249,0,15,143,112,255,
102,97,144,31,7,195,6,30,102,96,102,247,38,86,2,102,
139,14,86,2,232,85,255,232,213,252,102,97,144,31,7,195,
6,30,102,96,102,247,38,102,2,102,139,30,50,2,102,139,
14,102,2,30,7,102,139,62,66,2,232,7,252,232,175,252,
102,97,144,31,7,195,102,80,102,83,102,81,102,139,30,70,
2,102,139,200,102,193,232,3,102,131,225,7,102,3,216,102,
184,1,0,0,0,102,211,224,103,132,3,15,132,4,0,248,
235,2,144,249,102,89,102,91,102,88,195,103,128,123,8,1,
15,132,4,0,102,43,192,195,103,102,141,115,16,103,102,139,
86,8,102,59,194,15,135,11,0,103,102,139,22,102,59,194,
15,131,4,0,102,43,192,195,103,3,94,16,102,43,246,103,
128,59,0,15,132,62,0,232,129,0,102,3,241,232,57,0,
102,3,202,102,59,193,15,140,33,0,102,139,209,102,80,103,
102,15,182,11,102,139,193,102,131,224,15,102,193,233,4,102,
3,217,102,3,216,102,67,102,88,235,196,102,43,200,102,43,
194,102,3,198,195,102,43,192,195,102,43,201,103,138,11,128,
225,15,102,131,249,0,15,133,4,0,102,43,201,195,102,83,
102,82,102,3,217,103,102,15,190,19,102,73,102,75,102,131,
249,0,15,132,13,0,102,193,226,8,103,138,19,102,75,102,
73,235,235,102,139,202,102,90,102,91,195,102,83,102,82,102,
43,210,103,138,19,102,131,226,15,102,43,201,103,138,11,192,
233,4,102,131,249,0,15,133,8,0,102,43,201,102,90,102,
91,195,102,3,218,102,3,217,103,102,15,190,19,102,73,102,
75,102,131,249,0,15,132,13,0,102,193,226,8,103,138,19,
102,75,102,73,235,235,102,139,202,102,90,102,91,195,102,11,
201,15,133,1,0,195,102,81,102,86,103,131,62,97,15,140,
12,0,103,131,62,122,15,143,4,0,103,131,46,32,102,131,
198,2,226,230,102,94,102,89,195,102,80,102,81,102,139,208,
102,161,46,2,103,102,141,88,16,103,3,67,4,103,102,141,
64,16,102,139,218,232,130,249,102,11,192,15,132,5,0,102,
89,102,89,195,102,161,50,2,102,11,192,15,133,8,0,102,
89,102,89,102,51,192,195,102,139,22,50,2,103,102,141,82,
16,103,102,139,66,8,102,64,102,139,30,78,2,102,247,227,
102,51,210,102,247,54,94,2,102,80,102,88,102,11,192,15,
132,48,0,102,72,102,80,232,28,254,114,238,232,241,253,102,
90,102,89,102,91,102,83,102,81,102,82,102,161,66,2,103,
102,141,64,24,232,19,249,102,11,192,116,206,102,89,102,89,
102,89,195,102,89,102,89,102,51,192,195,102,81,102,80,102,
184,5,0,0,0,30,7,102,139,249,232,153,253,102,139,193,
102,91,102,83,102,15,183,14,12,2,102,186,14,2,0,0,
232,122,248,102,91,102,89,102,11,192,15,133,47,0,102,139,
193,102,139,203,102,80,102,83,232,35,0,102,91,102,95,102,
11,192,15,132,23,0,30,7,232,91,253,102,139,199,102,15,
183,14,12,2,102,186,14,2,0,0,232,64,248,195,102,81,
102,187,32,0,0,0,102,185,0,0,0,0,102,186,0,0,
0,0,232,40,248,102,11,192,15,132,82,0,102,139,216,30,
7,102,139,62,22,2,232,189,248,30,7,102,139,30,22,2,
102,89,38,102,57,15,15,132,46,0,38,102,131,63,255,15,
132,45,0,38,131,127,4,0,15,132,36,0,38,102,15,183,
71,4,3,216,139,195,37,0,128,116,215,140,192,5,0,8,
142,192,129,227,255,127,235,202,38,102,139,71,16,195,102,89,
102,51,192,195,160,249,1,233,200,244,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\ntfs\i386\ntfsboot.asm ===
page    ,132
        title   ntfsboot - NTFS boot loader
        name    ntfsboot

; The ROM in the IBM PC starts the boot process by performing a hardware
; initialization and a verification of all external devices.  If all goes
; well, it will then load from the boot drive the sector from track 0, head 0,
; sector 1.  This sector is placed at physical address 07C00h.
;
; The boot code's sole resposiblity is to find NTLDR, load it at
; address 2000:0000, and then jump to it.
;
; The boot code understands the structure of the NTFS root directory,
; and is capable of reading files.  There is no contiguity restriction.
;
; DEBUG EQU 1
MASM    equ     1
        .xlist
        .286

A_DEFINED EQU 1

    include ntfs.inc

DoubleWord      struc
lsw     dw      ?
msw     dw      ?
DoubleWord      ends

;
; The following are various segments used by the boot loader. The first
; two are the segments where the boot sector is initially loaded and where
; the boot sector is relocated to.  The third is the static location
; where the NTLDR is loaded.
;

BootSeg segment at 07c0h        ; this is where the MBR loads us initially.
BootSeg ends

NewSeg  segment at 0d00h        ; this is where we'll relocate to.
NewSeg  ends                    ; enough for 16 boot sectors +
                                ;       4-sector scratch
                                ; below where we'll load NTLDR.

LdrSeg segment at 2000h         ; we want to load the loader at 2000:0000
LdrSeg ends

;/********************** START OF SPECIFICATIONS ************************/
;/*                                                                     */
;/* SUBROUTINE NAME: ntfsboot                                           */
;/*                                                                     */
;/* DESCRIPTIVE NAME: Bootstrap loader                                  */
;/*                                                                     */
;/* FUNCTION:    To load NTLDR into memory.                             */
;/*                                                                     */
;/* NOTES:       ntfsboot is loaded by the ROM BIOS (Int 19H) at        */
;/*              physical memory location 0000:7C00H.                   */
;/*              ntfsboot runs in real mode.                            */
;/*              This boot record is for NTFS volumes only.             */
;/*                                                                     */
;/* ENTRY POINT: ntfsboot                                               */
;/* LINKAGE:     Jump (far) from Int 19H                                */
;/*                                                                     */
;/* INPUT:       CS:IP = 0000:7C00H                                     */
;/*              SS:SP = 0030:00FAH (CBIOS dependent)                   */
;/*                                                                     */
;/* EXIT-NORMAL: DL = INT 13 drive number we booted from                */
;/*              Jmp to main in NTLDR                                   */
;/*                                                                     */
;/* EXIT-ERROR:  None                                                   */
;/*                                                                     */
;/* EFFECTS:     NTLDR is loaded into the physical memory               */
;/*                location 00020000H                                   */
;/*                                                                     */
;/*********************** END OF SPECIFICATIONS *************************/
BootCode segment        ;would like to use BootSeg here, but LINK flips its lid
        assume  cs:BootCode,ds:nothing,es:nothing,ss:nothing

        org     0               ; start at beginning of segment, not 0100h.

        public  _ntfsboot
_ntfsboot label near
        jmp     start
    .errnz  ($-_ntfsboot) GT (3)        ;<FATAL PROBLEM: JMP is more than three bytes>

    org 3

Version                 db      "NTFS    "      ; Signature, must be "NTFS    "
BPB                     label   byte
BytesPerSector          dw      512             ; Size of a physical sector
SectorsPerCluster       db      1               ; Sectors per allocation unit

;
; Traditionally the next 7 bytes were the reserved sector count, fat count,
; root dir entry count, and the small volume sector count. However all of
; these fields must be 0 on NTFS volumes.
;
; We use this space to store some temporary variables used by the boot code,
; which avoids the need for separate space in sector 0 to store them.
; We also take advantage of the free 0-initialization to save some space
; by avoiding the code to initialize them.
;
; Note that ideally we'd want to use an unused field for the SectorCount
; and initialize it to 16. This would let us save a few bytes by avoiding
; code to explicitly initialize this value before we read the 16 boot sectors.
; However setup and other code tends to preserve the entire bpb area when
; it updates boot code, so we avoid a dependency here and initialize
; the value explicitly to 16 in the first part of the boot code.
;
SectorCount             dw      0               ; number of sectors to read
SectorBase              dd      0               ; start sector for read request
HaveXInt13              db      0               ; extended int13 available flag

Media                   db      0f8h            ; Media byte
FatSectors              dw      0               ; (always 0 on NTFS)
SectorsPerTrack         dw      0               ; Sectors per track
Heads                   dw      0               ; Number of surfaces
HiddenSectors           dd      0               ; partition start LBA

;
; The field below is traditionally the large sector count and is
; always 0 on NTFS. We use it here for a value the boot code calculates,
; namely the number of sectors visible on the drive via conventional int13.
;
Int13Sectors            dd      0

DriveNumber             db      80h             ; int13 unit number

                        db      3 dup (?)       ; alignment filler

;
; The following is the rest of the NTFS Sector Zero information.
; The offsets of most of these fields cannot be changed without changing
; all code that validates, formats, recognizes, etc, NTFS volumes.
; In other words, don't change it.
;
SectorsOnVolume         db (size LARGE_INTEGER) dup (?)
MftStartLcn             db (size LARGE_INTEGER) dup (?)
Mft2StartLcn            db (size LARGE_INTEGER) dup (?)
ClustersPerFrs          dd ?
DefClustersPerBuf       dd ?
SerialNumber            db (size LARGE_INTEGER) dup (?)
CheckSum                dd ?

;
; Make sure size of fields matches what fs_rec.sys thinks is should be
;
        .errnz          ($-_ntfsboot) NE (54h)

;****************************************************************************
start:
;
;       First of all, set up the segments we need (stack and data).
;
        cli
        xor     ax,ax                   ; Set up the stack to just before
        mov     ss,ax                   ; this code.  It'll be moved after
        mov     sp,7c00h                ; we relocate.
        sti

        mov     ax,Bootseg              ; Address BPB with DS.
        mov     ds,ax
        assume  ds:BootCode

        call    Int13SecCnt             ; determine range of regular int13

;
; Read bootcode and jump to code in sector 1.
; Assumes HaveXInt13 and SectorBase are initialized to 0,
; which they are since they are stored in areas of the BPB
; that must be 0 on NTFS volumes.
;
        mov     ax,NewSeg
        mov     es,ax
        xor     bx,bx                   ; es:bx = transfer address

        mov     byte ptr SectorCount,16 ; word field is 0 on-disk so byte init is OK
        call    ReadSectors

        push    NewSeg
        push    offset mainboot
        retf

;
; Determine the number of sectors addressable via
; conventional int13. If we can't get drive params for some reason
; then something is very wrong -- we'll try to force the caller
; to use conventional int13 by maxing out the sector count.
;
; Input: ds addresses start of first sector
;
; Output: in eax; also stored in Int13Sectors variable.
;
; Preserves: assume none.
;
Int13SecCnt proc near
        mov     dl,DriveNumber          ; int13 unit number
        mov     ah,8                    ; get drive params
        int     13h                     ; call BIOS
        jnc     @f                      ; no error, procede
        mov     cx,-1                   ; strange case, fake registers to force
        mov     dh,cl                   ; use of standard int13 (set all vals to max)
@@:
.386
        movzx   eax,dh                  ; eax = max head # (0-255)
        inc     ax                      ; eax = heads (1-256)
        movzx   edx,cl                  ; edx = sectors per track + cyl bits
        and     dl,3fh                  ; edx = sectors per track (1-63)
        mul     dx                      ; eax = sectors per cylinder, edx = 0
        xchg    cl,ch
        shr     ch,6                    ; cx = max cylinder # (0-1023)
        inc     cx                      ; cx = cylinders (1-1024)
        movzx   ecx,cx                  ; ecx = cylinders (1-1024)
        mul     ecx                     ; eax = sectors visible via int13, edx = 0
        mov     Int13Sectors,eax        ; save # sectors addressable via int13
.286
        ret
Int13SecCnt endp

;
; Determine whether extended int13 services are available on the boot drive.
;
; Stores result (boolean) in HaveXInt13 variable.
;
; Preserves: assume none.
;
HaveInt13Ext proc near
        mov     ah,41h
        mov     bx,055aah
        mov     dl,DriveNumber
        int     13h
        jc      @f                      ; error from int13 means no xint13
        cmp     bx,0aa55h               ; absence of sig means no xint13
        jne     @f
        test    cl,1                    ; bit 0 off means no xint13
        jz      @f
        inc     byte ptr HaveXInt13     ; xint13 is available
@@:     ret
HaveInt13Ext endp


;
; Read SectorCount sectors starting at logical sector SectorBase,
; into es:bx, using extended int13 if necessary.
;
; Preserves all
;
ReadSectors proc near
.386
        pushad                          ; save registers
        push    ds
        push    es

read_loop:
        mov     eax,SectorBase          ; logical starting sector
        add     eax,HiddenSectors       ; eax = physical starting sector
        cmp     eax,Int13Sectors        ; determine if standard int13 is ok
        jb      stdint13

        push    ds                      ; preserve ds

        db      66h                     ; hand-coded 32-bit push of 8-bit immediate
        push    0                       ; high 32 bits of sector #
        push    eax                     ; low 32 bits of sector #
        push    es
        push    bx                      ; transfer address
        push    dword ptr 10010h        ; transfer 1 sector, packet size = 16

        cmp     byte ptr HaveXInt13,0
        jne     @f                      ; already know we have xint13 available
        call    HaveInt13Ext            ; see if we have it
        cmp     byte ptr HaveXInt13,0

        je      BootErr$he              ; need it but don't have it

@@:     mov     ah,42h                  ; extended read
        mov     dl,DriveNumber          ; dl = int13 unit #
        push    ss
        pop     ds
        mov     si,sp                   ; ds:si -> param packet

        int     13h

        pop     eax                     ; throw away first 4 bytes of param packet
        pop     bx                      ; restore es:bx from param packet
        pop     es
        pop     eax                     ; throw away last 8 bytes of param packet
        pop     eax                     ; without clobbering carry flag

        pop     ds                      ; restore ds

        jmp     short did_read

stdint13:
        xor     edx,edx                 ; edx:eax = absolute sector number
        movzx   ecx,SectorsPerTrack     ; ecx = sectors per track
        div     ecx                     ; eax = track, edx = sector within track (0-62)
        inc     dl                      ; dl = sector within track (1-63)
        mov     cl,dl                   ; cl = sector within track
        mov     edx,eax
        shr     edx,16                  ; dx:ax = track
        div     Heads                   ; ax = cylinder (0-1023), dx = head (0-255)
        xchg    dl,dh                   ; dh = head
        mov     dl,DriveNumber          ; dl = int13 unit #
        mov     ch,al                   ; ch = bits 0-7 of cylinder
        shl     ah,6
        or      cl,ah                   ; bits 6-7 of cl = bits 8-9 of cylinder
        mov     ax,201h                 ; read 1 sector
        int     13h
did_read:
        jc      BootErr$he

read_next:
        mov     ax,es                   ; advance transfer address
        add     ax,20h                  ; by moving segment register along
        mov     es,ax                   ; thus no 64K limit on transfer length

        inc     SectorBase              ; advance sector number
        dec     SectorCount             ; see if done
        jnz     read_loop               ; not done

        pop     es
        pop     ds
        popad                           ; restore registers
.286
        ret
ReadSectors endp

BootErr$he:

        mov     al,byte ptr TXT_MSG_SYSINIT_BOOT_ERROR
BootErr2:

        call    BootErr$print
        mov     al,byte ptr TXT_MSG_SYSINIT_REBOOT
        call    BootErr$print
        sti
        jmp     $                       ; Wait forever

BootErr$print:
;
; al is offset - 256 of message. Adjust to form real offset
; and stick in si so lodsb below will work.
;
        mov     ah,1
        mov     si,ax

BootErr$print1:
        lodsb                           ; Get next character
        cmp     al,0
        je      BootErr$Done
        mov     ah,14                   ; Write teletype
        mov     bx,7                    ; Attribute
        int     10h                     ; Print it
        jmp     BootErr$print1
BootErr$Done:
        ret

;****************************************************************************

;
; Message table.
;
; We put English messages here as a placeholder only, so that in case
; anyone uses bootntfs.h without patching new messages in, things will
; still be correct (in English, but at least functional).
;
MSG_SYSINIT_BOOT_ERROR:

        DB      13,10,'A disk read error occurred',0

MSG_SYSINIT_FILE_NOT_FD:

        DB      13,10,'NTLDR is missing',0

MSG_SYSINIT_NTLDR_CMPRS:

        DB      13,10,'NTLDR is compressed',0

MSG_SYSINIT_REBOOT:

        DB      13,10,'Press Ctrl+Alt+Del to restart',13,10,0

;
; Now build a table with the low byte of the offset to each message.
; Code that patches the boot sector messages updates this table.
;
        .errnz ($-_ntfsboot) GT (512-8)
        ORG     512 - 8
TXT_MSG_SYSINIT_BOOT_ERROR:
        db OFFSET (MSG_SYSINIT_BOOT_ERROR - _ntfsboot) - 256
TXT_MSG_SYSINIT_FILE_NOT_FD:
        db OFFSET (MSG_SYSINIT_FILE_NOT_FD - _ntfsboot) - 256
TXT_MSG_SYSINIT_NTLDR_CMPRS:
        db OFFSET (MSG_SYSINIT_NTLDR_CMPRS - _ntfsboot) - 256
TXT_MSG_SYSINIT_REBOOT:
        db OFFSET (MSG_SYSINIT_REBOOT - _ntfsboot) - 256

        .errnz ($-_ntfsboot) NE (512-4)
        db      0,0,55h,0aah

;   Name we look for.  ntldr_length is the number of characters,
;   ntldr_name is the name itself.  Note that it is not NULL
;   terminated, and doesn't need to be.
;
ntldr_name_length   dw  5

ntldr_name          dw  'N', 'T', 'L', 'D', 'R'

;   Predefined name for index-related attributes associated with an
;   index over $FILE_NAME
;
index_name_length   dw 4
index_name          dw '$', 'I', '3', '0'

;   Global variables.  These offsets are all relative to NewSeg.
;
AttrList            dd 0e000h   ; Offset of buffer to hold attribute list
MftFrs              dd  3000h   ; Offset of general scratch buffer for FRS
SegmentsInMft       dd   ?      ; number of FRS's with MFT Data attribute records
RootIndexFrs        dd   ?      ; Offset of Root Index FRS
AllocationIndexFrs  dd   ?      ; Offset of Allocation Index FRS        ; KPeery
BitmapIndexFrs      dd   ?      ; Offset of Bitmap Index FRS            ; KPeery
IndexRoot           dd   ?      ; Offset of Root Index $INDEX_ROOT attribute
IndexAllocation     dd   ?      ; Offset of Root Index $INDEX_ALLOCATION attribute
IndexBitmap         dd   ?      ; Offset of Root Index $BITMAP attribute
NtldrFrs            dd   ?      ; Offset of NTLDR FRS
NtldrData           dd   ?      ; Offset of NTLDR $DATA attribute
IndexBlockBuffer    dd   ?      ; Offset of current index buffer
IndexBitmapBuffer   dd   ?      ; Offset of index bitmap buffer
NextBuffer          dd   ?      ; Offset of next free byte in buffer space

BytesPerCluster     dd   ?      ; Bytes per cluster
BytesPerFrs         dd   ?      ; Bytes per File Record Segment

;
; For floppyless booting, winnt32.exe creates c:\$win_nt$.~bt\bootsec.dat and
; places an entry in boot.ini for it (the boot selection says something
; like "Windows NT Setup or Upgrade"). When that is selected, the boot loader
; loads 16 sectors worth of data from bootsect.dat into d000 (which is where
; the first sector of this code would have loaded it) and jumps into it at
; a known location of 256h. That was correct in earlier versions of NT
; but is not correct now because the 4 fields below were added to this sector.
;
; Note that 0000 is "add [bx+si],al" which because of the way the boot loader
; is written happens to be a benign add of 0 to something in segment 7c0,
; which doesn't seem to hose anything but is still somewhat random.
;
; We code in a jump here so as this new code proliferates we get this
; cleaned up.
;
        .errnz  $-_ntfsboot ne 256h
SectorsPerFrs label dword       ; Sectors per File Record Segment
                    jmp short mainboot
                    nop
                    nop
        .errnz  $-_ntfsboot ne 25ah

MftLcnFrs               dd  ?   ; Offset scratch FRS buffer for LookupMftLcn
BytesPerIndexBlock      dd  ?   ; Bytes per index alloc block in root index
ClustersPerIndexBlock   dd  ?   ; Clusters per index alloc block in root index
SectorsPerIndexBlock    dd  ?   ; Sectors per index block in root index

.386

SAVE_ALL    macro

    push    es
    push    ds
    pushad

endm

RESTORE_ALL macro

    popad
    nop
    pop     ds
    pop     es

endm


;****************************************************************************
;
; mainboot - entry point after 16 boot sectors have been read in
;
;
mainboot proc   far

;       Get the new ds and the new stack.  Note that ss is zero.
;
        mov     ax, cs                  ; Set DS to CS
        mov     ds, ax

        shl     ax, 4                   ; convert to an offset.
        cli
        mov     sp, ax                  ; load new stack, just before boot code.
        sti

;
; Reinitialize xint13-related variables
;
        call    Int13SecCnt             ; determine range of regular int13

;       Set up the FRS buffers.  The MFT buffer is in a fixed
;       location, and the other three come right after it.  The
;       buffer for index allocation blocks comes after that.
;

;       Compute the useful constants associated with the volume
;
        movzx   eax, BytesPerSector     ; eax = Bytes per Sector
        movzx   ebx, SectorsPerCluster  ; ebx = Sectors Per Cluster
        mul     ebx                     ; eax = Bytes per Cluster
        mov     BytesPerCluster, eax

        mov     ecx, ClustersPerFrs     ; ecx = clusters per frs
        cmp     cl, 0                   ; is ClustersPerFrs less than zero?
        jg      mainboot$1

;       If the ClustersPerFrs field is negative, we calculate the number
;       of bytes per FRS by negating the value and using that as a shif count.
;

        neg     cl
        mov     eax, 1
        shl     eax, cl                 ; eax = bytes per frs
        jmp     mainboot$2

mainboot$1:

;       Otherwise if ClustersPerFrs was positive, we multiply by bytes
;       per cluster.

        mov     eax, BytesPerCluster
        mul     ecx                     ; eax = bytes per frs

mainboot$2:

        mov     BytesPerFrs, eax
        movzx   ebx, BytesPerSector
        xor     edx, edx                ; zero high part of dividend
        div     ebx                     ; eax = sectors per frs
        mov     SectorsPerFrs, eax


;       Set up the MFT FRS's---this will read all the $DATA attribute
;       records for the MFT.
;

        call    SetupMft

;       Set up the remaining FRS buffers.  The RootIndex FRS comes
;       directly after the last MFT FRS, followed by the NTLdr FRS
;       and the Index Block buffer.
;
        mov     ecx, NextBuffer
        mov     RootIndexFrs, ecx

        add     ecx, BytesPerFrs            ; AllocationFrs may be different
        mov     AllocationIndexFrs, ecx     ; from RootIndexFrs - KPeery

        add     ecx, BytesPerFrs            ; BitmapFrs may be different
        mov     BitmapIndexFrs, ecx         ; from RootIndexFrs - KPeery

        add     ecx, BytesPerFrs
        mov     NtldrFrs, ecx

        add     ecx, BytesPerFrs
        mov     IndexBlockBuffer, ecx

;
;       Read the root index, allocation index and bitmap FRS's and locate
;       the interesting attributes.
;

        mov     eax, $INDEX_ROOT
        mov     ecx, RootIndexFrs
        call    LoadIndexFrs

        or      eax, eax

        jz      BootErr$he

        mov     IndexRoot, eax          ; offset in Frs buffer

        mov     eax, $INDEX_ALLOCATION  ; Attribute type code
        mov     ecx, AllocationIndexFrs ; FRS to search
        call    LoadIndexFrs

        mov     IndexAllocation, eax

        mov     eax, $BITMAP            ; Attribute type code
        mov     ecx, BitmapIndexFrs     ; FRS to search
        call    LoadIndexFrs

        mov     IndexBitmap, eax

;       Consistency check: the index root must exist, and it
;       must be resident.
;
        mov     eax, IndexRoot
        or      eax, eax

        jz      BootErr$he

        cmp     [eax].ATTR_FormCode, RESIDENT_FORM

        jne     BootErr$he


;       Determine the size of the index allocation buffer based
;       on information in the $INDEX_ROOT attribute.  The index
;       bitmap buffer comes immediately after the index block buffer.
;
;       eax -> $INDEX_ROOT attribute record
;
        lea     edx, [eax].ATTR_FormUnion   ; edx -> resident info
        add     ax, [edx].RES_ValueOffset   ; eax -> value of $INDEX_ROOT

        movzx   ecx, [eax].IR_ClustersPerBuffer
        mov     ClustersPerIndexBlock, ecx

        mov     ecx, [eax].IR_BytesPerBuffer
        mov     BytesPerIndexBlock, ecx

        mov     eax, BytesPerIndexBlock
        movzx   ecx, BytesPerSector
        xor     edx, edx
        div     ecx                     ; eax = sectors per index block
        mov     SectorsPerIndexBlock, eax

        mov     eax, IndexBlockBuffer
        add     eax, BytesPerIndexBlock
        mov     IndexBitmapBuffer, eax

;       Next consistency check: if the $INDEX_ALLOCATION attribute
;       exists, the $INDEX_BITMAP attribute must also exist.
;
        cmp     IndexAllocation, 0
        je      mainboot30

        cmp     IndexBitmap, 0          ; since IndexAllocation exists, the

        je      BootErr$he              ;  bitmap must exist, too.

;       Since the bitmap exists, we need to read it into the bitmap
;       buffer.  If it's resident, we can just copy the data.
;

        mov     ebx, IndexBitmap        ; ebx -> index bitmap attribute
        push    ds
        pop     es
        mov     edi, IndexBitmapBuffer  ; es:edi -> index bitmap buffer

        call    ReadWholeAttribute

mainboot30:
;
;       OK, we've got the index-related attributes.
;
        movzx   ecx, ntldr_name_length  ; ecx = name length in characters
        mov     eax, offset ntldr_name  ; eax -> name

        call    FindFile

        or      eax, eax
        jz      BootErr$fnf

;       Read the FRS for NTLDR and find its data attribute.
;
;       eax -> Index Entry for NTLDR.
;
        mov     eax, [eax].IE_FileReference.REF_LowPart

        push    ds
        pop     es              ; es:edi = target buffer
        mov     edi, NtldrFrs

        call    ReadFrs

        mov     eax, NtldrFrs   ; pointer to FRS
        mov     ebx, $DATA      ; requested attribute type
        mov     ecx, 0          ; attribute name length in characters
        mov     edx, 0          ; attribute name (NULL if none)

        call    LocateAttributeRecord

;       eax -> $DATA attribute for NTLDR
;
        or      eax, eax        ; if eax is zero, attribute not found.
        jnz     mainboot$FoundData

;
;       The ntldr $DATA segment is fragmented.  Search the attribute list
;       for the $DATA member.  And load it from there.
;
        mov     ecx, $DATA             ; Attribute type code
        mov     eax, NtldrFrs          ; FRS to search

        call    SearchAttrList         ; search attribute list for FRN
                                       ; of specified ($DATA)

        or      eax, eax               ; if eax is zero, attribute not found.
        jz      BootErr$fnf

;
;       We found the FRN of the $DATA attribute; load that into memory.
;
        push    ds
        pop     es                     ; es:edi = target buffer
        mov     edi, NtldrFrs

        call    ReadFrs

;
;       Determine the beginning offset of the $DATA in the FRS
;
        mov     eax, NtldrFrs   ; pointer to FRS
        mov     ebx, $DATA      ; requested attribute type
        mov     ecx, 0          ; attribute name length in characters
        mov     edx, 0          ; attribute name (NULL if none)

        call    LocateAttributeRecord

;       eax -> $DATA attribute for NTLDR
;
        or      eax, eax        ; if eax is zero, attribute not found.
        jz      BootErr$fnf

mainboot$FoundData:

;       Get the attribute record header flags, and make sure none of the
;       `compressed' bits are set

        movzx   ebx, [eax].ATTR_Flags
        and     ebx, ATTRIBUTE_FLAG_COMPRESSION_MASK
        jnz     BootErr$ntc

        mov     ebx, eax        ; ebx -> $DATA attribute for NTLDR

        push    LdrSeg
        pop     es              ; es = segment addres to read into
        sub     edi, edi        ; es:edi = buffer address

        call    ReadWholeAttribute

;
; We've loaded NTLDR--jump to it.
;
; Before we go to NTLDR, set up the registers the way it wants them:
;       DL = INT 13 drive number we booted from
;
        mov     dl, DriveNumber
        mov     ax,1000
        mov     es, ax                  ; we don't really need this
        lea     si, BPB
        sub     ax,ax
        push    LdrSeg
        push    ax
        retf                            ; "return" to NTLDR.

mainboot endp

.386
;****************************************************************************
;
;   ReadClusters - Reads a run of clusters from the disk.
;
;   ENTRY:  eax == LCN to read
;           edx == clusters to read
;           es:edi -> Target buffer
;
;   USES:   none (preserves all registers)
;
ReadClusters proc near

    SAVE_ALL

    mov     ebx, edx                ; ebx = clusters to read.
    movzx   ecx, SectorsPerCluster  ; ecx = cluster factor

    mul     ecx                 ; Convert LCN to sectors (wipes out edx!)
    mov     SectorBase, eax     ; Store starting sector in SectorBase

    mov     eax, ebx            ; eax = number of clusters
    mul     ecx                 ; Convert EAX to sectors (wipes out edx!)
    mov     SectorCount, ax     ; Store number of sectors in SectorCount

;
;   Note that ReadClusters gets its target buffer in es:edi but calls
;   the ReadSectors worker function that takes a target in es:bx--we need
;   to normalize es:edi so that we don't overflow bx.
;
    mov     bx, di
    and     bx, 0Fh
    mov     ax, es
    shr     edi, 4
    add     ax, di              ; ax:bx -> target buffer

    push    ax
    pop     es                  ; es:bx -> target buffer

    call    ReadSectors

    RESTORE_ALL
    ret

ReadClusters endp

;
;****************************************************************************
;
;   LocateAttributeRecord   --  Find an attribute record in an FRS.
;
;   ENTRY:  EAX -- pointer to FRS
;           EBX -- desired attribute type code
;           ECX -- length of attribute name in characters
;           EDX -- pointer to attribute name
;
;   EXIT:   EAX points at attribute record (0 indicates not found)
;
;   USES:   All
;
LocateAttributeRecord proc near

; get the first attribute record.
;
        add     ax, word ptr[eax].FRS_FirstAttribute

;       eax -> next attribute record to investigate.
;       ebx == desired type
;       ecx == name length
;       edx -> pointer to name
;
lar10:
        cmp     [eax].ATTR_TypeCode, 0ffffffffh
        je      lar99

        cmp     dword ptr[eax].ATTR_TypeCode, ebx
        jne     lar80

;       this record is a potential match.  Compare the names:
;
;       eax -> candidate record
;       ebx == desired type
;       ecx == name length
;       edx -> pointer to name
;
        or      ecx, ecx    ; Did the caller pass in a name length?
        jnz     lar20

;       We want an attribute with no name--the current record is
;       a match if and only if it has no name.
;
        cmp     [eax].ATTR_NameLength, 0
        jne     lar80       ; Not a match.

;       It's a match, and eax is set up correctly, so return.
;
        ret

;       We want a named attribute.
;
;       eax -> candidate record
;       ebx == desired type
;       ecx == name length
;       edx -> pointer to name
;
lar20:
        cmp     cl, [eax].ATTR_NameLength
        jne     lar80       ; Not a match.

;       Convert name in current record to uppercase.
;
        mov     esi, eax
        add     si, word ptr[eax].ATTR_NameOffset

        call    UpcaseName

;       eax -> candidate record
;       ebx == desired type
;       ecx == name length
;       edx -> pointer to name
;       esi -> Name in current record (upcased)
;
        push    ecx         ; save cx

        push    ds          ; Copy data segment into es
        pop     es
        mov     edi, edx    ; note that esi is already set up.

        repe cmpsw          ; zero flag is set if equal

        pop     ecx         ; restore cx

        jnz     lar80       ; not a match

;       eax points at a matching record.
;
        ret

;
;   This record doesn't match; go on to the next.
;
;       eax -> rejected candidate attribute record
;       ebx == desired type
;       ecx == Name length
;       edx -> desired name
;
lar80:  cmp     [eax].ATTR_RecordLength, 0  ; if the record length is zero
        je      lar99                       ; the FRS is corrupt.

        add     eax, [eax].ATTR_RecordLength; Go to next record
        jmp     lar10                       ; and try again

;       Didn't find it.
;
lar99:  sub     eax, eax
        ret

LocateAttributeRecord endp

;****************************************************************************
;
;   LocateIndexEntry   --  Find an index entry in a file name index
;
;   ENTRY:  EAX -> pointer to index header
;           EBX -> file name to find
;           ECX == length of file name in characters
;
;   EXIT:   EAX points at index entry.  NULL to indicate failure.
;
;   USES:   All
;
LocateIndexEntry proc near

;       Convert the input name to upper-case
;

        mov     esi, ebx
        call    UpcaseName

ifdef DEBUG
        call    PrintName
        call    Debug2
endif ; DEBUG

        add     eax, [eax].IH_FirstIndexEntry

;       EAX -> current entry
;       EBX -> file name to find
;       ECX == length of file name in characters
;
lie10:  test    [eax].IE_Flags, INDEX_ENTRY_END ; Is it the end entry?
        jnz     lie99

        lea     edx, [eax].IE_Value         ; edx -> FILE_NAME attribute value

ifdef DEBUG
;       DEBUG CODE -- list file names as they are examined

        SAVE_ALL

        call    Debug3
        movzx   ecx, [edx].FN_FileNameLength    ; ecx = chars in name
        lea     esi, [edx].FN_FileName          ; esi -> name
        call    PrintName

        RESTORE_ALL
endif ; DEBUG

;       EAX -> current entry
;       EBX -> file name to find
;       ECX == length of file name in characters
;       EDX -> FILE_NAME attribute

        cmp     cl, [edx].FN_FileNameLength ; Is name the right length?
        jne     lie80

        lea     esi, [edx].FN_FileName      ; Get name from FILE_NAME structure

        call    UpcaseName

        push    ecx         ; save ecx

        push    ds
        pop     es          ; copy data segment into es for cmpsw
        mov     edi, ebx    ; edi->search name (esi already set up)
        repe    cmpsw       ; zero flag is set if they're equal

        pop     ecx         ; restore ecx

        jnz     lie80

;       the current entry matches the search name, and eax points at it.
;
        ret

;       The current entry is not a match--get the next one.
;           EAX -> current entry
;           EBX -> file name to find
;           ECX == length of file name in characters
;
lie80:  cmp     [eax].IE_Length, 0      ; If the entry length is zero
        je      lie99                   ; then the index block is corrupt.

        add     ax, [eax].IE_Length     ; Get the next entry.

        jmp     lie10


;   Name not found in this block.  Set eax to zero and return
;
lie99:  xor     eax, eax
        ret

LocateIndexEntry endp

;****************************************************************************
;
;   ReadWholeAttribute - Read an entire attribute value
;
;   ENTRY:  ebx -> attribute
;           es:edi -> target buffer
;
;   USES:   ALL
;
ReadWholeAttribute proc near

        cmp     [ebx].ATTR_FormCode, RESIDENT_FORM
        jne      rwa10

;       The attribute is resident.
;       ebx -> attribute
;       es:edi -> target buffer
;

        SAVE_ALL

        lea     edx, [ebx].ATTR_FormUnion   ; edx -> resident form info
        mov     ecx, [edx].RES_ValueLength  ; ecx = bytes in value
        mov     esi, ebx                    ; esi -> attribute
        add     si, [edx].RES_ValueOffset   ; esi -> attribute value

        rep     movsb                       ; copy bytes from value to buffer

        RESTORE_ALL

        ret                                 ; That's all!

rwa10:
;
;       The attribute type is non-resident.  Just call
;       ReadNonresidentAttribute starting at VCN 0 and
;       asking for the whole thing.
;
;       ebx -> attribute
;       es:edi -> target buffer
;
        lea     edx, [ebx].ATTR_FormUnion   ; edx -> nonresident form info
        mov     ecx, [edx].NONRES_HighestVcn.LowPart; ecx = HighestVcn
        inc     ecx                         ; ecx = clusters in attribute

        sub     eax, eax                    ; eax = 0 (first VCN to read)

        call    ReadNonresidentAttribute

        ret

ReadWholeAttribute endp

;****************************************************************************
;
;   ReadNonresidentAttribute - Read clusters from a nonresident attribute
;
;   ENTRY:  EAX == First VCN to read
;           EBX -> Attribute
;           ECX == Number of clusters to read
;           ES:EDI == Target of read
;
;   EXIT:   None.
;
;   USES:   None (preserves all registers with SAVE_ALL/RESTORE_ALL)
;
ReadNonresidentAttribute proc near

        SAVE_ALL

        cmp     [ebx].ATTR_FormCode, NONRESIDENT_FORM
        je      ReadNR10

;       This attribute is not resident--the disk is corrupt.

        jmp     BootErr$he

ReadNR10:
;       eax == Next VCN to read
;       ebx -> Attribute
;       ecx -> Remaining clusters to read
;       es:edi -> Target of read
;

        cmp     ecx, 0
        jne     ReadNR20

;       Nothing left to read--return success.
;
        RESTORE_ALL
        ret

ReadNR20:
        push    ebx ; pointer to attribute
        push    eax ; Current VCN

        push    ecx
        push    edi
        push    es

        call    ComputeLcn  ; eax = LCN to read, ecx = run length
        mov     edx, ecx    ; edx = remaining run length

        pop     es
        pop     edi
        pop     ecx


;       eax == LCN to read
;       ecx == remaining clusters to read
;       edx == remaining clusters in current run
;       es:edi == Target of read
;       TOS == Current VCN
;       TOS + 4 == pointer to attribute
;
        cmp     ecx, edx
        jge     ReadNR30

;       Run length is greater than remaining request; only read
;       remaining request.
;
        mov     edx, ecx    ; edx = Remaining request

ReadNR30:
;       eax == LCN to read
;       ecx == remaining clusters to read
;       edx == clusters to read in current run
;       es:edi == Target of read
;       TOS == Current VCN
;       TOS +  == pointer to attribute
;

        call    ReadClusters

        sub     ecx, edx            ; Decrement clusters remaining in request
        mov     ebx, edx            ; ebx = clusters read

        mov     eax, edx            ; eax = clusters read
        movzx   edx, SectorsPerCluster
        mul     edx                 ; eax = sectors read (wipes out edx!)
        movzx   edx, BytesPerSector
        mul     edx                 ; eax = bytes read (wipes out edx!)

        add     edi, eax            ; Update target of read

        pop     eax                 ; eax = previous VCN
        add     eax, ebx            ; update VCN to read

        pop     ebx                 ; ebx -> attribute
        jmp     ReadNR10


ReadNonresidentAttribute endp

;****************************************************************************
;
;   ReadIndexBlockSectors - Read sectors from an index allocation attribute
;
;   ENTRY:  EAX == First VBN to read
;           EBX -> Attribute
;           ECX == Number of sectors to read
;           ES:EDI == Target of read
;
;   EXIT:   None.
;
;   USES:   None (preserves all registers with SAVE_ALL/RESTORE_ALL)
;
ReadIndexBlockSectors proc near

        SAVE_ALL

        cmp     [ebx].ATTR_FormCode, NONRESIDENT_FORM
        je      ReadIBS_10

;       This attribute is resident--the disk is corrupt.

        jmp     BootErr$he

ReadIBS_10:
;       eax == Next VBN to read
;       ebx -> Attribute
;       ecx -> Remaining sectors to read
;       es:edi -> Target of read
;

        cmp     ecx, 0
        jne     ReadIBS_20

;       Nothing left to read--return success.
;


        RESTORE_ALL
        ret

ReadIBS_20:
        push    ebx ; pointer to attribute
        push    eax ; Current VBN

        push    ecx
        push    edi
        push    es

        ; Convert eax from a VBN back to a VCN by dividing by SectorsPerCluster.
        ; The remainder of this division is the sector offset in the cluster we
        ; want.  Then use the mapping information to get the LCN for this VCN,
        ; then multiply to get back to LBN.
        ;

        push    ecx         ; save remaining sectors in request

        xor     edx, edx    ; zero high part of dividend
        movzx   ecx, SectorsPerCluster
        div     ecx         ; edx = remainder
        push    edx         ; save remainder

        call    ComputeLcn  ; eax = LCN to read, ecx = remaining run length

        movzx   ebx, SectorsPerCluster
        mul     ebx         ; eax = LBN of cluster, edx = 0
        pop     edx         ; edx = remainder
        add     eax, edx    ; eax = LBN we want
        push    eax         ; save LBN

        movzx   eax, SectorsPerCluster
        mul     ecx         ; eax = remaining run length in sectors, edx = 0
        mov     edx, eax    ; edx = remaining run length

        pop     eax         ; eax = LBN
        pop     ecx         ; ecx = remaining sectors in request

        pop     es
        pop     edi
        pop     ecx


;       eax == LBN to read
;       ecx == remaining sectors to read
;       edx == remaining sectors in current run
;       es:edi == Target of read
;       TOS == Current VCN
;       TOS + 4 == pointer to attribute
;
        cmp     ecx, edx
        jge     ReadIBS_30

;       Run length is greater than remaining request; only read
;       remaining request.
;
        mov     edx, ecx    ; edx = Remaining request

ReadIBS_30:
;       eax == LBN to read
;       ecx == remaining sectors to read
;       edx == sectors to read in current run
;       es:edi == Target of read
;       TOS == Current VCN
;       TOS +  == pointer to attribute
;

        mov     SectorBase, eax
        mov     SectorCount, dx

;       We have a pointer to the target buffer in es:edi, but we want that
;       in es:bx for ReadSectors.
;

        SAVE_ALL

        mov     bx, di
        and     bx, 0Fh
        mov     ax, es
        shr     edi, 4
        add     ax, di              ; ax:bx -> target buffer

        push    ax
        pop     es                  ; es:bx -> target buffer

        call    ReadSectors

        RESTORE_ALL

        sub     ecx, edx            ; Decrement sectors remaining in request
        mov     ebx, edx            ; ebx = sectors read

        mov     eax, edx            ; eax = sectors read
        movzx   edx, BytesPerSector
        mul     edx                 ; eax = bytes read (wipes out edx!)

        add     edi, eax            ; Update target of read

        pop     eax                 ; eax = previous VBN
        add     eax, ebx            ; update VBN to read

        pop     ebx                 ; ebx -> attribute
        jmp     ReadIBS_10


ReadIndexBlockSectors endp


;****************************************************************************
;
;   MultiSectorFixup - fixup a structure read off the disk
;                      to reflect Update Sequence Array.
;
;   ENTRY:  ES:EDI = Target buffer
;
;   USES:   none (preserves all registers with SAVE_ALL/RESTORE_ALL)
;
;   Note: ES:EDI must point at a structure which is protected
;         by an update sequence array, and which begins with
;         a multi-sector-header structure.
;
MultiSectorFixup proc near

    SAVE_ALL

    movzx   ebx, es:[edi].MSH_UpdateArrayOfs    ; ebx = update array offset
    movzx   ecx, es:[edi].MSH_UpdateArraySize   ; ecx = update array size

    or      ecx, ecx        ; if the size of the update sequence array

    jz      BootErr$he      ; is zero, this structure is corrupt.

    add     ebx, edi        ; es:ebx -> update sequence array count word
    add     ebx, 2          ; es:ebx -> 1st entry of update array

    add     edi, SEQUENCE_NUMBER_STRIDE - 2 ; es:edi->last word of first chunk
    dec     ecx             ; decrement to reflect count word

MSF10:

;   ecx = number of entries remaining in update sequence array
;   es:ebx -> next entry in update sequence array
;   es:edi -> next target word for update sequence array

    or      ecx, ecx
    jz      MSF30

    mov     ax, word ptr es:[ebx]   ; copy next update sequence array entry
    mov     word ptr es:[edi], ax   ; to next target word

    add     ebx, 2                      ; go on to next entry
    add     edi, SEQUENCE_NUMBER_STRIDE ; go on to next target

    dec     ecx


    jmp     MSF10

MSF30:

    RESTORE_ALL

    ret

MultiSectorFixup endp

;****************************************************************************
;
;   SetupMft - Reads MFT File Record Segments into the LBN array
;
;   ENTRY:  none.
;
;   EXIT:   NextBuffer is set to the free byte after the last MFT FRS
;           SegmentsInMft is initialized
;
;
SetupMft proc near

        SAVE_ALL

;       Initialize SegmentsInMft and NextBuffer as if the MFT
;       had only one FRS.
;
        mov     eax, 1
        mov     SegmentsInMft, eax

        mov     eax, MftFrs                     ; this is the scratch mft buffer
        add     eax, BytesPerFrs
        mov     MftLcnFrs,eax                   ; this is the scratch mft buffer for lookup
        add     eax, BytesPerFrs
        mov     NextBuffer, eax


;       Read FRS 0 into the first MFT FRS buffer, being sure
;       to resolve the Update Sequence Array.  Remember the physical
;       location in the Lbn array.
;

        mov     eax, MftStartLcn.LowPart
        movzx   ebx, SectorsPerCluster
        mul     ebx                             ; eax = mft starting sector

        mov     ebx, NextBuffer                 ; Store this location in the Lbn array
        mov     [bx], eax
        mov     SectorBase, eax                 ; SectorBase = mft starting sector for read
        add     bx, 4
        mov     eax, SectorsPerFrs
        mov     [bx], eax                       ; Store the sector count in the Lcn array
        mov     SectorCount, ax                 ; SectorCount = SectorsPerFrs
        add     bx, 4
        mov     NextBuffer, ebx                 ; Remember the next Lbn array location

        mov     ebx, MftFrs                     ; Read the sectors into the MftFrs scratch buffer

        push    ds
        pop     es

        call    ReadSectors
        mov     edi, ebx                        ; es:edi = buffer

        call    MultiSectorFixup

;       Determine whether the MFT has an Attribute List attribute

        mov     eax, MftFrs
        mov     ebx, $ATTRIBUTE_LIST
        mov     ecx, 0
        mov     edx, 0

        call    LocateAttributeRecord

        or      eax, eax        ; If there's no Attribute list,
        jz      SetupMft99      ;    we're done!

;       Read the attribute list.
;       eax -> attribute list attribute
;
        mov     ebx, eax        ; ebx -> attribute list attribute
        push    ds
        pop     es              ; copy ds into es
        mov     edi, AttrList   ; ds:edi->attribute list buffer

        call    ReadWholeAttribute

        mov     ebx, AttrList   ; ebx -> first attribute list entry

;       Now, traverse the attribute list looking for the first
;       entry for the $DATA type.  We know it must have at least
;       one.
;
;       ebx -> first attribute list entry
;

SetupMft10:
        cmp     [bx].ATTRLIST_TypeCode, $DATA
        je      SetupMft30

        add     bx,[bx].ATTRLIST_Length
        jmp     SetupMft10


SetupMft20:
;       Scan forward through the attribute list entries for the
;       $DATA attribute, reading each referenced FRS.  Note that
;       there will be at least one non-$DATA entry after the entries
;       for the $DATA attribute, since there's a $BITMAP.
;
;       ebx -> Next attribute list entry
;       NextBuffer    -> Target for next mapping information
;       MftFrs        -> Target of next read
;       SegmentsInMft == number of MFT segments read so far
;

;       Find the physical sector and sector count for the runs for this
;       file record (max 2 runs).  The mapping for this must already
;       be in a file record already visited.  Find the Vcn and cluster
;       offset for this FRS.  Use LookupMftLcn to find the Lcn.

        push    ebx                 ; Save the current position in the attribute list

;       Convert from Frs to sectors, then to Vcn

        mov     eax, [bx].ATTRLIST_SegmentReference.REF_LowPart
        mul     SectorsPerFrs
        push    eax                 ; Remember the VBN
        xor     edx, edx
        movzx   ebx, SectorsPerCluster
        div     ebx                 ; eax = VCN
        push    edx                 ; save remainder, this is cluster offset

        call    ComputeMftLcn       ; eax = LCN

        or      eax, eax            ; LCN equal to zero?

        jz      BootErr$he          ; zero is not a possible LCN

        mov     ecx, SectorsPerFrs  ; ecx = Number of sectors remaining for this file record

;       Change the LCN back into an LBN and add the remainder back in to get
;       the sector we want to read.

        movzx   ebx, SectorsPerCluster
        mul     ebx                 ; eax = cluster first LBN
        pop     edx                 ; edx = sector remainder
        add     eax, edx            ; eax = desired LBN

;       Store this in the current Lcn array slot

        mov     ebx, NextBuffer
        mov     [bx], eax           ; Store the starting sector
        add     bx, 4
        movzx   eax, SectorsPerCluster
        sub     eax, edx

        cmp     eax, ecx            ; Check if we have too many sectors
        jbe     SetupMft60
        mov     eax, ecx            ; Limit ourselves to the sectors remaining
SetupMft60:
        mov     [bx], eax           ; Store the sector count

;       If we have a complete file record skip to process the attribute entry

SetupMft70:
        sub     ecx, eax            ; Subtract these sectors from remaining sectors
        pop     edx                 ; Get the previous starting VBN (restores stack also)

        jz      SetupMft50

;       This may be a split file record.  Go ahead and get the next piece.

        add     eax, edx            ; Add the sector count for the last run to the start Vbn for the run
                                    ; This is the next Vbn to read
        push    eax                 ; Save the Vbn

        xor     edx, edx            ; Convert to Vcn, there should be no remainder this time
        movzx   ebx, SectorsPerCluster
        div     ebx                 ; eax = VCN

        push    ecx                 ; Save the remaining sectors
        call    ComputeMftLcn       ; eax = LCN
        pop     ecx                 ; Restore the remaining sectors

        or      eax, eax            ; LCN equal to zero?
        jz      BootErr$he          ; zero is not a possible LCN

;       Change the LCN back into a LBN to get the starting sector we want to read.

        movzx   ebx, SectorsPerCluster
        mul     ebx                 ; eax = cluster first LBN

;       If this sector is the contiguous with the other half of the run
;       make it appear to be single longer run.

        mov     ebx, NextBuffer     ; Recover the last run
        mov     edx, [bx]
        add     bx, 4
        add     edx, [bx]           ; This is the next potential LBN

        cmp     edx, eax            ; Check if we are at the contiguous LBN
        jne     SetupMft80

;       Append this to the previous run.

        movzx   eax, SectorsPerCluster
        cmp     eax, ecx            ; Check if have more sectors than we need
        jbe     SetupMft90
        mov     eax, ecx
SetupMft90:

        add     [bx], eax
        jmp     SetupMft70          ; Loop to see if there more work to do

;       This is multiple runs.  Update the next entry.

SetupMft80:
        add     bx, 4
        mov     NextBuffer, ebx    ; advance our NextBuffer pointer

        mov     [bx], eax          ; fill in the next run start sector
        add     bx, 4

        movzx   eax, SectorsPerCluster
        cmp     eax, ecx            ; Check if have more sectors than we need
        jbe     SetupMft100
        mov     eax, ecx
SetupMft100:
        mov     [bx], eax          ; and count
        jmp     SetupMft70         ; Loop to see if there is more work to do

SetupMft50:

;       Advance the count of Frs segments and the NextBuffer pointer

        add     bx, 4
        inc     SegmentsInMft
        mov     NextBuffer, ebx

        pop     ebx

;       Go on to the next attribute list entry

SetupMft30:
        add     bx,[bx].ATTRLIST_Length
        cmp     [bx].ATTRLIST_TypeCode, $DATA
        je      SetupMft20

SetupMft99:

        RESTORE_ALL
        ret

SetupMft endp

;****************************************************************************
;
;   ComputeMftLcn   --  Computes the LCN for a cluster of the MFT
;
;
;   ENTRY:  EAX == VCN
;
;   EXIT:   EAX == LCN
;
;   USES:   ALL
;
ComputeMftLcn proc near

        mov     edx, eax                ; edx = VCN

        mov     ecx, SegmentsInMft      ; ecx = # of FRS's to search

        mov     esi,MftLcnFrs
        add     esi,BytesPerFrs         ; si -> FRS LBN list

MftLcn10:
;       ECX == number of remaining FRS's to search
;       EDX == VCN
;       EBX == Buffer to read into
;       ESI == LBN array
;       EDI == Number of sectors to read
;
        push    edx                     ; save VCN
        push    ecx                     ; save MFT segment count
        push    edx                     ; save VCN again

;       Read the sectors for the given FRS

        mov     ebx,MftLcnFrs
        mov     edi,SectorsPerFrs

;       Read these sectors

MftLcn40:
        mov     eax,[si]                ; Get the start sector and sector count
        mov     SectorBase,eax
        add     si,4
        mov     eax,[si]
        mov     SectorCount,ax
        add     si,4

        push    ds
        pop     es

        call    ReadSectors

;       Check if we have more data to read

        sub     edi, eax
        je      MftLcn30

;       Read the next run

        mul     BytesPerSector          ; move forward in the buffer, results in ax:dx
        add     bx,ax
        jmp     MftLcn40

MftLcn30:

;       Do the multi sector fixup

        mov     edi,MftLcnFrs
        push    ds
        pop     es

        call    MultiSectorFixup

        mov     eax, MftLcnFrs
        mov     ebx, $DATA
        mov     ecx, 0
        mov     edx, ecx

        call    LocateAttributeRecord

;       EAX -> $DATA attribute
;       TOS == VCN
;       TOS + 4 == number of remaining FRS's to search
;       TOS + 8 -> FRS being searched
;       TOS +12 == VCN

        or      eax, eax

        jz      BootErr$he  ; No $DATA attribute in this FRS!

        mov     ebx, eax    ; ebx -> attribute
        pop     eax         ; eax = VCN

;       EAX == VCN
;       EBX -> $DATA attribute
;       TOS number of remaining FRS's to search
;       TOS + 4 == FRS being searched
;       TOS + 8 == VCN

        push    esi
        call    ComputeLcn
        pop     esi

        or      eax, eax
        jz      MftLcn20

;       Found our LCN.  Clean up the stack and return.
;
;       EAX == LCN
;       TOS number of remaining FRS's to search
;       TOS + 4 == FRS being searched
;       TOS + 8 == VCN
;
        pop     ebx
        pop     ebx     ; clean up the stack

        ret

MftLcn20:
;
;       Didn't find the VCN in this FRS; try the next one.
;
;       TOS number of remaining FRS's to search
;       TOS + 4 -> FRS being searched
;       TOS + 8 == VCN
;
        pop     ecx     ; ecx = number of FRS's remaining, including current
        pop     edx     ; edx = VCN

        loop    MftLcn10            ; decrement cx and try next FRS

;       This VCN was not found.
;
        xor     eax, eax
        ret


ComputeMftLcn endp

;****************************************************************************
;
;   ReadMftSectors - Read sectors from the MFT
;
;   ENTRY:  EAX == starting VBN
;           ECX == number of sectors to read
;           ES:EDI == Target buffer
;
;   USES:   none (preserves all registers with SAVE_ALL/RESTORE_ALL)
;
ReadMftSectors proc near

    SAVE_ALL

RMS$Again:

    push    eax                     ; save starting VBN
    push    ecx                     ; save sector count

;   Divide the VBN by SectorsPerCluster to get the VCN

    xor     edx, edx                ; zero high part of dividend
    movzx   ebx, SectorsPerCluster
    div     ebx                     ; eax = VCN
    push    edx                     ; save remainder
    push    edi                     ; save the target buffer

    call    ComputeMftLcn           ; eax = LCN
    pop     edi                     ; recover the buffer

    or      eax, eax                ; LCN equal to zero?

    jz      BootErr$he              ; zero is not a possible LCN

;   Change the LCN back into a LBN and add the remainder back in to get
;   the sector we want to read, which goes into SectorBase.
;

    movzx   ebx, SectorsPerCluster
    mul     ebx                     ; eax = cluster first LBN
    pop     edx                     ; edx = sector remainder
    add     eax, edx                ; eax = desired LBN

    mov     SectorBase, eax



;
;   Figure out how many sectors to read this time; we never attempt
;   to read more than one cluster at a time.
;

    pop     ecx                     ; ecx = sectors to read

    movzx   ebx, SectorsPerCluster
    cmp     ecx,ebx
    jle     RMS10

;
;   Read only a single cluster at a time, to avoid problems with fragmented
;   runs in the mft.
;

    mov     SectorCount, bx         ; this time read 1 cluster
    sub     ecx, ebx                ; ecx = sectors remaining to read

    pop     eax                     ; eax = VBN
    add     eax, ebx                ; VBN += sectors this read


    push    eax                     ; save next VBN
    push    ecx                     ; save remaining sector count

    jmp     RMS20

RMS10:

    pop     eax                     ; eax = VBN
    add     eax, ecx                ; VBN += sectors this read
    push    eax                     ; save next VBN

    mov     SectorCount, cx
    mov     ecx, 0
    push    ecx                     ; save remaining sector count (0)

RMS20:


;   The target buffer was passed in es:edi, but we want it in es:bx.
;   Do the conversion.
;

    push    es                      ; save buffer pointer
    push    edi

    mov     bx, di
    and     bx, 0Fh
    mov     ax, es
    shr     edi, 4
    add     ax, di                  ; ax:bx -> target buffer

    push    ax
    pop     es                      ; es:bx -> target buffer

    call    ReadSectors

    pop     edi                     ; restore buffer pointer
    pop     es

    add     edi, BytesPerCluster    ; increment buf ptr by one cluster

    pop     ecx                     ; restore remaining sector count
    pop     eax                     ; restore starting VBN

    cmp     ecx, 0                  ; are we done?
    jg      RMS$Again               ; repeat until desired == 0


    RESTORE_ALL
    ret

ReadMftSectors endp


;****************************************************************************
;
;   ReadFrs - Read an FRS
;
;   ENTRY:  EAX == FRS number
;           ES:EDI == Target buffer
;
;   USES:  none (preserves all registers with SAVE_ALL/RESTORE_ALL)
;
ReadFrs proc near

    SAVE_ALL

    mul     SectorsPerFrs       ; eax = sector number in MFT DATA attribute
                                ; (note that mul wipes out edx!)

    mov     ecx, SectorsPerFrs  ; number of sectors to read

    call    ReadMftSectors
    call    MultiSectorFixup

    RESTORE_ALL
    ret

ReadFrs endp

;****************************************************************************
;
;   ReadIndexBlock - read an index block from the root index.
;
;   ENTRY:  EAX == Block number
;
;   USES:  none (preserves all registers with SAVE_ALL/RESTORE_ALL)
;
ReadIndexBlock proc near

    SAVE_ALL

    mul     SectorsPerIndexBlock        ; eax = first VBN to read
                                        ; (note that mul wipes out edx!)
    mov     ebx, IndexAllocation        ; ebx -> $INDEX_ALLOCATION attribute
    mov     ecx, SectorsPerIndexBlock   ; ecx == Sectors to read

    push    ds
    pop     es
    mov     edi, IndexBlockBuffer       ; es:edi -> index block buffer

    call    ReadIndexBlockSectors

    call    MultiSectorFixup

    RESTORE_ALL
    ret

ReadIndexBlock endp

;****************************************************************************
;
;   IsBlockInUse - Checks the index bitmap to see if an index
;                  allocation block is in use.
;
;   ENTRY:  EAX == block number
;
;   EXIT:   Carry flag clear if block is in use
;           Carry flag set   if block is not in use.
;
IsBlockInUse proc near

        push    eax
        push    ebx
        push    ecx

        mov     ebx, IndexBitmapBuffer

        mov     ecx, eax    ; ecx = block number
        shr     eax, 3      ; eax = byte number
        and     ecx, 7      ; ecx = bit number in byte

        add     ebx, eax    ; ebx -> byte to test

        mov     eax, 1
        shl     eax, cl     ; eax = mask

        test    byte ptr[ebx], al

        jz      IBU10

        clc                 ; Block is not in use.
        jmp     IBU20

IBU10:  stc                 ; Block is in use.

IBU20:
        pop     ecx
        pop     ebx
        pop     eax         ; restore registers

        ret

IsBlockInUse endp

;****************************************************************************
;
;   ComputeLcn - Converts a VCN into an LCN
;
;   ENTRY:  EAX -> VCN
;           EBX -> Attribute
;
;   EXIT:   EAX -> LCN  (zero indicates not found)
;           ECX -> Remaining run length
;
;   USES:   ALL.
;
ComputeLcn proc near

        cmp     [ebx].ATTR_FormCode, NONRESIDENT_FORM
        je      clcn10

        sub     eax, eax    ; This is a resident attribute.
        ret

clcn10: lea     esi, [ebx].ATTR_FormUnion   ; esi -> nonresident info of attrib

;       eax -> VCN
;       ebx -> Attribute
;       esi -> Nonresident information of attribute record
;
;       See if the desired VCN is in range.

        mov     edx, [esi].NONRES_HighestVcn.LowPart ; edx = HighestVcn
        cmp     eax, edx
        ja      clcn15      ; VCN is greater than HighestVcn

        mov     edx, [esi].NONRES_LowestVcn.LowPart ; edx = LowestVcn
        cmp     eax, edx
        jae     clcn20

clcn15:
        sub     eax, eax    ; VCN is not in range
        ret

clcn20:
;       eax -> VCN
;       ebx -> Attribute
;       esi -> Nonresident information of attribute record
;       edx -> LowestVcn
;
        add     bx, [esi].NONRES_MappingPairOffset  ; ebx -> mapping pairs
        sub     esi, esi                            ; esi = 0

clcn30:
;       eax == VCN to find
;       ebx -> Current mapping pair count byte
;       edx == Current VCN
;       esi == Current LCN
;
        cmp     byte ptr[ebx], 0    ; if count byte is zero...
        je      clcn99              ;  ... we're done (and didn't find it)

;       Update CurrentLcn
;
        call    LcnFromMappingPair
        add     esi, ecx            ; esi = current lcn for this mapping pair

        call    VcnFromMappingPair

;       eax == VCN to find
;       ebx -> Current mapping pair count byte
;       ecx == DeltaVcn for current mapping pair
;       edx == Current VCN
;       esi == Current LCN
;
        add     ecx, edx            ; ecx = NextVcn

        cmp     eax, ecx            ; If target < NextVcn ...
        jl      clcn80              ;   ... we found the right mapping pair.

;       Go on to next mapping pair.
;
        mov     edx, ecx            ; CurrentVcn = NextVcn

        push    eax

        movzx   ecx, byte ptr[ebx]  ; ecx = count byte
        mov     eax, ecx            ; eax = count byte
        and     eax, 0fh            ; eax = number of vcn bytes
        shr     ecx, 4              ; ecx = number of lcn bytes

        add     ebx, ecx
        add     ebx, eax
        inc     ebx                 ; ebx -> next count byte

        pop     eax
        jmp     clcn30

clcn80:
;       We found the mapping pair we want.
;
;       eax == target VCN
;       ebx -> mapping pair count byte
;       edx == Starting VCN of run
;       ecx == Next VCN (ie. start of next run)
;       esi == starting LCN of run
;
        sub     ecx, eax            ; ecx = remaining run length
        sub     eax, edx            ; eax = offset into run
        add     eax, esi            ; eax = LCN to return

        ret

;       The target VCN is not in this attribute.

clcn99: sub     eax, eax    ; Not found.
        ret


ComputeLcn endp

;****************************************************************************
;
;   VcnFromMappingPair
;
;   ENTRY:  EBX -> Mapping Pair count byte
;
;   EXIT:   ECX == DeltaVcn from mapping pair
;
;   USES:   ECX
;
VcnFromMappingPair proc near

        sub     ecx, ecx            ; ecx = 0
        mov     cl, byte ptr[ebx]   ; ecx = count byte
        and     cl, 0fh             ; ecx = v

        cmp     ecx, 0              ; if ecx is zero, volume is corrupt.
        jne     VFMP5

        sub     ecx, ecx
        ret

VFMP5:
        push    ebx
        push    edx

        add     ebx, ecx            ; ebx -> last byte of compressed vcn

        movsx   edx, byte ptr[ebx]
        dec     ecx
        dec     ebx

;       ebx -> Next byte to add in
;       ecx == Number of bytes remaining
;       edx == Accumulated value
;
VFMP10: cmp     ecx, 0              ; When ecx == 0, we're done.
        je      VFMP20

        shl     edx, 8
        mov     dl, byte ptr[ebx]

        dec     ebx                 ; Back up through bytes to process.
        dec     ecx                 ; One less byte to process.

        jmp     VFMP10

VFMP20:
;       edx == Accumulated value to return

        mov     ecx, edx

        pop     edx
        pop     ebx

        ret

VcnFromMappingPair endp


;****************************************************************************
;
;   LcnFromMappingPair
;
;   ENTRY:  EBX -> Mapping Pair count byte
;
;   EXIT:   ECX == DeltaLcn from mapping pair
;
;   USES:   ECX
;
LcnFromMappingPair proc near

        push    ebx
        push    edx

        sub     edx, edx            ; edx = 0
        mov     dl, byte ptr[ebx]   ; edx = count byte
        and     edx, 0fh            ; edx = v

        sub     ecx, ecx            ; ecx = 0
        mov     cl, byte ptr[ebx]   ; ecx = count byte
        shr     cl, 4               ; ecx = l

        cmp     ecx, 0              ; if ecx is zero, volume is corrupt.
        jne     LFMP5

        sub     ecx, ecx

        pop     edx
        pop     ebx
        ret

LFMP5:
;       ebx -> count byte
;       ecx == l
;       edx == v
;

        add     ebx, edx            ; ebx -> last byte of compressed vcn
        add     ebx, ecx            ; ebx -> last byte of compressed lcn

        movsx   edx, byte ptr[ebx]
        dec     ecx
        dec     ebx

;       ebx -> Next byte to add in
;       ecx == Number of bytes remaining
;       edx == Accumulated value
;
LFMP10: cmp     ecx, 0              ; When ecx == 0, we're done.
        je      LFMP20

        shl     edx, 8
        mov     dl, byte ptr[ebx]

        dec     ebx                 ; Back up through bytes to process.
        dec     ecx                 ; One less byte to process.

        jmp     LFMP10

LFMP20:
;       edx == Accumulated value to return

        mov     ecx, edx

        pop     edx
        pop     ebx

        ret

LcnFromMappingPair endp

;****************************************************************************
;
; UpcaseName - Converts the name of the file to all upper-case
;
;       ENTRY:  ESI -> Name
;               ECX -> Length of name
;
;       USES:   none
;
UpcaseName proc   near


        or      ecx, ecx
        jnz     UN5

        ret

UN5:
        push    ecx
        push    esi

UN10:
        cmp     word ptr[esi], 'a'      ; if it's less than 'a'
        jl      UN20                    ; leave it alone

        cmp     word ptr[esi], 'z'      ; if it's greater than 'z'
        jg      UN20                    ; leave it alone.

        sub     word ptr[esi], 'a'-'A'  ; the letter is lower-case--convert it.
UN20:
        add     esi, 2                  ; move on to next unicode character
        loop    UN10

        pop     esi
        pop     ecx

        ret
UpcaseName endp

;****************************************************************************
;
;   FindFile - Locates the index entry for a file in the root index.
;
;   ENTRY:  EAX -> name to find
;           ECX == length of file name in characters
;
;   EXIT:   EAX -> Index Entry.  NULL to indicate failure.
;
;   USES:   ALL
;
FindFile proc near

        push    eax     ; name address
        push    ecx     ; name length

;       First, search the index root.
;
;       eax -> name to find
;       ecx == name length
;       TOS == name length
;       TOS+4 -> name to find
;
        mov     edx, eax                    ; edx -> name to find
        mov     eax, IndexRoot              ; eax -> &INDEX_ROOT attribute
        lea     ebx, [eax].ATTR_FormUnion   ; ebx -> resident info
        add     ax, [ebx].RES_ValueOffset   ; eax -> Index Root value

        lea     eax, [eax].IR_IndexHeader   ; eax -> Index Header

        mov     ebx, edx                    ; ebx -> name to find

        call    LocateIndexEntry

        or      eax, eax
        jz      FindFile20

;       Found it in the root!  The result is already in eax.
;       Clean up the stack and return.
;
        pop     ecx
        pop     ecx
        ret

FindFile20:
;
;       We didn't find the index entry we want in the root, so we have to
;       crawl through the index allocation buffers.
;
;       TOS == name length
;       TOS+4 -> name to find
;
        mov     eax, IndexAllocation
        or      eax, eax
        jnz     FindFile30

;       There is no index allocation attribute; clean up
;       the stack and return failure.
;
        pop     ecx
        pop     ecx
        xor     eax, eax
        ret

FindFile30:
;
;       Search the index allocation blocks for the name we want.
;       Instead of searching in tree order, we'll just start with
;       the last one and work our way backwards.
;
;       TOS == name length
;       TOS+4 -> name to find
;
        mov     edx, IndexAllocation        ; edx -> index allocation attr.
        lea     edx, [edx].ATTR_FormUnion   ; edx -> nonresident form info
        mov     eax, [edx].NONRES_HighestVcn.LowPart; eax = HighestVcn
        inc     eax                         ; eax = clusters in attribute

        mov     ebx, BytesPerCluster
        mul     ebx                         ; eax = bytes in attribute

        xor     edx, edx
        div     BytesPerIndexBlock          ; convert bytes to index blocks

        push    eax                         ; number of blocks to process

FindFile40:
;
;       TOS == remaining index blocks to search
;       TOS + 4 == name length
;       TOS + 8 -> name to find
;
        pop     eax         ; eax == number of remaining blocks

        or      eax, eax
        jz      FindFile90

        dec     eax         ; eax == number of next block to process
                            ;        and number of remaining blocks

        push    eax

;       eax == block number to process
;       TOS == remaining index blocks to search
;       TOS + 4 == name length
;       TOS + 8 -> name to find
;
;       See if the block is in use; if not, go on to next.

        call    IsBlockInUse
        jc      FindFile40      ; c set if not in use

;       eax == block number to process
;       TOS == remaining index blocks to search
;       TOS + 4 == name length
;       TOS + 8 -> name to find
;

        call    ReadIndexBlock

        pop     edx         ; edx == remaining buffers to search
        pop     ecx         ; ecx == name length
        pop     ebx         ; ebx -> name

        push    ebx
        push    ecx
        push    edx

;       ebx -> name to find
;       ecx == name length in characters
;       TOS == remaining blocks to process
;       TOS + 4 == name length
;       TOS + 8 -> name
;
;       Index buffer to search is in index allocation block buffer.
;
        mov     eax, IndexBlockBuffer       ; eax -> Index allocation block
        lea     eax, [eax].IB_IndexHeader   ; eax -> Index Header

        call    LocateIndexEntry            ; eax -> found entry

        or      eax, eax
        jz      FindFile40

;       Found it!
;
;       eax -> Found entry
;       TOS == remaining blocks to process
;       TOS + 4 == name length
;       TOS + 8 -> name
;
        pop     ecx
        pop     ecx
        pop     ecx ; clean up stack
        ret

FindFile90:
;
;       Name not found.
;
;       TOS == name length
;       TOS + 4 -> name to find
;
        pop     ecx
        pop     ecx         ; clean up stack.
        xor     eax, eax    ; zero out eax.
        ret


FindFile endp

ifdef DEBUG
;****************************************************************************
;
;   DumpIndexBlock - dumps the index block buffer
;
DumpIndexBlock proc near

    SAVE_ALL

    mov     esi, IndexBlockBuffer

    mov     ecx, 20h    ; dwords to dump

DIB10:

    test    ecx, 3
    jnz     DIB20
    call    DebugNewLine

DIB20:

    lodsd
    call    PrintNumber
    loop    DIB10

    RESTORE_ALL
    ret

DumpIndexBlock endp

;****************************************************************************
;
;   DebugNewLine
;
DebugNewLine proc near

    SAVE_ALL

    xor     eax, eax
    xor     ebx, ebx

    mov     al, 0dh
    mov     ah, 14
    mov     bx, 7
    int     10h

    mov     al, 0ah
    mov     ah, 14
    mov     bx, 7
    int     10h

    RESTORE_ALL
    ret

DebugNewLine endp


;****************************************************************************
;
;   PrintName  -   Display a unicode name
;
;   ENTRY:  DS:ESI  -> null-terminated string
;           ECX     == characters in string
;
;   USES:   None.
;
PrintName proc near


    SAVE_ALL

    or      ecx, ecx
    jnz     PrintName10

    call    DebugNewLine

    RESTORE_ALL

    ret

PrintName10:

    xor     eax, eax
    xor     ebx, ebx

    lodsw

    mov     ah, 14  ; write teletype
    mov     bx, 7   ; attribute
    int     10h     ; print it
    loop    PrintName10

    call    DebugNewLine

    RESTORE_ALL
    ret

PrintName endp

;****************************************************************************
;
;   DebugPrint  -   Display a debug string.
;
;   ENTRY:  DS:SI  -> null-terminated string
;
;   USES:   None.
;
.286
DebugPrint proc near

    pusha

DbgPr20:

    lodsb
    cmp     al, 0
    je      DbgPr30

    mov     ah, 14  ; write teletype
    mov     bx, 7   ; attribute
    int     10h     ; print it
    jmp     DbgPr20

DbgPr30:

    popa
    nop
    ret

DebugPrint endp

;****************************************************************************
;
;
;   PrintNumber
;
;   ENTRY: EAX == number to print
;
;   PRESERVES ALL REGISTERS
;
.386
PrintNumber proc near


    SAVE_ALL

    mov     ecx, 8      ; number of digits in a DWORD

PrintNumber10:

    mov     edx, eax
    and     edx, 0fh    ; edx = lowest-order digit
    push    edx         ; put it on the stack
    shr     eax, 4      ; drop low-order digit
    loop    PrintNumber10

    mov     ecx, 8      ; number of digits on stack.

PrintNumber20:

    pop     eax         ; eax = next digit to print
    cmp     eax, 9
    jg      PrintNumber22

    add     eax, '0'
    jmp     PrintNumber25

PrintNumber22:

    sub     eax, 10
    add     eax, 'A'

PrintNumber25:

    xor     ebx, ebx

    mov     ah, 14
    mov     bx, 7
    int     10h
    loop    PrintNumber20

;   Print a space to separate numbers

    mov     al, ' '
    mov     ah, 14
    mov     bx, 7
    int     10h

    RESTORE_ALL

    call    Pause

    ret

PrintNumber endp


;****************************************************************************
;
;   Debug0 - Print debug string 0 -- used for checkpoints in mainboot
;
Debug0 proc near

    SAVE_ALL

    mov     si, offset DbgString0
    call    BootErr$Print1

    RESTORE_ALL

    ret

Debug0 endp

;****************************************************************************
;
;   Debug1 - Print debug string 1 --
;
Debug1 proc near

    SAVE_ALL

    mov     si, offset DbgString1
    call    BootErr$Print1

    RESTORE_ALL

    ret

Debug1 endp

;****************************************************************************
;
;   Debug2 - Print debug string 2
;
Debug2 proc near

    SAVE_ALL

    mov     si, offset DbgString2
    call    BootErr$Print1

    RESTORE_ALL

    ret

Debug2 endp

;****************************************************************************
;
;   Debug3 - Print debug string 3 --
;
Debug3 proc near

    SAVE_ALL

    mov     si, offset DbgString3
    call    BootErr$Print1

    RESTORE_ALL

    ret

Debug3 endp

;****************************************************************************
;
;   Debug4 - Print debug string 4
;
Debug4 proc near

    SAVE_ALL

    mov     si, offset DbgString4
    call    BootErr$Print1

    RESTORE_ALL

    ret

Debug4 endp

;****************************************************************************
;
;   Pause - Pause for about 1/2 a second.  Simply count until you overlap
;           to zero.
;
Pause proc near

    push eax
    mov  eax, 0fff10000h

PauseLoopy:
    inc  eax

    or   eax, eax
    jnz  PauseLoopy

    pop  eax
    ret

Pause endp

endif ; DEBUG

;*************************************************************************
;
;       LoadIndexFrs  -  For the requested index type code locate and
;                        load the associated Frs.
;
;       ENTRY: EAX - requested index type code
;              ECX - Points to empty Frs buffer
;
;       EXIT:  EAX - points to offset in Frs buffer of requested index type
;                    code or Zero if not found.
;       USES:  All
;
LoadIndexFrs    proc    near

        push    ecx                     ; save FRS buffer for later
        push    eax                     ; save index type code for later

        mov     eax, ROOT_FILE_NAME_INDEX_NUMBER
        push    ds
        pop     es
        mov     edi, ecx                ; es:edi = target buffer

        call    ReadFrs

        mov     eax, ecx                ; FRS to search

        pop     ebx                     ; Attribute type code
        push    ebx
        movzx   ecx, index_name_length  ; Attribute name length
        mov     edx, offset index_name  ; Attribute name

        call    LocateAttributeRecord

        pop     ebx
        pop     ecx

        or      eax, eax
        jnz     LoadIndexFrs$Exit      ; if found in root return

;
;       if not found in current Frs, search in attribute list
;
                                       ; EBX - holds Attribute type code
        mov     eax, ecx               ; FRS to search
        mov     ecx, ebx               ; type code
        push    eax                    ; save Frs
        push    ebx                    ; save type code

        call    SearchAttrList          ; search attribute list for FRN
                                        ; of specified ($INDEX_ROOT,
                                        ; $INDEX_ALLOCATION, or $BITMAP)

        ; EAX - holds FRN for Frs, or Zero

        pop     ebx                     ; Attribute type code (used later)
        pop     edi                     ; es:edi = target buffer

        or      eax, eax                ; if we cann't find it in attribute
        jz      LoadIndexFrs$Exit       ; list then we are hosed


;       We should now have the File Record Number where the index for the
;       specified type code we are searching for is,  load this into the
;       Frs target buffer.
;
;       EAX - holds FRN
;       EBX - holds type code
;       EDI - holds target buffer

        push    ds
        pop     es

        call    ReadFrs

;
;       Now determine the offset in the Frs of the index
;

;       EBX - holds type code

        mov     eax, edi                ; Frs to search
        movzx   ecx, index_name_length  ; Attribute name length
        mov     edx, offset index_name  ; Attribute name

        call    LocateAttributeRecord

;       EAX -  holds offset or Zero.


LoadIndexFrs$Exit:
        ret

LoadIndexFrs    endp


;****************************************************************************
;
;   SearchAttrList
;
;   Search the Frs for the attribute list.  Then search the attribute list
;   for the specifed type code.  When you find it return the FRN in the
;   attribute list entry found or Zero if no match found.
;
;   ENTRY: ECX - type code to search attrib list for
;          EAX - Frs buffer holding head of attribute list
;   EXIT:  EAX - FRN file record number to load, Zero if none.
;
;   USES: All
;
SearchAttrList proc  near

        push    ecx                     ; type code to search for in
                                        ; attrib list

                                        ; EAX - holds Frs to search
        mov     ebx, $ATTRIBUTE_LIST    ; Attribute type code
        mov     ecx, 0                  ; Attribute name length
        mov     edx, 0                  ; Attribute name

        call    LocateAttributeRecord

        or      eax, eax                      ; If there's no Attribute list,
        jz      SearchAttrList$NotFoundIndex1 ; We are done

;       Read the attribute list.
;       eax -> attribute list attribute

        mov     ebx, eax        ; ebx -> attribute list attribute
        push    ds
        pop     es              ; copy ds into es
        mov     edi, AttrList   ; ds:edi->attribute list buffer

        call    ReadWholeAttribute

        push    ds
        pop     es
        mov     ebx, AttrList   ; es:ebx -> first attribute list entry

;       Now, traverse the attribute list looking for the entry for
;       the Index type code.
;
;       ebx -> first attribute list entry
;

        pop     ecx                            ; Get Index Type code


SearchAttrList$LookingForIndex:

ifdef DEBUG
        SAVE_ALL

        mov     eax, es:[bx].ATTRLIST_TypeCode
        call    PrintNumber
        movzx   eax, es:[bx].ATTRLIST_Length
        call    PrintNumber
        mov     eax, es
        call    PrintNumber
        mov     eax, ebx
        call    PrintNumber
        push    es
        pop     ds
        movzx   ecx, es:[bx].ATTRLIST_NameLength    ; ecx = chars in name
        lea     esi, es:[bx].ATTRLIST_Name          ; esi -> name
        call    PrintName

        RESTORE_ALL
endif ; DEBUG

        cmp     es:[bx].ATTRLIST_TypeCode, ecx
        je      SearchAttrList$FoundIndex

        cmp     es:[bx].ATTRLIST_TypeCode, $END   ; reached invalid attribute
        je      SearchAttrList$NotFoundIndex2     ; so must be at end

        cmp     es:[bx].ATTRLIST_Length, 0
        je      SearchAttrList$NotFoundIndex2     ; reached end of list and
                                                  ; nothing found
        movzx   eax, es:[bx].ATTRLIST_Length
        add     bx, ax

        mov     ax, bx
        and     ax, 08000h                        ; test for roll over
        jz      SearchAttrList$LookingForIndex

        ;  If we rolled over then increment to the next es 32K segment and
        ;  zero off the high bits of bx

        mov     ax, es
        add     ax, 800h
        mov     es, ax

        and     bx, 07fffh

        jmp     SearchAttrList$LookingForIndex

SearchAttrList$FoundIndex:

        ;  found the index, return the FRN

        mov     eax, es:[bx].ATTRLIST_SegmentReference.REF_LowPart
        ret


SearchAttrList$NotFoundIndex1:
        pop     ecx
SearchAttrList$NotFoundIndex2:
        xor     eax, eax
        ret

SearchAttrList endp

;
; Boot message printing, relocated from sector 0 to sace space
;
BootErr$fnf:
        mov     al,byte ptr TXT_MSG_SYSINIT_FILE_NOT_FD
        jmp     BootErr2
BootErr$ntc:
        mov     al,byte ptr TXT_MSG_SYSINIT_NTLDR_CMPRS
        jmp     BootErr2

ifdef DEBUG
DbgString0      db  "Debug Point 0", 0Dh, 0Ah, 0
DbgString1      db  "Debug Point 1", 0Dh, 0Ah, 0
DbgString2      db  "Debug Point 2", 0Dh, 0Ah, 0
DbgString3      db  "Debug Point 3", 0Dh, 0Ah, 0
DbgString4      db  "Debug Point 4", 0Dh, 0Ah, 0

endif ; DEBUG

        .errnz  ($-_ntfsboot) GT 8192   ; <FATAL PROBLEM: main boot record exceeds available space>

        org     8192

BootCode ends

         end _ntfsboot
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\ntfs\ia64\bootimage.c ===
//
// readbpb.c
//copyright (c) 1994 by CuTEST Inc.

#include "windows.h"
#include "stdio.h"
#include "stdlib.h"
#include "winioctl.h"

int main(int argc, char *argv[])
{
    ULONG       Value;
    UCHAR       Buffer[8012];
    HANDLE      Source, Target;
    DWORD       BytesRead, BytesWritten;
    ULONG       err;
    int         i;
    
    if ((Source = CreateFile( "ntfsboot.com",
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                              )) == ((HANDLE)-1))  {

	printf("Can't get a handle to ntfsboot.com\n");
	err = GetLastError();
	printf("error = %d\n", err);
	return 0;
    }
    printf("Open to ntfsboot.com succeeded\n");

    if ((Target = CreateFile( "bootntfs.h",
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                              )) == ((HANDLE)-1))  {

	printf("Can't get a handle to bootntfs.h\n");
	err = GetLastError();
	printf("error = %d\n", err);
	return 0;
    }
    printf("Open to bootntfs.h succeeded\n");

    sprintf(Buffer, "#define NTFSBOOTCODE_SIZE 32768\n\n\n");
    WriteFile(Target, Buffer, strlen(Buffer), &BytesWritten, NULL);

    sprintf(Buffer, "unsigned char NtfsBootCode[] = {\n");
    WriteFile(Target, Buffer, strlen(Buffer), &BytesWritten, NULL);

    printf("Starting Do-While loop\n");
    i = 0;
    do {
        ReadFile(Source, &Value, 1, &BytesRead, NULL);
        _itoa(Value, Buffer, 10);
        WriteFile(Target, Buffer, strlen(Buffer), &BytesWritten, NULL);

        sprintf(Buffer, ",");
        WriteFile(Target, Buffer, strlen(Buffer), &BytesWritten, NULL);
        
        if ((i != 0) && (i % 16 == 0)) {
            sprintf(Buffer, "\n");
            WriteFile(Target, Buffer, strlen(Buffer), &BytesWritten, NULL);
        }
        i++;

    } while (BytesRead);

    sprintf(Buffer, "};\n");
    WriteFile(Target, Buffer, strlen(Buffer), &BytesWritten, NULL);

    CloseHandle(Source);
    CloseHandle(Target);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\ntfs\ia64\makefile.inc ===
#
# dummy makefile.inc
#
BOOT_FILE=$(_OBJ_DIR)\ia64\ntfsboot.obj $(_OBJ_DIR)\ia64\miscc.obj
SIMSAL_FILE=$(_OBJ_DIR)\ia64\simsal.obj $(_OBJ_DIR)\ia64\miscc.obj

$(O)\ntfsboot.exe:$(BOOT_OBJ) makefile.inc
        -ilink -out:$(O)\ntfsboot.exe @$(TARGET_DIRECTORY)boot.rsp

$(O)\simsal.exe:$(BOOT_OBJ) makefile.inc
        -ilink -out:$(O)\simsal.exe @simsal.rsp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\ntfs\ia64\genntfs.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
//      without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    genntfs.c

Abstract:

    This module implements a program which generates IA64 machine dependent
    structure offset definitions for kernel structures that are accessed in
    assembly code.

Author:

    David N. Cutler (davec) 27-Mar-1990

Revision History:

    Allen M. Kay (akay) 25-Jan-1996          Modified this file for IA64.

--*/

//#include "ki.h"
//#pragma hdrstop
//#define HEADER_FILE
#include "ntos.h"
#include "stdio.h"
#include "stdlib.h"
#include "zwapi.h"
#include "nt.h"
#include "excpt.h"
#include "ntdef.h"
#include "ntkeapi.h"
#include "ntia64.h"
#include "ntimage.h"
#include "ntseapi.h"
#include "ntobapi.h"
#include "ntlpcapi.h"
#include "ntioapi.h"
#include "ntmmapi.h"
#include "ntldr.h"
#include "ntpsapi.h"
#include "ntexapi.h"
#include "ntnls.h"
#include "nturtl.h"
#include "ntcsrmsg.h"
#include "ntcsrsrv.h"
#include "ntxcapi.h"
#include "ia64.h"
#include "arc.h"
#include "ntstatus.h"
#include "kxia64.h"
#include "stdarg.h"
#include "setjmp.h"
#include "ntioapi.h"
#include "fsrtl.h"
//#include "index.h"
#include "nodetype.h"
#include "ntfs.h"
#include "ntfsstru.h"
#include "ntfsdata.h"
#include "ntfslog.h"
#include "ntfsproc.h"

//
// Define architecture specific generation macros.
//

#define genAlt(Name, Type, Member) \
    dumpf("#define " #Name " 0x%lx\n", OFFSET(Type, Member))

#define genCom(Comment)        \
    dumpf("\n");               \
    dumpf("//\n");             \
    dumpf("// " Comment "\n"); \
    dumpf("//\n");             \
    dumpf("\n")

#define genDef(Prefix, Type, Member) \
    dumpf("#define " #Prefix #Member " 0x%lx\n", OFFSET(Type, Member))

#define genDef2(Prefix, Type, Name, Member) \
    dumpf("#define " #Prefix #Name " 0x%lx\n", OFFSET(Type, Member))

#define genVal(Name, Value)    \
    dumpf("#define " #Name " 0x%lx\n", Value)

#define genSpc() dumpf("\n");

//
// Define member offset computation macro.
//

#define OFFSET(type, field) ((LONG)(&((type *)0)->field))

FILE *NtfsDefs;

//
// EnableInc(a) - Enables output to goto specified include file
//
#define EnableInc(a)    OutputEnabled |= a;

//
// DisableInc(a) - Disables output to goto specified include file
//
#define DisableInc(a)   OutputEnabled &= ~a;

ULONG OutputEnabled;

#define NTFSDEFS    0x01

#define KERNEL NTFSDEFS

VOID dumpf (const char *format, ...);

//
// This routine returns the bit number right to left of a field.
//

LONG
t (
    IN ULONG z
    )

{
    LONG i;

    for (i = 0; i < 32; i += 1) {
        if ((z >> i) & 1) {
            break;
        }
    }
    return i;
}

//
// This program generates the IA64 machine dependent assembler offset
// definitions.
//

VOID
main (argc, argv)
    int argc;
    char *argv[];
{

    char *outName;

    //
    // Create file for output.
    //

    if (argc == 2) {
        outName = argv[ 1 ];
    } else {
        outName = "ntfsdefs.h";
    }
    outName = argc >= 2 ? argv[1] : "ntfsdefs.h";
    NtfsDefs = fopen( outName, "w" );

    if (NtfsDefs == NULL) {
        fprintf( stderr, "GENNTFS: Cannot open %s for writing.\n", outName);
        perror("NTFSDEFS");
        exit(1);
    }

    fprintf( stderr, "GENNTFS: Writing %s header file.\n", outName );

    //
    // Constant definitions
    //

    dumpf("\n");
    dumpf("//\n");
    dumpf("// Constant definitions\n");
    dumpf("//\n");
    dumpf("\n");

    genVal(LowPart, 0);
    genVal(HighPart, 4);
    genVal(MASTER_FILE_TABLE_NUMBER, MASTER_FILE_TABLE_NUMBER);
    genVal(MASTER_FILE_TABLE2_NUMBER, MASTER_FILE_TABLE2_NUMBER);
    genVal(LOG_FILE_NUMBER, LOG_FILE_NUMBER);
    genVal(VOLUME_DASD_NUMBER, VOLUME_DASD_NUMBER);
    genVal(ATTRIBUTE_DEF_TABLE_NUMBER, ATTRIBUTE_DEF_TABLE_NUMBER);
    genVal(ROOT_FILE_NAME_INDEX_NUMBER, ROOT_FILE_NAME_INDEX_NUMBER);
    genVal(BIT_MAP_FILE_NUMBER, BIT_MAP_FILE_NUMBER);
    genVal(BOOT_FILE_NUMBER, BOOT_FILE_NUMBER);
    genVal(BAD_CLUSTER_FILE_NUMBER, BAD_CLUSTER_FILE_NUMBER);
    genVal(QUOTA_TABLE_NUMBER, QUOTA_TABLE_NUMBER);
    genVal(UPCASE_TABLE_NUMBER, UPCASE_TABLE_NUMBER);
    genVal($STANDARD_INFORMATION, $STANDARD_INFORMATION);
    genVal($ATTRIBUTE_LIST, $ATTRIBUTE_LIST);
    genVal($FILE_NAME, $FILE_NAME);
    genVal($OBJECT_ID, $OBJECT_ID);
    genVal($SECURITY_DESCRIPTOR, $SECURITY_DESCRIPTOR);
    genVal($VOLUME_NAME, $VOLUME_NAME);
    genVal($VOLUME_INFORMATION, $VOLUME_INFORMATION);
    genVal($DATA, $DATA);
    genVal($INDEX_ROOT, $INDEX_ROOT);
    genVal($INDEX_ALLOCATION, $INDEX_ALLOCATION);
    genVal($BITMAP, $BITMAP);
    genVal($SYMBOLIC_LINK, $SYMBOLIC_LINK);
    genVal($EA_INFORMATION, $EA_INFORMATION);
    genVal($EA, $EA);
    genVal($FIRST_USER_DEFINED_ATTRIBUTE, $FIRST_USER_DEFINED_ATTRIBUTE);
    genVal($END, $END);

    genVal(SEQUENCE_NUMBER_STRIDE, SEQUENCE_NUMBER_STRIDE);

    //
    // MFT_SEGMENT_REFERENCE
    //
    genDef(REF_, MFT_SEGMENT_REFERENCE, SegmentNumberLowPart);
    genDef(REF_, MFT_SEGMENT_REFERENCE, SegmentNumberHighPart);
    genDef(REF_, MFT_SEGMENT_REFERENCE, SequenceNumber);

    //
    // MULTI_SECTOR_HEADER
    //
    genDef(MSH_, MULTI_SECTOR_HEADER, Signature);
    genDef(MSH_, MULTI_SECTOR_HEADER, UpdateSequenceArrayOffset);
    genDef(MSH_, MULTI_SECTOR_HEADER, UpdateSequenceArraySize);

    //
    // FILE_RECORD_SEGMENT_HEADER
    //
    genDef(FRS_, FILE_RECORD_SEGMENT_HEADER, MultiSectorHeader);
    genDef(FRS_, FILE_RECORD_SEGMENT_HEADER, Lsn);
    genDef(FRS_, FILE_RECORD_SEGMENT_HEADER, SequenceNumber);
    genDef(FRS_, FILE_RECORD_SEGMENT_HEADER, ReferenceCount);
    genDef(FRS_, FILE_RECORD_SEGMENT_HEADER, FirstAttributeOffset);
    genDef(FRS_, FILE_RECORD_SEGMENT_HEADER, Flags);
    genDef(FRS_, FILE_RECORD_SEGMENT_HEADER, FirstFreeByte);
    genDef(FRS_, FILE_RECORD_SEGMENT_HEADER, BytesAvailable);
    genDef(FRS_, FILE_RECORD_SEGMENT_HEADER, BaseFileRecordSegment);
    genDef(FRS_, FILE_RECORD_SEGMENT_HEADER, NextAttributeInstance);
    genDef(FRS_, FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly);

    genVal(FILE_RECORD_SEGMENT_IN_USE, FILE_RECORD_SEGMENT_IN_USE);
    genVal(FILE_FILE_NAME_INDEX_PRESENT, FILE_FILE_NAME_INDEX_PRESENT);

    //
    // ATTRIBUTE_RECORD_HEADER
    //
    genDef(ATTR_, ATTRIBUTE_RECORD_HEADER, TypeCode);
    genDef(ATTR_, ATTRIBUTE_RECORD_HEADER, RecordLength);
    genDef(ATTR_, ATTRIBUTE_RECORD_HEADER, FormCode);
    genDef(ATTR_, ATTRIBUTE_RECORD_HEADER, NameLength);
    genDef(ATTR_, ATTRIBUTE_RECORD_HEADER, NameOffset);
    genDef(ATTR_, ATTRIBUTE_RECORD_HEADER, Flags);
    genDef(ATTR_, ATTRIBUTE_RECORD_HEADER, Instance);
    genDef(ATTR_, ATTRIBUTE_RECORD_HEADER, Form);

    //
    // Resident
    //
    genDef2(RES_,ATTRIBUTE_RECORD_HEADER,ValueLength,Form.Resident.ValueLength);
    genDef2(RES_,ATTRIBUTE_RECORD_HEADER,ValueOffset,Form.Resident.ValueOffset);
    genDef2(RES_,ATTRIBUTE_RECORD_HEADER,ResidentFlags,Form.Resident.ResidentFlags);
    genDef2(RES_,ATTRIBUTE_RECORD_HEADER,Reserved,Form.Resident.Reserved);

    //
    // Nonresident
    //
    genDef2(NONRES_,ATTRIBUTE_RECORD_HEADER,LowestVcn,Form.Nonresident.LowestVcn);
    genDef2(NONRES_,ATTRIBUTE_RECORD_HEADER,HighestVcn,Form.Nonresident.HighestVcn);
    genDef2(NONRES_,ATTRIBUTE_RECORD_HEADER,MappingPairOffset,Form.Nonresident.MappingPairsOffset);
    genDef2(NONRES_,ATTRIBUTE_RECORD_HEADER,CompressionUnit,Form.Nonresident.CompressionUnit);
    genDef2(NONRES_,ATTRIBUTE_RECORD_HEADER,Reserved,Form.Nonresident.Reserved);
    genDef2(NONRES_,ATTRIBUTE_RECORD_HEADER,AllocatedLength,Form.Nonresident.AllocatedLength);
    genDef2(NONRES_,ATTRIBUTE_RECORD_HEADER,FileSize,Form.Nonresident.FileSize);
    genDef2(NONRES_,ATTRIBUTE_RECORD_HEADER,ValidDataLength,Form.Nonresident.ValidDataLength);
    genDef2(NONRES_,ATTRIBUTE_RECORD_HEADER,TotalAllocated,Form.Nonresident.TotalAllocated);

    genVal(RESIDENT_FORM, RESIDENT_FORM);
    genVal(NONRESIDENT_FORM, NONRESIDENT_FORM);
    genVal(ATTRIBUTE_FLAG_COMPRESSION_MASK, ATTRIBUTE_FLAG_COMPRESSION_MASK);

    //
    // ATTRIBUTE_LIST_ENTRY
    //
    genDef(ATTRLIST_, ATTRIBUTE_LIST_ENTRY, AttributeTypeCode);
    genDef(ATTRLIST_, ATTRIBUTE_LIST_ENTRY, RecordLength);
    genDef(ATTRLIST_, ATTRIBUTE_LIST_ENTRY, AttributeNameLength);
    genDef(ATTRLIST_, ATTRIBUTE_LIST_ENTRY, AttributeNameOffset);
    genDef(ATTRLIST_, ATTRIBUTE_LIST_ENTRY, LowestVcn);
    genDef(ATTRLIST_, ATTRIBUTE_LIST_ENTRY, SegmentReference);
    genDef(ATTRLIST_, ATTRIBUTE_LIST_ENTRY, Instance);
    genDef(ATTRLIST_, ATTRIBUTE_LIST_ENTRY, AttributeName);

    genVal(FAT_DIRENT_ATTR_READ_ONLY, FAT_DIRENT_ATTR_READ_ONLY);
    genVal(FAT_DIRENT_ATTR_HIDDEN, FAT_DIRENT_ATTR_HIDDEN);
    genVal(FAT_DIRENT_ATTR_SYSTEM, FAT_DIRENT_ATTR_SYSTEM);
    genVal(FAT_DIRENT_ATTR_VOLUME_ID, FAT_DIRENT_ATTR_VOLUME_ID);
    genVal(FAT_DIRENT_ATTR_ARCHIVE, FAT_DIRENT_ATTR_ARCHIVE);
    genVal(FAT_DIRENT_ATTR_DEVICE, FAT_DIRENT_ATTR_DEVICE);

    //
    // DUPLICATED_INFORMATION
    //
    genDef(DUPINFO_, DUPLICATED_INFORMATION, CreationTime);
    genDef(DUPINFO_, DUPLICATED_INFORMATION, LastModificationTime);
    genDef(DUPINFO_, DUPLICATED_INFORMATION, LastChangeTime);
    genDef(DUPINFO_, DUPLICATED_INFORMATION, LastAccessTime);
    genDef(DUPINFO_, DUPLICATED_INFORMATION, AllocatedLength);
    genDef(DUPINFO_, DUPLICATED_INFORMATION, FileSize);
    genDef(DUPINFO_, DUPLICATED_INFORMATION, FileAttributes);
    genDef(DUPINFO_, DUPLICATED_INFORMATION, PackedEaSize);
    genDef(DUPINFO_, DUPLICATED_INFORMATION, Reserved);

    //
    // FILE_NAME
    //
    genDef(FN_, FILE_NAME, ParentDirectory);
    genDef(FN_, FILE_NAME, Info);
    genDef(FN_, FILE_NAME, FileNameLength);
    genDef(FN_, FILE_NAME, Flags);
    genDef(FN_, FILE_NAME, FileName);

    genVal(FILE_NAME_NTFS, FILE_NAME_NTFS);
    genVal(FILE_NAME_DOS, FILE_NAME_DOS);
    genVal(FILE_NAME_LINK, 4);

    //
    // INDEX_HEADER
    //
    genDef(IH_, INDEX_HEADER, FirstIndexEntry);
    genDef(IH_, INDEX_HEADER, FirstFreeByte);
    genDef(IH_, INDEX_HEADER, BytesAvailable);
    genDef(IH_, INDEX_HEADER, Flags);
    genDef(IH_, INDEX_HEADER, Reserved);

    genVal(INDEX_NODE, INDEX_NODE);

    //
    // INDEX_ROOT
    //
    genDef(IR_, INDEX_ROOT, IndexedAttributeType);
    genDef(IR_, INDEX_ROOT, CollationRule);
    genDef(IR_, INDEX_ROOT, BytesPerIndexBuffer);
    genDef(IR_, INDEX_ROOT, BlocksPerIndexBuffer);
    genDef(IR_, INDEX_ROOT, Reserved);
    genDef(IR_, INDEX_ROOT, IndexHeader);

    //
    // INDEX_ALLOCATION_BUFFER
    //
    genDef(IB_, INDEX_ALLOCATION_BUFFER, MultiSectorHeader);
    genDef(IB_, INDEX_ALLOCATION_BUFFER, Lsn);
    genDef(IB_, INDEX_ALLOCATION_BUFFER, ThisBlock);
    genDef(IB_, INDEX_ALLOCATION_BUFFER, IndexHeader);
    genDef(IB_, INDEX_ALLOCATION_BUFFER, UpdateSequenceArray);

    //
    // INDEX_ENTRY
    //
    genDef(IE_, INDEX_ENTRY, FileReference);
    genDef(IE_, INDEX_ENTRY, Length);
    genDef(IE_, INDEX_ENTRY, AttributeLength);
    genDef(IE_, INDEX_ENTRY, Flags);
    genDef(IE_, INDEX_ENTRY, Reserved);

    genVal(INDEX_ENTRY_NODE, INDEX_ENTRY_NODE);
    genVal(INDEX_ENTRY_END, INDEX_ENTRY_END);

    fclose(NtfsDefs);
}

VOID
dumpf (const char *format, ...)
{
    va_list(arglist);

    va_start(arglist, format);

//    if (OutputEnabled & NTFSDEFS) {
        vfprintf (NtfsDefs, format, arglist);
//    }

    va_end(arglist);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\ntfs\i386\ntfsn98.asm ===
NEC_98=1;
        page    ,132
        title   ntfsboot - NTFS boot loader
        name    ntfsboot

; The ROM in the IBM PC starts the boot process by performing a hardware
; initialization and a verification of all external devices.  If all goes
; well, it will then load from the boot drive the sector from track 0, head 0,
; sector 1.  This sector is placed at physical address 07C00h.
;
; The boot code's sole resposiblity is to find NTLDR, load it at
; address 2000:0000, and then jump to it.
;
; The boot code understands the structure of the NTFS root directory,
; and is capable of reading files.  There is no contiguity restriction.
;
; DEBUG EQU 1
MASM    equ     1
        .xlist
        .286

A_DEFINED EQU 1

    include ntfs.inc

DoubleWord      struc
lsw     dw      ?
msw     dw      ?
DoubleWord      ends

IFDEF NEC_98
PartitionDescriptor struc
    BootableFlag        db  ?
    PartitionType       db  ?
    Reserved            dw  ?
    IPLSector           db  ?
    IPLTrack            db  ?
    IPLCylinder         dw  ?
    StartingSector      db  ?
    StartingTrack       db  ?
    StartingCylinder    dw  ?
    EndingSector        db  ?
    EndingTrack         db  ?
    EndingCylinder      dw  ?
    PartitionName       db  16 dup(?)       ; ASCII strings
PartitionDescriptor ends

DAUA        equ     584h
endif
;
; The following are various segments used by the boot loader. The first
; two are the segments where the boot sector is initially loaded and where
; the boot sector is relocated to.  The third is the static location
; where the NTLDR is loaded.
;

IFDEF NEC_98
; We must not use BootSeg.
; Because, we don't know address that this module is loaded.
; The address transform under the influence of Sector Length and Machine Mode.
else
BootSeg segment at 07c0h        ; this is where the MBR loads us initially.
BootSeg ends
endif

NewSeg  segment at 0d00h        ; this is where we'll relocate to.
NewSeg  ends                    ; enough for 16 boot sectors +
                                ;       4-sector scratch
                                ; below where we'll load NTLDR.

LdrSeg segment at 2000h         ; we want to load the loader at 2000:0000
LdrSeg ends

;/********************** START OF SPECIFICATIONS ************************/
;/*                                                                     */
;/* SUBROUTINE NAME: ntfsboot                                           */
;/*                                                                     */
;/* DESCRIPTIVE NAME: Bootstrap loader                                  */
;/*                                                                     */
;/* FUNCTION:    To load NTLDR into memory.                             */
;/*                                                                     */
;/* NOTES:       ntfsboot is loaded by the ROM BIOS (Int 19H) at        */
;/*              physical memory location 0000:7C00H.                   */
;/*              ntfsboot runs in real mode.                            */
;/*              This boot record is for NTFS volumes only.             */
;/*                                                                     */
;/* ENTRY POINT: ntfsboot                                               */
;/* LINKAGE:     Jump (far) from Int 19H                                */
;/*                                                                     */
;/* INPUT:       CS:IP = 0000:7C00H                                     */
;/*              SS:SP = 0030:00FAH (CBIOS dependent)                   */
;/*                                                                     */
;/* EXIT-NORMAL: DL = INT 13 drive number we booted from                */
;/*              Jmp to main in NTLDR                                   */
;/*                                                                     */
;/* EXIT-ERROR:  None                                                   */
;/*                                                                     */
;/* EFFECTS:     NTLDR is loaded into the physical memory               */
;/*                location 00020000H                                   */
;/*                                                                     */
;/*********************** END OF SPECIFICATIONS *************************/
BootCode segment        ;would like to use BootSeg here, but LINK flips its lid
        assume  cs:BootCode,ds:nothing,es:nothing,ss:nothing

        org     0               ; start at beginning of segment, not 0100h.

        public  _ntfsboot
_ntfsboot label near
IFDEF NEC_98
        jmp     short   start
else
        jmp     start
endif
    .errnz  ($-_ntfsboot) GT (3)        ;<FATAL PROBLEM: JMP is more than three bytes>

    org 3

Version                 db      "NTFS    "      ; Signature, must be "NTFS    "
BPB                     label   byte
BytesPerSector          dw      512             ; Size of a physical sector
SectorsPerCluster       db      1               ; Sectors per allocation unit

;
; Traditionally the next 7 bytes were the reserved sector count, fat count,
; root dir entry count, and the small volume sector count. However all of
; these fields must be 0 on NTFS volumes.
;
; We use this space to store some temporary variables used by the boot code,
; which avoids the need for separate space in sector 0 to store them.
; We also take advantage of the free 0-initialization to save some space
; by avoiding the code to initialize them.
;
; Note that ideally we'd want to use an unused field for the SectorCount
; and initialize it to 16. This would let us save a few bytes by avoiding
; code to explicitly initialize this value before we read the 16 boot sectors.
; However setup and other code tends to preserve the entire bpb area when
; it updates boot code, so we avoid a dependency here and initialize
; the value explicitly to 16 in the first part of the boot code.
;
SectorCount             dw      0               ; number of sectors to read
SectorBase              dd      0               ; start sector for read request
HaveXInt13              db      0               ; extended int13 available flag

Media                   db      0f8h            ; Media byte
FatSectors              dw      0               ; (always 0 on NTFS)
SectorsPerTrack         dw      0               ; Sectors per track
Heads                   dw      0               ; Number of surfaces
HiddenSectors           dd      0               ; partition start LBA

;
; The field below is traditionally the large sector count and is
; always 0 on NTFS. We use it here for a value the boot code calculates,
; namely the number of sectors visible on the drive via conventional int13.
;
Int13Sectors            dd      0

DriveNumber             db      80h             ; int13 unit number

                        db      3 dup (?)       ; alignment filler

;
; The following is the rest of the NTFS Sector Zero information.
; The offsets of most of these fields cannot be changed without changing
; all code that validates, formats, recognizes, etc, NTFS volumes.
; In other words, don't change it.
;
SectorsOnVolume         db (size LARGE_INTEGER) dup (?)
MftStartLcn             db (size LARGE_INTEGER) dup (?)
Mft2StartLcn            db (size LARGE_INTEGER) dup (?)
ClustersPerFrs          dd ?
DefClustersPerBuf       dd ?
SerialNumber            db (size LARGE_INTEGER) dup (?)
CheckSum                dd ?

;
; Make sure size of fields matches what fs_rec.sys thinks is should be
;
        .errnz          ($-_ntfsboot) NE (54h)

;****************************************************************************
start:
;
;       First of all, set up the segments we need (stack and data).
;
        cli
        xor     ax,ax                   ; Set up the stack to just before
        mov     ss,ax                   ; this code.  It'll be moved after
        mov     sp,7c00h                ; we relocate.
        sti

IFDEF NEC_98
        push    si                      ; for after use
        mov     ax, cs                  ; Address BPB with DS.
else
        mov     ax,Bootseg              ; Address BPB with DS.
endif
        mov     ds,ax
        assume  ds:BootCode

IFDEF NEC_98
; Boot is from hard disk.
; Our BPB tells us BytesPerSector, but it is a logical value
; that may differ from the physical value.
; We need SectorShiftFactor that is used to convert logical sector address
; to phisical sector address.

.386
        xor     eax, eax                ;
.286
        mov     es, ax                  ;
        mov     al, es:[DAUA]           ;
        mov     DriveNumber, al         ; Save DriveNumber

IFDEF NEC_98
;
; we assume physical sector length is 512.
; so SectorShiftFactor is 1
;
else
        mov     ah, 84h                 ; ROM BIOS sense command
        xor     bx, bx                  ; initialize bx to 0
        int     1Bh                     ;
        jc      Flg01

        test    bx, bx                  ; physical sector length returned ?
        jnz     Flg02                   ; if not,
Flg01:
        mov     bx, 512                 ; we assume 512 bytes per sector
Flg02:
        mov     ax, BytesPerSector      ; BytesPerSector
        xor     dx, dx
        div     bx
        mov     SectorShiftFactor,ax
endif
;
;   We need to calculate length of hidden sector.
;
        mov     HiddenSectors.lsw, 0
        mov     HiddenSectors.msw, 0

        mov     SectorBase.lsw, 0       ; read Partition control area
        mov     SectorBase.msw, 0
        mov     word ptr [SectorCount], 2   ; Maximum pattern

        mov     ax, NewSeg              ; read it at NewSeg.
        mov     es, ax                  ;                   >>  take a room
.386
        xor     ebx, ebx                ; at NewSeg:0000.
.286
        call    DoReadLL                ; Call low-level DoRead routine

.386
        mov     ax, Heads               ;
        mov     bx, es:[si].StartingCylinder ;
        mul     ebx                     ; cylinder * head = total_track
        mov     bx, SectorsPerTrack     ;
        mul     ebx                     ; (edx:eax = total_track) * (ebx=sec/trk)
        mov     HiddenSectors, eax      ; = total_sec
.286
else
        call    Int13SecCnt             ; determine range of regular int13
endif

;
; Read bootcode and jump to code in sector 1.
; Assumes HaveXInt13 and SectorBase are initialized to 0,
; which they are since they are stored in areas of the BPB
; that must be 0 on NTFS volumes.
;
IFDEF NEC_98
        mov     SectorBase.lsw, 0       ; read sector zero.
        mov     SectorBase.msw, 0

;        xor     dx, dx
;        mov     ax, 2000h
;        div     BytesPerSector
;        mov     byte ptr SectorCount,ax ; word field is 0 on-disk so byte init is OK
        mov     byte ptr SectorCount,10h ; word field is 0 on-disk so byte init is OK
        mov     ax,NewSeg
        mov     es,ax
        xor     bx,bx                   ; es:bx = transfer address
        call    DoReadLL                ; Call low-level DoRead routine
else
        mov     ax,NewSeg
        mov     es,ax
        xor     bx,bx                   ; es:bx = transfer address
        mov     byte ptr SectorCount,16 ; word field is 0 on-disk so byte init is OK
        call    ReadSectors
endif
IFDEF NEC_98
        mov     cl, DriveNumber         ; Copy DriveNumber
        mov     bx, HiddenSectors.lsw   ;
        mov     dx, HiddenSectors.msw   ; bx:ax = HiddenSectors
        pop     si                      ; Partition information
endif
        push    NewSeg
        push    offset mainboot
        retf

IFDEF NEC_98
else
;
; Determine the number of sectors addressable via
; conventional int13. If we can't get drive params for some reason
; then something is very wrong -- we'll try to force the caller
; to use conventional int13 by maxing out the sector count.
;
; Input: ds addresses start of first sector
;
; Output: in eax; also stored in Int13Sectors variable.
;
; Preserves: assume none.
;
Int13SecCnt proc near
        mov     dl,DriveNumber          ; int13 unit number
        mov     ah,8                    ; get drive params
        int     13h                     ; call BIOS
        jnc     @f                      ; no error, procede
        mov     cx,-1                   ; strange case, fake registers to force
        mov     dh,cl                   ; use of standard int13 (set all vals to max)
@@:
.386
        movzx   eax,dh                  ; eax = max head # (0-255)
        inc     ax                      ; eax = heads (1-256)
        movzx   edx,cl                  ; edx = sectors per track + cyl bits
        and     dl,3fh                  ; edx = sectors per track (1-63)
        mul     dx                      ; eax = sectors per cylinder, edx = 0
        xchg    cl,ch
        shr     ch,6                    ; cx = max cylinder # (0-1023)
        inc     cx                      ; cx = cylinders (1-1024)
        movzx   ecx,cx                  ; ecx = cylinders (1-1024)
        mul     ecx                     ; eax = sectors visible via int13, edx = 0
        mov     Int13Sectors,eax        ; save # sectors addressable via int13
.286
        ret
Int13SecCnt endp

;
; Determine whether extended int13 services are available on the boot drive.
;
; Stores result (boolean) in HaveXInt13 variable.
;
; Preserves: assume none.
;
HaveInt13Ext proc near
        mov     ah,41h
        mov     bx,055aah
        mov     dl,DriveNumber
        int     13h
        jc      @f                      ; error from int13 means no xint13
        cmp     bx,0aa55h               ; absence of sig means no xint13
        jne     @f
        test    cl,1                    ; bit 0 off means no xint13
        jz      @f
        inc     byte ptr HaveXInt13     ; xint13 is available
@@:     ret
HaveInt13Ext endp

endif
IFDEF NEC_98
;*******************************************************************************
;
; Low-level read routine that doesn't work across a 64k addr boundary.
;
;       Read SectorCount sectors (starting at SectorBase) to es:bx.
;
;       As a side effect, SectorBase is updated (but es:bx are not)
;       and SectorCount is reduced to zero.
;
DoReadLL proc
        pusha
        push    es

        mov     si, SectorCount
        mov     bp, bx
        mov     cx, SectorBase.lsw      ; Starting sector
        mov     dx, SectorBase.msw      ; Starting sector

;    (dx:cx) = logical sector # relative to partition
;    (si)    = # of sectors to read
;    (es:bp) = read buffer

Rpt03:
        push    dx
        push    cx

;   [sp]   = logical sector number LSW
;   [sp+2] = logical sector number MSW

;   We are reading hard disk.
;   We don't care about DMA boundary
;   as length we read is 64KB max.
;
;        push    dx
;        xor     dx, dx
;        mov     ax, 32768               ; sectors we can read (32KB)
;        div     BytesPerSector          ; this is not optimum on performance
;        pop     dx
        mov     ax, 64                  ; ax = 32768(32KB)/512(BytePerSector)
;
;   (ax) = # of sectors we can read with 1 time ROM call
;   (si) = # of sectors we need to read
;
        cmp     si, ax
        jnb     @F

        mov     ax, si
@@:

        push    ax                      ; # of sectors we are reading this call
        push    dx
        mul     BytesPerSector          ; SECSIZE
        pop     dx
        push    ax                      ; # of bytes.

;   [sp]   = # of bytes to read
;   [sp+2] = # of sectors
;   [sp+4] = logical sector number LSW
;   [sp+6] = logical sector number MSW

        mov     bx, ax                  ; # of bytes we read
;        mov     ax, SectorShiftFactor
;
;Rpt04:                                  ; logical sector address to
;        shr     ax, 1
;        jc      @F
;
;        shl     cx, 1                   ; physical sector address
;        rcl     dx, 1
;        jmp     short   Rpt04
;@@:
Flg00:
        add     cx, HiddenSectors.lsw
        adc     dx, HiddenSectors.msw   ; (dx:cx) -> relative to drive

        mov     al, DriveNumber
        and     al, 7Fh                 ; drive #

;   We have prepared following ROM BIOS parameters
;   (al) = drive
;   (dx:cx) = relative sector number
;   (es:bp) -> buffer
;
        mov     ah, 01010110b           ; read
        int     1Bh

        pop     di                      ; # of bytes
        pop     bx                      ; # of sectors
        pop     cx                      ; lsn (LSW)
        pop     dx                      ; lsn (MSW)

        jc      @F                      ; return Carry

;   prepare for next call

        add     cx, bx                  ; advance lsn
        adc     dx, 0                   ;
        add     bp, di                  ; advance offset
        sub     si, bx                  ; decrement # of sectors
        jnz     Rpt03                   ; CarryFlag is Clear
@@:

        mov     SectorCount, si
        mov     SectorBase.lsw, cx      ; Next Starting sector
        mov     SectorBase.msw, dx      ; Next Starting sector

        pop     es
        popa
        ret
DoReadLL  endp
endif
IFDEF NEC_98
;SectorShiftFactor           dw    ?
endif

;
; Read SectorCount sectors starting at logical sector SectorBase,
; into es:bx, using extended int13 if necessary.
;
; Preserves all
;
ReadSectors proc near
IFDEF NEC_98
;****************************************************************************
;
; ReadSectors - read SectorCount sectors into ES:BX starting from sector
;          SectorBase.
;
; NOTE: This code WILL NOT WORK if ES:BX does not point to an address whose
; physical address (ES * 16 + BX) MOD 512 != 0.
;
; ReadSectors adds to ES rather than BX in the main loop so that runs longer than
; 64K can be read with a single call to ReadSectors.
;
; Note that ReadSectors (unlike DoReadLL) saves and restores SectorCount
; and SectorBase
;
.286
        push    ax                      ; save important registers
        push    bx
        push    cx
        push    dx
        push    es
        push    SectorCount             ; save state variables too
        push    SectorBase.lsw
        push    SectorBase.msw
;
; Calculate how much we can read into what's left of the current 64k
; physical address block, and read it.
;
;
        mov     ax,bx

        shr     ax,4
        mov     cx,es
        add     ax,cx                   ; ax = paragraph addr

;
; Now calc maximum number of paragraphs that we can read safely:
;       4k - ( ax mod 4k )
;

        and     ax,0fffh
        sub     ax,1000h
        neg     ax

;
; Calc CX = number of paragraphs to be read
;
        push    ax
        mov     ax,SectorCount          ; convert SectorCount to paragraph cnt
        mov     cx,BytesPerSector
        shr     cx,4
        mul     cx
        mov     cx,ax
        pop     ax

ReadSectors$Loop64:
        push    cx                      ; save cpRead

        cmp     ax,cx                   ; ax = min(cpReadSafely, cpRead)
        jbe     @F
        mov     ax,cx
@@:
        push    ax
;
; Calculate new SectorCount from amount we can read
;
        mov     cx,BytesPerSector
        shr     cx,4
        xor     dx,dx
        div     cx
        mov     SectorCount,ax

        call    DoReadLL

        pop     ax                      ; ax = cpActuallyRead
        pop     cx                      ; cx = cpRead

        sub     cx,ax                   ; Any more to read?
        jbe     ReadSectors$Exit64           ; Nope.
;
; Adjust ES:BX by amount read
;
        mov     dx,es
        add     dx,ax
        mov     es,dx
;
; Since we're now reading on a 64k byte boundary, cpReadSafely == 4k.
;
        mov     ax,01000h               ; 16k paragraphs per 64k segment
        jmp     short ReadSectors$Loop64     ; and go read some more.

ReadSectors$Exit64:
        pop     SectorBase.msw          ; restore all this crap
        pop     SectorBase.lsw
        pop     SectorCount
        pop     es
        pop     dx
        pop     cx
        pop     bx
        pop     ax
        ret
else
.386
        pushad                          ; save registers
        push    ds
        push    es

read_loop:
        mov     eax,SectorBase          ; logical starting sector
        add     eax,HiddenSectors       ; eax = physical starting sector
        cmp     eax,Int13Sectors        ; determine if standard int13 is ok
        jb      stdint13

        push    ds                      ; preserve ds

        db      66h                     ; hand-coded 32-bit push of 8-bit immediate
        push    0                       ; high 32 bits of sector #
        push    eax                     ; low 32 bits of sector #
        push    es
        push    bx                      ; transfer address
        push    dword ptr 10010h        ; transfer 1 sector, packet size = 16

        cmp     byte ptr HaveXInt13,0
        jne     @f                      ; already know we have xint13 available
        call    HaveInt13Ext            ; see if we have it
        cmp     byte ptr HaveXInt13,0

        je      BootErr$he              ; need it but don't have it

@@:     mov     ah,42h                  ; extended read
        mov     dl,DriveNumber          ; dl = int13 unit #
        push    ss
        pop     ds
        mov     si,sp                   ; ds:si -> param packet

        int     13h

        pop     eax                     ; throw away first 4 bytes of param packet
        pop     bx                      ; restore es:bx from param packet
        pop     es
        pop     eax                     ; throw away last 8 bytes of param packet
        pop     eax                     ; without clobbering carry flag

        pop     ds                      ; restore ds

        jmp     short did_read

stdint13:
        xor     edx,edx                 ; edx:eax = absolute sector number
        movzx   ecx,SectorsPerTrack     ; ecx = sectors per track
        div     ecx                     ; eax = track, edx = sector within track (0-62)
        inc     dl                      ; dl = sector within track (1-63)
        mov     cl,dl                   ; cl = sector within track
        mov     edx,eax
        shr     edx,16                  ; dx:ax = track
        div     Heads                   ; ax = cylinder (0-1023), dx = head (0-255)
        xchg    dl,dh                   ; dh = head
        mov     dl,DriveNumber          ; dl = int13 unit #
        mov     ch,al                   ; ch = bits 0-7 of cylinder
        shl     ah,6
        or      cl,ah                   ; bits 6-7 of cl = bits 8-9 of cylinder
        mov     ax,201h                 ; read 1 sector
        int     13h
did_read:
        jc      BootErr$he

read_next:
        mov     ax,es                   ; advance transfer address
        add     ax,20h                  ; by moving segment register along
        mov     es,ax                   ; thus no 64K limit on transfer length

        inc     SectorBase              ; advance sector number
        dec     SectorCount             ; see if done
        jnz     read_loop               ; not done

        pop     es
        pop     ds
        popad                           ; restore registers
.286
        ret
endif
ReadSectors endp

BootErr$he:

        mov     al,byte ptr TXT_MSG_SYSINIT_BOOT_ERROR
IFDEF NEC_98
BootErr2:

        mov     ah, 1                   ; offset = offseet + 256
        add     ax, 2
        mov     si, ax                  ; set string data

;        mov     ax, 0a00h               ; initialize crt mode 80*25
;        int     18h                     ;
;        mov     ah, 0ch                 ; start display
;        int     18h                     ;

        call    BootErr$print
        sti
        jmp     $                       ; Wait forever

BootErr$print:
        mov     ax, 0a000h              ; set V-RAM
        mov     es, ax
        xor     ah, ah

        lodsb                           ; Get next character
        cmp     al, 0                   ; Is text end ?
        je      BootErr$Done            ;
        stosw                           ; move to vram
        jmp     BootErr$print           ;
BootErr$Done:
else
BootErr2:
        call    BootErr$print
        mov     al,byte ptr TXT_MSG_SYSINIT_REBOOT
        call    BootErr$print
        sti
        jmp     $                       ; Wait forever

BootErr$print:
;
; al is offset - 256 of message. Adjust to form real offset
; and stick in si so lodsb below will work.
;
        mov     ah,1
        mov     si,ax

BootErr$print1:
        lodsb                           ; Get next character
        cmp     al,0
        je      BootErr$Done
        mov     ah,14                   ; Write teletype
        mov     bx,7                    ; Attribute
        int     10h                     ; Print it
        jmp     BootErr$print1
BootErr$Done:
endif
        ret

;****************************************************************************

;
; Message table.
;
; We put English messages here as a placeholder only, so that in case
; anyone uses bootntfs.h without patching new messages in, things will
; still be correct (in English, but at least functional).
;
MSG_SYSINIT_BOOT_ERROR:

        DB      13,10,'A disk read error occurred',0

MSG_SYSINIT_FILE_NOT_FD:

        DB      13,10,'NTLDR is missing',0

ifdef NEC_98
else
MSG_SYSINIT_NTLDR_CMPRS:

        DB      13,10,'NTLDR is compressed',0

MSG_SYSINIT_REBOOT:

        DB      13,10,'Press Ctrl+Alt+Del to restart',13,10,0
endif

;
; Now build a table with the low byte of the offset to each message.
; Code that patches the boot sector messages updates this table.
;
        .errnz ($-_ntfsboot) GT (512-8)
        ORG     512 - 8
TXT_MSG_SYSINIT_BOOT_ERROR:
        db OFFSET (MSG_SYSINIT_BOOT_ERROR - _ntfsboot) - 256
TXT_MSG_SYSINIT_FILE_NOT_FD:
        db OFFSET (MSG_SYSINIT_FILE_NOT_FD - _ntfsboot) - 256
ifdef NEC_98
else
TXT_MSG_SYSINIT_NTLDR_CMPRS:
        db OFFSET (MSG_SYSINIT_NTLDR_CMPRS - _ntfsboot) - 256
TXT_MSG_SYSINIT_REBOOT:
        db OFFSET (MSG_SYSINIT_REBOOT - _ntfsboot) - 256
endif

ifdef NEC_98
        .errnz ($-_ntfsboot) GT (512-4)
        ORG     512 - 4
endif
        .errnz ($-_ntfsboot) NE (512-4)
        db      0,0,55h,0aah

;   Name we look for.  ntldr_length is the number of characters,
;   ntldr_name is the name itself.  Note that it is not NULL
;   terminated, and doesn't need to be.
;
ntldr_name_length   dw  5
ntldr_name          dw  'N', 'T', 'L', 'D', 'R'

;   Predefined name for index-related attributes associated with an
;   index over $FILE_NAME
;
index_name_length   dw 4
index_name          dw '$', 'I', '3', '0'

;   Global variables.  These offsets are all relative to NewSeg.
;
AttrList            dd 0e000h   ; Offset of buffer to hold attribute list
MftFrs              dd  3000h   ; Offset of general scratch buffer for FRS
SegmentsInMft       dd   ?      ; number of FRS's with MFT Data attribute records
RootIndexFrs        dd   ?      ; Offset of Root Index FRS
AllocationIndexFrs  dd   ?      ; Offset of Allocation Index FRS        ; KPeery
BitmapIndexFrs      dd   ?      ; Offset of Bitmap Index FRS            ; KPeery
IndexRoot           dd   ?      ; Offset of Root Index $INDEX_ROOT attribute
IndexAllocation     dd   ?      ; Offset of Root Index $INDEX_ALLOCATION attribute
IndexBitmap         dd   ?      ; Offset of Root Index $BITMAP attribute
NtldrFrs            dd   ?      ; Offset of NTLDR FRS
NtldrData           dd   ?      ; Offset of NTLDR $DATA attribute
IndexBlockBuffer    dd   ?      ; Offset of current index buffer
IndexBitmapBuffer   dd   ?      ; Offset of index bitmap buffer
NextBuffer          dd   ?      ; Offset of next free byte in buffer space

BytesPerCluster     dd   ?      ; Bytes per cluster
BytesPerFrs         dd   ?      ; Bytes per File Record Segment

;
; For floppyless booting, winnt32.exe creates c:\$win_nt$.~bt\bootsec.dat and
; places an entry in boot.ini for it (the boot selection says something
; like "Windows NT Setup or Upgrade"). When that is selected, the boot loader
; loads 16 sectors worth of data from bootsect.dat into d000 (which is where
; the first sector of this code would have loaded it) and jumps into it at
; a known location of 256h. That was correct in earlier versions of NT
; but is not correct now because the 4 fields below were added to this sector.
;
; Note that 0000 is "add [bx+si],al" which because of the way the boot loader
; is written happens to be a benign add of 0 to something in segment 7c0,
; which doesn't seem to hose anything but is still somewhat random.
;
; We code in a jump here so as this new code proliferates we get this
; cleaned up.
;
        .errnz  $-_ntfsboot ne 256h
SectorsPerFrs label dword       ; Sectors per File Record Segment
                    jmp short mainboot
                    nop
                    nop
        .errnz  $-_ntfsboot ne 25ah

MftLcnFrs               dd  ?   ; Offset scratch FRS buffer for LookupMftLcn
BytesPerIndexBlock      dd  ?   ; Bytes per index alloc block in root index
ClustersPerIndexBlock   dd  ?   ; Clusters per index alloc block in root index
SectorsPerIndexBlock    dd  ?   ; Sectors per index block in root index

.386

SAVE_ALL    macro

    push    es
    push    ds
    pushad

endm

RESTORE_ALL macro

    popad
    nop
    pop     ds
    pop     es

endm


;****************************************************************************
;
; mainboot - entry point after 16 boot sectors have been read in
;
;
mainboot proc   far

;       Get the new ds and the new stack.  Note that ss is zero.
;
        mov     ax, cs                  ; Set DS to CS
        mov     ds, ax

        shl     ax, 4                   ; convert to an offset.
        cli
        mov     sp, ax                  ; load new stack, just before boot code.
        sti

IFDEF NEC_98
;
;       cl    = DA/UA Booted from
;       dx:bx = HiddenSectors
;       si    = Partition information
;
        mov     al, cl
        mov     DriveNumber, al         ; Save DriveNumber
        mov     HiddenSectors.lsw, bx   ;
        mov     HiddenSectors.msw, dx   ;
        push    si                      ;

; Boot is from hard disk.
; Our BPB tells us BytesPerSector, but it is a logical value
; that may differ from the physical value.
; We need SectorShiftFactor that is used to convert logical sector address
; to phisical sector address.
ifdef NEC_98
;        mov     SectorShiftFactor, 1
else
        mov     ah, 84h                 ; ROM BIOS sense command
        xor     bx, bx                  ; initialize bx to 0
        int     1Bh                     ;
        jc      Flg21

        test    bx, bx                  ; physical sector length returned ?
        jnz     Flg22                   ; if not,
Flg21:
        mov     bx, 256                 ;   we assume 256 bytes per sector
Flg22:
        mov     ax, BytesPerSector      ; BytesPerSector
        xor     dx, dx
        div     bx
        mov     SectorShiftFactor,ax
endif
else
;
; Reinitialize xint13-related variables
;
        call    Int13SecCnt             ; determine range of regular int13
endif

;       Set up the FRS buffers.  The MFT buffer is in a fixed
;       location, and the other three come right after it.  The
;       buffer for index allocation blocks comes after that.
;

;       Compute the useful constants associated with the volume
;
        movzx   eax, BytesPerSector     ; eax = Bytes per Sector
        movzx   ebx, SectorsPerCluster  ; ebx = Sectors Per Cluster
        mul     ebx                     ; eax = Bytes per Cluster
        mov     BytesPerCluster, eax

        mov     ecx, ClustersPerFrs     ; ecx = clusters per frs
        cmp     cl, 0                   ; is ClustersPerFrs less than zero?
        jg      mainboot$1

;       If the ClustersPerFrs field is negative, we calculate the number
;       of bytes per FRS by negating the value and using that as a shif count.
;

        neg     cl
        mov     eax, 1
        shl     eax, cl                 ; eax = bytes per frs
        jmp     mainboot$2

mainboot$1:

;       Otherwise if ClustersPerFrs was positive, we multiply by bytes
;       per cluster.

        mov     eax, BytesPerCluster
        mul     ecx                     ; eax = bytes per frs

mainboot$2:

        mov     BytesPerFrs, eax
        movzx   ebx, BytesPerSector
        xor     edx, edx                ; zero high part of dividend
        div     ebx                     ; eax = sectors per frs
        mov     SectorsPerFrs, eax


;       Set up the MFT FRS's---this will read all the $DATA attribute
;       records for the MFT.
;

        call    SetupMft

;       Set up the remaining FRS buffers.  The RootIndex FRS comes
;       directly after the last MFT FRS, followed by the NTLdr FRS
;       and the Index Block buffer.
;
        mov     ecx, NextBuffer
        mov     RootIndexFrs, ecx

        add     ecx, BytesPerFrs            ; AllocationFrs may be different
        mov     AllocationIndexFrs, ecx     ; from RootIndexFrs - KPeery

        add     ecx, BytesPerFrs            ; BitmapFrs may be different
        mov     BitmapIndexFrs, ecx         ; from RootIndexFrs - KPeery

        add     ecx, BytesPerFrs
        mov     NtldrFrs, ecx

        add     ecx, BytesPerFrs
        mov     IndexBlockBuffer, ecx

;
;       Read the root index, allocation index and bitmap FRS's and locate
;       the interesting attributes.
;

        mov     eax, $INDEX_ROOT
        mov     ecx, RootIndexFrs
        call    LoadIndexFrs

        or      eax, eax

        jz      BootErr$he

        mov     IndexRoot, eax          ; offset in Frs buffer

        mov     eax, $INDEX_ALLOCATION  ; Attribute type code
        mov     ecx, AllocationIndexFrs ; FRS to search
        call    LoadIndexFrs

        mov     IndexAllocation, eax

        mov     eax, $BITMAP            ; Attribute type code
        mov     ecx, BitmapIndexFrs     ; FRS to search
        call    LoadIndexFrs

        mov     IndexBitmap, eax

;       Consistency check: the index root must exist, and it
;       must be resident.
;
        mov     eax, IndexRoot
        or      eax, eax

        jz      BootErr$he

        cmp     [eax].ATTR_FormCode, RESIDENT_FORM

        jne     BootErr$he


;       Determine the size of the index allocation buffer based
;       on information in the $INDEX_ROOT attribute.  The index
;       bitmap buffer comes immediately after the index block buffer.
;
;       eax -> $INDEX_ROOT attribute record
;
        lea     edx, [eax].ATTR_FormUnion   ; edx -> resident info
        add     ax, [edx].RES_ValueOffset   ; eax -> value of $INDEX_ROOT

        movzx   ecx, [eax].IR_ClustersPerBuffer
        mov     ClustersPerIndexBlock, ecx

        mov     ecx, [eax].IR_BytesPerBuffer
        mov     BytesPerIndexBlock, ecx

        mov     eax, BytesPerIndexBlock
        movzx   ecx, BytesPerSector
        xor     edx, edx
        div     ecx                     ; eax = sectors per index block
        mov     SectorsPerIndexBlock, eax

        mov     eax, IndexBlockBuffer
        add     eax, BytesPerIndexBlock
        mov     IndexBitmapBuffer, eax

;       Next consistency check: if the $INDEX_ALLOCATION attribute
;       exists, the $INDEX_BITMAP attribute must also exist.
;
        cmp     IndexAllocation, 0
        je      mainboot30

        cmp     IndexBitmap, 0          ; since IndexAllocation exists, the

        je      BootErr$he              ;  bitmap must exist, too.

;       Since the bitmap exists, we need to read it into the bitmap
;       buffer.  If it's resident, we can just copy the data.
;

        mov     ebx, IndexBitmap        ; ebx -> index bitmap attribute
        push    ds
        pop     es
        mov     edi, IndexBitmapBuffer  ; es:edi -> index bitmap buffer

        call    ReadWholeAttribute

mainboot30:
;
;       OK, we've got the index-related attributes.
;
        movzx   ecx, ntldr_name_length  ; ecx = name length in characters
        mov     eax, offset ntldr_name  ; eax -> name

        call    FindFile

        or      eax, eax
        jz      BootErr$fnf

;       Read the FRS for NTLDR and find its data attribute.
;
;       eax -> Index Entry for NTLDR.
;
        mov     eax, [eax].IE_FileReference.REF_LowPart

        push    ds
        pop     es              ; es:edi = target buffer
        mov     edi, NtldrFrs

        call    ReadFrs

        mov     eax, NtldrFrs   ; pointer to FRS
        mov     ebx, $DATA      ; requested attribute type
        mov     ecx, 0          ; attribute name length in characters
        mov     edx, 0          ; attribute name (NULL if none)

        call    LocateAttributeRecord

;       eax -> $DATA attribute for NTLDR
;
        or      eax, eax        ; if eax is zero, attribute not found.
        jnz     mainboot$FoundData

;
;       The ntldr $DATA segment is fragmented.  Search the attribute list
;       for the $DATA member.  And load it from there.
;
        mov     ecx, $DATA             ; Attribute type code
        mov     eax, NtldrFrs          ; FRS to search

        call    SearchAttrList         ; search attribute list for FRN
                                       ; of specified ($DATA)

        or      eax, eax               ; if eax is zero, attribute not found.
        jz      BootErr$fnf

;
;       We found the FRN of the $DATA attribute; load that into memory.
;
        push    ds
        pop     es                     ; es:edi = target buffer
        mov     edi, NtldrFrs

        call    ReadFrs

;
;       Determine the beginning offset of the $DATA in the FRS
;
        mov     eax, NtldrFrs   ; pointer to FRS
        mov     ebx, $DATA      ; requested attribute type
        mov     ecx, 0          ; attribute name length in characters
        mov     edx, 0          ; attribute name (NULL if none)

        call    LocateAttributeRecord

;       eax -> $DATA attribute for NTLDR
;
        or      eax, eax        ; if eax is zero, attribute not found.
        jz      BootErr$fnf

mainboot$FoundData:

;       Get the attribute record header flags, and make sure none of the
;       `compressed' bits are set

        movzx   ebx, [eax].ATTR_Flags
        and     ebx, ATTRIBUTE_FLAG_COMPRESSION_MASK
        jnz     BootErr$ntc

        mov     ebx, eax        ; ebx -> $DATA attribute for NTLDR

        push    LdrSeg
        pop     es              ; es = segment addres to read into
        sub     edi, edi        ; es:edi = buffer address

        call    ReadWholeAttribute

;
; We've loaded NTLDR--jump to it.
;
; Before we go to NTLDR, set up the registers the way it wants them:
;       DL = INT 13 drive number we booted from
;
        mov     dl, DriveNumber
        mov     ax,1000
        mov     es, ax                  ; we don't really need this
        lea     si, BPB
        sub     ax,ax
IFDEF NEC_98
        pop     bp
endif
        push    LdrSeg
        push    ax
        retf                            ; "return" to NTLDR.

mainboot endp

.386
;****************************************************************************
;
;   ReadClusters - Reads a run of clusters from the disk.
;
;   ENTRY:  eax == LCN to read
;           edx == clusters to read
;           es:edi -> Target buffer
;
;   USES:   none (preserves all registers)
;
ReadClusters proc near

    SAVE_ALL

    mov     ebx, edx                ; ebx = clusters to read.
    movzx   ecx, SectorsPerCluster  ; ecx = cluster factor

    mul     ecx                 ; Convert LCN to sectors (wipes out edx!)
    mov     SectorBase, eax     ; Store starting sector in SectorBase

    mov     eax, ebx            ; eax = number of clusters
    mul     ecx                 ; Convert EAX to sectors (wipes out edx!)
    mov     SectorCount, ax     ; Store number of sectors in SectorCount

;
;   Note that ReadClusters gets its target buffer in es:edi but calls
;   the ReadSectors worker function that takes a target in es:bx--we need
;   to normalize es:edi so that we don't overflow bx.
;
    mov     bx, di
    and     bx, 0Fh
    mov     ax, es
    shr     edi, 4
    add     ax, di              ; ax:bx -> target buffer

    push    ax
    pop     es                  ; es:bx -> target buffer

    call    ReadSectors

    RESTORE_ALL
    ret

ReadClusters endp

;
;****************************************************************************
;
;   LocateAttributeRecord   --  Find an attribute record in an FRS.
;
;   ENTRY:  EAX -- pointer to FRS
;           EBX -- desired attribute type code
;           ECX -- length of attribute name in characters
;           EDX -- pointer to attribute name
;
;   EXIT:   EAX points at attribute record (0 indicates not found)
;
;   USES:   All
;
LocateAttributeRecord proc near

; get the first attribute record.
;
        add     ax, word ptr[eax].FRS_FirstAttribute

;       eax -> next attribute record to investigate.
;       ebx == desired type
;       ecx == name length
;       edx -> pointer to name
;
lar10:
        cmp     [eax].ATTR_TypeCode, 0ffffffffh
        je      lar99

        cmp     dword ptr[eax].ATTR_TypeCode, ebx
        jne     lar80

;       this record is a potential match.  Compare the names:
;
;       eax -> candidate record
;       ebx == desired type
;       ecx == name length
;       edx -> pointer to name
;
        or      ecx, ecx    ; Did the caller pass in a name length?
        jnz     lar20

;       We want an attribute with no name--the current record is
;       a match if and only if it has no name.
;
        cmp     [eax].ATTR_NameLength, 0
        jne     lar80       ; Not a match.

;       It's a match, and eax is set up correctly, so return.
;
        ret

;       We want a named attribute.
;
;       eax -> candidate record
;       ebx == desired type
;       ecx == name length
;       edx -> pointer to name
;
lar20:
        cmp     cl, [eax].ATTR_NameLength
        jne     lar80       ; Not a match.

;       Convert name in current record to uppercase.
;
        mov     esi, eax
        add     si, word ptr[eax].ATTR_NameOffset

        call    UpcaseName

;       eax -> candidate record
;       ebx == desired type
;       ecx == name length
;       edx -> pointer to name
;       esi -> Name in current record (upcased)
;
        push    ecx         ; save cx

        push    ds          ; Copy data segment into es
        pop     es
        mov     edi, edx    ; note that esi is already set up.

        repe cmpsw          ; zero flag is set if equal

        pop     ecx         ; restore cx

        jnz     lar80       ; not a match

;       eax points at a matching record.
;
        ret

;
;   This record doesn't match; go on to the next.
;
;       eax -> rejected candidate attribute record
;       ebx == desired type
;       ecx == Name length
;       edx -> desired name
;
lar80:  cmp     [eax].ATTR_RecordLength, 0  ; if the record length is zero
        je      lar99                       ; the FRS is corrupt.

        add     eax, [eax].ATTR_RecordLength; Go to next record
        jmp     lar10                       ; and try again

;       Didn't find it.
;
lar99:  sub     eax, eax
        ret

LocateAttributeRecord endp

;****************************************************************************
;
;   LocateIndexEntry   --  Find an index entry in a file name index
;
;   ENTRY:  EAX -> pointer to index header
;           EBX -> file name to find
;           ECX == length of file name in characters
;
;   EXIT:   EAX points at index entry.  NULL to indicate failure.
;
;   USES:   All
;
LocateIndexEntry proc near

;       Convert the input name to upper-case
;

        mov     esi, ebx
        call    UpcaseName

ifdef DEBUG
        call    PrintName
        call    Debug2
endif ; DEBUG

        add     eax, [eax].IH_FirstIndexEntry

;       EAX -> current entry
;       EBX -> file name to find
;       ECX == length of file name in characters
;
lie10:  test    [eax].IE_Flags, INDEX_ENTRY_END ; Is it the end entry?
        jnz     lie99

        lea     edx, [eax].IE_Value         ; edx -> FILE_NAME attribute value

ifdef DEBUG
;       DEBUG CODE -- list file names as they are examined

        SAVE_ALL

        call    Debug3
        movzx   ecx, [edx].FN_FileNameLength    ; ecx = chars in name
        lea     esi, [edx].FN_FileName          ; esi -> name
        call    PrintName

        RESTORE_ALL
endif ; DEBUG

;       EAX -> current entry
;       EBX -> file name to find
;       ECX == length of file name in characters
;       EDX -> FILE_NAME attribute

        cmp     cl, [edx].FN_FileNameLength ; Is name the right length?
        jne     lie80

        lea     esi, [edx].FN_FileName      ; Get name from FILE_NAME structure

        call    UpcaseName

        push    ecx         ; save ecx

        push    ds
        pop     es          ; copy data segment into es for cmpsw
        mov     edi, ebx    ; edi->search name (esi already set up)
        repe    cmpsw       ; zero flag is set if they're equal

        pop     ecx         ; restore ecx

        jnz     lie80

;       the current entry matches the search name, and eax points at it.
;
        ret

;       The current entry is not a match--get the next one.
;           EAX -> current entry
;           EBX -> file name to find
;           ECX == length of file name in characters
;
lie80:  cmp     [eax].IE_Length, 0      ; If the entry length is zero
        je      lie99                   ; then the index block is corrupt.

        add     ax, [eax].IE_Length     ; Get the next entry.

        jmp     lie10


;   Name not found in this block.  Set eax to zero and return
;
lie99:  xor     eax, eax
        ret

LocateIndexEntry endp

;****************************************************************************
;
;   ReadWholeAttribute - Read an entire attribute value
;
;   ENTRY:  ebx -> attribute
;           es:edi -> target buffer
;
;   USES:   ALL
;
ReadWholeAttribute proc near

        cmp     [ebx].ATTR_FormCode, RESIDENT_FORM
        jne      rwa10

;       The attribute is resident.
;       ebx -> attribute
;       es:edi -> target buffer
;

        SAVE_ALL

        lea     edx, [ebx].ATTR_FormUnion   ; edx -> resident form info
        mov     ecx, [edx].RES_ValueLength  ; ecx = bytes in value
        mov     esi, ebx                    ; esi -> attribute
        add     si, [edx].RES_ValueOffset   ; esi -> attribute value

        rep     movsb                       ; copy bytes from value to buffer

        RESTORE_ALL

        ret                                 ; That's all!

rwa10:
;
;       The attribute type is non-resident.  Just call
;       ReadNonresidentAttribute starting at VCN 0 and
;       asking for the whole thing.
;
;       ebx -> attribute
;       es:edi -> target buffer
;
        lea     edx, [ebx].ATTR_FormUnion   ; edx -> nonresident form info
        mov     ecx, [edx].NONRES_HighestVcn.LowPart; ecx = HighestVcn
        inc     ecx                         ; ecx = clusters in attribute

        sub     eax, eax                    ; eax = 0 (first VCN to read)

        call    ReadNonresidentAttribute

        ret

ReadWholeAttribute endp

;****************************************************************************
;
;   ReadNonresidentAttribute - Read clusters from a nonresident attribute
;
;   ENTRY:  EAX == First VCN to read
;           EBX -> Attribute
;           ECX == Number of clusters to read
;           ES:EDI == Target of read
;
;   EXIT:   None.
;
;   USES:   None (preserves all registers with SAVE_ALL/RESTORE_ALL)
;
ReadNonresidentAttribute proc near

        SAVE_ALL

        cmp     [ebx].ATTR_FormCode, NONRESIDENT_FORM
        je      ReadNR10

;       This attribute is not resident--the disk is corrupt.

        jmp     BootErr$he

ReadNR10:
;       eax == Next VCN to read
;       ebx -> Attribute
;       ecx -> Remaining clusters to read
;       es:edi -> Target of read
;

        cmp     ecx, 0
        jne     ReadNR20

;       Nothing left to read--return success.
;
        RESTORE_ALL
        ret

ReadNR20:
        push    ebx ; pointer to attribute
        push    eax ; Current VCN

        push    ecx
        push    edi
        push    es

        call    ComputeLcn  ; eax = LCN to read, ecx = run length
        mov     edx, ecx    ; edx = remaining run length

        pop     es
        pop     edi
        pop     ecx


;       eax == LCN to read
;       ecx == remaining clusters to read
;       edx == remaining clusters in current run
;       es:edi == Target of read
;       TOS == Current VCN
;       TOS + 4 == pointer to attribute
;
        cmp     ecx, edx
        jge     ReadNR30

;       Run length is greater than remaining request; only read
;       remaining request.
;
        mov     edx, ecx    ; edx = Remaining request

ReadNR30:
;       eax == LCN to read
;       ecx == remaining clusters to read
;       edx == clusters to read in current run
;       es:edi == Target of read
;       TOS == Current VCN
;       TOS +  == pointer to attribute
;

        call    ReadClusters

        sub     ecx, edx            ; Decrement clusters remaining in request
        mov     ebx, edx            ; ebx = clusters read

        mov     eax, edx            ; eax = clusters read
        movzx   edx, SectorsPerCluster
        mul     edx                 ; eax = sectors read (wipes out edx!)
        movzx   edx, BytesPerSector
        mul     edx                 ; eax = bytes read (wipes out edx!)

        add     edi, eax            ; Update target of read

        pop     eax                 ; eax = previous VCN
        add     eax, ebx            ; update VCN to read

        pop     ebx                 ; ebx -> attribute
        jmp     ReadNR10


ReadNonresidentAttribute endp

;****************************************************************************
;
;   ReadIndexBlockSectors - Read sectors from an index allocation attribute
;
;   ENTRY:  EAX == First VBN to read
;           EBX -> Attribute
;           ECX == Number of sectors to read
;           ES:EDI == Target of read
;
;   EXIT:   None.
;
;   USES:   None (preserves all registers with SAVE_ALL/RESTORE_ALL)
;
ReadIndexBlockSectors proc near

        SAVE_ALL

        cmp     [ebx].ATTR_FormCode, NONRESIDENT_FORM
        je      ReadIBS_10

;       This attribute is resident--the disk is corrupt.

        jmp     BootErr$he

ReadIBS_10:
;       eax == Next VBN to read
;       ebx -> Attribute
;       ecx -> Remaining sectors to read
;       es:edi -> Target of read
;

        cmp     ecx, 0
        jne     ReadIBS_20

;       Nothing left to read--return success.
;


        RESTORE_ALL
        ret

ReadIBS_20:
        push    ebx ; pointer to attribute
        push    eax ; Current VBN

        push    ecx
        push    edi
        push    es

        ; Convert eax from a VBN back to a VCN by dividing by SectorsPerCluster.
        ; The remainder of this division is the sector offset in the cluster we
        ; want.  Then use the mapping information to get the LCN for this VCN,
        ; then multiply to get back to LBN.
        ;

        push    ecx         ; save remaining sectors in request

        xor     edx, edx    ; zero high part of dividend
        movzx   ecx, SectorsPerCluster
        div     ecx         ; edx = remainder
        push    edx         ; save remainder

        call    ComputeLcn  ; eax = LCN to read, ecx = remaining run length

        movzx   ebx, SectorsPerCluster
        mul     ebx         ; eax = LBN of cluster, edx = 0
        pop     edx         ; edx = remainder
        add     eax, edx    ; eax = LBN we want
        push    eax         ; save LBN

        movzx   eax, SectorsPerCluster
        mul     ecx         ; eax = remaining run length in sectors, edx = 0
        mov     edx, eax    ; edx = remaining run length

        pop     eax         ; eax = LBN
        pop     ecx         ; ecx = remaining sectors in request

        pop     es
        pop     edi
        pop     ecx


;       eax == LBN to read
;       ecx == remaining sectors to read
;       edx == remaining sectors in current run
;       es:edi == Target of read
;       TOS == Current VCN
;       TOS + 4 == pointer to attribute
;
        cmp     ecx, edx
        jge     ReadIBS_30

;       Run length is greater than remaining request; only read
;       remaining request.
;
        mov     edx, ecx    ; edx = Remaining request

ReadIBS_30:
;       eax == LBN to read
;       ecx == remaining sectors to read
;       edx == sectors to read in current run
;       es:edi == Target of read
;       TOS == Current VCN
;       TOS +  == pointer to attribute
;

        mov     SectorBase, eax
        mov     SectorCount, dx

;       We have a pointer to the target buffer in es:edi, but we want that
;       in es:bx for ReadSectors.
;

        SAVE_ALL

        mov     bx, di
        and     bx, 0Fh
        mov     ax, es
        shr     edi, 4
        add     ax, di              ; ax:bx -> target buffer

        push    ax
        pop     es                  ; es:bx -> target buffer

        call    ReadSectors

        RESTORE_ALL

        sub     ecx, edx            ; Decrement sectors remaining in request
        mov     ebx, edx            ; ebx = sectors read

        mov     eax, edx            ; eax = sectors read
        movzx   edx, BytesPerSector
        mul     edx                 ; eax = bytes read (wipes out edx!)

        add     edi, eax            ; Update target of read

        pop     eax                 ; eax = previous VBN
        add     eax, ebx            ; update VBN to read

        pop     ebx                 ; ebx -> attribute
        jmp     ReadIBS_10


ReadIndexBlockSectors endp


;****************************************************************************
;
;   MultiSectorFixup - fixup a structure read off the disk
;                      to reflect Update Sequence Array.
;
;   ENTRY:  ES:EDI = Target buffer
;
;   USES:   none (preserves all registers with SAVE_ALL/RESTORE_ALL)
;
;   Note: ES:EDI must point at a structure which is protected
;         by an update sequence array, and which begins with
;         a multi-sector-header structure.
;
MultiSectorFixup proc near

    SAVE_ALL

    movzx   ebx, es:[edi].MSH_UpdateArrayOfs    ; ebx = update array offset
    movzx   ecx, es:[edi].MSH_UpdateArraySize   ; ecx = update array size

    or      ecx, ecx        ; if the size of the update sequence array

    jz      BootErr$he      ; is zero, this structure is corrupt.

    add     ebx, edi        ; es:ebx -> update sequence array count word
    add     ebx, 2          ; es:ebx -> 1st entry of update array

    add     edi, SEQUENCE_NUMBER_STRIDE - 2 ; es:edi->last word of first chunk
    dec     ecx             ; decrement to reflect count word

MSF10:

;   ecx = number of entries remaining in update sequence array
;   es:ebx -> next entry in update sequence array
;   es:edi -> next target word for update sequence array

    or      ecx, ecx
    jz      MSF30

    mov     ax, word ptr es:[ebx]   ; copy next update sequence array entry
    mov     word ptr es:[edi], ax   ; to next target word

    add     ebx, 2                      ; go on to next entry
    add     edi, SEQUENCE_NUMBER_STRIDE ; go on to next target

    dec     ecx


    jmp     MSF10

MSF30:

    RESTORE_ALL

    ret

MultiSectorFixup endp

;****************************************************************************
;
;   SetupMft - Reads MFT File Record Segments into the LBN array
;
;   ENTRY:  none.
;
;   EXIT:   NextBuffer is set to the free byte after the last MFT FRS
;           SegmentsInMft is initialized
;
;
SetupMft proc near

        SAVE_ALL

;       Initialize SegmentsInMft and NextBuffer as if the MFT
;       had only one FRS.
;
        mov     eax, 1
        mov     SegmentsInMft, eax

        mov     eax, MftFrs                     ; this is the scratch mft buffer
        add     eax, BytesPerFrs
        mov     MftLcnFrs,eax                   ; this is the scratch mft buffer for lookup
        add     eax, BytesPerFrs
        mov     NextBuffer, eax


;       Read FRS 0 into the first MFT FRS buffer, being sure
;       to resolve the Update Sequence Array.  Remember the physical
;       location in the Lbn array.
;

        mov     eax, MftStartLcn.LowPart
        movzx   ebx, SectorsPerCluster
        mul     ebx                             ; eax = mft starting sector

        mov     ebx, NextBuffer                 ; Store this location in the Lbn array
        mov     [bx], eax
        mov     SectorBase, eax                 ; SectorBase = mft starting sector for read
        add     bx, 4
        mov     eax, SectorsPerFrs
        mov     [bx], eax                       ; Store the sector count in the Lcn array
        mov     SectorCount, ax                 ; SectorCount = SectorsPerFrs
        add     bx, 4
        mov     NextBuffer, ebx                 ; Remember the next Lbn array location

        mov     ebx, MftFrs                     ; Read the sectors into the MftFrs scratch buffer

        push    ds
        pop     es

        call    ReadSectors
        mov     edi, ebx                        ; es:edi = buffer

        call    MultiSectorFixup

;       Determine whether the MFT has an Attribute List attribute

        mov     eax, MftFrs
        mov     ebx, $ATTRIBUTE_LIST
        mov     ecx, 0
        mov     edx, 0

        call    LocateAttributeRecord

        or      eax, eax        ; If there's no Attribute list,
        jz      SetupMft99      ;    we're done!

;       Read the attribute list.
;       eax -> attribute list attribute
;
        mov     ebx, eax        ; ebx -> attribute list attribute
        push    ds
        pop     es              ; copy ds into es
        mov     edi, AttrList   ; ds:edi->attribute list buffer

        call    ReadWholeAttribute

        mov     ebx, AttrList   ; ebx -> first attribute list entry

;       Now, traverse the attribute list looking for the first
;       entry for the $DATA type.  We know it must have at least
;       one.
;
;       ebx -> first attribute list entry
;

SetupMft10:
        cmp     [bx].ATTRLIST_TypeCode, $DATA
        je      SetupMft30

        add     bx,[bx].ATTRLIST_Length
        jmp     SetupMft10


SetupMft20:
;       Scan forward through the attribute list entries for the
;       $DATA attribute, reading each referenced FRS.  Note that
;       there will be at least one non-$DATA entry after the entries
;       for the $DATA attribute, since there's a $BITMAP.
;
;       ebx -> Next attribute list entry
;       NextBuffer    -> Target for next mapping information
;       MftFrs        -> Target of next read
;       SegmentsInMft == number of MFT segments read so far
;

;       Find the physical sector and sector count for the runs for this
;       file record (max 2 runs).  The mapping for this must already
;       be in a file record already visited.  Find the Vcn and cluster
;       offset for this FRS.  Use LookupMftLcn to find the Lcn.

        push    ebx                 ; Save the current position in the attribute list

;       Convert from Frs to sectors, then to Vcn

        mov     eax, [bx].ATTRLIST_SegmentReference.REF_LowPart
        mul     SectorsPerFrs
        push    eax                 ; Remember the VBN
        xor     edx, edx
        movzx   ebx, SectorsPerCluster
        div     ebx                 ; eax = VCN
        push    edx                 ; save remainder, this is cluster offset

        call    ComputeMftLcn       ; eax = LCN

        or      eax, eax            ; LCN equal to zero?

        jz      BootErr$he          ; zero is not a possible LCN

        mov     ecx, SectorsPerFrs  ; ecx = Number of sectors remaining for this file record

;       Change the LCN back into an LBN and add the remainder back in to get
;       the sector we want to read.

        movzx   ebx, SectorsPerCluster
        mul     ebx                 ; eax = cluster first LBN
        pop     edx                 ; edx = sector remainder
        add     eax, edx            ; eax = desired LBN

;       Store this in the current Lcn array slot

        mov     ebx, NextBuffer
        mov     [bx], eax           ; Store the starting sector
        add     bx, 4
        movzx   eax, SectorsPerCluster
        sub     eax, edx

        cmp     eax, ecx            ; Check if we have too many sectors
        jbe     SetupMft60
        mov     eax, ecx            ; Limit ourselves to the sectors remaining
SetupMft60:
        mov     [bx], eax           ; Store the sector count

;       If we have a complete file record skip to process the attribute entry

SetupMft70:
        sub     ecx, eax            ; Subtract these sectors from remaining sectors
        pop     edx                 ; Get the previous starting VBN (restores stack also)

        jz      SetupMft50

;       This may be a split file record.  Go ahead and get the next piece.

        add     eax, edx            ; Add the sector count for the last run to the start Vbn for the run
                                    ; This is the next Vbn to read
        push    eax                 ; Save the Vbn

        xor     edx, edx            ; Convert to Vcn, there should be no remainder this time
        movzx   ebx, SectorsPerCluster
        div     ebx                 ; eax = VCN

        push    ecx                 ; Save the remaining sectors
        call    ComputeMftLcn       ; eax = LCN
        pop     ecx                 ; Restore the remaining sectors

        or      eax, eax            ; LCN equal to zero?
        jz      BootErr$he          ; zero is not a possible LCN

;       Change the LCN back into a LBN to get the starting sector we want to read.

        movzx   ebx, SectorsPerCluster
        mul     ebx                 ; eax = cluster first LBN

;       If this sector is the contiguous with the other half of the run
;       make it appear to be single longer run.

        mov     ebx, NextBuffer     ; Recover the last run
        mov     edx, [bx]
        add     bx, 4
        add     edx, [bx]           ; This is the next potential LBN

        cmp     edx, eax            ; Check if we are at the contiguous LBN
        jne     SetupMft80

;       Append this to the previous run.
        
        movzx   eax, SectorsPerCluster
        cmp     eax, ecx            ; Check if have more sectors than we need
        jbe     SetupMft90
        mov     eax, ecx
SetupMft90:

        add     [bx], eax
        jmp     SetupMft70          ; Loop to see if there more work to do

;       This is multiple runs.  Update the next entry.

SetupMft80:
        add     bx, 4
        mov     NextBuffer, ebx    ; advance our NextBuffer pointer

        mov     [bx], eax          ; fill in the next run start sector
        add     bx, 4

        movzx   eax, SectorsPerCluster
        cmp     eax, ecx            ; Check if have more sectors than we need
        jbe     SetupMft100
        mov     eax, ecx
SetupMft100:
        mov     [bx], eax          ; and count
        jmp     SetupMft70         ; Loop to see if there is more work to do

SetupMft50:

;       Advance the count of Frs segments and the NextBuffer pointer

        add     bx, 4
        inc     SegmentsInMft
        mov     NextBuffer, ebx

        pop     ebx

;       Go on to the next attribute list entry

SetupMft30:
        add     bx,[bx].ATTRLIST_Length
        cmp     [bx].ATTRLIST_TypeCode, $DATA
        je      SetupMft20

SetupMft99:

        RESTORE_ALL
        ret

SetupMft endp

;****************************************************************************
;
;   ComputeMftLcn   --  Computes the LCN for a cluster of the MFT
;
;
;   ENTRY:  EAX == VCN
;
;   EXIT:   EAX == LCN
;
;   USES:   ALL
;
ComputeMftLcn proc near

        mov     edx, eax                ; edx = VCN

        mov     ecx, SegmentsInMft      ; ecx = # of FRS's to search

        mov     esi,MftLcnFrs
        add     esi,BytesPerFrs         ; si -> FRS LBN list

MftLcn10:
;       ECX == number of remaining FRS's to search
;       EDX == VCN
;       EBX == Buffer to read into
;       ESI == LBN array
;       EDI == Number of sectors to read
;
        push    edx                     ; save VCN
        push    ecx                     ; save MFT segment count
        push    edx                     ; save VCN again

;       Read the sectors for the given FRS

        mov     ebx,MftLcnFrs
        mov     edi,SectorsPerFrs

;       Read these sectors

MftLcn40:
        mov     eax,[si]                ; Get the start sector and sector count
        mov     SectorBase,eax
        add     si,4
        mov     eax,[si]
        mov     SectorCount,ax
        add     si,4

        push    ds
        pop     es

        call    ReadSectors

;       Check if we have more data to read

        sub     edi, eax
        je      MftLcn30

;       Read the next run

        mul     BytesPerSector          ; move forward in the buffer, results in ax:dx
        add     bx,ax
        jmp     MftLcn40

MftLcn30:

;       Do the multi sector fixup

        mov     edi,MftLcnFrs
        push    ds
        pop     es

        call    MultiSectorFixup

        mov     eax, MftLcnFrs
        mov     ebx, $DATA
        mov     ecx, 0
        mov     edx, ecx

        call    LocateAttributeRecord

;       EAX -> $DATA attribute
;       TOS == VCN
;       TOS + 4 == number of remaining FRS's to search
;       TOS + 8 -> FRS being searched
;       TOS +12 == VCN

        or      eax, eax

        jz      BootErr$he  ; No $DATA attribute in this FRS!

        mov     ebx, eax    ; ebx -> attribute
        pop     eax         ; eax = VCN

;       EAX == VCN
;       EBX -> $DATA attribute
;       TOS number of remaining FRS's to search
;       TOS + 4 == FRS being searched
;       TOS + 8 == VCN

        push    esi
        call    ComputeLcn
        pop     esi

        or      eax, eax
        jz      MftLcn20

;       Found our LCN.  Clean up the stack and return.
;
;       EAX == LCN
;       TOS number of remaining FRS's to search
;       TOS + 4 == FRS being searched
;       TOS + 8 == VCN
;
        pop     ebx
        pop     ebx     ; clean up the stack

        ret

MftLcn20:
;
;       Didn't find the VCN in this FRS; try the next one.
;
;       TOS number of remaining FRS's to search
;       TOS + 4 -> FRS being searched
;       TOS + 8 == VCN
;
        pop     ecx     ; ecx = number of FRS's remaining, including current
        pop     edx     ; edx = VCN

        loop    MftLcn10            ; decrement cx and try next FRS

;       This VCN was not found.
;
        xor     eax, eax
        ret


ComputeMftLcn endp

;****************************************************************************
;
;   ReadMftSectors - Read sectors from the MFT
;
;   ENTRY:  EAX == starting VBN
;           ECX == number of sectors to read
;           ES:EDI == Target buffer
;
;   USES:   none (preserves all registers with SAVE_ALL/RESTORE_ALL)
;
ReadMftSectors proc near

    SAVE_ALL

RMS$Again:

    push    eax                     ; save starting VBN
    push    ecx                     ; save sector count

;   Divide the VBN by SectorsPerCluster to get the VCN

    xor     edx, edx                ; zero high part of dividend
    movzx   ebx, SectorsPerCluster
    div     ebx                     ; eax = VCN
    push    edx                     ; save remainder
    push    edi                     ; save the target buffer

    call    ComputeMftLcn           ; eax = LCN
    pop     edi                     ; recover the buffer

    or      eax, eax                ; LCN equal to zero?

    jz      BootErr$he              ; zero is not a possible LCN

;   Change the LCN back into a LBN and add the remainder back in to get
;   the sector we want to read, which goes into SectorBase.
;

    movzx   ebx, SectorsPerCluster
    mul     ebx                     ; eax = cluster first LBN
    pop     edx                     ; edx = sector remainder
    add     eax, edx                ; eax = desired LBN

    mov     SectorBase, eax


        
;
;   Figure out how many sectors to read this time; we never attempt
;   to read more than one cluster at a time.
;

    pop     ecx                     ; ecx = sectors to read

    movzx   ebx, SectorsPerCluster
    cmp     ecx,ebx
    jle     RMS10

;
;   Read only a single cluster at a time, to avoid problems with fragmented
;   runs in the mft.
;

    mov     SectorCount, bx         ; this time read 1 cluster
    sub     ecx, ebx                ; ecx = sectors remaining to read

    pop     eax                     ; eax = VBN
    add     eax, ebx                ; VBN += sectors this read


    push    eax                     ; save next VBN
    push    ecx                     ; save remaining sector count

    jmp     RMS20

RMS10:

    pop     eax                     ; eax = VBN
    add     eax, ecx                ; VBN += sectors this read
    push    eax                     ; save next VBN

    mov     SectorCount, cx
    mov     ecx, 0
    push    ecx                     ; save remaining sector count (0)

RMS20:


;   The target buffer was passed in es:edi, but we want it in es:bx.
;   Do the conversion.
;

    push    es                      ; save buffer pointer
    push    edi

    mov     bx, di
    and     bx, 0Fh
    mov     ax, es
    shr     edi, 4
    add     ax, di                  ; ax:bx -> target buffer

    push    ax
    pop     es                      ; es:bx -> target buffer

    call    ReadSectors

    pop     edi                     ; restore buffer pointer
    pop     es

    add     edi, BytesPerCluster    ; increment buf ptr by one cluster

    pop     ecx                     ; restore remaining sector count
    pop     eax                     ; restore starting VBN

    cmp     ecx, 0                  ; are we done?
    jg      RMS$Again               ; repeat until desired == 0


    RESTORE_ALL
    ret

ReadMftSectors endp


;****************************************************************************
;
;   ReadFrs - Read an FRS
;
;   ENTRY:  EAX == FRS number
;           ES:EDI == Target buffer
;
;   USES:  none (preserves all registers with SAVE_ALL/RESTORE_ALL)
;
ReadFrs proc near

    SAVE_ALL

    mul     SectorsPerFrs       ; eax = sector number in MFT DATA attribute
                                ; (note that mul wipes out edx!)

    mov     ecx, SectorsPerFrs  ; number of sectors to read

    call    ReadMftSectors
    call    MultiSectorFixup

    RESTORE_ALL
    ret

ReadFrs endp

;****************************************************************************
;
;   ReadIndexBlock - read an index block from the root index.
;
;   ENTRY:  EAX == Block number
;
;   USES:  none (preserves all registers with SAVE_ALL/RESTORE_ALL)
;
ReadIndexBlock proc near

    SAVE_ALL

    mul     SectorsPerIndexBlock        ; eax = first VBN to read
                                        ; (note that mul wipes out edx!)
    mov     ebx, IndexAllocation        ; ebx -> $INDEX_ALLOCATION attribute
    mov     ecx, SectorsPerIndexBlock   ; ecx == Sectors to read

    push    ds
    pop     es
    mov     edi, IndexBlockBuffer       ; es:edi -> index block buffer

    call    ReadIndexBlockSectors

    call    MultiSectorFixup

    RESTORE_ALL
    ret

ReadIndexBlock endp

;****************************************************************************
;
;   IsBlockInUse - Checks the index bitmap to see if an index
;                  allocation block is in use.
;
;   ENTRY:  EAX == block number
;
;   EXIT:   Carry flag clear if block is in use
;           Carry flag set   if block is not in use.
;
IsBlockInUse proc near

        push    eax
        push    ebx
        push    ecx

        mov     ebx, IndexBitmapBuffer

        mov     ecx, eax    ; ecx = block number
        shr     eax, 3      ; eax = byte number
        and     ecx, 7      ; ecx = bit number in byte

        add     ebx, eax    ; ebx -> byte to test

        mov     eax, 1
        shl     eax, cl     ; eax = mask

        test    byte ptr[ebx], al

        jz      IBU10

        clc                 ; Block is not in use.
        jmp     IBU20

IBU10:  stc                 ; Block is in use.

IBU20:
        pop     ecx
        pop     ebx
        pop     eax         ; restore registers

        ret

IsBlockInUse endp

;****************************************************************************
;
;   ComputeLcn - Converts a VCN into an LCN
;
;   ENTRY:  EAX -> VCN
;           EBX -> Attribute
;
;   EXIT:   EAX -> LCN  (zero indicates not found)
;           ECX -> Remaining run length
;
;   USES:   ALL.
;
ComputeLcn proc near

        cmp     [ebx].ATTR_FormCode, NONRESIDENT_FORM
        je      clcn10

        sub     eax, eax    ; This is a resident attribute.
        ret

clcn10: lea     esi, [ebx].ATTR_FormUnion   ; esi -> nonresident info of attrib

;       eax -> VCN
;       ebx -> Attribute
;       esi -> Nonresident information of attribute record
;
;       See if the desired VCN is in range.

        mov     edx, [esi].NONRES_HighestVcn.LowPart ; edx = HighestVcn
        cmp     eax, edx
        ja      clcn15      ; VCN is greater than HighestVcn

        mov     edx, [esi].NONRES_LowestVcn.LowPart ; edx = LowestVcn
        cmp     eax, edx
        jae     clcn20

clcn15:
        sub     eax, eax    ; VCN is not in range
        ret

clcn20:
;       eax -> VCN
;       ebx -> Attribute
;       esi -> Nonresident information of attribute record
;       edx -> LowestVcn
;
        add     bx, [esi].NONRES_MappingPairOffset  ; ebx -> mapping pairs
        sub     esi, esi                            ; esi = 0

clcn30:
;       eax == VCN to find
;       ebx -> Current mapping pair count byte
;       edx == Current VCN
;       esi == Current LCN
;
        cmp     byte ptr[ebx], 0    ; if count byte is zero...
        je      clcn99              ;  ... we're done (and didn't find it)

;       Update CurrentLcn
;
        call    LcnFromMappingPair
        add     esi, ecx            ; esi = current lcn for this mapping pair

        call    VcnFromMappingPair

;       eax == VCN to find
;       ebx -> Current mapping pair count byte
;       ecx == DeltaVcn for current mapping pair
;       edx == Current VCN
;       esi == Current LCN
;
        add     ecx, edx            ; ecx = NextVcn

        cmp     eax, ecx            ; If target < NextVcn ...
        jl      clcn80              ;   ... we found the right mapping pair.

;       Go on to next mapping pair.
;
        mov     edx, ecx            ; CurrentVcn = NextVcn

        push    eax

        movzx   ecx, byte ptr[ebx]  ; ecx = count byte
        mov     eax, ecx            ; eax = count byte
        and     eax, 0fh            ; eax = number of vcn bytes
        shr     ecx, 4              ; ecx = number of lcn bytes

        add     ebx, ecx
        add     ebx, eax
        inc     ebx                 ; ebx -> next count byte

        pop     eax
        jmp     clcn30

clcn80:
;       We found the mapping pair we want.
;
;       eax == target VCN
;       ebx -> mapping pair count byte
;       edx == Starting VCN of run
;       ecx == Next VCN (ie. start of next run)
;       esi == starting LCN of run
;
        sub     ecx, eax            ; ecx = remaining run length
        sub     eax, edx            ; eax = offset into run
        add     eax, esi            ; eax = LCN to return

        ret

;       The target VCN is not in this attribute.

clcn99: sub     eax, eax    ; Not found.
        ret


ComputeLcn endp

;****************************************************************************
;
;   VcnFromMappingPair
;
;   ENTRY:  EBX -> Mapping Pair count byte
;
;   EXIT:   ECX == DeltaVcn from mapping pair
;
;   USES:   ECX
;
VcnFromMappingPair proc near

        sub     ecx, ecx            ; ecx = 0
        mov     cl, byte ptr[ebx]   ; ecx = count byte
        and     cl, 0fh             ; ecx = v

        cmp     ecx, 0              ; if ecx is zero, volume is corrupt.
        jne     VFMP5

        sub     ecx, ecx
        ret

VFMP5:
        push    ebx
        push    edx

        add     ebx, ecx            ; ebx -> last byte of compressed vcn

        movsx   edx, byte ptr[ebx]
        dec     ecx
        dec     ebx

;       ebx -> Next byte to add in
;       ecx == Number of bytes remaining
;       edx == Accumulated value
;
VFMP10: cmp     ecx, 0              ; When ecx == 0, we're done.
        je      VFMP20

        shl     edx, 8
        mov     dl, byte ptr[ebx]

        dec     ebx                 ; Back up through bytes to process.
        dec     ecx                 ; One less byte to process.

        jmp     VFMP10

VFMP20:
;       edx == Accumulated value to return

        mov     ecx, edx

        pop     edx
        pop     ebx

        ret

VcnFromMappingPair endp


;****************************************************************************
;
;   LcnFromMappingPair
;
;   ENTRY:  EBX -> Mapping Pair count byte
;
;   EXIT:   ECX == DeltaLcn from mapping pair
;
;   USES:   ECX
;
LcnFromMappingPair proc near

        push    ebx
        push    edx

        sub     edx, edx            ; edx = 0
        mov     dl, byte ptr[ebx]   ; edx = count byte
        and     edx, 0fh            ; edx = v

        sub     ecx, ecx            ; ecx = 0
        mov     cl, byte ptr[ebx]   ; ecx = count byte
        shr     cl, 4               ; ecx = l

        cmp     ecx, 0              ; if ecx is zero, volume is corrupt.
        jne     LFMP5

        sub     ecx, ecx

        pop     edx
        pop     ebx
        ret

LFMP5:
;       ebx -> count byte
;       ecx == l
;       edx == v
;

        add     ebx, edx            ; ebx -> last byte of compressed vcn
        add     ebx, ecx            ; ebx -> last byte of compressed lcn

        movsx   edx, byte ptr[ebx]
        dec     ecx
        dec     ebx

;       ebx -> Next byte to add in
;       ecx == Number of bytes remaining
;       edx == Accumulated value
;
LFMP10: cmp     ecx, 0              ; When ecx == 0, we're done.
        je      LFMP20

        shl     edx, 8
        mov     dl, byte ptr[ebx]

        dec     ebx                 ; Back up through bytes to process.
        dec     ecx                 ; One less byte to process.

        jmp     LFMP10

LFMP20:
;       edx == Accumulated value to return

        mov     ecx, edx

        pop     edx
        pop     ebx

        ret

LcnFromMappingPair endp

;****************************************************************************
;
; UpcaseName - Converts the name of the file to all upper-case
;
;       ENTRY:  ESI -> Name
;               ECX -> Length of name
;
;       USES:   none
;
UpcaseName proc   near


        or      ecx, ecx
        jnz     UN5

        ret

UN5:
        push    ecx
        push    esi

UN10:
        cmp     word ptr[esi], 'a'      ; if it's less than 'a'
        jl      UN20                    ; leave it alone

        cmp     word ptr[esi], 'z'      ; if it's greater than 'z'
        jg      UN20                    ; leave it alone.

        sub     word ptr[esi], 'a'-'A'  ; the letter is lower-case--convert it.
UN20:
        add     esi, 2                  ; move on to next unicode character
        loop    UN10

        pop     esi
        pop     ecx

        ret
UpcaseName endp

;****************************************************************************
;
;   FindFile - Locates the index entry for a file in the root index.
;
;   ENTRY:  EAX -> name to find
;           ECX == length of file name in characters
;
;   EXIT:   EAX -> Index Entry.  NULL to indicate failure.
;
;   USES:   ALL
;
FindFile proc near

        push    eax     ; name address
        push    ecx     ; name length

;       First, search the index root.
;
;       eax -> name to find
;       ecx == name length
;       TOS == name length
;       TOS+4 -> name to find
;
        mov     edx, eax                    ; edx -> name to find
        mov     eax, IndexRoot              ; eax -> &INDEX_ROOT attribute
        lea     ebx, [eax].ATTR_FormUnion   ; ebx -> resident info
        add     ax, [ebx].RES_ValueOffset   ; eax -> Index Root value

        lea     eax, [eax].IR_IndexHeader   ; eax -> Index Header

        mov     ebx, edx                    ; ebx -> name to find

        call    LocateIndexEntry

        or      eax, eax
        jz      FindFile20

;       Found it in the root!  The result is already in eax.
;       Clean up the stack and return.
;
        pop     ecx
        pop     ecx
        ret

FindFile20:
;
;       We didn't find the index entry we want in the root, so we have to
;       crawl through the index allocation buffers.
;
;       TOS == name length
;       TOS+4 -> name to find
;
        mov     eax, IndexAllocation
        or      eax, eax
        jnz     FindFile30

;       There is no index allocation attribute; clean up
;       the stack and return failure.
;
        pop     ecx
        pop     ecx
        xor     eax, eax
        ret

FindFile30:
;
;       Search the index allocation blocks for the name we want.
;       Instead of searching in tree order, we'll just start with
;       the last one and work our way backwards.
;
;       TOS == name length
;       TOS+4 -> name to find
;
        mov     edx, IndexAllocation        ; edx -> index allocation attr.
        lea     edx, [edx].ATTR_FormUnion   ; edx -> nonresident form info
        mov     eax, [edx].NONRES_HighestVcn.LowPart; eax = HighestVcn
        inc     eax                         ; eax = clusters in attribute

        mov     ebx, BytesPerCluster
        mul     ebx                         ; eax = bytes in attribute

        xor     edx, edx
        div     BytesPerIndexBlock          ; convert bytes to index blocks

        push    eax                         ; number of blocks to process

FindFile40:
;
;       TOS == remaining index blocks to search
;       TOS + 4 == name length
;       TOS + 8 -> name to find
;
        pop     eax         ; eax == number of remaining blocks

        or      eax, eax
        jz      FindFile90

        dec     eax         ; eax == number of next block to process
                            ;        and number of remaining blocks

        push    eax

;       eax == block number to process
;       TOS == remaining index blocks to search
;       TOS + 4 == name length
;       TOS + 8 -> name to find
;
;       See if the block is in use; if not, go on to next.

        call    IsBlockInUse
        jc      FindFile40      ; c set if not in use

;       eax == block number to process
;       TOS == remaining index blocks to search
;       TOS + 4 == name length
;       TOS + 8 -> name to find
;

        call    ReadIndexBlock

        pop     edx         ; edx == remaining buffers to search
        pop     ecx         ; ecx == name length
        pop     ebx         ; ebx -> name

        push    ebx
        push    ecx
        push    edx

;       ebx -> name to find
;       ecx == name length in characters
;       TOS == remaining blocks to process
;       TOS + 4 == name length
;       TOS + 8 -> name
;
;       Index buffer to search is in index allocation block buffer.
;
        mov     eax, IndexBlockBuffer       ; eax -> Index allocation block
        lea     eax, [eax].IB_IndexHeader   ; eax -> Index Header

        call    LocateIndexEntry            ; eax -> found entry

        or      eax, eax
        jz      FindFile40

;       Found it!
;
;       eax -> Found entry
;       TOS == remaining blocks to process
;       TOS + 4 == name length
;       TOS + 8 -> name
;
        pop     ecx
        pop     ecx
        pop     ecx ; clean up stack
        ret

FindFile90:
;
;       Name not found.
;
;       TOS == name length
;       TOS + 4 -> name to find
;
        pop     ecx
        pop     ecx         ; clean up stack.
        xor     eax, eax    ; zero out eax.
        ret


FindFile endp

ifdef DEBUG
;****************************************************************************
;
;   DumpIndexBlock - dumps the index block buffer
;
DumpIndexBlock proc near

    SAVE_ALL

    mov     esi, IndexBlockBuffer

    mov     ecx, 20h    ; dwords to dump

DIB10:

    test    ecx, 3
    jnz     DIB20
    call    DebugNewLine

DIB20:

    lodsd
    call    PrintNumber
    loop    DIB10

    RESTORE_ALL
    ret

DumpIndexBlock endp

;****************************************************************************
;
;   DebugNewLine
;
DebugNewLine proc near

    SAVE_ALL

    xor     eax, eax
    xor     ebx, ebx

    mov     al, 0dh
    mov     ah, 14
    mov     bx, 7
    int     10h

    mov     al, 0ah
    mov     ah, 14
    mov     bx, 7
    int     10h

    RESTORE_ALL
    ret

DebugNewLine endp


;****************************************************************************
;
;   PrintName  -   Display a unicode name
;
;   ENTRY:  DS:ESI  -> null-terminated string
;           ECX     == characters in string
;
;   USES:   None.
;
PrintName proc near


IFDEF NEC_98
else
    SAVE_ALL

    or      ecx, ecx
    jnz     PrintName10

    call    DebugNewLine

    RESTORE_ALL

    ret

PrintName10:

    xor     eax, eax
    xor     ebx, ebx

    lodsw

    mov     ah, 14  ; write teletype
    mov     bx, 7   ; attribute
    int     10h     ; print it
    loop    PrintName10

    call    DebugNewLine

    RESTORE_ALL
endif
    ret

PrintName endp

;****************************************************************************
;
;   DebugPrint  -   Display a debug string.
;
;   ENTRY:  DS:SI  -> null-terminated string
;
;   USES:   None.
;
.286
DebugPrint proc near

    pusha

DbgPr20:

    lodsb
    cmp     al, 0
    je      DbgPr30

    mov     ah, 14  ; write teletype
    mov     bx, 7   ; attribute
    int     10h     ; print it
    jmp     DbgPr20

DbgPr30:

    popa
    nop
    ret

DebugPrint endp

;****************************************************************************
;
;
;   PrintNumber
;
;   ENTRY: EAX == number to print
;
;   PRESERVES ALL REGISTERS
;
.386
PrintNumber proc near


IFDEF NEC_98
else
    SAVE_ALL

    mov     ecx, 8      ; number of digits in a DWORD

PrintNumber10:

    mov     edx, eax
    and     edx, 0fh    ; edx = lowest-order digit
    push    edx         ; put it on the stack
    shr     eax, 4      ; drop low-order digit
    loop    PrintNumber10

    mov     ecx, 8      ; number of digits on stack.

PrintNumber20:

    pop     eax         ; eax = next digit to print
    cmp     eax, 9
    jg      PrintNumber22

    add     eax, '0'
    jmp     PrintNumber25

PrintNumber22:

    sub     eax, 10
    add     eax, 'A'

PrintNumber25:

    xor     ebx, ebx

    mov     ah, 14
    mov     bx, 7
    int     10h
    loop    PrintNumber20

;   Print a space to separate numbers

    mov     al, ' '
    mov     ah, 14
    mov     bx, 7
    int     10h

    RESTORE_ALL

    call    Pause

endif
    ret

PrintNumber endp


IFDEF NEC_98
Debug0 proc near
Debug1:
Debug2:
Debug3:
Debug4:
        ret
Debug0 endp
else
;****************************************************************************
;
;   Debug0 - Print debug string 0 -- used for checkpoints in mainboot
;
Debug0 proc near

    SAVE_ALL

    mov     si, offset DbgString0
    call    BootErr$Print1

    RESTORE_ALL

    ret

Debug0 endp

;****************************************************************************
;
;   Debug1 - Print debug string 1 --
;
Debug1 proc near

    SAVE_ALL

    mov     si, offset DbgString1
    call    BootErr$Print1

    RESTORE_ALL

    ret

Debug1 endp

;****************************************************************************
;
;   Debug2 - Print debug string 2
;
Debug2 proc near

    SAVE_ALL

    mov     si, offset DbgString2
    call    BootErr$Print1

    RESTORE_ALL

    ret

Debug2 endp

;****************************************************************************
;
;   Debug3 - Print debug string 3 --
;
Debug3 proc near

    SAVE_ALL

    mov     si, offset DbgString3
    call    BootErr$Print1

    RESTORE_ALL

    ret

Debug3 endp

;****************************************************************************
;
;   Debug4 - Print debug string 4
;
Debug4 proc near

    SAVE_ALL

    mov     si, offset DbgString4
    call    BootErr$Print1

    RESTORE_ALL

    ret

Debug4 endp

;****************************************************************************
;
;   Pause - Pause for about 1/2 a second.  Simply count until you overlap
;           to zero.
;
Pause proc near

    push eax
    mov  eax, 0fff10000h

PauseLoopy:
    inc  eax

    or   eax, eax
    jnz  PauseLoopy

    pop  eax
    ret

Pause endp

endif ; DEBUG

endif
;*************************************************************************
;
;       LoadIndexFrs  -  For the requested index type code locate and
;                        load the associated Frs.
;
;       ENTRY: EAX - requested index type code
;              ECX - Points to empty Frs buffer
;
;       EXIT:  EAX - points to offset in Frs buffer of requested index type
;                    code or Zero if not found.
;       USES:  All
;
LoadIndexFrs    proc    near

        push    ecx                     ; save FRS buffer for later
        push    eax                     ; save index type code for later

        mov     eax, ROOT_FILE_NAME_INDEX_NUMBER
        push    ds
        pop     es
        mov     edi, ecx                ; es:edi = target buffer

        call    ReadFrs

        mov     eax, ecx                ; FRS to search

        pop     ebx                     ; Attribute type code
        push    ebx
        movzx   ecx, index_name_length  ; Attribute name length
        mov     edx, offset index_name  ; Attribute name

        call    LocateAttributeRecord

        pop     ebx
        pop     ecx

        or      eax, eax
        jnz     LoadIndexFrs$Exit      ; if found in root return

;
;       if not found in current Frs, search in attribute list
;
                                       ; EBX - holds Attribute type code
        mov     eax, ecx               ; FRS to search
        mov     ecx, ebx               ; type code
        push    eax                    ; save Frs
        push    ebx                    ; save type code

        call    SearchAttrList          ; search attribute list for FRN
                                        ; of specified ($INDEX_ROOT,
                                        ; $INDEX_ALLOCATION, or $BITMAP)

        ; EAX - holds FRN for Frs, or Zero

        pop     ebx                     ; Attribute type code (used later)
        pop     edi                     ; es:edi = target buffer

        or      eax, eax                ; if we cann't find it in attribute
        jz      LoadIndexFrs$Exit       ; list then we are hosed


;       We should now have the File Record Number where the index for the
;       specified type code we are searching for is,  load this into the
;       Frs target buffer.
;
;       EAX - holds FRN
;       EBX - holds type code
;       EDI - holds target buffer

        push    ds
        pop     es

        call    ReadFrs

;
;       Now determine the offset in the Frs of the index
;

;       EBX - holds type code

        mov     eax, edi                ; Frs to search
        movzx   ecx, index_name_length  ; Attribute name length
        mov     edx, offset index_name  ; Attribute name

        call    LocateAttributeRecord

;       EAX -  holds offset or Zero.


LoadIndexFrs$Exit:
        ret

LoadIndexFrs    endp


;****************************************************************************
;
;   SearchAttrList
;
;   Search the Frs for the attribute list.  Then search the attribute list
;   for the specifed type code.  When you find it return the FRN in the
;   attribute list entry found or Zero if no match found.
;
;   ENTRY: ECX - type code to search attrib list for
;          EAX - Frs buffer holding head of attribute list
;   EXIT:  EAX - FRN file record number to load, Zero if none.
;
;   USES: All
;
SearchAttrList proc  near

        push    ecx                     ; type code to search for in
                                        ; attrib list

                                        ; EAX - holds Frs to search
        mov     ebx, $ATTRIBUTE_LIST    ; Attribute type code
        mov     ecx, 0                  ; Attribute name length
        mov     edx, 0                  ; Attribute name

        call    LocateAttributeRecord

        or      eax, eax                      ; If there's no Attribute list,
        jz      SearchAttrList$NotFoundIndex1 ; We are done

;       Read the attribute list.
;       eax -> attribute list attribute

        mov     ebx, eax        ; ebx -> attribute list attribute
        push    ds
        pop     es              ; copy ds into es
        mov     edi, AttrList   ; ds:edi->attribute list buffer

        call    ReadWholeAttribute

        push    ds
        pop     es
        mov     ebx, AttrList   ; es:ebx -> first attribute list entry

;       Now, traverse the attribute list looking for the entry for
;       the Index type code.
;
;       ebx -> first attribute list entry
;

        pop     ecx                            ; Get Index Type code


SearchAttrList$LookingForIndex:

ifdef DEBUG
        SAVE_ALL

        mov     eax, es:[bx].ATTRLIST_TypeCode
        call    PrintNumber
        movzx   eax, es:[bx].ATTRLIST_Length
        call    PrintNumber
        mov     eax, es
        call    PrintNumber
        mov     eax, ebx
        call    PrintNumber
        push    es
        pop     ds
        movzx   ecx, es:[bx].ATTRLIST_NameLength    ; ecx = chars in name
        lea     esi, es:[bx].ATTRLIST_Name          ; esi -> name
        call    PrintName

        RESTORE_ALL
endif ; DEBUG

        cmp     es:[bx].ATTRLIST_TypeCode, ecx
        je      SearchAttrList$FoundIndex

        cmp     es:[bx].ATTRLIST_TypeCode, $END   ; reached invalid attribute
        je      SearchAttrList$NotFoundIndex2     ; so must be at end

        cmp     es:[bx].ATTRLIST_Length, 0
        je      SearchAttrList$NotFoundIndex2     ; reached end of list and
                                                  ; nothing found
        movzx   eax, es:[bx].ATTRLIST_Length
        add     bx, ax

        mov     ax, bx
        and     ax, 08000h                        ; test for roll over
        jz      SearchAttrList$LookingForIndex

        ;  If we rolled over then increment to the next es 32K segment and
        ;  zero off the high bits of bx

        mov     ax, es
        add     ax, 800h
        mov     es, ax

        and     bx, 07fffh

        jmp     SearchAttrList$LookingForIndex

SearchAttrList$FoundIndex:

        ;  found the index, return the FRN

        mov     eax, es:[bx].ATTRLIST_SegmentReference.REF_LowPart
        ret


SearchAttrList$NotFoundIndex1:
        pop     ecx
SearchAttrList$NotFoundIndex2:
        xor     eax, eax
        ret

SearchAttrList endp

;
; Boot message printing, relocated from sector 0 to sace space
;
ifdef NEC_98
BootErr$ntc:
endif
BootErr$fnf:
        mov     al,byte ptr TXT_MSG_SYSINIT_FILE_NOT_FD
        jmp     BootErr2
ifdef NEC_98
else
BootErr$ntc:
        mov     al,byte ptr TXT_MSG_SYSINIT_NTLDR_CMPRS
        jmp     BootErr2
endif

ifdef DEBUG
DbgString0      db  "Debug Point 0", 0Dh, 0Ah, 0
DbgString1      db  "Debug Point 1", 0Dh, 0Ah, 0
DbgString2      db  "Debug Point 2", 0Dh, 0Ah, 0
DbgString3      db  "Debug Point 3", 0Dh, 0Ah, 0
DbgString4      db  "Debug Point 4", 0Dh, 0Ah, 0

endif ; DEBUG

        .errnz  ($-_ntfsboot) GT 8192   ; <FATAL PROBLEM: main boot record exceeds available space>

        org     8192

BootCode ends

         end _ntfsboot
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\ntfs\ia64\ntfsdefs.h ===
//
// Constant definitions
//

#define LowPart 0x0
#define HighPart 0x4
#define MASTER_FILE_TABLE_NUMBER 0x0
#define MASTER_FILE_TABLE2_NUMBER 0x1
#define LOG_FILE_NUMBER 0x2
#define VOLUME_DASD_NUMBER 0x3
#define ATTRIBUTE_DEF_TABLE_NUMBER 0x4
#define ROOT_FILE_NAME_INDEX_NUMBER 0x5
#define BIT_MAP_FILE_NUMBER 0x6
#define BOOT_FILE_NUMBER 0x7
#define BAD_CLUSTER_FILE_NUMBER 0x8
#define QUOTA_TABLE_NUMBER 0x9
#define UPCASE_TABLE_NUMBER 0xa
#define $STANDARD_INFORMATION 0x10
#define $ATTRIBUTE_LIST 0x20
#define $FILE_NAME 0x30
#define $OBJECT_ID 0x40
#define $SECURITY_DESCRIPTOR 0x50
#define $VOLUME_NAME 0x60
#define $VOLUME_INFORMATION 0x70
#define $DATA 0x80
#define $INDEX_ROOT 0x90
#define $INDEX_ALLOCATION 0xa0
#define $BITMAP 0xb0
#define $SYMBOLIC_LINK 0xc0
#define $EA_INFORMATION 0xd0
#define $EA 0xe0
#define $FIRST_USER_DEFINED_ATTRIBUTE 0x100
#define $END 0xffffffff
#define SEQUENCE_NUMBER_STRIDE 0x200
#define REF_SegmentNumberLowPart 0x0
#define REF_SegmentNumberHighPart 0x4
#define REF_SequenceNumber 0x6
#define MSH_Signature 0x0
#define MSH_UpdateSequenceArrayOffset 0x4
#define MSH_UpdateSequenceArraySize 0x6
#define FRS_MultiSectorHeader 0x0
#define FRS_Lsn 0x8
#define FRS_SequenceNumber 0x10
#define FRS_ReferenceCount 0x12
#define FRS_FirstAttributeOffset 0x14
#define FRS_Flags 0x16
#define FRS_FirstFreeByte 0x18
#define FRS_BytesAvailable 0x1c
#define FRS_BaseFileRecordSegment 0x20
#define FRS_NextAttributeInstance 0x28
#define FRS_UpdateArrayForCreateOnly 0x2a
#define FILE_RECORD_SEGMENT_IN_USE 0x1
#define FILE_FILE_NAME_INDEX_PRESENT 0x2
#define ATTR_TypeCode 0x0
#define ATTR_RecordLength 0x4
#define ATTR_FormCode 0x8
#define ATTR_NameLength 0x9
#define ATTR_NameOffset 0xa
#define ATTR_Flags 0xc
#define ATTR_Instance 0xe
#define ATTR_Form 0x10
#define RES_ValueLength 0x10
#define RES_ValueOffset 0x14
#define RES_ResidentFlags 0x16
#define RES_Reserved 0x17
#define NONRES_LowestVcn 0x10
#define NONRES_HighestVcn 0x18
#define NONRES_MappingPairOffset 0x20
#define NONRES_CompressionUnit 0x22
#define NONRES_Reserved 0x23
#define NONRES_AllocatedLength 0x28
#define NONRES_FileSize 0x30
#define NONRES_ValidDataLength 0x38
#define NONRES_TotalAllocated 0x40
#define RESIDENT_FORM 0x0
#define NONRESIDENT_FORM 0x1
#define ATTRIBUTE_FLAG_COMPRESSION_MASK 0xff
#define ATTRLIST_AttributeTypeCode 0x0
#define ATTRLIST_RecordLength 0x4
#define ATTRLIST_AttributeNameLength 0x6
#define ATTRLIST_AttributeNameOffset 0x7
#define ATTRLIST_LowestVcn 0x8
#define ATTRLIST_SegmentReference 0x10
#define ATTRLIST_Instance 0x18
#define ATTRLIST_AttributeName 0x1a
#define FAT_DIRENT_ATTR_READ_ONLY 0x1
#define FAT_DIRENT_ATTR_HIDDEN 0x2
#define FAT_DIRENT_ATTR_SYSTEM 0x4
#define FAT_DIRENT_ATTR_VOLUME_ID 0x8
#define FAT_DIRENT_ATTR_ARCHIVE 0x20
#define FAT_DIRENT_ATTR_DEVICE 0x40
#define DUPINFO_CreationTime 0x0
#define DUPINFO_LastModificationTime 0x8
#define DUPINFO_LastChangeTime 0x10
#define DUPINFO_LastAccessTime 0x18
#define DUPINFO_AllocatedLength 0x20
#define DUPINFO_FileSize 0x28
#define DUPINFO_FileAttributes 0x30
#define DUPINFO_PackedEaSize 0x34
#define DUPINFO_Reserved 0x36
#define FN_ParentDirectory 0x0
#define FN_Info 0x8
#define FN_FileNameLength 0x40
#define FN_Flags 0x41
#define FN_FileName 0x42
#define FILE_NAME_NTFS 0x1
#define FILE_NAME_DOS 0x2
#define FILE_NAME_LINK 0x4
#define IH_FirstIndexEntry 0x0
#define IH_FirstFreeByte 0x4
#define IH_BytesAvailable 0x8
#define IH_Flags 0xc
#define IH_Reserved 0xd
#define INDEX_NODE 0x1
#define IR_IndexedAttributeType 0x0
#define IR_CollationRule 0x4
#define IR_BytesPerIndexBuffer 0x8
#define IR_BlocksPerIndexBuffer 0xc
#define IR_Reserved 0xd
#define IR_IndexHeader 0x10
#define IB_MultiSectorHeader 0x0
#define IB_Lsn 0x8
#define IB_ThisBlock 0x10
#define IB_IndexHeader 0x18
#define IB_UpdateSequenceArray 0x28
#define IE_FileReference 0x0
#define IE_Length 0x8
#define IE_AttributeLength 0xa
#define IE_Flags 0xc
#define IE_Reserved 0xe
#define INDEX_ENTRY_NODE 0x1
#define INDEX_ENTRY_END 0x2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\ntfs\ia64\ntfsboot.s ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

//++
//
//  Module name
//      NTFSBOOT.S
//  Author
//      Allen Kay    (akay)    May-6-97
//  Description
//      NTFS boot code
// Notes
//      This is the startup routine for NTFS NT boot sector.  It finds
//      NTLDR by walk through the NTFS file system structure.
// Assumptions
//      1.  SAL/Gambit makes sure all TLB entries are purged before
//          passing control to SuSetup().
// SuSetup does the following:
//      1.   Initialize PSR with interrupt disabled.
//      2.   Invalidate ALAT.
//      3.   Invalidate RS.
//      4.   Setup GP.
//      5.   Set region registers rr[r0] - rr[r7] to RID=0, PS=8K, E=0.
//      6.   Initialize SP to 0x00902000.
//      7.   Initialize BSP to 0x00202000.
//      8.   Enable register stack engine.
//      9.   Setup IVA to 0x001F8000.
//      10.  Setup virtual->physical address translation
//           0x80000000->0x00000000 in dtr0/itr0 for NT kernel.
//      11.  Setup virtual->physical address translation
//           0x80400000->0x00400000 in dtr1/itr1 for HAL.dll.
//      12.  Setup virtual->physical address translation
//           0x00800000->0x00800000 in dtr1/itr1 for NTLDR.
//---

#include "ksia64.h"
#include "susetup.h"
#include "ntfsdefs.h"

        .file   "ntfsboot.s"

#define NewSeg 0x100000
#define LdrSeg 0x200000

        .global Multiply
        .type Multiply, @function

        .global Divide
        .type Divide, @function

        .global memcpy
        .type memcpy, @function

        .global strncmp
        .type strncmp, @function

        .global PrintName
        .type PrintName, @function

        .global BootErr$Print
        .type BootErr$Print, @function

        .global SscExit
        .type SscExit, @function

        .global SalDiskReadWrite
        .type SalDiskReadWrite, @function

        .global ReadSectors
        .type ReadSectors, @function

        .global SalPrint
        .type SalPrint, @function

        .global LoadNtldrSymbols
        .type LoadNtldrSymbols, @function

        .global RelocateLoaderSections
        .type RelocateLoaderSections, @function

//
//      This is a template BPB--anyone who writes boot code to disk
//      should either preserve the existing BPB and NTFS information
//      or create it anew.
//

#ifdef BSDT
//
// First define the Boot Sector Descriptor Table (BSDT)
//
BsdtSignature:      data1    0x01, 0x02, 0x45, 0x4d, 0x0f, 0x00
BsdtSectors:        data2    64
BsdtEntryPoint:     data4    mainboot
BsdtVersion:        data1    0
BsdtReserved:       data1    0, 0
BsdtCheckSum:       data1    0
#endif

//
// Start of the NTFS boot sector
//
Version:            string      "NTFS    "  // Must be 8 characters
BytesPerSector:     data2.ua    0           // Size of a physical sector 
SectorsPerCluster:  data1       0           // Sectors per allocation unit

//
// Traditionally the next 7 bytes were the reserved sector count, fat count,
// root dir entry count, and the small volume sector count. However all of
// these fields must be 0 on NTFS volumes.
//
// We use this space to store some temporary variables used by the boot code,
// which avoids the need for separate space in sector 0 to store them.
// We also take advantage of the free 0-initialization to save some space
// by avoiding the code to initialize them.
//
// Note that ideally we'd want to use an unused field for the SectorCount
// and initialize it to 16. This would let us save a few bytes by avoiding
// code to explicitly initialize this value before we read the 16 boot sectors.
// However setup and other code tends to preserve the entire bpb area when
// it updates boot code, so we avoid a dependency here and initialize
// the value explicitly to 16 in the first part of the boot code.
//
// ReservedSectors:    data2.ua    0    // Number of reserved sectors
// Fats:               data1       0    // Number of fats 
// DirectoryEntries:   data2.ua    0    // Number of directory entries 
// Sectors:            data2.ua    0    // No. of sectors-no. of hidden sectors

SectorCount:        data2.ua    0    // number of sectors to read
SectorBase:         data4.ua    0    // start sector for read request
HaveXInt13:         data1       0    // extended int13 available flag

Media:              data1       0    // Media byte
FatSectors:         data2.ua    0    // Number of fat sectors
SectorsPerTrack:    data2.ua    0    // Sectors per track
Heads:              data2.ua    0    // Number of surfaces
HiddenSectors:      data4.ua    0    // Number of hidden sectors

//
// The field below is traditionally the large sector count and is
// always 0 on NTFS. We use it here for a value the boot code calculates,
// namely the number of sectors visible on the drive via conventional int13.
//
// Int13Sectors:       data2    0
//

SectorsLong:        data4.ua    0           // Number of sectors iff Sectors = 0
//
// TBD: Need additition fields for 5.0 stuff.
//

DriveNumber:        data1    0x80        // int13 unit number
ReservedForBootCode:data1    0
#ifdef BSDT
Unused:             data1    0,0,0,0,0   // Alignment filler
#else
Unused:             data1    0,0         // Alignment filler
#endif

//
// The following is the rest of the NTFS Sector Zero information.
// The offsets of most of these fields cannot be changed without changing
// all code that validates, formats, recognizes, etc, NTFS volumes.
// In other words, don't change it.
//
SectorsOnVolume:    data8   0
MftStartLcn:        data8   0
Mft2StartLcn:       data8   0
ClustersPerFrs:     data1   0
Unused1:            data1   0,0,0
DefClustersPerBuf:  data1   0
Unused2:            data1   0,0,0
SerialNumber:       data8   0
CheckSum:           data4   0

//
// TBD:  What should be done for IA64?
//
// Make sure size of fields matches what fs_rec.sys thinks is should be
//
//        .errnz          ($-_ntfsboot) NE (54h)
//

//
// TBD.  Dummy BootErr$he function.  Need to fill in at a later time.
//
BootErr$he:

//
// NTFS data
//

//   Name we look for.  ntldr_length is the number of characters,
//   ntldr_name is the name itself.  Note that it is not NULL
//   terminated, and doesn't need to be.
//
ntldr_name_length:  data2  5
ntldr_name:         data2  'N', 'T', 'L', 'D', 'R'

//   Predefined name for index-related attributes associated with an
//   index over $FILE_NAME
//
index_name_length:  data2 4
index_name:         data2 '$', 'I', '3', '0'

//   Global variables.  These offsets are all relative to NewSeg.
//
AttrList:           data4 0x0e000 // Offset of buffer to hold attribute list
MftFrs:             data4 0x3000  // Offset of first MFT FRS
SegmentsInMft:      data4 0  // number of FRS's with MFT Data attribute records
RootIndexFrs:       data4 0  // Offset of Root Index FRS
AllocationIndexFrs: data4 0  // Offset of Allocation Index FRS        ; KPeery
BitmapIndexFrs:     data4 0  // Offset of Bitmap Index FRS            ; KPeery
IndexRoot:          data4 0  // Offset of Root Index $INDEX_ROOT attribute
IndexAllocation:    data4 0  // Offset of Root Index $INDEX_ALLOCATION attribute
IndexBitmap:        data4 0  // Offset of Root Index $BITMAP attribute
NtldrFrs:           data4 0  // Offset of NTLDR FRS
NtldrData:          data4 0  // Offset of NTLDR $DATA attribute
IndexBlockBuffer:   data4 0  // Offset of current index buffer
IndexBitmapBuffer:  data4 0  // Offset of index bitmap buffer
NextBuffer:         data4 0  // Offset of next free byte in buffer space

BytesPerCluster:    data4 0  // Bytes per cluster
BytesPerFrs:        data4 0  // Bytes per File Record Segment

Result:             data4 0  // Result from Multiply and Divide
Remainder:          data4 0  // Remainder 

//
// For floppyless booting, winnt32.exe creates c:\$win_nt$.~bt\bootsec.dat and
// places an entry in boot.ini for it (the boot selection says something
// like "Windows NT Setup or Upgrade"). When that is selected, the boot loader
// loads 16 sectors worth of data from bootsect.dat into d000 (which is where
// the first sector of this code would have loaded it) and jumps into it at
// a known location of 256h. That was correct in earlier versions of NT
// but is not correct now because the 4 fields below were added to this sector.
//
// Note that 0000 is "add [bx+si],al" which because of the way the boot loader
// is written happens to be a benign add of 0 to something in segment 7c0,
// which doesn't seem to hose anything but is still somewhat random.
//
// We code in a jump here so as this new code proliferates we get this
// cleaned up.
//
//        .errnz  $-_ntfsboot ne 256h
// SectorsPerFrs label dword       ; Sectors per File Record Segment
//                     jmp short mainboot
//                     nop
//                     nop
//         .errnz  $-_ntfsboot ne 25ah
SectorsPerFrs:          data4 0  // Sectors per File Record Segment

BytesPerIndexBlock:     data4 0  // Bytes per index alloc block in root index
ClustersPerIndexBlock:  data4 0  // Clusters per index alloc block in root index
SectorsPerIndexBlock:   data4 0  // Sectors per index block in root index

//***************************************************************************
//
// mainboot - entry point after 16 boot sectors have been read in
//
//
        .align 0x10
        NESTED_ENTRY(mainboot)
        NESTED_SETUP(3,6,8,0)
        PROLOGUE_END

        rpT0        = t22
        rpT1        = t21
        rpT2        = t20
        rpT3        = t19
        rIndexRoot  = loc2
        rIRAttrib   = loc3
        rNtldrIndex = loc4
        rPlabel     = loc5

//
// Setup the stack scratch area
//
        add      sp = -STACK_SCRATCH_AREA, sp

//
// Reinitialize xint13-related variables
//
//      br.call.sptd.many  brp = Int13SecCnt  // determine range of regular int13

//      Set up the FRS buffers.  The MFT buffer is in a fixed
//      location, and the other three come right after it.  The
//      buffer for index allocation blocks comes after that.
//

//
//      Compute the useful constants associated with the volume
//
        movl    rpT0 = BytesPerSector        // Bytes Per Sector
        ld2     out0 = [rpT0]
 
        movl    rpT0 = SectorsPerCluster     // Sectors Per Cluster
        ld1     out1 = [rpT0]

        mov      ap = sp
        br.call.sptk.many brp = Multiply

        movl    rpT0 = BytesPerCluster
        st4     [rpT0] = v0

        movl    rpT0 = ClustersPerFrs        // Clusters Per FRS
        ld1     t0 = [rpT0]
        sxt1    t0 = t0

        cmp.gt  pt0,pt1 = t0, zero           // ClustersPerFrs less than zero?
(pt0)   br.cond.sptk.clr mainboot1

//      If the ClustersPerFrs field is negative, we calculate the number
//      of bytes per FRS by negating the value and using that as a shift count.
//

        sub     t0 = zero, t0
        movl    t1 = 1
        shl     t3 = t1, t0                   // bytes per frs
        br.cond.sptk.clr mainboot2

mainboot1:

//      Otherwise if ClustersPerFrs was positive, we multiply by bytes
//      per cluster.

        movl    rpT0 = BytesPerCluster
        ld4     out1 = [rpT0]
        mov     out0 = t0

        mov     ap = sp
        br.call.sptk.many brp = Multiply

mainboot2:

        movl     rpT0 = BytesPerFrs
        st4      [rpT0] = v0

        movl     rpT0 = BytesPerSector
        ld2      t2 = [rpT0]

        mov      out0 = t3
        mov      out1 = t2
        movl     out2 = Result
        movl     out3 = Remainder

        mov      ap = sp
        br.call.sptk.many brp = Divide

        movl     rpT0 = Result
        ld4      t0 = [rpT0]

        movl     rpT0 = SectorsPerFrs
        st4      [rpT0] = t0

//      Set up the MFT FRS's---this will read all the $DATA attribute
//      records for the MFT.
//

        mov      ap = sp
        br.call.sptk.many  brp = SetupMft

//      Set up the remaining FRS buffers.  The RootIndex FRS comes
//      directly after the last MFT FRS, followed by the NTLdr FRS
//      and the Index Block buffer.
//
        movl    rpT0 = NextBuffer
        ld4     t0 = [rpT0]

        movl    rpT0 = RootIndexFrs
        st4     [rpT0] = t0

        movl    rpT0 = BytesPerFrs
        ld4     t1 = [rpT0]

        add     t0 = t0, t1                 // AllocationFrs may be different
        movl    rpT0 = AllocationIndexFrs   // from RootIndexFrs - KPeery
        st4     [rpT0] = t0 

        add     t0 = t0, t1                 // BitmapFrs may be different
        movl    rpT0 = BitmapIndexFrs       // from RootIndexFrs - KPeery
        st4     [rpT0] = t0

        add     t0 = t0, t1
        movl    rpT0 = NtldrFrs
        st4     [rpT0] = t0

        add     t0 = t0, t1
        movl    rpT0 = IndexBlockBuffer
        st4     [rpT0] = t0

//
//      Read the root index, allocation index and bitmap FRS's and locate
//      the interesting attributes.
//

        movl    out0 = $INDEX_ROOT
        movl    rpT0 = RootIndexFrs
        ld4     out1 = [rpT0]

        mov     ap = sp
        br.call.sptk.many brp = LoadIndexFrs

        cmp.eq  pt0, pt1 = v0, zero
(pt0)   br.cond.sptk.clr BootErr$he

        mov     rIndexRoot = v0
        movl    rpT0 = IndexRoot          // offset in Frs buffer
        st4     [rpT0] = rIndexRoot

        movl    out0 = $INDEX_ALLOCATION  // Attribute type code
        movl    rpT0 = AllocationIndexFrs // FRS to search
        ld4     out1 = [rpT0]

        br.call.sptk.many brp = LoadIndexFrs
        movl    rpT0 = IndexAllocation
        st4     [rpT0] = v0

        movl    out0 = $BITMAP            // Attribute type code
        movl    rpT0 = BitmapIndexFrs     // FRS to search
        ld4     out1 = [rpT0]

        br.call.sptk.many brp = LoadIndexFrs
        movl    rpT0 = IndexBitmap
        st4     [rpT0] = v0

//      Consistency check: the index root must exist, and it
//      must be resident.
//
        cmp.eq  pt0, pt1 = rIndexRoot, zero
(pt0)   br.cond.sptk.clr BootErr$he

        add     rpT0 = ATTR_FormCode, rIndexRoot
        ld1     t0 = [rpT0]

        cmp.eq  pt0, pt1 = RESIDENT_FORM, t0
(pt1)   br.cond.sptk.clr BootErr$he

//      Determine the size of the index allocation buffer based
//      on information in the $INDEX_ROOT attribute.  The index
//      bitmap buffer comes immediately after the index block buffer.
//
//      rIndexRoot -> $INDEX_ROOT attribute record
//
        add     rpT3 = RES_ValueOffset, rIndexRoot // value of $INDEX_ROOT
        ld2     t0 = [rpT3]
        add     rIRAttrib = rIndexRoot, t0

        add     rpT0 = IR_BlocksPerIndexBuffer, rIRAttrib
        ld1     t0 = [rpT0]
        movl    rpT1 = ClustersPerIndexBlock
        st4     [rpT1] = t0

        add     rpT0 = IR_BytesPerIndexBuffer, rIRAttrib
        ld4     t0 = [rpT0]
        movl    rpT1 = BytesPerIndexBlock
        st4     [rpT1] = t0

        mov     out0 = t0
        movl    rpT0 = BytesPerSector
        ld2     out1 = [rpT0]

        movl    out2 = Result
        movl    out3 = Remainder

        mov     ap = sp
        br.call.sptk.many brp = Divide

        movl    rpT0 = Result
        ld4     t0 = [rpT0]

        movl    rpT1 = SectorsPerIndexBlock
        st4     [rpT1] = t0

        movl    rpT2 = IndexBlockBuffer
        ld4     t0 = [rpT2]

        movl    rpT3 = BytesPerIndexBlock
        ld4     t1 = [rpT3]
        
        add     t2 = t0, t1
        movl    rpT0 = IndexBitmapBuffer
        st4     [rpT0] = t2

//      Next consistency check: if the $INDEX_ALLOCATION attribute
//      exists, the $INDEX_BITMAP attribute must also exist.
//
        movl    rpT0 = IndexAllocation
        ld4     t0 = [rpT0]

        cmp.eq  pt0, pt1 = t0, zero
(pt0)   br.cond.sptk.clr mainboot30

        movl    rpT0 = IndexBitmap
        ld4     t0 = [rpT0]

        cmp.eq  pt0, pt1 = t0, zero         // since IndexAllocation exists, the
(pt0)   br.cond.sptk.clr BootErr$he         // bitmap must exist, too.

//      Since the bitmap exists, we need to read it into the bitmap
//      buffer.  If it's resident, we can just copy the data.
//

        movl    rpT0 = IndexBitmap
        ld4     out0 = [rpT0]               // out0 -> index bitmap attribute

        movl    rpT1 = IndexBitmapBuffer
        ld4     out1 = [rpT1]               // out1 -> index bitmap buffer

        mov     ap = sp
        br.call.sptk.many brp = ReadWholeAttribute

mainboot30:
//
//      OK, we've got the index-related attributes.
//
        movl    out0 = ntldr_name           // out0 -> name
        movl    rpT0 = ntldr_name_length
        ld2     out1 = [rpT0]               // out1 = name length in characters

        mov     ap = sp
        br.call.sptk.many brp = FindFile

        cmp.eq  pt0, pt1 = v0, zero
(pt0)   br.cond.sptk.clr BootErr$fnf

        mov     rNtldrIndex = v0

//      Read the FRS for NTLDR and find its data attribute.
//
//      rNtldrIndex -> Index Entry for NTLDR.
//
        add     rpT0 = IE_FileReference+LowPart, rNtldrIndex
        ld4     out0 = [rpT0]

        movl    rpT1 = NtldrFrs
        ld4     out1 = [rpT1]

        mov     ap = sp
        br.call.sptk.many brp = ReadFrs

        movl    rpT0 = NtldrFrs
        ld4     out0 = [rpT0]            // pointer to FRS

        movl    out1 = $DATA             // requested attribute type
        mov     out2 = zero              // attribute name length in characters
        mov     out3 = zero              // attribute name (NULL if none)

        mov     ap = sp
        br.call.sptk.many brp = LocateAttributeRecord

//      v0 -> $DATA attribute for NTLDR
//
        cmp.eq  pt0, pt1 = v0, zero
(pt1)   br.cond.sptk.clr mainboot$FoundData  // found attribute

//
//      The ntldr $DATA segment is fragmented.  Search the attribute list
//      for the $DATA member.  And load it from there.
//
        movl    out0 = $DATA             // Attribute type code
        movl    rpT0 = NtldrFrs 
        ld4     out1 = [rpT0]            // FRS to search

        mov     ap = sp
        br.call.sptk.many brp = SearchAttrList  // search attribute list for FRN
                                                // of specified ($DATA)

        cmp.eq  pt0, pt1 = v0, zero      // if v0 is zero, attribute not found.
(pt0)   br.cond.sptk.clr BootErr$fnf

//
//      We found the FRN of the $DATA attribute; load that into memory.
//
        movl    rpT0 = NtldrFrs
        ld4     out0 = [rpT0]

        mov     ap = sp
        br.call.sptk.many brp = ReadFrs

//
//      Determine the beginning offset of the $DATA in the FRS
//
        movl    rpT0 = NtldrFrs // pointer to FRS
        ld4     out0 = [rpT0]

        movl    out1 = $DATA    // requested attribute type
        mov     out2 = zero     // attribute name length in characters
        mov     out3 = zero     // attribute name (NULL if none)

        mov     ap = sp
        br.call.sptk.many brp = LocateAttributeRecord

//      v0 -> $DATA attribute for NTLDR
//
        cmp.eq  pt0, pt1 = v0, zero  // if v0 is zero, attribute not found.
(pt0)   br.cond.sptk.clr BootErr$fnf

mainboot$FoundData:

//      Get the attribute record header flags, and make sure none of the
//      `compressed' bits are set

        add     rpT0 = ATTR_Flags, v0
        ld2     t0 = [rpT0]

        movl    t1 = ATTRIBUTE_FLAG_COMPRESSION_MASK
        and     t2 = t0, t1

        cmp.eq  pt0, pt1 = t2, zero
(pt1)   br.cond.sptk.clr BootErr$ntc 

        mov     out0 = v0             // out0 -> $DATA attribute for NTLDR
        movl    out1 = LdrSeg         // out1 = buffer address

        mov     ap = sp
        br.call.sptk.many brp = ReadWholeAttribute

//
// Relocate the NTLDR image from LdrSeg to what is specified by the PE header
// 
        movl    out0 = LdrSeg         // out1 = buffer address
        mov     ap = sp
        br.call.sptk.many brp = RelocateLoaderSections

        mov     rPlabel = v0

//
// Tell simdb to load NTLDR symbols
//
        mov      ap = sp
        br.call.sptk.many brp = LoadNtldrSymbols

//
// We've loaded NTLDR--jump to it.
//
// Before we go to NTLDR, set up the registers the way it wants them:
//
        movl    out0 = DriveNumber
        movl    out1 = BytesPerSector

        mov     psr.l = zero
        movl    t1 = MASK(PSR_BN,1) | MASK(PSR_IT,1) | MASK(PSR_DA,1) | MASK(PSR_RT,1) | MASK(PSR_DT,1) | MASK(PSR_PK,1) | MASK(PSR_I,1)| MASK(PSR_IC,1)
        mov     cr.ipsr = t1

        add     rpT0 = PlEntryPoint, rPlabel
        ld8     t0 = [rpT0]
        mov     cr.iip = t0

        add     rpT1 = PlGlobalPointer, rPlabel
        ld8     gp = [rpT1]
        rfi                              // "return" to NTLDR.
        ;;

        add     sp = STACK_SCRATCH_AREA, sp  // restore the original sp
        NESTED_RETURN
        NESTED_EXIT(mainboot)

//****************************************************************************
//
//   ReadClusters - Reads a run of clusters from the disk.
//
//   ENTRY:  in0 == LCN to read
//           in1 == clusters to read
//           in2 -> Target buffer
//
//   USES:   none (preserves all registers)
//
        NESTED_ENTRY(ReadClusters)
        NESTED_SETUP(3,4,8,0)
        PROLOGUE_END

        rpT0               = t22
        rpT1               = t21
        rLcn               = in0
        rCluster           = in1
        rBuffer            = in2
        rSectorBase        = loc2
        rSectorsPerCluster = loc3

//
// setup stack scratch area
//
        add     sp = -STACK_SCRATCH_AREA, sp

        movl    rpT0 = SectorsPerCluster
        ld1     rSectorsPerCluster = [rpT0]

        mov     out0 = rLcn
        mov     out1 = rSectorsPerCluster

        mov     ap = sp
        br.call.sptk.many brp = Multiply
        mov     rSectorBase= v0

        mov     out0 = rCluster    
        mov     out1 = rSectorsPerCluster

        mov     ap = sp
        br.call.sptk.many brp = Multiply

        mov     out1 = v0                 // Number of sectors to read

        mov     out0 = rSectorBase
        mov     out2 = rBuffer

        mov     ap = sp
        br.call.sptk.many brp = ReadSectors

        add     sp = STACK_SCRATCH_AREA, sp  // restore the original sp

        NESTED_RETURN
        NESTED_EXIT(ReadClusters)

//
//****************************************************************************
//
//   LocateAttributeRecord   --  Find an attribute record in an FRS.
//
//   ENTRY:  in0 -- pointer to FRS
//           in1 -- desired attribute type code
//           in2 -- length of attribute name in characters
//           in3 -- pointer to attribute name
//
//   EXIT:   v0 points at attribute record (0 indicates not found)
//
//   USES:   All
//
        NESTED_ENTRY(LocateAttributeRecord)
        NESTED_SETUP(4,3,8,0)
        PROLOGUE_END

        rpFrs         = in0
        rTypeCode     = in1
        rLength       = in2
        rpAttrName    = in3
        rpCurrentName = loc2
        rpT0          = t22
        rpT1          = t21

//
// Setup stack scratch area
//
        add      sp = -STACK_SCRATCH_AREA, sp

//
// get the first attribute record.
//
        add     rpT0 = FRS_FirstAttributeOffset, rpFrs
        ld2     t0 = [rpT0]
        add     rpFrs = rpFrs, t0

//      rpFrs -> next attribute record to investigate.
//      rTypeCode == desired type
//      rLength == name length
//      rpAttrName -> pointer to name
//
lar10:
        add     rpT0 = ATTR_TypeCode, rpFrs
        ld4     t0 = [rpT0]
        movl    t1 = 0xffffffff

        cmp.eq  pt0, pt1 = t0, t1
(pt0)   br.cond.sptk.clr lar99

        cmp.eq  pt0, pt1 = t0, rTypeCode
(pt1)   br.cond.sptk.clr lar80

//      this record is a potential match.  Compare the names:
//
//      rpFrs -> candidate record
//      rTypeCode == desired type
//      rLength == name length
//      rpAttrName -> pointer to name
//
        cmp.eq  pt0, pt1 = zero, rLength //Did the caller pass in a name length?
(pt1)   br.cond.sptk.clr lar20

//      We want an attribute with no name--the current record is
//      a match if and only if it has no name.
//
        add     rpT0 = ATTR_NameLength, rpFrs
        ld1     t0 = [rpT0]
        cmp.eq  pt0, pt1 = zero, t0
(pt1)   br.cond.sptk.clr lar80         // Not a match.

//      It's a match, and rpFrs is set up correctly, so return.
//
        mov     v0 = rpFrs
        add      sp = STACK_SCRATCH_AREA, sp  // retore the original sp
        NESTED_RETURN

//      We want a named attribute.
//
//      rpFrs -> candidate record
//      rTypeCode == desired type
//      rLength == name length
//      rpAttrName -> pointer to name
//
lar20:
        add     rpT0 = ATTR_NameLength, rpFrs
        ld1     t0 = [rpT0]

        cmp.eq  pt0, pt1 = rLength, t0
(pt1)   br.cond.sptk.clr lar80         // Not a match.

//      Convert name in current record to uppercase.
//
        add     rpT0 = ATTR_NameOffset, rpFrs
        ld2     t0 = [rpT0]

        add     rpCurrentName = rpFrs, t0
        mov     out0 = rpCurrentName
        add     out1 = ATTR_NameLength, rpFrs

        mov      ap = sp
        br.call.sptk.clr brp = UpcaseName

//      rpFrs -> candidate record
//      rTypeCode == desired type
//      rLength == name length
//      rpAttrName -> pointer to name
//      in4 -> Name in current record (upcased)
//

        mov     t2 = rLength
        mov     rpT0 = rpCurrentName
        mov     rpT1 = rpAttrName
lar79:
        ld2     t0 = [rpT0], 2
        ld2     t1 = [rpT1], 2

        cmp.eq  pt0, pt1 = t0, t1
(pt1)   br.cond.sptk.clr lar80

        add     t2 = -1, t2
        cmp.gt  pt0, pt1 = t2, zero
(pt0)   br.cond.sptk.clr lar79
        
//      t1 points at a matching record.
//
        mov     v0 = rpFrs
        add     sp = STACK_SCRATCH_AREA, sp    // restore sp before returning
        NESTED_RETURN

//
//  This record doesn't match; go on to the next.
//
//      rpFrs -> rejected candidate attribute record
//      rTypeCode == desired type
//      rLength == Name length
//      rpAttrName -> desired name
//
lar80:  add     rpT0 = ATTR_RecordLength, rpFrs
        ld1     t0 = [rpT0]
        cmp.eq  pt0, pt1 = zero, t0     // if the record length is zero
(pt0)   br.cond.sptk.clr lar99           // the FRS is corrupt.
        
        add     rpFrs = rpFrs, t0
        br.cond.sptk.clr lar10

//      Didn't find it.
//
lar99:  mov     v0 = zero

        add     sp = STACK_SCRATCH_AREA, sp    // restore sp before returning
        NESTED_RETURN
        NESTED_EXIT(LocateAttributeRecord)

//****************************************************************************
//
//  LocateIndexEntry   --  Find an index entry in a file name index
//
//  ENTRY:  in0 -> pointer to index header
//          in1 -> file name to find
//          in2 == length of file name in characters
//
//  EXIT:   v0 points at index entry.  NULL to indicate failure.
//
//  USES:   All
//
        NESTED_ENTRY(LocateIndexEntry)
        NESTED_SETUP(3,4,8,0)
        PROLOGUE_END

        rpT0         = t22
        rHeader      = in0
        rpName       = in1
        rLength      = in2
        rEntry       = loc2
        rAttr        = loc3

//
//      Setup the stack scratch area
//
        add     sp = -STACK_SCRATCH_AREA, sp

//      Convert the input name to upper-case
//

        mov     out0 = rpName
        mov     out1 = rLength

        mov     ap = sp
        br.call.sptk.many brp = UpcaseName

#ifdef DEBUG
        mov     out0 = rpName
        mov     ap = sp
        br.call.sptk.many brp = PrintName

        mov     ap = sp
        br.call.sptk.many brp = Debug2
#endif DEBUG

        add     rpT0 = IH_FirstIndexEntry, rHeader
        ld4     t0 = [rpT0]
        add     rEntry = rHeader, t0

//      rEntry  -> current entry
//      rpName  -> file name to find
//      rLength == length of file name in characters
//
lie10:  add     rpT0 = IE_Flags, rEntry
        ld2     t0 = [rpT0]

        and     t1 = INDEX_ENTRY_END, t0    // Is it the end entry?
        cmp.eq  pt0, pt1 = t1, zero
(pt1)   br.cond.sptk.clr lie99              // quit if it is

        add     rAttr = IE_Reserved+0x2, rEntry   // FILE_NAME attribute value
                                                  // was IE_Value   

#ifdef DEBUG
//      DEBUG CODE -- list file names as they are examined

        mov     ap = sp
        br.call.sptk.many brp = Debug3

        mov     rpT0 = FN_FileNameLength, rAttr
        ld1     out1 = [rpT0]

        add     out0 = FN_FileName, rAttr
        mov     ap = sp
        br.call.sptk.many brp = PrintName

#endif DEBUG

//      rEntry  -> current entry
//      rpName  -> file name to find
//      rLength == length of file name in characters
//      rAttr   -> FILE_NAME attribute

        add     rpT0 = FN_FileNameLength, rAttr
        ld1     t0 = [rpT0]

        cmp.eq  pt0, pt1 = t0, rLength      // Is name the right length?
(pt1)   br.cond.sptk.clr lie80

        add     out0 = FN_FileName, rAttr   // Get name from FILE_NAME structure
        mov     out1 = rLength

        mov     ap = sp
        br.call.sptk.many brp = UpcaseName

        add     out0 = FN_FileName, rAttr
        mov     out1 = rpName               // out0 alread setup by last call
        mov     out2 = rLength
        br.call.sptk.many brp = strncmp

        cmp.eq  pt0, pt1 = v0, zero
(pt1)   br.cond.sptk.clr lie80

//      the current entry matches the search name, and eax points at it.
//
        mov     v0 = rEntry

        add     sp = STACK_SCRATCH_AREA, sp
        NESTED_RETURN

//      The current entry is not a match--get the next one.
//          rEntry -> current entry
//          rpName -> file name to find
//          rLength == length of file name in characters
//
lie80:  add     rpT0 = IE_Length, rEntry
        ld2     t0 = [rpT0]

        cmp.eq  pt0, pt1 = t0, zero     // If the entry length is zero
(pt0)   br.cond.sptk.clr lie99          // then the index block is corrupt.

        add     rEntry = rEntry, t0     // Get the next entry.
        br.cond.sptk.clr lie10

//  Name not found in this block.  Set v0 to zero and return
//
lie99:  mov     v0 = zero

        add     sp = STACK_SCRATCH_AREA, sp
        NESTED_RETURN
        NESTED_EXIT(LocateIndexEntry)

//****************************************************************************
//
//  ReadWholeAttribute - Read an entire attribute value
//
//  ENTRY:  in0 -> attribute
//          in1 -> target buffer
//
//  USES:   ALL
//
        NESTED_ENTRY(ReadWholeAttribute)
        NESTED_SETUP(2,4,8,0)

        rAttribute = in0
        rBuffer    = in1
        rpT0       = t22

// setup sp and ap for all function calls
        add     sp = -STACK_SCRATCH_AREA, sp

        add     rpT0 = ATTR_FormCode, in0
        ld1     t0 = [rpT0]

        cmp.eq   pt0, pt1 =  RESIDENT_FORM, t0
(pt1)   br.cond.sptk.clr rwa10

//      The attribute is resident.
//      rAttribute -> attribute
//      rBuffer    -> target buffer
//

        add     rpT0 = RES_ValueOffset, rAttribute
        ld2     t0 = [rpT0]
        add     out0 = rAttribute, t0

        mov     out1 = rBuffer
        add     rpT0 = RES_ValueLength, rAttribute
        ld4     out2 = [rpT0]

        mov      ap = sp
        br.call.sptk.many brp = memcpy

        add     sp = STACK_SCRATCH_AREA, sp // restore the original sp

        NESTED_RETURN                       // That's all!

rwa10:
//
//      The attribute type is non-resident.  Just call
//      ReadNonresidentAttribute starting at VCN 0 and
//      asking for the whole thing.
//
//      rAttribute -> attribute
//      rBuffer    -> target buffer
//
        mov     out0 = zero                 // 0 (first VCN to read)
        mov     out1 = rAttribute           // Attribute

        add     rpT0 = NONRES_HighestVcn+LowPart, rAttribute // # of clusters
        ld4     out2 = [rpT0]
        add     out2 = 1, out2

        mov     out3 = rBuffer              // Target Buffer
        mov     ap = sp
        br.call.sptk.many brp = ReadNonresidentAttribute

        add     sp = STACK_SCRATCH_AREA, sp // restore the original sp

        NESTED_RETURN
        NESTED_EXIT(ReadWholeAttribute)

//****************************************************************************
//
//  ReadNonresidentAttribute - Read clusters from a nonresident attribute
//
//  ENTRY:  in0 == First VCN to read
//          in1 -> Attribute
//          in2 == Number of clusters to read
//          in3 == Target of read
//
//  EXIT:   None.
//
//  USES:   None (preserves all registers with SAVE_ALL/RESTORE_ALL)
//
        NESTED_ENTRY(ReadNonresidentAttribute)
        NESTED_SETUP(4,4,8,0)
        PROLOGUE_END

        rVcn       = in0
        rAttribute = in1
        rCluster   = in2
        rBuffer    = in3
        rRun       = loc2
        rTmp       = loc3

//
// setup stack scratch area
//
        add     sp = -STACK_SCRATCH_AREA, sp

        add     rpT0 = ATTR_FormCode, rAttribute
        ld1     t0 = [rpT0]

        cmp.eq  pt0, pt1 = NONRESIDENT_FORM, t0
(pt0)   br.cond.sptk.clr ReadNR10

//      This attribute is not resident--the disk is corrupt.

        br.cond.sptk.clr BootErr$he


ReadNR10:
//      rVcn       == Next VCN to read
//      rAttribute -> Attribute
//      rCluster   -> Remaining clusters to read
//      rBuffer    -> Target of read
//

        cmp.eq  pt0, pt1 = rCluster,zero
(pt1)   br.cond.sptk.clr ReadNR20

//      Nothing left to read--return success.
//
        add     sp = STACK_SCRATCH_AREA, sp // restore the original sp
        NESTED_RETURN

ReadNR20:
        mov     out0 = rVcn
        mov     out1 = rAttribute

        mov     ap = sp
        br.call.sptk.many brp = ComputeLcn 

        mov     rLcn = t0                   // rLcn = LCN
        mov     rRun = t1                   // rRun = remaining run length

//      rLcn     == LCN to read
//      rCluster == remaining clusters to read
//      rRun     == remaining clusters in current run
//      rBuffer  == Target of read
//
        cmp.ge  pt0, pt1 = rCluster, rRun
(pt0)   br.cond.sptk.clr ReadNR30

//      Run length is greater than remaining request// only read
//      remaining request.
//
        mov     rRun = rCluster    // rRun = Remaining request

ReadNR30:
//      rLcn       == LCN to read
//      rCluster   == remaining clusters to read
//      rRun       == clusters to read in current run
//      rBuffer    == Target of read
//
        mov     out0 = rLcn
        mov     out1 = rCluster
        mov     out2 = rBuffer

        mov     ap = sp
        br.call.sptk.many brp = ReadClusters

        sub     rCluster = rCluster, rRun // Decrement clusters remaining

        mov     out0 = rRun
        movl    rpT0 = SectorsPerCluster
        ld1     out1 = [rpT0]

        mov     ap = sp
        br.call.sptk.many brp = Multiply

        mov     out0 = v0
        movl    rpT0 = BytesPerSector
        ld4     out1 = [rpT0]

        mov     ap = sp
        br.call.sptk.many brp = Multiply

        add     rBuffer = rBuffer, v0     // Update target of read
        add     rVcn = rVcn, rRun         // Update VCN to read

        br.cond.sptk.clr ReadNR10

        add     sp = STACK_SCRATCH_AREA, sp // restore the original sp
        NESTED_RETURN
        NESTED_EXIT(ReadNonresidentAttribute)

//****************************************************************************
//
//   ReadIndexBlockSectors - Read sectors from an index allocation attribute
//
//   ENTRY:  in0 == First VBN to read
//           in1 -> Attribute
//           in2 == Number of sectors to read
//           in3 == Target of read
//
//   EXIT:   None.
//
//   USES:   None (preserves all registers with SAVE_ALL/RESTORE_ALL)
//
        NESTED_ENTRY(ReadIndexBlockSectors)
        NESTED_SETUP(4,6,8,0)
        PROLOGUE_END

        rpT0               = t22
        rVbn               = in0
        rAttr              = in1
        rSectors           = in2
        rBuffer            = in3
        rSectorsPerCluster = loc2
        rRemainClusters    = loc3
        rRunSectors        = loc4
        rLbn               = loc5

//
// Setup stack scratch area
//
        add     sp = -STACK_SCRATCH_AREA, sp

        add     rpT0 = ATTR_FormCode, rAttr   
        ld1     t0 = [rpT0]

        cmp.eq  pt0, pt1 = NONRESIDENT_FORM, t0
(pt0)   br.cond.sptk.clr ReadIBS_10

//      This attribute is resident--the disk is corrupt.

        br.cond.sptk.clr BootErr$he

ReadIBS_10:
//      rVbn     == Next VBN to read
//      rAttr    -> Attribute
//      rSectors -> Remaining sectors to read
//      rBuffer  -> Target of read
//

        cmp.eq  pt0, pt1 = rSectors, zero
(pt1)   br.cond.sptk.clr ReadIBS_20

//      Nothing left to read--return success.
//
        add     sp = STACK_SCRATCH_AREA, sp
        NESTED_RETURN

ReadIBS_20:

        // Convert rVbn from a VBN back to a VCN by dividing by SectorsPerCluster.
        // The remainder of this division is the sector offset in the cluster we
        // want.  Then use the mapping information to get the LCN for this VCN,
        // then multiply to get back to LBN.
        //

        mov     out0 = rVbn
        movl    rpT0 = SectorsPerCluster
        ld1     rSectorsPerCluster = [rpT0]

        mov     out1 = rSectorsPerCluster
        movl    out2 = Result
        movl    out3 = Remainder

        mov     ap = sp
        br.call.sptk.many brp = Divide

        movl    rpT0 = Result
        ld4     out0 = [rpT0]
        mov     out1 = rAttr
        
        mov     ap = sp
        br.call.sptk.many brp = ComputeLcn  // t0 = LCN to read,
                                            // t1 = remaining run length

        mov     rRemainClusters = t1
        mov     out0 = t0
        mov     out1 = rSectorsPerCluster
        
        mov     ap = sp
        br.call.sptk.many brp = Multiply     // v0 = LBN of cluster

        movl    rpT0 = Remainder
        ld4     t0 = [rpT0]                  // t0 = remainder
        add     rLbn = v0, t0                // rLbn = LBN we want

        mov     out0 = rRemainClusters
        mov     out1 = rSectorsPerCluster

        mov     ap = sp
        br.call.sptk.many brp = Multiply // v0 = remaining run length in sectors
        mov     rRunSectors = v0         // remaining run length

//      rLbn        == LBN to read
//      rSectors    == remaining sectors to read
//      rRunSectors == remaining sectors in current run
//      rBuffer     == Target of read
//
        cmp.ge  pt0, pt1 = rSectors, rRunSectors
(pt0)   br.cond.sptk.clr ReadIBS_30

//      Run length is greater than remaining request; only read
//      remaining request.
//
        mov     rRunSectors = rSectors    // rRunSectors = Remaining request

ReadIBS_30:
//      rLbn == LBN to read
//      rSectors == remaining sectors to read
//      rRunSectors == sectors to read in current run
//      rBuffer == Target of read
//

        mov     out0 = rLbn
        mov     out1 = rRunSectors
        mov     out2 = rBuffer

        mov     ap = sp
        br.call.sptk.many brp = ReadSectors

//
// Decrement sectors remaining in request
//
        sub     rSectors = rSectors, rRunSectors 

        mov     out0 = rRunSectors        // eax = sectors read
        movl    rpT0 = BytesPerSector
        ld2     out1 = [rpT0]

        br.call.sptk.many brp = Multiply  // v0 = bytes read (wipes out edx!)

        add     rBuffer = rBuffer, v0     // Update target of read

        add     rVbn = rVbn, rRunSectors  // update VBN to read

        br.cond.sptk.clr ReadIBS_10

        add     sp = STACK_SCRATCH_AREA, sp
        NESTED_RETURN
        NESTED_EXIT(ReadIndexBlockSectors)

//****************************************************************************
//
//   MultiSectorFixup - fixup a structure read off the disk
//                      to reflect Update Sequence Array.
//
//   ENTRY:  in0 = Target buffer
//
//   USES:   none (preserves all registers with SAVE_ALL/RESTORE_ALL)
//
//   Note: in0 must point at a structure which is protected
//         by an update sequence array, and which begins with
//         a multi-sector-header structure.
//
        NESTED_ENTRY(MultiSectorFixup)
        NESTED_SETUP(3,3,8,0)
        PROLOGUE_END

#define MshUpdateSeqenceArrayOffset 4
#define SEQUENCE_NUMBER_STRIDE      512

        add     rpT0 = MshUpdateSeqenceArrayOffset, in0
        ld2     t0 = [rpT0], 2       // t0 = update array offset
        ld2     t1 = [rpT0]          // t1 = update array size

        cmp.eq  pt0, pt1 = zero, t1  // if the size of the update sequence array
(pt0)   br.cond.sptk.clr BootErr$he  // is zero, this structure is corrupt.

        add     rpT0 = t0, in0       // rpT0 -> update sequence array count word
        add     rpT0 = 2, rpT0       // rpT0 -> 1st entry of update array

        add     rpT1=SEQUENCE_NUMBER_STRIDE-2,in0 //t2->last word of first chunk
        movl    t2 = 1
        sub     t1 = t1, t2          // decrement to reflect count word

        cmp.eq  pt0, pt1 = zero, t2 
(pt0)   br.cond.sptk.clr MSF30

MSF10:

//   t1 = number of entries remaining in update sequence array
//   rpT0 -> next entry in update sequence array
//   rpT1 -> next target word for update sequence array


        ld2     t0 = [rpT0]          // copy next update sequence array entry
        st2     [rpT0] = t0          // to next target word

        add     rpT0 = 2, rpT0       // go on to next entry
        add     rpT1 = SEQUENCE_NUMBER_STRIDE, rpT1 // go on to next target

        sub     t1 = t1, t2

        cmp.lt  pt0, pt1 = zero, t1 
(pt0)   br.cond.sptk.clr MSF10

MSF30:

        NESTED_RETURN
        NESTED_EXIT(MultiSectorFixup)

//****************************************************************************
//
//   SetupMft - Reads MFT File Record Segments into memory.
//
//   ENTRY:  none.
//
//   EXIT:   NextBuffer is set to the free byte after the last MFT FRS
//           SegmentsInMft is initialized
//
//
        NESTED_ENTRY(SetupMft)
        NESTED_SETUP(3,6,8,0)
        PROLOGUE_END

        rpT0         = t22
        rpT1         = t21
        rpT2         = t20
        rpT3         = t19
        rAttrList    = loc2
        rAttrLength  = loc3
        rNextBuffer  = loc4
        rBytesPerFrs = loc5

//
// Setup stack scratch area
//
        add     sp = -STACK_SCRATCH_AREA, sp

//
//      Update MftFrs with NewSeg base offset
//
        movl    rpT0 = MftFrs
        ld4     t0 = [rpT0]

        movl    t1 = NewSeg
        add     t2 = t0, t1

        st4     [rpT0] = t2


//      Initialize SegmentsInMft and NextBuffer as if the MFT
//      had only one FRS.
//
        movl    t0 = 1
        movl    rpT0 = SegmentsInMft
        st4     [rpT0] = t0

        movl    rpT1 = MftFrs
        ld4     t1 = [rpT1]

        movl    rpT2 = BytesPerFrs
        ld4     rBytesPerFrs = [rpT2]

        add     rNextBuffer = t1, rBytesPerFrs
        movl    rpT3 = NextBuffer
        st4     [rpT3] = t3

//      Read FRS 0 into the first MFT FRS buffer, being sure
//      to resolve the Update Sequence Array.
//

        movl    rpT0 = MftStartLcn
        ld8     out0 = [rpT0]

        movl    rpT1 = SectorsPerCluster
        ld8     out1 = [rpT1]

        mov     ap = sp
        br.call.sptk.many brp = Multiply

        movl    rpT0 = SectorBase          // SectorBase = mft starting sector
        st4     [rpT0] = v0

        movl    rpT0 = SectorsPerFrs
        ld8     t0 = [rpT0]

        movl    rpT0 = SectorCount        // SectorCount = SectorsPerFrs
        st2     [rpT0] = t0

        movl    rpT0 = MftFrs
        ld4     t0 = [rpT0]

        movl    rpT0 = SectorBase
        ld4     out0 = [rpT0]

        // Sector count is zero for some reason.  Manually set to 1
        //
        movl    rpT1 = SectorCount
        ld4     out1 = [rpT1]

        movl    rpT0 = MftFrs
        ld4     out2 = [rpT0]

        mov     ap = sp
        br.call.sptk.many brp = ReadSectors

        movl    rpT0 = MftFrs
        ld4     out0 = [rpT0]

#ifdef MFT_FRS
        movl    t1 = NewSeg
        add     out0 = t0, t1
#endif

        mov     ap = sp
        br.call.sptk.many brp = MultiSectorFixup

//      Determine whether the MFT has an Attribute List attribute

        movl    rpT0 = MftFrs
        ld4     out0 = [rpT0]

#ifdef MFT_FRS
        movl    t1 = NewSeg
        add     out0 = t0, t1
#endif

        movl    out1 = $ATTRIBUTE_LIST
        mov     out2 = zero
        mov     out3 = zero

        mov     ap = sp
        br.call.sptk.many brp = LocateAttributeRecord

        cmp.eq  pt0, pt1 = zero, v0    // If there's no Attribute list,
(pt0)   br.cond.sptk.clr SetupMft99    // we're done!

//      Read the attribute list.
//      v0 -> attribute list attribute
//
        mov     out0 = v0                  // out0 -> attribute list attribute
        mov     out1 = rAttrList           // rAttrList -> attribute list buffer
        mov     ap = sp
        br.call.sptk.many brp = ReadWholeAttribute

//      Now, traverse the attribute list looking for the first
//      entry for the $DATA type.  We know it must have at least
//      one.
//
//      rAttrList -> first attribute list entry
//
SetupMft10:
        add     rpT0 = ATTRLIST_AttributeTypeCode, rAttrList
        ld4     t0 = [rpT0]
        movl    t1 = $DATA

        cmp.eq  pt0, pt1 = t0, t1
(pt0)   br.cond.sptk.clr SetupMft20

        add     rpT0 = ATTRLIST_RecordLength, rAttrList
        ld4     t0 = [rpT0]

        add     rAttrList = rAttrList, t0
        br.cond.sptk.clr SetupMft10

SetupMft20:
//      Scan forward through the attribute list entries for the
//      $DATA attribute, reading each referenced FRS.  Note that
//      there will be at least one non-$DATA entry after the entries
//      for the $DATA attribute, since there's a $BITMAP.
//
//      rAttrList     -> Next attribute list entry
//      rNextBuffer   -> Target for next read
//      SegmentsInMft == number of MFT segments read so far
//
        add     rpT0 = ATTRLIST_AttributeTypeCode, rAttrList
        ld4     t0 = [rpT0]
        movl    t1 = $DATA

        cmp.eq  pt0, pt1 = t0, t1
(pt1)   br.cond.sptk.clr SetupMft99

//      Read the FRS referred to by this attribute list entry into
//      the next buffer, and increment rNextBuffer and SegmentsInMft.
//
        add     rpT0 = ATTRLIST_SegmentReference, rAttrList
        add     rpT0 = REF_SegmentNumberLowPart, rAttrList
        ld4     out0 = [rpT0]

        mov     out1 = rNextBuffer
        mov     ap = sp
        br.call.sptk.many brp = ReadFrs

//      Increment rNextBuffer and SegmentsInMft

        add     rNextBuffer = rNextBuffer, rBytesPerFrs

        movl    rpT0 = SegmentsInMft
        ld4     t0 = [rpT0]

        add     t0 = 1, t0
        st4     [rpT0] = t0

//      Go on to the next attribute list entry

        add     rAttrList = rAttrList, rAttrLength
        br.cond.sptk.clr SetupMft20

SetupMft99:
        movl    rpT0 = NextBuffer
        st4     [rpT0] = rNextBuffer

        add     sp = STACK_SCRATCH_AREA, sp      // readjust sp before exiting

        NESTED_RETURN
        NESTED_EXIT(SetupMft)

//****************************************************************************
//
//   ComputeMftLcn   --  Computes the LCN for a cluster of the MFT
//
//
//   ENTRY:  in0 == VCN
//
//   EXIT:   v0  == LCN
//
//   USES:   ALL
//
        NESTED_ENTRY(ComputeMftLcn)
        NESTED_SETUP(3,5,8,0)
        PROLOGUE_END

        rpT0      = t22
        rFrsCount = loc2
        rNextFrs  = loc3
        rVcn      = loc4

//
// Setup sp and ap for all function calls
//
        add     sp = -STACK_SCRATCH_AREA, sp
        mov     ap = sp

        mov     rVcn = in0               // rVcn = VCN
        movl    rpT0 = SegmentsInMft     // rFrsCount = # of FRS's to search
        ld4     rFrsCount = [rpT0]

        movl    rpT0 = MftFrs            // rNextFrs -> first FRS to search
        ld4     rNextFrs = [rpT0]  

MftLcn10:
//      rNextFrs  -> Next FRS to search
//      rFrsCount == number of remaining FRS's to search
//      rVcn      == VCN
//
        mov     out0 = rNextFrs
        movl    out1 = $DATA
        mov     out2 = zero
        mov     out3 = zero

        mov     ap = sp
        br.call.sptk.many brp = LocateAttributeRecord

        cmp.eq  pt0, pt1 = zero, v0
(pt0)   br.cond.sptk.clr BootErr$he       // No $DATA attribute in this FRS!

        mov     out0 = rVcn               // out0 = VCN
        mov     out1 = v0                 // out1 -> attribute

        mov     ap = sp
        br.call.sptk.many brp = ComputeLcn

        cmp.eq  pt0, pt1 = zero, t0       // t0 is return value of ComputeLcn
(pt0)   br.cond.sptk.clr MftLcn20
        mov     v0 = t0

        add     sp = STACK_SCRATCH_AREA, sp  // readjust sp before exiting

        NESTED_RETURN

MftLcn20:
//
//      Didn't find the VCN in this FRS; try the next one.
//
        movl    rpT0 = BytesPerFrs        // rNextFrs -> next FRS
        ld4     t0 = [rpT0]
        add     rNextFrs = rNextFrs, t0

	br.cond.sptk.clr MftLcn10         // decrement ecx and try next FRS

//      This VCN was not found.
//
        mov     v0 = zero

        add     sp = STACK_SCRATCH_AREA, sp  // readjust sp before exiting

        NESTED_RETURN
        NESTED_EXIT(ComputeMftLcn)

//****************************************************************************
//
//  ReadMftSectors - Read sectors from the MFT
//
//  ENTRY:  in0 == starting VBN
//          in1 == number of sectors to read
//          in2 == Target buffer
//
//  USES:   none (preserves all registers with SAVE_ALL/RESTORE_ALL)
//
        NESTED_ENTRY(ReadMftSectors)
        NESTED_SETUP(3,4,8,0)
        PROLOGUE_END

        rpT0               = t22
        rVbn               = in0
        rSectorCount       = in1
        rBuffer            = in2
        rSectorsPerCluster = loc2
        rBytesPerCluster   = loc3

// Reserve the stack scratch area
        add     sp = -STACK_SCRATCH_AREA, sp

        movl    rpT0 = BytesPerCluster
        ld4     rBytesPerCluster = [rpT0]

RMS$Again:

// Divide the VBN by SectorsPerCluster to get the VCN

        mov     out0 = in0

        movl    rpT0 = SectorsPerCluster
        ld1     rSectorsPerCluster = [rpT0]
        mov     out1 = rSectorsPerCluster

        movl    out2 = Result
        movl    out3 = Remainder

        mov     ap = sp
        br.call.sptk.many brp = Divide

        movl    rpT0 = Result
        ld4     out0 = [rpT0]

        mov     ap = sp
        br.call.sptk.many brp = ComputeMftLcn

        cmp.eq  pt0, pt1 = zero, v0     // LCN equal to zero?
(pt0)   br.cond.sptk.clr BootErr$he     // zero is not a possible LCN

// Change the LCN back into a LBN and add the remainder back in to get
// the sector we want to read, which goes into SectorBase.
//

        mov     out0 = v0
        mov     out1 = rSectorsPerCluster

        mov     ap = sp
        br.call.sptk.many brp = Multiply         // v0 = cluster first LBN

        movl    rpT0 = Remainder
        ld4     t0 = [rpT0]

        add     t1 = v0, t0                      // t1 = desired LBN
        movl    rpT0 = SectorBase
        st4     [rpT0] = t1

//
// Figure out how many sectors to read this time// we never attempt
// to read more than one cluster at a time.
//

        cmp.le  pt0, pt1 = rSectorCount,rSectorsPerCluster
(pt0)   br.cond.sptk.clr RMS10

//
// Read only a single cluster at a time, to avoid problems with fragmented
// runs in the mft.
//

        movl    rpT0 = SectorCount
        st2     [rpT0] = rSectorsPerCluster    // this time read 1 cluster
        sub     rSectorCount = rSectorCount, rSectorsPerCluster // sect. remain

        add     rVbn = rVbn, rSectorsPerCluster // VBN += sectors this read

        br.cond.sptk.clr RMS20

RMS10:

        add     rVbn = rVbn, rSectorCount     // VBN += sectors this read

        movl    rpT0 = SectorCount
        st2     [rpT0] = rSectorCount
        mov     rSectorCount = zero           // remaining sector count (0)

RMS20:


//   The target buffer was passed in es:edi, but we want it in es:bx.
//   Do the conversion.
//

        movl    rpT0 = SectorBase
        ld4     out0 = [rpT0]

        movl    rpT0 = SectorCount
        ld2     out1 = [rpT0]
        mov     out2 = rBuffer

        mov     ap = sp
        br.call.sptk.many brp = ReadSectors

        add     rBuffer = rBuffer, rBytesPerCluster 
        cmp.gt  pt0, pt1 = rSectorCount, zero    // are we done?
(pt0)   br.cond.sptk.clr RMS$Again               // repeat until desired == 0

        add     sp = STACK_SCRATCH_AREA, sp      // Reclaim the scratch area

        NESTED_RETURN
        NESTED_EXIT(ReadMftSectors)


//****************************************************************************
//
//  ReadFrs - Read an FRS
//
//  ENTRY:  in0 == FRS number
//          in1 == Target buffer
//
//  USES:  none (preserves all registers with SAVE_ALL/RESTORE_ALL)
//
        NESTED_ENTRY(ReadFrs)
        NESTED_SETUP(3,3,8,0)
        PROLOGUE_END

        rpT0           = t22
        rSectorsPerFrs = loc2

//
// Adjust sp with sratch area
//
        add     sp = -STACK_SCRATCH_AREA, sp

        movl    rpT0 = SectorsPerFrs
        ld4     rSectorsPerFrs = [rpT0]

        mov     out0 = in0             // FRS number
        mov     out1 = rSectorsPerFrs  // Sectors per FRS

        mov     ap = sp
        br.call.sptk.many brp = Multiply

        mov     out0 = v0             // out0 = starting VBN
        mov     out1 = rSectorsPerFrs // out1 = number of sectors to read
        mov     out2 = in1            // out2 = target buffer

        mov     ap = sp
        br.call.sptk.many brp = ReadMftSectors

        mov     out0 = in1            // out2 = target buffer
        mov     ap = sp
        br.call.sptk.many brp = MultiSectorFixup

        add     sp = STACK_SCRATCH_AREA, sp     // Readjust sp before exiting

        NESTED_RETURN
        NESTED_EXIT(ReadFrs)

//****************************************************************************
//
//  ReadIndexBlock - read an index block from the root index.
//
//  ENTRY:  in0 == Block number
//
//  USES:  none (preserves all registers with SAVE_ALL/RESTORE_ALL)
//
        NESTED_ENTRY(ReadIndexBlock)
        NESTED_SETUP(3,3,8,0)

        rpT0      = t22
        rpT1      = t21
        rpT2      = t20
        rBlock    = in0
        rBuffer   = loc2
        
//
// Setup stack scratch area
//
        add     sp = -STACK_SCRATCH_AREA, sp

        mov     out0 = rBlock
        movl    rpT0 = SectorsPerIndexBlock
        ld4     out1 = [rpT0] 

        mov     ap = sp
        br.call.sptk.many brp = Multiply

        mov     out0 = v0                     // v0 = first VBN to read

        movl    rpT0 = IndexAllocation
        ld4     out1 = [rpT0]         // out1 -> $INDEX_ALLOCATION attribute

        movl    rpT1 = SectorsPerIndexBlock   // out2 == Sectors to read
        ld4     out2 = [rpT1]

        movl    rpT2 = IndexBlockBuffer       // out3 -> index block buffer
        ld4     rBuffer = [rpT2]
        mov     out3 = rBuffer

        mov     ap = sp
        br.call.sptk.many brp = ReadIndexBlockSectors

        mov     out0 = rBuffer
        mov     ap = sp
        br.call.sptk.many brp = MultiSectorFixup

        add     sp = STACK_SCRATCH_AREA, sp   // Readjust sp before exiting

        NESTED_RETURN
        NESTED_EXIT(ReadIndexBlock)

//****************************************************************************
//
//  IsBlockInUse - Checks the index bitmap to see if an index
//                 allocation block is in use.
//
//  ENTRY:  in0 == block number
//
//  EXIT:   Carry flag clear if block is in use
//          Carry flag set   if block is not in use.
//
        NESTED_ENTRY(IsBlockInUse)
        NESTED_SETUP(3,5,8,0)
        PROLOGUE_END

        rpT0               = t22
        rBlock             = in0
        rTest              = loc2
        rByte              = loc3
        rBit               = loc4

//
// Reserve stack scratch area
//
        add     sp = -STACK_SCRATCH_AREA, sp

        movl    rpT0 = IndexBitmapBuffer
        ld4     rTest = [rpT0]

        mov     t0 = rBlock                // t0 = block number
        shr     rByte = t0, 3              // rByte = byte number
        and     rBit = 7, rBlock           // rBit  = bit number in byte

        add     rTest = rTest, rByte       // rTest = byte to test
        movl    t0 = 1
        shl     t0 = t0, rBit              // t0 = mask

        ld1     t1 = [rTest]
        and     t2 = t1, t0

        cmp.eq  pt0, pt1 = t2, zero
(pt0)   br.cond.sptk.clr IBU10

        mov     v0 = zero    // Block is not in use.
        br.cond.sptk.clr IBU20

IBU10:  movl    v0 = 1       // Block is in use.

IBU20:  add     sp = STACK_SCRATCH_AREA, sp  // restore the original sp

        NESTED_RETURN
        NESTED_EXIT(IsBlockInUse)

//****************************************************************************
//
//  ComputeLcn - Converts a VCN into an LCN
//
//  ENTRY:  in0 -> VCN
//          in1 -> Attribute
//
//  EXIT:   t0 -> LCN  (zero indicates not found)
//          t1 -> Remaining run length
//
//  USES:   ALL.
//
        NESTED_ENTRY(ComputeLcn)
        NESTED_SETUP(3,7,8,0)
        PROLOGUE_END

        rpT0            = t22
        rVcn            = in0               // VCN
        rAttribute      = in1               // Attribute
        rpMappingPair   = loc2
        rDeltaVcn       = loc3
        rCurrentVcn     = loc4
        rCurrentLcn     = loc5
        rNextVcn        = loc6

//
// Setup stack scratch area
//
        add     sp = -STACK_SCRATCH_AREA, sp

        add     rpT0 = ATTR_FormCode, rAttribute
        ld1     t0 = [rpT0]
  
        cmp.eq  pt0, pt1 = NONRESIDENT_FORM, t0
(pt1)   br.cond.sptk.clr clcn99             // This is a resident attribute.

clcn10:

//
//      See if the desired VCN is in range.
//

        add     rpT0 = NONRES_HighestVcn+LowPart, rAttribute 
        ld4     t0 = [rpT0]                // t0 = HighestVcn
        cmp.gt  pt0, pt1 = rVcn, t0
(pt0)   br.cond.sptk.clr clcn99            // VCN is greater than HighestVcn

        add     rpT0 = NONRES_LowestVcn+LowPart, rAttribute 
        ld4     rCurrentVcn = [rpT0]       // rCurrentVcn = LowestVcn
        cmp.lt  pt0, pt1 = rVcn, rCurrentVcn
(pt0)   br.cond.sptk.clr clcn99            // VCN is less than LowestVcn

clcn20:
        add     rpT0 = NONRES_MappingPairOffset, rAttribute
        ld2     t0 = [rpT0]            

        add     rpMappingPair = rAttribute, t0
        ld1     t0 = [rpMappingPair]

        mov     rCurrentLcn = zero         // Initialize Current LCN

clcn30:
        cmp.eq  pt0, pt1 = zero, t0       // if count byte is zero...
(pt0)   br.cond.sptk.clr clcn99           // ... we're done (and didn't find it)

//      Update CurrentLcn
//
        mov     out0 = rpMappingPair

        mov     ap = sp
        br.call.sptk.many brp = LcnFromMappingPair
        add     rCurrentLcn = rCurrentLcn, v0 

        mov     out0 = rpMappingPair
        mov     ap = sp
        br.call.sptk.many brp = VcnFromMappingPair  // out0 = previous out0

        mov     rDeltaVcn = v0

//      rVcn          == VCN to find
//      rpMappingPair -> Current mapping pair count byte
//      rDeltaVcn     == DeltaVcn for current mapping pair
//      rCurrentVcn   == Current VCN
//      rCurrentLcn   == Current LCN
//
        add     rNextVcn = rDeltaVcn, rCurrentVcn  // NextVcn

        cmp.lt  pt0, pt1 = rVcn, rNextVcn    // If target < NextVcn ...
(pt0)   br.cond.sptk.clr clcn80      //   ... we found the right mapping pair.

//      Go on to next mapping pair.
//
        mov     rCurrentVcn = rNextVcn // CurrentVcn = NextVcn

        ld1     t0 = [rpMappingPair]   // t0 = count byte
        mov     t1 = t0                // t1 = count byte
        and     t1 = 0x0f, t1          // t1 = number of vcn bytes
        shr     t0 = t0, 4             // t0 = number of lcn bytes

        add     rpMappingPair = rpMappingPair, t0
        add     rpMappingPair = rpMappingPair, t1
        add     rpMappingPair = 1, rpMappingPair // -> next count byte

        br.cond.sptk.clr clcn30

clcn80:
//      We found the mapping pair we want.
//
//      rVcn == target VCN
//      rMappingPair -> mapping pair count byte
//      rCurrentVcn == Starting VCN of run
//      rNextVcn == Next VCN (ie. start of next run)
//      rCurrentLcn == starting LCN of run
//
        sub     t1 = rNextVcn, rVcn    // t1 = remaining run length
        sub     t0 = rVcn, rCurrentVcn // t0 = offset into run
        add     t0 = t0, rCurrentLcn   // t0 = LCN to return

        add     sp = STACK_SCRATCH_AREA, sp  // restore the original sp
        NESTED_RETURN

//      The target VCN is not in this attribute.

clcn99: mov     v0 = zero               // Not found.

        add     sp = STACK_SCRATCH_AREA, sp  // restore the original sp
        NESTED_RETURN
        NESTED_EXIT(ComputeLcn)

//****************************************************************************
//
//  VcnFromMappingPair
//
//  ENTRY:  in0 -> Mapping Pair count byte
//
//  EXIT:   v0  == DeltaVcn from mapping pair
//
//
        LEAF_ENTRY(VcnFromMappingPair)
        LEAF_SETUP(3,4,8,0)
        PROLOGUE_END

        rpMP  = in0
        rv    = loc2
        rVcn  = loc3

        ld1     rv = [rpMP]               // rv = count byte
        and     rv = 0x0f, rv             // rv = v

        cmp.eq  pt0, pt1 = zero, rv       // if rv is zero, volume is corrupt.
(pt1)   br.cond.sptk.clr VFMP5

        mov     v0 = zero
        br.cond.sptk.clr VFMP99

VFMP5:
        add     rpMP = rpMP, rv          // rpMP -> last byte of compressed vcn

        ld1     rVcn = [rpMP]
        sxt1    rVcn = rVcn

        add     rv  = -1, rv
        add     rpMP = -1, rpMP

//      rpMP -> Next byte to add in
//      rv == Number of bytes remaining
//      rVcn == Accumulated value
//
VFMP10: cmp.eq  pt0, pt1 = zero, rv      // When rv == 0, we're done.
(pt0)   br.cond.sptk.clr VFMP20

        shl     rVcn = rVcn, 8
        ld1     t0 = [rpMP]
        or      rVcn = rVcn, t0

        add     rpMP = -1, rpMP          // Back up through bytes to process.
        add     rv  = -1, rv             // One less byte to process.

        br.cond.sptk.clr VFMP10

VFMP20:
//      rVcn == Accumulated value to return

        movl    t0 = 0xffffffff         // return the lower 32-bits
        and     v0 = rVcn, t0

VFMP99:
        LEAF_RETURN
        LEAF_EXIT(VcnFromMappingPair)


//****************************************************************************
//
//  LcnFromMappingPair
//
//  ENTRY:  in0 -> Mapping Pair count byte
//
//  EXIT:   v0  == DeltaLcn from mapping pair
//
        LEAF_ENTRY(LcnFromMappingPair)
        LEAF_SETUP(3,5,8,0)
        PROLOGUE_END

        rpMP = in0
        rv   = loc2
        rl   = loc3
        rLcn = loc4

        ld1     rv = [rpMP]
        and     rv = 0xf, rv              // rv = v

        ld1     rl = [rpMP]
        shr     rl = rl, 4                // rl = l

        cmp.eq  pt0, pt1 = zero, rl       // if rl is zero, volume is corrupt.
(pt1)   br.cond.sptk.clr LFMP5

        mov     v0 = zero
        br.cond.sptk.clr LFMP99

LFMP5:
//      rpMP -> count byte
//      rl  == l
//      rv  == v
//

        add     rpMP = rpMP, rv          // rpMP -> last byte of compressed vcn
        add     rpMP = rpMP, rl          // rpMP -> last byte of compressed lcn

        ld1     rLcn = [rpMP]
        sxt1    rLcn = rLcn

        add     rl = -1, rl
        add     rpMP = -1, rpMP

//      rpMP  -> Next byte to add in
//      rl    == Number of bytes remaining
//      rLcn  == Accumulated value
//
LFMP10: cmp.eq  pt0, pt1 = zero, rl     // When rl == 0, we're done.
(pt0)   br.cond.sptk.clr LFMP20

        shl     rLcn = rLcn, 8
        ld1     t0 = [rpMP]
        or      rLcn = rLcn, t0

        add     rpMP = -1, rpMP         // Back up through bytes to process.
        add     rl  = -1, rl            // One less byte to process.

        br.cond.sptk.clr LFMP10

LFMP20:
//      rLcn == Accumulated value to return

        movl    t0 = 0xffffffff         // return the lower 32-bits
        and     v0 = rLcn, t0

LFMP99:

        LEAF_RETURN
        LEAF_EXIT(LcnFromMappingPair)


//***************************************************************************
//
// UpcaseName - Converts the name of the file to all upper-case
//
//      ENTRY:  in0 -> Name
//              in1 -> Length of name
//
//      USES:   none
//
        LEAF_ENTRY(UpcaseName)
        LEAF_SETUP(2,3,0,0)
        PROLOGUE_END

        rpName  = in0
        rLength = in1

        cmp.eq  pt0, pt1 = zero, rLength
(pt0)   br.cond.sptk.clr UN30

UN10:
        ld2     t0 = [rpName]
        cmp.gt  pt0, pt1 = 'a', t0      // if it's less than 'a'
(pt0)   br.cond.sptk.clr UN20           // leave it alone

        cmp.lt  pt0, pt1 = 'z', t0      // if it's greater than 'z'  
(pt0)   br.cond.sptk.clr UN20           // leave it alone.    

        movl    t1 = 'a' - 'A'          // the letter is lower-case--convert it.
        sub     t0 = t0, t1             
UN20:
        add     rpName = 2, rpName      // move on to next unicode character

        add     rLength = -1, rLength
        cmp.eq  pt0, pt1 = zero, rLength
(pt0)   br.cond.sptk.clr UN10

UN30: 
        LEAF_RETURN
        LEAF_EXIT(UpcaseName)

//****************************************************************************
//
//  FindFile - Locates the index entry for a file in the root index.
//
//  ENTRY:  in0 -> name to find
//          in1 == length of file name in characters
//
//  EXIT:   v0  -> Index Entry.  NULL to indicate failure.
//
//  USES:   ALL
//
        NESTED_ENTRY(FindFile)
        NESTED_SETUP(3,4,8,0)
        PROLOGUE_END

        rpT0             = t22
        rpT1             = t21
        rpName           = in0
        rLength          = in1
        rIndexAllocation = loc2
        rBlock           = loc3
//
// Setup stack scratch area
//
        add     sp = -STACK_SCRATCH_AREA, sp

//      First, search the index root.
//
//      rpName  -> name to find
//      rLength == name length
//
        movl    rpT0 = IndexRoot
        ld4     t0 = [rpT0]        

        add     rpT1 = RES_ValueOffset, t0
        ld2     t1 = [rpT1]
        add     t2 = t0, t1

        add     out0 = IR_IndexHeader, t2
        mov     out1 = rpName
        mov     out2 = rLength

        mov     ap = sp
        br.call.sptk.many brp = LocateIndexEntry

        cmp.eq  pt0, pt1 = v0, zero
(pt0)   br.cond.sptk.clr FindFile20

//      Found it in the root!  The result is already in eax.
//      Clean up the stack and return.
//
        add     sp = STACK_SCRATCH_AREA, sp
        NESTED_RETURN

FindFile20:
//
//      We didn't find the index entry we want in the root, so we have to
//      crawl through the index allocation buffers.
//
        movl    rpT0 = IndexAllocation
        ld4     rIndexAllocation = [rpT0]

        cmp.eq  pt0, pt1 = t0, zero
(pt1)   br.cond.sptk.clr FindFile30

//      There is no index allocation attribute; clean up
//      the stack and return failure.
//
        mov     v0 = zero
        add     sp = STACK_SCRATCH_AREA, sp
        NESTED_RETURN

FindFile30:
//
//      Search the index allocation blocks for the name we want.
//      Instead of searching in tree order, we'll just start with
//      the last one and work our way backwards.
//
        add     rpT1 = NONRES_HighestVcn+LowPart, rIndexAllocation
        ld4     t1 = [rpT1]                 // t1 = HighestVcn
        add     out0 = 1, t1                // out0 = clusters in attribute

        movl    rpT2 = BytesPerCluster      
        ld4     out1 = [rpT2]

        mov     ap = sp
        br.call.sptk.many brp = Multiply    // v0 = bytes in attribute

        mov     out0 = v0
        movl    rpT0 = BytesPerIndexBlock
        ld4     out1 = [rpT0]

        movl    out2 = Result
        movl    out3 = Remainder

        mov     ap = sp
        br.call.sptk.many brp = Divide      // convert bytes to index blocks

        movl    rpT0 = Result
        ld4     rBlock = [rpT0]             // number of blocks to process

FindFile40:
        cmp.eq  pt0, pt1 = rBlock, zero
(pt0)   br.cond.sptk.clr FindFile90

        add     rBlock = -1, rBlock          // rBlock == number of next block to process

//
//      See if the block is in use; if not, go on to next.
//
        mov     out0 = rBlock
        mov     ap = sp
        br.call.sptk.many brp = IsBlockInUse

        cmp.eq  pt0, pt1 = v0, zero
(pt1)   br.cond.sptk.clr FindFile40          // v0 == zero if not in use

//      rBlock  == block number to process
//      rLength == name length
//      rpName  -> name to find
//
        mov     out0 = rBlock
        mov     ap = sp
        br.call.sptk.many brp = ReadIndexBlock

//      rpName -> name to find
//      rLength == name length in characters
//
//      Index buffer to search is in index allocation block buffer.
//
        movl    rpT0 = IndexBlockBuffer        // t0 -> Index allocation block
        ld4     t0 = [rpT0]

        add     out0 = IB_IndexHeader, t0      // out0 -> Index Header
        mov     out1 = rpName
        mov     out2 = rLength

        mov     ap = sp
        br.call.sptk.many brp = LocateIndexEntry  // v0 -> found entry

        cmp.eq  pt0, pt1 = v0, zero
(pt0)   br.cond.sptk.clr FindFile40

//      Found it!
//
//      v0      -> Found entry
//
        add      sp = STACK_SCRATCH_AREA, sp    // restore the original sp
        NESTED_RETURN

FindFile90:
//
//      Name not found.
//
        mov      v0 = zero                      // zero out v0.

        add      sp = STACK_SCRATCH_AREA, sp    // restore the original sp
        NESTED_RETURN
        NESTED_EXIT(FindFile)

#ifdef DEBUG
#ifdef NOT_YET_PORTED
;****************************************************************************
;
;   DumpIndexBlock - dumps the index block buffer
;
DumpIndexBlock proc near

    SAVE_ALL

    mov     esi, IndexBlockBuffer

    mov     ecx, 20h    ; dwords to dump

DIB10:

    test    ecx, 3
    jnz     DIB20
    call    DebugNewLine

DIB20:

    lodsd
    call    PrintNumber
    loop    DIB10

    RESTORE_ALL
    ret

DumpIndexBlock endp

;****************************************************************************
;
;   DebugNewLine
;
DebugNewLine proc near

    SAVE_ALL

    xor     eax, eax
    xor     ebx, ebx

    mov     al, 0dh
    mov     ah, 14
    mov     bx, 7
    int     10h

    mov     al, 0ah
    mov     ah, 14
    mov     bx, 7
    int     10h

    RESTORE_ALL
    ret

DebugNewLine endp

;****************************************************************************
;
;   DebugPrint  -   Display a debug string.
;
;   ENTRY:  DS:SI  -> null-terminated string
;
;   USES:   None.
;
.286
DebugPrint proc near

    pusha

DbgPr20:

    lodsb
    cmp     al, 0
    je      DbgPr30

    mov     ah, 14  ; write teletype
    mov     bx, 7   ; attribute
    int     10h     ; print it
    jmp     DbgPr20

DbgPr30:

    popa
    nop
    ret

DebugPrint endp

;****************************************************************************
;
;
;   PrintNumber
;
;   ENTRY: EAX == number to print
;
;   PRESERVES ALL REGISTERS
;
.386
PrintNumber proc near


    SAVE_ALL

    mov     ecx, 8      ; number of digits in a DWORD

PrintNumber10:

    mov     edx, eax
    and     edx, 0fh    ; edx = lowest-order digit
    push    edx         ; put it on the stack
    shr     eax, 4      ; drop low-order digit
    loop    PrintNumber10

    mov     ecx, 8      ; number of digits on stack.

PrintNumber20:

    pop     eax         ; eax = next digit to print
    cmp     eax, 9
    jg      PrintNumber22

    add     eax, '0'
    jmp     PrintNumber25

PrintNumber22:

    sub     eax, 10
    add     eax, 'A'

PrintNumber25:

    xor     ebx, ebx

    mov     ah, 14
    mov     bx, 7
    int     10h
    loop    PrintNumber20

;   Print a space to separate numbers

    mov     al, ' '
    mov     ah, 14
    mov     bx, 7
    int     10h

    RESTORE_ALL

    call    Pause

    ret

PrintNumber endp
#endif NOT_YET_PORTED


//****************************************************************************
//
//  Debug0 - Print debug string 0 -- used for checkpoints in mainboot
//
        NESTED_ENTRY(Debug0)
        NESTED_SETUP(3,3,8,0)
        PROLOGUE_END

        add     sp = STACK_SCRATCH_AREA, sp

        movl    out0 = DbgString0
        mov     ap = sp
        br.call.sptk.many brp = BootErr$Print

        add     sp = -STACK_SCRATCH_AREA, sp

        NESTED_RETURN
        NESTED_EXIT(Debug0)

//****************************************************************************
//
//  Debug1 - Print debug string 1 --
//
        NESTED_ENTRY(Debug1)
        NESTED_SETUP(3,3,8,0)

        add     sp = STACK_SCRATCH_AREA, sp

        movl    out0 = DbgString1
        mov     ap = sp
        br.call.sptk.many brp = BootErr$Print

        add     sp = -STACK_SCRATCH_AREA, sp

        NESTED_RETURN
        NESTED_EXIT(Debug1)

//****************************************************************************
//
//  Debug2 - Print debug string 2
//
        NESTED_ENTRY(Debug2)
        NESTED_SETUP(3,3,8,0)

        add     sp = -STACK_SCRATCH_AREA, sp

        movl    out0 = DbgString2
        mov     ap = sp
        br.call.sptk.many brp = BootErr$Print

        add     sp = STACK_SCRATCH_AREA, sp

        NESTED_RETURN
        NESTED_EXIT(Debug2)

//****************************************************************************
//
//   Debug3 - Print debug string 3 --
//
        NESTED_ENTRY(Debug3)
        NESTED_SETUP(3,3,8,0)
        PROLOGUE_END

        add     sp = -STACK_SCRATCH_AREA, sp

        movl    out0 = DbgString3
        mov     ap = sp
        br.call.sptk.many brp = BootErr$Print

        add     sp = STACK_SCRATCH_AREA, sp

        NESTED_RETURN
        NESTED_EXIT(Debug3)

//****************************************************************************
//
//   Debug4 - Print debug string 4
//
        NESTED_ENTRY(Debug4)
        NESTED_SETUP(3,3,8,0)
        PROLOGUE_END

        add     sp = -STACK_SCRATCH_AREA, sp

        movl    out0 = DbgString4
        mov     ap = sp
        br.call.sptk.many brp = BootErr$Print

        add     sp = STACK_SCRATCH_AREA, sp

        NESTED_RETURN
        NESTED_EXIT(Debug4)

#ifdef NOT_YET_PORTED
;****************************************************************************
;
;   Pause - Pause for about 1/2 a second.  Simply count until you overlap
;           to zero.
;
Pause proc near

    push eax
    mov  eax, 0fff10000h

PauseLoopy:
    inc  eax

    or   eax, eax
    jnz  PauseLoopy

    pop  eax
    ret

Pause endp
#endif NOT_YET_PORTED

#endif DEBUG


//*************************************************************************
//
//      LoadIndexFrs  -  For the requested index type code locate and
//                       load the associated Frs.
//
//      ENTRY: in0 - requested index type code
//             in1 - Points to empty Frs buffer
//
//      EXIT:  v0  - points to offset in Frs buffer of requested index type
//                   code or Zero if not found.
//      USES:  All
//
        NESTED_ENTRY(LoadIndexFrs)
        NESTED_SETUP(3,3,8,0)
        PROLOGUE_END

        rTypeCode = in0                   // index type code
        rpFrs     = in1                   // pointer to FRS

//
// setup stack scratch area
//
        add     sp = -STACK_SCRATCH_AREA, sp

        movl    out0 = ROOT_FILE_NAME_INDEX_NUMBER
        mov     out1 = rpFrs

        mov     ap = sp
        br.call.sptk.many brp = ReadFrs

        mov     out0 = rpFrs              // FRS to search
        mov     out1 = rTypeCode          // index type code
        movl    out3 = index_name         // Attribute name

        movl    rpT0 = index_name_length  // Attribute name length  
        ld2     out2 = [rpT0]

        mov     ap = sp
        br.call.sptk.many brp = LocateAttributeRecord

        cmp.eq  pt0, pt1 = v0, zero
(pt1)   br.cond.sptk.clr LoadIndexFrs$Exit // if found in root return

//
//      if not found in current Frs, search in attribute list
//
        mov     out0 = rTypeCode       // type code
        mov     out1 = rpFrs           // FRS to search

        mov     ap = sp
        br.call.sptk.many brp = SearchAttrList  // search attribute list for FRN
                                       // of specified ($INDEX_ROOT,
                                       // $INDEX_ALLOCATION, or $BITMAP)

        // v0 - holds FRN for Frs, or Zero

        cmp.eq  pt0, pt1 = v0, zero         // if we cann't find it in attribute
(pt0)   br.cond.sptk.clr LoadIndexFrs$Exit  // list then we are hosed

//      We should now have the File Record Number where the index for the
//      specified type code we are searching for is,  load this into the
//      Frs target buffer.
//
//      EAX - holds FRN
//      EBX - holds type code
//      EDI - holds target buffer

        mov     out0 = v0
        mov     out1 = rTypeCode
        mov     out2 = rpFrs

        mov     ap = sp
        br.call.sptk.many brp = ReadFrs

//
//      Now determine the offset in the Frs of the index
//

        mov     out0 = rpFrs            // Frs to search
        mov     out1 = rTypeCode        // FRS Type Code

        movl    rpT0 = index_name_length
        ld4     out2 = [rpT0]           // Attribute name length
        movl    out3 = index_name

        mov     ap = sp
        br.call.sptk.many brp = LocateAttributeRecord

//      v0 -  holds offset or Zero.

LoadIndexFrs$Exit:

        add     sp = STACK_SCRATCH_AREA, sp          // restore original sp

        NESTED_RETURN
        NESTED_EXIT(LoadIndexFrs)


//****************************************************************************
//
//  SearchAttrList
//
//  Search the Frs for the attribute list.  Then search the attribute list
//  for the specifed type code.  When you find it return the FRN in the
//  attribute list entry found or Zero if no match found.
//
//  ENTRY: in0 - type code to search attrib list for
//         in1 - Frs buffer holding head of attribute list
//  EXIT:  v0  - FRN file record number to load, Zero if none.
//
//  USES: All
//
        NESTED_ENTRY(SearchAttrList)
        NESTED_SETUP(2,4,8,0)
        PROLOGUE_END

        rTypeCode = in0
        rFrs      = in1
        rAttrList = loc2

//
// Setup stack scratch area
//
        add     sp = -STACK_SCRATCH_AREA, sp

        mov     out0 = rFrs
        mov     out1 = $ATTRIBUTE_LIST    // Attribute type code
        mov     out2 = 0                  // Attribute name length
        mov     out3 = 0                  // Attribute name

        mov     ap = sp
        br.call.sptk.many brp = LocateAttributeRecord

        cmp.eq  pt0, pt1 = v0, zero       // If there's no Attribute list,
(pt0)   br.cond.sptk.clr SearchAttrList$NotFoundIndex1 // We are done

//      Read the attribute list.
//      eax -> attribute list attribute

        mov     out0 = v0       // out0 -> attribute list attribute
        movl    out1 = AttrList // out1 -> attribute list buffer

        mov     ap = sp
        br.call.sptk.many brp = ReadWholeAttribute

        movl    rpT0 = AttrList
        ld4     rAttrList = [rpT0]   // rAttrList -> first attribute list entry

//      Now, traverse the attribute list looking for the entry for
//      the Index type code.
//
//      rAttrList -> first attribute list entry
//

SearchAttrList$LookingForIndex:

#ifdef DEBUG

        add     rpT0 = ATTRLIST_AttributeTypeCode, rAttrList
        ld4     out0 = [rpT0]
        mov     ap = sp
        br.call.sptk.many brp = PrintNumber

        add     rpT0 = ATTRLIST_RecordLength, rAttrList
        ld4     out0 = [rpT0]
        mov     ap = sp
        br.call.sptk.many brp = PrintNumber

        mov     out0 = rAttrList
        mov     ap = sp
        br.call.sptk.many brp = PrintNumber

        add     out0 = ATTRLIST_Name, rAttrList
        mov     ap = sp
        br.call.sptk.many brp = PrintName

#endif

        add     rpT0 = ATTRLIST_AttributeTypeCode, rpT0
        ld4     t0 = [rpT0]
        cmp.eq  pt0, pt1 = rTypeCode, t0
(pt0)   br.cond.sptk.clr SearchAttrList$FoundIndex

        movl    t1 = $END
        cmp.eq  pt0, pt1 = t0, t1         // reached invalid attribute
(pt0)   br.cond.sptk.clr SearchAttrList$NotFoundIndex2  // so must be at end

        add     rpT0 = ATTRLIST_RecordLength, rpT0
        ld4     t0 = [rpT0]
        cmp.eq  pt0, pt1 = 0, t0
(pt0)   br.cond.sptk.clr SearchAttrList$NotFoundIndex2 //reached end of list and
                                                       // nothing found

        add     rAttrList = rAttrList, t0              // Next attribute
        br.cond.sptk.clr SearchAttrList$LookingForIndex

SearchAttrList$FoundIndex:

        //  found the index, return the FRN

        add    rpT0 = ATTRLIST_SegmentReference, rAttrList
        add    rpT0 = REF_SegmentNumberLowPart, rAttrList
        ld4     v0 = [rpT0]

        NESTED_RETURN

SearchAttrList$NotFoundIndex1:
        // pop     ecx
SearchAttrList$NotFoundIndex2:
        mov     v0 = zero

        add     sp = -STACK_SCRATCH_AREA, sp   // restore original sp 

        NESTED_RETURN
        NESTED_EXIT(SearchAttrList)

//
// Boot message printing, relocated from sector 0 to sace space
//
BootErr2:              // temporary label
BootErr$fnf:
        movl    out0 = TXT_MSG_SYSINIT_FILE_NOT_FD
        br.cond.sptk.clr BootErr2
BootErr$ntc:
        movl    out0 = TXT_MSG_SYSINIT_NTLDR_CMPRS
        br.cond.sptk.clr BootErr2

TXT_MSG_SYSINIT_BOOT_ERROR:     stringz  "A disk read error occurred"
TXT_MSG_SYSINIT_FILE_NOT_FD:    stringz  "NTLDR is missing"
TXT_MSG_SYSINIT_NTLDR_CMPRS:    stringz  "NTLDR is compressed"
TXT_MSG_SYSINIT_REBOOT:         stringz  "Press Ctrl+Alt+Del to restart"

#ifdef DEBUG
DbgString0      stringz  "Debug Point 0"
DbgString1      stringz  "Debug Point 1"
DbgString2      stringz  "Debug Point 2"
DbgString3      stringz  "Debug Point 3"
DbgString4      stringz  "Debug Point 4"
#endif DEBUG

#ifdef NOT_YET_PORTED
        .errnz  ($-_ntfsboot) GT 8192   ; <FATAL PROBLEM: main boot record exceeds available space>

        org     8192

BootCode ends

        end _ntfsboot
#endif NOT_YET_PORTED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\ntfs\ia64\sal.h ===
typedef struct _IA32_BIOS_REGISTER_STATE {

    // general registers
    ULONG eax;    
    ULONG ecx;    
    ULONG edx;    
    ULONG ebx;    
    ULONG esp;    

    // stack registers
    ULONG ebp;    
    ULONG esi;    
    ULONG edi;    

    // eflags
    ULONG efalgs;    

    // instruction pointer
    ULONG cs;    
    ULONG ds;    
    ULONG es;    
    ULONG fs;    
    ULONG gs;    
    ULONG ss;    

    // LDT/GDT table pointer and LDT selector
    ULONGLONG *LDTTable;                      // 64 bit pointer to LDT table
    ULONGLONG *GDTTable;                      // 64 bit pointer to GDT table
    ULONG ldt_selector;
} IA32_BIOS_REGISTER_STATE, *PIA32_BIOS_REGISTER_STATE;

typedef union _BIT32_AND_BIT16 {
    ULONG Part32;
    struct {
        USHORT LowPart16;
        USHORT HighPart16;
    };
} BIT32_AND_BIT16;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\ntfs\ia64\miscc.c ===
#include "bldr.h"
#include "sal.h"
#include "ssc.h"
#include "ntimage.h"

#define SECTOR_SIZE 512

SalDiskReadWrite(
    ULONG ReadWrite,
    ULONG SectorsToRead,
    ULONG Cylinder,
    ULONG CylinderPerSector,
    ULONG Head,
    ULONG Drive,
    PUCHAR Buffer
    )
{
    IA32_BIOS_REGISTER_STATE IA32RegisterState;
    BIT32_AND_BIT16 IA32Register;

    if (ReadWrite == 0) {
        IA32Register.HighPart16 = 0x02;
    } else {
        IA32Register.HighPart16 = 0x03;
    }

    IA32Register.LowPart16 = SectorsToRead;
    IA32RegisterState.eax = IA32Register.Part32;

    IA32Register.HighPart16 = Cylinder;
    IA32Register.LowPart16 = CylinderPerSector;
    IA32RegisterState.ecx = IA32Register.Part32;

    IA32Register.HighPart16 = Head;
    IA32Register.LowPart16 = Drive;
    IA32RegisterState.edx = IA32Register.Part32;

    IA32RegisterState.es = 0;

    IA32Register.HighPart16 = 0;
    IA32Register.LowPart16 = Buffer;
    IA32RegisterState.ebx = IA32Register.Part32;
   
    // SAL_PROC(0x100,&IA32RegisterState,0,0,0,0,0,0,);
}

ReadSectors(
    ULONG SectorBase,
    USHORT SectorCount,
    PUCHAR Buffer)
{
    static char *VolumeName = "\\\\.\\D:";
    SSC_HANDLE VolumeHandle;
    SSC_DISK_REQUEST Request[1];
    SSC_DISK_COMPLETION DiskCompletion;
    LARGE_INTEGER VolumeNamePtr;
    LARGE_INTEGER RequestPtr;
    LARGE_INTEGER VolumeOffset;
    LARGE_INTEGER DiskCompletionPtr;

    VolumeNamePtr.LowPart = VolumeName;
    VolumeNamePtr.HighPart = 0;
    VolumeHandle = SscDiskOpenVolume (VolumeNamePtr, SSC_ACCESS_READ);

    Request[0].DiskBufferAddress.LowPart = Buffer;
    Request[0].DiskBufferAddress.HighPart = 0;
    Request[0].DiskByteCount = SectorCount * SECTOR_SIZE;
    RequestPtr.LowPart = Request;
    RequestPtr.HighPart = 0;

    VolumeOffset.LowPart = SectorBase * SECTOR_SIZE;
    VolumeOffset.HighPart = 0;
    SscDiskReadVolume(VolumeHandle, 1,  RequestPtr, VolumeOffset);

    DiskCompletion.VolumeHandle = VolumeHandle;
    DiskCompletionPtr.LowPart = &DiskCompletion;
    DiskCompletionPtr.HighPart = 0;
    while (1) {
        if (SscDiskWaitIoCompletion(DiskCompletionPtr) == 0) break;
    }
}

SalPrint(
    PUCHAR Buffer
    )
{
    IA32_BIOS_REGISTER_STATE IA32RegisterState;
    BIT32_AND_BIT16 IA32Register;
    ULONG i;

    for (i = 0; Buffer[i] != 0 && i < 256; i++) {
        IA32Register.HighPart16 = 14;
        IA32Register.LowPart16 = Buffer[i];
        IA32RegisterState.eax = IA32Register.Part32;

        IA32RegisterState.ebx = 7;
   
        // SAL_PROC(0x100,&IA32RegisterState,0,0,0,0,0,0,);
    }
}

Multiply(
    ULONG Multiplicant,
    ULONG Multiplier)
{
    return(Multiplicant * Multiplier);
}

Divide(
    ULONG Numerator,
    ULONG Denominator,
    PULONG Result,
    PULONG Remainder
    )
{
    float f1, f2;

    f1 = (float) Numerator;
    f2 = (float) Denominator;
    *Result = (ULONG) (f1 / f2);
    *Remainder = Numerator % Denominator;
}

memcpy(
    PUCHAR Source,
    PUCHAR Destination,
    ULONG Length
    )
{
    while (Length--) {
        *Destination++ = *Source++;
    }
}

memmove(
    PUCHAR Source,
    PUCHAR Destination,
    ULONG Length
    )
{
    while (Length--) {
        *Destination++ = *Source++;
    }
}

memset(
    PUCHAR Destination,
    ULONG Length,
    ULONG Value
    )
{
    while (Length--) {
        *Destination++ = Value;
    }
}

strncmp(
    PUCHAR String1,
    PUCHAR String2,
    ULONG Length
    )
{
    while (Length--) {
        if (*String1++ != *String2++)
            return(String1);
    }
    return(0);
}

PrintName(
    PUCHAR String
    )
{
    LARGE_INTEGER StringPtr;

    StringPtr.LowPart = String;
    StringPtr.HighPart = 0;
    SscDbgPrintf(StringPtr);
}

BootErr$Print(
    PUCHAR String
    )
{
    LARGE_INTEGER StringPtr;

    StringPtr.LowPart = String;
    StringPtr.HighPart = 0;
    SscDbgPrintf(StringPtr);
}

LoadNtldrSymbols()
{
    static char *NtfsBoot = "\\ntfsboot.exe";
    static char *Ntldr = "\\NTLDR";
    LARGE_INTEGER PhysicalPtr;

    PhysicalPtr.LowPart = NtfsBoot;
    PhysicalPtr.HighPart = 0;

    SscUnloadImage(PhysicalPtr, 
                   0x0, 
                   (ULONG)-1,
                   (ULONG)0);

    PhysicalPtr.LowPart = Ntldr;
    PhysicalPtr.HighPart = 0;

    SscLoadImage(PhysicalPtr,
                 0xE00000,
                 0x118A00,
                 0x7cc,
                 0,                   // process ID
                 1);                  // load count
}

ULONG
RelocateLoaderSections(
    ULONG NtldrBuffer
    )
/*++

Routine Description:

    The SU module is prepended to the OS loader file. The OS loader file
    is a coff++ file. This routine computes the beginning of the OS loader
    file, then relocates the OS loader's sections as if it were just
    loading the file from disk file.

Arguments:

    NtldrBuffer - Buffer that contains the NTLDR raw image from disk

Returns:

    Entry point of loader


--*/
{
    ULONG Start, End;
    USHORT Section;
    ULONG Source,Destination;
    ULONG VirtualSize;
    ULONG SizeOfRawData;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;
    PIMAGE_SECTION_HEADER SectionHeader;

    //
    // Make a pointer to the beginning of the loader's coff header
    //

    FileHeader = (PIMAGE_FILE_HEADER) NtldrBuffer;

    //
    // Validate the appended loader image by checking signatures.
    //   1st - is it an executable image?
    //   2nd - is the target environment the 386?
    //

    if ((FileHeader->Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0) {
        SalPrint("SU_NTLDR_CORRUPT");
        return;
    }

    if (FileHeader->Machine != IMAGE_FILE_MACHINE_IA64) {
        SalPrint("SU_NTLDR_CORRUPT");
        return;
    }

    //
    // Make a pointer to the optional header in the header-buffer
    //

    OptionalHeader = (PIMAGE_OPTIONAL_HEADER)((PUCHAR)FileHeader +
        sizeof(IMAGE_FILE_HEADER));

    //
    // Make a pointer to the first section in the header buffer
    //

    SectionHeader = (PIMAGE_SECTION_HEADER)((PUCHAR)OptionalHeader +
        FileHeader->SizeOfOptionalHeader);

    Start = OptionalHeader->ImageBase+SectionHeader->VirtualAddress;
    End   = Start + SectionHeader->SizeOfRawData;

    //
    // Loop and relocate each section with a non-zero RawData size
    //

    for (Section=FileHeader->NumberOfSections ; Section-- ; SectionHeader++) {

        //
        // Compute source, destination, and count arguments
        //

        Source = NtldrBuffer  + SectionHeader->PointerToRawData;
        Destination = OptionalHeader->ImageBase + SectionHeader->VirtualAddress;

        VirtualSize = SectionHeader->Misc.VirtualSize;
        SizeOfRawData = SectionHeader->SizeOfRawData;

        if (VirtualSize == 0) {
            VirtualSize = SizeOfRawData;
        }

        if (SectionHeader->PointerToRawData == 0) {
            //
            // SizeOfRawData can be non-zero even if PointerToRawData is zero
            //

            SizeOfRawData = 0;
        } else if (SizeOfRawData > VirtualSize) {
            //
            // Don't load more from image than is expected in memory
            //

            SizeOfRawData = VirtualSize;
        }

        if (Destination < Start) {
            Start = Destination;
        }

        if (Destination+VirtualSize > End) {
            End = Destination+VirtualSize;
        }

        if (SizeOfRawData != 0) {
            //
            // This section is either a code (.TEXT) section or an
            // initialized data (.DATA) section.
            // Relocate the section to memory at the virtual/physical
            // addresses specified in the section header.
            //
            memmove(Source,Destination,SizeOfRawData);
        }

        if (SizeOfRawData < VirtualSize) {
            //
            // Zero the portion not loaded from the image
            //
            memset(Destination+SizeOfRawData,0,VirtualSize - SizeOfRawData);
        }
#if 0
        //
        // Check if this is the resource section.  If so, we need
        // to pass its location to the osloader.
        //
        if ((SectionHeader->Name[0] == '.') &&
            (SectionHeader->Name[1] == 'r') &&
            (SectionHeader->Name[2] == 's') &&
            (SectionHeader->Name[3] == 'r') &&
            (SectionHeader->Name[4] == 'c')) {
            ResourceDirectory = Destination;
            ResourceOffset = SectionHeader->VirtualAddress;
        }
#endif
    }

    return(OptionalHeader->AddressOfEntryPoint + OptionalHeader->ImageBase);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootfont\sources.inc ===
!IF 0

binplace the appropriate bootfont.bin files.

!ENDIF

ALT_PROJECT=$(LANGUAGE)
ALT_PROJECT_TARGET=$(ALT_PROJECT)

TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=

SOURCES=

# makefile.def will binplace any file listed in the MISCFILES macro.
MISCFILES=bootfont.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\ntfs\ia64\susetup.h ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

//++
//
//  Module name
//	SuSetup.h
//  Author
//	Allen Kay    (akay)    Jun-12-95
//  Description
//	Include file for SuSetup.s
//--

#ifndef __SUSETUP__
#define __SUSETUP__

//
// NT OS Loader address map
//
#define BOOT_USER_PAGE       0x00C00
#define BOOT_SYSTEM_PAGE     0x80C00
#define BOOT_PHYSICAL_PAGE   0x00000

#define BL_PAGE_SIZE         0x18            // 0x18=24, 2^24=16MB

#define BL_SP_BASE           0x00D80000      // Initial stack pointer
#define	Bl_IVT_BASE	         0x00A08000      // Interrup vector table base

//
// Initial CPU values
//

//
// Initial Region Register value:
//	RID = 0, PS = 4M, E = 0
//
#define	RR_PAGE_SIZE    (BL_PAGE_SIZE << RR_PS)
#define	RR_SHIFT        61
#define	RR_BITS         3
#define	RR_SIZE         8

#endif __SUSETUP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootcode\ntfs\ia64\simsal.s ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

//++
//
//  Module name
//      SIMSAL.S
//  Author
//      Allen Kay    (akay)    May-6-97
//  Description
//      Initializes the CPU and loads the first sector from the boot partition.
//  SIMSAL does the following:
//      1.   Initialize PSR with interrupt disabled.
//      2.   Invalidate ALAT.
//      3.   Invalidate RS.
//      4.   Setup GP.
//      5.   Set region registers rr[r0] - rr[r7] to RID=0, PS=8K, E=0.
//      6.   Initialize SP to 0x00902000.
//      7.   Initialize BSP to 0x00202000.
//      8.   Enable register stack engine.
//      9.   Setup IVA to 0x001F8000.
//      10.  Setup virtual->physical address translation
//           0x80000000->0x00000000 in dtr0/itr0 for NT kernel.
//      11.  Setup virtual->physical address translation
//           0x80400000->0x00400000 in dtr1/itr1 for HAL.dll.
//      12.  Setup virtual->physical address translation
//           0x00800000->0x00800000 in dtr1/itr1 for NTLDR.
//---

#include "ksia64.h"
#include "susetup.h"
#include "ntfsdefs.h"

        .file   "start.s"

        .global SscExit
        .type SscExit, @function

        .global ReadSectors
        .type ReadSectors, @function

#define Buffer 0x0

//
// Interrupt Vector Table
//

#define VECTOR(Offset, Name)                     \
        .##org Offset;                           \
Name::                                           \
        mov     a0 = cr##.##iip;                 \
        br##.##call##.##sptk##.##clr brp = SscExit
        
        .section ivt = "ax", "progbits"
BlIvtBase::

        VECTOR(0x0000, BlVhptTransVector)
        VECTOR(0x0400, BlInstTlbVector)
        VECTOR(0x0800, BlDataTlbVector)
        VECTOR(0x0C00, BlAltInstTlbVector)
        VECTOR(0x1000, BlAltDataTlbVector)
        VECTOR(0x1400, BlNestedTlbVector)
        VECTOR(0x1800, BlInstKeyMissVector)
        VECTOR(0x1C00, BlDataKeyMissVector)
        VECTOR(0x2000, BlDirtyBitVector)
        VECTOR(0x2400, BlInstAccessBitVector)
        VECTOR(0x2800, BlDataAccessBitVector)
        VECTOR(0x2C00, BlBreakVector)
        VECTOR(0x3000, BlExternalInterruptVector)
        VECTOR(0x5000, BlPageNotPresentVector)
        VECTOR(0x5100, BlKeyPermVector)
        VECTOR(0x5200, BlInstAccessRightsVector)
        VECTOR(0x5300, BlDataAccessRightsVector)
        VECTOR(0x5400, BlGeneralExceptionVector)
        VECTOR(0x5500, BlDisabledFpRegisterVector)
        VECTOR(0x5600, BlNatConsumptionVector)
        VECTOR(0x5700, BlSpeculationVector)
        VECTOR(0x6900, BlIA32ExceptionVector)
        VECTOR(0x6A00, BlIA32InterceptionVector)
        VECTOR(0x6B00, BlIA32InterruptionVector)
        
// ***************************************************************************
// Initialize the processor
// ***************************************************************************
        NESTED_ENTRY(SimSal)
        NESTED_SETUP(3,3,8,0)
        PROLOGUE_END

        rpT0    = t22
        rpT1    = t21
        rpT2    = t20
        rpT3    = t19


        mov     psr.l = zero            // initialize psr.l
        movl    t0 = FPSR_FOR_KERNEL    
        mov     ar.fpsr = t0            // initialize fpsr

        invala                          // invalidate ALAT

        mov     ar.rsc = zero           // invalidate register stack
        loadrs             

//
// Initialize Region Registers
//
        mov     t0 = RR_PAGE_SIZE
        mov     t1 = zero
Bl_RRLoop:
        dep     t2 = t2, t1, RR_SHIFT, RR_BITS
        mov     rr[t2] = t0
        add     t1 = 1, t1
        cmp4.geu pt0, pt1 = RR_SIZE, t1
(pt0)   br.cond.sptk.clr Bl_RRLoop

//
// Initialize the protection key registers with only pkr[0] = valid.
//
        mov     t0 = PKR_VALID
        mov     t1 = zero
        mov     pkr[t1] = t0

        mov     t0 = zero

Bl_PKRLoop:
        add     t1 = t1, zero, 1                // increment PKR
        cmp.gtu pt0, pt1 = PKRNUM, t1
(pt0)   mov     pkr[t1] = t0
(pt0)   br.cond.sptk.clr Bl_PKRLoop

//
// Setup SP
//
        movl    sp = BL_SP_BASE

//
// Set up tbe scratch area
//
        add     sp = -STACK_SCRATCH_AREA, sp

//
// Setup register stack backing store.
//
        mov     t0 = RSC_KERNEL_DISABLED
        mov     ar.rsc = t0

        movl    t1 = BL_SP_BASE
        mov     ar.bspstore = t1

//
// Setup the base address of interrupt vector table
//
        movl    t0 = BlIvtBase
        mov     cr.iva = t0

//
// Setup system address translation for NT kernel
//  
//

        movl    t0 = BOOT_SYSTEM_PAGE << PAGE_SHIFT
        ADDS4   (t0, 0, t0)
        mov     cr.ifa = t0

        movl    t1 = IDTR_IIP_VALUE(0,0,BL_PAGE_SIZE)
        mov     cr.itir = t1
        
        movl    t2 = TR_VALUE(1,BOOT_PHYSICAL_PAGE,3,0,1,1,1,1)
        mov     t3 = zero

        itr.d   dtr[t3] = t2
        itr.i   itr[t3] = t2

//
//  Setup the aliased kernel space
//
        zxt4    t0 = t0                 // zero extend kernel address
        mov     t4 = 6                  // create alias in region 6 
        mov     t5 = 2                  // index
        dep     t0 = t4, t0, 61, 3
        mov     cr.ifa = t0
        
        itr.i   itr[t5] = t2            

//
// Setup 1-1 address translation for NT kernel
//  

        movl    t0 = BOOT_USER_PAGE << PAGE_SHIFT
        ADDS4   (t0, 0, t0)
        mov     cr.ifa = t0

        movl    t2 = TR_VALUE(1,BOOT_USER_PAGE,3,0,1,1,1,1)
        add     t3 = 1, t3

        itr.d   dtr[t3] = t2
        itr.i   itr[t3] = t2

//
// Turn on address translation, interrupt, psr.ed, protection key.
//
        movl    t1 = MASK(PSR_BN,1) | MASK(PSR_IT,1) | MASK(PSR_DA,1) | MASK(PSR_RT,1) | MASK(PSR_DT,1) | MASK(PSR_PK,1) | MASK(PSR_I,1)| MASK(PSR_IC,1)
        mov     cr.ipsr = t1

//
// Initialize DCR to defer all speculation faults
//
        movl    t0 = DCR_DEFER_ALL
        mov     cr.dcr = t0

//
// Read the first sector of the boot partition
//
        mov     out0 = zero
        movl    out1 = 1
        movl    out2 = Buffer

        mov     ap = sp
        br.call.sptk.many brp = ReadSectors

//
// Read the first sector of the boot partition
//
        mov     out0 = zero

#ifdef BSDT
        movl    t0 = Buffer             // get the sector count
        add     rpT0 = 6, t0
        ld2     out1 = [rpT0]
#else
        movl    out1 = 64               // read 64 sectors, 32KB
#endif

        movl    out2 = Buffer
        mov     ap = sp
        br.call.sptk.many brp = ReadSectors

//
// Now pass control to the first sector code
//
#ifdef BSDT
        movl    t0 = Buffer             // (the second sector).
        add     rpT0 = 8, t0
        ld4     t1 = [rpT0]
#else
        movl    t1 = 0xd0               // since no bsdt, hardcode it for now.
#endif

        mov     cr.iip = t1

        rfi;;

        NESTED_EXIT(SimSal)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\boot\bootfont\cht\fonttable.h ===
#define MAX_SBCS_NUM      190
#define MAX_SBCS_BYTES    17
#define MAX_DBCS_NUM      5838
#define MAX_DBCS_BYTES    34
#define LANGUAGE_ID       0x404


// local string to send into _tsetlocale
PCHAR   LocaleString = "chinese-traditional";

unsigned char LeadByteTable[] = { 0xA1, 0xFE, 0x8E, 0xA0, 0x81, 0x8D, 0x00, 0x00 };

unsigned char SBCSImage[MAX_SBCS_NUM][MAX_SBCS_BYTES] = { 
{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0x20, 0x27, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24 },
{ 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xfc, 0x4, 0xe4, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24 },
{ 0x3, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x27, 0x20, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0x4, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0xe4, 0x4, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0x5, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24 },
{ 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x0, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0x7, 0x0, 0x0, 0x0, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x3e, 0x1c, 0x1c, 0x8 },
{ 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0x9, 0x0, 0x0, 0x0, 0x0, 0x18, 0x24, 0x24, 0x42, 0x42, 0x42, 0x42, 0x24, 0x24, 0x18, 0x0, 0x0 },
{ 0xa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0xb, 0x0, 0x0, 0x0, 0x0, 0xfe, 0x82, 0xc6, 0xaa, 0xaa, 0x92, 0x92, 0xaa, 0xaa, 0xc6, 0x82, 0xfe },
{ 0xc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0xd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0xe, 0x0, 0x0, 0x0, 0x0, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe },
{ 0xf, 0x0, 0x0, 0x49, 0x49, 0x2a, 0x36, 0x14, 0x22, 0xe3, 0x22, 0x14, 0x36, 0x2a, 0x49, 0x49, 0x0 },
{ 0x10, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0xe7, 0x0, 0xe7, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24 },
{ 0x11, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0x12, 0x0, 0x0, 0x0, 0x8, 0x1c, 0x1c, 0x3e, 0x8, 0x8, 0x8, 0x8, 0x8, 0x3e, 0x1c, 0x1c, 0x8 },
{ 0x13, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0x14, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa },
{ 0x15, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0xe7, 0x0, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0x16, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x0, 0xe7, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24 },
{ 0x17, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0xe4, 0x4, 0xe4, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24 },
{ 0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0x19, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x27, 0x20, 0x27, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24 },
{ 0x1a, 0x0, 0x55, 0x0, 0xaa, 0x0, 0x55, 0x0, 0xaa, 0x0, 0x55, 0x0, 0xaa, 0x0, 0x55, 0x0, 0xaa },
{ 0x1b, 0x0, 0x0, 0x0, 0x2, 0x2, 0x2, 0x2, 0x22, 0x62, 0xfe, 0x60, 0x20, 0x0, 0x0, 0x0, 0x0 },
{ 0x1c, 0x0, 0x0, 0x0, 0x8, 0x1c, 0x1c, 0x3e, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8 },
{ 0x1d, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8 },
{ 0x1e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x6, 0x7f, 0x6, 0x4, 0x0, 0x0, 0x0, 0x0 },
{ 0x1f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x60, 0xfe, 0x60, 0x20, 0x0, 0x0, 0x0, 0x0 },
{ 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0x21, 0x0, 0x0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x0, 0x0, 0x10, 0x38, 0x10, 0x0, 0x0 },
{ 0x22, 0x0, 0x0, 0x6c, 0x6c, 0x24, 0x48, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0x23, 0x0, 0x0, 0x24, 0x24, 0x24, 0x7e, 0x24, 0x24, 0x24, 0x24, 0x7e, 0x24, 0x24, 0x24, 0x0, 0x0 },
{ 0x24, 0x0, 0x0, 0x10, 0x38, 0x54, 0x54, 0x50, 0x38, 0x14, 0x54, 0x54, 0x54, 0x38, 0x10, 0x0, 0x0 },
{ 0x25, 0x0, 0x0, 0x22, 0x56, 0x54, 0x2c, 0x8, 0x18, 0x10, 0x30, 0x24, 0x6a, 0x4a, 0x44, 0x0, 0x0 },
{ 0x26, 0x0, 0x0, 0x30, 0x48, 0x48, 0x50, 0x20, 0x66, 0x66, 0x94, 0x94, 0x88, 0x8c, 0x76, 0x0, 0x0 },
{ 0x27, 0x0, 0x0, 0x18, 0x18, 0x8, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0x28, 0x0, 0x0, 0x8, 0x10, 0x10, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x10, 0x10, 0x8, 0x0, 0x0 },
{ 0x29, 0x0, 0x0, 0x10, 0x8, 0x8, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x8, 0x8, 0x10, 0x0, 0x0 },
{ 0x2a, 0x0, 0x0, 0x0, 0x0, 0x10, 0x92, 0x54, 0x38, 0x38, 0x54, 0x92, 0x10, 0x0, 0x0, 0x0, 0x0 },
{ 0x2b, 0x0, 0x0, 0x0, 0x0, 0x10, 0x10, 0x10, 0xfe, 0x10, 0x10, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0 },
{ 0x2c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x18, 0x18, 0x8, 0x10 },
{ 0x2d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0x2e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x18, 0x18, 0x0, 0x0 },
{ 0x2f, 0x0, 0x0, 0x2, 0x4, 0x4, 0x8, 0x8, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40, 0x80, 0x0, 0x0 },
{ 0x30, 0x0, 0x0, 0x18, 0x24, 0x24, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x24, 0x24, 0x18, 0x0, 0x0 },
{ 0x31, 0x0, 0x0, 0x10, 0x30, 0x50, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7c, 0x0, 0x0 },
{ 0x32, 0x0, 0x0, 0x3c, 0x42, 0x42, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x42, 0x42, 0x7e, 0x0, 0x0 },
{ 0x33, 0x0, 0x0, 0x3c, 0x42, 0x42, 0x2, 0x2, 0x1c, 0x2, 0x2, 0x42, 0x42, 0x42, 0x3c, 0x0, 0x0 },
{ 0x34, 0x0, 0x0, 0x4, 0xc, 0xc, 0x14, 0x24, 0x24, 0x44, 0x44, 0xfe, 0x4, 0x4, 0xe, 0x0, 0x0 },
{ 0x35, 0x0, 0x0, 0x7e, 0x40, 0x40, 0x40, 0x7c, 0x42, 0x2, 0x2, 0x42, 0x42, 0x42, 0x3c, 0x0, 0x0 },
{ 0x36, 0x0, 0x0, 0x3c, 0x42, 0x42, 0x40, 0x40, 0x7c, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x0, 0x0 },
{ 0x37, 0x0, 0x0, 0x7e, 0x42, 0x42, 0x4, 0x4, 0x8, 0x8, 0x10, 0x10, 0x10, 0x10, 0x10, 0x0, 0x0 },
{ 0x38, 0x0, 0x0, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x0, 0x0 },
{ 0x39, 0x0, 0x0, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3e, 0x2, 0x2, 0x42, 0x42, 0x3c, 0x0, 0x0 },
{ 0x3a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x18, 0x18, 0x0, 0x0, 0x0, 0x0, 0x18, 0x18, 0x0, 0x0 },
{ 0x3b, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x18, 0x18, 0x0, 0x0, 0x0, 0x0, 0x18, 0x18, 0x8, 0x10 },
{ 0x3c, 0x0, 0x0, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x0, 0x0, 0x0 },
{ 0x3d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7e, 0x0, 0x7e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0x3e, 0x0, 0x0, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x0, 0x0, 0x0 },
{ 0x3f, 0x0, 0x0, 0x38, 0x44, 0x82, 0x82, 0x44, 0x8, 0x10, 0x10, 0x0, 0x10, 0x38, 0x10, 0x0, 0x0 },
{ 0x40, 0x0, 0x0, 0x3c, 0x42, 0x42, 0x2, 0x2, 0x32, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a, 0x3c, 0x0, 0x0 },
{ 0x41, 0x0, 0x0, 0x18, 0x24, 0x42, 0x42, 0x42, 0x42, 0x7e, 0x42, 0x42, 0x42, 0x42, 0x42, 0x0, 0x0 },
{ 0x42, 0x0, 0x0, 0xfc, 0x42, 0x42, 0x42, 0x42, 0x7c, 0x42, 0x42, 0x42, 0x42, 0x42, 0xfc, 0x0, 0x0 },
{ 0x43, 0x0, 0x0, 0x3a, 0x46, 0x42, 0x42, 0x40, 0x40, 0x40, 0x40, 0x42, 0x42, 0x42, 0x3c, 0x0, 0x0 },
{ 0x44, 0x0, 0x0, 0xf8, 0x44, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x44, 0xf8, 0x0, 0x0 },
{ 0x45, 0x0, 0x0, 0xfe, 0x42, 0x40, 0x40, 0x44, 0x7c, 0x44, 0x40, 0x40, 0x40, 0x42, 0xfe, 0x0, 0x0 },
{ 0x46, 0x0, 0x0, 0xfe, 0x42, 0x40, 0x40, 0x44, 0x7c, 0x44, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x0, 0x0 },
{ 0x47, 0x0, 0x0, 0x3a, 0x46, 0x42, 0x42, 0x40, 0x40, 0x4e, 0x42, 0x42, 0x42, 0x46, 0x3a, 0x0, 0x0 },
{ 0x48, 0x0, 0x0, 0xee, 0x44, 0x44, 0x44, 0x44, 0x7c, 0x44, 0x44, 0x44, 0x44, 0x44, 0xee, 0x0, 0x0 },
{ 0x49, 0x0, 0x0, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7c, 0x0, 0x0 },
{ 0x4a, 0x0, 0x0, 0x3c, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x88, 0x70, 0x0, 0x0 },
{ 0x4b, 0x0, 0x0, 0xee, 0x44, 0x48, 0x50, 0x60, 0x60, 0x50, 0x50, 0x48, 0x48, 0x44, 0xee, 0x0, 0x0 },
{ 0x4c, 0x0, 0x0, 0x70, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x7e, 0x0, 0x0 },
{ 0x4d, 0x0, 0x0, 0xc6, 0x44, 0x6c, 0x6c, 0x54, 0x54, 0x54, 0x44, 0x44, 0x44, 0x44, 0xee, 0x0, 0x0 },
{ 0x4e, 0x0, 0x0, 0xee, 0x44, 0x64, 0x64, 0x74, 0x54, 0x5c, 0x4c, 0x4c, 0x44, 0x44, 0xee, 0x0, 0x0 },
{ 0x4f, 0x0, 0x0, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x0, 0x0 },
{ 0x50, 0x0, 0x0, 0xf8, 0x44, 0x42, 0x42, 0x42, 0x44, 0x78, 0x40, 0x40, 0x40, 0x40, 0xe0, 0x0, 0x0 },
{ 0x51, 0x0, 0x0, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x72, 0x4a, 0x44, 0x3a, 0x0, 0x0 },
{ 0x52, 0x0, 0x0, 0xfc, 0x42, 0x42, 0x42, 0x44, 0x78, 0x4c, 0x44, 0x44, 0x44, 0x44, 0xee, 0x0, 0x0 },
{ 0x53, 0x0, 0x0, 0x3a, 0x46, 0x42, 0x40, 0x20, 0x18, 0x4, 0x2, 0x42, 0x42, 0x62, 0x5c, 0x0, 0x0 },
{ 0x54, 0x0, 0x0, 0xfe, 0x92, 0x92, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x0, 0x0 },
{ 0x55, 0x0, 0x0, 0xee, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x38, 0x0, 0x0 },
{ 0x56, 0x0, 0x0, 0xee, 0x44, 0x44, 0x44, 0x44, 0x44, 0x28, 0x28, 0x28, 0x10, 0x10, 0x10, 0x0, 0x0 },
{ 0x57, 0x0, 0x0, 0xee, 0x44, 0x44, 0x44, 0x44, 0x54, 0x54, 0x7c, 0x6c, 0x6c, 0x44, 0x44, 0x0, 0x0 },
{ 0x58, 0x0, 0x0, 0xee, 0x44, 0x44, 0x28, 0x28, 0x10, 0x10, 0x28, 0x28, 0x44, 0x44, 0xee, 0x0, 0x0 },
{ 0x59, 0x0, 0x0, 0xee, 0x44, 0x44, 0x44, 0x28, 0x28, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x0, 0x0 },
{ 0x5a, 0x0, 0x0, 0xfe, 0x82, 0x82, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x82, 0x82, 0xfe, 0x0, 0x0 },
{ 0x5b, 0x0, 0x0, 0x1c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1c, 0x0, 0x0 },
{ 0x5c, 0x0, 0x0, 0x80, 0x40, 0x40, 0x20, 0x20, 0x10, 0x10, 0x8,  0x8,  0x4,  0x4,  0x2,  0x0, 0x0},
{ 0x5d, 0x0, 0x0, 0x38, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x38, 0x0, 0x0 },
{ 0x5e, 0x0, 0x0, 0x18, 0x24, 0x42, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0x5f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x0 },
{ 0x60, 0x0, 0x0, 0x30, 0x30, 0x20, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0x61, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x38, 0x44, 0x4, 0x3c, 0x44, 0x44, 0x4c, 0x36, 0x0, 0x0 },
{ 0x62, 0x0, 0x0, 0xc0, 0x40, 0x40, 0x40, 0x58, 0x64, 0x42, 0x42, 0x42, 0x42, 0x64, 0xd8, 0x0, 0x0 },
{ 0x63, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x38, 0x44, 0x44, 0x40, 0x40, 0x44, 0x44, 0x38, 0x0, 0x0 },
{ 0x64, 0x0, 0x0, 0xc, 0x4, 0x4, 0x4, 0x34, 0x4c, 0x44, 0x44, 0x44, 0x44, 0x4c, 0x36, 0x0, 0x0 },
{ 0x65, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x38, 0x44, 0x44, 0x7c, 0x40, 0x44, 0x44, 0x38, 0x0, 0x0 },
{ 0x66, 0x0, 0x0, 0xc, 0x12, 0x10, 0x10, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x0, 0x0 },
{ 0x67, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x44, 0x44, 0x44, 0x4c, 0x34, 0x4, 0x44, 0x44, 0x38 },
{ 0x68, 0x0, 0x0, 0xc0, 0x40, 0x40, 0x40, 0x58, 0x64, 0x44, 0x44, 0x44, 0x44, 0x44, 0xee, 0x0, 0x0 },
{ 0x69, 0x0, 0x0, 0x0, 0x10, 0x10, 0x0, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x0, 0x0 },
{ 0x6a, 0x0, 0x0, 0x0, 0x8, 0x8, 0x0, 0x38, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x48, 0x48, 0x30 },
{ 0x6b, 0x0, 0x0, 0xc0, 0x40, 0x40, 0x40, 0x40, 0x4c, 0x48, 0x50, 0x60, 0x50, 0x48, 0xee, 0x0, 0x0 },
{ 0x6c, 0x0, 0x0, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x0, 0x0 },
{ 0x6d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe8, 0x54, 0x54, 0x54, 0x54, 0x54, 0x54, 0xd6, 0x0, 0x0 },
{ 0x6e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xd8, 0x64, 0x44, 0x44, 0x44, 0x44, 0x44, 0xee, 0x0, 0x0 },
{ 0x6f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x0, 0x0 },
{ 0x70, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7c, 0x22, 0x22, 0x22, 0x22, 0x3c, 0x20, 0x20, 0x20, 0x70 },
{ 0x71, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x44, 0x44, 0x44, 0x44, 0x3c, 0x4, 0x4, 0x4, 0xe },
{ 0x72, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6c, 0x32, 0x22, 0x20, 0x20, 0x20, 0x20, 0x70, 0x0, 0x0 },
{ 0x73, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3c, 0x42, 0x42, 0x30, 0xc, 0x42, 0x42, 0x3c, 0x0, 0x0 },
{ 0x74, 0x0, 0x0, 0x0, 0x10, 0x10, 0x10, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x12, 0x12, 0xc, 0x0, 0x0 },
{ 0x75, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xcc, 0x44, 0x44, 0x44, 0x44, 0x44, 0x4c, 0x36, 0x0, 0x0 },
{ 0x76, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xee, 0x44, 0x44, 0x44, 0x28, 0x28, 0x10, 0x10, 0x0, 0x0 },
{ 0x77, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc6, 0x44, 0x44, 0x54, 0x54, 0x54, 0x6c, 0x44, 0x0, 0x0 },
{ 0x78, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc6, 0x44, 0x28, 0x10, 0x10, 0x28, 0x44, 0xc6, 0x0, 0x0 },
{ 0x79, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xee, 0x44, 0x44, 0x24, 0x28, 0x18, 0x8, 0x10, 0x90, 0x60 },
{ 0x7a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7e, 0x42, 0x4, 0x8, 0x10, 0x20, 0x42, 0x7e, 0x0, 0x0 },
{ 0x7b, 0x0, 0x0, 0xc, 0x10, 0x10, 0x10, 0x10, 0x20, 0x10, 0x10, 0x10, 0x10, 0x10, 0xc, 0x0, 0x0 },
{ 0x7c, 0x0, 0x0, 0x0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x0, 0x0 },
{ 0x7d, 0x0, 0x0, 0x30, 0x8, 0x8, 0x8, 0x8, 0x4, 0x8, 0x8, 0x8, 0x8, 0x8, 0x30, 0x0, 0x0 },
{ 0x7e, 0x0, 0x0, 0x32, 0x4c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0xa1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x30, 0x48, 0x48, 0x30 },
{ 0xa2, 0x3e, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0xa3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x3e },
{ 0xa4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x30, 0x10 },
{ 0xa5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x18, 0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0xa6, 0x0, 0x0, 0x7e, 0x2, 0x2, 0x2, 0x7e, 0x2, 0x2, 0x2, 0x4, 0x4, 0x8, 0x10, 0x60, 0x0 },
{ 0xa7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7e, 0x2, 0x14, 0x18, 0x10, 0x10, 0x10, 0x20, 0x20, 0x40, 0x0 },
{ 0xa8, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x4, 0x8, 0x18, 0x68, 0x8, 0x8, 0x8, 0x8, 0x8, 0x0 },
{ 0xa9, 0x0, 0x0, 0x0, 0x0, 0x8, 0x8, 0x8, 0x7f, 0x41, 0x41, 0x1, 0x2, 0x2, 0x4, 0x18, 0x0 },
{ 0xaa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3e, 0x8, 0x8, 0x8, 0x8, 0x8, 0x7f, 0x0, 0x0, 0x0 },
{ 0xab, 0x0, 0x0, 0x0, 0x0, 0x4, 0x4, 0x4, 0x7f, 0x4, 0xc, 0x14, 0x24, 0x44, 0x4, 0xc, 0x0 },
{ 0xac, 0x0, 0x0, 0x0, 0x0, 0x20, 0x20, 0x27, 0x79, 0x12, 0x12, 0x10, 0x8, 0x8, 0x8, 0x8, 0x0 },
{ 0xad, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3c, 0x4, 0x4, 0x4, 0x4, 0x4, 0x7f, 0x0, 0x0, 0x0 },
{ 0xae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7e, 0x2, 0x2, 0x7e, 0x2, 0x2, 0x7e, 0x0, 0x0, 0x0 },
{ 0xaf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x9, 0x49, 0x21, 0x21, 0x2, 0x2, 0x4, 0x8, 0x30, 0x0 },
{ 0xb0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x3f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0xb1, 0x0, 0x0, 0x7f, 0x1, 0x9, 0xa, 0xa, 0x8, 0x8, 0x8, 0x8, 0x10, 0x10, 0x20, 0x20, 0x0 },
{ 0xb2, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x4, 0xc, 0x14, 0x64, 0x4, 0x4, 0x4, 0x4, 0x4, 0x0 },
{ 0xb3, 0x0, 0x8, 0x8, 0x8, 0x7f, 0x41, 0x41, 0x41, 0x1, 0x1, 0x1, 0x2, 0x2, 0x4, 0x18, 0x0 },
{ 0xb4, 0x0, 0x0, 0x0, 0x3e, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x7f, 0x0, 0x0, 0x0 },
{ 0xb5, 0x0, 0x4, 0x4, 0x4, 0x7f, 0xc, 0xc, 0x14, 0x14, 0x14, 0x24, 0x24, 0x44, 0x4, 0xc, 0x0 },
{ 0xb6, 0x0, 0x8, 0x8, 0x8, 0x7f, 0x9, 0x9, 0x9, 0x9, 0x11, 0x11, 0x11, 0x22, 0x22, 0x4c, 0x0 },
{ 0xb7, 0x0, 0x10, 0x10, 0x10, 0x1e, 0x68, 0x8, 0x8, 0xf, 0x78, 0x4, 0x4, 0x4, 0x4, 0x4, 0x0 },
{ 0xb8, 0x0, 0x8, 0x8, 0x1f, 0x11, 0x11, 0x21, 0x41, 0x2, 0x2, 0x4, 0x4, 0x8, 0x10, 0x60, 0x0 },
{ 0xb9, 0x0, 0x20, 0x20, 0x20, 0x3f, 0x24, 0x24, 0x44, 0x4, 0x4, 0x4, 0x8, 0x8, 0x10, 0x20, 0x0 },
{ 0xba, 0x0, 0x0, 0x0, 0x7e, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x7e, 0x0, 0x0, 0x0 },
{ 0xbb, 0x0, 0x24, 0x24, 0x24, 0x7f, 0x24, 0x24, 0x24, 0x24, 0x4, 0x4, 0x8, 0x8, 0x10, 0x20, 0x0 },
{ 0xbc, 0x0, 0x30, 0x8, 0x0, 0x0, 0x60, 0x11, 0x1, 0x1, 0x1, 0x2, 0x2, 0x4, 0x18, 0x60, 0x0 },
{ 0xbd, 0x0, 0x0, 0x7e, 0x2, 0x2, 0x4, 0x4, 0x4, 0x8, 0x8, 0x14, 0x12, 0x22, 0x21, 0x41, 0x0 },
{ 0xbe, 0x0, 0x10, 0x10, 0x10, 0x10, 0x17, 0x79, 0x11, 0x12, 0x12, 0x10, 0x10, 0x10, 0x8, 0x7, 0x0 },
{ 0xbf, 0x0, 0x2, 0x42, 0x22, 0x22, 0x2, 0x2, 0x2, 0x4, 0x4, 0x4, 0x8, 0x8, 0x10, 0x20, 0x0 },
{ 0xc0, 0x0, 0x20, 0x20, 0x3e, 0x22, 0x22, 0x5a, 0x46, 0x2, 0x2, 0x4, 0x4, 0x8, 0x10, 0x60, 0x0 },
{ 0xc1, 0x0, 0x2, 0x4, 0x38, 0x8, 0x8, 0x8, 0x7f, 0x8, 0x8, 0x8, 0x8, 0x10, 0x10, 0x60, 0x0 },
{ 0xc2, 0x0, 0x10, 0x9, 0x9, 0x49, 0x21, 0x21, 0x1, 0x2, 0x2, 0x4, 0x4, 0x8, 0x10, 0x20, 0x0 },
{ 0xc3, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x0, 0x7f, 0x8, 0x8, 0x8, 0x8, 0x8, 0x10, 0x10, 0x20, 0x0 },
{ 0xc4, 0x0, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1c, 0x12, 0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x0 },
{ 0xc5, 0x0, 0x8, 0x8, 0x8, 0x8, 0x7f, 0x8, 0x8, 0x8, 0x8, 0x8, 0x10, 0x10, 0x20, 0x40, 0x0 },
{ 0xc6, 0x0, 0x0, 0x0, 0x3e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0x0, 0x0, 0x0 },
{ 0xc7, 0x0, 0x0, 0x3f, 0x1, 0x1, 0x2, 0x22, 0x1a, 0x4, 0x6, 0xa, 0x9, 0x11, 0x21, 0x40, 0x0 },
{ 0xc8, 0x0, 0x8, 0x8, 0x8, 0x7f, 0x2, 0x4, 0x4, 0xa, 0x19, 0x29, 0x48, 0x8, 0x8, 0x8, 0x0 },
{ 0xc9, 0x0, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x4, 0x4, 0x4, 0x8, 0x8, 0x10, 0x20, 0x40, 0x0 },
{ 0xca, 0x0, 0x0, 0x12, 0x12, 0x12, 0x12, 0x12, 0x11, 0x11, 0x21, 0x21, 0x21, 0x21, 0x41, 0x41, 0x0 },
{ 0xcb, 0x0, 0x20, 0x20, 0x20, 0x20, 0x20, 0x23, 0x3c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x10, 0xf, 0x0 },
{ 0xcc, 0x0, 0x0, 0x7e, 0x2, 0x2, 0x2, 0x2, 0x2, 0x4, 0x4, 0x4, 0x8, 0x8, 0x10, 0x20, 0x0 },
{ 0xcd, 0x0, 0x0, 0x10, 0x28, 0x28, 0x44, 0x44, 0x4, 0x2, 0x2, 0x2, 0x1, 0x1, 0x1, 0x0, 0x0 },
{ 0xce, 0x0, 0x8, 0x8, 0x8, 0x7f, 0x8, 0x8, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x8, 0x8, 0x0 },
{ 0xcf, 0x0, 0x0, 0x7e, 0x2, 0x2, 0x2, 0x4, 0x44, 0x28, 0x10, 0x10, 0x8, 0x8, 0x8, 0x8, 0x0 },
{ 0xd0, 0x0, 0x0, 0x38, 0x6, 0x1, 0x0, 0x30, 0xc, 0x2, 0x0, 0x70, 0xc, 0x2, 0x1, 0x0, 0x0 },
{ 0xd1, 0x0, 0x8, 0x8, 0x8, 0x8, 0x8, 0x10, 0x10, 0x10, 0x12, 0x22, 0x21, 0x27, 0x59, 0x61, 0x0 },
{ 0xd2, 0x0, 0x1, 0x1, 0x1, 0x2, 0x32, 0xa, 0x4, 0x6, 0xa, 0x9, 0x11, 0x11, 0x20, 0x40, 0x0 },
{ 0xd3, 0x0, 0x0, 0x3e, 0x8, 0x8, 0x8, 0x8, 0x7f, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x7, 0x0 },
{ 0xd4, 0x0, 0x20, 0x20, 0x23, 0x1d, 0x71, 0x12, 0x12, 0x8, 0x8, 0x8, 0x4, 0x4, 0x4, 0x4, 0x0 },
{ 0xd5, 0x0, 0x0, 0x0, 0x3c, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x7f, 0x0, 0x0, 0x0 },
{ 0xd6, 0x0, 0x0, 0x0, 0x7e, 0x2, 0x2, 0x2, 0x7e, 0x2, 0x2, 0x2, 0x2, 0x7e, 0x0, 0x0, 0x0 },
{ 0xd7, 0x0, 0x0, 0x3c, 0x0, 0x0, 0x0, 0x7e, 0x2, 0x2, 0x2, 0x4, 0x4, 0x8, 0x10, 0x20, 0x0 },
{ 0xd8, 0x0, 0x0, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x2, 0x2, 0x4, 0x4, 0x8, 0x10, 0x0 },
{ 0xd9, 0x0, 0x0, 0x8, 0x28, 0x28, 0x28, 0x28, 0x29, 0x29, 0x29, 0x2a, 0x2a, 0x4c, 0x4c, 0x48, 0x0 },
{ 0xda, 0x0, 0x0, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21, 0x21, 0x21, 0x22, 0x22, 0x24, 0x28, 0x30, 0x0 },
{ 0xdb, 0x0, 0x0, 0x0, 0x7e, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7e, 0x42, 0x0, 0x0 },
{ 0xdc, 0x0, 0x0, 0x7e, 0x42, 0x42, 0x42, 0x42, 0x2, 0x4, 0x4, 0x4, 0x8, 0x8, 0x10, 0x20, 0x0 },
{ 0xdd, 0x0, 0x0, 0x60, 0x10, 0x0, 0x1, 0x1, 0x1, 0x2, 0x2, 0x2, 0x4, 0x8, 0x10, 0x60, 0x0 },
{ 0xde, 0x0, 0x0, 0x8, 0x24, 0x12, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
{ 0xdf, 0x0, 0x0, 0x18, 0x24, 0x24, 0x18, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
};

unsigned char DBCSImage[MAX_DBCS_NUM][MAX_DBCS_BYTES] = { 
{0xA1,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x41,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x80,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x80,0x00,0xC0,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x43,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x02,0x40,0x02,0x40,0x02,0x40,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x45,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x03,0xC0,0x03,0xC0,0x03,0xC0,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x46,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x80,0x01,0x00,0x00,0x00},
{0xA1,0x47,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x48,0x00,0x00,0x00,0x00,0x03,0xC0,0x04,0x30,0x04,0x10,0x00,0x30,0x00,0x20,0x00,0x60,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00},
{0xA1,0x49,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00},
{0xA1,0x4A,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x4B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x31,0x86,0x31,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x4C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x4D,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x18,0x00,0x08,0x00,0x00,0x00},
{0xA1,0x4E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x08,0x00,0x04,0x00,0x00,0x00},
{0xA1,0x4F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x51,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x08,0x00,0x10,0x00,0x00,0x00},
{0xA1,0x52,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x53,0x00,0x00,0x00,0x00,0x1C,0x00,0x22,0x00,0x61,0x00,0x01,0x00,0x02,0x00,0x04,0x00,0x08,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x54,0x00,0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x55,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00},
{0xA1,0x56,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x57,0x00,0x00,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x00},
{0xA1,0x58,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x59,0x00,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x00,0x00},
{0xA1,0x5A,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x00,0x66,0x00,0x66,0x00,0x06,0x00,0x0C,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x5B,0x08,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x08,0x00,0x08,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x08,0x00},
{0xA1,0x5C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8E,0x31,0x71,0xCE,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x5D,0x00,0x00,0x00,0x08,0x00,0x10,0x00,0x10,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x10,0x00,0x10,0x00,0x08},
{0xA1,0x5E,0x00,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x04,0x00,0x04,0x00,0x08,0x00},
{0xA1,0x5F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xF8,0x30,0x06,0x40,0x01,0x00,0x00,0x00,0x00},
{0xA1,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x01,0x30,0x06,0x0F,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x61,0x00,0x00,0x00,0x04,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x30,0x00,0x10,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x04},
{0xA1,0x62,0x00,0x00,0x10,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x06,0x00,0x04,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x10,0x00},
{0xA1,0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0xC0,0x3F,0x3E,0x40,0x01,0x00,0x00,0x00,0x00},
{0xA1,0x64,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x3E,0x7C,0x01,0x80,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x65,0x00,0x00,0x00,0x08,0x00,0x30,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x30,0x00,0x08},
{0xA1,0x66,0x00,0x00,0x08,0x00,0x06,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x06,0x00,0x08,0x00},
{0xA1,0x67,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFC,0x20,0x02,0x20,0x02,0x40,0x01,0x00,0x00,0x00,0x00},
{0xA1,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x01,0x20,0x02,0x20,0x02,0x1F,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x69,0x00,0x00,0x00,0x7C,0x00,0x78,0x00,0x60,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x60,0x00,0x78,0x00,0x7C},
{0xA1,0x6A,0x00,0x00,0x1F,0x00,0x0F,0x00,0x03,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x0F,0x00,0x1F,0x00},
{0xA1,0x6B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0x70,0x07,0x60,0x03,0x60,0x03,0x40,0x01,0x00,0x00,0x00,0x00},
{0xA1,0x6C,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x01,0x40,0x03,0x60,0x03,0x70,0x07,0x7F,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x6D,0x00,0x00,0x00,0x0A,0x00,0x0A,0x00,0x14,0x00,0x14,0x00,0x28,0x00,0x28,0x00,0x50,0x00,0x50,0x00,0x50,0x00,0x28,0x00,0x28,0x00,0x14,0x00,0x14,0x00,0x0A,0x00,0x0A},
{0xA1,0x6E,0x00,0x00,0x28,0x00,0x28,0x00,0x14,0x00,0x14,0x00,0x0A,0x00,0x0A,0x00,0x05,0x00,0x05,0x00,0x05,0x00,0x0A,0x00,0x0A,0x00,0x14,0x00,0x14,0x00,0x28,0x00,0x28,0x00},
{0xA1,0x6F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xC0,0x06,0x30,0x19,0xCC,0x66,0x33,0x18,0x0C,0x60,0x03,0x00,0x00,0x00,0x00},
{0xA1,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x03,0x18,0x0C,0x66,0x33,0x19,0xCC,0x06,0x30,0x01,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x71,0x00,0x00,0x00,0x04,0x00,0x04,0x00,0x08,0x00,0x08,0x00,0x10,0x00,0x10,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x10,0x00,0x10,0x00,0x08,0x00,0x08,0x00,0x04,0x00,0x04},
{0xA1,0x72,0x00,0x00,0x10,0x00,0x10,0x00,0x08,0x00,0x08,0x00,0x04,0x00,0x04,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x04,0x00,0x04,0x00,0x08,0x00,0x08,0x00,0x10,0x00,0x10,0x00},
{0xA1,0x73,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xC0,0x06,0x30,0x18,0x0C,0x60,0x03,0x00,0x00,0x00,0x00},
{0xA1,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x03,0x18,0x0C,0x06,0x30,0x01,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x75,0x00,0x00,0x00,0x7C,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x76,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x1F,0x00},
{0xA1,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x7F,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x79,0x00,0x00,0x00,0x7C,0x00,0x7C,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x7A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x1F,0x00,0x1F,0x00},
{0xA1,0x7B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0xFF,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00},
{0xA1,0x7C,0x00,0x00,0x00,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x7F,0x80,0x7F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x7D,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x80,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x80,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x02,0x00,0x01,0x00,0x01,0x00,0x00,0x80,0x00,0x80,0x01,0x00,0x01,0x00,0x02,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xA1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x03,0x00,0x01,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x40,0x00,0x00,0x00,0x00},
{0xA1,0xA2,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x80,0x00,0xC0,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xA3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x01,0x00,0x00,0x80,0x00,0x00,0x00,0x00},
{0xA1,0xA4,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x40,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x40,0x00,0x80,0x00,0x00,0x00,0x00},
{0xA1,0xA5,0x00,0x00,0x00,0x02,0x00,0x04,0x00,0x06,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xA6,0x00,0x00,0x60,0x00,0x60,0x00,0x20,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xA7,0x00,0x00,0x00,0x12,0x00,0x24,0x00,0x36,0x00,0x36,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xA8,0x00,0x00,0x36,0x00,0x36,0x00,0x12,0x00,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xA9,0x00,0x00,0x00,0xD8,0x00,0x6C,0x00,0x24,0x00,0x12,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xAA,0x00,0x00,0x0D,0x80,0x1B,0x00,0x14,0x00,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xAB,0x00,0x00,0x06,0x00,0x03,0x80,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xAC,0x00,0x00,0x00,0x60,0x01,0xC0,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xAD,0x00,0x00,0x02,0x20,0x02,0x20,0x02,0x20,0x1F,0xFC,0x1F,0xFC,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x3F,0xF8,0x3F,0xF8,0x08,0x40,0x08,0x40,0x08,0x40,0x00,0x00},
{0xA1,0xAE,0x00,0x00,0x03,0x80,0x04,0x40,0x08,0x40,0x0C,0x40,0x0C,0x80,0x07,0x00,0x0E,0x3C,0x12,0x10,0x21,0x10,0x21,0x90,0x20,0xA0,0x30,0x62,0x18,0xB4,0x0F,0x18,0x00,0x00},
{0xA1,0xAF,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0xC0,0x30,0xC6,0x38,0xC6,0x0C,0x8C,0x02,0xB0,0x01,0xC0,0x06,0xB0,0x18,0x8C,0x31,0x86,0x31,0x86,0x01,0x80,0x00,0x80,0x00,0x00},
{0xA1,0xB0,0x00,0x00,0x00,0x00,0x20,0x04,0x11,0x88,0x09,0x90,0x04,0x20,0x02,0x40,0x19,0x98,0x19,0x98,0x02,0x40,0x04,0x20,0x09,0x90,0x11,0x88,0x20,0x04,0x00,0x00,0x00,0x00},
{0xA1,0xB1,0x00,0x00,0x01,0x80,0x02,0x40,0x02,0x00,0x01,0x00,0x00,0xC0,0x01,0x60,0x02,0x20,0x02,0x20,0x01,0x40,0x00,0x80,0x00,0x40,0x00,0x20,0x03,0x20,0x02,0x40,0x01,0x80},
{0xA1,0xB2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x60,0x02,0x40,0x02,0x40,0x02,0x40,0x04,0x80,0x04,0x80,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xB3,0x00,0x00,0x03,0xE0,0x0C,0x18,0x10,0x04,0x10,0x04,0x20,0x02,0x20,0x02,0x40,0x01,0x40,0x01,0x40,0x01,0x20,0x02,0x20,0x02,0x10,0x04,0x10,0x04,0x0C,0x18,0x03,0xE0},
{0xA1,0xB4,0x00,0x00,0x03,0xE0,0x0F,0xF8,0x1F,0xFC,0x1F,0xFC,0x3F,0xFE,0x3F,0xFE,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x3F,0xFE,0x3F,0xFE,0x1F,0xFC,0x1F,0xFC,0x0F,0xF8,0x03,0xE0},
{0xA1,0xB5,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x80,0x01,0x40,0x01,0x40,0x02,0x20,0x04,0x10,0x04,0x10,0x08,0x08,0x08,0x08,0x10,0x04,0x10,0x04,0x20,0x02,0x7F,0xFF,0x00,0x00},
{0xA1,0xB6,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x80,0x01,0xC0,0x01,0xC0,0x03,0xE0,0x07,0xF0,0x07,0xF0,0x0F,0xF8,0x0F,0xF8,0x1F,0xFC,0x1F,0xFC,0x3F,0xFE,0x7F,0xFF,0x00,0x00},
{0xA1,0xB7,0x00,0x00,0x03,0xE0,0x0C,0x18,0x10,0x04,0x11,0xC4,0x22,0x22,0x22,0x22,0x44,0x11,0x44,0x11,0x44,0x11,0x22,0x22,0x22,0x22,0x11,0xC4,0x10,0x04,0x0C,0x18,0x03,0xE0},
{0xA1,0xB8,0x00,0x00,0x00,0x80,0x00,0x80,0x01,0x40,0x01,0x20,0x02,0x10,0x7C,0x1F,0x10,0x04,0x08,0x08,0x04,0x10,0x04,0x90,0x09,0x48,0x0A,0x28,0x1C,0x1C,0x10,0x04,0x00,0x00},
{0xA1,0xB9,0x00,0x00,0x00,0x80,0x00,0x80,0x01,0xC0,0x01,0xE0,0x03,0xF0,0x7F,0xFF,0x1F,0xFC,0x0F,0xF8,0x07,0xF0,0x07,0xF0,0x0F,0x78,0x0E,0x38,0x1C,0x1C,0x10,0x04,0x00,0x00},
{0xA1,0xBA,0x00,0x00,0x00,0x00,0x00,0xC0,0x01,0x20,0x02,0x10,0x04,0x08,0x08,0x04,0x10,0x02,0x20,0x01,0x10,0x02,0x08,0x04,0x04,0x08,0x02,0x10,0x01,0x20,0x00,0xC0,0x00,0x00},
{0xA1,0xBB,0x00,0x00,0x00,0x00,0x00,0xC0,0x01,0xE0,0x03,0xF0,0x07,0xF8,0x0F,0xFC,0x1F,0xFE,0x3F,0xFF,0x1F,0xFE,0x0F,0xFC,0x07,0xF8,0x03,0xF0,0x01,0xE0,0x00,0xC0,0x00,0x00},
{0xA1,0xBC,0x00,0x00,0x7F,0xFE,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x7F,0xFE,0x00,0x00},
{0xA1,0xBD,0x00,0x00,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x7F,0xFE,0x00,0x00},
{0xA1,0xBE,0x00,0x00,0x00,0x00,0x7F,0xFF,0x20,0x02,0x10,0x04,0x10,0x04,0x08,0x08,0x08,0x08,0x04,0x10,0x04,0x10,0x02,0x20,0x01,0x40,0x01,0x40,0x00,0x80,0x00,0x80,0x00,0x00},
{0xA1,0xBF,0x00,0x00,0x00,0x00,0x7F,0xFF,0x3F,0xFE,0x1F,0xFC,0x1F,0xFC,0x0F,0xF8,0x0F,0xF8,0x07,0xF0,0x07,0xF0,0x03,0xE0,0x01,0xC0,0x01,0xC0,0x00,0x80,0x00,0x80,0x00,0x00},
{0xA1,0xC0,0x00,0x00,0x03,0xE0,0x0C,0x18,0x10,0x04,0x17,0xF4,0x20,0x82,0x20,0x82,0x46,0xA1,0x44,0xF1,0x44,0x81,0x24,0x82,0x24,0x92,0x1F,0xFC,0x10,0x04,0x0C,0x18,0x03,0xE0},
{0xA1,0xC1,0x00,0x00,0x1C,0x03,0x22,0x04,0x46,0x08,0x40,0x10,0x40,0x20,0x42,0x40,0x22,0x80,0x1D,0x38,0x02,0x44,0x04,0x82,0x08,0x82,0x10,0x82,0x20,0x82,0x40,0x44,0x00,0x38},
{0xA1,0xC2,0x00,0x00,0x7F,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xC3,0x00,0x00,0x7F,0xFF,0x7F,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xC4,0x00,0x00,0x00,0xFF,0x00,0xFF,0x3C,0x00,0x66,0x00,0x66,0x00,0x06,0x00,0x0C,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xC5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0x7F,0xFF},
{0xA1,0xC6,0x00,0x00,0x71,0xC7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xC7,0x00,0x00,0x7C,0x9F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xC8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x71,0xC7,0x00,0x00},
{0xA1,0xC9,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x9F,0x00,0x00},
{0xA1,0xCA,0x00,0x00,0x1C,0x1C,0x22,0x22,0x41,0xC1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xCB,0x00,0x00,0x1C,0x1C,0x22,0x22,0x41,0xC1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xCC,0x00,0x00,0x12,0x00,0x12,0x00,0x12,0x00,0x7F,0x00,0x7F,0x00,0x24,0x00,0x24,0x00,0x24,0x00,0x24,0x00,0x7F,0x00,0x7F,0x00,0x24,0x00,0x24,0x00,0x24,0x00,0x00,0x00},
{0xA1,0xCD,0x00,0x00,0x10,0x00,0x28,0x00,0x28,0x00,0x28,0x00,0x28,0x00,0x10,0x00,0x36,0x00,0x52,0x00,0x52,0x00,0x4C,0x00,0x4C,0x00,0x48,0x00,0x2E,0x00,0x10,0x00,0x00,0x00},
{0xA1,0xCE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x49,0x00,0x6B,0x00,0x2A,0x00,0x1C,0x00,0x2A,0x00,0x6B,0x00,0x49,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xCF,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x1F,0xFC,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00,0x00,0x00},
{0xA1,0xD0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xD1,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x08,0x08,0x10,0x04,0x20,0x02,0x40,0x01,0x80,0x01,0x80,0x02,0x40,0x04,0x20,0x08,0x10,0x10,0x08,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xD2,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xD3,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x1F,0xFC,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00,0x1F,0xFC,0x00,0x00,0x00,0x00},
{0xA1,0xD4,0x00,0x3F,0x00,0x40,0x00,0x40,0x00,0x80,0x00,0x80,0x01,0x00,0x01,0x00,0x02,0x00,0x02,0x00,0x24,0x00,0xE4,0x00,0x28,0x00,0x38,0x00,0x10,0x00,0x10,0x00,0x00,0x00},
{0xA1,0xD5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x30,0x00,0xC0,0x03,0x00,0x0C,0x00,0x30,0x00,0x0C,0x00,0x03,0x00,0x00,0xC0,0x00,0x30,0x00,0x0C,0x00,0x00,0x00,0x00},
{0xA1,0xD6,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x0C,0x00,0x03,0x00,0x00,0xC0,0x00,0x30,0x00,0x0C,0x00,0x30,0x00,0xC0,0x03,0x00,0x0C,0x00,0x30,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xD7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xD8,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0x70,0x03,0x80,0x0C,0x00,0x30,0x00,0x0C,0x00,0x03,0x80,0x00,0x70,0x00,0x0C,0x00,0x00,0x3F,0xFC,0x00,0x00,0x3F,0xFC,0x00,0x00},
{0xA1,0xD9,0x00,0x00,0x00,0x00,0x30,0x00,0x0E,0x00,0x01,0xC0,0x00,0x30,0x00,0x0C,0x00,0x30,0x01,0xC0,0x0E,0x00,0x30,0x00,0x00,0x00,0x3F,0xFC,0x00,0x00,0x3F,0xFC,0x00,0x00},
{0xA1,0xDA,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x1F,0xF8,0x01,0x00,0x01,0x00,0x01,0x00,0x1F,0xF8,0x02,0x00,0x02,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xDB,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x1C,0x22,0x22,0x41,0x41,0x40,0x81,0x40,0x81,0x41,0x41,0x22,0x22,0x1C,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xDC,0x00,0x00,0x00,0x00,0x06,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x60,0x00,0x00,0x00,0x00},
{0xA1,0xDD,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x00,0x00,0x00,0x3F,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xDE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x7C,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xDF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x18,0x00,0x60,0x00,0x18,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xE1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x18,0x00,0x06,0x00,0x18,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xE2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xE3,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x00,0x23,0x01,0x40,0xC2,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xE4,0x00,0x00,0x00,0x00,0x07,0xE0,0x08,0x10,0x08,0x10,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x00,0x00,0x00,0x00},
{0xA1,0xE5,0x00,0x00,0x00,0x00,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x08,0x10,0x08,0x10,0x07,0xE0,0x00,0x00,0x00,0x00},
{0xA1,0xE6,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x3F,0xFC,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xE7,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x08,0x00,0x10,0x00,0x20,0x00,0x40,0x00,0x80,0x01,0x00,0x02,0x00,0x04,0x00,0x08,0x00,0x10,0x00,0x3F,0xFC,0x00,0x00,0x00,0x00},
{0xA1,0xE8,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x1F,0xFC,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xE9,0x00,0x00,0x00,0x08,0x00,0x18,0x00,0x28,0x00,0x48,0x00,0x88,0x01,0x08,0x02,0x08,0x04,0x08,0x08,0x08,0x10,0x08,0x20,0x08,0x7F,0xF8,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xEA,0x00,0x00,0x00,0x00,0x60,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x23,0x1B,0x24,0xA4,0x24,0xA4,0x24,0xA4,0x24,0x98,0x24,0xB0,0x24,0x9C,0x73,0x22,0x00,0x22,0x00,0x1C},
{0xA1,0xEB,0x00,0x00,0x00,0x00,0x38,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x09,0xB8,0x08,0xC4,0x08,0x84,0x08,0x84,0x08,0x84,0x08,0x84,0x3D,0xCE,0x00,0x00,0x00,0x00},
{0xA1,0xEC,0x00,0x00,0x01,0xC0,0x02,0x20,0x02,0x60,0x02,0x00,0x01,0x00,0x01,0x00,0x00,0x80,0x00,0x80,0x00,0x40,0x00,0x40,0x00,0x20,0x03,0x20,0x02,0x20,0x01,0xC0,0x00,0x00},
{0xA1,0xED,0x00,0x00,0x01,0xC0,0x02,0x20,0x02,0x60,0x01,0x00,0x03,0xC0,0x05,0x20,0x08,0x90,0x08,0x90,0x08,0x50,0x04,0x60,0x03,0xC0,0x00,0x20,0x03,0x20,0x01,0xC0,0x00,0x00},
{0xA1,0xEE,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x0C,0x30,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00},
{0xA1,0xEF,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x0C,0x30,0x0C,0x00,0x00,0x00,0x00},
{0xA1,0xF0,0x00,0x00,0x01,0xC0,0x02,0x20,0x04,0x10,0x04,0x10,0x02,0x20,0x01,0xC0,0x00,0x80,0x00,0x80,0x1F,0xFC,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00},
{0xA1,0xF1,0x00,0x00,0x00,0x80,0x01,0xC0,0x02,0xA0,0x02,0xA0,0x04,0x90,0x00,0x80,0x00,0x80,0x00,0x80,0x01,0xC0,0x02,0x20,0x04,0x10,0x04,0x10,0x02,0x20,0x01,0xC0,0x00,0x00},
{0xA1,0xF2,0x00,0x00,0x00,0x00,0x03,0xE0,0x0C,0x98,0x10,0x84,0x10,0x84,0x20,0x82,0x3F,0xFE,0x20,0x82,0x20,0x82,0x10,0x84,0x10,0x84,0x0C,0x98,0x03,0xE0,0x00,0x00,0x00,0x00},
{0xA1,0xF3,0x00,0x00,0x00,0x00,0x03,0xC0,0x0C,0x30,0x10,0x08,0x10,0x08,0x20,0x04,0x21,0x84,0x21,0x84,0x20,0x04,0x10,0x08,0x10,0x08,0x0C,0x30,0x03,0xC0,0x00,0x00,0x00,0x00},
{0xA1,0xF4,0x00,0x00,0x00,0x80,0x01,0xC0,0x02,0xA0,0x04,0x90,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00},
{0xA1,0xF5,0x00,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x04,0x90,0x02,0xA0,0x01,0xC0,0x00,0x80,0x00,0x00},
{0xA1,0xF6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x10,0x00,0x20,0x00,0x7F,0xFF,0x20,0x00,0x10,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xF7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x04,0x00,0x02,0x7F,0xFF,0x00,0x02,0x00,0x04,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x00,0x18,0x00,0x14,0x00,0x12,0x00,0x01,0x00,0x00,0x80,0x00,0x40,0x00,0x20,0x00,0x10,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xF9,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x00,0x18,0x00,0x28,0x00,0x48,0x00,0x80,0x01,0x00,0x02,0x00,0x04,0x00,0x08,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xFA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x10,0x00,0x20,0x00,0x40,0x00,0x80,0x01,0x00,0x12,0x00,0x14,0x00,0x18,0x00,0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xFB,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x08,0x00,0x04,0x00,0x02,0x00,0x01,0x00,0x00,0x80,0x00,0x48,0x00,0x28,0x00,0x18,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA1,0xFC,0x00,0x00,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x00,0x00},
{0xA1,0xFD,0x00,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA1,0xFE,0x00,0x00,0x00,0x02,0x00,0x04,0x00,0x08,0x00,0x10,0x00,0x20,0x00,0x40,0x00,0x80,0x01,0x00,0x02,0x00,0x04,0x00,0x08,0x00,0x10,0x00,0x20,0x00,0x40,0x00,0x00,0x00},
{0xA2,0x40,0x00,0x00,0x40,0x00,0x20,0x00,0x10,0x00,0x08,0x00,0x04,0x00,0x02,0x00,0x01,0x00,0x00,0x80,0x00,0x40,0x00,0x20,0x00,0x10,0x00,0x08,0x00,0x04,0x00,0x02,0x00,0x00},
{0xA2,0x41,0x00,0x00,0x00,0x20,0x00,0x20,0x00,0x40,0x00,0x40,0x00,0x80,0x00,0x80,0x01,0x00,0x01,0x00,0x01,0x00,0x02,0x00,0x02,0x00,0x04,0x00,0x04,0x00,0x08,0x00,0x08,0x00},
{0xA2,0x42,0x00,0x00,0x04,0x00,0x04,0x00,0x02,0x00,0x02,0x00,0x01,0x00,0x01,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x20,0x00,0x10,0x00,0x10},
{0xA2,0x43,0x00,0x00,0x00,0x80,0x01,0xC0,0x02,0xA0,0x04,0x90,0x04,0xB0,0x04,0x80,0x02,0x80,0x01,0xC0,0x00,0xA0,0x00,0x90,0x06,0x90,0x04,0x90,0x04,0xA0,0x03,0xC0,0x00,0x80},
{0xA2,0x44,0x00,0x00,0x00,0x00,0x3E,0x3C,0x0C,0x10,0x04,0x10,0x06,0x20,0x3F,0xFC,0x01,0x40,0x01,0x80,0x3F,0xFC,0x00,0x80,0x00,0x80,0x00,0x80,0x03,0xE0,0x00,0x00,0x00,0x00},
{0xA2,0x45,0x00,0x00,0x7F,0xFE,0x7F,0xFE,0x00,0x00,0x00,0x00,0x7F,0xFE,0x7F,0xFE,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x00,0x00},
{0xA2,0x46,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x80,0x01,0xE0,0x02,0x90,0x04,0xB0,0x04,0x80,0x04,0x80,0x04,0x80,0x04,0x90,0x02,0x90,0x01,0xE0,0x00,0x80,0x00,0x80,0x00,0x00},
{0xA2,0x47,0x00,0x00,0x00,0x00,0x00,0xE0,0x01,0x30,0x02,0x30,0x02,0x00,0x02,0x00,0x03,0x00,0x1F,0xF0,0x01,0x00,0x01,0x00,0x1D,0x04,0x23,0x08,0x22,0xF0,0x1C,0x00,0x00,0x00},
{0xA2,0x48,0x00,0x00,0x1C,0x00,0x22,0x04,0x22,0x08,0x22,0x10,0x22,0x20,0x22,0x40,0x1C,0x80,0x01,0x38,0x02,0x44,0x04,0x44,0x08,0x44,0x10,0x44,0x20,0x44,0x00,0x38,0x00,0x00},
{0xA2,0x49,0x00,0x00,0x00,0x00,0x03,0xF0,0x04,0x08,0x08,0x04,0x11,0xD4,0x12,0x24,0x12,0x24,0x12,0x24,0x12,0x68,0x11,0xB0,0x08,0x04,0x04,0x08,0x03,0xF0,0x00,0x00,0x00,0x00},
{0xA2,0x4A,0x00,0x00,0x30,0x70,0x49,0x8A,0x4A,0x06,0x32,0x02,0x06,0x02,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x02,0x02,0x01,0x84,0x00,0x78,0x00,0x00,0x00,0x00},
{0xA2,0x4B,0x00,0x00,0x30,0x00,0x4B,0xFE,0x48,0x86,0x30,0x82,0x00,0x80,0x00,0x88,0x00,0xF8,0x00,0x88,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x07,0xF0,0x00,0x00,0x00,0x00},
{0xA2,0x4C,0x00,0x00,0x08,0x00,0x0C,0x00,0x1A,0x00,0x2A,0x00,0x2A,0x00,0x28,0x00,0x18,0x00,0x18,0x00,0x0C,0x00,0x0A,0x00,0x2A,0x00,0x2A,0x00,0x2A,0x00,0x1C,0x00,0x08,0x00},
{0xA2,0x4D,0x00,0x00,0x21,0x00,0x51,0x00,0x52,0x00,0x52,0x00,0x54,0x00,0x24,0x00,0x08,0x00,0x08,0x00,0x12,0x00,0x15,0x00,0x25,0x00,0x25,0x00,0x45,0x00,0x42,0x00,0x00,0x00},
{0xA2,0x4E,0x00,0x00,0x00,0x00,0x1C,0x00,0x22,0x00,0x22,0x00,0x49,0x00,0x55,0x00,0x55,0x00,0x55,0x00,0x55,0x00,0x4A,0x00,0x20,0x00,0x22,0x00,0x1C,0x00,0x00,0x00,0x00,0x00},
{0xA2,0x4F,0x00,0x00,0x00,0x00,0x00,0x16,0x00,0x02,0x00,0x02,0x00,0x02,0x5B,0x32,0x24,0x92,0x24,0x92,0x24,0x92,0x24,0x92,0x24,0x92,0x24,0x92,0x64,0xD7,0x00,0x00,0x00,0x00},
{0xA2,0x50,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x54,0x54,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x6B,0x6B,0x00,0x00,0x00,0x00},
{0xA2,0x51,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0xD4,0x22,0x2A,0x46,0x2A,0x40,0x2A,0x40,0x2A,0x40,0x2A,0x22,0x2A,0x1C,0x6B,0x00,0x00,0x00,0x00},
{0xA2,0x52,0x00,0x00,0x00,0x00,0x70,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x2E,0xD4,0x24,0x2A,0x28,0x2A,0x28,0x2A,0x34,0x2A,0x24,0x2A,0x22,0x2A,0x77,0x6B,0x00,0x00,0x00,0x00},
{0xA2,0x53,0x00,0x00,0x00,0x00,0x77,0x63,0x22,0x26,0x24,0x36,0x24,0x36,0x28,0x36,0x28,0x36,0x38,0x3A,0x24,0x2A,0x24,0x2A,0x22,0x2A,0x22,0x22,0x77,0x77,0x00,0x00,0x00,0x00},
{0xA2,0x54,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x09,0x00,0x02,0x00,0x04,0x5C,0xEF,0x23,0x10,0x22,0x10,0x22,0x10,0x22,0x10,0x22,0x10,0x22,0x10,0x77,0xB8,0x00,0x00,0x00,0x00},
{0xA2,0x55,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x54,0x3B,0x2A,0x44,0x2A,0x44,0x2A,0x44,0x2A,0x38,0x2A,0x60,0x2A,0x3C,0x6B,0x62,0x00,0x42,0x00,0x3C},
{0xA2,0x56,0x00,0x00,0x00,0x00,0x70,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x2E,0x3B,0x24,0x44,0x28,0x44,0x28,0x44,0x34,0x38,0x24,0x60,0x22,0x3C,0x77,0x62,0x00,0x42,0x00,0x3C},
{0xA2,0x57,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x1E,0x21,0x21,0x43,0x43,0x40,0x40,0x40,0x40,0x40,0x40,0x21,0x21,0x1E,0x1E,0x00,0x00,0x00,0x00},
{0xA2,0x58,0x00,0x00,0x18,0x00,0x24,0x00,0x24,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA2,0x59,0x00,0x00,0x0C,0x18,0x09,0x10,0x7F,0x90,0x08,0x10,0x08,0x14,0x3E,0xFE,0x22,0x10,0x22,0x10,0x22,0x10,0x3E,0x10,0x14,0x10,0x14,0x12,0x24,0x02,0x24,0x03,0x43,0xFE},
{0xA2,0x5A,0x00,0x00,0x0C,0x00,0x08,0x1C,0x7F,0x70,0x08,0x10,0x08,0x10,0x3E,0x14,0x22,0xFE,0x22,0x10,0x22,0x10,0x3E,0x10,0x14,0x12,0x14,0x12,0x24,0x12,0x24,0x03,0x43,0xFE},
{0xA2,0x5B,0x00,0x00,0x0C,0x10,0x08,0x38,0x7E,0xE0,0x08,0x20,0x08,0x3C,0x3E,0xE0,0x22,0x20,0x22,0x3C,0x22,0xE0,0x3E,0x24,0x14,0x24,0x14,0x1C,0x24,0x01,0x24,0x01,0x43,0xFF},
{0xA2,0x5C,0x00,0x00,0x0C,0x38,0x08,0x08,0x7F,0x64,0x08,0x44,0x08,0x42,0x3E,0x82,0x23,0x7D,0x22,0x24,0x22,0x24,0x3E,0x24,0x14,0x44,0x14,0x5D,0x24,0x89,0x24,0x01,0x43,0xFF},
{0xA2,0x5D,0x00,0x00,0x0C,0x04,0x08,0xFE,0x7F,0x10,0x08,0x20,0x08,0x7C,0x3E,0x44,0x22,0x44,0x22,0x7C,0x22,0x44,0x3E,0x44,0x14,0x7C,0x14,0x45,0x24,0x01,0x24,0x01,0x43,0xFF},
{0xA2,0x5E,0x00,0x00,0x0C,0x82,0x08,0xFF,0x7E,0x80,0x08,0xBE,0x08,0xAA,0x3E,0xBE,0x22,0xAA,0x22,0xBE,0x22,0x88,0x3E,0xBE,0x14,0x88,0x15,0x3E,0x25,0x01,0x24,0x01,0x43,0xFF},
{0xA2,0x5F,0x00,0x00,0x10,0x42,0x7E,0x7F,0x12,0x42,0x12,0x42,0x22,0x7E,0x2D,0x82,0x42,0x60,0x04,0x10,0x1B,0xEC,0x60,0x03,0x1F,0xFC,0x12,0x44,0x1F,0xFC,0x12,0x44,0x12,0x5C},
{0xA2,0x60,0x00,0x00,0x02,0x00,0x7F,0x0C,0x10,0x1E,0x10,0xF0,0x12,0x10,0x1E,0x10,0x12,0x12,0x12,0xFF,0x12,0x10,0x2A,0x10,0x2A,0x10,0x22,0x12,0x2E,0x12,0x72,0x03,0x21,0xFE},
{0xA2,0x61,0x00,0x00,0x0C,0x82,0x08,0xFF,0x4A,0x80,0x2A,0xBE,0x2C,0xAA,0x08,0xAA,0x7E,0xBE,0x18,0xAA,0x18,0xAA,0x2C,0xBE,0x2A,0x88,0x4A,0xBE,0x08,0x88,0x09,0x08,0x09,0x7F},
{0xA2,0x62,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0x00,0x00},
{0xA2,0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x00,0x00},
{0xA2,0x64,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x00,0x00},
{0xA2,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x00,0x00},
{0xA2,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x00,0x00},
{0xA2,0x67,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x00,0x00},
{0xA2,0x68,0x00,0x00,0x00,0x00,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x00,0x00},
{0xA2,0x69,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x00,0x00},
{0xA2,0x6A,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x00,0x00},
{0xA2,0x6B,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x00,0x00},
{0xA2,0x6C,0x7C,0x00,0x7C,0x00,0x7C,0x00,0x7C,0x00,0x7C,0x00,0x7C,0x00,0x7C,0x00,0x7C,0x00,0x7C,0x00,0x7C,0x00,0x7C,0x00,0x7C,0x00,0x7C,0x00,0x7C,0x00,0x7C,0x00,0x00,0x00},
{0xA2,0x6D,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x7F,0x00,0x00,0x00},
{0xA2,0x6E,0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,0x00,0x00},
{0xA2,0x6F,0x7F,0xF0,0x7F,0xF0,0x7F,0xF0,0x7F,0xF0,0x7F,0xF0,0x7F,0xF0,0x7F,0xF0,0x7F,0xF0,0x7F,0xF0,0x7F,0xF0,0x7F,0xF0,0x7F,0xF0,0x7F,0xF0,0x7F,0xF0,0x7F,0xF0,0x00,0x00},
{0xA2,0x70,0x7F,0xFC,0x7F,0xFC,0x7F,0xFC,0x7F,0xFC,0x7F,0xFC,0x7F,0xFC,0x7F,0xFC,0x7F,0xFC,0x7F,0xFC,0x7F,0xFC,0x7F,0xFC,0x7F,0xFC,0x7F,0xFC,0x7F,0xFC,0x7F,0xFC,0x00,0x00},
{0xA2,0x71,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x7F,0xFF,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00},
{0xA2,0x72,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x7F,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA2,0x73,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00},
{0xA2,0x74,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x7F,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00},
{0xA2,0x75,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0xFF,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00},
{0xA2,0x76,0x00,0x00,0x7F,0xFF,0x7F,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA2,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA2,0x78,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00},
{0xA2,0x79,0x00,0x00,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03},
{0xA2,0x7A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00},
{0xA2,0x7B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00},
{0xA2,0x7C,0x00,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA2,0x7D,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA2,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x00,0x60,0x00,0x80,0x00,0x80,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00},
{0xA2,0xA1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x06,0x00,0x01,0x00,0x01,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00},
{0xA2,0xA2,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x80,0x00,0x80,0x00,0x60,0x00,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA2,0xA3,0x00,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x01,0x00,0x01,0x00,0x06,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA2,0xA4,0x00,0x00,0x00,0x80,0x00,0x80,0x3C,0x80,0x66,0x80,0x66,0x00,0x06,0x00,0x0C,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA2,0xA5,0x00,0x00,0x00,0x80,0x00,0x80,0x3C,0x80,0x66,0x80,0x66,0x00,0x06,0x00,0x0C,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA2,0xA6,0x00,0x00,0x00,0x80,0x00,0x80,0x3C,0x80,0x66,0x80,0x66,0x00,0x06,0x00,0x0C,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA2,0xA7,0x00,0x00,0x00,0x80,0x00,0x80,0x3C,0x80,0x66,0x80,0x66,0x00,0x06,0x00,0x0C,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA2,0xA8,0x00,0x00,0x00,0x01,0x00,0x03,0x00,0x07,0x00,0x0F,0x00,0x1F,0x00,0x3F,0x00,0x7F,0x00,0xFF,0x01,0xFF,0x03,0xFF,0x07,0xFF,0x0F,0xFF,0x1F,0xFF,0x3F,0xFF,0x00,0x00},
{0xA2,0xA9,0x00,0x00,0x40,0x00,0x60,0x00,0x70,0x00,0x78,0x00,0x7C,0x00,0x7E,0x00,0x7F,0x00,0x7F,0x80,0x7F,0xC0,0x7F,0xE0,0x7F,0xF0,0x7F,0xF8,0x7F,0xFC,0x7F,0xFE,0x00,0x00},
{0xA2,0xAA,0x00,0x00,0x3F,0xFF,0x1F,0xFF,0x0F,0xFF,0x07,0xFF,0x03,0xFF,0x01,0xFF,0x00,0xFF,0x00,0x7F,0x00,0x3F,0x00,0x1F,0x00,0x0F,0x00,0x07,0x00,0x03,0x00,0x01,0x00,0x00},
{0xA2,0xAB,0x00,0x00,0x7F,0xFE,0x7F,0xFC,0x7F,0xF8,0x7F,0xF0,0x7F,0xE0,0x7F,0xC0,0x7F,0x80,0x7F,0x00,0x7E,0x00,0x7C,0x00,0x78,0x00,0x70,0x00,0x60,0x00,0x40,0x00,0x00,0x00},
{0xA2,0xAC,0x00,0x00,0x00,0x02,0x00,0x04,0x00,0x08,0x00,0x10,0x00,0x20,0x00,0x40,0x00,0x80,0x01,0x00,0x02,0x00,0x04,0x00,0x08,0x00,0x10,0x00,0x20,0x00,0x40,0x00,0x00,0x00},
{0xA2,0xAD,0x00,0x00,0x40,0x00,0x20,0x00,0x10,0x00,0x08,0x00,0x04,0x00,0x02,0x00,0x01,0x00,0x00,0x80,0x00,0x40,0x00,0x20,0x00,0x10,0x00,0x08,0x00,0x04,0x00,0x02,0x00,0x01},
{0xA2,0xAE,0x00,0x00,0x40,0x02,0x20,0x04,0x10,0x08,0x08,0x10,0x04,0x20,0x02,0x40,0x01,0x80,0x01,0x80,0x02,0x40,0x04,0x20,0x08,0x10,0x10,0x08,0x20,0x04,0x40,0x02,0x00,0x00},
{0xA2,0xAF,0x00,0x00,0x00,0x00,0x01,0x80,0x02,0x40,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x02,0x40,0x01,0x80,0x00,0x00,0x00,0x00},
{0xA2,0xB0,0x00,0x00,0x00,0x00,0x01,0x00,0x07,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x07,0xC0,0x00,0x00,0x00,0x00},
{0xA2,0xB1,0x00,0x00,0x00,0x00,0x03,0xC0,0x04,0x20,0x04,0x20,0x04,0x20,0x00,0x60,0x00,0x40,0x00,0x80,0x01,0x00,0x02,0x00,0x04,0x20,0x04,0x20,0x07,0xE0,0x00,0x00,0x00,0x00},
{0xA2,0xB2,0x00,0x00,0x00,0x00,0x03,0xC0,0x04,0x60,0x04,0x20,0x00,0x20,0x00,0x40,0x01,0x80,0x00,0x40,0x00,0x20,0x00,0x20,0x04,0x20,0x04,0x20,0x03,0xC0,0x00,0x00,0x00,0x00},
{0xA2,0xB3,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0xC0,0x01,0x40,0x01,0x40,0x02,0x40,0x02,0x40,0x04,0x40,0x04,0x40,0x07,0xE0,0x00,0x40,0x00,0x40,0x01,0xE0,0x00,0x00,0x00,0x00},
{0xA2,0xB4,0x00,0x00,0x00,0x00,0x07,0xE0,0x04,0x00,0x04,0x00,0x04,0x00,0x05,0x80,0x06,0x60,0x00,0x20,0x00,0x20,0x00,0x20,0x06,0x20,0x04,0x60,0x03,0xC0,0x00,0x00,0x00,0x00},
{0xA2,0xB5,0x00,0x00,0x00,0x00,0x01,0xC0,0x02,0x60,0x02,0x00,0x04,0x00,0x04,0x80,0x07,0x40,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x02,0x20,0x03,0xC0,0x00,0x00,0x00,0x00},
{0xA2,0xB6,0x00,0x00,0x00,0x00,0x07,0xE0,0x04,0x20,0x04,0x20,0x00,0x40,0x00,0x40,0x00,0x80,0x00,0x80,0x01,0x00,0x01,0x00,0x01,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00,0x00},
{0xA2,0xB7,0x00,0x00,0x00,0x00,0x03,0xC0,0x04,0x20,0x04,0x20,0x04,0x20,0x06,0x40,0x03,0x80,0x02,0xC0,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x03,0xC0,0x00,0x00,0x00,0x00},
{0xA2,0xB8,0x00,0x00,0x00,0x00,0x03,0xC0,0x04,0x40,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x03,0xE0,0x00,0x20,0x00,0x20,0x00,0x40,0x06,0x40,0x03,0x80,0x00,0x00,0x00,0x00},
{0xA2,0xB9,0x00,0x00,0x00,0x00,0x07,0xC0,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x07,0xC0,0x00,0x00,0x00,0x00},
{0xA2,0xBA,0x00,0x00,0x00,0x00,0x3E,0x7C,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x3E,0x7C,0x00,0x00,0x00,0x00},
{0xA2,0xBB,0x00,0x00,0x00,0x00,0x7B,0xDE,0x21,0x08,0x21,0x08,0x21,0x08,0x21,0x08,0x21,0x08,0x21,0x08,0x21,0x08,0x21,0x08,0x21,0x08,0x21,0x08,0x7B,0xDE,0x00,0x00,0x00,0x00},
{0xA2,0xBC,0x00,0x00,0x00,0x00,0x7F,0xCF,0x21,0x04,0x21,0x84,0x20,0x84,0x20,0x88,0x20,0xC8,0x20,0x48,0x20,0x50,0x20,0x50,0x20,0x70,0x20,0x20,0x78,0x20,0x00,0x00,0x00,0x00},
{0xA2,0xBD,0x00,0x00,0x00,0x00,0x3E,0x3C,0x08,0x10,0x0C,0x10,0x04,0x10,0x04,0x20,0x06,0x20,0x02,0x40,0x02,0x40,0x03,0x40,0x01,0x80,0x01,0x80,0x01,0x00,0x00,0x00,0x00,0x00},
{0xA2,0xBE,0x00,0x00,0x00,0x00,0x79,0xFF,0x30,0x84,0x10,0x84,0x10,0x84,0x11,0x04,0x19,0x04,0x09,0x04,0x0A,0x04,0x0E,0x04,0x06,0x04,0x04,0x04,0x04,0x1E,0x00,0x00,0x00,0x00},
{0xA2,0xBF,0x00,0x00,0x00,0x00,0x73,0x7F,0x62,0x24,0x22,0x24,0x22,0x24,0x24,0x24,0x34,0x24,0x14,0x24,0x14,0x24,0x18,0x24,0x18,0x24,0x08,0x24,0x08,0x7F,0x00,0x00,0x00,0x00},
{0xA2,0xC0,0x00,0x00,0x00,0x00,0x6F,0xFF,0x64,0x92,0x64,0x92,0x24,0x92,0x28,0x92,0x28,0x92,0x28,0x92,0x38,0x92,0x10,0x92,0x10,0x92,0x10,0x92,0x11,0xFF,0x00,0x00,0x00,0x00},
{0xA2,0xC1,0x00,0x00,0x00,0x00,0x7B,0xCE,0x21,0x84,0x20,0x88,0x20,0xD0,0x20,0x50,0x20,0x20,0x20,0x70,0x20,0x50,0x20,0x98,0x21,0x08,0x21,0x04,0x7F,0x8E,0x00,0x00,0x00,0x00},
{0xA2,0xC2,0x00,0x00,0x00,0x00,0x3E,0x7C,0x04,0x10,0x06,0x20,0x02,0x40,0x03,0x40,0x01,0x80,0x01,0x80,0x02,0xC0,0x02,0x40,0x04,0x60,0x08,0x30,0x3C,0x7C,0x00,0x00,0x00,0x00},
{0xA2,0xC3,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00},
{0xA2,0xC4,0x00,0x00,0x00,0x18,0x00,0x10,0x00,0x10,0x06,0x10,0x04,0x10,0x04,0x10,0x04,0x10,0x04,0x10,0x04,0x10,0x04,0x10,0x04,0x10,0x04,0x10,0x00,0x10,0x00,0x10,0x00,0x00},
{0xA2,0xC5,0x00,0x00,0x00,0x06,0x18,0x04,0x10,0xC4,0x10,0x84,0x10,0x84,0x10,0x84,0x10,0x84,0x10,0x84,0x10,0x84,0x10,0x84,0x10,0x84,0x10,0x84,0x10,0x04,0x00,0x04,0x00,0x00},
{0xA2,0xC6,0x00,0x00,0x00,0x18,0x20,0x10,0x10,0x10,0x08,0x20,0x06,0x20,0x01,0x40,0x00,0xC0,0x00,0xC0,0x01,0x20,0x02,0x10,0x04,0x08,0x08,0x04,0x30,0x04,0x00,0x00,0x00,0x00},
{0xA2,0xC7,0x00,0x00,0x00,0x08,0x00,0x08,0x06,0x18,0x04,0x30,0x06,0xE0,0x01,0xC0,0x06,0x60,0x0C,0x30,0x08,0x10,0x18,0x18,0x10,0x18,0x18,0x10,0x0C,0x30,0x07,0xE0,0x00,0x00},
{0xA2,0xC8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x00,0x01,0x04,0x7F,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA2,0xC9,0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x00,0x01,0x04,0x7F,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x3F,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA2,0xCA,0x00,0x00,0x01,0x80,0x01,0x00,0x01,0x04,0x7F,0xFE,0x00,0x00,0x00,0x00,0x00,0x10,0x1F,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x7F,0xFE,0x00,0x00,0x00,0x00},
{0xA2,0xCB,0x00,0x00,0x01,0x80,0x01,0x04,0x7F,0xFE,0x00,0x0C,0x10,0x08,0x08,0x08,0x08,0x10,0x04,0x20,0x02,0x20,0x02,0x40,0x01,0x80,0x03,0x40,0x0C,0x30,0x70,0x0E,0x00,0x00},
{0xA2,0xCC,0x00,0x00,0x00,0x80,0x00,0x04,0x3C,0xFE,0x66,0x0C,0x66,0x08,0x06,0x08,0x0C,0x10,0x18,0x20,0x18,0x20,0x00,0x40,0x18,0x80,0x18,0x40,0x00,0x30,0x00,0x0E,0x00,0x00},
{0xA2,0xCD,0x00,0x00,0x0C,0x18,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x12,0x7F,0xFF,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10},
{0xA2,0xCE,0x00,0x00,0x00,0x18,0x00,0x10,0x3C,0x10,0x66,0x10,0x66,0x10,0x06,0x10,0x0C,0x12,0x18,0xFF,0x18,0x10,0x00,0x10,0x18,0x10,0x18,0x10,0x00,0x10,0x00,0x10,0x00,0x10},
{0xA2,0xCF,0x00,0x00,0x00,0x80,0x01,0x80,0x01,0x80,0x02,0xC0,0x02,0x40,0x02,0x40,0x04,0x60,0x04,0x20,0x0F,0xE0,0x08,0x30,0x08,0x10,0x10,0x18,0x3C,0x7C,0x00,0x00,0x00,0x00},
{0xA2,0xD0,0x00,0x00,0x00,0x00,0x3F,0xE0,0x08,0x30,0x08,0x10,0x08,0x10,0x08,0x20,0x0F,0xC0,0x08,0x30,0x08,0x18,0x08,0x18,0x08,0x18,0x08,0x30,0x3F,0xE0,0x00,0x00,0x00,0x00},
{0xA2,0xD1,0x00,0x00,0x00,0x00,0x01,0xC0,0x06,0x28,0x08,0x18,0x18,0x08,0x18,0x00,0x18,0x00,0x18,0x00,0x18,0x00,0x08,0x00,0x0C,0x08,0x06,0x10,0x03,0xE0,0x00,0x00,0x00,0x00},
{0xA2,0xD2,0x00,0x00,0x00,0x00,0x3F,0xC0,0x08,0x30,0x08,0x18,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x18,0x08,0x10,0x08,0x30,0x3F,0xC0,0x00,0x00,0x00,0x00},
{0xA2,0xD3,0x00,0x00,0x00,0x00,0x3F,0xF0,0x04,0x18,0x04,0x08,0x04,0x40,0x04,0x40,0x07,0xC0,0x04,0x40,0x04,0x40,0x04,0x00,0x04,0x08,0x04,0x18,0x3F,0xF0,0x00,0x00,0x00,0x00},
{0xA2,0xD4,0x00,0x00,0x00,0x00,0x1F,0xF0,0x04,0x18,0x04,0x08,0x04,0x40,0x04,0x40,0x07,0xC0,0x04,0x40,0x04,0x40,0x04,0x00,0x04,0x00,0x04,0x00,0x1F,0x00,0x00,0x00,0x00,0x00},
{0xA2,0xD5,0x00,0x00,0x00,0x00,0x03,0xC0,0x06,0x28,0x08,0x18,0x08,0x08,0x18,0x00,0x18,0x00,0x18,0x00,0x18,0x7C,0x08,0x10,0x0C,0x10,0x06,0x20,0x03,0xC0,0x00,0x00,0x00,0x00},
{0xA2,0xD6,0x00,0x00,0x00,0x00,0x1E,0x78,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x0F,0xF0,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x1E,0x78,0x00,0x00,0x00,0x00},
{0xA2,0xD7,0x00,0x00,0x00,0x00,0x03,0xE0,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x03,0xE0,0x00,0x00,0x00,0x00},
{0xA2,0xD8,0x00,0x00,0x00,0x00,0x03,0xE0,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x0C,0x80,0x08,0x80,0x07,0x00,0x00,0x00},
{0xA2,0xD9,0x00,0x00,0x00,0x00,0x3E,0x7C,0x08,0x20,0x08,0x40,0x08,0x80,0x09,0x00,0x0B,0x00,0x0D,0x80,0x08,0xC0,0x08,0x60,0x08,0x30,0x08,0x18,0x3E,0x7E,0x00,0x00,0x00,0x00},
{0xA2,0xDA,0x00,0x00,0x00,0x00,0x1F,0x80,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x00,0x06,0x08,0x06,0x18,0x1F,0xF0,0x00,0x00,0x00,0x00},
{0xA2,0xDB,0x00,0x00,0x00,0x00,0x70,0x0F,0x38,0x0C,0x28,0x14,0x2C,0x14,0x24,0x24,0x24,0x24,0x26,0x44,0x22,0x44,0x23,0x84,0x23,0x84,0x21,0x04,0x79,0x1F,0x00,0x00,0x00,0x00},
{0xA2,0xDC,0x00,0x00,0x00,0x00,0x38,0x1E,0x1C,0x08,0x16,0x08,0x12,0x08,0x13,0x08,0x11,0x88,0x10,0x88,0x10,0xC8,0x10,0x68,0x10,0x28,0x10,0x38,0x3C,0x18,0x00,0x00,0x00,0x00},
{0xA2,0xDD,0x00,0x00,0x00,0x00,0x03,0xE0,0x04,0x10,0x08,0x08,0x08,0x08,0x18,0x0C,0x18,0x0C,0x18,0x0C,0x18,0x0C,0x18,0x0C,0x08,0x08,0x08,0x08,0x04,0x10,0x03,0xE0,0x00,0x00},
{0xA2,0xDE,0x00,0x00,0x00,0x00,0x1F,0xC0,0x04,0x30,0x04,0x18,0x04,0x18,0x04,0x18,0x04,0x30,0x07,0xC0,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x1F,0x00,0x00,0x00,0x00,0x00},
{0xA2,0xDF,0x00,0x00,0x00,0x00,0x07,0xC0,0x08,0x20,0x08,0x20,0x10,0x10,0x30,0x18,0x30,0x18,0x30,0x18,0x10,0x10,0x17,0x90,0x08,0x50,0x08,0x60,0x07,0xD8,0x00,0x0E,0x00,0x00},
{0xA2,0xE0,0x00,0x00,0x00,0x00,0x1F,0x80,0x04,0x60,0x04,0x30,0x04,0x30,0x04,0x30,0x04,0x60,0x07,0x80,0x04,0xC0,0x04,0x40,0x04,0x60,0x04,0x30,0x1F,0x38,0x00,0x00,0x00,0x00},
{0xA2,0xE1,0x00,0x00,0x00,0x00,0x03,0x80,0x04,0x50,0x08,0x30,0x08,0x10,0x08,0x00,0x04,0x00,0x03,0x80,0x00,0xE0,0x00,0x30,0x08,0x10,0x0C,0x10,0x0A,0x20,0x01,0xC0,0x00,0x00},
{0xA2,0xE2,0x00,0x00,0x00,0x00,0x0F,0xF8,0x18,0x8C,0x10,0x84,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x07,0xF0,0x00,0x00,0x00,0x00},
{0xA2,0xE3,0x00,0x00,0x00,0x00,0x3E,0x3C,0x18,0x10,0x18,0x10,0x18,0x10,0x18,0x10,0x18,0x10,0x18,0x10,0x18,0x10,0x18,0x10,0x08,0x10,0x0C,0x20,0x07,0xC0,0x00,0x00,0x00,0x00},
{0xA2,0xE4,0x00,0x00,0x00,0x00,0x3E,0x3C,0x18,0x10,0x08,0x10,0x0C,0x20,0x0C,0x20,0x04,0x40,0x06,0x40,0x06,0x40,0x02,0x80,0x03,0x80,0x03,0x00,0x01,0x00,0x00,0x00,0x00,0x00},
{0xA2,0xE5,0x00,0x00,0x00,0x00,0x7B,0xCF,0x31,0x84,0x31,0x84,0x10,0x84,0x18,0xC8,0x19,0xC8,0x19,0x48,0x0A,0x50,0x0E,0x70,0x0E,0x70,0x04,0x20,0x04,0x20,0x00,0x00,0x00,0x00},
{0xA2,0xE6,0x00,0x00,0x00,0x00,0x3E,0x78,0x0C,0x20,0x04,0x40,0x06,0x40,0x03,0x80,0x01,0x00,0x03,0x80,0x02,0xC0,0x04,0x40,0x08,0x60,0x08,0x30,0x3C,0x7C,0x00,0x00,0x00,0x00},
{0xA2,0xE7,0x00,0x00,0x00,0x00,0x3E,0x7C,0x18,0x10,0x0C,0x20,0x04,0x20,0x06,0x40,0x03,0x40,0x03,0x80,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x07,0xC0,0x00,0x00,0x00,0x00},
{0xA2,0xE8,0x00,0x00,0x00,0x00,0x07,0xF0,0x0C,0x30,0x08,0x60,0x00,0x40,0x00,0xC0,0x01,0x80,0x01,0x00,0x03,0x00,0x06,0x00,0x04,0x08,0x0C,0x18,0x1F,0xF0,0x00,0x00,0x00,0x00},
{0xA2,0xE9,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x80,0x0C,0x40,0x00,0x40,0x01,0xC0,0x06,0x40,0x0C,0x40,0x0C,0x40,0x07,0xB0,0x00,0x00,0x00,0x00},
{0xA2,0xEA,0x00,0x00,0x00,0x00,0x04,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0x05,0xC0,0x06,0x20,0x04,0x10,0x04,0x10,0x04,0x10,0x04,0x10,0x06,0x20,0x05,0xC0,0x00,0x00,0x00,0x00},
{0xA2,0xEB,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xE0,0x04,0x10,0x04,0x30,0x0C,0x00,0x0C,0x00,0x04,0x10,0x04,0x20,0x03,0xC0,0x00,0x00,0x00,0x00},
{0xA2,0xEC,0x00,0x00,0x00,0x20,0x00,0x60,0x00,0x20,0x00,0x20,0x00,0x20,0x03,0xA0,0x04,0x60,0x08,0x20,0x08,0x20,0x08,0x20,0x08,0x20,0x04,0x60,0x03,0xB0,0x00,0x00,0x00,0x00},
{0xA2,0xED,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC0,0x06,0x20,0x04,0x30,0x0C,0x10,0x0F,0xF0,0x0C,0x00,0x0C,0x00,0x04,0x10,0x03,0xE0,0x00,0x00,0x00,0x00},
{0xA2,0xEE,0x00,0x00,0x00,0x00,0x00,0xC0,0x01,0x20,0x01,0x60,0x01,0x00,0x07,0xC0,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x07,0xC0,0x00,0x00,0x00,0x00},
{0xA2,0xEF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x04,0xB0,0x08,0x40,0x08,0x40,0x04,0x80,0x03,0x00,0x0C,0x00,0x0F,0xC0,0x10,0x20,0x10,0x20,0x0F,0xC0},
{0xA2,0xF0,0x00,0x00,0x00,0x00,0x1C,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x05,0xC0,0x06,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x1E,0x70,0x00,0x00,0x00,0x00},
{0xA2,0xF1,0x00,0x00,0x00,0x00,0x03,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x07,0xC0,0x00,0x00,0x00,0x00},
{0xA2,0xF2,0x00,0x00,0x01,0x80,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x80,0x03,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x05,0x00,0x02,0x00},
{0xA2,0xF3,0x00,0x00,0x00,0x00,0x04,0x00,0x0C,0x00,0x04,0x00,0x04,0x00,0x04,0xF0,0x04,0x40,0x04,0x80,0x07,0x00,0x04,0x80,0x04,0xC0,0x04,0x40,0x1E,0xF0,0x00,0x00,0x00,0x00},
{0xA2,0xF4,0x00,0x00,0x00,0x00,0x01,0x00,0x03,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x07,0xC0,0x00,0x00,0x00,0x00},
{0xA2,0xF5,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6E,0x70,0x31,0x88,0x21,0x08,0x21,0x08,0x21,0x08,0x21,0x08,0x21,0x08,0x73,0x9C,0x00,0x00,0x00,0x00},
{0xA2,0xF6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1D,0xC0,0x06,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x0E,0x70,0x00,0x00,0x00,0x00},
{0xA2,0xF7,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC0,0x04,0x20,0x0C,0x30,0x08,0x10,0x08,0x10,0x08,0x10,0x0C,0x30,0x04,0x20,0x03,0xC0,0x00,0x00},
{0xA2,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1D,0xC0,0x06,0x20,0x04,0x10,0x04,0x10,0x04,0x10,0x04,0x10,0x06,0x20,0x05,0xC0,0x04,0x00,0x0E,0x00},
{0xA2,0xF9,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xA0,0x04,0x60,0x08,0x20,0x08,0x20,0x08,0x20,0x08,0x20,0x04,0x60,0x03,0xA0,0x00,0x20,0x00,0x70},
{0xA2,0xFA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0xC0,0x03,0x20,0x02,0x60,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x0F,0x80,0x00,0x00,0x00,0x00},
{0xA2,0xFB,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xA0,0x04,0x60,0x04,0x20,0x04,0x00,0x03,0x00,0x00,0xC0,0x00,0x20,0x04,0x20,0x06,0x20,0x05,0xC0,0x00,0x00},
{0xA2,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x07,0xC0,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x20,0x00,0xC0,0x00,0x00,0x00,0x00},
{0xA2,0xFD,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0xE0,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x60,0x03,0xB0,0x00,0x00,0x00,0x00},
{0xA2,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x70,0x04,0x20,0x04,0x40,0x06,0x40,0x02,0x80,0x02,0x80,0x01,0x80,0x01,0x00,0x00,0x00,0x00,0x00},
{0xA3,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7B,0x9C,0x11,0x08,0x11,0x90,0x1A,0x90,0x0A,0x90,0x0A,0x60,0x0C,0x60,0x04,0x40,0x00,0x00,0x00,0x00},
{0xA3,0x41,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0xF0,0x04,0x40,0x02,0x80,0x03,0x00,0x01,0x80,0x02,0x80,0x04,0x40,0x1E,0xF0,0x00,0x00,0x00,0x00},
{0xA3,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x70,0x04,0x20,0x04,0x40,0x06,0x40,0x02,0x80,0x03,0x00,0x01,0x00,0x0D,0x00,0x09,0x00,0x06,0x00},
{0xA3,0x43,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x0C,0x40,0x08,0x80,0x01,0x00,0x01,0x00,0x02,0x20,0x04,0x60,0x0F,0xC0,0x00,0x00,0x00,0x00},
{0xA3,0x44,0x00,0x00,0x00,0x80,0x01,0x80,0x01,0x80,0x02,0xC0,0x02,0x40,0x02,0x40,0x04,0x60,0x04,0x20,0x0F,0xE0,0x08,0x30,0x08,0x10,0x10,0x18,0x3C,0x7C,0x00,0x00,0x00,0x00},
{0xA3,0x45,0x00,0x00,0x00,0x00,0x3F,0xE0,0x08,0x30,0x08,0x10,0x08,0x10,0x08,0x20,0x0F,0xC0,0x08,0x30,0x08,0x18,0x08,0x18,0x08,0x18,0x08,0x30,0x3F,0xE0,0x00,0x00,0x00,0x00},
{0xA3,0x46,0x00,0x00,0x00,0x00,0x1F,0xF0,0x04,0x18,0x04,0x08,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x1F,0x00,0x00,0x00,0x00,0x00},
{0xA3,0x47,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x80,0x02,0x80,0x02,0xC0,0x04,0x40,0x04,0x60,0x04,0x20,0x08,0x30,0x08,0x10,0x10,0x10,0x1F,0xF8,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA3,0x48,0x00,0x00,0x00,0x00,0x3F,0xF0,0x04,0x18,0x04,0x08,0x04,0x40,0x04,0x40,0x07,0xC0,0x04,0x40,0x04,0x40,0x04,0x00,0x04,0x08,0x04,0x18,0x3F,0xF0,0x00,0x00,0x00,0x00},
{0xA3,0x49,0x00,0x00,0x00,0x00,0x07,0xF0,0x0C,0x30,0x08,0x60,0x00,0x40,0x00,0xC0,0x01,0x80,0x01,0x00,0x03,0x00,0x06,0x00,0x04,0x08,0x0C,0x18,0x1F,0xF0,0x00,0x00,0x00,0x00},
{0xA3,0x4A,0x00,0x00,0x00,0x00,0x1E,0x78,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x0F,0xF0,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x1E,0x78,0x00,0x00,0x00,0x00},
{0xA3,0x4B,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xE0,0x04,0x10,0x08,0x08,0x08,0x08,0x10,0x04,0x1F,0xFC,0x10,0x04,0x08,0x08,0x08,0x08,0x04,0x10,0x03,0xE0,0x00,0x00,0x00,0x00},
{0xA3,0x4C,0x00,0x00,0x00,0x00,0x07,0xC0,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x07,0xC0,0x00,0x00,0x00,0x00},
{0xA3,0x4D,0x00,0x00,0x00,0x00,0x3E,0x78,0x08,0x20,0x08,0x40,0x08,0x80,0x09,0x00,0x0B,0x00,0x0D,0x80,0x08,0xC0,0x08,0x60,0x08,0x30,0x08,0x18,0x3E,0x7C,0x00,0x00,0x00,0x00},
{0xA3,0x4E,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x80,0x01,0x80,0x02,0xC0,0x02,0x40,0x02,0x60,0x04,0x20,0x04,0x20,0x04,0x30,0x08,0x10,0x08,0x18,0x1E,0x3C,0x00,0x00,0x00,0x00},
{0xA3,0x4F,0x00,0x00,0x00,0x00,0x70,0x0F,0x38,0x0C,0x28,0x14,0x2C,0x14,0x24,0x24,0x24,0x24,0x26,0x44,0x22,0x44,0x23,0x84,0x23,0x84,0x21,0x04,0x79,0x1F,0x00,0x00,0x00,0x00},
{0xA3,0x50,0x00,0x00,0x00,0x00,0x38,0x1E,0x1C,0x08,0x16,0x08,0x12,0x08,0x13,0x08,0x11,0x88,0x10,0x88,0x10,0xC8,0x10,0x68,0x10,0x28,0x10,0x38,0x3C,0x18,0x00,0x00,0x00,0x00},
{0xA3,0x51,0x00,0x00,0x00,0x00,0x07,0xF0,0x08,0x08,0x08,0x08,0x00,0x00,0x08,0x08,0x0F,0xF8,0x08,0x08,0x00,0x00,0x10,0x04,0x10,0x04,0x10,0x04,0x1F,0xFC,0x00,0x00,0x00,0x00},
{0xA3,0x52,0x00,0x00,0x00,0x00,0x03,0xE0,0x04,0x10,0x08,0x08,0x08,0x08,0x18,0x0C,0x18,0x0C,0x18,0x0C,0x18,0x0C,0x18,0x0C,0x08,0x08,0x08,0x08,0x04,0x10,0x03,0xE0,0x00,0x00},
{0xA3,0x53,0x00,0x00,0x00,0x00,0x1F,0xF8,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x1E,0x78,0x00,0x00,0x00,0x00},
{0xA3,0x54,0x00,0x00,0x00,0x00,0x1F,0xC0,0x04,0x30,0x04,0x18,0x04,0x18,0x04,0x18,0x04,0x30,0x07,0xC0,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x1F,0x00,0x00,0x00,0x00,0x00},
{0xA3,0x55,0x00,0x00,0x00,0x00,0x1F,0xE0,0x18,0x30,0x0C,0x10,0x06,0x00,0x03,0x00,0x01,0x80,0x00,0xC0,0x01,0x00,0x02,0x00,0x04,0x08,0x08,0x18,0x1F,0xF0,0x00,0x00,0x00,0x00},
{0xA3,0x56,0x00,0x00,0x00,0x00,0x0F,0xF8,0x18,0x8C,0x10,0x84,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x07,0xF0,0x00,0x00,0x00,0x00},
{0xA3,0x57,0x00,0x00,0x00,0x00,0x0E,0x38,0x11,0x44,0x11,0x44,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x03,0xE0,0x00,0x00,0x00,0x00},
{0xA3,0x58,0x00,0x00,0x00,0x00,0x03,0xE0,0x00,0x80,0x03,0xE0,0x0C,0x98,0x18,0x8C,0x10,0x84,0x10,0x84,0x18,0x8C,0x0C,0x98,0x03,0xE0,0x00,0x80,0x03,0xE0,0x00,0x00,0x00,0x00},
{0xA3,0x59,0x00,0x00,0x00,0x00,0x3E,0x78,0x0C,0x20,0x04,0x40,0x06,0x40,0x03,0x80,0x01,0x00,0x03,0x80,0x02,0xC0,0x04,0x40,0x08,0x60,0x08,0x30,0x3C,0x7C,0x00,0x00,0x00,0x00},
{0xA3,0x5A,0x00,0x00,0x00,0x00,0x03,0xE0,0x00,0x80,0x30,0x86,0x50,0x85,0x18,0x8C,0x08,0x88,0x0C,0x98,0x04,0x90,0x03,0xE0,0x00,0x80,0x00,0x80,0x03,0xE0,0x00,0x00,0x00,0x00},
{0xA3,0x5B,0x00,0x00,0x00,0x00,0x03,0xC0,0x04,0x30,0x08,0x10,0x18,0x18,0x18,0x18,0x18,0x18,0x08,0x10,0x04,0x20,0x04,0x20,0x12,0x48,0x1E,0x78,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA3,0x5C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x88,0x02,0x50,0x04,0x50,0x08,0x60,0x08,0x40,0x08,0xC0,0x09,0x50,0x06,0x20,0x00,0x00,0x00,0x00},
{0xA3,0x5D,0x00,0x00,0x00,0x00,0x00,0xE0,0x01,0x10,0x02,0x10,0x02,0x10,0x04,0x20,0x05,0xC0,0x04,0x20,0x08,0x20,0x08,0x20,0x08,0x20,0x1C,0xC0,0x13,0x80,0x10,0x00,0x20,0x00},
{0xA3,0x5E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x30,0x09,0x60,0x01,0x80,0x01,0x00,0x01,0x00,0x02,0x00,0x02,0x00,0x06,0x00,0x04,0x00,0x00,0x00},
{0xA3,0x5F,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xC0,0x01,0x20,0x01,0x10,0x00,0x80,0x06,0x40,0x0C,0x40,0x08,0x40,0x08,0x40,0x08,0xC0,0x0D,0x80,0x02,0x00,0x00,0x00,0x00,0x00},
{0xA3,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x03,0x20,0x02,0x00,0x01,0x80,0x02,0x40,0x06,0x00,0x06,0x20,0x03,0xC0,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA3,0x61,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x80,0x04,0x00,0x05,0xE0,0x07,0xE0,0x04,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x0F,0x80,0x00,0x40,0x00,0x40,0x07,0x80},
{0xA3,0x62,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x70,0x0A,0x90,0x03,0x20,0x02,0x20,0x04,0x20,0x04,0x40,0x0C,0x40,0x00,0xC0,0x00,0x80,0x00,0x00},
{0xA3,0x63,0x00,0x00,0x00,0x00,0x00,0xC0,0x01,0x20,0x02,0x20,0x02,0x20,0x04,0x20,0x07,0xE0,0x04,0x40,0x08,0x40,0x08,0x40,0x08,0x80,0x09,0x00,0x06,0x00,0x00,0x00,0x00,0x00},
{0xA3,0x64,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x80,0x01,0x80,0x01,0x00,0x01,0x00,0x02,0x00,0x02,0x40,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA3,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x30,0x02,0x60,0x02,0x40,0x05,0x80,0x06,0x80,0x04,0x80,0x08,0x90,0x08,0x60,0x00,0x00,0x00,0x00},
{0xA3,0x66,0x00,0x00,0x00,0x00,0x02,0x00,0x05,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x01,0x80,0x02,0x80,0x04,0x80,0x04,0x80,0x08,0x90,0x00,0x60,0x00,0x00,0x00,0x00},
{0xA3,0x67,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x20,0x06,0x60,0x04,0x40,0x04,0x40,0x04,0x80,0x0C,0x80,0x0B,0x60,0x08,0x00,0x10,0x00,0x00,0x00},
{0xA3,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x10,0x02,0x20,0x02,0x20,0x06,0x40,0x04,0x40,0x04,0x80,0x07,0x00,0x04,0x00,0x00,0x00,0x00,0x00},
{0xA3,0x69,0x00,0x00,0x00,0x00,0x01,0x00,0x02,0x00,0x01,0xE0,0x03,0xC0,0x04,0x00,0x04,0x00,0x03,0xC0,0x06,0xE0,0x08,0x00,0x08,0x00,0x08,0x00,0x07,0x00,0x00,0x80,0x03,0x00},
{0xA3,0x6A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x80,0x04,0x40,0x04,0x20,0x0C,0x20,0x08,0x20,0x08,0x60,0x04,0x40,0x03,0x80,0x00,0x00,0x00,0x00},
{0xA3,0x6B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x0F,0xF0,0x09,0x40,0x02,0x40,0x02,0x40,0x04,0x80,0x0C,0xA0,0x08,0xC0,0x00,0x00,0x00,0x00},
{0xA3,0x6C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x80,0x04,0x40,0x08,0x40,0x08,0x40,0x08,0x40,0x0C,0xC0,0x13,0x80,0x10,0x00,0x10,0x00,0x20,0x00},
{0xA3,0x6D,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x03,0xF8,0x06,0xC0,0x04,0x60,0x08,0x20,0x08,0x60,0x08,0x40,0x04,0xC0,0x03,0x00,0x00,0x00,0x00,0x00},
{0xA3,0x6E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x03,0xB0,0x0F,0xE0,0x09,0x00,0x01,0x00,0x01,0x00,0x02,0x40,0x02,0x80,0x03,0x00,0x00,0x00,0x00,0x00},
{0xA3,0x6F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x10,0x0D,0x10,0x01,0x10,0x02,0x10,0x02,0x20,0x02,0x20,0x03,0xC0,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA3,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x60,0x08,0x90,0x08,0x98,0x18,0x98,0x19,0x10,0x09,0x10,0x05,0x20,0x03,0xC0,0x02,0x00,0x04,0x00,0x04,0x00},
{0xA3,0x71,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x10,0x05,0x20,0x01,0x40,0x01,0x80,0x01,0x00,0x03,0x00,0x05,0x00,0x09,0x90,0x18,0xA0,0x00,0x60},
{0xA3,0x72,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x40,0x00,0x80,0x04,0x80,0x0C,0xA0,0x19,0x10,0x11,0x10,0x11,0x10,0x0A,0x20,0x07,0xC0,0x02,0x00,0x02,0x00,0x04,0x00},
{0xA3,0x73,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x30,0x08,0x08,0x10,0x88,0x11,0x48,0x11,0x88,0x11,0x90,0x0E,0xE0,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA3,0x74,0x00,0x00,0x03,0x00,0x02,0x00,0x04,0x0C,0x08,0xFC,0x1F,0x04,0x10,0x0C,0x00,0x08,0x00,0x08,0x00,0x18,0x00,0x10,0x04,0x30,0x03,0x20,0x01,0xC0,0x00,0x80,0x00,0x00},
{0xA3,0x75,0x00,0x00,0x00,0xC0,0x00,0x80,0x01,0x80,0x01,0x3C,0x03,0xCC,0x06,0x08,0x04,0x10,0x01,0x20,0x00,0xC0,0x00,0x60,0x00,0xB0,0x03,0x18,0x0C,0x08,0x30,0x00,0x00,0x00},
{0xA3,0x76,0x00,0x00,0x00,0x00,0x00,0x38,0x23,0xCC,0x3C,0x0C,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x00,0x08,0x00,0x00,0x00,0x00},
{0xA3,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xF8,0x3F,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x0C,0x00,0x07,0xFC,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA3,0x78,0x00,0x00,0x03,0x00,0x02,0x00,0x06,0x00,0x04,0x1C,0x08,0x66,0x1F,0x86,0x11,0x04,0x03,0x04,0x02,0x04,0x04,0x08,0x04,0x08,0x08,0x90,0x10,0x70,0x00,0x20,0x00,0x00},
{0xA3,0x79,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0xC0,0x00,0x80,0x00,0x80,0x00,0x8C,0x01,0xFE,0x7F,0x00,0x01,0x00,0x02,0x40,0x02,0x20,0x04,0x50,0x0F,0x98,0x08,0x08,0x00,0x00},
{0xA3,0x7A,0x00,0x00,0x00,0x70,0x01,0xB0,0x1E,0x20,0x00,0x20,0x00,0x40,0x00,0xF8,0x00,0x88,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x20,0x04,0x60,0x03,0xC0,0x01,0x00,0x00,0x00},
{0xA3,0x7B,0x00,0x00,0x00,0xC0,0x08,0xC0,0x08,0x80,0x10,0x98,0x13,0xEC,0x3D,0x0C,0x21,0x08,0x02,0x08,0x02,0x08,0x04,0x08,0x04,0x10,0x09,0x10,0x10,0xE0,0x20,0x40,0x00,0x00},
{0xA3,0x7C,0x00,0x00,0x02,0x10,0x03,0x18,0x03,0x18,0x04,0x10,0x04,0x20,0x08,0x20,0x08,0x40,0x10,0x80,0x08,0x40,0x04,0x20,0x06,0x30,0x02,0x10,0x03,0x18,0x01,0x08,0x00,0x00},
{0xA3,0x7D,0x00,0x00,0x00,0x00,0x00,0x0C,0x01,0xFE,0x3F,0x00,0x01,0x00,0x01,0x18,0x03,0xEC,0x06,0x0C,0x04,0x18,0x00,0x10,0x00,0x30,0x02,0x20,0x01,0xC0,0x00,0x80,0x00,0x00},
{0xA3,0x7E,0x00,0x00,0x00,0x0C,0x08,0x3E,0x0F,0xC0,0x04,0x00,0x04,0x00,0x04,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x20,0x00,0x40,0x00,0x00,0x00},
{0xA3,0xA1,0x00,0x00,0x00,0x40,0x00,0x60,0x08,0x60,0x0C,0x20,0x0C,0x20,0x04,0x20,0x04,0x60,0x04,0xA0,0x07,0x20,0x0E,0x20,0x04,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x00},
{0xA3,0xA2,0x00,0x00,0x00,0x20,0x00,0x30,0x00,0x60,0x00,0x40,0x01,0x80,0x02,0x00,0x0C,0x00,0x0C,0x00,0x03,0x00,0x00,0x80,0x00,0x40,0x00,0x30,0x00,0x18,0x00,0x08,0x00,0x00},
{0xA3,0xA3,0x00,0x00,0x00,0x0C,0x00,0xFE,0x3F,0x80,0x00,0x80,0x00,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x00,0x80,0x00,0x80,0x00,0x00},
{0xA3,0xA4,0x00,0x00,0x00,0x00,0x02,0x00,0x03,0x10,0x01,0x18,0x21,0x18,0x31,0x10,0x11,0x10,0x11,0xF8,0x3F,0x10,0x11,0x00,0x01,0x00,0x01,0x0C,0x01,0xFE,0x7E,0x00,0x00,0x00},
{0xA3,0xA5,0x00,0x00,0x00,0x30,0x00,0x20,0x00,0x40,0x01,0x98,0x06,0x10,0x00,0x20,0x00,0x60,0x00,0xA0,0x03,0x20,0x0C,0x20,0x30,0x60,0x00,0x60,0x00,0x60,0x00,0x20,0x00,0x00},
{0xA3,0xA6,0x00,0x00,0x00,0x1C,0x07,0xE6,0x00,0x06,0x00,0x0C,0x08,0x78,0x0F,0x80,0x0C,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x08,0x00,0x08,0x00,0x10,0x00,0x20,0x00,0x00,0x00},
{0xA3,0xA7,0x00,0x00,0x00,0x08,0x20,0xFC,0x37,0x0C,0x30,0x0C,0x10,0x08,0x12,0x08,0x11,0x88,0x10,0xC8,0x10,0x48,0x10,0x08,0x10,0x18,0x1F,0xF0,0x10,0x10,0x00,0x00,0x00,0x00},
{0xA3,0xA8,0x00,0x00,0x00,0x18,0x31,0xFC,0x1F,0x0C,0x01,0x08,0x01,0x08,0x01,0x18,0x01,0x10,0x01,0x70,0x01,0x20,0x03,0x00,0x03,0x00,0x03,0x00,0x01,0x00,0x01,0x00,0x00,0x00},
{0xA3,0xA9,0x00,0x00,0x01,0x00,0x01,0x80,0x01,0x80,0x01,0x0C,0x01,0xFE,0x7F,0x00,0x01,0x00,0x01,0x00,0x02,0x60,0x07,0xB0,0x04,0x30,0x00,0x20,0x00,0x40,0x00,0x80,0x00,0x00},
{0xA3,0xAA,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x80,0x01,0x80,0x03,0x00,0x02,0x00,0x06,0x00,0x04,0x00,0x04,0x20,0x08,0x10,0x11,0xE8,0x3E,0x0C,0x20,0x04,0x00,0x00,0x00,0x00},
{0xA3,0xAB,0x00,0x00,0x00,0x00,0x38,0x18,0x0C,0x10,0x06,0x20,0x02,0x40,0x01,0x80,0x00,0x80,0x00,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x01,0x80,0x00,0x80,0x00,0x00,0x00,0x00},
{0xA3,0xAC,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0xFE,0x3F,0x40,0x00,0x40,0x00,0x40,0x03,0xC0,0x04,0x80,0x08,0x00,0x08,0x08,0x04,0x10,0x03,0xE0,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA3,0xAD,0x00,0x00,0x01,0x00,0x01,0x80,0x00,0x80,0x00,0x8C,0x00,0xFE,0x3F,0x40,0x00,0x40,0x03,0xC0,0x0C,0x40,0x10,0x00,0x10,0x00,0x10,0x08,0x08,0x30,0x07,0xC0,0x00,0x00},
{0xA3,0xAE,0x00,0x00,0x00,0x00,0x08,0x40,0x0C,0x60,0x04,0x60,0x04,0x20,0x04,0x2C,0x07,0xFE,0x7C,0x40,0x04,0x40,0x04,0x80,0x04,0x80,0x04,0x18,0x03,0xFC,0x00,0x00,0x00,0x00},
{0xA3,0xAF,0x00,0x00,0x00,0x0C,0x00,0xFE,0x3F,0x80,0x00,0x80,0x10,0x98,0x11,0xFC,0x3F,0x04,0x21,0x0C,0x23,0x08,0x02,0x08,0x02,0x18,0x04,0x10,0x04,0x10,0x08,0x20,0x00,0x00},
{0xA3,0xB0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x06,0xC0,0x38,0xC0,0x00,0x80,0x00,0x80,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x30,0x00,0x18,0x00,0x0E,0x00,0x00,0x00,0x00},
{0xA3,0xB1,0x00,0x00,0x01,0x00,0x01,0x80,0x01,0x90,0x03,0x18,0x02,0x18,0x04,0x30,0x09,0xA0,0x1E,0x40,0x10,0x80,0x01,0x00,0x02,0x10,0x0C,0x68,0x1F,0x8C,0x10,0x04,0x00,0x00},
{0xA3,0xB2,0x00,0x00,0x00,0x30,0x00,0xF8,0x0F,0x98,0x00,0x10,0x00,0x30,0x02,0x20,0x01,0x40,0x00,0xC0,0x01,0xE0,0x03,0x30,0x02,0x18,0x04,0x0C,0x08,0x04,0x10,0x00,0x00,0x00},
{0xA3,0xB3,0x00,0x00,0x00,0x60,0x00,0xF0,0x1F,0x10,0x04,0x20,0x04,0x20,0x08,0x4C,0x08,0xFE,0x1F,0x06,0x10,0x0C,0x00,0x08,0x00,0x10,0x00,0x20,0x00,0x40,0x00,0x00,0x00,0x00},
{0xA3,0xB4,0x00,0x00,0x10,0x00,0x18,0x00,0x18,0x00,0x10,0x00,0x10,0x00,0x20,0x30,0x23,0xF8,0x7C,0x08,0x40,0x18,0x00,0x10,0x00,0x30,0x00,0x20,0x00,0x20,0x00,0x40,0x00,0x00},
{0xA3,0xB5,0x00,0x00,0x02,0x00,0x03,0x00,0x03,0x00,0x01,0x30,0x01,0xFC,0x7F,0x00,0x03,0x00,0x03,0x00,0x05,0x00,0x05,0x00,0x09,0x00,0x11,0x00,0x20,0x98,0x40,0x7C,0x00,0x00},
{0xA3,0xB6,0x00,0x00,0x01,0x00,0x01,0x80,0x01,0x80,0x01,0x00,0x03,0x00,0x02,0x00,0x06,0x00,0x04,0x00,0x08,0x00,0x08,0x18,0x10,0x7C,0x3F,0x80,0x20,0x00,0x00,0x00,0x00,0x00},
{0xA3,0xB7,0x00,0x00,0x00,0x00,0x08,0x80,0x0C,0xC0,0x04,0x40,0x04,0x40,0x04,0x40,0x04,0x40,0x04,0x40,0x0C,0x40,0x08,0x40,0x08,0x44,0x10,0x46,0x10,0x3C,0x20,0x00,0x00,0x00},
{0xA3,0xB8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x00,0xFE,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA3,0xB9,0x00,0x00,0x00,0x10,0x00,0x18,0x08,0x18,0x04,0x10,0x02,0x20,0x01,0x60,0x00,0xC0,0x00,0xC0,0x01,0x20,0x02,0x30,0x04,0x18,0x08,0x08,0x30,0x0C,0x40,0x04,0x00,0x00},
{0xA3,0xBA,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x18,0x18,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x78,0x1F,0x88,0x18,0x08,0x10,0x00,0x00,0x00},
{0xA3,0xBB,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x03,0xC0,0x03,0xC0,0x03,0xC0,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA3,0xBC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA3,0xBD,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x40,0x00,0x80,0x03,0x00,0x06,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA3,0xBE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x20,0x06,0x20,0x02,0x40,0x01,0x40,0x01,0x80,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA3,0xBF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x06,0x00,0x03,0x00,0x00,0x80,0x00,0x40,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA4,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x7F,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
{0xA4,0x41,0x00,0x00,0x00,0x10,0x7F,0xF8,0x00,0x20,0x00,0x40,0x00,0x80,0x01,0x00,0x02,0x00,0x04,0x00,0x08,0x00,0x10,0x00,0x20,0x02,0x40,0x02,0x40,0x03,0x3F,0xFE,0x00,0x00},
{0xA4,0x42,0x00,0x00,0x00,0x02,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xA4,0x43,0x00,0x00,0x03,0x00,0x02,0x00,0x02,0x00,0x02,0x02,0x02,0x1F,0x03,0xE0,0x7E,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x02,0x02,0x02,0x02,0x03,0x01,0xFE,0x00,0x00},
{0xA4,0x44,0x00,0x00,0x00,0x20,0x7F,0xF0,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x42,0x08,0x7F,0x08,0x42,0x08,0x02,0x08,0x02,0x10,0x02,0x10,0x04,0x20,0x44,0x20,0x38,0x40,0x10},
{0xA4,0x45,0x00,0x00,0x03,0x00,0x02,0x00,0x02,0x00,0x02,0x20,0x7F,0xF0,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x08,0x20,0x08,0x20,0x10,0x22,0x10,0x22,0x20,0x23,0x40,0x1E},
{0xA4,0x46,0x00,0x00,0x00,0x02,0x7F,0xFF,0x00,0x04,0x00,0x18,0x00,0x20,0x00,0xC0,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xA4,0x47,0x00,0x00,0x00,0x00,0x00,0x04,0x3F,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x7F,0xFF,0x00,0x00,0x00,0x00},
{0xA4,0x48,0x00,0x00,0x01,0x80,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x80,0x02,0x80,0x02,0x40,0x02,0x40,0x04,0x20,0x04,0x20,0x08,0x10,0x08,0x08,0x10,0x07,0x60,0x02},
{0xA4,0x49,0x00,0x00,0x06,0x60,0x04,0x40,0x04,0x40,0x04,0x40,0x04,0x40,0x04,0x40,0x04,0x40,0x04,0x40,0x08,0x40,0x08,0x40,0x08,0x40,0x10,0x42,0x10,0x42,0x20,0x43,0x40,0x3E},
{0xA4,0x4A,0x00,0x00,0x00,0x80,0x3F,0xC0,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x01,0x40,0x01,0x40,0x02,0x40,0x02,0x20,0x04,0x20,0x04,0x10,0x08,0x08,0x10,0x07,0x60,0x02},
{0xA4,0x4B,0x00,0x40,0x03,0xE0,0x00,0x40,0x06,0x40,0x04,0x40,0x04,0x40,0x04,0x40,0x04,0x40,0x04,0x20,0x08,0x20,0x08,0x20,0x08,0x10,0x10,0x10,0x10,0x08,0x20,0x07,0x40,0x02},
{0xA4,0x4C,0x00,0x00,0x08,0x20,0x0F,0xF0,0x08,0x20,0x08,0x20,0x08,0x20,0x08,0x20,0x08,0x20,0x08,0x20,0x08,0x20,0x10,0x20,0x10,0x20,0x10,0x22,0x20,0x22,0x20,0x23,0x40,0x1E},
{0xA4,0x4D,0x00,0x00,0x00,0x02,0x7F,0xFF,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x04,0x02,0x04,0x02,0x04,0x02,0x08,0x04,0x08,0x04,0x10,0x04,0x10,0x44,0x20,0x38,0x40,0x10},
{0xA4,0x4E,0x00,0x00,0x00,0x02,0x7F,0xFF,0x00,0x02,0x00,0x02,0x00,0x12,0x00,0x22,0x00,0x42,0x00,0x82,0x01,0x02,0x06,0x04,0x18,0x04,0x70,0x04,0x20,0x44,0x00,0x38,0x00,0x10},
{0xA4,0x4F,0x00,0x00,0x01,0x80,0x01,0x00,0x01,0x02,0x7F,0xFF,0x01,0x02,0x01,0x02,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x04,0x04,0x04,0x04,0x08,0x44,0x10,0x38,0x60,0x10},
{0xA4,0x50,0x00,0x00,0x30,0x00,0x20,0x00,0x20,0x00,0x20,0x0C,0x20,0x10,0x20,0x60,0x23,0x80,0x3C,0x00,0x20,0x00,0x20,0x00,0x20,0x02,0x20,0x02,0x20,0x03,0x1F,0xFE,0x00,0x00},
{0xA4,0x51,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA4,0x52,0x00,0x00,0x03,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x03,0x00,0x02,0xC0,0x02,0x30,0x02,0x18,0x02,0x0C,0x02,0x04,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00},
{0xA4,0x53,0x00,0x00,0x00,0x08,0x7F,0xFC,0x00,0x08,0x08,0x08,0x18,0x10,0x34,0x10,0x24,0x20,0x02,0x20,0x01,0x40,0x00,0x80,0x01,0x40,0x02,0x20,0x04,0x18,0x18,0x07,0x60,0x02},
{0xA4,0x54,0x00,0x00,0x00,0x08,0x3F,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x1F,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x7F,0xFF,0x00,0x00},
{0xA4,0x55,0x00,0x00,0x00,0x02,0x7F,0xFF,0x01,0x00,0x01,0x00,0x01,0x80,0x01,0x60,0x01,0x18,0x01,0x08,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00},
{0xA4,0x56,0x00,0x00,0x00,0x30,0x00,0x20,0x00,0x22,0x7F,0xFF,0x00,0x20,0x18,0x20,0x14,0x40,0x24,0x40,0x22,0x80,0x01,0x00,0x01,0x80,0x02,0x60,0x04,0x18,0x18,0x07,0x60,0x02},
{0xA4,0x57,0x00,0x00,0x01,0x80,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x08,0x01,0xFC,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x02,0x7F,0xFF,0x00,0x00},
{0xA4,0x58,0x00,0x00,0x20,0x06,0x10,0x04,0x0C,0x08,0x02,0x10,0x02,0xA0,0x00,0xC0,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA4,0x59,0x00,0x00,0x03,0x00,0x02,0x00,0x02,0x10,0x7F,0xF8,0x02,0x10,0x02,0x10,0x02,0x10,0x02,0x10,0x06,0x10,0x05,0x90,0x08,0xD0,0x08,0x52,0x10,0x12,0x20,0x13,0x40,0x0E},
{0xA4,0x5A,0x00,0x00,0x08,0x20,0x0F,0xF0,0x08,0x20,0x08,0x20,0x0A,0x20,0x09,0x20,0x09,0x20,0x08,0xA0,0x08,0xA0,0x10,0x20,0x10,0x20,0x10,0x22,0x20,0x22,0x20,0x23,0x40,0x1E},
{0xA4,0x5B,0x00,0x00,0x06,0x00,0x04,0x00,0x04,0x20,0x07,0xF0,0x08,0x40,0x08,0x40,0x10,0x80,0x60,0x80,0x01,0x40,0x01,0x40,0x02,0x20,0x02,0x20,0x04,0x18,0x18,0x07,0x60,0x02},
{0xA4,0x5C,0x00,0x00,0x01,0x80,0x01,0x00,0x02,0x00,0x02,0x00,0x04,0x00,0x08,0xC0,0x10,0x80,0x60,0x80,0x01,0x00,0x02,0x10,0x02,0x08,0x04,0x0C,0x08,0xF6,0x3F,0x02,0x10,0x02},
{0xA4,0x5D,0x00,0x00,0x00,0xC0,0x18,0x80,0x10,0x84,0x10,0x9E,0x10,0xE4,0x17,0x84,0x78,0x84,0x10,0x84,0x10,0x88,0x10,0xB8,0x10,0x90,0x10,0x02,0x10,0x02,0x10,0x03,0x0F,0xFE},
{0xA4,0x5E,0x00,0x00,0x0C,0x00,0x08,0x04,0x1F,0xFE,0x10,0x00,0x20,0x10,0x4F,0xF8,0x00,0x10,0x00,0x20,0x00,0xC0,0x01,0x00,0x06,0x00,0x08,0x02,0x10,0x02,0x10,0x03,0x0F,0xFE},
{0xA4,0x5F,0x00,0x00,0x00,0x04,0x3F,0xFE,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xA4,0x60,0x00,0x00,0x00,0xC0,0x00,0x80,0x20,0x82,0x3F,0xFF,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x1F,0xFE,0x00,0x00},
{0xA4,0x61,0x00,0x00,0x00,0x02,0x7F,0xFF,0x04,0x40,0x04,0x40,0x04,0x40,0x04,0x40,0x04,0x40,0x04,0x40,0x08,0x40,0x08,0x40,0x08,0x40,0x10,0x42,0x10,0x42,0x20,0x43,0x40,0x3E},
{0xA4,0x62,0x00,0x00,0x00,0x02,0x7F,0xFF,0x01,0x02,0x01,0x02,0x01,0x02,0x41,0x02,0x22,0x02,0x1A,0x02,0x0A,0x02,0x04,0x04,0x04,0x04,0x08,0x04,0x08,0x44,0x10,0x38,0x60,0x10},
{0xA4,0x63,0x00,0x00,0x0C,0x00,0x08,0x02,0x0F,0xFF,0x10,0x02,0x10,0x02,0x20,0x02,0x20,0x22,0x4F,0xF2,0x00,0x02,0x00,0x02,0x00,0x04,0x00,0x04,0x00,0x44,0x00,0x38,0x00,0x10},
{0xA4,0x64,0x00,0x00,0x00,0x18,0x00,0xFC,0x3F,0x80,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA4,0x65,0x00,0x00,0x00,0x08,0x7F,0xFC,0x00,0x08,0x0A,0x10,0x19,0x10,0x34,0x90,0x24,0xA0,0x02,0x20,0x01,0x40,0x00,0x80,0x01,0x40,0x02,0x20,0x04,0x18,0x18,0x07,0x60,0x02},
{0xA4,0x66,0x00,0x00,0x00,0x00,0x20,0x04,0x3F,0xFE,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x3F,0xFC,0x20,0x04,0x00,0x00},
{0xA4,0x67,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x84,0x3F,0xFE,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF},
{0xA4,0x68,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x84,0x3F,0xFE},
{0xA4,0x69,0x00,0x00,0x01,0x80,0x01,0x00,0x02,0x02,0x03,0xFF,0x04,0x02,0x0A,0x04,0x11,0x04,0x61,0x88,0x00,0x90,0x00,0x20,0x00,0x40,0x01,0x80,0x06,0x00,0x18,0x00,0x60,0x00},
{0xA4,0x6A,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x01,0x80,0x01,0x40,0x02,0x20,0x02,0x20,0x04,0x10,0x08,0x08,0x10,0x07,0x60,0x02},
{0xA4,0x6B,0x00,0x00,0x03,0x00,0x02,0x00,0x02,0x00,0x02,0x02,0x7F,0xFF,0x04,0x10,0x04,0x10,0x08,0x20,0x08,0x20,0x17,0x40,0x00,0xC0,0x01,0x30,0x02,0x08,0x0C,0x06,0x70,0x02},
{0xA4,0x6C,0x00,0x00,0x00,0x08,0x1F,0xFC,0x00,0x08,0x00,0x30,0x00,0xC0,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xA4,0x6D,0x00,0x00,0x00,0x08,0x3F,0xFC,0x00,0x18,0x00,0x20,0x00,0xC0,0x00,0x87,0x00,0xB8,0x03,0xC0,0x7C,0x80,0x20,0x80,0x00,0x80,0x00,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xA4,0x6E,0x00,0x00,0x00,0x08,0x3F,0xFC,0x00,0x08,0x00,0x30,0x00,0xC0,0x00,0x80,0x30,0x80,0x2C,0x80,0x43,0x80,0x40,0xF0,0x00,0x8F,0x00,0x82,0x04,0x80,0x03,0x80,0x01,0x00},
{0xA4,0x6F,0x00,0x00,0x00,0x30,0x00,0x20,0x00,0x20,0x00,0x22,0x7F,0xFF,0x00,0x20,0x20,0x20,0x18,0x20,0x0C,0x20,0x04,0x20,0x00,0x20,0x00,0x20,0x01,0x20,0x00,0xE0,0x00,0x40},
{0xA4,0x70,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x80,0x00,0x80,0x0C,0x90,0x08,0x88,0x10,0x84,0x10,0x86,0x20,0x83,0x40,0x81,0x00,0x80,0x00,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xA4,0x71,0x00,0x00,0x01,0x80,0x01,0x00,0x01,0x00,0x01,0x02,0x7F,0xFF,0x01,0x40,0x01,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x04,0x40,0x04,0x42,0x08,0x42,0x10,0x43,0x60,0x3E},
{0xA4,0x72,0x00,0x00,0x10,0x02,0x1F,0xFF,0x10,0x02,0x10,0x02,0x10,0x02,0x10,0x02,0x1F,0xFE,0x10,0x02,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x20,0x00,0x20,0x00,0x40,0x00},
{0xA4,0x73,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x80,0x60,0x83,0x40,0x82,0x40,0x82,0x40,0x82,0x40,0x82,0x40,0x82,0x40,0x82,0x40,0x82,0x40,0x82,0x7F,0xFE,0x40,0x02,0x40,0x02},
{0xA4,0x74,0x00,0x00,0x0C,0x63,0x08,0x42,0x08,0x42,0x08,0x42,0x08,0x42,0x08,0x42,0x08,0x42,0x08,0x42,0x08,0x42,0x10,0x42,0x10,0x42,0x10,0x42,0x20,0x42,0x20,0x02,0x40,0x02},
{0xA4,0x75,0x00,0x00,0x00,0x00,0x00,0x04,0x3F,0xFE,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x00},
{0xA4,0x76,0x00,0x00,0x00,0x08,0x7F,0xFC,0x00,0x08,0x00,0x08,0x00,0x08,0x20,0x08,0x3F,0xF8,0x20,0x08,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x02,0x20,0x02,0x20,0x03,0x1F,0xFE},
{0xA4,0x77,0x00,0x00,0x00,0x08,0x7F,0xFC,0x00,0x08,0x00,0x08,0x30,0x08,0x20,0x08,0x3F,0xF8,0x20,0x08,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x02,0x20,0x02,0x20,0x03,0x1F,0xFE},
{0xA4,0x78,0x00,0x00,0x20,0x08,0x3F,0xFC,0x20,0x08,0x20,0x08,0x20,0x08,0x20,0x08,0x3F,0xF8,0x20,0x08,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x02,0x20,0x02,0x20,0x03,0x1F,0xFE},
{0xA4,0x79,0x00,0x00,0x00,0xC0,0x00,0x80,0x20,0x82,0x3F,0xFF,0x20,0x82,0x20,0x82,0x20,0x82,0x20,0x82,0x20,0x82,0x20,0x92,0x20,0x8E,0x20,0x84,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA4,0x7A,0x00,0x00,0x00,0x04,0x3F,0xFE,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x02,0x7F,0xFF,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00},
{0xA4,0x7B,0x00,0x00,0x06,0x18,0x04,0x10,0x04,0x10,0x04,0x10,0x04,0x10,0x04,0x12,0x7F,0xFF,0x04,0x10,0x04,0x10,0x08,0x10,0x08,0x10,0x10,0x10,0x10,0x10,0x20,0x10,0x40,0x10},
{0xA4,0x7C,0x00,0x00,0x01,0xA0,0x01,0x18,0x01,0x08,0x01,0x02,0x01,0x1F,0x03,0xE0,0x7D,0x00,0x00,0x80,0x00,0x80,0x00,0x40,0x00,0x42,0x00,0x22,0x00,0x12,0x00,0x0F,0x00,0x02},
{0xA4,0x7D,0x00,0x00,0x00,0x08,0x7F,0xFC,0x00,0x08,0x00,0x08,0x10,0x08,0x1F,0xF8,0x20,0x08,0x20,0x02,0x3F,0xFF,0x40,0x02,0x40,0x02,0x00,0x04,0x00,0x44,0x00,0x38,0x00,0x10},
{0xA4,0x7E,0x00,0x00,0x00,0x60,0x00,0x40,0x00,0x42,0x7F,0xFF,0x00,0xC0,0x01,0x40,0x01,0x40,0x02,0x40,0x02,0x40,0x04,0x40,0x18,0x40,0x60,0x40,0x02,0x40,0x01,0xC0,0x00,0x80},
{0xA4,0xA1,0x00,0x00,0x00,0x10,0x3F,0xF8,0x02,0x10,0x02,0x10,0x02,0x10,0x02,0x10,0x04,0x12,0x7F,0xFF,0x04,0x20,0x04,0x20,0x04,0x20,0x08,0x20,0x08,0x20,0x08,0x22,0x7F,0xFF},
{0xA4,0xA2,0x00,0x00,0x00,0x02,0x7F,0xFF,0x01,0x00,0x01,0x08,0x19,0xFC,0x11,0x00,0x11,0x02,0x3F,0xFF,0x20,0x02,0x20,0x02,0x00,0x02,0x00,0x04,0x00,0x44,0x00,0x38,0x00,0x10},
{0xA4,0xA3,0x00,0x00,0x00,0x02,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0xC0,0x01,0x90,0x02,0x88,0x04,0x84,0x18,0x86,0x60,0x82,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA4,0xA4,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x80,0x20,0x82,0x3F,0xFF,0x20,0x82,0x20,0x82,0x20,0x82,0x20,0x82,0x3F,0xFE,0x20,0x82,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA4,0xA5,0x00,0x00,0x00,0xC0,0x00,0x8C,0x00,0xF0,0x3F,0x80,0x00,0x80,0x00,0x88,0x1F,0xFC,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA4,0xA6,0x00,0x00,0x10,0x08,0x1F,0xFC,0x10,0x08,0x12,0x08,0x11,0x88,0x10,0x88,0x10,0x0A,0x7F,0xFF,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x20,0x48,0x20,0x38,0x40,0x10},
{0xA4,0xA7,0x00,0x00,0x01,0x80,0x01,0x00,0x01,0x08,0x7F,0xFC,0x00,0x10,0x00,0x20,0x00,0x40,0x00,0x80,0x01,0x00,0x02,0x00,0x34,0x00,0x28,0x00,0x44,0x00,0x43,0x03,0x00,0xFC},
{0xA4,0xA8,0x00,0x00,0x00,0x08,0x1F,0xFC,0x01,0x08,0x01,0x08,0x01,0x0A,0x7F,0xFF,0x02,0x08,0x02,0x08,0x02,0x08,0x1F,0xF8,0x04,0x08,0x04,0x00,0x08,0x00,0x10,0x00,0x60,0x00},
{0xA4,0xA9,0x00,0x00,0x00,0x08,0x3F,0xFC,0x00,0x10,0x02,0x60,0x01,0x80,0x00,0x82,0x7F,0xFF,0x00,0x82,0x00,0x84,0x00,0x80,0x00,0x80,0x00,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xA4,0xAA,0x00,0x00,0x00,0x08,0x1F,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x7F,0xFF,0x01,0x00,0x01,0x00,0x01,0x00,0x02,0x10,0x02,0x08,0x04,0x74,0x3F,0x86,0x10,0x02},
{0xA4,0xAB,0x00,0x00,0x06,0x30,0x04,0x20,0x04,0x24,0x3F,0xFE,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x22,0x7F,0xFF,0x04,0x20,0x04,0x20,0x08,0x20,0x08,0x20,0x10,0x20,0x20,0x20},
{0xA4,0xAC,0x00,0x00,0x00,0x04,0x7F,0xFE,0x04,0x00,0x04,0x10,0x07,0xF8,0x08,0x10,0x08,0x10,0x08,0x20,0x10,0x20,0x1F,0xE0,0x10,0x20,0x00,0x40,0x00,0x42,0x7F,0xFF,0x00,0x00},
{0xA4,0xAD,0x00,0x00,0x00,0x04,0x3F,0xFE,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x08,0x1F,0xFC,0x02,0x08,0x02,0x08,0x02,0x08,0x04,0x08,0x04,0x08,0x04,0x0A,0x7F,0xFF,0x00,0x00},
{0xA4,0xAE,0x00,0x00,0x01,0x80,0x01,0x04,0x7F,0xFE,0x00,0x00,0x00,0x00,0x04,0x20,0x07,0xF0,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x08,0x22,0x08,0x22,0x10,0x23,0x60,0x1E},
{0xA4,0xAF,0x00,0x00,0x0C,0x00,0x08,0x00,0x08,0x04,0x13,0xFE,0x18,0x00,0x30,0x00,0x50,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x02,0x17,0xFF,0x10,0x00},
{0xA4,0xB0,0x00,0x00,0x0C,0x30,0x08,0x20,0x08,0x20,0x10,0x20,0x18,0x20,0x30,0x22,0x57,0xFF,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20},
{0xA4,0xB1,0x00,0x00,0x0C,0x00,0x08,0x02,0x0B,0xFF,0x10,0x10,0x18,0x10,0x30,0x10,0x50,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x90,0x10,0x70,0x10,0x20},
{0xA4,0xB2,0x00,0x00,0x06,0x30,0x04,0x20,0x04,0x20,0x08,0x20,0x0C,0x30,0x18,0x28,0x28,0x26,0x48,0x23,0x08,0x21,0x08,0x20,0x08,0x20,0x08,0x20,0x08,0x20,0x08,0x20,0x08,0x20},
{0xA4,0xB3,0x00,0x00,0x0C,0xC0,0x08,0x80,0x08,0x80,0x10,0x88,0x1B,0xFC,0x30,0x88,0x50,0x88,0x10,0x88,0x10,0x88,0x11,0x08,0x11,0x08,0x11,0x0A,0x12,0x0A,0x12,0x0B,0x14,0x06},
{0xA4,0xB4,0x00,0x00,0x0C,0x08,0x0B,0xFC,0x08,0x88,0x10,0x88,0x18,0x88,0x30,0x92,0x50,0x9F,0x10,0x92,0x10,0x82,0x11,0x02,0x11,0x02,0x11,0x02,0x12,0x24,0x12,0x1C,0x14,0x08},
{0xA4,0xB5,0x00,0x00,0x01,0x80,0x02,0x80,0x02,0x40,0x04,0x20,0x08,0x18,0x10,0x47,0x67,0xE2,0x00,0x00,0x00,0x10,0x3F,0xF8,0x00,0x10,0x00,0x20,0x00,0x40,0x00,0x80,0x01,0x00},
{0xA4,0xB6,0x00,0x00,0x01,0x80,0x02,0x80,0x02,0x40,0x04,0x20,0x08,0x18,0x10,0x07,0x66,0x32,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x08,0x20,0x08,0x20,0x10,0x20,0x20,0x20},
{0xA4,0xB7,0x00,0x00,0x20,0x02,0x3F,0xFF,0x20,0x00,0x20,0x60,0x20,0x40,0x20,0x40,0x20,0x40,0x20,0x40,0x20,0xA0,0x20,0xA0,0x21,0x10,0x21,0x10,0x42,0x08,0x44,0x07,0x48,0x02},
{0xA4,0xB8,0x00,0x00,0x00,0x08,0x3F,0xFC,0x00,0x00,0x00,0x00,0x00,0x04,0x7F,0xFE,0x04,0x40,0x04,0x40,0x04,0x40,0x04,0x40,0x04,0x40,0x08,0x42,0x08,0x42,0x10,0x43,0x60,0x3E},
{0xA4,0xB9,0x00,0x00,0x03,0x00,0x02,0x00,0x02,0x20,0x04,0x10,0x04,0x18,0x09,0xEC,0x7E,0x44,0x24,0x40,0x04,0x40,0x04,0x40,0x04,0x40,0x08,0x42,0x08,0x42,0x10,0x43,0x60,0x3E},
{0xA4,0xBA,0x00,0x00,0x00,0x80,0x0F,0xC0,0x00,0x80,0x20,0x82,0x3F,0xFF,0x20,0x82,0x20,0x82,0x21,0x42,0x21,0x22,0x22,0x3A,0x2C,0x12,0x20,0x02,0x20,0x02,0x20,0x06,0x20,0x04},
{0xA4,0xBB,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x20,0x04,0x10,0x0C,0x08,0x08,0x0C,0x10,0x04,0x20,0x06,0x40,0x02,0x00,0x00},
{0xA4,0xBC,0x00,0x00,0x00,0x20,0x00,0xF0,0x06,0x20,0x04,0x10,0x08,0x0C,0x1F,0xF3,0x64,0x00,0x04,0x08,0x07,0xFC,0x08,0x08,0x08,0x08,0x00,0x08,0x00,0x10,0x01,0xE0,0x00,0x40},
{0xA4,0xBD,0x00,0x00,0x00,0x40,0x01,0xE0,0x0C,0x40,0x08,0x20,0x08,0x20,0x10,0x10,0x10,0x08,0x23,0x07,0x42,0x02,0x02,0x40,0x04,0x20,0x04,0x10,0x08,0xE8,0x7F,0x0C,0x20,0x04},
{0xA4,0xBE,0x00,0x00,0x20,0x02,0x3F,0xFF,0x20,0x02,0x40,0x04,0x04,0x20,0x07,0xF0,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x22,0x08,0x22,0x08,0x22,0x10,0x23,0x60,0x1E},
{0xA4,0xBF,0x00,0x00,0x00,0x18,0x34,0x13,0x22,0x22,0x22,0x22,0x21,0x42,0x21,0x42,0x20,0x82,0x20,0xC2,0x21,0x22,0x21,0x22,0x22,0x12,0x24,0x12,0x20,0x02,0x3F,0xFE,0x20,0x02},
{0xA4,0xC0,0x00,0x00,0x00,0x40,0x01,0xE0,0x0C,0x40,0x08,0x20,0x08,0x20,0x10,0x18,0x10,0x07,0x2F,0xFA,0x42,0x08,0x02,0x08,0x02,0x08,0x04,0x08,0x04,0x08,0x08,0xF0,0x30,0x20},
{0xA4,0xC1,0x00,0x00,0x30,0x02,0x23,0xFF,0x20,0x42,0x24,0x42,0x2E,0x42,0x70,0x42,0x20,0x42,0x24,0x42,0x24,0x82,0x26,0x84,0x1C,0x84,0x01,0x04,0x01,0x04,0x02,0x38,0x04,0x10},
{0xA4,0xC2,0x00,0x00,0x01,0x83,0x41,0x32,0x21,0x22,0x12,0x22,0x0A,0x22,0x0A,0x22,0x04,0x22,0x06,0x22,0x0A,0x22,0x09,0x22,0x11,0x82,0x10,0x82,0x20,0x92,0x40,0x0E,0x00,0x04},
{0xA4,0xC3,0x00,0x00,0x0C,0x00,0x08,0x02,0x0F,0xFF,0x10,0x02,0x10,0x02,0x20,0x42,0x2F,0xE2,0x40,0x02,0x00,0x22,0x0F,0xF2,0x00,0x04,0x00,0x04,0x00,0x44,0x00,0x38,0x00,0x10},
{0xA4,0xC4,0x00,0x00,0x0C,0x00,0x08,0x02,0x0F,0xFF,0x10,0x02,0x13,0x02,0x22,0x02,0x42,0x02,0x04,0x82,0x04,0x42,0x09,0xA2,0x3E,0x24,0x10,0x04,0x00,0x44,0x00,0x38,0x00,0x10},
{0xA4,0xC5,0x00,0x00,0x0C,0x00,0x08,0x02,0x0F,0xFF,0x11,0x22,0x11,0x22,0x22,0x22,0x42,0x42,0x04,0x42,0x04,0x82,0x08,0x82,0x11,0x04,0x22,0x04,0x04,0x44,0x08,0x38,0x00,0x10},
{0xA4,0xC6,0x00,0x00,0x06,0x60,0x04,0x40,0x04,0x40,0x08,0x40,0x0C,0x46,0x18,0x44,0x28,0x58,0x48,0x60,0x09,0xC0,0x08,0x40,0x08,0x40,0x08,0x42,0x08,0x42,0x08,0x43,0x08,0x3E},
{0xA4,0xC7,0x00,0x00,0x00,0x02,0x7F,0xFF,0x21,0x20,0x21,0x20,0x21,0x20,0x21,0x20,0x22,0x24,0x22,0x24,0x24,0x26,0x38,0x1C,0x20,0x00,0x20,0x00,0x20,0x00,0x1F,0xFE,0x00,0x00},
{0xA4,0xC8,0x00,0x00,0x0C,0x00,0x08,0x08,0x0F,0xFC,0x18,0x80,0x10,0x80,0x20,0x80,0x40,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA4,0xC9,0x00,0x00,0x01,0x98,0x06,0x10,0x7C,0x10,0x04,0x10,0x04,0x10,0x04,0x12,0x7F,0xFF,0x04,0x10,0x04,0x10,0x04,0x10,0x08,0x10,0x08,0x10,0x10,0x10,0x10,0x10,0x20,0x10},
{0xA4,0xCA,0x00,0x00,0x19,0x8C,0x11,0x08,0x11,0x08,0x11,0x08,0x11,0x08,0x11,0x0A,0x7F,0xFF,0x11,0x08,0x11,0x08,0x11,0x08,0x11,0x08,0x11,0x08,0x21,0x08,0x21,0x08,0x40,0x08},
{0xA4,0xCB,0x00,0x00,0x02,0x00,0x01,0x80,0x00,0x80,0x00,0x02,0x7F,0xFF,0x01,0x00,0x01,0x80,0x01,0x40,0x01,0x30,0x01,0x18,0x01,0x08,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00},
{0xA4,0xCC,0x00,0x00,0x20,0x02,0x3F,0xFF,0x20,0x00,0x20,0x00,0x24,0x08,0x27,0xFC,0x24,0x08,0x24,0x08,0x24,0x88,0x24,0x78,0x24,0x10,0x24,0x02,0x44,0x02,0x44,0x03,0x43,0xFE},
{0xA4,0xCD,0x00,0x00,0x03,0x00,0x02,0x00,0x02,0x02,0x7F,0xFF,0x04,0x00,0x04,0x08,0x07,0xFC,0x0A,0x08,0x09,0x10,0x09,0x10,0x10,0xA0,0x10,0x40,0x20,0xB0,0x43,0x0F,0x0C,0x02},
{0xA4,0xCE,0x00,0x00,0x00,0x20,0x7F,0xF0,0x08,0x20,0x08,0x20,0x08,0x40,0x08,0x48,0x0F,0xFC,0x0A,0x08,0x09,0x10,0x11,0x10,0x10,0xA0,0x20,0x60,0x20,0x98,0x43,0x07,0x0C,0x02},
{0xA4,0xCF,0x00,0x00,0x10,0x02,0x1F,0xFF,0x10,0x00,0x10,0x00,0x10,0x04,0x1F,0xFE,0x12,0x04,0x11,0x08,0x11,0x08,0x10,0x90,0x10,0x60,0x20,0xA0,0x21,0x18,0x22,0x07,0x4C,0x02},
{0xA4,0xD0,0x00,0x00,0x00,0x18,0x00,0xFC,0x3F,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x84,0x3F,0xFE},
{0xA4,0xD1,0x00,0x00,0x00,0x02,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x84,0x3F,0xFE,0x00,0x80,0x01,0x40,0x01,0x40,0x02,0x20,0x02,0x10,0x04,0x08,0x18,0x07,0x60,0x02},
{0xA4,0xD2,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x84,0x3F,0xFE,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x01,0x40,0x01,0x20,0x02,0x20,0x04,0x18,0x18,0x07,0x60,0x02},
{0xA4,0xD3,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x01,0x40,0x01,0x40,0x02,0x20,0x02,0x20,0x04,0x10,0x05,0x10,0x08,0xCC,0x10,0x47,0x60,0x02},
{0xA4,0xD4,0x00,0x00,0x00,0x30,0x00,0xF8,0x07,0x80,0x38,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x01,0x40,0x01,0x40,0x02,0x20,0x02,0x20,0x04,0x18,0x18,0x07,0x60,0x02},
{0xA4,0xD5,0x00,0x00,0x01,0x30,0x7F,0xA0,0x01,0x20,0x02,0x20,0x0C,0x20,0x08,0x20,0x09,0xA0,0x0E,0x20,0x78,0x20,0x28,0x20,0x08,0x20,0x08,0x22,0x48,0x22,0x38,0x23,0x10,0x1E},
{0xA4,0xD6,0x00,0x00,0x00,0xC0,0x00,0x80,0x0C,0x88,0x08,0x84,0x18,0x82,0x10,0x83,0x20,0x81,0x44,0x8C,0x03,0x88,0x01,0x10,0x00,0x20,0x00,0x40,0x01,0x80,0x0E,0x00,0x70,0x00},
{0xA4,0xD7,0x00,0x00,0x01,0xA0,0x01,0x18,0x01,0x08,0x01,0x02,0x7F,0xFF,0x01,0x00,0x01,0x60,0x02,0x40,0x02,0x40,0x02,0x40,0x04,0x40,0x04,0x42,0x08,0x42,0x10,0x43,0x60,0x3E},
{0xA4,0xD8,0x00,0x00,0x10,0x08,0x1F,0xFC,0x10,0x08,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x88,0x10,0x80,0x10,0x40,0x10,0x40,0x10,0x20,0x20,0x20,0x20,0x18,0x20,0x07,0x40,0x02},
{0xA4,0xD9,0x00,0x00,0x01,0x80,0x01,0x04,0x7F,0xFE,0x01,0x00,0x01,0x00,0x31,0x0C,0x21,0x08,0x21,0x08,0x21,0x08,0x3F,0xF8,0x21,0x08,0x01,0x02,0x01,0x02,0x01,0x03,0x00,0xFE},
{0xA4,0xDA,0x00,0x00,0x40,0x08,0x7F,0xFC,0x41,0x08,0x41,0x08,0x41,0x08,0x41,0x08,0x41,0x08,0x7F,0xF8,0x40,0x08,0x40,0x00,0x40,0x00,0x40,0x02,0x40,0x02,0x40,0x03,0x3F,0xFE},
{0xA4,0xDB,0x00,0x00,0x0C,0x02,0x09,0xFF,0x10,0x02,0x10,0x02,0x63,0x02,0x22,0x02,0x14,0x02,0x0C,0x02,0x08,0x02,0x0A,0x02,0x11,0x04,0x17,0x84,0x78,0x84,0x20,0x38,0x00,0x10},
{0xA4,0xDC,0x00,0x00,0x0C,0x18,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x12,0x7F,0xFF,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x0F,0xF0,0x08,0x10},
{0xA4,0xDD,0x00,0x00,0x00,0x08,0x7F,0xFC,0x01,0x08,0x01,0x08,0x11,0x08,0x3F,0xF8,0x21,0x08,0x21,0x02,0x7F,0xFF,0x41,0x02,0x41,0x02,0x01,0x22,0x01,0x1C,0x01,0x08,0x01,0x00},
{0xA4,0xDE,0x00,0x00,0x00,0x83,0x7F,0xC2,0x00,0x82,0x00,0x82,0x20,0x82,0x3F,0x82,0x20,0x02,0x20,0x42,0x7F,0xE2,0x40,0x42,0x40,0x42,0x00,0x42,0x08,0x82,0x07,0x02,0x02,0x02},
{0xA4,0xDF,0x00,0x00,0x01,0x00,0x00,0x80,0x00,0x40,0x00,0x60,0x06,0x20,0x04,0x04,0x14,0x02,0x14,0x02,0x24,0x03,0x24,0x11,0x44,0x10,0x04,0x10,0x04,0x18,0x03,0xF0,0x00,0x00},
{0xA4,0xE0,0x00,0x00,0x01,0xA0,0x01,0x18,0x01,0x08,0x01,0x02,0x01,0x1F,0x03,0xE0,0x7D,0x00,0x00,0x8C,0x00,0x88,0x00,0x50,0x00,0x62,0x01,0xA2,0x0E,0x12,0x70,0x0F,0x00,0x02},
{0xA4,0xE1,0x00,0x00,0x00,0x0C,0x10,0x7E,0x1F,0x80,0x10,0x00,0x10,0x02,0x1F,0xFF,0x10,0x02,0x10,0x02,0x1F,0xFE,0x10,0x02,0x10,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x40,0x00},
{0xA4,0xE2,0x00,0x00,0x00,0x18,0x00,0xFC,0x3F,0x80,0x00,0x80,0x00,0x84,0x3F,0xFE,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xA4,0xE3,0x00,0x00,0x0C,0x60,0x08,0x40,0x0A,0x40,0x7F,0x40,0x08,0x40,0x08,0x40,0x09,0x40,0x0E,0x40,0x78,0x40,0x28,0x40,0x08,0x40,0x08,0x42,0x48,0x42,0x38,0x43,0x10,0x3E},
{0xA4,0xE4,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x88,0x1F,0xFC,0x08,0x08,0x04,0x10,0x03,0x20,0x00,0xC0,0x01,0x60,0x06,0x18,0x18,0x07,0x60,0x02},
{0xA4,0xE5,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x08,0x08,0x08,0x18,0x10,0x34,0x10,0x02,0x20,0x01,0x40,0x00,0xC0,0x01,0x20,0x06,0x18,0x18,0x07,0x60,0x02},
{0xA4,0xE6,0x00,0x00,0x00,0x30,0x04,0x20,0x02,0x20,0x03,0x20,0x11,0x20,0x08,0x20,0x0C,0x20,0x04,0x22,0x00,0x3F,0x03,0xE0,0x7C,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x20},
{0xA4,0xE7,0x00,0x00,0x00,0x0C,0x10,0x3E,0x1F,0xC0,0x10,0x00,0x10,0x00,0x10,0x02,0x1F,0xFF,0x10,0x40,0x10,0x40,0x10,0x40,0x10,0x40,0x20,0x40,0x20,0x40,0x20,0x40,0x40,0x40},
{0xA4,0xE8,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x82,0x7F,0xFF,0x04,0x00,0x04,0x08,0x07,0xFC,0x04,0x08,0x04,0x08,0x08,0x08,0x08,0x08,0x10,0x08,0x11,0x10,0x20,0xE0,0x40,0x40},
{0xA4,0xE9,0x00,0x00,0x10,0x08,0x1F,0xFC,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08},
{0xA4,0xEA,0x00,0x00,0x00,0x00,0x20,0x04,0x3F,0xFE,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x24,0x3F,0xF4,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x3F,0xFC,0x20,0x04,0x00,0x00},
{0xA4,0xEB,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x08,0x08,0x08,0x08,0x08,0x10,0x08,0x10,0x88,0x10,0x70,0x20,0x20},
{0xA4,0xEC,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x01,0x80,0x02,0xC0,0x02,0xA0,0x04,0xA0,0x04,0x90,0x08,0x88,0x10,0x87,0x60,0x82,0x00,0x80,0x00,0x80},
{0xA4,0xED,0x00,0x00,0x0C,0x00,0x08,0x00,0x08,0x04,0x0F,0xFE,0x10,0x04,0x11,0x88,0x21,0x10,0x41,0x00,0x01,0x00,0x01,0x80,0x02,0x40,0x02,0x20,0x04,0x18,0x08,0x07,0x70,0x02},
{0xA4,0xEE,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x80,0x00,0x80,0x18,0x80,0x10,0x88,0x10,0xFC,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x82,0x7F,0xFF,0x00,0x00},
{0xA4,0xEF,0x00,0x00,0x00,0x02,0x7F,0xFF,0x02,0x00,0x02,0x00,0x02,0x08,0x07,0xFC,0x04,0x08,0x0A,0x08,0x11,0x90,0x60,0xA0,0x00,0x40,0x00,0x80,0x03,0x00,0x0C,0x00,0x30,0x00},
{0xA4,0xF0,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x88,0x08,0x88,0x08,0x88,0x08,0x8A,0x7F,0xFF,0x11,0x08,0x11,0x08,0x22,0x10,0x22,0x12,0x7F,0xFF,0x24,0x10,0x08,0xE0,0x00,0x40},
{0xA4,0xF1,0x00,0x00,0x18,0x60,0x10,0x40,0x10,0x40,0x10,0x40,0x10,0x40,0x12,0x44,0x1F,0x7E,0x10,0x40,0x10,0x40,0x10,0x40,0x10,0x40,0x13,0x42,0x1C,0x42,0x70,0x43,0x20,0x3E},
{0xA4,0xF2,0x00,0x00,0x00,0x30,0x01,0xF8,0x3F,0x00,0x01,0x00,0x01,0x08,0x01,0xFC,0x3F,0x00,0x01,0x00,0x01,0x04,0x01,0xFE,0x7F,0x00,0x01,0x02,0x01,0x02,0x01,0x03,0x00,0xFE},
{0xA4,0xF3,0x00,0x00,0x00,0x18,0x10,0x7C,0x1F,0xC0,0x10,0x40,0x10,0x40,0x10,0x42,0x1F,0xFF,0x10,0x40,0x10,0x20,0x10,0x20,0x13,0x12,0x1C,0x12,0x70,0x0A,0x20,0x07,0x00,0x02},
{0xA4,0xF4,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x80,0x00,0x80,0x04,0xC6,0x7E,0xA4,0x04,0xA8,0x04,0x90,0x08,0x90,0x08,0x88,0x10,0x88,0x60,0x87,0x04,0x82,0x03,0x80,0x01,0x00},
{0xA4,0xF5,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x80,0x08,0x86,0x08,0x8C,0x08,0x88,0x10,0x90,0x30,0xA0,0x21,0x40,0x01,0x40,0x02,0x20,0x02,0x20,0x04,0x18,0x18,0x07,0x60,0x02},
{0xA4,0xF6,0x00,0x00,0x00,0x0C,0x08,0xFE,0x0F,0x90,0x08,0x90,0x08,0x90,0x08,0x88,0x08,0x88,0x08,0x88,0x10,0x88,0x10,0x88,0x10,0x84,0x10,0x84,0x20,0x84,0x20,0x82,0x40,0x81},
{0xA4,0xF7,0x00,0x00,0x06,0x30,0x0C,0x0C,0x08,0x06,0x10,0x03,0x20,0x19,0x4C,0x10,0x0A,0x20,0x12,0x20,0x11,0x40,0x00,0x80,0x00,0xC0,0x01,0x20,0x02,0x18,0x0C,0x07,0x70,0x02},
{0xA4,0xF8,0x00,0x00,0x38,0x0C,0x06,0x70,0x01,0x80,0x06,0x70,0x18,0x0E,0x60,0x02,0x0C,0x18,0x0A,0x10,0x12,0x20,0x11,0x40,0x00,0x80,0x01,0x60,0x06,0x18,0x18,0x07,0x60,0x02},
{0xA4,0xF9,0x00,0x00,0x18,0x60,0x10,0x40,0x10,0x40,0x10,0x42,0x1F,0xFF,0x10,0x00,0x10,0x00,0x10,0x20,0x1F,0xF0,0x10,0x20,0x10,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x40,0x20},
{0xA4,0xFA,0x00,0x00,0x00,0x04,0x7F,0xFE,0x00,0x40,0x18,0x40,0x10,0x40,0x10,0x42,0x3F,0xFF,0x00,0xC0,0x01,0x40,0x02,0x40,0x04,0x40,0x18,0x40,0x62,0x40,0x01,0xC0,0x00,0x80},
{0xA4,0xFB,0x00,0x00,0x00,0xC0,0x0C,0x80,0x08,0x88,0x1F,0xFC,0x10,0x80,0x20,0x80,0x40,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA4,0xFC,0x00,0x00,0x00,0xD0,0x00,0x88,0x00,0x88,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x01,0x40,0x01,0x40,0x02,0x20,0x02,0x20,0x04,0x10,0x08,0x08,0x10,0x07,0x60,0x02},
{0xA4,0xFD,0x00,0x00,0x00,0x04,0x3F,0xFE,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x88,0x1F,0xFC,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x00},
{0xA4,0xFE,0x00,0x00,0x00,0x02,0x7F,0xFF,0x00,0x80,0x00,0x80,0x20,0x82,0x3F,0xFF,0x20,0x82,0x21,0x42,0x21,0x32,0x22,0x1A,0x2C,0x0A,0x20,0x02,0x20,0x02,0x20,0x1E,0x20,0x04},
{0xA5,0x40,0x00,0x00,0x19,0x98,0x11,0x10,0x11,0x10,0x11,0x12,0x7F,0xFF,0x11,0x10,0x11,0x10,0x11,0x10,0x11,0x10,0x11,0xF0,0x11,0x10,0x10,0x00,0x10,0x04,0x1F,0xFE,0x10,0x00},
{0xA5,0x41,0x00,0x00,0x00,0x04,0x7F,0xFE,0x01,0x00,0x01,0x00,0x03,0x20,0x05,0x10,0x05,0x08,0x09,0x0C,0x11,0x06,0x61,0x02,0x01,0x00,0x01,0x00,0x00,0x02,0x7F,0xFF,0x00,0x00},
{0xA5,0x42,0x00,0x00,0x08,0x10,0x0F,0xF8,0x08,0x10,0x08,0x10,0x08,0x10,0x0F,0xF0,0x08,0x10,0x08,0x10,0x08,0x10,0x0F,0xF0,0x08,0x10,0x08,0x10,0x08,0x12,0x7F,0xFF,0x00,0x00},
{0xA5,0x43,0x00,0x00,0x00,0x18,0x10,0xFC,0x1F,0x00,0x10,0x00,0x10,0x00,0x10,0x04,0x1F,0xFE,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x22,0x7F,0xFF,0x00,0x00},
{0xA5,0x44,0x00,0x00,0x03,0x00,0x00,0xC0,0x00,0x44,0x3F,0xFE,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x88,0x1F,0xFC,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x00},
{0xA5,0x45,0x00,0x00,0x0C,0x00,0x08,0x02,0x0F,0xFF,0x12,0x00,0x12,0x00,0x22,0x08,0x43,0xFC,0x02,0x00,0x02,0x08,0x03,0xFC,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00,0x02,0x00},
{0xA5,0x46,0x00,0x00,0x00,0x0C,0x01,0xFE,0x7F,0x00,0x01,0x00,0x01,0x08,0x3F,0xFC,0x00,0x08,0x00,0x10,0x00,0x60,0x01,0x80,0x36,0x00,0x28,0x00,0x44,0x00,0x43,0x03,0x00,0xFC},
{0xA5,0x47,0x00,0x00,0x00,0x0C,0x00,0xFE,0x3F,0x80,0x00,0x8C,0x10,0x88,0x0C,0x90,0x04,0xA2,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xA5,0x48,0x00,0x00,0x18,0x0C,0x10,0x08,0x12,0x08,0x11,0x08,0x11,0x88,0x10,0x88,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x94,0x13,0x14,0x1C,0x22,0x70,0x43,0x21,0x81,0x06,0x00},
{0xA5,0x49,0x00,0x00,0x0C,0x0C,0x08,0x08,0x08,0x08,0x10,0x0A,0x1B,0xFF,0x30,0x08,0x51,0x08,0x10,0x88,0x10,0xC8,0x10,0x48,0x10,0x08,0x10,0x08,0x10,0x48,0x10,0x38,0x10,0x10},
{0xA5,0x4A,0x00,0x00,0x0C,0x04,0x09,0xFE,0x08,0x04,0x10,0x08,0x18,0x30,0x30,0x20,0x50,0x22,0x17,0xFF,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x11,0x20,0x10,0xE0,0x10,0x40},
{0xA5,0x4B,0x00,0x00,0x0C,0x30,0x08,0x20,0x08,0x20,0x10,0x20,0x18,0x22,0x37,0xFF,0x50,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x24,0x17,0xFE,0x10,0x00},
{0xA5,0x4C,0x00,0x00,0x0C,0x60,0x08,0x40,0x0B,0x44,0x12,0x4E,0x1A,0x74,0x32,0xC4,0x57,0x44,0x12,0x44,0x12,0x5C,0x12,0x48,0x12,0x40,0x12,0x42,0x12,0x02,0x12,0x03,0x11,0xFE},
{0xA5,0x4D,0x00,0x00,0x0C,0x0C,0x08,0x08,0x08,0x08,0x10,0x0A,0x17,0xFF,0x30,0x08,0x53,0x08,0x12,0x88,0x14,0x50,0x10,0x50,0x10,0x20,0x10,0x50,0x10,0x88,0x11,0x07,0x16,0x02},
{0xA5,0x4E,0x00,0x00,0x0C,0x68,0x08,0x46,0x08,0x42,0x10,0x40,0x18,0x42,0x30,0x7F,0x57,0xC0,0x10,0x40,0x10,0x20,0x10,0x20,0x10,0x10,0x10,0x12,0x10,0x0A,0x10,0x07,0x10,0x02},
{0xA5,0x4F,0x00,0x00,0x01,0x80,0x02,0x80,0x02,0x40,0x04,0x20,0x08,0x18,0x17,0xE7,0x60,0x02,0x00,0x08,0x1F,0xFC,0x01,0x08,0x01,0x08,0x01,0x48,0x01,0x38,0x01,0x10,0x01,0x00},
{0xA5,0x50,0x00,0x00,0x0C,0x30,0x08,0x20,0x08,0x20,0x13,0x23,0x1A,0x22,0x32,0x22,0x52,0x22,0x12,0x22,0x12,0x22,0x12,0x22,0x12,0x22,0x12,0x22,0x13,0xFE,0x12,0x02,0x12,0x02},
{0xA5,0x51,0x00,0x00,0x0C,0x00,0x08,0x02,0x0B,0xFF,0x10,0x42,0x18,0x42,0x32,0x42,0x51,0xC2,0x10,0xC2,0x10,0x42,0x10,0x82,0x10,0x82,0x11,0x04,0x11,0x44,0x12,0x38,0x14,0x10},
{0xA5,0x52,0x00,0x00,0x01,0x80,0x01,0x02,0x7F,0xFF,0x02,0x00,0x02,0x20,0x04,0x18,0x09,0xEC,0x3E,0x44,0x14,0x40,0x04,0x40,0x04,0x40,0x08,0x42,0x08,0x42,0x10,0x43,0x60,0x3E},
{0xA5,0x53,0x00,0x00,0x10,0x08,0x1F,0xFC,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x1F,0xF8,0x12,0x48,0x02,0x40,0x02,0x40,0x04,0x40,0x04,0x42,0x08,0x42,0x10,0x43,0x60,0x3E},
{0xA5,0x54,0x00,0x00,0x00,0xC0,0x10,0x84,0x1F,0xFE,0x10,0x84,0x10,0x84,0x1F,0xFC,0x10,0x84,0x10,0x84,0x10,0x84,0x7F,0xFF,0x10,0x04,0x10,0x04,0x10,0x24,0x10,0x1C,0x10,0x08},
{0xA5,0x55,0x00,0x00,0x20,0x04,0x3F,0xFE,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x7F,0xFF,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x5C,0x20,0x08},
{0xA5,0x56,0x00,0x00,0x06,0x00,0x04,0x08,0x07,0xFC,0x0C,0x08,0x12,0x10,0x61,0x20,0x00,0xC0,0x03,0x30,0x0D,0x0F,0x70,0xC2,0x00,0x40,0x00,0x18,0x00,0xE0,0x0F,0x00,0x04,0x00},
{0xA5,0x57,0x00,0x00,0x22,0x22,0x3F,0x3F,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x23,0xE2,0x22,0x22,0x22,0x22,0x20,0x02,0x20,0x02,0x20,0x02,0x3F,0xFE,0x20,0x02,0x20,0x02},
{0xA5,0x58,0x00,0x00,0x00,0xC0,0x18,0x86,0x10,0x84,0x10,0x84,0x10,0x84,0x1F,0xFC,0x10,0x84,0x00,0x80,0x00,0x80,0x30,0x83,0x20,0x82,0x20,0x82,0x20,0x82,0x3F,0xFE,0x20,0x02},
{0xA5,0x59,0x00,0x00,0x02,0x20,0x03,0xF0,0x02,0x20,0x02,0x20,0x02,0x20,0x22,0x22,0x3E,0x3F,0x22,0x22,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x3F,0xFE,0x20,0x02},
{0xA5,0x5A,0x00,0x00,0x01,0x03,0x3F,0x82,0x04,0x1A,0x04,0x12,0x04,0x12,0x04,0x92,0x7F,0xD2,0x04,0x12,0x04,0x12,0x04,0x12,0x04,0x02,0x04,0x02,0x04,0x12,0x04,0x0E,0x04,0x04},
{0xA5,0x5B,0x00,0x00,0x18,0x00,0x10,0x00,0x11,0x42,0x7F,0x7F,0x11,0x42,0x11,0x42,0x11,0x42,0x11,0x42,0x11,0x42,0x11,0x42,0x11,0x42,0x21,0x42,0x21,0x7E,0x2E,0x42,0x44,0x00},
{0xA5,0x5C,0x00,0x00,0x00,0x60,0x04,0x40,0x7E,0x40,0x10,0x42,0x13,0xFF,0x10,0x42,0x10,0x42,0x10,0x42,0x10,0x42,0x12,0x82,0x1C,0x84,0x71,0x04,0x21,0x04,0x02,0x38,0x04,0x10},
{0xA5,0x5D,0x00,0x00,0x0C,0x00,0x08,0x04,0x1F,0xFE,0x10,0x04,0x20,0x04,0x4F,0xC4,0x08,0x44,0x08,0x44,0x0F,0xC8,0x08,0x08,0x08,0x78,0x08,0x12,0x08,0x02,0x08,0x03,0x07,0xFE},
{0xA5,0x5E,0x00,0x00,0x0C,0x00,0x08,0x02,0x0F,0xFF,0x11,0x22,0x11,0x22,0x22,0x22,0x4A,0x42,0x06,0x42,0x05,0x82,0x08,0xE2,0x11,0x24,0x22,0x04,0x04,0x44,0x08,0x38,0x00,0x10},
{0xA5,0x5F,0x00,0x00,0x03,0x60,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x44,0x7E,0x7E,0x02,0x40,0x02,0x40,0x02,0x40,0x02,0x40,0x06,0x40,0x1A,0x42,0x62,0x42,0x42,0x43,0x02,0x3E},
{0xA5,0x60,0x00,0x00,0x40,0x04,0x7F,0xFE,0x40,0x00,0x40,0xC0,0x48,0x88,0x4F,0xFC,0x48,0x88,0x48,0x88,0x48,0x88,0x48,0xB8,0x48,0x90,0x40,0x80,0x40,0x02,0x7F,0xFF,0x40,0x00},
{0xA5,0x61,0x00,0x00,0x0C,0x0C,0x08,0x3E,0x0B,0xE0,0x10,0x20,0x18,0x20,0x30,0x22,0x57,0xFF,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20},
{0xA5,0x62,0x00,0x00,0x00,0xC0,0x0C,0x88,0x18,0x84,0x10,0x86,0x20,0x93,0x4F,0xF9,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA5,0x63,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x84,0x3F,0xFE,0x00,0x80,0x0C,0x98,0x08,0x90,0x08,0x12,0x7F,0xFF,0x08,0x10,0x08,0x10,0x10,0x10,0x10,0x10,0x20,0x10,0x40,0x10},
{0xA5,0x64,0x00,0x00,0x01,0x80,0x01,0x00,0x01,0x08,0x01,0xFC,0x01,0x00,0x01,0x02,0x7F,0xFF,0x01,0x00,0x01,0x80,0x01,0x60,0x01,0x18,0x01,0x0C,0x01,0x04,0x01,0x00,0x01,0x00},
{0xA5,0x65,0x00,0x00,0x01,0x80,0x01,0x00,0x01,0x02,0x01,0xFF,0x01,0x00,0x01,0x00,0x21,0x04,0x3F,0xFE,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x3F,0xFC,0x20,0x04},
{0xA5,0x66,0x00,0x00,0x11,0x80,0x1E,0x22,0x10,0x3F,0x11,0xA2,0x11,0x22,0x11,0x22,0x11,0x22,0x11,0x22,0x17,0x22,0x39,0x32,0x11,0x2E,0x02,0x24,0x02,0x20,0x04,0x20,0x08,0x20},
{0xA5,0x67,0x00,0x00,0x20,0x7E,0x3F,0x80,0x20,0x02,0x3F,0xFF,0x20,0x00,0x24,0x08,0x27,0xFC,0x24,0x08,0x24,0x08,0x24,0x88,0x24,0x70,0x24,0x22,0x44,0x02,0x44,0x03,0x43,0xFE},
{0xA5,0x68,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x84,0x3F,0xFE,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x01,0x00,0x01,0x20,0x02,0x10,0x02,0x08,0x04,0xF4,0x3F,0x06,0x10,0x02},
{0xA5,0x69,0x00,0x00,0x00,0x02,0x7F,0xFF,0x00,0x08,0x00,0x08,0x10,0x88,0x1F,0xC8,0x10,0x88,0x10,0x88,0x10,0x88,0x1F,0x88,0x10,0x88,0x00,0x08,0x00,0x48,0x00,0x38,0x00,0x10},
{0xA5,0x6A,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x10,0x84,0x1F,0xFE,0x10,0x04,0x10,0x04,0x10,0x04,0x10,0x04,0x1F,0xFC,0x10,0x04},
{0xA5,0x6B,0x00,0x00,0x03,0x00,0x02,0x00,0x02,0x02,0x7F,0xFF,0x04,0x00,0x04,0x00,0x08,0x00,0x0C,0x04,0x17,0xFE,0x14,0x04,0x24,0x04,0x44,0x04,0x04,0x04,0x07,0xFC,0x04,0x04},
{0xA5,0x6C,0x00,0x00,0x00,0x04,0x3F,0xFE,0x02,0x04,0x02,0x04,0x04,0x04,0x08,0x38,0x10,0x10,0x68,0x04,0x0F,0xFE,0x08,0x04,0x08,0x04,0x08,0x04,0x08,0x04,0x0F,0xFC,0x08,0x04},
{0xA5,0x6D,0x00,0x00,0x00,0x02,0x4B,0xFF,0x78,0x10,0x48,0x10,0x48,0x10,0x48,0x10,0x48,0x10,0x48,0x10,0x48,0x10,0x78,0x10,0x48,0x10,0x40,0x10,0x00,0x90,0x00,0x70,0x00,0x20},
{0xA5,0x6E,0x00,0x00,0x44,0x82,0x7E,0xFF,0x44,0x82,0x44,0x82,0x44,0x82,0x44,0x82,0x44,0x82,0x44,0x82,0x7C,0x82,0x44,0xA2,0x40,0x9C,0x00,0x88,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA5,0x6F,0x00,0x00,0x00,0x02,0x4B,0xFF,0x78,0x42,0x48,0x42,0x48,0x42,0x48,0x42,0x48,0x42,0x48,0x82,0x48,0x82,0x78,0x82,0x49,0x04,0x41,0x04,0x02,0x44,0x04,0x38,0x08,0x10},
{0xA5,0x70,0x00,0x00,0x00,0x02,0x4B,0xFF,0x78,0x02,0x48,0x02,0x48,0x02,0x48,0x0A,0x48,0x12,0x48,0x62,0x4B,0x82,0x79,0x02,0x48,0x04,0x40,0x04,0x00,0x44,0x00,0x38,0x00,0x10},
{0xA5,0x71,0x00,0x00,0x00,0x04,0x7F,0xFE,0x00,0x04,0x00,0x24,0x3F,0xF4,0x00,0x04,0x10,0x44,0x1F,0xE4,0x10,0x44,0x10,0x44,0x1F,0xC4,0x10,0x44,0x00,0x04,0x00,0x38,0x00,0x10},
{0xA5,0x72,0x00,0x00,0x40,0x04,0x7F,0xFE,0x40,0x00,0x40,0x00,0x44,0x10,0x47,0xF8,0x44,0x10,0x44,0x10,0x44,0x10,0x47,0xF0,0x44,0x10,0x40,0x00,0x40,0x02,0x7F,0xFF,0x40,0x00},
{0xA5,0x73,0x00,0x00,0x44,0x03,0x7E,0x62,0x44,0x42,0x44,0x42,0x44,0x42,0x44,0x42,0x44,0x42,0x44,0x42,0x7C,0x46,0x44,0x5A,0x40,0xE2,0x00,0x42,0x00,0x02,0x00,0x02,0x00,0x02},
{0xA5,0x74,0x00,0x00,0x10,0x04,0x1F,0xFE,0x10,0x04,0x10,0x04,0x10,0x04,0x1F,0xFC,0x10,0x04,0x01,0x00,0x7F,0xFF,0x01,0x02,0x02,0x02,0x02,0x02,0x04,0x44,0x18,0x38,0x60,0x10},
{0xA5,0x75,0x00,0x00,0x10,0x04,0x1F,0xFE,0x10,0x04,0x10,0x04,0x10,0x04,0x10,0x04,0x10,0x04,0x1F,0xFC,0x10,0x04,0x06,0x10,0x04,0x08,0x08,0x04,0x08,0x06,0x10,0x03,0x60,0x01},
{0xA5,0x76,0x00,0x00,0x00,0xC0,0x00,0x80,0x20,0x84,0x3F,0xFE,0x20,0x84,0x20,0x84,0x20,0x84,0x3F,0xFC,0x20,0x84,0x00,0x80,0x19,0x00,0x27,0x00,0x22,0xE0,0x0C,0x1F,0x70,0x02},
{0xA5,0x77,0x00,0x00,0x00,0xC0,0x48,0x80,0x7C,0x80,0x48,0x80,0x48,0x86,0x48,0x84,0x48,0x88,0x48,0x90,0x48,0xE0,0x7B,0x80,0x48,0x80,0x40,0x82,0x00,0x82,0x00,0x83,0x00,0x7E},
{0xA5,0x78,0x00,0x00,0x01,0x80,0x01,0x00,0x02,0x10,0x04,0x0C,0x09,0xF6,0x7E,0x03,0x20,0x01,0x08,0x08,0x0F,0xFC,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x08},
{0xA5,0x79,0x00,0x00,0x0C,0x00,0x08,0x02,0x0F,0xFF,0x18,0x02,0x10,0x02,0x24,0x22,0x47,0xF2,0x04,0x22,0x04,0x22,0x04,0x22,0x07,0xE4,0x04,0x24,0x00,0x04,0x00,0x78,0x00,0x10},
{0xA5,0x7A,0x00,0x00,0x00,0x20,0x48,0xF0,0x7C,0x20,0x49,0xA0,0x49,0x20,0x49,0x10,0x49,0x10,0x49,0x10,0x49,0x10,0x7A,0x10,0x4A,0x08,0x42,0x08,0x04,0x04,0x04,0x07,0x18,0x02},
{0xA5,0x7B,0x00,0x00,0x00,0x60,0x44,0x40,0x7C,0x42,0x45,0xFF,0x44,0x42,0x44,0x42,0x44,0x42,0x44,0x42,0x44,0x42,0x7C,0x82,0x44,0x84,0x41,0x04,0x01,0x04,0x02,0x38,0x0C,0x10},
{0xA5,0x7C,0x00,0x00,0x00,0x00,0x40,0x02,0x7F,0xFF,0x42,0x42,0x42,0x42,0x42,0x42,0x44,0x4A,0x44,0x4A,0x48,0x3A,0x50,0x02,0x40,0x02,0x40,0x02,0x7F,0xFE,0x40,0x02,0x00,0x00},
{0xA5,0x7D,0x00,0x00,0x20,0x02,0x3F,0xFF,0x20,0x02,0x20,0xC2,0x20,0x82,0x20,0x82,0x20,0x82,0x21,0x42,0x21,0x42,0x22,0x22,0x22,0x3A,0x2C,0x12,0x20,0x02,0x3F,0xFE,0x20,0x02},
{0xA5,0x7E,0x00,0x00,0x18,0x30,0x10,0x20,0x11,0x20,0x1F,0xA0,0x11,0x20,0x21,0x20,0x22,0x20,0x5A,0xE0,0x04,0x38,0x04,0x27,0x08,0x22,0x08,0x20,0x10,0x20,0x20,0x20,0x00,0x20},
{0xA5,0xA1,0x00,0x00,0x01,0x80,0x01,0x00,0x11,0x08,0x1F,0xFC,0x11,0x08,0x11,0x08,0x11,0x08,0x11,0x0A,0x7F,0xFF,0x02,0x80,0x02,0x40,0x04,0x20,0x04,0x18,0x18,0x07,0x60,0x02},
{0xA5,0xA2,0x00,0x00,0x00,0xC0,0x0C,0x80,0x08,0x80,0x08,0x88,0x1F,0xFC,0x10,0x80,0x20,0x80,0x00,0x82,0x7F,0xFF,0x01,0x40,0x01,0x20,0x02,0x20,0x04,0x18,0x18,0x07,0x60,0x02},
{0xA5,0xA3,0x00,0x00,0x18,0x00,0x10,0x02,0x10,0xFF,0x12,0x42,0x7F,0x42,0x12,0x42,0x12,0x24,0x22,0x24,0x24,0x18,0x54,0x08,0x08,0x14,0x14,0x14,0x12,0x22,0x22,0x42,0x40,0x81},
{0xA5,0xA4,0x00,0x00,0x18,0x08,0x11,0xFC,0x10,0x48,0x12,0x48,0x7F,0x48,0x12,0x52,0x12,0x5F,0x22,0x52,0x64,0x42,0x14,0x42,0x08,0x82,0x14,0x82,0x12,0xA2,0x21,0x1C,0x42,0x08},
{0xA5,0xA5,0x00,0x00,0x00,0x20,0x3F,0xF0,0x04,0x40,0x04,0x42,0x08,0x7F,0x08,0x02,0x17,0xF2,0x60,0x22,0x00,0x4C,0x00,0x80,0x7F,0xFF,0x00,0x80,0x00,0x80,0x07,0x80,0x01,0x00},
{0xA5,0xA6,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x4C,0x04,0x08,0x00,0x08,0x18,0x08,0x60,0x09,0x80,0x0E,0x00,0x08,0x04,0x08,0x04,0x08,0x06,0x07,0xFC,0x00,0x00},
{0xA5,0xA7,0x00,0x00,0x20,0x08,0x3F,0xFC,0x20,0x08,0x20,0x08,0x3F,0xF8,0x20,0x08,0x26,0x00,0x24,0x0C,0x24,0x30,0x24,0xC0,0x27,0x02,0x24,0x02,0x44,0x03,0x43,0xFE,0x40,0x00},
{0xA5,0xA8,0x00,0x00,0x00,0x04,0x7F,0xFE,0x10,0x00,0x10,0x00,0x10,0x08,0x1F,0xFC,0x10,0x08,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08,0x10,0x00,0x10,0x02,0x7F,0xFF,0x00,0x00},
{0xA5,0xA9,0x00,0x00,0x00,0x02,0x03,0xFF,0x00,0x40,0x7E,0x40,0x10,0x80,0x10,0x82,0x11,0xFF,0x10,0x02,0x12,0x02,0x1C,0x02,0x70,0x02,0x20,0x04,0x00,0x44,0x00,0x38,0x00,0x10},
{0xA5,0xAA,0x00,0x00,0x03,0x00,0x02,0x00,0x02,0x02,0x3F,0xFF,0x02,0x00,0x04,0x00,0x04,0x04,0x05,0xFE,0x08,0x20,0x08,0x20,0x10,0x20,0x20,0x20,0x40,0x22,0x07,0xFF,0x00,0x00},
{0xA5,0xAB,0x00,0x00,0x01,0x80,0x01,0x02,0x7F,0xFF,0x00,0x00,0x01,0x80,0x21,0x04,0x3F,0xFE,0x21,0x04,0x21,0x04,0x21,0x04,0x21,0x24,0x21,0x1C,0x21,0x08,0x01,0x00,0x01,0x00},
{0xA5,0xAC,0x00,0x00,0x03,0x00,0x02,0x00,0x02,0x02,0x7F,0xFF,0x04,0x00,0x08,0xC0,0x08,0x84,0x1F,0xFE,0x28,0x84,0x48,0x84,0x08,0xA4,0x08,0x9C,0x08,0x88,0x00,0x80,0x00,0x80},
{0xA5,0xAD,0x00,0x00,0x00,0x08,0x3F,0xFC,0x01,0x00,0x0D,0x20,0x09,0x10,0x11,0x18,0x21,0x08,0x01,0x02,0x7F,0xFF,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00},
{0xA5,0xAE,0x00,0x00,0x18,0x30,0x10,0x20,0x10,0x22,0x20,0xFF,0x66,0x22,0x14,0x22,0x0C,0x22,0x08,0x22,0x08,0x22,0x12,0x42,0x15,0x42,0x79,0x42,0x20,0x82,0x00,0x9C,0x01,0x08},
{0xA5,0xAF,0x00,0x00,0x03,0x00,0x02,0x20,0x04,0x10,0x08,0xEC,0x7F,0x06,0x20,0x02,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x04,0x20,0x08,0x20,0x08,0x20,0x10,0x20,0x20,0x20},
{0xA5,0xB0,0x00,0x00,0x02,0x00,0x7F,0x18,0x02,0x10,0x22,0x10,0x3E,0x10,0x22,0x10,0x20,0x20,0x42,0x20,0x7F,0x20,0x42,0x24,0x02,0x42,0x02,0x4D,0x22,0xF1,0x1C,0x40,0x08,0x00},
{0xA5,0xB1,0x00,0x00,0x06,0x60,0x04,0x48,0x7F,0xFC,0x04,0x48,0x24,0x48,0x3F,0xF8,0x24,0x48,0x44,0x42,0x7F,0xFF,0x44,0x42,0x04,0x42,0x08,0x42,0x08,0x5C,0x10,0x48,0x20,0x40},
{0xA5,0xB2,0x00,0x00,0x01,0x00,0x00,0xCC,0x00,0x48,0x06,0x08,0x04,0x10,0x04,0x10,0x24,0x24,0x24,0x22,0x24,0x43,0x44,0x81,0x45,0x08,0x06,0x08,0x1C,0x0C,0x63,0xF8,0x00,0x00},
{0xA5,0xB3,0x00,0x00,0x00,0x68,0x00,0x46,0x10,0x40,0x1F,0xFF,0x10,0x40,0x10,0x40,0x10,0x46,0x10,0x24,0x10,0x28,0x10,0x10,0x10,0x32,0x20,0x4A,0x21,0x8A,0x26,0x07,0x40,0x02},
{0xA5,0xB4,0x00,0x00,0x0C,0x00,0x08,0x02,0x09,0xFF,0x7E,0x10,0x08,0x10,0x08,0x10,0x0A,0x10,0x0C,0x10,0x78,0x10,0x28,0x10,0x08,0x10,0x08,0x10,0x48,0x90,0x38,0x70,0x10,0x20},
{0xA5,0xB5,0x00,0x00,0x18,0x08,0x13,0xFC,0x10,0x88,0x7C,0x88,0x10,0x88,0x10,0x92,0x14,0x9F,0x18,0x92,0x70,0x82,0x51,0x02,0x11,0x02,0x11,0x04,0x12,0x04,0x72,0x38,0x24,0x10},
{0xA5,0xB6,0x00,0x00,0x18,0x10,0x10,0xF8,0x10,0x10,0x7D,0x90,0x11,0x10,0x11,0x10,0x15,0x10,0x19,0x08,0x71,0x08,0x51,0x08,0x11,0x08,0x12,0x08,0x12,0x04,0x72,0x07,0x24,0x02},
{0xA5,0xB7,0x00,0x00,0x0C,0x30,0x08,0x20,0x0A,0x20,0x7F,0x20,0x08,0x20,0x08,0x30,0x09,0x28,0x0E,0x26,0x78,0x23,0x28,0x21,0x08,0x20,0x08,0x20,0x48,0x20,0x38,0x20,0x10,0x20},
{0xA5,0xB8,0x00,0x00,0x00,0x0C,0x10,0x7E,0x1F,0xC0,0x10,0x00,0x10,0x00,0x10,0x02,0x1F,0xFF,0x10,0x40,0x13,0x40,0x10,0xC0,0x10,0x70,0x20,0x58,0x20,0x48,0x20,0x40,0x40,0x40},
{0xA5,0xB9,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x08,0x00,0x00,0x00,0x02,0x7F,0xFF,0x00,0x00},
{0xA5,0xBA,0x00,0x00,0x01,0xA0,0x01,0x18,0x01,0x08,0x01,0x02,0x7F,0xFF,0x01,0x00,0x0D,0x30,0x09,0x20,0x09,0x20,0x09,0x20,0x11,0x22,0x11,0x22,0x21,0x23,0x41,0x1E,0x01,0x00},
{0xA5,0xBB,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x82,0x7F,0xFF,0x01,0xC0,0x02,0xA0,0x02,0xA0,0x04,0x90,0x04,0x88,0x08,0x88,0x10,0xA4,0x67,0xF3,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA5,0xBC,0x00,0x00,0x00,0xC0,0x00,0x88,0x1F,0xFC,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x01,0x80,0x02,0xC0,0x02,0xA0,0x04,0x98,0x18,0x87,0x60,0x82,0x00,0x80,0x00,0x80},
{0xA5,0xBD,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x84,0x3F,0xFE,0x01,0x80,0x02,0xC0,0x02,0xA0,0x04,0x98,0x18,0x87,0x60,0x82,0x00,0x80,0x00,0x80},
{0xA5,0xBE,0x00,0x00,0x0C,0x60,0x08,0x40,0x0A,0x40,0x7F,0x40,0x18,0x40,0x18,0x40,0x2C,0x40,0x2B,0x40,0x29,0x40,0x48,0x40,0x08,0x42,0x08,0x42,0x08,0x43,0x08,0x3E,0x08,0x00},
{0xA5,0xBF,0x00,0x00,0x00,0x04,0x7F,0xFE,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x18,0x88,0x10,0xFC,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x82,0x7F,0xFF,0x00,0x00},
{0xA5,0xC0,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x08,0x0B,0x08,0x08,0xC8,0x08,0x0A,0x7F,0xFF,0x10,0x08,0x13,0x08,0x10,0xC8,0x10,0x0A,0x3F,0xFF,0x20,0x10,0x00,0xF0,0x00,0x20},
{0xA5,0xC1,0x00,0x00,0x10,0x04,0x1F,0xFE,0x10,0x04,0x10,0x04,0x1F,0xFC,0x10,0x44,0x10,0x40,0x1F,0xFF,0x10,0x20,0x10,0x20,0x10,0x92,0x17,0x12,0x78,0x0A,0x20,0x07,0x00,0x02},
{0xA5,0xC2,0x00,0x00,0x10,0x7C,0x1F,0xC0,0x10,0x40,0x10,0x40,0x10,0x44,0x1F,0xFE,0x10,0x20,0x10,0x20,0x10,0x20,0x11,0x90,0x1E,0x12,0x70,0x0A,0x20,0x4A,0x0F,0xE7,0x00,0x02},
{0xA5,0xC3,0x00,0x00,0x0C,0x00,0x03,0x80,0x00,0x00,0x1F,0x80,0x00,0x80,0x04,0x86,0x7E,0xD8,0x04,0xA0,0x04,0xA0,0x08,0x90,0x08,0x88,0x10,0x87,0x64,0x82,0x03,0x80,0x01,0x00},
{0xA5,0xC4,0x00,0x00,0x20,0x30,0x10,0x20,0x10,0x20,0x44,0x20,0x24,0x22,0x2B,0xFF,0x08,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x60,0x20,0x20,0x20,0x20,0x20,0x60,0x20,0x20,0x20},
{0xA5,0xC5,0x00,0x00,0x20,0x02,0x17,0xFF,0x10,0x20,0x40,0x20,0x24,0x20,0x28,0x20,0x08,0x20,0x10,0x20,0x10,0x20,0x60,0x20,0x20,0x20,0x20,0x20,0x61,0x20,0x20,0xE0,0x00,0x40},
{0xA5,0xC6,0x00,0x00,0x20,0x00,0x12,0x04,0x13,0xFE,0x42,0x04,0x22,0x04,0x26,0x04,0x0A,0x04,0x0A,0x44,0x12,0x38,0x12,0x10,0x62,0x02,0x22,0x02,0x22,0x02,0x62,0x03,0x21,0xFE},
{0xA5,0xC7,0x00,0x00,0x4C,0x00,0x29,0x04,0x11,0xFE,0x29,0x04,0x49,0x04,0x05,0x04,0x0D,0x04,0x15,0x44,0x15,0x38,0x25,0x10,0x45,0x00,0x09,0x02,0x09,0x02,0x71,0x03,0x20,0xFE},
{0xA5,0xC8,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x01,0x00,0x02,0x00,0x04,0x30,0x18,0x20,0x06,0x40,0x01,0x80,0x01,0x10,0x02,0x08,0x04,0x74,0x3F,0x86,0x10,0x02,0x00,0x00},
{0xA5,0xC9,0x00,0x00,0x00,0x04,0x3F,0xFE,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x88,0x1F,0xFC,0x00,0x80,0x00,0xA0,0x00,0x98,0x00,0x88,0x00,0x82,0x7F,0xFF,0x00,0x00},
{0xA5,0xCA,0x00,0x00,0x00,0x18,0x11,0xFC,0x1F,0x10,0x11,0x10,0x11,0x10,0x11,0x10,0x11,0x10,0x11,0x10,0x11,0x08,0x11,0x08,0x11,0x48,0x21,0x24,0x21,0x74,0x23,0x92,0x40,0x01},
{0xA5,0xCB,0x00,0x00,0x00,0x04,0x7F,0xFE,0x04,0x00,0x04,0x00,0x04,0x20,0x0F,0xF0,0x08,0x20,0x0A,0x20,0x09,0x20,0x09,0x20,0x10,0x20,0x10,0xE2,0x17,0x22,0x78,0x23,0x20,0x1E},
{0xA5,0xCC,0x00,0x00,0x0C,0x18,0x08,0x10,0x08,0x12,0x7F,0xFF,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x0F,0xF0,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x0F,0xF0,0x08,0x10},
{0xA5,0xCD,0x00,0x00,0x00,0xC0,0x0C,0x80,0x08,0x80,0x08,0x84,0x1F,0xFE,0x10,0x80,0x20,0x80,0x40,0x88,0x1F,0xFC,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x00},
{0xA5,0xCE,0x00,0x00,0x10,0x04,0x1F,0xFE,0x10,0x84,0x10,0x84,0x10,0x84,0x1F,0xFC,0x10,0x84,0x10,0x84,0x10,0x84,0x1F,0xFC,0x10,0x84,0x20,0x84,0x20,0xA4,0x20,0x9C,0x40,0x08},
{0xA5,0xCF,0x00,0x00,0x20,0x08,0x3F,0xFC,0x21,0x08,0x21,0x08,0x3F,0xF8,0x21,0x08,0x21,0x08,0x3F,0xF8,0x21,0x08,0x21,0x08,0x21,0x48,0x21,0x3A,0x41,0x12,0x41,0x03,0x00,0xFE},
{0xA5,0xD0,0x00,0x00,0x00,0x00,0x20,0x02,0x3F,0xFF,0x20,0x82,0x20,0x82,0x20,0x82,0x20,0x82,0x3F,0xFE,0x20,0x82,0x20,0x82,0x20,0x82,0x20,0x82,0x3F,0xFE,0x20,0x02,0x00,0x00},
{0xA5,0xD1,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x80,0x20,0x82,0x3F,0xFF,0x20,0x82,0x20,0x82,0x20,0x82,0x3F,0xFE,0x20,0x82,0x20,0x82,0x20,0x82,0x20,0x82,0x3F,0xFE,0x20,0x02},
{0xA5,0xD2,0x00,0x00,0x20,0x02,0x3F,0xFF,0x20,0x82,0x20,0x82,0x20,0x82,0x3F,0xFE,0x20,0x82,0x20,0x82,0x20,0x82,0x3F,0xFE,0x20,0x82,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA5,0xD3,0x00,0x00,0x00,0xC0,0x00,0x80,0x20,0x82,0x3F,0xFF,0x20,0x82,0x20,0x82,0x3F,0xFE,0x20,0x82,0x20,0x82,0x20,0x82,0x3F,0xFE,0x20,0x82,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA5,0xD4,0x00,0x00,0x00,0x04,0x7F,0xFE,0x00,0x84,0x00,0x88,0x00,0x80,0x00,0x80,0x18,0x88,0x10,0xFC,0x10,0x80,0x10,0x80,0x10,0x80,0x28,0x80,0x26,0x80,0x21,0x83,0x40,0x7C},
{0xA5,0xD5,0x00,0x00,0x01,0x80,0x01,0x00,0x22,0x04,0x3F,0xFE,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x3F,0xFC,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x3F,0xFC,0x20,0x04},
{0xA5,0xD6,0x00,0x00,0x00,0x60,0x00,0x40,0x10,0x42,0x1F,0xFF,0x10,0x42,0x10,0x40,0x10,0x48,0x1F,0xFC,0x12,0x08,0x11,0x10,0x10,0xA0,0x20,0x40,0x20,0xB0,0x23,0x0F,0x4C,0x02},
{0xA5,0xD7,0x00,0x00,0x20,0x04,0x3F,0xFE,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x7F,0xFF,0x00,0x00},
{0xA5,0xD8,0x00,0x00,0x10,0x04,0x1F,0xFE,0x10,0x04,0x10,0x04,0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x04,0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x04,0x10,0x04,0x1F,0xFC,0x10,0x04},
{0xA5,0xD9,0x00,0x00,0x00,0x10,0x1F,0xF8,0x00,0x10,0x03,0x60,0x00,0x82,0x7F,0xFF,0x01,0x82,0x02,0x84,0x02,0x88,0x04,0x80,0x18,0x80,0x60,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xA5,0xDA,0x00,0x00,0x0C,0x00,0x08,0x00,0x08,0x04,0x1F,0xFE,0x10,0x80,0x20,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x01,0x40,0x01,0x20,0x02,0x20,0x04,0x18,0x18,0x07,0x60,0x02},
{0xA5,0xDB,0x00,0x00,0x00,0x02,0x7F,0xFF,0x04,0x00,0x04,0x00,0x04,0x00,0x08,0x04,0x0F,0xFE,0x18,0x04,0x18,0x04,0x28,0x04,0x48,0x04,0x08,0x04,0x08,0x04,0x0F,0xFC,0x08,0x04},
{0xA5,0xDC,0x00,0x00,0x00,0x08,0x1F,0xFC,0x00,0x00,0x00,0x00,0x00,0x02,0x7F,0xFF,0x00,0x80,0x00,0x80,0x18,0x90,0x10,0x88,0x20,0x84,0x20,0x86,0x40,0x82,0x00,0x80,0x00,0x80},
{0xA5,0xDD,0x00,0x00,0x00,0x18,0x00,0xFC,0x3F,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x01,0x80,0x02,0xC0,0x02,0xA0,0x04,0x98,0x18,0x87,0x60,0x82,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA5,0xDE,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x40,0x44,0x03,0xE0,0x00,0x40,0x06,0x40,0x04,0x20,0x04,0x20,0x08,0x10,0x08,0x10,0x10,0x08,0x20,0x07,0x40,0x02},
{0xA5,0xDF,0x00,0x00,0x01,0x80,0x01,0x00,0x01,0x04,0x7F,0xFE,0x00,0x00,0x10,0x18,0x08,0x10,0x08,0x10,0x0C,0x20,0x04,0x20,0x04,0x20,0x04,0x40,0x00,0x42,0x7F,0xFF,0x00,0x00},
{0xA5,0xE0,0x00,0x00,0x00,0x10,0x3F,0xF8,0x00,0x10,0x00,0x20,0x04,0xC0,0x7E,0x86,0x04,0xD8,0x04,0xA0,0x08,0x98,0x10,0x87,0x60,0x82,0x07,0x80,0x01,0x00,0x00,0x02,0x7F,0xFF},
{0xA5,0xE1,0x00,0x00,0x00,0x04,0x7F,0xFE,0x01,0x00,0x01,0x08,0x3F,0xFC,0x01,0x00,0x01,0x02,0x7F,0xFF,0x02,0x00,0x02,0x20,0x04,0x10,0x04,0x08,0x08,0xF4,0x7F,0x06,0x20,0x02},
{0xA5,0xE2,0x00,0x00,0x00,0x18,0x08,0x7C,0x0F,0x80,0x08,0x00,0x08,0x04,0x0F,0xFE,0x08,0x20,0x08,0x20,0x08,0x20,0x08,0x22,0x7F,0xFF,0x00,0x00,0x06,0x00,0x18,0x00,0x60,0x00},
{0xA5,0xE3,0x00,0x00,0x00,0x18,0x08,0x7C,0x0F,0x80,0x08,0x00,0x08,0x04,0x0F,0xFE,0x08,0x20,0x08,0x20,0x08,0x20,0x08,0x20,0x7F,0xFF,0x00,0x00,0x00,0x30,0x00,0x0E,0x00,0x02},
{0xA5,0xE4,0x00,0x00,0x0C,0x30,0x08,0x20,0x09,0x20,0x0F,0xA0,0x08,0x20,0x08,0x20,0x08,0x20,0x49,0x20,0x7F,0xA0,0x41,0x20,0x41,0x22,0x41,0x22,0x41,0x22,0x7F,0x23,0x41,0x1E},
{0xA5,0xE5,0x00,0x00,0x00,0x04,0x7F,0xFE,0x04,0x00,0x04,0x10,0x07,0xF8,0x04,0x10,0x05,0x10,0x08,0x90,0x08,0xA0,0x0A,0x20,0x11,0x20,0x11,0x40,0x00,0x40,0x00,0x42,0x7F,0xFF},
{0xA5,0xE6,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x00,0x0C,0x08,0x10,0x06,0x66,0x13,0x0A,0x11,0x09,0x20,0x01,0x40,0x00,0x80,0x01,0x60,0x02,0x18,0x0C,0x07,0x70,0x02},
{0xA5,0xE7,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x02,0x20,0x02,0x20,0x1A,0x28,0x12,0x24,0x12,0x24,0x22,0x22,0x22,0x22,0x44,0x22,0x04,0x20,0x08,0x20,0x09,0xE0,0x10,0x40},
{0xA5,0xE8,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x01,0x00,0x06,0x00,0x18,0x00,0x06,0x60,0x00,0x8C,0x01,0x10,0x06,0x20,0x18,0x40,0x61,0xA0,0x06,0x10,0x18,0x0C,0x60,0x04},
{0xA5,0xE9,0x00,0x00,0x0C,0x30,0x08,0x20,0x08,0x22,0x13,0xFF,0x18,0x80,0x30,0x84,0x50,0xFE,0x10,0x84,0x10,0x84,0x10,0x84,0x11,0x04,0x11,0x04,0x11,0x44,0x12,0x38,0x14,0x10},
{0xA5,0xEA,0x00,0x00,0x0C,0x30,0x08,0x20,0x08,0x22,0x13,0xFF,0x18,0x00,0x30,0x88,0x50,0xFC,0x10,0x88,0x10,0x88,0x10,0x88,0x10,0x88,0x11,0x09,0x11,0x09,0x11,0x09,0x12,0x07},
{0xA5,0xEB,0x00,0x00,0x0C,0x30,0x08,0x20,0x08,0x20,0x11,0x23,0x19,0x22,0x31,0x24,0x52,0x24,0x12,0x68,0x10,0x50,0x10,0x50,0x10,0x90,0x10,0x88,0x11,0x08,0x12,0x07,0x14,0x02},
{0xA5,0xEC,0x00,0x00,0x0C,0x00,0x08,0x04,0x0B,0xFE,0x10,0x44,0x10,0x44,0x37,0xFF,0x50,0x44,0x10,0x44,0x13,0xFC,0x10,0x44,0x10,0x40,0x10,0x80,0x10,0x80,0x11,0x00,0x12,0x00},
{0xA5,0xED,0x00,0x00,0x0C,0x30,0x08,0x20,0x08,0x24,0x13,0xFE,0x18,0x20,0x30,0x20,0x50,0x22,0x17,0xFF,0x10,0x20,0x10,0x50,0x10,0x50,0x10,0x88,0x10,0x88,0x11,0x07,0x16,0x02},
{0xA5,0xEE,0x00,0x00,0x0C,0x04,0x0B,0xFE,0x08,0x40,0x10,0x40,0x18,0x40,0x30,0x44,0x53,0xFE,0x10,0x84,0x10,0x84,0x10,0x84,0x10,0x84,0x10,0x84,0x10,0x84,0x17,0xFF,0x10,0x00},
{0xA5,0xEF,0x00,0x00,0x0C,0x68,0x08,0x46,0x08,0x40,0x10,0x44,0x18,0x4E,0x30,0x70,0x53,0xC0,0x10,0x46,0x10,0x24,0x10,0x28,0x10,0x30,0x10,0x51,0x11,0x89,0x16,0x05,0x10,0x03},
{0xA5,0xF0,0x00,0x00,0x0C,0x30,0x08,0x20,0x08,0x20,0x10,0x22,0x1B,0xFF,0x30,0x60,0x50,0xB0,0x10,0xA8,0x11,0x28,0x11,0x24,0x12,0x27,0x14,0x22,0x10,0x20,0x10,0x20,0x10,0x20},
{0xA5,0xF1,0x00,0x00,0x0C,0x34,0x08,0x22,0x08,0x20,0x10,0x22,0x1B,0xFF,0x30,0x20,0x50,0x20,0x10,0x50,0x10,0x50,0x10,0x50,0x10,0x88,0x10,0x88,0x11,0x04,0x11,0x07,0x12,0x02},
{0xA5,0xF2,0x00,0x00,0x0C,0x30,0x08,0x20,0x08,0x20,0x12,0x22,0x1B,0xFF,0x32,0x22,0x52,0x22,0x12,0x22,0x12,0x22,0x13,0xFE,0x12,0x22,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20},
{0xA5,0xF3,0x00,0x00,0x0C,0x30,0x09,0xA0,0x09,0x24,0x11,0xFE,0x19,0x20,0x32,0x20,0x54,0x20,0x10,0x22,0x17,0xFF,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20},
{0xA5,0xF4,0x00,0x00,0x0C,0x0C,0x08,0x3E,0x0B,0xE0,0x10,0x20,0x18,0x20,0x30,0x20,0x50,0x22,0x17,0xFF,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x24,0x11,0xFE,0x10,0x00},
{0xA5,0xF5,0x00,0x00,0x0C,0x00,0x08,0xD2,0x0B,0x1F,0x12,0x12,0x1A,0x12,0x32,0x12,0x52,0x12,0x12,0x12,0x12,0x12,0x12,0x52,0x12,0x92,0x17,0x1E,0x12,0x14,0x10,0x10,0x10,0x10},
{0xA5,0xF6,0x00,0x00,0x0B,0x18,0x0A,0x10,0x0A,0x10,0x12,0x10,0x1A,0x10,0x32,0x92,0x53,0xDF,0x12,0x10,0x12,0x10,0x12,0x10,0x12,0x10,0x12,0x52,0x12,0x92,0x17,0x13,0x12,0x0E},
{0xA5,0xF7,0x00,0x00,0x0C,0x10,0x08,0xF8,0x08,0x10,0x11,0x08,0x19,0x08,0x32,0x07,0x54,0x02,0x13,0xFC,0x10,0x84,0x10,0x84,0x10,0x84,0x11,0x04,0x11,0x04,0x12,0x38,0x14,0x10},
{0xA5,0xF8,0x00,0x00,0x01,0x80,0x02,0x80,0x02,0x40,0x04,0x20,0x08,0x18,0x10,0xC7,0x60,0x82,0x0C,0x80,0x08,0x88,0x08,0xFC,0x08,0x80,0x08,0x80,0x08,0x80,0x08,0x82,0x7F,0xFF},
{0xA5,0xF9,0x00,0x00,0x0C,0x04,0x09,0xFE,0x08,0x84,0x10,0x84,0x18,0x88,0x30,0x8A,0x50,0xFF,0x11,0x42,0x11,0x44,0x11,0x24,0x11,0x28,0x12,0x10,0x12,0x28,0x12,0x47,0x14,0x82},
{0xA5,0xFA,0x00,0x00,0x00,0xC0,0x00,0x80,0x20,0x8C,0x18,0x98,0x0C,0x90,0x04,0xA0,0x00,0x82,0x7F,0xFF,0x04,0x40,0x04,0x40,0x04,0x40,0x08,0x42,0x08,0x42,0x10,0x43,0x60,0x3E},
{0xA5,0xFB,0x00,0x00,0x30,0x06,0x26,0x34,0x21,0x44,0x20,0x84,0x23,0x64,0x2C,0x14,0x20,0x04,0x3F,0xFC,0x24,0x44,0x04,0x40,0x04,0x40,0x04,0x42,0x08,0x42,0x10,0x43,0x60,0x3E},
{0xA5,0xFC,0x00,0x00,0x03,0x60,0x02,0x40,0x42,0x46,0x22,0x4C,0x32,0x58,0x12,0x60,0x02,0x40,0x0A,0x60,0x12,0x58,0x62,0x4C,0x44,0x44,0x04,0x41,0x08,0x41,0x10,0x41,0x60,0x3F},
{0xA5,0xFD,0x00,0x00,0x00,0xC0,0x0C,0x80,0x08,0x88,0x1F,0xFC,0x10,0x80,0x20,0x80,0x00,0x82,0x7F,0xFF,0x04,0x20,0x04,0x20,0x04,0x20,0x08,0x22,0x08,0x22,0x10,0x23,0x60,0x1E},
{0xA5,0xFE,0x00,0x00,0x00,0x80,0x1F,0xC0,0x00,0x80,0x01,0x60,0x06,0x18,0x18,0x07,0x6F,0xFA,0x00,0x80,0x00,0x80,0x00,0x90,0x0F,0xF8,0x00,0x80,0x00,0x80,0x00,0x84,0x3F,0xFE},
{0xA6,0x40,0x00,0x00,0x06,0x30,0x04,0x20,0x04,0x20,0x04,0x24,0x3F,0xFE,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x22,0x7F,0xFF,0x00,0x00,0x0C,0x20,0x08,0x18,0x10,0x06,0x60,0x02},
{0xA6,0x41,0x00,0x00,0x00,0x02,0x7F,0xFF,0x00,0x80,0x10,0x84,0x1F,0xFE,0x10,0x84,0x10,0x84,0x1F,0xFC,0x10,0x84,0x10,0x84,0x7F,0xFF,0x10,0x04,0x10,0x04,0x10,0x3C,0x10,0x08},
{0xA6,0x42,0x00,0x00,0x00,0x30,0x40,0x20,0x40,0x20,0x24,0x20,0x2B,0xA6,0x08,0xA8,0x10,0xB0,0x11,0x28,0x11,0x28,0x61,0x24,0x22,0x27,0x24,0x22,0x61,0x20,0x20,0xE0,0x00,0x40},
{0xA6,0x43,0x00,0x00,0x00,0x83,0x7F,0xC2,0x08,0x1A,0x08,0x12,0x11,0x12,0x1F,0x92,0x11,0x12,0x21,0x12,0x52,0x12,0x0A,0x12,0x04,0x02,0x04,0x02,0x08,0x12,0x10,0x0E,0x60,0x04},
{0xA6,0x44,0x00,0x00,0x00,0x83,0x7F,0xC2,0x11,0x1A,0x11,0x12,0x11,0x12,0x11,0x12,0x7F,0xD2,0x11,0x12,0x11,0x12,0x11,0x12,0x11,0x12,0x21,0x02,0x21,0x02,0x21,0x0E,0x41,0x04},
{0xA6,0x45,0x00,0x00,0x1A,0x03,0x11,0x02,0x11,0x1A,0x10,0x12,0x17,0x92,0x78,0x12,0x11,0x92,0x11,0x12,0x0A,0x12,0x0A,0x12,0x04,0x82,0x0A,0x82,0x12,0x82,0x61,0xCE,0x00,0x84},
{0xA6,0x46,0x00,0x00,0x18,0x03,0x10,0x02,0x10,0x5A,0x1F,0xD2,0x25,0x52,0x25,0x52,0x49,0x52,0x0A,0x52,0x12,0x52,0x14,0x52,0x24,0x92,0x08,0x82,0x10,0x82,0x07,0x0E,0x02,0x04},
{0xA6,0x47,0x00,0x00,0x21,0x03,0x3F,0x82,0x21,0x32,0x21,0x22,0x21,0x22,0x3F,0x22,0x21,0x22,0x21,0x22,0x21,0x22,0x3F,0x22,0x21,0x22,0x21,0x02,0x49,0x12,0x47,0x0E,0x42,0x04},
{0xA6,0x48,0x00,0x00,0x00,0xC0,0x0C,0x88,0x10,0x86,0x63,0x83,0x01,0x19,0x00,0x60,0x01,0x80,0x0E,0x00,0x70,0x84,0x0F,0xFE,0x00,0x84,0x01,0x04,0x02,0x44,0x0C,0x38,0x70,0x10},
{0xA6,0x49,0x00,0x00,0x0C,0x00,0x08,0x02,0x1F,0xFF,0x10,0x02,0x20,0x02,0x44,0xC2,0x12,0x92,0x11,0x12,0x12,0x92,0x14,0x94,0x1F,0xF4,0x10,0x14,0x00,0x04,0x00,0x38,0x00,0x10},
{0xA6,0x4A,0x00,0x00,0x40,0x04,0x7F,0xFE,0x40,0x00,0x40,0x08,0x5F,0xFC,0x40,0x80,0x40,0x90,0x4F,0xF8,0x40,0x80,0x40,0x88,0x5F,0xFC,0x40,0x00,0x40,0x02,0x7F,0xFF,0x40,0x00},
{0xA6,0x4B,0x00,0x00,0x40,0x04,0x7F,0xFE,0x40,0x00,0x44,0x78,0x47,0x80,0x44,0x00,0x44,0x08,0x47,0xFC,0x44,0x40,0x48,0x40,0x48,0x40,0x50,0x40,0x40,0x02,0x7F,0xFF,0x40,0x00},
{0xA6,0x4C,0x00,0x00,0x02,0x00,0x27,0x42,0x38,0x7F,0x20,0x42,0x22,0x42,0x3F,0x42,0x20,0x42,0x20,0x42,0x20,0x42,0x22,0x42,0x3F,0x5E,0x20,0x44,0x00,0x40,0x00,0x40,0x00,0x40},
{0xA6,0x4D,0x00,0x00,0x04,0x00,0x07,0xE0,0x0C,0x20,0x09,0xC0,0x10,0x82,0x3F,0xFF,0x50,0x00,0x12,0x10,0x13,0xF8,0x12,0x10,0x12,0x10,0x12,0x72,0x22,0x22,0x22,0x03,0x41,0xFE},
{0xA6,0x4E,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x84,0x3F,0xFE,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x08},
{0xA6,0x4F,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x80,0x1F,0xFC,0x10,0x84,0x10,0x84,0x1F,0xFC,0x00,0x80,0x18,0x80,0x15,0x00,0x23,0x00,0x02,0xC0,0x0C,0x38,0x70,0x07},
{0xA6,0x50,0x00,0x00,0x20,0x02,0x3F,0xFF,0x20,0x02,0x20,0x12,0x2F,0xFA,0x20,0x02,0x24,0x12,0x27,0xF2,0x24,0x12,0x24,0x12,0x27,0xF2,0x24,0x12,0x20,0x02,0x20,0x0E,0x20,0x04},
{0xA6,0x51,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x88,0x20,0x82,0x3F,0xFF,0x20,0x82,0x20,0x82,0x20,0x82,0x20,0x8E,0x20,0x84,0x00,0x80,0x00,0x80},
{0xA6,0x52,0x00,0x00,0x00,0x30,0x48,0x20,0x7C,0x20,0x48,0x20,0x48,0x20,0x48,0x24,0x4B,0xFE,0x48,0x20,0x48,0x20,0x78,0x20,0x48,0x20,0x40,0x20,0x00,0x22,0x0F,0xFF,0x00,0x00},
{0xA6,0x53,0x00,0x00,0x00,0x04,0x49,0xFE,0x7C,0x20,0x48,0x20,0x48,0x20,0x48,0x22,0x4B,0xFF,0x48,0x20,0x48,0x20,0x78,0x20,0x48,0x20,0x40,0x20,0x01,0x20,0x00,0xE0,0x00,0x40},
{0xA6,0x54,0x00,0x00,0x00,0x0C,0x48,0x08,0x7C,0x08,0x48,0x0A,0x4B,0xFF,0x48,0x08,0x48,0x08,0x49,0x08,0x48,0xC8,0x78,0x48,0x48,0x08,0x40,0x08,0x00,0x48,0x00,0x38,0x00,0x10},
{0xA6,0x55,0x00,0x00,0x06,0x00,0x04,0x08,0x0F,0xFC,0x14,0x10,0x63,0x20,0x00,0xC0,0x03,0x38,0x0C,0x07,0x70,0x02,0x0F,0xF8,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x08},
{0xA6,0x56,0x00,0x00,0x01,0x80,0x01,0x00,0x22,0x02,0x3F,0xFF,0x20,0x02,0x24,0x22,0x27,0xF2,0x24,0x22,0x24,0x22,0x24,0x22,0x27,0xE2,0x24,0x22,0x20,0x02,0x20,0x0E,0x20,0x04},
{0xA6,0x57,0x00,0x00,0x01,0x80,0x01,0x08,0x03,0xFC,0x04,0x10,0x0A,0x20,0x31,0x40,0x01,0x80,0x02,0x04,0x07,0xFE,0x1C,0x04,0x64,0x04,0x04,0x04,0x04,0x04,0x07,0xFC,0x04,0x04},
{0xA6,0x58,0x00,0x00,0x01,0x80,0x01,0x40,0x02,0x20,0x04,0x10,0x08,0x0C,0x17,0xF7,0x60,0x02,0x08,0x08,0x0F,0xFC,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x08},
{0xA6,0x59,0x00,0x00,0x00,0x60,0x48,0x40,0x7C,0x82,0x48,0xFF,0x49,0x00,0x4A,0x08,0x48,0xFC,0x48,0x08,0x48,0x10,0x78,0x20,0x48,0x42,0x40,0x82,0x01,0x02,0x01,0x03,0x00,0xFE},
{0xA6,0x5A,0x00,0x00,0x00,0x0C,0x20,0xFE,0x3F,0x80,0x20,0x00,0x20,0x02,0x3F,0xFF,0x20,0x00,0x24,0x04,0x27,0xFE,0x24,0x04,0x24,0x04,0x24,0x04,0x44,0x04,0x47,0xFC,0x44,0x04},
{0xA6,0x5B,0x00,0x00,0x00,0x60,0x48,0x40,0x7C,0x40,0x48,0x80,0x48,0x8C,0x4B,0x08,0x48,0x90,0x48,0xD0,0x48,0x20,0x78,0x48,0x48,0x44,0x40,0x86,0x01,0x3B,0x07,0xC1,0x02,0x01},
{0xA6,0x5C,0x00,0x00,0x00,0x18,0x00,0x7C,0x4B,0xC0,0x78,0x40,0x48,0x40,0x48,0x42,0x48,0x4F,0x48,0x70,0x4B,0xC0,0x48,0x40,0x78,0x40,0x48,0x42,0x40,0x42,0x00,0x43,0x00,0x3E},
{0xA6,0x5D,0x00,0x00,0x20,0x02,0x3F,0xFF,0x20,0x02,0x20,0xC2,0x20,0x92,0x2F,0xFA,0x20,0x82,0x21,0x42,0x21,0x42,0x22,0x22,0x22,0x3A,0x2C,0x12,0x20,0x02,0x3F,0xFE,0x20,0x02},
{0xA6,0x5E,0x00,0x00,0x00,0x00,0x20,0x02,0x3F,0xFF,0x20,0x02,0x20,0x02,0x24,0x12,0x27,0xFA,0x24,0x12,0x24,0x12,0x27,0xF2,0x24,0x12,0x20,0x02,0x20,0x02,0x3F,0xFE,0x20,0x02},
{0xA6,0x5F,0x00,0x00,0x20,0x02,0x3F,0xFF,0x20,0x02,0x27,0xF2,0x20,0x22,0x20,0x42,0x20,0x52,0x2F,0xFA,0x20,0x42,0x20,0x42,0x23,0xC2,0x20,0x82,0x20,0x02,0x3F,0xFE,0x20,0x02},
{0xA6,0x60,0x00,0x00,0x18,0xC3,0x10,0x9A,0x10,0x92,0x14,0x92,0x7E,0x92,0x10,0x92,0x10,0x92,0x10,0x92,0x12,0x92,0x1C,0x92,0x70,0x92,0x20,0x92,0x01,0x02,0x01,0x02,0x02,0x02},
{0xA6,0x61,0x00,0x00,0x18,0x30,0x10,0x20,0x11,0xA0,0x11,0x24,0x7D,0x3E,0x11,0xE4,0x17,0x24,0x11,0x24,0x11,0x2C,0x11,0x24,0x1D,0x20,0x71,0x02,0x21,0x02,0x01,0x03,0x00,0xFE},
{0xA6,0x62,0x00,0x00,0x03,0x00,0x02,0x00,0x02,0x02,0x7F,0xFF,0x04,0x00,0x08,0x30,0x08,0x20,0x18,0x24,0x29,0xFE,0x48,0x20,0x08,0x20,0x08,0x20,0x08,0x22,0x0B,0xFF,0x08,0x00},
{0xA6,0x63,0x00,0x00,0x00,0xC0,0x00,0x84,0x1F,0xFE,0x00,0x80,0x00,0x82,0x3F,0xFF,0x00,0x00,0x00,0xC0,0x00,0x84,0x1F,0xFE,0x00,0x80,0x00,0x80,0x00,0x82,0x3F,0xFF,0x00,0x00},
{0xA6,0x64,0x00,0x00,0x18,0x04,0x10,0xFE,0x10,0x00,0x10,0x02,0x7D,0xFF,0x10,0x40,0x10,0x42,0x10,0x7F,0x10,0x82,0x1C,0x82,0x70,0x02,0x20,0x02,0x00,0x44,0x00,0x38,0x00,0x10},
{0xA6,0x65,0x00,0x00,0x19,0x02,0x11,0xFF,0x11,0x02,0x11,0x02,0x7D,0x02,0x11,0x02,0x11,0xFE,0x11,0x02,0x11,0x00,0x15,0x00,0x19,0x00,0x71,0x02,0x21,0x02,0x01,0x03,0x00,0xFE},
{0xA6,0x66,0x00,0x00,0x18,0x04,0x11,0xFE,0x10,0x20,0x10,0x20,0x7C,0x20,0x10,0x22,0x13,0xFF,0x10,0x20,0x10,0x20,0x14,0x20,0x18,0x20,0x70,0x20,0x21,0x20,0x00,0xE0,0x00,0x40},
{0xA6,0x67,0x00,0x00,0x20,0x08,0x3F,0xFC,0x20,0x08,0x20,0x48,0x2F,0xE8,0x22,0x08,0x22,0x48,0x23,0xE8,0x24,0x48,0x2A,0x88,0x22,0x88,0x21,0x05,0x42,0x05,0x4C,0x03,0x40,0x01},
{0xA6,0x68,0x00,0x00,0x03,0x00,0x02,0x20,0x07,0xF0,0x08,0x40,0x36,0x80,0x01,0x00,0x06,0x60,0x18,0x42,0x60,0xFF,0x03,0x04,0x0C,0xC8,0x00,0x30,0x00,0xC0,0x03,0x00,0x1C,0x00},
{0xA6,0x69,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x80,0x3F,0xFC,0x00,0x84,0x1F,0xFC,0x10,0x80,0x3F,0xFF,0x20,0x81,0x01,0x4E,0x02,0x20,0x04,0x18,0x18,0x07,0x60,0x02},
{0xA6,0x6A,0x00,0x00,0x03,0x00,0x02,0x02,0x7F,0xFF,0x04,0x20,0x08,0x18,0x17,0xF7,0x60,0x02,0x1F,0xFC,0x04,0x00,0x0F,0xF8,0x08,0x08,0x00,0x08,0x00,0x10,0x01,0xE0,0x00,0x40},
{0xA6,0x6B,0x00,0x00,0x00,0xC0,0x10,0x84,0x1F,0xFE,0x10,0x00,0x10,0x00,0x0F,0xFC,0x00,0x00,0x02,0x02,0x7F,0xFF,0x02,0x10,0x04,0x20,0x0E,0x40,0x01,0xB0,0x06,0x1C,0x38,0x04},
{0xA6,0x6C,0x00,0x00,0x18,0x04,0x10,0xFE,0x12,0x10,0x7F,0x10,0x12,0x10,0x12,0x10,0x22,0x12,0x25,0xFF,0x64,0x10,0x18,0x10,0x14,0x10,0x12,0x10,0x22,0x10,0x40,0x10,0x00,0x10},
{0xA6,0x6D,0x00,0x00,0x18,0x04,0x11,0xFE,0x10,0x04,0x7F,0x04,0x12,0x04,0x12,0x04,0x22,0x84,0x22,0xFC,0x24,0x84,0x54,0x80,0x08,0x80,0x14,0x82,0x12,0x82,0x22,0x83,0x40,0x7E},
{0xA6,0x6E,0x00,0x00,0x18,0x02,0x10,0xFF,0x12,0x02,0x7F,0x04,0x12,0x18,0x12,0x10,0x22,0x12,0x25,0xFF,0x24,0x10,0x58,0x10,0x14,0x10,0x12,0x10,0x22,0x10,0x40,0x70,0x00,0x20},
{0xA6,0x6F,0x00,0x00,0x18,0x18,0x10,0x10,0x10,0xD0,0x12,0x92,0x7E,0x97,0x12,0xBA,0x13,0xD2,0x22,0x92,0x24,0x96,0x54,0x92,0x18,0x90,0x14,0x82,0x22,0x82,0x22,0x83,0x40,0x7E},
{0xA6,0x70,0x00,0x00,0x18,0x00,0x10,0x42,0x12,0x7F,0x7F,0x42,0x12,0x42,0x12,0x42,0x22,0x42,0x22,0x42,0x24,0x42,0x54,0x42,0x08,0x42,0x14,0x42,0x12,0x7E,0x22,0x42,0x40,0x00},
{0xA6,0x71,0x00,0x00,0x18,0x60,0x10,0x40,0x10,0x42,0x12,0x7F,0x7E,0x82,0x12,0x82,0x13,0x02,0x22,0x12,0x24,0x7A,0x54,0x02,0x18,0x02,0x14,0x04,0x22,0x44,0x22,0x38,0x40,0x10},
{0xA6,0x72,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x40,0x24,0x0F,0xF0,0x00,0x20,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xA6,0x73,0x00,0x00,0x06,0x00,0x04,0x02,0x7F,0xFF,0x04,0x00,0x08,0x08,0x0B,0xFC,0x10,0x08,0x30,0x30,0x50,0x22,0x17,0xFF,0x10,0x20,0x10,0x20,0x11,0x20,0x10,0xE0,0x10,0x40},
{0xA6,0x74,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x40,0x12,0x1F,0xF8,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xA6,0x75,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x40,0x34,0x00,0x20,0x00,0x22,0x7F,0xFF,0x00,0x20,0x10,0x20,0x0C,0x20,0x04,0x20,0x01,0x20,0x00,0xE0,0x00,0x40},
{0xA6,0x76,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x40,0x64,0x01,0xF0,0x1F,0x00,0x01,0x04,0x01,0x3E,0x07,0xC0,0x79,0x00,0x01,0x02,0x01,0x02,0x01,0x03,0x00,0xFE},
{0xA6,0x77,0x00,0x00,0x01,0x80,0x21,0x04,0x3F,0xFE,0x20,0x04,0x43,0x08,0x02,0x02,0x7F,0xFF,0x02,0x10,0x04,0x10,0x1C,0x20,0x02,0x40,0x01,0x80,0x02,0x60,0x0C,0x18,0x30,0x08},
{0xA6,0x78,0x00,0x00,0x01,0x80,0x01,0x08,0x3F,0xFC,0x01,0x00,0x01,0x02,0x7F,0xFF,0x00,0x20,0x00,0x24,0x7F,0xFE,0x10,0x20,0x0C,0x20,0x04,0x20,0x01,0x20,0x00,0xE0,0x00,0x40},
{0xA6,0x79,0x00,0x00,0x00,0xC0,0x00,0x80,0x0C,0x90,0x18,0x8C,0x12,0x86,0x21,0x82,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x80,0x01,0x60,0x02,0x18,0x0C,0x07,0x70,0x02},
{0xA6,0x7A,0x00,0x00,0x18,0x60,0x10,0x42,0x10,0xFF,0x54,0x80,0x55,0x04,0x56,0x7E,0x54,0x04,0x54,0x08,0x54,0x10,0x54,0x20,0x7C,0x42,0x44,0x42,0x40,0x82,0x00,0x83,0x00,0x7E},
{0xA6,0x7B,0x00,0x00,0x0C,0x63,0x08,0x42,0x08,0x42,0x08,0x42,0x2A,0x52,0x2A,0x52,0x49,0x4A,0x49,0x4A,0x08,0x42,0x08,0x42,0x10,0x42,0x10,0x42,0x20,0x42,0x20,0x42,0x40,0x42},
{0xA6,0x7C,0x00,0x00,0x18,0x88,0x10,0xFC,0x54,0x88,0x7E,0x88,0x54,0x88,0x54,0xC8,0x54,0xA8,0x54,0xA8,0x54,0x88,0x5C,0x88,0x54,0x88,0x11,0x0A,0x11,0x0A,0x12,0x0B,0x14,0x06},
{0xA6,0x7D,0x00,0x00,0x08,0x0C,0x1C,0x08,0x02,0x10,0x3F,0xFE,0x04,0x10,0x04,0x10,0x04,0x10,0x04,0x12,0x7F,0xFF,0x04,0x10,0x04,0x10,0x08,0x10,0x08,0x10,0x10,0x10,0x20,0x10},
{0xA6,0x7E,0x00,0x00,0x0C,0x00,0x08,0x04,0x1F,0xFE,0x10,0x40,0x20,0x40,0x48,0x48,0x0F,0xFC,0x08,0x40,0x08,0x40,0x08,0x42,0x7F,0xFF,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x40},
{0xA6,0xA1,0x00,0x00,0x00,0x68,0x00,0x46,0x00,0x40,0x7F,0xFF,0x00,0x40,0x00,0x40,0x02,0x40,0x7F,0x20,0x08,0x20,0x08,0x20,0x09,0x90,0x0E,0x12,0x78,0x0A,0x20,0x07,0x00,0x02},
{0xA6,0xA2,0x00,0x00,0x04,0x18,0x7E,0x10,0x04,0xD0,0x24,0x92,0x3C,0x97,0x24,0xBA,0x21,0xD2,0x44,0x92,0x7E,0x96,0x44,0x92,0x04,0x90,0x04,0x82,0x44,0x82,0x38,0x83,0x10,0x7E},
{0xA6,0xA3,0x00,0x00,0x18,0x18,0x10,0x10,0x10,0x92,0x14,0xFF,0x52,0x80,0x52,0x80,0x50,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x7E,0x10,0x00},
{0xA6,0xA4,0x00,0x00,0x18,0x0C,0x10,0x08,0x10,0x08,0x18,0x0A,0x55,0xFF,0x54,0x08,0x51,0x08,0x10,0x88,0x10,0x88,0x10,0x48,0x10,0x08,0x10,0x08,0x10,0x48,0x10,0x38,0x10,0x10},
{0xA6,0xA5,0x00,0x00,0x00,0x68,0x00,0x46,0x00,0x40,0x7F,0xFF,0x00,0x40,0x06,0x40,0x04,0x26,0x04,0xA4,0x07,0x28,0x7C,0x10,0x24,0x10,0x08,0x29,0x08,0xC9,0x13,0x05,0x20,0x03},
{0xA6,0xA6,0x00,0x00,0x00,0x68,0x00,0x46,0x10,0x40,0x1F,0xFF,0x10,0x40,0x10,0x40,0x10,0x26,0x11,0x24,0x1F,0xA8,0x10,0x10,0x10,0x10,0x20,0x29,0x20,0xC9,0x23,0x05,0x40,0x03},
{0xA6,0xA7,0x00,0x00,0x00,0x68,0x00,0x46,0x10,0x40,0x1F,0xFF,0x10,0x40,0x10,0x40,0x14,0x26,0x12,0x24,0x13,0x28,0x11,0x10,0x10,0x10,0x20,0x29,0x20,0xC9,0x23,0x05,0x40,0x03},
{0xA6,0xA8,0x00,0x00,0x00,0x68,0x00,0x46,0x20,0x40,0x3F,0xFF,0x20,0x40,0x20,0x40,0x22,0x26,0x3F,0x24,0x22,0x28,0x22,0x28,0x22,0x10,0x22,0x2A,0x4C,0x4A,0x40,0x87,0x43,0x02},
{0xA6,0xA9,0x00,0x00,0x0C,0x00,0x08,0x82,0x08,0xFF,0x7E,0x82,0x08,0x82,0x08,0x82,0x0A,0x82,0x0C,0x82,0x78,0x82,0x28,0x82,0x08,0x82,0x08,0x82,0x48,0xFE,0x38,0x82,0x10,0x00},
{0xA6,0xAA,0x00,0x00,0x0C,0x04,0x09,0xFE,0x08,0x20,0x7E,0x20,0x08,0x20,0x08,0x20,0x0A,0x20,0x0C,0x20,0x78,0x20,0x28,0x20,0x08,0x20,0x08,0x20,0x48,0x22,0x3B,0xFF,0x10,0x00},
{0xA6,0xAB,0x00,0x00,0x0C,0x18,0x08,0x7C,0x09,0xC0,0x7E,0x40,0x08,0x40,0x08,0x44,0x0A,0x4E,0x0C,0x70,0x79,0xC0,0x28,0x40,0x08,0x42,0x08,0x42,0x48,0x42,0x38,0x43,0x10,0x3E},
{0xA6,0xAC,0x00,0x00,0x06,0x60,0x04,0x40,0x34,0x42,0x24,0xFF,0x24,0x84,0x24,0x84,0x25,0x44,0x26,0x48,0x24,0x28,0x3C,0x10,0x64,0x28,0x24,0x28,0x04,0x44,0x04,0x47,0x04,0x82},
{0xA6,0xAD,0x00,0x00,0x10,0x08,0x1F,0xFC,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08,0x10,0x08,0x1F,0xF8,0x11,0x08,0x01,0x02,0x7F,0xFF,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00},
{0xA6,0xAE,0x00,0x00,0x30,0x00,0x20,0x70,0x23,0x84,0x3C,0x04,0x20,0x06,0x1F,0xFC,0x00,0x00,0x10,0x08,0x1F,0xFC,0x10,0x08,0x1F,0xF8,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08},
{0xA6,0xAF,0x00,0x00,0x0C,0x00,0x08,0x02,0x1F,0xFF,0x10,0x02,0x28,0x42,0x4F,0xE2,0x08,0x42,0x0F,0xC2,0x08,0x42,0x08,0x42,0x0F,0xC4,0x08,0x44,0x00,0x04,0x00,0x78,0x00,0x10},
{0xA6,0xB0,0x00,0x00,0x18,0x00,0x10,0x44,0x10,0x7E,0x12,0x44,0x7F,0x44,0x12,0x44,0x12,0x7C,0x12,0x44,0x12,0x44,0x12,0x44,0x12,0x7C,0x22,0x45,0x22,0x01,0x22,0x01,0x41,0xFE},
{0xA6,0xB1,0x00,0x00,0x03,0x30,0x02,0x20,0x22,0x22,0x3F,0xFF,0x22,0x22,0x22,0x22,0x22,0x22,0x3F,0xFE,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x3F,0xFE,0x20,0x02,0x00,0x00},
{0xA6,0xB2,0x00,0x00,0x01,0x80,0x21,0x08,0x3F,0xFC,0x21,0x08,0x21,0x08,0x3F,0xF8,0x20,0x88,0x20,0x88,0x3F,0xF8,0x20,0x80,0x00,0x58,0x00,0x62,0x01,0xA2,0x0E,0x1B,0x70,0x06},
{0xA6,0xB3,0x00,0x00,0x06,0x00,0x04,0x02,0x7F,0xFF,0x04,0x00,0x08,0x08,0x0F,0xFC,0x18,0x08,0x28,0x08,0x4F,0xF8,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x08,0x08,0x38,0x08,0x10},
{0xA6,0xB4,0x00,0x00,0x0C,0x02,0x09,0xFF,0x08,0x40,0x7E,0x40,0x08,0x42,0x18,0xFF,0x18,0x82,0x2C,0x02,0x2B,0x02,0x49,0x02,0x48,0x04,0x08,0x04,0x08,0x44,0x08,0x38,0x08,0x10},
{0xA6,0xB5,0x00,0x00,0x06,0x30,0x04,0x20,0x05,0x20,0x7F,0xA0,0x0C,0x20,0x14,0x30,0x16,0x28,0x15,0x26,0x25,0xA3,0x24,0xA1,0x44,0x20,0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20},
{0xA6,0xB6,0x00,0x00,0x00,0xC0,0x0C,0x80,0x08,0x88,0x1F,0xFC,0x10,0x80,0x20,0x80,0x00,0x82,0x7F,0xFF,0x01,0x80,0x02,0xC0,0x02,0xA0,0x04,0x98,0x18,0x87,0x60,0x82,0x00,0x80},
{0xA6,0xB7,0x00,0x00,0x04,0x20,0x07,0xF0,0x04,0x20,0x04,0x22,0x08,0x22,0x08,0x23,0x30,0x9E,0x00,0x80,0x7F,0xFF,0x01,0x80,0x02,0xE0,0x04,0x98,0x18,0x87,0x60,0x82,0x00,0x80},
{0xA6,0xB8,0x00,0x00,0x00,0xC0,0x08,0x80,0x7C,0x82,0x01,0xFF,0x01,0x02,0x02,0x34,0x04,0x20,0x00,0x20,0x02,0x20,0x0C,0x50,0x70,0x50,0x20,0x88,0x00,0x88,0x01,0x07,0x06,0x02},
{0xA6,0xB9,0x00,0x00,0x06,0x30,0x04,0x20,0x34,0x20,0x24,0x20,0x25,0x22,0x27,0xBF,0x24,0x20,0x24,0x20,0x24,0x20,0x24,0x20,0x24,0x22,0x25,0xA2,0x2E,0x22,0x70,0x23,0x20,0x1E},
{0xA6,0xBA,0x00,0x00,0x00,0x02,0x7F,0xFF,0x08,0x00,0x08,0x60,0x11,0x40,0x1F,0x40,0x11,0x44,0x11,0x7E,0x2A,0x40,0x4A,0x40,0x04,0x40,0x04,0x42,0x08,0x42,0x10,0x43,0x60,0x3E},
{0xA6,0xBB,0x00,0x00,0x10,0x08,0x1F,0xFC,0x20,0x00,0x2F,0xF0,0x40,0x00,0x1F,0xF8,0x00,0x08,0x1F,0xC8,0x04,0x88,0x04,0xE8,0x04,0xA9,0x08,0x25,0x08,0x25,0x13,0xC3,0x60,0x81},
{0xA6,0xBC,0x00,0x00,0x20,0x60,0x10,0x40,0x14,0x40,0x04,0x42,0x47,0xFF,0x28,0x84,0x28,0x84,0x09,0x04,0x11,0x08,0x11,0x08,0x62,0xD0,0x20,0x28,0x20,0x44,0x61,0x86,0x26,0x02},
{0xA6,0xBD,0x00,0x00,0x20,0x04,0x13,0xFE,0x10,0x20,0x40,0x20,0x24,0x20,0x28,0x22,0x0B,0xFF,0x10,0x20,0x10,0x20,0x60,0x20,0x20,0x20,0x20,0x20,0x60,0x20,0x20,0x20,0x00,0x20},
{0xA6,0xBE,0x00,0x00,0x20,0x04,0x13,0xFE,0x10,0x20,0x40,0x20,0x24,0x20,0x28,0x22,0x0B,0xFF,0x10,0x20,0x10,0x20,0x60,0x20,0x20,0x20,0x20,0x20,0x61,0x20,0x20,0xE0,0x00,0x40},
{0xA6,0xBF,0x00,0x00,0x20,0x04,0x17,0xFE,0x10,0x20,0x00,0x20,0x44,0x20,0x24,0x20,0x28,0x20,0x08,0x20,0x10,0x20,0x10,0x20,0x60,0x20,0x20,0x20,0x20,0x22,0x6F,0xFF,0x20,0x00},
{0xA6,0xC0,0x00,0x00,0x20,0x60,0x13,0x40,0x12,0x44,0x42,0x4E,0x2A,0x74,0x2B,0xC4,0x0E,0x44,0x12,0x44,0x12,0x5C,0x12,0x48,0x62,0x40,0x22,0x02,0x22,0x02,0x62,0x03,0x21,0xFE},
{0xA6,0xC1,0x00,0x00,0x20,0x60,0x10,0x40,0x10,0x42,0x02,0x7F,0x44,0x82,0x24,0x84,0x29,0x44,0x09,0x28,0x12,0x28,0x10,0x10,0x60,0x10,0x20,0x20,0x20,0x40,0x61,0x80,0x26,0x00},
{0xA6,0xC2,0x00,0x00,0x20,0x30,0x10,0x20,0x10,0x20,0x04,0x20,0x4B,0x23,0x2A,0x22,0x2A,0x22,0x12,0x22,0x12,0x22,0x12,0x22,0x62,0x22,0x22,0x22,0x23,0xFE,0x62,0x02,0x22,0x02},
{0xA6,0xC3,0x00,0x00,0x20,0x04,0x11,0xFE,0x10,0x00,0x44,0x00,0x24,0x02,0x2B,0xFF,0x08,0x80,0x10,0x82,0x11,0xFF,0x61,0x02,0x20,0x02,0x20,0x02,0x60,0x44,0x20,0x38,0x00,0x10},
{0xA6,0xC4,0x00,0x00,0x20,0x08,0x17,0xFC,0x10,0x88,0x40,0x88,0x24,0x88,0x28,0x88,0x08,0xA8,0x13,0xF8,0x10,0x88,0x60,0x88,0x20,0x89,0x21,0x05,0x61,0x05,0x22,0x03,0x04,0x02},
{0xA6,0xC5,0x00,0x00,0x20,0x60,0x10,0x40,0x10,0x48,0x03,0xFC,0x44,0x48,0x24,0x48,0x28,0x48,0x08,0x48,0x10,0x88,0x10,0xE8,0x60,0xA8,0x20,0x88,0x21,0x09,0x61,0x09,0x22,0x07},
{0xA6,0xC6,0x00,0x00,0x22,0x10,0x13,0xF8,0x12,0x10,0x42,0x10,0x26,0x10,0x2A,0x90,0x0A,0x90,0x12,0x50,0x12,0x50,0x62,0x10,0x22,0x12,0x24,0x12,0x64,0x12,0x24,0x13,0x08,0x0E},
{0xA6,0xC7,0x00,0x00,0x06,0x00,0x04,0x02,0x7F,0xFF,0x08,0x00,0x08,0x60,0x08,0x40,0x0A,0x46,0x12,0x48,0x12,0x50,0x14,0xA0,0x10,0x90,0x21,0x10,0x21,0x08,0x42,0x07,0x0C,0x02},
{0xA6,0xC8,0x00,0x00,0x03,0x00,0x02,0x10,0x04,0x0C,0x7F,0xF6,0x20,0x02,0x0C,0xC0,0x08,0x88,0x1F,0xFC,0x20,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA6,0xC9,0x00,0x00,0x06,0x60,0x34,0x40,0x24,0x40,0x3F,0x40,0x24,0x46,0x44,0x4C,0x45,0x48,0x06,0x50,0x0C,0x60,0x74,0x40,0x24,0x42,0x04,0x42,0x04,0x43,0x04,0x3E,0x04,0x00},
{0xA6,0xCA,0x00,0x00,0x00,0x02,0x7F,0xFF,0x01,0x00,0x01,0x00,0x12,0x04,0x1F,0xFE,0x10,0x04,0x10,0x04,0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x04,0x10,0x04,0x1F,0xFC,0x10,0x04},
{0xA6,0xCB,0x00,0x00,0x18,0x60,0x10,0x40,0x12,0x42,0x1F,0x7F,0x24,0x88,0x24,0x88,0x45,0x08,0x04,0x08,0x04,0x08,0x04,0x08,0x04,0x08,0x04,0x08,0x04,0x48,0x04,0x38,0x04,0x10},
{0xA6,0xCC,0x00,0x00,0x00,0xC0,0x10,0x8C,0x08,0x88,0x0C,0x98,0x04,0x90,0x00,0xA2,0x7F,0xFF,0x01,0x80,0x02,0xC0,0x02,0xB0,0x04,0x88,0x18,0x87,0x60,0x82,0x00,0x80,0x00,0x80},
{0xA6,0xCD,0x00,0x00,0x03,0x00,0x02,0x00,0x04,0x30,0x18,0x20,0x06,0x40,0x01,0x88,0x01,0x04,0x02,0x7A,0x3F,0x82,0x10,0x80,0x06,0x90,0x04,0x88,0x08,0x86,0x30,0x82,0x00,0x80},
{0xA6,0xCE,0x00,0x00,0x0C,0x00,0x08,0x08,0x1F,0xFC,0x10,0x80,0x20,0x80,0x40,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x18,0x86,0x10,0x84,0x10,0x84,0x10,0x84,0x1F,0xFC,0x10,0x04},
{0xA6,0xCF,0x00,0x00,0x08,0x18,0x06,0x10,0x02,0x24,0x3F,0xFE,0x00,0x80,0x00,0x88,0x1F,0xFC,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA6,0xD0,0x00,0x00,0x02,0x02,0x7F,0x7F,0x02,0x02,0x0E,0x0E,0x0A,0x0A,0x12,0x12,0x22,0x22,0x4E,0x42,0x0A,0x0E,0x12,0x0A,0x22,0x12,0x42,0x22,0x02,0x42,0x1E,0x1E,0x04,0x04},
{0xA6,0xD1,0x00,0x00,0x03,0x00,0x02,0x46,0x3F,0xE4,0x02,0x08,0x02,0x10,0x02,0x22,0x7F,0xFF,0x00,0x80,0x03,0x0C,0x0C,0x10,0x74,0x60,0x07,0x82,0x04,0x02,0x04,0x03,0x03,0xFE},
{0xA6,0xD2,0x00,0x00,0x03,0x00,0x02,0x46,0x3F,0xE4,0x02,0x08,0x02,0x32,0x7F,0xFF,0x01,0x00,0x07,0xFE,0x1A,0x00,0x63,0xF8,0x04,0x08,0x04,0x08,0x00,0x10,0x00,0xE0,0x00,0x40},
{0xA6,0xD3,0x00,0x00,0x00,0x02,0x7F,0xFF,0x01,0x00,0x02,0x00,0x24,0x02,0x3F,0xFF,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x2E,0x20,0x04},
{0xA6,0xD4,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0xFC,0x3F,0x80,0x00,0x88,0x3F,0xFC,0x00,0x80,0x7F,0xFF,0x00,0x80,0x02,0xC0,0x04,0xB0,0x18,0x8F,0x60,0x82,0x00,0x80,0x00,0x80},
{0xA6,0xD5,0x00,0x00,0x00,0x02,0x7F,0xFF,0x08,0x10,0x08,0x10,0x0F,0xF0,0x08,0x10,0x08,0x10,0x0F,0xF0,0x08,0x10,0x08,0x1F,0x0B,0xF0,0x7C,0x10,0x20,0x10,0x00,0x10,0x00,0x10},
{0xA6,0xD6,0x00,0x00,0x01,0x80,0x01,0x08,0x1F,0xFC,0x01,0x08,0x7F,0xFF,0x01,0x08,0x1F,0xF8,0x01,0x08,0x01,0x00,0x3F,0xFE,0x01,0x00,0x7F,0xFF,0x01,0x00,0x01,0x00,0x01,0x00},
{0xA6,0xD7,0x00,0x00,0x00,0x80,0x03,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x82,0x21,0x42,0x21,0x32,0x22,0x1A,0x2C,0xCA,0x20,0x82,0x21,0x42,0x22,0x32,0x2C,0x12,0x20,0x0E,0x20,0x04},
{0xA6,0xD8,0x00,0x00,0x24,0x30,0x3E,0x20,0x24,0x20,0x24,0x22,0x3D,0xFF,0x24,0x22,0x24,0x22,0x24,0x22,0x3C,0x22,0x24,0x42,0x24,0x42,0x44,0x42,0x44,0x82,0x5C,0x9C,0x49,0x08},
{0xA6,0xD9,0x00,0x00,0x24,0x00,0x3E,0x88,0x24,0xFC,0x24,0x88,0x3C,0x88,0x24,0x88,0x24,0x88,0x24,0x88,0x3C,0x88,0x24,0x88,0x24,0x88,0x24,0x89,0x45,0x09,0x5D,0x09,0x4A,0x07},
{0xA6,0xDA,0x00,0x00,0x20,0x04,0x3F,0xFE,0x21,0x00,0x21,0x00,0x21,0x08,0x3F,0xFC,0x20,0x08,0x20,0x08,0x20,0x08,0x3F,0xF8,0x21,0x08,0x21,0x00,0x21,0x02,0x3F,0xFF,0x20,0x00},
{0xA6,0xDB,0x00,0x00,0x01,0x80,0x01,0x00,0x22,0x04,0x3F,0xFE,0x20,0x04,0x20,0x04,0x3F,0xFC,0x20,0x04,0x20,0x04,0x3F,0xFC,0x20,0x04,0x20,0x04,0x20,0x04,0x3F,0xFC,0x20,0x04},
{0xA6,0xDC,0x00,0x00,0x00,0x02,0x7F,0xFF,0x02,0x00,0x04,0x10,0x04,0x08,0x08,0xF4,0x7F,0x86,0x20,0x82,0x00,0x80,0x00,0x88,0x3F,0xFC,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF},
{0xA6,0xDD,0x00,0x00,0x03,0x00,0x24,0x02,0x38,0x7F,0x20,0x02,0x20,0x02,0x20,0x02,0x22,0x02,0x3F,0x7E,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x3F,0xFE,0x20,0x02},
{0xA6,0xDE,0x00,0x00,0x00,0x18,0x00,0xFC,0x3F,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x10,0x84,0x1F,0xFE,0x10,0x04,0x10,0x04,0x10,0x04,0x1F,0xFC,0x10,0x04},
{0xA6,0xDF,0x00,0x00,0x18,0x0C,0x10,0x08,0x11,0x0A,0x1F,0x7F,0x11,0x08,0x21,0x68,0x32,0x48,0x2A,0x48,0x4A,0x4A,0x04,0xFF,0x04,0x08,0x08,0x08,0x10,0x08,0x20,0x08,0x00,0x08},
{0xA6,0xE0,0x00,0x00,0x00,0xC0,0x00,0x80,0x09,0x08,0x0F,0xFC,0x08,0x08,0x09,0x08,0x08,0xC8,0x08,0x0A,0x7F,0xFF,0x08,0x88,0x08,0x88,0x08,0x88,0x10,0x88,0x10,0xB8,0x20,0x10},
{0xA6,0xE1,0x00,0x00,0x10,0x10,0x1F,0xF8,0x10,0x10,0x10,0x10,0x1F,0xF0,0x10,0x10,0x10,0x10,0x1F,0xF0,0x11,0x10,0x10,0x86,0x10,0x58,0x13,0x20,0x1C,0x18,0x70,0x07,0x20,0x02},
{0xA6,0xE2,0x00,0x00,0x06,0x00,0x04,0x20,0x0F,0xF0,0x08,0x40,0x10,0x84,0x3F,0xFE,0x50,0x84,0x10,0x84,0x10,0x84,0x1F,0xFC,0x10,0x04,0x10,0x01,0x10,0x01,0x10,0x01,0x0F,0xFF},
{0xA6,0xE3,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x00,0x00,0x18,0x18,0x14,0x10,0x24,0x20,0x02,0x20,0x01,0x40,0x00,0x80,0x01,0x60,0x02,0x18,0x0C,0x07,0x70,0x02},
{0xA6,0xE4,0x00,0x00,0x01,0x80,0x01,0x00,0x21,0x04,0x3F,0xFE,0x21,0x04,0x21,0x04,0x21,0x04,0x21,0x04,0x3F,0xFC,0x21,0x04,0x01,0x08,0x01,0x04,0x01,0xFA,0x7F,0x03,0x20,0x01},
{0xA6,0xE5,0x00,0x00,0x01,0x80,0x01,0x00,0x22,0x04,0x3F,0xFE,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x22,0x44,0x7F,0xFF,0x00,0x00},
{0xA6,0xE6,0x00,0x00,0x0C,0x04,0x09,0xFE,0x10,0x00,0x26,0x00,0x44,0x02,0x09,0xFF,0x18,0x08,0x28,0x08,0x48,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x48,0x08,0x38,0x08,0x10},
{0xA6,0xE7,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x82,0x7F,0xFF,0x01,0x80,0x02,0x80,0x04,0x86,0x18,0x4C,0x68,0x50,0x08,0x20,0x08,0x10,0x09,0x90,0x0E,0x0C,0x38,0x07,0x10,0x02},
{0xA6,0xE8,0x00,0x00,0x00,0x02,0x7F,0xFF,0x02,0x40,0x22,0x42,0x3F,0xFF,0x22,0x42,0x22,0x42,0x22,0x4A,0x24,0x4A,0x24,0x3A,0x28,0x02,0x20,0x02,0x20,0x02,0x3F,0xFE,0x20,0x02},
{0xA6,0xE9,0x00,0x00,0x48,0x0C,0x7C,0x1E,0x49,0xF0,0x48,0x10,0x50,0x10,0x50,0x10,0x48,0x12,0x45,0xFF,0x44,0x10,0x44,0x10,0x78,0x10,0x50,0x10,0x40,0x10,0x40,0x10,0x40,0x10},
{0xA6,0xEA,0x00,0x00,0x00,0xC0,0x08,0x88,0x0F,0xFC,0x08,0x88,0x08,0x88,0x0F,0xF8,0x08,0x88,0x20,0x82,0x3F,0xFF,0x20,0x82,0x20,0x82,0x3F,0xFE,0x20,0x82,0x00,0x80,0x00,0x80},
{0xA6,0xEB,0x00,0x00,0x01,0x80,0x01,0x02,0x7F,0xFF,0x00,0x00,0x0F,0xF0,0x08,0x10,0x0F,0xF0,0x00,0x00,0x7F,0xFC,0x00,0x18,0x00,0xE0,0x00,0x80,0x00,0x80,0x07,0x80,0x01,0x00},
{0xA6,0xEC,0x00,0x00,0x0C,0x30,0x08,0x20,0x08,0x22,0x13,0xFF,0x18,0x00,0x31,0x06,0x51,0x04,0x10,0x84,0x10,0x88,0x10,0x88,0x10,0x48,0x10,0x50,0x10,0x12,0x17,0xFF,0x10,0x00},
{0xA6,0xED,0x00,0x00,0x0C,0x40,0x08,0x30,0x08,0x12,0x13,0xFF,0x18,0x20,0x30,0x20,0x50,0x20,0x10,0x24,0x13,0xFE,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x22,0x17,0xFF,0x10,0x00},
{0xA6,0xEE,0x00,0x00,0x0C,0x30,0x09,0x22,0x09,0xFF,0x11,0x02,0x1A,0x04,0x30,0x02,0x53,0xFF,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x11,0x20,0x10,0xE0,0x10,0x40},
{0xA6,0xEF,0x00,0x00,0x0C,0x30,0x09,0x22,0x09,0xFF,0x11,0x02,0x1A,0x04,0x30,0xC0,0x50,0x80,0x10,0x8C,0x10,0x90,0x10,0xE0,0x10,0x80,0x10,0x82,0x10,0x82,0x10,0x83,0x10,0x7E},
{0xA6,0xF0,0x00,0x00,0x0C,0x08,0x09,0xFC,0x08,0x00,0x10,0x04,0x1B,0xFE,0x30,0x40,0x50,0x42,0x17,0xFF,0x10,0x84,0x10,0x84,0x11,0x08,0x12,0x90,0x10,0x60,0x11,0x98,0x16,0x06},
{0xA6,0xF1,0x00,0x00,0x0C,0x30,0x08,0x20,0x09,0xA4,0x11,0x22,0x12,0x23,0x35,0xFD,0x50,0x20,0x10,0x20,0x10,0x22,0x17,0xFF,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20},
{0xA6,0xF2,0x00,0x00,0x0C,0x90,0x08,0x94,0x0B,0xFE,0x10,0x94,0x12,0x94,0x33,0xFC,0x52,0x90,0x12,0x92,0x17,0xFF,0x14,0x92,0x10,0x92,0x10,0x9E,0x11,0x14,0x11,0x10,0x12,0x10},
{0xA6,0xF3,0x00,0x00,0x0C,0x00,0x08,0x02,0x0B,0xFF,0x10,0x04,0x1A,0x24,0x33,0xF4,0x52,0x24,0x12,0x24,0x12,0x24,0x13,0xE4,0x12,0x24,0x10,0x04,0x10,0x24,0x10,0x1C,0x10,0x08},
{0xA6,0xF4,0x00,0x00,0x0C,0x30,0x08,0x20,0x08,0x22,0x17,0xFF,0x10,0x20,0x30,0x20,0x50,0x20,0x12,0x22,0x13,0xFF,0x12,0x02,0x12,0x02,0x12,0x02,0x12,0x02,0x13,0xFE,0x12,0x02},
{0xA6,0xF5,0x00,0x00,0x0C,0x60,0x08,0x40,0x08,0x42,0x13,0xFF,0x18,0x80,0x30,0x80,0x50,0x84,0x11,0xFE,0x11,0x10,0x12,0x10,0x12,0x10,0x14,0x10,0x10,0x12,0x13,0xFF,0x10,0x00},
{0xA6,0xF6,0x00,0x00,0x0C,0x60,0x08,0x40,0x08,0x42,0x17,0xFF,0x10,0x80,0x30,0x80,0x51,0x04,0x11,0xFE,0x13,0x04,0x15,0x04,0x11,0x04,0x11,0x04,0x11,0x04,0x11,0xFC,0x11,0x04},
{0xA6,0xF7,0x00,0x00,0x0D,0x80,0x09,0x00,0x09,0x09,0x11,0x2F,0x1B,0xE9,0x31,0x29,0x51,0x29,0x11,0x29,0x11,0x29,0x11,0x29,0x11,0x29,0x11,0x29,0x12,0x29,0x12,0xEF,0x14,0x49},
{0xA6,0xF8,0x00,0x00,0x0C,0x02,0x0B,0xFF,0x08,0x02,0x10,0x12,0x1B,0xFA,0x30,0x02,0x51,0x12,0x11,0xFA,0x11,0x12,0x11,0x12,0x11,0xF2,0x11,0x12,0x10,0x02,0x10,0x0E,0x10,0x04},
{0xA6,0xF9,0x00,0x00,0x0C,0x30,0x08,0x20,0x0A,0x22,0x13,0xFF,0x1A,0x22,0x32,0x22,0x53,0xFE,0x12,0x22,0x12,0x22,0x13,0xFE,0x12,0x22,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20},
{0xA6,0xFA,0x00,0x00,0x0C,0x00,0x0A,0x02,0x0B,0xFF,0x12,0x22,0x1A,0x22,0x32,0x22,0x52,0x22,0x13,0xFE,0x12,0x22,0x12,0x22,0x12,0x22,0x12,0x22,0x13,0xFE,0x12,0x02,0x10,0x00},
{0xA6,0xFB,0x00,0x00,0x0C,0x30,0x08,0x20,0x08,0x20,0x10,0x22,0x18,0x3F,0x30,0x20,0x50,0x20,0x12,0x22,0x13,0xFF,0x12,0x02,0x12,0x02,0x12,0x02,0x12,0x02,0x13,0xFE,0x12,0x02},
{0xA6,0xFC,0x00,0x00,0x0C,0x03,0x09,0x82,0x09,0x02,0x11,0x42,0x19,0x22,0x31,0x12,0x51,0x12,0x11,0x04,0x11,0x04,0x11,0x24,0x11,0x4A,0x13,0x89,0x11,0x11,0x10,0x21,0x10,0x40},
{0xA6,0xFD,0x00,0x00,0x0D,0x04,0x09,0xFE,0x09,0x04,0x11,0x04,0x19,0x04,0x31,0xFC,0x51,0x04,0x11,0x04,0x11,0x04,0x11,0xFC,0x11,0x04,0x10,0x00,0x10,0x02,0x17,0xFF,0x10,0x00},
{0xA6,0xFE,0x00,0x00,0x0A,0x02,0x0B,0xFF,0x0A,0x22,0x12,0x22,0x1A,0x22,0x33,0xFE,0x52,0x22,0x12,0x22,0x12,0x22,0x13,0xFE,0x12,0x22,0x12,0x22,0x12,0x22,0x14,0x2E,0x14,0x04},
{0xA7,0x40,0x00,0x00,0x0D,0x80,0x09,0x02,0x09,0xFF,0x11,0x40,0x1A,0x40,0x32,0x44,0x54,0x7E,0x10,0x40,0x10,0x40,0x10,0x44,0x10,0x7E,0x10,0x40,0x10,0x40,0x10,0x40,0x10,0x40},
{0xA7,0x41,0x00,0x00,0x0D,0x80,0x09,0x00,0x09,0x02,0x11,0xFF,0x1A,0x22,0x32,0x24,0x54,0x20,0x11,0xA8,0x11,0x24,0x13,0x26,0x12,0x22,0x14,0x22,0x10,0x20,0x10,0xE0,0x10,0x40},
{0xA7,0x42,0x00,0x00,0x0C,0x30,0x08,0x20,0x09,0x42,0x11,0xFF,0x19,0x02,0x31,0x02,0x51,0x02,0x11,0x02,0x11,0xFE,0x11,0x02,0x11,0x02,0x11,0x02,0x11,0x02,0x11,0xFE,0x11,0x02},
{0xA7,0x43,0x00,0x00,0x0C,0x0C,0x09,0x1E,0x09,0xF0,0x11,0x10,0x19,0x10,0x31,0x12,0x51,0xFF,0x11,0x08,0x11,0x08,0x11,0x69,0x17,0x89,0x12,0x05,0x10,0x25,0x17,0xF3,0x10,0x01},
{0xA7,0x44,0x00,0x00,0x0C,0x60,0x08,0xA0,0x08,0x90,0x11,0x0C,0x16,0xF3,0x38,0x00,0x50,0x04,0x13,0xFE,0x10,0x44,0x10,0x44,0x10,0x44,0x10,0x5C,0x10,0x48,0x10,0x40,0x10,0x40},
{0xA7,0x45,0x00,0x00,0x01,0x80,0x01,0x40,0x02,0x20,0x04,0x18,0x18,0x07,0x6F,0xFA,0x00,0x80,0x00,0x84,0x3F,0xFE,0x00,0x80,0x0C,0x90,0x08,0x8C,0x10,0x86,0x63,0x82,0x01,0x00},
{0xA7,0x46,0x00,0x00,0x0D,0x80,0x09,0x00,0x09,0x02,0x13,0xFF,0x12,0x02,0x35,0x12,0x51,0xFA,0x11,0x12,0x11,0x12,0x11,0x12,0x11,0xF2,0x11,0x14,0x10,0x04,0x10,0x38,0x10,0x10},
{0xA7,0x47,0x00,0x00,0x0C,0x60,0x08,0x40,0x08,0x42,0x17,0xFF,0x10,0x80,0x31,0x30,0x51,0x22,0x13,0xFF,0x15,0x22,0x11,0x22,0x11,0x22,0x11,0x2E,0x11,0x24,0x10,0x20,0x10,0x20},
{0xA7,0x48,0x00,0x00,0x0C,0x30,0x09,0xA0,0x09,0x24,0x11,0xFE,0x12,0x20,0x34,0x20,0x50,0x22,0x17,0xFF,0x10,0x20,0x10,0x50,0x10,0x50,0x10,0x88,0x10,0x88,0x11,0x07,0x16,0x02},
{0xA7,0x49,0x00,0x00,0x00,0x20,0x06,0xF0,0x04,0x20,0x08,0x10,0x10,0x08,0x6F,0xF7,0x08,0x12,0x08,0x10,0x08,0x10,0x0F,0xF0,0x0A,0x50,0x02,0x42,0x04,0x42,0x08,0x43,0x70,0x3E},
{0xA7,0x4A,0x00,0x00,0x01,0x80,0x01,0x02,0x7F,0xFF,0x01,0x00,0x11,0x08,0x1F,0xFC,0x10,0x08,0x10,0x08,0x10,0x08,0x1F,0xF8,0x12,0x48,0x02,0x42,0x04,0x42,0x08,0x43,0x70,0x3E},
{0xA7,0x4B,0x00,0x00,0x00,0x40,0x3F,0xE0,0x08,0x40,0x10,0x40,0x13,0x80,0x21,0x08,0x7F,0xFC,0x21,0x08,0x21,0x08,0x3F,0xF8,0x22,0x88,0x04,0x82,0x04,0x82,0x18,0x83,0x60,0x7E},
{0xA7,0x4C,0x00,0x00,0x00,0x18,0x08,0x7C,0x0F,0x80,0x08,0x00,0x08,0x04,0x0F,0xFE,0x08,0x20,0x08,0x20,0x08,0x20,0x08,0x22,0x7F,0xFF,0x00,0x00,0x06,0x30,0x18,0x0E,0x60,0x02},
{0xA7,0x4D,0x00,0x00,0x00,0x30,0x40,0x20,0x44,0x48,0x24,0x44,0x28,0x9A,0x0B,0xE3,0x09,0x01,0x10,0x00,0x11,0x02,0x61,0xFF,0x21,0x02,0x21,0x02,0x61,0x02,0x21,0xFE,0x01,0x02},
{0xA7,0x4E,0x00,0x00,0x00,0x60,0x40,0x50,0x40,0x90,0x20,0x88,0x29,0x14,0x0A,0xFB,0x14,0x00,0x10,0x04,0x13,0xFE,0x60,0x44,0x20,0x44,0x20,0x5C,0x60,0x48,0x20,0x40,0x00,0x40},
{0xA7,0x4F,0x00,0x00,0x20,0x83,0x3F,0xC2,0x20,0x9A,0x20,0x92,0x20,0x92,0x3F,0x92,0x28,0x92,0x08,0x12,0x0F,0xD2,0x08,0x92,0x10,0x82,0x10,0x82,0x10,0x92,0x27,0x0E,0x42,0x04},
{0xA7,0x50,0x00,0x00,0x06,0x03,0x04,0x02,0x35,0x1A,0x24,0x92,0x24,0x52,0x5F,0x52,0x04,0x12,0x04,0x12,0x07,0x92,0x7C,0x12,0x24,0x12,0x08,0x02,0x08,0x12,0x10,0x0E,0x20,0x04},
{0xA7,0x51,0x00,0x00,0x07,0x83,0x3C,0x02,0x04,0x1A,0x04,0x12,0x04,0x92,0x7F,0xD2,0x0C,0x12,0x16,0x12,0x15,0x12,0x25,0x92,0x24,0x92,0x44,0x02,0x04,0x12,0x04,0x0E,0x04,0x04},
{0xA7,0x52,0x00,0x00,0x20,0x43,0x3F,0xE2,0x2A,0x4A,0x2A,0x4A,0x2A,0x4A,0x2A,0x4A,0x7F,0xEA,0x2A,0x4A,0x2A,0x4A,0x2A,0x4A,0x2A,0x4A,0x2A,0x42,0x2A,0x42,0x21,0xCE,0x20,0x84},
{0xA7,0x53,0x00,0x00,0x18,0x03,0x10,0x82,0x1F,0xDA,0x20,0x92,0x3E,0x92,0x52,0x92,0x12,0x92,0x1E,0x92,0x10,0x92,0x13,0x12,0x10,0x52,0x10,0x42,0x10,0x62,0x0F,0xCE,0x00,0x04},
{0xA7,0x54,0x00,0x00,0x06,0x18,0x04,0x10,0x05,0x10,0x3F,0x92,0x04,0x7F,0x04,0x12,0x04,0x92,0x7F,0xD2,0x08,0x12,0x0A,0x12,0x11,0x22,0x16,0xA2,0x78,0xA2,0x20,0x4E,0x00,0x84},
{0xA7,0x55,0x00,0x00,0x00,0x30,0x22,0x20,0x3F,0x20,0x22,0x22,0x22,0xFF,0x3E,0x22,0x22,0x22,0x22,0x22,0x3E,0x22,0x22,0x22,0x22,0x22,0x27,0x42,0x78,0x42,0x20,0x9C,0x03,0x08},
{0xA7,0x56,0x00,0x00,0x18,0x00,0x12,0x04,0x7F,0x7E,0x12,0x44,0x62,0x24,0x14,0x18,0x0A,0x2C,0x32,0xC3,0x41,0x08,0x3F,0xFC,0x02,0x08,0x02,0x08,0x04,0x88,0x18,0x70,0x60,0x20},
{0xA7,0x57,0x00,0x00,0x18,0x0C,0x10,0x08,0x10,0x88,0x3F,0x89,0x20,0xBF,0x52,0x89,0x1E,0x89,0x12,0x89,0x12,0x89,0x1E,0x89,0x12,0x91,0x00,0x91,0x01,0x21,0x0E,0x2E,0x04,0x44},
{0xA7,0x58,0x00,0x00,0x40,0x04,0x7F,0xFE,0x40,0x00,0x4F,0xF8,0x48,0x88,0x48,0x88,0x4F,0xF8,0x48,0x88,0x48,0x88,0x4F,0xF8,0x48,0x88,0x40,0x80,0x40,0x82,0x7F,0xFF,0x40,0x00},
{0xA7,0x59,0x00,0x00,0x21,0x22,0x3F,0xBF,0x21,0x22,0x21,0x22,0x3F,0x22,0x21,0x22,0x21,0x22,0x3F,0x22,0x21,0x22,0x24,0x22,0x22,0x32,0x2D,0x2E,0x71,0x24,0x20,0x20,0x00,0x20},
{0xA7,0x5A,0x00,0x00,0x23,0x42,0x3C,0x7F,0x20,0x42,0x21,0x42,0x29,0x52,0x25,0x4A,0x25,0x4A,0x21,0x42,0x23,0x42,0x2D,0x52,0x71,0x4E,0x22,0x44,0x02,0x40,0x04,0x40,0x18,0x40},
{0xA7,0x5B,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x08,0x0C,0x10,0x33,0x20,0x01,0xC0,0x0E,0x38,0x70,0x07,0x08,0x08,0x0F,0xFC,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x08},
{0xA7,0x5C,0x00,0x00,0x00,0x30,0x48,0x20,0x78,0x22,0x4B,0xFF,0x48,0x00,0x48,0x88,0x48,0xFC,0x48,0x88,0x48,0x88,0x78,0x88,0x48,0x88,0x41,0x09,0x01,0x09,0x02,0x09,0x04,0x07},
{0xA7,0x5D,0x00,0x00,0x00,0x10,0x1F,0xF8,0x02,0x00,0x02,0x02,0x7F,0xFF,0x04,0x20,0x04,0x10,0x08,0x0C,0x10,0x03,0x6F,0xF8,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x08},
{0xA7,0x5E,0x00,0x00,0x00,0x04,0x3F,0xFE,0x01,0x00,0x01,0x10,0x1F,0xF8,0x02,0x10,0x02,0x12,0x7F,0xFF,0x00,0x00,0x1F,0xF8,0x10,0x08,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08},
{0xA7,0x5F,0x00,0x00,0x00,0x02,0x7F,0xFF,0x01,0x80,0x02,0xA0,0x04,0x98,0x18,0x86,0x60,0x82,0x00,0x80,0x10,0x08,0x1F,0xFC,0x10,0x08,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08},
{0xA7,0x60,0x00,0x00,0x01,0x04,0x49,0xFE,0x7D,0x04,0x49,0x04,0x49,0x04,0x49,0x04,0x49,0xFC,0x49,0x24,0x79,0x20,0x49,0x10,0x42,0x10,0x02,0x08,0x04,0x0C,0x04,0x07,0x08,0x02},
{0xA7,0x61,0x00,0x00,0x01,0x04,0x49,0xFE,0x7D,0x24,0x49,0x24,0x49,0x24,0x49,0x24,0x49,0x24,0x49,0xFC,0x49,0x04,0x79,0x00,0x49,0x00,0x41,0x02,0x01,0x02,0x01,0x03,0x00,0xFE},
{0xA7,0x62,0x00,0x00,0x10,0x08,0x1F,0xFC,0x10,0x08,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x01,0x80,0x06,0xE0,0x18,0x98,0x60,0x87,0x00,0x80},
{0xA7,0x63,0x00,0x00,0x02,0x02,0x4B,0xFF,0x7A,0x00,0x4A,0x00,0x4A,0x44,0x4A,0x7E,0x4A,0x44,0x4A,0x44,0x4A,0x44,0x7A,0x5C,0x4A,0x48,0x02,0x42,0x04,0x42,0x04,0x43,0x08,0x3E},
{0xA7,0x64,0x00,0x00,0x02,0x10,0x03,0xF8,0x1A,0x10,0x13,0xF0,0x12,0x10,0x10,0x00,0x1F,0xFC,0x10,0x88,0x00,0x88,0x00,0x8A,0x7F,0xFF,0x01,0x40,0x02,0x30,0x0C,0x0F,0x30,0x02},
{0xA7,0x65,0x00,0x00,0x10,0x08,0x1F,0xFC,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08,0x00,0x00,0x00,0xF8,0x1F,0x80,0x00,0x80,0x00,0x88,0x3F,0xFC,0x00,0x80,0x00,0x82,0x7F,0xFF},
{0xA7,0x66,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x88,0x01,0x00,0x22,0x02,0x3F,0xFF,0x20,0x02,0x20,0x02,0x20,0x02,0x3F,0xFE,0x20,0x02},
{0xA7,0x67,0x00,0x00,0x00,0x08,0x3F,0xFC,0x01,0x08,0x01,0x0A,0x7F,0xFF,0x02,0x08,0x02,0x08,0x3F,0xF8,0x04,0x00,0x0F,0xFC,0x14,0x04,0x64,0x04,0x04,0x04,0x07,0xFC,0x04,0x04},
{0xA7,0x68,0x00,0x00,0x00,0x38,0x48,0x08,0x7D,0x88,0x49,0x04,0x49,0x04,0x4A,0x02,0x4D,0xFD,0x48,0x44,0x48,0x44,0x78,0x44,0x48,0x84,0x40,0x84,0x01,0x04,0x01,0x38,0x02,0x10},
{0xA7,0x69,0x00,0x00,0x00,0xC0,0x0C,0x80,0x08,0x88,0x1F,0xFC,0x20,0x80,0x00,0x82,0x7F,0xFF,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x08},
{0xA7,0x6A,0x00,0x00,0x00,0xC0,0x48,0x80,0x7C,0x82,0x48,0xFF,0x49,0x02,0x49,0x34,0x4A,0x20,0x48,0x20,0x48,0x60,0x78,0x50,0x48,0x50,0x40,0x88,0x01,0x08,0x02,0x07,0x0C,0x02},
{0xA7,0x6B,0x00,0x00,0x00,0xC0,0x48,0x80,0x7C,0x82,0x48,0xFF,0x49,0x4A,0x49,0x4A,0x4A,0x4A,0x48,0x92,0x48,0x92,0x79,0x22,0x4A,0x22,0x40,0x44,0x00,0x84,0x01,0x38,0x00,0x10},
{0xA7,0x6C,0x00,0x00,0x00,0x08,0x03,0xFC,0x48,0x88,0x7C,0x88,0x48,0x90,0x48,0x92,0x48,0xFF,0x49,0x42,0x49,0x22,0x79,0x24,0x4A,0x18,0x42,0x28,0x04,0x24,0x08,0x47,0x01,0x82},
{0xA7,0x6D,0x00,0x00,0x00,0x60,0x48,0x40,0x7C,0x48,0x48,0x84,0x48,0x9E,0x4B,0xE3,0x49,0x01,0x48,0x00,0x78,0xCC,0x48,0x88,0x40,0x88,0x00,0x89,0x01,0x09,0x01,0x09,0x06,0x07},
{0xA7,0x6E,0x00,0x00,0x00,0x30,0x48,0x20,0x7C,0x20,0x49,0xA8,0x49,0x26,0x49,0x23,0x4A,0x21,0x4C,0x20,0x78,0xE6,0x48,0x44,0x40,0x08,0x00,0x10,0x00,0x60,0x01,0x80,0x0E,0x00},
{0xA7,0x6F,0x00,0x00,0x00,0x20,0x00,0xF0,0x48,0x20,0x7A,0x22,0x4B,0xFF,0x4A,0x22,0x4A,0x52,0x4A,0x52,0x4A,0x4A,0x7A,0x86,0x4A,0x02,0x42,0x02,0x02,0x02,0x02,0x0E,0x02,0x04},
{0xA7,0x70,0x00,0x00,0x00,0x34,0x48,0x22,0x7C,0x22,0x48,0x20,0x48,0x22,0x4B,0xFF,0x48,0x20,0x48,0x20,0x48,0x50,0x78,0x50,0x48,0x48,0x40,0x88,0x00,0x84,0x01,0x07,0x06,0x02},
{0xA7,0x71,0x00,0x00,0x00,0x4C,0x07,0xE8,0x50,0x48,0x78,0x88,0x50,0x88,0x50,0xA8,0x50,0xC8,0x51,0x88,0x56,0x88,0x74,0x88,0x50,0x88,0x50,0x89,0x00,0x89,0x03,0x89,0x01,0x07},
{0xA7,0x72,0x00,0x00,0x00,0x04,0x4B,0xFE,0x78,0x10,0x49,0x90,0x49,0x10,0x49,0x12,0x4B,0xFF,0x48,0x30,0x48,0x50,0x78,0x50,0x48,0x90,0x41,0x10,0x06,0x10,0x00,0x70,0x00,0x20},
{0xA7,0x73,0x00,0x00,0x00,0x30,0x48,0x20,0x78,0x22,0x4B,0xFF,0x48,0x20,0x48,0x20,0x48,0x24,0x4B,0xFE,0x49,0x04,0x78,0x88,0x48,0x50,0x40,0x20,0x00,0x50,0x01,0x8C,0x06,0x07},
{0xA7,0x74,0x00,0x00,0x01,0x80,0x02,0x40,0x04,0x30,0x1B,0xCC,0x60,0x03,0x00,0x10,0x3F,0xF8,0x00,0x10,0x00,0x20,0x10,0x48,0x1F,0xFC,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08},
{0xA7,0x75,0x00,0x00,0x00,0x60,0x48,0xD0,0x7C,0x88,0x49,0x04,0x4A,0x13,0x4D,0xF8,0x48,0x00,0x48,0x04,0x4B,0xFE,0x78,0x08,0x48,0x08,0x40,0x10,0x00,0x10,0x00,0x20,0x00,0x20},
{0xA7,0x76,0x00,0x00,0x00,0x0C,0x49,0x1E,0x7D,0xE0,0x49,0x00,0x49,0x00,0x49,0x02,0x49,0xFF,0x49,0x10,0x79,0x10,0x49,0x10,0x42,0x10,0x02,0x10,0x02,0x10,0x04,0x10,0x08,0x10},
{0xA7,0x77,0x00,0x00,0x03,0x00,0x24,0x02,0x3F,0xFF,0x20,0x02,0x2C,0xC2,0x22,0x9A,0x21,0x12,0x23,0x22,0x24,0xC2,0x28,0xA2,0x21,0x32,0x22,0x12,0x20,0x02,0x3F,0xFE,0x20,0x02},
{0xA7,0x78,0x00,0x00,0x20,0x02,0x3F,0xFF,0x20,0x02,0x20,0xC2,0x20,0x92,0x2F,0xFA,0x21,0x82,0x22,0xC2,0x22,0xA2,0x24,0xA2,0x28,0x9A,0x20,0x82,0x20,0x02,0x3F,0xFE,0x20,0x02},
{0xA7,0x79,0x00,0x00,0x20,0x02,0x3F,0xFF,0x21,0x02,0x21,0x22,0x2F,0xF2,0x21,0x02,0x2D,0x32,0x29,0x22,0x2F,0xE2,0x29,0x2A,0x21,0x0A,0x20,0xFA,0x20,0x02,0x3F,0xFE,0x20,0x02},
{0xA7,0x7A,0x00,0x00,0x20,0x02,0x3F,0xFF,0x20,0x02,0x23,0x02,0x22,0x12,0x23,0xFA,0x25,0x52,0x29,0x52,0x22,0x52,0x24,0x92,0x21,0x12,0x22,0x62,0x20,0x02,0x3F,0xFE,0x20,0x02},
{0xA7,0x7B,0x00,0x00,0x18,0x30,0x10,0x22,0x13,0xFF,0x10,0x80,0x7C,0x80,0x10,0x84,0x10,0xFE,0x10,0x84,0x14,0x84,0x18,0x84,0x70,0x84,0x21,0x04,0x01,0x04,0x02,0x38,0x0C,0x10},
{0xA7,0x7C,0x00,0x00,0x18,0x30,0x10,0x22,0x13,0xFF,0x10,0x00,0x7C,0x00,0x10,0x88,0x10,0xFC,0x10,0x88,0x14,0x88,0x18,0x88,0x70,0x88,0x21,0x09,0x01,0x09,0x02,0x09,0x0C,0x07},
{0xA7,0x7D,0x00,0x00,0x18,0x30,0x10,0x20,0x10,0x20,0x10,0x20,0x7D,0xA0,0x11,0x24,0x11,0x3E,0x11,0x20,0x15,0x20,0x19,0x20,0x71,0x20,0x21,0x20,0x01,0x22,0x0F,0xFF,0x00,0x00},
{0xA7,0x7E,0x00,0x00,0x19,0x04,0x11,0xFE,0x11,0x04,0x11,0x44,0x7D,0x34,0x11,0x14,0x11,0x04,0x17,0xFF,0x11,0x04,0x15,0x04,0x19,0x04,0x72,0x04,0x22,0x24,0x02,0x1C,0x04,0x08},
{0xA7,0xA1,0x00,0x00,0x18,0xC0,0x10,0x80,0x10,0x82,0x10,0xFF,0x7D,0x02,0x11,0x12,0x12,0xFA,0x10,0x02,0x10,0x12,0x14,0xFA,0x18,0x02,0x70,0x04,0x20,0x04,0x00,0x78,0x00,0x10},
{0xA7,0xA2,0x00,0x00,0x18,0xC0,0x10,0x80,0x10,0x82,0x10,0xFF,0x7D,0x02,0x11,0x34,0x12,0x20,0x10,0x20,0x10,0x20,0x14,0x50,0x18,0x50,0x70,0x88,0x20,0x88,0x01,0x07,0x06,0x02},
{0xA7,0xA3,0x00,0x00,0x18,0x08,0x13,0xFC,0x10,0x88,0x10,0x88,0x7C,0x90,0x10,0x92,0x10,0xFF,0x11,0x42,0x15,0x22,0x19,0x24,0x72,0x18,0x22,0x28,0x04,0x24,0x08,0x47,0x01,0x82},
{0xA7,0xA4,0x00,0x00,0x00,0xC0,0x0C,0x8C,0x08,0x88,0x08,0x88,0x14,0x94,0x12,0x92,0x22,0xA2,0x00,0x80,0x00,0x84,0x3F,0xFE,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x00},
{0xA7,0xA5,0x00,0x00,0x18,0x02,0x13,0xFF,0x10,0x20,0x10,0x20,0x7C,0x40,0x10,0x70,0x10,0xA4,0x10,0xA2,0x14,0xA3,0x19,0x21,0x71,0x21,0x22,0x20,0x00,0x20,0x00,0x20,0x00,0x20},
{0xA7,0xA6,0x00,0x00,0x18,0x0C,0x10,0x9E,0x10,0xE0,0x14,0x80,0x7E,0x80,0x10,0x82,0x10,0xFF,0x10,0x88,0x12,0x88,0x1C,0x88,0x70,0x88,0x21,0x08,0x01,0x08,0x02,0x08,0x04,0x08},
{0xA7,0xA7,0x00,0x00,0x06,0x18,0x34,0x10,0x24,0x10,0x24,0x10,0x3C,0x12,0x25,0xFF,0x04,0x10,0x04,0x10,0x7C,0x10,0x24,0x10,0x24,0x10,0x24,0x10,0x24,0x14,0x44,0xFE,0x44,0x00},
{0xA7,0xA8,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x80,0x18,0x86,0x10,0x84,0x28,0x8A,0x25,0x49,0x45,0x51,0x01,0x20,0x02,0x20,0x02,0x10,0x04,0x0C,0x18,0x07,0x60,0x02},
{0xA7,0xA9,0x00,0x00,0x06,0x60,0x34,0x40,0x24,0x40,0x24,0x42,0x3D,0xFF,0x24,0x44,0x04,0x44,0x04,0x84,0x7C,0x88,0x25,0x48,0x24,0x30,0x24,0x28,0x44,0x44,0x44,0x46,0x05,0x82},
{0xA7,0xAA,0x00,0x00,0x18,0x8E,0x10,0xF0,0x10,0x80,0x12,0x82,0x7E,0xFF,0x12,0x82,0x22,0x82,0x22,0x82,0x64,0xFE,0x54,0x82,0x08,0x80,0x14,0x80,0x15,0x00,0x21,0x00,0x42,0x00},
{0xA7,0xAB,0x00,0x00,0x18,0x30,0x10,0x22,0x11,0xFF,0x7E,0x40,0x12,0x40,0x12,0x44,0x22,0x7E,0x24,0x44,0x64,0x44,0x58,0x44,0x14,0x84,0x24,0x84,0x21,0x04,0x41,0x38,0x02,0x10},
{0xA7,0xAC,0x00,0x00,0x18,0x04,0x10,0xFE,0x12,0x24,0x7F,0x24,0x12,0x24,0x12,0x24,0x12,0x24,0x22,0xFF,0x64,0x44,0x54,0x44,0x08,0x44,0x14,0x44,0x14,0x44,0x21,0xFF,0x40,0x00},
{0xA7,0xAD,0x00,0x00,0x31,0x8C,0x21,0x08,0x25,0x08,0x7D,0x08,0x25,0x08,0x25,0x4A,0x25,0xEF,0x49,0x08,0x69,0x08,0x59,0x08,0x15,0x08,0x15,0x29,0x21,0xC9,0x23,0x09,0x41,0x07},
{0xA7,0xAE,0x00,0x00,0x30,0x18,0x20,0x10,0x24,0x10,0x7E,0xD4,0x24,0x93,0x24,0x91,0x25,0x10,0x44,0x73,0x68,0x22,0x58,0x04,0x14,0x08,0x12,0x10,0x22,0x20,0x40,0xC0,0x03,0x00},
{0xA7,0xAF,0x00,0x00,0x18,0x0C,0x10,0x1E,0x12,0xF0,0x7E,0x10,0x12,0x10,0x12,0x12,0x23,0xFF,0x22,0x10,0x64,0x10,0x54,0x28,0x08,0x28,0x14,0x44,0x24,0x44,0x40,0x82,0x01,0x01},
{0xA7,0xB0,0x00,0x00,0x18,0x02,0x10,0xFF,0x12,0x24,0x7F,0x24,0x12,0x24,0x12,0x24,0x22,0x24,0x24,0xFF,0x64,0x24,0x58,0x24,0x14,0x24,0x12,0x24,0x22,0x44,0x40,0x44,0x00,0x84},
{0xA7,0xB1,0x00,0x00,0x18,0x04,0x10,0xFE,0x12,0x04,0x7F,0x68,0x12,0x10,0x12,0x02,0x22,0xFF,0x24,0x12,0x64,0x14,0x58,0x10,0x14,0x10,0x12,0x10,0x22,0x90,0x40,0x70,0x00,0x20},
{0xA7,0xB2,0x00,0x00,0x30,0x30,0x20,0x20,0x24,0x22,0x7D,0xFF,0x24,0x20,0x24,0x24,0x25,0xFE,0x44,0x84,0x68,0x44,0x50,0x48,0x18,0x30,0x14,0x10,0x24,0x28,0x20,0x47,0x41,0x82},
{0xA7,0xB3,0x00,0x00,0x18,0x0C,0x10,0x1E,0x10,0xF0,0x7E,0x10,0x12,0x10,0x12,0x10,0x22,0x12,0x22,0xFF,0x64,0x10,0x54,0x10,0x08,0x10,0x14,0x10,0x12,0x14,0x22,0xFE,0x40,0x00},
{0xA7,0xB4,0x00,0x00,0x00,0x7E,0x1F,0x80,0x10,0x88,0x10,0x66,0x23,0x22,0x02,0x00,0x02,0x02,0x7F,0xFF,0x02,0x10,0x04,0x20,0x04,0x20,0x0B,0xC0,0x01,0x30,0x06,0x0C,0x38,0x04},
{0xA7,0xB5,0x00,0x00,0x03,0x00,0x02,0x46,0x1F,0xE4,0x02,0x08,0x02,0x12,0x7F,0xFF,0x00,0x80,0x1F,0xF0,0x04,0x20,0x18,0x44,0x6F,0xFE,0x00,0x40,0x00,0x40,0x03,0xC0,0x00,0x80},
{0xA7,0xB6,0x00,0x00,0x02,0x60,0x7F,0x40,0x02,0x40,0x0C,0x42,0x08,0xFF,0x0A,0x84,0x0C,0x84,0x19,0x44,0x7A,0x48,0x28,0x28,0x08,0x10,0x08,0x28,0x48,0x28,0x38,0x44,0x11,0x83},
{0xA7,0xB7,0x00,0x00,0x00,0x7E,0x1F,0x80,0x11,0x08,0x10,0xC6,0x20,0x42,0x00,0x10,0x0F,0xF8,0x00,0x20,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xA7,0xB8,0x00,0x00,0x00,0xC0,0x00,0x84,0x3F,0xFE,0x00,0x80,0x3F,0xFF,0x20,0x02,0x4F,0xF4,0x00,0x20,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xA7,0xB9,0x00,0x00,0x01,0x80,0x21,0x02,0x3F,0xFF,0x20,0x02,0x40,0x24,0x1F,0xF0,0x00,0x00,0x00,0x04,0x7F,0xFE,0x04,0x40,0x04,0x40,0x04,0x42,0x08,0x42,0x08,0x43,0x30,0x3E},
{0xA7,0xBA,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x40,0xC4,0x00,0x80,0x00,0x82,0x7F,0xFF,0x01,0x80,0x02,0xC0,0x02,0xA0,0x04,0x98,0x18,0x87,0x60,0x82,0x00,0x80},
{0xA7,0xBB,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x43,0x04,0x02,0x00,0x7F,0xFF,0x04,0x00,0x04,0xC0,0x08,0x80,0x09,0x10,0x11,0x08,0x22,0x74,0x47,0x86,0x02,0x02},
{0xA7,0xBC,0x00,0x00,0x18,0x30,0x10,0x28,0x14,0x48,0x7E,0x44,0x10,0x84,0x15,0x03,0x14,0x6C,0x14,0x48,0x14,0x48,0x14,0x48,0x14,0x88,0x24,0x8A,0x25,0x0A,0x24,0x03,0x43,0xFE},
{0xA7,0xBD,0x00,0x00,0x20,0x08,0x3F,0xFC,0x20,0x08,0x20,0x08,0x3F,0xF8,0x20,0x08,0x20,0x02,0x3F,0xFF,0x20,0x02,0x2F,0xC2,0x28,0x42,0x28,0x42,0x4F,0xC2,0x40,0x1C,0x40,0x08},
{0xA7,0xBE,0x00,0x00,0x20,0x04,0x3F,0xFE,0x20,0x04,0x20,0x04,0x3F,0xFC,0x20,0x04,0x26,0x30,0x24,0x20,0x25,0x24,0x27,0xBE,0x24,0x20,0x24,0x22,0x45,0xA2,0x5E,0x23,0x48,0x1E},
{0xA7,0xBF,0x00,0x00,0x20,0x04,0x3F,0xFE,0x20,0x04,0x20,0x04,0x3F,0xFC,0x20,0x04,0x20,0x60,0x22,0x40,0x2F,0x46,0x22,0x68,0x22,0x50,0x24,0x48,0x44,0x47,0x49,0xC2,0x40,0x80},
{0xA7,0xC0,0x00,0x00,0x20,0x08,0x3F,0xFC,0x20,0x08,0x20,0x08,0x3F,0xF8,0x20,0x08,0x20,0x60,0x20,0xF0,0x27,0x80,0x20,0xF8,0x2F,0x80,0x20,0xFD,0x5F,0x81,0x40,0x81,0x40,0x7F},
{0xA7,0xC1,0x00,0x00,0x18,0x30,0x10,0x20,0x10,0x22,0x55,0xFF,0x54,0x20,0x54,0x24,0x55,0xFE,0x54,0x84,0x54,0x44,0x54,0x48,0x54,0x30,0x7C,0x10,0x44,0x28,0x00,0x47,0x01,0x82},
{0xA7,0xC2,0x00,0x00,0x00,0xC0,0x30,0x86,0x20,0x84,0x3F,0xFC,0x21,0x84,0x02,0x40,0x04,0x30,0x1B,0xCC,0x60,0x03,0x0F,0xF8,0x00,0x10,0x00,0x20,0x00,0x20,0x00,0x40,0x00,0x80},
{0xA7,0xC3,0x00,0x00,0x06,0xE0,0x04,0x20,0x08,0x10,0x10,0x0C,0x6F,0xF3,0x02,0x10,0x02,0x10,0x04,0x70,0x38,0x20,0x00,0xC0,0x18,0x86,0x10,0x84,0x10,0x84,0x1F,0xFC,0x10,0x04},
{0xA7,0xC4,0x00,0x00,0x31,0x8C,0x21,0x08,0x3F,0xF8,0x20,0x08,0x00,0x40,0x7F,0xE0,0x08,0x40,0x08,0x90,0x0F,0xF8,0x0A,0x10,0x11,0x20,0x10,0xC0,0x20,0xB0,0x43,0x0F,0x0C,0x02},
{0xA7,0xC5,0x00,0x00,0x00,0x04,0x3F,0xFE,0x00,0x80,0x0C,0x8C,0x08,0x88,0x08,0x88,0x18,0x98,0x14,0x94,0x24,0xA4,0x22,0xA2,0x42,0xC2,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x00},
{0xA7,0xC6,0x00,0x00,0x1E,0x78,0x01,0x80,0x06,0x60,0x39,0x98,0x01,0x02,0x7F,0xFF,0x02,0x00,0x04,0xC0,0x08,0x84,0x1F,0xFE,0x68,0x84,0x08,0x84,0x08,0x9C,0x08,0x88,0x00,0x80},
{0xA7,0xC7,0x00,0x00,0x00,0x60,0x20,0x42,0x3F,0xFF,0x20,0x00,0x27,0xF8,0x20,0x10,0x21,0xA0,0x20,0x42,0x3F,0xFF,0x20,0x42,0x20,0x44,0x20,0x40,0x42,0x40,0x41,0xC0,0x40,0x80},
{0xA7,0xC8,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x00,0x26,0x30,0x24,0x20,0x24,0x20,0x25,0x24,0x27,0xBE,0x24,0x20,0x24,0x20,0x24,0xA2,0x47,0x22,0x5C,0x23,0x48,0x1E},
{0xA7,0xC9,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x00,0x20,0x60,0x20,0x44,0x2F,0xFE,0x20,0xC0,0x21,0x60,0x21,0x50,0x22,0x50,0x22,0x48,0x44,0x46,0x48,0x40,0x40,0x40},
{0xA7,0xCA,0x00,0x00,0x04,0x0C,0x7E,0x1E,0x04,0xF0,0x08,0x10,0x10,0x10,0x24,0x12,0x7E,0xFF,0x24,0x10,0x04,0x10,0x34,0x14,0x28,0xFE,0x48,0x00,0x54,0x00,0x13,0x03,0x20,0xFC},
{0xA7,0xCB,0x00,0x00,0x00,0x08,0x1F,0xFC,0x00,0x80,0x00,0x90,0x0F,0xF8,0x00,0x80,0x00,0x84,0x3F,0xFE,0x00,0x00,0x04,0x12,0x7F,0xFF,0x04,0x10,0x08,0x10,0x08,0x10,0x10,0x10},
{0xA7,0xCC,0x00,0x00,0x08,0x18,0x06,0x10,0x02,0x24,0x7F,0xFE,0x00,0x84,0x10,0x84,0x1F,0xFC,0x10,0x80,0x10,0x82,0x3F,0xFF,0x21,0x82,0x02,0x82,0x0C,0xBC,0x70,0x88,0x00,0x80},
{0xA7,0xCD,0x00,0x00,0x10,0x83,0x1F,0xC2,0x10,0x84,0x14,0x88,0x12,0xB0,0x12,0x83,0x10,0xE2,0x17,0x84,0x78,0x88,0x50,0xB3,0x10,0x82,0x10,0x84,0x20,0x88,0x23,0xB0,0x41,0x00},
{0xA7,0xCE,0x00,0x00,0x01,0x06,0x7F,0x84,0x12,0x08,0x12,0x10,0x12,0x60,0x12,0x06,0x12,0x84,0x7F,0xC8,0x12,0x10,0x12,0x63,0x12,0x02,0x22,0x04,0x22,0x08,0x22,0x10,0x42,0x60},
{0xA7,0xCF,0x00,0x00,0x0C,0x30,0x08,0x20,0x10,0x22,0x23,0xFF,0x4C,0x80,0x08,0x84,0x10,0xFE,0x30,0x84,0x50,0x84,0x10,0x84,0x11,0x04,0x11,0x04,0x11,0x04,0x12,0x78,0x14,0x10},
{0xA7,0xD0,0x00,0x00,0x0D,0x10,0x09,0xF8,0x11,0x10,0x21,0x12,0x4D,0x13,0x09,0x0E,0x12,0x00,0x30,0x04,0x57,0xFE,0x11,0x04,0x10,0x88,0x10,0x50,0x10,0x60,0x10,0x98,0x17,0x07},
{0xA7,0xD1,0x00,0x00,0x00,0xC0,0x20,0x84,0x3F,0xFE,0x20,0x00,0x20,0x00,0x20,0x00,0x1F,0xFC,0x00,0x00,0x00,0x80,0x06,0xC0,0x24,0x44,0x24,0x52,0x44,0x13,0x44,0x19,0x03,0xF0},
{0xA7,0xD2,0x00,0x00,0x00,0x08,0x3F,0xFC,0x00,0x08,0x10,0x08,0x1F,0xFA,0x10,0x0A,0x10,0x03,0x0F,0xFE,0x00,0x00,0x06,0x80,0x24,0x40,0x24,0x52,0x44,0x11,0x44,0x19,0x03,0xF0},
{0xA7,0xD3,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x88,0x1F,0xFC,0x00,0x00,0x00,0x80,0x06,0xC0,0x24,0x44,0x24,0x12,0x44,0x13,0x44,0x19,0x03,0xF0},
{0xA7,0xD4,0x00,0x00,0x00,0x04,0x3F,0xFE,0x01,0x04,0x31,0x04,0x0D,0x04,0x02,0x04,0x0C,0x78,0x70,0x10,0x00,0x00,0x06,0x80,0x24,0xC4,0x24,0x52,0x44,0x13,0x44,0x19,0x03,0xF0},
{0xA7,0xD5,0x00,0x00,0x18,0x30,0x10,0x20,0x10,0xA2,0x18,0xFF,0x54,0xA2,0x55,0x24,0x50,0x20,0x10,0x20,0x10,0x58,0x10,0x50,0x10,0x50,0x10,0x92,0x10,0x92,0x11,0x13,0x12,0x0E},
{0xA7,0xD6,0x00,0x00,0x18,0x60,0x10,0x40,0x10,0x44,0x13,0xFE,0x58,0x44,0x54,0x44,0x54,0x44,0x10,0x44,0x17,0xFF,0x10,0x60,0x10,0x50,0x10,0x90,0x10,0x88,0x11,0x04,0x16,0x03},
{0xA7,0xD7,0x00,0x00,0x18,0x04,0x13,0xFE,0x10,0x44,0x18,0x44,0x54,0x44,0x54,0x44,0x50,0x84,0x13,0xFF,0x10,0x88,0x10,0x88,0x10,0x88,0x11,0x08,0x11,0x0A,0x17,0xFF,0x10,0x00},
{0xA7,0xD8,0x00,0x00,0x18,0x10,0x10,0x78,0x10,0x10,0x19,0x88,0x55,0x08,0x55,0x08,0x51,0x64,0x12,0x44,0x12,0x42,0x14,0x41,0x10,0x90,0x10,0x88,0x10,0xB4,0x13,0xC6,0x11,0x02},
{0xA7,0xD9,0x00,0x00,0x00,0x68,0x00,0x46,0x00,0x40,0x7F,0xFF,0x00,0x20,0x1B,0x20,0x12,0x26,0x12,0x24,0x7F,0x94,0x12,0x14,0x12,0x08,0x22,0x09,0x22,0x15,0x42,0x25,0x00,0xC3},
{0xA7,0xDA,0x00,0x00,0x00,0x30,0x07,0x24,0x3C,0x23,0x04,0x21,0x04,0x20,0x7F,0xFF,0x04,0x20,0x04,0x26,0x05,0xA4,0x0E,0x14,0x74,0x18,0x24,0x11,0x04,0x29,0x3C,0x25,0x08,0xC3},
{0xA7,0xDB,0x00,0x00,0x18,0x18,0x10,0x10,0x10,0x10,0x7C,0xD4,0x10,0x92,0x10,0x93,0x15,0x11,0x19,0x10,0x72,0x73,0x50,0x22,0x10,0x04,0x10,0x08,0x10,0x30,0x70,0xC0,0x23,0x00},
{0xA7,0xDC,0x00,0x00,0x18,0x30,0x10,0x22,0x13,0xFF,0x7C,0x00,0x10,0x00,0x10,0x88,0x14,0xFC,0x18,0x88,0x70,0x88,0x50,0x88,0x10,0x88,0x10,0x89,0x11,0x09,0x71,0x09,0x22,0x07},
{0xA7,0xDD,0x00,0x00,0x18,0x0C,0x11,0x08,0x10,0xC8,0x7C,0x48,0x10,0x08,0x11,0x08,0x14,0xC8,0x18,0x4A,0x70,0x0F,0x50,0x78,0x13,0x88,0x10,0x08,0x10,0x08,0x70,0x08,0x20,0x08},
{0xA7,0xDE,0x00,0x00,0x18,0x30,0x10,0x20,0x10,0x22,0x7D,0xFF,0x10,0x20,0x10,0x24,0x15,0xFE,0x18,0x84,0x70,0x44,0x50,0x48,0x10,0x30,0x10,0x10,0x10,0x28,0x70,0x44,0x21,0x83},
{0xA7,0xDF,0x00,0x00,0x18,0x30,0x10,0x20,0x10,0x24,0x7D,0xFE,0x10,0x20,0x10,0x20,0x14,0x22,0x1B,0xFF,0x70,0x20,0x50,0x50,0x10,0x50,0x10,0x88,0x10,0x88,0x71,0x04,0x22,0x03},
{0xA7,0xE0,0x00,0x00,0x18,0x30,0x10,0x20,0x10,0x24,0x7D,0xFE,0x10,0x24,0x10,0x24,0x14,0x24,0x18,0x24,0x73,0xFF,0x50,0x50,0x10,0x50,0x10,0x88,0x10,0x88,0x71,0x04,0x26,0x03},
{0xA7,0xE1,0x00,0x00,0x18,0x04,0x13,0xFE,0x10,0x44,0x7C,0x44,0x10,0x44,0x10,0x44,0x14,0x84,0x1B,0xFF,0x70,0x88,0x50,0x88,0x10,0x88,0x11,0x08,0x11,0x0A,0x77,0xFF,0x20,0x00},
{0xA7,0xE2,0x00,0x00,0x18,0x00,0x11,0x04,0x11,0xFE,0x7D,0x24,0x11,0x24,0x11,0x24,0x15,0x24,0x19,0x24,0x71,0xFC,0x51,0x04,0x11,0x00,0x11,0x02,0x11,0x02,0x71,0x03,0x20,0xFE},
{0xA7,0xE3,0x00,0x00,0x19,0x02,0x11,0xFF,0x11,0x00,0x7D,0x00,0x11,0x24,0x11,0x3E,0x15,0x24,0x19,0x24,0x71,0x24,0x51,0x3C,0x11,0x28,0x11,0x22,0x12,0x22,0x72,0x23,0x24,0x1E},
{0xA7,0xE4,0x00,0x00,0x18,0x68,0x10,0x46,0x14,0x40,0x7E,0x4E,0x10,0x70,0x13,0xC0,0x10,0x46,0x14,0x44,0x18,0x28,0x70,0x28,0x50,0x10,0x10,0x29,0x10,0xC5,0x73,0x03,0x20,0x01},
{0xA7,0xE5,0x00,0x00,0x19,0x8C,0x11,0x08,0x11,0x08,0x7D,0x08,0x11,0x08,0x11,0x4A,0x15,0xEF,0x19,0x08,0x71,0x08,0x51,0x08,0x11,0x08,0x11,0x29,0x11,0x49,0x73,0x89,0x21,0x07},
{0xA7,0xE6,0x00,0x00,0x19,0x02,0x11,0xFF,0x11,0x00,0x7D,0x00,0x11,0x04,0x11,0xFE,0x15,0x44,0x19,0x44,0x71,0x28,0x51,0x28,0x11,0x10,0x12,0x28,0x12,0x24,0x72,0x44,0x24,0x83},
{0xA7,0xE7,0x00,0x00,0x18,0x04,0x11,0xFE,0x14,0x04,0x7E,0x68,0x10,0x10,0x10,0x02,0x15,0xFF,0x18,0x12,0x70,0x14,0x50,0x10,0x10,0x10,0x10,0x10,0x10,0x90,0x70,0x70,0x20,0x20},
{0xA7,0xE8,0x00,0x00,0x18,0x30,0x10,0x20,0x10,0x20,0x7C,0x20,0x11,0xA0,0x11,0x24,0x15,0x3E,0x19,0x20,0x71,0x20,0x51,0x20,0x11,0x20,0x11,0x20,0x11,0x22,0x77,0xFF,0x20,0x00},
{0xA7,0xE9,0x00,0x00,0x0C,0x04,0x08,0x8E,0x08,0xF0,0x7E,0x80,0x08,0x80,0x08,0x82,0x0A,0xFF,0x0C,0x88,0x78,0x88,0x28,0x88,0x08,0x88,0x09,0x08,0x09,0x08,0x39,0x08,0x12,0x08},
{0xA7,0xEA,0x00,0x00,0x18,0x08,0x10,0x3C,0x10,0x08,0x7C,0xC8,0x10,0x84,0x11,0x04,0x15,0x02,0x1A,0xFD,0x70,0x44,0x50,0x44,0x10,0x44,0x10,0x84,0x10,0x84,0x71,0x38,0x22,0x10},
{0xA7,0xEB,0x00,0x00,0x18,0x90,0x10,0xF8,0x14,0x90,0x7E,0x92,0x10,0x93,0x10,0x8E,0x15,0x00,0x18,0x04,0x71,0xFE,0x50,0x84,0x10,0x48,0x10,0x30,0x10,0x50,0x70,0x8C,0x23,0x03},
{0xA7,0xEC,0x00,0x00,0x18,0x0C,0x11,0x3E,0x11,0xE4,0x7D,0x24,0x11,0x24,0x11,0x24,0x15,0x24,0x19,0x24,0x71,0x24,0x51,0x24,0x11,0x24,0x12,0x22,0x12,0x22,0x72,0x21,0x24,0x21},
{0xA7,0xED,0x00,0x00,0x19,0x60,0x11,0x92,0x11,0x1F,0x7D,0x12,0x11,0x12,0x11,0x12,0x15,0x12,0x19,0x12,0x71,0x12,0x51,0x52,0x11,0x92,0x13,0x1E,0x11,0x14,0x70,0x10,0x20,0x10},
{0xA7,0xEE,0x00,0x00,0x18,0x30,0x10,0x20,0x10,0x22,0x7D,0xFF,0x10,0x84,0x10,0x84,0x14,0x4C,0x18,0x48,0x70,0x28,0x50,0x10,0x10,0x28,0x10,0x28,0x10,0x44,0x70,0x84,0x21,0x03},
{0xA7,0xEF,0x00,0x00,0x02,0x60,0x7F,0x40,0x02,0x42,0x02,0x7F,0x42,0x44,0x7E,0x44,0x42,0xC4,0x40,0xA4,0x41,0x28,0x40,0x28,0x42,0x10,0x43,0x28,0x3E,0x28,0x00,0xC4,0x03,0x03},
{0xA7,0xF0,0x00,0x00,0x00,0xC0,0x04,0x80,0x7E,0x82,0x10,0xFF,0x10,0x84,0x11,0x84,0x11,0x44,0x12,0x48,0x10,0x28,0x12,0x30,0x1C,0x10,0x70,0x28,0x20,0x48,0x00,0x84,0x03,0x03},
{0xA7,0xF1,0x00,0x00,0x0C,0x60,0x08,0x40,0x08,0x42,0x10,0x7F,0x16,0x84,0x34,0x84,0x54,0x84,0x15,0x44,0x14,0x28,0x14,0x28,0x14,0x10,0x14,0x28,0x14,0x28,0x10,0x44,0x11,0x83},
{0xA7,0xF2,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x00,0x00,0x3F,0xFE,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA7,0xF3,0x00,0x00,0x00,0x04,0x7F,0xFE,0x00,0x80,0x1F,0xF8,0x10,0x88,0x1F,0xF8,0x10,0x88,0x1F,0xF8,0x10,0x88,0x00,0x80,0x19,0x00,0x17,0x00,0x22,0xC0,0x0C,0x38,0x70,0x07},
{0xA7,0xF4,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x80,0x10,0x84,0x1F,0xFE,0x10,0x84,0x10,0x84,0x1F,0xFC,0x11,0x84,0x02,0xC0,0x04,0xB0,0x18,0x8C,0x60,0x83,0x00,0x80},
{0xA7,0xF5,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x01,0x80,0x06,0xE0,0x18,0x98,0x60,0x07,0x07,0xF0,0x00,0x20,0x00,0x42,0x7F,0xFF,0x00,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xA7,0xF6,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x01,0x80,0x02,0xE0,0x0C,0x98,0x70,0x87,0x00,0x80,0x10,0x08,0x1F,0xFC,0x10,0x08,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08},
{0xA7,0xF7,0x00,0x00,0x0C,0x0C,0x08,0x08,0x08,0x0A,0x7E,0xFF,0x08,0x18,0x18,0x18,0x18,0x28,0x2C,0x28,0x2A,0x48,0x4A,0x48,0x08,0x88,0x09,0x08,0x08,0x08,0x08,0x38,0x08,0x10},
{0xA7,0xF8,0x00,0x00,0x0C,0x06,0x08,0x04,0x08,0x04,0x7E,0xFF,0x08,0x04,0x18,0x04,0x18,0x84,0x2C,0x44,0x2A,0x64,0x4A,0x24,0x08,0x04,0x08,0x04,0x08,0x24,0x08,0x1C,0x08,0x08},
{0xA7,0xF9,0x00,0x00,0x0C,0x18,0x08,0x10,0x08,0x10,0x7E,0x10,0x08,0x14,0x18,0xFE,0x18,0x10,0x2C,0x10,0x2B,0x10,0x49,0x10,0x08,0x10,0x08,0x10,0x08,0x12,0x09,0xFF,0x08,0x00},
{0xA7,0xFA,0x00,0x00,0x0C,0x06,0x08,0x04,0x08,0x04,0x7E,0xFF,0x08,0x04,0x18,0x04,0x1C,0xC4,0x2A,0xA8,0x29,0x28,0x48,0x10,0x08,0x10,0x08,0x28,0x08,0x28,0x08,0x44,0x09,0x83},
{0xA7,0xFB,0x00,0x00,0x0C,0x04,0x09,0xFE,0x08,0x04,0x7E,0x04,0x08,0x04,0x18,0x04,0x18,0x84,0x2C,0xFC,0x2A,0x84,0x4A,0x80,0x48,0x80,0x08,0x82,0x08,0x82,0x08,0x83,0x08,0x7E},
{0xA7,0xFC,0x00,0x00,0x0C,0x06,0x08,0x04,0x0A,0x08,0x7F,0x10,0x08,0x60,0x18,0x06,0x18,0x04,0x2C,0x08,0x2B,0x10,0x49,0x63,0x08,0x02,0x08,0x04,0x08,0x08,0x08,0x10,0x08,0x60},
{0xA7,0xFD,0x00,0x00,0x0C,0x04,0x08,0xFE,0x08,0x10,0x7E,0x10,0x08,0x10,0x18,0x10,0x18,0x12,0x2C,0xFF,0x2A,0x10,0x4A,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10},
{0xA7,0xFE,0x00,0x00,0x0C,0x04,0x09,0xFE,0x08,0x20,0x7E,0x20,0x08,0x20,0x18,0x20,0x18,0x20,0x2C,0x20,0x2A,0x20,0x4A,0x20,0x08,0x20,0x08,0x20,0x08,0x22,0x09,0xFF,0x08,0x00},
{0xA8,0x40,0x00,0x00,0x0C,0x60,0x08,0x40,0x08,0x42,0x7E,0xFF,0x08,0x82,0x19,0x02,0x18,0x02,0x2C,0x12,0x2A,0xFA,0x4A,0x02,0x08,0x04,0x08,0x04,0x08,0x44,0x08,0x38,0x08,0x10},
{0xA8,0x41,0x00,0x00,0x00,0xC0,0x20,0x84,0x3F,0xFE,0x20,0x00,0x20,0x00,0x1F,0xFC,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x01,0x80,0x06,0xE0,0x18,0x98,0x60,0x87,0x00,0x80},
{0xA8,0x42,0x00,0x00,0x00,0xC0,0x18,0x88,0x10,0xFC,0x10,0x80,0x10,0x82,0x7F,0xFF,0x00,0x80,0x0C,0x80,0x08,0x8C,0x13,0x88,0x61,0x10,0x00,0x60,0x01,0x80,0x0E,0x00,0x70,0x00},
{0xA8,0x43,0x00,0x00,0x0C,0x00,0x08,0x04,0x1F,0xFE,0x20,0x00,0x4F,0xF8,0x09,0x08,0x08,0x8A,0x7F,0xFF,0x08,0x08,0x11,0x08,0x10,0x88,0x3F,0xFE,0x20,0x10,0x00,0xF0,0x00,0x20},
{0xA8,0x44,0x00,0x00,0x00,0xC8,0x00,0x86,0x00,0x80,0x7F,0xFF,0x00,0x80,0x20,0x80,0x18,0xC6,0x08,0xA4,0x01,0xA8,0x06,0x90,0x18,0x88,0x70,0x87,0x20,0x82,0x07,0x80,0x01,0x00},
{0xA8,0x45,0x00,0x00,0x00,0x08,0x1F,0xFC,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x00,0x00,0xC0,0x04,0x8C,0x3E,0x88,0x04,0xD0,0x08,0xA0,0x10,0x98,0x60,0x87,0x03,0x82,0x01,0x00},
{0xA8,0x46,0x00,0x00,0x20,0x18,0x10,0x10,0x10,0x10,0x44,0xD4,0x24,0x92,0x28,0x93,0x09,0x11,0x12,0x10,0x60,0x76,0x20,0x24,0x20,0x08,0x60,0x10,0x60,0x60,0x21,0x80,0x0E,0x00},
{0xA8,0x47,0x00,0x00,0x20,0x40,0x10,0x20,0x10,0x30,0x45,0x90,0x25,0x00,0x29,0x00,0x09,0x04,0x11,0x02,0x15,0x02,0x65,0x0B,0x25,0x09,0x29,0x08,0x69,0x0C,0x60,0xF8,0x20,0x00},
{0xA8,0x48,0x00,0x00,0x20,0x30,0x10,0x20,0x11,0x22,0x45,0xFF,0x25,0x22,0x2A,0x24,0x08,0x20,0x10,0x38,0x10,0x50,0x60,0x50,0x20,0x50,0x20,0x92,0x60,0x92,0x61,0x13,0x26,0x0E},
{0xA8,0x49,0x00,0x00,0x22,0x02,0x13,0xFF,0x12,0x02,0x44,0x04,0x20,0x00,0x29,0x10,0x09,0xF8,0x11,0x10,0x11,0x10,0x61,0x10,0x21,0x10,0x21,0x12,0x62,0x12,0x62,0x13,0x24,0x0E},
{0xA8,0x4A,0x00,0x00,0x20,0x08,0x11,0xFC,0x10,0x00,0x44,0x00,0x24,0x00,0x28,0x02,0x0B,0xFF,0x10,0x90,0x10,0x90,0x60,0x90,0x20,0x90,0x21,0x12,0x41,0x12,0x62,0x13,0x24,0x0E},
{0xA8,0x4B,0x00,0x00,0x20,0x30,0x10,0x22,0x17,0xFF,0x40,0x20,0x22,0x22,0x2B,0xFF,0x0A,0x22,0x12,0x22,0x12,0x22,0x62,0x22,0x22,0x22,0x22,0x2E,0x62,0x24,0x20,0x20,0x00,0x20},
{0xA8,0x4C,0x00,0x00,0x20,0x02,0x13,0xFF,0x10,0x20,0x44,0x20,0x24,0x20,0x28,0x20,0x08,0x24,0x11,0xFE,0x10,0x20,0x60,0x20,0x20,0x20,0x20,0x20,0x60,0x22,0x67,0xFF,0x20,0x00},
{0xA8,0x4D,0x00,0x00,0x20,0x60,0x10,0x40,0x10,0x48,0x43,0xFC,0x28,0x48,0x28,0x48,0x08,0x48,0x10,0x4A,0x17,0xFF,0x60,0x40,0x20,0xA0,0x20,0x90,0x61,0x08,0x22,0x04,0x0C,0x03},
{0xA8,0x4E,0x00,0x00,0x20,0x30,0x10,0x20,0x14,0x20,0x44,0x22,0x2B,0xFF,0x28,0x60,0x08,0x70,0x10,0xA8,0x10,0xA8,0x61,0x24,0x21,0x24,0x22,0x22,0x64,0x21,0x60,0x20,0x20,0x20},
{0xA8,0x4F,0x00,0x00,0x20,0x30,0x10,0x20,0x10,0x20,0x44,0x22,0x27,0xFF,0x28,0x20,0x08,0x50,0x10,0x50,0x10,0x48,0x60,0x88,0x20,0x84,0x21,0x44,0x61,0x34,0x62,0x12,0x24,0x01},
{0xA8,0x50,0x00,0x00,0x20,0x30,0x10,0x20,0x10,0x26,0x44,0x78,0x2B,0xA0,0x28,0x20,0x0B,0x26,0x12,0x24,0x12,0x24,0x62,0x24,0x23,0xFC,0x22,0x25,0x60,0x21,0x60,0x21,0x20,0x1F},
{0xA8,0x51,0x00,0x00,0x21,0x02,0x11,0xFF,0x11,0x02,0x03,0x02,0x45,0x02,0x25,0x02,0x29,0x02,0x09,0xFE,0x11,0x02,0x71,0x02,0x11,0x02,0x11,0x02,0x31,0x02,0x31,0xFE,0x11,0x02},
{0xA8,0x52,0x00,0x00,0x20,0x30,0x10,0x20,0x14,0x20,0x44,0x22,0x2B,0xFF,0x2A,0x22,0x0A,0x22,0x12,0x22,0x12,0x22,0x63,0xFE,0x22,0x22,0x20,0x20,0x60,0x20,0x60,0x20,0x20,0x20},
{0xA8,0x53,0x00,0x00,0x20,0xC0,0x10,0x84,0x10,0xFE,0x44,0x84,0x25,0x04,0x29,0x38,0x0A,0x10,0x10,0x04,0x13,0xFE,0x61,0x04,0x20,0x98,0x20,0x60,0x60,0x50,0x61,0x8F,0x26,0x02},
{0xA8,0x54,0x00,0x00,0x23,0x00,0x12,0x00,0x13,0xFE,0x44,0x00,0x29,0xFC,0x20,0x00,0x0B,0xF8,0x10,0x08,0x10,0x08,0x60,0x08,0x20,0x09,0x20,0x09,0x60,0x05,0x60,0x03,0x20,0x01},
{0xA8,0x55,0x00,0x00,0x10,0x0C,0x08,0x3E,0x09,0xE0,0x40,0x20,0x24,0x20,0x28,0x20,0x08,0x22,0x13,0xFF,0x10,0x20,0x60,0x50,0x20,0x50,0x20,0x88,0x60,0x88,0x61,0x04,0x26,0x03},
{0xA8,0x56,0x00,0x00,0x20,0x08,0x17,0xFC,0x11,0x08,0x41,0x08,0x25,0x10,0x29,0x12,0x09,0xFF,0x11,0x42,0x11,0x24,0x62,0x24,0x22,0x18,0x22,0x28,0x64,0x24,0x24,0x44,0x09,0x83},
{0xA8,0x57,0x00,0x00,0x20,0x08,0x10,0x7C,0x10,0x08,0x45,0x88,0x25,0x04,0x29,0x04,0x0A,0x02,0x13,0xFD,0x14,0x84,0x60,0x84,0x20,0x84,0x21,0x04,0x61,0x04,0x22,0x38,0x04,0x10},
{0xA8,0x58,0x00,0x00,0x20,0x80,0x10,0x60,0x10,0x30,0x40,0x10,0x24,0x02,0x2B,0xFF,0x08,0x20,0x10,0x30,0x10,0x28,0x60,0x24,0x20,0x26,0x20,0x22,0x60,0x20,0x60,0x20,0x20,0x20},
{0xA8,0x59,0x00,0x00,0x20,0x60,0x10,0x42,0x17,0xFF,0x40,0x00,0x24,0x00,0x29,0x10,0x09,0xF8,0x11,0x10,0x11,0x10,0x61,0x10,0x21,0x12,0x21,0x12,0x62,0x12,0x22,0x13,0x0C,0x0E},
{0xA8,0x5A,0x00,0x00,0x20,0x30,0x10,0x20,0x10,0x22,0x47,0xFF,0x20,0x04,0x29,0x84,0x0A,0x88,0x12,0x48,0x10,0x50,0x10,0x20,0x60,0x50,0x20,0x50,0x20,0x88,0x61,0x04,0x22,0x03},
{0xA8,0x5B,0x00,0x00,0x20,0x02,0x17,0xFF,0x10,0x80,0x40,0x80,0x24,0x84,0x29,0xFE,0x09,0x04,0x11,0x04,0x12,0x04,0x62,0x08,0x23,0xF8,0x22,0x08,0x60,0x08,0x60,0x0A,0x2F,0xFF},
{0xA8,0x5C,0x00,0x00,0x20,0x02,0x17,0xFF,0x10,0x20,0x40,0x20,0x23,0x22,0x2A,0x3F,0x0A,0x22,0x12,0x22,0x13,0xFE,0x62,0x02,0x20,0x02,0x20,0x04,0x60,0x44,0x60,0x38,0x20,0x10},
{0xA8,0x5D,0x00,0x00,0x23,0x18,0x12,0x10,0x12,0x10,0x42,0x10,0x26,0x10,0x2A,0x94,0x0B,0xDE,0x12,0x10,0x12,0x10,0x62,0x10,0x22,0x10,0x22,0x51,0x63,0x91,0x2E,0x11,0x04,0x0F},
{0xA8,0x5E,0x00,0x00,0x20,0x0C,0x11,0x1E,0x11,0xE0,0x41,0x00,0x25,0x00,0x29,0x02,0x09,0xFF,0x11,0x08,0x11,0x08,0x61,0x08,0x22,0x08,0x22,0x08,0x62,0x08,0x64,0x08,0x28,0x08},
{0xA8,0x5F,0x00,0x00,0x18,0x30,0x10,0x20,0x10,0x20,0x16,0x20,0x54,0x24,0x59,0xFE,0x50,0x20,0x50,0x20,0x18,0x20,0x14,0x20,0x16,0x20,0x22,0x20,0x20,0x22,0x23,0xFF,0x40,0x00},
{0xA8,0x60,0x00,0x00,0x18,0x60,0x10,0x40,0x10,0x42,0x16,0xFF,0x54,0x82,0x59,0x02,0x52,0x02,0x50,0x12,0x18,0xFA,0x14,0x02,0x16,0x02,0x22,0x04,0x20,0x44,0x20,0x38,0x40,0x10},
{0xA8,0x61,0x00,0x00,0x18,0xCC,0x11,0x08,0x66,0x30,0x11,0x08,0x08,0x84,0x00,0x00,0x01,0x80,0x09,0x0C,0x09,0x10,0x11,0x60,0x62,0x80,0x02,0x40,0x04,0x30,0x18,0x0F,0x60,0x02},
{0xA8,0x62,0x00,0x00,0x04,0x20,0x07,0xF0,0x08,0x40,0x30,0x80,0x01,0x40,0x06,0x30,0x18,0x0F,0x61,0x82,0x09,0x18,0x09,0x60,0x31,0x00,0x02,0xC0,0x04,0x30,0x18,0x0F,0x60,0x02},
{0xA8,0x63,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x40,0xC4,0x0C,0x80,0x08,0x88,0x1F,0xFC,0x20,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA8,0x64,0x00,0x00,0x06,0x18,0x34,0x10,0x24,0x10,0x3F,0x10,0x24,0x14,0x44,0xFE,0x44,0x10,0x05,0x10,0x0E,0x10,0x74,0x10,0x24,0x10,0x04,0x10,0x04,0x12,0x05,0xFF,0x04,0x00},
{0xA8,0x65,0x00,0x00,0x0C,0x18,0x28,0xD0,0x28,0x90,0x3E,0x92,0x48,0x97,0x48,0xBA,0x09,0xD2,0x08,0x92,0x0E,0x96,0x78,0x92,0x28,0x90,0x08,0x81,0x08,0x81,0x08,0x81,0x08,0x7F},
{0xA8,0x66,0x00,0x00,0x46,0x30,0x24,0x20,0x18,0x20,0x10,0xA3,0x28,0xA2,0x49,0x24,0x0D,0x28,0x14,0x20,0x14,0x20,0x24,0x50,0x44,0x50,0x04,0x88,0x44,0x88,0x39,0x04,0x12,0x03},
{0xA8,0x67,0x00,0x00,0x4C,0x04,0x29,0xFE,0x10,0x20,0x10,0x20,0x28,0x20,0x48,0x20,0x0C,0x24,0x15,0xFE,0x14,0x20,0x24,0x20,0x44,0x20,0x04,0x20,0x44,0x22,0x3B,0xFF,0x10,0x00},
{0xA8,0x68,0x00,0x00,0x08,0x60,0x7C,0x40,0x10,0x44,0x10,0x7E,0x10,0x84,0x7C,0x88,0x11,0x08,0x12,0x10,0x10,0x10,0x1C,0x30,0x70,0x28,0x20,0x48,0x00,0x84,0x01,0x04,0x06,0x03},
{0xA8,0x69,0x00,0x00,0x00,0x10,0x7F,0xF8,0x00,0x20,0x06,0x40,0x21,0x84,0x3F,0xFE,0x21,0x04,0x21,0x04,0x3F,0xFC,0x21,0x04,0x21,0x04,0x3F,0xFC,0x21,0x04,0x21,0x1C,0x21,0x08},
{0xA8,0x6A,0x00,0x00,0x01,0xB0,0x01,0x0A,0x7F,0xFF,0x01,0x00,0x21,0x04,0x3F,0xFE,0x21,0x04,0x21,0x04,0x3F,0xFC,0x21,0x04,0x21,0x04,0x3F,0xFC,0x21,0x04,0x21,0x1C,0x21,0x08},
{0xA8,0x6B,0x00,0x00,0x10,0x04,0x1F,0xFE,0x10,0x84,0x1F,0xFC,0x10,0x84,0x1F,0xFC,0x10,0x04,0x01,0x80,0x01,0x02,0x7F,0xFF,0x02,0x02,0x02,0x02,0x04,0x22,0x18,0x1C,0x60,0x08},
{0xA8,0x6C,0x00,0x00,0x0C,0x00,0x08,0x04,0x1F,0xFE,0x10,0x04,0x20,0x04,0x5F,0xC4,0x12,0x44,0x12,0x44,0x1F,0xC4,0x12,0x44,0x12,0x48,0x1F,0xC8,0x00,0x08,0x00,0x78,0x00,0x10},
{0xA8,0x6D,0x00,0x00,0x00,0xC0,0x11,0x04,0x1F,0xFE,0x10,0x04,0x1F,0xFC,0x10,0x04,0x1F,0xFC,0x10,0x04,0x06,0x00,0x04,0x08,0x3F,0xFC,0x04,0x00,0x04,0x02,0x04,0x03,0x03,0xFE},
{0xA8,0x6E,0x00,0x00,0x48,0x02,0x7B,0xFF,0x48,0x20,0x48,0x20,0x78,0x20,0x48,0x20,0x48,0x20,0x78,0x20,0x48,0x20,0x48,0x20,0x48,0x20,0x78,0x20,0x49,0x20,0x40,0xE0,0x00,0x40},
{0xA8,0x6F,0x00,0x00,0x03,0x00,0x02,0x20,0x04,0x18,0x3F,0xEC,0x10,0x04,0x08,0x10,0x0F,0xF8,0x30,0x80,0x00,0x82,0x7F,0xFF,0x01,0x40,0x01,0x20,0x02,0x10,0x0C,0x0C,0x30,0x03},
{0xA8,0x70,0x00,0x00,0x0F,0x00,0x78,0x30,0x08,0x20,0x0A,0x20,0x7F,0x20,0x18,0x20,0x18,0x40,0x2C,0x40,0x2A,0x48,0x4A,0x44,0x08,0x84,0x08,0x9A,0x0B,0xE3,0x09,0x01,0x08,0x00},
{0xA8,0x71,0x00,0x00,0x00,0xFC,0x1F,0x80,0x00,0x82,0x7F,0xFF,0x01,0x80,0x06,0xF0,0x18,0x8F,0x60,0x22,0x0F,0xF0,0x02,0x24,0x02,0x7E,0x04,0x44,0x04,0x04,0x08,0x78,0x30,0x10},
{0xA8,0x72,0x00,0x00,0x00,0xFC,0x1F,0x80,0x00,0x82,0x7F,0xFF,0x01,0x80,0x06,0xF0,0x18,0x8F,0x60,0x02,0x06,0x60,0x04,0x40,0x04,0x40,0x04,0x42,0x08,0x42,0x08,0x43,0x70,0x3E},
{0xA8,0x73,0x00,0x00,0x01,0x80,0x21,0x04,0x3F,0xFE,0x20,0x04,0x4C,0x69,0x08,0x41,0x10,0x3F,0x63,0x00,0x02,0x20,0x3F,0xF0,0x04,0x20,0x04,0x22,0x08,0x22,0x10,0x23,0x60,0x1E},
{0xA8,0x74,0x00,0x00,0x00,0xFC,0x3F,0x80,0x01,0x00,0x02,0x30,0x0E,0x40,0x01,0x80,0x01,0x20,0x02,0x18,0x1F,0xEC,0x08,0x84,0x00,0x80,0x0C,0x90,0x08,0x8C,0x10,0x86,0x20,0x82},
{0xA8,0x75,0x00,0x00,0x20,0x04,0x3F,0xFE,0x20,0x04,0x46,0x68,0x08,0x41,0x70,0x3F,0x00,0x00,0x1F,0xF8,0x01,0x00,0x01,0x04,0x7F,0xFE,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00},
{0xA8,0x76,0x00,0x00,0x00,0xC0,0x0C,0x90,0x18,0x8C,0x10,0x87,0x3F,0xFD,0x50,0x04,0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x04,0x10,0x3C,0x10,0x08},
{0xA8,0x77,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x00,0x20,0x00,0x1F,0xFC,0x00,0x00,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x08,0x38,0x08,0x10},
{0xA8,0x78,0x00,0x00,0x24,0x04,0x3E,0xFE,0x24,0x10,0x24,0x10,0x3C,0x10,0x24,0x10,0x24,0x12,0x25,0xFF,0x3C,0x10,0x24,0x10,0x24,0x10,0x24,0x10,0x44,0x10,0x5C,0x10,0x48,0x10},
{0xA8,0x79,0x00,0x00,0x24,0x06,0x3E,0x04,0x24,0x04,0x24,0x04,0x3D,0xFF,0x24,0x04,0x24,0x84,0x24,0x44,0x3C,0x64,0x24,0x24,0x24,0x04,0x24,0x04,0x44,0x24,0x5C,0x1C,0x48,0x08},
{0xA8,0x7A,0x00,0x00,0x24,0x00,0x3C,0x04,0x25,0xFE,0x24,0x20,0x3C,0x20,0x24,0x20,0x24,0x20,0x24,0x20,0x3C,0x20,0x24,0x20,0x24,0x20,0x24,0x20,0x44,0x22,0x5D,0xFF,0x48,0x00},
{0xA8,0x7B,0x00,0x00,0x24,0x30,0x3E,0x20,0x24,0x20,0x24,0x20,0x3C,0x20,0x24,0x24,0x25,0xFE,0x24,0x20,0x3C,0x20,0x24,0x20,0x24,0x20,0x24,0x20,0x44,0x22,0x5D,0xFF,0x48,0x00},
{0xA8,0x7C,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x02,0x10,0x04,0x0C,0x3F,0xF6,0x00,0x02,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x08,0x38,0x08,0x10},
{0xA8,0x7D,0x00,0x00,0x01,0x80,0x11,0x10,0x1F,0xF8,0x10,0x10,0x10,0x10,0x1F,0xF0,0x10,0x10,0x10,0x10,0x1F,0xF0,0x11,0x06,0x10,0x98,0x10,0x60,0x17,0x18,0x78,0x07,0x20,0x02},
{0xA8,0x7E,0x00,0x00,0x06,0x18,0x04,0x12,0x7F,0xFF,0x04,0x10,0x00,0xC0,0x20,0x84,0x3F,0xFE,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x20,0x00,0x1F,0xFC,0x00,0x00},
{0xA8,0xA1,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x00,0x08,0x1F,0xFC,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xA8,0xA2,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x08,0x04,0x1F,0xFE,0x10,0x04,0x20,0x04,0x40,0x44,0x0F,0xE4,0x00,0x04,0x00,0x04,0x00,0x08,0x00,0xF0,0x00,0x20},
{0xA8,0xA3,0x00,0x00,0x10,0x08,0x1F,0xFC,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08,0x1F,0xF8,0x10,0x08,0x10,0x08,0x1F,0xF8,0x12,0x48,0x02,0x42,0x04,0x42,0x18,0x43,0x60,0x3E},
{0xA8,0xA4,0x00,0x00,0x02,0x00,0x07,0xF0,0x04,0x20,0x08,0x44,0x1F,0xFE,0x70,0x84,0x10,0x84,0x1F,0xFC,0x10,0x84,0x10,0x84,0x1F,0xFC,0x10,0x04,0x20,0x04,0x20,0x3C,0x40,0x08},
{0xA8,0xA5,0x00,0x00,0x00,0x10,0x1F,0xF8,0x00,0x02,0x7F,0xFF,0x00,0x00,0x1F,0xF8,0x00,0x00,0x1F,0xF8,0x00,0x00,0x10,0x08,0x1F,0xFC,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08},
{0xA8,0xA6,0x00,0x00,0x06,0x20,0x0C,0x18,0x08,0x0C,0x11,0x84,0x21,0x40,0x02,0x20,0x04,0x18,0x18,0x07,0x60,0x02,0x0F,0xF8,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x08},
{0xA8,0xA7,0x00,0x00,0x00,0x04,0x3F,0xFE,0x00,0x00,0x10,0x08,0x1F,0xFC,0x10,0x08,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08,0x00,0x00,0x08,0x30,0x06,0x20,0x02,0x42,0x7F,0xFF},
{0xA8,0xA8,0x00,0x00,0x00,0x02,0x7F,0xFF,0x01,0x80,0x03,0x00,0x0C,0x86,0x31,0x84,0x02,0x58,0x0C,0x60,0x30,0xC0,0x03,0x60,0x0C,0x58,0x70,0x47,0x04,0x42,0x03,0x80,0x01,0x00},
{0xA8,0xA9,0x00,0x00,0x10,0x08,0x1F,0xFC,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08,0x06,0x60,0x18,0x1C,0x60,0x04},
{0xA8,0xAA,0x00,0x00,0x00,0xC0,0x00,0x88,0x1F,0xFC,0x00,0x80,0x00,0x82,0x7F,0xFF,0x02,0x20,0x02,0x20,0x1A,0x28,0x12,0x24,0x22,0x26,0x44,0x22,0x04,0x20,0x08,0xE0,0x10,0x40},
{0xA8,0xAB,0x00,0x00,0x00,0xC0,0x00,0x80,0x00,0x88,0x1F,0xFC,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x18,0x88,0x10,0xFC,0x10,0x80,0x2C,0x80,0x23,0x83,0x40,0x7C},
{0xA8,0xAC,0x00,0x00,0x10,0x08,0x1F,0xFC,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x88,0x00,0x80,0x18,0x88,0x10,0xFC,0x10,0x80,0x2C,0x80,0x23,0x83,0x40,0x7C},
{0xA8,0xAD,0x00,0x00,0x00,0xC0,0x09,0x08,0x0F,0xFC,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xFB,0x08,0x0A,0x09,0xFC,0x7E,0x18,0x20,0x68,0x01,0x88,0x0E,0x08,0x70,0x78,0x00,0x10},
{0xA8,0xAE,0x00,0x00,0x00,0xC0,0x00,0x84,0x3F,0xFE,0x00,0x80,0x1F,0xFC,0x10,0x84,0x1F,0xFC,0x10,0x84,0x1F,0xFC,0x10,0x84,0x00,0x80,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA8,0xAF,0x00,0x00,0x00,0xC0,0x00,0x84,0x3F,0xFE,0x00,0x00,0x08,0x18,0x06,0x10,0x02,0x22,0x7F,0xFF,0x00,0x80,0x00,0x84,0x3F,0xFE,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA8,0xB0,0x00,0x00,0x20,0x04,0x3F,0xFE,0x20,0x00,0x20,0x08,0x2F,0xFC,0x20,0x00,0x20,0x02,0x3F,0xFF,0x24,0x40,0x24,0x26,0x24,0x28,0x24,0x10,0x45,0xC8,0x5E,0x07,0x48,0x02},
{0xA8,0xB1,0x00,0x00,0x20,0x04,0x1B,0xFE,0x00,0x20,0x40,0x20,0x30,0x22,0x07,0xFF,0x00,0x20,0x10,0x20,0x78,0x20,0x10,0x20,0x11,0x20,0x10,0xE0,0x18,0x40,0x66,0x03,0x41,0xFC},
{0xA8,0xB2,0x00,0x00,0x20,0x60,0x1B,0x40,0x02,0x48,0x42,0x7C,0x33,0xC8,0x06,0x48,0x02,0x48,0x12,0x58,0x7A,0x4A,0x12,0x02,0x12,0x03,0x11,0xFE,0x18,0x00,0x66,0x03,0x41,0xFC},
{0xA8,0xB3,0x00,0x00,0x40,0x08,0x37,0xFC,0x00,0x88,0x40,0x88,0x30,0x88,0x00,0x88,0x03,0xE8,0x10,0x88,0x78,0x8A,0x11,0x0A,0x11,0x06,0x12,0x02,0x18,0x00,0x66,0x03,0x41,0xFC},
{0xA8,0xB4,0x00,0x00,0x21,0x80,0x19,0x04,0x01,0xFE,0x42,0x00,0x34,0x10,0x01,0xF8,0x00,0x10,0x10,0x20,0x78,0x44,0x10,0x84,0x11,0x06,0x10,0xFC,0x18,0x00,0x66,0x03,0x41,0xFC},
{0xA8,0xB5,0x00,0x00,0x20,0x00,0x19,0xB6,0x01,0x24,0x41,0x24,0x32,0x48,0x02,0x48,0x04,0x90,0x12,0x48,0x79,0x24,0x11,0x24,0x10,0x92,0x10,0x92,0x18,0x00,0x66,0x03,0x41,0xFC},
{0xA8,0xB6,0x00,0x00,0x08,0x20,0x0F,0xF0,0x08,0x20,0x08,0x20,0x0F,0xE0,0x08,0x20,0x20,0x08,0x3F,0xFC,0x21,0x08,0x21,0x08,0x3F,0xF8,0x20,0x0A,0x20,0x02,0x20,0x03,0x1F,0xFE},
{0xA8,0xB7,0x00,0x00,0x01,0x22,0x7F,0xBF,0x12,0x22,0x12,0x22,0x12,0x24,0x12,0x24,0x7F,0xA2,0x12,0x22,0x12,0x21,0x12,0x21,0x12,0x21,0x12,0x2E,0x22,0x24,0x22,0x20,0x42,0x20},
{0xA8,0xB8,0x00,0x00,0x01,0x22,0x7F,0xBF,0x02,0x22,0x32,0x22,0x22,0x24,0x22,0x24,0x7F,0xA2,0x46,0x22,0x0A,0x21,0x0A,0x21,0x12,0x21,0x22,0x2E,0x42,0x24,0x0E,0x20,0x04,0x20},
{0xA8,0xB9,0x00,0x00,0x06,0x22,0x04,0x3F,0x07,0xA2,0x3C,0x22,0x04,0x24,0x05,0x24,0x3F,0xA2,0x04,0x22,0x05,0x21,0x7F,0xA1,0x08,0x21,0x08,0x2E,0x10,0x24,0x10,0x20,0x20,0x20},
{0xA8,0xBA,0x00,0x00,0x02,0x22,0x7F,0x3F,0x12,0x22,0x12,0x22,0x7F,0xA4,0x12,0x24,0x12,0x22,0x12,0x22,0x7F,0xA1,0x12,0x21,0x12,0x21,0x12,0x2E,0x22,0x24,0x2E,0x20,0x44,0x20},
{0xA8,0xBB,0x00,0x00,0x00,0x02,0x7F,0xFF,0x02,0x40,0x22,0x44,0x3F,0xFE,0x22,0x44,0x22,0x54,0x24,0x34,0x28,0x04,0x20,0x04,0x3F,0xFC,0x20,0x04,0x20,0x04,0x3F,0xFC,0x20,0x04},
{0xA8,0xBC,0x00,0x00,0x00,0x18,0x00,0xFC,0x3F,0x80,0x00,0x8C,0x10,0x98,0x0C,0x90,0x04,0xA2,0x7F,0xFF,0x01,0x80,0x02,0xC0,0x04,0xB0,0x18,0x8F,0x60,0x82,0x00,0x80,0x00,0x80},
{0xA8,0xBD,0x00,0x00,0x10,0x04,0x1F,0xFE,0x10,0x84,0x10,0x84,0x1F,0xFC,0x10,0x84,0x10,0x84,0x1F,0xFC,0x10,0x84,0x00,0x80,0x00,0x84,0x3F,0xFE,0x00,0x80,0x00,0x82,0x7F,0xFF},
{0xA8,0xBE,0x00,0x00,0x48,0x30,0x7C,0x20,0x48,0x22,0x4B,0xFF,0x50,0x80,0x50,0x84,0x48,0xFE,0x48,0x84,0x44,0x84,0x44,0x84,0x78,0x84,0x51,0x04,0x41,0x04,0x42,0x38,0x44,0x10},
{0xA8,0xBF,0x00,0x00,0x48,0x04,0x7D,0xFE,0x48,0x00,0x48,0x00,0x50,0x00,0x50,0x02,0x4B,0xFF,0x48,0x48,0x44,0x48,0x44,0x48,0x44,0x48,0x78,0x89,0x50,0x89,0x41,0x09,0x46,0x07},
{0xA8,0xC0,0x00,0x00,0x48,0xCC,0x7C,0x88,0x48,0x88,0x4B,0xFE,0x50,0x88,0x50,0x88,0x48,0x88,0x48,0x8A,0x47,0xFF,0x44,0x88,0x44,0x88,0x78,0x88,0x51,0x08,0x41,0x08,0x42,0x08},
{0xA8,0xC1,0x00,0x00,0x49,0x06,0x7D,0xFF,0x49,0x00,0x49,0x00,0x51,0x04,0x51,0xFE,0x49,0x44,0x49,0x44,0x45,0x28,0x45,0x28,0x45,0x10,0x79,0x10,0x52,0x28,0x42,0x47,0x44,0x82},
{0xA8,0xC2,0x00,0x00,0x48,0x30,0x7C,0x22,0x4B,0xFF,0x48,0x00,0x50,0x00,0x50,0x88,0x48,0xFC,0x48,0x88,0x44,0x88,0x44,0x88,0x44,0x88,0x78,0x89,0x51,0x09,0x41,0x09,0x46,0x07},
{0xA8,0xC3,0x00,0x00,0x10,0x18,0x0C,0x10,0x04,0x24,0x3F,0xFE,0x02,0x40,0x02,0x40,0x22,0x46,0x12,0x44,0x12,0x4C,0x1A,0x48,0x0A,0x48,0x0A,0x50,0x02,0x40,0x02,0x42,0x7F,0xFF},
{0xA8,0xC4,0x00,0x00,0x00,0xFC,0x3F,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x06,0xB0,0x04,0xA0,0x7C,0xA6,0x04,0xB8,0x04,0xA1,0x1C,0xA1,0x64,0x9F,0x44,0x80,0x00,0x80,0x00,0x80},
{0xA8,0xC5,0x00,0x00,0x07,0xB0,0x39,0x20,0x24,0xA0,0x24,0xA0,0x40,0x20,0x3F,0xA0,0x01,0x20,0x06,0x20,0x04,0xA0,0x07,0x20,0x7C,0x22,0x24,0x22,0x04,0x22,0x3C,0x23,0x08,0x1E},
{0xA8,0xC6,0x00,0x00,0x00,0x82,0x7F,0xFF,0x00,0x80,0x0F,0xF8,0x08,0x88,0x0F,0xF8,0x00,0x80,0x1F,0xFC,0x00,0x84,0x7F,0xFF,0x00,0x84,0x1F,0xFC,0x00,0x80,0x07,0x80,0x01,0x00},
{0xA8,0xC7,0x00,0x00,0x06,0x30,0x04,0x20,0x34,0x20,0x25,0x24,0x27,0xBE,0x24,0x20,0x24,0x22,0x27,0xA3,0x78,0x1E,0x20,0x00,0x00,0x08,0x1F,0xFC,0x00,0x00,0x00,0x02,0x7F,0xFF},
{0xA8,0xC8,0x00,0x00,0x00,0x02,0x7F,0xFF,0x02,0x40,0x02,0x40,0x22,0x44,0x3E,0x7E,0x22,0x04,0x20,0x04,0x22,0x44,0x3E,0x7C,0x22,0x44,0x02,0x40,0x02,0x40,0x02,0x42,0x7F,0xFF},
{0xA8,0xC9,0x00,0x00,0x00,0x84,0x3F,0xFE,0x00,0x00,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x00,0x00,0x1F,0xF8,0x00,0x20,0x00,0x42,0x7F,0xFF,0x00,0x80,0x00,0x80,0x07,0x80,0x01,0x00},
{0xA8,0xCA,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x00,0x0F,0xF8,0x08,0x08,0x08,0x08,0x0F,0xF8,0x00,0x80,0x0C,0x90,0x08,0x8C,0x10,0x86,0x60,0x82,0x03,0x80,0x01,0x00},
{0xA8,0xCB,0x00,0x00,0x0D,0x0C,0x08,0xC8,0x08,0x52,0x13,0xFF,0x18,0x20,0x30,0x24,0x53,0xFE,0x10,0x20,0x10,0x22,0x17,0xFF,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20},
{0xA8,0xCC,0x00,0x00,0x0C,0x30,0x08,0x20,0x08,0x22,0x17,0xFF,0x10,0x40,0x30,0xA0,0x50,0xA3,0x11,0x92,0x12,0x94,0x14,0x88,0x10,0x88,0x10,0x84,0x10,0xE4,0x13,0x82,0x11,0x01},
{0xA8,0xCD,0x00,0x00,0x0C,0x30,0x08,0x24,0x0B,0xFE,0x10,0x20,0x10,0x22,0x37,0xFF,0x50,0x00,0x10,0x0A,0x17,0xFF,0x10,0x08,0x12,0x08,0x11,0x88,0x10,0x88,0x10,0x38,0x10,0x10},
{0xA8,0xCE,0x00,0x00,0x0C,0x30,0x08,0x24,0x09,0xFE,0x10,0x20,0x18,0x22,0x33,0xFF,0x50,0x00,0x10,0x30,0x10,0x24,0x13,0xFE,0x10,0x20,0x10,0x20,0x10,0x22,0x17,0xFF,0x10,0x00},
{0xA8,0xCF,0x00,0x00,0x0C,0x30,0x08,0x22,0x0B,0xFF,0x10,0x20,0x1A,0x22,0x33,0xFF,0x52,0x22,0x12,0x22,0x13,0xFE,0x10,0x42,0x13,0x40,0x12,0xC0,0x14,0xA0,0x11,0x18,0x16,0x07},
{0xA8,0xD0,0x00,0x00,0x0C,0x60,0x08,0x40,0x08,0x53,0x13,0xFA,0x18,0x44,0x30,0x48,0x57,0xFF,0x10,0x30,0x10,0xC0,0x13,0x8C,0x1C,0x98,0x10,0xE2,0x10,0x82,0x10,0x83,0x10,0x7E},
{0xA8,0xD1,0x00,0x00,0x0C,0xCC,0x08,0x88,0x08,0x88,0x10,0x88,0x13,0xFE,0x30,0x88,0x50,0x88,0x10,0x88,0x10,0x8A,0x17,0xFF,0x10,0x00,0x10,0xC8,0x10,0x86,0x11,0x03,0x12,0x01},
{0xA8,0xD2,0x00,0x00,0x0C,0x21,0x0B,0xF1,0x09,0x05,0x11,0x15,0x19,0xF5,0x31,0x15,0x51,0x15,0x12,0xA5,0x12,0x65,0x14,0x25,0x10,0x45,0x10,0x41,0x10,0x81,0x11,0x07,0x12,0x02},
{0xA8,0xD3,0x00,0x00,0x00,0xC0,0x00,0x84,0x3F,0xFE,0x00,0x80,0x0C,0x8C,0x08,0x88,0x14,0x94,0x22,0xA2,0x01,0x80,0x02,0xE0,0x04,0x98,0x18,0x87,0x60,0x82,0x00,0x80,0x00,0x80},
{0xA8,0xD4,0x00,0x00,0x0A,0x04,0x0B,0xFE,0x0A,0x04,0x12,0x04,0x12,0x04,0x33,0xFC,0x52,0x04,0x10,0x00,0x13,0x6C,0x12,0x48,0x12,0x48,0x12,0x49,0x12,0x49,0x14,0x49,0x14,0x47},
{0xA8,0xD5,0x00,0x00,0x0C,0x02,0x0B,0xFF,0x08,0x20,0x10,0x20,0x19,0x42,0x31,0xFF,0x51,0x02,0x11,0x02,0x11,0x02,0x11,0xFE,0x11,0x02,0x11,0x02,0x11,0x02,0x11,0xFE,0x11,0x02},
{0xA8,0xD6,0x00,0x00,0x0C,0x63,0x08,0x42,0x08,0x84,0x13,0xDF,0x18,0x84,0x30,0x84,0x50,0xA4,0x10,0xC4,0x13,0x9F,0x12,0x84,0x10,0x84,0x10,0x84,0x11,0x04,0x11,0x04,0x12,0x04},
{0xA8,0xD7,0x00,0x00,0x0C,0x60,0x08,0x44,0x08,0x7E,0x10,0x84,0x1B,0x68,0x30,0x30,0x50,0xC0,0x17,0x22,0x10,0x3F,0x10,0x42,0x11,0xB4,0x10,0x08,0x10,0x30,0x10,0xC0,0x17,0x00},
{0xA8,0xD8,0x00,0x00,0x0A,0x04,0x0B,0xFE,0x0A,0x04,0x12,0x24,0x1B,0xF4,0x32,0x84,0x52,0x94,0x13,0xF4,0x12,0x94,0x12,0x94,0x12,0x95,0x12,0xB5,0x14,0x93,0x14,0x83,0x14,0x81},
{0xA8,0xD9,0x00,0x00,0x0C,0xD8,0x08,0x90,0x08,0x90,0x14,0x96,0x14,0x94,0x32,0x98,0x52,0x90,0x10,0x90,0x11,0x98,0x16,0x96,0x14,0x92,0x11,0x10,0x11,0x11,0x12,0x11,0x14,0x0F},
{0xA8,0xDA,0x00,0x00,0x01,0x80,0x02,0x40,0x04,0x20,0x08,0x10,0x17,0xEC,0x60,0x03,0x00,0x00,0x3F,0xFC,0x22,0x44,0x22,0x44,0x3F,0xFC,0x22,0x44,0x22,0x44,0x22,0x5C,0x20,0x08},
{0xA8,0xDB,0x00,0x00,0x0C,0x30,0x09,0x90,0x09,0x08,0x12,0x08,0x13,0xFC,0x35,0x0B,0x59,0x08,0x11,0xF8,0x11,0x08,0x11,0x08,0x11,0xF8,0x11,0x08,0x12,0x08,0x12,0x38,0x14,0x10},
{0xA8,0xDC,0x00,0x00,0x0C,0x30,0x09,0xA0,0x09,0x24,0x13,0xFE,0x12,0x20,0x34,0x20,0x50,0x22,0x17,0xFF,0x10,0x60,0x10,0xB0,0x10,0xA8,0x11,0x27,0x16,0x22,0x10,0x20,0x10,0x20},
{0xA8,0xDD,0x00,0x00,0x0C,0x60,0x08,0x42,0x0B,0xFF,0x10,0x80,0x19,0x04,0x31,0xFE,0x53,0x04,0x15,0xFC,0x11,0x04,0x11,0x04,0x11,0xFC,0x11,0x04,0x11,0x04,0x11,0x1C,0x11,0x08},
{0xA8,0xDE,0x00,0x00,0x0C,0x20,0x09,0xF0,0x08,0x20,0x10,0x50,0x11,0x8C,0x36,0x03,0x51,0xFC,0x10,0x20,0x10,0x20,0x10,0x24,0x13,0xFE,0x10,0x20,0x10,0x20,0x10,0x22,0x17,0xFF},
{0xA8,0xDF,0x00,0x00,0x06,0x00,0x04,0x40,0x0F,0xE0,0x08,0x40,0x10,0x88,0x7F,0xFC,0x21,0x08,0x21,0x08,0x3F,0xF8,0x22,0x88,0x02,0xA0,0x04,0x9A,0x04,0x8A,0x18,0x83,0x60,0x7E},
{0xA8,0xE0,0x00,0x00,0x26,0x04,0x38,0x7E,0x20,0x04,0x24,0x04,0x3E,0x7C,0x20,0x04,0x20,0x04,0x3F,0xFC,0x24,0x44,0x04,0x40,0x04,0x40,0x08,0x42,0x08,0x42,0x10,0x43,0x60,0x3E},
{0xA8,0xE1,0x00,0x00,0x22,0x44,0x3E,0x7E,0x22,0x44,0x23,0xC4,0x22,0x44,0x20,0x04,0x20,0x04,0x3F,0xFC,0x22,0x44,0x02,0x40,0x02,0x40,0x04,0x42,0x04,0x42,0x18,0x43,0x60,0x3E},
{0xA8,0xE2,0x00,0x00,0x00,0x02,0x7F,0xFF,0x00,0x80,0x20,0x82,0x3F,0xFF,0x20,0x82,0x3C,0xF2,0x24,0x92,0x2C,0xB2,0x2A,0xAA,0x32,0xCA,0x20,0x82,0x20,0x82,0x20,0x9E,0x20,0x04},
{0xA8,0xE3,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x08,0x0A,0x7F,0xFF,0x00,0x00,0x06,0x30,0x08,0x0C,0x30,0x04},
{0xA8,0xE4,0x00,0x00,0x06,0x18,0x04,0x10,0x3F,0xFE,0x04,0x10,0x04,0x10,0x07,0xF0,0x04,0x10,0x07,0xF0,0x04,0x10,0x04,0x12,0x7F,0xFF,0x00,0x00,0x06,0x30,0x08,0x0C,0x30,0x04},
{0xA8,0xE5,0x00,0x00,0x03,0x30,0x02,0x20,0x12,0x24,0x1F,0xFE,0x12,0x24,0x12,0x24,0x1F,0xFC,0x12,0x24,0x12,0x24,0x12,0x24,0x7F,0xFF,0x00,0x00,0x06,0x30,0x08,0x0C,0x30,0x04},
{0xA8,0xE6,0x00,0x00,0x00,0x23,0x4F,0xF2,0x42,0x02,0x22,0x2A,0x2B,0xEA,0x0A,0x2A,0x12,0x2A,0x15,0x4A,0x64,0xCA,0x28,0x4A,0x20,0x8A,0x60,0x82,0x61,0x02,0x22,0x0E,0x04,0x04},
{0xA8,0xE7,0x00,0x00,0x00,0x02,0x7F,0xFF,0x02,0x00,0x02,0x80,0x37,0xC3,0x20,0x82,0x28,0x9A,0x26,0xA2,0x20,0xC2,0x22,0xA2,0x2C,0x9A,0x29,0x8A,0x20,0x02,0x3F,0xFE,0x20,0x02},
{0xA8,0xE8,0x00,0x00,0x06,0x03,0x04,0x9A,0x7F,0xD2,0x08,0x12,0x09,0x92,0x31,0x12,0x12,0x12,0x0A,0xD2,0x04,0x92,0x09,0x12,0x11,0x12,0x62,0x82,0x04,0x82,0x18,0x4E,0x60,0x44},
{0xA8,0xE9,0x00,0x00,0x01,0x80,0x19,0x08,0x11,0x04,0x2F,0xF6,0x42,0x42,0x04,0x20,0x3F,0xFE,0x08,0x10,0x10,0x0C,0x6F,0xF3,0x02,0x10,0x02,0x10,0x04,0x10,0x08,0xE0,0x30,0x40},
{0xA8,0xEA,0x00,0x00,0x20,0x43,0x3F,0xC2,0x20,0x5A,0x20,0x52,0x3F,0xD2,0x22,0x52,0x22,0x12,0x2A,0x52,0x2F,0xD2,0x2A,0x52,0x2A,0x42,0x2B,0xC2,0x4A,0x92,0x42,0x0E,0x42,0x04},
{0xA8,0xEB,0x00,0x00,0x06,0x03,0x04,0x9A,0x7F,0xD2,0x04,0x12,0x24,0x52,0x3F,0xD2,0x24,0x52,0x24,0x52,0x25,0xD2,0x0C,0x92,0x16,0x02,0x15,0x02,0x25,0x92,0x44,0x8E,0x04,0x04},
{0xA8,0xEC,0x00,0x00,0x00,0x83,0x7F,0xC2,0x08,0x1A,0x09,0x12,0x10,0x92,0x7F,0x52,0x24,0x52,0x04,0x12,0x05,0x12,0x3F,0x92,0x04,0x02,0x04,0xC2,0x07,0x12,0x7C,0x0E,0x20,0x04},
{0xA8,0xED,0x00,0x00,0x03,0x03,0x07,0x9A,0x7C,0x12,0x04,0x12,0x04,0x92,0x7F,0xD2,0x04,0x12,0x04,0x12,0x24,0x92,0x3F,0xD2,0x20,0x82,0x20,0x82,0x20,0x92,0x3F,0x8E,0x20,0x84},
{0xA8,0xEE,0x00,0x00,0x06,0x03,0x34,0x02,0x25,0x1A,0x3F,0x92,0x44,0x12,0x04,0x92,0x7F,0xD2,0x04,0x12,0x24,0x92,0x3F,0xD2,0x24,0x82,0x24,0x82,0x27,0x92,0x25,0x0E,0x04,0x04},
{0xA8,0xEF,0x00,0x00,0x11,0x03,0x1F,0x9A,0x11,0x12,0x11,0x12,0x11,0x52,0x20,0xD2,0x46,0x12,0x04,0x92,0x7F,0xD2,0x0C,0x12,0x16,0x02,0x15,0x02,0x24,0xD2,0x44,0x0E,0x04,0x04},
{0xA8,0xF0,0x00,0x00,0x0C,0x18,0x09,0x10,0x7F,0x90,0x10,0x12,0x13,0x7F,0x62,0x12,0x14,0x12,0x09,0x92,0x09,0x12,0x12,0x22,0x62,0x22,0x05,0x22,0x19,0x42,0x60,0x5C,0x00,0x88},
{0xA8,0xF1,0x00,0x00,0x41,0x18,0x7F,0x90,0x40,0x10,0x42,0x12,0x5F,0x7F,0x44,0x12,0x44,0x12,0x5F,0x12,0x44,0x12,0x44,0x22,0x5F,0x22,0x40,0x22,0x7F,0xC2,0x40,0x5C,0x00,0x88},
{0xA8,0xF2,0x00,0x00,0x00,0xC0,0x00,0x84,0x3F,0xFE,0x00,0x00,0x06,0x18,0x04,0x10,0x0B,0x2C,0x31,0x44,0x00,0x00,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA8,0xF3,0x00,0x00,0x18,0x60,0x10,0x44,0x13,0xFE,0x10,0x44,0x7C,0x84,0x13,0x38,0x10,0x00,0x11,0x8C,0x11,0x08,0x17,0xDF,0x12,0x49,0x12,0x49,0x12,0x49,0x14,0x51,0x15,0x96},
{0xA8,0xF4,0x00,0x00,0x00,0xC0,0x00,0x84,0x00,0xFE,0x00,0x80,0x1F,0xFC,0x10,0x04,0x1F,0xFC,0x10,0x04,0x1F,0xFC,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA8,0xF5,0x00,0x00,0x01,0x80,0x12,0x04,0x1F,0xFE,0x10,0x84,0x1F,0xFC,0x10,0x84,0x10,0x84,0x1F,0xFC,0x11,0x04,0x02,0x60,0x04,0x42,0x7F,0xFF,0x00,0x40,0x00,0x40,0x00,0x40},
{0xA8,0xF6,0x00,0x00,0x06,0x18,0x04,0x10,0x3F,0x90,0x04,0x10,0x04,0x90,0x7F,0xD8,0x00,0x14,0x06,0x12,0x04,0x13,0x3F,0x91,0x04,0x10,0x04,0xD0,0x07,0x10,0x78,0x10,0x20,0x10},
{0xA8,0xF7,0x00,0x00,0x01,0x80,0x19,0x08,0x11,0x04,0x2F,0xF6,0x42,0x42,0x04,0x20,0x3F,0xFE,0x08,0x10,0x14,0x2C,0x67,0xF3,0x04,0x20,0x04,0xE4,0x04,0x44,0x04,0x06,0x03,0xFC},
{0xA8,0xF8,0x00,0x00,0x18,0x00,0x11,0x22,0x3F,0xBF,0x44,0x22,0x05,0x22,0x7F,0xA2,0x04,0x22,0x05,0x22,0x37,0xA2,0x24,0x22,0x24,0x22,0x27,0xAE,0x7C,0x24,0x20,0x20,0x00,0x20},
{0xA8,0xF9,0x00,0x00,0x06,0x00,0x04,0x22,0x28,0xBF,0x3F,0xA2,0x2A,0xA2,0x2A,0xA2,0x2A,0xA2,0x2A,0xA2,0x2A,0xA2,0x2A,0xA2,0x2A,0xE2,0x2F,0xAE,0x78,0x24,0x20,0x20,0x00,0x20},
{0xA8,0xFA,0x00,0x00,0x01,0x00,0x7F,0x80,0x22,0x02,0x22,0xFF,0x3E,0x42,0x22,0x42,0x22,0x24,0x3E,0x24,0x22,0x18,0x22,0x10,0x2E,0x28,0x72,0x28,0x22,0x44,0x02,0x83,0x02,0x00},
{0xA8,0xFB,0x00,0x00,0x0C,0x02,0x08,0xFF,0x0A,0x42,0x0F,0x42,0x08,0x42,0x09,0x24,0x7F,0xA4,0x08,0x28,0x2A,0x18,0x2A,0x30,0x49,0x28,0x49,0x28,0x08,0x44,0x38,0x42,0x10,0x81},
{0xA8,0xFC,0x00,0x00,0x00,0xFC,0x3F,0x00,0x11,0x0C,0x0C,0xC8,0x24,0x52,0x3F,0xFF,0x20,0x02,0x40,0x24,0x1F,0xF0,0x04,0x20,0x02,0x40,0x01,0x80,0x02,0xC0,0x0C,0x30,0x30,0x0C},
{0xA8,0xFD,0x00,0x00,0x00,0x30,0x48,0x20,0x7C,0x24,0x49,0xFE,0x48,0x20,0x48,0x22,0x4B,0xFF,0x48,0x20,0x48,0x60,0x78,0xB0,0x48,0xA8,0x41,0x27,0x06,0x22,0x00,0x20,0x00,0x20},
{0xA8,0xFE,0x00,0x00,0x00,0x02,0x03,0xFF,0x48,0x04,0x7C,0x04,0x49,0x14,0x49,0xF4,0x49,0x14,0x49,0x14,0x49,0x14,0x49,0xF4,0x79,0x14,0x48,0x04,0x00,0x04,0x00,0x1C,0x00,0x08},
{0xA9,0x40,0x00,0x00,0x01,0x80,0x01,0x00,0x49,0x09,0x79,0x2F,0x4B,0xE9,0x49,0x29,0x49,0x29,0x49,0x29,0x49,0x29,0x49,0x29,0x79,0x29,0x4A,0x29,0x02,0x29,0x04,0xEF,0x08,0x49},
{0xA9,0x41,0x00,0x00,0x00,0x04,0x4B,0xFE,0x78,0x20,0x48,0x40,0x48,0x40,0x48,0xB0,0x48,0xA4,0x49,0x22,0x49,0x23,0x7A,0x21,0x48,0x20,0x40,0x20,0x00,0x02,0x07,0xFF,0x00,0x00},
{0xA9,0x42,0x00,0x00,0x00,0x30,0x00,0x20,0x48,0x20,0x78,0x22,0x4B,0xFF,0x48,0x20,0x48,0x20,0x49,0x24,0x49,0xFE,0x49,0x04,0x79,0x04,0x49,0x04,0x41,0x04,0x01,0xFC,0x01,0x04},
{0xA9,0x43,0x00,0x00,0x01,0x08,0x49,0xFC,0x7D,0x08,0x49,0x08,0x49,0x08,0x49,0xF8,0x49,0x08,0x49,0x08,0x49,0x08,0x79,0xF8,0x49,0x08,0x41,0x08,0x01,0x0A,0x0F,0xFF,0x00,0x00},
{0xA9,0x44,0x00,0x00,0x00,0x30,0x48,0x20,0x7A,0x22,0x4B,0xFF,0x4A,0x22,0x4A,0x22,0x4B,0xFE,0x4A,0x22,0x4A,0x22,0x7B,0xFE,0x4A,0x22,0x40,0x20,0x00,0x20,0x00,0x20,0x00,0x20},
{0xA9,0x45,0x00,0x00,0x02,0x02,0x4B,0xFF,0x7A,0x22,0x4A,0x22,0x4B,0xFE,0x4A,0x22,0x4A,0x22,0x4A,0x22,0x4B,0xFE,0x7A,0x22,0x48,0x20,0x40,0x20,0x00,0x20,0x00,0x20,0x00,0x20},
{0xA9,0x46,0x00,0x00,0x00,0x30,0x00,0x20,0x49,0xA6,0x7D,0x24,0x49,0x24,0x49,0x24,0x49,0xFC,0x49,0x24,0x48,0x20,0x4B,0x23,0x7A,0x22,0x4A,0x22,0x42,0x22,0x03,0xFE,0x02,0x02},
{0xA9,0x47,0x00,0x00,0x22,0x44,0x3F,0x7E,0x22,0x44,0x22,0x44,0x3E,0x7C,0x22,0x44,0x00,0x00,0x04,0x20,0x07,0xF0,0x04,0x20,0x04,0x20,0x08,0x22,0x08,0x22,0x10,0x23,0x60,0x1E},
{0xA9,0x48,0x00,0x00,0x01,0x80,0x49,0x04,0x79,0xFE,0x4A,0x04,0x4A,0x04,0x4D,0xF4,0x49,0x14,0x49,0x14,0x49,0xF4,0x79,0x04,0x49,0x38,0x41,0x12,0x01,0x02,0x01,0x03,0x00,0xFE},
{0xA9,0x49,0x00,0x00,0x00,0x0C,0x48,0x3E,0x7B,0xE0,0x48,0x26,0x4A,0x24,0x49,0xA8,0x48,0xA8,0x48,0x22,0x4B,0xFF,0x78,0x20,0x48,0x20,0x40,0x20,0x01,0x20,0x00,0xE0,0x00,0x40},
{0xA9,0x4A,0x00,0x00,0x00,0xC6,0x48,0x84,0x7C,0x84,0x49,0x04,0x49,0x7F,0x4B,0x04,0x4D,0x04,0x49,0x44,0x49,0x24,0x79,0x34,0x49,0x14,0x01,0x04,0x01,0x04,0x01,0x1C,0x01,0x08},
{0xA9,0x4B,0x00,0x00,0x00,0x0C,0x4A,0x7E,0x7B,0xC8,0x4A,0x48,0x4A,0x48,0x4A,0x48,0x4A,0x48,0x4A,0x48,0x7A,0x48,0x4A,0x44,0x42,0x44,0x04,0x52,0x04,0xEA,0x04,0x4A,0x08,0x01},
{0xA9,0x4C,0x00,0x00,0x03,0x00,0x52,0x02,0x7A,0x3F,0x52,0x12,0x57,0xD2,0x52,0x52,0x52,0x52,0x52,0x52,0x54,0x54,0x74,0x8C,0x52,0x88,0x41,0x08,0x02,0x94,0x02,0x94,0x04,0x23},
{0xA9,0x4D,0x00,0x00,0x06,0x00,0x0F,0x00,0x78,0x42,0x08,0x7F,0x0A,0x42,0x7F,0x42,0x18,0x42,0x18,0x42,0x2C,0x42,0x2B,0x42,0x49,0x42,0x08,0x42,0x08,0x7E,0x08,0x42,0x08,0x00},
{0xA9,0x4E,0x00,0x00,0x00,0xC0,0x48,0x84,0x7C,0xFE,0x49,0x84,0x4A,0x88,0x48,0x50,0x48,0x60,0x49,0x98,0x4E,0x07,0x78,0xC0,0x48,0x20,0x40,0x0C,0x00,0x70,0x03,0x80,0x01,0x00},
{0xA9,0x4F,0x00,0x00,0x02,0x04,0x4B,0xFE,0x7A,0x04,0x4A,0x04,0x4B,0xFC,0x4A,0x04,0x4A,0x60,0x4A,0x40,0x4A,0x46,0x7A,0x58,0x4A,0x60,0x42,0x42,0x04,0x42,0x04,0x43,0x08,0x3E},
{0xA9,0x50,0x00,0x00,0x08,0x02,0x0F,0xFF,0x08,0x02,0x08,0x42,0x09,0xF2,0x08,0x42,0x0B,0xFA,0x08,0x02,0x09,0xF2,0x09,0x12,0x09,0x12,0x11,0xF2,0x10,0x02,0x10,0x1E,0x20,0x04},
{0xA9,0x51,0x00,0x00,0x01,0x80,0x49,0x02,0x79,0xFF,0x4A,0x40,0x4A,0x40,0x4C,0x44,0x48,0x7E,0x48,0x40,0x48,0x40,0x78,0x44,0x48,0x7E,0x40,0x40,0x00,0x40,0x00,0x40,0x00,0x40},
{0xA9,0x52,0x00,0x00,0x01,0x80,0x03,0x40,0x04,0x30,0x18,0x0C,0x67,0xF3,0x00,0x00,0x22,0x44,0x3F,0x7E,0x22,0x44,0x22,0x44,0x22,0x44,0x3E,0x5C,0x22,0x48,0x00,0x40,0x00,0x40},
{0xA9,0x53,0x00,0x00,0x18,0x0C,0x11,0x08,0x1F,0x88,0x11,0x14,0x31,0x14,0x4A,0x22,0x06,0x42,0x19,0x80,0x60,0x7F,0x00,0x00,0x1F,0xF8,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08},
{0xA9,0x54,0x00,0x00,0x20,0x02,0x3F,0xFF,0x20,0x02,0x20,0xC2,0x20,0x92,0x2F,0xFA,0x20,0x82,0x20,0x82,0x27,0xF2,0x24,0x12,0x27,0xF2,0x24,0x12,0x20,0x02,0x3F,0xFE,0x20,0x02},
{0xA9,0x55,0x00,0x00,0x18,0x30,0x10,0x20,0x10,0x22,0x13,0xFF,0x10,0x00,0x7D,0x06,0x11,0x04,0x10,0x84,0x10,0x88,0x14,0x88,0x18,0x90,0x70,0x10,0x20,0x22,0x07,0xFF,0x00,0x00},
{0xA9,0x56,0x00,0x00,0x18,0x02,0x13,0xFF,0x10,0x04,0x10,0x04,0x7D,0x24,0x11,0xF4,0x11,0x24,0x11,0x24,0x15,0x24,0x19,0xE4,0x71,0x24,0x20,0x04,0x00,0x04,0x00,0x1C,0x00,0x08},
{0xA9,0x57,0x00,0x00,0x18,0x04,0x13,0xFE,0x10,0x20,0x11,0xA8,0x7D,0x24,0x11,0x26,0x12,0x22,0x10,0x20,0x17,0xFF,0x10,0x20,0x1C,0x20,0x70,0x20,0x20,0x20,0x00,0x20,0x00,0x20},
{0xA9,0x58,0x00,0x00,0x18,0xC6,0x10,0x84,0x10,0x84,0x13,0xFF,0x7C,0x84,0x10,0x84,0x10,0x84,0x10,0x84,0x10,0xFC,0x14,0x84,0x18,0x84,0x70,0x84,0x20,0x84,0x00,0xFC,0x00,0x84},
{0xA9,0x59,0x00,0x00,0x18,0x18,0x10,0x10,0x11,0x12,0x11,0xFF,0x7D,0x12,0x11,0x14,0x11,0x10,0x11,0xFE,0x15,0x42,0x19,0x24,0x72,0x28,0x22,0x10,0x04,0x28,0x04,0x44,0x09,0x83},
{0xA9,0x5A,0x00,0x00,0x19,0x04,0x11,0xFE,0x11,0x04,0x11,0x04,0x7D,0x04,0x11,0xFC,0x11,0x04,0x11,0x04,0x15,0x04,0x19,0xFC,0x71,0x04,0x20,0x00,0x00,0x02,0x07,0xFF,0x00,0x00},
{0xA9,0x5B,0x00,0x00,0x18,0x18,0x10,0x10,0x11,0x11,0x11,0xFF,0x7D,0x11,0x11,0x11,0x11,0xFF,0x11,0x11,0x15,0x11,0x19,0xFF,0x71,0x11,0x20,0x10,0x00,0x10,0x00,0x10,0x00,0x10},
{0xA9,0x5C,0x00,0x00,0x18,0x0C,0x11,0x1E,0x11,0xE0,0x11,0x00,0x7D,0x02,0x11,0xFF,0x11,0x10,0x11,0x10,0x15,0x50,0x19,0x30,0x72,0x1C,0x22,0x16,0x04,0x12,0x04,0x10,0x08,0x10},
{0xA9,0x5D,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x00,0x0C,0xC0,0x08,0x88,0x10,0xFC,0x11,0x08,0x31,0x90,0x52,0x50,0x15,0x20,0x10,0xC0,0x10,0xB0,0x11,0x0F,0x16,0x02},
{0xA9,0x5E,0x00,0x00,0x01,0x80,0x01,0x00,0x3F,0xFE,0x01,0x00,0x1F,0xFC,0x02,0x20,0x7F,0xFF,0x04,0x10,0x08,0x88,0x17,0xF4,0x60,0x83,0x00,0x80,0x1F,0xFC,0x00,0x80,0x00,0x80},
{0xA9,0x5F,0x00,0x00,0x01,0x80,0x01,0x04,0x3F,0xFE,0x02,0x40,0x04,0x38,0x18,0x08,0x00,0x02,0x7F,0xFF,0x00,0x08,0x1F,0x88,0x10,0x88,0x10,0x88,0x1F,0x88,0x00,0x38,0x00,0x10},
{0xA9,0x60,0x00,0x00,0x01,0x80,0x01,0x02,0x7F,0xFF,0x04,0x20,0x08,0x10,0x17,0xEC,0x60,0x03,0x00,0x08,0x3F,0xFC,0x00,0x80,0x0C,0x90,0x08,0x88,0x10,0x8C,0x23,0x84,0x01,0x00},
{0xA9,0x61,0x00,0x00,0x01,0x80,0x01,0x02,0x7F,0xFF,0x04,0x20,0x09,0x90,0x11,0x0C,0x7F,0xFB,0x11,0x08,0x1F,0xF8,0x11,0x08,0x1F,0xF8,0x11,0x0A,0x01,0x02,0x01,0x03,0x00,0xFE},
{0xA9,0x62,0x00,0x00,0x01,0x80,0x01,0x02,0x7F,0xFF,0x02,0x20,0x04,0x90,0x18,0x8C,0x63,0xE3,0x00,0x80,0x06,0x98,0x04,0x12,0x7F,0xFF,0x04,0x10,0x08,0x10,0x08,0x10,0x10,0x10},
{0xA9,0x63,0x00,0x00,0x00,0xC0,0x00,0x84,0x3F,0xFE,0x08,0x18,0x06,0x10,0x02,0x22,0x7F,0xFF,0x00,0x00,0x02,0x02,0x7F,0xFF,0x04,0x10,0x0C,0x20,0x03,0xC0,0x0C,0x3C,0x70,0x04},
{0xA9,0x64,0x00,0x00,0x00,0x84,0x3F,0xFE,0x00,0x80,0x0F,0xF8,0x00,0x8A,0x7F,0xFF,0x00,0x88,0x0F,0xF8,0x01,0x00,0x3F,0xFE,0x02,0x10,0x0E,0x20,0x01,0xC0,0x06,0x3C,0x38,0x04},
{0xA9,0x65,0x00,0x00,0x00,0xFC,0x3F,0x80,0x00,0x82,0x7F,0xFF,0x02,0xC0,0x0C,0xB8,0x70,0x87,0x03,0x00,0x02,0x02,0x7F,0xFF,0x04,0x10,0x1C,0x20,0x03,0xC0,0x06,0x3C,0x38,0x04},
{0xA9,0x66,0x00,0x00,0x18,0x18,0x10,0x10,0x12,0x14,0x7E,0xFE,0x12,0x10,0x12,0x10,0x22,0xFF,0x24,0x30,0x64,0x58,0x58,0x54,0x08,0x94,0x14,0x92,0x25,0x11,0x40,0x10,0x00,0x10},
{0xA9,0x67,0x00,0x00,0x18,0x82,0x10,0xFF,0x12,0x82,0x7E,0x82,0x12,0xFE,0x12,0x82,0x22,0xB0,0x24,0xA0,0x64,0xA6,0x58,0xAC,0x08,0xB0,0x15,0x22,0x15,0x22,0x21,0x23,0x42,0x1E},
{0xA9,0x68,0x00,0x00,0x18,0x18,0x10,0x10,0x10,0x10,0x12,0x12,0x7E,0xFF,0x12,0x10,0x12,0x10,0x22,0x10,0x24,0x92,0x54,0xFF,0x08,0x82,0x14,0x82,0x12,0x82,0x22,0xFE,0x40,0x82},
{0xA9,0x69,0x00,0x00,0x18,0x84,0x10,0xFE,0x12,0x84,0x7E,0xA4,0x12,0x94,0x12,0x84,0x23,0xFF,0x24,0x84,0x64,0xA4,0x59,0x14,0x09,0x04,0x15,0xFF,0x15,0x04,0x20,0x38,0x40,0x10},
{0xA9,0x6A,0x00,0x00,0x18,0x84,0x10,0xFE,0x12,0x84,0x7E,0x84,0x12,0x84,0x12,0xFC,0x22,0x84,0x24,0x84,0x64,0x84,0x58,0xFC,0x08,0x84,0x14,0x84,0x14,0x84,0x23,0xFF,0x40,0x00},
{0xA9,0x6B,0x00,0x00,0x31,0x04,0x21,0xFE,0x25,0x54,0x7D,0x54,0x25,0x54,0x25,0x54,0x25,0x54,0x4B,0xFF,0x69,0x54,0x51,0x54,0x11,0x54,0x29,0x54,0x29,0x54,0x21,0x0C,0x41,0x04},
{0xA9,0x6C,0x00,0x00,0x18,0x30,0x10,0x20,0x12,0x20,0x7E,0x48,0x12,0x46,0x13,0xFB,0x22,0x81,0x24,0x00,0x64,0x82,0x58,0xFF,0x08,0x82,0x14,0x82,0x12,0x82,0x22,0xFE,0x40,0x82},
{0xA9,0x6D,0x00,0x00,0x18,0x18,0x10,0xD0,0x12,0x90,0x7E,0x94,0x12,0xFE,0x12,0x90,0x22,0x90,0x25,0x10,0x64,0x14,0x54,0xFE,0x08,0x10,0x14,0x10,0x14,0x10,0x20,0x12,0x41,0xFF},
{0xA9,0x6E,0x00,0x00,0x18,0x18,0x10,0x10,0x12,0x9E,0x7E,0xF0,0x12,0x90,0x12,0x90,0x22,0x92,0x25,0xFF,0x65,0x32,0x58,0x52,0x08,0x52,0x14,0x9E,0x24,0x94,0x41,0x10,0x00,0x10},
{0xA9,0x6F,0x00,0x00,0x18,0x18,0x10,0x10,0x10,0x10,0x12,0x92,0x7E,0xFF,0x12,0x92,0x12,0x92,0x22,0x92,0x24,0xFE,0x64,0x92,0x58,0x92,0x08,0x92,0x14,0x92,0x24,0xFE,0x40,0x82},
{0xA9,0x70,0x00,0x00,0x18,0x60,0x10,0x40,0x12,0x42,0x7E,0x7F,0x12,0x92,0x13,0x14,0x22,0x10,0x24,0x54,0x64,0x54,0x58,0x92,0x08,0x92,0x15,0x12,0x24,0x10,0x40,0x70,0x00,0x20},
{0xA9,0x71,0x00,0x00,0x18,0x06,0x10,0xC4,0x12,0x84,0x7E,0x84,0x12,0xA4,0x12,0xA4,0x22,0x94,0x24,0x94,0x64,0x84,0x58,0xA8,0x08,0xC8,0x15,0x94,0x14,0x92,0x24,0x23,0x40,0xC1},
{0xA9,0x72,0x00,0x00,0x18,0x18,0x10,0x10,0x12,0xD4,0x7E,0x92,0x12,0x93,0x13,0x11,0x22,0xFE,0x24,0x10,0x64,0x10,0x58,0x12,0x09,0xFF,0x14,0x10,0x12,0x10,0x22,0x10,0x40,0x10},
{0xA9,0x73,0x00,0x00,0x00,0x10,0x1F,0xF8,0x00,0x20,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x03,0x80,0x11,0x08,0x1F,0xFC,0x12,0x48,0x12,0x48,0x12,0x4A,0x7F,0xFF},
{0xA9,0x74,0x00,0x00,0x02,0x0C,0x7E,0x9E,0x02,0xE4,0x0C,0xA4,0x08,0xA4,0x0A,0xA4,0x0C,0xA4,0x18,0xA4,0x68,0xA4,0x48,0xA4,0x09,0x24,0x09,0x32,0x09,0x6A,0x39,0x29,0x12,0x01},
{0xA9,0x75,0x00,0x00,0x00,0xFC,0x3F,0x80,0x00,0x82,0x7F,0xFF,0x01,0x80,0x0E,0xF0,0x70,0x8F,0x07,0xF0,0x00,0x20,0x00,0x42,0x7F,0xFF,0x00,0x80,0x00,0x80,0x07,0x80,0x01,0x00},
{0xA9,0x76,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x40,0x14,0x1F,0xF8,0x00,0x00,0x00,0x02,0x7F,0xFF,0x00,0x80,0x0C,0x90,0x08,0x8C,0x10,0x86,0x63,0x82,0x01,0x00},
{0xA9,0x77,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x40,0x04,0x1F,0xFC,0x00,0x80,0x00,0x80,0x18,0x88,0x10,0xFC,0x10,0x80,0x10,0x80,0x28,0x80,0x26,0x83,0x41,0xFC},
{0xA9,0x78,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x4F,0xF4,0x08,0x10,0x08,0x10,0x0F,0xF0,0x08,0x10,0x08,0x00,0x0F,0xF8,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x08},
{0xA9,0x79,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x48,0x14,0x0F,0xF8,0x08,0x10,0x08,0x10,0x0F,0xF0,0x08,0x10,0x08,0x10,0x0F,0xF0,0x08,0x10,0x08,0x14,0x7F,0xFE},
{0xA9,0x7A,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x40,0xC4,0x00,0x80,0x10,0x84,0x1F,0xFE,0x10,0x84,0x10,0x84,0x1F,0xFC,0x10,0x84,0x10,0x84,0x1F,0xFC,0x10,0x04},
{0xA9,0x7B,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x4C,0x04,0x09,0x40,0x1F,0x7E,0x11,0x44,0x11,0x44,0x2A,0x44,0x4A,0x5C,0x04,0x48,0x08,0x42,0x10,0x43,0x60,0x3E},
{0xA9,0x7C,0x00,0x00,0x00,0xC0,0x0C,0x90,0x18,0x8C,0x20,0x86,0x40,0x83,0x3F,0xFD,0x20,0x04,0x20,0x04,0x27,0xE4,0x24,0x24,0x24,0x24,0x27,0xE4,0x20,0x04,0x20,0x1C,0x20,0x08},
{0xA9,0x7D,0x00,0x00,0x20,0x04,0x3F,0xFE,0x20,0x04,0x20,0x04,0x3F,0xFC,0x20,0x04,0x20,0x60,0x26,0x46,0x24,0x44,0x27,0xFC,0x20,0x40,0x2C,0x43,0x48,0x42,0x4F,0xFE,0x48,0x02},
{0xA9,0x7E,0x00,0x00,0x20,0x04,0x3F,0xFE,0x20,0x04,0x20,0x04,0x3F,0xFC,0x20,0x44,0x20,0x40,0x2F,0xFF,0x20,0x40,0x24,0x44,0x27,0xFE,0x24,0x04,0x44,0x04,0x47,0xFC,0x44,0x04},
{0xA9,0xA1,0x00,0x00,0x20,0x04,0x3F,0xFE,0x20,0x04,0x20,0x04,0x3F,0xFC,0x20,0x04,0x20,0x60,0x2C,0x43,0x2B,0xFA,0x28,0x42,0x28,0x42,0x29,0xF2,0x48,0x02,0x4F,0xFE,0x48,0x02},
{0xA9,0xA2,0x00,0x00,0x19,0x02,0x11,0xFF,0x55,0x02,0x55,0x02,0x55,0xFE,0x55,0x12,0x55,0x10,0x55,0x12,0x55,0xFF,0x55,0x10,0x7D,0x09,0x45,0x09,0x01,0x65,0x07,0x83,0x02,0x01},
{0xA9,0xA3,0x00,0x00,0x20,0x02,0x3F,0xFF,0x20,0x02,0x26,0x1A,0x21,0x22,0x2F,0xFA,0x20,0x02,0x20,0xC2,0x26,0x9A,0x24,0x92,0x24,0x92,0x27,0xF2,0x24,0x12,0x20,0x0E,0x20,0x04},
{0xA9,0xA4,0x00,0x00,0x18,0xC6,0x10,0x84,0x1F,0xFC,0x10,0x04,0x00,0x00,0x3F,0xFE,0x20,0x00,0x27,0xFC,0x20,0x40,0x20,0x42,0x2F,0xFF,0x20,0x40,0x40,0x40,0x40,0x40,0x40,0x40},
{0xA9,0xA5,0x00,0x00,0x00,0xC0,0x18,0x86,0x10,0x84,0x1F,0xFC,0x10,0x04,0x00,0x00,0x7F,0xFF,0x02,0x00,0x04,0x04,0x0F,0xFE,0x18,0x04,0x68,0x04,0x08,0x04,0x0F,0xFC,0x08,0x04},
{0xA9,0xA6,0x00,0x00,0x00,0x30,0x18,0x20,0x10,0x20,0x11,0x22,0x55,0xFF,0x55,0x22,0x55,0x22,0x55,0x22,0x55,0xFE,0x55,0x22,0x55,0x22,0x7D,0x22,0x45,0x22,0x01,0xFE,0x01,0x02},
{0xA9,0xA7,0x00,0x00,0x0C,0xC8,0x08,0x86,0x10,0x80,0x30,0x7F,0x57,0xC0,0x10,0x21,0x10,0x19,0x10,0x07,0x00,0xC0,0x18,0x86,0x10,0x84,0x10,0x84,0x10,0x84,0x1F,0xFC,0x10,0x04},
{0xA9,0xA8,0x00,0x00,0x10,0x7C,0x1F,0x80,0x10,0x00,0x10,0x08,0x1F,0xFC,0x10,0x40,0x10,0x42,0x7F,0xFF,0x00,0x00,0x00,0xC0,0x30,0x86,0x20,0x84,0x20,0x84,0x3F,0xFC,0x20,0x04},
{0xA9,0xA9,0x00,0x00,0x01,0x80,0x21,0x04,0x3F,0xFE,0x42,0x44,0x0C,0x49,0x70,0x3F,0x01,0x80,0x11,0x08,0x1F,0xFC,0x11,0x08,0x11,0x08,0x11,0x08,0x11,0x38,0x11,0x10,0x01,0x00},
{0xA9,0xAA,0x00,0x00,0x0F,0xF8,0x00,0x0A,0x7F,0xFF,0x00,0x08,0x0F,0xF8,0x20,0x02,0x3F,0xFF,0x40,0x02,0x40,0x84,0x1F,0xFC,0x10,0x84,0x10,0x84,0x10,0x9C,0x10,0x88,0x00,0x80},
{0xA9,0xAB,0x00,0x00,0x18,0x18,0x10,0x10,0x52,0x10,0x7F,0x12,0x52,0x1F,0x52,0x10,0x52,0x10,0x52,0x92,0x52,0xFF,0x52,0x82,0x5E,0x82,0x54,0x82,0x10,0x82,0x10,0xFE,0x10,0x82},
{0xA9,0xAC,0x00,0x00,0x18,0x18,0x10,0x10,0x52,0xA2,0x7E,0xFF,0x52,0x82,0x52,0x82,0x52,0x82,0x52,0x82,0x52,0xFE,0x52,0x82,0x5E,0x82,0x54,0x82,0x10,0x82,0x10,0xFE,0x10,0x82},
{0xA9,0xAD,0x00,0x00,0x00,0xC0,0x09,0x08,0x0F,0xFC,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x88,0x20,0x82,0x3F,0xFF,0x20,0x82,0x20,0x82,0x20,0x8E,0x20,0x84,0x00,0x80},
{0xA9,0xAE,0x00,0x00,0x0C,0x00,0x09,0x02,0x7F,0x7F,0x11,0x22,0x12,0x14,0x2C,0x08,0x0A,0x34,0x12,0xC3,0x60,0x80,0x0F,0xFC,0x08,0x84,0x08,0x84,0x08,0x9C,0x08,0x88,0x00,0x80},
{0xA9,0xAF,0x00,0x00,0x00,0xC0,0x00,0x88,0x1F,0xFC,0x00,0x80,0x00,0x82,0x7F,0xFF,0x04,0x10,0x02,0x20,0x0F,0xF8,0x00,0x80,0x00,0x84,0x3F,0xFE,0x00,0x80,0x00,0x80,0x00,0x80},
{0xA9,0xB0,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x00,0x20,0x80,0x2F,0xFC,0x20,0x84,0x3F,0xFF,0x20,0x84,0x2F,0xFC,0x21,0x40,0x21,0x20,0x42,0x10,0x44,0x0C,0x58,0x03},
{0xA9,0xB1,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x00,0x20,0xC0,0x20,0x84,0x20,0xFE,0x20,0x80,0x24,0x84,0x27,0xFE,0x24,0x04,0x24,0x04,0x44,0x04,0x47,0xFC,0x44,0x04},
{0xA9,0xB2,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x00,0x23,0x06,0x22,0x04,0x24,0xFF,0x2C,0x04,0x34,0x84,0x24,0x64,0x24,0x24,0x24,0x04,0x44,0x04,0x44,0x1C,0x44,0x08},
{0xA9,0xB3,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x00,0x24,0x3E,0x27,0xE0,0x24,0x20,0x24,0x22,0x27,0xFF,0x24,0x10,0x24,0x10,0x25,0xC9,0x4E,0x05,0x40,0x23,0x4F,0xF1},
{0xA9,0xB4,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x00,0x24,0x08,0x27,0xFC,0x28,0x08,0x37,0xC8,0x24,0x48,0x24,0x48,0x27,0xC8,0x24,0x32,0x44,0x02,0x44,0x03,0x43,0xFE},
{0xA9,0xB5,0x00,0x00,0x08,0x0C,0x7C,0x1E,0x09,0xF0,0x10,0x10,0x10,0x10,0x24,0xD4,0x7E,0x9E,0x24,0x90,0x04,0x90,0x34,0x90,0x28,0x92,0x48,0x7F,0x14,0x00,0x23,0x03,0x40,0xFC},
{0xA9,0xB6,0x00,0x00,0x04,0x18,0x7E,0x10,0x04,0x12,0x25,0xFF,0x3C,0x30,0x24,0x20,0x20,0x46,0x44,0xC4,0x7E,0x28,0x44,0x10,0x04,0x30,0x04,0x24,0x44,0x42,0x39,0xFD,0x10,0x81},
{0xA9,0xB7,0x00,0x00,0x04,0x0C,0x7E,0x9E,0x04,0xE4,0x24,0xA4,0x3C,0xA4,0x24,0xA4,0x20,0xA4,0x44,0xA4,0x7E,0xA4,0x44,0xA4,0x05,0x24,0x05,0x32,0x45,0x6A,0x3A,0x29,0x12,0x01},
{0xA9,0xB8,0x00,0x00,0x08,0x02,0x7F,0x7F,0x11,0x22,0x12,0x14,0x2C,0x08,0x0A,0x14,0x11,0x63,0x6F,0xF8,0x00,0x08,0x0F,0xF8,0x08,0x00,0x1F,0xFC,0x10,0x04,0x00,0x08,0x00,0xF0},
{0xA9,0xB9,0x00,0x00,0x18,0x40,0x10,0x30,0x20,0x12,0x2B,0xFF,0x48,0x20,0x10,0x20,0x10,0x20,0x30,0x24,0x53,0xFE,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x22,0x17,0xFF,0x10,0x00},
{0xA9,0xBA,0x00,0x00,0x18,0x04,0x13,0xFE,0x20,0x20,0x2C,0x20,0x48,0x20,0x13,0x20,0x12,0x24,0x32,0x3E,0x52,0x20,0x12,0x20,0x12,0x20,0x12,0x20,0x12,0x22,0x17,0xFF,0x10,0x00},
{0xA9,0xBB,0x00,0x00,0x18,0x90,0x10,0x94,0x23,0xFE,0x28,0x94,0x4A,0x94,0x13,0xFC,0x12,0x94,0x32,0x92,0x57,0xFF,0x14,0x92,0x10,0x92,0x10,0x9E,0x11,0x14,0x11,0x10,0x12,0x10},
{0xA9,0xBC,0x00,0x00,0x18,0x18,0x10,0x10,0x21,0x12,0x2D,0xFF,0x49,0x12,0x11,0x14,0x11,0x10,0x31,0xFE,0x51,0x42,0x11,0x24,0x11,0x28,0x12,0x10,0x12,0x28,0x12,0x44,0x14,0x83},
{0xA9,0xBD,0x00,0x00,0x00,0xFC,0x1F,0x80,0x00,0x80,0x01,0x02,0x7F,0xFF,0x02,0x20,0x04,0x18,0x19,0x84,0x61,0x03,0x0D,0x48,0x09,0x24,0x11,0x12,0x21,0x12,0x07,0x00,0x02,0x00},
{0xA9,0xBE,0x00,0x00,0x00,0xC0,0x10,0x84,0x1F,0xFE,0x10,0x84,0x10,0x84,0x1F,0xFC,0x10,0x84,0x00,0x80,0x01,0x00,0x04,0x80,0x24,0xC4,0x24,0x52,0x44,0x13,0x44,0x19,0x03,0xF0},
{0xA9,0xBF,0x00,0x00,0x0C,0x00,0x08,0x04,0x0F,0xFE,0x11,0x24,0x62,0x24,0x0C,0x44,0x31,0x84,0x06,0x38,0x00,0x90,0x06,0x80,0x24,0x44,0x24,0x52,0x44,0x13,0x44,0x19,0x03,0xF0},
{0xA9,0xC0,0x00,0x00,0x01,0x80,0x01,0x40,0x02,0x20,0x04,0x18,0x1B,0xE7,0x60,0x02,0x0F,0xF8,0x00,0x08,0x00,0x10,0x05,0x20,0x14,0xC4,0x24,0x52,0x24,0x13,0x44,0x19,0x03,0xF0},
{0xA9,0xC1,0x00,0x00,0x06,0xE0,0x04,0x20,0x08,0x10,0x10,0x0C,0x6F,0xF3,0x02,0x10,0x02,0x10,0x04,0x70,0x18,0x20,0x01,0x00,0x04,0xC4,0x24,0x52,0x24,0x13,0x44,0x19,0x03,0xF0},
{0xA9,0xC2,0x00,0x00,0x18,0x30,0x10,0x20,0x11,0x24,0x19,0xFE,0x55,0x24,0x55,0x24,0x51,0x24,0x11,0x24,0x17,0xFF,0x10,0x20,0x10,0x50,0x10,0x48,0x10,0x88,0x11,0x04,0x12,0x03},
{0xA9,0xC3,0x00,0x00,0x18,0x04,0x13,0xFE,0x10,0x20,0x18,0x20,0x54,0x20,0x54,0x20,0x51,0xA4,0x11,0x3E,0x11,0x20,0x11,0x20,0x11,0x20,0x11,0x20,0x11,0x22,0x17,0xFF,0x10,0x00},
{0xA9,0xC4,0x00,0x00,0x18,0x30,0x10,0x20,0x10,0x24,0x19,0xFE,0x54,0x20,0x54,0x20,0x50,0x22,0x13,0xFF,0x10,0x40,0x10,0x40,0x10,0x88,0x10,0x84,0x11,0x3A,0x17,0xC3,0x12,0x01},
{0xA9,0xC5,0x00,0x00,0x18,0x34,0x10,0x23,0x10,0x20,0x1B,0xFF,0x54,0x20,0x54,0x20,0x51,0xAC,0x11,0x28,0x11,0x28,0x11,0x29,0x11,0x29,0x12,0x29,0x12,0x29,0x14,0x27,0x10,0x20},
{0xA9,0xC6,0x00,0x00,0x18,0x60,0x10,0x42,0x13,0xFF,0x18,0x40,0x54,0x98,0x54,0x92,0x51,0xFF,0x12,0x92,0x14,0x92,0x10,0x92,0x10,0x92,0x10,0x9E,0x10,0x94,0x10,0x10,0x10,0x10},
{0xA9,0xC7,0x00,0x00,0x18,0x04,0x13,0xFE,0x11,0x04,0x18,0x88,0x54,0x50,0x54,0x30,0x50,0xCC,0x13,0x03,0x10,0x30,0x10,0x24,0x13,0xFE,0x10,0x20,0x10,0x20,0x10,0x22,0x17,0xFF},
{0xA9,0xC8,0x00,0x00,0x18,0x18,0x10,0x10,0x11,0x22,0x19,0xFF,0x55,0x02,0x55,0x02,0x51,0x02,0x11,0x02,0x11,0xFE,0x11,0x02,0x11,0x02,0x11,0x02,0x11,0x02,0x11,0xFE,0x11,0x02},
{0xA9,0xC9,0x00,0x00,0x18,0x30,0x10,0x20,0x18,0x20,0x54,0x48,0x54,0x44,0x50,0x9A,0x13,0xE3,0x11,0x01,0x10,0x82,0x10,0xFF,0x10,0x82,0x10,0x82,0x10,0x82,0x10,0xFE,0x10,0x82},
{0xA9,0xCA,0x00,0x00,0x18,0x18,0x10,0xD0,0x10,0x90,0x18,0x94,0x54,0xFE,0x55,0x10,0x51,0x10,0x12,0x10,0x10,0x14,0x10,0xFE,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x12,0x13,0xFF},
{0xA9,0xCB,0x00,0x00,0x19,0x02,0x11,0xFF,0x11,0x02,0x19,0x02,0x55,0xFE,0x55,0x02,0x51,0x30,0x11,0x20,0x11,0x26,0x11,0x38,0x11,0x20,0x12,0x22,0x12,0x22,0x12,0x23,0x14,0x1E},
{0xA9,0xCC,0x00,0x00,0x18,0x50,0x10,0x54,0x13,0xFE,0x18,0x54,0x55,0x54,0x55,0xFC,0x51,0x54,0x11,0x52,0x13,0xFF,0x12,0x52,0x10,0x52,0x10,0x5E,0x10,0x94,0x10,0x90,0x11,0x10},
{0xA9,0xCD,0x00,0x00,0x18,0x00,0x11,0x04,0x11,0xFE,0x19,0x04,0x55,0x04,0x55,0x04,0x51,0xFC,0x11,0x04,0x11,0x04,0x11,0x04,0x11,0xFC,0x11,0x04,0x10,0x00,0x10,0x02,0x17,0xFF},
{0xA9,0xCE,0x00,0x00,0x00,0x68,0x00,0x46,0x00,0x40,0x7F,0xFF,0x00,0x40,0x00,0x40,0x3F,0x26,0x21,0x24,0x21,0x28,0x3F,0x10,0x00,0x11,0x07,0xA9,0x78,0x25,0x20,0x43,0x01,0x81},
{0xA9,0xCF,0x00,0x00,0x06,0x34,0x34,0x22,0x24,0x22,0x24,0x20,0x3C,0x3F,0x25,0xE0,0x04,0x26,0x04,0x24,0x7C,0x28,0x24,0x10,0x24,0x11,0x24,0x29,0x44,0x25,0x44,0x43,0x04,0x81},
{0xA9,0xD0,0x00,0x00,0x10,0x7C,0x1F,0x80,0x10,0x04,0x1F,0xFE,0x10,0x04,0x1F,0xFC,0x10,0x00,0x10,0x42,0x1F,0xFF,0x11,0x00,0x11,0xFC,0x21,0x04,0x22,0x04,0x22,0x78,0x44,0x20},
{0xA9,0xD1,0x00,0x00,0x10,0x7C,0x1F,0x80,0x10,0x04,0x1F,0xFE,0x10,0x04,0x10,0x04,0x1F,0xFC,0x10,0x00,0x10,0x64,0x10,0x42,0x1F,0xFF,0x20,0x40,0x20,0xA0,0x23,0x18,0x4C,0x07},
{0xA9,0xD2,0x00,0x00,0x27,0x4E,0x38,0x70,0x20,0x40,0x21,0x40,0x3F,0x42,0x21,0x7F,0x21,0x44,0x21,0x44,0x3F,0x44,0x21,0x44,0x20,0x44,0x20,0x84,0x40,0x84,0x40,0x84,0x41,0x04},
{0xA9,0xD3,0x00,0x00,0x00,0x10,0x1F,0xF8,0x00,0x10,0x00,0x20,0x08,0xC3,0x7C,0x82,0x0B,0xEA,0x08,0x8C,0x0B,0xE8,0x10,0x84,0x17,0xF4,0x20,0x82,0x40,0x82,0x03,0x81,0x01,0x00},
{0xA9,0xD4,0x00,0x00,0x18,0x18,0x10,0x10,0x10,0x12,0x7D,0xFF,0x10,0x00,0x10,0x86,0x14,0x84,0x18,0x44,0x70,0x48,0x50,0x48,0x10,0x48,0x10,0x10,0x10,0x12,0x73,0xFF,0x20,0x00},
{0xA9,0xD5,0x00,0x00,0x18,0x18,0x10,0x10,0x14,0xD4,0x7E,0x92,0x10,0x93,0x11,0x11,0x14,0xFE,0x18,0x10,0x70,0x10,0x50,0x12,0x11,0xFF,0x10,0x10,0x10,0x10,0x70,0x10,0x20,0x10},
{0xA9,0xD6,0x00,0x00,0x18,0x40,0x10,0x20,0x10,0x04,0x7D,0xFE,0x10,0x20,0x10,0x20,0x14,0x20,0x18,0x24,0x71,0xFE,0x50,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x70,0x22,0x23,0xFF},
{0xA9,0xD7,0x00,0x00,0x19,0x02,0x11,0xFF,0x11,0x02,0x7D,0x02,0x11,0xFE,0x11,0x12,0x15,0x10,0x19,0x12,0x71,0xFF,0x51,0x10,0x11,0x08,0x11,0x09,0x11,0x65,0x77,0x83,0x22,0x01},
{0xA9,0xD8,0x00,0x00,0x18,0x50,0x10,0x54,0x13,0xFE,0x7C,0x54,0x11,0x54,0x11,0xFC,0x15,0x54,0x19,0x52,0x73,0xFF,0x52,0x52,0x10,0x52,0x10,0x5E,0x10,0x94,0x70,0x90,0x21,0x10},
{0xA9,0xD9,0x00,0x00,0x18,0x18,0x10,0x10,0x10,0x12,0x7D,0xFF,0x10,0x10,0x10,0x10,0x14,0x14,0x18,0xFE,0x70,0x30,0x50,0x58,0x10,0x54,0x10,0x94,0x10,0x92,0x71,0x11,0x20,0x10},
{0xA9,0xDA,0x00,0x00,0x19,0x04,0x11,0xFE,0x11,0x00,0x7D,0x00,0x11,0x04,0x11,0xFE,0x15,0x04,0x19,0x04,0x71,0x04,0x51,0xFC,0x11,0x04,0x11,0x00,0x11,0x02,0x71,0xFF,0x21,0x00},
{0xA9,0xDB,0x00,0x00,0x18,0x02,0x11,0xFF,0x14,0x42,0x7E,0x42,0x10,0x42,0x10,0x82,0x14,0x9C,0x19,0x08,0x70,0x82,0x50,0xFF,0x10,0x82,0x10,0x82,0x10,0x82,0x70,0xFE,0x20,0x82},
{0xA9,0xDC,0x00,0x00,0x18,0x18,0x10,0x10,0x11,0x12,0x7D,0xFF,0x11,0x12,0x11,0x14,0x15,0x10,0x19,0xFE,0x71,0x42,0x51,0x24,0x11,0x28,0x12,0x10,0x12,0x28,0x72,0x24,0x24,0xC3},
{0xA9,0xDD,0x00,0x00,0x18,0x00,0x10,0x02,0x13,0xFF,0x7C,0x40,0x10,0x40,0x10,0x40,0x14,0x82,0x18,0xFF,0x71,0x82,0x52,0x82,0x14,0x82,0x10,0x82,0x10,0x82,0x70,0xFE,0x20,0x82},
{0xA9,0xDE,0x00,0x00,0x18,0x68,0x10,0x46,0x10,0x40,0x7D,0xFF,0x10,0x40,0x10,0x46,0x14,0x84,0x18,0xC4,0x70,0xA8,0x51,0x28,0x11,0x10,0x12,0x18,0x12,0x28,0x74,0x44,0x21,0x83},
{0xA9,0xDF,0x00,0x00,0x19,0x80,0x11,0x18,0x11,0x10,0x7D,0x10,0x11,0x3E,0x17,0xD2,0x12,0x12,0x1A,0xD2,0x72,0x92,0x52,0x92,0x12,0x92,0x12,0xA2,0x12,0xAD,0x74,0x81,0x24,0x7F},
{0xA9,0xE0,0x00,0x00,0x18,0x30,0x10,0x20,0x14,0x20,0x7E,0x22,0x10,0x3F,0x10,0x20,0x14,0x20,0x19,0x22,0x71,0xFF,0x51,0x02,0x11,0x02,0x11,0x02,0x11,0x02,0x71,0xFE,0x21,0x02},
{0xA9,0xE1,0x00,0x00,0x18,0x04,0x10,0xFE,0x10,0x20,0x7C,0xA8,0x10,0xA4,0x11,0x26,0x15,0x22,0x18,0x20,0x73,0xFF,0x50,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x70,0x20,0x20,0x20},
{0xA9,0xE2,0x00,0x00,0x18,0x18,0x10,0x10,0x10,0x10,0x7D,0x11,0x11,0xFF,0x11,0x11,0x15,0x11,0x19,0x11,0x71,0xFF,0x51,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x71,0xFF,0x21,0x01},
{0xA9,0xE3,0x00,0x00,0x19,0x02,0x11,0xFF,0x11,0x22,0x7D,0x22,0x11,0xFE,0x11,0x22,0x15,0x22,0x19,0x22,0x71,0xFE,0x51,0x22,0x10,0x20,0x10,0x20,0x10,0x20,0x70,0x20,0x20,0x20},
{0xA9,0xE4,0x00,0x00,0x19,0x04,0x11,0xFE,0x11,0x04,0x7D,0x04,0x11,0x04,0x11,0xFC,0x15,0x04,0x18,0x02,0x73,0xFF,0x50,0x42,0x10,0x42,0x10,0x82,0x10,0x82,0x71,0x3C,0x22,0x08},
{0xA9,0xE5,0x00,0x00,0x18,0x30,0x10,0x20,0x11,0xA6,0x7D,0x24,0x11,0x24,0x11,0x24,0x15,0xFC,0x19,0x24,0x70,0x20,0x53,0x23,0x12,0x22,0x12,0x22,0x12,0x22,0x73,0xFE,0x22,0x02},
{0xA9,0xE6,0x00,0x00,0x19,0x04,0x11,0xFE,0x11,0x04,0x7D,0x44,0x11,0x34,0x11,0x04,0x17,0xFF,0x15,0x04,0x19,0x44,0x71,0x34,0x52,0x04,0x13,0xFF,0x12,0x08,0x70,0x78,0x20,0x10},
{0xA9,0xE7,0x00,0x00,0x18,0x18,0x10,0x10,0x11,0x22,0x7D,0xFF,0x11,0x02,0x11,0x02,0x15,0x02,0x19,0x02,0x71,0xFE,0x51,0x02,0x11,0x02,0x11,0x02,0x11,0x02,0x71,0xFE,0x21,0x02},
{0xA9,0xE8,0x00,0x00,0x18,0x0C,0x11,0x1E,0x11,0xF0,0x7D,0x10,0x11,0x14,0x11,0xFE,0x15,0x10,0x19,0x10,0x71,0x08,0x51,0x69,0x17,0x85,0x12,0x03,0x10,0x09,0x77,0xFC,0x20,0x00},
{0xA9,0xE9,0x00,0x00,0x18,0x30,0x10,0x20,0x10,0x48,0x7C,0x86,0x13,0xFB,0x11,0x01,0x14,0x00,0x18,0xCC,0x70,0x88,0x57,0xFF,0x10,0x88,0x10,0x88,0x11,0x08,0x71,0x08,0x22,0x08},
{0xA9,0xEA,0x00,0x00,0x18,0xC0,0x10,0x84,0x11,0xFE,0x7D,0x04,0x12,0x04,0x15,0xE4,0x11,0x24,0x15,0x24,0x19,0xE4,0x71,0x04,0x51,0x38,0x11,0x12,0x11,0x02,0x71,0x03,0x20,0xFE},
{0xA9,0xEB,0x00,0x00,0x18,0xC0,0x10,0x82,0x10,0xFF,0x7D,0x82,0x11,0x02,0x12,0x02,0x10,0xFA,0x14,0x8A,0x18,0x8A,0x70,0xFA,0x50,0x02,0x10,0x02,0x10,0x04,0x70,0x38,0x20,0x10},
{0xA9,0xEC,0x00,0x00,0x18,0xC0,0x10,0x82,0x11,0xFF,0x7D,0x00,0x12,0x18,0x10,0xD2,0x14,0x9F,0x18,0xF2,0x71,0x92,0x50,0x96,0x10,0x92,0x10,0x90,0x10,0x81,0x70,0x81,0x20,0x7F},
{0xA9,0xED,0x00,0x00,0x18,0xCC,0x10,0x88,0x10,0x89,0x7C,0x9F,0x11,0x29,0x13,0x29,0x10,0xC9,0x14,0x49,0x18,0x89,0x70,0x89,0x51,0x29,0x13,0xD1,0x11,0x11,0x70,0x27,0x20,0x42},
{0xA9,0xEE,0x00,0x00,0x18,0x0C,0x10,0x9E,0x14,0xE0,0x7E,0x80,0x10,0x82,0x10,0xFF,0x14,0x88,0x18,0x88,0x70,0xA8,0x50,0x98,0x10,0x8E,0x11,0x0B,0x11,0x09,0x71,0x08,0x22,0x08},
{0xA9,0xEF,0x00,0x00,0x18,0x30,0x10,0x20,0x14,0x20,0x7E,0x48,0x10,0x44,0x10,0x9A,0x11,0xE3,0x1C,0x81,0x70,0x00,0x50,0xFE,0x10,0x82,0x10,0x82,0x10,0x82,0x70,0xFE,0x20,0x82},
{0xA9,0xF0,0x00,0x00,0x18,0x30,0x10,0x28,0x10,0x48,0x7C,0x44,0x10,0x82,0x13,0x7D,0x10,0x00,0x14,0x02,0x19,0xFF,0x70,0x22,0x50,0x22,0x10,0x2E,0x10,0x24,0x70,0x20,0x20,0x20},
{0xA9,0xF1,0x00,0x00,0x0C,0x30,0x08,0x20,0x0A,0x20,0x7F,0x22,0x20,0x3F,0x22,0x42,0x3E,0x42,0x22,0xA4,0x22,0x24,0x22,0x14,0x22,0x18,0x22,0x28,0x42,0x24,0x5C,0x44,0x49,0x83},
{0xA9,0xF2,0x00,0x00,0x0C,0x30,0x10,0x0E,0x66,0x32,0x09,0xC0,0x03,0x30,0x0C,0x0C,0x70,0xF3,0x0F,0x00,0x08,0x04,0x0F,0xFE,0x08,0x40,0x08,0x40,0x10,0x40,0x10,0x40,0x20,0x40},
{0xA9,0xF3,0x00,0x00,0x0C,0x10,0x08,0x30,0x0A,0x28,0x7F,0x48,0x20,0x44,0x20,0x84,0x3E,0xA2,0x23,0x11,0x22,0x18,0x22,0x08,0x22,0x00,0x22,0x20,0x42,0x10,0x5C,0x18,0x48,0x08},
{0xA9,0xF4,0x00,0x00,0x00,0x04,0x4B,0xFE,0x78,0x20,0x48,0x20,0x48,0x20,0x48,0x20,0x78,0x24,0x4B,0xFE,0x48,0x20,0x48,0x20,0x78,0x20,0x48,0x20,0x40,0x22,0x07,0xFF,0x00,0x00},
{0xA9,0xF5,0x00,0x00,0x03,0x30,0x02,0x20,0x02,0x24,0x3F,0xFE,0x02,0x20,0x02,0x22,0x7F,0xFF,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08},
{0xA9,0xF6,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x0A,0x08,0x02,0x02,0x07,0xFF,0x08,0x92,0x31,0x22,0x06,0x22,0x18,0x42,0x01,0x9C,0x06,0x08},
{0xA9,0xF7,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x20,0x02,0x3F,0xFF,0x20,0x02,0x3F,0xFE,0x20,0x02,0x20,0x02,0x3F,0xFE,0x20,0x02},
{0xA9,0xF8,0x00,0x00,0x10,0x08,0x1F,0xFC,0x10,0x08,0x1F,0xF8,0x10,0x08,0x1F,0xF8,0x10,0x08,0x00,0x00,0x18,0x60,0x12,0x4C,0x1F,0x50,0x10,0x62,0x17,0x42,0x78,0x43,0x20,0x3E},
{0xA9,0xF9,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x23,0x42,0x3C,0x7F,0x20,0x42,0x20,0x42,0x27,0x42,0x78,0x5E,0x20,0x44,0x00,0x40},
{0xA9,0xFA,0x00,0x00,0x22,0x42,0x3F,0x7F,0x22,0x42,0x22,0x42,0x22,0x7E,0x3E,0x42,0x22,0x42,0x22,0x42,0x22,0x7E,0x3E,0x42,0x22,0x42,0x00,0x82,0x00,0x92,0x01,0x0E,0x02,0x04},
{0xA9,0xFB,0x00,0x00,0x00,0xC0,0x48,0x80,0x7D,0x02,0x49,0xFF,0x4A,0x02,0x4C,0x12,0x79,0xFA,0x48,0x02,0x48,0x12,0x49,0xFA,0x78,0x02,0x48,0x04,0x40,0x04,0x00,0x78,0x00,0x10},
{0xA9,0xFC,0x00,0x00,0x10,0x7C,0x1F,0xC0,0x10,0x40,0x10,0x44,0x1F,0xFE,0x10,0x20,0x13,0x91,0x7C,0x09,0x20,0x05,0x0F,0xFB,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08},
{0xA9,0xFD,0x00,0x00,0x00,0x0C,0x49,0x1E,0x7D,0xE0,0x49,0x00,0x49,0x00,0x49,0x02,0x79,0xFF,0x49,0x08,0x49,0x08,0x49,0x08,0x79,0x08,0x4A,0x08,0x42,0x08,0x02,0x08,0x04,0x08},
{0xA9,0xFE,0x00,0x00,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x00,0x02,0x7F,0xFF,0x00,0x80,0x00,0x84,0x3F,0xFE,0x01,0x40,0x02,0x20,0x0C,0x18,0x70,0x07},
{0xAA,0x40,0x00,0x00,0x1F,0xF8,0x10,0x08,0x1F,0xF8,0x10,0x08,0x1F,0xF8,0x10,0x08,0x03,0x80,0x3C,0x30,0x04,0x20,0x04,0x22,0x7F,0xFF,0x04,0x20,0x08,0x20,0x08,0x20,0x30,0x20},
{0xAA,0x41,0x00,0x00,0x25,0x04,0x3D,0xFE,0x25,0x04,0x25,0x04,0x3D,0x3C,0x25,0x08,0x25,0x02,0x25,0xFF,0x3D,0x42,0x25,0x24,0x25,0x28,0x25,0x18,0x45,0x14,0x5D,0x24,0x49,0x43},
{0xAA,0x42,0x00,0x00,0x11,0x22,0x1F,0xBF,0x11,0x22,0x11,0x22,0x1F,0x3E,0x11,0x22,0x11,0x22,0x11,0x22,0x1F,0x3E,0x11,0x22,0x11,0x22,0x21,0x22,0x21,0x42,0x27,0x4E,0x42,0x44},
{0xAA,0x43,0x00,0x00,0x18,0x30,0x10,0x20,0x10,0x22,0x7D,0xFF,0x10,0x00,0x30,0x00,0x30,0x88,0x58,0xFC,0x54,0x88,0x54,0x88,0x10,0x88,0x10,0x89,0x11,0x09,0x11,0x09,0x12,0x07},
{0xAA,0x44,0x00,0x00,0x18,0x18,0x10,0x10,0x10,0x12,0x7D,0xFF,0x10,0x40,0x30,0x44,0x30,0x7E,0x58,0x44,0x54,0x44,0x54,0x44,0x10,0x84,0x10,0x84,0x10,0x84,0x11,0x38,0x12,0x10},
{0xAA,0x45,0x00,0x00,0x18,0x30,0x10,0x20,0x11,0x22,0x7D,0xFF,0x11,0x22,0x32,0x24,0x30,0x20,0x58,0x40,0x54,0x58,0x54,0x50,0x10,0x52,0x10,0x92,0x10,0x92,0x11,0x13,0x16,0x0E},
{0xAA,0x46,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x80,0x1F,0xFC,0x10,0x84,0x1F,0xFC,0x10,0x84,0x1F,0xFC,0x01,0x80,0x02,0xE0,0x04,0x98,0x18,0x87,0x60,0x82,0x00,0x80},
{0xAA,0x47,0x00,0x00,0x10,0x04,0x1F,0xFE,0x10,0x84,0x1F,0xFC,0x10,0x84,0x1F,0xFC,0x10,0x84,0x00,0x80,0x7F,0xFF,0x01,0x80,0x02,0xE0,0x04,0x98,0x18,0x87,0x60,0x82,0x00,0x80},
{0xAA,0x48,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x01,0x80,0x02,0xE0,0x04,0x98,0x18,0x87,0x60,0x82,0x08,0x08,0x0F,0xFC,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08},
{0xAA,0x49,0x00,0x00,0x18,0x00,0x11,0x04,0x11,0xFE,0x7D,0x24,0x11,0x24,0x31,0x24,0x31,0x24,0x59,0xFC,0x55,0x04,0x55,0x00,0x11,0x00,0x11,0x02,0x11,0x02,0x11,0x03,0x10,0xFE},
{0xAA,0x4A,0x00,0x00,0x19,0x8C,0x11,0x08,0x11,0x08,0x7D,0x08,0x11,0x08,0x31,0x4A,0x31,0xEF,0x59,0x08,0x55,0x08,0x55,0x08,0x11,0x08,0x11,0x29,0x11,0xC9,0x17,0x09,0x12,0x07},
{0xAA,0x4B,0x00,0x00,0x18,0x30,0x10,0x22,0x13,0xFF,0x7C,0x20,0x10,0x20,0x30,0x24,0x33,0xFE,0x58,0x84,0x54,0x88,0x54,0x48,0x10,0x50,0x10,0x20,0x10,0x50,0x10,0x8C,0x13,0x03},
{0xAA,0x4C,0x00,0x00,0x0C,0x18,0x08,0x10,0x0A,0x12,0x7F,0x7F,0x08,0x10,0x18,0x30,0x18,0x58,0x2C,0x54,0x2A,0x54,0x4A,0x92,0x08,0x91,0x09,0x10,0x08,0x10,0x08,0x10,0x08,0x10},
{0xAA,0x4D,0x00,0x00,0x0C,0x02,0x09,0xFF,0x08,0x10,0x7F,0x10,0x18,0x20,0x18,0x38,0x2C,0x50,0x2A,0x54,0x2A,0x92,0x48,0x93,0x09,0x11,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10},
{0xAA,0x4E,0x00,0x00,0x00,0xC0,0x00,0x82,0x3F,0xFF,0x01,0x80,0x02,0xC0,0x02,0xA0,0x04,0x98,0x08,0x87,0x30,0x82,0x00,0x80,0x00,0x00,0x12,0x22,0x12,0x22,0x21,0x11,0x21,0x11},
{0xAA,0x4F,0x00,0x00,0x0C,0x82,0x08,0xFF,0x08,0x80,0x7E,0x80,0x18,0x82,0x18,0xFF,0x2C,0xA2,0x2A,0xA2,0x2A,0x92,0x48,0x94,0x08,0x88,0x09,0x14,0x09,0x14,0x09,0x22,0x0A,0x41},
{0xAA,0x50,0x00,0x00,0x18,0x04,0x13,0xFE,0x10,0x20,0x7C,0x20,0x10,0x20,0x30,0x20,0x30,0x24,0x59,0xFE,0x54,0x20,0x54,0x20,0x10,0x20,0x10,0x20,0x10,0x22,0x13,0xFF,0x10,0x00},
{0xAA,0x51,0x00,0x00,0x18,0x10,0x10,0x78,0x10,0x10,0x7C,0xC8,0x10,0x88,0x30,0x84,0x39,0x34,0x55,0x22,0x55,0x21,0x52,0x40,0x10,0x48,0x10,0x44,0x10,0x9A,0x13,0xE3,0x11,0x01},
{0xAA,0x52,0x00,0x00,0x0C,0x04,0x08,0x8E,0x08,0xF0,0x7E,0x80,0x08,0x80,0x18,0x82,0x18,0xFF,0x2C,0x88,0x2A,0x88,0x4A,0x88,0x08,0x88,0x09,0x08,0x09,0x08,0x09,0x08,0x0A,0x08},
{0xAA,0x53,0x00,0x00,0x0C,0xC0,0x08,0x80,0x08,0x84,0x7E,0xFE,0x08,0x90,0x19,0x10,0x19,0x10,0x28,0x12,0x2D,0xFF,0x4A,0x10,0x0A,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10},
{0xAA,0x54,0x00,0x00,0x0C,0x60,0x08,0x40,0x08,0x42,0x7E,0x7F,0x08,0x84,0x18,0xC4,0x19,0x44,0x2C,0x28,0x2A,0x28,0x4A,0x10,0x08,0x28,0x08,0x28,0x08,0x44,0x08,0x84,0x09,0x03},
{0xAA,0x55,0x00,0x00,0x0C,0x0C,0x08,0x88,0x08,0x68,0x7E,0x28,0x08,0x08,0x18,0x88,0x1C,0x68,0x2A,0x2A,0x2A,0x0F,0x48,0x38,0x09,0xC8,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08},
{0xAA,0x56,0x00,0x00,0x0C,0x04,0x09,0xFE,0x08,0x04,0x7E,0x68,0x08,0x10,0x18,0x02,0x19,0xFF,0x2C,0x12,0x2A,0x14,0x4A,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0xF0,0x08,0x20},
{0xAA,0x57,0x00,0x00,0x0C,0x18,0x08,0x10,0x08,0x10,0x7E,0x54,0x08,0x52,0x18,0x93,0x19,0x11,0x2C,0x10,0x2A,0x73,0x4A,0x22,0x08,0x04,0x08,0x08,0x08,0x30,0x08,0xC0,0x0B,0x00},
{0xAA,0x58,0x00,0x00,0x10,0x08,0x1F,0xFC,0x10,0x08,0x1F,0xF8,0x10,0x08,0x1F,0xF8,0x10,0x08,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x01,0x80,0x06,0xE0,0x18,0x98,0x60,0x87,0x00,0x80},
{0xAA,0x59,0x00,0x00,0x02,0x30,0x27,0x20,0x38,0x21,0x20,0x3F,0x22,0x41,0x3F,0x5A,0x24,0x90,0x24,0x10,0x24,0x10,0x24,0x28,0x24,0x28,0x24,0x48,0x44,0x44,0x44,0x84,0x45,0x03},
{0xAA,0x5A,0x00,0x00,0x02,0x34,0x3F,0x22,0x00,0x22,0x00,0x20,0x7F,0xFF,0x00,0x20,0x06,0x20,0x34,0x20,0x25,0x20,0x27,0x90,0x24,0x12,0x24,0x0A,0x27,0xCA,0x7C,0x07,0x20,0x02},
{0xAA,0x5B,0x00,0x00,0x06,0x18,0x04,0x12,0x05,0xFF,0x34,0x10,0x27,0x90,0x24,0x12,0x24,0xFF,0x24,0x42,0x24,0x44,0x24,0x24,0x25,0xA8,0x2E,0x10,0x70,0x28,0x20,0x44,0x01,0x83},
{0xAA,0x5C,0x00,0x00,0x01,0x22,0x7F,0xBF,0x10,0x22,0x12,0x22,0x1F,0x42,0x12,0x4C,0x22,0x00,0x3A,0xFF,0x44,0x42,0x04,0x24,0x08,0x24,0x08,0x18,0x10,0x28,0x10,0x44,0x21,0x83},
{0xAA,0x5D,0x00,0x00,0x0C,0x82,0x08,0xFF,0x48,0x82,0x7E,0x82,0x40,0xFE,0x40,0x8A,0x40,0x88,0x40,0xFF,0x40,0x88,0x40,0x88,0x40,0x89,0x3C,0xA5,0x00,0xC5,0x03,0x83,0x01,0x01},
{0xAA,0x5E,0x00,0x00,0x10,0x00,0x1F,0xFC,0x10,0x00,0x27,0xF0,0x40,0x00,0x3F,0xF8,0x00,0x08,0x0D,0x88,0x10,0x68,0x6F,0xD9,0x04,0x49,0x04,0x45,0x08,0x45,0x13,0x83,0x21,0x01},
{0xAA,0x5F,0x00,0x00,0x20,0x60,0x10,0x40,0x10,0x44,0x07,0xFE,0x40,0x00,0x25,0x0C,0x29,0x08,0x09,0x08,0x10,0x90,0x10,0x90,0x60,0x90,0x20,0xA0,0x20,0x22,0x6F,0xFF,0x20,0x00},
{0xAA,0x60,0x00,0x00,0x20,0x80,0x10,0x60,0x10,0x22,0x07,0xFF,0x40,0x20,0x24,0x20,0x28,0x20,0x08,0x24,0x13,0xFE,0x10,0x20,0x60,0x20,0x20,0x20,0x20,0x22,0x67,0xFF,0x20,0x00},
{0xAA,0x61,0x00,0x00,0x21,0x80,0x10,0x60,0x10,0x00,0x41,0xE0,0x24,0x20,0x20,0x23,0x0B,0xA2,0x08,0xB4,0x10,0xA8,0x11,0x28,0x61,0x24,0x22,0x24,0x24,0x23,0x60,0xE0,0x20,0x40},
{0xAA,0x62,0x00,0x00,0x20,0x30,0x10,0x20,0x12,0x22,0x43,0xFF,0x22,0x02,0x24,0xC4,0x08,0x80,0x10,0x8C,0x10,0xB0,0x60,0xC0,0x20,0x80,0x20,0x82,0x60,0x82,0x60,0x83,0x20,0x7E},
{0xAA,0x63,0x00,0x00,0x20,0x40,0x10,0x36,0x10,0x14,0x02,0xC4,0x44,0x88,0x24,0x88,0x28,0x90,0x0A,0x94,0x12,0xA2,0x14,0xC1,0x64,0x89,0x21,0x88,0x22,0x88,0x2C,0x8C,0x00,0x78},
{0xAA,0x64,0x00,0x00,0x22,0x04,0x13,0xFE,0x12,0x04,0x02,0x04,0x43,0xFC,0x26,0x04,0x2A,0xC0,0x0A,0x80,0x12,0x8C,0x12,0x90,0x62,0xE0,0x24,0x82,0x24,0x82,0x64,0x83,0x28,0x7E},
{0xAA,0x65,0x00,0x00,0x20,0x02,0x17,0xFF,0x10,0x04,0x40,0x04,0x22,0x24,0x2B,0xF4,0x0A,0x24,0x12,0x24,0x12,0x24,0x63,0xE4,0x22,0x24,0x20,0x04,0x60,0x24,0x20,0x1C,0x00,0x08},
{0xAA,0x66,0x00,0x00,0x20,0x30,0x10,0x20,0x10,0x22,0x07,0xFF,0x40,0x20,0x24,0x20,0x28,0x20,0x0A,0x24,0x13,0xFE,0x12,0x04,0x62,0x04,0x22,0x04,0x22,0x04,0x63,0xFC,0x22,0x04},
{0xAA,0x67,0x00,0x00,0x20,0x60,0x10,0x40,0x12,0x40,0x44,0x42,0x24,0x7F,0x28,0x40,0x08,0x40,0x12,0x42,0x13,0xFF,0x62,0x02,0x22,0x02,0x22,0x02,0x62,0x02,0x63,0xFE,0x22,0x02},
{0xAA,0x68,0x00,0x00,0x20,0x02,0x17,0xFF,0x10,0x42,0x40,0x42,0x24,0x82,0x28,0x82,0x09,0x1C,0x12,0x08,0x10,0x02,0x63,0xFF,0x22,0x02,0x22,0x02,0x62,0x02,0x63,0xFE,0x22,0x02},
{0xAA,0x69,0x00,0x00,0x20,0x30,0x12,0x22,0x13,0xFF,0x42,0x22,0x26,0x24,0x2A,0x20,0x0B,0xFE,0x12,0x84,0x12,0x84,0x62,0x48,0x22,0x50,0x24,0x30,0x64,0x50,0x68,0x8C,0x23,0x03},
{0xAA,0x6A,0x00,0x00,0x20,0x30,0x10,0x20,0x10,0x22,0x47,0xFF,0x20,0x20,0x28,0x24,0x0B,0xFE,0x10,0x60,0x10,0xB0,0x60,0xA8,0x21,0x28,0x21,0x24,0x66,0x23,0x20,0x20,0x00,0x20},
{0xAA,0x6B,0x00,0x00,0x20,0x30,0x10,0x20,0x10,0x24,0x43,0xFE,0x24,0x20,0x28,0x20,0x08,0x22,0x17,0xFF,0x10,0x40,0x60,0x40,0x20,0x88,0x20,0x84,0x61,0x3A,0x67,0xC3,0x22,0x01},
{0xAA,0x6C,0x00,0x00,0x20,0x4C,0x17,0xE8,0x10,0x48,0x42,0x48,0x23,0xC8,0x2A,0x08,0x0A,0x08,0x14,0x50,0x17,0xD0,0x24,0x54,0x60,0x52,0x20,0x92,0x20,0xA5,0x67,0x79,0x22,0x21},
{0xAA,0x6D,0x00,0x00,0x20,0x90,0x10,0x94,0x17,0xFE,0x40,0x94,0x22,0x94,0x2B,0xFC,0x0A,0x90,0x12,0x92,0x17,0xFF,0x14,0x92,0x64,0x92,0x21,0x1E,0x21,0x14,0x62,0x10,0x24,0x10},
{0xAA,0x6E,0x00,0x00,0x23,0x6C,0x12,0x48,0x12,0x48,0x42,0x48,0x2A,0x4A,0x2F,0xFF,0x0A,0x48,0x12,0x48,0x12,0x48,0x12,0x78,0x62,0x48,0x22,0x48,0x22,0x02,0x63,0xFF,0x22,0x00},
{0xAA,0x6F,0x00,0x00,0x20,0x30,0x10,0x20,0x10,0x20,0x42,0x22,0x2B,0xFF,0x2A,0x22,0x0A,0x22,0x12,0x22,0x13,0xFE,0x12,0x22,0x62,0x22,0x22,0x22,0x22,0x22,0x63,0xFE,0x22,0x02},
{0xAA,0x70,0x00,0x00,0x22,0x04,0x13,0xFE,0x12,0x04,0x42,0x04,0x26,0x04,0x2A,0x04,0x0A,0x04,0x13,0xFC,0x12,0x94,0x60,0x90,0x20,0x92,0x21,0x12,0x61,0x12,0x62,0x13,0x2C,0x0E},
{0xAA,0x71,0x00,0x00,0x21,0x08,0x11,0xFC,0x11,0x08,0x45,0x08,0x25,0x08,0x29,0xF8,0x09,0x08,0x11,0x08,0x11,0x08,0x61,0xF8,0x21,0x08,0x21,0x08,0x61,0x0A,0x6F,0xFF,0x20,0x00},
{0xAA,0x72,0x00,0x00,0x22,0x01,0x13,0xFF,0x12,0x51,0x42,0x51,0x26,0x51,0x2A,0x51,0x0A,0x51,0x12,0x55,0x12,0x95,0x62,0x8D,0x23,0x01,0x22,0x01,0x62,0x01,0x63,0xFF,0x22,0x01},
{0xAA,0x73,0x00,0x00,0x22,0x02,0x13,0xFF,0x12,0x02,0x42,0x32,0x26,0x22,0x2A,0x22,0x0A,0x62,0x12,0x52,0x12,0x52,0x62,0x8A,0x22,0x8A,0x22,0x02,0x62,0x02,0x63,0xFE,0x22,0x02},
{0xAA,0x74,0x00,0x00,0x20,0x30,0x10,0x20,0x11,0x24,0x41,0xFE,0x25,0x24,0x29,0x24,0x09,0x24,0x11,0x24,0x17,0xFF,0x60,0x50,0x20,0x50,0x20,0x88,0x60,0x88,0x61,0x04,0x26,0x03},
{0xAA,0x75,0x00,0x00,0x20,0xD8,0x10,0x88,0x10,0x88,0x41,0x08,0x25,0x04,0x2A,0x03,0x08,0x00,0x11,0x04,0x11,0xFE,0x61,0x04,0x21,0x04,0x21,0x04,0x61,0x04,0x61,0xFC,0x21,0x04},
{0xAA,0x76,0x00,0x00,0x20,0x30,0x10,0x20,0x10,0x48,0x44,0x44,0x24,0x8E,0x2B,0xF3,0x09,0x01,0x10,0x00,0x11,0x04,0x61,0xFE,0x21,0x04,0x21,0x04,0x61,0x04,0x61,0xFC,0x21,0x04},
{0xAA,0x77,0x00,0x00,0x21,0x80,0x11,0x04,0x11,0xFE,0x42,0x04,0x2A,0x04,0x2D,0xF4,0x09,0x14,0x11,0x14,0x11,0xF4,0x61,0x04,0x21,0x18,0x21,0x02,0x61,0x02,0x61,0x03,0x20,0xFE},
{0xAA,0x78,0x00,0x00,0x20,0x0C,0x10,0x3E,0x17,0xC0,0x40,0x30,0x24,0x20,0x28,0x24,0x0B,0xFE,0x10,0x08,0x10,0x10,0x60,0x20,0x20,0x40,0x26,0x80,0x65,0x00,0x64,0xC3,0x28,0x3C},
{0xAA,0x79,0x00,0x00,0x20,0x30,0x10,0x20,0x12,0x42,0x43,0xFF,0x26,0x02,0x2A,0x02,0x0A,0x02,0x12,0x02,0x13,0xFE,0x62,0x02,0x22,0x02,0x22,0x02,0x62,0x02,0x63,0xFE,0x22,0x02},
{0xAA,0x7A,0x00,0x00,0x20,0x30,0x10,0x20,0x10,0x24,0x43,0xFE,0x28,0x20,0x28,0x22,0x17,0xFF,0x10,0x60,0x10,0xB0,0x60,0xA8,0x21,0x28,0x21,0x24,0x66,0x23,0x60,0x20,0x20,0x20},
{0xAA,0x7B,0x00,0x00,0x22,0x04,0x13,0xFE,0x12,0x04,0x42,0x04,0x23,0xFC,0x2A,0x14,0x0A,0x10,0x12,0x12,0x13,0xFF,0x62,0x10,0x22,0x09,0x22,0x09,0x62,0xE5,0x6F,0x03,0x24,0x01},
{0xAA,0x7C,0x00,0x00,0x20,0x0C,0x11,0x3E,0x11,0xD0,0x41,0x10,0x25,0x12,0x29,0xFF,0x09,0x10,0x11,0x08,0x11,0x08,0x61,0x69,0x27,0x85,0x22,0x05,0x60,0x13,0x67,0xF9,0x20,0x00},
{0xAA,0x7D,0x00,0x00,0x22,0xC0,0x13,0x12,0x12,0x1F,0x42,0x52,0x26,0x52,0x2A,0x52,0x0A,0x52,0x12,0x52,0x12,0xD2,0x67,0x52,0x22,0x5E,0x20,0x94,0x60,0x90,0x21,0x10,0x02,0x10},
{0xAA,0x7E,0x00,0x00,0x20,0x20,0x10,0x60,0x10,0x50,0x40,0x88,0x29,0x04,0x2E,0xFB,0x08,0x00,0x10,0x04,0x13,0xFE,0x60,0x44,0x20,0x44,0x20,0x5C,0x60,0x48,0x20,0x40,0x00,0x40},
{0xAA,0xA1,0x00,0x00,0x18,0x30,0x10,0x20,0x10,0x22,0x15,0xFF,0x54,0x00,0x58,0x88,0x50,0xFC,0x50,0x88,0x10,0x88,0x18,0x88,0x24,0x88,0x24,0x89,0x21,0x09,0x41,0x09,0x42,0x07},
{0xAA,0xA2,0x00,0x00,0x00,0xC0,0x08,0x86,0x08,0x84,0x31,0x68,0x01,0x18,0x06,0x06,0x38,0xC2,0x00,0x80,0x08,0x8C,0x08,0x88,0x31,0x50,0x01,0x20,0x02,0x18,0x0C,0x07,0x70,0x02},
{0xAA,0xA3,0x00,0x00,0x18,0x18,0x10,0x10,0x10,0x10,0x16,0xD4,0x54,0x92,0x58,0x93,0x51,0x11,0x52,0x10,0x18,0x73,0x14,0x22,0x22,0x04,0x22,0x08,0x20,0x30,0x40,0xC0,0x07,0x00},
{0xAA,0xA4,0x00,0x00,0x18,0xC0,0x10,0x80,0x10,0x82,0x16,0xFF,0x54,0x82,0x59,0x34,0x51,0x20,0x52,0x20,0x18,0x20,0x14,0x50,0x24,0x50,0x20,0x88,0x20,0x88,0x41,0x07,0x06,0x02},
{0xAA,0xA5,0x00,0x00,0x01,0x80,0x01,0x08,0x03,0xFC,0x0C,0x10,0x32,0x60,0x09,0x80,0x06,0x00,0x78,0xC0,0x04,0x8C,0x08,0x88,0x31,0x50,0x01,0x20,0x02,0x18,0x0C,0x07,0x70,0x02},
{0xAA,0xA6,0x00,0x00,0x02,0x00,0x27,0x42,0x3A,0x7F,0x2A,0x52,0x2A,0x52,0x2A,0x7E,0x2A,0x42,0x2A,0x40,0x2A,0x41,0x29,0x41,0x29,0x3E,0x28,0x80,0x48,0x60,0x48,0x18,0x48,0x07},
{0xAA,0xA7,0x00,0x00,0x00,0x7E,0x1F,0x80,0x11,0x08,0x20,0xC6,0x40,0x42,0x1F,0xF8,0x00,0x8A,0x7F,0xFF,0x00,0x88,0x1F,0xF8,0x00,0x88,0x00,0x80,0x00,0x80,0x07,0x80,0x01,0x00},
{0xAA,0xA8,0x00,0x00,0x0C,0x30,0x10,0x0C,0x66,0x32,0x09,0xC0,0x03,0x20,0x0C,0x18,0x70,0x07,0x1F,0xF8,0x10,0x88,0x10,0x88,0x1F,0xF8,0x10,0x0A,0x10,0x02,0x10,0x03,0x0F,0xFE},
{0xAA,0xA9,0x00,0x00,0x36,0x82,0x24,0xFF,0x24,0x80,0x24,0x80,0x3E,0x82,0x20,0xFF,0x20,0xA2,0x24,0xA2,0x3E,0x94,0x24,0x94,0x24,0x88,0x24,0x94,0x45,0x14,0x45,0x22,0x45,0x41},
{0xAA,0xAA,0x00,0x00,0x0C,0x60,0x28,0x40,0x28,0x42,0x3E,0x7F,0x28,0x44,0x48,0x84,0x4A,0xC4,0x0C,0xA8,0x79,0x28,0x28,0x10,0x08,0x10,0x08,0x28,0x08,0x24,0x08,0x47,0x09,0x82},
{0xAA,0xAB,0x00,0x00,0x0C,0x60,0x28,0x40,0x28,0x42,0x3E,0xFF,0x28,0xAA,0x49,0x2A,0x48,0x4A,0x0A,0x52,0x0C,0x92,0x78,0xA2,0x29,0x22,0x08,0x44,0x08,0x84,0x08,0x38,0x08,0x10},
{0xAA,0xAC,0x00,0x00,0x06,0x18,0x34,0x10,0x24,0x14,0x24,0x13,0x3C,0x10,0x25,0xFF,0x04,0x10,0x04,0x30,0x7C,0x28,0x24,0x28,0x24,0x48,0x24,0x44,0x44,0x84,0x44,0x82,0x05,0x01},
{0xAA,0xAD,0x00,0x00,0x4D,0x02,0x29,0xFF,0x11,0x22,0x11,0x22,0x29,0xFE,0x49,0x22,0x0D,0x22,0x15,0x22,0x15,0xFE,0x25,0x22,0x44,0x20,0x04,0x20,0x44,0x20,0x38,0x20,0x10,0x20},
{0xAA,0xAE,0x00,0x00,0x4C,0x84,0x28,0xFE,0x10,0x84,0x10,0x84,0x28,0x84,0x48,0xFC,0x0C,0x84,0x14,0x84,0x14,0x84,0x24,0xFC,0x44,0x84,0x04,0x84,0x44,0x84,0x3B,0xFF,0x10,0x00},
{0xAA,0xAF,0x00,0x00,0x4C,0xC0,0x28,0x80,0x10,0x82,0x11,0xFF,0x29,0x02,0x4A,0x02,0x0C,0xFA,0x14,0x8A,0x14,0x8A,0x24,0xFA,0x44,0x02,0x04,0x02,0x44,0x04,0x38,0x38,0x10,0x10},
{0xAA,0xB0,0x00,0x00,0x4C,0x0C,0x29,0x3E,0x11,0xE4,0x11,0x24,0x29,0x24,0x49,0x24,0x0D,0x24,0x15,0x24,0x15,0x24,0x25,0x24,0x45,0x22,0x05,0x32,0x45,0x6A,0x3A,0x09,0x12,0x01},
{0xAA,0xB1,0x00,0x00,0x08,0x04,0x7C,0xFE,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x02,0x7D,0xFF,0x10,0x48,0x10,0x48,0x14,0x48,0x18,0x48,0x70,0x89,0x20,0x89,0x01,0x09,0x06,0x07},
{0xAA,0xB2,0x00,0x00,0x08,0x04,0x7D,0xFE,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20,0x7C,0x24,0x11,0xFE,0x10,0x20,0x12,0x20,0x1C,0x20,0x70,0x20,0x20,0x22,0x03,0xFF,0x00,0x00},
{0xAA,0xB3,0x00,0x00,0x08,0x30,0x7C,0x20,0x10,0x22,0x13,0xFF,0x10,0x04,0x7C,0x84,0x11,0x88,0x13,0x48,0x10,0x50,0x14,0x30,0x18,0x20,0x70,0x50,0x20,0x8C,0x01,0x07,0x06,0x02},
{0xAA,0xB4,0x00,0x00,0x08,0xC0,0x7C,0x80,0x10,0x82,0x10,0xFF,0x10,0x84,0x11,0x84,0x7D,0x44,0x12,0x48,0x10,0x28,0x14,0x30,0x18,0x10,0x70,0x28,0x20,0x44,0x00,0x87,0x03,0x02},
{0xAA,0xB5,0x00,0x00,0x04,0x82,0x7E,0xFF,0x10,0x82,0x10,0x82,0x10,0xFE,0x14,0x82,0x7E,0x82,0x10,0x82,0x10,0xFE,0x12,0x82,0x1C,0x82,0x71,0x02,0x21,0x12,0x02,0x0E,0x04,0x04},
{0xAA,0xB6,0x00,0x00,0x00,0xDB,0x44,0x92,0x7E,0x92,0x54,0x92,0x54,0x92,0x54,0x92,0x7C,0x92,0x54,0x92,0x54,0x92,0x54,0x92,0x7C,0x92,0x45,0x12,0x01,0x12,0x02,0x12,0x04,0x02},
{0xAA,0xB7,0x00,0x00,0x00,0x30,0x08,0x22,0x0F,0xFF,0x48,0x00,0x28,0x30,0x28,0x20,0x0B,0x23,0x0A,0x22,0x1A,0x22,0x6A,0x22,0x4A,0x22,0x0A,0x22,0x13,0xFE,0x12,0x02,0x20,0x00},
{0xAA,0xB8,0x00,0x00,0x00,0x60,0x08,0x42,0x0F,0xFF,0x48,0x00,0x28,0x84,0x28,0xFE,0x09,0x00,0x0A,0x08,0x18,0xFC,0x68,0x10,0x48,0x20,0x08,0x42,0x10,0x82,0x10,0x83,0x20,0x7E},
{0xAA,0xB9,0x00,0x00,0x00,0x60,0x08,0x42,0x0F,0xFF,0x48,0x00,0x28,0xC0,0x28,0x88,0x08,0xFC,0x09,0x10,0x19,0x10,0x6A,0x20,0x48,0x20,0x08,0x50,0x10,0x88,0x11,0x04,0x26,0x03},
{0xAA,0xBA,0x00,0x00,0x0C,0x60,0x08,0x40,0x52,0x42,0x7E,0x7F,0x42,0x82,0x42,0x82,0x43,0x02,0x7E,0x42,0x42,0x32,0x42,0x12,0x42,0x02,0x42,0x04,0x7E,0x44,0x42,0x38,0x00,0x10},
{0xAA,0xBB,0x00,0x00,0x00,0x08,0x1F,0xFC,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x03,0x80,0x11,0x08,0x1F,0xFC,0x12,0x48,0x12,0x48,0x12,0x48,0x12,0x4A,0x7F,0xFF},
{0xAA,0xBC,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x00,0x20,0x00,0x1F,0xFC,0x00,0x00,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08},
{0xAA,0xBD,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x80,0x04,0x88,0x07,0xFC,0x34,0x08,0x27,0xF8,0x24,0x08,0x27,0xF8,0x24,0x08,0x27,0xF8,0x20,0x02,0x3F,0xFF,0x20,0x00},
{0xAA,0xBE,0x00,0x00,0x18,0x00,0x10,0x00,0x12,0x42,0x3F,0x7F,0x24,0x42,0x44,0x42,0x05,0x42,0x7F,0xC2,0x04,0x42,0x0A,0x42,0x0A,0x42,0x11,0x42,0x11,0x7E,0x20,0x42,0x40,0x00},
{0xAA,0xBF,0x00,0x00,0x02,0x30,0x7F,0x20,0x08,0x22,0x08,0x3F,0x12,0x42,0x1E,0x42,0x32,0xA4,0x53,0x24,0x12,0x28,0x12,0x08,0x12,0x10,0x1E,0x10,0x12,0x20,0x00,0x40,0x00,0x80},
{0xAA,0xC0,0x00,0x00,0x04,0x18,0x3E,0x10,0x00,0x10,0x02,0x10,0x7F,0x10,0x08,0x14,0x08,0xFE,0x2A,0x10,0x2A,0x10,0x2A,0x10,0x2A,0x10,0x4A,0x10,0x48,0x12,0x09,0xFF,0x08,0x00},
{0xAA,0xC1,0x00,0x00,0x04,0x00,0x3E,0x42,0x00,0x7F,0x02,0x42,0x7F,0x42,0x08,0x42,0x08,0x42,0x2A,0x7E,0x2A,0x42,0x2A,0x40,0x4A,0x40,0x4A,0x42,0x4A,0x42,0x08,0x43,0x08,0x3E},
{0xAA,0xC2,0x00,0x00,0x02,0x00,0x3F,0x22,0x00,0x3F,0x01,0x22,0x7F,0xA2,0x04,0x24,0x04,0x24,0x35,0xA2,0x25,0x21,0x25,0x21,0x25,0x21,0x45,0x2E,0x45,0x24,0x04,0x20,0x04,0x20},
{0xAA,0xC3,0x00,0x00,0x00,0xF8,0x1F,0x80,0x00,0x84,0x7F,0xFE,0x00,0x80,0x1F,0xF8,0x00,0x8A,0x7F,0xFF,0x00,0x88,0x1F,0xF8,0x01,0x80,0x06,0xE0,0x18,0x98,0x60,0x87,0x00,0x80},
{0xAA,0xC4,0x00,0x00,0x0E,0x18,0x78,0x10,0x08,0x10,0x08,0xD3,0x7E,0x92,0x18,0x92,0x18,0x92,0x2C,0x92,0x2A,0x92,0x2A,0x92,0x48,0x92,0x08,0x92,0x08,0xFE,0x08,0x82,0x08,0x00},
{0xAA,0xC5,0x00,0x00,0x01,0x80,0x21,0x04,0x3F,0xFE,0x20,0x04,0x46,0x68,0x04,0x42,0x08,0x43,0x70,0x3E,0x00,0x00,0x1F,0xF8,0x01,0x00,0x01,0x00,0x01,0x04,0x7F,0xFE,0x00,0x00},
{0xAA,0xC6,0x00,0x00,0x00,0xC0,0x20,0x84,0x3F,0xFE,0x26,0x44,0x44,0x41,0x18,0x3F,0x60,0x00,0x1F,0xF8,0x00,0x08,0x0F,0xF8,0x08,0x00,0x1F,0xFC,0x10,0x04,0x00,0x18,0x00,0xE0},
{0xAA,0xC7,0x00,0x00,0x18,0x30,0x12,0x22,0x1F,0x3F,0x28,0x50,0x26,0x4C,0x42,0x84,0x00,0x00,0x00,0x10,0x1F,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x7F,0xFE,0x00,0x00},
{0xAA,0xC8,0x00,0x00,0x18,0x03,0x10,0x32,0x26,0x22,0x64,0x22,0x18,0x22,0x0C,0x22,0x12,0x22,0x7D,0x22,0x49,0x26,0x0C,0x3A,0x2A,0x62,0x2A,0x22,0x4A,0x02,0x08,0x02,0x08,0x02},
{0xAA,0xC9,0x00,0x00,0x20,0x02,0x3F,0xFF,0x20,0x02,0x24,0x32,0x22,0x22,0x2F,0xFA,0x20,0x82,0x24,0x82,0x27,0xFA,0x24,0x02,0x24,0x02,0x23,0xF2,0x20,0x02,0x20,0x0E,0x20,0x04},
{0xAA,0xCA,0x00,0x00,0x10,0x30,0x0C,0x20,0x04,0x48,0x3F,0xFC,0x01,0x00,0x1F,0xF8,0x01,0x00,0x7F,0xFE,0x04,0x40,0x04,0x40,0x04,0x40,0x08,0x42,0x08,0x42,0x10,0x43,0x60,0x3E},
{0xAA,0xCB,0x00,0x00,0x0C,0xCC,0x08,0x88,0x78,0x8F,0x08,0x88,0x08,0x08,0x00,0xC0,0x00,0x88,0x1F,0xFC,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xAA,0xCC,0x00,0x00,0x01,0x80,0x01,0x06,0x1F,0xE4,0x01,0x08,0x01,0x12,0x7F,0xFF,0x00,0x80,0x03,0x20,0x0C,0x10,0x77,0xF8,0x04,0x08,0x07,0xF8,0x04,0x08,0x07,0xF8,0x04,0x08},
{0xAA,0xCD,0x00,0x00,0x24,0x18,0x3C,0x12,0x25,0xFF,0x24,0x10,0x3C,0x92,0x24,0xFF,0x24,0x92,0x24,0x92,0x3C,0x92,0x24,0x92,0x24,0x92,0x24,0x9E,0x44,0x94,0x5C,0x10,0x48,0x10},
{0xAA,0xCE,0x00,0x00,0x25,0x04,0x3D,0xFE,0x25,0x24,0x25,0x24,0x3D,0x24,0x25,0x24,0x25,0x24,0x25,0xFC,0x3D,0x04,0x25,0x00,0x25,0x00,0x25,0x02,0x45,0x02,0x5D,0x03,0x48,0xFE},
{0xAA,0xCF,0x00,0x00,0x24,0x30,0x3C,0x20,0x24,0x22,0x25,0xFF,0x3C,0x20,0x24,0x24,0x25,0xFE,0x24,0x84,0x3C,0x44,0x24,0x48,0x24,0x30,0x24,0x10,0x44,0x28,0x5C,0x47,0x49,0x82},
{0xAA,0xD0,0x00,0x00,0x24,0x30,0x3C,0x20,0x24,0x22,0x25,0xFF,0x3C,0x40,0x24,0x40,0x24,0x98,0x24,0x90,0x3C,0x90,0x25,0x20,0x25,0x24,0x26,0x44,0x44,0x4A,0x5C,0xF1,0x48,0x41},
{0xAA,0xD1,0x00,0x00,0x24,0x88,0x3C,0xFC,0x24,0x88,0x24,0x88,0x3C,0x89,0x24,0x87,0x25,0x00,0x24,0x04,0x3D,0xFE,0x24,0x84,0x24,0x48,0x24,0x30,0x44,0x28,0x5C,0x44,0x49,0x83},
{0xAA,0xD2,0x00,0x00,0x24,0x30,0x3E,0x26,0x24,0x38,0x25,0xE0,0x3C,0x20,0x24,0x20,0x25,0xA6,0x25,0x24,0x3D,0x24,0x25,0xFC,0x25,0x24,0x24,0x20,0x44,0x22,0x5C,0x23,0x48,0x1E},
{0xAA,0xD3,0x00,0x00,0x10,0x7E,0x1F,0x80,0x10,0x00,0x1F,0xFC,0x10,0x04,0x1F,0xFC,0x10,0x00,0x17,0xFC,0x14,0x04,0x17,0xFC,0x14,0x04,0x27,0xFC,0x24,0x04,0x24,0x1C,0x44,0x08},
{0xAA,0xD4,0x00,0x00,0x3C,0x78,0x03,0x80,0x04,0x60,0x39,0x98,0x01,0x02,0x7F,0xFF,0x02,0x00,0x07,0xF8,0x1C,0x08,0x67,0xF8,0x04,0x08,0x07,0xF8,0x04,0x08,0x04,0x78,0x04,0x10},
{0xAA,0xD5,0x00,0x00,0x24,0x18,0x3E,0x10,0x24,0x12,0x25,0xFF,0x3C,0x40,0x24,0x44,0x24,0x7E,0x24,0x44,0x3C,0x44,0x24,0x44,0x24,0x44,0x24,0x84,0x44,0x84,0x5C,0xB8,0x49,0x10},
{0xAA,0xD6,0x00,0x00,0x00,0xC0,0x0C,0x90,0x08,0xF8,0x08,0x82,0x7F,0xFF,0x00,0x00,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x08,0x08,0x08,0x78,0x08,0x10},
{0xAA,0xD7,0x00,0x00,0x42,0x18,0x7F,0x10,0x48,0x10,0x48,0x10,0x4A,0x10,0x7F,0x10,0x42,0x10,0x42,0x30,0x7E,0x28,0x4A,0x28,0x48,0x48,0x48,0x44,0x7F,0x44,0x40,0x82,0x01,0x01},
{0xAA,0xD8,0x00,0x00,0x2D,0x80,0x31,0x04,0x21,0x3E,0x21,0x04,0x29,0x04,0x3D,0x3C,0x21,0x04,0x21,0x04,0x3F,0xFC,0x21,0x04,0x02,0x80,0x02,0x60,0x04,0x18,0x18,0x07,0x60,0x02},
{0xAA,0xD9,0x00,0x00,0x01,0x80,0x02,0x40,0x04,0x30,0x08,0x0C,0x17,0xF3,0x60,0x80,0x00,0x84,0x7F,0xFE,0x00,0x80,0x08,0x88,0x0F,0xFC,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x08},
{0xAA,0xDA,0x00,0x00,0x06,0x18,0x04,0x12,0x7F,0xFF,0x04,0x10,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x04,0x00,0x04,0x08,0x07,0xFC,0x04,0x08,0x08,0x08,0x08,0x08,0x10,0xF0,0x60,0x20},
{0xAA,0xDB,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x01,0x80,0x01,0x08,0x3F,0xFC,0x00,0x08,0x00,0x30,0x00,0x40,0x01,0x80,0x36,0x00,0x28,0x00,0x46,0x03,0x41,0xFC},
{0xAA,0xDC,0x00,0x00,0x06,0x18,0x04,0x12,0x7F,0xFF,0x04,0x10,0x00,0xC0,0x00,0x88,0x1F,0xFC,0x00,0x80,0x00,0x82,0x7F,0xFF,0x01,0x40,0x02,0x20,0x04,0x18,0x18,0x07,0x60,0x02},
{0xAA,0xDD,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x20,0x08,0x3F,0xFC,0x21,0x08,0x21,0x08,0x21,0x08,0x3F,0xF8,0x20,0x08,0x20,0x02,0x20,0x02,0x20,0x03,0x1F,0xFE},
{0xAA,0xDE,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x00,0x00,0x3F,0xFC,0x00,0x40,0x08,0x44,0x1F,0xFE,0x10,0xC0,0x03,0x40,0x0C,0x40,0x70,0x40,0x01,0xC0,0x00,0x80},
{0xAA,0xDF,0x00,0x00,0x04,0x22,0x7F,0xFF,0x04,0x20,0x00,0x00,0x07,0xE0,0x04,0x22,0x04,0x23,0x38,0x1E,0x00,0x00,0x1F,0xF8,0x04,0x10,0x02,0x60,0x01,0x80,0x06,0x70,0x78,0x0E},
{0xAA,0xE0,0x00,0x00,0x04,0x20,0x7F,0xFF,0x04,0x20,0x00,0x00,0x10,0x7C,0x1F,0x80,0x10,0x00,0x10,0x04,0x1F,0xFE,0x10,0x40,0x10,0x40,0x10,0x40,0x20,0x40,0x20,0x40,0x40,0x40},
{0xAA,0xE1,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x00,0x00,0x0C,0xC0,0x08,0x80,0x10,0x98,0x18,0xB0,0x30,0xC0,0x51,0x80,0x12,0x82,0x10,0x82,0x10,0x83,0x10,0x7E},
{0xAA,0xE2,0x00,0x00,0x04,0x22,0x7F,0xFF,0x04,0x20,0x00,0x00,0x06,0xC0,0x04,0x20,0x08,0x18,0x10,0x07,0x6F,0xF2,0x02,0x10,0x02,0x10,0x04,0x10,0x04,0x10,0x08,0xE0,0x30,0x40},
{0xAA,0xE3,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x01,0x80,0x02,0x60,0x04,0x18,0x18,0x07,0x66,0x32,0x04,0x20,0x04,0x20,0x04,0x20,0x08,0x20,0x08,0x20,0x10,0x20},
{0xAA,0xE4,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x04,0x20,0x00,0x80,0x06,0x40,0x04,0x60,0x14,0x24,0x14,0x02,0x24,0x12,0x24,0x11,0x44,0x19,0x03,0xF0,0x00,0x00},
{0xAA,0xE5,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x00,0x00,0x1F,0xF8,0x00,0x00,0x00,0x02,0x7F,0xFF,0x01,0x00,0x02,0x20,0x02,0x10,0x04,0xF8,0x3F,0x0C,0x10,0x04},
{0xAA,0xE6,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x00,0x02,0x7F,0xFF,0x00,0x80,0x01,0x80,0x02,0x90,0x04,0x8C,0x18,0x86,0x60,0x82,0x00,0x80,0x00,0x80,0x00,0x80},
{0xAA,0xE7,0x00,0x00,0x04,0x10,0x7F,0xFF,0x04,0x10,0x00,0xC0,0x00,0x82,0x3F,0xFF,0x00,0x80,0x00,0x88,0x3F,0xFC,0x04,0x10,0x03,0x20,0x00,0xC0,0x03,0x20,0x0C,0x18,0x70,0x07},
{0xAA,0xE8,0x00,0x00,0x06,0x18,0x04,0x12,0x7F,0xFF,0x04,0x10,0x00,0x82,0x7F,0xFF,0x00,0x80,0x10,0x84,0x1F,0xFE,0x10,0x84,0x10,0x84,0x10,0xBC,0x10,0x88,0x00,0x80,0x00,0x80},
{0xAA,0xE9,0x00,0x00,0x06,0x18,0x04,0x12,0x7F,0xFF,0x04,0x10,0x00,0xC0,0x00,0x80,0x18,0x80,0x10,0x88,0x10,0xFC,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x82,0x7F,0xFF},
{0xAA,0xEA,0x00,0x00,0x01,0x10,0x01,0xF8,0x21,0x02,0x3F,0xFF,0x20,0x02,0x21,0x04,0x21,0xF0,0x2F,0x02,0x20,0xFE,0x20,0x00,0x23,0x30,0x22,0x20,0x42,0x22,0x44,0x23,0x58,0x1E},
{0xAA,0xEB,0x00,0x00,0x00,0x10,0x7F,0xF8,0x00,0x10,0x07,0x90,0x3C,0x10,0x04,0x10,0x3F,0x90,0x24,0x90,0x24,0x88,0x3F,0x88,0x04,0x09,0x04,0x85,0x07,0x45,0x7C,0x63,0x20,0x21},
{0xAA,0xEC,0x00,0x00,0x0C,0x00,0x08,0x02,0x08,0xFF,0x7E,0x22,0x02,0x22,0x04,0x22,0x08,0x22,0x1B,0x22,0x2C,0x22,0x4A,0x42,0x0A,0x42,0x08,0x42,0x08,0x82,0x08,0x9C,0x09,0x08},
{0xAA,0xED,0x00,0x00,0x00,0xC0,0x00,0x80,0x3F,0xFE,0x00,0x80,0x1F,0xFC,0x00,0x80,0x7F,0xFF,0x02,0x80,0x04,0x46,0x1C,0x58,0x64,0x20,0x05,0xA0,0x06,0x18,0x38,0x07,0x10,0x02},
{0xAA,0xEE,0x00,0x00,0x0C,0x30,0x09,0x20,0x7F,0xA0,0x08,0x20,0x7F,0x20,0x49,0x20,0x7F,0x20,0x49,0x20,0x7F,0x20,0x08,0x20,0x09,0x22,0x7F,0xA2,0x08,0x22,0x08,0x23,0x08,0x1E},
{0xAA,0xEF,0x00,0x00,0x22,0xD2,0x1B,0x1F,0x02,0x12,0x42,0x12,0x32,0x12,0x02,0x12,0x02,0x12,0x12,0x52,0x7A,0x92,0x17,0x1E,0x12,0x14,0x10,0x10,0x28,0x10,0x26,0x03,0x41,0xFC},
{0xAA,0xF0,0x00,0x00,0x21,0x02,0x19,0xFF,0x01,0x00,0x41,0x04,0x31,0xFE,0x01,0x44,0x01,0x24,0x11,0x28,0x79,0x10,0x11,0x28,0x12,0x28,0x12,0x46,0x18,0x80,0x66,0x03,0x41,0xFC},
{0xAA,0xF1,0x00,0x00,0x20,0x0C,0x19,0x1E,0x01,0xE0,0x41,0x00,0x31,0x02,0x01,0xFF,0x01,0x08,0x11,0x08,0x79,0x08,0x11,0x08,0x12,0x08,0x12,0x08,0x18,0x08,0x66,0x03,0x41,0xFC},
{0xAA,0xF2,0x00,0x00,0x01,0x22,0x7F,0xBF,0x11,0x22,0x11,0x22,0x11,0x24,0x21,0x24,0x2E,0x22,0x44,0x22,0x21,0x21,0x3F,0xA1,0x21,0x21,0x21,0x2E,0x21,0x24,0x3F,0x20,0x21,0x20},
{0xAA,0xF3,0x00,0x00,0x21,0xD2,0x3E,0x1F,0x22,0x12,0x22,0x12,0x22,0x94,0x3F,0xD4,0x22,0x12,0x22,0x12,0x21,0x51,0x2D,0x51,0x71,0x51,0x20,0xDE,0x02,0x54,0x7F,0x10,0x00,0x10},
{0xAA,0xF4,0x00,0x00,0x23,0xA2,0x3C,0x3F,0x20,0x22,0x20,0x22,0x21,0x24,0x3F,0xA4,0x22,0x22,0x22,0x22,0x22,0x21,0x22,0xA1,0x27,0x21,0x78,0x2E,0x20,0x24,0x00,0x20,0x00,0x20},
{0xAA,0xF5,0x00,0x00,0x0A,0x12,0x0A,0x1F,0x0A,0x12,0x0A,0x12,0x0A,0x94,0x7B,0xD4,0x0A,0x12,0x0A,0x12,0x0A,0x11,0x1A,0x11,0x6A,0x51,0x4A,0x5E,0x0A,0x54,0x09,0xD0,0x08,0x10},
{0xAA,0xF6,0x00,0x00,0x00,0x0C,0x00,0x7E,0x1F,0x88,0x10,0x86,0x10,0x62,0x60,0xA0,0x00,0x82,0x7F,0xFF,0x01,0x80,0x02,0xC0,0x02,0xA0,0x04,0x98,0x18,0x87,0x60,0x82,0x00,0x80},
{0xAA,0xF7,0x00,0x00,0x01,0x80,0x03,0x40,0x02,0x20,0x04,0x10,0x08,0x0C,0x17,0xF3,0x60,0x80,0x00,0x80,0x00,0x84,0x3F,0xFE,0x00,0x80,0x10,0x98,0x0C,0x90,0x04,0xA2,0x7F,0xFF},
{0xAA,0xF8,0x00,0x00,0x04,0x08,0x07,0xFC,0x04,0x00,0x07,0xF8,0x04,0x00,0x07,0xF8,0x04,0x02,0x7F,0xFF,0x09,0x00,0x08,0x86,0x08,0x58,0x09,0xA0,0x0E,0x18,0x78,0x07,0x20,0x02},
{0xAA,0xF9,0x00,0x00,0x21,0x42,0x3F,0x7F,0x21,0x42,0x3F,0x7E,0x21,0x42,0x3F,0x7E,0x21,0x42,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x1E,0x20,0x04},
{0xAA,0xFA,0x00,0x00,0x01,0x80,0x12,0x00,0x1F,0xF0,0x10,0x10,0x1F,0xF0,0x10,0x00,0x1F,0xF8,0x10,0x08,0x1F,0xF8,0x10,0x88,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80},
{0xAA,0xFB,0x00,0x00,0x48,0x30,0x7C,0x20,0x49,0x22,0x49,0xFF,0x51,0x02,0x52,0x64,0x48,0x40,0x48,0x40,0x44,0x46,0x44,0x58,0x44,0x60,0x78,0x42,0x50,0x42,0x40,0x43,0x40,0x3E},
{0xAA,0xFC,0x00,0x00,0x48,0x02,0x7B,0xFF,0x48,0x04,0x48,0x04,0x51,0x24,0x51,0xF4,0x49,0x24,0x49,0x24,0x45,0x24,0x45,0xE4,0x45,0x24,0x78,0x04,0x50,0x04,0x40,0x1C,0x40,0x08},
{0xAA,0xFD,0x00,0x00,0x48,0x84,0x7C,0xFE,0x48,0x84,0x48,0x84,0x50,0x84,0x50,0xFC,0x48,0x84,0x48,0x84,0x44,0x84,0x44,0xFC,0x44,0x84,0x78,0x84,0x50,0x84,0x43,0xFF,0x40,0x00},
{0xAA,0xFE,0x00,0x00,0x48,0xC6,0x7C,0x84,0x48,0x84,0x49,0x3F,0x51,0x04,0x53,0x84,0x55,0x24,0x49,0x24,0x49,0x14,0x45,0x14,0x45,0x04,0x79,0x04,0x51,0x04,0x41,0x1C,0x41,0x08},
{0xAB,0x40,0x00,0x00,0x48,0x18,0x7C,0x10,0x49,0x12,0x49,0xFF,0x51,0x12,0x51,0x14,0x49,0x10,0x49,0xFE,0x45,0x44,0x45,0x24,0x79,0x28,0x52,0x10,0x42,0x28,0x42,0x44,0x44,0x83},
{0xAB,0x41,0x00,0x00,0x06,0x30,0x04,0x60,0x08,0x40,0x08,0x84,0x1F,0xFE,0x28,0x40,0x48,0x44,0x0F,0xFE,0x08,0x40,0x08,0x44,0x0F,0xFE,0x08,0x40,0x08,0x42,0x0F,0xFF,0x08,0x00},
{0xAB,0x42,0x00,0x00,0x00,0x02,0x7F,0xFF,0x00,0x80,0x20,0x82,0x3F,0xFF,0x20,0x82,0x28,0xA2,0x26,0x9A,0x22,0x8A,0x20,0xA2,0x28,0x9A,0x26,0x8A,0x22,0x82,0x20,0x9E,0x20,0x84},
{0xAB,0x43,0x00,0x00,0x00,0x80,0x3F,0xFE,0x00,0x80,0x1F,0xFC,0x00,0x80,0x7F,0xFF,0x00,0x00,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x08,0x78,0x08,0x10},
{0xAB,0x44,0x00,0x00,0x03,0x60,0x02,0x40,0x02,0x44,0x7E,0x7E,0x02,0x40,0x02,0x44,0x3E,0x7E,0x02,0x40,0x03,0x40,0x0E,0x42,0x72,0x7F,0x24,0x40,0x04,0x40,0x08,0x40,0x10,0x40},
{0xAB,0x45,0x00,0x00,0x00,0x02,0x7F,0xFF,0x08,0x00,0x08,0x00,0x1F,0x04,0x01,0x7E,0x79,0x44,0x49,0x44,0x49,0x28,0x79,0x28,0x01,0x10,0x0E,0x28,0x04,0xC6,0x00,0x00,0x7F,0xFF},
{0xAB,0x46,0x00,0x00,0x01,0x80,0x01,0x08,0x3F,0xFC,0x00,0x00,0x0F,0xF0,0x08,0x10,0x0F,0xF0,0x20,0x02,0x3F,0xFF,0x40,0x02,0x5F,0xF8,0x00,0x80,0x00,0x80,0x07,0x80,0x01,0x00},
{0xAB,0x47,0x00,0x00,0x01,0x80,0x01,0x04,0x7F,0xFE,0x00,0x00,0x0F,0xF0,0x08,0x10,0x0F,0xF0,0x20,0x04,0x3F,0xFE,0x20,0x04,0x46,0x68,0x04,0x40,0x08,0x42,0x10,0x43,0x60,0x3E},
{0xAB,0x48,0x00,0x00,0x0C,0x08,0x09,0xFC,0x08,0x00,0x10,0x02,0x1B,0xFF,0x30,0x00,0x51,0xFC,0x10,0x00,0x11,0xFC,0x10,0x00,0x11,0xFC,0x11,0x04,0x11,0x04,0x11,0xFC,0x11,0x04},
{0xAB,0x49,0x00,0x00,0x0D,0xF8,0x08,0x08,0x0B,0xFE,0x10,0x08,0x11,0xF8,0x34,0x02,0x57,0xFF,0x14,0x02,0x18,0x08,0x13,0xFC,0x11,0x08,0x10,0x90,0x10,0x60,0x11,0x98,0x16,0x07},
{0xAB,0x4A,0x00,0x00,0x0C,0x08,0x09,0xFC,0x08,0x08,0x10,0x0A,0x1B,0xFF,0x30,0x00,0x51,0x04,0x11,0xFE,0x12,0x20,0x14,0x22,0x13,0xFF,0x10,0x50,0x10,0x88,0x11,0x04,0x16,0x03},
{0xAB,0x4B,0x00,0x00,0x0C,0x04,0x0B,0xFE,0x08,0x20,0x12,0x24,0x1B,0xFE,0x32,0x24,0x53,0xFC,0x12,0x24,0x13,0xFC,0x12,0x24,0x10,0x20,0x11,0xA0,0x16,0x60,0x10,0x98,0x17,0x07},
{0xAB,0x4C,0x00,0x00,0x0C,0x30,0x08,0x20,0x08,0x22,0x13,0xFF,0x18,0x20,0x31,0xA6,0x51,0x24,0x12,0xAA,0x14,0xB1,0x10,0x20,0x10,0x50,0x10,0x50,0x10,0x88,0x11,0x04,0x16,0x03},
{0xAB,0x4D,0x00,0x00,0x0C,0x04,0x09,0xFE,0x08,0x04,0x10,0x68,0x1A,0x12,0x33,0xFF,0x52,0x22,0x13,0xFE,0x12,0x22,0x12,0x22,0x13,0xFE,0x12,0x22,0x12,0x22,0x12,0x2E,0x12,0x04},
{0xAB,0x4E,0x00,0x00,0x0C,0x30,0x09,0xA4,0x09,0x22,0x11,0x23,0x1A,0x21,0x31,0xFC,0x51,0x04,0x11,0xFC,0x11,0x04,0x11,0x04,0x11,0xFC,0x11,0x04,0x11,0x04,0x11,0x1C,0x11,0x08},
{0xAB,0x4F,0x00,0x00,0x0D,0x04,0x09,0xFE,0x09,0x04,0x11,0x04,0x19,0x04,0x31,0xFC,0x51,0x24,0x10,0x20,0x13,0xFF,0x10,0x60,0x10,0xB0,0x10,0xAC,0x11,0x23,0x12,0x20,0x10,0x20},
{0xAB,0x50,0x00,0x00,0x0D,0x02,0x09,0xFF,0x09,0x02,0x11,0x02,0x19,0x02,0x31,0xFE,0x51,0x12,0x10,0x10,0x11,0x92,0x11,0x1F,0x11,0x10,0x11,0x10,0x12,0xD0,0x12,0x30,0x14,0x0F},
{0xAB,0x51,0x00,0x00,0x0D,0x04,0x09,0xFE,0x09,0x04,0x11,0x04,0x19,0x04,0x31,0xFC,0x51,0x24,0x10,0x20,0x12,0x42,0x13,0xFF,0x12,0x02,0x12,0x02,0x12,0x02,0x13,0xFE,0x12,0x02},
{0xAB,0x52,0x00,0x00,0x0C,0x3E,0x09,0xE4,0x09,0x12,0x11,0x12,0x1A,0x00,0x31,0xFE,0x50,0x04,0x10,0x08,0x10,0x12,0x13,0xFF,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xF0,0x10,0x20},
{0xAB,0x53,0x00,0x00,0x0C,0x60,0x08,0x48,0x08,0x84,0x13,0xFA,0x18,0x02,0x31,0x08,0x51,0xFC,0x11,0x20,0x12,0x22,0x17,0xFF,0x10,0x50,0x10,0x48,0x10,0x88,0x11,0x04,0x16,0x03},
{0xAB,0x54,0x00,0x00,0x0C,0x60,0x08,0x48,0x08,0x84,0x13,0xFA,0x18,0x90,0x31,0x11,0x56,0x0F,0x10,0x80,0x10,0xFC,0x11,0x04,0x16,0x88,0x10,0x50,0x10,0x28,0x10,0xC4,0x13,0x03},
{0xAB,0x55,0x00,0x00,0x0C,0xC8,0x08,0x84,0x09,0x26,0x11,0x32,0x1A,0x50,0x30,0x88,0x51,0x04,0x16,0x03,0x11,0xFC,0x11,0x04,0x11,0x04,0x11,0x04,0x11,0x04,0x11,0xFC,0x11,0x04},
{0xAB,0x56,0x00,0x00,0x0D,0x80,0x09,0x04,0x0B,0xFE,0x12,0x00,0x15,0xFC,0x31,0x44,0x51,0x24,0x17,0xFF,0x11,0x04,0x11,0x44,0x12,0x24,0x13,0xFE,0x12,0x08,0x10,0x78,0x10,0x10},
{0xAB,0x57,0x00,0x00,0x0C,0xE1,0x0B,0x81,0x08,0x8D,0x10,0x89,0x17,0xE9,0x30,0x89,0x51,0x89,0x11,0xC9,0x12,0xA9,0x12,0xA9,0x14,0x89,0x10,0x81,0x10,0x81,0x10,0x87,0x10,0x82},
{0xAB,0x58,0x00,0x00,0x0C,0x18,0x08,0xD0,0x17,0x14,0x11,0x13,0x11,0x10,0x37,0xFF,0x51,0x10,0x11,0x56,0x11,0x94,0x17,0x14,0x15,0x08,0x11,0x09,0x11,0x15,0x17,0x63,0x12,0x01},
{0xAB,0x59,0x00,0x00,0x0C,0x1E,0x0B,0xE0,0x08,0x20,0x10,0x4C,0x19,0x88,0x30,0x50,0x50,0x24,0x10,0x42,0x13,0xFD,0x11,0x21,0x10,0x20,0x13,0x28,0x12,0x26,0x14,0x22,0x10,0x20},
{0xAB,0x5A,0x00,0x00,0x0A,0x02,0x0B,0xFF,0x0A,0x22,0x12,0x22,0x1B,0xFE,0x32,0x22,0x52,0x22,0x13,0xFE,0x12,0x22,0x10,0x20,0x13,0xFE,0x10,0x20,0x10,0x22,0x17,0xFF,0x10,0x00},
{0xAB,0x5B,0x00,0x00,0x0C,0x84,0x08,0xFE,0x14,0x84,0x12,0x84,0x22,0x84,0x40,0xFC,0x00,0x84,0x0C,0x84,0x08,0x84,0x14,0xFC,0x12,0x84,0x22,0x84,0x40,0x84,0x03,0xFF,0x00,0x00},
{0xAB,0x5C,0x00,0x00,0x3F,0x80,0x00,0xC0,0x03,0x20,0x0C,0x18,0x33,0xE7,0x40,0x00,0x1F,0x06,0x11,0x34,0x1F,0x24,0x11,0x24,0x1F,0x24,0x11,0x24,0x11,0x04,0x17,0x1C,0x12,0x08},
{0xAB,0x5D,0x00,0x00,0x0A,0x04,0x0B,0xFE,0x0A,0x04,0x12,0x04,0x13,0xFC,0x32,0x00,0x53,0xFF,0x12,0x02,0x12,0xF2,0x12,0x92,0x12,0x92,0x14,0xF2,0x14,0x02,0x18,0x3C,0x10,0x08},
{0xAB,0x5E,0x00,0x00,0x00,0x82,0x7F,0xFF,0x00,0x00,0x0C,0x38,0x08,0x08,0x1F,0xF4,0x68,0x14,0x08,0x12,0x08,0x11,0x0F,0xF0,0x02,0x40,0x02,0x42,0x04,0x42,0x08,0x43,0x70,0x3E},
{0xAB,0x5F,0x00,0x00,0x3F,0xFC,0x20,0x04,0x2F,0xF4,0x20,0x04,0x2F,0xF4,0x20,0x04,0x00,0x00,0x0F,0xF0,0x08,0x10,0x0F,0xF0,0x08,0x10,0x0F,0xF0,0x08,0x10,0x0F,0xF0,0x08,0x10},
{0xAB,0x60,0x00,0x00,0x01,0x00,0x3F,0xFC,0x21,0x04,0x3F,0xFC,0x21,0x04,0x3F,0xFC,0x00,0x00,0x1F,0xF8,0x10,0x08,0x17,0xE8,0x10,0x08,0x17,0xE8,0x10,0x08,0x10,0x78,0x10,0x10},
{0xAB,0x61,0x00,0x00,0x20,0x04,0x3F,0xFE,0x40,0x04,0x44,0x08,0x3E,0x08,0x00,0x0A,0x02,0x7F,0x7F,0x08,0x14,0x48,0x14,0x28,0x14,0x08,0x14,0x3A,0x24,0x12,0x24,0x03,0x43,0xFE},
{0xAB,0x62,0x00,0x00,0x30,0xC3,0x09,0x02,0x06,0x1A,0x19,0x92,0x60,0x92,0x06,0x12,0x04,0x92,0x7F,0xD2,0x0C,0x12,0x14,0x12,0x16,0x12,0x25,0x82,0x44,0x92,0x04,0x0E,0x04,0x04},
{0xAB,0x63,0x00,0x00,0x31,0x83,0x0A,0x1A,0x7F,0x92,0x04,0x92,0x24,0x92,0x3F,0x92,0x24,0x12,0x24,0x12,0x7F,0xD2,0x4C,0x52,0x14,0x42,0x15,0xC2,0x24,0x92,0x44,0x0E,0x04,0x04},
{0xAB,0x64,0x00,0x00,0x04,0x03,0x15,0x1A,0x14,0x92,0x24,0xD2,0x44,0x52,0x3F,0x92,0x20,0x92,0x3F,0x92,0x20,0x92,0x20,0x92,0x3F,0x92,0x20,0x82,0x20,0x82,0x23,0x8E,0x21,0x04},
{0xAB,0x65,0x00,0x00,0x18,0x30,0x04,0x42,0x7F,0xFF,0x00,0x00,0x21,0x36,0x3F,0xA4,0x21,0x24,0x3F,0x24,0x21,0x24,0x3F,0x24,0x21,0x24,0x21,0x24,0x21,0x04,0x2F,0x1C,0x22,0x08},
{0xAB,0x66,0x00,0x00,0x06,0x03,0x04,0x9A,0x7F,0xD2,0x04,0x12,0x3F,0x92,0x24,0x92,0x24,0x92,0x3F,0x92,0x0C,0x12,0x16,0x12,0x15,0x02,0x24,0x82,0x44,0x92,0x04,0x0E,0x04,0x04},
{0xAB,0x67,0x00,0x00,0x06,0x06,0x04,0x34,0x7F,0xA4,0x04,0x24,0x04,0x24,0x3F,0xA4,0x20,0xA4,0x20,0xA4,0x3F,0xA4,0x12,0x24,0x12,0x04,0x12,0x1D,0x22,0x09,0x22,0x01,0x41,0xFF},
{0xAB,0x68,0x00,0x00,0x21,0x03,0x3F,0x82,0x21,0x1A,0x21,0x12,0x3F,0x12,0x21,0x12,0x3F,0x12,0x21,0x12,0x21,0x12,0x3F,0x12,0x21,0x02,0x00,0x02,0x1A,0x12,0x21,0x8E,0x40,0x84},
{0xAB,0x69,0x00,0x00,0x00,0x10,0x3F,0xF8,0x02,0x20,0x01,0x40,0x1F,0xFC,0x10,0x84,0x1F,0xFC,0x10,0x84,0x1F,0xFC,0x01,0x00,0x7F,0xFE,0x02,0x02,0x04,0x02,0x18,0x3C,0x60,0x10},
{0xAB,0x6A,0x00,0x00,0x18,0x18,0x12,0x10,0x1F,0x12,0x12,0x7F,0x24,0x12,0x7F,0x92,0x24,0x92,0x24,0xA2,0x3F,0xA2,0x0A,0x22,0x0A,0x44,0x12,0x5D,0x12,0x89,0x22,0x01,0x41,0xFF},
{0xAB,0x6B,0x00,0x00,0x06,0x18,0x04,0x10,0x7F,0x92,0x04,0x7F,0x3F,0x92,0x40,0x92,0x3F,0x12,0x02,0x12,0x04,0x22,0x07,0xA2,0x7C,0x22,0x24,0x42,0x04,0x42,0x1C,0x9C,0x09,0x08},
{0xAB,0x6C,0x00,0x00,0x01,0x18,0x7F,0x90,0x29,0x12,0x29,0x7F,0x52,0x12,0x29,0x12,0x29,0x12,0x00,0x12,0x7F,0x92,0x08,0x22,0x09,0xA2,0x0E,0x22,0x78,0x42,0x20,0x5C,0x00,0x88},
{0xAB,0x6D,0x00,0x00,0x0C,0x00,0x08,0x02,0x1F,0xFF,0x11,0x22,0x2F,0xF2,0x41,0x02,0x0F,0xE2,0x09,0x22,0x0F,0xE2,0x09,0x22,0x0F,0xE2,0x09,0x22,0x09,0x62,0x09,0x2E,0x00,0x04},
{0xAB,0x6E,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x80,0x20,0x82,0x3F,0xFF,0x24,0x12,0x22,0x22,0x2F,0xFA,0x20,0x82,0x27,0xF2,0x20,0x82,0x20,0x82,0x20,0x8E,0x20,0x04},
{0xAB,0x6F,0x00,0x00,0x1A,0x00,0x11,0x22,0x20,0xBF,0x4C,0xA2,0x0A,0x22,0x11,0x22,0x21,0xA2,0x40,0xA2,0x3F,0x22,0x21,0x22,0x21,0x22,0x21,0x2E,0x3F,0x24,0x21,0x20,0x00,0x20},
{0xAB,0x70,0x00,0x00,0x1F,0xFF,0x10,0x00,0x13,0xFC,0x12,0x04,0x13,0xFC,0x12,0x04,0x13,0xFC,0x10,0x00,0x17,0xFC,0x10,0x08,0x10,0x12,0x2F,0xFF,0x20,0x20,0x21,0xE0,0x40,0x40},
{0xAB,0x71,0x00,0x00,0x08,0x82,0x2C,0xFF,0x2A,0x80,0x4A,0x80,0x08,0x82,0x7E,0xFF,0x08,0xA2,0x0A,0xA2,0x0C,0x94,0x78,0x94,0x48,0x88,0x11,0x14,0x11,0x12,0x21,0x22,0x42,0x41},
{0xAB,0x72,0x00,0x00,0x00,0x30,0x48,0x22,0x7B,0xFF,0x48,0x00,0x48,0xCC,0x49,0x83,0x4A,0x01,0x48,0xCC,0x49,0x48,0x79,0x48,0x48,0x30,0x00,0x20,0x00,0x50,0x01,0x8C,0x06,0x03},
{0xAB,0x73,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x00,0x00,0x1F,0xF8,0x10,0x08,0x10,0x08,0x1F,0xF8,0x02,0x80,0x04,0x46,0x1C,0x58,0x64,0x20,0x07,0x98,0x3C,0x07,0x10,0x02},
{0xAB,0x74,0x00,0x00,0x00,0x60,0x08,0x42,0x7C,0xFF,0x00,0x92,0x01,0x10,0x04,0x28,0x18,0x28,0x60,0xC4,0x43,0x03,0x00,0x00,0x1F,0xF8,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08},
{0xAB,0x75,0x00,0x00,0x00,0xCC,0x48,0x88,0x7B,0xFF,0x48,0x88,0x48,0x88,0x48,0x00,0x49,0x86,0x4A,0x84,0x4A,0x48,0x78,0x48,0x48,0x30,0x00,0x28,0x00,0x48,0x00,0x84,0x03,0x03},
{0xAB,0x76,0x00,0x00,0x06,0x60,0x04,0x48,0x3F,0x46,0x04,0x42,0x04,0x40,0x7F,0xFF,0x00,0x40,0x00,0x46,0x3F,0x24,0x21,0x28,0x21,0x28,0x3F,0x12,0x00,0x2A,0x00,0xC7,0x03,0x02},
{0xAB,0x77,0x00,0x00,0x00,0x68,0x00,0x46,0x20,0x40,0x3F,0xFF,0x20,0x40,0x2F,0xA0,0x20,0x26,0x2F,0xA4,0x28,0xA8,0x28,0x90,0x2F,0x90,0x28,0x29,0x40,0xC9,0x47,0x05,0x40,0x03},
{0xAB,0x78,0x00,0x00,0x00,0x30,0x48,0x22,0x7B,0xFF,0x48,0x20,0x4B,0xFE,0x48,0x22,0x49,0xFE,0x49,0x20,0x7B,0xFF,0x4A,0x21,0x42,0x57,0x00,0x52,0x00,0x88,0x01,0x04,0x06,0x03},
{0xAB,0x79,0x00,0x00,0x00,0x30,0x48,0x22,0x7B,0xFF,0x48,0x20,0x48,0x40,0x49,0x8C,0x48,0x58,0x48,0x30,0x48,0x26,0x78,0xC4,0x4B,0x08,0x40,0x18,0x00,0x24,0x00,0xC6,0x03,0x02},
{0xAB,0x7A,0x00,0x00,0x00,0x30,0x48,0x20,0x7D,0xFE,0x48,0x20,0x48,0x22,0x4B,0xFF,0x48,0x00,0x48,0x30,0x48,0x24,0x7B,0xFE,0x48,0x20,0x40,0x20,0x00,0x22,0x07,0xFF,0x00,0x00},
{0xAB,0x7B,0x00,0x00,0x00,0x02,0x4B,0xFF,0x78,0x50,0x48,0x50,0x4A,0x51,0x4B,0xFF,0x4A,0x51,0x4A,0x51,0x4A,0x55,0x7A,0x95,0x4B,0x0D,0x42,0x01,0x02,0x01,0x03,0xFF,0x02,0x01},
{0xAB,0x7C,0x00,0x00,0x02,0x02,0x4B,0xFF,0x7A,0x02,0x4A,0x32,0x4A,0x22,0x4A,0xFA,0x4A,0x22,0x4A,0x22,0x4A,0x52,0x7A,0x52,0x4A,0x4A,0x42,0x8A,0x02,0x02,0x03,0xFE,0x02,0x02},
{0xAB,0x7D,0x00,0x00,0x00,0x30,0x4A,0x26,0x79,0x24,0x49,0xA4,0x48,0xA8,0x48,0x22,0x4B,0xFF,0x48,0x60,0x48,0xB0,0x78,0xA8,0x49,0x28,0x41,0x24,0x02,0x23,0x00,0x20,0x00,0x20},
{0xAB,0x7E,0x00,0x00,0x08,0x10,0x0F,0xF8,0x08,0x10,0x08,0x10,0x08,0x10,0x0F,0xF0,0x08,0x10,0x42,0x42,0x7F,0x7F,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x7E,0x7E,0x42,0x42},
{0xAB,0xA1,0x00,0x00,0x00,0xCC,0x48,0x88,0x78,0x88,0x4B,0xFE,0x48,0x88,0x48,0x88,0x48,0x88,0x48,0x88,0x48,0x8A,0x7B,0xFF,0x48,0x00,0x41,0x90,0x01,0x0C,0x02,0x06,0x0C,0x02},
{0xAB,0xA2,0x00,0x00,0x00,0x60,0x00,0x50,0x48,0x90,0x7C,0x88,0x49,0x04,0x4A,0xFB,0x4C,0x00,0x48,0x00,0x49,0x04,0x49,0xFE,0x79,0x04,0x49,0x04,0x41,0x04,0x01,0xFC,0x01,0x04},
{0xAB,0xA3,0x00,0x00,0x00,0xC0,0x48,0x84,0x7C,0xFE,0x48,0x84,0x49,0x88,0x4A,0x48,0x48,0x30,0x48,0x4C,0x49,0x83,0x7A,0xFC,0x48,0x84,0x40,0x84,0x00,0x84,0x00,0xFC,0x00,0x84},
{0xAB,0xA4,0x00,0x00,0x21,0x42,0x3F,0x7F,0x21,0x42,0x21,0x42,0x3F,0x42,0x29,0x7E,0x28,0x00,0x28,0x34,0x24,0x22,0x24,0x23,0x22,0x41,0x21,0x00,0x20,0xC0,0x40,0x38,0x40,0x07},
{0xAB,0xA5,0x00,0x00,0x00,0x30,0x00,0x20,0x49,0x42,0x7D,0xFF,0x49,0x02,0x49,0x02,0x49,0xFE,0x49,0x02,0x49,0x02,0x79,0xFE,0x49,0x02,0x41,0x02,0x01,0x02,0x01,0xFE,0x01,0x02},
{0xAB,0xA6,0x00,0x00,0x01,0x98,0x51,0x10,0x79,0x10,0x52,0x12,0x52,0xFF,0x56,0x10,0x5A,0x30,0x52,0x38,0x52,0x54,0x72,0x54,0x52,0x92,0x43,0x11,0x02,0x10,0x02,0x10,0x02,0x10},
{0xAB,0xA7,0x00,0x00,0x01,0x0C,0x48,0x88,0x78,0x90,0x4B,0xFE,0x48,0x20,0x48,0x24,0x4B,0xFE,0x48,0x20,0x48,0x22,0x7B,0xFF,0x48,0x20,0x40,0x20,0x00,0x20,0x00,0x20,0x00,0x20},
{0xAB,0xA8,0x00,0x00,0x00,0x43,0x07,0xE2,0x52,0x0A,0x7A,0x4A,0x53,0xEA,0x52,0x4A,0x52,0x4A,0x55,0x4A,0x55,0x4A,0x58,0x8A,0x70,0x82,0x51,0x02,0x01,0x02,0x02,0x0E,0x04,0x04},
{0xAB,0xA9,0x00,0x00,0x01,0x80,0x51,0x04,0x72,0xFE,0x52,0x24,0x56,0x24,0x5A,0xFF,0x52,0x24,0x52,0x24,0x52,0xFC,0x72,0x24,0x52,0x20,0x42,0x20,0x02,0x40,0x02,0x40,0x02,0x80},
{0xAB,0xAA,0x00,0x00,0x20,0x02,0x3F,0xFF,0x20,0x02,0x21,0x02,0x2F,0xFA,0x22,0x02,0x23,0xF2,0x26,0x12,0x2B,0xF2,0x22,0x12,0x23,0xF2,0x22,0x12,0x22,0x32,0x20,0x02,0x3F,0xFE},
{0xAB,0xAB,0x00,0x00,0x00,0x18,0x00,0xFC,0x3F,0x80,0x00,0x80,0x00,0x84,0x3F,0xFE,0x08,0x88,0x08,0x8A,0x7F,0xFF,0x08,0x88,0x08,0x88,0x3F,0xFE,0x00,0x80,0x00,0x82,0x7F,0xFF},
{0xAB,0xAC,0x00,0x00,0x01,0x06,0x7F,0xB4,0x12,0x24,0x12,0x24,0x7F,0xA4,0x12,0x24,0x22,0x04,0x22,0x1C,0x42,0x08,0x00,0xC0,0x00,0x88,0x1F,0xFC,0x00,0x80,0x00,0x82,0x7F,0xFF},
{0xAB,0xAD,0x00,0x00,0x19,0x04,0x11,0xFE,0x11,0x04,0x11,0x04,0x7D,0xFC,0x11,0x04,0x11,0x04,0x11,0xFC,0x15,0x20,0x19,0x23,0x71,0x12,0x21,0x14,0x01,0xC8,0x07,0x07,0x02,0x02},
{0xAB,0xAE,0x00,0x00,0x18,0x04,0x13,0xFE,0x10,0x00,0x11,0x04,0x7D,0xFE,0x11,0x04,0x11,0x04,0x11,0xFC,0x15,0x04,0x19,0x04,0x71,0xFC,0x21,0x04,0x00,0x00,0x00,0x02,0x07,0xFF},
{0xAB,0xAF,0x00,0x00,0x19,0x1E,0x11,0xE0,0x11,0x00,0x11,0x02,0x7D,0xFF,0x11,0x00,0x11,0x00,0x11,0x42,0x11,0x7F,0x15,0x42,0x19,0x42,0x72,0x42,0x22,0x42,0x02,0x7E,0x04,0x42},
{0xAB,0xB0,0x00,0x00,0x30,0x1A,0x20,0x11,0x22,0x10,0x23,0xFF,0x7A,0x10,0x22,0x50,0x23,0xEB,0x22,0x4A,0x22,0x4A,0x3A,0x4C,0x63,0xC9,0x22,0x95,0x04,0x15,0x04,0x23,0x08,0x41},
{0xAB,0xB1,0x00,0x00,0x18,0x30,0x10,0x22,0x13,0xFF,0x10,0x50,0x7C,0x88,0x11,0x04,0x16,0xFB,0x10,0x00,0x13,0xFE,0x14,0x40,0x18,0xFC,0x70,0x84,0x20,0x04,0x00,0x08,0x00,0x30},
{0xAB,0xB2,0x00,0x00,0x18,0x30,0x10,0x22,0x11,0xFF,0x10,0x20,0x7C,0x40,0x11,0x8C,0x10,0x58,0x10,0x30,0x14,0x26,0x18,0x44,0x71,0x88,0x20,0x18,0x00,0x24,0x00,0x46,0x01,0x82},
{0xAB,0xB3,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x02,0x20,0x1A,0x28,0x12,0x26,0x24,0xE2,0x44,0x40,0x08,0x80,0x00,0x82,0x7F,0xFF,0x01,0x40,0x02,0x30,0x0C,0x0C,0x70,0x03},
{0xAB,0xB4,0x00,0x00,0x08,0x02,0x7E,0xFF,0x08,0x22,0x7E,0x22,0x08,0x22,0x0F,0x42,0x78,0x4E,0x08,0x84,0x08,0x00,0x00,0x82,0x7F,0xFF,0x01,0x40,0x02,0x30,0x0C,0x0C,0x70,0x03},
{0xAB,0xB5,0x00,0x00,0x01,0x80,0x01,0x00,0x3F,0xFE,0x01,0x00,0x1F,0xFC,0x02,0x20,0x7F,0xFF,0x08,0x08,0x17,0xF4,0x60,0x83,0x1F,0xFC,0x01,0x40,0x02,0x30,0x0C,0x0C,0x30,0x04},
{0xAB,0xB6,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x01,0x40,0x06,0x30,0x18,0xCC,0x60,0x83,0x0F,0xF8,0x00,0x80,0x3F,0xFE,0x00,0x00,0x00,0x80,0x0F,0xF8,0x00,0x82,0x7F,0xFF},
{0xAB,0xB7,0x00,0x00,0x06,0x00,0x04,0x40,0x0F,0xE0,0x08,0x80,0x11,0x04,0x3F,0xFE,0x51,0x44,0x11,0x54,0x12,0x34,0x14,0x84,0x7F,0xFF,0x01,0x40,0x02,0x30,0x0C,0x0F,0x70,0x02},
{0xAB,0xB8,0x00,0x00,0x0C,0x30,0x02,0x44,0x3F,0xFE,0x00,0x80,0x0F,0xF8,0x00,0x80,0x3F,0xFE,0x00,0x00,0x01,0x00,0x7F,0xFF,0x02,0x10,0x0C,0x20,0x03,0xC0,0x0C,0x30,0x70,0x0E},
{0xAB,0xB9,0x00,0x00,0x30,0x33,0x20,0x22,0x24,0x44,0x7D,0xEF,0x24,0x44,0x24,0x44,0x24,0x54,0x24,0x64,0x65,0xDF,0x59,0x44,0x08,0x44,0x14,0x44,0x14,0x84,0x20,0x84,0x41,0x04},
{0xAB,0xBA,0x00,0x00,0x00,0x60,0x08,0x42,0x7C,0xFF,0x00,0x92,0x01,0x10,0x0C,0x28,0x70,0x44,0x21,0x83,0x02,0x00,0x7F,0xFF,0x02,0x10,0x0C,0x20,0x03,0xC0,0x0C,0x30,0x70,0x0E},
{0xAB,0xBB,0x00,0x00,0x30,0x30,0x20,0x22,0x25,0xFF,0x7C,0x00,0x24,0xC4,0x24,0x83,0x25,0x01,0x24,0x66,0x64,0xA4,0x58,0x28,0x08,0x18,0x14,0x10,0x14,0x28,0x20,0x44,0x41,0x83},
{0xAB,0xBC,0x00,0x00,0x30,0x18,0x20,0x12,0x25,0xFF,0x7E,0x10,0x24,0xFE,0x24,0x12,0x24,0xFE,0x24,0x90,0x65,0xFF,0x59,0x11,0x08,0x29,0x14,0x2A,0x14,0x48,0x20,0x44,0x41,0x83},
{0xAB,0xBD,0x00,0x00,0x30,0x30,0x20,0x20,0x25,0xFC,0x7C,0x20,0x24,0x24,0x27,0xFE,0x24,0x00,0x24,0x30,0x64,0x24,0x59,0xFE,0x08,0x20,0x14,0x20,0x14,0x22,0x23,0xFF,0x40,0x00},
{0xAB,0xBE,0x00,0x00,0x30,0x30,0x20,0x20,0x24,0x23,0x7E,0xFA,0x24,0x22,0x24,0x24,0x25,0xFF,0x24,0x10,0x68,0x20,0x58,0xC6,0x0B,0x58,0x14,0x60,0x14,0x42,0x20,0x43,0x40,0x3E},
{0xAB,0xBF,0x00,0x00,0x30,0x02,0x23,0xFF,0x20,0x20,0x7E,0x28,0x24,0x44,0x24,0x44,0x25,0xFA,0x24,0x82,0x64,0x30,0x58,0x24,0x09,0xFE,0x14,0x20,0x14,0x22,0x23,0xFF,0x40,0x00},
{0xAB,0xC0,0x00,0x00,0x30,0x50,0x20,0x50,0x24,0x50,0x7D,0x56,0x25,0x54,0x24,0xD8,0x24,0x50,0x24,0x50,0x64,0xD8,0x59,0x56,0x09,0x52,0x14,0x50,0x14,0x91,0x20,0x91,0x41,0x0F},
{0xAB,0xC1,0x00,0x00,0x03,0x00,0x02,0x04,0x7F,0xFE,0x04,0x10,0x1C,0x60,0x03,0x80,0x0C,0x70,0x70,0x0C,0x08,0x10,0x7F,0x7F,0x12,0x12,0x64,0x64,0x18,0x18,0x16,0x16,0x62,0x61},
{0xAB,0xC2,0x00,0x00,0x00,0x68,0x00,0x46,0x20,0x40,0x3F,0xFF,0x20,0x20,0x2F,0xA0,0x22,0x26,0x2F,0xA4,0x24,0xA8,0x2D,0x28,0x22,0x10,0x25,0x11,0x48,0xA9,0x40,0x45,0x41,0x83},
{0xAB,0xC3,0x00,0x00,0x31,0x01,0x21,0xFF,0x25,0x01,0x7D,0x19,0x25,0x11,0x25,0x7D,0x25,0x11,0x25,0x11,0x65,0x29,0x59,0x29,0x09,0x25,0x15,0x45,0x15,0x01,0x21,0xFF,0x41,0x01},
{0xAB,0xC4,0x00,0x00,0x02,0x18,0x7F,0x10,0x02,0x12,0x05,0xFF,0x0C,0x10,0x08,0x26,0x0A,0xC4,0x0C,0x28,0x18,0x10,0x68,0x66,0x49,0x84,0x08,0x08,0x48,0x14,0x38,0x63,0x11,0x81},
{0xAB,0xC5,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x40,0x04,0x1F,0xFC,0x00,0x00,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x00,0x02,0x7F,0xFF},
{0xAB,0xC6,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x40,0x02,0x50,0x04,0x1F,0xFC,0x10,0x80,0x10,0x88,0x1F,0xFC,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x88,0x10,0x80,0x1F,0xFE},
{0xAB,0xC7,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x40,0x04,0x1F,0xFC,0x02,0x00,0x04,0x10,0x1F,0xEC,0x08,0x84,0x00,0x80,0x1F,0xF8,0x00,0x80,0x00,0x84,0x7F,0xFE},
{0xAB,0xC8,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x21,0x02,0x41,0xF4,0x06,0x10,0x19,0x20,0x00,0xC0,0x03,0x30,0x0C,0x0C,0x77,0xFB,0x04,0x08,0x04,0x08,0x07,0xF8,0x04,0x08},
{0xAB,0xC9,0x00,0x00,0x00,0xC0,0x20,0x84,0x3F,0xFE,0x42,0x04,0x42,0x08,0x3F,0xFE,0x04,0x00,0x0F,0xF8,0x14,0x08,0x67,0xF8,0x04,0x08,0x07,0xF8,0x04,0x08,0x04,0x38,0x04,0x10},
{0xAB,0xCA,0x00,0x00,0x06,0x06,0x04,0x04,0x3F,0x04,0x04,0x04,0x04,0x7F,0x7F,0x84,0x00,0x04,0x04,0x24,0x3F,0x24,0x04,0x14,0x04,0x14,0x07,0x84,0x7C,0x24,0x20,0x1C,0x00,0x08},
{0xAB,0xCB,0x00,0x00,0x20,0x04,0x3F,0xFE,0x20,0x04,0x3F,0xFC,0x20,0x04,0x20,0x60,0x24,0x4C,0x23,0x48,0x21,0x52,0x2F,0xFF,0x20,0xE0,0x21,0x58,0x42,0x47,0x4C,0x42,0x40,0x40},
{0xAB,0xCC,0x00,0x00,0x20,0x04,0x3F,0xFE,0x20,0x04,0x3F,0xFC,0x20,0x04,0x26,0x18,0x21,0x20,0x2F,0xFE,0x21,0x10,0x21,0x12,0x2F,0xFF,0x22,0x10,0x42,0x10,0x44,0x10,0x58,0x10},
{0xAB,0xCD,0x00,0x00,0x20,0x04,0x3F,0xFE,0x20,0x04,0x3F,0xFC,0x20,0x04,0x20,0x00,0x3F,0xFF,0x22,0x00,0x24,0x30,0x27,0xA4,0x28,0xBE,0x35,0x20,0x42,0x21,0x44,0x21,0x58,0x1F},
{0xAB,0xCE,0x00,0x00,0x20,0x04,0x3F,0xFE,0x20,0x04,0x3F,0xFC,0x20,0x00,0x2F,0xFE,0x21,0x10,0x22,0x08,0x2F,0xF4,0x24,0x04,0x20,0x40,0x27,0xFC,0x40,0x40,0x40,0x42,0x5F,0xFF},
{0xAB,0xCF,0x00,0x00,0x18,0x30,0x10,0x24,0x11,0xFE,0x54,0x20,0x54,0x22,0x57,0xFF,0x54,0x08,0x54,0x0A,0x57,0xFF,0x54,0x08,0x7D,0x08,0x44,0x88,0x40,0x88,0x00,0x38,0x00,0x10},
{0xAB,0xD0,0x00,0x00,0x19,0x02,0x11,0xFF,0x11,0x02,0x55,0x7A,0x55,0x02,0x55,0x4A,0x55,0x7A,0x55,0x4A,0x55,0x4A,0x55,0x7A,0x7D,0x4A,0x45,0x02,0x41,0x02,0x01,0x0E,0x01,0x04},
{0xAB,0xD1,0x00,0x00,0x06,0x30,0x04,0x20,0x3F,0xFC,0x04,0x20,0x04,0x22,0x7F,0xFF,0x04,0x10,0x08,0x08,0x1F,0xF4,0x68,0x13,0x08,0x10,0x0F,0xF4,0x08,0x04,0x08,0x06,0x07,0xFC},
{0xAB,0xD2,0x00,0x00,0x00,0xC0,0x00,0x84,0x3F,0xFE,0x04,0x10,0x22,0x22,0x3F,0xFF,0x20,0x02,0x40,0xC0,0x08,0x88,0x0F,0xFC,0x08,0x88,0x08,0x88,0x08,0xB8,0x08,0x90,0x00,0x80},
{0xAB,0xD3,0x00,0x00,0x0C,0x18,0x50,0x10,0x7E,0x92,0x42,0xFF,0x42,0x92,0x7E,0x92,0x42,0x92,0x40,0x92,0x7E,0x92,0x42,0x92,0x42,0x92,0x7E,0x9E,0x42,0x94,0x00,0x10,0x00,0x10},
{0xAB,0xD4,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x02,0x20,0x1A,0x28,0x12,0x26,0x24,0xE2,0x48,0x40,0x00,0x80,0x1F,0xFC,0x10,0x84,0x10,0x84,0x10,0x9C,0x10,0x88,0x00,0x80},
{0xAB,0xD5,0x00,0x00,0x00,0xC0,0x0C,0x98,0x68,0x93,0x48,0x92,0x50,0xA2,0x76,0xEE,0x54,0xAA,0x48,0x92,0x48,0x92,0x54,0xAA,0x5A,0xB6,0x50,0xA2,0x40,0x82,0x7F,0xFE,0x40,0x02},
{0xAB,0xD6,0x00,0x00,0x00,0x60,0x20,0x42,0x3F,0xFF,0x22,0x08,0x21,0x10,0x2F,0xFE,0x20,0x40,0x20,0x48,0x27,0xFC,0x20,0x40,0x20,0x42,0x2F,0xFF,0x40,0x40,0x40,0x40,0x40,0x40},
{0xAB,0xD7,0x00,0x00,0x00,0x60,0x10,0x42,0x1F,0xFF,0x10,0x00,0x11,0x0A,0x1F,0xFF,0x11,0x08,0x11,0xF8,0x10,0x00,0x17,0xFC,0x11,0x08,0x20,0x90,0x20,0x60,0x21,0x98,0x4E,0x07},
{0xAB,0xD8,0x00,0x00,0x08,0x20,0x7D,0xFC,0x08,0x24,0x0B,0xFF,0x10,0x24,0x21,0xFC,0x7C,0x20,0x45,0xFC,0x04,0x20,0x68,0x24,0x5B,0xFE,0x48,0x20,0x14,0x20,0x13,0x03,0x20,0xFC},
{0xAB,0xD9,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x02,0x20,0x1A,0x28,0x12,0x26,0x24,0xE2,0x48,0x40,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x04,0x20,0x08,0x20,0x30,0x20},
{0xAB,0xDA,0x00,0x00,0x04,0x02,0x7E,0xFF,0x04,0x44,0x24,0x44,0x3C,0x7C,0x24,0x44,0x20,0x44,0x44,0x7C,0x7E,0x44,0x44,0x47,0x04,0x5C,0x05,0xE4,0x44,0x84,0x38,0x04,0x10,0x04},
{0xAB,0xDB,0x00,0x00,0x00,0x88,0x3F,0xFC,0x04,0x20,0x03,0xC0,0x02,0x20,0x2C,0x12,0x3F,0xFF,0x20,0x00,0x20,0x38,0x21,0xC0,0x2E,0x1C,0x20,0xE0,0x4F,0x0E,0x40,0x70,0x4F,0x80},
{0xAB,0xDC,0x00,0x00,0x0D,0x04,0x09,0xFE,0x11,0x04,0x21,0x04,0x4D,0xFC,0x09,0x04,0x11,0x04,0x31,0xFC,0x51,0x24,0x11,0x20,0x11,0x13,0x11,0x14,0x11,0x68,0x17,0x87,0x12,0x02},
{0xAB,0xDD,0x00,0x00,0x0C,0x30,0x08,0x20,0x11,0xFE,0x20,0x20,0x4C,0x22,0x0B,0xFF,0x10,0x08,0x30,0x0A,0x53,0xFF,0x10,0x08,0x12,0x08,0x11,0x88,0x10,0x88,0x10,0x38,0x10,0x10},
{0xAB,0xDE,0x00,0x00,0x0C,0x00,0x09,0x02,0x11,0xFF,0x21,0x02,0x4D,0x02,0x09,0x4A,0x11,0x7A,0x31,0x4A,0x51,0x4A,0x11,0x7A,0x11,0x4A,0x11,0x02,0x11,0x02,0x11,0xFE,0x11,0x02},
{0xAB,0xDF,0x00,0x00,0x18,0x30,0x10,0x24,0x21,0xFE,0x2C,0x24,0x4B,0xFF,0x10,0x24,0x11,0xFC,0x30,0x24,0x50,0x20,0x11,0xFE,0x10,0x20,0x13,0xFF,0x10,0x20,0x10,0x20,0x10,0x20},
{0xAB,0xE0,0x00,0x00,0x18,0xC0,0x10,0x80,0x20,0x82,0x2D,0xFF,0x49,0x02,0x12,0x02,0x15,0xF2,0x31,0x12,0x51,0xF2,0x11,0x12,0x11,0xF2,0x11,0x12,0x10,0x02,0x10,0x3C,0x10,0x08},
{0xAB,0xE1,0x00,0x00,0x18,0x30,0x10,0x60,0x21,0x8C,0x2C,0x50,0x48,0x20,0x10,0x44,0x13,0xFB,0x31,0x41,0x50,0x44,0x10,0x7E,0x10,0x84,0x13,0x48,0x10,0x30,0x10,0x6C,0x13,0x83},
{0xAB,0xE2,0x00,0x00,0x19,0x06,0x10,0xC4,0x20,0x48,0x2B,0xFE,0x48,0x20,0x10,0x24,0x33,0xFE,0x50,0x20,0x10,0x20,0x10,0x22,0x17,0xFF,0x10,0x20,0x10,0x20,0x10,0x20,0x10,0x20},
{0xAB,0xE3,0x00,0x00,0x18,0x02,0x11,0x7F,0x7F,0x42,0x11,0x22,0x12,0x14,0x2C,0x08,0x0A,0x14,0x11,0x63,0x60,0x00,0x0D,0x04,0x28,0xC2,0x28,0x53,0x48,0x11,0x48,0x18,0x07,0xF0},
{0xAB,0xE4,0x00,0x00,0x10,0x08,0x1F,0xFC,0x11,0x08,0x11,0x08,0x1F,0xF8,0x11,0x08,0x11,0x08,0x1F,0xF8,0x10,0x08,0x01,0x00,0x2C,0xC4,0x28,0x52,0x48,0x13,0x48,0x19,0x07,0xF0},
{0xAB,0xE5,0x00,0x00,0x03,0x20,0x04,0x10,0x7F,0xEC,0x20,0x04,0x00,0x00,0x1F,0xF8,0x10,0x08,0x10,0x08,0x1F,0xF8,0x01,0x00,0x2C,0xC4,0x28,0x52,0x48,0x13,0x48,0x19,0x07,0xF0},
{0xAB,0xE6,0x00,0x00,0x04,0x00,0x07,0xE0,0x08,0x40,0x10,0x88,0x6F,0xFC,0x00,0x08,0x7F,0xFE,0x00,0x08,0x1F,0xF8,0x00,0x08,0x0D,0x00,0x28,0x92,0x28,0x93,0x48,0x19,0x07,0xF0},
{0xAB,0xE7,0x00,0x00,0x0C,0x00,0x08,0x04,0x1F,0xFE,0x12,0x00,0x23,0xF8,0x42,0x00,0x03,0xFC,0x02,0x00,0x02,0x00,0x01,0x00,0x2C,0xC4,0x28,0x52,0x48,0x13,0x48,0x19,0x07,0xF0},
{0xAB,0xE8,0x00,0x00,0x0C,0x00,0x09,0x44,0x1F,0x7E,0x11,0x44,0x2A,0x44,0x4A,0x58,0x04,0x42,0x08,0x43,0x30,0x3E,0x01,0x00,0x2C,0xC4,0x28,0x52,0x48,0x13,0x48,0x19,0x07,0xF0},
{0xAB,0xE9,0x00,0x00,0x18,0x30,0x10,0x20,0x12,0x23,0x19,0x26,0x55,0xA4,0x54,0xA8,0x50,0x22,0x17,0xFF,0x10,0x90,0x10,0x90,0x10,0x90,0x11,0x12,0x11,0x12,0x12,0x13,0x14,0x0E},
{0xAB,0xEA,0x00,0x00,0x18,0x20,0x10,0x60,0x10,0x50,0x18,0x88,0x54,0x88,0x55,0x04,0x52,0xFA,0x14,0x01,0x11,0x04,0x11,0xFE,0x11,0x04,0x11,0x04,0x11,0x04,0x11,0xFC,0x11,0x04},
{0xAB,0xEB,0x00,0x00,0x19,0x04,0x11,0xFE,0x11,0x04,0x19,0x04,0x55,0xFC,0x55,0x04,0x51,0x04,0x11,0xFC,0x11,0x24,0x11,0x20,0x11,0x13,0x11,0x14,0x11,0x68,0x17,0x87,0x12,0x02},
{0xAB,0xEC,0x00,0x00,0x18,0x60,0x10,0x40,0x10,0x42,0x17,0xFF,0x58,0x80,0x54,0x98,0x55,0x10,0x11,0x56,0x12,0x58,0x12,0x90,0x14,0x28,0x10,0x28,0x10,0x44,0x10,0x44,0x11,0x83},
{0xAB,0xED,0x00,0x00,0x18,0x04,0x13,0xFE,0x10,0x80,0x18,0x80,0x54,0x88,0x55,0xFC,0x51,0x08,0x11,0x48,0x11,0x28,0x12,0x10,0x12,0x90,0x10,0x50,0x10,0x20,0x10,0x22,0x17,0xFF},
{0xAB,0xEE,0x00,0x00,0x18,0x30,0x10,0x20,0x19,0xFE,0x54,0x20,0x54,0x22,0x53,0xFF,0x10,0x08,0x10,0x0A,0x13,0xFF,0x10,0x08,0x12,0x08,0x11,0x88,0x10,0x88,0x10,0x38,0x10,0x10},
{0xAB,0xEF,0x00,0x00,0x18,0x0C,0x10,0x3E,0x13,0xE0,0x18,0x20,0x54,0x22,0x57,0xFF,0x54,0x20,0x10,0x20,0x11,0x24,0x11,0xFE,0x11,0x04,0x11,0x04,0x11,0x04,0x11,0xFC,0x11,0x04},
{0xAB,0xF0,0x00,0x00,0x19,0x02,0x11,0xFF,0x11,0x02,0x19,0x7A,0x55,0x02,0x55,0x4A,0x51,0x7A,0x11,0x4A,0x11,0x4A,0x11,0x7A,0x11,0x4A,0x11,0x02,0x11,0x02,0x11,0x0E,0x11,0x04},
{0xAB,0xF1,0x00,0x00,0x18,0xC0,0x10,0x84,0x18,0xFE,0x54,0x84,0x55,0x88,0x52,0x50,0x10,0x30,0x10,0xCC,0x17,0x03,0x11,0xFC,0x11,0x04,0x11,0x04,0x11,0x04,0x11,0xFC,0x11,0x04},
{0xAB,0xF2,0x00,0x00,0x18,0x00,0x10,0x30,0x10,0x20,0x19,0x44,0x55,0xFE,0x55,0x54,0x51,0x54,0x11,0x54,0x11,0x54,0x11,0x54,0x11,0x54,0x11,0x54,0x11,0x54,0x17,0xFF,0x10,0x00},
{0xAB,0xF3,0x00,0x00,0x20,0x7C,0x3F,0x80,0x20,0x04,0x3F,0xFE,0x20,0x04,0x3F,0xFC,0x20,0x00,0x28,0x02,0x2F,0xFF,0x29,0x22,0x2F,0xFE,0x29,0x22,0x49,0x22,0x49,0x2E,0x48,0x04},
{0xAB,0xF4,0x00,0x00,0x0E,0x04,0x78,0xFE,0x08,0x10,0x08,0x14,0x7E,0xFE,0x08,0x10,0x08,0x14,0x0A,0xFE,0x1C,0x10,0x68,0x12,0x49,0xFF,0x10,0x10,0x10,0x10,0x20,0x10,0x40,0x10},
{0xAB,0xF5,0x00,0x00,0x18,0x30,0x11,0x22,0x11,0xFF,0x7D,0x02,0x12,0xD8,0x10,0x91,0x15,0x0F,0x18,0x00,0x71,0xFC,0x50,0x08,0x10,0x30,0x10,0xC2,0x11,0x02,0x71,0x03,0x20,0xFE},
{0xAB,0xF6,0x00,0x00,0x18,0x30,0x11,0x22,0x11,0xFF,0x7D,0x02,0x12,0x64,0x10,0x40,0x13,0xFF,0x14,0x44,0x18,0x44,0x70,0x88,0x51,0x48,0x10,0x30,0x10,0x48,0x70,0x86,0x23,0x02},
{0xAB,0xF7,0x00,0x00,0x18,0x63,0x10,0x42,0x10,0x84,0x7B,0xDF,0x10,0x84,0x10,0x84,0x14,0xA4,0x18,0xC4,0x73,0x9F,0x52,0x84,0x10,0x84,0x10,0x84,0x11,0x04,0x71,0x04,0x22,0x04},
{0xAB,0xF8,0x00,0x00,0x18,0x18,0x10,0x12,0x10,0x11,0x7D,0xFF,0x10,0x08,0x10,0x08,0x15,0xE8,0x18,0x88,0x70,0x88,0x50,0xA8,0x10,0xC9,0x13,0x85,0x11,0x05,0x70,0x03,0x20,0x01},
{0xAB,0xF9,0x00,0x00,0x18,0x30,0x10,0x20,0x11,0xFE,0x7C,0x20,0x10,0x22,0x13,0xFF,0x14,0x08,0x18,0x0A,0x73,0xFF,0x50,0x08,0x12,0x08,0x11,0x88,0x10,0x88,0x70,0x38,0x20,0x10},
{0xAB,0xFA,0x00,0x00,0x18,0x30,0x10,0x20,0x10,0x22,0x7D,0xFF,0x10,0x20,0x10,0x24,0x15,0xFE,0x18,0x00,0x71,0x04,0x51,0xFE,0x11,0x04,0x11,0x04,0x11,0x04,0x71,0xFC,0x21,0x04},
{0xAB,0xFB,0x00,0x00,0x18,0x60,0x10,0x40,0x12,0x44,0x7F,0xFE,0x12,0x44,0x13,0xFC,0x16,0x44,0x1B,0xFC,0x72,0x40,0x50,0x26,0x10,0x28,0x10,0x11,0x10,0x69,0x73,0x85,0x20,0x03},
{0xAB,0xFC,0x00,0x00,0x19,0x80,0x11,0x0C,0x11,0x30,0x7D,0xC2,0x11,0x03,0x10,0xFE,0x14,0x00,0x19,0x04,0x71,0xFE,0x51,0x04,0x11,0xFC,0x11,0x04,0x11,0x04,0x71,0xFC,0x21,0x04},
{0xAB,0xFD,0x00,0x00,0x18,0xCC,0x10,0x88,0x10,0x88,0x7C,0x88,0x13,0xFE,0x10,0x88,0x14,0x88,0x18,0x88,0x70,0x8A,0x57,0xFF,0x10,0x00,0x10,0xC8,0x10,0x84,0x71,0x06,0x22,0x02},
{0xAB,0xFE,0x00,0x00,0x18,0x60,0x10,0x40,0x11,0xF6,0x7C,0x44,0x10,0x48,0x13,0xFF,0x14,0x20,0x18,0xFE,0x71,0x80,0x56,0xFC,0x10,0x84,0x10,0x04,0x10,0x04,0x70,0x78,0x20,0x10},
{0xAC,0x40,0x00,0x00,0x18,0x08,0x11,0xFC,0x10,0x08,0x7C,0x30,0x10,0x20,0x13,0xA6,0x10,0xB4,0x1D,0x28,0x71,0x28,0x52,0x24,0x14,0xE3,0x10,0x40,0x10,0x02,0x77,0xFF,0x20,0x00},
{0xAC,0x41,0x00,0x00,0x18,0x0C,0x10,0x3E,0x13,0xE0,0x7C,0x20,0x10,0x22,0x13,0xFF,0x14,0x20,0x18,0x20,0x71,0x24,0x51,0xFE,0x11,0x04,0x11,0x04,0x11,0x04,0x71,0xFC,0x21,0x04},
{0xAC,0x42,0x00,0x00,0x18,0x30,0x10,0x50,0x10,0x48,0x7C,0x88,0x10,0x84,0x11,0x12,0x12,0x79,0x10,0x00,0x1C,0x84,0x70,0xFE,0x50,0x84,0x10,0x84,0x10,0x84,0x70,0xFC,0x20,0x84},
{0xAC,0x43,0x00,0x00,0x18,0x20,0x13,0xF0,0x10,0x20,0x7C,0x50,0x11,0x8C,0x16,0x03,0x11,0xFC,0x14,0x20,0x18,0x20,0x70,0x24,0x53,0xFE,0x10,0x20,0x10,0x20,0x70,0x22,0x27,0xFF},
{0xAC,0x44,0x00,0x00,0x18,0x50,0x10,0x50,0x10,0x50,0x7D,0x56,0x11,0x54,0x10,0xD8,0x14,0x50,0x18,0x50,0x70,0xD8,0x53,0x56,0x12,0x52,0x10,0x50,0x10,0x91,0x70,0x91,0x21,0x0F},
{0xAC,0x45,0x00,0x00,0x18,0x30,0x10,0x20,0x11,0xFC,0x7C,0x20,0x10,0x22,0x13,0xFF,0x10,0x00,0x1C,0x30,0x70,0x24,0x51,0xFE,0x10,0x20,0x10,0x20,0x10,0x22,0x73,0xFF,0x20,0x00},
{0xAC,0x46,0x00,0x00,0x02,0x60,0x7F,0x40,0x08,0x42,0x08,0x7F,0x2A,0x44,0x2F,0x44,0x28,0xC4,0x29,0x28,0x28,0x28,0x2B,0x10,0x2C,0x10,0x78,0x28,0x20,0x24,0x00,0x47,0x01,0x82},
{0xAC,0x47,0x00,0x00,0x0C,0x60,0x08,0x40,0x0A,0x42,0x7F,0x7F,0x08,0x44,0x08,0x44,0x2A,0xC4,0x3E,0xA8,0x23,0x28,0x22,0x10,0x22,0x10,0x22,0x28,0x3E,0x24,0x22,0x47,0x00,0x82},
{0xAC,0x48,0x00,0x00,0x04,0x0C,0x7E,0x8E,0x10,0xF0,0x10,0x80,0x10,0x80,0x1E,0x82,0x32,0xFF,0x52,0x88,0x12,0x88,0x12,0x88,0x1E,0x88,0x12,0x88,0x11,0x08,0x01,0x08,0x02,0x08},
{0xAC,0x49,0x00,0x00,0x0C,0x60,0x08,0x40,0x08,0x42,0x7E,0xFF,0x20,0x80,0x25,0x24,0x3E,0xAE,0x24,0xF4,0x25,0xA4,0x24,0xAC,0x24,0xA4,0x24,0xA0,0x44,0x82,0x5C,0x83,0x48,0x7E},
{0xAC,0x4A,0x00,0x00,0x22,0x04,0x3E,0xFE,0x22,0x48,0x3E,0x48,0x22,0x48,0x22,0x48,0x3E,0x4A,0x22,0xFF,0x28,0x14,0x24,0x14,0x24,0x15,0x2E,0x25,0x72,0x25,0x20,0x45,0x00,0x83},
{0xAC,0x4B,0x00,0x00,0x00,0xC0,0x00,0x80,0x3F,0xFE,0x01,0x00,0x1F,0xFC,0x02,0x20,0x7F,0xFF,0x04,0x10,0x18,0x0C,0x67,0xF3,0x04,0x10,0x07,0xF0,0x04,0x10,0x07,0xF0,0x04,0x10},
{0xAC,0x4C,0x00,0x00,0x00,0x02,0x4B,0xFF,0x78,0x42,0x48,0x42,0x48,0x82,0x48,0x84,0x79,0x1C,0x4A,0x08,0x49,0x02,0x49,0xFF,0x79,0x02,0x49,0x02,0x41,0x02,0x01,0xFE,0x01,0x02},
{0xAC,0x4D,0x00,0x00,0x00,0x30,0x48,0x20,0x7D,0x24,0x49,0xFE,0x49,0x24,0x49,0x24,0x79,0x24,0x49,0x24,0x4F,0xFF,0x48,0x50,0x78,0x50,0x48,0x88,0x00,0x88,0x03,0x07,0x0C,0x02},
{0xAC,0x4E,0x00,0x00,0x00,0x30,0x48,0x20,0x7C,0x24,0x49,0xFE,0x48,0x20,0x48,0x22,0x7B,0xFF,0x48,0x60,0x48,0xB0,0x48,0xA8,0x79,0x28,0x4A,0x27,0x04,0x22,0x00,0x20,0x00,0x20},
{0xAC,0x4F,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x00,0x02,0x7F,0xFF,0x01,0x00,0x19,0x10,0x11,0xFC,0x2D,0x00,0x23,0x00,0x40,0xFF},
{0xAC,0x50,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x00,0x00,0x0C,0xC0,0x08,0x88,0x1F,0xFC,0x60,0x80,0x0F,0xF8,0x00,0x80,0x00,0x82,0x7F,0xFF},
{0xAC,0x51,0x00,0x00,0x01,0x80,0x49,0x00,0x79,0x02,0x4B,0xFF,0x4A,0x40,0x4C,0x44,0x78,0x7E,0x48,0x40,0x48,0x44,0x48,0x7E,0x78,0x40,0x48,0x40,0x40,0x40,0x00,0x40,0x00,0x40},
{0xAC,0x52,0x00,0x00,0x10,0x08,0x1F,0xFC,0x10,0x08,0x1F,0xF8,0x10,0x08,0x1F,0xF8,0x10,0x08,0x00,0xC0,0x00,0x84,0x3F,0xFE,0x04,0x10,0x04,0x20,0x02,0x20,0x02,0x42,0x7F,0xFF},
{0xAC,0x53,0x00,0x00,0x00,0x30,0x48,0x50,0x7C,0x48,0x48,0x88,0x48,0x84,0x49,0x7A,0x7A,0x01,0x48,0x04,0x49,0xFE,0x48,0x44,0x78,0x44,0x48,0x5C,0x00,0x48,0x00,0x40,0x00,0x40},
{0xAC,0x54,0x00,0x00,0x10,0x10,0x1F,0xF8,0x10,0x10,0x1F,0xF0,0x10,0x10,0x1F,0xF0,0x14,0x02,0x07,0xFF,0x18,0xC2,0x60,0x82,0x09,0x42,0x0A,0x22,0x0F,0xF2,0x08,0x04,0x00,0x38},
{0xAC,0x55,0x00,0x00,0x0C,0x18,0x08,0x12,0x09,0xFF,0x7E,0x00,0x08,0x18,0x18,0x92,0x1C,0xFF,0x2A,0x92,0x2A,0x92,0x48,0x92,0x08,0x92,0x08,0x9E,0x08,0x94,0x08,0x10,0x08,0x10},
{0xAC,0x56,0x00,0x00,0x20,0xC0,0x14,0x90,0x47,0xF8,0x28,0x92,0x09,0x12,0x71,0x13,0x12,0x0E,0x14,0xC0,0x00,0x82,0x7F,0xFF,0x01,0x80,0x06,0xE0,0x18,0x98,0x60,0x87,0x00,0x80},
{0xAC,0x57,0x00,0x00,0x0C,0x40,0x08,0x30,0x08,0x12,0x7E,0xFF,0x08,0x10,0x18,0x10,0x18,0x10,0x2C,0x14,0x2A,0xFE,0x4A,0x10,0x08,0x10,0x08,0x10,0x08,0x12,0x09,0xFF,0x08,0x00},
{0xAC,0x58,0x00,0x00,0x00,0x10,0x1F,0xF8,0x03,0x20,0x00,0xC4,0x7F,0xFE,0x02,0x84,0x0C,0x88,0x73,0x80,0x00,0x82,0x7F,0xFF,0x01,0x80,0x02,0xE0,0x0C,0x98,0x70,0x87,0x00,0x80},
{0xAC,0x59,0x00,0x00,0x06,0x18,0x04,0x12,0x7F,0xFF,0x04,0x10,0x07,0xF0,0x04,0x10,0x07,0xF0,0x04,0x90,0x00,0x82,0x7F,0xFF,0x01,0x80,0x06,0xE0,0x18,0x98,0x60,0x87,0x00,0x80},
{0xAC,0x5A,0x00,0x00,0x00,0xC0,0x00,0x84,0x3F,0xFE,0x00,0x80,0x10,0x84,0x1F,0xFE,0x14,0x94,0x12,0xA4,0x1F,0xFC,0x11,0x84,0x02,0xE0,0x04,0x98,0x18,0x87,0x60,0x82,0x00,0x80},
{0xAC,0x5B,0x00,0x00,0x0C,0x00,0x09,0x22,0x7F,0xBF,0x09,0x22,0x11,0x22,0x11,0x22,0x27,0x3E,0x42,0x22,0x00,0x80,0x7F,0xFF,0x01,0x80,0x06,0xE0,0x18,0x98,0x60,0x87,0x00,0x80},
{0xAC,0x5C,0x00,0x00,0x0C,0x18,0x08,0x10,0x08,0x10,0x7E,0x12,0x09,0xFF,0x18,0x10,0x18,0x10,0x2C,0x92,0x2A,0xFF,0x4A,0x82,0x08,0x82,0x08,0x82,0x08,0x82,0x08,0xFE,0x08,0x82},
{0xAC,0x5D,0x00,0x00,0x0C,0x82,0x08,0xFF,0x08,0xAA,0x7E,0xAA,0x08,0xAA,0x18,0xAA,0x19,0xFF,0x2C,0xAA,0x2A,0xAA,0x4A,0xAA,0x08,0xAA,0x08,0xAA,0x08,0xAA,0x08,0xAE,0x08,0x82},
{0xAC,0x5E,0x00,0x00,0x0C,0x82,0x08,0xFF,0x08,0x80,0x7E,0x98,0x08,0x90,0x18,0x9E,0x18,0xA4,0x2C,0xC8,0x2A,0x88,0x4A,0x94,0x08,0xA4,0x08,0xC2,0x08,0x80,0x08,0xFF,0x08,0x80},
{0xAC,0x5F,0x00,0x00,0x0C,0x02,0x09,0xFF,0x08,0x04,0x7E,0x04,0x08,0x94,0x18,0xF4,0x18,0x94,0x2C,0x94,0x2A,0xF4,0x4A,0x94,0x08,0x04,0x08,0x04,0x08,0x04,0x08,0x1C,0x08,0x08},
{0xAC,0x60,0x00,0x00,0x18,0x02,0x13,0xFF,0x10,0x20,0x7D,0x22,0x11,0xFF,0x31,0x22,0x31,0x22,0x59,0x52,0x55,0x4A,0x55,0x8A,0x11,0x02,0x11,0x02,0x11,0x02,0x11,0x0E,0x11,0x04},
{0xAC,0x61,0x00,0x00,0x0C,0xC6,0x08,0x84,0x08,0x84,0x7E,0x84,0x09,0xFF,0x18,0x84,0x18,0x84,0x2C,0x84,0x2A,0xFC,0x4A,0x84,0x08,0x84,0x08,0x84,0x08,0x84,0x08,0xFC,0x08,0x84},
{0xAC,0x62,0x00,0x00,0x0C,0x82,0x08,0xFF,0x08,0x82,0x7E,0x82,0x08,0xFE,0x18,0x80,0x18,0x02,0x2C,0xFF,0x2A,0x22,0x4A,0x22,0x08,0x22,0x08,0x42,0x08,0x42,0x08,0x9C,0x09,0x08},
{0xAC,0x63,0x00,0x00,0x0C,0x18,0x08,0x10,0x08,0x10,0x7E,0x92,0x08,0xFF,0x18,0x92,0x18,0x92,0x2C,0x92,0x2A,0xFE,0x4A,0x92,0x08,0x92,0x08,0x92,0x08,0x92,0x08,0xFE,0x08,0x82},
{0xAC,0x64,0x00,0x00,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x01,0x80,0x02,0xE0,0x04,0x98,0x18,0x87,0x60,0x02,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x00,0x02,0x7F,0xFF},
{0xAC,0x65,0x00,0x00,0x0C,0xC0,0x08,0x82,0x08,0xFF,0x7E,0x82,0x09,0x02,0x1A,0xFA,0x18,0x8A,0x2C,0x8A,0x2A,0x8A,0x4A,0xFA,0x08,0x8A,0x08,0x02,0x08,0x04,0x08,0x38,0x08,0x10},
{0xAC,0x66,0x00,0x00,0x0C,0x18,0x08,0x10,0x08,0xA2,0x7E,0xFF,0x08,0x82,0x18,0x82,0x18,0x82,0x2C,0x82,0x2A,0xFE,0x4A,0x82,0x08,0x82,0x08,0x82,0x08,0x82,0x08,0xFE,0x08,0x82},
{0xAC,0x67,0x00,0x00,0x0C,0x60,0x08,0x40,0x08,0x42,0x7E,0xFF,0x08,0xA0,0x19,0x24,0x18,0x3E,0x2C,0x20,0x2A,0x20,0x4A,0x24,0x08,0x3E,0x08,0x20,0x08,0x20,0x08,0x20,0x08,0x20},
{0xAC,0x68,0x00,0x00,0x18,0x60,0x11,0x89,0x11,0x2F,0x7D,0x29,0x11,0x29,0x39,0x29,0x35,0x29,0x55,0x29,0x51,0x69,0x53,0xA9,0x11,0x2F,0x10,0x4A,0x10,0x48,0x10,0x88,0x11,0x08},
{0xAC,0x69,0x00,0x00,0x0C,0x04,0x08,0xFE,0x08,0x10,0x7E,0x54,0x08,0x54,0x18,0x92,0x1C,0x92,0x2A,0x10,0x29,0xFF,0x48,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10},
{0xAC,0x6A,0x00,0x00,0x0C,0x82,0x08,0xFF,0x08,0x92,0x7E,0x92,0x08,0xFE,0x18,0x92,0x18,0x92,0x2C,0x92,0x2A,0xFE,0x4A,0x92,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10,0x08,0x10},
{0xAC,0x6B,0x00,0x00,0x0C,0x04,0x08,0x9E,0x08,0xF0,0x7E,0x90,0x08,0x92,0x18,0xFF,0x18,0x88,0x2C,0x88,0x2A,0x88,0x48,0xB5,0x0B,0xC5,0x09,0x03,0x08,0x09,0x0B,0xFC,0x08,0x00},
{0xAC,0x6C,0x00,0x00,0x0C,0x0C,0x08,0x9E,0x08,0xE0,0x7E,0x80,0x08,0x82,0x18,0xFF,0x18,0x88,0x2C,0xA8,0x2A,0x98,0x4A,0x8C,0x08,0x8E,0x08,0x8A,0x09,0x08,0x09,0x08,0x0A,0x08},
{0xAC,0x6D,0x00,0x00,0x20,0x60,0x12,0x40,0x44,0x4C,0x24,0x70,0x0B,0xC2,0x70,0x43,0x10,0x3E,0x10,0x80,0x00,0x82,0x7F,0xFF,0x01,0x80,0x06,0xE0,0x18,0x98,0x60,0x87,0x00,0x80},
{0xAC,0x6E,0x00,0x00,0x00,0x04,0x7F,0xFE,0x01,0x80,0x02,0xA0,0x0C,0x98,0x70,0x86,0x00,0x82,0x00,0x00,0x3F,0xFE,0x00,0x80,0x0C,0x90,0x08,0xF8,0x08,0x80,0x08,0x82,0x7F,0xFF},
{0xAC,0x6F,0x00,0x00,0x04,0x30,0x7E,0x20,0x20,0x20,0x25,0x24,0x3D,0xFE,0x25,0x24,0x25,0x24,0x55,0x24,0x49,0x24,0x0B,0xFF,0x08,0x50,0x10,0x48,0x10,0x88,0x21,0x07,0x46,0x02},
{0xAC,0x70,0x00,0x00,0x04,0x30,0x7E,0x20,0x20,0x24,0x24,0x44,0x3E,0x42,0x24,0x87,0x25,0xF9,0x54,0x81,0x48,0x00,0x08,0xFE,0x08,0x82,0x10,0x82,0x10,0x82,0x20,0xFE,0x40,0x82},
{0xAC,0x71,0x00,0x00,0x26,0x48,0x38,0x7C,0x20,0x48,0x24,0x48,0x3E,0x49,0x20,0x47,0x24,0x80,0x3E,0x04,0x20,0xFE,0x22,0x44,0x2C,0x24,0x70,0x28,0x20,0x10,0x20,0x6C,0x21,0x83},
{0xAC,0x72,0x00,0x00,0x00,0x80,0x3F,0xFE,0x00,0x80,0x1F,0xFC,0x00,0x80,0x7F,0xFF,0x00,0x00,0x0F,0xF8,0x08,0x4A,0x7F,0xFF,0x08,0x88,0x10,0x88,0x1F,0xFE,0x10,0x10,0x00,0xE0},
{0xAC,0x73,0x00,0x00,0x01,0x8C,0x45,0x08,0x7D,0x08,0x55,0x08,0x55,0x08,0x55,0x4A,0x7D,0xEF,0x55,0x08,0x55,0x08,0x55,0x08,0x7D,0x08,0x45,0x29,0x01,0xC9,0x03,0x09,0x01,0x07},
{0xAC,0x74,0x00,0x00,0x08,0x08,0x0F,0xFC,0x10,0x00,0x6F,0xF8,0x00,0x00,0x3F,0xF8,0x04,0x88,0x3F,0xE8,0x04,0xA8,0x1F,0xE8,0x14,0x85,0x3F,0xF5,0x28,0x95,0x08,0xB3,0x10,0x81},
{0xAC,0x75,0x00,0x00,0x00,0xC0,0x09,0x08,0x0F,0xFC,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x00,0xC0,0x3E,0x86,0x04,0xC8,0x08,0xB0,0x70,0x8F,0x07,0x82,0x01,0x00},
{0xAC,0x76,0x00,0x00,0x21,0x0C,0x10,0x88,0x10,0x90,0x43,0xFE,0x28,0x20,0x28,0x24,0x0B,0xFE,0x10,0x20,0x10,0x22,0x67,0xFF,0x20,0x20,0x20,0x20,0x60,0x20,0x20,0x20,0x00,0x20},
{0xAC,0x77,0x00,0x00,0x21,0x99,0x11,0x11,0x11,0x11,0x45,0x11,0x25,0x11,0x29,0x99,0x09,0x55,0x15,0x55,0x15,0x11,0x69,0x11,0x21,0x11,0x22,0x11,0x62,0x11,0x22,0x11,0x04,0x11},
{0xAC,0x78,0x00,0x00,0x20,0xCC,0x10,0x88,0x10,0x88,0x40,0x88,0x23,0xFE,0x28,0x88,0x08,0x88,0x10,0x88,0x10,0x8A,0x67,0xFF,0x20,0x00,0x20,0xC8,0x60,0x84,0x61,0x06,0x26,0x02},
{0xAC,0x79,0x00,0x00,0x20,0x30,0x10,0x22,0x17,0xFF,0x40,0x40,0x20,0x88,0x2B,0xF6,0x09,0x02,0x10,0x00,0x11,0xAC,0x61,0x28,0x21,0x28,0x21,0x29,0x62,0x29,0x62,0x29,0x24,0x07},
{0xAC,0x7A,0x00,0x00,0x20,0x30,0x10,0x24,0x11,0xFE,0x40,0x24,0x27,0xFF,0x28,0x24,0x09,0xFC,0x10,0x24,0x10,0x20,0x61,0xFC,0x20,0x20,0x27,0xFF,0x60,0x20,0x60,0x20,0x20,0x20},
{0xAC,0x7B,0x00,0x00,0x20,0x43,0x17,0xE2,0x12,0x0A,0x42,0x4A,0x2B,0xEA,0x2A,0x4A,0x12,0x4A,0x15,0x4A,0x14,0x8A,0x68,0x8A,0x20,0x82,0x21,0x02,0x61,0x02,0x62,0x0E,0x24,0x04},
{0xAC,0x7C,0x00,0x00,0x20,0x02,0x17,0xFF,0x11,0x08,0x41,0x08,0x25,0xF8,0x29,0x08,0x09,0x08,0x11,0xF8,0x11,0x08,0x61,0x0E,0x21,0x38,0x27,0xC8,0x62,0x08,0x60,0x08,0x20,0x08},
{0xAC,0x7D,0x00,0x00,0x22,0x02,0x13,0xFF,0x12,0x02,0x42,0xFA,0x26,0x02,0x0A,0x8A,0x0A,0xFA,0x12,0x8A,0x12,0x8A,0x62,0xFA,0x22,0x8A,0x22,0x02,0x62,0x02,0x62,0x0E,0x22,0x04},
{0xAC,0x7E,0x00,0x00,0x20,0x18,0x10,0xD0,0x10,0x90,0x45,0xFE,0x25,0x10,0x2A,0x10,0x08,0x12,0x13,0xFF,0x10,0x48,0x60,0x48,0x20,0x48,0x20,0x89,0x60,0x89,0x21,0x09,0x06,0x07},
{0xAC,0xA1,0x00,0x00,0x20,0x0C,0x10,0x3E,0x13,0xE0,0x44,0x20,0x24,0x22,0x2B,0xFF,0x08,0x20,0x10,0x20,0x11,0x22,0x61,0xFF,0x21,0x02,0x21,0x02,0x61,0x02,0x21,0xFE,0x01,0x02},
{0xAC,0xA2,0x00,0x00,0x20,0x20,0x10,0x60,0x10,0x50,0x40,0x88,0x24,0x88,0x29,0x04,0x0A,0xFA,0x14,0x01,0x11,0x04,0x61,0xFE,0x21,0x04,0x21,0x04,0x61,0x04,0x21,0xFC,0x01,0x04},
{0xAC,0xA3,0x00,0x00,0x20,0x0C,0x12,0x3E,0x13,0xC0,0x42,0x00,0x22,0x9E,0x2A,0xF0,0x0A,0x90,0x12,0x93,0x12,0x94,0x62,0x88,0x22,0x88,0x24,0x84,0x64,0xB4,0x25,0xC2,0x08,0x81},
{0xAC,0xA4,0x00,0x00,0x21,0x80,0x11,0x00,0x11,0x02,0x43,0xFF,0x22,0x02,0x2C,0x22,0x0A,0xAA,0x12,0x4A,0x12,0xAA,0x62,0x0A,0x23,0xFA,0x22,0x0A,0x60,0x02,0x20,0x3C,0x00,0x08},
{0xAC,0xA5,0x00,0x00,0x20,0xC0,0x10,0x84,0x10,0xFE,0x44,0x84,0x25,0x88,0x29,0x48,0x0A,0x30,0x10,0x4C,0x11,0x83,0x62,0xFC,0x20,0x84,0x20,0x84,0x60,0x84,0x20,0xFC,0x00,0x84},
{0xAC,0xA6,0x00,0x00,0x00,0x02,0x7F,0xFF,0x02,0x00,0x07,0xF8,0x1C,0x08,0x64,0x08,0x07,0xF8,0x04,0x08,0x00,0xC0,0x3E,0x86,0x04,0xC8,0x08,0xB0,0x70,0x8F,0x07,0x82,0x01,0x00},
{0xAC,0xA7,0x00,0x00,0x20,0x04,0x13,0xFE,0x10,0x00,0x41,0x04,0x25,0xFE,0x29,0x04,0x09,0x04,0x11,0xFC,0x11,0x04,0x61,0x04,0x21,0xFC,0x21,0x04,0x60,0x00,0x60,0x02,0x27,0xFF},
{0xAC,0xA8,0x00,0x00,0x20,0x60,0x10,0x42,0x17,0xFF,0x40,0x80,0x24,0x84,0x29,0xFE,0x09,0x04,0x13,0xFC,0x15,0x04,0x61,0x04,0x21,0xFC,0x21,0x04,0x61,0x04,0x61,0x1C,0x21,0x08},
{0xAC,0xA9,0x00,0x00,0x20,0x30,0x10,0x20,0x12,0x26,0x41,0x24,0x25,0xA8,0x28,0xA8,0x08,0x22,0x13,0xFF,0x10,0x90,0x60,0x90,0x20,0x90,0x21,0x12,0x61,0x12,0x62,0x13,0x24,0x0E},
{0xAC,0xAA,0x00,0x00,0x20,0x60,0x10,0x40,0x12,0x44,0x43,0xFE,0x26,0x44,0x2B,0xFC,0x0A,0x44,0x13,0xFC,0x12,0x24,0x60,0x20,0x20,0x2C,0x20,0x31,0x60,0xD1,0x67,0x09,0x20,0x07},
{0xAC,0xAB,0x00,0x00,0x20,0xD8,0x10,0x90,0x14,0x90,0x42,0x96,0x2A,0x94,0x28,0x98,0x08,0x90,0x10,0x90,0x11,0x98,0x66,0x96,0x24,0x92,0x20,0x90,0x61,0x11,0x61,0x11,0x22,0x0F},
{0xAC,0xAC,0x00,0x00,0x21,0x80,0x11,0x02,0x11,0xFF,0x42,0x02,0x2A,0x02,0x2D,0xF2,0x09,0x12,0x11,0xF2,0x11,0x12,0x61,0xF2,0x21,0x12,0x20,0x02,0x60,0x04,0x60,0x38,0x20,0x10},
{0xAC,0xAD,0x00,0x00,0x20,0x18,0x10,0x10,0x11,0x22,0x41,0xFF,0x25,0x02,0x29,0x02,0x09,0xFE,0x11,0x02,0x11,0x02,0x61,0xFE,0x21,0x02,0x21,0x02,0x61,0x02,0x61,0xFE,0x21,0x02},
{0xAC,0xAE,0x00,0x00,0x20,0x30,0x10,0x20,0x12,0x44,0x43,0xFE,0x2A,0x94,0x2A,0x94,0x0A,0x94,0x12,0x94,0x12,0x94,0x62,0x94,0x22,0x94,0x22,0x94,0x62,0x94,0x6F,0xFF,0x20,0x00},
{0xAC,0xAF,0x00,0x00,0x18,0x30,0x10,0x22,0x13,0xFF,0x10,0x30,0x56,0x20,0x54,0x20,0x58,0x4C,0x50,0xC8,0x10,0x28,0x18,0x10,0x14,0x30,0x24,0x28,0x20,0x44,0x21,0xFB,0x40,0x81},
{0xAC,0xB0,0x00,0x00,0x01,0xFC,0x3F,0x00,0x20,0x88,0x2F,0xE4,0x48,0x24,0x08,0x40,0x0F,0xF0,0x08,0x10,0x08,0x22,0x1F,0xFF,0x10,0x02,0x25,0x42,0x2A,0xA2,0x4A,0xAE,0x00,0x04},
{0xAC,0xB1,0x00,0x00,0x18,0x02,0x13,0xFF,0x10,0x20,0x15,0x22,0x55,0xFF,0x59,0x22,0x51,0x22,0x11,0x52,0x11,0x4A,0x31,0x8A,0x29,0x02,0x25,0x02,0x25,0x02,0x41,0x0E,0x01,0x04},
{0xAC,0xB2,0x00,0x00,0x19,0x04,0x11,0xFE,0x11,0x00,0x17,0x00,0x55,0x04,0x59,0xFE,0x51,0x04,0x51,0x04,0x11,0x04,0x19,0xFC,0x15,0x04,0x25,0x00,0x25,0x02,0x21,0xFF,0x41,0x00},
{0xAC,0xB3,0x00,0x00,0x19,0x02,0x11,0xFF,0x11,0x02,0x17,0x02,0x55,0x4A,0x59,0x7A,0x51,0x4A,0x51,0x4A,0x11,0x4A,0x19,0x7A,0x15,0x4A,0x25,0x02,0x25,0x02,0x21,0x0E,0x41,0x04},
{0xAC,0xB4,0x00,0x00,0x00,0xC0,0x18,0x86,0x10,0x84,0x1F,0xFC,0x00,0x00,0x3F,0xFF,0x20,0x00,0x20,0x60,0x22,0x46,0x22,0x44,0x2C,0xC8,0x20,0xB0,0x41,0x10,0x42,0x0C,0x4C,0x03},
{0xAC,0xB5,0x00,0x00,0x18,0xC0,0x10,0x82,0x10,0xFF,0x16,0xA0,0x55,0x20,0x59,0x24,0x52,0x3E,0x50,0x20,0x18,0x20,0x14,0x24,0x24,0x3E,0x24,0x20,0x20,0x20,0x40,0x20,0x00,0x20},
{0xAC,0xB6,0x00,0x00,0x18,0xC0,0x10,0x82,0x10,0xFF,0x15,0x02,0x55,0x02,0x5A,0xF2,0x50,0x92,0x10,0x92,0x18,0xF2,0x14,0x82,0x24,0x9C,0x24,0x88,0x20,0x82,0x40,0x83,0x00,0x7E},
{0xAC,0xB7,0x00,0x00,0x18,0x02,0x11,0xFF,0x10,0x42,0x16,0x42,0x54,0x42,0x58,0x84,0x50,0x9C,0x51,0x08,0x1A,0x82,0x14,0xFF,0x24,0x82,0x24,0x82,0x20,0x82,0x40,0xFE,0x00,0x82},
{0xAC,0xB8,0x00,0x00,0x00,0xFC,0x1F,0x88,0x10,0x86,0x20,0x42,0x4F,0xF8,0x02,0x02,0x3F,0xFF,0x02,0x00,0x02,0x08,0x07,0xFC,0x05,0x08,0x08,0x90,0x30,0x60,0x01,0x98,0x0E,0x07},
{0xAC,0xB9,0x00,0x00,0x0C,0x18,0x28,0x10,0x28,0xD0,0x3E,0x94,0x48,0xFE,0x49,0x10,0x09,0x10,0x08,0x14,0x0E,0xFE,0x78,0x10,0x28,0x10,0x08,0x10,0x08,0x12,0x09,0xFF,0x08,0x00},
{0xAC,0xBA,0x00,0x00,0x0C,0x18,0x28,0x10,0x28,0x10,0x3E,0x12,0x49,0xFF,0x48,0x10,0x08,0x10,0x0A,0x92,0x0C,0xFF,0x78,0x82,0x28,0x82,0x08,0x82,0x08,0x82,0x08,0xFE,0x08,0x82},
{0xAC,0xBB,0x00,0x00,0x0C,0x04,0x28,0x9E,0x28,0xF0,0x3E,0x90,0x48,0x92,0x48,0xFF,0x08,0x88,0x0A,0x88,0x0C,0x88,0x78,0xE5,0x2B,0x85,0x09,0x03,0x08,0x09,0x0B,0xFC,0x08,0x00},
{0xAC,0xBC,0x00,0x00,0x46,0x18,0x25,0x12,0x19,0xFF,0x12,0x02,0x2A,0x0C,0x48,0x08,0x0D,0xFF,0x14,0x08,0x14,0x88,0x24,0x48,0x44,0x48,0x04,0x08,0x44,0x08,0x38,0x38,0x10,0x10},
{0xAC,0xBD,0x00,0x00,0x46,0x84,0x24,0xFE,0x18,0x84,0x10,0x84,0x28,0xFC,0x48,0x84,0x08,0x84,0x14,0xFC,0x14,0xA0,0x24,0x93,0x44,0x94,0x04,0x88,0x44,0xA8,0x39,0xC4,0x10,0x83},
{0xAC,0xBE,0x00,0x00,0x46,0x30,0x24,0x22,0x19,0xFF,0x10,0x00,0x28,0xC4,0x48,0x83,0x0D,0x01,0x14,0xCC,0x14,0xA8,0x25,0x28,0x44,0x10,0x04,0x28,0x44,0x28,0x38,0x44,0x11,0x83},
{0xAC,0xBF,0x00,0x00,0x00,0x30,0x04,0x20,0x7E,0x20,0x10,0x22,0x10,0x3F,0x14,0x20,0x7E,0x20,0x10,0x22,0x11,0xFF,0x13,0x02,0x1D,0x02,0x71,0x02,0x21,0x02,0x01,0xFE,0x01,0x02},
{0xAC,0xC0,0x00,0x00,0x09,0x04,0x7D,0xFE,0x11,0x54,0x11,0x54,0x11,0x54,0x7D,0x54,0x13,0xFF,0x11,0x54,0x15,0x54,0x19,0x54,0x71,0x54,0x21,0x54,0x01,0x54,0x01,0x5C,0x01,0x04},
{0xAC,0xC1,0x00,0x00,0x08,0x18,0x7C,0x10,0x11,0x12,0x11,0xFF,0x11,0x12,0x7D,0x14,0x11,0x10,0x11,0xFE,0x15,0x44,0x19,0x24,0x71,0x28,0x22,0x10,0x02,0x28,0x02,0x44,0x04,0x83},
{0xAC,0xC2,0x00,0x00,0x08,0x30,0x7C,0x50,0x10,0x48,0x10,0x88,0x10,0x84,0x7D,0x7A,0x12,0x01,0x10,0x04,0x11,0xFE,0x1C,0x44,0x70,0x44,0x20,0x5C,0x00,0x48,0x00,0x40,0x00,0x40},
{0xAC,0xC3,0x00,0x00,0x08,0x30,0x7C,0x50,0x10,0x48,0x10,0x88,0x13,0x34,0x7C,0x23,0x10,0x40,0x11,0x98,0x10,0x10,0x1C,0x20,0x70,0xCC,0x23,0x08,0x00,0x30,0x00,0xC0,0x03,0x00},
{0xAC,0xC4,0x00,0x00,0x00,0x18,0x04,0x10,0x7E,0xA2,0x10,0xFF,0x10,0x82,0x14,0x82,0x7E,0x82,0x10,0x82,0x10,0xFE,0x12,0x82,0x1C,0x82,0x70,0x82,0x20,0x82,0x00,0xFE,0x00,0x82},
{0xAC,0xC5,0x00,0x00,0x08,0xD8,0x7C,0x92,0x10,0x92,0x10,0x91,0x11,0x90,0x7D,0xBF,0x12,0x90,0x10,0x90,0x14,0x88,0x18,0x88,0x70,0x89,0x20,0x85,0x00,0x85,0x00,0x83,0x00,0x81},
{0xAC,0xC6,0x00,0x00,0x06,0x18,0x04,0x10,0x3F,0xFE,0x04,0x10,0x07,0xF0,0x04,0x10,0x07,0xF0,0x04,0x12,0x7F,0xFF,0x11,0x20,0x12,0x24,0x1C,0x1C,0x10,0x00,0x1F,0xFE,0x10,0x00},
{0xAC,0xC7,0x00,0x00,0x00,0x04,0x7F,0xFE,0x01,0x80,0x06,0xB0,0x18,0x8E,0x60,0x82,0x00,0x00,0x1F,0xFC,0x10,0x84,0x1F,0xFC,0x10,0x84,0x1F,0xFC,0x10,0x84,0x20,0x9C,0x20,0x08},
{0xAC,0xC8,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x88,0x0F,0xF8,0x08,0x88,0x0F,0xF8,0x08,0x08,0x00,0x02,0x7F,0xFF,0x08,0x80,0x08,0x4C,0x09,0x50,0x0E,0x20,0x78,0x18,0x20,0x07},
{0xAC,0xC9,0x00,0x00,0x10,0x08,0x1F,0xFC,0x11,0x08,0x1F,0xF8,0x11,0x08,0x1F,0xF8,0x12,0x48,0x04,0x20,0x18,0x18,0x66,0x27,0x04,0x20,0x04,0x20,0x08,0x20,0x08,0x20,0x10,0x20},
{0xAC,0xCA,0x00,0x00,0x00,0x34,0x44,0x22,0x7E,0x22,0x54,0x20,0x57,0xFF,0x54,0x20,0x7C,0x20,0x54,0x60,0x54,0x50,0x54,0x50,0x7C,0x90,0x44,0x88,0x01,0x08,0x02,0x04,0x04,0x03},
{0xAC,0xCB,0x00,0x00,0x00,0xC0,0x44,0x80,0x7E,0x82,0x54,0xFF,0x54,0x84,0x55,0x84,0x7D,0x44,0x56,0x48,0x54,0x28,0x54,0x30,0x7C,0x10,0x44,0x28,0x00,0x44,0x00,0x87,0x07,0x02},
{0xAC,0xCC,0x00,0x00,0x00,0x60,0x08,0x42,0x0F,0xFF,0x48,0x00,0x29,0xF0,0x29,0x12,0x09,0x13,0x0A,0x0E,0x18,0x00,0x6B,0xFC,0x49,0x08,0x08,0x90,0x10,0x60,0x11,0x98,0x26,0x07},
{0xAC,0xCD,0x00,0x00,0x00,0x60,0x08,0x42,0x0F,0xFF,0x48,0x00,0x29,0x04,0x29,0xFE,0x09,0x24,0x09,0x24,0x19,0x24,0x69,0xFC,0x49,0x04,0x09,0x01,0x11,0x01,0x11,0x01,0x20,0xFF},
{0xAC,0xCE,0x00,0x00,0x00,0x60,0x08,0x42,0x0F,0xFF,0x48,0x00,0x28,0x60,0x28,0x50,0x09,0x8C,0x0E,0x03,0x18,0xCC,0x68,0x88,0x48,0x88,0x08,0x88,0x11,0x08,0x11,0x08,0x22,0x08},
{0xAC,0xCF,0x00,0x00,0x00,0x60,0x08,0x42,0x0F,0xFF,0x48,0x00,0x28,0x30,0x28,0x20,0x09,0x26,0x09,0x24,0x1A,0x28,0x6A,0x50,0x48,0x50,0x08,0x88,0x10,0x88,0x11,0x04,0x26,0x03},
{0xAC,0xD0,0x00,0x00,0x00,0x60,0x08,0x42,0x0F,0xFF,0x48,0x00,0x28,0x68,0x28,0x44,0x0B,0xFE,0x08,0x40,0x18,0x58,0x68,0x50,0x48,0x90,0x08,0x92,0x11,0x12,0x11,0x13,0x22,0x0E},
{0xAC,0xD1,0x00,0x00,0x01,0x00,0x3F,0x8C,0x01,0x50,0x1A,0x23,0x04,0x14,0x18,0x0C,0x67,0xF3,0x00,0x80,0x00,0x84,0x3F,0xFE,0x01,0x40,0x01,0x20,0x02,0x18,0x0C,0x07,0x30,0x02},
{0xAC,0xD2,0x00,0x00,0x18,0x60,0x10,0x40,0x12,0x4E,0x1F,0x70,0x10,0x42,0x13,0x43,0x7C,0x3E,0x20,0xC0,0x09,0x08,0x0F,0xFC,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08},
{0xAC,0xD3,0x00,0x00,0x00,0xC0,0x09,0x08,0x0F,0xFC,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x00,0x00,0x3F,0xFE,0x00,0x80,0x1F,0xFC,0x00,0x80,0x00,0x82,0x7F,0xFF},
{0xAC,0xD4,0x00,0x00,0x19,0x02,0x11,0xFF,0x25,0x00,0x7D,0x04,0x45,0xFE,0x45,0x44,0x45,0x44,0x7D,0x24,0x45,0x28,0x45,0x10,0x45,0x18,0x7D,0x28,0x45,0x24,0x02,0x47,0x02,0x82},
{0xAC,0xD5,0x00,0x00,0x00,0x20,0x3F,0xF0,0x08,0x20,0x08,0x24,0x0F,0xBE,0x10,0x84,0x15,0x04,0x22,0x38,0x4D,0x90,0x00,0x00,0x1F,0xF8,0x12,0x48,0x12,0x48,0x12,0x4A,0x7F,0xFF},
{0xAC,0xD6,0x00,0x00,0x00,0x20,0x06,0xF0,0x04,0x20,0x08,0x10,0x17,0xFC,0x62,0x13,0x02,0x10,0x04,0xF0,0x08,0x20,0x30,0x00,0x1F,0xF8,0x12,0x48,0x12,0x48,0x12,0x4A,0x7F,0xFF},
{0xAC,0xD7,0x00,0x00,0x00,0x02,0x7F,0xFF,0x01,0x00,0x03,0x20,0x05,0x18,0x19,0x06,0x61,0x02,0x01,0x00,0x10,0x08,0x1F,0xFC,0x12,0x48,0x12,0x48,0x12,0x4A,0x7F,0xFF,0x00,0x00},
{0xAC,0xD8,0x00,0x00,0x00,0xC0,0x20,0x84,0x3F,0xFE,0x20,0x84,0x20,0x84,0x3F,0xFC,0x20,0x84,0x00,0x80,0x10,0x08,0x1F,0xFC,0x12,0x48,0x12,0x48,0x12,0x4A,0x7F,0xFF,0x00,0x00},
{0xAC,0xD9,0x00,0x00,0x00,0xC0,0x0C,0x88,0x08,0x84,0x13,0x82,0x61,0x1B,0x00,0x61,0x01,0x88,0x0F,0xFC,0x78,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08},
{0xAC,0xDA,0x00,0x00,0x48,0x20,0x7C,0x2E,0x48,0x70,0x4B,0xA0,0x78,0x20,0x49,0xA6,0x49,0x24,0x79,0x24,0x49,0x24,0x49,0xFC,0x79,0x24,0x48,0x21,0x40,0x21,0x00,0x21,0x00,0x1F},
{0xAC,0xDB,0x00,0x00,0x0C,0x00,0x08,0x82,0x08,0xFF,0x7E,0x82,0x08,0x82,0x18,0xFE,0x18,0x82,0x2C,0x82,0x2A,0xFE,0x4A,0x82,0x08,0x82,0x08,0x82,0x08,0xFE,0x08,0x82,0x08,0x00},
{0xAC,0xDC,0x00,0x00,0x20,0x04,0x3F,0xFE,0x20,0x84,0x20,0x84,0x3F,0xFC,0x20,0x04,0x20,0x00,0x27,0xFC,0x24,0x04,0x27,0xFC,0x24,0x04,0x27,0xFC,0x44,0x04,0x47,0xFC,0x44,0x04},
{0xAC,0xDD,0x00,0x00,0x01,0xF8,0x1F,0x00,0x01,0x00,0x3F,0xFC,0x02,0x00,0x7F,0xFF,0x04,0x00,0x07,0xF8,0x0C,0x08,0x17,0xF8,0x64,0x08,0x07,0xF8,0x04,0x08,0x07,0xF8,0x04,0x08},
{0xAC,0xDE,0x00,0x00,0x20,0x7E,0x3F,0xC0,0x20,0x40,0x20,0x42,0x3F,0xFF,0x20,0x40,0x24,0x44,0x27,0xFE,0x24,0x04,0x27,0xFC,0x24,0x04,0x27,0xFC,0x44,0x04,0x47,0xFC,0x44,0x04},
{0xAC,0xDF,0x00,0x00,0x48,0x30,0x7C,0x90,0x48,0x88,0x49,0x08,0x79,0x04,0x4A,0x03,0x4D,0xFC,0x78,0x44,0x48,0x44,0x48,0x44,0x48,0x84,0x78,0x84,0x49,0x04,0x41,0x38,0x02,0x10},
{0xAC,0xE0,0x00,0x00,0x48,0x18,0x7C,0x10,0x48,0x10,0x48,0xD4,0x78,0x92,0x49,0x13,0x49,0x11,0x7A,0x10,0x48,0x73,0x48,0x22,0x48,0x04,0x78,0x08,0x48,0x30,0x40,0xC0,0x03,0x00},
{0xAC,0xE1,0x00,0x00,0x02,0x20,0x7F,0x30,0x02,0x50,0x34,0x48,0x08,0x48,0x00,0x84,0x7E,0xFA,0x09,0x02,0x19,0x09,0x2A,0xFC,0x28,0x08,0x48,0x10,0x08,0x10,0x38,0x20,0x10,0x20},
{0xAC,0xE2,0x00,0x00,0x02,0x18,0x7F,0x10,0x10,0x10,0x10,0x54,0x10,0x52,0x1E,0x93,0x32,0x91,0x53,0x10,0x12,0x73,0x12,0x22,0x1E,0x04,0x12,0x08,0x10,0x30,0x00,0xC0,0x03,0x00},
{0xAC,0xE3,0x00,0x00,0x08,0x42,0x7D,0xEF,0x10,0x44,0x10,0x44,0x10,0x44,0x24,0x44,0x3E,0x54,0x64,0x6F,0x25,0xC4,0x25,0x44,0x3C,0x44,0x24,0x44,0x20,0x84,0x00,0x84,0x01,0x04},
{0xAC,0xE4,0x00,0x00,0x04,0xC0,0x7E,0x81,0x10,0xBF,0x10,0x89,0x10,0xE9,0x13,0x89,0x3C,0x89,0x64,0x89,0x24,0xA9,0x24,0xC9,0x25,0x91,0x24,0x92,0x3C,0x22,0x24,0x2E,0x00,0x44},
{0xAC,0xE5,0x00,0x00,0x02,0x60,0x7F,0x40,0x08,0x42,0x08,0x7F,0x10,0x42,0x1E,0x94,0x12,0x90,0x33,0x10,0x52,0x10,0x12,0x30,0x12,0x28,0x1E,0x48,0x12,0x48,0x00,0x84,0x03,0x03},
{0xAC,0xE6,0x00,0x00,0x04,0x04,0x3E,0x7E,0x00,0x10,0x02,0x10,0x7F,0x10,0x08,0x12,0x08,0xFF,0x2A,0x10,0x2A,0x30,0x2A,0x28,0x2A,0x28,0x4A,0x44,0x48,0x44,0x08,0x82,0x09,0x01},
{0xAC,0xE7,0x00,0x00,0x04,0x18,0x3E,0x10,0x00,0x10,0x00,0x10,0x7E,0xD0,0x08,0x94,0x08,0x9E,0x2A,0x90,0x2A,0x90,0x2A,0x90,0x2A,0x90,0x4A,0x90,0x48,0x92,0x09,0xFF,0x08,0x00},
{0xAC,0xE8,0x00,0x00,0x04,0x04,0x3E,0x4E,0x00,0x70,0x02,0x40,0x7F,0x42,0x08,0x7F,0x08,0x44,0x2A,0x44,0x2A,0x44,0x2A,0x44,0x2A,0x44,0x4A,0x84,0x48,0x84,0x08,0x84,0x09,0x04},
{0xAC,0xE9,0x00,0x00,0x04,0x0C,0x3E,0x9E,0x00,0xE8,0x00,0x88,0x7E,0x88,0x08,0x8A,0x08,0xFF,0x2A,0x88,0x2A,0x88,0x2A,0x88,0x2A,0x85,0x4A,0x85,0x48,0xB5,0x09,0xC3,0x08,0x81},
{0xAC,0xEA,0x00,0x00,0x00,0xFC,0x1F,0x80,0x00,0x88,0x0F,0xFC,0x08,0x88,0x08,0x88,0x0F,0xF8,0x08,0x88,0x20,0x82,0x7F,0xFF,0x20,0x82,0x20,0xC2,0x2F,0xA2,0x24,0x2E,0x20,0x04},
{0xAC,0xEB,0x00,0x00,0x08,0x08,0x0F,0xFC,0x08,0x88,0x0F,0xF8,0x08,0x88,0x08,0x88,0x0F,0xF8,0x08,0x88,0x20,0x82,0x7F,0xFF,0x20,0x82,0x20,0xC2,0x2F,0xA2,0x24,0x2E,0x20,0x04},
{0xAC,0xEC,0x00,0x00,0x0E,0x0C,0x78,0x88,0x08,0x68,0x0A,0x28,0x7F,0x08,0x08,0x08,0x18,0x88,0x1C,0x68,0x2A,0x2A,0x2A,0x0F,0x48,0xF8,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08},
{0xAC,0xED,0x00,0x00,0x0E,0x18,0x78,0x10,0x08,0x10,0x08,0x54,0x7E,0x52,0x08,0x93,0x19,0x11,0x1C,0x10,0x2A,0x73,0x2A,0x22,0x48,0x04,0x08,0x08,0x08,0x10,0x08,0x60,0x09,0x80},
{0xAC,0xEE,0x00,0x00,0x0E,0x30,0x78,0x20,0x08,0x20,0x08,0xA6,0x7E,0xA4,0x08,0xA4,0x19,0x28,0x1C,0x20,0x2A,0x50,0x2A,0x50,0x48,0x48,0x08,0x88,0x08,0x84,0x09,0x04,0x0A,0x03},
{0xAC,0xEF,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x26,0x22,0x48,0x25,0x30,0x1F,0x0F,0xF8,0x00,0x40,0x08,0x44,0x1F,0xFE,0x10,0xC0,0x03,0x40,0x0C,0x40,0x71,0xC0,0x00,0x80},
{0xAC,0xF0,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x02,0x46,0x64,0x04,0x41,0x08,0x3F,0x31,0x90,0x01,0x08,0x7F,0xFE,0x01,0x00,0x02,0x80,0x04,0x60,0x18,0x18,0x60,0x06},
{0xAC,0xF1,0x00,0x00,0x10,0x20,0x1F,0x3F,0x24,0x48,0x42,0x84,0x00,0x00,0x1F,0xFC,0x00,0x80,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},
{0xAC,0xF2,0x00,0x00,0x10,0x20,0x1F,0x3F,0x24,0x48,0x42,0x84,0x00,0x00,0x1F,0xFC,0x00,0x80,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x80,0x00,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xAC,0xF3,0x00,0x00,0x0C,0x04,0x08,0xFE,0x4A,0x04,0x2A,0x08,0x2C,0x18,0x08,0x10,0x7E,0x12,0x09,0xFF,0x2C,0x10,0x2A,0x10,0x4A,0x10,0x4A,0x10,0x48,0x10,0x08,0x70,0x08,0x20},
{0xAC,0xF4,0x00,0x00,0x18,0x06,0x10,0x04,0x20,0x04,0x6D,0xFF,0x18,0x04,0x10,0x04,0x2C,0x84,0x74,0x64,0x50,0x34,0x18,0x14,0x54,0x04,0x54,0x04,0x50,0x24,0x10,0x1C,0x10,0x08},
{0xAC,0xF5,0x00,0x00,0x18,0x00,0x10,0x04,0x20,0xFE,0x6C,0x10,0x18,0x10,0x10,0x10,0x2C,0x10,0x74,0x10,0x50,0x10,0x18,0x10,0x54,0x10,0x54,0x10,0x50,0x12,0x11,0xFF,0x10,0x00},
{0xAC,0xF6,0x00,0x00,0x18,0x04,0x11,0xFE,0x20,0x04,0x6C,0x04,0x18,0x04,0x10,0x84,0x2C,0xFC,0x74,0x84,0x50,0x80,0x18,0x80,0x54,0x82,0x54,0x82,0x50,0x82,0x10,0x83,0x10,0x7E},
{0xAC,0xF7,0x00,0x00,0x18,0x02,0x11,0xFF,0x20,0x22,0x6C,0x22,0x19,0x22,0x10,0xA2,0x2C,0xA2,0x74,0x62,0x50,0x22,0x18,0x42,0x54,0x42,0x54,0x42,0x50,0x82,0x10,0x9C,0x11,0x08},
{0xAC,0xF8,0x00,0x00,0x18,0x60,0x10,0x42,0x20,0xFF,0x6C,0x80,0x19,0x04,0x10,0xFE,0x2C,0x04,0x74,0x08,0x50,0x10,0x18,0x20,0x54,0x42,0x54,0x82,0x50,0x82,0x10,0x83,0x10,0x7E},
{0xAC,0xF9,0x00,0x00,0x18,0x60,0x10,0x40,0x20,0x42,0x6C,0xFF,0x18,0x82,0x11,0x02,0x2C,0x02,0x74,0x12,0x50,0xFA,0x18,0x02,0x54,0x02,0x54,0x02,0x50,0x44,0x10,0x38,0x10,0x10},
{0xAC,0xFA,0x00,0x00,0x18,0x04,0x10,0xFE,0x20,0x10,0x6C,0x10,0x18,0x10,0x10,0x12,0x2D,0xFF,0x74,0x10,0x50,0x10,0x18,0x10,0x54,0x10,0x54,0x10,0x50,0x10,0x10,0x70,0x10,0x20},
{0xAC,0xFB,0x00,0x00,0x30,0x04,0x24,0xFE,0x3E,0x10,0x48,0x10,0x48,0x10,0x0A,0x10,0x7F,0x10,0x08,0x10,0x08,0x10,0x2A,0x10,0x2A,0x10,0x2A,0x10,0x3E,0x12,0x22,0xFF,0x00,0x00},
{0xAC,0xFC,0x00,0x00,0x08,0x18,0x06,0x10,0x02,0x24,0x3F,0xFE,0x00,0x80,0x1F,0xF8,0x00,0x82,0x7F,0xFF,0x00,0x00,0x00,0x84,0x7F,0xFE,0x01,0x40,0x02,0x30,0x0C,0x0C,0x70,0x03},
{0xAC,0xFD,0x00,0x00,0x7E,0xFC,0x06,0x0C,0x1A,0x34,0x66,0xCC,0x1A,0x34,0x62,0xC4,0x00,0x04,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x08,0x20,0x08,0x20,0x10,0x20,0x20,0x20},
{0xAC,0xFE,0x00,0x00,0x02,0x00,0x1F,0xC6,0x02,0x18,0x7F,0xFE,0x04,0x00,0x0F,0xE8,0x74,0x08,0x03,0xF0,0x3E,0x00,0x03,0xF8,0x3E,0x00,0x03,0xFA,0x7E,0x02,0x02,0x03,0x01,0xFE},
{0xAD,0x40,0x00,0x00,0x01,0x06,0x7F,0x84,0x08,0x04,0x51,0x04,0x7F,0x7F,0x55,0x04,0x55,0x04,0x55,0x44,0x55,0x34,0x55,0x14,0x55,0x04,0x55,0x04,0x41,0x24,0x47,0x1C,0x42,0x08},
{0xAD,0x41,0x00,0x00,0x00,0x04,0x7F,0xFE,0x01,0x00,0x22,0x04,0x3F,0xFE,0x22,0x44,0x22,0x44,0x20,0x4C,0x02,0x02,0x7F,0xFF,0x02,0x10,0x0C,0x20,0x03,0xC0,0x0C,0x30,0x70,0x0E},
{0xAD,0x42,0x00,0x00,0x00,0xC0,0x18,0x86,0x10,0x84,0x10,0x84,0x1F,0xFC,0x10,0x04,0x00,0x00,0x7F,0xFF,0x00,0x80,0x11,0x04,0x1F,0xFE,0x12,0x44,0x12,0x44,0x12,0x5C,0x12,0x48},
{0xAD,0x43,0x00,0x00,0x01,0x22,0x7F,0xBF,0x11,0x22,0x11,0x22,0x1F,0x24,0x11,0x24,0x11,0x22,0x1F,0x22,0x11,0x21,0x11,0x21,0x1F,0x21,0x71,0x2E,0x21,0x24,0x01,0x20,0x01,0x20},
{0xAD,0x44,0x00,0x00,0x24,0x10,0x3E,0x54,0x24,0x92,0x24,0x92,0x3D,0x11,0x24,0x14,0x24,0xFE,0x24,0x10,0x3C,0x12,0x25,0xFF,0x24,0x10,0x24,0x10,0x44,0x10,0x5C,0x10,0x48,0x10},
{0xAD,0x45,0x00,0x00,0x00,0x04,0x7F,0xFE,0x01,0x04,0x0D,0x10,0x09,0xF8,0x15,0x00,0x63,0xFF,0x00,0x00,0x1F,0xF8,0x10,0x08,0x1F,0xF8,0x10,0x08,0x1F,0xF8,0x10,0x08,0x10,0x18},
{0xAD,0x46,0x00,0x00,0x24,0x02,0x3D,0xFF,0x24,0x10,0x24,0x30,0x3C,0x50,0x24,0x54,0x24,0x92,0x24,0x93,0x3D,0x11,0x24,0x10,0x24,0x10,0x24,0x10,0x44,0x02,0x5D,0xFF,0x48,0x00},
{0xAD,0x47,0x00,0x00,0x20,0x02,0x3F,0xFF,0x20,0x82,0x3F,0xFE,0x20,0x82,0x3F,0xFE,0x20,0x02,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x08,0x38,0x08,0x10},
{0xAD,0x48,0x00,0x00,0x00,0xC0,0x20,0x82,0x3F,0xFF,0x20,0x82,0x3F,0xFE,0x20,0x82,0x3F,0xFE,0x20,0x02,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x08,0x18},
{0xAD,0x49,0x00,0x00,0x03,0x60,0x7E,0x46,0x02,0x78,0x0E,0x41,0x72,0x41,0x22,0x3F,0x00,0x00,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x0F,0xF8,0x08,0x08,0x08,0x38,0x08,0x10},
{0xAD,0x4A,0x00,0x00,0x0C,0x42,0x08,0x7F,0x0A,0x42,0x7F,0x42,0x08,0x7E,0x08,0x42,0x4A,0x42,0x7F,0x42,0x42,0x7E,0x42,0x42,0x42,0x42,0x7E,0x82,0x42,0x82,0x00,0x9E,0x01,0x04},
{0xAD,0x4B,0x00,0x00,0x25,0x02,0x3D,0xFF,0x25,0x22,0x25,0x22,0x3D,0xFE,0x25,0x22,0x25,0x22,0x25,0x22,0x3D,0xFE,0x25,0x22,0x24,0x20,0x24,0x20,0x44,0x20,0x5C,0x20,0x48,0x20},
{0xAD,0x4C,0x00,0x00,0x24,0x30,0x3E,0x20,0x24,0x28,0x24,0x44,0x3C,0x46,0x25,0xFB,0x24,0x81,0x24,0x00,0x3C,0x82,0x24,0xFF,0x24,0x82,0x24,0x82,0x44,0x82,0x5C,0xFE,0x48,0x82},
{0xAD,0x4D,0x00,0x00,0x24,0xC0,0x3C,0x82,0x24,0xFF,0x25,0x02,0x3D,0x02,0x26,0xF2,0x24,0x92,0x24,0x92,0x3C,0xF2,0x24,0x82,0x24,0x9C,0x24,0x89,0x44,0x81,0x5C,0x81,0x48,0x7F},
{0xAD,0x4E,0x00,0x00,0x33,0x18,0x22,0x10,0x2E,0xD0,0x21,0x10,0x22,0x90,0x2F,0x50,0x20,0x10,0x27,0xD0,0x24,0x50,0x27,0xD0,0x24,0x50,0x27,0xD2,0x44,0x52,0x44,0x53,0x44,0xCE},
{0xAD,0x4F,0x00,0x00,0x24,0x04,0x3E,0x9E,0x24,0xF0,0x24,0x90,0x3C,0x92,0x24,0xFF,0x24,0x88,0x24,0x88,0x3C,0x88,0x24,0xB5,0x25,0xC5,0x24,0x83,0x44,0x09,0x5D,0xFC,0x48,0x00},
{0xAD,0x50,0x00,0x00,0x02,0x30,0x7F,0xA0,0x08,0x22,0x12,0x3F,0x12,0x22,0x7D,0x42,0x21,0x64,0x0C,0x54,0x08,0x94,0x7F,0x08,0x08,0x08,0x0B,0x14,0x7C,0x14,0x20,0x22,0x00,0xC1},
{0xAD,0x51,0x00,0x00,0x0C,0x0C,0x10,0x08,0x3E,0x08,0x22,0x69,0x32,0x49,0x2A,0x49,0x22,0x49,0x2F,0x49,0x7A,0x49,0x2A,0x49,0x2A,0x49,0x22,0x49,0x22,0x7F,0x4E,0x41,0x44,0x00},
{0xAD,0x52,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x20,0x04,0x3F,0xFE,0x20,0x04,0x40,0x08,0x3F,0xFC,0x00,0x80,0x00,0x80,0x00,0x80,0x04,0x80,0x03,0x80,0x01,0x00},
{0xAD,0x53,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x21,0x08,0x19,0xFC,0x41,0x08,0x23,0x08,0x25,0x08,0x09,0x38,0x09,0x10,0x71,0x02,0x11,0x02,0x31,0x03,0x10,0xFE},
{0xAD,0x54,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x1F,0xF8,0x00,0x10,0x01,0xA0,0x00,0x42,0x7F,0xFF,0x01,0x42,0x02,0x44,0x0C,0x40,0x70,0x40,0x01,0xC0,0x00,0x80},
{0xAD,0x55,0x00,0x00,0x04,0x22,0x7F,0xFF,0x04,0x20,0x20,0x04,0x3F,0xFE,0x20,0x00,0x20,0x08,0x3F,0xFC,0x20,0x08,0x20,0x08,0x3F,0xF8,0x20,0x08,0x20,0x02,0x3F,0xFF,0x20,0x00},
{0xAD,0x56,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x00,0x02,0x7F,0xFF,0x00,0x08,0x1F,0x88,0x10,0x88,0x10,0x88,0x1F,0x88,0x10,0x88,0x00,0x08,0x00,0x78,0x00,0x10},
{0xAD,0x57,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x01,0x80,0x01,0x02,0x7F,0xFF,0x01,0x00,0x11,0x08,0x1F,0xFC,0x10,0x08,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08},
{0xAD,0x58,0x00,0x00,0x03,0x30,0x02,0x22,0x7F,0xFF,0x02,0x20,0x18,0x00,0x12,0x44,0x7F,0x7E,0x12,0x44,0x12,0x44,0x12,0x44,0x12,0x44,0x22,0x44,0x22,0x7C,0x2E,0x44,0x44,0x00},
{0xAD,0x59,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x03,0x00,0x02,0x02,0x7F,0xFF,0x04,0x00,0x04,0x08,0x0F,0xFC,0x14,0x08,0x64,0x08,0x04,0x08,0x07,0xF8,0x04,0x08},
{0xAD,0x5A,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x00,0xCC,0x10,0x82,0x1F,0xFF,0x10,0x80,0x10,0x4C,0x10,0x50,0x10,0x20,0x10,0xD2,0x23,0x12,0x2C,0x0B,0x40,0x06},
{0xAD,0x5B,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x00,0x82,0x7F,0xFF,0x00,0x80,0x00,0x84,0x3F,0xFE,0x01,0x80,0x02,0xE0,0x0C,0x98,0x70,0x87,0x00,0x80,0x00,0x80},
{0xAD,0x5C,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x01,0x80,0x11,0x08,0x1F,0xFC,0x11,0x08,0x7F,0xFE,0x11,0x08,0x7F,0xFF,0x10,0x08,0x10,0x08,0x10,0x38,0x10,0x10},
{0xAD,0x5D,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x04,0x20,0x20,0x04,0x3F,0xFE,0x21,0x04,0x21,0x04,0x3F,0xFC,0x21,0x04,0x21,0x04,0x21,0x04,0x3F,0xFC,0x20,0x04},
{0xAD,0x5E,0x00,0x00,0x06,0x18,0x04,0x12,0x7F,0xFF,0x04,0x10,0x00,0xC0,0x08,0x88,0x0F,0xFC,0x08,0x88,0x08,0x88,0x08,0x8A,0x7F,0xFF,0x01,0x40,0x02,0x20,0x0C,0x18,0x70,0x07},
{0xAD,0x5F,0x00,0x00,0x06,0x18,0x04,0x12,0x7F,0xFF,0x04,0x10,0x00,0xC0,0x18,0x86,0x10,0x84,0x1F,0xFC,0x10,0x84,0x00,0x80,0x30,0x83,0x20,0x82,0x20,0x82,0x3F,0xFE,0x20,0x02},
{0xAD,0x60,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x10,0x08,0x1F,0xFC,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08,0x1F,0xF8,0x10,0x08,0x10,0x08,0x1F,0xF8,0x10,0x08},
{0xAD,0x61,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x03,0x00,0x02,0x10,0x04,0x0C,0x7F,0xF6,0x20,0x02,0x0F,0xF8,0x08,0x08,0x08,0x08,0x08,0x08,0x0F,0xF8,0x08,0x08},
{0xAD,0x62,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x18,0x00,0x11,0x44,0x1F,0x7E,0x11,0x44,0x22,0x44,0x5A,0x44,0x04,0x5C,0x04,0x49,0x08,0x41,0x10,0x41,0x20,0x3F},
{0xAD,0x63,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x10,0x04,0x1F,0xFE,0x20,0x04,0x2F,0xC4,0x48,0x44,0x08,0x44,0x0F,0xC8,0x08,0x32,0x08,0x02,0x08,0x03,0x07,0xFE},
{0xAD,0x64,0x00,0x00,0x04,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x01,0x80,0x02,0x60,0x0C,0x18,0x77,0xF7,0x00,0x00,0x1F,0xF8,0x01,0x08,0x01,0x08,0x01,0x78,0x01,0x10,0x01,0x00},
{0xAD,0x65,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x10,0x04,0x1F,0xFE,0x20,0x04,0x2F,0xC4,0x48,0x44,0x08,0x44,0x0F,0xC4,0x08,0x44,0x00,0x04,0x00,0x78,0x00,0x10},
{0xAD,0x66,0x00,0x00,0x06,0x18,0x04,0x12,0x7F,0xFF,0x04,0x10,0x00,0xC0,0x00,0x82,0x7F,0xFF,0x01,0xC0,0x02,0xA0,0x04,0x98,0x18,0x87,0x67,0xF2,0x00,0x80,0x00,0x80,0x00,0x80},
{0xAD,0x67,0x00,0x00,0x06,0x30,0x04,0x22,0x7F,0xFF,0x04,0x20,0x27,0x04,0x38,0x7E,0x23,0x44,0x22,0x44,0x22,0x44,0x2E,0x44,0x72,0x44,0x22,0x5C,0x04,0x48,0x04,0x40,0x08,0x40},
{0xAD,0x68,0x00,0x00,0x01,0x20,0x01,0xF0,0x21,0x04,0x3F,0xFE,0x21,0x04,0x21,0xE8,0x2F,0x02,0x20,0xFE,0x20,0x00,0x23,0xFC,0x22,0x00,0x2F,0xFF,0x42,0x00,0x43,0xFC,0x40,0x00},
{0xAD,0x69,0x00,0x00,0x18,0x02,0x10,0xFF,0x52,0x10,0x7F,0x10,0x52,0x10,0x52,0x10,0x52,0x10,0x7E,0x10,0x52,0x10,0x10,0x10,0x14,0x10,0x1A,0x10,0x72,0x12,0x21,0xFF,0x00,0x00},
{0xAD,0x6A,0x00,0x00,0x18,0x18,0x10,0x10,0x54,0x92,0x7E,0xFF,0x54,0x80,0x54,0x80,0x54,0x80,0x54,0x80,0x7C,0x80,0x54,0x80,0x10,0x80,0x14,0x80,0x7A,0x7E,0x22,0x00,0x00,0x00},
{0xAD,0x6B,0x00,0x00,0x02,0x30,0x7F,0x20,0x24,0x20,0x25,0x24,0x25,0xFE,0x25,0x24,0x25,0x24,0x25,0xFC,0x25,0x24,0x24,0x20,0x24,0x28,0x25,0xF5,0x44,0x85,0x44,0x01,0x43,0xFF},
{0xAD,0x6C,0x00,0x00,0x19,0x02,0x10,0x9F,0x20,0x80,0x4C,0x20,0x0A,0x22,0x11,0x5F,0x31,0x44,0x50,0x84,0x10,0x84,0x17,0x04,0x11,0x04,0x11,0x04,0x13,0x04,0x13,0x1C,0x11,0x08},
{0xAD,0x6D,0x00,0x00,0x18,0x06,0x12,0x04,0x7F,0x08,0x02,0x10,0x04,0x60,0x08,0x06,0x1B,0x04,0x2C,0x08,0x4A,0x10,0x0A,0x63,0x09,0x02,0x08,0x04,0x08,0x18,0x08,0x60,0x08,0x00},
{0xAD,0x6E,0x00,0x00,0x00,0x02,0x7F,0xFF,0x02,0x40,0x22,0x44,0x3F,0xFE,0x22,0x44,0x3F,0xFC,0x20,0x04,0x02,0x02,0x7F,0xFF,0x02,0x10,0x0C,0x20,0x03,0xC0,0x06,0x7C,0x38,0x04},
{0xAD,0x6F,0x00,0x00,0x18,0x18,0x12,0x10,0x1F,0x10,0x24,0x12,0x3F,0x7F,0x69,0x12,0x29,0x12,0x3F,0x12,0x29,0x12,0x29,0x12,0x3F,0x22,0x21,0x22,0x21,0x22,0x47,0x5C,0x42,0x48},
{0xAD,0x70,0x00,0x00,0x04,0x18,0x3E,0x10,0x00,0x10,0x7F,0x10,0x00,0x10,0x3E,0x12,0x00,0xFF,0x3E,0x10,0x00,0x10,0x22,0x10,0x3F,0x10,0x22,0x10,0x22,0x10,0x3E,0x10,0x22,0x10},
{0xAD,0x71,0x00,0x00,0x04,0x00,0x3E,0x02,0x00,0xFF,0x7F,0x08,0x00,0x08,0x3E,0x08,0x00,0x08,0x3E,0x08,0x00,0x08,0x22,0x08,0x3F,0x08,0x22,0x08,0x22,0x08,0x3E,0x78,0x22,0x10},
{0xAD,0x72,0x00,0x00,0x02,0x30,0x3F,0x20,0x00,0x20,0x7F,0xA0,0x00,0x20,0x3F,0x30,0x00,0x28,0x3F,0x26,0x00,0x23,0x21,0x21,0x3F,0xA0,0x21,0x20,0x21,0x20,0x3F,0x20,0x21,0x20},
{0xAD,0x73,0x00,0x00,0x01,0x04,0x01,0xFE,0x01,0x00,0x11,0x08,0x1F,0xFC,0x10,0x08,0x1F,0xF8,0x10,0x08,0x1F,0xF8,0x10,0x08,0x1F,0xF8,0x10,0x08,0x06,0x30,0x18,0x0E,0x60,0x02},
{0xAD,0x74,0x00,0x00,0x04,0x20,0x07,0xF0,0x04,0x20,0x09,0xC0,0x10,0x88,0x3F,0xFC,0x10,0x08,0x1F,0xF8,0x10,0x08,0x1F,0xF8,0x10,0x08,0x1F,0xF8,0x04,0x10,0x18,0x0E,0x60,0x02},
{0xAD,0x75,0x00,0x00,0x