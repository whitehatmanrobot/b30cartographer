          {
	            //
	            // If position is 0 (this seems to happen on the Toshiba) then
	            // we'll return our last valid seek position
	            //

                MSF msfStart;
                MSF msfRel;
                msfPos = lpInfo->fPrevSeekTime;

                if (CdGetTrack (lpInfo, msfPos, &cTrack, &msfStart))
                {
                    if (msfStart <= msfPos)
                        msfRel = msfPos - msfStart;
                    else
                        msfRel = 0;

                    *disktime = REDTH(msfPos, cTrack);
                    *tracktime = REDTH(msfRel, cTrack);
                    return TRUE;
                }
                else
                {
                    continue;
                }
	        }
            else
            {
	            dprintf4(("CdPosition - MSF disk pos: %u, %u, %u",
		                 REDMINUTE(msfPos), REDSECOND(msfPos), REDFRAME(msfPos)));
	            *disktime = REDTH(msfPos, cTrack);

	            // data is current position

	            msfPos = MAKERED(sqd.CurrentPosition.TrackRelativeAddress[1],
			                     sqd.CurrentPosition.TrackRelativeAddress[2],
			                     sqd.CurrentPosition.TrackRelativeAddress[3]);

	            dprintf4(("CdPosition - MSF track pos (t,m,s,f): %u, %u, %u, %u",
		                  cTrack, REDMINUTE(msfPos), REDSECOND(msfPos), REDFRAME(msfPos)));
	            *tracktime = REDTH(msfPos, cTrack);


	            return TRUE;
            }
	    }
    }

    dprintf1(("CdPosition - Failed to read cd position"));

    return FALSE;
}



/***************************************************************************

    @doc EXTERNAL

    @api MSF | CdDiskEnd | Get the position of the end of the disk.

    @parm HCD | hCD | The handle of a currently open drive.

    @rdesc The return value is the end position expressed
	in MSF or INVALID_TRACK if an error occurs.

***************************************************************************/

MSF CdDiskEnd(HCD hCD)
{
    LPCDINFO lpInfo;

    lpInfo = (LPCDINFO) hCD;

    return lpInfo->msfEnd;
}


/***************************************************************************

    @doc EXTERNAL

    @api MSF | CdDiskLength | Get the length of the disk.

    @parm HCD | hCD | The handle of a currently open drive.

    @rdesc The return value is the length expressed
	in MSF or INVALID_TRACK if an error occurs.

***************************************************************************/

MSF CdDiskLength(HCD hCD)
{
    LPCDINFO lpInfo;
    MSF FirstTrackStart;

    lpInfo = (LPCDINFO) hCD;

    FirstTrackStart = CdTrackStart(hCD, lpInfo->FirstTrack);

    if (FirstTrackStart == INVALID_TRACK) {
	    return INVALID_TRACK;
    } else {
	    return reddiff(lpInfo->msfEnd, FirstTrackStart);
    }
}


/***************************************************************************

    @doc EXTERNAL

    @api DWORD | CdStatus | Get the disk status.

    @parm HCD | hCD | The handle of a currently open drive.

    @rdesc The return value is the current audio status.

***************************************************************************/

DWORD CdStatus(HCD hCD)
{
    LPCDINFO lpInfo;
    SUB_Q_CHANNEL_DATA sqd;
    CDROM_SUB_Q_DATA_FORMAT Format;
    DWORD CheckStatus;
    DWORD ReadStatus;
    UCHAR fStatus;

    lpInfo = (LPCDINFO) hCD;

    dprintf2(("CdStatus(%08XH)", hCD));

    Format.Format = IOCTL_CDROM_CURRENT_POSITION;

    FillMemory((PVOID)&sqd, sizeof(sqd), 0xFF);

    //
    // Check the disk status as well because IOCTL_CDROM_READ_Q_CHANNEL
    // can return ERROR_SUCCESS even if there's no disk (I don't know why - or
    // whether it's software bug in NT, hardware bug or valid!).
    //

    CheckStatus = cdIoctl(lpInfo, IOCTL_CDROM_CHECK_VERIFY, NULL, 0);

    if (ERROR_SUCCESS != CheckStatus) {
	    return DISC_NOT_READY;
    }

    ReadStatus = cdIoctlData(lpInfo, IOCTL_CDROM_READ_Q_CHANNEL,
					         &Format, sizeof(Format),
					         &sqd, sizeof(sqd));

    if (ReadStatus == ERROR_NOT_READY) {
	    if (ERROR_SUCCESS == cdGetDiskInfo(lpInfo)) {
		    ReadStatus = cdIoctlData(lpInfo, IOCTL_CDROM_READ_Q_CHANNEL,
			    			         &Format, sizeof(Format),
				    		         &sqd, sizeof(sqd));
        }
    }
    if (ERROR_SUCCESS != ReadStatus) {
	    //
	    // The read Q channel command is optional
	    //
	    dprintf1(("CdStatus - Failed to get Q channel data"));
	    return DISC_NOT_READY;
    }

    // Save previous audio status to prevent bug
    fStatus = sqd.CurrentPosition.Header.AudioStatus;
    CdSetAudioStatus (hCD, fStatus);

    dprintf4(("CdStatus - Status %02XH", fStatus));

    switch (fStatus) 
    {
    case AUDIO_STATUS_IN_PROGRESS:
	    dprintf4(("CdStatus - Playing"));
	    return DISC_PLAYING;
    
    case AUDIO_STATUS_PAUSED:
	    dprintf4(("CdStatus - Paused"));
	    return DISC_PAUSED;
    
    case AUDIO_STATUS_PLAY_COMPLETE:
	    dprintf4(("CdStatus - Stopped"));
	    return DISC_READY;

    case AUDIO_STATUS_NO_STATUS:
	    // Grab previous status instead
	    switch (lpInfo->fPrevStatus)
	    {
#if 0
	    // NOTE:  Be very careful before uncommenting the
	    //        following 3 lines, they basically cause
	    //        Play & wait to spin forever breaking
	    //        "Continous Play", "Random Order" in CDPLAYER
	    //        and MCI Play & wait commands.

	    //        Basically, I didn't have time to track down
	    //        the real problem.   Apparently, the driver
	    //        Is not returning AUDIO_STATUS_PLAY_COMPLETE
	    //        when the CD reaches the end of the current
	    //        play command.   From my end, MCICDA is not
	    //        receiving this.  ChuckP says the lowlevel 
	    //        driver is generating this status correctly.
        //        Which I have verified
	    //        So, the question is how is it getting lost?
	    case AUDIO_STATUS_IN_PROGRESS:
    	    dprintf4(("CdStatus - Playing (Prev)"));
	    	return DISC_PLAYING;
#endif
    
	    case AUDIO_STATUS_PAUSED:
	        dprintf4(("CdStatus - Paused (Prev)"));
		    return DISC_PAUSED;
    
	    case AUDIO_STATUS_PLAY_COMPLETE:
	        dprintf4(("CdStatus - Stopped (Prev)"));
		    return DISC_READY;

        case AUDIO_STATUS_NO_STATUS:
	    default:
		    break;
	    } // End switch
        dprintf4(("CdStatus - No status, assume stopped (Prev)"));
	    return DISC_READY;
 
	//
	// Some drives just return 0 sometimes - so we rely on the results of
	// CHECK_VERIFY in this case
	//
    default:
	    dprintf4(("CdStatus - No status, assume Stopped"));
	    return DISC_READY;
    }
} // End CdStatus


/***************************************************************************

    @doc EXTERNAL

    @api BOOL | CdEject | Eject the disk

    @parm HCD | hCD | The handle of a currently open drive.

    @rdesc The return value is the current status.

***************************************************************************/

BOOL CdEject(HCD hCD)
{
    LPCDINFO lpInfo;
    BOOL fResult;

    lpInfo = (LPCDINFO) hCD;

    dprintf2(("CdEject(%08XH)", hCD));

    fResult = (ERROR_SUCCESS == cdIoctl(lpInfo, IOCTL_CDROM_EJECT_MEDIA, NULL, 0));
    //if (fResult) {
	    // Save Audio Status to prevent bug
	//lpInfo->fPrevStatus = 0;
    //}
    return fResult;
}


/***************************************************************************

    @doc EXTERNAL

    @api BOOL | CdPause | Pause the playing

    @parm HCD | hCD | The handle of a currently open drive.

    @rdesc The return value is the current status.

***************************************************************************/

BOOL CdPause(HCD hCD)
{
    LPCDINFO lpInfo;

    lpInfo = (LPCDINFO) hCD;

    dprintf2(("CdPause(%08XH)", hCD));

    cdIoctl(lpInfo, IOCTL_CDROM_PAUSE_AUDIO, NULL, 0);

    //
    //  Ignore the return - we may have been paused or stopped already
    //

    return TRUE;
}


/***************************************************************************

    @doc EXTERNAL

    @api BOOL | CdResume | Resume the playing

    @parm HCD | hCD | The handle of a currently open drive.

    @rdesc The return value is the current status.

***************************************************************************/

BOOL CdResume(HCD hCD)
{
    LPCDINFO lpInfo;

    lpInfo = (LPCDINFO) hCD;

    dprintf2(("CdResume(%08XH)", hCD));

    return ERROR_SUCCESS == cdIoctl(lpInfo, IOCTL_CDROM_RESUME_AUDIO, NULL, 0);
}


/***************************************************************************

    @doc EXTERNAL

    @api BOOL | CdStop | Stop playing

    @parm HCD | hCD | The handle of a currently open drive.

    @rdesc The return value is the current status.  Note that not
	   all devices support stop

***************************************************************************/

BOOL CdStop(HCD hCD)
{
    LPCDINFO lpInfo;
    BOOL fResult;

    lpInfo = (LPCDINFO) hCD;

    dprintf2(("CdStop(%08XH)", hCD));

    fResult = (ERROR_SUCCESS == cdIoctl(lpInfo, IOCTL_CDROM_STOP_AUDIO, NULL, 0));

    if (fResult) 
    {
        lpInfo->fPrevStatus = AUDIO_STATUS_PLAY_COMPLETE;
    }
    return fResult;
}



/***************************************************************************

    @doc EXTERNAL

    @api BOOL | CdSetVolumeAll | Set the playing volume for all channels

    @parm HCD | hCD | The handle of a currently open drive.

    @parm UCHAR | Volume | The volume to set (FF = max)

    @rdesc The return value is the current status.

***************************************************************************/

BOOL CdSetVolumeAll(HCD hCD, UCHAR Volume)
{
    LPCDINFO        lpInfo;
    VOLUME_CONTROL  VolumeControl;
    DWORD           dwErr;

    lpInfo = (LPCDINFO) hCD;

    dprintf4(("CdSetVolumeAll(%08XH), Volume %u", hCD, Volume));
    
    //
    // Read the old values
    //
    dwErr = cdIoctl(lpInfo,
		            IOCTL_CDROM_GET_VOLUME,
		            (PVOID)&VolumeControl,
		            sizeof(VolumeControl));
    if (dwErr != ERROR_SUCCESS)
    {
        dprintf2(("CdSetVolumeAll(%08XH), Volume %u, Error = %lx", 
                  hCD, Volume, dwErr));

        return FALSE;
    }

    //  Set all channels to new volume
    VolumeControl.PortVolume[0] = Volume;
    VolumeControl.PortVolume[1] = Volume;
    VolumeControl.PortVolume[2] = Volume;
    VolumeControl.PortVolume[3] = Volume;

    // Save what we think it should be
    lpInfo->VolChannels[0] = Volume;
    lpInfo->VolChannels[1] = Volume;
    lpInfo->VolChannels[2] = Volume;
    lpInfo->VolChannels[3] = Volume;

    //
    // Not all CDs support volume setting so don't check the return code here
    //
    dwErr = cdIoctl(lpInfo, IOCTL_CDROM_SET_VOLUME,
	                (PVOID)&VolumeControl,
	                sizeof(VolumeControl));
    if (dwErr != ERROR_SUCCESS)
    {
        dprintf2(("CdSetVolumeAll(%08XH), Volume %u, Set Volume Failed (%08XH)", 
                  hCD, Volume, dwErr));
    }


#ifdef DEBUG
    // Double Check
    if (ERROR_SUCCESS != cdIoctl(lpInfo,
				                 IOCTL_CDROM_GET_VOLUME,
				                 (PVOID)&VolumeControl,
				                 sizeof(VolumeControl))) 
    {
        dprintf2(("CdSetVolumeAll(%08XH), Volume %u, Get Volume Failed (%08XH)", 
                  hCD, Volume, dwErr));
    }

    // Compare actual to what we think it should be
    if ((VolumeControl.PortVolume[0] != lpInfo->VolChannels[0]) ||
        (VolumeControl.PortVolume[1] != lpInfo->VolChannels[1]) ||
        (VolumeControl.PortVolume[2] != lpInfo->VolChannels[2]) ||
        (VolumeControl.PortVolume[3] != lpInfo->VolChannels[3]))
    {
        dprintf2(("CdSetVolumeAll(%08XH), Volume %u, Channels don't match [%lx,%lx,%lx,%lx] != [%lx,%lx,%lx,%lx]", 
                  hCD, Volume, 
                  (DWORD)VolumeControl.PortVolume[0],
                  (DWORD)VolumeControl.PortVolume[1],
                  (DWORD)VolumeControl.PortVolume[2],
                  (DWORD)VolumeControl.PortVolume[3],
                  (DWORD)lpInfo->VolChannels[0],
                  (DWORD)lpInfo->VolChannels[1],
                  (DWORD)lpInfo->VolChannels[2],
                  (DWORD)lpInfo->VolChannels[3]
                  ));
    }
#endif

    return TRUE;
}



/***************************************************************************

    @doc EXTERNAL

    @api BOOL | CdSetVolume | Set the playing volume for one channel

    @parm HCD | hCD | The handle of a currently open drive.

    @parm int | Channel | The channel to set

    @parm UCHAR | Volume | The volume to set (FF = max)

    @rdesc The return value is the current status.

***************************************************************************/

BOOL CdSetVolume(HCD hCD, int Channel, UCHAR Volume)
{
    LPCDINFO        lpInfo;
    VOLUME_CONTROL  VolumeControl;
    DWORD           dwErr;

    lpInfo = (LPCDINFO) hCD;

    dprintf4(("CdSetVolume(%08XH), Channel %d Volume %u", hCD, Channel, Volume));
    
    VolumeControl.PortVolume[0] = lpInfo->VolChannels[0];
    VolumeControl.PortVolume[1] = lpInfo->VolChannels[1];
    VolumeControl.PortVolume[2] = lpInfo->VolChannels[2];
    VolumeControl.PortVolume[3] = lpInfo->VolChannels[3];

    //
    // Read the old values
    //

    dwErr = cdIoctl(lpInfo,
		            IOCTL_CDROM_GET_VOLUME,
		            (PVOID)&VolumeControl,
		            sizeof(VolumeControl));
    if (dwErr != ERROR_SUCCESS)
    {
        dprintf2(("CdSetVolume(%08XH), Channel %u, Volume %u, Error = %lx", 
                  hCD, Channel, Volume, dwErr));

        return FALSE;
    }


    // Check if it is already the correct value
    if (VolumeControl.PortVolume[Channel] == Volume)
    {
        // Nothing to do
        dprintf2(("CdSetVolume(%08XH), Channel %u, Volume %u, Already this volume!!!", 
                  hCD, Channel, Volume));

        return TRUE;
    }

    lpInfo->VolChannels[Channel] = Volume;
    VolumeControl.PortVolume[Channel] = Volume;

    //
    // Not all CDs support volume setting so don't check the return code here
    //
    dwErr = cdIoctl(lpInfo, IOCTL_CDROM_SET_VOLUME,
	                (PVOID)&VolumeControl,
	                sizeof(VolumeControl));
    if (dwErr != ERROR_SUCCESS)
    {
        dprintf2(("CdSetVolume(%08XH), Channel %d, Volume %u, Set Volume Failed (%08XH)", 
                  hCD, Channel, Volume, dwErr));
    }


#ifdef DEBUG
    //
    // Double Check our results
    //
    if (ERROR_SUCCESS != cdIoctl(lpInfo,
				                 IOCTL_CDROM_GET_VOLUME,
				                 (PVOID)&VolumeControl,
				                 sizeof(VolumeControl))) 
    {
        dprintf2(("CdSetVolumeAll(%08XH), Volume %u, Get Volume Failed (%08XH)", 
                  hCD, Volume, dwErr));
    }

    // Compare actual to what we think it should be
    if ((VolumeControl.PortVolume[0] != lpInfo->VolChannels[0]) ||
        (VolumeControl.PortVolume[1] != lpInfo->VolChannels[1]) ||
        (VolumeControl.PortVolume[2] != lpInfo->VolChannels[2]) ||
        (VolumeControl.PortVolume[3] != lpInfo->VolChannels[3]))
    {
        dprintf2(("CdSetVolume (%08XH), Channel %u, Volume %u, Channels don't match [%lx,%lx,%lx,%lx] != [%lx,%lx,%lx,%lx]", 
                  hCD, Channel, Volume, 
                  (DWORD)VolumeControl.PortVolume[0],
                  (DWORD)VolumeControl.PortVolume[1],
                  (DWORD)VolumeControl.PortVolume[2],
                  (DWORD)VolumeControl.PortVolume[3],
                  (DWORD)lpInfo->VolChannels[0],
                  (DWORD)lpInfo->VolChannels[1],
                  (DWORD)lpInfo->VolChannels[2],
                  (DWORD)lpInfo->VolChannels[3]
                  ));
    }
#endif

    return TRUE;
}



/***************************************************************************

    @doc EXTERNAL

    @api BOOL | CdCloseTray | Close the tray

    @parm HCD | hCD | The handle of a currently open drive.

    @rdesc The return value is the current status.

***************************************************************************/

BOOL CdCloseTray(HCD hCD)
{
    LPCDINFO lpInfo;
    BOOL fResult;

    lpInfo = (LPCDINFO) hCD;

    dprintf2(("CdCloseTray(%08XH)", hCD));

    fResult = (ERROR_SUCCESS == cdIoctl(lpInfo, IOCTL_CDROM_LOAD_MEDIA, NULL, 0));
    //if (fResult) {
	// Save Audio Status to prevent bug
	//    lpInfo->fPrevStatus = 0;
    //}
    return fResult;
}



/***************************************************************************

    @doc EXTERNAL

    @api BOOL | CdNumTracks | Return the number of tracks and check
	ready (updating TOC) as a side-effect.

    @parm HCD | hCD | The handle of a currently open drive.

    @rdesc The return value is the current status.

***************************************************************************/

int CdNumTracks(HCD hCD)
{
    LPCDINFO lpInfo;
    DWORD Status;
    MSF Position;
    MSF Temp;

    lpInfo = (LPCDINFO) hCD;

    dprintf2(("CdNumTracks(%08XH)", hCD));

    //
    // If the driver does NOT cache the table of contents then we may
    // fail if a play is in progress
    //
    // However, if we don't have a valid TOC to work with then we'll just
    // have to blow away the play anyway.
    //

    if (!lpInfo->bTOCValid) {
	    Status = cdGetDiskInfo(lpInfo);

	    if (ERROR_SUCCESS != Status) {

	        //
	        // See if we failed because it's playing
	        //

	        if (Status == ERROR_BUSY) {
		        if (!lpInfo->bTOCValid) {
		            int i;

		            //
		            // Stop it one way or another
		            // Note that pause is no good because in a paused
		            // state we may still not be able to read the TOC
		            //


		            if (!CdPosition(hCD, &Temp, &Position)) {
			            CdStop(hCD);
		            } else {

			            //
			            // Can't call CdPlay because this needs a valid
			            // position!
			            //
			            CDROM_PLAY_AUDIO_MSF msfPlay;

			            //
			            // Set up the data for the call to the driver
			            //

			            msfPlay.StartingM = REDMINUTE(Position);
			            msfPlay.StartingS = REDSECOND(Position);
			            msfPlay.StartingF = REDFRAME(Position);
			            msfPlay.EndingM = REDMINUTE(Position);
			            msfPlay.EndingS = REDSECOND(Position);
			            msfPlay.EndingF = REDFRAME(Position);

			            cdIoctl(lpInfo, IOCTL_CDROM_PLAY_AUDIO_MSF, &msfPlay,
						        sizeof(msfPlay));
		            }

		            //
		            // Make sure the driver knows it's stopped and
		            // give it a chance to stop.
		            // (NOTE - Sony drive can take around 70ms)
		            //

		            for (i = 0; i < 60; i++) {
			            if (CdStatus(hCD) == DISC_PLAYING) {
			                Sleep(10);
			            } else {
			                break;
			            }
		            }

		            dprintf2(("Took %d tries to stop it!", i));

		            //
		            //  Have another go
		            //

		            if (ERROR_SUCCESS != cdGetDiskInfo(lpInfo)) {
			            return 0;
		            }
		        }
	        } else {
		        return 0;
	        }

	    }
    }
    return lpInfo->LastTrack - lpInfo->FirstTrack + 1;
}

/***************************************************************************

    @doc EXTERNAL

    @api DWORD | CdDiskID | Return the disk id

    @parm HCD | hCD | The handle of a currently open drive.

    @rdesc The return value is the disk id or -1 if it can't be found.

***************************************************************************/

DWORD CdDiskID(HCD hCD)
{
    LPCDINFO lpInfo;
    UINT     i;
    DWORD    id;

    dprintf2(("CdDiskID"));

    lpInfo = (LPCDINFO) hCD;

    if (!lpInfo->bTOCValid) {
        if (ERROR_SUCCESS != cdGetDiskInfo(lpInfo))
        {
	        dprintf2(("CdDiskID - Invalid TOC"));
	        return (DWORD)-1;
        }
    }

    for (i = 0, id = 0;
	     i < (UINT)(lpInfo->LastTrack - lpInfo->FirstTrack + 1);
	     i++) {
	    id += lpInfo->Track[i].msfStart & 0x00FFFFFF;
    }

    if (lpInfo->LastTrack - lpInfo->FirstTrack + 1 <= 2) {
	    id += CDA_red2bin(reddiff(lpInfo->leadout, lpInfo->Track[0].msfStart));
    }

    return id;
}

/***************************************************************************

    @doc EXTERNAL

    @api BOOL | CdDiskUPC | Return the disk UPC code

    @parm HCD | hCD | The handle of a currently open drive.

    @parm LPTSTR | upc | Where to put the upc

    @rdesc TRUE or FALSE if failed

***************************************************************************/

BOOL CdDiskUPC(HCD hCD, LPTSTR upc)
{
    LPCDINFO                lpInfo;
    SUB_Q_CHANNEL_DATA      sqd;
    CDROM_SUB_Q_DATA_FORMAT Format;
    DWORD                   Status;
    UINT                    i;


    dprintf2(("CdDiskUPC"));

    Format.Format = IOCTL_CDROM_MEDIA_CATALOG;
    Format.Track  = 0;

    lpInfo = (LPCDINFO) hCD;

    Status = cdIoctlData(lpInfo, IOCTL_CDROM_READ_Q_CHANNEL,
			             &Format, sizeof(Format),
			             &sqd, sizeof(SUB_Q_MEDIA_CATALOG_NUMBER));

    if (ERROR_SUCCESS != Status) {
	    return FALSE;
    }

    // Save previous audio status to prevent bug
    CdSetAudioStatus (hCD, sqd.CurrentPosition.Header.AudioStatus);
    
    //
    //  See if there's anything there
    //

    if (!sqd.MediaCatalog.Mcval ||
	     sqd.MediaCatalog.FormatCode != IOCTL_CDROM_MEDIA_CATALOG) {
	    return FALSE;
    }

    //
    //  Check the upc format :
    //
    //  1.  ASCII               at least 12 ASCII digits
    //  2.  packed bcd          6 packed BCD digits
    //  3.  unpacked upc
    //

    if (sqd.MediaCatalog.MediaCatalog[9] >= TEXT('0')) {
	    for (i = 0; i < 12; i++) {
	        if (sqd.MediaCatalog.MediaCatalog[i] < TEXT('0') ||
		        sqd.MediaCatalog.MediaCatalog[i] > TEXT('9')) {
		        return FALSE;
	        }
	    }
	    wsprintf(upc, TEXT("%12.12hs"), sqd.MediaCatalog.MediaCatalog);
	    return TRUE;
    }

    //
    //  See if it's packed or unpacked.
    //

    for (i = 0; i < 6; i++) {
	    if (sqd.MediaCatalog.MediaCatalog[i] > 9) {
	        //
	        //  Packed - unpack
	        //

	        for (i = 6; i > 0; i --) {
		        UCHAR uBCD;

		        uBCD = sqd.MediaCatalog.MediaCatalog[i - 1];

		        sqd.MediaCatalog.MediaCatalog[i * 2 - 2] = (UCHAR)(uBCD >> 4);
		        sqd.MediaCatalog.MediaCatalog[i * 2 - 1] = (UCHAR)(uBCD & 0x0F);
	        }

	        break;
	    }
    }

    //
    //  Check everything is in range
    //

    for (i = 0; i < 12; i++) {
	    if (sqd.MediaCatalog.MediaCatalog[i] > 9) {
	        return FALSE;
	    }
    }
    for (i = 0; i < 12; i++) {
	    if (sqd.MediaCatalog.MediaCatalog[i] != 0) {
	        //
	        //  There is a real media catalog
	        //
	        for (i = 0 ; i < 12; i++) {
		        wsprintf(upc + i, TEXT("%01X"), sqd.MediaCatalog.MediaCatalog[i]);
	        }

	        return TRUE;
	    }
    }

    return FALSE;
}

/***************************************************************************

    @doc EXTERNAL

    @api BOOL | CdGetDrive | Return the drive id if matches one in our
	  list

    @parm LPTSTR | lpstrDeviceName | Name of the device

    @parm DID * | pdid | Where to put the id

    @rdesc TRUE or FALSE if failed

    @comm We allow both the device form and drive form eg:

	    f:
	    \\.\f:

***************************************************************************/

BOOL CdGetDrive(LPCTSTR lpstrDeviceName, DID * pdid)
{
    DID didSearch;
	TCHAR szDeviceName[10];
	TCHAR szDeviceNameOnly[10];
	
    dprintf2(("CdGetDrive"));

    for (didSearch = 0; didSearch < NumDrives; didSearch++) {
	    wsprintf(szDeviceNameOnly, TEXT("%c:"), lpstrDeviceName[0]);
		wsprintf(szDeviceName, TEXT("%c:"), CdInfo[didSearch].cDrive);
		if (lstrcmpi(szDeviceName, szDeviceNameOnly) == 0) {
	        *pdid = didSearch;
	        return TRUE;
	    }
		
		wsprintf(szDeviceNameOnly, TEXT("\\\\.\\%c:"), lpstrDeviceName[0]);
		wsprintf(szDeviceName, TEXT("\\\\.\\%c:"), CdInfo[didSearch].cDrive);
	    if (lstrcmpi(szDeviceName, szDeviceNameOnly) == 0) {
	        *pdid = didSearch;
	        return TRUE;
	    }
    }

    return FALSE;
}




/***************************************************************************

    @doc EXTERNAL

    @api DWORD | CdStatusTrackPos | Get the disk status,track,and pos.

    @parm HCD | hCD | The handle of a currently open drive.
           
    @parm DWORD * | pStatus | return status code here

    @parm MSF * | pTrackTime | return Track Time here

    @parm MSF * | pDiscTime | return Track Time here

    @rdesc The return value is success/failure.

    This function does an end run around to get past the MCI functionality
    In other words it is a major HACK.   The only compelling reason for
    this function is that it reduces the number of IOCTL's that CDPLAYER
    generates every 1/2 second from ~15 to 1 on average.  Reducing system
    traffic for SCSI drives by a substantial factor

***************************************************************************/

BOOL CdStatusTrackPos (
    HCD     hCD, 
    DWORD * pStatus,
    MSF *   pTrackTime,
    MSF *   pDiscTime)
{
    LPCDINFO                lpInfo;
    SUB_Q_CHANNEL_DATA      sqd;
    CDROM_SUB_Q_DATA_FORMAT Format;
    DWORD                   CheckStatus;
    DWORD                   ReadStatus;
    MSF                     msfPos;
    BOOL                    fTryAgain = TRUE;
    UCHAR                   fStatus;
    UCHAR                   fCode;
    UCHAR                   cTrack;

    // Check hCD
    lpInfo = (LPCDINFO) hCD;
    if (!lpInfo)
    {
        dprintf2(("CdStatusTrackPos(%08LX), invalid hCD", hCD));
    	return FALSE;
    }

    // Check parameters
    if ((!pStatus) || (!pTrackTime) || (!pDiscTime))
    {
        dprintf2(("CdStatusTrackPos(%c), invalid parameters", (char)(lpInfo->cDrive)));
	    return FALSE;
    }

    dprintf2(("CdStatusTrackPos(%08LX, %c), Enter", 
              hCD, (char)(lpInfo->cDrive)));


lblTRYAGAIN:

    *pStatus    = DISC_NOT_READY;
    *pTrackTime = REDTH(0, 1);
	*pDiscTime  = REDTH(0, 0);

    Format.Format = IOCTL_CDROM_CURRENT_POSITION;
    FillMemory((PVOID)&sqd, sizeof(sqd), 0xFF);

	//
	// Read position and status
	//
    ReadStatus = cdIoctlData(lpInfo, IOCTL_CDROM_READ_Q_CHANNEL,
					         &Format, sizeof(Format), &sqd, sizeof(sqd));

    switch (ReadStatus)
    {
    case ERROR_NOT_READY:
        // Don't give up yet
        if (fTryAgain)
        {
	        if (ERROR_SUCCESS == cdGetDiskInfo(lpInfo)) 
	        {
	            // Try one more time before admitting defeat
	            fTryAgain = FALSE;
	            goto lblTRYAGAIN;
	        }
	    }
	    // Give up !!!
        dprintf2(("CdStatusTrackPos(%08LX, %c), ReadQChannel = ERROR_NOT_READY", 
                  hCD, (char)(lpInfo->cDrive)));
        return FALSE;

    case STATUS_VERIFY_REQUIRED:
	    // Check if disk is still in drive
	    CheckStatus = cdIoctl (lpInfo, IOCTL_CDROM_CHECK_VERIFY, NULL, 0);
	    switch (CheckStatus)
	    {
		    case ERROR_NO_MEDIA_IN_DRIVE:
		    case ERROR_UNRECOGNIZED_MEDIA:
		    case ERROR_NOT_READY:
            default:
	            *pStatus = DISC_NOT_READY;
                break;

	        case ERROR_SUCCESS:
                *pStatus = DISC_READY;
                break;
	    }
	    break;
    
    case ERROR_INVALID_FUNCTION:
        dprintf2(("CdStatusTrackPos(%08LX, %c), ReadQChannel = ERROR_INVALID_FUNCTION failed", 
                  hCD, (char)(lpInfo->cDrive)));
		*pTrackTime = REDTH(0, 1);
		*pDiscTime = REDTH(0, 0);

        CdGetAudioStatus (hCD, 0, pStatus);
		return TRUE;

    case ERROR_SUCCESS:
	    // Success, fall through
        fStatus = sqd.CurrentPosition.Header.AudioStatus;
        fCode   = sqd.CurrentPosition.FormatCode;
        cTrack  = sqd.CurrentPosition.TrackNumber;
	    break;

    default:
	    // Failed
        dprintf2(("CdStatusTrackPos(%08LX, %c), ReadQChannel = unknown error (%08LX) failed", 
                  hCD, (char)(lpInfo->cDrive), (DWORD)ReadStatus));
	    return FALSE;
    }

    // Save previous audio status to prevent bug
    CdSetAudioStatus (hCD, fStatus);

	// Translate status code
    CdGetAudioStatus (hCD, fStatus, pStatus);    

    dprintf2(("CdStatusTrackPos - Status %02XH", fStatus));

    //
    // Get Position
    //

    // If the track > 100  (outside spec'ed range)
	// OR track > last track number
	// then display an error message
	if ((fCode == 0x01) &&
	    ((100 < cTrack) || 
	     ((lpInfo->bTOCValid) && 
	      (lpInfo->LastTrack < cTrack)))) 
    {
		// Always display this message on checked builds.
		// We need some feeling for how often this happens
		// It should NEVER happen, but (at least for NEC
		// drives) we see it after a seek to end
		dprintf1(("CDIoctlData returned track==%d, retrying", cTrack));

    	if (fTryAgain)
	    {
            // Try one more time
	        fTryAgain = FALSE;
	        goto lblTRYAGAIN;
	    }
	}


	dprintf4(("Status = %02X, Length[0] = %02X, Length[1] = %02X",
		     fStatus,
		     sqd.CurrentPosition.Header.DataLength[0],
		     sqd.CurrentPosition.Header.DataLength[1]));

	dprintf4(("  Format %02XH", fCode));
	dprintf4(("  Absolute Address %02X%02X%02X%02XH",
     		 sqd.CurrentPosition.AbsoluteAddress[0],
	    	 sqd.CurrentPosition.AbsoluteAddress[1],
		     sqd.CurrentPosition.AbsoluteAddress[2],
		     sqd.CurrentPosition.AbsoluteAddress[3]));
	dprintf4(("  Relative Address %02X%02X%02X%02XH",
		     sqd.CurrentPosition.TrackRelativeAddress[0],
		     sqd.CurrentPosition.TrackRelativeAddress[1],
		     sqd.CurrentPosition.TrackRelativeAddress[2],
		     sqd.CurrentPosition.TrackRelativeAddress[3]));

	if (fCode == 0x01)
    {        
    	// MSF format ?

	    // data is current position

	    msfPos = MAKERED(sqd.CurrentPosition.AbsoluteAddress[1],
			             sqd.CurrentPosition.AbsoluteAddress[2],
			             sqd.CurrentPosition.AbsoluteAddress[3]);

	    //
		// If position is 0 (this seems to happen on the Toshiba) then
		// we'll try again
		//
	    if (msfPos == 0) 
	    {
	        if (fTryAgain)
	        {
	    	    fTryAgain = FALSE;
		        goto lblTRYAGAIN;
	        }

            dprintf3(("CdStatusTrackPos(%08LX, %c), Position = 0", 
                     hCD, (char)(lpInfo->cDrive), (DWORD)ReadStatus));
	        return FALSE;
	    }

	    dprintf4(("CdStatusTrackPos - MSF disk pos: %u, %u, %u",
		         REDMINUTE(msfPos), REDSECOND(msfPos), REDFRAME(msfPos)));
	    *pDiscTime = REDTH(msfPos, cTrack);

	    // data is current position

	    msfPos = MAKERED(sqd.CurrentPosition.TrackRelativeAddress[1],
			             sqd.CurrentPosition.TrackRelativeAddress[2],
			             sqd.CurrentPosition.TrackRelativeAddress[3]);

	    dprintf4(("CdStatusTrackPos - MSF track pos (t,m,s,f): %u, %u, %u, %u",
		         cTrack, REDMINUTE(msfPos), REDSECOND(msfPos), REDFRAME(msfPos)));
	    *pTrackTime = REDTH(msfPos, cTrack);

	    return TRUE;
    }

    dprintf1(("CdStatusTrackPos - Failed to read cd position"));
    return FALSE;
}




/***************************************************************************

    @doc INTERNAL

    @api BOOL | CdSetAudioStatus | 

    @rdesc TRUE or FALSE if failed

***************************************************************************/

void CdSetAudioStatus (HCD hCD, UCHAR fStatus)
{
    LPCDINFO lpInfo;

    if (! hCD)
        return;

    lpInfo = (LPCDINFO)hCD;

        // Save Old status
    switch (fStatus)
    {
    case AUDIO_STATUS_NO_STATUS:
        // Do nothing
        break;

    case AUDIO_STATUS_NOT_SUPPORTED:
    case AUDIO_STATUS_IN_PROGRESS:
    case AUDIO_STATUS_PAUSED:
    case AUDIO_STATUS_PLAY_COMPLETE:
    case AUDIO_STATUS_PLAY_ERROR:
    default:
        // Save previous state
        lpInfo->fPrevStatus = fStatus;
        break;
    }
} // End CdSetAudioStatus



/***************************************************************************

    @doc INTERNAL

    @api BOOL | CdGetAudioStatus | 

    @rdesc TRUE or FALSE if failed

***************************************************************************/

BOOL CdGetAudioStatus (HCD hCD, UCHAR fStatus, DWORD * pStatus)
{
    LPCDINFO lpInfo;
    DWORD CheckStatus;

    if ((! hCD) || (!pStatus))
        return FALSE;

    lpInfo = (LPCDINFO)hCD;


	// Get status code
    switch (fStatus)
    {
    case AUDIO_STATUS_IN_PROGRESS:
        *pStatus = DISC_PLAYING;
        break;
    
    case AUDIO_STATUS_PAUSED:
        *pStatus = DISC_PAUSED;
        break;
    
    case AUDIO_STATUS_PLAY_COMPLETE:
        *pStatus = DISC_READY;
        break;

    case AUDIO_STATUS_NO_STATUS:
	    // Grab previous status instead
	    switch (lpInfo->fPrevStatus)
	    {
#if 0            
	    // NOTE:  Be very careful before uncommenting
	    //        The following 3 lines, they basically
	    //        Cause Play & wait on IDE CD-ROMS to
	    //        spin forever breaking "Continous Play", 
        //        "Random Order" in CDPLAYER and
	    //        MCI Play & wait commands.

	    //        Basically, I didn't have time to track down
	    //        the real problem.   Apparently, the driver
	    //        Is not returning AUDIO_STATUS_PLAY_COMPLETE
	    //        when the CD reaches the end of the current
	    //        play command.   From my end, MCICDA is not
	    //        receiving this.  ChuckP says the lowlevel 
	    //        driver is generating this status correctly.
        //        Which I have verified
	    //        So, the question is how is it getting lost?
	    case AUDIO_STATUS_IN_PROGRESS:
	        *pStatus = DISC_PLAYING;
            break;
#endif
    
	    case AUDIO_STATUS_PAUSED:
	        *pStatus = DISC_PAUSED;
		    break;
    
	    case AUDIO_STATUS_PLAY_COMPLETE:
	        *pStatus = DISC_READY;
		    break;

	    default:
	        // We are in a broken state, so just
	        // assume we are stopped, it's the safest
	        *pStatus = DISC_READY;
		    break;
	    } // End switch
    	break;
 
	//
	// Some drives just return 0 sometimes - so we rely on the results of
	// CHECK_VERIFY in this case
	//
    default:
	    // Check if disk is still in drive
	    CheckStatus = cdIoctl (lpInfo, IOCTL_CDROM_CHECK_VERIFY, NULL, 0);
        if (ERROR_SUCCESS != CheckStatus) 
        {
	        *pStatus = DISC_NOT_READY;
        }
        else
        {
            *pStatus = DISC_READY;
        }
	    break;
    } // End Switch

    // Success
    return TRUE;
} // CdGetAudioStatus



  
/***************************************************************************

    @doc EXTERNAL

    @api MSF | CdGetTrack | Given a position to find the corresponding track
    if any

    @parm LPCDINFO | lpInfo | Pointer to CD info including track data.

    @parm MSF | msfStart | Position to start looking.

    @rdesc A new MSF to play from / seek to  within an audio track or
	the end of the CD if none was found.

***************************************************************************/

BOOL CdGetTrack(
    LPCDINFO lpInfo, 
    MSF      msfPos, 
    UCHAR *  pTrack, 
    MSF *    pmsfStart)
{
    UINT tracknum;
    MSF  lastaudio = lpInfo->msfEnd;

    //
    // Search for the track which ends after ours and is audio
    //

    for (tracknum = 0; ;tracknum++) {

	    //
	    // Note that some CDs return positions outside the playing range
	    // sometimes (notably 0) so msfStart may be less than the first
	    // track start
	    //

	    //
	    // If we're beyond the start of the track and before the start
	    // of the next track then this is the track we want.
	    //
	    // We assume we're always beyond the start of the first track
	    // and we check that if we're looking at the last track then
	    // we check we're before the end of the CD.
	    //

	    if ((msfPos >= lpInfo->Track[tracknum].msfStart || tracknum == 0)
	    &&
	        (tracknum + lpInfo->FirstTrack == lpInfo->LastTrack
	        ? msfPos <= lpInfo->msfEnd
	        : msfPos < lpInfo->Track[tracknum + 1].msfStart)) 
        {
	        if (!(lpInfo->Track[tracknum].Ctrl & IS_DATA_TRACK)) 
            {
                *pTrack     = lpInfo->Track[tracknum].TrackNumber;
                *pmsfStart  = lpInfo->Track[tracknum].msfStart;
		        return TRUE;
	        }
	    }

	    //
	    // Exhausted all tracks ?
	    //

	    if (tracknum + lpInfo->FirstTrack >= lpInfo->LastTrack)
        {
	        return FALSE;
	    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcicda\debug.c ===
/* Copyright (c) 1991-1994 Microsoft Corporation */
/*
    debug.c

    Support code for the dprintf routines.

    Note that all of this is conditional on the DBG flag

*/


#include <windows.h>            // private include file
#include <mmsystem.h>
#include "mcicda.h"
#include "cda.h"
#include "cdio.h"
#include <stdio.h>
#include <stdarg.h>

#if DBG
int DebugLevel = 1;

/***************************************************************************

    @doc INTERNAL

    @api void | mcicdaDbgOut | This function sends output to the current
        debug output device.

    @parm LPSTR | lpszFormat | Pointer to a printf style format string.
    @parm ??? | ... | Args.

    @rdesc There is no return value.

****************************************************************************/

void mcicdaDbgOut(LPSTR lpszFormat, ...)
{
    char buf[512];
    UINT n;
    va_list va;


    n = wsprintfA(buf, "MCICDA: (tid %x) ", GetCurrentThreadId());

    va_start(va, lpszFormat);
    n += vsprintf(buf+n, lpszFormat, va);
    va_end(va);

    buf[n++] = '\n';
    buf[n] = 0;
    OutputDebugStringA(buf);
    Sleep(0);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcicda\mcicda.h ===
/*******************************Module*Header*********************************\
* Module Name: mcicda.h
*
* Media Control Architecture Redbook CD Audio Driver
*
* Created:
* Author:
*
* History:
*
* Internal data structures
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\****************************************************************************/
#define MCIRBOOK_MAX_DRIVES 26

#define MCICDAERR_NO_TIMERS (MCIERR_CUSTOM_DRIVER_BASE)
#define IDS_PRODUCTNAME         1
#define IDS_CDMUSIC             2
#define IDS_CDMUSICCAPTION      3

#define MCI_CDA_AUDIO_S         96
#define MCI_CDA_OTHER_S         97

#define MCI_STATUS_TRACK_POS    0xBEEF

#ifndef cchLENGTH
#define cchLENGTH(_sz) (sizeof(_sz)/sizeof(_sz[0]))
#endif

extern HANDLE hInstance;

/* Instance data type */
typedef struct tag_INSTDATA
{
    MCIDEVICEID uMCIDeviceID;      /* MCI Device ID */
    UINT        uDevice;           /* Index of physical device */
    DWORD       dwTimeFormat;      /* Current instance time format */
                                   //    MCI_FORMAT_MSF - minutes, seconds, frames
                                   //    MCI_FORMAT_TMSF - tracks, minutes ...
                                   //    MCI_FORMAT_MILLISECONDS
} INSTDATA, *PINSTDATA;

typedef struct
{
    HWND   hCallback;         /* Handle to window function to call back     */
    BOOL   bDiscPlayed;       /* TRUE if the disk was played since it       */
                              /* was changed                                */
    BOOL   bActiveTimer;      /* TRUE if waiting to notify                  */
    DWORD  dwPlayTo;          /* Last position being played to              */
    MCIDEVICEID wDeviceID;    /* MCI device ID for this drive */
    BOOL   bShareable;        /* If the device was opened shareable         */
    int    nUseCount;         /* Number of current opens on the device      */
} DRIVEDATA;

typedef struct
{
    DWORD   dwStatus;
    DWORD   dwTrack;
    DWORD   dwDiscTime;
} STATUSTRACKPOS, *PSTATUSTRACKPOS;

extern DWORD FAR PASCAL CD_MCI_Handler (MCIDEVICEID wDeviceID,
                                        UINT message, DWORD_PTR lParam1,
                                        DWORD_PTR lParam2);

extern DWORD CDAudio_GetUnitVolume     (UINT uDrive);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcicda\mcicda.c ===
/*******************************Module*Header*********************************\
* Module Name: mcicda.c
*
* Media Control Architecture Redbook CD Audio Driver
*
* Created: 4/25/90
* Author:  DLL (DavidLe)
*
* History:
*   DavidLe - Based on MCI Pioneer Videodisc Driver
*   MikeRo 12/90 - 1/91
*   RobinSp 10th March 1992 - Move to Windows NT
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "mcicda.h"
#include "cda.h"
#include "cdio.h"

#define CHECK_MSF

#define MCICDA_BAD_TIME 0xFFFFFFFF

HANDLE hInstance;

UINT_PTR wTimerID;
int nWaitingDrives;

DRIVEDATA DriveTable[MCIRBOOK_MAX_DRIVES];

// MBR This

void CALLBACK TimerProc (
HWND hwnd,
UINT uMessage,
UINT uTimer,
DWORD dwParam)
{
    DID i;
    int wStatus;

    for (i = 0; i < MCIRBOOK_MAX_DRIVES; ++i) {

	EnterCrit( CdInfo[i].DeviceCritSec );

	if (DriveTable[i].bActiveTimer) {

	    // MBR can other conditions beside successful completion of the
	    // play cause the != DISC_PLAYING?
	    if ((wStatus = CDA_drive_status (i)) != DISC_PLAYING)
	    {

		if (--nWaitingDrives <= 0)
		    KillTimer (NULL, uTimer);
		DriveTable[i].dwPlayTo = MCICDA_BAD_TIME;
		DriveTable[i].bActiveTimer = FALSE;

		switch (wStatus)
		{
		    case DISC_PLAYING:
		    case DISC_PAUSED:
		    case DISC_READY:
			wStatus = MCI_NOTIFY_SUCCESSFUL;
			break;
		    default:
			wStatus = MCI_NOTIFY_FAILURE;
			break;
		}
		mciDriverNotify (DriveTable[i].hCallback,
				 DriveTable[i].wDeviceID, wStatus);
	    }
	}

	LeaveCrit( CdInfo[i].DeviceCritSec );
    }
}

/*****************************************************************************

 @doc INTERNAL MCICDA

 @api UINT | notify | This function handles the notify
     for all mci commands.

 @parm DID | didDrive | Drive identifier

 @parm WORD | wDeviceID | Calling device ID

 @parm BOOL | wStartTimer | A boolean indicating that a timer is to be
       started

 @parm UINT | wFlag | The flag to be passed by mciDriverNotify

 @parm LPMCI_GENERIC_PARMS | lpParms | For direct callback

*****************************************************************************/
UINT
notify ( DID didDrive,
	 MCIDEVICEID wDeviceID,
	 BOOL wStartTimer,
	 UINT wFlag,
	 LPMCI_GENERIC_PARMS lpParms)
{

    if (DriveTable[didDrive].bActiveTimer)
    {
	mciDriverNotify (DriveTable[didDrive].hCallback, wDeviceID,
			 MCI_NOTIFY_SUPERSEDED);
	if (--nWaitingDrives <= 0)
	    KillTimer (NULL, wTimerID);
	DriveTable[didDrive].bActiveTimer = FALSE;
    }

    if (!wStartTimer)
	mciDriverNotify ((HWND)lpParms->dwCallback, wDeviceID,
			 wFlag);
    else
    {
	if (!DriveTable[didDrive].bActiveTimer &&
		nWaitingDrives++ == 0)
	{

	    // MBR every 1/10 of a sec. Should this be a parameter?
	    wTimerID = SetTimer (NULL, 1, 100, (TIMERPROC)TimerProc);
	    if (wTimerID == 0)
		return MCICDAERR_NO_TIMERS;
	}

	DriveTable[didDrive].wDeviceID = wDeviceID;
	DriveTable[didDrive].bActiveTimer = TRUE;
	DriveTable[didDrive].hCallback = (HANDLE)lpParms->dwCallback;
    }
    return 0;
}

/*****************************************************************************
 @doc INTERNAL MCICDA

 @api   void | abort_notify |

 @parm  PINSTDATA | pInst | application instance data

 @rdesc

 @comm

*****************************************************************************/
void abort_notify (PINSTDATA pInst)
{
    DID didDrive = pInst->uDevice;
    if (DriveTable[didDrive].bActiveTimer)
    {
	mciDriverNotify (DriveTable[didDrive].hCallback,
			 pInst->uMCIDeviceID,
			 MCI_NOTIFY_ABORTED);
	// Kill timer if appropriate
	if (--nWaitingDrives == 0)
	    KillTimer (NULL, wTimerID);
	DriveTable[didDrive].dwPlayTo = MCICDA_BAD_TIME;
	DriveTable[didDrive].bActiveTimer = FALSE;
    }
}

/*
    Return TRUE if the drive is in a playable state
*/

UINT disc_ready (DID didDrive)
{
    // The disk is ready if we can read its TOC (note the
    // kernel driver works out if the TOC really needs reading
    if (CDA_disc_ready(didDrive)) {

	if (CDA_num_tracks(didDrive)) {
	    return TRUE;
	} else {
	    CDA_reset_drive(didDrive);
	    return FALSE;
	}

    } else
	return FALSE;
}

/*
 * @func redbook | flip3 | Put minute/second/frame values in different order
 *
 * @parm redbook | rbIn | Current position as track|minute|second|frame
 *
 * @rdesc (redbook)0|frame|second|minute
 */

redbook flip3 (redbook rbIn)
{
    return MAKERED(MCI_MSF_MINUTE(rbIn),
		   MCI_MSF_SECOND(rbIn),
		   MCI_MSF_FRAME(rbIn));
}

/*
 * @func redbook | flip4 | Put track/minute/second/frame values in different order
 *
 * @parm redbook | rbIn | Current position as track|minute|second|frame
 *
 * @rdesc (redbook)frame|second|minute|track
 */

redbook flip4 (redbook rbIn)
{
    redbook rbOut;

    LPSTR lpOut = (LPSTR)&rbOut,
	  lpIn = (LPSTR)&rbIn;

    lpOut[0] = lpIn[3];
    lpOut[1] = lpIn[2];
    lpOut[2] = lpIn[1];
    lpOut[3] = lpIn[0];

    return rbOut;
}

// MBR Return the absolute redbook time of track sTrack, rbTime into track

/*****************************************************************************
 @doc INTERNAL MCICDA

 @api   redbook | track_time | Return the absolute redbook time of
	     track sTrack, rbTime into track

 @parm  DID | didDrive |

 @parm  int | sTrack |

 @parm  redbook | rbTime |

 @rdesc

 @comm
*****************************************************************************/
redbook track_time (DID didDrive, int sTrack, redbook rbTime)
{
    redbook rbTemp;

    rbTemp = CDA_track_start (didDrive, sTrack);
    if (rbTemp == INVALID_TRACK)
	return rbTemp;
    return redadd (rbTime, rbTemp);
}

redbook miltored(DWORD dwMill)
{
    unsigned char m, s, f;
    long r1, r2;


    r1 = dwMill % 60000;

    m = (unsigned char) ((dwMill - r1) / 60000);

    r2 = r1 % 1000;

    s = (unsigned char) ((r1 - r2) / 1000);

    f = (unsigned char) ((r2 * 75) / 1000);

    return MAKERED(m, s, f);
}

DWORD redtomil(redbook rbRed)
{
// Adding an extra one ms to prevent rounding errors at start
    return (DWORD)REDMINUTE(rbRed) * 60000 +
	   (DWORD)REDSECOND(rbRed) * 1000 +
	   ((DWORD)REDFRAME(rbRed) * 1000) / 75 +
	   1;
}


#ifdef AUDIOPHILE

DWORD NEAR PASCAL mcSeek(
    PINSTDATA           pInst,
    DWORD               dwFlags,
    LPMCI_SEEK_PARMS    lpSeek );

DWORD NEAR PASCAL GetAudioPhileInfo(LPCTSTR lpCDAFileName)
{
    OFSTRUCT of;
    RIFFCDA cda;
    HFILE hf;

    //
    //  open the file and read the CDA info.
    //

    if ((hf = _lopen (lpCDAFileName)) == HFILE_ERROR)
	return 0;
    _lread(hf, &cda, sizeof(cda));
    _lclose(hf);

    if (cda.dwRIFF != RIFF_RIFF || cda.dwCDDA != RIFF_CDDA)
    {
	return 0;
    }
    return MCI_MAKE_TMSF(cda.wTrack,0,0,0);
}
#endif


DWORD mcOpen (
    PINSTDATA           pInst,
    DWORD               dwFlags,
    LPMCI_OPEN_PARMS lpOpen)
{
    DID didDrive = (DID)pInst->uDevice;
    DID didOld = (DID)pInst->uDevice;
    UCHAR Volume;
    DWORD dwTempVol;
    int nUseCount;

    /* Instance Initialization */
    pInst->dwTimeFormat = MCI_FORMAT_MSF;

    /* If an ELEMENT_ID is specified, this could be a drive letter */
    if (dwFlags & (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID))
    {
    	if ((dwFlags & (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID)) == (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID))
        {
            dprintf2(("mcOpen, (%08lX), Flags not compatible", (DWORD)didDrive));
	        return MCIERR_FLAGS_NOT_COMPATIBLE;
        }

	    //
	    //  Find the device corresponding to this name
	    //

	    if (COMMAND_SUCCESSFUL !=
	        CDA_get_drive(lpOpen->lpstrElementName, &didDrive)) 
        {
            dprintf2(("mcOpen, (%08lX), Failed to get corresponding device", (DWORD)didDrive));
	        return MCIERR_INVALID_FILE;
	    }

        dprintf2(("mcOpen, changing from drive (%08lx) to drive (%08lX)", (DWORD)(pInst->uDevice), (DWORD)didDrive));
	    pInst->uDevice = didDrive;
    }

    /* Device Initialization */
    nUseCount = DriveTable[didDrive].nUseCount;
    if (nUseCount > 0)
    {
    	// This drive is already open as another MCI device
	    if (dwFlags & MCI_OPEN_SHAREABLE &&
	        DriveTable[didDrive].bShareable)
        {
    	    // Shareable was specified so just increment the use count
	        nUseCount++;
            dprintf2(("mcOpen, drive (%08lx), Incrementing UseCount, now = %ld",
                (DWORD)didDrive, (DWORD)nUseCount));
        }
	    else
        {
            dprintf2(("mcOpen, drive (%08lx), tryed to share without specifing MCI_OPEN_SHAREABLE",
                (DWORD)didDrive));
	        return MCIERR_MUST_USE_SHAREABLE;
        }
    }
    else
    {
        nUseCount = 1;
    }

    if (!CDA_open(didDrive))
    {
        dprintf2(("mcOpen, drive (%08lx), failed to open, UseCount = %ld",
                (DWORD)didDrive, (DWORD)nUseCount));
	    return MCIERR_DEVICE_OPEN;
    }

    //
    // Don't call disc_ready here because it will read the table of
    // contents and on some drivers this will terminate any play
    // unnecessarily
    //

    if (CDA_drive_status (didDrive) == DISC_PLAYING)
    	DriveTable[didDrive].bDiscPlayed = TRUE;
    else
	    DriveTable[didDrive].bDiscPlayed = FALSE;
    DriveTable[didDrive].bActiveTimer = FALSE;
    DriveTable[didDrive].dwPlayTo = MCICDA_BAD_TIME;
    DriveTable[didDrive].bShareable = (dwFlags & MCI_OPEN_SHAREABLE) != 0;
    DriveTable[didDrive].nUseCount = nUseCount;

    dprintf2(("mcOpen, drive (%08lx), Setting UseCount = %ld",
            (DWORD)didDrive, (DWORD)nUseCount));

    //dstewart: fix for when vol in registry is > 8 bits
    dwTempVol = CDAudio_GetUnitVolume(didDrive);
    if (dwTempVol > 0xFF)
    {
        dwTempVol = 0xFF;
    }
    Volume = (UCHAR)dwTempVol;

    CDA_set_audio_volume_all (didDrive, Volume);

#ifdef AUDIOPHILE
    /*
     * AudioPhile track information handler.
     *
     * The new CDROM file system for Windows 4.0 produces files that describe
     * CDAudio tracks.  If a user wants to play a track, she should be able
     * to double click on the track.  So, we add open element support here
     * and add an mplayer association s.t. the file may be read and the disc
     * played back.  We need to reject the Phile if a CDROM of this ID can't
     * be found.  A message box should be displayed if the disc is incorrect.
     * Repercussions of this feature are that we need to simulate a disc in
     * a data structure.
     */

    if (dwFlags & (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID))
    {
	MCI_SEEK_PARMS Seek;

	pInst->dwTimeFormat = MCI_FORMAT_TMSF;

	Seek.dwTo = GetAudioPhileInfo(lpOpen->lpstrElementName);
	if (Seek.dwTo != 0L)
		mcSeek(pInst, MCI_TO, (LPMCI_SEEK_PARMS)&Seek);
    }
#endif
    
    return 0;
}

#define MSF_BITS        ((redbook) 0x00FFFFFF)

/*****************************************************************************
 @doc INTERNAL MCICDA

 @api   redbook | convert_time | Take a DWORD time value and
     convert from current time format into  redbook.

 @parm  PINSTDATA | pInst | Pointer to application instance data

 @parm  DWORD | dwTimeIn |

 @rdesc Return MCICDA_BAD_TIME if out of range.

 @comm
*****************************************************************************/
redbook convert_time(
    PINSTDATA   pInst,
    DWORD       dwTimeIn )
{
    DID didDrive = (DID)pInst->uDevice;
    redbook rbTime;
    short nTrack;

    switch (pInst->dwTimeFormat)
    {
	case MCI_FORMAT_MILLISECONDS:
	    rbTime = miltored (dwTimeIn);
	    return rbTime;

	case MCI_FORMAT_MSF:
	    dprintf3(("Time IN: %lu",dwTimeIn));
	    rbTime = flip3 (dwTimeIn);
	    dprintf3(("Time OUT: %d:%d:%d:%d", REDTRACK(rbTime), REDMINUTE(rbTime),REDSECOND(rbTime), REDFRAME(rbTime)));

	    break;

	case MCI_FORMAT_TMSF:
	    nTrack = (short)(dwTimeIn & 0xFF);
	    if (nTrack > CDA_num_tracks( didDrive))
		return MCICDA_BAD_TIME;
	    rbTime = track_time (didDrive, nTrack, flip3 (dwTimeIn >> 8));
	    if (rbTime == INVALID_TRACK)
		return MCICDA_BAD_TIME;
	    break;
    }

#ifdef CHECK_MSF
    if ((REDFRAME(rbTime)>74) || (REDMINUTE(rbTime)>99) ||
	(REDSECOND(rbTime)>59))
	return MCICDA_BAD_TIME;
#endif

    return rbTime;
}

/*****************************************************************************
 @doc INTERNAL MCICDA

 @api   DWORD | seek | Process the MCI_SEEK command

 @parm  PINSTDATA | pInst | Pointer to application instance data

 @parm  DWORD | dwFlags |

 @parm  LPMCI_SEEK_PARMS | lpSeek |

 @rdesc

 @comm
*****************************************************************************/
DWORD mcSeek(
    PINSTDATA           pInst,
    DWORD               dwFlags,
    LPMCI_SEEK_PARMS    lpSeek )
{
    DID didDrive = pInst->uDevice;

    redbook     rbTime = 0;
    LPSTR       lpTime = (LPSTR) &rbTime;
    redbook     rbStart;
    redbook     rbEnd;
    BOOL        fForceAudio;

    dprintf3(("Seek, drive %d  TO %8x", didDrive, lpSeek->dwTo));
    abort_notify (pInst);

    if ( !disc_ready (didDrive))
	return MCIERR_HARDWARE;

    if ((rbStart = CDA_track_start( didDrive, 1)) == INVALID_TRACK)
	return MCIERR_HARDWARE;

    rbStart &= MSF_BITS;

    if ((rbEnd = CDA_disc_end( didDrive)) == INVALID_TRACK)
	return MCIERR_HARDWARE;

    rbEnd &= MSF_BITS;

    // Check only one positioning command is given.
    // First isolate the bits we want
    // Then subtract 1.  This removes the least significant bit, and puts
    //   ones in any lower bit positions.  Leaves other bits untouched.
    // If any bits are left on, more than one of TO, START or END was given
    // Note: if NO flags are given this ends up ANDING 0 with -1 == 0
    // which is OK.

#define SEEK_BITS (dwFlags & (MCI_TO | MCI_SEEK_TO_START | MCI_SEEK_TO_END))
#define CHECK_FLAGS (((SEEK_BITS)-1) & (SEEK_BITS))

    if (CHECK_FLAGS) {
	return MCIERR_FLAGS_NOT_COMPATIBLE;
    }

    if (dwFlags & MCI_TO)
    {
	// When the above test is reviewed and proven to pick out
	// incompatible flags delete these lines.
	// Note:  we detect more incompatible cases than Win 16 - this
	// is deliberate and fixes a Win 16 bug.  CurtisP has seen this code.
	//if (dwFlags & (MCI_SEEK_TO_START | MCI_SEEK_TO_END))
	//    return MCIERR_FLAGS_NOT_COMPATIBLE;

	if ((rbTime = convert_time (pInst, lpSeek->dwTo)) == MCICDA_BAD_TIME)
	    return MCIERR_OUTOFRANGE;

	// if seek pos is before valid audio return an error
	if ( rbTime < rbStart)
	    return MCIERR_OUTOFRANGE;

	// similarly, if seek pos is past end of disk return an error
	else if (rbTime > rbEnd)
	    return MCIERR_OUTOFRANGE;

	fForceAudio = FALSE;

    } else if (dwFlags & MCI_SEEK_TO_START) {

	rbTime = rbStart;
	fForceAudio = TRUE;      // We want the first audio track

    } else if (dwFlags & MCI_SEEK_TO_END) {

	rbTime = rbEnd;
	fForceAudio = TRUE;      // We want the last audio track

    } else {
	return MCIERR_MISSING_PARAMETER;
    }

    // send seek command to driver
    if (CDA_seek_audio (didDrive, rbTime, fForceAudio) != COMMAND_SUCCESSFUL)
	return MCIERR_HARDWARE;
    if (CDA_pause_audio (didDrive) != COMMAND_SUCCESSFUL)
	return MCIERR_HARDWARE;

    DriveTable[didDrive].bDiscPlayed = TRUE;

    return 0;
}

/*****************************************************************************
 @doc INTERNAL MCICDA

 @api   BOOL | wait |

 @parm  DWORD | dwFlags |

 @parm  PINSTDATA | pInst | Pointer to application instance data

 @rdesc Return TRUE if BREAK was pressed

 @comm If the wait flag is set then wait until the device is no longer playing
*****************************************************************************/
BOOL wait (
    DWORD       dwFlags,
    PINSTDATA   pInst )
{
    DID         didDrive = pInst->uDevice;
    MCIDEVICEID wDeviceID = pInst->uMCIDeviceID;

    if (dwFlags & MCI_WAIT)
    {
    //Note: jyg This is interesting.  I've noticed that some drives do give
    //      sporadic errors.  Thus this retry stuff.  5X is enough to
    //      determine true failure.

	int status, retry=0;
retry:
	while ((status = CDA_drive_status (didDrive)) == DISC_PLAYING) {

	    LeaveCrit( CdInfo[didDrive].DeviceCritSec );

	    if (mciDriverYield (wDeviceID) != 0) {
		EnterCrit( CdInfo[didDrive].DeviceCritSec );
		return TRUE;
	    }

	    Sleep(50);
	    EnterCrit( CdInfo[didDrive].DeviceCritSec );
	}

	if (status == DISC_NOT_READY && retry++ < 5)
	    goto retry;
    }
    return FALSE;
}

/*****************************************************************************
 @doc INTERNAL MCICDA

 @api   DWORD | play | Process the MCI_PLAY command

 @parm  PINSTDATA | pInst | Pointer to application instance data

 @parm  DWORD | dwFlags |

 @parm  LPMCI_PLAY_PARMS | lpPlay |

 @parm  BOOL FAR * | bBreak |

 @rdesc

 @comm
*****************************************************************************/
DWORD mcPlay(
    PINSTDATA           pInst,
    DWORD               dwFlags,
    LPMCI_PLAY_PARMS    lpPlay,
    BOOL FAR *          bBreak )
{
    DID didDrive = pInst->uDevice;

    redbook rbFrom, rbTo;
    redbook dStart, dEnd;
    BOOL bAbort = FALSE;

    if (!disc_ready (didDrive)) // MBR could return more specific error
	return MCIERR_HARDWARE;

    // do we have both from and to parameters?
    // If so then do a "seek" instead
    if ((dwFlags & (MCI_FROM | MCI_TO)) == (MCI_FROM | MCI_TO))
	if (lpPlay->dwTo == lpPlay->dwFrom)
	// Convert a 'play x to x' into 'seek to x'
	{
	    MCI_SEEK_PARMS Seek;

	    Seek.dwTo = lpPlay->dwFrom;
	    Seek.dwCallback = lpPlay->dwCallback;
	    return mcSeek(pInst, dwFlags, (LPMCI_SEEK_PARMS)&Seek);
	}

    // mask is to ignore track number in the upper byte
    // which appears at some times
    dStart = CDA_track_start( didDrive, 1) & MSF_BITS;
    dEnd = CDA_disc_end( didDrive) & MSF_BITS;

    if (dwFlags & MCI_TO)
    {
	if ((rbTo = convert_time (pInst, lpPlay->dwTo))
	    == MCICDA_BAD_TIME)
	    return MCIERR_OUTOFRANGE;
    } else
	rbTo = dEnd;

    if (dwFlags & MCI_FROM)
    {
	if ((rbFrom = convert_time (pInst, lpPlay->dwFrom))
	    == MCICDA_BAD_TIME)
	    return MCIERR_OUTOFRANGE;

    } else // no FROM
    {
// If the disk has never played the current position is indeterminate so
// we must start from the beginning
	if (!DriveTable[didDrive].bDiscPlayed)
	{
	    // Initial position is at the beginning of track 1
	    rbFrom = track_time (didDrive, (int)1, (redbook)0);
	    if (rbFrom == INVALID_TRACK)
		return MCIERR_HARDWARE;
	} else if ((!(dwFlags & MCI_TO) ||
		    rbTo == DriveTable[didDrive].dwPlayTo) &&
		    CDA_drive_status (didDrive) == DISC_PLAYING)
	    // Disc is playing and no (or redundent) "to" position was
	    // specified so do nothng
	    goto exit_fn;
	else
	{
	   CDA_time_info (didDrive, NULL, &rbFrom);
	    // Current position in track 0 means play starting from track 1
	    if (REDTRACK(rbFrom) == 0)
	    {
		rbFrom = track_time (didDrive, (int)1, (redbook)0);
		if (rbFrom == INVALID_TRACK)
		    return MCIERR_HARDWARE;
	    }
	    rbFrom &= MSF_BITS;
// Some drives (SONY) will return an illegal position
	    if (rbFrom < dStart)
		rbFrom = dStart;
	}
    }

    rbFrom &= MSF_BITS;
    rbTo &= MSF_BITS;

    if (dwFlags & MCI_TO)
    {
	if (rbFrom > rbTo || rbTo > dEnd)
	    return MCIERR_OUTOFRANGE;
    } else {
	rbTo = dEnd;
    }


    // if From is before audio start return an error
    if ( rbFrom < dStart)
	return MCIERR_OUTOFRANGE;

    if (dwFlags & MCI_FROM) {
	// Try a seek - don't care if it works (!)
	CDA_seek_audio(didDrive, rbFrom, TRUE);
    }

    // send play command to driver
    if (CDA_play_audio(didDrive, rbFrom, rbTo)
	!= COMMAND_SUCCESSFUL)
	return MCIERR_HARDWARE;  // values should be vaild so err is hard

    DriveTable[didDrive].bDiscPlayed = TRUE;

exit_fn:;
// Abort if either from or (a new) to position is specified
    if (dwFlags & MCI_FROM || rbTo != DriveTable[didDrive].dwPlayTo)
	abort_notify (pInst);

    *bBreak = wait(dwFlags, pInst);

    DriveTable[didDrive].dwPlayTo = rbTo;

    return 0;
}

/*****************************************************************************
 @doc INTERNAL MCICDA

 @api   DWORD | mcGetDevCaps | Process the MCI_GETDEVCAPS command

 @parm  PINSTDATA | pInst | Pointer to application data instance

 @parm  DWORD | dwFlags |

 @parm  LPMCI_GETDEVCAPS_PARMS | lpCaps |

 @rdesc

 @comm
*****************************************************************************/
DWORD mcGetDevCaps(
    PINSTDATA                   pInst,
    DWORD                       dwFlags,
    LPMCI_GETDEVCAPS_PARMS      lpCaps )
{
    DWORD dwReturn = 0;

    if (!(dwFlags & MCI_GETDEVCAPS_ITEM))
	return MCIERR_MISSING_PARAMETER;

    switch (lpCaps->dwItem)
    {
	case MCI_GETDEVCAPS_CAN_RECORD:
	case MCI_GETDEVCAPS_CAN_SAVE:
	case MCI_GETDEVCAPS_HAS_VIDEO:
	case MCI_GETDEVCAPS_USES_FILES:
	case MCI_GETDEVCAPS_COMPOUND_DEVICE:
	    lpCaps->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
	    dwReturn = MCI_RESOURCE_RETURNED;
	    break;
	case MCI_GETDEVCAPS_HAS_AUDIO:
	case MCI_GETDEVCAPS_CAN_EJECT: // mbr - bogus...
	case MCI_GETDEVCAPS_CAN_PLAY:
	    lpCaps->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
	    dwReturn = MCI_RESOURCE_RETURNED;
	    break;
	case MCI_GETDEVCAPS_DEVICE_TYPE:
	    lpCaps->dwReturn = MAKEMCIRESOURCE(MCI_DEVTYPE_CD_AUDIO,
					       MCI_DEVTYPE_CD_AUDIO);
	    dwReturn = MCI_RESOURCE_RETURNED;
	    break;
	default:
	    dwReturn = MCIERR_UNSUPPORTED_FUNCTION;
	    break;
    }

    return dwReturn;
}

/*****************************************************************************
 @doc INTERNAL MCICDA

 @api   DWORD | mcStatus | Process the MCI_STATUS command

 @parm  PINSTDATA | pInst | Pointer to application instance data

 @parm  DWORD | dwFlags |

 @parm  LPMCI_STATUS_PARMS | lpStatus |

 @rdesc

 @comm
*****************************************************************************/
DWORD mcStatus (
    PINSTDATA           pInst,
    DWORD               dwFlags,
    LPMCI_STATUS_PARMS  lpStatus)
{
    DID didDrive = (DID)pInst->uDevice;
    DWORD dwReturn = 0;

    if (!(dwFlags & MCI_STATUS_ITEM))
	return MCIERR_MISSING_PARAMETER;

    switch (lpStatus->dwItem)
    {
	int n;

	case MCI_STATUS_MEDIA_PRESENT:
	    if (CDA_traystate(didDrive) != TRAY_OPEN &&
		CDA_disc_ready(didDrive))
		lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
	    else
		lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
	    dwReturn = MCI_RESOURCE_RETURNED;
	    break;
	case MCI_STATUS_READY:
	    switch (CDA_drive_status (didDrive))
	    {
		case DISC_PLAYING:
		case DISC_PAUSED:
		case DISC_READY:
		    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
		    break;
		default:
		    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
		    break;
	    }
	    dwReturn = MCI_RESOURCE_RETURNED;
	    break;
	case MCI_STATUS_MODE:
	{
	    switch (CDA_drive_status (didDrive))
	    {
		case DISC_PLAYING:
		    n = MCI_MODE_PLAY;
		    break;
		case DISC_PAUSED:
		    n = MCI_MODE_STOP;  // HACK HACK!
		    break;
		case DISC_READY:
		    n = MCI_MODE_STOP;
		    break;
		default:
		    if (CDA_traystate (didDrive) == TRAY_OPEN)
			n = MCI_MODE_OPEN;
		    else
			n = MCI_MODE_NOT_READY;
		    break;
	    }
	    lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(n, n);
	    dwReturn = MCI_RESOURCE_RETURNED;
	    break;
	}
	case MCI_STATUS_TIME_FORMAT:
	    n = (WORD)pInst->dwTimeFormat;
	    lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(n,n + MCI_FORMAT_RETURN_BASE);
	    dwReturn = MCI_RESOURCE_RETURNED;
	    break;
	case MCI_STATUS_POSITION:
	{
	    redbook tracktime, disctime;

	    if (dwFlags & MCI_TRACK)
	    {
		int n;

		if (dwFlags & MCI_STATUS_START)
		    return MCIERR_FLAGS_NOT_COMPATIBLE;

		if (!disc_ready(didDrive))
		    return MCIERR_HARDWARE;
		if ((n = CDA_num_tracks (didDrive)) == 0)
		    return MCIERR_HARDWARE;
		if (!lpStatus->dwTrack || lpStatus->dwTrack > (DWORD)n)
		    return MCIERR_OUTOFRANGE;
		lpStatus->dwReturn =
		    CDA_track_start (didDrive, (short)lpStatus->dwTrack);
		switch (pInst->dwTimeFormat)
		{
		    case MCI_FORMAT_MILLISECONDS:
			lpStatus->dwReturn = redtomil ((redbook)lpStatus->dwReturn);
			dwReturn = 0;
			break;
		    case MCI_FORMAT_TMSF:
			lpStatus->dwReturn = lpStatus->dwTrack;
			dwReturn = MCI_COLONIZED4_RETURN;
			break;
		    case MCI_FORMAT_MSF:
			lpStatus->dwReturn = flip3 ((redbook)lpStatus->dwReturn);
			dwReturn = MCI_COLONIZED3_RETURN;
			break;
		}
	    } else if (dwFlags & MCI_STATUS_START)
	    {
		if (!disc_ready(didDrive))
		    return MCIERR_HARDWARE;
		if ((n = CDA_num_tracks (didDrive)) == 0)
		    return MCIERR_HARDWARE;
		lpStatus->dwReturn =
		    CDA_track_start (didDrive, 1);
		switch (pInst->dwTimeFormat)
		{
		    case MCI_FORMAT_MILLISECONDS:
			lpStatus->dwReturn = redtomil ((redbook)lpStatus->dwReturn);
			dwReturn = 0;
			break;
		    case MCI_FORMAT_TMSF:
			lpStatus->dwReturn = 1;
			dwReturn = MCI_COLONIZED4_RETURN;
			break;
		    case MCI_FORMAT_MSF:
			lpStatus->dwReturn = flip3 ((redbook)lpStatus->dwReturn);
			dwReturn = MCI_COLONIZED3_RETURN;
			break;
		}
	    } else
	    {
		if (!DriveTable[didDrive].bDiscPlayed)
		{
		    tracktime = REDTH(0, 1);
		    if (!disc_ready(didDrive))
			return MCIERR_HARDWARE;
		    disctime = CDA_track_start( didDrive, 1);
		} else if (CDA_time_info(didDrive, &tracktime, &disctime) !=
			   COMMAND_SUCCESSFUL)
		    return MCIERR_HARDWARE;

		if (REDTRACK(tracktime) == 0)
		{
		    tracktime = (redbook)0;
		    disctime = (redbook)0;
		}
		switch (pInst->dwTimeFormat)
		{
		    case MCI_FORMAT_MILLISECONDS:
			lpStatus->dwReturn = redtomil (disctime);
			dwReturn = 0;
			break;
		    case MCI_FORMAT_MSF:
			lpStatus->dwReturn = flip3(disctime);
			dwReturn = MCI_COLONIZED3_RETURN;
			break;
		    case MCI_FORMAT_TMSF:
			lpStatus->dwReturn = flip4 (tracktime);
			dwReturn = MCI_COLONIZED4_RETURN;
			break;
		}
	    }
	    break;
	}
	case MCI_STATUS_LENGTH:
	    if (!disc_ready(didDrive))
		return MCIERR_HARDWARE;

	    if (dwFlags & MCI_TRACK)
	    {
		lpStatus->dwReturn =
		    CDA_track_length (didDrive, (short)lpStatus->dwTrack);
		if (lpStatus->dwReturn == INVALID_TRACK)
		    return MCIERR_OUTOFRANGE;
		switch (pInst->dwTimeFormat)
		{
		    case MCI_FORMAT_MILLISECONDS:
			lpStatus->dwReturn = redtomil ((redbook)lpStatus->dwReturn);
			dwReturn = 0;
			break;
		    case MCI_FORMAT_MSF:
		    case MCI_FORMAT_TMSF:
			lpStatus->dwReturn = flip3((redbook)lpStatus->dwReturn);
			dwReturn = MCI_COLONIZED3_RETURN;
			break;
		}
	    } else
	    {
// Subtract one to match SEEK_TO_END
		lpStatus->dwReturn = CDA_disc_length (didDrive);
		switch (pInst->dwTimeFormat)
		{
		    case MCI_FORMAT_MILLISECONDS:
			lpStatus->dwReturn = redtomil ((redbook)lpStatus->dwReturn);
			dwReturn = 0;
			break;
		    case MCI_FORMAT_MSF:
		    case MCI_FORMAT_TMSF:
			lpStatus->dwReturn = flip3((redbook)lpStatus->dwReturn);
			dwReturn = MCI_COLONIZED3_RETURN;
			break;
		}
	    }
	    break;
	case MCI_STATUS_NUMBER_OF_TRACKS:
	    if (!disc_ready(didDrive))
		return MCIERR_HARDWARE;

	    lpStatus->dwReturn = (DWORD)CDA_num_tracks (didDrive);
	    dwReturn = 0;
	    break;
	case MCI_STATUS_CURRENT_TRACK:
	{
	    redbook tracktime;

	    if (!DriveTable[didDrive].bDiscPlayed)
		lpStatus->dwReturn = 1;
	    else
	    {
		if (CDA_time_info(didDrive, &tracktime, NULL) !=
		    COMMAND_SUCCESSFUL)
		    return MCIERR_HARDWARE;

		lpStatus->dwReturn = REDTRACK (tracktime);
	    }
	    break;
	}
	case MCI_CDA_STATUS_TYPE_TRACK:
	    if (!disc_ready(didDrive))
		return MCIERR_HARDWARE;

	    if (dwFlags & MCI_TRACK)
	    {
		DWORD dwTmp;

		dwTmp = CDA_track_type (didDrive, (int)lpStatus->dwTrack);

		switch (dwTmp)
		{
		    case INVALID_TRACK:
			return MCIERR_OUTOFRANGE;

		    case MCI_CDA_TRACK_AUDIO:
			lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(dwTmp,
			    MCI_CDA_AUDIO_S);
			break;

		    case MCI_CDA_TRACK_OTHER:
			lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(dwTmp,
			    MCI_CDA_OTHER_S);
			break;
		}
		    dwReturn = MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER;
	    }
	    break;

	case MCI_STATUS_TRACK_POS:
	{
        // Note:  This code is a major hack that does an end-run around
        //        past the normal MCI functionality.  The only reason it
        //        is here is because the new functionality replaces 3 MCI
        //        calls in CDPLAYER to get the position,track, and status
        //        with this one call.
        //        This means what used to take ~15 IOCTL's to accomplish
        //        now takes ~1 IOCTL.   Since CDPLAYER generates one of
        //        these messages every 1/2 second for updating it's timer
        //        display.   This is a major reduction in system traffic
        //        for SCSI and IDE CD-Roms drivers.
	    DWORD           status;
	    DWORD           mciStatus;
	    redbook         tracktime, disctime;
	    int             rc;
	    STATUSTRACKPOS  stp;
	    PSTATUSTRACKPOS pSTP;

        if (!DriveTable[didDrive].bDiscPlayed)
		{
		    tracktime = REDTH(0, 1);
		    
            if (!disc_ready(didDrive))
            {
                dprintf(("mcStatus (%08LX), MCI_STATUS_TRACK_POS, Disc Not Ready", (DWORD)didDrive));
			    return MCIERR_HARDWARE;
            }
		    disctime = CDA_track_start( didDrive, 1);

            status = CDA_drive_status (didDrive); 
            switch (status)
	        {
		    case DISC_PLAYING:
		        mciStatus = MCI_MODE_PLAY;
		        break;
		    case DISC_PAUSED:
		        mciStatus = MCI_MODE_STOP;  // HACK HACK!
		        break;
		    case DISC_READY:
		        mciStatus = MCI_MODE_STOP;
		        break;
		    default:
		        if (CDA_traystate (didDrive) == TRAY_OPEN)
			        mciStatus = MCI_MODE_OPEN;
		        else
			        mciStatus = MCI_MODE_NOT_READY;
		        break;
    	    }
		} 
        else 
        {
	        rc = CDA_status_track_pos (didDrive, &status, &tracktime, &disctime);
	        if (rc != COMMAND_SUCCESSFUL)
            {
                dprintf(("mcStatus (%08LX), MCI_STATUS_TRACK_POS, CDA_status_track_pos failed", (DWORD)didDrive));
		        return MCIERR_HARDWARE;
            }

	        if (REDTRACK(tracktime) == 0)
	        {
		        tracktime = (redbook)0;
		        disctime = (redbook)0;
	        }

	        switch (status)
	        {
	        case DISC_PLAYING:
		        mciStatus = MCI_MODE_PLAY;
		        break;
	        case DISC_PAUSED:
		        mciStatus = MCI_MODE_STOP;  // HACK HACK!
		        break;
	        case DISC_READY:
		        mciStatus = MCI_MODE_STOP;
		        break;
	        case DISC_NOT_IN_CDROM:
		        mciStatus = MCI_MODE_OPEN;
		        break;
	        default:
		        mciStatus = MCI_MODE_NOT_READY;
		        break;
	        }
        }

	    stp.dwStatus = mciStatus;
	    stp.dwTrack = REDTRACK (tracktime);
	    switch (pInst->dwTimeFormat)
	    {
		case MCI_FORMAT_MILLISECONDS:
		    stp.dwDiscTime = redtomil ((redbook)disctime);
		    dwReturn = 0;
		    break;
		case MCI_FORMAT_MSF:
		    stp.dwDiscTime = flip3(disctime);
		    dwReturn = MCI_COLONIZED3_RETURN;
		    break;
		case MCI_FORMAT_TMSF:
		    stp.dwDiscTime = flip4 (tracktime);
		    dwReturn = MCI_COLONIZED4_RETURN;
		    break;
	    }

	    pSTP = (PSTATUSTRACKPOS)lpStatus->dwReturn;
	    if (pSTP == NULL)
            return MCIERR_MISSING_PARAMETER;

	    pSTP->dwStatus   = stp.dwStatus;
	    pSTP->dwTrack    = stp.dwTrack;
	    pSTP->dwDiscTime = stp.dwDiscTime;
	    break;
	}

	default:
	    dwReturn = MCIERR_UNSUPPORTED_FUNCTION;
	    break;
    }

    return dwReturn;
}

/*****************************************************************************
 @doc INTERNAL MCICDA

 @api   DWORD | mcClose | Process the MCI_CLOSE command

 @parm  PINSTDATA | pInst | Pointer to application data instance

 @rdesc

 @comm
*****************************************************************************/
DWORD mcClose(
    PINSTDATA pInst)
{
    DID didDrive = pInst->uDevice;
    MCIDEVICEID wDeviceID = pInst->uMCIDeviceID;
    int nUseCount;

    if (!pInst)
    {
        dprintf2(("mcClose, passed in NULL pointer"));
    }

    if (DriveTable[didDrive].nUseCount == 0)
    {
        dprintf2(("mcClose (%08lX), nUseCount already ZERO!!!", (DWORD)didDrive));
    }
    else if (--DriveTable[didDrive].nUseCount == 0) 
    {
        dprintf2(("mcClose, Actually closing device (%08lX)", (DWORD)didDrive));
	    CDA_close(didDrive);
	    CDA_terminate_audio ();
    }
    else
    {
        dprintf2(("mcClose, Enter, device (%08lx), decremented useCount = %ld", 
            (DWORD)didDrive, DriveTable[didDrive].nUseCount));
    
        // Note: Having this here prevents a mis-count problem
	    CDA_close(didDrive);
    }

// Abort any notify if the use count is 0 or if the notify is for the device
// being closed
    if ((DriveTable[didDrive].nUseCount == 0) ||
	    (wDeviceID == DriveTable[didDrive].wDeviceID))
	    abort_notify (pInst);

    mciSetDriverData(pInst->uMCIDeviceID, 0L);
    LocalFree((HLOCAL)pInst);

    dprintf2(("mcClose, Exit, device (%08lx), useCount = %ld", 
        (DWORD)didDrive, DriveTable[didDrive].nUseCount));    
    return 0;
}

/*****************************************************************************
 @doc INTERNAL MCICDA

 @api   DWORD | mcStop | Process the MCI_STOP command

 @parm  PINSTDATA | pInst | Pointer to application data instance

 @parm  DWORD | dwFlags |

 @rdesc

*****************************************************************************/
DWORD mcStop(
    PINSTDATA              pInst,
    DWORD                  dwFlags,
    LPMCI_GENERIC_PARMS    lpGeneric)
{
    DID didDrive = pInst->uDevice;

    if (!disc_ready (didDrive))
	return MCIERR_HARDWARE;

    abort_notify (pInst);

    if (CDA_stop_audio(didDrive) != COMMAND_SUCCESSFUL)
	    return MCIERR_HARDWARE;

    return 0;
}

/*****************************************************************************
 @doc INTERNAL MCICDA

 @api   DWORD | mcPause | Process the MCI_PAUSE command

 @parm  PINSTDATA | pInst | Pointer to application data instance

 @parm  DWORD | dwFlags |

 @rdesc

*****************************************************************************/

DWORD mcPause(
    PINSTDATA           pInst,
    DWORD               dwFlags,
    LPMCI_GENERIC_PARMS lpGeneric)
{
    DID didDrive = pInst->uDevice;

    if (!disc_ready (didDrive))
	return MCIERR_HARDWARE;

    abort_notify (pInst);

    if (CDA_pause_audio(didDrive) != COMMAND_SUCCESSFUL)
	    return MCIERR_HARDWARE;

    return 0;
}

/*****************************************************************************
 @doc INTERNAL MCICDA

 @api   DWORD | mcResume | Process the MCI_PAUSE command

 @parm  PINSTDATA | pInst | Pointer to application data instance

 @parm  DWORD | dwFlags |

 @rdesc

*****************************************************************************/

DWORD mcResume(
    PINSTDATA           pInst,
    DWORD               dwFlags,
    LPMCI_GENERIC_PARMS lpGeneric)
{
    DID didDrive = pInst->uDevice;

    if (!disc_ready (didDrive))
	return MCIERR_HARDWARE;

    abort_notify (pInst);

    if (CDA_resume_audio(didDrive) != COMMAND_SUCCESSFUL)
	    return MCIERR_HARDWARE;

    return 0;
}

// MBR cda.c!SendDriverReq masks off the actual error bits and just
// leaves the upper bit set - this is ok for now. There exists
// no seperate "command is known but not supported" error at
// the driver level, so if the driver returns "unrecognized
// command", we return "unsupported function".

#define ERRQ(X) (((X)==0) ? MCIERR_UNSUPPORTED_FUNCTION : 0)

/*****************************************************************************
 @doc INTERNAL MCICDA

 @api   DWORD | mcSet | Process the MCI_SET command

 @parm  DWORD | dwFlags |

 @parm  LPMCI_SET_PARMS | lpSet |

 @rdesc

 @comm
*****************************************************************************/
DWORD  mcSet(
    PINSTDATA           pInst,
    DWORD               dwFlags,
    LPMCI_SET_PARMS     lpSet )
{
    DID  didDrive = pInst->uDevice;
    UINT wErr = 0;

    dwFlags &= ~(MCI_NOTIFY | MCI_WAIT);

    if (!dwFlags)
	return MCIERR_MISSING_PARAMETER;
	
    if (dwFlags & MCI_SET_TIME_FORMAT)
    {
	DWORD wFormat = lpSet->dwTimeFormat;

	switch (wFormat)
	{
	    case MCI_FORMAT_MILLISECONDS:
	    case MCI_FORMAT_MSF:
	    case MCI_FORMAT_TMSF:
		pInst->dwTimeFormat = wFormat;
		break;
	    default:
		wErr = MCIERR_BAD_TIME_FORMAT;
		break;
	}
    }

    if (!wErr && (dwFlags & MCI_SET_DOOR_OPEN))
    {
	abort_notify (pInst);
	CDA_stop_audio (didDrive);
	CDA_eject(didDrive);

	DriveTable[didDrive].bDiscPlayed = FALSE;
    }

    if (!wErr && (dwFlags & MCI_SET_AUDIO))
    {
	UCHAR wVolume;
	if (dwFlags & MCI_SET_ON && dwFlags & MCI_SET_OFF)
	    return MCIERR_FLAGS_NOT_COMPATIBLE;

	if (dwFlags & MCI_SET_ON)
	    wVolume = 255;
	else if (dwFlags & MCI_SET_OFF)
	    wVolume = 0;
	else
	    return MCIERR_MISSING_PARAMETER;

	switch (lpSet->dwAudio)
	{
	    case MCI_SET_AUDIO_ALL:
		if (CDA_set_audio_volume_all (didDrive, wVolume)
			!= COMMAND_SUCCESSFUL)
		    wErr = MCIERR_HARDWARE;
		break;
	    case MCI_SET_AUDIO_LEFT:
		if (CDA_set_audio_volume (didDrive, 0, wVolume)
			!= COMMAND_SUCCESSFUL)
		    wErr = MCIERR_HARDWARE;
		break;
	    case MCI_SET_AUDIO_RIGHT:
		if (CDA_set_audio_volume (didDrive, 1, wVolume)
			!= COMMAND_SUCCESSFUL)
		    wErr = MCIERR_HARDWARE;
		break;
	}
    }

    if (!wErr && dwFlags & MCI_SET_DOOR_CLOSED)
	CDA_closetray (didDrive);

    return wErr;
}

/*****************************************************************************
 @doc INTERNAL MCICDA

 @api   DWORD | mcInfo | Process the MCI_INFO command

 @parm  PINSTDATA | pInst | Pointer to application instance data

 @parm  DWORD | dwFlags |

 @parm  LPMCI_INFO_PARMS | lpInfo |

 @rdesc

 @comm
*****************************************************************************/
DWORD mcInfo (
    PINSTDATA           pInst,
    DWORD               dwFlags,
    LPMCI_INFO_PARMS    lpInfo )
{
    DID   didDrive = pInst->uDevice;
    DWORD wReturnBufferLength;

    wReturnBufferLength = LOWORD(lpInfo->dwRetSize);

    if (!lpInfo->lpstrReturn || !wReturnBufferLength)
	return MCIERR_PARAM_OVERFLOW;

    if (dwFlags & MCI_INFO_PRODUCT)
    {
	*(lpInfo->lpstrReturn) = '\0';
	lpInfo->dwRetSize = (DWORD)LoadString(hInstance, IDS_PRODUCTNAME, lpInfo->lpstrReturn, (int)wReturnBufferLength);
	return 0;
    }
    else if (dwFlags & MCI_INFO_MEDIA_UPC)
    {
	unsigned char upc[16];
	int i;

	if (!disc_ready(didDrive))
	    return MCIERR_HARDWARE;

	if (CDA_disc_upc(didDrive, lpInfo->lpstrReturn) != COMMAND_SUCCESSFUL)
	    return MCIERR_NO_IDENTITY;

	return 0;
    }
    else if (dwFlags & MCI_INFO_MEDIA_IDENTITY)
    {
	DWORD dwId;
	if (!disc_ready(didDrive))
	    return MCIERR_HARDWARE;

	dwId = CDA_disc_id(didDrive);
	if (dwId == (DWORD)-1L)
	    return MCIERR_HARDWARE;
	wsprintf(lpInfo->lpstrReturn,TEXT("%lu"),dwId);
	return 0;
    } else
	return MCIERR_MISSING_PARAMETER;
}

/*
 * @doc INTERNAL MCIRBOOK
 *
 * @api DWORD | mciDriverEntry | Single entry point for MCI drivers
 *
 * @parm MCIDEVICEID | wDeviceID | The MCI device ID
 *
 * @parm UINT | message | The requested action to be performed.
 *
 * @parm LPARAM | lParam1 | Data for this message.  Defined seperately for
 * each message
 *
 * @parm LPARAM | lParam2 | Data for this message.  Defined seperately for
 * each message
 *
 * @rdesc Defined seperately for each message.
 *
 */
DWORD CD_MCI_Handler (MCIDEVICEID wDeviceID,
		      UINT        message,
		      DWORD_PTR   lParam1,
		      DWORD_PTR   lParam2)
{
    DID                 didDrive;
    LPMCI_GENERIC_PARMS lpGeneric = (LPMCI_GENERIC_PARMS)lParam2;
    BOOL                bDelayed = FALSE;
    DWORD               dwErr = 0, wNotifyErr;
    DWORD               dwPlayTo = MCICDA_BAD_TIME;
    WORD                wNotifyStatus = MCI_NOTIFY_SUCCESSFUL;
    PINSTDATA           pInst;



    pInst = (PINSTDATA)mciGetDriverData(wDeviceID);
    didDrive = (DID)pInst->uDevice;

    EnterCrit( CdInfo[didDrive].DeviceCritSec );

    switch (message)
    {
	case MCI_OPEN_DRIVER:
	    dwErr = mcOpen (pInst, (DWORD)lParam1, (LPMCI_OPEN_PARMS)lParam2);
	    break;

	case MCI_CLOSE_DRIVER:
	    dwErr = mcClose (pInst);
	    break;

	case MCI_PLAY:
	{
	    BOOL bBreak = FALSE;
	    dwErr = mcPlay (pInst, (DWORD)lParam1, (LPMCI_PLAY_PARMS)lParam2, &bBreak);

	    if (dwErr == 0 && (DWORD)lParam1 & MCI_WAIT && (DWORD)lParam1 & MCI_NOTIFY)
	    {
		switch (CDA_drive_status (didDrive))
		{
		    case DISC_PLAYING:
		    case DISC_PAUSED:
		    case DISC_READY:
			break;
		    default:
			wNotifyStatus = MCI_NOTIFY_FAILURE;
			break;
		}
	    }

// If MCI_WAIT is not set or if the wait loop was broken out of then delay
	    if (!((DWORD)lParam1 & MCI_WAIT) || bBreak)
		bDelayed = TRUE;
	    break;
	}

	case MCI_SEEK:
	    dwErr = mcSeek (pInst, (DWORD)lParam1, (LPMCI_SEEK_PARMS)lParam2);
	    break;

	case MCI_STOP:
	    dwErr = mcStop ( pInst, (DWORD)lParam1, (LPMCI_GENERIC_PARMS)lParam2);
	    break;

	case MCI_PAUSE:
	    dwErr = mcPause ( pInst, (DWORD)lParam1, (LPMCI_GENERIC_PARMS)lParam2);
	    break;

	case MCI_GETDEVCAPS:
	    dwErr = mcGetDevCaps (pInst, (DWORD)lParam1, (LPMCI_GETDEVCAPS_PARMS)lParam2);
	    break;

	case MCI_STATUS:
	    dwErr = mcStatus (pInst, (DWORD)lParam1, (LPMCI_STATUS_PARMS)lParam2);
	    break;

	case MCI_SET:
	    dwErr = mcSet (pInst, (DWORD)lParam1, (LPMCI_SET_PARMS)lParam2);
	    break;

	case MCI_INFO:
	    dwErr = mcInfo (pInst, (DWORD)lParam1, (LPMCI_INFO_PARMS)lParam2);
	    break;

	case MCI_RECORD:
	case MCI_LOAD:
	case MCI_SAVE:
	    LeaveCrit( CdInfo[didDrive].DeviceCritSec );
	    return MCIERR_UNSUPPORTED_FUNCTION;

	case MCI_RESUME:
	    dwErr = mcResume ( pInst, (DWORD)lParam1, (LPMCI_GENERIC_PARMS)lParam2);
	    break;

	default:
	    LeaveCrit( CdInfo[didDrive].DeviceCritSec );
	    return MCIERR_UNRECOGNIZED_COMMAND;
    } /* switch */

    /* it is possible that the instance information has disappeared if
     * CLOSE NOTIFY is requested.  Therefore NOTIFY should never take
     * instance data.
     */

    if ((DWORD)lParam1 & MCI_NOTIFY && LOWORD (dwErr) == 0)
	if ((wNotifyErr =
		notify (didDrive, wDeviceID, bDelayed, wNotifyStatus,
			(LPMCI_GENERIC_PARMS)lParam2)) != 0) {
	    LeaveCrit( CdInfo[didDrive].DeviceCritSec );
	    return wNotifyErr;
    }

    LeaveCrit( CdInfo[didDrive].DeviceCritSec );

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcicda\sources.inc ===
#
#   Create an MCI handler DLL
#

MAJORCOMP=windows
MINORCOMP=mci

TARGETNAME=mcicda
TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows

NTPROFILEINPUT=yes

USE_NTDLL=1

DLLDEF=..\$(TARGETNAME).def
DLLORDER=..\$(TARGETNAME).prf

# Define libs we need and where to find them

TARGETLIBS=$(SDK_LIB_PATH)\user32.lib   \
           $(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\winmm.lib \
           $(SDK_LIB_PATH)\advapi32.lib

C_DEFINES=-DUNICODE

# C_DEFINES=-DUNICODE -DDBG -DDEBUG
# NTDEBUG=ntsd
# NTDEBUGTYPE=both
# MSC_OPTIMIZATION=/Od /Zi

SOURCES=..\mcicda.c    \
        ..\cddrvr.c    \
        ..\mcicda.rc   \
        ..\cda.c       \
        ..\cdio.c      \
        ..\debug.c

DLLBASE=0x68300000

PASS1_PUBLISH= \
    {$(O)\mcicda.lib=$(PROJECT_LIB_PATH)\mcicda.lib}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcicda\old\cdconfig.h ===
// Copyright (c) 1995 Microsoft Corporation

#define C_DRIVE_LIST   106
#define	IDD_CONFIG	1

int PASCAL FAR CDAConfig (HWND hwndParent, LPDRVCONFIGINFO lpInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcihwnd\debug.c ===
/* Copyright (c) 1992 Microsoft Corporation */
/*
 *  debug.c
 *
 *  debugging menu support
 *
 *  Debug level info is in WIN.INI in the [debug] section:
 *
 *      [debug]
 *      App=0               level for App
 *
 */

#include "mcihwnd.h"
#include <stdarg.h>

// mcihwnd pulls in the other needed files

#if DBG

char aszAppName[] = "MciHwnd";
int __iDebugLevel = 1;

/***************************************************************************

    @doc INTERNAL

    @api void | dDbgOut | This function sends output to the current
        debug output device.

    @parm LPSTR | lpszFormat | Pointer to a printf style format string.
    @parm ??? | ... | Args.

    @rdesc There is no return value.

****************************************************************************/

void dDbgOut(LPSTR lpszFormat, ...)
{
    int i;
    char buf[256];
    va_list va;

    sprintf(buf, "%s: ", aszAppName);
    OutputDebugString(buf);

    va_start(va, lpszFormat);
    i = vsprintf(buf, lpszFormat, va);
    va_end(va);

    OutputDebugString(buf);

    OutputDebugString("\n");
}

/***************************************************************************

    @doc INTERNAL

    @api int | dGetDebugLevel | This function gets the current debug level
        for a module.

    @parm LPSTR | lpszModule | The name of the module.

    @rdesc The return value is the current debug level.

    @comm The information is kept in the [debug] section of WIN.INI

****************************************************************************/

int dGetDebugLevel(LPSTR lpszAppName)
{
    return GetProfileInt("MMDEBUG", lpszAppName, 3);
}

/***************************************************************************

    @doc INTERNAL

    @api int | dDbgSaveLevel | This function saves the current debug level
        for a module.

    @parm LPSTR | lpszModule | The name of the module.
    @parm int | iLevel | The value to save.

    @rdesc There is no return value.

    @comm The information is kept in the [debug] section of WIN.INI

****************************************************************************/

void dDbgSaveLevel(LPSTR lpszAppName, int iLevel)
{
    char buf[80];

    sprintf(buf, "%d", iLevel);
    WriteProfileString("MMDEBUG", lpszAppName, buf);
}

/***************************************************************************

    @doc INTERNAL

    @api void | dDbgAssert | This function shows an assert message box.

    @parm LPSTR | exp | Pointer to the expression string.
    @parm LPSTR | file | Pointer to the file name.
    @parm int | line | The line number.

    @rdesc There is no return value.

    @comm We try to use the current active window as the parent. If
        this fails we use the desktop window.  The box is system
        modal to avoid any trouble.

****************************************************************************/

void dDbgAssert(LPSTR exp, LPSTR file, int line)
{
    char bufTmp[256];
    int iResponse;
    HWND hWnd;

    sprintf(bufTmp,
        "Expression: %s\nFile: %s, Line: %d\n\nAbort:  Exit Process\nRetry:  Enter Debugger\nIgnore: Continue",
        exp, file, line);

    // try to use the active window, but NULL is ok if there
    // isn't one.  Use the debug console as well
	dprintf(bufTmp);

    hWnd = GetActiveWindow();

    iResponse = MessageBox(hWnd,
                           bufTmp,
                           "Assertion Failure",
                           MB_TASKMODAL
                            | MB_ICONEXCLAMATION
                            | MB_DEFBUTTON3
                            | MB_ABORTRETRYIGNORE);

    switch (iResponse) {
        case 0:
            dprintf1("Assert message box failed");
            dprintf2("  Expression: %s", exp);
            dprintf2("  File: %s,  Line: %d", file, line);
            break;
        case IDABORT:
            ExitProcess(1);
            break;
        case IDRETRY:
            DebugBreak();
            break;
        case IDIGNORE:
            break;
    }
}

#endif

#if DBG

/***************************************************************************

    @doc INTERNAL

    @api void | winmmDbgOut | This function sends output to the current
        debug output device.

    @parm LPSTR | lpszFormat | Pointer to a printf style format string.
    @parm ??? | ... | Args.

    @rdesc There is no return value.

****************************************************************************/

void winmmDbgOut(LPSTR lpszFormat, ...)
{
    char buf[256];
    UINT n;
    va_list va;

    n = wsprintf(buf, "MciHwnd: ");

    va_start(va, lpszFormat);
    n += vsprintf(buf+n, lpszFormat, va);
    va_end(va);

    buf[n++] = '\n';
    buf[n] = 0;
    OutputDebugString(buf);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcicda\old\cdconfig.c ===
/*******************************Module*Header*********************************\
* Module Name: cdconfig.c
*
* Media Control Architecture Redbook CD Audio Driver
*
* History:
*   RobinSp - 6 Mar 1992 ported to Windows NT
*
* Copyright (c) 1990-1995 Microsoft Corporation
*
\****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "mcicda.h"
#include "cdconfig.h"
#include "cda.h"
#include "cdio.h"

#define MAXINILENGTH 128

TCHAR szIniFile[] = TEXT("system.ini");
TCHAR szNull[] = TEXT("");
int numdrives;

STATICFN LPWSTR GetTail(LPWSTR  pch)
{
    while (*pch && *pch != ' ')
        pch++;

    while (*pch == ' ')
        pch++ ;

    return (pch);
}

STATICFN UINT GetCmdParam (LPDRVCONFIGINFO lpdci)
{
    WCHAR sz[MAXINILENGTH];
    LPWSTR lpsz;

    if ((lpdci->dwDCISize == sizeof(DRVCONFIGINFO)) && GetPrivateProfileStringW(
        lpdci->lpszDCISectionName,
        lpdci->lpszDCIAliasName,
        szNull,  sz, MAXINILENGTH, szIniFile))
    {

        WCHAR parameters[6];
        LPWSTR pszDefault;

        // We have got the name of the driver
        // Just in case the user has added the command parameter to the
        // end of the name we had better make sure there is only one token
        // on the line.  If there is a command parameter this becomes the
        // default on the call to read WIN.INI

        lpsz = GetTail (sz);

        pszDefault = lpsz;     // Either the number on the end, or NULL

        if (*lpsz) {
            // RATS!!  There is a parameter on the end of the driver name
            while (*--lpsz == TEXT(' ')) {
            }
            *++lpsz = TEXT('\0');  // Terminate the string after the DLL name
        }

        if (GetProfileString(sz, lpdci->lpszDCIAliasName, lpsz, parameters, sizeof(parameters)/sizeof(WCHAR))) {
            if (parameters[0] == TEXT('\0') ||
                parameters[0] < TEXT('0') || parameters[0] > L'9')
                return 0;
            else
                return parameters[0] - L'0';
        } else
            return(0);

    } else
        return 0;
}

STATICFN void PutCmdParam(LPDRVCONFIGINFO lpdci, UINT nDrive)
{
    WCHAR sz[MAXINILENGTH];
    LPWSTR lpch;

    if (lpdci->dwDCISize == sizeof(DRVCONFIGINFO))
    {

        if (GetPrivateProfileStringW(
                lpdci->lpszDCISectionName,
                lpdci->lpszDCIAliasName,
                szNull,  sz, MAXINILENGTH-5, szIniFile))
        {

            // There might be a command parameter on the end of the DLL name.
            // Ensure we only have the first token

            sz[MAXINILENGTH-1] = 0;
            lpch = GetTail(sz);
            if (*lpch) {
                // RATS!!  Not a simple name
                while (*--lpch == L' ') {
                }
                *++lpch = TEXT('\0');  // Terminate the string after the DLL name
            }

            // lpch addresses the 0 terminating the DLL name
            // we now add the command parameter into the same buffer, but
            // as a separate string.  This will then be written to win.ini
            // [mcicda.dll]
            //   aliasname = parameter

            *++lpch = (TCHAR)(nDrive + '0');
            *(lpch+1) = '\0';

            WriteProfileString(sz, lpdci->lpszDCIAliasName, lpch);
        }
    }
}

BOOL ConfigDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int    i;
    HWND   hListbox;
    static LPDRVCONFIGINFO lpdci;


    switch (msg) {
    case WM_INITDIALOG:
    {
        WCHAR wszFormat[32];

        hListbox = GetDlgItem (hDlg, C_DRIVE_LIST);
        LoadString( hInstance, IDS_DRIVE, wszFormat,
                    sizeof(wszFormat) / sizeof(WCHAR) );

        lpdci = (LPDRVCONFIGINFO)lParam;
        for (i = 0; i < numdrives; ++i)
        {
            TCHAR item_name[32];

            wsprintf( item_name, wszFormat, CdInfo[i].cDrive );
            SendMessage (hListbox, LB_ADDSTRING, 0, (DWORD)(LPWSTR)item_name);
        }
        i = GetCmdParam(lpdci);
        SendMessage (hListbox, LB_SETCURSEL, (UINT)i, 0);
        break;
    }

    case WM_COMMAND:
        switch (LOWORD(wParam))
            {
            case IDOK:

                hListbox = GetDlgItem (hDlg, C_DRIVE_LIST);

                i = SendMessage (hListbox, LB_GETCURSEL, 0, 0L);
                if (i != LB_ERR)
                    PutCmdParam(lpdci, i);
                EndDialog(hDlg, DRVCNF_OK);
                break;

            case IDCANCEL:
                EndDialog(hDlg, DRVCNF_CANCEL);
                break;

            default:
                break;
            }
        break;

    default:
        return FALSE;
        break;
    }

    return TRUE;
}

STATICFN void DisplayMessage(
        HWND    hwndParent,
        UINT    wMessageID)
{
        WCHAR    aszCaption[128];
        WCHAR    aszMessage[128];

        LoadStringW( hInstance, wMessageID, aszMessage,
                     sizeof(aszMessage) / sizeof(WCHAR) );

        LoadStringW( hInstance, IDS_CONFIGCAPTION, aszCaption,
                     sizeof(aszCaption) / sizeof(WCHAR) );

        MessageBoxW( hwndParent, aszMessage, aszCaption,
                     MB_ICONINFORMATION | MB_OK);
}

int PASCAL FAR CDAConfig (HWND hwndParent, LPDRVCONFIGINFO lpInfo)
{
    int iResult;

    //
    // Initialize global count of number of CD drives present
    //

    numdrives = CDA_init_audio();

    //
    // If no drives are detected we still allow the install
    //
    // If there is more than one drive ask the user which one they want
    // to use with this driver.
    //
    // Note that the user may select cancel in the dialog.
    //

    switch (numdrives) {
    case -1:
    case 0:
        DisplayMessage(hwndParent, IDS_NODRIVES);
        iResult = DRVCNF_OK;
        break;

    case 1:
        DisplayMessage(hwndParent, IDS_ONEDRIVE);
        iResult = DRVCNF_OK;
        break;

    default:
        iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_CONFIG), hwndParent, (DLGPROC)ConfigDlgProc, (DWORD)lpInfo);
        break;
    }

    //
    // Close the devices we opened
    //

    CDA_terminate_audio ();

    //
    // Tell the control panel whether to cancel or continue
    //

    return iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcihwnd\mcihwnd.c ===
/* mcitest.c - WinMain(), main dialog box and support code for MCITest.
 *
 * MCITest is a Windows with Multimedia sample application illustrating
 * the use of the Media Control Interface (MCI). MCITest puts up a dialog
 * box allowing you to enter and execute MCI string commands.
 *
 *    (C) Copyright (c) 1991-1998 Microsoft Corporation
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 */

/*----------------------------------------------------------------------------*\
|   mcitest.c - A testbed for MCI                                              |
|                                                                              |
|                                                                              |
|   History:                                                                   |
|       01/01/88 toddla     Created                                            |
|       03/01/90 davidle    Modified quick app into MCI testbed                |
|       09/17/90 t-mikemc   Added Notification box with 3 notification types   |
|       11/02/90 w-dougb    Commented & formatted the code to look pretty      |
|       05/29/91 NigelT     ported to Win32
|                                                                              |
\*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*\
|                                                                              |
|   i n c l u d e   f i l e s                                                  |
|                                                                              |
\*----------------------------------------------------------------------------*/

#include "mcihwnd.h"

CHAR aszMciWindow[] = MCI_GLOBAL_PROCESS;
PGLOBALMCI base;

/*
//	BOOL CreateMappedFile(void)          INTERNAL
//
//	Set up a global named file to use for interprocess communication.
//  This process will be the only one to write into this shared memory.
//	On exit the memory has been mapped, and our global variable set to
//	point to it.  From here on in most of the work is done in WINMM,
//	including the window creation.
*/
BOOL CreateMappedFile(void)
{
	HANDLE	hFileMapping;
	DWORD	err;

	hFileMapping = CreateFileMapping(
					(HANDLE)-1,		// put onto the paging file
					NULL,			// security attributes
					PAGE_READWRITE,
					0,				// high order size
					sizeof(GLOBALMCI),// only need a few bytes
                    aszMciWindow	// name of file
									);
	dprintf3("hFileMapping from CreateFileMapping is %x", hFileMapping);
	if (!hFileMapping) {
		// Note:  This prevents the module being run twice...
		//		  The second create will fail
		err = GetLastError();
		dprintf2("Error %d from CreateFileMapping", err);
		return FALSE;
	}

	base = MapViewOfFile( hFileMapping, FILE_MAP_WRITE,
							0, 0, 0);  // from beginning for total length

	dprintf3("Base address from MapViewOfFile is %x", base);
	if (!base) {
		err = GetLastError();
		dprintf2("Error %d from MapViewOfFile", err);
		return(FALSE);
	}

	memset(base, 0, sizeof(GLOBALMCI));
	base->dwGlobalProcessId = GetCurrentProcessId();
	base->dwGlobalThreadId = GetCurrentThreadId();
	dprintf3("Setting notify pid/tid to %x %x", base->dwGlobalProcessId, base->dwGlobalThreadId);

	return(TRUE);
}

//
// MYCREATEEVENT
//
BOOL SrvCreateEvent(VOID)
{

	SECURITY_ATTRIBUTES SA;
	HANDLE	hEvent;

	SA.bInheritHandle = TRUE;
	SA.lpSecurityDescriptor = NULL;
	SA.nLength = sizeof(SA);

	hEvent = CreateEvent( &SA,
		                TRUE, // Manual reset
		                FALSE, // initially not signalled
		                NULL); // no name


	if (hEvent) {

		dprintf2("Created shared event, handle is %8x", hEvent);
		base->hEvent = hEvent;
		return(TRUE);

	} else {
#if DBG
		DWORD	err;
		err = GetLastError();
		dprintf2("Error %d creating MCI shared event", err);
#endif
		return(FALSE);
	}
}

//
// MYCREATEMUTEX
//
BOOL SrvCreateMutex(VOID)
{

	SECURITY_ATTRIBUTES SA;
	HANDLE hMutex;

	SA.bInheritHandle = TRUE;
	SA.lpSecurityDescriptor = NULL;
	SA.nLength = sizeof(SA);

	hMutex = CreateMutex( &SA,
		                FALSE, // initially not owned
		                NULL); // no name


	if (hMutex) {

		dprintf2("Created shared mutex, handle is %8x", hMutex);
		base->hMutex = hMutex;
		return(TRUE);

	} else {
#if DBG
		DWORD err;
		err = GetLastError();
		dprintf2("Error %d creating MCI shared mutex", err);
#endif
		return(FALSE);
	}
}

/*----------------------------------------------------------------------------*\
|   MAIN:                                                                      |
|                                                                              |
|   Description:                                                               |
|       The main procedure for the app. After initializing, it just goes       |
|       into a message-processing loop until it gets a WM_QUIT message         |
|       (meaning the app was closed).                                          |
|                                                                              |
|   Arguments:                                                                 |
|       hInst           instance handle of this instance of the app            |
|       hPrev           instance handle of previous instance, NULL if first    |
|       szCmdLine       null-terminated command line string                    |
|       sw              specifies how the window is to be initially displayed  |
|                                                                              |
|   Returns:                                                                   |
|       The exit code as specified in the WM_QUIT message.                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
typedef BOOL (* BOOLPROC)(void);

int __cdecl main(
    int argc,
    char *argv[],
    char *envp[])
{
    MSG     Msg;                    /* Windows message structure */
	HANDLE  hLib;
	BOOLPROC proc;

    // If we are in DEBUG mode, get debug level for this module
    dGetDebugLevel(aszAppName);

#if DBG
    dprintf2("MCIHWND started (debug level %d)", __iDebugLevel);
#endif

    /* Call the initialization procedure */
	/* We load the library explicitly to prevent module load causing */
	/* WINMM's DLL initialisation to be run.  We have probably started */
	/* as a result of that initialisation. */

    if (!CreateMappedFile()) return 0;
    if (!SrvCreateEvent()) return 0;	  	// Set up the shared event
    if (!SrvCreateMutex()) return 0;	  	// Set up the shared mutex
	base->dwType = GMCI_MCIHWND;

	UnmapViewOfFile(base);
	base = NULL;

	hLib = LoadLibrary("WINMM");
	if (!hLib) {
		dprintf("MCIHWND failed to load WINMM");
		return(FALSE);
	}

	proc = (BOOLPROC)GetProcAddress(hLib, (LPCSTR)"mciSoundInit");

    if (NULL == proc) {
		dprintf("cannot get address of mciWndInit");
        return FALSE;
    }

    if (!(*proc)()) {
		dprintf("failure returned from mciWndInit");
        return FALSE;
    }

	dprintf4("MCIHWND now going into its message loop");

    /* Poll the event queue for messages */

    while (GetMessage(&Msg, NULL, 0, 0))  {

        /* Main message processing */
		dprintf4("Message received %8x   Hwnd=%8x  wParam=%8x  lParam=%8x", Msg.message, Msg.hwnd, Msg.wParam, Msg.lParam);

        TranslateMessage(&Msg);
        DispatchMessage(&Msg);
    }
	dprintf2("MCIHWND exited its message loop");
	dprintf2("    Last message %8x   Hwnd=%8x  wParam=%8x  lParam=%8x", Msg.message, Msg.hwnd, Msg.wParam, Msg.lParam);

	DebugBreak();
	dprintf1("MCIHWND should not be here...");

    return Msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciseq\callback.c ===
/* Copyright (c) 1992 Microsoft Corporation */
/*  callback put in separate module because must be fixed */
#define UNICODE

//MMSYSTEM
#define MMNOSOUND        - Sound support
#define MMNOWAVE         - Waveform support
#define MMNOAUX          - Auxiliary output support
#define MMNOJOY          - Joystick support

//MMDDK
#define NOWAVEDEV         - Waveform support
#define NOAUXDEV          - Auxiliary output support
#define NOJOYDEV          - Joystick support

#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "mmsys.h"
#include "list.h"
#include "mciseq.h"

PUBLIC void FAR PASCAL _LOADDS mciSeqCallback (HANDLE h, UINT wMsg, DWORD_PTR dwInstance,
                                                    DWORD_PTR dw1, DWORD_PTR dw2)
// this function handles messages from the sequencer
{
    pSeqStreamType  pStream = (pSeqStreamType) dwInstance;

    switch (wMsg)
    {
        case MIDISEQ_DONE:  // sequencer is done with buff (& wants a new one)
            // clear the beginning and end flags, and set the done flag
            ((LPMIDISEQHDR) dw1)->wFlags &= ~(MIDISEQHDR_BOT + MIDISEQHDR_EOT);
            ((LPMIDISEQHDR) dw1)->wFlags |= MIDISEQHDR_DONE;  // set done bit
            TaskSignal(pStream->streamTaskHandle, WTM_FILLBUFFER); // SIGNAL on this seq
            break;

        case MIDISEQ_RESET: // sequencer wants to reset the stream
            StreamTrackReset(pStream, (UINT) dw1);
            break;
        case MIDISEQ_DONEPLAY:
            TaskSignal(pStream->streamTaskHandle, WTM_DONEPLAY);
            break;
    }
}

/***********************************************************************/

PUBLIC void FAR PASCAL NotifyCallback(HANDLE hStream)
// Callback for all notifies from MMSEQ
{
    Notify((pSeqStreamType)hStream, MCI_NOTIFY_SUCCESSFUL);
}

/*************************************************************************/

PUBLIC VOID FAR PASCAL Notify(pSeqStreamType pStream, UINT wStatus)
// notifies with cb and instance stored in pStream, with wMsg (success, abort..)

{
    if (pStream->hNotifyCB) {
        mciDriverNotify(pStream->hNotifyCB, pStream->wDeviceID, wStatus);
        pStream->hNotifyCB = NULL; // this signifies that it has been notified
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcihwnd\mcihwnd.h ===
// Copyright (c) 1992 Microsoft Corporation
/*
//
//  Local header file for MCIHWND - permanent window for MM code
//
*/

#define DEBUGLEVELVAR __iDebugLevel

#ifndef RC_INVOKED

#include <string.h>
#include <stdio.h>

#endif /* RC_INVOKED */

#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "mci.h"

#if DBG

extern char aszAppName[];
extern int dGetDebugLevel(LPSTR lpszAppName);

#else

#define dGetDebugLevel(x)

#endif

/***************************************************************************

    DEBUGGING SUPPORT

 ***************************************************************************/


#if DBG

    #ifdef DEBUGLEVELVAR
      // So that other related modules can use their own debug level
      // variable
      #define winmmDebugLevel DEBUGLEVELVAR
    #endif

    extern BOOL fDebugBreak;
    extern int winmmDebugLevel;
    extern void winmmDbgOut(LPSTR lpszFormat, ...);
    extern void dDbgAssert(LPSTR exp, LPSTR file, int line);

    DWORD __dwEval;

#ifdef BASE_DEBUG

    #define dprintf                            DbgPrint
    #define dprintf1 if (winmmDebugLevel >= 1) DbgPrint
    #define dprintf2 if (winmmDebugLevel >= 2) DbgPrint
    #define dprintf3 if (winmmDebugLevel >= 3) DbgPrint
    #define dprintf4 if (winmmDebugLevel >= 4) DbgPrint
    #define dprintf5 if (winmmDebugLevel >= 5) DbgPrint

#else

    extern void winmmDbgOut(LPSTR lpszFormat, ...);

    #define dprintf                            winmmDbgOut
    #define dprintf1 if (winmmDebugLevel >= 1) winmmDbgOut
    #define dprintf2 if (winmmDebugLevel >= 2) winmmDbgOut
    #define dprintf3 if (winmmDebugLevel >= 3) winmmDbgOut
    #define dprintf4 if (winmmDebugLevel >= 4) winmmDbgOut
    #define dprintf5 if (winmmDebugLevel >= 5) winmmDbgOut

#endif // BASE_DEBUG

    #define WinAssert(exp) \
        ((exp) ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__))

    #define WinEval(exp) \
        ((__dwEval=(DWORD)(exp)),  \
		  __dwEval ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__), __dwEval)

    #define DOUT(x) (OutputDebugString(x), OutputDebugString("\r\n"), 0)
    #define DOUTX(x) (OutputDebugString(x), 0)
    #define ROUTS(x) (OutputDebugString(x), OutputDebugString("\r\n"), 0)
    #define ROUT(x) (OutputDebugString(x), OutputDebugString("\r\n"), 0)
    #define ROUTX(x) (OutputDebugString(x), 0)

#else
    #define DebugBreak()
    #define fDebugBreak    0 /* Therefore FALSE */

    #define dprintf  if (0) ((int (*)(char *, ...)) 0)
    #define dprintf1 if (0) ((int (*)(char *, ...)) 0)
    #define dprintf2 if (0) ((int (*)(char *, ...)) 0)
    #define dprintf3 if (0) ((int (*)(char *, ...)) 0)
    #define dprintf4 if (0) ((int (*)(char *, ...)) 0)
    #define dprintf5 if (0) ((int (*)(char *, ...)) 0)

    #define WinAssert(exp) 0
    #define WinEval(exp) (exp)

    #define DOUT(x)     0
    #define DOUTX(x)    0
    #define ROUTS(x)    0
    #define ROUT(x)     0
    #define ROUTX(x)    0

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciole\libinit.asm ===
page	,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  LIBINIT.ASM
;
; library stub to do local init for a Dynamic linked library
;
; Created: 06-27-89
; Author:  Todd Laney [ToddLa]
;
; Exported Functions:   none
;
; Public Functions:     none
;
; Public Data:		none
;
; General Description:
;
; Restrictions:
;
;   This must be the first object file in the LINK line, this assures
;   that the reserved parameter block is at the *base* of DGROUP
;
;-----------------------------------------------------------------------;

?PLM=1      ; PASCAL Calling convention is DEFAULT
?WIN=1	    ; Windows calling convention

        .286p
	.xlist
	include cmacros.inc
;       include windows.inc
        .list

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;   external functions
;
        externFP    LocalInit           ; in KERNEL
        externP     LibMain             ; C code to do DLL init

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
%out link me first!!
sBegin  Data
assumes DS,Data
            org 0               ; base of DATA segment!

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
	__acrtused = 1

sEnd        Data

;-----------------------------------------------------------------------;

sBegin  CodeSeg
        assumes cs,CodeSeg

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used)
;
; Returns:
;       AX = TRUE if success
; Error Returns:
;       AX = FALSE if error (ie fail load process)
; Registers Preserved:
;	SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,ES,FLAGS
; Calls:
;	None
; History:
;
;       06-27-89 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
        ;
        ; Init the local heap (if one is declared in the .def file)
        ;
        jcxz no_heap

        cCall   LocalInit,<0,0,cx>

no_heap:
        cCall   LibMain, <di>
cEnd

if 0
;--------------------------Exported-Routine-----------------------------;
;
;   WEP()
;
;   called when the DLL is unloaded, it is passed 1 WORD parameter that
;   is TRUE if the system is going down, or zero if the app is
;
;   WARNING:
;
;       This function is basicly useless, you cant can any kernel function
;       that may cause the LoadModule() code to be reentered..
;
;-----------------------------------------------------------------------;

cProc   WEP,<FAR,PUBLIC,NODATA>,<>
;       ParmW   fSystemExit
cBegin  nogen
        mov     ax,1
        retf    2
cEnd    nogen
endif

sEnd    CodeSeg

        end     LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciseq\debug.c ===
/* Copyright (c) 1992 Microsoft Corporation */
/*
    debug.c

    Support code for the dprintf routines.

    Note that all of this is conditional on the DBG flag

*/
#include <windows.h>
#include <mmsystem.h>
#include "mmsys.h"
#include "list.h"

#include "stdio.h"
#include "mciseq.h"            // private include file
#include <stdarg.h>

#if DBG
    #ifdef MEDIA_DEBUG
        int mciseqDebugLevel = 0;
    #else
        int mciseqDebugLevel = 0;
    #endif

/***************************************************************************

    @doc INTERNAL

    @api void | mciseqDbgOut | This function sends output to the current
        debug output device.

    @parm LPSTR | lpszFormat | Pointer to a printf style format string.
    @parm ??? | ... | Args.

    @rdesc There is no return value.

****************************************************************************/

void mciseqDbgOut(LPSTR lpszFormat, ...)
{
    UINT n;
    char buf[256];
    va_list va;

    n = wsprintf(buf, "MCISEQ: (tid %x) ", GetCurrentThreadId());

    va_start(va, lpszFormat);
    n += vsprintf(buf+n, lpszFormat, va);
    va_end(va);

    buf[n++] = '\n';
    buf[n] = 0;
    OutputDebugStringA(buf);
    Sleep(10);  // let terminal catch up
}

#endif // DBG

/**************************************************************************

    @doc INTERNAL

    @api void | mciseqSetDebugLevel | Set the current debug level

    @parm int | iLevel | The new level to set

    @rdesc There is no return value

**************************************************************************/

void mciseqSetDebugLevel(int level)
{
#if DBG
    mciseqDebugLevel = level;
    dprintf(("debug level set to %d", mciseqDebugLevel));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciole\mciole.h ===
// Copyright (c) 1992 Microsoft Corporation
///////////////////////////////////////////////////////////////////////////////
//
//  these are the default OLE functions (exported from OLECLI.DLL)
//
///////////////////////////////////////////////////////////////////////////////
extern OLESTATUS FAR PASCAL DefLoadFromStream (LPOLESTREAM, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);
extern OLESTATUS FAR PASCAL DefCreateFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);
extern OLESTATUS FAR PASCAL DefCreateLinkFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
extern OLESTATUS FAR PASCAL DefCreateFromTemplate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
extern OLESTATUS FAR PASCAL DefCreate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
extern OLESTATUS FAR PASCAL DefCreateFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
extern OLESTATUS FAR PASCAL DefCreateLinkFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

///////////////////////////////////////////////////////////////////////////////
//
//  these are our OLE handlers (defined in this file)
//
///////////////////////////////////////////////////////////////////////////////

// Server has to implement only the following methods.
LPVOID          FAR PASCAL _LOADDS DllQueryProtocol         (LPOLEOBJECT, LPSTR);
OLESTATUS       FAR PASCAL _LOADDS DllRelease               (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _LOADDS DllShow                  (LPOLEOBJECT, BOOL);
OLESTATUS       FAR PASCAL _LOADDS DllDoVerb                (LPOLEOBJECT, UINT, BOOL, BOOL);
OLESTATUS       FAR PASCAL _LOADDS DllGetData               (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
OLESTATUS       FAR PASCAL _LOADDS DllSetData               (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS       FAR PASCAL _LOADDS DllSetTargetDevice       (LPOLEOBJECT, HANDLE);
OLESTATUS       FAR PASCAL _LOADDS DllSetBounds             (LPOLEOBJECT, LPRECT);
OLECLIPFORMAT   FAR PASCAL _LOADDS DllEnumFormats           (LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS       FAR PASCAL _LOADDS DllSetColorScheme        (LPOLEOBJECT, LPLOGPALETTE);

// Extra methods required for client.
OLESTATUS       FAR PASCAL _LOADDS DllDelete                (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _LOADDS DllSetHostNames          (LPOLEOBJECT, LPSTR, LPSTR);
OLESTATUS       FAR PASCAL _LOADDS DllSaveToStream          (LPOLEOBJECT, LPOLESTREAM);
OLESTATUS       FAR PASCAL _LOADDS DllClone                 (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *);
OLESTATUS       FAR PASCAL _LOADDS DllCopyFromLink          (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *);
OLESTATUS       FAR PASCAL _LOADDS DllEqual                 (LPOLEOBJECT, LPOLEOBJECT);
OLESTATUS       FAR PASCAL _LOADDS DllCopyToClipboard       (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _LOADDS DllDraw                  (LPOLEOBJECT, HDC, LPRECT, LPRECT, HDC);
OLESTATUS       FAR PASCAL _LOADDS DllActivate              (LPOLEOBJECT, WORD, BOOL, BOOL, HWND, LPRECT);
OLESTATUS       FAR PASCAL _LOADDS DllExecute               (LPOLEOBJECT, HANDLE, WORD);
OLESTATUS       FAR PASCAL _LOADDS DllClose                 (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _LOADDS DllUpdate                (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _LOADDS DllReconnect             (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _LOADDS DllObjectConvert         (LPOLEOBJECT, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *);
OLESTATUS       FAR PASCAL _LOADDS DllGetLinkUpdateOptions  (LPOLEOBJECT, OLEOPT_UPDATE FAR *);
OLESTATUS       FAR PASCAL _LOADDS DllSetLinkUpdateOptions  (LPOLEOBJECT, OLEOPT_UPDATE);
OLESTATUS       FAR PASCAL _LOADDS DllRename                (LPOLEOBJECT, LPSTR);
OLESTATUS       FAR PASCAL _LOADDS DllQueryName             (LPOLEOBJECT, LPSTR, UINT FAR *);
OLESTATUS       FAR PASCAL _LOADDS DllQueryType             (LPOLEOBJECT, LPLONG);
OLESTATUS       FAR PASCAL _LOADDS DllQueryBounds           (LPOLEOBJECT, LPRECT);
OLESTATUS       FAR PASCAL _LOADDS DllQuerySize             (LPOLEOBJECT, DWORD FAR *);
OLESTATUS       FAR PASCAL _LOADDS DllQueryOpen             (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _LOADDS DllQueryOutOfDate        (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _LOADDS DllQueryReleaseStatus    (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _LOADDS DllQueryReleaseError     (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _LOADDS DllRequestData           (LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS       FAR PASCAL _LOADDS DllObjectLong            (LPOLEOBJECT, UINT, LPLONG);
OLE_RELEASE_METHOD  FAR PASCAL _LOADDS DllQueryReleaseMethod(LPOLEOBJECT);

// This method is internal only
OLESTATUS       FAR PASCAL _LOADDS DllChangeData            (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);

///////////////////////////////////////////////////////////////////////////////
//
//  DEBUG STUFF
//
///////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG
    extern void FAR cdecl dprintf(LPSTR, ...);

    #define DPRINTF(x) dprintf x
#else
    #define DPRINTF(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciole\mciole.c ===
/* Copyright (c) 1992-1999 Microsoft Corporation */
/*****************************************************************************\
 *
 * MCIOLE.C
 *
 * Modified 19-Oct-1992 by Mike Tricker [MikeTri] Ported to Win32
 *
\*****************************************************************************/

// #define USE_MOUSE_HOOK

#ifdef WIN32

#if DBG
#define DEBUG
#endif

#endif

//
//  MCIOLE  - OLE handler DLL for MCI objects
//
//
//  NOTES:
//      The whole reason for this handler DLL is to supply the function
//
//      OleQueryObjPos()
//
//      this function gives information to the server application on the
//      location (in the client document) of the activated OLE object.
//      the server can use this information to play the object in place
//      or position the server window correctly
//
//  IMPLEMENTION:
//
//      in theory all this DLL (handler) has to do is save the information
//      passed to OleActivate().  But in reality no app correctly calls
//      OleActivate().  They either pass no information or the wrong
//      information.
//
//      this DLL is a OLE handler, because of global data (vtblDef!) it
//      can only be a handler for one class at a time.
//
//      the handler intercepts the OleDraw, OleActivate, and all the
//      creation/destuction OLE APIs.  for each OLE object a info
//      structure is maintained (a OBJINFO structure) when ever the
//      client draws (using OleDraw...) the drawing position, and the
//      window drawn to is remembered.
//
//      when the client calls OleActivate, the saved draw location is
//      recalled, or if the app never called OleDraw() (plays
//      the meta-file itself) then the rectangle passed to OleActivate()
//      is used. (if one is supplied)
//
//      there are many classes of apps:
//
//          calls OleActivate() with correct info
//          calls OleActivate() with incorrect info
//          calls OleActivate() with no info
//
//          calls OleDraw()
//          does not call OleDraw()
//
//      here is a table of known OLE Clients....
//
//                      OleDraw     OleActivate()
//      App             Y or N      Y, N, X
//                                  (X = wrong info)
//      -------------   ----------  ------------
//      Write           Y           N
//      CardFile        Y           N
//      Packager        Y           N
//
//      Excel           N           N               (uses DDE)
//      Excel 4.0       N           N               (uses DDE)
//      PowerPnt 2.0    N           N               (uses DDE)
//
//      WinWord         N           N
//      WinWorks        Y           X
//      PowerPnt 3.0    N           Y
//      MsPublisher     N           X
//      ClTest          Y           N
//      Cirus           Y           X
//      WinProj         ?           ?
//
//      AmiPro          Y           ?
//
#include <windows.h>
#include <ole.h>
#include <port1632.h>
#include <stdio.h>
#include "mciole.h"
#ifdef WIN32
#include <stdlib.h>
#else
#include <shellapi.h>
#endif

HANDLE          ghInstance;     // Module handle
BOOL            fRunningInWOW;  // Dll attached to the WOW process
OLEOBJECTVTBL   vtblDll;        // these are our functions.
OLEOBJECTVTBL   vtblDef;        // these are the default functions.
HBITMAP         hbmStock;


/******************************************************************************\
**
** The mciole32 shared memory.
**
** This is only used when mplay32 is serving a WOW client.  The memory
** always gets mapped into the WOW process.  It only gets mapped into
** the mplay32.exe server process if mplay32.exe detects that it is serving
** a WOW client app.  Therefore the global variable lpvMem is NULL in all
** other processes.
**
** The memory gets mapped into the mplay32.exe server when it sets the
** the global hook.  We can detect that mplay32.exe is serving a WOW client
** because the clients window handle will have 0xFFFF in its HIWORD.
** Of course this is a real hack.
**
** Inside the hook proc we look at lpvMem.  If it is NULL we ignore it because
** current process is not WOW or mplay32.exe serving a WOW client.
** We then check to see if the client process id matches the current process
** id.  If this is the case we look for interesting mouse message and stop
** the playing in place if we find any.
**
** If lpvMem is not NULL the current process must either by WOW or mplay32.exe
** serving a WOW client, in which case the global fRunningInWOW will be FALSE.
**
**
**
**
\******************************************************************************/
typedef struct {
    HWND    hwndServer;
    DWORD   wow_app_thread_id;
} MCIOLE32_SHARED_MEMORY;
MCIOLE32_SHARED_MEMORY   *lpvMem;
HANDLE hMapObject = NULL;   /* handle to file mapping */


#ifdef DEBUG
RECT rcNull = {0,0,0,0};
UINT oleDebugLevel = 0;
#define PUSHRC(prc) *((prc) ? (prc) : &rcNull)
#define CARETPOS()  // {POINT pt; GetCaretPos(&pt); DPRINTF(("CaretPos: [%d, %d]", pt.x, pt.y));}
#endif


/****************************************************************************
****************************************************************************/

void    ReplaceFunctions(LPOLEOBJECT);
BOOL    CanReplace(LPOLEOBJECT);

#ifndef WIN32
/****************************************************************************

    FUNCTION: LibMain(HANDLE hInstance)

****************************************************************************/

BOOL NEAR PASCAL LibMain (HANDLE hInstance)
{
    HDC hdc;
    HBITMAP hbm;

    ghInstance = (HANDLE)hInstance;


    //
    // get the stock 1x1 mono bitmap.
    //
    hbm = CreateBitmap(1,1,1,1,NULL);
    hdc = CreateCompatibleDC(NULL);
    hbmStock = SelectObject(hdc, hbm);
    SelectObject(hdc, hbmStock);
    DeleteDC(hdc);
    DeleteObject(hbm);

//  // register clipboard formats.
//  cfObjectLink    = RegisterClipboardFormat("ObjectLink");
//  cfOwnerLink     = RegisterClipboardFormat("OwnerLink");
//  cfNative        = RegisterClipboardFormat("Native");

    return TRUE;
}
#else

/****************************************************************************

    FUNCTION: DllEntryPoint(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved)

    This function is called whenever a process attaches or detaches to/from
    the DLL.

****************************************************************************/
BOOL
DllEntryPoint(
    HINSTANCE hinstDLL,         /* DLL module handle        */
    DWORD fdwReason,            /* reason called            */
    LPVOID lpvReserved)         /* reserved                 */
{

    BOOL fIgnore;
    HDC hdc;
    HBITMAP hbm;

#   define SHMEMSIZE (sizeof(MCIOLE32_SHARED_MEMORY))


    switch (fdwReason) {

    /*
    ** DLL is attaching to a process, due to process
    ** initialization or a call to LoadLibrary.
    */
    case DLL_PROCESS_ATTACH:

        ghInstance = (HANDLE)hinstDLL;

        //
        // get the stock 1x1 mono bitmap. why ??
        //

        hbm = CreateBitmap(1,1,1,1,NULL);
        if (NULL != hbm)
        {
            hdc = CreateCompatibleDC(NULL);
            if (NULL != hdc)
            {
                hbmStock = SelectObject(hdc, hbm);
                if (NULL != hbmStock)
                    SelectObject(hdc, hbmStock);
                DeleteDC(hdc);
            }
            DeleteObject(hbm);
        }

#ifdef DEBUG
        oleDebugLevel = GetProfileInt("Debug", "MCIOLE32", 0);
#endif

        /*
        **
        **
        **
        ** create named file mapping object
        */
        hMapObject = CreateFileMapping(INVALID_HANDLE_VALUE, // use paging file
                                       NULL,              // no security attr.
                                       PAGE_READWRITE,    // read/write access
                                       0,                 // size: high 32-bits
                                       SHMEMSIZE,         // size: low 32-bits
                                       "mciole32shrmem"); // name of map object

        if (hMapObject == NULL) {
            return FALSE;
        }


        /*
        ** The first process to attach initializes memory.
        **
        ** fInit = (GetLastError() != ERROR_ALREADY_EXISTS);
        **
        */

        /*
        ** Are we attaching to the WOW process ?
        ** If so the we map the shared memory into the process.
        */
        fRunningInWOW = (GetModuleHandle( "WOW32.DLL" ) != NULL);
        if ( fRunningInWOW ) {

            DPRINTF(( "Attaching shared memory to WOW process" ));

            /*
            ** Get a pointer to file mapped shared memory.
            */
            lpvMem = MapViewOfFile( hMapObject, FILE_MAP_WRITE, 0, 0, 0 );
            if (lpvMem == NULL) {
                fIgnore = CloseHandle(hMapObject);
                return FALSE;
            }
        }
        break;


    case DLL_THREAD_ATTACH:
        /*
        ** The attached process creates a new thread.
        */
        break;


    case DLL_THREAD_DETACH:
        /*
        ** The thread of the attached process terminates.
        */
        break;


    case DLL_PROCESS_DETACH:
        /*
        ** The DLL is detaching from a process, due to
        ** process termination or a call to FreeLibrary.
        **
        ** Unmap shared memory from process' address space.  But only
        ** if it was mapped.
        */

        if ( lpvMem ) {

#ifdef DEBUG
            if ( fRunningInWOW ) {
                DPRINTF(( "Unmapping shared memory from WOW process" ));
            }
#endif
            fIgnore = UnmapViewOfFile(lpvMem);
        }

        /*
        ** Close the process' handle to the file-mapping object.
        */
        fIgnore = CloseHandle(hMapObject);
        break;


    default:
        break;

    }


    return TRUE;
}
#endif

#ifndef WIN32
/****************************************************************************

    FUNCTION: WEP(int)

    PURPOSE: Standard exit routine for the DLL

****************************************************************************/

int FAR PASCAL _LOADDS WEP(nParameter)
int nParameter;
{
    return 1;
}

/****************************************************************************
****************************************************************************/

BOOL NEAR PASCAL IsApp(LPSTR szApp)
{
    char ach[80];
    int  i;
    WORD wStack;

    _asm mov wStack,ss

    GetModuleFileName((HINSTANCE)wStack, ach, sizeof(ach));

    for (i = lstrlen(ach);
        i > 0 && ach[i-1] != '\\' && ach[i-1] != '/' && ach[i] != ':';
        i--)
        ;

    return lstrcmpi(ach + i, szApp) == 0;
}

#endif //!WIN32

/****************************************************************************
****************************************************************************/

BOOL NEAR PASCAL IsDcMemory(HDC hdc)
{
    HBITMAP hbmT;

    if (hbmT = SelectObject(hdc, hbmStock))
        SelectObject(hdc, hbmT);

    return hbmT != NULL;
}

/****************************************************************************
****************************************************************************/

typedef struct _OBJINFO {

    struct _OBJINFO*poiNext;

    LPOLEOBJECT     lpobj;          // client side LPOLEOBJECT

    HWND            hwnd;           // client window (passed to OleActivate)
    RECT            rcActivate;     // activation rectangle (passed to OleActivate)

    HWND            hwndDraw;       // active window at time of OleDraw
    RECT            rcDraw;         // rectangle of draw
}   OBJINFO;

BOOL RegSetGetData(OBJINFO *poi, BOOL Write)
{
    LONG Length;

    static CHAR szKey[] = "PlayData";
    static CHAR szFormat[] = "%ld %ld %d %d %d %d %d %d %d %d";


    if (Write) {
        LONG Rc;

        CHAR Data[100];

        //
        // Store hwnd, hwnddraw, rcDraw, rcActivate
        //

#ifdef WIN32
        wsprintf(Data, szFormat,
                 (LONG_PTR)poi->hwnd,
                 (LONG_PTR)poi->hwndDraw,
                 poi->rcDraw.left,
                 poi->rcDraw.right,
                 poi->rcDraw.top,
                 poi->rcDraw.bottom,
                 poi->rcActivate.left,
                 poi->rcActivate.right,
                 poi->rcActivate.top,
                 poi->rcActivate.bottom);

#else
        wsprintf(Data, szFormat,
                 (LONG)(poi->hwnd == NULL ? (LONG)0 : MAKELONG(poi->hwnd, 0xFFFF)),
                 (LONG)(poi->hwndDraw == NULL ? (LONG)0 : MAKELONG(poi->hwndDraw, 0xFFFF)),
                 poi->rcDraw.left,
                 poi->rcDraw.right,
                 poi->rcDraw.top,
                 poi->rcDraw.bottom,
                 poi->rcActivate.left,
                 poi->rcActivate.right,
                 poi->rcActivate.top,
                 poi->rcActivate.bottom);
#endif

        Rc = RegSetValue(HKEY_CLASSES_ROOT,
                         szKey,
                         REG_SZ,
                         Data,
                         lstrlen(Data));

        return Rc == ERROR_SUCCESS;
    } else {

#ifdef WIN32
        LONG Rc;
        CHAR Data[100];

        Length = sizeof(Data);

        Rc = RegQueryValue(HKEY_CLASSES_ROOT, szKey,
                           Data, &Length);

        RegSetValue(HKEY_CLASSES_ROOT, szKey, REG_SZ, "", 0);

        //
        // Extract our data - sscanf doesn't work yet!!!
        //

        if (Rc == ERROR_SUCCESS) {

            LONG OurData[10];
            int i;
            LPTSTR lpData;

            for (i = 0, lpData = Data; i < 10; i++) {
                OurData[i] = atol(lpData);
                while (*lpData != ' ' && *lpData != '\0') {
                    lpData++;
                }

                if (*lpData == ' ') {
                    lpData++;
                }
            }

            poi->hwnd = (HWND)(UINT_PTR)OurData[0];
            poi->hwndDraw = (HWND)(UINT_PTR)OurData[1];
            poi->rcDraw.left = OurData[2];
            poi->rcDraw.right = OurData[3];
            poi->rcDraw.top = OurData[4];
            poi->rcDraw.bottom = OurData[5];
            poi->rcActivate.left = OurData[6];
            poi->rcActivate.right = OurData[7];
            poi->rcActivate.top = OurData[8];
            poi->rcActivate.bottom = OurData[9];
        }

        return Rc == ERROR_SUCCESS && Length != 0;
#else
        return FALSE;
#endif
    }
}

#ifdef DEBUG
int nObjects = 0;
#endif
OBJINFO *poiFirst = NULL;

OBJINFO *FindObj(LPOLEOBJECT lpobj)
{
    OBJINFO *poi;

    for (poi=poiFirst; poi; poi=poi->poiNext)
        if (poi->lpobj == lpobj)
            return poi;

    DPRINTF(("FindObj: Unable to find object %lx", lpobj));

    return NULL;
}

void DelObj(LPOLEOBJECT lpobj)
{
    OBJINFO *poi;
    OBJINFO *poiT;

    for (poiT=NULL,poi=poiFirst; poi; poiT=poi,poi=poi->poiNext)
    {
        if (poi->lpobj == lpobj)
        {
            if (poiT)
                poiT->poiNext = poi->poiNext;
            else
                poiFirst = poi->poiNext;

            poi->lpobj = NULL;
            LocalFree((HLOCAL)poi);

            DPRINTF(("DelObj(%lx): %d objects", lpobj, --nObjects));
            return;
        }
    }

    DPRINTF(("DelObj(%lx): Cant find object to delete.", lpobj));
}

//
// for some reason we dont get all the OleDelete() calls that we should
// so lets try to "weed out the bad apples" so we dont choke.
//
void CleanObjects()
{
    OBJINFO *poi;

again:
    for (poi=poiFirst; poi; poi=poi->poiNext)
    {
        if (IsBadReadPtr(poi->lpobj, 0))
        {
            DPRINTF(("Freeing bad object %lx", poi->lpobj));
            DelObj(poi->lpobj);
            goto again;
        }
    }
}

OBJINFO *NewObj(LPOLEOBJECT lpobj)
{
    OBJINFO *poi;

    CleanObjects();

    if (poi = FindObj(lpobj))
    {
        DPRINTF(("NewObj(%lx): Trying to add object twice!", lpobj));
        return poi;
    }

    if (poi = (OBJINFO*)LocalAlloc(LPTR, sizeof(OBJINFO)))
    {
        poi->lpobj = lpobj;
        poi->hwnd  = NULL;
        poi->hwndDraw = NULL;
        SetRectEmpty(&poi->rcDraw);
        SetRectEmpty(&poi->rcActivate);

        poi->poiNext = poiFirst;
        poiFirst = poi;

        DPRINTF(("NewObj(%lx): %d objects", lpobj, ++nObjects));
    }
    else
    {
        DPRINTF(("NewObj(%lx): Out of room in the object table", lpobj));
    }

    return poi;
}

/****************************************************************************
****************************************************************************/

#ifndef WIN32
HWND LookForDC(HWND hwndP, HDC hdc)
{
    RECT    rc;
    DWORD   dw;
    HWND    hwnd;

    if (hwndP == NULL)
        return NULL;

    dw = GetDCOrg(hdc);

    for (hwnd = hwndP; hwnd; hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        GetClientRect(hwnd, &rc);
        ClientToScreen(hwnd, (LPPOINT)&rc);
        ClientToScreen(hwnd, (LPPOINT)&rc+1);

        if ((int)LOWORD(dw) == rc.left && (int)HIWORD(dw) == rc.top)
            return hwnd;

        if (PtInRect(&rc, MAKEPOINT(dw)) && (hwndP = GetWindow(hwnd, GW_CHILD)))
            if (hwndP = LookForDC(hwndP,hdc))
                return hwndP;
    }

    return NULL;
}

HWND WindowFromDC(HDC hdc)
{
    return LookForDC(GetDesktopWindow(), hdc);
}
#endif

/****************************************************************************
****************************************************************************/

BOOL RectSameSize(LPRECT lprc1, LPRECT lprc2)
{
    return lprc1->right  - lprc1->left == lprc2->right  - lprc2->left &&
           lprc1->bottom - lprc1->top  == lprc2->bottom - lprc2->top;
}

/****************************************************************************

    OleQueryObjPos - this function retuns the last drawn or activated
                     position of a object

****************************************************************************/

OLESTATUS FAR PASCAL _LOADDS OleQueryObjPos(
LPOLEOBJECT lpobj,      /* object to query */
HWND FAR *  lphwnd,     /* window of the document containing the object */
LPRECT      lprc,       /* rect (client cords) of object. */
LPRECT      lprcWBounds)/* rect (client cords) of bounding rect. */
{
    OBJINFO oi;

    //
    // we dont do this any more
    //
    if (lprcWBounds)
        SetRectEmpty(lprcWBounds);

    //
    // because the server side calls this API the passed lpobj is
    // a server side LPOLEOBJECT, we can't search our table for this
    // object.
    //
    // this API is only callable by the server during the DoVerb
    // server callback
    //
    //!!! this only works for the last active object!!!!

    DPRINTF(("OleQueryObjPos(%lx)", lpobj));


    if (RegSetGetData(&oi, FALSE))
    {
        *lphwnd = oi.hwnd;

//      if (IsRectEmpty(&oi.rcActivate))
        if (!IsRectEmpty(&oi.rcDraw))
        {
            DPRINTF(("Using the OleDraw() rectange...."));

            //
            // use the draw rectangle
            //
            *lprc = oi.rcDraw;

            if (oi.hwndDraw)
            {
                ClientToScreen(oi.hwndDraw, (LPPOINT)lprc);
                ClientToScreen(oi.hwndDraw, (LPPOINT)lprc+1);
            }

            ScreenToClient(oi.hwnd, (LPPOINT)lprc);
            ScreenToClient(oi.hwnd, (LPPOINT)lprc+1);
        }
        else
        {
            //
            // use the activate rectangle
            //
            *lprc = oi.rcActivate;
        }

        if (oi.hwnd && !IsRectEmpty(lprc))
            return OLE_OK;
        else
            return OLE_ERROR_BLANK;     // return a error, we dont know about this OBJ
    }
    else
    {
        *lphwnd = NULL;
        SetRectEmpty(lprc);

        return OLE_ERROR_BLANK;     // return a error, we dont know about this OBJ
    }
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _LOADDS DllLoadFromStream (lpstream, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, objType, aClass, cfFormat)
LPOLESTREAM         lpstream;
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
LONG                objType;
ATOM                aClass;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;

    DPRINTF(("OleLoadFromStream(%s,%s)", lpprotocol, lpobjname));

    retVal = DefLoadFromStream (lpstream, lpprotocol, lpclient,
                    lhclientdoc, lpobjname, lplpobj,
                    objType, aClass, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _LOADDS DllCreateFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat, objType)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
LONG                objType;
{
    OLESTATUS   retVal;

    DPRINTF(("OleCreateFromClip(%s,%s)", lpprotocol, lpobjname));

    retVal =  DefCreateFromClip (lpprotocol, lpclient,
                            lhclientdoc, lpobjname, lplpobj,
                            optRender, cfFormat, objType);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _LOADDS DllCreateLinkFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS       retVal;
    BOOL            bReplace = FALSE;

    DPRINTF(("OleCreateLinkFromClip(%s,%s)", lpprotocol, lpobjname));

    retVal =  DefCreateLinkFromClip (lpprotocol, lpclient,
                        lhclientdoc, lpobjname, lplpobj,
                        optRender, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _LOADDS DllCreateFromTemplate (lpprotocol, lpclient, lptemplate, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lptemplate;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;

    DPRINTF(("OleCreateFromTemplate(%s,%s,%s)", lpprotocol, lptemplate, lpobjname));

    retVal = DefCreateFromTemplate (lpprotocol, lpclient, lptemplate,
                            lhclientdoc, lpobjname, lplpobj,
                            optRender, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _LOADDS DllCreate (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;

    DPRINTF(("OleCreate(%s,%s,%s)", lpprotocol, lpclass, lpobjname));

    retVal = DefCreate (lpprotocol, lpclient, lpclass,
                    lhclientdoc, lpobjname, lplpobj,
                    optRender, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _LOADDS DllCreateFromFile (lpprotocol, lpclient, lpclass, lpfile, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;

    DPRINTF(("OleCreateFromFile(%s,%s,%s,%s)", lpprotocol, lpclass, lpfile, lpobjname));

    retVal = DefCreateFromFile (lpprotocol, lpclient, lpclass, lpfile,
                        lhclientdoc, lpobjname, lplpobj,
                        optRender, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}


/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _LOADDS DllCreateLinkFromFile (lpprotocol, lpclient, lpclass, lpfile, lpitem, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LPSTR               lpitem;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;

    DPRINTF(("OleCreateLinkFromFile(%s,%s,%s,%s,%s)", lpprotocol, lpclass, lpfile, lpitem, lpobjname));

    retVal = DefCreateLinkFromFile (lpprotocol, lpclient,
                        lpclass, lpfile, lpitem,
                        lhclientdoc, lpobjname, lplpobj,
                        optRender, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}


/****************************************************************************
****************************************************************************/

void ReplaceFunctions(LPOLEOBJECT lpobj)
{
//    OBJINFO *poi;

    if (!CanReplace(lpobj))
        return;

    NewObj(lpobj);

    //
    // get the default handlers
    //
    if (vtblDef.Draw == NULL)           // only get the handlers once!
        vtblDef = *lpobj->lpvtbl;       // save default handlers

    //
    //  make the OLE object use our handlers
    //
    lpobj->lpvtbl = (LPOLEOBJECTVTBL)&vtblDll;

    //
    //  init our VTBL, ie replace any handlers we want to override.
    //  any handlers we dont replace we set the the default ones.
    //
    vtblDll = vtblDef;

////(FARPROC)vtblDll.QueryProtocol           = (FARPROC)DllQueryProtocol;
////(FARPROC)vtblDll.Release                 = (FARPROC)DllRelease;
////(FARPROC)vtblDll.Show                    = (FARPROC)DllShow;
////(FARPROC)vtblDll.DoVerb                  = (FARPROC)DllDoVerb;
////(FARPROC)vtblDll.GetData                 = (FARPROC)DllGetData;
////(FARPROC)vtblDll.SetData                 = (FARPROC)DllSetData;
////(FARPROC)vtblDll.SetTargetDevice         = (FARPROC)DllSetTargetDevice;
////(FARPROC)vtblDll.SetBounds               = (FARPROC)DllSetBounds;
////(FARPROC)vtblDll.EnumFormats             = (FARPROC)DllEnumFormats;
////(FARPROC)vtblDll.SetColorScheme          = (FARPROC)DllSetColorScheme;

    (FARPROC)vtblDll.Delete                  = (FARPROC)DllDelete;
////(FARPROC)vtblDll.SetHostNames            = (FARPROC)DllSetHostNames;
////(FARPROC)vtblDll.SaveToStream            = (FARPROC)DllSaveToStream;
    (FARPROC)vtblDll.Clone                   = (FARPROC)DllClone;
    (FARPROC)vtblDll.CopyFromLink            = (FARPROC)DllCopyFromLink;
////(FARPROC)vtblDll.Equal                   = (FARPROC)DllEqual;
////(FARPROC)vtblDll.CopyToClipboard         = (FARPROC)DllCopyToClipboard;
    (FARPROC)vtblDll.Draw                    = (FARPROC)DllDraw;
    (FARPROC)vtblDll.Activate                = (FARPROC)DllActivate;
////(FARPROC)vtblDll.Execute                 = (FARPROC)DllExecute;
////(FARPROC)vtblDll.Close                   = (FARPROC)DllClose;
////(FARPROC)vtblDll.Update                  = (FARPROC)DllUpdate;
////(FARPROC)vtblDll.Reconnect               = (FARPROC)DllReconnect;
    (FARPROC)vtblDll.ObjectConvert           = (FARPROC)DllObjectConvert;
////(FARPROC)vtblDll.GetLinkUpdateOptions    = (FARPROC)DllGetLinkUpdateOptions;
////(FARPROC)vtblDll.SetLinkUpdateOptions    = (FARPROC)DllSetLinkUpdateOptions;
////(FARPROC)vtblDll.Rename                  = (FARPROC)DllRename;
////(FARPROC)vtblDll.QueryName               = (FARPROC)DllQueryName;
////(FARPROC)vtblDll.QueryType               = (FARPROC)DllQueryType;
////(FARPROC)vtblDll.QueryBounds             = (FARPROC)DllQueryBounds;
////(FARPROC)vtblDll.QuerySize               = (FARPROC)DllQuerySize;
////(FARPROC)vtblDll.QueryOpen               = (FARPROC)DllQueryOpen;
////(FARPROC)vtblDll.QueryOutOfDate          = (FARPROC)DllQueryOutOfDate;
////(FARPROC)vtblDll.QueryReleaseStatus      = (FARPROC)DllQueryReleaseStatus;
////(FARPROC)vtblDll.QueryReleaseError       = (FARPROC)DllQueryReleaseError;
////(FARPROC)vtblDll.QueryReleaseMethod      = (FARPROC)DllQueryReleaseMethod;
////(FARPROC)vtblDll.RequestData             = (FARPROC)DllRequestData;
////(FARPROC)vtblDll.ObjectLong              = (FARPROC)DllObjectLong;
////(FARPROC)vtblDll.ChangeData              = (FARPROC)DllChangeData;
}

/****************************************************************************
****************************************************************************/

BOOL CanReplace(LPOLEOBJECT lpobj)
{
#if 0   // did not work anyway.
    //
    // we dont work on the wierd OLE shipped with PenWindows so don't load
    //
#ifndef WIN32
#pragma message("Disabling handler because we are on PenWindows...")
#endif //!WIN32
    if (GetSystemMetrics(SM_PENWINDOWS))
        return FALSE;
#endif

    return TRUE;
}

/****************************************************************************
****************************************************************************/

LPVOID GetData(LPOLEOBJECT lpobj, WORD cf)
{
    HANDLE h;

    if ( (*vtblDef.GetData)(lpobj, cf, &h) != OLE_OK || h == NULL)
        return NULL;

    return GlobalLock(h);
}

/****************************************************************************

these are the actual handlers.....

****************************************************************************/

/****************************************************************************
****************************************************************************/

LPVOID          FAR PASCAL _LOADDS DllQueryProtocol (
LPOLEOBJECT     lpobj,
LPSTR           lpsz)
{
    DPRINTF(("OleQueryProtocol(%ls)", lpsz));

    return vtblDef.QueryProtocol(lpobj, lpsz);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllRelease (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleRelease()"));

    return vtblDef.Release(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllShow (
LPOLEOBJECT     lpobj,
BOOL            fShow)
{
    DPRINTF(("OleShow(%d)", fShow));

    return vtblDef.Show(lpobj, fShow);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllDoVerb (
LPOLEOBJECT     lpobj,
UINT            verb,
BOOL            fShow,
BOOL            fActivate)
{
    DPRINTF(("OleDoVerb(%d, %d, %d)", verb, fShow, fActivate));

    return vtblDef.DoVerb(lpobj, verb, fShow, fActivate);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllGetData (
LPOLEOBJECT     lpobj,
OLECLIPFORMAT   cf,
LPHANDLE        lph)
{
    DPRINTF(("OleGetData(%d)", cf));

    return vtblDef.GetData(lpobj, cf, lph);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllSetData (
LPOLEOBJECT     lpobj,
OLECLIPFORMAT   cf,
HANDLE          h)
{
    DPRINTF(("OleSetData(%d, %d)", cf, h));

    return vtblDef.SetData(lpobj, cf, h);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllSetTargetDevice (
LPOLEOBJECT     lpobj,
HANDLE          h)
{
    DPRINTF(("OleSetTargetDevice()"));

    return vtblDef.SetTargetDevice(lpobj, h);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllSetBounds (
LPOLEOBJECT     lpobj,
LPRECT          lprc)
{
    DPRINTF(("OleSetBounds([%d,%d,%d,%d])", PUSHRC(lprc)));

    return vtblDef.SetBounds(lpobj, lprc);
}

/****************************************************************************
****************************************************************************/

OLECLIPFORMAT   FAR PASCAL _LOADDS DllEnumFormats (
LPOLEOBJECT     lpobj,
OLECLIPFORMAT   cf)
{
    DPRINTF(("OleEnumFormats(%d)", cf));

    return vtblDef.EnumFormats(lpobj, cf);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllSetColorScheme (
LPOLEOBJECT     lpobj,
LPLOGPALETTE    lppal)
{
    DPRINTF(("OleSetColorScheme()"));

    return vtblDef.SetColorScheme(lpobj, lppal);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllDelete (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleDelete(%lx)", lpobj));

    DelObj(lpobj);
    CleanObjects();

    return vtblDef.Delete(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllSetHostNames (
LPOLEOBJECT     lpobj,
LPSTR           szClientName,
LPSTR           szDocName)
{
    DPRINTF(("OleSetHostNames(%ls,%ls)", szClientName, szDocName));

    return vtblDef.SetHostNames(lpobj, szClientName, szDocName);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllSaveToStream (
LPOLEOBJECT     lpobj,
LPOLESTREAM     lpstream)
{
    DPRINTF(("OleSaveToStream()"));

    return vtblDef.SaveToStream(lpobj, lpstream);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllClone (
LPOLEOBJECT     lpobj,
LPOLECLIENT     lpClient,
LHCLIENTDOC     lhClientDoc,
LPSTR           szObjName,
LPOLEOBJECT FAR*lplpobj)
{
    OLESTATUS err;

    DPRINTF(("OleClone(%ls)", szObjName));

    err = vtblDef.Clone(lpobj, lpClient, lhClientDoc, szObjName, lplpobj);

    //
    // if the object cloned correctly then clone our object information
    //
    if (err <= OLE_WAIT_FOR_RELEASE)
    {
        OBJINFO *poi, *poiT;

        if ((poiT = FindObj(lpobj)) && (poi = NewObj(NULL)))
        {
            poi->lpobj      = *lplpobj;
            poi->hwnd       = poiT->hwnd;
            poi->rcActivate = poiT->rcActivate;
            poi->hwndDraw   = poiT->hwndDraw;
            poi->rcDraw     = poiT->rcDraw;
        }
    }

    return err;
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllCopyFromLink (
LPOLEOBJECT     lpobj,
LPOLECLIENT     lpClient,
LHCLIENTDOC     lhClientDoc,
LPSTR           szObjName,
LPOLEOBJECT FAR*lplpobj)
{
    OLESTATUS err;

    DPRINTF(("OleCopyFromLink(%ls)", szObjName));

    err = vtblDef.CopyFromLink(lpobj, lpClient, lhClientDoc, szObjName, lplpobj);

    if (err <= OLE_WAIT_FOR_RELEASE)
        NewObj(*lplpobj);

    return err;
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllEqual (
LPOLEOBJECT     lpobj1,
LPOLEOBJECT     lpobj2)
{
    DPRINTF(("OleEqual()"));

    return vtblDef.Equal(lpobj1, lpobj2);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllCopyToClipboard (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleCopyToClipboard()"));

    return vtblDef.CopyToClipboard(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllDraw (
LPOLEOBJECT     lpobj,
HDC             hdc,
LPRECT          lprcBounds,
LPRECT          lprcWBounds,
HDC             hdcFormat)
{
    OBJINFO *poi;
    RECT rc;

    DPRINTF(("OleDraw(%lx,[%d,%d,%d,%d], [%d,%d,%d,%d])", lpobj, PUSHRC(lprcBounds), PUSHRC(lprcWBounds)));

#ifdef DEBUG
    if (OleIsDcMeta(hdc))
        DPRINTF(("OleDraw: drawing to a meta-file"));
    else if (IsDcMemory(hdc))
        DPRINTF(("OleDraw: drawing to a bitmap"));
#endif

    if ((poi = FindObj(lpobj)) && !OleIsDcMeta(hdc) && !IsDcMemory(hdc))
    {
        //!!!get the window from the HDC!!!

        poi->hwndDraw = WindowFromDC(hdc);
        DPRINTF(("OleDraw: hwndDraw = %04X", poi->hwndDraw));

        if (lprcBounds && !IsRectEmpty(lprcBounds))
        {
            poi->rcDraw = *lprcBounds;

            //
            // convert the bound rectange into coordinates.
            // relative to hwndDraw
            //
            LPtoDP(hdc, (LPPOINT)&poi->rcDraw, 2);

            if (poi->hwndDraw == NULL)
            {
#ifdef WIN32
                POINT   pTemp;
                if (GetDCOrgEx(hdc, &pTemp)) {
                    OffsetRect(&poi->rcDraw, pTemp.x, pTemp.y);
                }
#else
                DWORD   dw;
                dw = GetDCOrg(hdc);
                OffsetRect(&poi->rcDraw, LOWORD(dw), HIWORD(dw));
#endif
            }
        }

        if (GetClipBox(hdc, &rc) == NULLREGION)
            return OLE_OK;
    }

    return vtblDef.Draw(lpobj, hdc, lprcBounds, lprcWBounds, hdcFormat);
}

/****************************************************************************

    scan WinWords stack and "extract" the info it should have passed to
    OleActivate() this has been tested with WinWord 2.0 and 2.0a.

    we expect future verisons of WinWord to pass the correct info to
    OleActivate() so we will never get here.

****************************************************************************/
#ifndef WIN32

BOOL NEAR PASCAL GetOpusRect(LPRECT lprcBound)
{
    LPRECT lprc;
    LPVOID lp;
    int i,dx,dy;

    //
    //  see if the current app is WinWord
    //
    if (!IsApp("WINWORD.EXE"))
        return FALSE;

    //
    //  lets scan the stack looking for a RECT, this is a total
    //  hack to get MSWORD to work.
    //
    _asm
    {
        mov     bx,ss:[bp]      ; get saved BP              DllActivate()
        and     bx, not 1
        mov     bx,ss:[bx]      ; get saved saved BP        OleActivate()
        and     bx, not 1
        mov     bx,ss:[bx]      ; get saved saved saved BP  "winword"
        and     bx, not 1

        mov     word ptr lp[0], bx
        mov     word ptr lp[2], ss
    }

#ifdef DEBUG
    DPRINTF(("****** SCANING WINWORDs STACK ********"));
    lprc = lp;

    for (i=0; i<1000; i++)
    {
        dx = lprc->right  - lprc->left;
        dy = lprc->bottom - lprc->top;

        if (dx >= 158 && dx <= 162 &&
            dy >= 118 && dy <= 122)
        {
            DPRINTF(("found a RECT at offset %d, [%d, %d, %d, %d]",
                (LPBYTE)lprc - (LPBYTE)lp, PUSHRC(lprc)));
        }

        ((LPBYTE)lprc)++;
    }
    DPRINTF(("**************************************"));
#endif

    lprc = (LPRECT)((LPBYTE)lp + 6);

    if (lprc->right - lprc->left > 0 && lprc->bottom - lprc->top > 0)
    {
        DPRINTF(("*** HACK FOR WINWORD, [%d, %d, %d, %d]", PUSHRC(lprc)));
        *lprcBound = *lprc;
        return TRUE;
    }

    return FALSE;
}

#endif //!WIN32


#ifdef WIN32
/*
** This is a pointer to the currently playing ole object.  It is only
** valid in the context of the client application.
**
*/
LPOLEOBJECT lpobjPlaying;
HWND hwndOleServer;


/*
** These are the process and thread ID's of the currently
** playing client application.  These variables have the value 0 in all
** other applications.
**
*/
DWORD dwProcessIDPlaying;
#endif



/****************************************************************************

  Note the use of a BOOL to pass an HWND in this fine piece of code...

****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllActivate (
LPOLEOBJECT     lpobj,
WORD            verb,
BOOL            fShow,
BOOL            fActivate,
HWND            hwnd,
LPRECT          lprcBound)
{
    OBJINFO *poi;
    RECT    rc;

    DPRINTF(("OleActivate(%lx, %d, %d, %d, %04X, [%d,%d,%d,%d])", lpobj, verb, fShow, fActivate, hwnd, PUSHRC(lprcBound)));

#ifdef WIN32
    lpobjPlaying = lpobj;
    dwProcessIDPlaying = GetCurrentProcessId();
#endif

    //
    //  hack for Write
    //
    if (IsWindow((HWND)(UINT_PTR)fActivate))
    {
        DPRINTF(("OleActivate: Write pre-realase work around"));
        hwnd = (HWND)(UINT_PTR)fActivate;
        fActivate = TRUE;
    }

    if (poi = FindObj(lpobj))
    {
        poi->hwnd = hwnd;

        if (poi->hwnd == NULL)
        {
            if (GetFocus())
            {
                DPRINTF(("OleActivate: no window specifed, using the focus window"));
                poi->hwnd = GetFocus();
            }
            else
            {
                DPRINTF(("OleActivate: no window specifed, using the active window"));
                poi->hwnd = GetActiveWindow();
            }
        }

        if (lprcBound && !IsRectEmpty(lprcBound))
        {
            poi->rcActivate = *lprcBound;
        }
#ifndef WIN32
        else
        {
            GetOpusRect(&poi->rcActivate);
        }
#endif //!WIN32

        //
        //  MS-Publisher gives use the *wrong* rectangle in the OleActivate call
        //  and never calls OleDraw() we are hosed!
        //
        //  so we check if the rect is off in space, and dont use it if so.
        //
        if (poi->hwnd)
        {
            GetClientRect(poi->hwnd, &rc);

            IntersectRect(&rc,&rc,&poi->rcActivate);

            if (IsRectEmpty(&rc))
            {
                DPRINTF(("OleActivate: rectangle specifed is not valid"));
                SetRectEmpty(&poi->rcActivate);
            }
        }

        if (IsRectEmpty(&poi->rcActivate))
        {
            DPRINTF(("OleActivate: stupid ole app!!!"));
        }

        //
        // Shove it in the registry
        //

        {
            RegSetGetData(poi, TRUE);
        }
    }

    return vtblDef.Activate(lpobj, verb, fShow, fActivate, hwnd, lprcBound);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllExecute (
LPOLEOBJECT     lpobj,
HANDLE          hCmds,
WORD            reserved)
{
    DPRINTF(("OleExecute(%ls)", GlobalLock(hCmds)));

    return vtblDef.Execute(lpobj, hCmds, reserved);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllClose (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleClose(%lx)", lpobj));

////DelObj(lpobj);

    return vtblDef.Close(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllUpdate (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleUpdate()"));

    return vtblDef.Update(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllReconnect (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleReconnect()"));

    return vtblDef.Reconnect(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllObjectConvert (
LPOLEOBJECT     lpobj,
LPSTR           szProtocol,
LPOLECLIENT     lpClient,
LHCLIENTDOC     lhClientDoc,
LPSTR           szObjName,
LPOLEOBJECT FAR*lplpobj)
{
    OLESTATUS err;

    DPRINTF(("OleObjectConvert(%ls,%ls)", szProtocol, szObjName));

    err = vtblDef.ObjectConvert(lpobj, szProtocol, lpClient, lhClientDoc, szObjName, lplpobj);

    if (err <= OLE_WAIT_FOR_RELEASE)
        NewObj(*lplpobj);

    return err;
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllGetLinkUpdateOptions (
LPOLEOBJECT     lpobj,
OLEOPT_UPDATE FAR *lpoleopt)
{
    DPRINTF(("OleGetLinkUpdateOptions()"));

    return vtblDef.GetLinkUpdateOptions(lpobj, lpoleopt);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllSetLinkUpdateOptions (
LPOLEOBJECT     lpobj,
OLEOPT_UPDATE   oleopt)
{
    DPRINTF(("OleSetLinkUpdateOptions()"));

    return vtblDef.SetLinkUpdateOptions(lpobj, oleopt);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllRename (
LPOLEOBJECT     lpobj,
LPSTR           szName)
{
    DPRINTF(("OleRename(%ls)", szName));

    return vtblDef.Rename(lpobj, szName);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllQueryName (
LPOLEOBJECT     lpobj,
LPSTR           szObjName,
UINT FAR *      lpwSize)
{
    DPRINTF(("OleQueryName(%ls)", szObjName));

    return vtblDef.QueryName(lpobj, szObjName, lpwSize);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllQueryType (
LPOLEOBJECT     lpobj,
LPLONG          lpType)
{
    DPRINTF(("OleQueryType()"));

    return vtblDef.QueryType(lpobj, lpType);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllQueryBounds (
LPOLEOBJECT     lpobj,
LPRECT          lprc)
{
    DPRINTF(("OleQueryBounds()"));

    return vtblDef.QueryBounds(lpobj, lprc);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllQuerySize (
LPOLEOBJECT     lpobj,
DWORD FAR *     lpdwSize)
{
    DPRINTF(("OleQuerySize()"));

    return vtblDef.QuerySize(lpobj, lpdwSize);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllQueryOpen (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleQueryOpen()"));

    return vtblDef.QueryOpen(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllQueryOutOfDate (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleQueryOutOfDate()"));

    return vtblDef.QueryOutOfDate(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllQueryReleaseStatus (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleQueryReleaseStatus()"));

    return vtblDef.QueryReleaseStatus(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllQueryReleaseError (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleQueryReleaseError()"));

    return vtblDef.QueryReleaseError(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllRequestData (
LPOLEOBJECT     lpobj,
OLECLIPFORMAT   cf)
{
    DPRINTF(("OleRequestData(%d)", cf));

    return vtblDef.RequestData(lpobj, cf);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllObjectLong (
LPOLEOBJECT     lpobj,
UINT            u,
LPLONG          lpl)
{
    DPRINTF(("OleObjectLong()"));

    return vtblDef.ObjectLong(lpobj, u, lpl);
}

/****************************************************************************
****************************************************************************/

OLE_RELEASE_METHOD  FAR PASCAL _LOADDS DllQueryReleaseMethod (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleQueryReleaseMethod()"));

    return vtblDef.QueryReleaseMethod(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _LOADDS DllChangeData (
LPOLEOBJECT     lpobj,
HANDLE          h,
LPOLECLIENT     lpClient,
BOOL            f)
{
    DPRINTF(("OleChangeData()"));

    return vtblDef.ChangeData(lpobj, h, lpClient, f);
}

///////////////////////////////////////////////////////////////////////////////
//
//  DEBUG STUFF
//
///////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG

#ifndef WIN32

void FAR cdecl dprintf(LPSTR szFormat, ...)
{
    char ach[128];
    va_list va;

    extern FAR PASCAL OutputDebugStr(LPSTR);

    lstrcpy(ach, "MCIOLE: ");
    va_start (va, szFormat);
    wvsprintf(ach + 8,szFormat,va);
    va_end (va);
    lstrcat(ach,"\r\n");

    OutputDebugString(ach);
}

#else  //!WIN32
/*
 *
 * In theory I need to include STDARGS and STDIO, but I don't get any warnings
 * That was because the debug output stuff was never enabled (DBG/DEBUG ...)
 *
 */
void FAR cdecl dprintf(LPSTR szFormat, ...)
{
    char ach[128];
    int  s;
    va_list va;

    if (oleDebugLevel == 0 ) {
        return;
    }

    va_start(va, szFormat);
    s = sprintf( ach, "MCIOLE32: (tid %x) ", GetCurrentThreadId() );
    s += vsprintf (ach+s,szFormat, va);
    va_end(va);

    ach[s++] = '\n';
    ach[s] = 0;

    OutputDebugString(ach);
}

#endif //WIN32
#endif


#ifdef WIN32

/*****************************************************************************\
**
**                  Stuff to support mouse HookProc
**
\*****************************************************************************/

#ifdef USE_MOUSE_HOOK
LRESULT CALLBACK MouseHook( int hc, WPARAM wParam, LPARAM lParam );
#else
LONG_PTR CALLBACK GetMessageHook( int hc, WPARAM wParam, LPARAM lParam );
#endif

BOOL InstallHook( HWND hwndServer, DWORD wow_thread_id );
BOOL RemoveHook( VOID );

/*
** hHookMouse is the handle to the hook proc.  This global is only
** valid in the context of the process that installed the hook (mplay32.exe).
** In all other address spaces this value is null.
**
*/
HHOOK hHookMouse = NULL;



/*****************************************************************************\
** InstallHook
**
** Called from mplay32.exe to install a global HookProc.  Returning
** TRUE means everything worked OK.  This should only be card from mplay32.
**
\*****************************************************************************/
BOOL InstallHook( HWND hwndServer, DWORD wow_thread_id )
{

    DPRINTF(( "Install hook to thread ID = %x", wow_thread_id ));
    if ( wow_thread_id ) {

        /*
        ** Get a pointer to file mapped shared memory.
        */
        lpvMem = MapViewOfFile( hMapObject, FILE_MAP_WRITE, 0, 0, 0 );
        if (lpvMem == NULL) {
            return FALSE;
        }

        lpvMem->hwndServer = hwndServer;
        lpvMem->wow_app_thread_id = wow_thread_id;

    }

    //
    // Set the thread id for WOW.  In principle this means that
    // we don't need to give WOW the thread id since the hook should
    // only run on this thread.
    //
    // For some reason specifying the thread helps give WOW enough
    // cycles to actually process the hook proc (if we don't specify it
    // we don't ever get in with a mouse click to cancel the play).
    //

#ifdef USE_MOUSE_HOOK

    hHookMouse = SetWindowsHookEx( WH_MOUSE, MouseHook,
                                   GetModuleHandle( "mciole32" ),
                                   wow_thread_id );

#else
    hHookMouse = SetWindowsHookEx( WH_GETMESSAGE, GetMessageHook,
                                   GetModuleHandle( "mciole32" ),
                                   wow_thread_id );
#endif

    DPRINTF(( "Mouse hook %s", hHookMouse ? "installed" : "failed" ));

    return hHookMouse != NULL;
}




/*****************************************************************************\
** RemoveHook
**
** Called from mplay32.exe to remove a global HookProc.  Returning TRUE
** means everything worked OK.
**
\*****************************************************************************/
BOOL RemoveHook( VOID )
{
    BOOL    fRemove;

    fRemove = UnhookWindowsHookEx( hHookMouse );
    DPRINTF(( "RemoveMouseHook %s", fRemove ? "removed" : "error" ));

    if (lpvMem != NULL) {

        DPRINTF(( "Thread ID = %x", lpvMem->wow_app_thread_id ));

        lpvMem->hwndServer = (HWND)NULL;
        lpvMem->wow_app_thread_id = 0L;
    }

    return fRemove;
}



#ifdef USE_MOUSE_HOOK
/*****************************************************************************\
** MouseHook
**
** Global mouse hook proc called whenever anything happens to the mouse.
**
\*****************************************************************************/
LRESULT CALLBACK MouseHook( int hc, WPARAM wParam, LPARAM lParam )
{

    LPMOUSEHOOKSTRUCT lpmh = (LPVOID)lParam;
    UINT    message = (UINT)wParam;

    if (hc == HC_ACTION) {

        /*
        ** Are we being called in the context of the client thats
        ** currently playing ?
        */

//      DPRINTF(( "Mouse hook called <%x>", message ));

        if ( dwProcessIDPlaying == GetCurrentProcessId() ) {


            /*
            ** If the left or right button is down always stop the
            ** play on place.
            */
            if ( message == WM_LBUTTONDOWN || message == WM_RBUTTONDOWN ) {

                DPRINTF(( "Stopping play in place" ));
                vtblDef.Close( lpobjPlaying );
            }

            /*
            ** If the Non-client left or right button is down AND the user
            ** is not clicking on the title bar (called a caption in Windows)
            ** stop the play in place.
            */
            else if ( message == WM_NCLBUTTONDOWN
                   || message == WM_NCRBUTTONDOWN ) {


                if ( lpmh->wHitTestCode != HTCAPTION ) {

                    DPRINTF(( "Stopping play in place" ));
                    vtblDef.Close( lpobjPlaying );
                }
            }
        }
    }

    /*
    ** Chain to the next hook proc.  The use of hHookMouse below is not an
    ** error, this code gets executed in the context many different
    ** processes.  The global hHookMouse is only valid on the process that
    ** installed the hook (mplay32.exe), otherwise it contains null.
    ** ScottLu tells me that this is correct behaviour for a global hook
    ** proc.
    */

    return CallNextHookEx( hHookMouse, hc, wParam, lParam );

}

#else
/*****************************************************************************\
** GetMessageHook
**
** Global GetMessageHook hook proc called whenever a message is removed from
** a message queue.
**
\*****************************************************************************/
LONG_PTR CALLBACK GetMessageHook( int hc, WPARAM wParam, LPARAM lParam )
{

    LPMSG   lpmh = (LPVOID)lParam;
    UINT    message = lpmh->message;

    if (hc == HC_ACTION) {

        /*
        ** Are we being called in the context of the client thats
        ** currently playing ?
        */
        if ( dwProcessIDPlaying == GetCurrentProcessId() ) {

            /*
            ** If the left or right button is down always stop the
            ** play on place.
            */
            if ( message == WM_LBUTTONDOWN || message == WM_RBUTTONDOWN ) {

                DPRINTF(( "Stopping play in place" ));
                vtblDef.Close( lpobjPlaying );
            }

            /*
            ** If the Non-client left or right button is down AND the user
            ** is not clicking on the title bar (called a caption in Windows)
            ** stop the play in place.
            */
            else if ( message == WM_NCLBUTTONDOWN
                   || message == WM_NCRBUTTONDOWN ) {

                if ( lpmh->wParam != (WPARAM)HTCAPTION ) {

                    DPRINTF(( "Stopping play in place" ));
                    vtblDef.Close( lpobjPlaying );
                }
            }
        }

        /*
        ** If we are running in WOW and the thread Ids match we have to
        ** stop the play in place by sending a private message to mplay32.exe
        */
        else if ( lpvMem != NULL && fRunningInWOW ) {

            if ( lpvMem->wow_app_thread_id == GetCurrentThreadId() ) {

                /*
                ** If the left or right button is down always stop the
                ** play on place.
                */
                if ( message == WM_LBUTTONDOWN || message == WM_RBUTTONDOWN ) {

                    DPRINTF(( "Stopping WOW play in place" ));
                    SendMessage( lpvMem->hwndServer, WM_USER+500, 0L, 0L );
                }

                /*
                ** If the Non-client left or right button is down AND the user
                ** is not clicking on the title bar (called a caption in Windows)
                ** stop the play in place.
                */
                else if ( message == WM_NCLBUTTONDOWN
                       || message == WM_NCRBUTTONDOWN ) {

                    if ( lpmh->wParam != (WPARAM)HTCAPTION ) {

                        DPRINTF(( "Stopping WOW play in place" ));
                        SendMessage( lpvMem->hwndServer, WM_USER+500, 0L, 0L );

                    }
                }
            }
        }
    }

    /*
    ** Chain to the next hook proc.  The use of hHookMouse below is not an
    ** error, this code gets executed in the context many different
    ** processes.  The global hHookMouse is only valid on the process that
    ** installed the hook (mplay32.exe), otherwise it contains null.
    ** ScottLu tells me that this is correct behaviour for a global hook
    ** proc.
    */

    return CallNextHookEx( hHookMouse, hc, wParam, lParam );

}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciseq\list.h ===
// Copyright (c) 1992 Microsoft Corporation
/* list.h */

#define MAXLISTS 500
                 // this means that total of all seqs and tracks <= 500 
                    
#define NULLLIST        ((DWORD)-1)

typedef DWORD           ListHandle;

typedef struct Node
{
    struct Node *next;  // ptr to next element in list
    HLOCAL  handle;     // handle to self
    BYTE    data[];     // where the data goes
} Node;

// below:  size of stuff preceeding data in "Node" structure (for mem alloc)
#define  NODEHDRSIZE sizeof(Node)

typedef struct  l
{
    DWORD   nodeSize;
    BOOL    fLocked;
    Node    *firstNode;
} List;

PUBLIC ListHandle FAR PASCAL List_Create(DWORD nodeSize, DWORD flags);
PUBLIC NPSTR FAR PASCAL List_Allocate(ListHandle lh);
PUBLIC void FAR PASCAL List_Deallocate(ListHandle lh, NPSTR node);
PUBLIC VOID FAR PASCAL List_Destroy(ListHandle lh);
PUBLIC VOID FAR PASCAL List_Attach_Tail(ListHandle lh, NPSTR node);
PUBLIC NPSTR FAR PASCAL List_Get_First(ListHandle lh);
PUBLIC NPSTR FAR PASCAL List_Get_Next(ListHandle lh, VOID* node);


#ifdef DEBUG

PUBLIC VOID FAR PASCAL List_Lock(ListHandle lh);
PUBLIC VOID FAR PASCAL List_Unlock(ListHandle lh);

#else

#define List_Lock(lh)
#define List_Unlock(lh)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciseq\mciseq.c ===
/******************************************************************************

   Copyright (c) 1985-1999 Microsoft Corporation

   Title:   mciseq.c - Multimedia Systems Media Control Interface
            Sequencer driver for MIDI files.

   Version: 1.00

   Date:    24-Apr-1992

   Author:  Greg Simons

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   ----- -----------------------------------------------------------
   24-APR-1990   GregSi Original
   1 -OCT-1990   GregSi Merge with MMSEQ
   10-MAR-1992   RobinSp Move to Windows NT

*****************************************************************************/
#define UNICODE
//MMSYSTEM
#define MMNOSOUND        - Sound support
#define MMNOWAVE         - Waveform support
#define MMNOAUX          - Auxiliary output support
#define MMNOJOY          - Joystick support

//MMDDK
#define NOWAVEDEV         - Waveform support
#define NOAUXDEV          - Auxiliary output support
#define NOJOYDEV          - Joystick support


#include <stdlib.h>
#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <string.h>
#include <wchar.h>
#include "mmsys.h"
#include "list.h"
#include "mciseq.h"

#define CONFIG_ID   0xFFFFFFFF  // Use this value to identify config. opens

#define GETMOTDWORD(lpd)        ((((DWORD)GETMOTWORD(lpd)) << (8 * sizeof(WORD))) + GETMOTWORD((LPBYTE)(lpd) + sizeof(WORD)))
#define ASYNCMESSAGE(w)         (((w) == MCI_PLAY) || ((w) == MCI_SEEK))

/***************************************************************************
 *
 *                         Globals
 *
 **************************************************************************/

ListHandle      SeqStreamListHandle;
HINSTANCE       hInstance;
UINT            MINPERIOD;              // Minimum timer period supported.

int MIDIConfig (HWND hwndParent);

/***************************************************************************
 *
 * @doc INTERNAL MCISEQ
 *
 * @api DWORD | mciDriverEntry | Single entry point for MCI drivers
 *
 * @parm MCIDEVICEID | wDeviceID | The MCI device ID
 *
 * @parm UINT | wMessage | The requested action to be performed.
 *
 * @parm DWORD | dwParam1 | Data for this message.  Defined seperately for
 * each message
 *
 * @parm DWORD | dwParam2 | Data for this message.  Defined seperately for
 * each message
 *
 * @rdesc Defined separately for each message.
 *
 * @comm This may not be called at interrupt time.
 *
 ***************************************************************************/
PUBLIC DWORD FAR PASCAL mciDriverEntry (MCIDEVICEID wDeviceID, UINT wMessage,
                                 DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
    pSeqStreamType   pStream;
    DWORD       dwError;

    // get the sequence stream handle for the given ID
    pStream = (pSeqStreamType) mciGetDriverData (wDeviceID);

    // (unless it's irrelevent to the command)
    if (!pStream &&
       (!((wMessage == MCI_OPEN_DRIVER) || (wMessage == MCI_GETDEVCAPS) ||
       (wMessage == MCI_INFO) || (wMessage == MCI_CLOSE_DRIVER))))
       return MCIERR_UNSUPPORTED_FUNCTION;

    switch (wMessage)
    {
        case MCI_OPEN_DRIVER:
            dwError = msOpen(&pStream, wDeviceID, (DWORD)dwParam1, (LPMCI_OPEN_PARMS)dwParam2);
            break;

        case MCI_CLOSE_DRIVER: // close file
            dwError = msClose(pStream, wDeviceID, (DWORD)dwParam1);
            pStream = NULL;
            break;

        case MCI_PLAY:  // play a file (pass thru to sequencer)
            dwError = msPlay(pStream, wDeviceID, (DWORD)dwParam1, (LPMCI_PLAY_PARMS)dwParam2);
            break;

        case MCI_PAUSE:
        case MCI_STOP:
            if (wMessage == MCI_PAUSE) // remember pause status for "mci_mode"
                pStream->bLastPaused = TRUE;
            else
                pStream->bLastPaused = FALSE;
            if (!(dwError = (DWORD)midiSeqMessage(pStream->hSeq, SEQ_STOP, 0L, 0L)))
                midiSeqMessage(pStream->hSeq, SEQ_SETPORTOFF, TRUE, 0L);
            break;

        case MCI_SEEK:  // pass thru as song ptr
            pStream->bLastPaused = FALSE;
            dwError = msSeek(pStream, wDeviceID, (DWORD)dwParam1, (LPMCI_SEEK_PARMS)dwParam2);
            break;

        case MCI_STATUS:
            dwError = msStatus(pStream, wDeviceID, (DWORD)dwParam1, (LPMCI_STATUS_PARMS)dwParam2);
            break;

        case MCI_GETDEVCAPS:
            dwError = msGetDevCaps(pStream, wDeviceID, (DWORD)dwParam1, (LPMCI_GETDEVCAPS_PARMS)dwParam2);
            break;

        case MCI_INFO: // TBD:  use resource for string
            dwError = msInfo(pStream, wDeviceID, (DWORD)dwParam1, (LPMCI_INFO_PARMS)dwParam2);
            break;

        case MCI_SET:
            dwError = msSet(pStream, wDeviceID, (DWORD)dwParam1, (LPMCI_SEQ_SET_PARMS)dwParam2);
            break;

        case MCI_STEP:
        case MCI_RECORD:
        case MCI_SAVE:
        case MCI_CUE:
        case MCI_REALIZE:
        case MCI_WINDOW:
        case MCI_PUT:
        case MCI_WHERE:
        case MCI_FREEZE:
        case MCI_UNFREEZE:
        case MCI_LOAD:
        case MCI_CUT:
        case MCI_COPY:
        case MCI_PASTE:
        case MCI_UPDATE:
        case MCI_DELETE:
        case MCI_RESUME:
            return MCIERR_UNSUPPORTED_FUNCTION;

        default:
        //case MCI_SOUND:   This is obsolete and has been removed from the public headers
            return MCIERR_UNRECOGNIZED_COMMAND;

    } // switch


    // NOTIFY HANDLED HERE
    if (!LOWORD(dwError))
    {
        MIDISEQINFO seqInfo;
        DWORD       dwTo;

        // first derive info crucial for play abort
        if (wMessage == MCI_PLAY)
        {
            // get info to aid in possible time format conversions (from & to)
            midiSeqMessage((HMIDISEQ) pStream->hSeq,
                SEQ_GETINFO, (DWORD_PTR)(LPMIDISEQINFO) &seqInfo, 0L);
            if (dwParam1 & MCI_TO)
            {
                // is the user typing in what he believes to be the end?
                if (((LPMCI_PLAY_PARMS)dwParam2)->dwTo == CnvtTimeFromSeq(pStream, seqInfo.dwLength, &seqInfo))
                    dwTo = seqInfo.dwLength; // if so, let him have it
                else
                    dwTo = CnvtTimeToSeq(pStream,   // else straight cnvt
                        ((LPMCI_PLAY_PARMS)dwParam2)->dwTo, &seqInfo);
            }
            else
                dwTo = seqInfo.dwLength; // already in native format
        }

        if (pStream) {
            // HANDLE ABORT/SUPERSEDE OF ANY OUTSTANDING DELAYED NOTIFY
            if (pStream->hNotifyCB)
            {
                if (bMutex(wMessage, pStream->wNotifyMsg,
                  (DWORD)dwParam1 /*flags*/, dwTo, pStream->dwNotifyOldTo))
                      // if msg cancels old notify (regardless of whether
                      // it notifies) abort pending notify
                    Notify(pStream, MCI_NOTIFY_ABORTED);
                else if (dwParam1 & MCI_NOTIFY)  // else if this one notifies,
                                                // that supersedes old one
                    Notify(pStream, MCI_NOTIFY_SUPERSEDED);
            }
            // HANDLE THIS MESSAGE'S NOTIFY
            if (dwParam1 & MCI_NOTIFY)
            {
                // HANDLE THIS NOTIFY
                PrepareForNotify(pStream, wMessage,
                    (LPMCI_GENERIC_PARMS) dwParam2, dwTo);

                if (!ASYNCMESSAGE(wMessage) || ((wMessage == MCI_PLAY) && (seqInfo.dwCurrentTick == dwTo)))
                    Notify(pStream, MCI_NOTIFY_SUCCESSFUL);
            }
        } else if (dwParam1 & MCI_NOTIFY)
            mciDriverNotify((HWND)((LPMCI_GENERIC_PARMS)dwParam2)->dwCallback, wDeviceID, MCI_NOTIFY_SUCCESSFUL);
    }
    return dwError;
}

/****************************************************************************
 *
 *                Helper Functions
 *
 ***************************************************************************/

PRIVATE BOOL NEAR PASCAL bMutex(UINT wNewMsg, UINT wOldMsg, DWORD wNewFlags,
    DWORD dwNewTo, DWORD dwOldTo)
{
    switch (wOldMsg)
    {
        case MCI_PLAY:
            switch (wNewMsg)
            {
                case MCI_STOP:
                case MCI_PAUSE:
                case MCI_SEEK:
                case MCI_CLOSE_DRIVER:
                    return TRUE;

                case MCI_PLAY:
                    if ((wNewFlags & MCI_FROM) || (dwNewTo != dwOldTo))
                        return TRUE;
                    else
                        return FALSE;

                default:
                    return FALSE;
            }
            break;
        case MCI_SEEK:
            switch (wNewMsg)
            {
                case MCI_CLOSE_DRIVER:
                case MCI_SEEK:
                    return TRUE;

                case MCI_PLAY:
                    if (wNewFlags & MCI_FROM)
                        return TRUE;
                    else
                        return FALSE;

                default:
                    return FALSE;
            }
            break;

            default:   // should never get here
                return FALSE;
    }
}

/***************************************************************************/

PUBLIC VOID FAR PASCAL PrepareForNotify(pSeqStreamType pStream,
    UINT wMessage, LPMCI_GENERIC_PARMS lpParms, DWORD dwTo)
/*  This function's purpose is to setup for notify in cases where
 *  an asynchronous message is about to be sent to the sequencer --
 *  e.g.  before a 'play,' where the sequencer must call back to tell you
 *  it's done (then you, in turn, call back the client).
 *  This funtion sets up the MCISEQ -> CLIENT interface.
 */
{
    // remember this notify's dwCallback, and message
    //   which notify was for
        //mci client's notify callback handle
    pStream->hNotifyCB = (HWND)lpParms->dwCallback;
    pStream->wNotifyMsg = wMessage; // remember for possible supersed/abort

    pStream->dwNotifyOldTo = dwTo; // save to position for possible
                                   // subsequent abort/supersede
}

/****************************************************************************/

PUBLIC VOID NEAR PASCAL EndStreamCycle(SeqStreamType* seqStream)
{
    // signal on all tracks' buffers
    // as a result, the Stream Cycle process will finish (i.e. die)
    // account for cases where stream or part of it wasn't allocated
    TrackStreamType* trackStream;
    int i;

    if (!seqStream)
        return;

    seqStream->streaming = FALSE; // first let it exit

    if (seqStream->trackStreamListHandle == NULLLIST)
        return;

    // now signal on all to let it escape
    trackStream = (TrackStreamType*) List_Get_First(seqStream->trackStreamListHandle);
    while(trackStream)
    {
        for(i = 0; i < NUMHDRS; i++) // signal on all buffers
        {
            if (seqStream->streamTaskHandle)
            {
                dprintf2(("about to signal in EndStreamCycle"));
                if (seqStream->streamTaskHandle) {
                    TaskSignal(seqStream->streamTaskHandle, WTM_QUITTASK);

#ifdef WIN32
                    TaskWaitComplete(seqStream->streamThreadHandle);
#else
                    Yield();
#endif // WIN32
                }
            }
            else
                break;
        }
        trackStream = (TrackStreamType*) List_Get_Next(seqStream->trackStreamListHandle, trackStream);
    }
}

/****************************************************************************/

PUBLIC DWORD NEAR PASCAL EndFileStream(pSeqStreamType pStream)
/* Closes the file and frees all stream memory.  Handles cases where
   allocation failed part way through. */
{
    if (!pStream)
        return 0;
    EndStreamCycle(pStream);
    if (pStream->hSeq)
        midiSeqMessage(pStream->hSeq, SEQ_CLOSE, 0L, 0L); //directly close it

    if (pStream->trackStreamListHandle != NULLLIST)
    {
        TrackStreamType *trackStream;

        trackStream = (TrackStreamType*) List_Get_First(pStream->trackStreamListHandle);
        while (trackStream)
        {
            int i;

            for(i = 0; i < NUMHDRS; i++)    // unlock two midihdr buffers for it
            {
                if (trackStream->fileHeaders[i])
                {
#ifdef WIN16
                    GlobalFreePtr(trackStream->fileHeaders[i]);
#else
                    GlobalFree(trackStream->fileHeaders[i]);
#endif
                }
                else
                    break;
            }
            trackStream = (TrackStreamType*) List_Get_Next(pStream->trackStreamListHandle, trackStream);
        }
        List_Destroy(pStream->trackStreamListHandle);
    }
    List_Deallocate(SeqStreamListHandle, (NPSTR) pStream);

    return 0;
}

/*****************************************************************************/
PRIVATE void PASCAL NEAR InitMMIOOpen(LPMMIOPROC pIOProc, LPMMIOINFO lpmmioInfo)
{
    _fmemset(lpmmioInfo, 0, sizeof(MMIOINFO));
    if (pIOProc)
        lpmmioInfo->pIOProc = pIOProc;
    else
        lpmmioInfo->fccIOProc = FOURCC_DOS;
}

/*****************************************************************************/
PRIVATE HMMIO NEAR PASCAL msOpenFile(LPWSTR szName, LPMMCKINFO lpmmckData, LPMMIOPROC pIOProc)
     /* Returns hmmio.  This value will be null if failure.
        Reads both RIFF and dos midifiles.
        Sets the current file position to the start of MIDI data. */
{
#define RMIDFORMTYPE            mmioFOURCC('R', 'M', 'I', 'D')
#define DATACKID                mmioFOURCC('d', 'a', 't', 'a')

    MMIOINFO    mmioInfo;
    HMMIO       hmmio;
    MMCKINFO    mmckRiff;

    InitMMIOOpen(pIOProc, &mmioInfo);
    hmmio = mmioOpen(szName, &mmioInfo, MMIO_READ | MMIO_DENYWRITE);
    if (hmmio == NULL)
        return NULL;
    mmckRiff.fccType = RMIDFORMTYPE;
    lpmmckData->ckid = DATACKID;
    if (mmioDescend(hmmio, &mmckRiff, NULL, MMIO_FINDRIFF) || mmioDescend(hmmio, lpmmckData, &mmckRiff, MMIO_FINDCHUNK))
    {
        lpmmckData->cksize = mmioSeek(hmmio, 0, SEEK_END);
        lpmmckData->fccType = 0;
        lpmmckData->dwDataOffset = 0;
        lpmmckData->dwFlags = 0;
        mmioSeek(hmmio, 0, SEEK_SET);
    }
    return hmmio;
}

/*****************************************************************************/

PUBLIC DWORD NEAR PASCAL msOpenStream(pSeqStreamType FAR * lppStream, LPCWSTR szName, LPMMIOPROC pIOProc)
    /* opens file, sets up streaming variables and buffers, calls routine
    to load them and send them to the sequencer.  Returns stream handle in
    pStream var pointed to by lppStream.  Returns error code */

{
#define MAXHDRSIZE  0x100
#define MThd            mmioFOURCC('M', 'T', 'h', 'd')
#define MTrk            mmioFOURCC('M', 'T', 'r', 'k')

    UINT        wTracks;
    UINT        wFormat;
    HMMIO       hmmio;
    SeqStreamType   *thisSeqStream = NULL;
    TrackStreamType *thisTrackStream;
    BYTE        fileHeader[MAXHDRSIZE];
    int         iTrackNum;
    DWORD       smErrCode, errCode;
    MIDISEQOPENDESC open;
    MMCKINFO    mmckData;
    MMCKINFO    mmck;
    MMIOINFO    mmioInfo;
    WCHAR       szPathName[128];

    wcsncpy(szPathName, szName, (sizeof(szPathName)/sizeof(WCHAR)) - 1);
    InitMMIOOpen(pIOProc, &mmioInfo);
    if (!mmioOpen(szPathName, &mmioInfo, MMIO_PARSE)) {
        hmmio = NULL;
        errCode = MCIERR_FILE_NOT_FOUND;
        goto ERROR_HDLR;
    }

    // check if it's a RIFF file or not -- if so, descend into RMID chunk
    // if not, just open it and assume that it's a MIDI file

    hmmio = msOpenFile(szPathName, &mmckData, pIOProc);
    if (!hmmio)   // open the MIDI file
    {
        errCode = MCIERR_FILE_NOT_FOUND;
        goto ERROR_HDLR;
    }
    mmck.ckid = MThd;
    if (mmioDescend(hmmio, &mmck, &mmckData, MMIO_FINDCHUNK))
    {
        errCode = MCIERR_INVALID_FILE;
        goto ERROR_HDLR;
    }
    mmck.cksize = GETMOTDWORD(&mmck.cksize);
    if (mmck.cksize < 3 * sizeof(WORD))
    {
        errCode = MCIERR_INVALID_FILE;
        goto ERROR_HDLR;
    }

    // allocate sequence stream structure & its track stream list
    if (! (thisSeqStream = (SeqStreamType*) List_Allocate(SeqStreamListHandle)))
    {
        errCode = MCIERR_OUT_OF_MEMORY;
        goto ERROR_HDLR;
    }
    List_Attach_Tail(SeqStreamListHandle, (NPSTR) thisSeqStream);

    thisSeqStream->trackStreamListHandle = NULLLIST;

    thisSeqStream->hmmio = hmmio;
    thisSeqStream->pIOProc = pIOProc;
    lstrcpy(thisSeqStream->szFilename, szPathName);
    Yield();
    thisSeqStream->dwFileLength = mmckData.cksize;
    open.dwLen = min(mmck.cksize, MAXHDRSIZE);
    mmioRead(hmmio, (HPSTR)fileHeader, open.dwLen); // read the header info now
    wFormat = GETMOTWORD(fileHeader);
    wTracks = GETMOTWORD(fileHeader + sizeof(WORD));
    if (((wFormat == 0) && (wTracks > 1)) ||  // illegal format 0
        (wFormat > 1))                        // illegal format
    {
        errCode = MCIERR_INVALID_FILE;
        goto ERROR_HDLR;
    }

    thisSeqStream->wPortNum = MIDI_MAPPER;

    /*  Create a sequence given the header data (will add stream as param) */

    open.lpMIDIFileHdr = (LPBYTE) fileHeader;  // step over mhdr+len
    open.dwCallback = (DWORD_PTR) mciSeqCallback;
    open.dwInstance = (DWORD_PTR) thisSeqStream;
    open.hStream = (HANDLE)thisSeqStream;

    smErrCode = (DWORD)midiSeqMessage(NULL,           // open sequence
                          SEQ_OPEN,
                          (DWORD_PTR)(LPVOID)&open,
                          (DWORD_PTR)(LPVOID)&(thisSeqStream->hSeq));

    if (smErrCode != MIDISEQERR_NOERROR)
    {
        // N.B.  at this point if failed in sequencer, sequence is invalid
        //  thisSeqStream->hSeq should be NULL
        if (smErrCode == MIDISEQERR_NOMEM)
            errCode = MCIERR_OUT_OF_MEMORY;
        else
            errCode = MCIERR_INVALID_FILE;
        goto ERROR_HDLR;
    }

    thisSeqStream->trackStreamListHandle = List_Create((LONG) sizeof(TrackStreamType),0l);
    if (thisSeqStream->trackStreamListHandle == NULLLIST)
    {
        errCode = MCIERR_OUT_OF_MEMORY; // not a memory problem
        goto ERROR_HDLR;
    }

    mmioAscend(hmmio, &mmck, 0);
    // MIDI track data does not have RIFF even byte restriction
    if (mmck.cksize & 1L)
        mmioSeek(hmmio, -1L, SEEK_CUR);
    mmck.ckid = MTrk;
    iTrackNum = 0;
    while (wTracks-- > 0)
    {
        int         i;

        // allocate trackstream record and put it in list
        if (! (thisTrackStream = (TrackStreamType*)
          List_Allocate(thisSeqStream->trackStreamListHandle)))
        {
            errCode = MCIERR_OUT_OF_MEMORY;
            goto ERROR_HDLR;
        }
        List_Attach_Tail(thisSeqStream->trackStreamListHandle,
             (NPSTR) thisTrackStream);

        for(i = 0; i < NUMHDRS; i++)    // alloc and lock two midihdr buffers for it
        {
           if (! (thisTrackStream->fileHeaders[i] = (LPMIDISEQHDR)
#ifdef WIN16
             GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, (LONG) (sizeof(MIDISEQHDR) + BUFFSIZE))))
#else
             GlobalAlloc(GPTR, (LONG) (sizeof(MIDISEQHDR) + BUFFSIZE))))
#endif // WIN16
                {
                    errCode = MCIERR_OUT_OF_MEMORY;
                    goto ERROR_HDLR;
                }
           thisTrackStream->fileHeaders[i]->lpData =
                (LPSTR) (((DWORD_PTR) thisTrackStream->fileHeaders[i]) +
                sizeof(MIDISEQHDR));

           thisTrackStream->fileHeaders[i]->wTrack = (WORD)iTrackNum;
           thisTrackStream->fileHeaders[i]->lpNext = NULL;
           thisTrackStream->fileHeaders[i]->wFlags = MIDISEQHDR_DONE;
        };

        Yield();
        // set up to read this track's 'Mtrk' & length
        if (mmioDescend(hmmio, &mmck, &mmckData, MMIO_FINDCHUNK))
        {
            errCode = MCIERR_INVALID_FILE;
            goto ERROR_HDLR;
        }
        mmck.cksize = GETMOTDWORD(&mmck.cksize);

        // set up beginning, current, and end
        thisTrackStream->beginning = mmck.dwDataOffset;
        thisTrackStream->current = thisTrackStream->beginning;
        thisTrackStream->end = thisTrackStream->beginning + mmck.cksize - 1;

        // minimum track length is 3 bytes

        // verify track ends with "End Of Track" meta event
        mmioSeek(hmmio, (LONG)thisTrackStream->end - 2, SEEK_SET);
        mmioRead(hmmio, (HPSTR)fileHeader, 3L);  // read EOT
        if ((fileHeader[0] != 0xFF) || (fileHeader[1] != 0x2F) ||
            (fileHeader[2] != 0x00))
        {
            errCode = MCIERR_INVALID_FILE;
            goto ERROR_HDLR;
        }
        mmioAscend(hmmio, &mmck, 0);
        // MIDI track data does not have RIFF even byte restriction
        if (mmck.cksize & 1L)
            mmioSeek(hmmio, -1L, SEEK_CUR);
        iTrackNum++;
    }
    mmioClose(hmmio, 0); // don't need in this task context any longer
    hmmio = NULL;
    // create cycle task
    thisSeqStream->streaming = TRUE;
    thisSeqStream->streamTaskHandle = 0; // don't know it yet
    if (mmTaskCreate(mciStreamCycle, &thisSeqStream->streamThreadHandle,
                     (DWORD_PTR)thisSeqStream))
      //mmTaskCreate returns 0 if successful
    {
        errCode = MCIERR_OUT_OF_MEMORY;
        goto ERROR_HDLR;
    }
    thisSeqStream->bLastPaused = FALSE; // never paused
    thisSeqStream->hNotifyCB = NULL;  // no notify pending
    *lppStream = thisSeqStream;
    return 0;

ERROR_HDLR:
    if (hmmio)                    // close file if it was opened
        mmioClose(hmmio, 0);
    if (thisSeqStream)
    {
        midiSeqMessage((HMIDISEQ) thisSeqStream->hSeq, SEQ_SETPORTOFF, FALSE, 0L);
        EndFileStream(thisSeqStream); //dealloc it and everything it owns
    }
    return errCode;
}

/***************************************************************************/

PUBLIC VOID FAR PASCAL StreamTrackReset(pSeqStreamType pStream, UINT wTrackNum)
/* Find track stream struct within pStream as specified by wTrackNum & reset
   it to start over. */
{
    TrackStreamType *trackStream;
    int iTrackNum;

    if (pStream->trackStreamListHandle == NULLLIST)
        return;

    trackStream = (TrackStreamType*) List_Get_First(pStream->trackStreamListHandle);
    iTrackNum = 0;
    while ((trackStream) && ((int)wTrackNum != iTrackNum++))
    {
        trackStream = (TrackStreamType*) List_Get_Next(pStream->trackStreamListHandle, trackStream);
    }

    if (trackStream)
    {
        int i;

        trackStream->current = trackStream->beginning; // reset stream

        // now signal on all buffers that have been blocked on
        //    (have done bit set)
        for(i = 0; i < NUMHDRS; i++)  // fill any of these that're MT
            if (!(trackStream->fileHeaders[i]->wFlags & MIDISEQHDR_DONE))
            {
                trackStream->fileHeaders[i]->wFlags |= MIDISEQHDR_DONE; //set it
                TaskSignal(pStream->streamTaskHandle, WTM_FILLBUFFER);
            }
    }
}

/***************************************************************************/

PUBLIC VOID FAR PASCAL _LOADDS mciStreamCycle(DWORD_PTR dwInst)
/*  Fills any buffers for this track that are empty.  Rule:  at any time, the
    block count = the number of buffers - number of buffers with done bit clr
    (i.e. sent) - 1.  Note that this will normally be -1 (asleep).  When a
    buffer is freed, the done bit is set and we signal (block count++).

    Important:  when a buffer is available, but we've run out of data to send
    on that track, we clr the done bit and block anyway (otherwise we wouldn't
    go back to sleep properly).  The only thing is that we must properly regain
    our original status if the sequence is ever reset.  This is accomplished by
    signaling on every buffer with its done bit cleared.   (This is like
    signaling on every buffer that's been sent but not returned + any buffers
    ignored becuase there was no data to send on their track.)

    Whenever we signal for a buffer, we must be SURE that its done bit is set
    -- this is to maintain our rule above.  Otherwise it will break badly! */
{
    TrackStreamType *trackStream;
    SeqStreamType   *seqStream = (SeqStreamType*)dwInst;
    MMCKINFO        mmckData;
    HMMIO           hmmio;

    EnterSeq();

    /*
    ** Make a safe "user" call so that user knows about our thread.
    */
    GetDesktopWindow();

    if (!seqStream->streamTaskHandle) {
        seqStream->streamTaskHandle = mmGetCurrentTask(); // fill it in asap
    }


    hmmio = msOpenFile(seqStream->szFilename, &mmckData, seqStream->pIOProc);   // open the MIDI file
    seqStream->hmmio = hmmio;

    // block count = 0
    // first signal on all

    trackStream = (TrackStreamType*) List_Get_First(seqStream->trackStreamListHandle);
    while(trackStream)
    {
        int    i;

        for(i = 0; i < NUMHDRS; i++)  // fill any of these that're MT
        {
            trackStream->fileHeaders[i]->wFlags |= MIDISEQHDR_DONE;  //set it
            TaskSignal(seqStream->streamTaskHandle, WTM_FILLBUFFER);
        }
        trackStream = (TrackStreamType*) List_Get_Next(seqStream->trackStreamListHandle, trackStream);
    }

    // block count = number of buffers
    TaskBlock();
    // block count == number of buffers - 1

    do
    {
        trackStream = (TrackStreamType*) List_Get_First(seqStream->trackStreamListHandle);
        while ((trackStream) && (seqStream->streaming))
        {
           int    i;

           for(i = 0; i < NUMHDRS; i++)  // fill any of these that're MT
            {
                /* if the header isn't being used, fill it and send it to
                   the sequencer */
                if ((trackStream->fileHeaders[i]->wFlags & MIDISEQHDR_DONE) &&
                   (seqStream->streaming))
                {
                    int    iDataToRead;

                    mmioSeek(seqStream->hmmio, (LONG) trackStream->current, SEEK_SET);
                    iDataToRead = (int) min((DWORD) BUFFSIZE,
                         (trackStream->end - trackStream->current) + 1);

                    trackStream->fileHeaders[i]->wFlags &=
                        ~(MIDISEQHDR_DONE + MIDISEQHDR_EOT + MIDISEQHDR_BOT);
                         // clr the done beginning and end regardless

                    if (iDataToRead > 0)
                    {
                      if (trackStream->current == trackStream->beginning)
                          trackStream->fileHeaders[i]->wFlags |=
                              MIDISEQHDR_BOT; // set the beginning of track flag
                      mmioRead(seqStream->hmmio,
                          (HPSTR) trackStream->fileHeaders[i]->lpData, iDataToRead);

                      trackStream->fileHeaders[i]->dwLength = iDataToRead;
                      trackStream->current += iDataToRead;
                      trackStream->fileHeaders[i]->reserved =
                          ((trackStream->current - trackStream->beginning) - 1);
                      if (trackStream->current > trackStream->end)
                          trackStream->fileHeaders[i]->wFlags |=
                              MIDISEQHDR_EOT; // set the end of track flag

                      if (seqStream->streaming)
                          midiSeqMessage((HMIDISEQ) seqStream->hSeq, SEQ_TRACKDATA,
                            (DWORD_PTR) trackStream->fileHeaders[i], 0L); // send it
                    } // if data to read
                    while (seqStream->streaming) {
                        MIDISEQINFO seqInfo;

                        switch (TaskBlock()) {
                        case WTM_DONEPLAY:
                                midiSeqMessage((HMIDISEQ)seqStream->hSeq, SEQ_GETINFO, (DWORD_PTR)(LPMIDISEQINFO)&seqInfo, 0L);
                                if (!seqInfo.bPlaying)
                                        midiSeqMessage((HMIDISEQ)seqStream->hSeq, SEQ_SETPORTOFF, FALSE, 0L);
                                continue;
                        case WTM_QUITTASK:
                        case WTM_FILLBUFFER:
                                break;
                        }
                        break;
                    }
                    //BLOCK even if data wasn't available (buffer still "used")
                    // when all buffers have been blocked, we'll sleep here
                    if (seqStream->streaming)
                        // don't yield to close, 'cause it deallocs seq
                        Yield(); // yield in case cpu bound
                } // if done bit set and streaming
            } // for i
            if (seqStream->streaming)
                trackStream = (TrackStreamType*) List_Get_Next(seqStream->trackStreamListHandle, trackStream);

        } // while (trackStream)

    } while(seqStream->streaming);
    mmioClose(seqStream->hmmio, 0);
    seqStream->streamTaskHandle = 0;
    LeaveSeq();
}


/***************************************************************************
 *
 * @doc     INTERNAL
 *
 * @api     LRESULT | DriverProc | The entry point for an installable driver.
 *
 * @parm    DWORD | dwDriverId | For most messages, dwDriverId is the DWORD
 *          value that the driver returns in response to a DRV_OPEN message.
 *          Each time that the driver is opened, through the DrvOpen API,
 *          the driver receives a DRV_OPEN message and can return an
 *          arbitrary, non-zero, value. The installable driver interface
 *          saves this value and returns a unique driver handle to the
 *          application. Whenever the application sends a message to the
 *          driver using the driver handle, the interface routes the message
 *          to this entry point and passes the corresponding dwDriverId.
 *
 *          This mechanism allows the driver to use the same or different
 *          identifiers for multiple opens but ensures that driver handles
 *          are unique at the application interface layer.
 *
 *          The following messages are not related to a particular open
 *          instance of the driver. For these messages, the dwDriverId
 *          will always be  ZERO.
 *
 *              DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
 *
 * @parm    UINT | wMessage | The requested action to be performed. Message
 *          values below DRV_RESERVED are used for globally defined messages.
 *          Message values from DRV_RESERVED to DRV_USER are used for
 *          defined driver portocols. Messages above DRV_USER are used
 *          for driver specific messages.
 *
 * @parm    LPARAM | lParam1 | Data for this message.  Defined separately for
 *          each message
 *
 * @parm    LPARAM | lParam2 | Data for this message.  Defined separately for
 *          each message
 *
 * @rdesc Defined separately for each message.
 *
 ***************************************************************************/
PUBLIC LRESULT FAR PASCAL _LOADDS DriverProc (DWORD_PTR dwDriverID, HDRVR hDriver, UINT wMessage, LPARAM lParam1, LPARAM lParam2)
{
    DWORD_PTR dwRes = 0L;

    switch (wMessage)
        {
            TIMECAPS timeCaps;

        // Standard, globally used messages.

        case DRV_LOAD:
            /*
               Sent to the driver when it is loaded. Always the first
               message received by a driver.
            */

            /*
               Find the minimum period we can support
            */


            if (timeGetDevCaps(&timeCaps, sizeof(timeCaps)) == MMSYSERR_NOERROR)
            {
                MINPERIOD = timeCaps.wPeriodMin;

                /* create a list of seq streams */
                SeqStreamListHandle = List_Create((LONG) sizeof(SeqStreamType), 0L);
                // following sets up command table to enable subsequent commands

                dwRes = 1L;
            }
            break;

        case DRV_FREE:

            /*
               Sent to the driver when it is about to be discarded. This
               will always be the last message received by a driver before
               it is freed.

               dwDriverID is 0L.
               lParam1 is 0L.
               lParam2 is 0L.

               Return value is IGNORED.
            */

            //dwReturn = midiSeqTerminate();

            dwRes = 1L;
            break;

        case DRV_OPEN:

            /*
               Sent to the driver when it is opened.

               dwDriverID is 0L.

               lParam1 is a far pointer to a zero-terminated string
               containing the name used to open the driver.

               lParam2 is passed through from the drvOpen call.

               Return 0L to FAIL the open.
            */

            if (!lParam2)
                dwRes = CONFIG_ID;

            else
                {
                ((LPMCI_OPEN_DRIVER_PARMS)lParam2)->wCustomCommandTable = MCI_TABLE_NOT_PRESENT;
                ((LPMCI_OPEN_DRIVER_PARMS)lParam2)->wType = MCI_DEVTYPE_SEQUENCER;
                dwRes = ((LPMCI_OPEN_DRIVER_PARMS)lParam2)->wDeviceID;
                }

            break;

        case DRV_CLOSE:

            /*
               Sent to the driver when it is closed. Drivers are unloaded
               when the close count reaches zero.

               dwDriverID is the driver identifier returned from the
               corresponding DRV_OPEN.

               lParam1 is passed through from the drvOpen call.

               lParam2 is passed through from the drvOpen call.

               Return 0L to FAIL the close.
            */

            dwRes = 1L;
            break;

        case DRV_ENABLE:

            /*
               Sent to the driver when the driver is loaded or reloaded
               and whenever windows is enabled. Drivers should only
               hook interrupts or expect ANY part of the driver to be in
               memory between enable and disable messages

               dwDriverID is 0L.
               lParam1 is 0L.
               lParam2 is 0L.

               Return value is ignored.

            */

            dwRes = 1L;
            break;

        case DRV_DISABLE:

            /*
               Sent to the driver before the driver is freed.
               and whenever windows is disabled

               dwDriverID is 0L.
               lParam1 is 0L.
               lParam2 is 0L.

               Return value is ignored.

            */

            dwRes = 1L;
            break;

       case DRV_QUERYCONFIGURE:

            /*
                Sent to the driver so that applications can
                determine whether the driver supports custom
                configuration. The driver should return a
                non-zero value to indicate that configuration
                is supported.

                dwDriverID is the value returned from the DRV_OPEN
                call that must have succeeded before this message
                was sent.

                lParam1 is passed from the app and is undefined.
                lParam2 is passed from the app and is undefined.

                return 1L to indicate configuration supported.

            */

            dwRes = 1L;
            break;

       case DRV_CONFIGURE:

            /*
                Sent to the driver so that it can display a custom
                configuration dialog box.

                lParam1 is passed from the app. and should contain
                the parent window handle in the loword.
                lParam2 is passed from the app and is undefined.

                return value is undefined.

                Drivers should create their own section in
                system.ini. The section name should be the driver
                name.


            */

            if ( lParam1 )
                dwRes = MIDIConfig((HWND)LOWORD (lParam1));
            else
               dwRes = (LRESULT)DRVCNF_CANCEL;
            break;

        case DRV_INSTALL:
        case DRV_REMOVE:
            dwRes = DRVCNF_OK;
            break;

        default:
            if (CONFIG_ID != dwDriverID &&
                wMessage >= DRV_MCI_FIRST && wMessage <= DRV_MCI_LAST) {
                    EnterSeq();
                    dwRes = mciDriverEntry ((MCIDEVICEID)dwDriverID, wMessage,
                                            (DWORD_PTR)lParam1, (DWORD_PTR)lParam2);
                    LeaveSeq();
                }
            else
                dwRes = (DWORD_PTR)DefDriverProc(dwDriverID, hDriver, wMessage, lParam1, lParam2);
            break;
     }
     return (LRESULT)dwRes;
}

#ifdef WIN32

/**************************************************************************

    @doc EXTERNAL

    @api BOOL | DllInstanceInit | This procedure is called whenever a
        process attaches or detaches from the DLL.

    @parm PVOID | hModule | Handle of the DLL.

    @parm ULONG | Reason | What the reason for the call is.

    @parm PCONTEXT | pContext | Some random other information.

    @rdesc The return value is TRUE if the initialisation completed ok,
        FALSE if not.

**************************************************************************/

BOOL DllInstanceInit(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
    UNREFERENCED_PARAMETER(pContext);

    if (Reason == DLL_PROCESS_ATTACH) {
        /*
           Initialize our critical section
        */
        InitCrit();
        hInstance = hModule;
        DisableThreadLibraryCalls(hModule);

    } else if (Reason == DLL_PROCESS_DETACH) {
        DeleteCrit();
    }
    return TRUE;
}

/************************************************************************/

#endif


/*****************************************************************************
 @doc INTERNAL MCISEQ

 @api   int |   MIDIConfig |

 @parm  HWND | hwndParent  |

 @rdesc

 @comm
*****************************************************************************/
typedef BOOL (WINAPI *SHOWMMCPLPROPSHEETW)(HWND hwndParent,
                                           LPCWSTR szPropSheetID,
                                           LPWSTR szTabName,
                                           LPWSTR szCaption);
int MIDIConfig (HWND hwndParent)
{
    static HWND     hwndPrevParent = NULL;
    WCHAR           szCaptionW[ 128 ];

    // We need only a unicode version of the caption (for FindWindow()
    // and ShowMMCPLPropertySheetW(), which are unicode-enabled).
    //
    LoadStringW(hInstance,IDS_MIDICAPTION,szCaptionW,cchLENGTH(szCaptionW));

    if (hwndPrevParent)
    {
        BringWindowToTop(FindWindowW(NULL, szCaptionW));
    }
    else
    {
        HINSTANCE h;
        SHOWMMCPLPROPSHEETW fn;
        static TCHAR aszMMSystemW[] = TEXT("MMSYS.CPL");
        static char aszShowPropSheetA[] = "ShowMMCPLPropertySheetW";
        static WCHAR aszMIDIW[] = L"MIDI";
        WCHAR   szTabNameW[64];
        LoadStringW(hInstance, IDS_MIDITAB, szTabNameW, cchLENGTH(szTabNameW));

        h = LoadLibrary (aszMMSystemW);
        if (h)
        {
            fn = (SHOWMMCPLPROPSHEETW)GetProcAddress(h, aszShowPropSheetA);
            if (fn)
            {
                BOOL f;

                hwndPrevParent = hwndParent;
                f = fn(hwndParent, aszMIDIW, szTabNameW, szCaptionW);
                hwndPrevParent = NULL;
            }
            FreeLibrary(h);
        }
    }
    return DRVCNF_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciseq\list.c ===
/* Copyright (c) 1992-1998 Microsoft Corporation */
// Linked list code -- approximates the VMM linked list API's

#include <windows.h>
#include "mmsystem.h"
#include "mmsys.h"
#include "list.h"
#include "mciseq.h"

List       arrayOfLists[MAXLISTS];      // array of lists

/**************************** PRIVATE FUNCTIONS *************************/
#define UNICODE

#ifdef DEBUG

PRIVATE BOOL NEAR PASCAL ListHandleBad(ListHandle lh)
{
    if ((lh >= MAXLISTS) || arrayOfLists[lh].nodeSize == 0)
    {
        dprintf(("*** Bad List Handle ***"));  // Must display before Break call
        DebugBreak();
        return TRUE;
    }
    else
        return FALSE;
}

#else
    #define ListHandleBad(lh)   FALSE
#endif

/**************************** PUBLIC FUNCTIONS *************************/

PUBLIC ListHandle FAR PASCAL List_Create(DWORD nodeSize, DWORD flags)                    //
//size must be non-zero
{
    int i;

    for(i = 0; ((i < MAXLISTS) && (arrayOfLists[i].nodeSize)); i++)
        ;

    if (i >= MAXLISTS)
        return NULLLIST;
    else
    {
        arrayOfLists[i].nodeSize = nodeSize;
        return i;  // return array index as "listHandle"
    }
}

PUBLIC NPSTR FAR PASCAL List_Allocate(ListHandle lh)
{
    Node *myNode;
    DWORD size;
    HLOCAL hMemory;

    if (ListHandleBad(lh))
        return NULL;

    size = (arrayOfLists[lh].nodeSize + NODEHDRSIZE + 3) & 0xFFFFFFFC;
        /* the above line serves to compute the total size, rounded up to
            next longword boundary */
/*    if (size > 65535)
        error(LISTALLOCTOOBIG); */

    if (hMemory = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, (int) size)) // make room for it
    {
        if (myNode = (Node *) LocalLock(hMemory)) // lock and get abs ptr to it
        {
            myNode->handle = hMemory;
            myNode->next = NULL;
            return (NPSTR) myNode->data; // return pointer (success!)
        }
        else // couldn't lock
        {
            LocalFree(myNode->handle); // undo the alloc
            return NULL;               // fail
        }
    }
    else // couldn't alloc
        return NULL; // fail
}

PUBLIC void FAR PASCAL List_Deallocate(ListHandle lh, NPSTR node)
{
    Node *myNode;
    Node *prevNode;
    NPSTR prevElement = NULL;
    NPSTR element;

    if (ListHandleBad(lh))
        return ;

    List_Lock(lh);

    for(element = List_Get_First(lh);  // traverse 'till found or exausted
        ((element) && (element != node)) ;
        element = List_Get_Next(lh, element) )
            prevElement = element;

    if (element) // not exausted, must've found it
    {
        myNode = (Node *) (((LPBYTE) element) - NODEHDRSIZE);

        // if was previous element in list, make it point over this one
        if (prevElement)
        {
            prevNode = (Node *) (((LPBYTE) prevElement) - NODEHDRSIZE);
            prevNode->next = myNode->next;
        }

        //make sure this node doesn't remain "first" or "next" node in list
        if (arrayOfLists[lh].firstNode == myNode)
            arrayOfLists[lh].firstNode = myNode->next;

        LocalFree(myNode->handle);                // free it
    }

    List_Unlock(lh);
}

PUBLIC VOID FAR PASCAL List_Destroy(ListHandle lh)
{
    Node    *myNode;
    Node    *nextNode;

    if (ListHandleBad(lh))
        return ;

    List_Lock(lh);

    myNode = arrayOfLists[lh].firstNode;
    while (myNode != NULL)  // free each node in list
    {
        nextNode = myNode->next;
        LocalFree(myNode->handle);
        myNode = nextNode;
    }
    arrayOfLists[lh].firstNode = NULL;  // forget that you had the list
    arrayOfLists[lh].nodeSize = 0L;

    List_Unlock(lh);
}

PUBLIC VOID FAR PASCAL List_Attach_Tail(ListHandle lh, NPSTR node)
    /* warning--this "node" is ptr to data.  true node starts 10 bytes earlier */
{
    Node    *myNode;
    Node    *nodeToInsert;

    if (ListHandleBad(lh))
        return ;

    List_Lock(lh);

    nodeToInsert = (Node *) (((LPBYTE) node) - NODEHDRSIZE);
    myNode = arrayOfLists[lh].firstNode;
    if (!myNode)  // if list empty, make it first
        arrayOfLists[lh].firstNode = nodeToInsert;
    else
    {
        for ( ;(myNode->next != NULL); myNode = myNode->next); // traverse to end
        myNode->next = nodeToInsert; // and put it there
    }
    nodeToInsert->next = NULL; // make sure not pointing to outer space

    List_Unlock(lh);
}

PUBLIC NPSTR FAR PASCAL List_Get_First(ListHandle lh)
{
    Node  *thisNode;
    NPSTR retValue;

    if (ListHandleBad(lh))
        return NULL;

    if (thisNode = arrayOfLists[lh].firstNode)
        retValue = (NPSTR)thisNode + NODEHDRSIZE;
    else
        retValue = NULL;

    return retValue;
}


PUBLIC NPSTR FAR PASCAL List_Get_Next(ListHandle lh, VOID* node)
{
    Node* npNext;

    if (ListHandleBad(lh))
        return NULL;

    if (!node)
        return NULL;

    npNext = ((Node*)((NPSTR)node - NODEHDRSIZE))->next;

    if (npNext)
        return (NPSTR)npNext + NODEHDRSIZE;
    else
        return NULL;
}

#ifdef DEBUG

PUBLIC VOID FAR PASCAL List_Lock(ListHandle lh)
{
    if (arrayOfLists[lh].fLocked)
    {
        dprintf(("**** List code reentered *****"));
        DebugBreak();
    }

    arrayOfLists[lh].fLocked++;
}

PUBLIC VOID FAR PASCAL List_Unlock(ListHandle lh)
{
    if (!arrayOfLists[lh].fLocked)
    {
        dprintf(("**** List code not locked!!  HELP!! *****"));
        DebugBreak();
    }

    arrayOfLists[lh].fLocked--;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciseq\formats.c ===
/******************************************************************************

   Copyright (c) 1985-1998 Microsoft Corporation

   Title:   foramts.c - Multimedia Systems Media Control Interface
            Contains specific mci time format conversion functions

   Version: 1.00

   Date:    7-MAR-1991

   Author:  Greg Simons

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   ----- -----------------------------------------------------------
   7-MAR-1991    GregSi Original

*****************************************************************************/
#define UNICODE
//MMSYSTEM
#define MMNOSOUND        - Sound support
#define MMNOWAVE         - Waveform support
#define MMNOAUX          - Auxiliary output support
#define MMNOJOY          - Joystick support

//MMDDK
#define NOWAVEDEV         - Waveform support
#define NOAUXDEV          - Auxiliary output support
#define NOJOYDEV          - Joystick support


#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "mmsys.h"
#include "list.h"
#include "mciseq.h"

/**************************** PRIVATE PROTOTYPES *************************/
PRIVATE DWORD NEAR PASCAL FPSDisplay(DWORD dwDisplayType);
PRIVATE DWORD NEAR PASCAL FPSFile(int wFileDiv);
PRIVATE DWORD NEAR PASCAL HMSFToFrames(DWORD dwCurrent, DWORD dwFormat);
PRIVATE DWORD NEAR PASCAL HMSFToMS(DWORD dwHmsf, DWORD dwFormat);
PRIVATE DWORD NEAR PASCAL FramesToHMSF(DWORD dwFrames, DWORD dwFormat);

/**************************** PRIVATE FUNCTIONS *************************/

PRIVATE DWORD NEAR PASCAL FPSDisplay(DWORD dwDisplayType)
// return the frames per second for smpte display types
// (utility function for format conversion routines)
{

    switch (dwDisplayType)
    {
        case MCI_FORMAT_SMPTE_24:
            return 24;
        case MCI_FORMAT_SMPTE_25:
            return 25;
        case MCI_FORMAT_SMPTE_30DROP:
        case MCI_FORMAT_SMPTE_30:
            return 30;
#ifdef DEBUG
    default:
        return 0;
#endif
    } //switch
    return 0;
}


PRIVATE DWORD NEAR PASCAL FPSFile(int wFileDiv)
{
    // returns frames per second based file division type
    switch (wFileDiv)
    {
    case SEQ_DIV_SMPTE_24:
            return 24;
    case SEQ_DIV_SMPTE_25:
            return 25;
    case SEQ_DIV_SMPTE_30:
    case SEQ_DIV_SMPTE_30DROP:
        return 30;
#ifdef DEBUG
    default:
        return 0;
#endif
    } //switch
    return 0;
}

PRIVATE DWORD NEAR PASCAL HMSFToFrames(DWORD dwCurrent, DWORD dwFormat)
/* convert from hmsf (colonized) format to raw frames */
{
    DWORD dwReturn;
    HMSF  hmsf = * ((HMSF FAR *) &dwCurrent); // cast dwCurrent to hmsf
    int fps = (int)FPSDisplay(dwFormat);

    dwReturn = ((DWORD)hmsf.hours * 60 * 60 * fps) +
               ((DWORD)hmsf.minutes * 60 * fps) +
               ((DWORD)hmsf.seconds * fps) +
               hmsf.frames;
    return dwReturn;
}

PRIVATE DWORD NEAR PASCAL HMSFToMS(DWORD dwHmsf, DWORD dwFormat)
// convert hmsf (colonized) format to milliseconds
{
    DWORD dwReturn;
    DWORD dwFrames = HMSFToFrames(dwHmsf, dwFormat);
    int fps = (int)FPSDisplay(dwFormat);

    dwReturn = ((dwFrames * 1000) + (fps/2)) / fps; // (fps/2) for rounding
    return dwReturn;
}

PRIVATE DWORD NEAR PASCAL FramesToHMSF(DWORD dwFrames, DWORD dwFormat)
// convert from frames to hmsf (colonized) format
{
    HMSF  hmsf;
    int fps = (int)FPSDisplay(dwFormat);

    hmsf.hours   =   (BYTE)(dwFrames / ((DWORD) 60 * 60 * fps));
    hmsf.minutes =   (BYTE)((dwFrames % ((DWORD) 60 * 60 * fps)) / (60 * fps));
    hmsf.seconds =   (BYTE)((dwFrames % ((DWORD) 60 * fps)) / fps);
    hmsf.frames  =   (BYTE)((dwFrames % fps));

    return * ((DWORD FAR *) &hmsf);
}

/**************************** PUBLIC FUNCTIONS *************************/

PUBLIC BOOL NEAR PASCAL ColonizeOutput(pSeqStreamType pStream)
// tells whether the user display type is such that the output should
// displayed colonoized (i.e. "hh:mm:ss:ff")
{
    if ((pStream->userDisplayType == MCI_FORMAT_SMPTE_24) ||
     (pStream->userDisplayType == MCI_FORMAT_SMPTE_25) ||
     (pStream->userDisplayType == MCI_FORMAT_SMPTE_30DROP) ||
     (pStream->userDisplayType == MCI_FORMAT_SMPTE_30))
     // smpte times are the only colonized formats
        return TRUE;
     else
        return FALSE;
}

PUBLIC BOOL NEAR PASCAL FormatsEqual(pSeqStreamType pStream)
// tells whether the display format is compatible with the file format
// (i.e. will conversion have to be done in interaction with the user)
{
    BOOL bReturn;
    // Essentially, ppqn file type only compatible with song pointer display;
    // SMPTE compatible with anything but ppqn

    if (pStream->fileDivType == SEQ_DIV_PPQN)
    {
        if (pStream->userDisplayType == MCI_SEQ_FORMAT_SONGPTR)
            bReturn = TRUE;
        else
            bReturn = FALSE;
    }
    else
    {
        if ((pStream->userDisplayType == MCI_FORMAT_SMPTE_24) ||
          (pStream->userDisplayType == MCI_FORMAT_SMPTE_25) ||
          (pStream->userDisplayType == MCI_FORMAT_SMPTE_30DROP) ||
          (pStream->userDisplayType == MCI_FORMAT_SMPTE_30))
            bReturn = TRUE;
        else
            bReturn = FALSE;
    }
    return bReturn;
}

PUBLIC DWORD NEAR PASCAL CnvtTimeToSeq(pSeqStreamType pStream, DWORD dwCurrent, MIDISEQINFO FAR * pSeqInfo)
/*  The sequencer understands two time units:  Ticks for ppqn files,
    or frames for smpte files.  The user data is presented either as
    song pointer, milliseconds, or H(our)M(inute)S(econd)F(rame).

    This routine converts FROM user time TO sequencer time.
*/
{
    DWORD   dwMs;   // milliseconds
    DWORD   fps;    // frames per second;
    DWORD   dwReturn;
    DWORD   dwTicks;

    if (FormatsEqual(pStream))
    {
        if ((pStream->userDisplayType == MCI_FORMAT_SMPTE_24) ||
         (pStream->userDisplayType == MCI_FORMAT_SMPTE_25) ||
         (pStream->userDisplayType == MCI_FORMAT_SMPTE_30) ||
         (pStream->userDisplayType == MCI_FORMAT_SMPTE_30DROP))
         // both file and display are smpte
            dwReturn = pSeqInfo->wResolution *
                HMSFToFrames(dwCurrent, pStream->userDisplayType);
        else
            //both file and display are ppqn (convert song pointer to ppqn)
            dwReturn = (pSeqInfo->wResolution * dwCurrent) / 4;
    }
    else if (pStream->fileDivType == SEQ_DIV_PPQN)
    //ppqn file, display format !ppqn
    {
        if (pStream->userDisplayType != MCI_FORMAT_MILLISECONDS)
            // must be smpte -- convert hmsf to milliseconds
            dwMs = HMSFToMS(dwCurrent, pStream->userDisplayType);
        else // must be milliseconds already
            dwMs = dwCurrent;

        // now that we have milliseconds, we must ask the sequencer to
        // convert them to ppqn (using it's internal tempo map)
        midiSeqMessage((HMIDISEQ) pStream->hSeq, SEQ_MSTOTICKS,
            dwMs, (DWORD_PTR)(LPSTR) &dwTicks); // passed back in dwTicks
        dwReturn = dwTicks;
    }
    else // smpte file, display format != smpte
    {
        // NB:  don't worry about SONGPTR -- it's illegal here
        // also, don't worry about HMSF -- it's equal
        // The only possible case is ms -> ticks

        fps = FPSFile(pStream->fileDivType);
        dwReturn = ((dwCurrent * fps * pSeqInfo->wResolution) + 500) / 1000;  // add 500 to round
    }
    return dwReturn;
}

PUBLIC DWORD NEAR PASCAL CnvtTimeFromSeq(pSeqStreamType pStream, DWORD dwTicks, MIDISEQINFO FAR * pSeqInfo)
//    This routine converts FROM sequencer time TO user time.
{
    DWORD   dwMs;   // milliseconds
    DWORD   fps;    // frames per second;
    DWORD   dwReturn;
    DWORD   dwFrames;
    DWORD   dwNativeUnits;

    if (pSeqInfo->wDivType == SEQ_DIV_PPQN)
        dwNativeUnits = (dwTicks * 4) / pSeqInfo->wResolution;
    else
        dwNativeUnits = dwTicks / pSeqInfo->wResolution;

    if (FormatsEqual(pStream))
    {
        if ((pStream->userDisplayType == MCI_FORMAT_SMPTE_24) ||
         (pStream->userDisplayType == MCI_FORMAT_SMPTE_25) ||
         (pStream->userDisplayType == MCI_FORMAT_SMPTE_30) ||
         (pStream->userDisplayType == MCI_FORMAT_SMPTE_30DROP))
            dwReturn = FramesToHMSF(dwNativeUnits, pStream->userDisplayType);
        else
            dwReturn = dwNativeUnits; // no conversion needed
    }
    else if (pStream->fileDivType == SEQ_DIV_PPQN)
    {
        // convert song ptr to ms
        midiSeqMessage((HMIDISEQ) pStream->hSeq, SEQ_TICKSTOMS,
            dwTicks, (DWORD_PTR)(LPSTR) &dwMs); // passed back in dwSongPtr

        if (pStream->userDisplayType == MCI_FORMAT_MILLISECONDS)
            dwReturn = dwMs;
        else
        // convert from ms to frames, and then frames to hmsf format
        {
            fps = FPSDisplay(pStream->userDisplayType);
            dwFrames = (dwMs * fps) / 1000;
            dwReturn = FramesToHMSF(dwFrames, pStream->userDisplayType);
        }
    }
    else // smpte file
    {
        // NB:  don't worry about SONGPTR -- it's illegal here
        // also, don't worry about HMSF -- it's "equal"
        // The only possible case is frames->ms

        // set stream display type default based on file div type
        fps = FPSFile(pStream->fileDivType);

        dwReturn = ((dwTicks * 1000) + (fps/2)) /
            (fps * pSeqInfo->wResolution);
            // add (fps/2) to round
        // BTW:  it would take > 39 hours to overflow @ 30fps (23:59:59:29 is max)
    }
    return dwReturn;
}

PUBLIC BOOL NEAR PASCAL RangeCheck(pSeqStreamType pStream, DWORD dwValue)
/*  range checks raw, unconverted data.  checks if data is negative, or past
end of file length.  also checks if smpte hours, minutes, seconds and frames
are all valid.  Returns TRUE if legal, otherwise FALSE */
{
    int                 fps;
    HMSF                hmsf;
    DWORD               dwLength;
    MIDISEQINFO         seqInfo;

    // Get length, and convert it to display format
    midiSeqMessage((HMIDISEQ) pStream->hSeq,
             SEQ_GETINFO, (DWORD_PTR) (LPMIDISEQINFO) &seqInfo, 0L);
    dwLength = CnvtTimeFromSeq(pStream, seqInfo.dwLength, &seqInfo);

    switch (pStream->userDisplayType)  // check length based on user format
    {
        case MCI_FORMAT_SMPTE_24:
        case MCI_FORMAT_SMPTE_25:
        case MCI_FORMAT_SMPTE_30:
        case MCI_FORMAT_SMPTE_30DROP:
            hmsf = * ((HMSF FAR *) &dwValue);
            fps = (int)FPSDisplay(pStream->userDisplayType); // get frames per second

            // check for format errors
            if (((int)hmsf.frames >= fps) || (hmsf.seconds >= 60) ||
                (hmsf.minutes >= 60) || (hmsf.hours > 24))
                return FALSE;

            // don't check for negative values, since using unsigned bytes
            // (2's comp. negs would get caught above anyway)

            // check for length error
            if (HMSFToMS(* ((DWORD FAR *) &dwValue), pStream->userDisplayType) >
                HMSFToMS(dwLength, pStream->userDisplayType))
                return FALSE;
            break;

        case MCI_SEQ_FORMAT_SONGPTR:
        case MCI_FORMAT_MILLISECONDS:
            if (dwValue > dwLength)
                return FALSE; // past end
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciseq\mciseq.h ===
/******************************************************************************

   Copyright (c) 1985-1998 Microsoft Corporation

   Title:   mciseq.h - Multimedia Systems Media Control Interface streaming
            MIDI file data internal header file.

   Version: 1.00

   Date:    27-Apr-1990

   Author:  Greg Simons

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   ----- -----------------------------------------------------------
   27-APR-1990   GREGSI Original

*****************************************************************************/


//#define SEQDEBUG 1

#define MSEQ_PRODUCTNAME 1
#define IDS_MIDICAPTION  2
#define IDS_MIDITAB      3

#define IDDLGWARN        100
#define IDCHECK          102

/*************** Stream Stuff ***************************************/

#define NUMHDRS         2
#define BUFFSIZE      512

#ifndef cchLENGTH
#define cchLENGTH(_sz) (sizeof(_sz)/sizeof(_sz[0]))
#endif


typedef struct tag_HMSF
{
    BYTE hours;
    BYTE minutes;
    BYTE seconds;
    BYTE frames;
} HMSF;

typedef struct
{
    /* All stream data for a track of an open sequence goes here */
    DWORD     beginning;  // these are byte numbers within the open file
    DWORD     end;
    DWORD     current;   // byte # to start reading from for next chunk
    DWORD     bufferNum; // current buffer number
    LPMIDISEQHDR fileHeaders[NUMHDRS]; // pointers to midi file track data headers
} TrackStreamType;

typedef struct
{
    /* All stream data for an open sequence goes here */
    WCHAR        szFilename[128]; // file name here for stream thread
    HMIDISEQ    hSeq;      // handle to the sequence
    HMMIO       hmmio;      // MMIO handle to midi file or RMID file
    LPMMIOPROC  pIOProc;    // Optional MMIO proc
    HMIDIOUT    hmidiOut;   // handle to dest. midi port
    UINT        wPortNum;   // midi port number
    DWORD       dwFileLength;
    ListHandle  trackStreamListHandle;
    BOOL        streaming;  // to flag streaming process to exit or not
    DWORD       streamTaskHandle; // handle to streaming task
    HANDLE      streamThreadHandle; // OS handle to stream thread
    HWND        hNotifyCB;  // mci client's notify cb--NULL if none
    UINT        wNotifyMsg;  // mci message (command) that async notify's for
    DWORD       dwNotifyOldTo; // x for last "play foo to x notify"
                               // (critical for abort/supersede)
    MCIDEVICEID wDeviceID;   // this stream's devID for Notify callback
    int         fileDivType; // file division type
    DWORD       userDisplayType;  // song pointer, smpte x, or milliseconds
    BOOL        bLastPaused; // if last stop action was result of "mci_pause"

} SeqStreamType,
NEAR * pSeqStreamType;

extern ListHandle SeqStreamListHandle;  // this is a global kept for the seq streamer
extern HINSTANCE  hInstance;

// from mciseq.c
PUBLIC DWORD FAR PASCAL mciDriverEntry (MCIDEVICEID wDeviceID, UINT wMessage,
                    DWORD_PTR dwParam1, DWORD_PTR dwParam2);
PRIVATE BOOL NEAR PASCAL bAsync(UINT wMsg);
PRIVATE BOOL NEAR PASCAL bMutex(UINT wNewMsg, UINT wOldMsg, DWORD wNewFlags,
    DWORD dwNewTo, DWORD dwOldTo);
PUBLIC VOID FAR PASCAL PrepareForNotify(pSeqStreamType pStream,
    UINT wMessage, LPMCI_GENERIC_PARMS lpParms, DWORD dwTo);
PUBLIC VOID FAR PASCAL SetupMmseqCallback(pSeqStreamType pStream,
                    DWORD_PTR dwInstance);
PUBLIC VOID FAR PASCAL Notify(pSeqStreamType pStream, UINT wStatus);
PUBLIC VOID NEAR PASCAL EndStreamCycle(pSeqStreamType pStream);
PUBLIC DWORD NEAR PASCAL EndFileStream(pSeqStreamType pStream);
PUBLIC DWORD NEAR PASCAL msOpenStream(pSeqStreamType FAR * lppStream,
                    LPCWSTR szName, LPMMIOPROC pIOProc);
PUBLIC VOID FAR PASCAL StreamTrackReset(pSeqStreamType pStream,
                    UINT wTrackNum);
PUBLIC VOID FAR _LOADDS PASCAL mciStreamCycle(DWORD_PTR dwInst);
PUBLIC VOID FAR PASCAL _LOADDS mciSeqCallback(HANDLE h, UINT wMsg, DWORD_PTR dwInstance,
                DWORD_PTR dw1, DWORD_PTR dw2);


// from mcicmds.c:
PUBLIC DWORD NEAR PASCAL msOpen(pSeqStreamType FAR *lppStream, MCIDEVICEID wDeviceID,
    DWORD dwFlags, LPMCI_OPEN_PARMS lpOpen);
PUBLIC DWORD NEAR PASCAL msClose(pSeqStreamType pStream, MCIDEVICEID wDeviceID,
    DWORD dwFlags);
PUBLIC DWORD NEAR PASCAL msPlay(pSeqStreamType pStream, MCIDEVICEID wDeviceID,
    DWORD dwFlags, LPMCI_PLAY_PARMS lpPlay);
PUBLIC DWORD NEAR PASCAL msSeek(pSeqStreamType pStream, MCIDEVICEID wDeviceID,
    DWORD dwParam1, LPMCI_SEEK_PARMS lpSeek);
PUBLIC DWORD NEAR PASCAL msStatus(pSeqStreamType pStream, MCIDEVICEID wDeviceID,
    DWORD dwFlags, LPMCI_STATUS_PARMS lpStatus);
PUBLIC DWORD NEAR PASCAL msGetDevCaps(pSeqStreamType pStream, MCIDEVICEID wDeviceID,
    DWORD dwParam1, LPMCI_GETDEVCAPS_PARMS lpCapParms);
PUBLIC DWORD NEAR PASCAL msInfo(pSeqStreamType pStream, MCIDEVICEID wDeviceID,
    DWORD dwFlags, LPMCI_INFO_PARMS lpInfo);
PUBLIC DWORD NEAR PASCAL msSet(pSeqStreamType pStream, MCIDEVICEID wDeviceID,
    DWORD dwFlags, LPMCI_SEQ_SET_PARMS lpSetParms);

// from Formats.c
PUBLIC BOOL NEAR PASCAL ColonizeOutput(pSeqStreamType pStream);
PUBLIC BOOL NEAR PASCAL FormatsEqual(pSeqStreamType pStream);
PUBLIC DWORD NEAR PASCAL CnvtTimeToSeq(pSeqStreamType pStream,
        DWORD dwCurrent, MIDISEQINFO FAR * pSeqInfo);
PUBLIC DWORD NEAR PASCAL CnvtTimeFromSeq(pSeqStreamType pStream,
        DWORD dwTicks, MIDISEQINFO FAR * pSeqInfo);
PUBLIC BOOL NEAR PASCAL RangeCheck(pSeqStreamType pStream, DWORD dwValue);


/***************************************************************************

    DEBUGGING SUPPORT

***************************************************************************/


#if DBG

    extern void mciseqDbgOut(LPSTR lpszFormat, ...);

    int mciseqDebugLevel;

    #define dprintf( _x_ )                             mciseqDbgOut _x_
    #define dprintf1( _x_ ) if (mciseqDebugLevel >= 1) mciseqDbgOut _x_
    #define dprintf2( _x_ ) if (mciseqDebugLevel >= 2) mciseqDbgOut _x_
    #define dprintf3( _x_ ) if (mciseqDebugLevel >= 3) mciseqDbgOut _x_
    #define dprintf4( _x_ ) if (mciseqDebugLevel >= 4) mciseqDbgOut _x_

#else

    #define dprintf(x)
    #define dprintf1(x)
    #define dprintf2(x)
    #define dprintf3(x)
    #define dprintf4(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciseq\mcicmds.c ===
/*---------------------------------------------------------------------------*/
/*
   Copyright (c) 1985-1998 Microsoft Corporation

   Title:   mcicmds.c - Multimedia Systems Media Control Interface
        Contains specific mci command implementations

   Version: 1.00

   Date:    7-MAR-1991

   Author:  Greg Simons

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   ----- -----------------------------------------------------------
   7-MAR-1991    GregSi Original
*/
/*---------------------------------------------------------------------------*/
#define UNICODE

//MMSYSTEM
#define MMNOSOUND    - Sound support
#define MMNOWAVE     - Waveform support
#define MMNOAUX      - Auxiliary output support
#define MMNOJOY      - Joystick support

//MMDDK
#define NOWAVEDEV     - Waveform support
#define NOAUXDEV      - Auxiliary output support
#define NOJOYDEV      - Joystick support

#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <string.h>
#include <wchar.h>
#include "mmsys.h"
#include "list.h"
#include "mciseq.h"

#ifdef WIN16
#define SZCODE char _based(_segname("_CODE"))
#else
#define WSZCODE WCHAR
#endif

PRIVATE WSZCODE aszAppName[]        = L"mciseq.drv";
PRIVATE WSZCODE aszSystemIni[]      = L"system.ini";
PRIVATE WSZCODE aszTrue[]           = L"true";
PRIVATE WSZCODE aszNull[]           = L"";
PRIVATE WSZCODE aszDisableWarning[] = L"disablewarning";

/*---------------------------------------------------------------------------*/
PUBLIC  DWORD NEAR PASCAL msOpen(
    pSeqStreamType  FAR *lppStream,
    MCIDEVICEID wDeviceID,
    DWORD   dwFlags,
    LPMCI_OPEN_PARMS    lpOpen)
{
    DWORD   dwReturn;    // to be returned from this function
    LPCWSTR  lpstrFileName;
    LPMMIOPROC  pIOProc;
    pSeqStreamType  pStream;

    if ((dwFlags & (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID)) == (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID))
        return MCIERR_FLAGS_NOT_COMPATIBLE;
    if (!(dwFlags & (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID)))
        return 0L;
    if (dwFlags & MCI_OPEN_SHAREABLE)
        return MCIERR_UNSUPPORTED_FUNCTION;
    if (dwFlags & MCI_OPEN_ELEMENT)
        pIOProc = NULL;
    else
        pIOProc = *(LPMMIOPROC *)(lpOpen + 1);
    // open the "stream" (opens file, allocs data, creates streaming task,
    // and calls mmseq (sequencer) to have it allocate sequence structure)
    lpstrFileName = lpOpen->lpstrElementName;
    // Does not support 'new'
    if (lpstrFileName != NULL && *lpstrFileName == '\0')
        return MCIERR_FILENAME_REQUIRED;
    dwReturn = msOpenStream(&pStream, lpstrFileName, pIOProc);
    if (!dwReturn) {
        MIDISEQINFO seqInfo;

        pStream->wDeviceID = wDeviceID;
        pStream->wNotifyMsg = 0;
        // set up to remember when seq calls back
        // tell sequencer to prepare to play (actually parses whole file
        // and creates tempo map [which allocs memory])
        if (midiSeqMessage(pStream->hSeq, SEQ_SETUPTOPLAY, 0L, 0L) == MIDISEQERR_NOMEM)
            return MCIERR_OUT_OF_MEMORY;
        // get back file division type (ppqn, smpte, etc...)
        midiSeqMessage(pStream->hSeq, SEQ_GETINFO, (DWORD_PTR)(LPMIDISEQINFO)&seqInfo, 0L);
        pStream->fileDivType = seqInfo.wDivType;
        // set stream display type default based on file div type
        switch (pStream->fileDivType) {
        case SEQ_DIV_PPQN:
            pStream->userDisplayType = MCI_SEQ_FORMAT_SONGPTR;
            break;
        case SEQ_DIV_SMPTE_24:
            pStream->userDisplayType = MCI_FORMAT_SMPTE_24;
            break;
        case SEQ_DIV_SMPTE_25:
            pStream->userDisplayType = MCI_FORMAT_SMPTE_25;
            break;
        case SEQ_DIV_SMPTE_30:
            pStream->userDisplayType = MCI_FORMAT_SMPTE_30;
            break;
        case SEQ_DIV_SMPTE_30DROP:
            pStream->userDisplayType = MCI_FORMAT_SMPTE_30DROP;
            break;
        }
        //Force a wait until stream is initialized.
        do {
            Yield();
            midiSeqMessage(pStream->hSeq, SEQ_GETINFO, (DWORD_PTR)(LPMIDISEQINFO)&seqInfo, 0L);
        } while ((!seqInfo.bReadyToPlay) && (seqInfo.tempoMapExists) && (seqInfo.bLegalFile));
        // (if tempo map deleted, this is a sign that a tempo map alloc failed)
        // important:  check to see if tempo map allocation failed
        //  if so, close sequence and return failure
        mciSetDriverData(wDeviceID, (DWORD_PTR)pStream);
        // MCI bookkeeping -- must come before close below
        if (!seqInfo.tempoMapExists) {
            dwReturn = MCIERR_OUT_OF_MEMORY;
            mciDriverEntry(wDeviceID, MCI_CLOSE_DRIVER, dwFlags & ~MCI_NOTIFY, (DWORD_PTR)lpOpen);
        } else if (!seqInfo.bLegalFile) {
            dwReturn = MCIERR_INVALID_FILE;
            mciDriverEntry(wDeviceID, MCI_CLOSE_DRIVER, dwFlags & ~MCI_NOTIFY, (DWORD_PTR)lpOpen);
        } else
            *lppStream = pStream;
    }
    return dwReturn;
}

/*---------------------------------------------------------------------------*/
PUBLIC  DWORD NEAR PASCAL msClose(
    pSeqStreamType  pStream,
    MCIDEVICEID wDeviceID,
    DWORD   dwFlags)
{
    dprintf2(("close"));
    if (pStream) {
        midiSeqMessage(pStream->hSeq, SEQ_STOP, 0L, 0L);
        dprintf4(("calling endfilestream"));
        midiSeqMessage(pStream->hSeq, SEQ_SETPORTOFF, FALSE, 0L);
        dprintf4(("closed port"));
        Notify(pStream, (dwFlags == MCI_NOTIFY) ? MCI_NOTIFY_SUPERSEDED : MCI_NOTIFY_ABORTED);
        EndFileStream(pStream);
        dprintf4(("back from endfilestream"));
    }
    return 0;
 }


/*---------------------------------------------------------------------------*/
PRIVATE DWORD PASCAL NEAR OpenMidiPort(
    pSeqStreamType  pStream)
{
    if ((pStream->wPortNum == MCI_SEQ_NONE) || (midiSeqMessage(pStream->hSeq, SEQ_QUERYHMIDI, 0L, 0L)))
        return 0;

    if (!midiOutGetNumDevs()) {
        dprintf1(("OpenMidiPort - no MIDI ports present"));
        return MCIERR_SEQ_NOMIDIPRESENT;  // No midi ports present
    }

    switch ((UINT)midiSeqMessage(pStream->hSeq, SEQ_SETPORT, (DWORD)pStream->wPortNum, 0L)) {
    case 0:
        return 0;
    case MMSYSERR_ALLOCATED:
        return MCIERR_SEQ_PORT_INUSE;
    case MMSYSERR_BADDEVICEID:
        return MCIERR_SEQ_PORT_NONEXISTENT;
    case MIDIERR_NODEVICE:
        return MIDIERR_NODEVICE;
    default:
        return MCIERR_SEQ_NOMIDIPRESENT;
    }
}

/*---------------------------------------------------------------------------*/
PUBLIC DWORD NEAR PASCAL msPlay(pSeqStreamType pStream, MCIDEVICEID wDeviceID,
        DWORD dwFlags, LPMCI_PLAY_PARMS lpPlay)
{
    MIDISEQINFO seqInfo;
    DWORD   dwPlayFrom;
    DWORD   dwPlayTo;
    DWORD   dwReturn;

    if (0 != (dwReturn = OpenMidiPort(pStream)))
        return dwReturn;

    // get info to aid in possible time format conversions (from & to)
    midiSeqMessage(pStream->hSeq, SEQ_GETINFO, (DWORD_PTR)(LPMIDISEQINFO)&seqInfo, 0L);
    // convert "to," if any
    if (MCI_TO & dwFlags) {
        // is the user typing in what he believes to be the end?
        if (lpPlay->dwTo == CnvtTimeFromSeq(pStream, seqInfo.dwLength, &seqInfo))
            dwPlayTo = seqInfo.dwLength; // if so, let him have it
        else
            dwPlayTo = CnvtTimeToSeq(pStream, lpPlay->dwTo, &seqInfo);
    } else
        dwPlayTo = PLAYTOEND; // has no effect
    // convert "from," if any
    if (MCI_FROM & dwFlags)
        dwPlayFrom = CnvtTimeToSeq(pStream, lpPlay->dwFrom, &seqInfo);
    else
        dwPlayFrom = 0;
    // complain if input out of range
    // "to" in range [0..length]
    if ((MCI_TO & dwFlags) && (!RangeCheck(pStream, lpPlay->dwTo)))
        dwReturn = MCIERR_OUTOFRANGE;
    // "from" in range [0..length]
    else if ((MCI_FROM & dwFlags) && (!RangeCheck(pStream, lpPlay->dwFrom)))
        dwReturn = MCIERR_OUTOFRANGE;
    // from before to (can't play backwards!)
    else if ((MCI_FROM & dwFlags) && (MCI_TO & dwFlags) && (dwPlayFrom > dwPlayTo))
        dwReturn = MCIERR_OUTOFRANGE;
    // if from not specified, current pos implied -- don't play backwards
    else if ((!(MCI_FROM & dwFlags)) && (MCI_TO & dwFlags) && (dwPlayTo < seqInfo.dwCurrentTick))
        dwReturn = MCIERR_OUTOFRANGE;
    else if (MCI_FROM & dwFlags)
        if (midiSeqMessage(pStream->hSeq, SEQ_SYNCSEEKTICKS, dwPlayFrom, 0) != MIDISEQERR_NOERROR)
            dwReturn = MCIERR_DEVICE_NOT_READY;

    if (!dwReturn) {
        if (0 != (dwReturn = (DWORD)midiSeqMessage(pStream->hSeq, SEQ_PLAY, dwPlayTo, 0L))) {
            // handle possible timer error (possibly due to timer.dll not loading)
            if (dwReturn == MIDISEQERR_TIMER)
                dwReturn = MCIERR_SEQ_TIMER;
        } else if ((dwFlags & MCI_WAIT)) {
            // handle "Play Wait"
            if (pStream->hNotifyCB)
                if (pStream->wNotifyMsg == MCI_PLAY) {
                    if (dwPlayTo == PLAYTOEND)
                        dwPlayTo = seqInfo.dwLength;
                    Notify(pStream, ((dwFlags & MCI_FROM) || (pStream->dwNotifyOldTo != dwPlayTo)) ? MCI_NOTIFY_ABORTED : MCI_NOTIFY_SUPERSEDED);
                } else if (pStream->wNotifyMsg == MCI_SEEK)
                    Notify(pStream, MCI_NOTIFY_SUPERSEDED);
            do {
                Yield();
                midiSeqMessage(pStream->hSeq, SEQ_GETINFO, (DWORD_PTR)(LPMIDISEQINFO)&seqInfo, 0L);
            } while ((seqInfo.bPlaying) && (!mciDriverYield(wDeviceID)));
        }
    }
    if (dwReturn && !seqInfo.bPlaying)
        midiSeqMessage(pStream->hSeq, SEQ_SETPORTOFF, FALSE, 0L);
    return dwReturn;
}

/*---------------------------------------------------------------------------*/
PUBLIC  DWORD NEAR PASCAL msSeek(
    pSeqStreamType  pStream,
    MCIDEVICEID wDeviceID,
    DWORD   dwParam1,
    LPMCI_SEEK_PARMS    lpSeek)
{
    DWORD   dwFlags;
    DWORD   dwSeekTo;
    MIDISEQINFO seqInfo;

    dwFlags = dwParam1 & ~(MCI_WAIT | MCI_NOTIFY);  // don't consider these here
    if (!dwFlags)
        return MCIERR_MISSING_PARAMETER;
    if (dwFlags != (dwFlags & (MCI_TO | MCI_SEEK_TO_START | MCI_SEEK_TO_END)))
        return MCIERR_UNRECOGNIZED_KEYWORD;
    midiSeqMessage(pStream->hSeq, SEQ_GETINFO, (DWORD_PTR)(LPMIDISEQINFO)&seqInfo, 0L);
    switch (dwFlags) {
    case MCI_TO:
        if (!RangeCheck(pStream, lpSeek->dwTo))
            return MCIERR_OUTOFRANGE;
        dwSeekTo = CnvtTimeToSeq(pStream, lpSeek->dwTo, &seqInfo);
        break;
    case MCI_SEEK_TO_START:
        dwSeekTo = 0L;
        break;
    case MCI_SEEK_TO_END:
        dwSeekTo = seqInfo.dwLength;
        break;
    default:
        return MCIERR_FLAGS_NOT_COMPATIBLE;
    }
    // if playing, call self to pause 1st.
    if (seqInfo.bPlaying)
        mciDriverEntry(wDeviceID, MCI_PAUSE, dwFlags, (DWORD_PTR)lpSeek);
    // set up to remember when seq calls back
    if (midiSeqMessage(pStream->hSeq, SEQ_SEEKTICKS, dwSeekTo, 0) != MIDISEQERR_NOERROR)
        return MCIERR_DEVICE_NOT_READY;
    else if (dwParam1 & MCI_WAIT) {
        if (pStream->hNotifyCB)
            if (pStream->wNotifyMsg == MCI_SEEK)
                Notify(pStream, (pStream->dwNotifyOldTo != lpSeek->dwTo) ? MCI_NOTIFY_ABORTED : MCI_NOTIFY_SUPERSEDED);
            else if (pStream->wNotifyMsg == MCI_PLAY)
                Notify(pStream, MCI_NOTIFY_SUPERSEDED);
        do {
            midiSeqMessage(pStream->hSeq, SEQ_GETINFO, (DWORD_PTR)(LPMIDISEQINFO)&seqInfo, 0L);
            Yield();
        } while ((seqInfo.bSeeking) && (!mciDriverYield(wDeviceID)));
    }
    return 0;
}

/*---------------------------------------------------------------------------*/
PUBLIC  DWORD NEAR PASCAL msStatus(
    pSeqStreamType  pStream,
    MCIDEVICEID wDeviceID,
    DWORD   dwFlags,
    LPMCI_STATUS_PARMS  lpStatus)
{
    DWORD   dwReturn;
    MIDISEQINFO seqInfo;
    DWORD   dwStatusReturn = 0;

    if (!(dwFlags & MCI_STATUS_ITEM))
        return MCIERR_MISSING_PARAMETER;
    if  ((dwFlags & MCI_TRACK) && (!((lpStatus->dwItem) & (MCI_STATUS_POSITION | MCI_STATUS_LENGTH))))
        return MCIERR_DUPLICATE_FLAGS;
    dwReturn = 0;
    midiSeqMessage(pStream->hSeq, SEQ_GETINFO, (DWORD_PTR)(LPMIDISEQINFO)&seqInfo, 0L);
    switch (lpStatus->dwItem) {
        UINT    wThingsPerMin;
        UINT    wResource;

    case MCI_STATUS_TIME_FORMAT:
        wResource = (UINT)pStream->userDisplayType;
        if (wResource == MCI_SEQ_FORMAT_SONGPTR)
            dwStatusReturn = (DWORD)MAKEMCIRESOURCE(MCI_SEQ_FORMAT_SONGPTR, MCI_SEQ_FORMAT_SONGPTR_S);
        else
            dwStatusReturn = (DWORD)MAKEMCIRESOURCE(wResource, wResource + MCI_FORMAT_RETURN_BASE);
        dwReturn = MCI_RESOURCE_RETURNED;
        break;
    case MCI_STATUS_POSITION:
        if  (dwFlags & MCI_TRACK) {
            if ((lpStatus->dwTrack) != 1)
                dwReturn = MCIERR_OUTOFRANGE;
            else
                dwStatusReturn = 0L; //beginning of track
        } else if (dwFlags & MCI_STATUS_START)
            dwStatusReturn = 0L; //beginning of track
        else // normal status position request
            dwStatusReturn = CnvtTimeFromSeq(pStream, seqInfo.dwCurrentTick, &seqInfo);
        if (ColonizeOutput(pStream))
            dwReturn = MCI_COLONIZED4_RETURN;
        break;
    case MCI_STATUS_LENGTH:
        if (dwFlags & MCI_TRACK)
            if ((lpStatus->dwTrack) != 1)
                dwReturn = MCIERR_OUTOFRANGE;
        dwStatusReturn = CnvtTimeFromSeq(pStream, seqInfo.dwLength, &seqInfo);
        if (ColonizeOutput(pStream))
            dwReturn = MCI_COLONIZED4_RETURN;
        break;
    case MCI_STATUS_READY:
        dwReturn = MCI_RESOURCE_RETURNED;
        if (seqInfo.bReadyToPlay)
            dwStatusReturn = (DWORD)MAKEMCIRESOURCE(TRUE, MCI_TRUE);
        else
            dwStatusReturn = (DWORD)MAKEMCIRESOURCE(FALSE, MCI_FALSE);
        break;
    case MCI_STATUS_NUMBER_OF_TRACKS:
        dwStatusReturn = 1;
        break;
    case MCI_STATUS_MODE:
        dwReturn = MCI_RESOURCE_RETURNED;
        if (seqInfo.bSeeking)
            wResource = MCI_MODE_SEEK;
        else if (seqInfo.bPlaying)
            wResource = MCI_MODE_PLAY;
        else if (pStream->bLastPaused)
            wResource = MCI_MODE_PAUSE;
        else
            wResource = MCI_MODE_STOP;
        dwStatusReturn = (DWORD)MAKEMCIRESOURCE(wResource, wResource);
        break;
    case MCI_STATUS_MEDIA_PRESENT:
        dwReturn = MCI_RESOURCE_RETURNED;
        dwStatusReturn = (DWORD)MAKEMCIRESOURCE(TRUE, MCI_TRUE);
        break;
    case MCI_SEQ_STATUS_DIVTYPE:
        dwReturn = MCI_RESOURCE_RETURNED;
        switch (seqInfo.wDivType) {
            //NB:  the MCI_SEQ_DIV... codes are string ids
        case SEQ_DIV_PPQN:
            wResource = MCI_SEQ_DIV_PPQN;
            break;
        case SEQ_DIV_SMPTE_24:
            wResource = MCI_SEQ_DIV_SMPTE_24;
            break;
        case SEQ_DIV_SMPTE_25:
            wResource = MCI_SEQ_DIV_SMPTE_25;
            break;
        case SEQ_DIV_SMPTE_30:
            wResource = MCI_SEQ_DIV_SMPTE_30;
            break;
        case SEQ_DIV_SMPTE_30DROP:
            wResource = MCI_SEQ_DIV_SMPTE_30DROP;
            break;
        }
        dwStatusReturn = (DWORD)MAKEMCIRESOURCE(wResource, wResource);
        break;
    case MCI_SEQ_STATUS_TEMPO:
        // tempo comes back in microseconds per tick -- convert to
        // more human-readable form if smpte: fps else bpm
        wThingsPerMin = (UINT)(USecPerMinute / ((DWORD)seqInfo.wResolution * (DWORD)seqInfo.dwTempo));
        if (seqInfo.wDivType == SEQ_DIV_PPQN)
            dwStatusReturn = (DWORD)wThingsPerMin;
        else
            dwStatusReturn = (DWORD)(wThingsPerMin / 60);   // things per second
        break;
    case MCI_SEQ_STATUS_PORT:
        switch (pStream->wPortNum) {
        case (UINT)MIDI_MAPPER:
            dwReturn = MCI_RESOURCE_RETURNED;
            dwStatusReturn = (DWORD)MAKEMCIRESOURCE(MIDI_MAPPER, MIDIMAPPER_S);
            break;
        case MCI_SEQ_NONE:
            dwReturn = MCI_RESOURCE_RETURNED;
            dwStatusReturn = (DWORD)MAKEMCIRESOURCE(MCI_SEQ_NONE, MCI_SEQ_NONE_S);
            break;
        default:
            dwStatusReturn = pStream->wPortNum;
            break;
        }
        break;
    case MCI_SEQ_STATUS_SLAVE:
        dwReturn = MCI_RESOURCE_RETURNED;
        switch(seqInfo.wInSync) {
        case SEQ_SYNC_NOTHING:
            dwStatusReturn = (DWORD)MAKEMCIRESOURCE(MCI_SEQ_NONE, MCI_SEQ_NONE_S);
            break;
        case SEQ_SYNC_FILE:
            dwStatusReturn = (DWORD)MAKEMCIRESOURCE(MCI_SEQ_FILE, MCI_SEQ_FILE_S);
            break;
        case SEQ_SYNC_MIDI:
            dwStatusReturn = (DWORD)MAKEMCIRESOURCE(MCI_SEQ_MIDI, MCI_SEQ_MIDI_S);
            break;
        case SEQ_SYNC_SMPTE:
            dwStatusReturn = (DWORD)MAKEMCIRESOURCE(MCI_SEQ_SMPTE, MCI_SEQ_SMPTE_S);
            break;
        }
        break;
    case MCI_SEQ_STATUS_MASTER:
        dwReturn = MCI_RESOURCE_RETURNED;
        switch(seqInfo.wOutSync) {
        case SEQ_SYNC_NOTHING:
            dwStatusReturn = (DWORD)MAKEMCIRESOURCE(MCI_SEQ_NONE, MCI_SEQ_NONE_S);
            break;
        case SEQ_SYNC_MIDI:
            dwStatusReturn = (DWORD)MAKEMCIRESOURCE(MCI_SEQ_MIDI, MCI_SEQ_MIDI_S);
            break;
        case SEQ_SYNC_SMPTE:
            dwStatusReturn = (DWORD)MAKEMCIRESOURCE(MCI_SEQ_SMPTE, MCI_SEQ_SMPTE_S);
            break;
        }
        break;
    case MCI_SEQ_STATUS_OFFSET:
        dwStatusReturn = seqInfo.mmSmpteOffset.u.smpte.hour + ((DWORD)seqInfo.mmSmpteOffset.u.smpte.min << 8) + ((DWORD)seqInfo.mmSmpteOffset.u.smpte.sec << 16) + ((DWORD)seqInfo.mmSmpteOffset.u.smpte.frame << 24);
        dwReturn = MCI_COLONIZED4_RETURN;
        break;
    case MCI_STATUS_CURRENT_TRACK:
        dwStatusReturn = 1;
        break;
    default:
        dwReturn = MCIERR_UNSUPPORTED_FUNCTION;
        break;
    }
    // Return the status value in the struct
    lpStatus->dwReturn = dwStatusReturn;
    return dwReturn;
}

/*---------------------------------------------------------------------------*/
PUBLIC  DWORD NEAR PASCAL msGetDevCaps(
    pSeqStreamType  pStream,
    MCIDEVICEID wDeviceID,
    DWORD   dwFlags,
    LPMCI_GETDEVCAPS_PARMS  lpCapParms)
{
    if (!(dwFlags & MCI_GETDEVCAPS_ITEM)) {
        dprintf1(("msGetDevCaps - no capability requested"));
        return MCIERR_MISSING_PARAMETER;
    }

    switch (lpCapParms->dwItem) {
    case MCI_GETDEVCAPS_HAS_AUDIO:
    case MCI_GETDEVCAPS_COMPOUND_DEVICE:
    case MCI_GETDEVCAPS_USES_FILES:
    case MCI_GETDEVCAPS_CAN_PLAY:


        if (midiOutGetNumDevs()) {
            dprintf2(("msGetDevCaps - %d midi out port(s) found",
                        midiOutGetNumDevs()));
            lpCapParms->dwReturn = (DWORD)MAKEMCIRESOURCE(TRUE, MCI_TRUE);
        } else {
            dprintf2(("msGetDevCaps - NO midi out ports found"));
            lpCapParms->dwReturn = (DWORD)MAKEMCIRESOURCE(FALSE, MCI_FALSE);
        }
        break;

    case MCI_GETDEVCAPS_CAN_EJECT:
    case MCI_GETDEVCAPS_CAN_RECORD:
    case MCI_GETDEVCAPS_HAS_VIDEO:
    case MCI_GETDEVCAPS_CAN_SAVE:
        lpCapParms->dwReturn = (DWORD)MAKEMCIRESOURCE(FALSE, MCI_FALSE);
        break;

    case MCI_GETDEVCAPS_DEVICE_TYPE:
        lpCapParms->dwReturn = (DWORD)MAKEMCIRESOURCE(MCI_DEVTYPE_SEQUENCER, MCI_DEVTYPE_SEQUENCER);
        break;

    default:
        return MCIERR_MISSING_PARAMETER;
    }
    return MCI_RESOURCE_RETURNED;
 }

/*---------------------------------------------------------------------------*/
PUBLIC  DWORD NEAR PASCAL msInfo(
    pSeqStreamType  pStream,
    MCIDEVICEID wDeviceID,
    DWORD   dwFlags,
    LPMCI_INFO_PARMS    lpInfo)
{
    UINT    wReturnLength;

    if (!lpInfo->lpstrReturn)
        return MCIERR_PARAM_OVERFLOW;
    dwFlags &= ~(MCI_NOTIFY | MCI_WAIT);
    if (dwFlags != (dwFlags & (MCI_INFO_PRODUCT | MCI_INFO_FILE)))
        return MCIERR_UNRECOGNIZED_KEYWORD;
    wReturnLength = (UINT)lpInfo->dwRetSize;
    *(lpInfo->lpstrReturn + wReturnLength - 1) = '\0';
    switch (dwFlags) {
    case MCI_INFO_PRODUCT:
        LoadString(hInstance, MSEQ_PRODUCTNAME, lpInfo->lpstrReturn, wReturnLength);
        break;
    case MCI_INFO_FILE:
        if (!pStream)
            return MCIERR_UNSUPPORTED_FUNCTION;
        else
            wcsncpy(lpInfo->lpstrReturn, (LPWSTR)pStream->szFilename, wReturnLength);
        break;
    default:
        return MCIERR_MISSING_PARAMETER;
    }


    if ( *(lpInfo->lpstrReturn + wReturnLength - 1) != '\0' ) {
        return MCIERR_PARAM_OVERFLOW;
    }
    else {
        lpInfo->dwRetSize = wcslen( lpInfo->lpstrReturn );
        return 0;
    }
}

/*---------------------------------------------------------------------------*/
PUBLIC  DWORD NEAR PASCAL msSet(
    pSeqStreamType  pStream,
    MCIDEVICEID wDeviceID,
    DWORD   dwFlags,
    LPMCI_SEQ_SET_PARMS lpSetParms)
{
    DWORD   dwReturn;

    dwFlags &= ~(MCI_NOTIFY | MCI_WAIT | MCI_SET_ON | MCI_SET_OFF);
    if (dwFlags != (dwFlags & (MCI_SEQ_SET_TEMPO | MCI_SEQ_SET_PORT | MCI_SEQ_SET_SLAVE | MCI_SEQ_SET_MASTER | MCI_SEQ_SET_OFFSET | MCI_SET_AUDIO | MCI_SET_VIDEO | MCI_SET_DOOR_OPEN | MCI_SET_DOOR_CLOSED | MCI_SET_TIME_FORMAT)))
        return MCIERR_UNRECOGNIZED_KEYWORD;
    dwReturn = 0; // no error by default
    switch (dwFlags) {
        UINT    wPort;
        MMTIME  mmOffset;

    case MCI_SET_TIME_FORMAT:
        switch ((UINT)lpSetParms->dwTimeFormat) {
        case MCI_FORMAT_SMPTE_30DROP:
        case MCI_FORMAT_SMPTE_30:
        case MCI_FORMAT_SMPTE_25:
        case MCI_FORMAT_SMPTE_24:
        case MCI_FORMAT_MILLISECONDS:
            pStream->userDisplayType = lpSetParms->dwTimeFormat;
            break;
        case MCI_SEQ_FORMAT_SONGPTR:
            if (pStream->fileDivType == SEQ_DIV_PPQN)
                pStream->userDisplayType = lpSetParms->dwTimeFormat;
            else
                dwReturn = MCIERR_SEQ_DIV_INCOMPATIBLE;
            break;
        default:
            dwReturn = MCIERR_BAD_TIME_FORMAT;
            break;
        }
        break;
    case MCI_SEQ_SET_TEMPO:
        dwReturn = (DWORD)midiSeqMessage(pStream->hSeq, SEQ_SETTEMPO, lpSetParms->dwTempo, 0L);
        break;
    case MCI_SEQ_SET_PORT:
        wPort = (UINT)lpSetParms->dwPort; // else use # passed in
        if (wPort == MCI_SEQ_NONE) {
            midiSeqMessage(pStream->hSeq, SEQ_SETPORTOFF, TRUE, 0L);
            pStream->wPortNum = MCI_SEQ_NONE; //store port num (so can return "none")
        } else if (!midiOutGetNumDevs())
            dwReturn = MCIERR_SEQ_NOMIDIPRESENT;
        else if ((wPort != MIDI_MAPPER) && (wPort >= midiOutGetNumDevs()))
            dwReturn = MCIERR_SEQ_PORT_NONEXISTENT;
        else if (wPort != pStream->wPortNum) { // ignore if using wPort already
            MIDISEQINFO seqInfo;

            // it's 0, 1...., or MAPPER

            pStream->wPortNum = wPort; //store port number
            midiSeqMessage(pStream->hSeq, SEQ_GETINFO, (DWORD_PTR)(LPMIDISEQINFO)&seqInfo, 0L);
            if (seqInfo.bPlaying) {
                midiSeqMessage(pStream->hSeq, SEQ_SETPORTOFF, TRUE, 0L);
                dwReturn = OpenMidiPort(pStream);
            }
        }
        break;
    case MCI_SEQ_SET_SLAVE:
        switch (lpSetParms->dwSlave) {
        case MCI_SEQ_SMPTE:
        case MCI_SEQ_MIDI:
            dwReturn = MCIERR_UNSUPPORTED_FUNCTION;
            break;
        case MCI_SEQ_NONE:
            dwReturn = (DWORD)midiSeqMessage(pStream->hSeq, SEQ_SETSYNCSLAVE, SEQ_SYNC_NOTHING, 0L);
            break;
        case MCI_SEQ_FILE:
            dwReturn = (DWORD)midiSeqMessage(pStream->hSeq, SEQ_SETSYNCSLAVE, SEQ_SYNC_FILE, 0L);
            break;
        }
        break;
    case MCI_SEQ_SET_MASTER:
        switch (lpSetParms->dwMaster) {
        case MCI_SEQ_SMPTE:
        case MCI_SEQ_MIDI:
            dwReturn = MCIERR_UNSUPPORTED_FUNCTION;
            break;
        case MCI_SEQ_NONE:
            dwReturn = (DWORD)midiSeqMessage(pStream->hSeq, SEQ_SETSYNCMASTER, SEQ_SYNC_NOTHING, 0L);
            break;
        }
        break;
    case MCI_SEQ_SET_OFFSET:
        mmOffset.u.smpte.hour = (BYTE)lpSetParms->dwOffset;
        mmOffset.u.smpte.min = (BYTE)(lpSetParms->dwOffset >> 8);
        mmOffset.u.smpte.sec = (BYTE)(lpSetParms->dwOffset >> 16);
        mmOffset.u.smpte.frame = (BYTE)(lpSetParms->dwOffset >> 24);
        if ((lpSetParms->dwOffset & 0x80808080) || // all positive
            (mmOffset.u.smpte.hour > 23) ||
            (mmOffset.u.smpte.min > 59) ||
            (mmOffset.u.smpte.sec > 59) ||
            (mmOffset.u.smpte.frame > 29)) // allow max for all fmts
            dwReturn = MCIERR_OUTOFRANGE;
        else
            dwReturn = (DWORD)midiSeqMessage(pStream->hSeq, SEQ_SETSYNCSLAVE, SEQ_SYNC_OFFSET, (DWORD_PTR)(LPMMTIME)&mmOffset);
        break;
    case MCI_SET_AUDIO: //fall thru...
    case MCI_SET_VIDEO:
    case MCI_SET_DOOR_OPEN:
    case MCI_SET_DOOR_CLOSED:
        dwReturn = MCIERR_UNSUPPORTED_FUNCTION;
        break;
    default:
        dwReturn = MCIERR_MISSING_PARAMETER;
    }
    return dwReturn;
}

/*---------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciseq\mmseq.c ===
/*******************************Module*Header*********************************\
* Module Name: mmseq.c
*
* MultiMedia Systems MIDI Sequencer DLL
*
* Created: 4/10/90
* Author:  Greg Simons
*
* History:
*
* Copyright (c) 1985-1998 Microsoft Corporation
*
\******************************************************************************/
#define UNICODE


//MMSYSTEM
#define MMNOSOUND           - Sound support
#define MMNOWAVE            - Waveform support
#define MMNOAUX             - Auxiliary output support
#define MMNOJOY             - Joystick support
//MMDDK

#define NOWAVEDEV           - Waveform support
#define NOAUXDEV            - Auxiliary output support
#define NOJOYDEV            - Joystick support

#include <windows.h>
#include <memory.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "mmsys.h"
#include "list.h"
#include "mmseqi.h"
#include "mciseq.h"


static ListHandle seqListHandle;

// Debug macro which checks sequencer structure signature.

#ifdef DEBUG
#define DEBUG_SIG   0x45427947
#define ValidateNPSEQ(npSeq) ((npSeq)->dwDebug == DEBUG_SIG)
#endif

#define SeqSetTempo(npSeq, dwTempo)     ((npSeq)->tempo = (dwTempo))    // usec per tick

/* Setup strucure to handle meta event properly at real time.  Since meta
events can update time-critical internal variables **and optionally ** be
buffered and send out as well, we will defer from reading them until real
time. */
#define SetUpMetaEvent(npTrack) ((npTrack)->shortMIDIData.byteMsg.status = METAEVENT)

/**************************** PRIVATE FUNCTIONS *************************/

PUBLIC VOID NEAR PASCAL SkipBytes(NPTRACK npTrack, LONG length)
// skips "length" bytes in the given track.
{
    LONG i = 0;

    while (i < length)
    {
        GetByte(npTrack);
        if ((!npTrack->blockedOn) || (npTrack->endOfTrack))
            i++;
        else
            break;
    }

    npTrack->dwBytesLeftToSkip = length - i; // remember for next time
    return;
}

/**********************************************************/
PRIVATE DWORD NEAR PASCAL GetMotorola24(NPTRACK npTrack)
// reads integer in 24 bit motorola format from the given track
{
    WORD    w;

    w = (WORD)GetByte(npTrack) << 8;
    w += GetByte(npTrack);
    return ((DWORD)w << 8) + GetByte(npTrack);
}

PRIVATE DWORD NEAR PASCAL MStoTicks(NPSEQ npSeq, DWORD dwMs)
/*  Convert milliseconds into ticks (some unit of time) in the given
    file.  If it's a ppqn file, this conversion totally depends on the
    tempo map (which tells what tempo changes happen at what times).
*/
{
    NPTEMPOMAPELEMENT npFrontTME;
    NPTEMPOMAPELEMENT npBehindTME;
    DWORD dwElapsedMs;
    DWORD dwElapsedTicks;
    DWORD dwTotalTicks;

    npBehindTME = NULL; // behind tempo map item:  starts null

    // Find the last element that's before the time passed in
    npFrontTME = (NPTEMPOMAPELEMENT) List_Get_First(npSeq->tempoMapList);
    while ((npFrontTME) && (npFrontTME->dwMs <= dwMs))
    {
        npBehindTME = npFrontTME;
        npFrontTME = (NPTEMPOMAPELEMENT) List_Get_Next(npSeq->tempoMapList, npFrontTME);
    }

    if (!npBehindTME)
        return (DWORD)-1L; //fail bad -- list was empty, or no dwMs = 0 item

    // Great, we found it.  Now just extrapolate, and return result.
    dwElapsedMs = dwMs - npBehindTME->dwMs;
        //compute dwet = dwems * 1000 / dwtempo
        // (ticks from last tempo chg to here)
    dwElapsedTicks = muldiv32(dwElapsedMs, 1000, npBehindTME->dwTempo);
        // ticks from beginning of file to here
    dwTotalTicks = npBehindTME->dwTicks + dwElapsedTicks;
    return  dwTotalTicks;
}

PRIVATE DWORD NEAR PASCAL TickstoMS(NPSEQ npSeq, DWORD dwTicks)
/*  Convert ticks (some unit of time) into milliseconds in the given
    file.  If it's a ppqn file, this conversion totally depends on the
    tempo map (which tells what tempo changes happen at what times).
*/
{
    NPTEMPOMAPELEMENT npFrontTME;
    NPTEMPOMAPELEMENT npBehindTME;
    DWORD dwRet;
    DWORD dwElapsedTicks;

    npBehindTME = NULL;

    // Find the last element that's before the ticks passed in
    npFrontTME = (NPTEMPOMAPELEMENT) List_Get_First(npSeq->tempoMapList);
    while ((npFrontTME) && (npFrontTME->dwTicks <= dwTicks))
    {
        npBehindTME = npFrontTME;
        npFrontTME = (NPTEMPOMAPELEMENT) List_Get_Next(npSeq->tempoMapList, npFrontTME);
    }

    if (!npBehindTME)
        return (DWORD)-1L; //fail bad -- list was empty, or didn't have tick = 0 item

    // Great, found it!  Now extrapolate and return result.
    dwElapsedTicks = dwTicks - npBehindTME->dwTicks;
    dwRet =  npBehindTME->dwMs + muldiv32(dwElapsedTicks,
                npBehindTME->dwTempo, 1000);

//           (((dwTicks - npBehindTME->dwTicks) * npBehindTME->dwTempo)
//           / 1000);  // remember, tempo in microseconds per tick
    return dwRet;
}

PRIVATE BOOL NEAR PASCAL AddTempoMapItem(NPSEQ npSeq, DWORD dwTempo, DWORD dwTicks)
/*  given a tempo change to dwTempo, happening at time dwTicks, in
    sequence npSeq, allocate a tempo map element, and put it at the
    end of the list.  Return false iff memory alloc error.
*/

{
    NPTEMPOMAPELEMENT npNewTME;
    NPTEMPOMAPELEMENT npLastTME;
    NPTEMPOMAPELEMENT npTestTME;
    DWORD dwElapsedTicks;

    npLastTME = NULL;

    // Find last tempo map element
    npTestTME = (NPTEMPOMAPELEMENT) List_Get_First(npSeq->tempoMapList);
    while (npTestTME)
    {
        npLastTME = npTestTME;
        npTestTME = (NPTEMPOMAPELEMENT) List_Get_Next(npSeq->tempoMapList, npTestTME);
    }

    // Allocate new element
    if (!(npNewTME = (NPTEMPOMAPELEMENT) List_Allocate(npSeq->tempoMapList)))
        return FALSE; // failure

    List_Attach_Tail(npSeq->tempoMapList, (NPSTR) npNewTME);

    npNewTME->dwTicks = dwTicks;  // these fields are always the same
    npNewTME->dwTempo = dwTempo;

    // ms field depends on last element
    if (!npLastTME)  // if list was empty
        npNewTME->dwMs = 0;
    else  // base new element data on last element
    {
        dwElapsedTicks = dwTicks - npLastTME->dwTicks;
        npNewTME->dwMs = npLastTME->dwMs + ((npLastTME->dwTempo * dwElapsedTicks)
                                                                   / 1000);
    }
    return TRUE; // success
}

PRIVATE VOID NEAR PASCAL SetBit(BitVector128 *bvPtr, UINT wIndex, BOOL On)
/* Affect "index" bit of filter pointed to by "bvPtr."
   If On then set the bit, else clear it. */
{
    UINT    mask;

    mask = 1 << (wIndex & 0x000F);
    wIndex >>= 4;
    if (On)
        bvPtr->filter[wIndex] |= mask;      // set the bit
    else
        bvPtr->filter[wIndex] &= (~mask); // clear the bit
}

PRIVATE BOOL NEAR PASCAL GetBit(BitVector128 *bvPtr, int index)
/*  If the bit indicated by "index" is set, return true,
    else return false */
{
    UINT    mask;

    mask = 1 << (index & 0x000F);
    index >>= 4;
    return (bvPtr->filter[index] & mask); // returns true iff bit set
}

PRIVATE VOID NEAR PASCAL AllNotesOff(NPSEQ npSeq, HMIDIOUT hMIDIPort)
// Sends a note off for every key and every channel that is on,
// according to npSeq->keyOnBitVect
{
    ShortMIDI myShortMIDIData;
    UINT channel;
    UINT key;

    if (hMIDIPort)
        for(channel = 0; channel < 16; channel++)
        {
            // sustain pedal off for all channels
            myShortMIDIData.byteMsg.status= (BYTE) (0xB0 + channel);
            myShortMIDIData.byteMsg.byte2 = (BYTE) 0x40;
            myShortMIDIData.byteMsg.byte3 = 0x0;
            midiOutShortMsg(hMIDIPort, myShortMIDIData.wordMsg);

            // now do note offs
            myShortMIDIData.byteMsg.status= (BYTE) (0x80 + channel);
            myShortMIDIData.byteMsg.byte3 = 0x40;  // release velocity
            for(key = 0; key < 128; key++)
            {
                if (GetBit(&npSeq->keyOnBitVect[channel], key)) // is key "on" ?
                {
                    myShortMIDIData.byteMsg.byte2 = (BYTE) key;
                        // turn it off
                        // doubly, for layered synths (2 on STOP 2 off)
                    midiOutShortMsg(hMIDIPort, myShortMIDIData.wordMsg);

                    // remember that it's off
                    SetBit(&npSeq->keyOnBitVect[channel], key, FALSE);
                }
            }
        }
}

PRIVATE NPSEQ NEAR PASCAL InitASeq(LPMIDISEQOPENDESC lpOpen,
        int divisionType, int resolution)
//  Create a sequence by allocating a sequence data structure for it.
//  Put it in the sequence list.

{
    NPSEQ       npSeqNew;
    ListHandle  hListTrack;
    ListHandle  hTempoMapList;
    int         buff;

    if (!seqListHandle)
    {
        seqListHandle = List_Create((LONG)sizeof(SEQ), 0L);
        if (seqListHandle == NULLLIST)
            return(NULL);
    }

    // allocate the sequence structure
    npSeqNew = pSEQ(List_Allocate(seqListHandle));
    if (!npSeqNew)
        return(NULL);

    // create the sequence's track list
    hListTrack = List_Create((LONG) sizeof(TRACK), 0L);
    if (hListTrack == NULLLIST)
    {
        List_Deallocate(seqListHandle, (NPSTR) npSeqNew);
        return(NULL);
    }

    // create the sequence's tempo map list
    hTempoMapList = List_Create((LONG) sizeof(TempoMapElement), 0L);
    if (hTempoMapList == NULLLIST)
    {
        List_Deallocate(seqListHandle, (NPSTR) npSeqNew);
        List_Destroy(hListTrack);
        return(NULL);
    }

    // set these sequencer fields to default values
    _fmemset(npSeqNew, 0, sizeof(SEQ));
    npSeqNew->divType           = divisionType;
    npSeqNew->resolution        = resolution;
    npSeqNew->slaveOf           = SEQ_SYNC_FILE;
    npSeqNew->seekTicks         = NotInUse;
    // set these sequencer fields to specific values already derived
    npSeqNew->trackList         = hListTrack;
    npSeqNew->tempoMapList      = hTempoMapList;
    npSeqNew->hStream           = lpOpen->hStream;
    npSeqNew->fwFlags           = LEGALFILE; // assume good till proven otherwise

    for (buff = 0; buff < NUMSYSEXHDRS + 1; buff++)
    {
        npSeqNew->longMIDI[buff].midihdr.lpData =
            (LPSTR) &npSeqNew->longMIDI[buff].data; // resolve data ptr
        // make buffer refer to seq so can find owner on callback
        npSeqNew->longMIDI[buff].midihdr.dwUser = (DWORD_PTR)(LPVOID)npSeqNew;
        npSeqNew->longMIDI[buff].midihdr.dwFlags |= MHDR_DONE; //just set done bit
    }

    // initialize internal filter on meta events to ignore all but
    // tempo, time signature, smpte offset, and end of track meta events.
    SetBit(&npSeqNew->intMetaFilter, TEMPOCHANGE, TRUE); // accept int tempo changes
    SetBit(&npSeqNew->intMetaFilter, ENDOFTRACK, TRUE); // accept int end of track
    SetBit(&npSeqNew->intMetaFilter, SMPTEOFFSET, TRUE); // accept int SMPTE offset
    SetBit(&npSeqNew->intMetaFilter, TIMESIG, TRUE); // accept int time sig
    SetBit(&npSeqNew->intMetaFilter, SEQSTAMP, TRUE);

    // put sequence in global list of all sequences
    List_Attach_Tail(seqListHandle, (NPSTR) npSeqNew);

    return npSeqNew;
}

PRIVATE DWORD NEAR PASCAL InitTempo(int divType, int resolution)
{
    DWORD ticksPerMinute;
    DWORD tempo;

    // set tempo to correct default (120 bpm or 24, 25, 30 fps).
    switch (divType)
    {
        case SEQ_DIV_PPQN:
            ticksPerMinute = (DWORD) DefaultTempo * resolution;
        break;

        case SEQ_DIV_SMPTE_24:
            ticksPerMinute = ((DWORD) (24 * 60)) * resolution; // 24 frames per second
        break;

        case SEQ_DIV_SMPTE_25:
            ticksPerMinute = ((DWORD) (25 * 60)) * resolution;
        break;

        case SEQ_DIV_SMPTE_30:
        case SEQ_DIV_SMPTE_30DROP:
            ticksPerMinute = ((DWORD) (30 * 60)) * resolution;
        break;
    }
    tempo = USecPerMinute / ticksPerMinute;
    return(tempo);
}

PRIVATE BOOL NEAR PASCAL SetUpToPlay(NPSEQ npSeq)
/*  After the sequence has been initialized and "connected" to the streamer,
    this function should be called.  It scans the file to create a tempo
    map, set up for the patch-cache message, and determine the length of
    the file.  (Actually, it just set's this process in motion, and much
    of the important code is in the blocking/unblocking logic.)

    Returns false only if there's a fatal error (e.g. memory alloc error),
    else true.
*/

{
    BOOL tempoChange;

    // set tempo to 120bpm or normal SMPTE frame rate
    //npSeq->tempo = InitTempo(npSeq->divType, npSeq->resolution);
    SeqSetTempo(npSeq, InitTempo(npSeq->divType, npSeq->resolution));

    if (!(AddTempoMapItem(npSeq, npSeq->tempo, 0L)))
        return FALSE;

    if (npSeq->slaveOf != SEQ_SYNC_FILE)
        tempoChange = FALSE;
    else
        tempoChange = TRUE;
    SetBit(&npSeq->intMetaFilter,TEMPOCHANGE, tempoChange);

    ResetToBeginning(npSeq); // this is considered reset 1
    SetBlockedTracksTo(npSeq, on_input, in_rewind_1); // 'mature' the input block state
    /* In state code, goes on to reset, scan early metas, build tempo
       map, and reset again, set tempo to 120bpm or normal SMPTE frame rate
       fill in the tracks (search to song pointer value) and then sets
       "ready to play."  Iff npSeq->playing, then plays the sequence.
    */
    return TRUE;
}

PRIVATE VOID NEAR PASCAL Destroy(NPSEQ npSeq)
{
    int      buff;

    Stop(npSeq);    // among other things, this cancels any pending callbacks
    List_Destroy(npSeq->trackList);           //destroys track data
    List_Destroy(npSeq->tempoMapList);        //destroys tempo map
    if (npSeq->npTrkArr)
        LocalFree((HANDLE)npSeq->npTrkArr);   // free track array
                                    // (ptr == handle since lmem_fixed)

    if (npSeq->hMIDIOut)  // should have already been closed -- but just in case
        for (buff = 0; buff < NUMSYSEXHDRS; buff++)
            midiOutUnprepareHeader(npSeq->hMIDIOut,
                (LPMIDIHDR) &npSeq->longMIDI[buff].midihdr,
                sizeof(npSeq->longMIDI[buff].midihdr));

    List_Deallocate(seqListHandle, (NPSTR) npSeq);    // deallocate memory
}

PRIVATE int NEAR PASCAL MIDILength(BYTE status) /* returns length of various MIDI messages */
{
    if (status & 0x80) // status byte since ms bit set
    {
        switch (status & 0xf0)      // look at ms nibble
        {
            case 0x80:              // note on
            case 0x90:              // note off
            case 0xA0:              // key aftertouch
            case 0xB0:              // cntl change or channel mode
            case 0xE0: return 3;    // pitch bend

            case 0xC0:              // pgm change
            case 0xD0: return 2;    // channel pressure

            case 0xF0:              // system
            {
                switch (status & 0x0F)  // look at ls nibble
                {
                    // "system common"
                    case 0x0: return SysExCode;    // sysex:  variable size
                    case 0x1:              // 2 MTC Q-Frame
                    case 0x3: return 2;    // 2 Song Select
                    case 0x2: return 3;    // 3 Song Pos Ptr
                    case 0x4:              // 0 undefined
                    case 0x5: return 0;    // 0 undefined
                    case 0x6:              // 1 tune request
                    case 0x7: return 1;    // 1 end of sysex (not really a message)

                    // "system real-time"
                    case 0x8:               // 1 timing clock
                    case 0xA:               // 1 start
                    case 0xB:               // 1 continue
                    case 0xC:               // 1 stop
                    case 0xE: return 1;     // 1 active sensing
                    case 0x9:               // 0 undefined
                    case 0xD: return 0;     // 0 undefined
                            /* 0xFF is really system reset, but is used
                            as a meta event header in MIDI files. */
                    case 0xF: return(MetaEventCode);
                } // case ls
            }// sytem messages
        } // case ms
    } // if status
//    else
        return 0;  // 0 undefined not a status byte
} // MIDILength

PRIVATE LONG NEAR PASCAL GetVarLen(NPTRACK npTrack) // returns next variable length qty in track
{   // will have to account for end of track here (perhaps change GetByte)
    int     count = 1;
    BYTE    c;
    LONG    delta;

    if ((delta = GetByte(npTrack)) & 0x80)    /* gets the next delta */
    {
        delta &= 0x7f;
        do
        {
            delta = (delta << 7) + ((c = GetByte(npTrack)) & 0x7f);
            count++;
        }
        while (c & 0x80);
    }

    if (count > 4)          /* 4 byte max on deltas */
    {
        dprintf1(("BOGUS DELTA !!!!"));
        return 0x7fffffff;
    }
    else
        return delta;
}

PRIVATE VOID NEAR PASCAL SkipEvent(BYTE status, NPTRACK npTrack)
// skips event in track, based on status byte passed in.
{
    LONG length;

    if ((status == METAEVENT) || (status == SYSEX) || (status == SYSEXF7))
        length = GetVarLen(npTrack);
    else
        length = MIDILength(status) -1 ;// -1 becuase already read status
    if ((!npTrack->blockedOn) && (length))
    {
        SkipBytes(npTrack, length);
        if (npTrack->blockedOn)
            npTrack->blockedOn = in_SkipBytes_ScanEM;
    }
    return;
}

PRIVATE VOID NEAR PASCAL FlushMidi(HMIDIOUT hMidiOut, LongMIDI * pBuf)
{
    if (pBuf->midihdr.dwBufferLength) {
        midiOutLongMsg(hMidiOut, &pBuf->midihdr, sizeof(MIDIHDR));
        pBuf->midihdr.dwBufferLength = 0;
    }
}

PRIVATE VOID NEAR PASCAL SetData(HMIDIOUT hMidiOut, LongMIDI * pBuf,
                                  ShortMIDI Data, int length)
{
    if (LONGBUFFSIZE < pBuf->midihdr.dwBufferLength + length) {
        FlushMidi(hMidiOut, pBuf);
    }

    pBuf->data[pBuf->midihdr.dwBufferLength++] = Data.byteMsg.status;

    if (length > 1) {
        pBuf->data[pBuf->midihdr.dwBufferLength++] = Data.byteMsg.byte2;
        if (length > 2) {
            pBuf->data[pBuf->midihdr.dwBufferLength++] = Data.byteMsg.byte3;
        }
    }
}

PRIVATE VOID NEAR PASCAL SendMIDI(NPSEQ npSeq, NPTRACK npTrack)
{
    ShortMIDI    myShortMIDIData;
    int     length;
    BYTE    status;
    BYTE    channel;
    BYTE    key;
    BYTE    velocity;
    BOOL    setBit;

    myShortMIDIData = npTrack->shortMIDIData;
    if ((length = MIDILength(myShortMIDIData.byteMsg.status)) <= 3)
    {
        if (npSeq->hMIDIOut)
        {
            //send short MIDI message

            //maintain note on/off structure
            status = (BYTE)((myShortMIDIData.byteMsg.status) & 0xF0);
            if ((status == 0x80) || (status == 0x90)) // note on or off
            {
                channel =   (BYTE)((myShortMIDIData.byteMsg.status) & 0x0F);
                key =       myShortMIDIData.byteMsg.byte2;
                velocity =  myShortMIDIData.byteMsg.byte3;

                //
                //  Only play channels 1 to 12 for marked files
                //
                if ((npSeq->fwFlags & GENERALMSMIDI) && channel >= 12) {
                    return;
                }

                if ((status == 0x90) && (velocity != 0)) // note on
                {
                    setBit = TRUE;
                    if (GetBit(&npSeq->keyOnBitVect[channel], key))
                    // are we hitting a key that's ALREADY "on" ?
                    {   // if so, turn it OFF
                        myShortMIDIData.byteMsg.status &= 0xEF; //9x->8x
                        SetData(npSeq->hMIDIOut,
                                &npSeq->longMIDI[NUMSYSEXHDRS],
                                myShortMIDIData,
                                length);
                        // midiOutShortMsg(npSeq->hMIDIOut, myShortMIDIData.wordMsg);
                        myShortMIDIData.byteMsg.status |= 0x10; //8x->9x
                    }
                }
                else
                    setBit = FALSE;
                SetBit(&npSeq->keyOnBitVect[channel], key, setBit);
            }
            SetData(npSeq->hMIDIOut,
                    &npSeq->longMIDI[NUMSYSEXHDRS],
                    myShortMIDIData,
                    length);
            // midiOutShortMsg(npSeq->hMIDIOut, myShortMIDIData.wordMsg);
        }
    }
}

PRIVATE VOID NEAR PASCAL SubtractAllTracks(NPSEQ npSeq, LONG subValue) // subtract subvalue from every track
{
    NPTRACK npTrack;

    if (subValue)  // ignore if zero
    {
        npTrack = (NPTRACK) List_Get_First(npSeq->trackList);
        while (npTrack)      /* subtract this delta from all others */
        {
            if (npTrack->delta != TrackEmpty)
                npTrack->delta -= subValue;
            npTrack = (NPTRACK) List_Get_Next(npSeq->trackList, npTrack);
        }
    }
}

PRIVATE VOID NEAR PASCAL SetUpSysEx(NPTRACK npTrack, BYTE status)
/*  Handle similar to Metas (don't prebuffer, since several tracks could
    have sysex, and we only have 2 buffers */
{
    npTrack->shortMIDIData.byteMsg.status = status;
    npTrack->sysExRemLength = GetVarLen(npTrack);
}

PRIVATE VOID NEAR PASCAL GetShortMIDIData(NPTRACK npTrack, BYTE status, int length)
{
    npTrack->shortMIDIData.byteMsg.status = status;

    if (length >= 2)
    {
        npTrack->shortMIDIData.byteMsg.byte2 = GetByte(npTrack);
        if (length == 3)
            npTrack->shortMIDIData.byteMsg.byte3 = GetByte(npTrack);
    }
}

PRIVATE BYTE NEAR PASCAL GetStatus(NPTRACK npTrack)
// returns correct status byte, taking running status fully into account.
{
    BYTE firstByte;
    BYTE status;

    if ((firstByte = LookByte(npTrack)) & 0x80)    // status byte??
    {
        firstByte = GetByte(npTrack); // actually get it if status
        if ((firstByte >= 0xF0) && (firstByte <= 0xF7))
        // sysex or sys common?
            npTrack->lastStatus = 0;    // cancel running status
        else if (firstByte < 0xF0)      // only use channel messages
            npTrack->lastStatus = firstByte; // else save it for running status
        status = firstByte; // return this as status byte regardless
    }
    else // 1st byte wasn't a status byte
    {
        if (npTrack->lastStatus & 0x80)    // there was prev. running status
            status = npTrack->lastStatus; // return previous status
        else
            status = 0; // error
    }
    return status;
}

PRIVATE VOID NEAR PASCAL FillInEvent(NPTRACK npTrack)
{
    BYTE    status;

    if (!npTrack->blockedOn)
    {
        status = GetStatus(npTrack);
        if (!npTrack->blockedOn)
        {
            int    length;

            if ((length = MIDILength(status)) <= 3)
                GetShortMIDIData(npTrack, status, length);
            else if ((status == SYSEX) || (status == SYSEXF7))
                // set up for sysEx
                SetUpSysEx(npTrack, status);
            else if (status == METAEVENT)
                // set up for meta event
                SetUpMetaEvent(npTrack);
                else {
                    dprintf1(("Bogus long message encountered!!!"));
                }
        }
    }
}

PRIVATE UINT NEAR PASCAL SetTempo(NPSEQ npSeq, DWORD dwUserTempo)
// tempo passed in from user.  Convert from beats per minute or frames
// per second to internal format (microseconds per tick)
{
    DWORD dwTempo;

    if (!dwUserTempo) // zero is an illegal tempo!
        return MCIERR_OUTOFRANGE;
    if (npSeq->divType == SEQ_DIV_PPQN)
        dwTempo = USecPerMinute / (dwUserTempo * npSeq->resolution);
    else
        dwTempo = USecPerSecond / (dwUserTempo * npSeq->resolution);

    if (!dwTempo)
        dwTempo = 1;  // at least 1 usec per tick!  This is spec'ed max tempo

    SeqSetTempo(npSeq, dwTempo);

    if (npSeq->wTimerID)
    {
        DestroyTimer(npSeq); // recompute everything from current position
        npSeq->nextExactTime = timeGetTime();

        //
        // Bug fix - make everything happen on the timer thread instead
        // of calling TimerIntRoutine which can get deadlocked.
        //
        SetTimerCallback(npSeq, MINPERIOD, npSeq->dwTimerParam);
    }
    return MIDISEQERR_NOERROR;
}

/**************************** PUBLIC FUNCTIONS *************************/

/****************************************************************************
 *
 * @doc INTERNAL SEQUENCER
 *
 * @api DWORD | midiSeqMessage | Single entry point for Sequencer
 *
 * @parm HMIDISEQ | hMIDISeq | Handle to MIDI Sequence
 *
 * @parm UINT | wMessage | The requested action to be performed.
 *
 * @parm DWORD | dwParam1 | Data for this message.
 *
 * @parm DWORD | dwParam2 | Data for this message.
 *
 * @rdesc Sequencer error code (see mmseq.h).
 *
 ***************************************************************************/

PUBLIC  DWORD_PTR FAR PASCAL midiSeqMessage(
        HMIDISEQ        hMIDISeq,
        UINT    wMessage,
        DWORD_PTR   dwParam1,
        DWORD_PTR   dwParam2)
{
        if (wMessage == SEQ_OPEN)
                return CreateSequence((LPMIDISEQOPENDESC)dwParam1, (LPHMIDISEQ)dwParam2);
        if (!hMIDISeq)
                return MIDISEQERR_INVALSEQHANDLE;
        switch (wMessage) {
        case SEQ_CLOSE:
                Destroy(pSEQ(hMIDISeq));
                break;
        case SEQ_PLAY:
                return Play(pSEQ(hMIDISeq), (DWORD)dwParam1);
        case SEQ_RESET:
                // set song pointer to beginning of the sequence;
                return midiSeqMessage(hMIDISeq, SEQ_SETSONGPTR, 0L, 0L);
        case SEQ_SETSYNCMASTER:
                switch ((WORD)dwParam1) {
                case SEQ_SYNC_NOTHING:
                        pSEQ(hMIDISeq)->masterOf = LOWORD(dwParam1);
                        break;
                case SEQ_SYNC_MIDI:             // not yet implemented...
                case SEQ_SYNC_SMPTE:
                        return MIDISEQERR_INVALPARM;
                case SEQ_SYNC_OFFSET:      // in both master and slave (same)
                        pSEQ(hMIDISeq)->smpteOffset = *((LPMMTIME) dwParam2);
                        break;
                default:
                        return MIDISEQERR_INVALPARM;
                }
                break;
        case SEQ_SETSYNCSLAVE:      // what we should slave to
                switch ((WORD)dwParam1) {
                case SEQ_SYNC_NOTHING:
                        // don't accept internal tempo changes;
                        SetBit(&pSEQ(hMIDISeq)->intMetaFilter, TEMPOCHANGE, FALSE);
                        pSEQ(hMIDISeq)->slaveOf = LOWORD(dwParam1);
                        break;
                case SEQ_SYNC_FILE:
                        // accept internal tempo changes;
                        SetBit(&pSEQ(hMIDISeq)->intMetaFilter, TEMPOCHANGE, TRUE);
                        pSEQ(hMIDISeq)->slaveOf = LOWORD(dwParam1);
                        break;
                case SEQ_SYNC_SMPTE:  //  not yet implemented...
                case SEQ_SYNC_MIDI:
                        return MIDISEQERR_INVALPARM;
                case SEQ_SYNC_OFFSET:      // in both master and slave (same)
                        pSEQ(hMIDISeq)->smpteOffset = *((LPMMTIME)dwParam2);
                        break;
                default:
                        return MIDISEQERR_INVALPARM;
                }
                break;
        case SEQ_MSTOTICKS: // given an ms value, convert it to ticks
                *((DWORD FAR *)dwParam2) = MStoTicks(pSEQ(hMIDISeq), (DWORD)dwParam1);
                break;
        case SEQ_TICKSTOMS: // given a tick value, convert it to ms
                *((DWORD FAR *)dwParam2) = TickstoMS(pSEQ(hMIDISeq), (DWORD)dwParam1);
                break;
        case SEQ_SETTEMPO:
                return SetTempo(pSEQ(hMIDISeq), (DWORD)dwParam1);
        case SEQ_SETSONGPTR:
                // remember it in case blocked;
                if (pSEQ(hMIDISeq)->divType == SEQ_DIV_PPQN) // div 4 16th->1/4 note
                        pSEQ(hMIDISeq)->seekTicks = (DWORD)((dwParam1 * pSEQ(hMIDISeq)->resolution) / 4);
                else
                        pSEQ(hMIDISeq)->seekTicks = (DWORD)dwParam1 * pSEQ(hMIDISeq)->resolution; // frames
                SeekTicks(pSEQ(hMIDISeq));
                break;
        case SEQ_SEEKTICKS:
                pSEQ(hMIDISeq)->wCBMessage = wMessage; // remember message type
                // No break;
        case SEQ_SYNCSEEKTICKS:
                // finer resolution than song ptr command;
                pSEQ(hMIDISeq)->seekTicks = (DWORD)dwParam1;
                SeekTicks(pSEQ(hMIDISeq));
                break;
        case SEQ_SETUPTOPLAY:
                if (!(SetUpToPlay(pSEQ(hMIDISeq)))) {
                        Destroy(pSEQ(hMIDISeq));
                        return MIDISEQERR_NOMEM;
                }
                break;
        case SEQ_STOP:
                Stop(pSEQ(hMIDISeq));
                break;
        case SEQ_TRACKDATA:
                if (!dwParam1)
                        return MIDISEQERR_INVALPARM;
                else
                        return NewTrackData(pSEQ(hMIDISeq), (LPMIDISEQHDR)dwParam1);
        case SEQ_GETINFO:
                if (!dwParam1)
                        return MIDISEQERR_INVALPARM;
                else
                        return GetInfo(pSEQ(hMIDISeq), (LPMIDISEQINFO) dwParam1);
        case SEQ_SETPORT:
                {
                        UINT    wRet;

                        if (MMSYSERR_NOERROR !=
                            (wRet =
                             midiOutOpen(&pSEQ(hMIDISeq)->hMIDIOut,
                                         (DWORD)dwParam1,
                                         (DWORD_PTR)MIDICallback,
                                         0L,
                                         CALLBACK_FUNCTION)))
                                return wRet;
                        if (MMSYSERR_NOERROR !=
                            (wRet = SendPatchCache(pSEQ(hMIDISeq), TRUE))) {
                                midiOutClose(pSEQ(hMIDISeq)->hMIDIOut);
                                pSEQ(hMIDISeq)->hMIDIOut = NULL;
                                return wRet;
                        }
                        for (wRet = 0; wRet < NUMSYSEXHDRS + 1; wRet++) {
                                midiOutPrepareHeader(pSEQ(hMIDISeq)->hMIDIOut, (LPMIDIHDR)&pSEQ(hMIDISeq)->longMIDI[wRet].midihdr, sizeof(pSEQ(hMIDISeq)->longMIDI[wRet].midihdr));
                                pSEQ(hMIDISeq)->longMIDI[wRet].midihdr.dwFlags |= MHDR_DONE;
                        }
                        break;
                }
        case SEQ_SETPORTOFF:
                if (pSEQ(hMIDISeq)->hMIDIOut) {
                        UINT    wHeader;
                        HMIDIOUT        hTempMIDIOut;

                        for (wHeader = 0; wHeader < NUMSYSEXHDRS + 1; wHeader++)
                                midiOutUnprepareHeader(pSEQ(hMIDISeq)->hMIDIOut, (LPMIDIHDR)&pSEQ(hMIDISeq)->longMIDI[wHeader].midihdr, sizeof(pSEQ(hMIDISeq)->longMIDI[wHeader].midihdr));
                        hTempMIDIOut = pSEQ(hMIDISeq)->hMIDIOut;
                        pSEQ(hMIDISeq)->hMIDIOut = NULL;  // avoid notes during "notesoff"
                        if ((BOOL)dwParam1)
                                AllNotesOff(pSEQ(hMIDISeq), hTempMIDIOut);
                        midiOutClose(hTempMIDIOut);
                }
                break;
        case SEQ_QUERYGENMIDI:
                return pSEQ(hMIDISeq)->fwFlags & GENERALMSMIDI;
        case SEQ_QUERYHMIDI:
                return (DWORD_PTR)pSEQ(hMIDISeq)->hMIDIOut;
        default:
                return MIDISEQERR_INVALMSG;
        }
        return MIDISEQERR_NOERROR;
}

/**********************************************************/

PRIVATE VOID NEAR PASCAL SeekTicks(NPSEQ npSeq)
/* Used for song pointer and seek ticks (same, but finer res.) command. */
{
    if (npSeq->playing)     // not a good idea to seek while playing!
        Stop(npSeq);

    if (npSeq->currentTick >= npSeq->seekTicks) // = because may have already
                                                // played current notes
    {
        // seeking behind:  must reset first
        npSeq->readyToPlay = FALSE;
        ResetToBeginning(npSeq); // tell streamer to start over
        // tell blocking logic what operation we're in
        SetBlockedTracksTo(npSeq, on_input, in_Seek_Tick);
    }
    else // seeking ahead in the file
    {
        if (GetNextEvent(npSeq) == NoErr)   // if there's a valid event set up
                                            // send ALL events in the file up through time = seekTicks
            SendAllEventsB4(npSeq, (npSeq->seekTicks - npSeq->currentTick),
                MODE_SEEK_TICKS);

        if ((AllTracksUnblocked(npSeq)) &&
            ((npSeq->currentTick + npSeq->nextEventTrack->delta)
            >= npSeq->seekTicks))  // Did we complete the operation??
        {
            npSeq->seekTicks = NotInUse;   // signify -- got there
            if (npSeq->wCBMessage == SEQ_SEEKTICKS)
                NotifyCallback(npSeq->hStream);
        }
        else
            npSeq->readyToPlay = FALSE; // didn't get there -- protect from play
    }
}

PUBLIC UINT NEAR PASCAL GetInfo(NPSEQ npSeq, LPMIDISEQINFO lpInfo)
/* Used to fulfill seqInfo command.  Fills in seq info structure passed in */
{
    // fill in the lpInfo structure
    lpInfo->wDivType        = (WORD)npSeq->divType;
    lpInfo->wResolution     = (WORD)npSeq->resolution;
    lpInfo->dwLength        = npSeq->length;
    lpInfo->bPlaying        = npSeq->playing;
    lpInfo->bSeeking        = !(npSeq->seekTicks == NotInUse);
    lpInfo->bReadyToPlay    = npSeq->readyToPlay;
    lpInfo->dwCurrentTick   = npSeq->currentTick;
    lpInfo->dwPlayTo        = npSeq->playTo;
    lpInfo->dwTempo         = npSeq->tempo;
//    lpInfo->bTSNum          = (BYTE) npSeq->timeSignature.numerator;
//    lpInfo->bTSDenom        = (BYTE) npSeq->timeSignature.denominator;
//    lpInfo->wNumTracks      = npSeq->wNumTrks;
//    lpInfo->hPort           = npSeq->hMIDIOut;
    lpInfo->mmSmpteOffset   = npSeq->smpteOffset;
    lpInfo->wInSync         = npSeq->slaveOf;
    lpInfo->wOutSync        = npSeq->masterOf;
    lpInfo->bLegalFile      = (BYTE)(npSeq->fwFlags & LEGALFILE);

    if (List_Get_First(npSeq->tempoMapList))
        lpInfo->tempoMapExists = TRUE;
    else
        lpInfo->tempoMapExists = FALSE;

    return MIDISEQERR_NOERROR;
}

PUBLIC UINT NEAR PASCAL CreateSequence(LPMIDISEQOPENDESC lpOpen,
        LPHMIDISEQ lphMIDISeq)
// Given a structure holding MIDI file header info, allocate and initialize
// all internal structures to play this file.  Return the allocated
// structure in lphMIDISeq.
{
    WORD    wTracks;
    int     division;
    int     divType;
    int     resolution;
    NPTRACK npTrackCur;
    NPSEQ   npSeq;
    BOOL    trackAllocError;
    WORD    iTrkNum;

    *lphMIDISeq = NULL;  // initially set up for error return

    if (lpOpen->dwLen < 6)         // header must be at least 6 bytes
        return MIDISEQERR_INVALPARM;

    wTracks = GETMOTWORD(lpOpen->lpMIDIFileHdr + sizeof(WORD));
    if (wTracks > MAXTRACKS)    // protect from random wTracks
        return MIDISEQERR_INVALPARM;

    division = (int)GETMOTWORD(lpOpen->lpMIDIFileHdr + 2 * sizeof(WORD));
    if (!(division & 0x8000))  // check division type:  smpte or ppqn
    {
        divType = SEQ_DIV_PPQN;
        resolution = division; // ticks per q-note
    }
    else // SMPTE
    {
        divType = -(division >> 8);  /* this will be -24, -25, -29 or -30 for
                 each different SMPTE frame rate.  Negate to make positive */
        resolution = (division & 0x00FF);
    }

    // allocate actual seq struct
    npSeq = InitASeq(lpOpen, divType, resolution);
    if (!npSeq)
        return MIDISEQERR_NOMEM;

    trackAllocError = FALSE;

    // allocate track array
    npSeq->npTrkArr =
        (NPTRACKARRAY) LocalAlloc(LMEM_FIXED, sizeof(NPTRACK) * wTracks);
    npSeq->wNumTrks = wTracks;
    if (!npSeq->npTrkArr)
        trackAllocError = TRUE;

    if (!trackAllocError)
        for (iTrkNum = 0; iTrkNum < wTracks; iTrkNum++)
        {
            if (!(npTrackCur = (NPTRACK) List_Allocate(npSeq->trackList)))
            {
                trackAllocError = TRUE;
                break;
            }
            // set trk array entry
            npSeq->npTrkArr->trkArr[iTrkNum] = npTrackCur;

            List_Attach_Tail(npSeq->trackList, (NPSTR) npTrackCur);
            if (npSeq->firstTrack == (NPTRACK) NULL)
                npSeq->firstTrack = npTrackCur; //1st track is special for metas

            npTrackCur->inPort.hdrList = NULL;
            npTrackCur->length = 0;
            npTrackCur->blockedOn = not_blocked;
            npTrackCur->dwCallback = (DWORD_PTR)lpOpen->dwCallback;
            npTrackCur->dwInstance = (DWORD_PTR)lpOpen->dwInstance;
            npTrackCur->sysExRemLength = 0;
            npTrackCur->iTrackNum = iTrkNum;
        }

    if (trackAllocError)
    {
        Destroy(npSeq); // dealloc seq related memory...
        return MIDISEQERR_NOMEM;
    }

    *lphMIDISeq = hSEQ(npSeq); /* Make what lphMIDISeq points to, point to
                                        sequence. */
    return MIDISEQERR_NOERROR;
}

PUBLIC VOID NEAR PASCAL SetBlockedTracksTo(NPSEQ npSeq,
            int fromState, int toState)
/*  Set all tracks that are blocked with a given state, to a new state */
{
    NPTRACK npTrack;

    npTrack = (NPTRACK) List_Get_First(npSeq->trackList);
    while (npTrack)
    {
        if (npTrack->blockedOn == fromState)
            npTrack->blockedOn = toState;
        npTrack = (NPTRACK) List_Get_Next(npSeq->trackList, npTrack);
    }
}

PUBLIC VOID NEAR PASCAL ResetToBeginning(NPSEQ npSeq)
/* set all globals and streams to play from beginning */
{
    NPTRACK  npTrack;

    npSeq->currentTick = 0;
    npSeq->nextExactTime = timeGetTime();

    npTrack = (NPTRACK) List_Get_First(npSeq->trackList);
    while (npTrack)
    {
        npTrack->delta = 0;
        npTrack->shortMIDIData.wordMsg = 0;
        npTrack->endOfTrack = FALSE;
        RewindToStart(npSeq, npTrack); /* reset stream to beginning of track
           (this basically entails freeing the buffers and setting a
           low-level block) */
        npTrack = (NPTRACK) List_Get_Next(npSeq->trackList, npTrack);
    }
}

PUBLIC UINT NEAR PASCAL Play(NPSEQ npSeq, DWORD dwPlayTo) /* play the sequence */
{
    npSeq->wCBMessage = SEQ_PLAY;

    if (dwPlayTo == PLAYTOEND)                  // default is play to end
        dwPlayTo = npSeq->length;

    if (npSeq->currentTick > npSeq->length) // illegal position in file
        return MIDISEQERR_ERROR;
    else if ((npSeq->playing) && (npSeq->playTo == dwPlayTo))
        return MIDISEQERR_NOERROR;  //do nothing, this play redundant
    else
    {
        if (npSeq->playing)
            Stop(npSeq);  // stop it before playing again

        npSeq->playing = TRUE;
        npSeq->nextExactTime = timeGetTime(); // start time of reference
        npSeq->playTo = dwPlayTo; // set limit

        if (!npSeq->bSetPeriod)
        {
            timeBeginPeriod(MINPERIOD);
            npSeq->bSetPeriod = TRUE;
        }
        if (npSeq->readyToPlay)
            //
            // Bug fix - make everything happen on the timer thread instead
            // of calling TimerIntRoutine which can get deadlocked.
            //
            return SetTimerCallback(npSeq, MINPERIOD, 0);
        else
            return MIDISEQERR_NOERROR;
        /* don't worry--if doesn't play here, it will start playing from state
        code in case where npSeq->playing == true (but may mask timer error). */
    }
}
/**********************************************************/
PUBLIC VOID NEAR PASCAL Stop(NPSEQ npSeq) /* stop the sequence */
{
    DestroyTimer(npSeq);
    if (npSeq->bSetPeriod) // only reset it once!
    {
        timeEndPeriod(MINPERIOD);
        npSeq->bSetPeriod = FALSE;
    }
    npSeq->playing = FALSE;
    AllNotesOff(npSeq, npSeq->hMIDIOut);
}

PUBLIC BOOL NEAR PASCAL HandleMetaEvent(NPSEQ npSeq, NPTRACK npTrack,
        UINT wMode) // called at time ready to send!!!
/*  Look at the meta event currently being pointed to in this track.
    Act on it accordingly.

    Ignore all except tempo change, end of track, time signature, and
    smpte offset.  Returns false only if tempo map allocation failed.

    wMode:  MODE_SEEK_TICKS, MODE_PLAYING, MODE_SCANEM: passed in by caller
    to indicate tempo map allocation, and how to mature blocking status.

    Caution:  wState must be FALSE when called at interrupt time!
    (This variable causes a tempo map element to be added to the tempo map
    list every time a tempo change meta event is encountered.)
*/
{
    BYTE    metaIDByte;
    int     bytesRead;
    LONG    length;
    DWORD   tempTempo;
    MMTIME  tempMM = {0, 0};
    TimeSigType tempTimeSig;
    BYTE    Manufacturer[3];

    // it is assumed at this point that the leading 0xFF status byte
    // has been read.
    metaIDByte = GetByte(npTrack);
    length = GetVarLen(npTrack);

    bytesRead = 0;
    if (GetBit(&npSeq->intMetaFilter, metaIDByte) && (!npTrack->blockedOn))
    /* only consider meta events that you've allowed to pass */
    {
        switch (metaIDByte)
        {
            case ENDOFTRACK: // end of track

                npTrack->endOfTrack = TRUE;
                break; // (read 0 bytes)

            case TEMPOCHANGE: // tempo change
                if (npTrack == npSeq->firstTrack)
                {
                    tempTempo = GetMotorola24(npTrack);
                    bytesRead = 3;
                    if (npTrack->blockedOn == not_blocked)
                    {
                        //npSeq->tempo = tempTempo / npSeq->resolution;
                        SeqSetTempo(npSeq, tempTempo / npSeq->resolution);
                        if (wMode == MODE_SCANEM)
                            if (!(AddTempoMapItem(npSeq, npSeq->tempo,
                                npTrack->length)))
                                return FALSE; // memory alloc failure !
                    }
                }
                break;

            case SMPTEOFFSET: // SMPTE Offset
                if (npTrack == npSeq->firstTrack)
                {
                    tempMM.u.smpte.hour = GetByte(npTrack);
                    tempMM.u.smpte.min = GetByte(npTrack);
                    tempMM.u.smpte.sec = GetByte(npTrack);
                    tempMM.u.smpte.frame = GetByte(npTrack);
                    //tempSMPTEOff.fractionalFrame = GetByte(npTrack); // add later?
                    bytesRead = 4;
                    if (npTrack->blockedOn == not_blocked)
                        npSeq->smpteOffset = tempMM;
                }
                break;

            case TIMESIG: // time signature
                // spec doesn't say, but probably only use if on track 1.
                tempTimeSig.numerator = GetByte(npTrack);
                tempTimeSig.denominator = GetByte(npTrack);
                tempTimeSig.midiClocksMetro = GetByte(npTrack);
                tempTimeSig.thirtySecondQuarter = GetByte(npTrack);
                bytesRead = 4;
                if (npTrack->blockedOn == not_blocked)
                    npSeq->timeSignature = tempTimeSig;
                break;

            case SEQSTAMP: // General MS midi stamp
                if ((length < 3) || npTrack->delta)
                    break;
                for (; bytesRead < 3;)
                    Manufacturer[bytesRead++] = GetByte(npTrack);
                if (!Manufacturer[0] && !Manufacturer[1] && (Manufacturer[2] == 0x41))
                    npSeq->fwFlags |= GENERALMSMIDI;
                break;

        } // end switch
    } // if metaFilter

    if (!npTrack->blockedOn)
    {
        SkipBytes(npTrack, length - bytesRead);// skip unexpected bytes (as per spec)
        if (npTrack->blockedOn)
            switch (wMode)  // mature blocking status
            {
                case MODE_SEEK_TICKS:
                    npTrack->blockedOn = in_SkipBytes_Seek;
                    break;

                case MODE_PLAYING:
                case MODE_SILENT:
                    npTrack->blockedOn = in_SkipBytes_Play;
                    break;

                case MODE_SCANEM:
                    npTrack->blockedOn = in_SkipBytes_ScanEM;
                    break;
            }
    }
    return TRUE;
}

PRIVATE BOOL NEAR PASCAL LegalMIDIFileStatus(BYTE status)
{
    if (status < 0x80)
        return FALSE;
    switch (status)
    {
        // legal case 0xf0:  sysex excape
        case 0xf1:
        case 0xf2:
        case 0xf3:
        case 0xf4:
        case 0xf5:
        case 0xf6:
        // legal case 0xf7:  no f0 sysex excape
        case 0xf8:
        case 0xf9:
        case 0xfA:
        case 0xfB:
        case 0xfC:
        case 0xfD:
        case 0xfE:
        // legal case 0xfF:  meta escape
            return FALSE;
            break;

        default:
            return TRUE;  // all other cases are legal status bytes
    }
}

PUBLIC BOOL NEAR PASCAL ScanEarlyMetas(NPSEQ npSeq, NPTRACK npTrack, DWORD dwUntil)
/*  Scan each track for meta events that affect the initialization
    of data such as tempo, time sig, key sig, SMPTE offset...
    If track passed in null, start at beginning of seq, else
    start with the track passed in.

    Warning:  the track parameter is for reentrancy in case of blocking.
    This function should be called with track NULL first, else ListGetNext
    will not function properly.

    This function assumes that all sequence tracks have been rewound.
    Returns false only on memory allocation error.
*/
{
    BYTE    status;
    BYTE    patch;
    BYTE    chan;
    BYTE    key;
    BOOL    bTempoMap;
    LONG    lOldDelta;

    #define BASEDRUMCHAN 15
    #define EXTENDDRUMCHAN 9
    #define NOTEON 0X90

    // determine if need to create a tempo map
    if (npSeq->divType == SEQ_DIV_PPQN)
        bTempoMap = TRUE;
    else
        bTempoMap = FALSE;

    if (!npTrack)  // if track passed in null, get the first one
    {
        npTrack = (NPTRACK) List_Get_First(npSeq->trackList);
        npTrack->lastStatus = 0;         // start with null running status
        npTrack->length = 0;
    }

    do
    {
        do
        {
            MarkLocation(npTrack); // remember current location
            lOldDelta = npTrack->delta; // remember last delta
            FillInDelta(npTrack);
            // ***TBD ck illegal delta
            if (npTrack->blockedOn) // abort on block
                break;
            if ((npTrack->delta + npTrack->length) < dwUntil)
            {
                status = GetStatus(npTrack);
                chan = (BYTE)(status & 0x0F);
                if (npTrack->blockedOn)
                    break;
                // check illegal status
                if (!LegalMIDIFileStatus(status)) //error
                {
                    npSeq->fwFlags &= ~LEGALFILE;
                    return TRUE;
                }
                else if (status == METAEVENT)
                {
                    // these actions will set the sequencer globals
                    if (!(HandleMetaEvent(npSeq, npTrack, MODE_SCANEM)))
                        return FALSE; // blew a tempo memory alloc
                }
                else if ((status & 0xF0) == PROGRAMCHANGE)
                {
                    patch = GetByte(npTrack);
                    if ((patch < 128) && (!npTrack->blockedOn))
                        npSeq->patchArray[patch] |= (1 << chan);
                }
                else if ( ((status & 0xF0) == NOTEON) &&
                    ((chan == BASEDRUMCHAN) || (chan == EXTENDDRUMCHAN)) )
                {
                    key = GetByte(npTrack);
                    if ((key < 128) && (!npTrack->blockedOn))
                    {
                        npSeq->drumKeyArray[key] |= (1 << chan);
                        GetByte(npTrack); // toss velocity byte
                    }
                }
                else
                    SkipEvent(status, npTrack); //skip bytes block set within
            }
            if ((npTrack->blockedOn == not_blocked) && (!npTrack->endOfTrack))
            {
                /* NB:  eot avoids adding last delta (which can be large,
                    but isn't really a part of the sequence) */
                npTrack->length += npTrack->delta; //add in this delta
                npTrack->delta = 0;  // zero it out (emulates playing it)
            }
        }
        while ((npTrack->blockedOn == not_blocked) && (!npTrack->endOfTrack)
            && (npTrack->length < dwUntil));

        if (npTrack->blockedOn == not_blocked)
        {
            if (npTrack->length > npSeq->length)
                npSeq->length = npTrack->length; // seq length is longest track
            if (NULL !=
                (npTrack = (NPTRACK) List_Get_Next(npSeq->trackList, npTrack)))
            {
                npTrack->lastStatus = 0;  // start with null running status
                npTrack->length = 0;
            }
        }
    }
    // get the next track
    while (npTrack && (npTrack->blockedOn == not_blocked));

    // now reset location and mature the block status if blocked on input
    // (note:  doesn't affect skip bytes status, which is set at lower level)
    if (npTrack && (npTrack->blockedOn == on_input))
    {
        ResetLocation(npTrack); // restore last saved location
        npTrack->delta = lOldDelta; // "undo" any change to delta
        npTrack->blockedOn = in_ScanEarlyMetas;
    }
    return TRUE;
}

PUBLIC UINT NEAR PASCAL TimerIntRoutine(NPSEQ npSeq, LONG elapsedTick)
/*  This routine does everything that should be done at this time (usually
    sending notes) and sets up the timer to wake us up the next time
    something should happen.

    Interface:    elapsedTick is set by the caller to tell how much time
    has elapsed since this fn was last called. (For ppqn files, a tick is
    1 ppqn in 960 ppqn format.     For SMPTE files, a tick is some fraction
    of a frame. */
{
    FileStatus  fStatus = NoErr;
    BOOL        loop;
    LONG        delta;
    LONG        wakeupInterval;
    DWORD       dTime; //delta in ms. 'till next event
    int         mode;

#ifdef WIN32
    EnterCrit();
#endif // WIN32

        if (npSeq->bTimerEntered)
        {
            dprintf1(("TI REENTERED!!!!!!"));
#ifdef WIN32
            LeaveCrit();
#endif // WIN32
            return 0;
        }
        npSeq->bTimerEntered = TRUE;

    // compute whether we're behind so we know whether to sound note-ons.
    wakeupInterval = (DWORD)npSeq->nextExactTime - timeGetTime();

    if (npSeq->playing)
    {
        do
        {
            loop = FALSE;
                /*    "ElapsedTick is set by whoever sets up timer callback
                ALL TIMING IS IN TERMS OF Ticks!!! (except for timer API) */

            if (wakeupInterval > -100)  // send all notes not more than
                mode = MODE_PLAYING;    // 0.1 seconds behind
            else
                mode = MODE_SILENT;

            fStatus = SendAllEventsB4(npSeq, elapsedTick, mode);

            if (fStatus == NoErr)
            {
                delta = npSeq->nextEventTrack->delta; // get delta 'till next event
                elapsedTick = delta;               // for next time
                if (delta)
                    dTime = muldiv32(delta, npSeq->tempo, 1000);
                else
                    dTime = 0;
                npSeq->nextExactTime += dTime;
                    /* nextExactTime is a global that is always looking
                    at next event.  Remember, tempo is in u-sec per tick
                    (+500 for rounding) */
                wakeupInterval = (DWORD)npSeq->nextExactTime -
                    timeGetTime();
                if (wakeupInterval > (LONG)MINPERIOD)  // buffer to prevent reentrancy
                {
                    #ifdef DEBUG
                      if (wakeupInterval > 60000) { // 1 minute
                        dprintf2(("MCISEQ:  Setting HUGE TIMER INTERVAL!!!"));
                        }
                    #endif

                    //
                    // we are going to program a event, clear bTimerEntered
                    // just in case it goes off before we get out of this
                    // function.
                    //
                        npSeq->bTimerEntered = FALSE;

                    if (SetTimerCallback(npSeq, (UINT) wakeupInterval,
                        elapsedTick) == MIDISEQERR_TIMER)
                    {
#ifndef WIN32
                        // Win 16 effectively releases the critical section
                        // more easily than NT.  The flag could have been
                        // reset since it was cleared above
                        #ifdef DEBUG
                            npSeq->bTimerEntered = FALSE;
                        #endif
#endif
                        Stop(npSeq);
                        seqCallback(npSeq->firstTrack, MIDISEQ_DONEPLAY, 0, 0);
                        dprintf1(("MCISEQ: TIMER ERROR!!!"));
#ifdef WIN32
                        LeaveCrit();
#endif // WIN32
                        return MIDISEQERR_TIMER;
                    }
                }
                else
                {
                    loop = TRUE; // already time to fire next note!
                //    while ((DWORD)npSeq->nextExactTime
                //        > timeGetTime());  // busy wait 'till then
                }
            } //if (fStatus == NoErr)
            else if ((fStatus == AllTracksEmpty) || (fStatus == AtLimit))
            {
                if (npSeq->wCBMessage == SEQ_PLAY)
                    NotifyCallback(npSeq->hStream);
                Stop(npSeq);
                seqCallback(npSeq->firstTrack, MIDISEQ_DONEPLAY, 0, 0);
                dprintf1(("MCISEQ:  At Limit or EOF"));

            }
            else {
                dprintf1(("MCISEQ:  QUIT!!!  fStatus = %x", fStatus));
            }
        }
        while (loop); // if enough time elapsed to fire next note already.
    } // if npSeq->playing

    FlushMidi(npSeq->hMIDIOut, &npSeq->longMIDI[NUMSYSEXHDRS]);

        npSeq->bTimerEntered = FALSE;

#ifdef WIN32
    LeaveCrit();
#endif // WIN32
    return MIDISEQERR_NOERROR;
}

PUBLIC FileStatus NEAR PASCAL SendAllEventsB4(NPSEQ npSeq,
        LONG elapsedTick, int mode)
/* send all events in the MIDI stream that occur before current tick, where
currentTick is elapsed ticks since last called.

This function is called both to play notes, and to scan forward to a song
pointer position.  The mode parameter reflects this state.  */

{
    LONG residualDelta;  // residual holds how much of elapsed
                         // tick has been accounted for
    FileStatus fStatus = GetNextEvent(npSeq);
    WORD wAdj;
    BYTE status;
    DWORD dwNextTick;

    if (npSeq->bSending)  // prevent reentrancy
        return NoErr;

    npSeq->bSending = TRUE; // set entered flag
    #ifdef DEBUG
        if (mode == MODE_SEEK_TICKS) {
            dprintf2(("ENTERING SEND ALL EVENTS"));
        }
    #endif

    if (elapsedTick > 0)
        residualDelta = elapsedTick;
    else
        residualDelta = 0;

    if (mode == MODE_SEEK_TICKS) // hack for song ptr -- don't send unless before eT
        wAdj = 1;
    else
        wAdj = 0;
    while ((fStatus == NoErr) &&
        (residualDelta >= (npSeq->nextEventTrack->delta + wAdj)) &&
        (!npSeq->bSendingSysEx)) // can't process any other msgs during sysex
    /* send all events within delta */
    {
        if (mode == MODE_PLAYING)
        // if playing, are we at the end yet yet?
        {

            // compute temp var
            dwNextTick = npSeq->currentTick + npSeq->nextEventTrack->delta;

            // if not play to end, don't play the last note
            if ((dwNextTick > npSeq->playTo) ||
                ((npSeq->playTo < npSeq->length) &&
                (dwNextTick == npSeq->playTo)))
            {
                fStatus = AtLimit;  // have reached play limit user requested
                SubtractAllTracks(npSeq, (npSeq->playTo - npSeq->currentTick));
                npSeq->currentTick = npSeq->playTo; // set to limit
                break; // leave while loop
            }
        }

        status = npSeq->nextEventTrack->shortMIDIData.byteMsg.status;
        if (status == METAEVENT)
        {
            MarkLocation(npSeq->nextEventTrack); // remember current location
            // note that these are "handled" even within song ptr traversal

            HandleMetaEvent(npSeq, npSeq->nextEventTrack, mode);

            if (npSeq->nextEventTrack->blockedOn == on_input)
            { // nb:  not affected if blocked in skip bytes!!
                ResetLocation(npSeq->nextEventTrack); // reset location
                if (mode == MODE_SEEK_TICKS)
                    npSeq->nextEventTrack->blockedOn = in_Seek_Meta;
                else
                    npSeq->nextEventTrack->blockedOn = in_Normal_Meta;
            }
        }
        else if ((status == SYSEX) || (status == SYSEXF7))
        {
            SendSysEx(npSeq);
            if (npSeq->bSendingSysEx)
                fStatus = InSysEx;
        }
        // send all but note-ons unless playing and note is current
        else if (((mode == MODE_PLAYING) &&
          (npSeq->nextEventTrack->delta >= 0)) ||
          ( ! (((status & 0xF0) == 0x90) &&   // note on with vel != 0
            (npSeq->nextEventTrack->shortMIDIData.byteMsg.byte3)) ))
                SendMIDI(npSeq, npSeq->nextEventTrack);

        if ((npSeq->nextEventTrack->blockedOn == not_blocked) ||
            (npSeq->bSendingSysEx) ||
            (npSeq->nextEventTrack->blockedOn == in_SkipBytes_Play) ||
            (npSeq->nextEventTrack->blockedOn == in_SkipBytes_Seek) ||
            (npSeq->nextEventTrack->blockedOn == in_SkipBytes_ScanEM))
        {
            // account for time spent only if it was sent
            // ...and only if dealing with a fresh delta
            if (npSeq->nextEventTrack->delta > 0)
            {
                residualDelta -= npSeq->nextEventTrack->delta;
                npSeq->currentTick += npSeq->nextEventTrack->delta;
                // account for delta
                SubtractAllTracks(npSeq, npSeq->nextEventTrack->delta);
            }
        }

        if ((npSeq->nextEventTrack->blockedOn == not_blocked) &&
          (!npSeq->nextEventTrack->endOfTrack) &&
          (!npSeq->bSendingSysEx))
            //fill in the next event from stream
            FillInNextTrack(npSeq->nextEventTrack);

        if (npSeq->nextEventTrack->blockedOn == on_input) //mature block
        {
            if (mode == MODE_SEEK_TICKS)  // set blocked status depending on mode
                npSeq->nextEventTrack->blockedOn = in_Seek_Tick;
            else
                npSeq->nextEventTrack->blockedOn = between_msg_out;
        }
        if (!npSeq->bSendingSysEx)
            // Make nextEventTrack point to next track to play
            if (((fStatus = GetNextEvent(npSeq)) == NoErr) &&
            (npSeq->nextEventTrack->endOfTrack))
                npSeq->readyToPlay = FALSE;
    }
    if ((fStatus == NoErr) && AllTracksUnblocked(npSeq))
    {
        npSeq->currentTick += residualDelta;
        SubtractAllTracks(npSeq, residualDelta); //account for rest of delta
    }
    #ifdef DEBUG
        if (mode == MODE_SEEK_TICKS) {
            dprintf2(("LEAVING SEND ALL EVENTS"));
        }
    #endif

    npSeq->bSending = FALSE; // reset entered flag

    return fStatus;
}

PUBLIC FileStatus NEAR PASCAL GetNextEvent(NPSEQ npSeq)
/* scan all track queues for the next event, and put the next one to occur in
    "nextEvent."  Remember that each track can use its own running status
    (we'll fill in all status).
*/
#define MAXDELTA    0x7FFFFFFF
{
    NPTRACK npTrack;
    NPTRACK npTrackMin = NULL;
    LONG    minDelta = MAXDELTA;  /* larger than any possible delta */
    BOOL    foundBlocked = FALSE;

    npTrack = (NPTRACK) List_Get_First(npSeq->trackList);
    while (npTrack)        /* find smallest delta */
    {
         if ((!npTrack->endOfTrack) && (npTrack->delta < minDelta))
         // note that "ties" go to earliest track
        {
            if (npTrack->blockedOn)
                foundBlocked = TRUE;
            else
            {
                minDelta = npTrack->delta;
                npTrackMin = npTrack;
            }
        }
        npTrack = (NPTRACK) List_Get_Next(npSeq->trackList, npTrack);
    }

    npSeq->nextEventTrack = npTrackMin;
    if (npTrackMin == NULL)
        if (foundBlocked)
            return OnlyBlockedTracks;
        else
            return AllTracksEmpty;
    else
        return NoErr;
}

PUBLIC VOID NEAR PASCAL FillInNextTrack(NPTRACK npTrack)
   /* given a pointer to a track structure, fill it in with next event data
      (delta time and data) received from mciseq streamer. */
{
    LONG    lOldDelta;

    MarkLocation(npTrack); // remember where you started in case get blocked
    lOldDelta = npTrack->delta; // remember this delta in case block
    FillInDelta(npTrack);
    FillInEvent(npTrack);
    if (npTrack->blockedOn)
    {
        ResetLocation(npTrack); // blocked -- hence rewind
        npTrack->delta = lOldDelta; // restore old delta
    }
}
/**********************************************************/

PUBLIC VOID NEAR PASCAL FillInDelta(NPTRACK npTrack) // fills in delta of track passed in
{
    npTrack->delta += GetVarLen(npTrack);
}

PUBLIC UINT NEAR PASCAL SendPatchCache(NPSEQ npSeq, BOOL cache)
{
    UINT        cacheOrNot;
    UINT        wRet;
    #define     BANK    0
    #define     DRUMPATCH 0

    if (!npSeq->hMIDIOut)  // do nothing if no midiport
        return MIDISEQERR_NOERROR;

    if (cache)
        cacheOrNot = MIDI_CACHE_BESTFIT;
    else
        cacheOrNot = MIDI_UNCACHE;

    wRet = midiOutCachePatches(npSeq->hMIDIOut, BANK,       // send it
        (LPPATCHARRAY) &npSeq->patchArray, cacheOrNot);

    if (!wRet)
        wRet = midiOutCacheDrumPatches(npSeq->hMIDIOut, DRUMPATCH,       // send it
            (LPKEYARRAY) &npSeq->drumKeyArray, cacheOrNot);

    return wRet == MMSYSERR_NOTSUPPORTED ? 0 : wRet;
}

PUBLIC VOID NEAR PASCAL SendSysEx(NPSEQ npSeq)
//  get a sysex buffer, fill it, and send it off
//  keep doing this until done (!sysexremlength), or blocked on input,
//  or blocked on output.
{
    NPLONGMIDI  myBuffer;
                // temp variable to reduce address computation time
    DWORD       sysExRemLength = npSeq->nextEventTrack->sysExRemLength;
    int         max, bytesSent;

    npSeq->bSendingSysEx = TRUE;

    dprintf2(("Entering SendSysEx"));

    while ((sysExRemLength) && (!npSeq->nextEventTrack->blockedOn))
    {
        if (!(myBuffer = GetSysExBuffer(npSeq)))
            break; // can't get a buffer

        bytesSent = 0;  // init buffer data index

        // if status byte was F0, make that 1st byte of message
        //  (remember, it could be F7, which shouldn't be sent)
        if (npSeq->nextEventTrack->shortMIDIData.byteMsg.status == SYSEX)
        {
            dprintf3(("Packing Sysex Byte"));
            myBuffer->data[bytesSent++] = SYSEX;
            sysExRemLength++; // semi-hack to account for extra byte
                //by convention, clear f0 status after f0 has been sent
            npSeq->nextEventTrack->shortMIDIData.byteMsg.status = 0;
        }

        max = min(LONGBUFFSIZE, (int)sysExRemLength);  // max bytes for this buff

        // fill buffer -- note that i will reflect # of valid bytes in buff
        do
            myBuffer->data[bytesSent] = GetByte(npSeq->nextEventTrack);
        while ((!npSeq->nextEventTrack->blockedOn) && (++bytesSent < max));

        // account for bytes sent
        sysExRemLength -= bytesSent;

        // send buffer
        myBuffer->midihdr.dwBufferLength = bytesSent;
        dprintf3(("SENDing SendSysEx"));
        if (npSeq->hMIDIOut)
            midiOutLongMsg(npSeq->hMIDIOut, &myBuffer->midihdr,
                sizeof(MIDIHDR));
    }

    if (sysExRemLength) // not done -- must be blocked
    {
        //blocked on in or out?
        if (npSeq->nextEventTrack->blockedOn)
        {
            //blocked on in
            npSeq->nextEventTrack->blockedOn = in_SysEx;
            dprintf3(("Sysex blocked on INPUT"));
        }
        else
        {
            //blocked on out
            npSeq->bSysExBlock = TRUE;
            dprintf3(("Sysex blocked on OUTPUT"));
        }
    }
    else // done
    {
        npSeq->bSendingSysEx = FALSE;
        dprintf4(("Sysex Legally Finished"));
    }
    npSeq->nextEventTrack->sysExRemLength = sysExRemLength; // restore
}

/*
// BOGUS
void DoSyncPrep(NPSEQ npSeq)
{
    //a bunch of sync prep will go here, such as:

    if ((npSeq->slaveOf != SEQ_SYNC_NOTHING) && (npSeq->slaveOf != SEQ_SYNC_MIDICLOCK) &&
    (npSeq->division == SEQ_DIV_PPQN))
        addTempoMap(npSeq);
    else
        destroyTempoMap(npSeq);

    if (npSeq->masterOf != SEQ_SYNC_NOTHING)
        addSyncOut(npSeq);
    else
        destroySyncOut(npSeq);
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciseq\mmseqi.h ===
/*******************************Module*Header*********************************
* Module Name: mmseqi.h
*
* MultiMedia Systems MIDI Sequencer DLL Internal prototypes and data struct's
*
* Created: 4/10/90
* Author:  GREGSI
*
* History:
*
* Copyright (c) 1985-1998 Microsoft Corporation
*
\****************************************************************************/
/*****************************************************************************
 *
 *                          Constants
 *
 ****************************************************************************/
//#define SEQDEBUG 1

// max. tracks allowed in a sequence

#define MAXTRACKS           100

//  MIDI real time data:

#define SysExCode           257
#define MetaEventCode       258

#define METAEVENT           0XFF
#define SYSEX               0XF0
#define SYSEXF7             0XF7
#define PROGRAMCHANGE       0xC0

// packet codes:  these are flags

#define LASTPACKET          0X1
#define FIRSTPACKET         0X2

// META EVENT TYPES

#define ENDOFTRACK          0X2F
#define TEMPOCHANGE         0X51
#define SMPTEOFFSET         0X54
#define TIMESIG             0X58
#define SEQSTAMP            0X7F

// PORT TYPES

#define TRACKPORT           0
#define OUTPORT             1
#define CONTROLPORT         2
#define METAPORT            3

/* fileStatus codes */

#define NoErr               256
#define EndOfStream         257
#define AllTracksEmpty      258
#define OnlyBlockedTracks   259
#define AtLimit 	    260
#define InSysEx 	    261

/* Blocking types */

#define not_blocked         0

// these imply that you're blocked on input (waiting for free input buffer)

#define between_msg_out     270
#define in_rewind_1	    271
#define in_rewind_2	    272
#define in_ScanEarlyMetas   273
#define in_Normal_Meta	    274
#define in_SysEx	    275
#define in_Seek_Tick	    276
#define in_Seek_Meta	    277
#define in_SkipBytes_Seek   278
#define in_SkipBytes_ScanEM 279
#define in_SkipBytes_Play   280

/* Generic types -- used temporarily at a low level */
#define on_input            350

// End of blocking types.

#define NAMELENGTH          32

/*
   codes to pass to SendAllEventB4 (called in normal course of playing, and
   by song pointer code for chase-lock)
*/

#define MODE_SEEK_TICKS     1
#define MODE_PLAYING        2
#define MODE_SILENT         3
#define MODE_SCANEM         4


// Code to hold in seq->SeekTickToBe when there is no seek pending

#define NotInUse            ((DWORD)-1L)

/* delta-time escapes ("legal" deltas only use 28 bits) */

#define MAXDelta            0X8FFFFFFF
#define TrackEmpty          0X8FFFFFFE

#define MHDR_LASTBUFF	    2
extern UINT MINPERIOD;

typedef int                 FileStatus;    // this not thoroughly defined

/*****************************************************************************
 *
 *                        Data Stuctures & Typedefs
 *
 ****************************************************************************/

/* USED FOR BYTE MANIPULATION OF MIDI DWORDS */
typedef struct fbm    // 32 bit -- passed in lparam
{
    BYTE    status;      // (order may change for optimization)
    BYTE    byte2;
    BYTE    byte3;
    BYTE    time;
} FourByteMIDI;

typedef union
{
    DWORD        wordMsg;
    FourByteMIDI byteMsg;
} ShortMIDI;

/* USED TO HOLD LONG MIDI (SYSEX) INFORMATION */
// size of data buffer
#define LONGBUFFSIZE 0x100
// number of buffers in array (held in seq struct)
#define NUMSYSEXHDRS 2

#define	pSEQ(h)	((NPSEQ)(h))
#define	hSEQ(p)	((HMIDISEQ)(p))

typedef struct lm    // ptr to this passed in lparam
{
    MIDIHDR midihdr; // embedded midihdr struct
    BYTE    data[LONGBUFFSIZE];
} LongMIDI;

typedef LongMIDI NEAR * NPLONGMIDI;

/* USED FOR KEEPING TRACK OF CERTAIN EVENTS (META/KEY/PATCH) */
typedef struct    // bit vector of booleans
{
    WORD    filter[8];   // yields 128 booleans
} BitVector128;

/* DATA STRUCTURES TO HOLD CONTENTS OF META EVENT READ IN */

typedef struct
{
    BYTE    hour;
    BYTE    minute;
    BYTE    second;
    BYTE    frame;
    BYTE    fractionalFrame;
} SMPTEType;

typedef struct
{
    int     numerator;
    int     denominator;
    int     midiClocksMetro;
    int     thirtySecondQuarter;
} TimeSigType;


/* TEMPO MAP ELEMENT (for list of tempo changes to facilitate ms <-> beat
   conversion) */

typedef struct tag_TempoMapElement
{
    DWORD   dwMs;
    DWORD   dwTicks;
    DWORD   dwTempo;
} TempoMapElement;

typedef TempoMapElement *NPTEMPOMAPELEMENT;

typedef struct t1
{
    LPBYTE      currentPtr;     //points at current byte in stream
    LPBYTE      endPtr;         //points at last byte in buffer
    LPBYTE      previousPtr;    //points at beginning of previous message
    LPMIDISEQHDR hdrList;        // list of track data headers
} TLevel1;


/* SEQUENCE TRACK DATA STRUCTURE */

typedef struct trk
{
    int         blockedOn;          // how blocked, if at all?
    LONG	delta;              // time in ticks 'till next event fired
    DWORD	length; 	    // length of this track in ticks
    BYTE        lastStatus;         // used for running status
    ShortMIDI   shortMIDIData;      // staging area for next event
    LONG        sysExRemLength;     // remaining length when sysex pending
    TLevel1     inPort;             // low level data pertaining to file
    BOOL        endOfTrack;         // whether track is at end of its data
    int         iTrackNum;          // track number (0-based)
    DWORD_PTR   dwCallback;         // address of callback routine in mciseq
                                    //   used to return buffer to it (so it
                                    //   can be refilled and received again)
    DWORD_PTR   dwInstance;         // mciseq's private instance information
                                    //  (usually contains file handle...)
    DWORD       dwBytesLeftToSkip;
} TRACK;

typedef TRACK NEAR *NPTRACK;

typedef struct trackarray_tag
{
    NPTRACK trkArr[];
} TRACKARRAY;
typedef TRACKARRAY NEAR * NPTRACKARRAY;

// fwFlags:
#define	LEGALFILE	0x0001		// Is a legal MIDI file
#define	GENERALMSMIDI	0x0002		// Is an MS General MIDI file

typedef struct seq_tag
{
    int         divType;            // PPQN, SMPTE24, SMPTE25, SMPTE30,
                                    //   or SMPTE30Drop
    int         resolution;         // if SMPTE, ticks/frame, if MIDI,
                                    //   ticks/q-note
    BOOL	playing;	    // whether sequence playing or not
    DWORD	playTo; 	    // what tick to play to, if not end
                                    //   (used for mci_play_to command)
    DWORD	length; 	    // length of sequence in ticks
    BOOL        readyToPlay;        // whether sequence is set up to play
    DWORD       currentTick;        // where we are rel. to beginning of song
    DWORD       nextExactTime;      // system time (ms) that next event
                                    //   *should* occur at
    BOOL        withinMsgOut;       // true iff in middle of sending a message
    DWORD       seekTicks;          // temp for seektick or song ptr operation
    DWORD       tempo;              // tempo of sequence in ticks per Usec.
    MMTIME	smpteOffset;	    // absolute smpte time of start of seq.
                                    //   from meta event, or user)
    TimeSigType timeSignature;      // current time signature of piece (can
                                    //   change)
    ListHandle  trackList;          // track list handle
    NPTRACK     nextEventTrack;     // track that next event resides in
    NPTRACK     firstTrack;         // track holding tempos, smpte offset...
    char        Name[NAMELENGTH];   // name of the sequence

    // sync-related stuff below

    DWORD       nextSyncEventTick;  // global tick at which the next sync
                                    // event is expected
    WORD 	slaveOf;	    // what you're slave of (mtc, clock,
                                    //   file, or nothing)
    WORD 	masterOf;	    // what you're slave of (mtc, clock,
                                    //   or nothing)
    BOOL        waitingForSync;     // tells if currently 'blocked' waiting
                                    // for a sync pulse
//  BitVector128      extMetaFilter;      // for each meta type, whether to send it.
                                    //   (unused for now)
    BitVector128      intMetaFilter;      // for each meta type, whether it
                                    //   affects seq.
    DWORD       dwTimerParam;       // used after timer interrupt to remember
                                    //   how many ticks elapsed
    UINT        wTimerID;           // handle to timer (used to cancel
                                    //   next interrupt.
    HMIDIOUT	hMIDIOut;	    // handle to midi output driver
    HANDLE      hStream;            // handle to stream
    UINT	wCBMessage;	    // message type that notify is for
    ListHandle	tempoMapList;	    // list of tempo map items for
                                    //   ms <-> ppqn conversion.
    BOOL	bSetPeriod;	    // whether timer period is currently
                                    //   set or not.
    PATCHARRAY  patchArray;	    // arrays to keep track of which
                                        //   patches used
    KEYARRAY    drumKeyArray;       // array for drum cacheing
    BitVector128 keyOnBitVect[16];  // arrays to keep track of which
                                        //   patches used
    BOOL        bSending;           // currently in sendevent loop
                                    // (used to prevent reentrancy)
    BOOL        bTimerEntered;      // (used to prevent timer reentrancy)
#ifdef DEBUG
    DWORD       dwDebug;            // debug signature (for detecting bogus
                                    //   seq ptr)
#endif
    NPTRACKARRAY  npTrkArr;         // pointer to track array
                                    // (used for routing incoming trk data)
    UINT        wNumTrks;           // number of tracks
    LongMIDI    longMIDI[NUMSYSEXHDRS + 1]; // list of long midi buffers
    BYTE        bSysExBlock;        // whether blocked waiting for long buff
    BYTE        bSendingSysEx;      // whether in mid sysex out
    UINT        fwFlags;            // various flags
} SEQ;

typedef SEQ NEAR *NPSEQ;

/****************************************************************************
 *
 *                         Prototypes
 *
 ***************************************************************************/

// MMSEQ.C
PRIVATE VOID NEAR PASCAL SeekTicks(NPSEQ npSeq);
PUBLIC  UINT NEAR PASCAL GetInfo(NPSEQ npSeq, LPMIDISEQINFO lpInfo);
PUBLIC  UINT NEAR PASCAL CreateSequence(LPMIDISEQOPENDESC lpOpen,
            LPHMIDISEQ lphMIDISeq);
PUBLIC  VOID NEAR PASCAL FillInDelta(NPTRACK npTrack);
PUBLIC  UINT NEAR PASCAL Play(NPSEQ npSeq, DWORD dwPlayTo);
PUBLIC  VOID NEAR PASCAL Stop(NPSEQ npSeq);
PUBLIC  UINT NEAR PASCAL TimerIntRoutine(NPSEQ npSeq, LONG elapsedTick);
PUBLIC  VOID NEAR PASCAL SetBlockedTracksTo(NPSEQ npSeq,
            int fromState, int toState);
PUBLIC  VOID NEAR PASCAL ResetToBeginning(NPSEQ npSeq) ;
PUBLIC  BOOL NEAR PASCAL HandleMetaEvent(NPSEQ npSeq, NPTRACK npTrack,
            UINT wMode);
PUBLIC  BOOL NEAR PASCAL ScanEarlyMetas(NPSEQ npSeq, NPTRACK npTrack,
            DWORD dwUntil);
PUBLIC  FileStatus NEAR PASCAL SendAllEventsB4(NPSEQ npSeq,
            LONG elapsedTick, int mode);
PUBLIC  FileStatus NEAR PASCAL GetNextEvent(NPSEQ npSeq);
PUBLIC  VOID NEAR PASCAL FillInNextTrack(NPTRACK npTrack);
PUBLIC  UINT NEAR PASCAL SendPatchCache(NPSEQ npSeq, BOOL cache);
PUBLIC  VOID NEAR PASCAL SendSysEx(NPSEQ npSeq);
PUBLIC  VOID NEAR PASCAL SkipBytes(NPTRACK npTrack, LONG length);


// UTIL.C

PUBLIC VOID NEAR PASCAL seqCallback(NPTRACK npTrack, UINT msg,
        DWORD_PTR dw1, DWORD_PTR dw2);
PUBLIC BYTE NEAR PASCAL LookByte(NPTRACK npTrack);
PUBLIC BYTE NEAR PASCAL GetByte(NPTRACK npTrack);
PUBLIC VOID NEAR PASCAL MarkLocation(NPTRACK npTrack);
PUBLIC VOID NEAR PASCAL ResetLocation(NPTRACK npTrack);
PUBLIC VOID NEAR PASCAL RewindToStart(NPSEQ npSeq, NPTRACK npTrack);
PUBLIC BOOL NEAR PASCAL AllTracksUnblocked(NPSEQ npSeq);
PUBLIC VOID FAR PASCAL _LOADDS OneShotTimer(UINT wId, UINT msg, DWORD_PTR dwUser,
        DWORD_PTR dwTime, DWORD_PTR dw2);
PUBLIC UINT NEAR PASCAL SetTimerCallback(NPSEQ npSeq, UINT msInterval,
        DWORD elapsedTicks);
PUBLIC VOID NEAR PASCAL DestroyTimer(NPSEQ npSeq);
PUBLIC VOID NEAR PASCAL SendLongMIDI(NPSEQ npSeq,
        LongMIDI FAR *pLongMIDIData);
PUBLIC UINT NEAR PASCAL NewTrackData(NPSEQ npSeq, LPMIDISEQHDR msgHdr);
PUBLIC NPLONGMIDI NEAR PASCAL GetSysExBuffer(NPSEQ npSeq);


// CRIT.ASM

extern FAR PASCAL EnterCrit(void);
extern FAR PASCAL LeaveCrit(void);

// CALLBACK.C

PUBLIC VOID  FAR  PASCAL _LOADDS MIDICallback(HMIDIOUT hMIDIOut, UINT wMsg,
       DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

PUBLIC VOID FAR PASCAL NotifyCallback(HANDLE hStream);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciseq\mmsys.h ===
/*******************************Module*Header*********************************
* Module Name: mmsys.h
*
* MultiMedia Systems MIDI Sequencer DLL Internal prototypes and data struct's
*   (contains constants, data types, and prototypes common to mci and seq
*       sections of mciseq.drv)
*
* Created: 4/10/90
* Author:  GREGSI
*
* History:
*
* Copyright (c) 1985-1998 Microsoft Corporation
*
\****************************************************************************/

#include <port1632.h>

/* Set up NT style debugging */

#ifdef WIN32
#if DBG
#define DEBUG
#endif
#endif

#define PUBLIC  extern          /* Public label.                */
#define PRIVATE static          /* Private label.               */
#define EXPORT  FAR _LOADDS     /* Export function.             */

#define WAIT_FOREVER ((DWORD)(-1))

#define GETMOTWORD(lpb) ((((WORD)*(LPBYTE)(lpb)) << (8 * sizeof(BYTE))) + *((LPBYTE)(lpb) + sizeof(BYTE)))

typedef HANDLE   HMIDISEQ;
typedef HMIDISEQ FAR *LPHMIDISEQ;
/****************************************************************************

    Sequencer error return values

****************************************************************************/

#define MIDISEQERR_BASE            96
#define MIDISEQERR_NOERROR         0                    // no error
#define MIDISEQERR_ERROR           (MIDISEQERR_BASE+1)  // unspecified error
#define MIDISEQERR_NOSEQUENCER     (MIDISEQERR_BASE+2)  // no sequencer present
#define MIDISEQERR_INVALSEQHANDLE  (MIDISEQERR_BASE+3)  // given sequence handle is invalid
#define MIDISEQERR_NOMEM           (MIDISEQERR_BASE+4)  // memory allocation error
#define MIDISEQERR_ALLOCATED       (MIDISEQERR_BASE+5)  // sequencer already allocated
#define MIDISEQERR_BADERRNUM       (MIDISEQERR_BASE+6)  // error number out of range
#define MIDISEQERR_INTERNALERROR   (MIDISEQERR_BASE+7)  // internal error - see mmddk.h
#define MIDISEQERR_INVALMIDIHANDLE (MIDISEQERR_BASE+8)  // specified MIDI output handle invalid
#define MIDISEQERR_INVALMSG        (MIDISEQERR_BASE+9)  // specified msg was invalid
#define MIDISEQERR_INVALPARM       (MIDISEQERR_BASE+10)  // msg parameter bad
#define MIDISEQERR_TIMER           (MIDISEQERR_BASE+11)  // timer failed

/****************************************************************************
    Sequencer callback
****************************************************************************/
typedef DRVCALLBACK MIDISEQCALLBACK;
typedef MIDISEQCALLBACK FAR *LPMIDISEQCALLBACK;

// callback messages
#define MIDISEQ_DONE    0
#define MIDISEQ_RESET   1
#define MIDISEQ_DONEPLAY        2
/****************************************************************************
    Sequencer data block header
****************************************************************************/

typedef struct midiseqhdr_tag {
    LPSTR       lpData;         // pointer to locked data block
    DWORD       dwLength;       // length of data in data block
    WORD        wFlags;         // assorted flags (see defines)
    WORD        wTrack;         // track number
    struct      midiseqhdr_tag far *lpNext;    // reserved for sequencer
    DWORD       reserved;                      // reserved for sequencer
} MIDISEQHDR;
typedef MIDISEQHDR FAR *LPMIDISEQHDR;

// defines for MIDISEQOUTHDR flag bits
#define MIDISEQHDR_DONE      0x0001  // done bit
#define MIDISEQHDR_BOT       0x0002  // beginning of track
#define MIDISEQHDR_EOT       0x0004  // end of track

/****************************************************************************
    Sequencer support structures
****************************************************************************/

/*  Struct used for the seqinfo message. */

typedef struct midiseqinfo_tag {
    WORD    wDivType;       // division type of file
    WORD    wResolution;    // resolution of file
    DWORD   dwLength;       // length of sequence in ticks
    BOOL    bPlaying;       // whether file is playing
    BOOL    bSeeking;       // whether seek is in progress
    BOOL    bReadyToPlay;   // if all is set to play
    DWORD   dwCurrentTick;  // current position in terms of file's ticks
    DWORD   dwPlayTo;
    DWORD   dwTempo;        // tempo of file in microseconds per tick
//    BYTE    bTSNum;       // numerator of time signature
//    BYTE    bTSDenom;     // denominator of time signature
//    WORD    wNumTracks;     // number of tracks in the file
//    HANDLE  hPort;        // MIDI port handle
    BOOL    bTempoFromFile; // whether file's tempo events are to be used
    MMTIME  mmSmpteOffset;  // offset into file if in smpte format
    WORD    wInSync;        // in (slave) sync mode
    WORD    wOutSync;       // out (master) sync mode
    BYTE    tempoMapExists;
    BYTE    bLegalFile;
    } MIDISEQINFO;
typedef MIDISEQINFO FAR *LPMIDISEQINFO;

/****************************************************************************
    Sequencer synchronization constants
****************************************************************************/

#define SEQ_SYNC_NOTHING          0
#define SEQ_SYNC_FILE             1
#define SEQ_SYNC_MIDI             2
#define SEQ_SYNC_SMPTE            3
#define SEQ_SYNC_OFFSET           4
#define SEQ_SYNC_OFFSET_NOEFFECT  0xFFFFFFFF
/****************************************************************************
    Sequencer file division-type constants
****************************************************************************/
#define     SEQ_DIV_PPQN         0
#define     SEQ_DIV_SMPTE_24     24
#define     SEQ_DIV_SMPTE_25     25
#define     SEQ_DIV_SMPTE_30DROP 29
#define     SEQ_DIV_SMPTE_30     30
/****************************************************************************
   midiSeqMessage constants
****************************************************************************/

#define SEQ_PLAY        3
#define SEQ_RESET       4
#define SEQ_SETTEMPO    6
#define SEQ_SETSONGPTR  7
#define SEQ_SETUPTOPLAY 8
#define SEQ_STOP        9
#define SEQ_TRACKDATA   10
#define SEQ_GETINFO     11
#define SEQ_SETPORT     12
#define SEQ_SETPORTOFF  13
#define SEQ_MSTOTICKS   14
#define SEQ_TICKSTOMS   15
#define SEQ_SEEKTICKS   16
#define SEQ_SYNCSEEKTICKS   17
#define SEQ_SETSYNCSLAVE    18
#define SEQ_SETSYNCMASTER   19
#define SEQ_QUERYGENMIDI    20
#define SEQ_QUERYHMIDI      21

/***************** "play to" code for seq_play ***************************/

#define PLAYTOEND       ((DWORD)-1)

/****************************************************************************
     sequencer support
****************************************************************************/

// opening info -- needed for MIDISEQOPEN message
typedef struct midiseqopendesc_tag {
    DWORD_PTR      dwCallback;       // callback
    DWORD_PTR      dwInstance;       // app's private instance information
    HANDLE         hStream;          // handle to stream
    LPBYTE         lpMIDIFileHdr;
    DWORD          dwLen;            // length of midi file header
} MIDISEQOPENDESC;
typedef MIDISEQOPENDESC FAR *LPMIDISEQOPENDESC;

/****************************************************************************
    MIDISeqMessage() messages
****************************************************************************/

#define SEQ_OPEN        1
#define SEQ_CLOSE       2


// microseconds per minute -- a handy thing to have around
#define     USecPerMinute 60000000
#define     USecPerSecond  1000000
#define     USecPerMinute 60000000
#define     DefaultTempo 120

/********************** COMMON SYSTEM PROTOTYPES ************************/

PUBLIC DWORD_PTR FAR  PASCAL midiSeqMessage(HMIDISEQ hMIDISeq, UINT msg,
       DWORD_PTR lParam1, DWORD_PTR lParam2);

/*** math support ****/
#ifdef WIN16
PUBLIC LONG FAR PASCAL  muldiv32(long, long, long);
#else
#define muldiv32 MulDiv
#endif // WIN16

#define WTM_DONEPLAY    (WM_USER+0)
#define WTM_QUITTASK    (WM_USER+1)
#define WTM_FILLBUFFER  (WM_USER+2)

PUBLIC UINT FAR PASCAL TaskBlock(void);
PUBLIC BOOL FAR PASCAL TaskSignal(DWORD dwThreadId, UINT wMsg);
PUBLIC VOID FAR PASCAL TaskWaitComplete(HANDLE htask);

#ifdef WIN32
#undef Yield
#define Yield() { LeaveSeq(); EnterSeq(); } /* Should there be a Sleep call ? */

VOID InitCrit(VOID);
VOID DeleteCrit(VOID);
DWORD midiSeqMessageInternal(HMIDISEQ, UINT, DWORD, DWORD);
VOID EnterSeq(VOID);
VOID LeaveSeq(VOID);
#else
#define EnterSeq()
#define LeaveSeq()
#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciseq\util.c ===
/*******************************Module*Header*********************************\
* Module Name: util.c
*
* MultiMedia Systems MIDI Sequencer DLL
*
* Created: 4/11/90
* Author:  GREGSI
*
* History:
*
* Copyright (c) 1985-1998 Microsoft Corporation
*
\******************************************************************************/
#define UNICODE

//MMSYSTEM
#define MMNOSOUND        - Sound support
#define MMNOWAVE         - Waveform support
#define MMNOAUX          - Auxiliary output support
#define MMNOJOY          - Joystick support
//MMDDK

#define NOWAVEDEV         - Waveform support
#define NOAUXDEV          - Auxiliary output support
#define NOJOYDEV          - Joystick support


#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "mmsys.h"
#include "list.h"
#include "mmseqi.h"
#include "mciseq.h"

typedef struct ts
{
    BOOL                        valid;
    void                        (*func)(void *, LONG);
    LONG                        instance;
    LONG                        param;
    LONG                        time;
} TimerStruct;

static  ListHandle  timerList;
static  DWORD       systemTime = 0; //global holding system time
static  DWORD       nextEventTime;

#ifdef DEBUG
static  BOOL        fInterruptTime = 0;
#endif

/**************************** PUBLIC FUNCTIONS *************************/

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | seqCallback | This calls DriverCallback for the seq device
 *
 * @parm NPTRACK   | npTrack | pointer to the TRACK info
 *
 * @parm UINT      | msg   | message
 *
 * @parm DWORD     | dw1   | message dword
 *
 * @parm DWORD     | dw2   | message dword
 *
 * @rdesc There is no return value
 ***************************************************************************/
PUBLIC VOID NEAR PASCAL seqCallback(NPTRACK npTrack, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2)
{
    //
    // don't use DriverCallback() because it will switch stacks and
    // we don't need to switch to a new stack.
    //
    // this function can get nested 1 or 2 deep and exaust MMSYSTEMs
    // internal stacks.
    //
#if 0
    if(npTrack->dwCallback)
        DriverCallback(npTrack->dwCallback, DCB_FUNCTION,
                       0,
                       msg,
                       npTrack->dwInstance,
                       dw1,
                       dw2);
#else
    if(npTrack->dwCallback)
        (*(LPDRVCALLBACK)npTrack->dwCallback)(0,msg,npTrack->dwInstance,dw1,dw2);
#endif
}

PUBLIC NPLONGMIDI NEAR PASCAL GetSysExBuffer(NPSEQ npSeq)
{
    int     i;

    for (i = 0; i < NUMSYSEXHDRS; i++)
        if (npSeq->longMIDI[i].midihdr.dwFlags & MHDR_DONE)
            return &npSeq->longMIDI[i];
    return NULL;
}
/**********************************************************/

PUBLIC BYTE NEAR PASCAL LookByte(NPTRACK npTrack)

/* Gets next byte from track.  Accounts for unfulfilled data buffer request,
end of track, and (premature) end of stream.  Returns byte read as fn result.
If error, returns file status error code (differentiate because filestatus is
an int, and err codes are > 255) */
{
    if ((npTrack->blockedOn) || (!npTrack->inPort.hdrList))
    // return if blocked, or hdrList empty
        return 0;

    if (npTrack->inPort.currentPtr <= npTrack->inPort.endPtr)
        return *npTrack->inPort.currentPtr;  // return next byte in buffer
    else
    {  // oops, out of bytes in this buffer -- return this one and get next
        /* if this is the last buffer, set done stuff; else
            if there's a pending track message header, set pointers to
            it; else block  */
        if (npTrack->inPort.hdrList->wFlags & MIDISEQHDR_EOT) //'last buffer' flag
        {
            npTrack->endOfTrack = TRUE;
            // pass the buffer back to the sequencer
            seqCallback(npTrack, MIDISEQ_DONE, (DWORD_PTR)npTrack->inPort.hdrList, 0L);

            npTrack->inPort.hdrList = npTrack->inPort.hdrList->lpNext;
                // point over it (should be NULL)
                // done with it!
            return ENDOFTRACK;
        }
        else if (npTrack->inPort.hdrList->lpNext)
        {
            npTrack->inPort.previousPtr = NULL; // can't back up.

            // pass the buffer back to the sequencer
            seqCallback(npTrack, MIDISEQ_DONE, (DWORD_PTR)npTrack->inPort.hdrList, 0L);

            // done with it!
            npTrack->inPort.hdrList = npTrack->inPort.hdrList->lpNext; // point over it
            npTrack->inPort.currentPtr = npTrack->inPort.hdrList->lpData;
            npTrack->inPort.endPtr = npTrack->inPort.currentPtr + npTrack->inPort.hdrList->dwLength - 1;

            return *npTrack->inPort.currentPtr;
        }
        else
        {
            npTrack->blockedOn = on_input;

            //
            //  we CANT call wsprintf at interupt time
            //
            #ifdef ACK_DEBUG
                dprintf(("***** BLOCKED ON INPUT  ********* Trk: %u", npTrack->inPort.hdrList->wTrack));
            #endif
            // Note:  don't return buffer in this case 'cause it will be
            // needed when track gets unblocked (may have beginning of msg)
            return 0;
        }
    }
}
/**********************************************************/
PUBLIC BYTE NEAR PASCAL GetByte(NPTRACK npTrack)

{
    BYTE    theByte;

    theByte = LookByte(npTrack);
    if (!npTrack->blockedOn)
        npTrack->inPort.currentPtr++;
    return theByte;
}

/* The mark and reset location code is used to recover from aborted operations
during reading the input buffer.  Note:  it will bite like a big dog if a
message can span 3 buffers. (I.E.-- can't back up over a message boundary!) */

PUBLIC VOID NEAR PASCAL MarkLocation(NPTRACK npTrack)// remember current location
{
    npTrack->inPort.previousPtr = npTrack->inPort.currentPtr;
}

PUBLIC VOID NEAR PASCAL ResetLocation(NPTRACK npTrack)// restore last saved location
{
    npTrack->inPort.currentPtr = npTrack->inPort.previousPtr;
}

/**********************************************************/
PUBLIC VOID NEAR PASCAL RewindToStart(NPSEQ npSeq, NPTRACK npTrack)
/* sets all blocking status, frees buffers, and sends messages to stream mgr
   needed to prepare the track to play from the beginning.  It is up to
   someone at a higher level to set 'blockedOn' to a more mature (specific)
   status.  */
{
    // Streamer sets done and signals all buffers
    npTrack->inPort.hdrList = NULL;  // lose the list of headers
    npTrack->blockedOn = on_input;
    seqCallback(npTrack, MIDISEQ_RESET, npTrack->iTrackNum, 0L);
}

PUBLIC BOOL NEAR PASCAL AllTracksUnblocked(NPSEQ npSeq)
{   // use trackarray to avoid re-entrancy problems with list code
    UINT i;

    for(i = 0;  i < npSeq->wNumTrks;  i++)
        if (npSeq->npTrkArr->trkArr[i]->blockedOn != not_blocked)
            return FALSE;

    return TRUE;  // made it thru all tracks -- must be none blocked.
}

PRIVATE VOID NEAR PASCAL PlayUnblock(NPSEQ npSeq, NPTRACK npTrack)
{
    DestroyTimer(npSeq);
    FillInNextTrack(npTrack);

    if ((!npSeq->bSending) && (GetNextEvent(npSeq) == NoErr) &&
        (npSeq->playing))
    {
        dprintf2(("Fired up timer on track data"));
        SetTimerCallback(npSeq, MINPERIOD, npSeq->nextEventTrack->delta);
    }
}

PRIVATE VOID NEAR PASCAL SeekUnblock(NPSEQ npSeq, NPTRACK npTrack)
{
    FillInNextTrack(npTrack);
    if ((!npSeq->bSending) && (AllTracksUnblocked(npSeq)) &&
        (GetNextEvent(npSeq) == NoErr))  // exit until all unblocked
    {
        SendAllEventsB4(npSeq, (npSeq->seekTicks - npSeq->currentTick),
            MODE_SEEK_TICKS);
        if ((AllTracksUnblocked(npSeq)) &&
            ((npSeq->currentTick + npSeq->nextEventTrack->delta)
            >= npSeq->seekTicks))
        {  // have finished the song pointer command
            npSeq->seekTicks = NotInUse;   // signify -- got there
            if (npSeq->wCBMessage == SEQ_SEEKTICKS)
                NotifyCallback(npSeq->hStream);

            npSeq->readyToPlay = TRUE;
            if (npSeq->playing) // someone hit play while locating
            {
                npSeq->seekTicks = NotInUse;    // finally got there
                SetTimerCallback(npSeq, MINPERIOD, npSeq->nextEventTrack->delta);
            }
        }
    }
}


PUBLIC UINT NEAR PASCAL NewTrackData(NPSEQ npSeq, LPMIDISEQHDR msgHdr)
{
    WORD    wTrackNum;
    NPTRACK npTrack;
    LPMIDISEQHDR myMsgHdr;
    BOOL    tempPlaying;
    int     block;

    // look at track number it's for
    // get that track number (or return if couldn't find it)
    // make sure this one's next ptr is null
    // walk down the list of midi track data buffers and set last one to
    // point to this one
    // if blocked != NONE
    // save blocked status
    // clear any "blocked on input" bit in track (now that what it was
    // waiting for has arrived).
    // case blocked status: InputBetMsg: compute elapsed ticks & call timer int
    //                    InputWithinSysex: compute
    //                    Output:

    /* Get ptr to track referenced in message */
    wTrackNum = msgHdr->wTrack;
    #ifdef ACK_DEBUG
    {
        dprintf(("GOT TRACKDATA for TRACK#: %u", wTrackNum));
    }
    #endif

    /*
    can't call list routines for track at non-interrupt time
    npTrack = (NPTRACK) List_Get_First(npSeq->trackList);
    i = 0;
    while ((npTrack) && (i++ != wTrackNum))
        npTrack = (NPTRACK) List_Get_Next(npSeq->trackList, npTrack);
    */

    npTrack = npSeq->npTrkArr->trkArr[wTrackNum];

    if (!npTrack)
    {
        dprintf1(("ERROR -- BOGUS TRACK NUM IN TRACK DATA HEADER"));
        return 0;
    }

    EnterCrit();
    msgHdr->lpNext = NULL; //make sure header passed in is NULL
    if (myMsgHdr = npTrack->inPort.hdrList) // if track already has data
    {                                       // put this one at end of list
        while (myMsgHdr->lpNext)
            myMsgHdr = myMsgHdr->lpNext;
        myMsgHdr->lpNext = msgHdr;
    }
    else        // there are currently no headers in list
    {
        npTrack->inPort.hdrList = msgHdr; // make this 1st one
        npTrack->inPort.currentPtr = msgHdr->lpData;
        npTrack->inPort.endPtr = msgHdr->lpData + msgHdr->dwLength - 1;
    }
    LeaveCrit();

    /* Dispatcher for state machine */
    block = npTrack->blockedOn;          // temp var just for switch
    npTrack->blockedOn = not_blocked;

    switch (block)
    {
        case not_blocked:       /* null case */
            break;

        case in_SysEx:
            SendSysEx(npSeq); // send all sysex messages
            if (!npSeq->bSendingSysEx)   // totally done
                PlayUnblock(npSeq, npTrack);
            break;

        case in_SkipBytes_Play:
            SkipBytes(npTrack, npTrack->dwBytesLeftToSkip);
            if (npTrack->blockedOn)
            {
                // if blocked again, reset status and leave
                npTrack->blockedOn = in_SkipBytes_Play;
                break;
            }
            PlayUnblock(npSeq, npTrack);
            break;

        case in_Normal_Meta:
            HandleMetaEvent(npSeq, npTrack, FALSE); // handle pending meta
            PlayUnblock(npSeq, npTrack);
            break;

        case between_msg_out:  /* was blocked on input while filling a track */
            PlayUnblock(npSeq, npTrack);
            break;

        case in_SkipBytes_Seek:
            SkipBytes(npTrack, npTrack->dwBytesLeftToSkip);
            if (npTrack->blockedOn)
            {
                // if blocked again, reset status and leave
                npTrack->blockedOn = in_SkipBytes_Seek;
                break;
            }
            SeekUnblock(npSeq, npTrack);
            break;

        case in_Seek_Meta:
            HandleMetaEvent(npSeq, npTrack, FALSE);  // handle pending meta
            SeekUnblock(npSeq, npTrack);
            break;

        case in_Seek_Tick:
            SeekUnblock(npSeq, npTrack);
            break;


        /*  THE THREE STATES BELOW ARE ENCOUNTERED IN "SETUPTOPLAY" */

        case in_rewind_1:  /* blocked while rewinding to get meta events */
            if (AllTracksUnblocked(npSeq))  // exits until last track unblocked
            {
                if (!(ScanEarlyMetas(npSeq, NULL, 0x7fffffff))) // gets tempo, time-sig, SMPTE offset...from file
                {
                    List_Destroy(npSeq->tempoMapList);  // tempo map alloc failed
                    break;                              // (empty list signals it)
                }
                if (AllTracksUnblocked(npSeq))  // exits until last track unblocked
                {
                    ResetToBeginning(npSeq); // this is considered reset 2
                    SetBlockedTracksTo(npSeq, on_input, in_rewind_2); // 'mature' the input block state
                }
            }
            break;

        case in_rewind_2: /* blocked while rewinding to play the file */
            FillInNextTrack(npTrack); /* get ready to send 1st message -- this will
                                   wait until buffer arrives */
            if (AllTracksUnblocked(npSeq))  // DONE PARSING FILE NOW
            {
                npSeq->readyToPlay = TRUE;

                SendPatchCache(npSeq, TRUE);

                if (npSeq->seekTicks != NotInUse) // there's a pending song ptr
                {
                    tempPlaying = npSeq->playing; /* if there's a pending play
                                    message, must temporarily turn off */
                    npSeq->playing = FALSE;
                    midiSeqMessage((HMIDISEQ) npSeq, SEQ_SEEKTICKS, npSeq->seekTicks,
                        FALSE);
                    npSeq->playing = tempPlaying;
                }

                if ((GetNextEvent(npSeq) == NoErr) && (npSeq->playing))
                {
                    SetTimerCallback(npSeq, MINPERIOD, npSeq->nextEventTrack->delta);
                }
                // later can call DoSyncSetup(npSeq); (or roll this in with metas)
            }
            break;

        case in_SkipBytes_ScanEM: /* blocked while skipping bytes within a meta
                                or sysex */
            SkipBytes(npTrack, npTrack->dwBytesLeftToSkip);
            if (npTrack->blockedOn)
            {
                // if blocked again, reset status and leave
                npTrack->blockedOn = in_SkipBytes_ScanEM;
                break;
            }
            // else fall through

        case in_ScanEarlyMetas: /* blocked in ScanEarlyMetas routine */
            if (!(ScanEarlyMetas(npSeq, npTrack, 0x7fffffff))) // gets tempo, time-sig, SMPTE offset...from file
            {
                List_Destroy(npSeq->tempoMapList);  // tempo map alloc failed
                break;                              // (empty list signals it)
            }

            if (AllTracksUnblocked(npSeq))        // exits until last track unblocked
            {
                ResetToBeginning(npSeq); // this is considered reset 2
                SetBlockedTracksTo(npSeq, on_input, in_rewind_2); // 'mature' the input block state
            }
            break;

        case on_input:
        default:
            dprintf(("UNDEFINED STATE ENCOUNTERED IN NEWTRACKDATA"));
            break;
    }
    return 0;
}
/**********************************************************/
PUBLIC VOID FAR PASCAL _LOADDS OneShotTimer(UINT wId, UINT msg, DWORD_PTR dwUser, DWORD_PTR dwTime, DWORD_PTR dw2)  // called by l1timer.dll
{
    NPSEQ npSeq;

#ifdef DEBUG
    fInterruptTime++;
#endif

    npSeq = (NPSEQ)  dwUser;   // parameter is sequence

    npSeq->wTimerID = 0;  // invalidate timer id, since no longer in use
    TimerIntRoutine(npSeq, npSeq->dwTimerParam);

/*  debugging code enabled from time to time to isolate timer vs. seq. bugs

    static BOOL lockOut = FALSE;

    TimerStruct *myTimerStruct;

    if ((nextEventTime <= (systemTime++)) & (!lockOut))  //note that one ms has elapsed
    {
        lockOut = TRUE;
        myTimerStruct = (TimerStruct *) List_Get_First(timerList);
        while ((myTimerStruct) &&
        !((myTimerStruct->valid) && (myTimerStruct->time <= systemTime)))
            myTimerStruct = (TimerStruct *) List_Get_Next(timerList, myTimerStruct);

        if (myTimerStruct) // if didn't run completely thru list
        {
            // call the callback fn and mark record as invalid
            (*(myTimerStruct->func))((NPSEQ) myTimerStruct->instance, myTimerStruct->param);
            myTimerStruct->valid = FALSE;
            ComputeNextEventTime();
        }
        lockOut = FALSE;
    }  // if nexteventtime...
*/
#ifdef DEBUG
    fInterruptTime--;
#endif
}

/**********************************************************/
PUBLIC UINT NEAR PASCAL SetTimerCallback(NPSEQ npSeq, UINT msInterval, DWORD elapsedTicks)
// sets up to call back timerIntRoutine in msInt ms with elapseTcks
{
    npSeq->dwTimerParam = elapsedTicks;
    npSeq->wTimerID = timeSetEvent(msInterval, MINPERIOD, OneShotTimer,
        (DWORD_PTR)npSeq, TIME_ONESHOT | TIME_KILL_SYNCHRONOUS);
    if (!npSeq->wTimerID)
        return MIDISEQERR_TIMER;
    else
        return MIDISEQERR_NOERROR;
}

/**********************************************************/

PUBLIC VOID NEAR PASCAL DestroyTimer(NPSEQ npSeq)
{
    EnterCrit();

    if (npSeq->wTimerID) // if pending timer event
    {

       /*
        *  In the sequencer there are effectively two 'threads'
        *
        *     The application's thread and it's device threads which are
        *     all mutually synchronized via the sequencer critical section.
        *
        *     The timer callback thread which all runs off this process'
        *     dedicated timer thread.  We use EnterCrit(),  LeaveCrit() to
        *     share structures with this thread.
        *
        *  This routine is always called in the first of these 2
        *  environments so only one routine can be in it at any one time.
        *
        *  We can't disable interrupts on NT so we can have a hanging
        *  timer event and need to synchronize with this event on the
        *  timer thread.
        *
        *  In addition we can't keep the critical section
        *  when we call timeKillEvent (poor design in the timer code?)
        *  because all the timer work including timer cancelling is
        *  serialized on the timer thread.  Thus the hanging event may get
        *  in on the timer thread so :
        *
        *    This Thread                    Timer thread
        *
        *   In DestroyTimer               In timer event callback
        *
        *   <Owns CritSec>                Waiting for CritSec - BLOCKED
        *
        *   WaitForSingleObject  BLOCKED  ... Would set (timer thread completion)
        *  (timer thread completion)          if it got CritSec
        *
        *
        *  We therefore set the 'timer entered' flag which will stop the
        *  timer routine doing anything when it gets in and get out of
        *  the critical section so the Event routine can run.
        *
        *  We know that nobody else is going to set a timer
        *  because we have the sequencer critical section at this point
        *  and we have disabled the interrupt routine.
        */

        npSeq->bTimerEntered = TRUE;

       /*
        *  Now we can get out of the critical section and any timer can
        *  fire without damaging anything.
        */

        LeaveCrit();

       /*
        *  cancel any pending timer events
        */

        timeKillEvent(npSeq->wTimerID);

       /*
        *  No timer will fire now because the timeKillEvent is synchronized
        *  with the timer events so we can tidy up our flag and id without
        *  needing the critical section.
        */

        npSeq->bTimerEntered = FALSE;
        npSeq->wTimerID = 0;
    } else {
        LeaveCrit();
    }
}


/***********************  DEBUG CODE *************************************/

/*
void Timer_Cancel_All(DWORD instance)
    // search the list, purging everything with same instance
{
    TimerStruct *myTimerStruct;
    for(myTimerStruct = (TimerStruct *) List_Get_First(timerList);
      myTimerStruct ;myTimerStruct = (TimerStruct *) List_Get_Next(timerList, myTimerStruct))
        if ((myTimerStruct->valid) && (myTimerStruct->instance = instance))
            myTimerStruct->valid = FALSE;
    ComputeNextEventTime();
}
*/

/**********************************************************/
/* void IdlePlayAllSeqs()
{

    SeqStreamType   *seqStream;
    TrackStreamType *trackStream;
    int             iDataToRead;
    int             i;
    DWORD           sysTime;

    sysTime = timeGetTime();

    seqStream = (SeqStreamType*) List_Get_First(SeqStreamListHandle);

    while (seqStream)
    {
        if ((seqStream->seq) && (seqStream->seq->nextEventTrack) &&
            (sysTime >= seqStream->seq->nextExactTime))
        {
            TimerIntRoutine(seqStream->seq,
                                 seqStream->seq->nextEventTrack->delta);
        }
    }

}
*/
/*
void ComputeNextEventTime()
{
    TimerStruct *myTimerStruct;

    nextEventTime = 0x7FFFFFFF;  // make it a long time

    myTimerStruct = (TimerStruct *) List_Get_First(timerList);
    while (myTimerStruct)
    {
        if ((myTimerStruct->valid) && (myTimerStruct->time < nextEventTime))
            nextEventTime = myTimerStruct->time;  // replace it with shortest
        myTimerStruct = (TimerStruct *) List_Get_Next(timerList, myTimerStruct);
    }
}
*/

/**********************************************************/
PUBLIC VOID FAR PASCAL _LOADDS MIDICallback(HMIDIOUT hMIDIOut, UINT wMsg,
    DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
    if (wMsg == MOM_DONE)
    {  // just finished a long buffer
        NPSEQ   npSeq;

        // dprintf3(("Callback on long buffer"));
        npSeq = (NPSEQ)(UINT_PTR) ((LPMIDIHDR)dwParam1)->dwUser; //derive npSeq
        if (npSeq->bSysExBlock) // was it blocked on sysex?
        {
            npSeq->bSysExBlock = FALSE; // not anymore!
            SendSysEx(npSeq); // send all sysex messages
            if (!npSeq->bSendingSysEx)   // if totally done with sysex
            {
                FillInNextTrack(npSeq->nextEventTrack); // set up to play
                if ((GetNextEvent(npSeq) == NoErr) && (npSeq->playing))
                {
                    dprintf3(("resume play from sysex unblock"));
                    // ...and play
                    SetTimerCallback(npSeq, MINPERIOD, npSeq->nextEventTrack->delta);
                }
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciseq\support.c ===
/*******************************Module*Header*********************************\
* Module Name: support.c
*
* MultiMedia Systems MIDI Sequencer DLL
*
* Created: 27-Feb-1992
* Author:  ROBINSP
*
* History:
*
* Copyright (c) 1985-1998 Microsoft Corporation
*
\******************************************************************************/
#define UNICODE

#include <windows.h>
#include <mmsystem.h>
#include <mmsys.h>

CRITICAL_SECTION CritSec;
CRITICAL_SECTION SeqCritSec;

//
// Cut-down critical section stuff
//

VOID InitCrit(VOID)
{
    InitializeCriticalSection(&CritSec);
    InitializeCriticalSection(&SeqCritSec);
}

VOID DeleteCrit(VOID)
{
    DeleteCriticalSection(&CritSec);
    DeleteCriticalSection(&SeqCritSec);
}

VOID EnterCrit(VOID)
{
    EnterCriticalSection(&CritSec);
}

VOID LeaveCrit(VOID)
{
    LeaveCriticalSection(&CritSec);
}

VOID EnterSeq(VOID)
{
    EnterCriticalSection(&SeqCritSec);
}

VOID LeaveSeq(VOID)
{
    LeaveCriticalSection(&SeqCritSec);
    Sleep(4);   // Give someone else a chance
}

/*************************************************************************
 *
 * @doc     MCISEQ
 *
 * @func    UINT | TaskBlock |  This function blocks the current
 *          task context if its event count is 0.
 *
 * @rdesc   Returns the message value of the signal sent.
 *
 ************************************************************************/

UINT TaskBlock(VOID)
{
    MSG msg;

    LeaveSeq();

  /*
   *   Loop until we get the message we want
   */
   for (;;) {
      /*
       *   Retrieve any message for task
       */
       GetMessage(&msg, NULL, 0, 0);

      /*
       *   If the message is for a window dispatch it
       */
       if (msg.hwnd != NULL) {
           DispatchMessage(&msg);
       } else {
           break;
       }
   }

   EnterSeq();
   return msg.message;
}


/*************************************************************************
 *
 * @doc     MCISEQ
 *
 * @func    BOOL | TaskSignal |  This function signals the specified
 *          task, incrementing its event count and unblocking
 *          it.
 *
 * @parm    DWORD | dwThreadId | Thread ID from <f mmGetCurrentTask>.
 *
 * @parm    UINT | Msg | Signal message to send.
 *
 * @rdesc   Returns TRUE if the signal was sent, else FALSE if the message
 *          queue was full.
 *
 * @xref    mmTaskBlock  mmTaskCreate
 *
 * @comm    For predictable results, must only be called from a task
 *          created with <f mmTaskCreate>.
 *
 ************************************************************************/
BOOL TaskSignal(DWORD dwThreadId, UINT Msg)
{
    return PostThreadMessage(dwThreadId, Msg, 0, 0);
}

/*************************************************************************
 *
 * @doc     MCISEQ
 *
 * @func    VOID | TaskWaitComplete |  This function waits for the
 *          specified task to terminate.
 *
 * @parm    HANDLE | h | Task handle. For predictable results, get the
 *          task handle from <f mmGetCurrentTask>.
 *
 * @rdesc   No return code
 *
 ************************************************************************/
VOID TaskWaitComplete(HANDLE h)
{
    LeaveSeq();
    WaitForSingleObject(h, INFINITE);  // Wait (no timeout) for thread to complete

    CloseHandle(h);

    // Note that the handle will be freed by thread itself.

    EnterSeq();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\mcivisca\appport.h ===
//**************************************************************************
//*
//*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//*  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//*  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//*  PURPOSE.
//*
//*  Copyright (c) 1992-1995 Microsoft Corporation
//* 
//*
//*  appport.h -- Win 16/32 Portability
//*
//*  Description:
//*      This file contains common macros to help with writing code that
//*      cross compiles between Win 32 and Win 16. This file should be
//*      included _after_ windows.h and windowsx.h.
//*
//**************************************************************************

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 32
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef _WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     _stdcall
        #define FNCLOCAL    _stdcall
        #define FNGLOBAL    _stdcall
        #define FNCGLOBAL   _stdcall
        #define FNCALLBACK  CALLBACK
        #define FNEXPORT    CALLBACK
    #endif

    #ifndef PCTSTR
        typedef const PTSTR     PCTSTR;
    #endif
    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)    \
        ((DWORD)SendMessage((hwndCtl), EM_GETSEL, (WPARAM)pnS, (LPARAM)pnE))

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)   sizeof(x)
    #endif

    #define HTASK       HANDLE

#endif // #ifdef _WIN32


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef _WIN32
    #ifndef FNLOCAL
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
        #define FNCALLBACK  CALLBACK
        #define FNEXPORT    CALLBACK _export
    #endif

    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef const PTSTR     PCTSTR;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)

    //
    //
    //
    #define CharNext        AnsiNext
    #define CharPrev        AnsiPrev

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)                        \
    {                                                               \
        DWORD   dw;                                                 \
        dw = (DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L);       \
        *pnE = (int)HIWORD(dw);                                     \
        *pnS = (int)LOWORD(dw);                                     \
    }

    //
    //  common message cracker macros available in windowx.h on NT--these
    //  should be added to the Win 16 windowsx.h and probably will be
    //  in the future.
    //
    //  there is a windowsx.h16 that ships with the NT PDK that defines
    //  these macros. so if that version is being used, don't redefine
    //  message crackers.
    //

#ifndef WM_CTLCOLORMSGBOX
    #define WM_CTLCOLORMSGBOX           0x0132
    #define WM_CTLCOLOREDIT             0x0133
    #define WM_CTLCOLORLISTBOX          0x0134
    #define WM_CTLCOLORBTN              0x0135
    #define WM_CTLCOLORDLG              0x0136
    #define WM_CTLCOLORSCROLLBAR        0x0137
    #define WM_CTLCOLORSTATIC           0x0138
#endif

#ifndef GET_WM_ACTIVATE_STATE
    #define GET_WM_ACTIVATE_STATE(wp, lp)           (wp)
    #define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)      (BOOL)HIWORD(lp)
    #define GET_WM_ACTIVATE_HWND(wp, lp)            (HWND)LOWORD(lp)
    #define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)      (WPARAM)(s), MAKELONG(hwnd, fmin)

    #define GET_WM_CHARTOITEM_CHAR(wp, lp)          (CHAR)(wp)
    #define GET_WM_CHARTOITEM_POS(wp, lp)           HIWORD(lp)
    #define GET_WM_CHARTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd)    (WPARAM)(ch), MAKELONG(hwnd, pos)

    #define GET_WM_COMMAND_ID(wp, lp)               (wp)
    #define GET_WM_COMMAND_HWND(wp, lp)             (HWND)LOWORD(lp)
    #define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(lp)
    #define GET_WM_COMMAND_MPS(id, hwnd, cmd)       (WPARAM)(id), MAKELONG(hwnd, cmd)

    #define GET_WM_CTLCOLOR_HDC(wp, lp, msg)        (HDC)(wp)
    #define GET_WM_CTLCOLOR_HWND(wp, lp, msg)       (HWND)LOWORD(lp)
    #define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)       HIWORD(lp)
    #define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type)    (WPARAM)(hdc), MAKELONG(hwnd, type)

    #define GET_WM_MENUSELECT_CMD(wp, lp)           (wp)
    #define GET_WM_MENUSELECT_FLAGS(wp, lp)         LOWORD(lp)
    #define GET_WM_MENUSELECT_HMENU(wp, lp)         (HMENU)HIWORD(lp)
    #define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)    (WPARAM)(cmd), MAKELONG(f, hmenu)

    // Note: the following are for interpreting MDIclient to MDI child messages.
    #define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (BOOL)(wp)
    #define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
    #define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)

    // Note: the following is for sending to the MDI client window.
    #define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA) (WPARAM)(hwndA), 0

    #define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW)   0, MAKELONG(hmenuF, hmenuW)

    #define GET_WM_MENUCHAR_CHAR(wp, lp)            (CHAR)(wp)
    #define GET_WM_MENUCHAR_HMENU(wp, lp)           (HMENU)LOWORD(lp)
    #define GET_WM_MENUCHAR_FMENU(wp, lp)           (BOOL)HIWORD(lp)
    #define GET_WM_MENUCHAR_MPS(ch, hmenu, f)       (WPARAM)(ch), MAKELONG(hmenu, f)

    #define GET_WM_PARENTNOTIFY_MSG(wp, lp)         (wp)
    #define GET_WM_PARENTNOTIFY_ID(wp, lp)          HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)   (HWND)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_X(wp, lp)           (INT)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_Y(wp, lp)           (INT)HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd)  (WPARAM)(msg), MAKELONG(hwnd, id)
    #define GET_WM_PARENTNOTIFY2_MPS(msg, x, y)     (WPARAM)(msg), MAKELONG(x, y)

    #define GET_WM_VKEYTOITEM_CODE(wp, lp)          (wp)
    #define GET_WM_VKEYTOITEM_ITEM(wp, lp)          (INT)HIWORD(lp)
    #define GET_WM_VKEYTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) (WPARAM)(code), MAKELONG(hwnd, item)

    #define GET_EM_SETSEL_START(wp, lp)             LOWORD(lp)
    #define GET_EM_SETSEL_END(wp, lp)               HIWORD(lp)
    #define GET_EM_SETSEL_MPS(iStart, iEnd)         0, MAKELONG(iStart, iEnd)

    #define GET_EM_LINESCROLL_MPS(vert, horz)       0, MAKELONG(vert, horz)

    #define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)   (HWND)LOWORD(lp)

    #define GET_WM_HSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_HSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_HSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_HSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)

    #define GET_WM_VSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_VSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_VSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_VSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)
#endif

#endif // #ifndef _WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\mcivisca\common.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992-1995 Microsoft Corporation
 * 
 *  COMMON.C
 *
 *  Description:
 *      Common functions useful for Windows programs.
 *
 *  Notes:
 *      This module is NOT to be declared unicode!
 *
 **************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include "appport.h"
#include "vcr.h"
#include "viscadef.h"
#include "mcivisca.h"
#include "viscamsg.h"
#include "common.h"

#ifdef DEBUG
char    ach[300];        // debug output (avoid stack overflow)
                        // each attaching process should have own
                        // version of this.

void NEAR PASCAL
DebugPrintf(int iDebugMask, LPSTR szFormat, LPSTR szArg1)
{
    // Errors always get printer, iDebugMask == 0
    if(!(iDebugMask & pvcr->iGlobalDebugMask) && (iDebugMask))
        return;

    wvsprintf(ach, szFormat, szArg1);

    if(!iDebugMask)
        OutputDebugString("Error: ");

    /* output the debug string */
    OutputDebugString(ach);
}

void FAR _cdecl _DPF1(iDebugMask, szFormat, iArg1, ...)
int     iDebugMask;
LPSTR    szFormat;    // debug output format string
int        iArg1;        // placeholder for first argument
{
    DebugPrintf(iDebugMask, szFormat, (LPSTR) &iArg1);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\mcivisca\cnfgdlg.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992-1995 Microsoft Corporation
 * 
 **************************************************************************/

#define IDD_VISCACNFG               100
#define IDD_STATIC_PORT             101
#define IDD_COMBO_PORT              102
#define IDD_STATIC_NUMVCRS          103
#define IDD_COMBO_DEVICE            104
#define IDD_CHECK_FREEZE            106
#define IDDETECT                    107
#define IDD_VCRONE                  108
#define IDD_VCRTWO                  109
#define IDD_VCRTHREE                110
#define IDD_VCRFOUR                 111
#define IDD_VCRFIVE                 112
#define IDD_VCRSIX                  113
#define IDD_VCRSEVEN                114
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\mcivisca\common.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992-1995 Microsoft Corporation
 *
 *  COMMON.H
 *
 *  MCI ViSCA Device Driver
 *
 *  Description:
 *
 *      Debugging macros.
 *
 ***************************************************************************/
#ifdef DEBUG

#define DPF	            _DPF1
void FAR cdecl          _DPF1(int iDebugMask, LPSTR szFormat, ...);
void FAR PASCAL         viscaPacketPrint(LPSTR lpstrData, UINT cbData);
#define DOUTSTR(a)      OutputDebugString(a)
#define DOUTSTRC(a, b)  { if(a) OutputDebugString(b); }

#define DBG_ERROR       0x00    // Errors always get printed if at least one.
#define DBG_MEM         0x01
#define DBG_MCI         0x02
#define DBG_COMM        0x04
#define DBG_QUEUE       0x08
#define DBG_SYNC        0x10
#define DBG_TASK        0x20
#define DBG_CONFIG      0x40

#define DBG_ALL         0xff
#define DBG_NONE        0x00    // This only prints the errors out.

// Use DBGMASK_CURRENT to specify things like (DBG_MEM | DBG_QUEUE)
#define DBGMASK_CURRENT    (DBG_CONFIG | DBG_MEM | DBG_MCI | DBG_COMM | DBG_TASK)

#define DF(a, b)        if(a & DBGMASK_CURRENT) { b;}

#else
#define DF(a, b)                    / ## /
#define DOUTSTR(a)                  / ## /
#define DPF	                        / ## /
#define viscaPacketPrint(a, b)      / ## /
#define DOUTSTRC(a, b)   	        / ## /

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\mcivisca\libinit.asm ===
page	,132
;-----------------------------Module-Header-----------------------------;
;
;   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
;   KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
;   IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
;   PURPOSE.
;
;   Copyright (c) 1992-1995 Microsoft Corporation
;
;
;   Module Name:  LIBINIT.ASM
;
;   library stub to do local init for a Dynamic linked library
;
;   Exported Functions:   none
;
;   Public Functions:     none
;
;   Public Data:		none
;
;   General Description:
;
;   Restrictions:
;
;       This must be the first object file in the LINK line, this assures
;       that the reserved parameter block is at the *base* of DGROUP
;
;-----------------------------------------------------------------------;

?PLM=1      ; PASCAL Calling convention is DEFAULT
?WIN=1	    ; Windows calling convention

        .286
	.xlist
	include cmacros.inc
;       include windows.inc
        .list

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;
;   externs from KERNEL
;
        externFP    <LocalInit>
        externFP    <FatalAppExit>

;-----------------------------------------------------------------------;
;
;   LibMain is the function in C code we will call on a DLL load.
;   it is assumed in the same segment as we are.
;
;;;;;;;;externNP    <LibMain>
        externFP    <LibMain>  ;; Use this line if LibMain is far call

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
sBegin  Data
assumes DS,Data
            org 0               ; base of DATA segment!

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
	__acrtused = 1

sEnd        Data

;-----------------------------------------------------------------------;

sBegin  CodeSeg
        assumes cs,CodeSeg

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used by a DLL)
;
; Returns:
;       AX = TRUE if success
; Error Returns:
;       AX = FALSE if error (ie fail load process)
; Registers Preserved:
;	SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,ES,FLAGS
; Calls:
;	None
; History:
;
;       06-27-89    Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
ifdef DEBUG
        ;
        ; if this module is not linked first the reserved parameter block
        ; will not be initialized correctly, check for this and
        ;
        lea     ax,pLocalHeap
        cmp     ax,6
        je      RsrvPtrsOk

RsrvPtrsHosed:
        int     3

        lea     ax,RsrvPtrsMsg
        cCall   FatalAppExit,<0,cs,ax>
        jmp short    RsrvPtrsOk

RsrvPtrsMsg:
        db      'RsrvPtrs hosed!',0

RsrvPtrsOk:
endif
	;
        ; Push frame for LibMain (hModule,cbHeap,lpszCmdLine)
	;
	push	di
	push	cx
	push	es
	push	si

        ;
        ; Init the local heap (if one is declared in the .def file)
        ;
        jcxz no_heap

        cCall   LocalInit,<0,0,cx>

no_heap:
        cCall   LibMain
cEnd

;--------------------------Exported-Routine-----------------------------;
;
;   WEP()
;
;   called when the DLL is unloaded, it is passed 1 WORD parameter that
;   is TRUE if the system is going down, or zero if the app is
;
;   WARNING:
;
;       This function is basicly useless, you cant can any kernel function
;       that may cause the LoadModule() code to be reentered..
;
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   WEP,<FAR,PUBLIC,NODATA>,<>
        ParmW  BogusParameter
cBegin
cEnd

sEnd    CodeSeg

        end     LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\mcivisca\commtask.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992-1995 Microsoft Corporation
 * 
 *  COMMTASK.C
 *
 *  MCI ViSCA Device Driver
 *
 *  Description:
 * 
 *      Background task procedures
 *
 ***************************************************************************/

#define  UNICODE
#include <windows.h>
#include <windowsx.h>
#include "appport.h"
#include <mmsystem.h>
#include <mmddk.h>
#include <string.h>
#include "vcr.h"
#include "viscadef.h"
#include "mcivisca.h"
#include "common.h"

//
// Global (not-changing) 
//
CODESEGCHAR szCommNotifyHandlerClassName[]  = TEXT("ViSCACommNotifyHandler");
extern HINSTANCE       hModuleInstance;    // module instance  (different in NT - DLL instances)

//
// Forward references to non-exported functions.
//
long FAR PASCAL TxThread(LPVOID uPort);  
long FAR PASCAL RxThread(LPVOID uPort);

static void NEAR PASCAL viscaAck(int iInst, BOOL FAR *pfTxRelease);
static void NEAR PASCAL viscaSuccessfulCompletion(int iInst, LPSTR lpstrPacket, BOOL FAR *pfTxRelease);
static void NEAR PASCAL viscaErrorCompletion(int iInst, LPSTR lpstrPacket, BOOL FAR *pfTxRelease);

static void NEAR PASCAL viscaAutoAck(UINT iPort, UINT iDev);
static void NEAR PASCAL viscaAutoSuccessfulCompletion(UINT iPort, UINT iDev, LPSTR lpstrPacket, BOOL FAR *pfTxRelease);
static void NEAR PASCAL viscaAutoErrorCompletion(UINT iPort, UINT iDev, LPSTR lpstrPacket, BOOL FAR *pfTxRelease);

static void NEAR PASCAL viscaReleaseAuto(UINT iPort, UINT iDev, DWORD dwNotify);
static BOOL NEAR PASCAL viscaAutoWrite(UINT iPort, UINT iDev, BOOL fBlockable, UINT uAutoBlocked, BOOL FAR *pfTxRelease); 
static BOOL NEAR PASCAL viscaSetCommandComplete(UINT iPort, UINT iDev, UINT uViscaCmd);
static void NEAR PASCAL TaskDoCommand(UINT uTaskState, DWORD lParam);
static void FAR  PASCAL SignalInstance(int iInst, BYTE bReplyFlags);
static void FAR  PASCAL SignalDevice(int iPort, int iDev, BYTE bReplyFlags);

#ifndef _WIN32
/****************************************************************************
 * Function: int viscaCommRead - Read bytes from a serial port.
 *
 * Parameters:
 *
 *      int idComDev - Comm device ID.
 *
 *      LPSTR lpstrData - Buffer into which to read data.
 *
 *      UINT cbData - Number of bytes to read.
 *
 *      UINT uWait - Maximum number of milliseconds to wait for data.
 *
 * Returns: 0 if successful, otherwise -1.
 ***************************************************************************/
static int NEAR PASCAL
    viscaCommRead(int idComDev, LPSTR lpstrData, UINT cbData, UINT uWait)
{
    int     cbRead;
    DWORD   dwTime0 = GetCurrentTime();
    DWORD   dwTime;
    
    while (cbData)
    {
        cbRead = ReadComm(idComDev, lpstrData, cbData);
        if (cbRead > 0)
        {
            lpstrData += cbRead;
            cbData -= cbRead;
        }
        else
        {
            if (GetCommError(idComDev, NULL))
            {
                DPF(DBG_ERROR, "viscaCommRead: GetCommError !\n");
                return (-1);
            }
            dwTime = GetCurrentTime();
            if (((dwTime < dwTime0) && ((dwTime + (ROLLOVER - dwTime0)) > uWait)) || 
                ((dwTime - dwTime0) > uWait))
            {
                DPF(DBG_ERROR, "viscaCommRead Timeout !");
                DPF(DBG_ERROR, "dwTime=%lu, dwTime0=%lu\n", dwTime, dwTime0);
                return (-1);
            }
        }
    }
    return (0);
}

/****************************************************************************
 * Function: int viscaCommWrite - Write bytes to a serial port.
 *
 * Parameters:
 *
 *      int idComDev - Comm device ID.
 *
 *      LPSTR lpstrData - Buffer to write.
 *
 *      UINT cbData - Number of bytes to read.
 *
 * Returns: TRUE if successful, otherwise FALSE.
 ***************************************************************************/
BOOL FAR PASCAL
    viscaCommWrite(int idComDev, LPSTR lpstrData, UINT cbData)
{
    int     cbWritten;

    while (cbData)
    {
        cbWritten = WriteComm(idComDev, lpstrData, cbData);
        if (cbWritten > 0)
        {
            lpstrData += cbWritten;
            cbData -= cbWritten;
        }
        else
        {
            if (GetCommError(idComDev, NULL))
            {
                return (0);
            }
        }
    }
    return (TRUE);
}
#endif


/****************************************************************************
 * Function: int viscaCommPortSetup - Open and setup the given comm port.
 *
 * Parameters:
 *
 *      int nComPort - Comm port to open (1..4).
 *
 * Returns: comm device ID if successful, otherwise a negative error
 *        code.
 ***************************************************************************/
VISCACOMMHANDLE FAR PASCAL
    viscaCommPortSetup(UINT nComPort)
{
    VISCACOMMHANDLE idComDev;
    int             err = 0;
    WCHAR           szDevControl[20];  
    DCB             dcb;
#ifdef _WIN32
    BOOL            bSuccess;
    COMMTIMEOUTS    toutComm;
#endif
    DPF(DBG_COMM, "Opening port number %u", nComPort);

    CreatePortHandles(pvcr->htaskCommNotifyHandler, nComPort-1);
    wsprintf(szDevControl, TEXT("COM%u"), nComPort);

#ifdef _WIN32
    idComDev = CreateFile(szDevControl, GENERIC_READ | GENERIC_WRITE,
                            0,              // exclusive access
                            NULL,           // no security
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL, // | FILE_FLAG_OVERLAPPED
                            NULL);

    // Set our timeouts to infinite, which means non-blocking.

    toutComm.ReadIntervalTimeout        = MAXDWORD;
    toutComm.ReadTotalTimeoutConstant   = 0;
    toutComm.ReadTotalTimeoutMultiplier = 0;

    SetCommTimeouts(idComDev, &toutComm);

    if(!idComDev)
        return FALSE;
    
    bSuccess = GetCommState(idComDev, &dcb);

    if(!bSuccess)
    {
        DPF(DBG_ERROR, "GetCommState has failed.\n");
    }

    dcb.BaudRate = 9600;
    dcb.ByteSize = 8;
    dcb.Parity   = NOPARITY;
    dcb.StopBits = ONESTOPBIT;

    bSuccess = SetCommState(idComDev, &dcb);

    if(!bSuccess)
    {
        DPF(DBG_ERROR, "SetCommState has failed\n");
    }

#else
    idComDev = OpenComm(szDevControl, 512, 128);
    if (idComDev < 0)
    {
        DPF(DBG_ERROR, "OpenComm(\"%s\", 512, 128) returned %d\n",(LPSTR)szDevControl, idComDev);
        return (idComDev);
    }
    
    wsprintf(szDevControl, "COM%u:9600,n,8,1", nComPort);
    err = BuildCommDCB(szDevControl, &dcb);
    if (err < 0)
    {
        DPF(DBG_ERROR, "BuildCommDCB(\"%s\", &dcb) returned %d\n",(LPSTR)szDevControl, err);
        CloseComm(idComDev);
        return (err);
    }
    
    err = SetCommState(&dcb);
    if (err < 0)
    {
        DPF(DBG_ERROR, "SetCommStat(&dcb) returned %d\n", err);
        CloseComm(idComDev);
        return (err);
    }
    
    FlushComm(idComDev, 0);
    FlushComm(idComDev, 1);

    EnableCommNotification(idComDev, pvcr->hwndCommNotifyHandler, 1, -1);
#endif
    return (idComDev); 
}


/****************************************************************************
 * Function: int viscaCommPortClose - Close an open comm port.
 *
 * Parameters:
 *
 *      int idComDev - Comm device ID to close.
 *
 * Returns: value returned by CloseComm() -- 0 if successful,
 *        otherwise less than 0.
 ***************************************************************************/
int FAR PASCAL
    viscaCommPortClose(VISCACOMMHANDLE idComDev, UINT uPort)
{
    return (MCloseComm(idComDev));
}

#ifdef _WIN32
BOOL IsTask(VISCAHTASK hTask)
{
    if(hTask != 0)
        return TRUE;
    else
        return FALSE;
}
#endif


#ifndef _WIN32
/****************************************************************************
 * Function: int    viscaPacketRead - Read a ViSCA packet from a serial port.
 *
 * Parameters:
 *
 *      int    idComDev      - Comm device ID.
 *
 *      LPSTR  lpstrPacket   - Buffer into which to read packet.
 *
 * Returns: 0 if successful, otherwise -1.
 ***************************************************************************/
static int NEAR PASCAL
    viscaPacketRead(int idComDev, LPSTR lpstrPacket)
{
    UINT    cbPacket = 0;
 
    if (viscaCommRead(idComDev, lpstrPacket, 1, PACKET_TIMEOUT))
    {
        DPF(DBG_ERROR, "Error reading 1st character!\n");
        return (-1);
    }
    while ((unsigned char) *lpstrPacket != (unsigned char)0xFF)
    {
        lpstrPacket++;
        cbPacket++;
        if (cbPacket == MAXPACKETLENGTH)
        {
            //
            // We've read max bytes, but still haven't got 0xff.
            //
            DPF(DBG_ERROR, " Bad Packet! No 0xFF!\n");
            return (-1);
        }
        if (viscaCommRead(idComDev, lpstrPacket, 1, PACKET_TIMEOUT))
        {
            DPF(DBG_ERROR, " viscaPacketRead, read: ");
            viscaPacketPrint(lpstrPacket - cbPacket, cbPacket);
            return (-1);
        }
    }
    lpstrPacket++;

    DPF(DBG_COMM, "---Read: ");
    viscaPacketPrint(lpstrPacket - cbPacket - 1, cbPacket + 1);

    return (0);
}
#endif

/****************************************************************************
 * Function: BOOL   viscaDeviceControl - Determine instance that started command and unlock or
 *                                      Lock device, etc.
 *
 * Parameters:
 *
 *      UINT   iPort         - Index of port on which message was received (0..3).
 *
 *      LPSTR  lpstrPacket   - ViSCA packet to process. 
 *
 * Returns: TRUE if processing should continue, FALSE if processing should return.
 *
 ***************************************************************************/
static BOOL NEAR PASCAL
    viscaDeviceControl(UINT iPort, LPSTR lpstrPacket, int FAR  *piInstReturn, BYTE FAR *pbRetType, UINT FAR *piDevReturn,
                        BOOL FAR *pfTxRelease)
{
    UINT            iDev    = VISCAREPLYDEVICE(lpstrPacket);
    int             iSocket = VISCAREPLYSOCKET(lpstrPacket);
    BYTE            bType   = VISCAREPLYTYPE(lpstrPacket);
    BOOL            fSocket = FALSE;


    //
    // If there is no device, there can be no socket. (like with cancel)
    //
    if(iDev==0)    
        iSocket = 0;

    *pfTxRelease = FALSE;

    if (((*lpstrPacket & 0x80) == 0x00) || (VISCAREPLYTODEVICE(lpstrPacket) != MASTERADDRESS))
    {
        // We're seriously hosed.
        DPF(DBG_ERROR, "Bad Packet\n");
        return (FALSE);
    }

    //
    // Don't be fooled! An error message 0x90 0x61 0x05 has a socket of 1
    // but error of 5.  That means No socket to be cancelled.
    //
    if((bType == VISCAREPLYERROR) &&
       iSocket                    &&
       (VISCAREPLYERRORCODE(lpstrPacket)==VISCAERRORNOSOCKET))
    {
        // Help it out by setting the socket to 0.
        iSocket = 0;
    }

    //
    // If port is locked, then this message MUST be response for port message.
    //
    if((BYTE)lpstrPacket[0] == VISCABROADCAST) // Broadcast response 0x88
    {
        iDev = pvcr->Port[iPort].iBroadcastDev; // Get responsible inst!
        *piDevReturn  = iDev;

        *piInstReturn = pvcr->Port[iPort].Dev[iDev].iInstReply;
        DPF(DBG_COMM, "Received a port message. port=%u, dev=%u, inst = %u", iPort, iDev, *piInstReturn);

        if(*piInstReturn != -1)
        {
            _fmemcpy(pinst[*piInstReturn].achPacket, lpstrPacket, MAXPACKETLENGTH);
            pinst[*piInstReturn].bReplyFlags |= VISCAF_COMPLETION;
            SignalInstance(*piInstReturn, VISCAF_ACK); // Ack and completion.
            SignalInstance(*piInstReturn, VISCAF_COMPLETION);
        }

        // This is not possible    
        if(pvcr->Port[iPort].Dev[iDev].fAckTimer)
        {
            KillTimer(pvcr->hwndCommNotifyHandler, MAKEACKTIMERID(iPort, 0));
            pvcr->Port[iPort].Dev[iDev].fAckTimer = FALSE;
        }
        
        *pfTxRelease = TRUE; // Not necessary.
        return FALSE;
    }

    if(iDev && pvcr->Port[iPort].Dev[iDev - 1].fTimerMsg)
    {
        //
        // This message has been generated by us to extend certain commands past their normal notifications.
        //
        iDev--;
        *piInstReturn = pvcr->iInstBackground;
        *piDevReturn  = iDev;
        DPF(DBG_COMM, "Timer message device=%d received.\n",iDev);
    }
    else if (iSocket && ((bType == VISCAREPLYCOMPLETION) || (bType == VISCAREPLYERROR)))
    {
        //                 (5x)                (6x)
        // This is either: command-complete or error.
        // And           : socket specified.
        //
        //
        // It is not possible that tx is locked here.
        //
        iDev--;
        iSocket--;
        fSocket = TRUE;
        //
        // Error codes 0x6n 0x04 where n is a valid socket will GO smoothly here.
        //
        // Which instance started this command.
        //
        *piInstReturn = pvcr->Port[iPort].Dev[iDev].rgSocket[iSocket].iInstReply;
        *piDevReturn  = iDev;
        pvcr->Port[iPort].Dev[iDev].rgSocket[iSocket].iInstReply = -1;
        //
        // If this is the auto-instance, then we need to know nothing more, clear socket.
        //
        if(*piInstReturn == pvcr->iInstBackground)
            pvcr->Port[iPort].Dev[iDev].iTransportSocket = -1;

        // Do not release TxLock here! Socket completions are asynchronous
    }
    else if (iDev)
    {
        // This is not a (socket completion) or (socket error).
        // 
        // The remaining options are:
        //      Socket ack.                 (4x)
        //      Non-socket completion.      (50)
        //      Non-socket error.           (60)
        //
        // The reason these are grouped together is that they all are
        // immediate responses to a sent command.
        //
        // If it is a cancelled message just ignore and return
        //
        if((bType == VISCAREPLYERROR) && (VISCAREPLYERRORCODE(lpstrPacket)==VISCAERRORCANCELLED))
            // Cancel commands do not block transmission.
            return FALSE;

        if((bType == VISCAREPLYERROR) && (VISCAREPLYERRORCODE(lpstrPacket)==VISCAERRORNOSOCKET))
            // Cancel commands do not block transmission.
            return FALSE;

        iDev--;
        //
        // Which instance started this command.
        //
        *piInstReturn = pvcr->Port[iPort].Dev[iDev].iInstReply;
        *piDevReturn  = iDev;
        pvcr->Port[iPort].Dev[iDev].iInstReply = -1;

        if (iSocket && (*piInstReturn != -1))
        {
            //
            // Ack with socket.  And there is an instance waiting for the ack.
            //
            fSocket = TRUE;
            iSocket--;
            pvcr->Port[iPort].Dev[iDev].rgSocket[iSocket].iInstReply = *piInstReturn;
            //
            // If this is an ack to the automatic instance, then unlock it now.
            //
            if(*piInstReturn == pvcr->iInstBackground)
            {
                DPF(DBG_QUEUE, "Setting transport socket\n");
                pvcr->Port[iPort].Dev[iDev].iTransportSocket = iSocket;
            }
        }

        // We always release tranport here!
        *pfTxRelease = TRUE;
    }
    *pbRetType = bType;
    return TRUE;
}


/****************************************************************************
 * Function: BOOL   viscaPacketProcess - Process a ViSCA packet.
 *
 * Parameters:
 *
 *      UINT   iPort         - Index of port on which message was received (0..3).
 *
 *      LPSTR  lpstrPacket   - ViSCA packet to process. 
 *
 * Returns: TRUE if message was stored with an OpenInstance,
 *        otherwise FALSE.
 *
 ***************************************************************************/
BOOL FAR PASCAL
    viscaPacketProcess(UINT iPort, LPSTR lpstrPacket)
{
    int iInst;
    BYTE bType;
    int  iDev = -1;
    BOOL fTxRelease = FALSE;


    if(!viscaDeviceControl(iPort, lpstrPacket, &iInst, &bType, &iDev, &fTxRelease))
    {
        // We must release the semaphore here. (unless cancel which does not return dev)
        if(iDev != -1)
            viscaReleaseSemaphore(OWNED(pvcr->Port[iPort].Dev[iDev].fTxLock));
        return TRUE;
    }

    // If it was a 90 38 ff (network change, ignore it)
    if(iInst == -1)
    {
        DPF(DBG_ERROR, "iInst == -1 \n");
        return TRUE; // What if we had a blocked! BAD
    }

    //
    //  We do not release the semaphore because the auto-inst may need
    //  to use it to transmit another command.
    //
    if(pvcr->Port[iPort].Dev[iDev].fTimerMsg != TRUE) // Device is already locked.
        viscaWaitForSingleObject(OWNED(pvcr->Port[iPort].Dev[iDev].fDeviceLock), FALSE, MY_INFINITE, (UINT)0);

    // It doesn't matter what it is, we can kill the ack timer now.
    if(pvcr->Port[iPort].Dev[iDev].fAckTimer)
    {
        DPF(DBG_COMM, "Killing timer now.\n");
        KillTimer(pvcr->hwndCommNotifyHandler, MAKEACKTIMERID(iPort, iDev));
        pvcr->Port[iPort].Dev[iDev].fAckTimer = FALSE;
    }


    switch(bType)
    {
        case VISCAREPLYERROR:
            if(iInst == pvcr->iInstBackground)
                viscaAutoErrorCompletion(iPort, iDev, lpstrPacket, &fTxRelease);
            else
                viscaErrorCompletion(iInst, lpstrPacket, &fTxRelease);
            break;

        case VISCAREPLYCOMPLETION:
            if(iInst == pvcr->iInstBackground)
                viscaAutoSuccessfulCompletion(iPort, iDev, lpstrPacket, &fTxRelease);
            else
                viscaSuccessfulCompletion(iInst, lpstrPacket, &fTxRelease);
            break;

        case VISCAREPLYADDRESS:
        case VISCAREPLYACK:
            if(iInst == pvcr->iInstBackground)
                viscaAutoAck(iPort, iDev);
            else
                viscaAck(iInst, &fTxRelease);
            break;

    }
    //
    // Did this survive?
    //
    if(fTxRelease)
        viscaReleaseSemaphore(OWNED(pvcr->Port[iPort].Dev[iDev].fTxLock));
    
    if(pvcr->Port[iPort].Dev[iDev].fTimerMsg != TRUE) // Device is already locked.
        viscaReleaseMutex(OWNED(pvcr->Port[iPort].Dev[iDev].fDeviceLock));

    return TRUE;
}


void FAR PASCAL SignalInstance(int iInst, BYTE bReplyFlags)
{
#ifdef _WIN32
    HANDLE      hProcess;
    HANDLE      hEventTemp;
#endif

    if(iInst < 0)
        return;

#ifdef _WIN32
    if(bReplyFlags & VISCAF_COMPLETION)
    {
        hProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pinst[iInst].pidThisInstance);

        DuplicateHandle(hProcess,
                pinst[iInst].fCompletionEvent,
                GetCurrentProcess(),
                &hEventTemp,
                0,
                FALSE,
                DUPLICATE_SAME_ACCESS);

        viscaSetEvent(hEventTemp);

        CloseHandle(hEventTemp);
        CloseHandle(hProcess);
    }
    else if(bReplyFlags & VISCAF_ACK)
    {
        hProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pinst[iInst].pidThisInstance);

        DuplicateHandle(hProcess,
                pinst[iInst].fAckEvent,
                GetCurrentProcess(),
                &hEventTemp,
                0,
                FALSE,
                DUPLICATE_SAME_ACCESS);

        SetEvent(hEventTemp);

        CloseHandle(hEventTemp);
        CloseHandle(hProcess);
    }
#else
    if(bReplyFlags & VISCAF_COMPLETION)
        viscaSetEvent(OWNED(pinst[iInst].fCompletionEvent));
    else if(bReplyFlags & VISCAF_ACK)
        viscaSetEvent(OWNED(pinst[iInst].fAckEvent));
#endif

    return;

}

void FAR PASCAL SignalDevice(int iPort, int iDev, BYTE bReplyFlags)
{
    // The background task own this one and it's duplicated in each instance.

    if(bReplyFlags & VISCAF_COMPLETION)
        viscaSetEvent(OWNED(pvcr->Port[iPort].Dev[iDev].fAutoCompletion));
    else if(bReplyFlags & VISCAF_ACK)
        viscaSetEvent(OWNED(pvcr->Port[iPort].Dev[iDev].fAutoAck));

    return;
}



/****************************************************************************
 * Function: void   viscaAck      - Handle acknowledgments.
 *
 * Parameters:
 *
 *      POpenInstace iInst   - Instance that started this comamnd.
 *
 ***************************************************************************/
static void NEAR PASCAL
    viscaAck(int iInst, BOOL FAR *pfTxRelease)
{
    UINT    iPort    = pinst[iInst].iPort;
    UINT    iDev     = pinst[iInst].iDev;

    // If a auto-command got blocked, then send it out now.
    DPF(DBG_QUEUE, "viscaAck -\n");

    if(pvcr->Port[iPort].Dev[iDev].uAutoBlocked)
        viscaAutoWrite(iPort, iDev, FALSE, 0, pfTxRelease); // This command is not blockable

    if(iInst != -1)
        pinst[iInst].bReplyFlags |= VISCAF_ACK;

    SignalInstance(iInst, VISCAF_ACK);
}


/****************************************************************************
 * Function: void   viscaSuccessfulCompletion - Handle successful completions
 *
 * Parameters:
 *
 *      int iInst  - Instance that started this command.
 *
 *      LPSTR  lpstrPacket   - The entire packet we have received.
 *
 ***************************************************************************/
static void NEAR PASCAL
    viscaSuccessfulCompletion(int iInst, LPSTR lpstrPacket, BOOL FAR *pfTxRelease)
{
    UINT iPort = pinst[iInst].iPort;
    UINT iDev  = pinst[iInst].iDev;

    DPF(DBG_QUEUE, "viscaSuccessfulCompletion - setting iInst to completed.\n");
    //
    // Process a completion and errors. (must be waiting).
    // 
    if(iInst != -1)
    {
        _fmemcpy(pinst[iInst].achPacket, lpstrPacket, MAXPACKETLENGTH);
        pinst[iInst].bReplyFlags |= VISCAF_COMPLETION;

        SignalInstance(iInst, VISCAF_ACK);          // This may already be signalled.
        SignalInstance(iInst, VISCAF_COMPLETION);   // This cannot be signalled yet.
    }

    if(pvcr->Port[iPort].Dev[iDev].uAutoBlocked)
        viscaAutoWrite(iPort, iDev, FALSE, 0, pfTxRelease);      // This command is not blockable 
}


/****************************************************************************
 * Function: void   viscaErrorCompletion - Handle error completions.
 *
 * Parameters:
 *
 *      int iInst  - Instance that started this command.
 *
 *      LPSTR  lpstrPacket   - The entire packet we have received.
 *
 ***************************************************************************/
static void NEAR PASCAL
    viscaErrorCompletion(int iInst, LPSTR lpstrPacket, BOOL FAR *pfTxRelease)
{
    UINT iPort = pinst[iInst].iPort;
    UINT iDev  = pinst[iInst].iDev;

    DPF(DBG_QUEUE, "viscaErrorCompletion - setting iInst to completed.\n");
    //
    // Process a completion and errors. (must be waiting).
    // 
    if(iInst != -1)
    {
        _fmemcpy(pinst[iInst].achPacket, lpstrPacket, MAXPACKETLENGTH);
        pinst[iInst].bReplyFlags |= VISCAF_COMPLETION;
        pinst[iInst].bReplyFlags |= VISCAF_ERROR;

        SignalInstance(iInst, VISCAF_ACK);          // This may already be signalled.
        SignalInstance(iInst, VISCAF_COMPLETION);   // This cannot be signalled yet.
    }

    if(pvcr->Port[iPort].Dev[iDev].uAutoBlocked)
        viscaAutoWrite(iPort, iDev, FALSE, 0, pfTxRelease); // This command is not blockable
}


/****************************************************************************
 * Function: void   viscaAutoWrite   - Send the next queued command.
 *
 * Parameters:
 *
 *      POpenInstace iInst      - Instance that started this command (auto).
 *
 *      BOOL   fBlockable       - Can transmission be blocked. If false then we must send.
 *
 *      UINT   uAutoBlocked     - If blocked, was it normal or error completion that was blocked.
 *
 ***************************************************************************/
static BOOL NEAR PASCAL
    viscaAutoWrite( UINT iPort,
                    UINT iDev,
                    BOOL fBlockable,
                    UINT uAutoBlocked,
                    BOOL FAR *pfTxRelease) 
{
    UINT    iDevDone        = pvcr->Port[iPort].Dev[iDev].iCmdDone;
    CmdInfo *pcmdCmd        = &(pvcr->Port[iPort].Dev[iDev].rgCmd[iDevDone]);
    LPSTR   lpstrCmd        = pcmdCmd->str[pcmdCmd->iCmdDone];
    BYTE    cbMessageLength = pcmdCmd->uLength[pcmdCmd->iCmdDone];
    UINT    uTimerID;

    if(fBlockable)
    {
        //
        // Only async completions can cause this (receive something after it gets locked)
        //    know async completion because txRelease is set to false.
        //
        if(!*pfTxRelease)  // We do not know if it is free, so check.
        {
            if(viscaWaitForSingleObject(OWNED(pvcr->Port[iPort].Dev[iDev].fTxLock), FALSE, 0L, 0)==WAIT_TIMEOUT) 
            {
                pvcr->Port[iPort].Dev[iDev].uAutoBlocked  = uAutoBlocked;
                pvcr->Port[iPort].Dev[iDev].wTransportCmd = 0;          // No command running after completion
                DPF(DBG_QUEUE, "viscaAutoWrite - We have been blocked!\n");
                return FALSE;
            }
        }
        // Claim the semaphore!
        *pfTxRelease = FALSE;
        DPF(DBG_QUEUE, "viscaAutoWrite - Clear sailing, transmitting now captain.\n");
        pvcr->Port[iPort].Dev[iDev].iInstReply     = pvcr->iInstBackground;
        pvcr->Port[iPort].Dev[iDev].uAutoBlocked   = uAutoBlocked;  // Set it to normal(I know we weren't blocked!)
    }
    else
    {
        // TxRelease must be true! No other way to get here.
        *pfTxRelease = FALSE;
        DPF(DBG_QUEUE, "viscaAutoWrite - Attempting blocked transmission now.\n");
        pvcr->Port[iPort].Dev[iDev].iInstReply = pvcr->iInstBackground;
    }

    lpstrCmd[0]                   = MAKEDEST((BYTE)(iDev+1));
    lpstrCmd[cbMessageLength + 1] = (BYTE)0xFF;

    DPF(DBG_COMM, "---Wrote: ");
    viscaPacketPrint(lpstrCmd, cbMessageLength + 2);

    pvcr->Port[iPort].Dev[iDev].uAutoBlocked  = FALSE;
    pvcr->Port[iPort].Dev[iDev].wTransportCmd = 0;  // No command running after completion
    //
    // Try to write packet
    //
#ifdef _WIN32
    //
    // We MUST have already claimed the Tx Lock on this device.
    // 
    WaitForSingleObject(pvcr->Port[iPort].fTxBuffer, MY_INFINITE);

    _fmemcpy(pvcr->Port[iPort].achTxPacket, lpstrCmd, cbMessageLength + 2);
    pvcr->Port[iPort].nchTxPacket = cbMessageLength + 2;

    // Signal that it is time to transmit. (we must use our version of the handle).
    SetEvent(pvcr->Port[iPort].fTxReady);
#else
    if (!viscaCommWrite(pvcr->Port[iPort].idComDev,
                lpstrCmd,
                cbMessageLength + 2))
    {
        pvcr->Port[iPort].Dev[iDev].iInstReply = -1;
        pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_ERROR;
        viscaReleaseAuto(iPort, iDev, MCI_NOTIFY_FAILURE);
        viscaReleaseSemaphore(OWNED(pvcr->Port[iPort].Dev[iDev].fTxLock));
        return FALSE;
    }
#endif

    uTimerID = MAKEACKTIMERID(iPort, iDev);

    DPF(DBG_COMM, "Timer ID = %x",uTimerID);

    if(SetTimer(pvcr->hwndCommNotifyHandler, uTimerID, ACK_TIMEOUT, NULL))
    {
        DPF(DBG_COMM, "Ack-timer started\n");
        pvcr->Port[iPort].Dev[iDev].fAckTimer = TRUE;
    }
    return TRUE;

}

/****************************************************************************
 * Function: void   viscaAutoAck  - Acknowledgements intended for auto-instance.
 *
 * Parameters:
 *
 *      int iInst  - Instance that started this command.
 *
 ***************************************************************************/
static void NEAR PASCAL
    viscaAutoAck(UINT iPort, UINT iDev)
{
    DPF(DBG_QUEUE, "viscaAutoAck - Setting wTransportCmd\n.");

    // Set current running command (Used only in cancel)
    pvcr->Port[iPort].Dev[iDev].wTransportCmd =
        pvcr->Port[iPort].Dev[iDev].rgCmd[pvcr->Port[iPort].Dev[iDev].iCmdDone].uViscaCmd;
        
    // The nth command, and the device (may be redundant on device).
    pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_ACK; // First ack

    // Auto-ack will never alter the state of pfTxRelease
    SignalDevice(iPort, iDev, VISCAF_ACK);       // This may already be signalled.
}



/****************************************************************************
 * Function: void   viscaAutoSuccessfulCompletion - Handle successful completion
 *                for the auto-instance.
 *
 * Parameters:
 *
 *      int iInst  - Instance that started this command.
 *
 *      LPSTR  lpstrPacket   - The entire packet we have received.
 *
 ***************************************************************************/
static void NEAR PASCAL
    viscaAutoSuccessfulCompletion(  UINT iPort,
                                    UINT iDev,
                                    LPSTR lpstrPacket,
                                    BOOL FAR *pfTxRelease)
{
    UINT iDevCmd    = pvcr->Port[iPort].Dev[iDev].iCmdDone;
    CmdInfo *pcmdCmd = &(pvcr->Port[iPort].Dev[iDev].rgCmd[iDevCmd]);
    UINT uViscaCmd   = pcmdCmd->uViscaCmd;

    DPF(DBG_QUEUE, "viscaAutoSuccessfulCompletion\n");
    //
    // Extend this command completion? Only need to do this on good completion, not error or others.
    //
    if( !pvcr->Port[iPort].Dev[iDev].fTimerMsg &&
        (pvcr->Port[iPort].Dev[iDev].uModelID  == VISCADEVICEVENDORSONY)    &&
        (pvcr->Port[iPort].Dev[iDev].uVendorID == VISCADEVICEMODELEVO9650))
    {
        UINT uTimerID;
        UINT uTimeOut;
        //
        // These timeouts have been emperically determined.
        //
        if(uViscaCmd == VISCA_FREEZE)
            uTimeOut = 3000;
        else if(uViscaCmd == VISCA_STEP)
            uTimeOut = 350;
        else
            uTimeOut = 0;

        if(uTimeOut != 0)
        {
            _fmemcpy(pvcr->Port[iPort].Dev[iDev].achPacket, lpstrPacket, MAXPACKETLENGTH);
            //
            // Make a unique timer id.
            // Put port in low-byte and device in hi-byte, add one so it is non-zero.
            //
            uTimerID = MAKETIMERID(iPort, iDev);

            if(SetTimer(pvcr->hwndCommNotifyHandler, uTimerID, uTimeOut, NULL))
            {
                pvcr->Port[iPort].Dev[iDev].fTimer = TRUE;
                DPF(DBG_COMM, "Started port=%d, device=%d\n", iPort, iDev);
            }
            return;
        }
    }
    //
    // Set the successful completion of the command. (see viscacom.c)
    //
    viscaSetCommandComplete(iPort, iDev, uViscaCmd);
    //
    // Are we done with this command?
    //
    pcmdCmd->uLoopCount--;
    if(pcmdCmd->uLoopCount == 0)
    {
        pcmdCmd->iCmdDone++;
        pvcr->Port[iPort].Dev[iDev].iCmdDone++;
    }
    //
    // We are done if we just incremented past the end of queue.
    //
    if(pvcr->Port[iPort].Dev[iDev].iCmdDone < pvcr->Port[iPort].Dev[iDev].nCmd)
    {
        DPF(DBG_QUEUE, "viscaAutoSuccessfulCompletion - Sending next command done=%d Total=%d\n", pvcr->Port[iPort].Dev[iDev].iCmdDone, pvcr->Port[iPort].Dev[iDev].nCmd);

        if(pvcr->Port[iPort].Dev[iDev].fQueueAbort)
        {
            // Someone has requested abort.
            pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_ERROR;
            viscaReleaseAuto(iPort, iDev, MCI_NOTIFY_ABORTED);
        }
        else
        {
            // Next command. TxRelease set to true. we might change it.
            viscaAutoWrite(iPort, iDev, TRUE, AUTOBLOCK_NORMAL, pfTxRelease);
            SignalDevice(iPort, iDev, VISCAF_ACK);       // This may already be signalled.
        }

    }
    else if(pvcr->Port[iPort].Dev[iDev].iCmdDone==pvcr->Port[iPort].Dev[iDev].nCmd)
    {
        DPF(DBG_QUEUE, "viscaAutoSuccessfulCompletion - Releasing auto.\n");
        viscaReleaseAuto(iPort, iDev, MCI_NOTIFY_SUCCESSFUL);
    }

    return;
}


/****************************************************************************
 * Function: void   viscaAutoErrorCompletion - Errors to the auto-instance.
 *
 * Parameters:
 *
 *      int iInst  - Instance that started this command.
 *
 *      LPSTR  lpstrPacket   - The entire packet we have received.
 *
 ***************************************************************************/
static void NEAR PASCAL
    viscaAutoErrorCompletion(   UINT iPort,
                                UINT iDev,
                                LPSTR lpstrPacket,
                                BOOL FAR *pfTxRelease)
{
    UINT iDevCmd        = pvcr->Port[iPort].Dev[iDev].iCmdDone;
    CmdInfo *pcmdCmd    = &(pvcr->Port[iPort].Dev[iDev].rgCmd[iDevCmd]);
    UINT uViscaCmd      = pcmdCmd->uViscaCmd;

    DPF(DBG_QUEUE, "viscaAutoErrorCompletion - \n");

    // One alternative has bit the dust (the main one).
    pcmdCmd->iCmdDone++;
    // If we are looping we will break now anyway!

    if(VISCAREPLYERRORCODE(lpstrPacket) == VISCAERRORCANCELLED)
    {
        //
        // We have been cancelled.
        //
        pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_ERROR;
        viscaReleaseAuto(iPort, iDev, MCI_NOTIFY_ABORTED);
    }
    else if(pcmdCmd->iCmdDone < pcmdCmd->nCmd)
    {
        //
        // Error is NOT cancel, and we have alternatives to send.
        //
        if(pvcr->Port[iPort].Dev[iDev].fQueueAbort)
        {
            pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_ERROR;
            viscaReleaseAuto(iPort, iDev, MCI_NOTIFY_ABORTED);
        }
        else
        {
            //
            // Try the next alternative to this command.
            //
            viscaAutoWrite(iPort, iDev, TRUE, AUTOBLOCK_ERROR, pfTxRelease);
        }
        pvcr->Port[iPort].Dev[iDev].wTransportCmd = 0;  // No command running after completion 
    }
    else
    {
        //
        // No alternatives and we had an error, so just die.
        //
        pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_ERROR;
        //
        // Only notify on error if this is not the first ack! The first
        // ack-error will be handled by the DoQueued command.
        //
        if(pvcr->Port[iPort].Dev[iDev].bReplyFlags & VISCAF_ACK)
        {
            viscaReleaseAuto(iPort, iDev, MCI_NOTIFY_FAILURE);
        }
        else  // In this case we need to know the error reason.
        {
            if(pvcr->Port[iPort].Dev[iDev].iInstTransport != -1)
                _fmemcpy(pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].achPacket, lpstrPacket, MAXPACKETLENGTH);

            viscaReleaseAuto(iPort, iDev, 0);
        }

    }

    return;
}


/****************************************************************************
 * Function: void   viscaReleaseAuto - Abort (cancel) in the auto-instance.
 *                                  
 * Parameters:
 *
 *      int iInst  - Instance that started this command.
 *
 *      DWORD  dwNotify  -   MCI-notification flags.
 *
 ***************************************************************************/
static void NEAR PASCAL
    viscaReleaseAuto(UINT iPort, UINT iDev, DWORD dwNotify)
{

    if(pvcr->Port[iPort].Dev[iDev].iInstTransport != -1)
    {
        //
        // Do we have to notify?
        //
        HWND hWndTransport = pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].hwndNotify;
        UINT uDeviceID     = pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].uDeviceID;

        //
        // hWnd Transport will be null if we do not want notification.
        //
        if(hWndTransport != NULL)
        {
            if((dwNotify == MCI_NOTIFY_FAILURE) || (dwNotify == MCI_NOTIFY_SUCCESSFUL))
            {
                mciDriverNotify(hWndTransport, uDeviceID, (UINT) dwNotify);
                pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].hwndNotify = NULL;

            }
            else if(dwNotify == MCI_NOTIFY_ABORTED)
            {
                // Special case pause, does not send abort or supersede.

                if(pvcr->Port[iPort].Dev[iDev].dwReason == MCI_NOTIFY_SUPERSEDED)
                {
                    mciDriverNotify(hWndTransport, uDeviceID, MCI_NOTIFY_SUPERSEDED);
                    pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].hwndNotify = NULL;
                }
                else if(pvcr->Port[iPort].Dev[iDev].dwReason == MCI_NOTIFY_ABORTED)
                {
                    mciDriverNotify(hWndTransport, uDeviceID, MCI_NOTIFY_ABORTED);
                    pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].hwndNotify = NULL;
                }

                // Pause will fall through and leave the hwndNotify in place.
                // Even though transport inst is not there.
            }
        }
    }

    //
    // Abort sending commands.
    //
    if(!pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].fWaiting)
    {
        DPF(DBG_QUEUE, "Releasing transport in commtask.c\n");
        viscaReleaseAutoParms(iPort, iDev);
        viscaSetEvent(OWNED(pvcr->Port[iPort].Dev[iDev].fTransportFree));
    }

    //
    // Set entire queue status to completion (may be waiting).
    //
    pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_COMPLETION;
    SignalDevice(iPort, iDev, VISCAF_COMPLETION);  //Owned by us!
    SignalDevice(iPort, iDev, VISCAF_ACK);       // This may already be signalled.
}

#ifndef _WIN32
/****************************************************************************
 * Function: void   viscaCommNotifyHandler - Handle WM_COMMNOTIFY message.
 *
 * Parameters:
 *
 *      HWND   hwnd          - Window that received WM_COMMNOTIFY message.
 *
 *      int    idComDev      - Comm device ID.
 *
 *      UINT   uNotifyStatus - Flags that indicate why WM_COMMNOTIFY was sent.
 *
 ***************************************************************************/
static void NEAR PASCAL
    viscaCommNotifyHandler(HWND hwnd, int idComDev, UINT uNotifyStatus)
{
    if (uNotifyStatus & CN_RECEIVE)
    {
        char        achPacket[MAXPACKETLENGTH];
        UINT        iPort;
        COMSTAT     comStat;

        for (iPort = 0; iPort < MAXPORTS; iPort++)
        {
            if (pvcr->Port[iPort].idComDev == idComDev)
            {
                break;
            }
        }
        if (iPort == MAXPORTS)
        {
            return;
        }
        comStat.cbInQue = 0;
        GetCommError(idComDev, &comStat);
        while (comStat.cbInQue > 0)
        {
            if (viscaPacketRead(idComDev, achPacket))
            {
                // Error reading packet.
                return;
            }

            viscaPacketProcess(iPort, achPacket);
            comStat.cbInQue = 0;
            GetCommError(idComDev, &comStat);
        }
    }
}
#else
static void NEAR PASCAL
    viscaCommNotifyHandler(HWND hwnd, int idComDev, UINT uNotifyStatus)
{
    return;
}
#endif

/****************************************************************************
 * Function: LRESULT viscaCommHandlerWndPro - Window procedure for background
 *                                         task window that receives
 *                                         WM_COMMNOTIFY messages.
 *
 * Parameters:
 *
 *      HWND   hwnd          - Window handle.
 *
 *      UINT   uMsg          - Windows message.
 *
 *      WPARAM wParam        - First message-specific parameter.
 *
 *      LPARAM lParam        - Second message-specific parameter.
 *
 * Returns: 0 if message was processed, otherwise returns value
 *        returned by DefWindowProc().
 ***************************************************************************/
LRESULT CALLBACK LOADDS
    viscaCommHandlerWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (LOWORD(uMsg))   // LOWORD for NT compatibility, Does nothing in Win3.1
    {
#ifndef _WIN32
        case WM_COMMNOTIFY:
            HANDLE_WM_COMMNOTIFY(hwnd, wParam, lParam, viscaCommNotifyHandler);
            return ((LRESULT)0);
#else
        case WM_USER:
            TaskDoCommand((UINT)wParam, lParam);
            break;
#endif

        //
        // Timer is used to extend command notifies.
        //
        case WM_TIMER:
            DPF(DBG_COMM, "------------->TimerMsg.\n");
            if(ISACKTIMER(wParam))
            {
                UINT iPort  = (UINT) (((0x00f0 & wParam) >> 4) - 1);
                UINT iDev   = (UINT) (((0xf000 & wParam) >> 12) - 1);

                KillTimer(hwnd, wParam);
                pvcr->Port[iPort].Dev[iDev].bReplyFlags    |= VISCAF_COMPLETION;
                pvcr->Port[iPort].Dev[iDev].bReplyFlags    |= VISCAF_ERROR;
                pvcr->Port[iPort].Dev[iDev].bReplyFlags    |= VISCAF_ERROR_TIMEOUT;

                // This messages is dispached through GetMessage loop in msmcivcr.exe! Check it out!
                // That means we, of course, own the following handle.
                viscaReleaseSemaphore(OWNED(pvcr->Port[iPort].Dev[iDev].fTxLock)); //We own this handle!

                if(pvcr->Port[iPort].Dev[iDev].iInstReply == pvcr->iInstBackground)
                    viscaReleaseAuto(iPort, iDev, MCI_NOTIFY_FAILURE);

                pvcr->Port[iPort].Dev[iDev].iInstReply     = -1;
                pvcr->Port[iPort].Dev[iDev].fAckTimer      = FALSE;
                DPF(DBG_ERROR, "Ack timeout! releasing TxLock now.\n");
            }
            else
            {
                UINT iPort  = (UINT) ((0x00ff & wParam) - 1);
                UINT iDev   = (UINT) (((0xff00 & wParam) >> 8) - 1);
                LPSTR lpstrFreeze;
                //
                // Kill the timer
                //
                KillTimer(hwnd, wParam);
                DPF(DBG_COMM, "Killed port=%d, device=%d\n", iPort, iDev);
                pvcr->Port[iPort].Dev[iDev].fTimer     = FALSE;
                pvcr->Port[iPort].Dev[iDev].fTimerMsg  = TRUE;
                viscaWaitForSingleObject(OWNED(pvcr->Port[iPort].Dev[iDev].fDeviceLock), FALSE, MY_INFINITE, (UINT)0);

                //
                // Resend the packet for processing, each device could have a packet (but clear the socket) 
                //
                lpstrFreeze     = pvcr->Port[iPort].Dev[iDev].achPacket;
                lpstrFreeze[1]  = (BYTE) ((BYTE)lpstrFreeze[1] & 0xf0);
                viscaPacketPrint(lpstrFreeze, 3);
                viscaPacketProcess(iPort, lpstrFreeze);
                _fmemset(pvcr->Port[iPort].Dev[iDev].achPacket, '\0', MAXPACKETLENGTH);
                pvcr->Port[iPort].Dev[iDev].fTimerMsg = FALSE;
                viscaReleaseMutex(OWNED(pvcr->Port[iPort].Dev[iDev].fDeviceLock));
            }
            break;

        default:
            return (DefWindowProc(hwnd, uMsg, wParam, lParam));
    }
}


/*
 * Create Handles necessary to synchronize device access.
 */
BOOL FAR PASCAL CreateDeviceHandles(DWORD pidBackground, UINT iPort, UINT iDev)  // This is called by the backgound task!
{
#ifdef _WIN32
    pvcr->Port[iPort].Dev[iDev].fTxLock    = CreateSemaphore(NULL,  // Null security description
                                                  1,            // Initial count. so someone can take it.
                                                  1,        // I do not want immediate ownership.
                                                  NULL);        // No name

    pvcr->Port[iPort].Dev[iDev].fQueueLock = CreateMutex(NULL,
                                                  FALSE,    // I do not want immediate ownership.
                                                  NULL);    // No name

    pvcr->Port[iPort].Dev[iDev].fTransportFree = CreateEvent(NULL,
                                                  TRUE,     // MANUAL
                                                  FALSE,    // Initially not-signalled.
                                                  NULL);    // No name

    pvcr->Port[iPort].Dev[iDev].fDeviceLock = CreateMutex(NULL,
                                                  FALSE,    // I do not want immediate ownership.
                                                  NULL);    // No name

    pvcr->Port[iPort].Dev[iDev].fAutoCompletion = CreateEvent(NULL,
                                                  TRUE,     // MANUAL
                                                  FALSE,    // Initially not-signalled.
                                                  NULL);    // No name

    pvcr->Port[iPort].Dev[iDev].fAutoAck = CreateEvent(NULL,
                                                  TRUE,     // MANUAL
                                                  FALSE,    // Initially not-signalled.
                                                  NULL);    // No name
#else
    pvcr->Port[iPort].Dev[iDev].fTxLock         = TRUE; //Count set to 1, one may go! with wait.
    pvcr->Port[iPort].Dev[iDev].fQueueLock      = TRUE;
    pvcr->Port[iPort].Dev[iDev].fTransportFree  = TRUE;
    pvcr->Port[iPort].Dev[iDev].fDeviceLock     = TRUE;
    pvcr->Port[iPort].Dev[iDev].fAutoCompletion = TRUE;
    pvcr->Port[iPort].Dev[iDev].fAutoAck        = TRUE;
#endif

    DPF(DBG_TASK, "CreateDeviceHandles Port=%u Dev=%uOk! \n", iPort, iDev);
    return TRUE;
}

/*
 * Create Handles necessary to synchronize device access.
 */
BOOL FAR PASCAL CloseDeviceHandles(DWORD pidBackground, UINT iPort, UINT iDev)  // This is called by the backgound task!
{
#ifdef _WIN32
    CloseHandle(pvcr->Port[iPort].Dev[iDev].fTxLock    );
    CloseHandle(pvcr->Port[iPort].Dev[iDev].fQueueLock );
    CloseHandle(pvcr->Port[iPort].Dev[iDev].fTransportFree );
    CloseHandle(pvcr->Port[iPort].Dev[iDev].fDeviceLock);
    CloseHandle(pvcr->Port[iPort].Dev[iDev].fAutoCompletion);
    CloseHandle(pvcr->Port[iPort].Dev[iDev].fAutoAck);
#endif
    DPF(DBG_TASK, "CloseDeviceHandles Port=%u Dev=%uOk! \n", iPort, iDev);
    return TRUE;
}


/*
 * Duplicate device Handles to an instance, so the instance can synchronize.
 */
BOOL FAR PASCAL DuplicateDeviceHandlesToInstance(DWORD pidBackground, UINT iPort, UINT iDev, int iInst)
{
#ifdef _WIN32
    HANDLE hProcessBackground;

    hProcessBackground = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pidBackground); // iInst has pid.

    DuplicateHandle(hProcessBackground,
            pvcr->Port[iPort].Dev[iDev].fTxLock,
            GetCurrentProcess(), 
            &pinst[iInst].pfTxLock,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    DuplicateHandle(hProcessBackground,
            pvcr->Port[iPort].Dev[iDev].fQueueLock,
            GetCurrentProcess(), 
            &pinst[iInst].pfQueueLock,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    DuplicateHandle(hProcessBackground,
            pvcr->Port[iPort].Dev[iDev].fTransportFree,
            GetCurrentProcess(), 
            &pinst[iInst].pfTransportFree,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    DuplicateHandle(hProcessBackground,
            pvcr->Port[iPort].Dev[iDev].fDeviceLock,
            GetCurrentProcess(), 
            &pinst[iInst].pfDeviceLock,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    DuplicateHandle(hProcessBackground,
            pvcr->Port[iPort].Dev[iDev].fAutoCompletion,
            GetCurrentProcess(), 
            &pinst[iInst].pfAutoCompletion,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    DuplicateHandle(hProcessBackground,
            pvcr->Port[iPort].Dev[iDev].fAutoAck,
            GetCurrentProcess(), 
            &pinst[iInst].pfAutoAck,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);




    CloseHandle(hProcessBackground);
#else
    pinst[iInst].pfTxLock           = &pvcr->Port[iPort].Dev[iDev].fTxLock;
    pinst[iInst].pfQueueLock        = &pvcr->Port[iPort].Dev[iDev].fQueueLock;
    pinst[iInst].pfTransportFree    = &pvcr->Port[iPort].Dev[iDev].fTransportFree;
    pinst[iInst].pfDeviceLock       = &pvcr->Port[iPort].Dev[iDev].fDeviceLock;
    pinst[iInst].pfAutoCompletion   = &pvcr->Port[iPort].Dev[iDev].fAutoCompletion;
    pinst[iInst].pfAutoAck          = &pvcr->Port[iPort].Dev[iDev].fAutoAck;
#endif
    pinst[iInst].fDeviceHandles = TRUE;
    DPF(DBG_TASK, "DuplicateDeviceHandles Port=%u Dev=%uOk! \n", iPort, iDev);
    return TRUE;
}

/*
 * Create handles needed to serialize Port access.
 */
BOOL FAR PASCAL CreatePortHandles(DWORD pidBackground, UINT iPort)
{
#ifdef _WIN32

    pvcr->Port[iPort].fTxBuffer = CreateEvent(NULL,
                                    FALSE,    // False means not-manual! This is auto.
                                    TRUE,     // Set to signalled! First person must gain access.
                                    NULL);    // No name

    pvcr->Port[iPort].fTxReady = CreateEvent(NULL,
                                    FALSE,    // False measn not-manual! This is auto!
                                    FALSE,    // Set to non-signalled state. 
                                    NULL);    // No name

#endif

    DPF(DBG_TASK, "CreatePortHandles for port index %u Ok! \n", iPort);
    return TRUE;
}

/*
 * Close handles needed to serialize Port access.
 */
BOOL FAR PASCAL ClosePortHandles(DWORD pidBackground, UINT iPort)
{
#ifdef _WIN32
    CloseHandle(pvcr->Port[iPort].fTxBuffer);
    CloseHandle(pvcr->Port[iPort].fTxReady);
#endif
    DPF(DBG_TASK, "ClosePortHandles for port index %u Ok! \n", iPort);
    return TRUE;
}


/*
 * Duplicate handles to instance needed to serialize Port access.
 */
BOOL FAR PASCAL DuplicatePortHandlesToInstance(DWORD pidBackground, UINT iPort, int iInst)
{
#ifdef _WIN32
    HANDLE hProcessBackground;

    hProcessBackground = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pidBackground); // iInst has pid.

    DuplicateHandle(hProcessBackground,
            pvcr->Port[iPort].fTxBuffer,
            GetCurrentProcess(), 
            &pinst[iInst].pfTxBuffer,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    DuplicateHandle(hProcessBackground,
            pvcr->Port[iPort].fTxReady,
            GetCurrentProcess(), 
            &pinst[iInst].pfTxReady,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    CloseHandle(hProcessBackground);
#endif
    pinst[iInst].fPortHandles = TRUE;

    DPF(DBG_TASK, "DuplicatePortHandles to port index %u Ok!\n", iPort);
    return TRUE;
}


/*
 * Create handles needed to serialize access to background task.
 */
BOOL FAR PASCAL CreateGlobalHandles(DWORD pidBackground)
{
#ifdef _WIN32
    pvcr->gfTaskLock        = CreateMutex(NULL,
                                    FALSE,    // I do not want immediate ownership.
                                    NULL);    // No name

    pvcr->gfTaskWorkDone    = CreateEvent(NULL,
                                    FALSE,    // False measn not-manual! This is auto!
                                    FALSE,    // Set to non-signalled state. 
                                    NULL);    // No name
#else 
    // These are globals. Not devices.
    pvcr->gfTaskLock        = TRUE;
    pvcr->gfTaskWorkDone    = TRUE;
#endif

    DPF(DBG_TASK, "CreateGlobalHandles Ok! \n");
    return TRUE;
}
/*
 * Close handles needed to serialize access to background task.
 */
BOOL FAR PASCAL CloseGlobalHandles(DWORD pidBackground)
{
#ifdef _WIN32
    CloseHandle(pvcr->gfTaskLock);
    CloseHandle(pvcr->gfTaskWorkDone);
#endif
    DPF(DBG_TASK, "CloseGlobalHandles Ok! \n");
    return TRUE;
}


/*
 * Duplicate handles to instance, needed to serialize access to background task.
 */
BOOL FAR PASCAL DuplicateGlobalHandlesToInstance(DWORD pidBackground, int iInst)
{
#ifdef _WIN32
    HANDLE hProcessBackground;

    hProcessBackground = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pidBackground); // iInst has pid.

    DuplicateHandle(hProcessBackground,
            pvcr->gfTaskLock,
            GetCurrentProcess(), 
            &pinst[iInst].pfTaskLock,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    DuplicateHandle(hProcessBackground,
            pvcr->gfTaskWorkDone,
            GetCurrentProcess(), 
            &pinst[iInst].pfTaskWorkDone,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    CloseHandle(hProcessBackground);
#else
    pinst[iInst].pfTaskLock = &pvcr->gfTaskLock;
#endif
    pinst[iInst].fGlobalHandles = TRUE;
    DPF(DBG_TASK, "DuplicateGlobalHandles Ok! \n");
    return TRUE;
}

BOOL FAR PASCAL CloseAllInstanceHandles(int iInst)
{
    // If it is pf mean pointer, we do not own it.
    // f means handle that we do own.
#ifdef _WIN32    
    if(pinst[iInst].fGlobalHandles)
    {
        CloseHandle(pinst[iInst].pfTaskLock  );
        CloseHandle(pinst[iInst].pfTaskWorkDone);
        pinst[iInst].fGlobalHandles = FALSE;
    }

    if(pinst[iInst].fPortHandles)
    {
        CloseHandle(pinst[iInst].pfTxReady   );
        CloseHandle(pinst[iInst].pfTxBuffer  );
        pinst[iInst].fPortHandles = FALSE;
    }

    if(pinst[iInst].fDeviceHandles)
    {

        CloseHandle(pinst[iInst].pfTxLock    );
        CloseHandle(pinst[iInst].pfQueueLock );
        CloseHandle(pinst[iInst].pfTransportFree );
        CloseHandle(pinst[iInst].pfDeviceLock );
        CloseHandle(pinst[iInst].pfAutoCompletion );
        CloseHandle(pinst[iInst].pfAutoAck);
        pinst[iInst].fDeviceHandles = FALSE;
    }

    CloseHandle(pinst[iInst].fCompletionEvent);
    CloseHandle(pinst[iInst].fAckEvent);
#endif
    return TRUE;
}

/*
 * Carry out a command in the background task.
 */
static void NEAR PASCAL TaskDoCommand(UINT uTaskState, DWORD lParam)
{
    UINT iPort, iDev;
#ifdef _WIN32
    DWORD ThreadId;
    pvcr->lParam = lParam;
#endif

    // Port is in the loword and device is in the highword.
    iPort  = (UINT) ((pvcr->lParam & 0x0000ffff));
    iDev   = (UINT) ((pvcr->lParam >> 16) & 0x0000ffff);

    switch(uTaskState)
    {
        case TASKOPENCOMM: //Open comm will have a device of 0 anyway.
            DPF(DBG_TASK, "TASKOPENCOMM message received.\n");

#ifdef _WIN32
            //
            // Create the semaphores and open the port.
            //
            pvcr->Port[iPort - 1].idComDev = viscaCommPortSetup(iPort);
            pvcr->Port[iPort - 1].fOk = TRUE;
            //
            // Create threads to handle transmission and recption.
            //
            pvcr->Port[iPort - 1].hRxThread = CreateThread(NULL,// Security.
                        4096,              // Use default stack size.
                        (LPTHREAD_START_ROUTINE) RxThread,       // Function thread executes.
                        (LPVOID)iPort,
                        0,              // Creation flag.
                        &ThreadId);     // Returns thread id.

            pvcr->Port[iPort - 1].hTxThread = CreateThread(NULL,// Security.
                        4096,              // Use default stack size.
                        (LPTHREAD_START_ROUTINE)TxThread,       // Function thread executes.
                        (LPVOID)iPort,   //
                        0,              // Creation flag.
                        &ThreadId);     // Returns thread id.


            DPF(DBG_TASK, "Opening comm in commtask now............................\n");
            if (pvcr->Port[iPort - 1].idComDev < 0)
            {
               DPF(DBG_ERROR, "Could not open comm port.. Die or something!\n");
            }
            SetEvent(pvcr->gfTaskWorkDone);
#else
            if(!pvcr->fConfigure)
                _fmemset(&pvcr->Port[iPort - 1], '\0', sizeof(PortEntry));

            pvcr->Port[iPort - 1].idComDev = viscaCommPortSetup(iPort);

            if (pvcr->Port[iPort - 1].idComDev < 0)
            {
                DPF(DBG_ERROR, "Could not open comm port.. Die or something!\n");
            }
#endif
            break;

        case TASKCLOSECOMM:
            DPF(DBG_TASK, "TASKCLOSECOMM message received.\n");
#ifdef _WIN32
            //
            // We must kill the threads first!
            //
            pvcr->Port[iPort - 1].fOk      = FALSE; // Kills the threads.

            if(!SetEvent(OWNED(pvcr->Port[iPort - 1].fTxReady)))
            {
                DPF(DBG_ERROR, "Unable to signal TxThread to close.\n");
            }

            //
            // Wait for threads to exit. Before closing port, otherwise who knows?
            //
            WaitForSingleObject(pvcr->Port[iPort - 1].hRxThread, MY_INFINITE);
            WaitForSingleObject(pvcr->Port[iPort - 1].hTxThread, MY_INFINITE);

            // All handles are closed, so background task must exit NOW!
            viscaCommPortClose(pvcr->Port[iPort - 1].idComDev, iPort);
 
            CloseHandle(pvcr->Port[iPort - 1].hRxThread);
            CloseHandle(pvcr->Port[iPort - 1].hTxThread);

            ClosePortHandles(pvcr->htaskCommNotifyHandler, iPort - 1);
            pvcr->uTaskState = TASKIDLE;
            DPF(DBG_TASK, "Closing comm in commtask now............................\n");
            //
            // Can't set it to -1 until we are sure it is dead.
            //
            SetEvent(pvcr->gfTaskWorkDone);
#else

            viscaCommPortClose(pvcr->Port[iPort - 1].idComDev, iPort);
            pvcr->Port[iPort - 1].idComDev = -1;
            DPF(DBG_COMM, "Closing comm in commtask now............................\n");
#endif
            break;

        case TASKCLOSE:
            DPF(DBG_TASK, "TASKCLOSE message received.\n");
#ifdef _WIN32
            pvcr->hwndCommNotifyHandler = NULL;
            PostQuitMessage(0);
            //
            // This is the only place we use the global variable! Because the inst handle is dead.
            //
            pvcr->uTaskState = TASKIDLE;  // We are done processing one message.
            return;
#else
            if (pvcr->hwndCommNotifyHandler)
            {
                DestroyWindow(pvcr->hwndCommNotifyHandler);
                pvcr->hwndCommNotifyHandler = NULL;
            }
            UnregisterClass(szCommNotifyHandlerClassName, hModuleInstance);
            CloseGlobalHandles(pvcr->htaskCommNotifyHandler);
            pvcr->htaskCommNotifyHandler = NULL;
            pvcr->uTaskState = 0;
#endif
            break;

        case TASKOPENDEVICE:
            CreateDeviceHandles(pvcr->htaskCommNotifyHandler, iPort, iDev);
#ifdef _WIN32
            SetEvent(pvcr->gfTaskWorkDone);
#endif
            break;

        case TASKCLOSEDEVICE:
            CloseDeviceHandles(pvcr->htaskCommNotifyHandler, iPort, iDev);
#ifdef _WIN32
            SetEvent(pvcr->gfTaskWorkDone);
#endif
            break;

// This function is only needed in the win32 version.
        case TASKPUNCHCLOCK:
#ifdef _WIN32
            EscapeCommFunction(pvcr->Port[iPort - 1].idComDev, CLRDTR);
            Sleep(2L); // Must be at least 1 millisecond long.
            EscapeCommFunction(pvcr->Port[iPort - 1].idComDev, SETDTR);
            SetEvent(pvcr->gfTaskWorkDone);
#endif
            break;

    }

   return;
}


/****************************************************************************
 * Function: void   viscaTaskCommNotifyHandlerProc - Function for background task.
 *
 * Parameters:
 *
 *      DWORD  dwInstData    - Instance specific data.  Not used.
 *
 ***************************************************************************/
void FAR PASCAL LOADDS
    viscaTaskCommNotifyHandlerProc(DWORD dwInstData)
{
    pvcr->htaskCommNotifyHandler = MGetCurrentTask(); // All other process can access this.

    if (pvcr->hwndCommNotifyHandler == (HWND)NULL)
    {
        WNDCLASS    wc;

        wc.style = 0;
        wc.lpfnWndProc      = (WNDPROC)viscaCommHandlerWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = hModuleInstance;
        wc.hIcon            = NULL;
        wc.hCursor          = NULL;
        wc.hbrBackground    = NULL;
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = szCommNotifyHandlerClassName;
        if (!RegisterClass(&wc))
        {
            DPF(DBG_ERROR, " Couldn't RegisterClass()\n");
            pvcr->htaskCommNotifyHandler = (VISCAHTASK)NULL;
            pvcr->uTaskState = 0;
            return;
        }
        pvcr->hwndCommNotifyHandler = CreateWindow(szCommNotifyHandlerClassName,
                                             TEXT("ViSCA CommNotify Handler"),
                                             0L, 0, 0, 0, 0,
                                             HWND_DESKTOP, NULL,
                                             hModuleInstance, NULL);
        if (!pvcr->hwndCommNotifyHandler)
        {
            DPF(DBG_ERROR, "Couldn't CreateWindow()\n");
            pvcr->htaskCommNotifyHandler =  (VISCAHTASK)NULL;
            pvcr->uTaskState = 0;
            return;
        }
    }

    if(pvcr->htaskCommNotifyHandler == (VISCAHTASK)NULL)
        return;
    //
    // All global semaphores are created by the background task and then
    // must be dupped into each instance. This is both versions!
    //
    CreateGlobalHandles(pvcr->htaskCommNotifyHandler);
    pvcr->uTaskState = TASKIDLE;
#ifdef _WIN32
    // In Win32 the when we return from this the process in msmcivcr.exe will go 
    // into it's idle loop and dispatch messages to the windows.
    return;
#else
    while (pvcr->htaskCommNotifyHandler != (VISCAHTASK)NULL)
    {
        // Block until task is needed.
        pvcr->uTaskState = TASKIDLE;
        while (pvcr->uTaskState == TASKIDLE)
        {
            // GetMsg() ;  Translate() ; Dispatch() ; all happens below!
            mmTaskBlock(pvcr->htaskCommNotifyHandler);
        }
        TaskDoCommand(pvcr->uTaskState, pvcr->lParam);
    }
#endif

}

/****************************************************************************
 * Function: BOOL   viscaTaskCreate - Create background task.
 *
 * Returns: TRUE if successful, otherwise FLASE.
 *
 ***************************************************************************/
BOOL FAR PASCAL
    viscaTaskCreate(void)
{
#ifdef _WIN32
    // Cannot unlock a semaphore that doesn't exist yet.  The background task must
    // create the global semaphores after it starts.
    BOOL fSuccess;
    PROCESS_INFORMATION ProcessInformation;
    STARTUPINFO    sui;

    /* set up the STARTUPINFO structure,
     *  then call CreateProcess to try and start the new exe.
     */
    sui.cb               = sizeof (STARTUPINFO);
    sui.lpReserved       = 0;
    sui.lpDesktop        = NULL;
    sui.lpTitle          = NULL;
    sui.dwX              = 0;
    sui.dwY              = 0;
    sui.dwXSize          = 0;
    sui.dwYSize          = 0;
    sui.dwXCountChars    = 0;
    sui.dwYCountChars    = 0;
    sui.dwFillAttribute  = 0;
    sui.dwFlags          = 0;
    sui.wShowWindow      = 0;
    sui.cbReserved2      = 0;
    sui.lpReserved2      = 0;


    // Create a real process! This process will in turn call CommNotifyHandlerProc to 

    fSuccess = CreateProcess(
        NULL,               // executable image.
        TEXT("msmcivcr.exe"),    // no command line.
        NULL,               // process attr.
        NULL,               // security attr.
        FALSE,              // Process inherit handles??
        NORMAL_PRIORITY_CLASS,   // Creation flags.
        NULL,               // Environment.
        NULL,               // New current directory.
        &sui,               // We have no main window.
        &ProcessInformation);
    //
    // Some arbitrary foreground task is creating this, be sure to close
    // the handles so it is not owned by parent.
    //

    if(fSuccess)
    {
        CloseHandle(ProcessInformation.hThread);
        CloseHandle(ProcessInformation.hProcess);
        DPF(DBG_TASK, "Background process is running.\n");
    }
    else
    {
        DPF(DBG_ERROR, "Background process has died in TaskCreate.\n");
    }

    //
    // We want to wait until the events, window, etc., is created and is dispatching messages.
    //
    while(pvcr->uTaskState != TASKIDLE)
        Sleep(200);

    DPF(DBG_TASK, "Background process has set uTaskState to idle.\n");
    return TRUE;
#else
    viscaReleaseMutex(&pvcr->gfTaskLock);

    // Create background task which will create a window to receive
    // comm port notifications.
    switch (mmTaskCreate((LPTASKCALLBACK)viscaTaskCommNotifyHandlerProc, NULL, 0L))
    {
        case 0:
            // Yield to the newly created task until it has
            // had a chance to initialize or fail to initialize
            while (pvcr->uTaskState == TASKINIT)
            {
                Yield();
            }
            if (!IsTask(pvcr->htaskCommNotifyHandler))
            {
                return (FALSE);
            }
            return (TRUE);
        
        case TASKERR_NOTASKSUPPORT:
        case TASKERR_OUTOFMEMORY:
        default:
            return (FALSE);
    }
#endif
}


/****************************************************************************
 * Function: LRESULT viscaTaskIsRunning - Check if background task is running.
 *
 * Returns: TRUE if background task is running, otherwise FLASE.
 ***************************************************************************/
BOOL FAR PASCAL
    viscaTaskIsRunning(void)
{
    return (pvcr->htaskCommNotifyHandler != (VISCAHTASK)NULL);
}


/****************************************************************************
 * Function: BOOL viscaTaskDestroy - Destroy background task.
 *
 * Returns: TRUE if successful, otherwise FLASE.
 ***************************************************************************/
BOOL FAR PASCAL
    viscaTaskDestroy(void)
{
#ifdef _WIN32
    //
    // We don't need to close the window or unregister class, because it will
    // die when the process dies.
    //
    DPF(DBG_TASK, "Destroying the task now.\n");

    //
    // No need to lock here!
    //
    if(pvcr->uTaskState != TASKIDLE)
    {
        DPF(DBG_ERROR, "---Major Problem! This cannot happen. Task is not idle...\n");
    }

    pvcr->uTaskState = TASKCLOSE;

    if(!PostMessage(pvcr->hwndCommNotifyHandler, (UINT) WM_USER, (WPARAM)TASKCLOSE, (LPARAM)0))
    {
        DPF(DBG_ERROR, "PostMessage to window has failed.");
    }

    DPF(DBG_TASK, "Waiting for pvcr->uTaskState to go idle.\n");

    while(pvcr->uTaskState != TASKIDLE)
    {
        Yield();
        Sleep(50);
    }
    pvcr->htaskCommNotifyHandler = 0L;
    DPF(DBG_TASK, "Destroyed the task.\n");
    return TRUE;
#else
    if (pvcr->htaskCommNotifyHandler)
    {
        pvcr->uTaskState = TASKCLOSE;
        // This PostApp is the same as mmTaskSignal
        PostAppMessage(pvcr->htaskCommNotifyHandler, WM_USER, 0, 0L);
        Yield();
        while (IsTask(pvcr->htaskCommNotifyHandler))
        {
            Yield();
        }
        return (TRUE);
    }
    else
    {
        return (FALSE);
    }
#endif
}


/****************************************************************************
 * Function: BOOL viscaSetCommandComplete - called when a command completes.
 *
 * Parameters:
 *
 *      int iInst  - Instance that started this command.
 *
 *      UINT  uViscaCmd - visca command being completed.
 *
 *       This function is used to change variables which describe the
 *  state of the device. Hence, they are only set on successful completion
 *  of the command in question.
 *
 * Returns: TRUE
 *
 ***************************************************************************/
static BOOL NEAR PASCAL
    viscaSetCommandComplete(UINT iPort, UINT iDev, UINT uViscaCmd)
{
    //
    // This function only is called if the function completes succesful.
    // And only for transport, which means only from commtask.c
    //
    if(uViscaCmd == VISCA_FREEZE)
        pvcr->Port[iPort].Dev[iDev].fFrozen = TRUE;

    if(uViscaCmd == VISCA_UNFREEZE)
        pvcr->Port[iPort].Dev[iDev].fFrozen = FALSE;

    if(uViscaCmd == VISCA_MODESET_OUTPUT)
        pvcr->Port[iPort].Dev[iDev].dwFreezeMode = MCI_VCR_FREEZE_OUTPUT;

    if(uViscaCmd == VISCA_MODESET_INPUT)
        pvcr->Port[iPort].Dev[iDev].dwFreezeMode = MCI_VCR_FREEZE_INPUT;

    if(uViscaCmd == VISCA_MODESET_FIELD)
        pvcr->Port[iPort].Dev[iDev].fField = TRUE;

    if(uViscaCmd == VISCA_MODESET_FRAME)
        pvcr->Port[iPort].Dev[iDev].fField = FALSE;

    //
    // Version 1.0 VISCA ROM's for CVD-1000, must wait 1/60th after search.
    // 
    if((uViscaCmd == VISCA_SEEK) &&
      ((pvcr->Port[iPort].Dev[iDev].uModelID == VISCADEVICEVENDORSONY) &&
       (pvcr->Port[iPort].Dev[iDev].uVendorID == VISCADEVICEMODELCVD1000)))
    {
        DWORD dwTime;
        DWORD dwStart = GetTickCount();

        while(1)
        {
            dwTime = GetTickCount();
            if (((dwTime < dwStart) && ((dwTime + (ROLLOVER - dwStart)) > 20)) ||
                ((dwTime - dwStart) > 20))
                break;
        }
    }
 
    return TRUE;
}

/****************************************************************************
 * Function: BOOL TaskDo - Get the background task to do some work for the foreground task.
 *
 * Parameters:
 *
 *      UINT uDo    - What to do? TASKCOMMOPEN or TASKCOMMCLOSE.
 *
 *      UINT uInfo  - Which commport to open or close.
 *
 *       This is actually a foreground process, and should be in mcicmds.c
 *
 * Returns: TRUE
 *
 ***************************************************************************/
BOOL FAR PASCAL
    viscaTaskDo(int iInst, UINT uDo, UINT uInfo, UINT uMoreInfo)
{
    DWORD lParam;
    //
    // Lock the task.
    //
    DPF(DBG_TASK, "Waiting for task lock.\n");
    viscaWaitForSingleObject(pinst[iInst].pfTaskLock, FALSE, 10000L, 0);  // Or we could wait for unlock.

    if(pvcr->uTaskState != TASKIDLE)
    {
        DPF(DBG_ERROR, "---Major Problem! This cannot happen. Task is not idle...\n");
    }
    //
    // The information is passed in a dword lparam.
    //
    lParam = (DWORD)( ((DWORD)uInfo            & 0x0000ffff) |
                     (((DWORD)uMoreInfo << 16) & 0xffff0000) );

#ifdef _WIN32
    if(!PostMessage(pvcr->hwndCommNotifyHandler, (UINT) WM_USER, (WPARAM)uDo, (LPARAM)lParam))
    {
        DPF(DBG_ERROR, "PostMessage has failed.\n");
    }

    DPF(DBG_TASK, "Waiting for background task to finish it's work.\n");

    WaitForSingleObject(pinst[iInst].pfTaskWorkDone, MY_INFINITE);
    viscaReleaseMutex(pinst[iInst].pfTaskLock);   // Release mutex only.
#else
    // uTaskState is just a "next thing to do" flag.  So.
    pvcr->uTaskState = uDo;
    pvcr->lParam     = lParam;

    // Signal the task to go for it.
    mmTaskSignal(pvcr->htaskCommNotifyHandler);

    // Now wait for the state to go back to idle

    while(pvcr->uTaskState != TASKIDLE)
    {
        Yield();
        DPF(DBG_TASK, "Waiting in viscaTaskDo.\n");
    }
    viscaReleaseMutex(&pvcr->gfTaskLock);
#endif

    return TRUE;
}

#ifdef _WIN32
/***************************************************************************
 *
 * RxThread()
 *
 * Read bytes into a buffer until 0xff (eopacket) is read.
 * Call packet process with this packet.
 *
 * Note: Thread per serial port.
 *       Non-blocking.
 *
 * Version 1.0: Non-blocking spin-loop.
 * Version 2.0: Use overlapped i/o to wait for a character to appear without
 *              polling.
 *
 *
 * Ownership: This thread is owned by background task.
 *  So all files-handles are owned by the current running task.
 *
 *
 */
long FAR PASCAL RxThread(LPVOID uPort)
{
    int     iIndex = 0;
    DWORD   dwRead;

    /*
     * Try to read a character.
     * Add char to buffer.
     * If char read was 0xff call packet process.
     *
     * Do it all over again.
     *
     */ 
    DPF(DBG_TASK, "RxThread ALIVE\n");

    while(pvcr->Port[(UINT) uPort - 1].fOk)
    {
        if(ReadFile(pvcr->Port[(UINT)uPort - 1].idComDev, pvcr->Port[(UINT)uPort - 1].achTempRxPacket, 1, &dwRead, NULL))
        {
            if(!pvcr->Port[(UINT)uPort - 1].fOk)
                break;

            if(dwRead > 0)
            {
                if(dwRead > 1)
                {
                    DPF(DBG_ERROR, "RxThread - Read too many chars.\n");
                }

                pvcr->Port[(UINT)uPort - 1].achRxPacket[iIndex] = pvcr->Port[(UINT)uPort - 1].achTempRxPacket[0];
                iIndex++;

                if((BYTE)(pvcr->Port[(UINT)uPort - 1].achTempRxPacket[0]) == (BYTE)0xff)
                {
                    //
                    // We have the entire packet, send it off to be processed.
                    //
                    DPF(DBG_TASK, "RxThread - packet beind sent to PacketProcess\n");
                    viscaPacketProcess((UINT)uPort - 1, pvcr->Port[(UINT)uPort - 1].achRxPacket); // Use shared memory.
                    iIndex = 0;
                }
            }
            else
            {
                Sleep(15);
            }

        }
        else
        {
            DPF(DBG_ERROR, "RxThread, ReadComm has failed.\n");
        }
    }

    DPF(DBG_TASK, "*** Exiting RxThread");
    ExitThread(0);
    return 0;
}

/***************************************************************************
 *
 * TxThread()
 *
 * Pseudo code:
 *
 *      Wait until the Transmit event is set.
 *      Read from the appropriate static spot.
 *      Do it all over again.
 *
 * Note: Thread per serial port.
 *       Non-blocking.
 *
 * Version 1.0: Non-blocking spin-loop.
 * Version 2.0: Use overlapped i/o to wait for a character to appear without
 *              polling.
 *
 *
 * Ownership: This thread is owned by background task.
 *
 */
long FAR PASCAL TxThread(LPVOID uPort)
{
    DWORD  nBytesWritten;

    DPF(DBG_TASK, "TxThread ALIVE\n");

    while(pvcr->Port[(UINT)uPort - 1].fOk)
    {
        DPF(DBG_TASK, "TxThread - Waiting for TxReady to be set. port index %u\n", (UINT)uPort - 1);

        if(WAIT_FAILED == WaitForSingleObject(pvcr->Port[(UINT)uPort - 1].fTxReady, MY_INFINITE))
        {
            DPF(DBG_ERROR, "TxThread - WaitFor fTxReady failed.\n");
        }

        //
        // We must be signalled to let use go and die.
        //
        if(!pvcr->Port[(UINT)uPort - 1].fOk)
            break;

        DPF(DBG_TASK, "Okay transmitting now.\n");

        // Read from static location.
        if(!WriteFile(pvcr->Port[(UINT)uPort - 1].idComDev,
            pvcr->Port[(UINT)uPort-1].achTxPacket,
            pvcr->Port[(UINT)uPort-1].nchTxPacket,
            &nBytesWritten,
            NULL))
        {
            DPF(DBG_ERROR, "TxThread - WriteFile failed.");
        }

        if(nBytesWritten != pvcr->Port[(UINT)uPort-1].nchTxPacket)
        {
            DPF(DBG_TASK, " TxThread: Error - tried %u, wrote %u ", pvcr->Port[(UINT)uPort-1].nchTxPacket, nBytesWritten);
        }

        if(!SetEvent(pvcr->Port[(UINT)uPort-1].fTxBuffer))
        {
            DPF(DBG_ERROR, "TxThread SetEvent fTxBuffer failed.\n");
        }
    }

    DPF(DBG_TASK, "*** Exiting TxThread");
    ExitThread(0);
    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\mcivisca\mcicmds.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992-1995 Microsoft Corporation
 * 
 *  MCICMDS.C           
 *
 *  MCI ViSCA Device Driver         
 *
 *  Description:
 *
 *      MCI Command Message Procedures
 *
 ***************************************************************************/
            
#define  UNICODE
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include "appport.h"
#include <mmddk.h>
#include <stdlib.h>
#include <string.h>
#include "vcr.h"
#include "viscadef.h"
#include "mcivisca.h"
#include "viscamsg.h"
#include "common.h"            

#define NO_LENGTH   0xFFFFFFFF      /* Invalid length */

extern HINSTANCE       hModuleInstance;    // module instance  (different in NT - DLL instances)

// In muldiv.asm 
extern DWORD FAR PASCAL muldiv32(DWORD, DWORD, DWORD);

// Forward references to non-exported functions 
static BOOL  NEAR PASCAL viscaTimecodeCheck(int iInst);
static BOOL  NEAR PASCAL viscaStartTimecodeCheck(int iInst, BOOL fPause);
static DWORD NEAR PASCAL viscaMciSet(int iInst, DWORD dwFlags, LPMCI_VCR_SET_PARMS lpSet);

/****************************************************************************
 * Function: int viscaInstanceCreate - Create an OpenInstance
 *                       structure for a given MCI device ID.
 *
 * Parameters:
 *
 *      UINT uDeviceID - MCI device ID.
 *
 *      UINT iPort - Port index (0..3).
 *
 *      UINT iDev - Device index (0..6).
 *
 * Returns: a pointer to the OpenInstance structure created if
 *        successful, otherwise NULL.
 *
 *       Each time MCI uses this driver to open a device,
 *       viscaInstanceCreate() is called to create an OpenInstance structure
 *       and associate it with the MCI device ID.
 ***************************************************************************/
int FAR PASCAL
viscaInstanceCreate(UINT uDeviceID, UINT iPort, UINT iDev)
{
    int            iInst;

    //
    // Create new "open instance" entry for the specified device
    //
    iInst = MemAllocInstance();

    if(iInst != -1)
    {
        pinst[iInst].pidThisInstance  = MGetCurrentTask(); // Used to 1. open this task and dup event.
        pinst[iInst].uDeviceID        = uDeviceID;
        pinst[iInst].iPort            = iPort;
        pinst[iInst].iDev             = iDev;
        pinst[iInst].dwTimeFormat     = MCI_FORMAT_MILLISECONDS;
        pinst[iInst].dwCounterFormat  = MCI_FORMAT_MILLISECONDS;

        pinst[iInst].fGlobalHandles  = FALSE;
        pinst[iInst].fPortHandles    = FALSE;
        pinst[iInst].fDeviceHandles  = FALSE;

#ifdef _WIN32
        // Ack and completion events for this instance

        pinst[iInst].fCompletionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        pinst[iInst].fAckEvent        = CreateEvent(NULL, TRUE, FALSE, NULL);
#endif

    }

    // 0 is an illegal value for device id.
    if(uDeviceID != 0) 
        mciSetDriverData(uDeviceID, (UINT)iInst);

    return (iInst);
}



/****************************************************************************
 * Function: void viscaInstanceDestroy - Destroy an OpenInstance.
 *
 * Parameters:
 *
 *      int iInst - Pointer to OpenInstance struct to
 *                       destroy.
 *
 *       When an MCI device ID is closed, viscaInstanceDestroy() is called
 *       to free the OpenInstance structure corresponding to that device ID.
 *
 ***************************************************************************/
void FAR PASCAL
viscaInstanceDestroy(int iInst)
{
    CloseAllInstanceHandles(iInst); // Close my handles to everything.
    mciSetDriverData(pinst[iInst].uDeviceID, 0L); // prevent reenter if we yield in this function.

    DPF(DBG_MEM, "viscaInstanceDestroy - Freeing iInst = %d \n", iInst);
    MemFreeInstance(iInst);
}
    

/****************************************************************************
 * Function: UINT viscaMciFPS - Returns the number of frames per second
 *               for an MCI time format.
 *
 * Parameters:
 *
 *      DWORD dwTimeFormat - MCI time format.
 *
 * Returns: number of frames per second if successful, otherwise 0.
 *
 *       This function should only be used for SMPTE time formats,
 *       i.e. MCI_FORMAT_SMPTE_XX, where XX is 24, 25, 30, or 30DROP.
 ***************************************************************************/
static UINT NEAR PASCAL
viscaMciFPS(DWORD dwMCITimeFormat)
{        
    switch (dwMCITimeFormat)
    {
        case MCI_FORMAT_SMPTE_24:
            return (24);
        case MCI_FORMAT_SMPTE_25:
            return (25);
        case MCI_FORMAT_SMPTE_30:
        case MCI_FORMAT_SMPTE_30DROP:
            return (30);
        default:
            return (0);
    }
}


/****************************************************************************
 * Function: DWORD viscaMciTimeFormatToViscaData - Convert an Mci time
 *               value to a ViSCA data structure.
 *
 * Parameters:
 *
 *      int iInst - Instance on whose behalf conversion
 *                       is being done.
 *
 *      BOOL fTimecode - Are we using the timecode or counter? (can both be non-drop frame).
 *
 *      DWORD dwTime - Time value to convert.
 *
 *      LPSTR lpstrData - Buffer to hold result.
 *
 *      BYTE bDataFormat - ViSCA data format desired.
 *
 * Returns: an Mci error code.
 *
 *       Converts an MCI DWORD position variable in the current MCI time
 *       format (specified in iInst->dwTimeFormat) to a ViSCA 5-byte
 *       position data structure of the type specified by bDataFormat.
 ***************************************************************************/
DWORD FAR PASCAL
viscaMciTimeFormatToViscaData(int iInst, BOOL fTimecode, DWORD dwTime, LPSTR lpstrData, BYTE bDataFormat)
{
    BYTE    bHours;
    BYTE    bMinutes;
    BYTE    bSeconds;
    BYTE    bFrames;
    UINT    uDevFPS  = pvcr->Port[pinst[iInst].iPort].Dev[pinst[iInst].iDev].uFramesPerSecond;
    DWORD   dwTimeFormat;

    if(fTimecode)
        dwTimeFormat =  pinst[iInst].dwTimeFormat;
    else
        dwTimeFormat =  pinst[iInst].dwCounterFormat;
    //
    // First extract hours, minutes, seconds, and frames from MCI data
    //
    switch (dwTimeFormat)
    {
        case MCI_FORMAT_MILLISECONDS:
            bHours   = (BYTE)(dwTime / 3600000L);
            bMinutes = (BYTE)((dwTime / 60000L) % 60);
            bSeconds = (BYTE)((dwTime /  1000L) % 60);
            bFrames  = (BYTE)((dwTime % 1000) * uDevFPS / 1000);
            break;
        case MCI_FORMAT_HMS:
            bHours   = MCI_HMS_HOUR(dwTime);
            bMinutes = MCI_HMS_MINUTE(dwTime);
            bSeconds = MCI_HMS_SECOND(dwTime);
            bFrames  = 0;
            break;
        case MCI_FORMAT_MSF:
            bHours   = (BYTE)(MCI_MSF_MINUTE(dwTime) / 60);
            bMinutes = (BYTE)(MCI_MSF_MINUTE(dwTime) % 60);
            bSeconds = MCI_MSF_SECOND(dwTime);
            bFrames  = MCI_MSF_FRAME(dwTime);
            break;
        case MCI_FORMAT_TMSF:
            if (MCI_TMSF_TRACK(dwTime) != 1)
                return(MCIERR_OUTOFRANGE);
            bHours   = (BYTE)(MCI_TMSF_MINUTE(dwTime) / 60);
            bMinutes = (BYTE)(MCI_TMSF_MINUTE(dwTime) % 60);
            bSeconds = MCI_TMSF_SECOND(dwTime);
            bFrames  = MCI_TMSF_FRAME(dwTime);
            break;
        case MCI_FORMAT_FRAMES:
        case MCI_FORMAT_SAMPLES:
            bHours   = (BYTE)(dwTime / (uDevFPS * 3600L));
            bMinutes = (BYTE)((dwTime / (uDevFPS * 60)) % 60);
            bSeconds = (BYTE)((dwTime / uDevFPS) % 60);
            bFrames  = (BYTE)(dwTime % uDevFPS);
            break;
        case MCI_FORMAT_SMPTE_24:
        case MCI_FORMAT_SMPTE_25:
        case MCI_FORMAT_SMPTE_30:
        case MCI_FORMAT_SMPTE_30DROP:
            bHours   = LOBYTE(LOWORD(dwTime));
            bMinutes = HIBYTE(LOWORD(dwTime));
            bSeconds = LOBYTE(HIWORD(dwTime));
            bFrames  = (BYTE)(UINT)MulDiv(HIBYTE(HIWORD(dwTime)),
                                          uDevFPS,
                                          viscaMciFPS(dwTimeFormat));
            //
            // Because of rounding, it's theoretically possible that bFrames
            // will exceed uDevFPS - 1.  So check for this condition.
            //
            if (bFrames >= uDevFPS)
                bFrames = uDevFPS - 1;
            break;
        case MCI_FORMAT_BYTES:
        default:
            return (MCIERR_BAD_TIME_FORMAT);
    }
    //
    // Create ViSCA data
    //

    if( (bMinutes >= 60) || (bSeconds >= 60) || (bFrames >= uDevFPS) )
        return(MCIERR_OUTOFRANGE);

    // Smpte timecode has a maximum of 23:59:59:29

    if(fTimecode && (bHours >= 24))
        return(MCIERR_OUTOFRANGE);

    viscaDataPosition(lpstrData, bDataFormat, bHours, bMinutes, bSeconds, bFrames);

    return (MCIERR_NO_ERROR);
}

/****************************************************************************
 * Function: DWORD viscaMciClockFormatToViscaData - Convert an MCI time
 *               value to a ViSCA data structure.
 *
 * Parameters:
 *
 *      DWORD dwTime - Time value to convert.
 *
 *      UINT   uTicksPerSecond - Ticks per second.
 *
 *      BYTE * bHours -  Hours returned.
 *
 *      BYTE * bMinutes - Minutes returned.
 *
 *      BYTE * bSeconds - Seconds returned.
 *
 *      UINT * uTicks - Ticks returned.
 *
 * Returns: an MCI error code.
 *
 *       Converts an MCI DWORD position variable in the current MCI time
 *       format (specified in pinst[iInst].dwTimeFormat) to a ViSCA 5-byte
 *       position data structure of the type specified by bDataFormat.
 ***************************************************************************/
DWORD FAR PASCAL
viscaMciClockFormatToViscaData(DWORD dwTime, UINT uTicksPerSecond, BYTE FAR *bHours, BYTE FAR *bMinutes, BYTE FAR *bSeconds, UINT FAR *uTicks)
{

    *bHours   = (BYTE)(dwTime / (3600L * (LONG) uTicksPerSecond));
    *bMinutes = (BYTE)((dwTime / (60L * (LONG) uTicksPerSecond)) % 60);
    *bSeconds = (BYTE)((dwTime / (LONG) uTicksPerSecond) % 60);
    *uTicks   = (UINT)((dwTime % (LONG) uTicksPerSecond));

    return MCIERR_NO_ERROR;
}

/****************************************************************************
 * Function: DWORD viscaDataToMciTimeFormat - Convert a ViSCA data structure
 *               to an MCI time value.
 *
 * Parameters:
 *
 *      int iInst - Instance on whose behalf conversion
 *                       is being done.
 *
 *      LPSTR lpstrData - ViSCA data structure to be converted.
 *
 *      DWORD FAR * lpdwTime - Pointer to DWORD to hold result.
 *
 * Returns: an MCI error code.
 *
 *       Converts a ViSCA 5-byte position data structure to an MCI DWORD
 *       position variable in the current MCI time format (specified in
 *       pinst[iInst].dwTimeFormat).
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaDataToMciTimeFormat(int iInst, BOOL fTimecode, LPSTR lpstrData, DWORD FAR *lpdwTime)
{
    UINT    uHours   = VISCAHOURS(lpstrData);
    UINT    uMinutes = VISCAMINUTES(lpstrData);
    UINT    uSeconds = VISCASECONDS(lpstrData);
    UINT    uFrames  = VISCAFRAMES(lpstrData);
    UINT    uDevFPS  = pvcr->Port[pinst[iInst].iPort].Dev[pinst[iInst].iDev].uFramesPerSecond;
    UINT    uMCIFPS  ;
    DWORD   dwTimeFormat;
   
    if(fTimecode)
        dwTimeFormat =  pinst[iInst].dwTimeFormat;
    else
        dwTimeFormat =  pinst[iInst].dwCounterFormat;

    uMCIFPS  = viscaMciFPS(dwTimeFormat);

    //
    // Sometimes a ViSCA device will return a bogus position. 
    //
    if ((uMinutes >= 60) || (uSeconds >= 60))
    {
        DPF(DBG_ERROR, "Bad uMinutes, uSeconds!\n");
        return (MCIERR_DRIVER_INTERNAL);
    }

    switch(dwTimeFormat)
    {
        case MCI_FORMAT_MILLISECONDS:
            *lpdwTime = (uHours * 3600000L) + (uMinutes * 60000L) +
                        (uSeconds * 1000L) +
                        (uFrames * 1000L / uDevFPS);
            return (MCIERR_NO_ERROR);

        case MCI_FORMAT_HMS:
            *lpdwTime = MCI_MAKE_HMS(uHours, uMinutes, uSeconds);
            return (MCI_COLONIZED3_RETURN);

        case MCI_FORMAT_MSF:
            *lpdwTime = MCI_MAKE_MSF((uHours * 60) + uMinutes, uSeconds,
                                                               uFrames);
            return (MCI_COLONIZED3_RETURN);

        case MCI_FORMAT_TMSF:
            *lpdwTime = MCI_MAKE_TMSF(1, (uHours * 60) + uMinutes, uSeconds,
                                                                   uFrames);
            return (MCI_COLONIZED4_RETURN);

        case MCI_FORMAT_FRAMES:
        case MCI_FORMAT_SAMPLES:
            *lpdwTime = ((uHours * 3600L + uMinutes * 60L + uSeconds) *
                         uDevFPS) + uFrames;
            return (MCIERR_NO_ERROR);

        case MCI_FORMAT_SMPTE_30DROP:
        case MCI_FORMAT_SMPTE_24:
        case MCI_FORMAT_SMPTE_25:
        case MCI_FORMAT_SMPTE_30:
        {
            uFrames  = MulDiv(uFrames, uMCIFPS, uDevFPS);
            //
            // Because of rounding, it's theoretically possible that uFrames
            // will exceed uMCIFPS - 1.  So check for this condition.
            //
            if (uFrames >= uMCIFPS) 
                uFrames = uMCIFPS - 1;
            
            *lpdwTime = ((DWORD)uHours) | ((DWORD)uMinutes << 8) |
                        ((DWORD)uSeconds << 16) | ((DWORD)uFrames << 24);
            return (MCI_COLONIZED4_RETURN);
        }

        default:
            return (MCIERR_BAD_TIME_FORMAT);
    }
}

/****************************************************************************
 * Function: DWORD viscaMciPos1LessThanPos2 - Checks whether a given position
 *               in the current MCI time format preceeds another
 *
 * Parameters:
 *
 *      int iInst - Instance on whose behalf check is made.
 *
 *      DWORD dwPos1 - First position.
 *
 *      DWORD dwPos2 - Second position.
 *
 * Returns: TRUE if dwPos1 preceeds dwPos2, otherwise FALSE.
 *
 *       This function is necessary because MCI stores byte-packed positions
 *       in reverse order.  I.e., SMPTE positions are stored as FFSSMMHH,
 *       which makes easy comparisons impossible.
 ***************************************************************************/
BOOL FAR PASCAL
viscaMciPos1LessThanPos2(int iInst, DWORD dwPos1, DWORD dwPos2)
{
#define REVERSEBYTES(x)     (((DWORD)HIBYTE(HIWORD(x))      ) | \
                             ((DWORD)LOBYTE(HIWORD(x)) <<  8) | \
                             ((DWORD)HIBYTE(LOWORD(x)) << 16) | \
                             ((DWORD)LOBYTE(LOBYTE(x)) << 24))

    switch (pinst[iInst].dwTimeFormat)
    {
        case MCI_FORMAT_SMPTE_24:
        case MCI_FORMAT_SMPTE_25:
        case MCI_FORMAT_SMPTE_30:
        case MCI_FORMAT_SMPTE_30DROP:
        case MCI_FORMAT_HMS:
        case MCI_FORMAT_TMSF:
        case MCI_FORMAT_MSF:
            return (REVERSEBYTES(dwPos1) < REVERSEBYTES(dwPos2));
        default:
            return (dwPos1 < dwPos2);
    }
}

/****************************************************************************
 * Function: DWORD viscaRoundSpeed - Map ranges of speeds into increments.
 *
 * Parameters:
 *
 *      DWORD dwSpeed  - MCI specified speed.
 *
 *      BOOL  fReverse - Direction of speed.
 *
 * Returns: rounded speed.
 *
 *       If total variable speed is desired then this function is needs
 *       to be changed to something device specific. i.e. A device specific
 *       mapping.
 *       
 ***************************************************************************/
DWORD FAR PASCAL
viscaRoundSpeed(DWORD dwSpeed, BOOL fReverse)
{
   if (dwSpeed == 0L)
       return(0L);
   else if (dwSpeed <= 150)
       return(100L);
   else if (dwSpeed <= 600)
       return(200L);
   else if (dwSpeed <= 1500)
       return(1000L);
   else
       return(2000L);
}

/****************************************************************************
 * Function: DWORD viscaMapSpeed - Map the speed into the VISCA command.
 *
 * Parameters:
 *
 *      DWORD dwSpeed  - MCI specified speed.
 *
 *      BOOL  fReverse - Direction of speed.
 *
 * Returns: rounded speed.
 *
 *       If total variable speed is desired then this function is needs
 *       to be changed to something device specific. i.e. A device specific
 *       mapping.
 *
 *       This should be combined with Round speed, since they do the
 *       same thing. So the return variables would be:
 *         1. Visca command
 *         2. The rounded speed this corresponds to.
 *
 *       We need to play at the speed dictated by DEVICEPLAYSPEED,
 *      where 1000 is normal.  We have 5 play speeds available:
 *      SLOW2 (x1/10), SLOW1 (x1/5), normal (x1), and FAST1 (x2).
 *      We choose one of these fives based on the following step function:
 *            0 -- STILL
 *     1 -  150 -- SLOW2
 *   151 -  600 -- SLOW1
 *   601 - 1500 -- normal
 *  1501 - .... -- FAST1
 *
 ***************************************************************************/
BYTE FAR PASCAL
viscaMapSpeed(DWORD dwSpeed, BOOL fReverse)
{
    if(fReverse)
    {
        //
        // You cannot set the speed to 0 and expect it to stop! 
        //
        if(dwSpeed == 0)
            return ( VISCAMODE1STILL);    
        if (dwSpeed <= 150) 
            return ( VISCAMODE1REVERSESLOW2);
        else if (dwSpeed <= 600) 
            return ( VISCAMODE1REVERSESLOW1);
        else if (dwSpeed <= 1500)
            return ( VISCAMODE1REVERSEPLAY);
        else 
            return ( VISCAMODE1REVERSEFAST1);
    }
    else
    {
        if (dwSpeed == 0)
            return ( VISCAMODE1STILL);    
        else if(dwSpeed <= 150) 
            return ( VISCAMODE1SLOW2);
        else if (dwSpeed <= 600) 
            return ( VISCAMODE1SLOW1);
        else if (dwSpeed <= 1500) 
            return ( VISCAMODE1PLAY);
        else 
            return ( VISCAMODE1FAST1);
    }
}

/****************************************************************************
 * Function: DWORD viscaMciCloseDriver - Edit instance-specific cleanup.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_GENERIC_PARMS lpGeneric - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_CLOSE_DRIVER
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciCloseDriver(int iInst, DWORD dwFlags, LPMCI_GENERIC_PARMS lpGeneric)
{
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;

    //
    // Remove any delayed commands running for this instance.
    //
    viscaRemoveDelayedCommand(iInst);
    //
    // Close in same order opened port, device, instance. (task if necessary)
    // We cannot close task first because it is needed to receivce port closing messages.
    // WE cannot kill port before instance, because we need to synchronize closing.
    // 
    // Task is first opened and last closed. Port, device, instance are created
    // on demand. instance first, then device, then port. So close then
    // port, device, instance in reverse order.
    //
    pvcr->Port[iPort].nUsage--;
    pvcr->Port[iPort].Dev[iDev].nUsage--;
    //
    // Kill the port if necessary.
    //
    if (pvcr->Port[iPort].nUsage == 0)
    {
        DPF(DBG_COMM, "Port on Port=%d closing \n", iPort);
        viscaTaskDo(iInst, TASKCLOSECOMM, iPort + 1, 0);
        // Port handles owned by background process are closed.
    }
    //
    // Kill the device if this is the last of shared.
    //
    if(pvcr->Port[iPort].Dev[iDev].nUsage == 0)
    {
        DPF(DBG_COMM, "Device on Port=%d Device=%d closing \n", iPort, iDev);
        viscaTaskDo(iInst, TASKCLOSEDEVICE, iPort, iDev);
        // Device handles owned by background task are closed.
    }

    DPF(DBG_COMM, "Instance on Port=%d Device=%d Instance=%d closing \n", iPort, iDev, iInst);
    return (viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
}


/****************************************************************************
 * Function: DWORD viscaDeviceConfig - Get device specific information.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 * Returns: an MCI error code.
 *
 *         1. Get information that requires communication.
 *         2. Save static info that does not require communication.
 *
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaDeviceConfig(int iInst, DWORD dwFlags)
{
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;
    BYTE    achPacket[MAXPACKETLENGTH];
    MCI_VCR_STATUS_PARMS mciStatus;
    DWORD   dwErr;
    //
    // Create this device's automatic command entry 
    //
    pvcr->Port[iPort].Dev[iDev].fDeviceOk       = TRUE;
    pvcr->Port[iPort].Dev[iDev].iInstTransport  = -1;
    pvcr->Port[iPort].Dev[iDev].iInstReply      = -1;
    pvcr->Port[iPort].Dev[iDev].dwPlaySpeed     = 1000L;
    pvcr->Port[iPort].Dev[iDev].fQueueReenter   = FALSE;

    // I should query this from device, if they're not reset.
    pvcr->Port[iPort].Dev[iDev].bVideoDesired   = 0x01; // on
    pvcr->Port[iPort].Dev[iDev].bAudioDesired   = 0x03;
    pvcr->Port[iPort].Dev[iDev].bTimecodeDesired= 0x01; 

    //
    // 0 means completion successful  
    //
    if(!viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
        achPacket,
        viscaMessageIF_DeviceTypeInq(achPacket + 1)))
    {
        // Is it one of the known types?
        pvcr->Port[iPort].Dev[iDev].uModelID   = achPacket[3]; // These are 1 relative
        pvcr->Port[iPort].Dev[iDev].uVendorID  = achPacket[5];
    }

    if(pvcr->Port[iPort].Dev[iDev].fDeviceOk)
    {
        DPF(DBG_MCI, "Vendor = %d ",  achPacket[3]);
        DPF(DBG_MCI, "Model  = %d\n", achPacket[5]);
    }
    else
    {
        DPF(DBG_ERROR, "Device refuses to open.\n");
    }

    //
    // An entry for number of -1 doesn't mean 0, it means no knowledge.
    //
    pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uNumInputs = -1;
    pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uNumInputs = -1;

    //
    // It would be nice if these tables were external somewhere (like in an ini file)
    // The only published devices are Sony. Hence the table.  Not meant to be
    // exclusionary.
    //
    if(pvcr->Port[iPort].Dev[iDev].uModelID == VISCADEVICEVENDORSONY)
    {
        switch(pvcr->Port[iPort].Dev[iDev].uVendorID)
        {
            case VISCADEVICEMODELCI1000:
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uNumInputs = 2;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uNumInputs = 2;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[0] = MCI_VCR_SRC_TYPE_MUTE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[1] = MCI_VCR_SRC_TYPE_LINE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uInputType[0] = MCI_VCR_SRC_TYPE_MUTE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uInputType[1] = MCI_VCR_SRC_TYPE_LINE;
                //
                // Preroll duration in frames.
                //
                pvcr->Port[iPort].Dev[iDev].uPrerollDuration = 0;
                
                break;

            case VISCADEVICEMODELCVD1000:
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uNumInputs = 4;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uNumInputs = 3;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[0] = MCI_VCR_SRC_TYPE_MUTE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[1] = MCI_VCR_SRC_TYPE_LINE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[2] = MCI_VCR_SRC_TYPE_LINE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[3] = MCI_VCR_SRC_TYPE_SVIDEO;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uInputType[0] = MCI_VCR_SRC_TYPE_MUTE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uInputType[1] = MCI_VCR_SRC_TYPE_LINE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uInputType[2] = MCI_VCR_SRC_TYPE_LINE;
                //
                // Preroll duration in frames.
                //
                pvcr->Port[iPort].Dev[iDev].uPrerollDuration = 42;
                break;

            case VISCADEVICEMODELEVO9650:
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uNumInputs = 4;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uNumInputs = 2;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[0] = MCI_VCR_SRC_TYPE_MUTE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[1] = MCI_VCR_SRC_TYPE_LINE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[2] = MCI_VCR_SRC_TYPE_SVIDEO;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_VIDEO].uInputType[3] = MCI_VCR_SRC_TYPE_AUX;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uInputType[0] = MCI_VCR_SRC_TYPE_MUTE;
                pvcr->Port[iPort].Dev[iDev].rgInput[VCR_INPUT_AUDIO].uInputType[1] = MCI_VCR_SRC_TYPE_LINE;
                //
                // Preroll duration in frames.
                //
                pvcr->Port[iPort].Dev[iDev].uPrerollDuration = 90;
 

                viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                                achPacket, 
                                viscaMessageENT_FrameMemorySelectInq(achPacket + 1));

                if(achPacket[2] == 2)
                    pvcr->Port[iPort].Dev[iDev].dwFreezeMode    = MCI_VCR_FREEZE_OUTPUT;
                else if(achPacket[2] == 1)
                    pvcr->Port[iPort].Dev[iDev].dwFreezeMode    = MCI_VCR_FREEZE_INPUT;

                viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                                achPacket, 
                                viscaMessageSE_VDEReadModeInq(achPacket + 1));

                if(achPacket[2] == 2)
                    pvcr->Port[iPort].Dev[iDev].fField    = TRUE;
                else if(achPacket[2] == 1)
                    pvcr->Port[iPort].Dev[iDev].fField    = FALSE;

                break;
        }
    }
    //
    // Information that requires communication to the device 
    //
    if (!viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
        achPacket, 
        viscaMessageMD_ConfigureIFInq(achPacket + 1)))
        pvcr->Port[iPort].Dev[iDev].uFramesPerSecond = FROMBCD(achPacket[2]);
    else
        pvcr->Port[iPort].Dev[iDev].uFramesPerSecond = 30;

    pvcr->Port[iPort].Dev[iDev].uTimeMode      = MCI_VCR_TIME_DETECT;
    pvcr->Port[iPort].Dev[iDev].bTimeType      = (BYTE) 0;
    if(viscaSetTimeType(iInst, VISCAABSOLUTECOUNTER))
        pvcr->Port[iPort].Dev[iDev].bTimeType = VISCARELATIVECOUNTER;
    
    pvcr->Port[iPort].Dev[iDev].uIndexFormat   = MCI_VCR_INDEX_TIMECODE;
    //
    // Get the mode, be sure no to notify!! 
    //
    pvcr->Port[iPort].Dev[iDev].fTimecodeChecked = FALSE;

    mciStatus.dwItem = MCI_STATUS_MODE;
    dwErr = viscaMciStatus(iInst, MCI_STATUS_ITEM, &mciStatus);

    if(HIWORD(mciStatus.dwReturn) == MCI_MODE_NOT_READY)
    {
        MCI_VCR_SET_PARMS mciSet;
        DPF(DBG_MCI, "Power is off, turning power on now.\n");
        //
        // Turn the power on 
        //
        viscaMciSet(iInst, MCI_VCR_SET_POWER | MCI_SET_ON, &mciSet);
        //
        // Get the new mode 
        //
        mciStatus.dwItem = MCI_STATUS_MODE;
        dwErr = viscaMciStatus(iInst, MCI_STATUS_ITEM, &mciStatus);
    }

    //
    // Save our current state.
    //
    pvcr->Port[iPort].Dev[iDev].uLastKnownMode = (UINT) mciStatus.dwReturn;
    switch(HIWORD(mciStatus.dwReturn))
    {
        case MCI_MODE_STOP:
            // I don't need to know, so just start it now 
            viscaStartTimecodeCheck(iInst, TRUE);
            break;

        case MCI_MODE_PLAY:
        case MCI_MODE_RECORD:
        case MCI_MODE_SEEK:
        case MCI_MODE_PAUSE:
            // I don't need to know, so just start it now 
            viscaStartTimecodeCheck(iInst, FALSE);
            break;

        case MCI_MODE_NOT_READY:
        case MCI_MODE_OPEN:
        default:
            // nothing we can do 
            break;
    }
    //
    // Counter is different than Timecode because it can be read as
    // soon as a tape is inserted. There is no need to delay on that one.
    //
    if(!viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                                        achPacket, 
                                        viscaMessageMD_PositionInq(achPacket + 1, VISCADATARELATIVE)))
    {
        // The upper 4 bits indicates default counter in use 
        if(achPacket[1] == VISCADATAHMSF)
            pvcr->Port[iPort].Dev[iDev].bRelativeType = VISCADATAHMSF;
        else
            pvcr->Port[iPort].Dev[iDev].bRelativeType = VISCADATAHMS;
    }
    else
    {
        pvcr->Port[iPort].Dev[iDev].bRelativeType = 0;
    }
    pvcr->Port[iPort].Dev[iDev].fCounterChecked = TRUE;


    pvcr->Port[iPort].Dev[iDev].uRecordMode = FALSE;

    //
    // Bug in CI-1000 ROM.  Returns 30 instead of 300, so just set all to 300.
    //
#ifdef CLOCK_FIXED 
    if(!viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
        achPacket, 
        viscaMessageIF_ClockInq(achPacket + 1)))
          pvcr->Port[iPort].Dev[iDev].uTicksPerSecond = (10 * (FROMBCD(achPacket[7]))) + (FROMBCD(achPacket[8]));
#else
    pvcr->Port[iPort].Dev[iDev].uTicksPerSecond = 300;
#endif
    //
    // Save static device information, that does not require communication.
    //
    pvcr->Port[iPort].Dev[iDev].nUsage = 1;
    pvcr->Port[iPort].Dev[iDev].fShareable = ((dwFlags & MCI_OPEN_SHAREABLE) != 0L);
    pvcr->Port[iPort].Dev[iDev].dwTapeLength = NO_LENGTH;
    
    return (MCIERR_NO_ERROR);
}

/****************************************************************************
 * Function: DWORD viscaSetTimeType - If CI1000 we need subControl when changing
 *          from relative to absolute modes.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      BYTE bType - ABSOLUTE or RELATIVE
 *
 * Returns: 0L
 *
 ***************************************************************************/
DWORD FAR PASCAL viscaSetTimeType(int iInst, BYTE bType)
{
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;
    //
    // The only reason to use, SubControl is for CI-1000 compatibility 
    //
    if((pvcr->Port[iPort].Dev[iDev].uModelID == VISCADEVICEVENDORSONY) &&
       (pvcr->Port[iPort].Dev[iDev].uVendorID == VISCADEVICEMODELCI1000))
    {
        if(pvcr->Port[iPort].Dev[iDev].bTimeType != bType)
        {
            BYTE    achPacket[MAXPACKETLENGTH];
            DWORD   dwErr;

            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Subcontrol(achPacket + 1, bType));

            if(!dwErr)
                pvcr->Port[iPort].Dev[iDev].bTimeType =  bType;
            else
                return 1L;
        }
    }
    else
    {
        pvcr->Port[iPort].Dev[iDev].bTimeType =  bType;
    }

    return 0L;
}


/****************************************************************************
 * Function: DWORD viscaDeviceAlreadyOpen - Open a device that is already open.
 *
 * Parameters:
 *
 *      int iInst - open instance.
 *
 *      DWORD dwFlags - Flags to the open.
 *
 *      LPMCI_OPEN_PARMS lpOpen - Pointer to MCI parameter block.
 *
 * Returns: 0L
 *
 ***************************************************************************/
DWORD NEAR PASCAL viscaDeviceAlreadyOpen(int iInst, DWORD dwFlags, LPMCI_OPEN_PARMS lpOpen)

{
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;
    DWORD   dwErr;

    if (pvcr->Port[iPort].Dev[iDev].fShareable)
    {
        if (dwFlags & MCI_OPEN_SHAREABLE)
        {
            pvcr->Port[iPort].nUsage++;
            pvcr->Port[iPort].Dev[iDev].nUsage++;

            // Port is already open.
            DuplicatePortHandlesToInstance(pvcr->htaskCommNotifyHandler, iPort, iInst);

            // Device handles must already have been created to open shareable.
            DuplicateDeviceHandlesToInstance(pvcr->htaskCommNotifyHandler, iPort, iDev, iInst);

            // Is the device dead before we open it?
            if(!pvcr->Port[iPort].Dev[iDev].fDeviceOk)
            {
                dwErr = MCIERR_DEVICE_NOT_READY;
                pvcr->Port[iPort].Dev[iDev].fDeviceOk = TRUE;
                viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr);
                return dwErr;
            }

            DPF(DBG_MCI, "Opening extra copy shareable\n");
            viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR);
            return MCIERR_NO_ERROR;
        }
        else
        {
            DPF(DBG_MCI, "Cannot open non-shareable since already open shareable\n");

            dwErr = MCIERR_MUST_USE_SHAREABLE;
            viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr);
            return dwErr;
        }
    }
    else
    {
        DPF(DBG_MCI, "Cannot open device since already open non-shareable\n");

        dwErr = MCIERR_MUST_USE_SHAREABLE;
        viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr);
        return dwErr;
    }
}

/****************************************************************************
 * Function: DWORD viscaOpenCommPort - Open the commport.
 *
 * Parameters:
 *
 *      int iInst - Open instance.
 *
 *      DWORD dwFlags - Open flags.
 *
 *      LPMCI_OPEN_PARMS lpOpen - Pointer to MCI parameter block.
 *
 * Returns: 0L
 *
 ***************************************************************************/
DWORD NEAR PASCAL viscaOpenCommPortAndDevice(int iInst, DWORD dwFlags, LPMCI_OPEN_PARMS lpOpen)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;
    DWORD   dwErr;

    viscaTaskDo(iInst, TASKOPENCOMM, iPort + 1, 0);

    if(pvcr->Port[iPort].idComDev < 0)
    {
        dwErr = MCIERR_HARDWARE;
        viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr);

        return dwErr;
    }

    DuplicatePortHandlesToInstance(pvcr->htaskCommNotifyHandler, iPort, iInst);

    // We must open the device here to use it's data structures to communicate
    // with the Visca Network.

    viscaTaskDo(iInst, TASKOPENDEVICE, iPort, iDev);
    DuplicateDeviceHandlesToInstance(pvcr->htaskCommNotifyHandler, iPort, iDev, iInst);

    // We have the green light to begin sending commands.

    pvcr->Port[iPort].Dev[iDev].fDeviceOk = TRUE;

    dwErr = viscaDoImmediateCommand(iInst, BROADCASTADDRESS,
                    achPacket,
                    viscaMessageIF_Clear(achPacket + 1));

    // Find number of devices on comm port.
    pvcr->Port[iPort].Dev[iDev].fDeviceOk = TRUE;

    dwErr = viscaDoImmediateCommand(iInst, BROADCASTADDRESS,
                    achPacket,
                    viscaMessageIF_Address(achPacket + 1));
    if (dwErr)
    {
        DPF(DBG_ERROR, "Could not assign addresses.\n");
        //
        // We cannot return dwErr, because if this is the last instance
        // of the driver, we will be unloaded before it can look up
        // the error string. So, we must return a generic error from mmsystem.
        //
        if (dwErr >= MCIERR_CUSTOM_DRIVER_BASE)
            dwErr = MCIERR_DEVICE_NOT_READY;

        viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr);
        viscaTaskDo(iInst, TASKCLOSECOMM, iPort + 1, 0); //Porthandles destroyed.
        viscaTaskDo(iInst, TASKCLOSEDEVICE, iPort, iDev); //Devicehandles destroyed.
        return dwErr;
    }

    // Okay, assign the addresses.

    pvcr->Port[iPort].nDevices = achPacket[2];  //!! From the address packet.
    if (pvcr->Port[iPort].nDevices > 0)
        pvcr->Port[iPort].nDevices--;           // Don't count the computer

    return MCIERR_NO_ERROR;
}

/****************************************************************************
 * Function: DWORD viscaRetryOpenDevice - Retries to open a device
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_OPEN_PARMS lpOpen - Pointer to MCI parameter block.
 *
 * Returns: 0L
 *
 ***************************************************************************/
DWORD NEAR PASCAL viscaRetryOpenDevice(int iInst, DWORD dwFlags, LPMCI_OPEN_PARMS lpOpen)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;
    DWORD   dwErr;
    //
    // Try for a "hot-docking".  But this may really mess things up! but try anyway.
    //
    pvcr->Port[iPort].Dev[iDev].fDeviceOk = TRUE;
    dwErr = viscaDoImmediateCommand(iInst, BROADCASTADDRESS,
                achPacket,
                viscaMessageIF_Address(achPacket + 1));

    pvcr->Port[iPort].nDevices = achPacket[2];//!! From the address packet.
    if (pvcr->Port[iPort].nDevices > 0)
        pvcr->Port[iPort].nDevices--;       // Don't count the computer

    if(dwErr || (iDev >= pvcr->Port[iPort].nDevices))
    {
        dwErr = MCIERR_HARDWARE;

        viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr);
        CloseDeviceHandles(pvcr->htaskCommNotifyHandler, iPort, iDev);
        return dwErr;
    }

    return MCIERR_NO_ERROR;
}


/****************************************************************************
 * Function: DWORD viscaMciOpenDriver - Edit instance-specific initialization.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_OPEN_PARMS lpOpen - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_OPEN_DRIVER
 *
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciOpenDriver(int iInst, DWORD dwFlags, LPMCI_OPEN_PARMS lpOpen)
{
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;
    DWORD   dwErr;

    if (dwFlags & MCI_OPEN_ELEMENT)
    {
        dwErr = viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_NO_ELEMENT_ALLOWED);

        return dwErr;
    }

    DuplicateGlobalHandlesToInstance(pvcr->htaskCommNotifyHandler, iInst);  // Always do this immediately.

    // Handle case in which device is already open.

    if (pvcr->Port[iPort].Dev[iDev].nUsage > 0)
        return(viscaDeviceAlreadyOpen(iInst, dwFlags, lpOpen));

    // Set the device status to ok here. We must be able to try.

    pvcr->Port[iPort].Dev[iDev].fDeviceOk = TRUE;

    // If we come here: The device is not open yet. Check if the port is not yet open.

    if (pvcr->Port[iPort].nUsage == 0)
    {
        // Okay, open the port.  

        dwErr = viscaOpenCommPortAndDevice(iInst, dwFlags, lpOpen);
        if(dwErr)
        {
            return dwErr;
        }
        // Continue if the port opens okay!
    }
    else
    {
        // Port is already open, but not this device.

        DuplicatePortHandlesToInstance(pvcr->htaskCommNotifyHandler, iPort, iInst);
        viscaTaskDo(iInst, TASKOPENDEVICE, iPort, iDev);
        DuplicateDeviceHandlesToInstance(pvcr->htaskCommNotifyHandler, iPort, iDev, iInst);
    }

    // *** From this point on we are guarnteed of having valid device handles!

    if (iDev >= pvcr->Port[iPort].nDevices)
    {
        DPF(DBG_COMM, "Device # not on line\n");

        // If the port was just opened(and address broadcast), then close it

        if (pvcr->Port[iPort].nUsage == 0)
        {
            dwErr = MCIERR_HARDWARE;

            dwErr = viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr);
            viscaTaskDo(iInst, TASKCLOSECOMM, iPort + 1, 0); //Porthandles destroyed.
            viscaTaskDo(iInst, TASKCLOSEDEVICE, iPort, iDev); //Porthandles destroyed.
            return dwErr;
        }
        else
        {
            // Port was opened earlier, maybe some plugged in a second since then.

            dwErr = viscaRetryOpenDevice(iInst, dwFlags, lpOpen);
            if(dwErr)
                return dwErr;
        }
    }

    // Successful opening Store # of devices on port

    DPF(DBG_MCI, "# devs = %u\n", pvcr->Port[iPort].nDevices);
    DPF(DBG_MCI, "dev  # = %u\n", iDev);

    // All is well, the device is being opened for the first time.

    pvcr->Port[iPort].nUsage++;
    
    // Device specific information must now be gotten/filled in.

    viscaDeviceConfig(iInst, dwFlags);
    return (viscaNotifyReturn(iInst, (HWND) lpOpen->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
}

/****************************************************************************
 * Function: DWORD viscaMciGetDevCaps - Get device capabilities.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_GETDEVCAPS_PARMS lpCaps - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_GETDEVCAPS
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciGetDevCaps(int iInst, DWORD dwFlags, LPMCI_GETDEVCAPS_PARMS lpCaps)
{
    UINT    iDev  = pinst[iInst].iDev;
    UINT    iPort = pinst[iInst].iPort;

    if (!(dwFlags & MCI_GETDEVCAPS_ITEM))
        return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));

    switch (lpCaps->dwItem)
    {
        case MCI_GETDEVCAPS_CAN_SAVE:
        case MCI_GETDEVCAPS_USES_FILES:
        case MCI_GETDEVCAPS_COMPOUND_DEVICE:
        case MCI_VCR_GETDEVCAPS_CAN_DETECT_LENGTH:
        case MCI_VCR_GETDEVCAPS_CAN_MONITOR_SOURCES:
        case MCI_VCR_GETDEVCAPS_CAN_PREVIEW:
            lpCaps->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));

        case MCI_VCR_GETDEVCAPS_CLOCK_INCREMENT_RATE:
            // The ticks should have been read on device startup. 
            lpCaps->dwReturn =    pvcr->Port[iPort].Dev[iDev].uTicksPerSecond;
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));


        case MCI_VCR_GETDEVCAPS_CAN_FREEZE:
        if((pvcr->Port[iPort].Dev[iDev].uModelID == VISCADEVICEVENDORSONY) &&
           (pvcr->Port[iPort].Dev[iDev].uVendorID == VISCADEVICEMODELEVO9650))
        {
            lpCaps->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
        }
        else
        {
            lpCaps->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
        }
        break;


        case MCI_VCR_GETDEVCAPS_HAS_TIMECODE: 
        {
            //
            // This is the VCR capability NOT the current tape! And returns true if unknown.
            //
            lpCaps->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
        }

        case MCI_GETDEVCAPS_CAN_PLAY:
        case MCI_GETDEVCAPS_CAN_RECORD:
        case MCI_GETDEVCAPS_HAS_AUDIO:
        case MCI_GETDEVCAPS_HAS_VIDEO:
        case MCI_GETDEVCAPS_CAN_EJECT:
        case MCI_VCR_GETDEVCAPS_CAN_REVERSE:
        case MCI_VCR_GETDEVCAPS_CAN_PREROLL:
        case MCI_VCR_GETDEVCAPS_CAN_TEST:
        case MCI_VCR_GETDEVCAPS_HAS_CLOCK:
            lpCaps->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));

        case MCI_GETDEVCAPS_DEVICE_TYPE:
            lpCaps->dwReturn = MAKEMCIRESOURCE(MCI_DEVTYPE_VCR,
                                               MCI_DEVTYPE_VCR);
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));

        case MCI_VCR_GETDEVCAPS_NUMBER_OF_MARKS:
            lpCaps->dwReturn = 99L;
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

       
        case MCI_VCR_GETDEVCAPS_SEEK_ACCURACY:
            lpCaps->dwReturn = 0L;
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        default:
            return (viscaNotifyReturn(iInst, (HWND) lpCaps->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_BAD_CONSTANT));
    }
}


/****************************************************************************
 * Function: DWORD viscaMciInfo - Get device information.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_INFO_PARMS lpInfo - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_INFO
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciInfo(int iInst, DWORD dwFlags, LPMCI_INFO_PARMS lpInfo)
{
    if ((dwFlags & MCI_INFO_PRODUCT) && (lpInfo->lpstrReturn != NULL))
    {
        BYTE    achPacket[MAXPACKETLENGTH];
        UINT    iDev    = pinst[iInst].iDev;
        UINT    cb      = 0;

        if (lpInfo->dwRetSize == 0L)
            return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_PARAM_OVERFLOW));

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        lpInfo->lpstrReturn[lpInfo->dwRetSize - 1] = '\0';

        if (!viscaDoImmediateCommand(iInst, (BYTE) (iDev + 1),
                    achPacket,
                    viscaMessageIF_DeviceTypeInq(achPacket + 1)))
        {
            cb += LoadString(hModuleInstance,IDS_VENDORID1_BASE + achPacket[3],
                             lpInfo->lpstrReturn, (int)lpInfo->dwRetSize);

            if ((cb > 0) && (cb < lpInfo->dwRetSize))
                lpInfo->lpstrReturn[cb++] = ' ';

            if (cb < lpInfo->dwRetSize)
                cb += LoadString(hModuleInstance,IDS_MODELID2_BASE + achPacket[5],
                                 lpInfo->lpstrReturn + cb, (int)lpInfo->dwRetSize - cb);

            if (cb > 0)
            {
                if (lpInfo->lpstrReturn[lpInfo->dwRetSize - 1] == '\0')
                    return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
                else
                    return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_PARAM_OVERFLOW));
            }
        }
        //
        // Couldn't successfully get vendor and model information
        // from device.  So return a default string.
        //
        LoadString(hModuleInstance, IDS_DEFAULT_INFO_PRODUCT,
                   lpInfo->lpstrReturn, (int)lpInfo->dwRetSize);

        if (lpInfo->lpstrReturn[lpInfo->dwRetSize - 1] == '\0')
            return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        else
            return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_PARAM_OVERFLOW));

    }
    else if ((dwFlags & MCI_VCR_INFO_VERSION) && (lpInfo->lpstrReturn != NULL))
    {
        if (lpInfo->dwRetSize == 0L)
            return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_PARAM_OVERFLOW));

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        lpInfo->lpstrReturn[lpInfo->dwRetSize - 1] = '\0';
        LoadString(hModuleInstance, IDS_VERSION,lpInfo->lpstrReturn, (int)lpInfo->dwRetSize);

        if (lpInfo->lpstrReturn[lpInfo->dwRetSize - 1] == '\0')
            return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        else
            return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_PARAM_OVERFLOW));
    }
    else
    {
        return (viscaNotifyReturn(iInst, (HWND) lpInfo->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));
    }
}

/****************************************************************************
 * Function: DWORD viscaNotifyReturn - Notifies an instance (decides if).
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      HWND  hWndNotify  - Window to send notify to.
 *
 *      DWORD dwFlags     - Did the instance actually request notification.
 *
 *      DWORD dwNotifyMsg - Which notification message to send.
 *
 *      DWORD dwReturnMsg - What return value to return.
 *
 * Returns: dwReturnMsg, so you can just return this function.
 *
 *       This function, in a sense, synchronizes the sending of notifies
 *   on a per-instance basis.  I.e. If there is a notify already existing
 *   then it must be superseded because this is a second one. This can
 *   happen because the same or different instance has started a delayed
 *   command and set the notify hwnd when it was started.
 *
 ***************************************************************************/
DWORD FAR PASCAL
viscaNotifyReturn(int iInst, HWND hwndNotify, DWORD dwFlags, UINT uNotifyMsg, DWORD dwReturnMsg)
{
    if(dwFlags & MCI_NOTIFY)
    {
        //
        // If return is failure then do not notify at all!
        //
        if(uNotifyMsg == MCI_NOTIFY_FAILURE)
            return dwReturnMsg;
        //
        // If this inst has a transport running, then we must supersede the noitfication.
        //
        if(pinst[iInst].hwndNotify != (HWND)NULL)
        {
            mciDriverNotify(pinst[iInst].hwndNotify, pinst[iInst].uDeviceID, MCI_NOTIFY_SUPERSEDED);
            pinst[iInst].hwndNotify = (HWND)NULL;
        }

        //
        // If success, or abort, then we must notify now.
        //
        mciDriverNotify(hwndNotify, pinst[iInst].uDeviceID, uNotifyMsg);
    }
    return dwReturnMsg;
}


/****************************************************************************
 * Function: DWORD viscaStartTimecodeCheck - start the timecode check timer.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      BOOL fPause - Do we send a pause command.
 *
 * Returns: TRUE.
 *
 *       Some devices must be paused before timecode can be checked.
 *      
 ***************************************************************************/
static BOOL NEAR PASCAL
viscaStartTimecodeCheck(int iInst, BOOL fPause)
{
    DWORD   dwErr;
    BYTE    achPacket[MAXPACKETLENGTH];
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;

    if(fPause)
    {
        dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL));
    }
    //
    // First, check if the counter is now available 
    //
    if(pvcr->Port[iPort].Dev[iDev].fCounterChecked == FALSE)
    {
        if(!viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                                            achPacket, 
                                            viscaMessageMD_PositionInq(achPacket + 1, VISCADATARELATIVE)))
        {
            // the upper 4 bits indicates default counter in use 
            if(achPacket[1] == VISCADATAHMSF)
                pvcr->Port[iPort].Dev[iDev].bRelativeType = VISCADATAHMSF;
            else
                pvcr->Port[iPort].Dev[iDev].bRelativeType = VISCADATAHMS;

        }
        else
        {
            // For the new decks that can fail counter! (like cvd-500)
            pvcr->Port[iPort].Dev[iDev].bRelativeType = 0;
        }
        pvcr->Port[iPort].Dev[iDev].fCounterChecked = TRUE;
    }


    DPF(DBG_MCI, "Starting time code check timer\n");

    pvcr->Port[iPort].Dev[iDev].dwStartTime     = GetTickCount();    
    pvcr->Port[iPort].Dev[iDev].fTimecodeChecked   = TC_WAITING;

    return TRUE;
}

/****************************************************************************
 * Function: BOOL viscaTimecodeCheckAndSet - If there is timecode -> set the state.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 * Returns: TRUE.
 *
 *       Sony bug#2: does not know about timecode yet:
 *      1) door open
 *      2) play causes queue reset.
 *      3) pause (with a wait)
 *      4) media check, still doesn't know. (must wait some random time)
 *       
 ***************************************************************************/
BOOL FAR PASCAL
viscaTimecodeCheckAndSet(int iInst)
{
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    BYTE    achPacket[MAXPACKETLENGTH];

    //
    // First, check if the counter is now available 
    //
    if(pvcr->Port[iPort].Dev[iDev].fCounterChecked == FALSE)
    {
        if(!viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                                            achPacket, 
                                            viscaMessageMD_PositionInq(achPacket + 1, VISCADATARELATIVE)))
        {
            // the upper 4 bits indicates default counter in use 
            if(achPacket[1] == VISCADATAHMSF)
                pvcr->Port[iPort].Dev[iDev].bRelativeType = VISCADATAHMSF;
            else
                pvcr->Port[iPort].Dev[iDev].bRelativeType = VISCADATAHMS;
        }
        else
        {
            pvcr->Port[iPort].Dev[iDev].bRelativeType = 0;
        }
        pvcr->Port[iPort].Dev[iDev].fCounterChecked = TRUE;
    }
 
    if( (pvcr->Port[iPort].Dev[iDev].fTimecodeChecked==TC_DONE) ||
        (pvcr->Port[iPort].Dev[iDev].uTimeMode != MCI_VCR_TIME_DETECT))
        return FALSE;

    if(viscaTimecodeCheck(iInst))
        viscaSetTimeType(iInst, VISCAABSOLUTECOUNTER);
    else
        viscaSetTimeType(iInst, VISCARELATIVECOUNTER);
    //
    // This means it has been set 
    //
    pvcr->Port[iPort].Dev[iDev].fTimecodeChecked = TC_DONE;

    return TRUE;
}


/****************************************************************************
 * Function: BOOL viscaTimecodeCheck - Is there timecode available?
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 * Returns: TRUE if there is, FALSE otherwise.
 *
 *       Some devices are a bit difficult to determine if there is timecode.
 *      
 ***************************************************************************/
static BOOL NEAR PASCAL
viscaTimecodeCheck(int iInst)
{
    DWORD   dwErr;
    BYTE    achPacket[MAXPACKETLENGTH];
    MCI_VCR_STATUS_PARMS mciStatus;
    DWORD   dwWaitTime  = 3000L;
    UINT    iDev        = pinst[iInst].iDev;
    UINT    iPort       = pinst[iInst].iPort;
    DWORD   dwStart, dwTime;


    if(pvcr->Port[iPort].Dev[iDev].fTimecodeChecked != TC_WAITING)
    {
        mciStatus.dwItem = MCI_STATUS_MODE;
        dwErr = viscaMciStatus(iInst, MCI_STATUS_ITEM, &mciStatus);

        switch(HIWORD(mciStatus.dwReturn))
        {
            case MCI_MODE_STOP:
                viscaStartTimecodeCheck(iInst, TRUE);
                break;

            case MCI_MODE_PLAY:
            case MCI_MODE_RECORD:
            case MCI_MODE_SEEK:
            case MCI_MODE_PAUSE:
                // do we need to wait one these no 
                viscaStartTimecodeCheck(iInst, FALSE);
                dwWaitTime = 200;
                break;

            case MCI_MODE_NOT_READY:
            case MCI_MODE_OPEN:
                return FALSE;
            default:
                // nothing we can do 
                break;
        }
    }
    //
    // Wait for the current one or the one just started to finnish 
    //
    dwStart = pvcr->Port[iPort].Dev[iDev].dwStartTime;
    while(1)
    {
        // This is a very bad loop.
        dwTime = GetTickCount();
        if(MShortWait(dwStart, dwTime, dwWaitTime))
            break;
        Yield();
    }
    pvcr->Port[iPort].Dev[iDev].fTimecodeChecked == TC_DONE;
    DPF(DBG_MCI, "Done time code check timer!\n");

    dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                achPacket,
                viscaMessageMD_MediaTrackInq(achPacket + 1));
    //
    // CI-1000 (CVD-801) supports timecode but not this command == ignore any errors 
    //
    if(!dwErr)
    {
        /* If we do support this command we know! for sure we support or not */
        if(achPacket[3] & VISCATRACKTIMECODE)
            return TRUE;
        else
           return FALSE;
    }
    //
    // Ok, we support timecode, now ask for position in time-code. 
    //
    dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                achPacket,
                viscaMessageMD_PositionInq(achPacket + 1,VISCADATAABSOLUTE));
    //
    // On CI-1000 we cannot determine! It will just return 0 always! 
    //
    if(dwErr || (!VISCAHOURS(achPacket+2) && !VISCAMINUTES(achPacket+2)
            && !VISCAMINUTES(achPacket+2) && !VISCAFRAMES(achPacket+2)))
        return FALSE;

    return TRUE;
}

/****************************************************************************
 * Function: DWORD viscaMciStatus - Get device status.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_STATUS_PARMS lpStatus - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_STATUS
 *       command.
 ***************************************************************************/
DWORD FAR PASCAL
viscaMciStatus(int iInst, DWORD dwFlags, LPMCI_VCR_STATUS_PARMS lpStatus)
{
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;

    BYTE    achPacket[MAXPACKETLENGTH];
    DWORD   dwErr;

    DPF(DBG_MCI, "Status Flags=%lx ", dwFlags);
 
    if (dwFlags & MCI_STATUS_ITEM)
    {
        switch (lpStatus->dwItem)
        {
            case MCI_STATUS_POSITION:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                viscaTimecodeCheckAndSet(iInst);

                if (dwFlags & MCI_TRACK)
                {
                    if (lpStatus->dwTrack == 1)
                    {
                        lpStatus->dwReturn = 0;
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
                    }
                    else
                    {
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));
                    }
                }
                else if (dwFlags & MCI_STATUS_START)
                {
                    lpStatus->dwReturn = 0;
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
                }
                else
                {
                    UINT    fTimeCode = TRUE;

                    if(pvcr->Port[iPort].Dev[iDev].bTimeType == VISCAABSOLUTECOUNTER)
                    {
                        //
                        // This device supports timecode, so this should never return an error,
                        // only sometimes return 0.  But we do not change it here.
                        //
                        dwErr = viscaDoImmediateCommand(iInst, (BYTE) (iDev + 1),
                                    achPacket,
                                    viscaMessageMD_PositionInq(achPacket + 1, VISCADATAABSOLUTE));
                    }
                    else
                    {
                        fTimeCode = FALSE;
                        dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                                        achPacket, 
                                        viscaMessageMD_PositionInq(achPacket + 1, VISCADATARELATIVE));
                    }

                    if (dwErr)
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
                    //
                    // Always use the time format 
                    //
                    dwErr = viscaDataToMciTimeFormat(iInst, TRUE, achPacket + 2,
                                                     &(lpStatus->dwReturn));

                    if (dwErr == MCIERR_DRIVER_INTERNAL)
                    {
#ifdef DEBUG
                        UINT i;
                        DPF(DBG_ERROR, "Bad positon! Internal error.\n");
                        for (i=0; i<MAXPACKETLENGTH; i++) 
                            DPF(DBG_ERROR, "%#02x ", (UINT)(BYTE)achPacket[i]);
                        DPF(DBG_ERROR, "\n");
#endif
                    }

                    if(!dwErr || (dwErr == MCI_COLONIZED3_RETURN) || (dwErr == MCI_COLONIZED4_RETURN))
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, dwErr));
                    else
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
                }

            case MCI_STATUS_LENGTH:
                if ((dwFlags & MCI_TRACK) && (lpStatus->dwTrack != 1))
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));

                if (pvcr->Port[iPort].Dev[iDev].dwTapeLength != NO_LENGTH)
                {
                    if(dwFlags & MCI_TEST)
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
                    //
                    // The user has explicitly set the length of the tape.
                    //
                    lpStatus->dwReturn = pvcr->Port[iPort].Dev[iDev].dwTapeLength;
                    switch (pinst[iInst].dwTimeFormat)
                    {
                        case MCI_FORMAT_HMS:
                        case MCI_FORMAT_MSF:
                            return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_COLONIZED3_RETURN));
                        case MCI_FORMAT_TMSF:
                        case MCI_FORMAT_SMPTE_24:
                        case MCI_FORMAT_SMPTE_25:
                        case MCI_FORMAT_SMPTE_30:
                        case MCI_FORMAT_SMPTE_30DROP:
                            return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback,
                                dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_COLONIZED4_RETURN));

                        default:
                            return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
                    }
                }
                else
                {
                    BYTE    bHours   = 0;
                    BYTE    bMinutes = 0;

                    if(dwFlags & MCI_TEST)
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
                    //
                    // Find out what type of tape is in the VCR
                    //
                    dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                                achPacket,
                                viscaMessageMD_MediaInq(achPacket + 1));
                    if (dwErr)
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwFlags));

                    switch ((BYTE)achPacket[2])
                    {
                        case VISCAFORMAT8MM:
                        case VISCAFORMATHI8:
                        case VISCAFORMATVHS:
                        case VISCAFORMATSVHS:
                            switch ((BYTE)achPacket[3])
                            {
                                case VISCASPEEDSP:
                                    bHours = 2;
                                    break;
                                case VISCASPEEDLP:
                                    bHours = 4;
                                    break;
                                case VISCASPEEDEP:
                                    bHours = 6;
                                    break;
                            }
                            break;
                        case VISCAFORMATBETA:
                        case VISCAFORMATEDBETA:
                            switch ((BYTE)achPacket[3])
                            {
                                case VISCASPEEDSP:
                                    bHours = 1;
                                    bMinutes = 30;
                                    break;
                                case VISCASPEEDLP:
                                    bHours = 3;
                                    break;
                                case VISCASPEEDEP:
                                    bHours = 4;
                                    bMinutes = 30;
                                    break;
                            }
                            break;
                    }
                    //
                    // Construct dummy ViSCA data structure, so that
                    // we can then easily convert the time to the
                    // appropriate MCI time format
                    //
                    viscaDataPosition(achPacket, VISCADATAHMS, bHours, bMinutes, (BYTE)0, (BYTE)0);
                    //
                    // Convert to MCI time format
                    //
                    dwErr = viscaDataToMciTimeFormat(iInst, TRUE, achPacket,&(lpStatus->dwReturn));

                    if(!dwErr || (dwErr == MCI_COLONIZED3_RETURN) || (dwErr == MCI_COLONIZED4_RETURN))
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, dwErr));
                    else
                         return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
                }

            case MCI_STATUS_CURRENT_TRACK:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = 1;
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            case MCI_STATUS_NUMBER_OF_TRACKS:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = 1;
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));


            case MCI_VCR_STATUS_NUMBER_OF_VIDEO_TRACKS:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = 1;
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            case MCI_VCR_STATUS_NUMBER_OF_AUDIO_TRACKS:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = 2;
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            case MCI_STATUS_MODE:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                            achPacket,
                            viscaMessageMD_Mode1Inq(achPacket + 1));
                if (dwErr)
                {
                    if (dwErr == MCIERR_VCR_POWER_OFF)
                    {
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_NOT_READY, MCI_MODE_NOT_READY);
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags,
                                    MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
                    }
                    else
                    {
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
                    }
                }
                switch (achPacket[2])
                {
                    case VISCAMODE1STOP:
                    case VISCAMODE1STOPTOP:
                    case VISCAMODE1STOPEND:
                    case VISCAMODE1STOPEMERGENCY:
                        if(pvcr->Port[iPort].Dev[iDev].fTimecodeChecked == TC_UNKNOWN)
                            viscaStartTimecodeCheck(iInst, TRUE);
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_STOP,
                                                             MCI_MODE_STOP);
                        break;
                    case VISCAMODE1SLOW2:
                    case VISCAMODE1SLOW1:
                    case VISCAMODE1PLAY:
                    case VISCAMODE1FAST1:
                    case VISCAMODE1FAST2:
                    case VISCAMODE1REVERSESLOW2:
                    case VISCAMODE1REVERSESLOW1:
                    case VISCAMODE1REVERSEPLAY:
                    case VISCAMODE1REVERSEFAST1:
                    case VISCAMODE1REVERSEFAST2:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_PLAY,
                                                             MCI_MODE_PLAY);
                        break;
                    case VISCAMODE1RECORD:
                    case VISCAMODE1CAMERAREC:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_RECORD,
                                                             MCI_MODE_RECORD);
                        break;
                    case VISCAMODE1FASTFORWARD:
                    case VISCAMODE1REWIND:
                    case VISCAMODE1SCAN:
                    case VISCAMODE1REVERSESCAN:
                    case VISCAMODE1EDITSEARCHFORWARD:
                    case VISCAMODE1EDITSEARCHREVERSE:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_SEEK,
                                                             MCI_MODE_SEEK);
                        break;
                    case VISCAMODE1STILL:
                    case VISCAMODE1RECPAUSE:
                    case VISCAMODE1CAMERARECPAUSE:
                        // Kludge to make stepping return seeking.
                        if(pvcr->Port[iPort].Dev[iDev].iInstTransport != -1)
                            lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_SEEK,
                                                                 MCI_MODE_SEEK);
                        else
                            lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_PAUSE,
                                                                 MCI_MODE_PAUSE);
                        break;
                    case VISCAMODE1EJECT:
                        pvcr->Port[iPort].Dev[iDev].fTimecodeChecked = FALSE;
                        pvcr->Port[iPort].Dev[iDev].fCounterChecked  = FALSE;
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_MODE_OPEN,
                                                             MCI_MODE_OPEN);
                        break;
                    default:
                        pvcr->Port[iPort].Dev[iDev].fTimecodeChecked = FALSE;
                        pvcr->Port[iPort].Dev[iDev].fCounterChecked  = FALSE;
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                                    MCI_MODE_NOT_READY, MCI_MODE_NOT_READY);
                    break;
                }
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }

            case MCI_VCR_STATUS_TIMECODE_PRESENT:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                if(viscaTimecodeCheck(iInst))
                {
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
                }
                else
                {
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
                }
            }
           
            case MCI_STATUS_MEDIA_PRESENT:
            {
                //
                // Determine whether a tape is present by determining the current mode.
                //
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                            achPacket,                        
                            viscaMessageMD_Mode1Inq(achPacket + 1));

                if (dwErr)
                       return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                if (achPacket[2] == VISCAMODE1EJECT)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                else
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }
            
            case MCI_STATUS_TIME_FORMAT:

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = MAKEMCIRESOURCE(pinst[iInst].dwTimeFormat + MCI_FORMAT_MILLISECONDS,
                                            pinst[iInst].dwTimeFormat + MCI_FORMAT_MILLISECONDS_S);
 
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            
            case MCI_STATUS_READY:
            {

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));


                // Check if we are ready by determining VCR mode
                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_Mode1Inq(achPacket + 1));
                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                // Only if there is no tape then we aren't ready; otherwise we are ready.
                if (achPacket[2] == VISCAMODE1EJECT)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                else
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }

            case MCI_VCR_STATUS_FRAME_RATE: 
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                                achPacket,
                                viscaMessageMD_ConfigureIFInq(achPacket + 1));
                
                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
                //
                // Store result in lpStatus->dwReturn,
                // as well as in the device's frames-per-second entry,
                // so that we store the most recent value.
                //
                pvcr->Port[iPort].Dev[iDev].uFramesPerSecond = FROMBCD(achPacket[2]);

                lpStatus->dwReturn = pvcr->Port[iPort].Dev[iDev].uFramesPerSecond;

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
            }

            case MCI_VCR_STATUS_SPEED:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = pvcr->Port[iPort].Dev[iDev].dwPlaySpeed;

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
            }

            case MCI_VCR_STATUS_CLOCK:
            {
                UINT    uHours, uMinutes, uSeconds;
                UINT    uTicks, uTicksL,  uTicksH;
                UINT    uTicksPerSecondL;
                UINT    uTicksPerSecondH;
                UINT    uTicksPerSecond;

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
                //
                // Try to read time
                //
                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                                achPacket,
                                viscaMessageIF_ClockInq(achPacket + 1));

                uHours    = FROMBCD(achPacket[2]);
                uMinutes  = FROMBCD(achPacket[3]);
                uSeconds  = FROMBCD(achPacket[4]);                               
                uTicksH   = FROMBCD(achPacket[5]);
                uTicksL   = FROMBCD(achPacket[6]);
                uTicksPerSecondH = FROMBCD(achPacket[7]);
                uTicksPerSecondL = FROMBCD(achPacket[8]);
         
                uTicks = uTicksH * 10 + uTicksL;
                uTicksPerSecond = pvcr->Port[iPort].Dev[iDev].uTicksPerSecond;
                

                lpStatus->dwReturn = (DWORD)
                    ((DWORD)uHours * 3600L * (DWORD)uTicksPerSecond) +
                    ((DWORD)uMinutes * 60L * (DWORD)uTicksPerSecond) +
                    ((DWORD)uSeconds * (DWORD)uTicksPerSecond) +
                    ((DWORD)uTicks);
                //
                // might be possible to use colonized 3 
                //
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
            }
            break;

            case MCI_VCR_STATUS_CLOCK_ID:
                lpStatus->dwReturn = iPort; // 0 relative? so should we add one 
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            case MCI_VCR_STATUS_MEDIA_TYPE:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                viscaTimecodeCheckAndSet(iInst);

                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                                achPacket,
                                viscaMessageMD_MediaInq(achPacket + 1));
                if (dwErr) 
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                switch ((BYTE)achPacket[2]){
                    case VISCAFORMAT8MM:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_MEDIA_8MM, MCI_VCR_MEDIA_8MM);
                        break;
                    case VISCAFORMATHI8:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_MEDIA_HI8, MCI_VCR_MEDIA_HI8);
                        break;
                    case VISCAFORMATVHS:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_MEDIA_VHS, MCI_VCR_MEDIA_VHS);
                        break;
                    case VISCAFORMATSVHS:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_MEDIA_SVHS, MCI_VCR_MEDIA_SVHS);
                        break;
                    case VISCAFORMATBETA:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_MEDIA_BETA, MCI_VCR_MEDIA_BETA);
                        break;
                    case VISCAFORMATEDBETA:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_MEDIA_EDBETA, MCI_VCR_MEDIA_EDBETA);
                        break;
                    default:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_MEDIA_OTHER, MCI_VCR_MEDIA_OTHER);
                            break;
                }
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
            }

            case MCI_VCR_STATUS_RECORD_FORMAT:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                viscaTimecodeCheckAndSet(iInst);

                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                                achPacket,
                                viscaMessageMD_RecSpeedInq(achPacket + 1));
                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                switch ((BYTE)achPacket[2])
                {
                    case VISCASPEEDSP:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_FORMAT_SP, MCI_VCR_FORMAT_SP);
                        break;
                    case VISCASPEEDLP:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_FORMAT_LP, MCI_VCR_FORMAT_LP);
                        break;
                    case VISCASPEEDEP:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_FORMAT_EP, MCI_VCR_FORMAT_EP);
                        break;
                    default:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_FORMAT_OTHER, MCI_VCR_FORMAT_OTHER);
                            break;
                }
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
            }

            case MCI_VCR_STATUS_PLAY_FORMAT:
            {
                //
                // Should perhaps use MD_MediaSpeedInq?
                // We use MD_MediaInq since both the Vbox CI-1000 and
                // the Vdeck CVD-1000 do not accept MD_MediaSpeedInq.
                //
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                viscaTimecodeCheckAndSet(iInst);
                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_MediaInq(achPacket + 1));
                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                switch ((BYTE)achPacket[3])
                {
                    case VISCASPEEDSP:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_FORMAT_SP, MCI_VCR_FORMAT_SP);
                        break;
                    case VISCASPEEDLP:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_FORMAT_LP, MCI_VCR_FORMAT_LP);
                        break;
                    case VISCASPEEDEP:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_FORMAT_EP, MCI_VCR_FORMAT_EP);
                        break;
                    default:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(
                            MCI_VCR_FORMAT_OTHER, MCI_VCR_FORMAT_OTHER);
                            break;
                }
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
            }


            case MCI_VCR_STATUS_AUDIO_SOURCE:
            {

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_InputSelectInq(achPacket + 1));

                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                if(((BYTE)achPacket[3] == (BYTE)VISCATUNER) || ((BYTE)achPacket[3] == (BYTE)VISCAOTHER))
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_TUNER, MCI_VCR_SRC_TYPE_TUNER);
                else if ((BYTE)achPacket[3] == (BYTE)VISCAOTHERLINE)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_LINE, MCI_VCR_SRC_TYPE_LINE);
                else if ((BYTE)achPacket[3] &  (BYTE)VISCALINE)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_LINE, MCI_VCR_SRC_TYPE_LINE);
                else if ((BYTE)achPacket[3] &  (BYTE)VISCASVIDEOLINE)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_SVIDEO, MCI_VCR_SRC_TYPE_SVIDEO);
                else if ((BYTE)achPacket[3] &  (BYTE)VISCAAUX)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_AUX, MCI_VCR_SRC_TYPE_AUX);
                else if ((BYTE)achPacket[3] ==  (BYTE)VISCAMUTE)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_MUTE, MCI_VCR_SRC_TYPE_MUTE);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
            }

            case MCI_VCR_STATUS_AUDIO_SOURCE_NUMBER:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_InputSelectInq(achPacket + 1));

                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                if(((BYTE)achPacket[3] == (BYTE)VISCATUNER) || ((BYTE)achPacket[3] == (BYTE)VISCAOTHER))
                    lpStatus->dwReturn = 1L;
                else if ((BYTE)achPacket[3] == (BYTE)VISCAOTHERLINE)
                    lpStatus->dwReturn = 1L;
                else if ((BYTE)achPacket[3] &  (BYTE)VISCALINE)
                    lpStatus->dwReturn = (DWORD)((BYTE)achPacket[3] - (BYTE)VISCALINE);
                else if (achPacket[3] &  VISCASVIDEOLINE)
                    lpStatus->dwReturn = (DWORD)((BYTE)achPacket[3] - (BYTE)VISCASVIDEOLINE);
                else if (achPacket[3] &  VISCAAUX)
                    lpStatus->dwReturn = (DWORD)((BYTE)achPacket[3] - (BYTE)VISCAAUX);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
            }
 
            case MCI_VCR_STATUS_VIDEO_SOURCE:
            {

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_InputSelectInq(achPacket + 1));

                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                if(((BYTE)achPacket[2] == (BYTE)VISCATUNER) || ((BYTE)achPacket[2] == (BYTE)VISCAOTHER))
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_TUNER, MCI_VCR_SRC_TYPE_TUNER);
                else if ((BYTE)achPacket[2] == (BYTE)VISCAOTHERLINE)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_LINE, MCI_VCR_SRC_TYPE_LINE);
                else if ((BYTE)(achPacket[2] & (BYTE)0xf0) ==  (BYTE)VISCALINE)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_LINE, MCI_VCR_SRC_TYPE_LINE);
                else if ((BYTE)(achPacket[2] & (BYTE)0xf0) == (BYTE)VISCASVIDEOLINE)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_SVIDEO, MCI_VCR_SRC_TYPE_SVIDEO);
                else if ((BYTE)(achPacket[2] & (BYTE)0xf0) == (BYTE)VISCAAUX)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_AUX, MCI_VCR_SRC_TYPE_AUX);
                else if ((BYTE)achPacket[2] ==  (BYTE)0x00)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_MUTE, MCI_VCR_SRC_TYPE_MUTE);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));

            }

            case MCI_VCR_STATUS_VIDEO_SOURCE_NUMBER:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_InputSelectInq(achPacket + 1));

                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                if(((BYTE)achPacket[2] == (BYTE)VISCATUNER) || ((BYTE)achPacket[2] == (BYTE)VISCAOTHER))
                    lpStatus->dwReturn = 1L;
                else if ((BYTE)achPacket[2] == (BYTE)VISCAOTHERLINE)
                    lpStatus->dwReturn = 1L;
                else if ((BYTE)(achPacket[2] & (BYTE)0xf0) == (BYTE)VISCALINE)
                    lpStatus->dwReturn = (DWORD)((BYTE)achPacket[2] - (BYTE)VISCALINE);
                else if ((BYTE)(achPacket[2] & (BYTE)0xf0) == (BYTE)VISCASVIDEOLINE)
                    lpStatus->dwReturn = (DWORD) ((BYTE)achPacket[2] - (BYTE)VISCASVIDEOLINE);
                else if ((BYTE)(achPacket[2] &  (BYTE)0xf0) == (BYTE)VISCAAUX)
                    lpStatus->dwReturn = (DWORD) ((BYTE)achPacket[2] - (BYTE)VISCAAUX);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
            }

            case MCI_VCR_STATUS_AUDIO_MONITOR_NUMBER:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = 1;
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            case MCI_VCR_STATUS_VIDEO_MONITOR_NUMBER:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = 1;
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));


            case MCI_VCR_STATUS_VIDEO_MONITOR:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_OUTPUT, MCI_VCR_SRC_TYPE_OUTPUT);
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
                break;

            case MCI_VCR_STATUS_AUDIO_MONITOR:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_SRC_TYPE_OUTPUT, MCI_VCR_SRC_TYPE_OUTPUT);
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
                break;


            case MCI_VCR_STATUS_INDEX_ON:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));


                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                            achPacket,
                            viscaMessageMD_OSDInq(achPacket + 1));

                if(achPacket[2] == VISCAOSDPAGEOFF)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                else
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }

            case MCI_VCR_STATUS_INDEX:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = MAKEMCIRESOURCE(pvcr->Port[iPort].Dev[iDev].uIndexFormat,pvcr->Port[iPort].Dev[iDev].uIndexFormat);
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
            }


            case MCI_VCR_STATUS_COUNTER_FORMAT:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = MAKEMCIRESOURCE(pinst[iInst].dwCounterFormat + MCI_FORMAT_MILLISECONDS,
                                            pinst[iInst].dwCounterFormat + MCI_FORMAT_MILLISECONDS_S);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }
            break;

            case MCI_VCR_STATUS_COUNTER_RESOLUTION:

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                if(pvcr->Port[iPort].Dev[iDev].bRelativeType == VISCADATAHMSF)
                    lpStatus->dwReturn =  MAKEMCIRESOURCE(MCI_VCR_COUNTER_RES_FRAMES,
                                                MCI_VCR_COUNTER_RES_FRAMES);
                else if(pvcr->Port[iPort].Dev[iDev].bRelativeType == VISCADATAHMS)
                    lpStatus->dwReturn =  MAKEMCIRESOURCE(MCI_VCR_COUNTER_RES_SECONDS,
                                                MCI_VCR_COUNTER_RES_SECONDS);
                else
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_HARDWARE));

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
                break;


            case MCI_VCR_STATUS_TIMECODE_TYPE:
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                viscaTimecodeCheckAndSet(iInst);
                //
                // May or may not set the i.e. if not on detect 
                //
                if(pvcr->Port[iPort].Dev[iDev].uTimeMode != MCI_VCR_TIME_DETECT)
                {
                    if(viscaTimecodeCheck(iInst))
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_TIMECODE_TYPE_SMPTE,
                                                             MCI_VCR_TIMECODE_TYPE_SMPTE);
                    else
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_TIMECODE_TYPE_NONE,
                                                             MCI_VCR_TIMECODE_TYPE_NONE);
                }
                else
                {
                    switch(pvcr->Port[iPort].Dev[iDev].bTimeType)
                    {
                        case VISCAABSOLUTECOUNTER:
                            lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_TIMECODE_TYPE_SMPTE,
                                                             MCI_VCR_TIMECODE_TYPE_SMPTE);
                             break;

                        case VISCARELATIVECOUNTER:
                            lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_TIMECODE_TYPE_NONE,
                                                             MCI_VCR_TIMECODE_TYPE_NONE);
                            break;
                    }

                }
               
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
                break;
    

            case MCI_VCR_STATUS_COUNTER_VALUE: // status index 
            {

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));


                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                            achPacket, 
                            viscaMessageMD_PositionInq(achPacket + 1,
                                            VISCADATARELATIVE));
                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                dwErr = viscaDataToMciTimeFormat(iInst, FALSE, achPacket + 2, &(lpStatus->dwReturn));

                if(!dwErr || (dwErr == MCI_COLONIZED3_RETURN) || (dwErr == MCI_COLONIZED4_RETURN))
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, dwErr));
                else
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

            }
 
            case MCI_VCR_STATUS_TUNER_CHANNEL:
            {
                UINT uNumber = 1; // 1 is the default tuner 

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                if(dwFlags & MCI_VCR_SETTUNER_NUMBER)
                    uNumber = (UINT) lpStatus->dwNumber;
                
                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_ChannelInq(achPacket + 1));

                if (dwErr) 
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                lpStatus->dwReturn = 100 * (achPacket[2] & 0x0F)+
                                      10 * (achPacket[3] & 0x0F)+
                                           (achPacket[4] & 0x0F);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
            }


            case MCI_VCR_STATUS_WRITE_PROTECTED:
            {
                //
                // We cannot tell.
                // So according to the alpha VCR command set spec.,
                // we should return false.
                //
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }

            case MCI_VCR_STATUS_TIMECODE_RECORD:
            case MCI_VCR_STATUS_VIDEO_RECORD:
            case MCI_VCR_STATUS_AUDIO_RECORD:
            case MCI_VCR_STATUS_ASSEMBLE_RECORD:
            {
                BOOL    fRecord;
                BYTE    bTrack = VISCATRACK1;

                // Audio has 2 tracks, video 1. This is a kludge!

                if(dwFlags & MCI_TRACK)
                {
                    if(lpStatus->dwTrack==0)
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));

                    if((lpStatus->dwItem == MCI_VCR_STATUS_AUDIO_RECORD) &&
                        ((UINT)lpStatus->dwTrack > 2))
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));

                    if((lpStatus->dwItem == MCI_VCR_STATUS_VIDEO_RECORD) &&
                        ((UINT)lpStatus->dwTrack > 1))
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));
                }

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                if(dwFlags & MCI_TRACK)
                {
                    if(lpStatus->dwTrack == 1)
                        bTrack = VISCATRACK1;
                    else if (lpStatus->dwTrack == 2)
                        bTrack = VISCATRACK2;
                }

                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_RecTrackInq(achPacket + 1));

                if (dwErr) 
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
                
                switch (lpStatus->dwItem)
                {
                    case MCI_VCR_STATUS_ASSEMBLE_RECORD:
                        fRecord = (achPacket[2] == 0) ? TRUE : FALSE;
                        break;

                    case MCI_VCR_STATUS_TIMECODE_RECORD:
                        fRecord = (achPacket[4] & VISCATRACKTIMECODE);
                        break;
                    case MCI_VCR_STATUS_VIDEO_RECORD:
                        fRecord = (achPacket[3] & bTrack);
                        break;
                    case MCI_VCR_STATUS_AUDIO_RECORD:
                        fRecord = (achPacket[5] & bTrack);
                        break;
 
                }

                if (fRecord)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
                else
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }

            case MCI_VCR_STATUS_VIDEO:
            case MCI_VCR_STATUS_AUDIO:
            {
                BOOL    fPlay;
                BYTE    bTrack = VISCATRACK1;

                // Audio has 2 tracks, video 1.

                if(dwFlags & MCI_TRACK)
                {
                    if(lpStatus->dwTrack==0)
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));

                    if((lpStatus->dwItem == MCI_VCR_STATUS_AUDIO) &&
                        ((UINT)lpStatus->dwTrack > 2))
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));

                    if((lpStatus->dwItem == MCI_VCR_STATUS_VIDEO) &&
                        ((UINT)lpStatus->dwTrack > 1))
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));
                }

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                if(dwFlags & MCI_TRACK)
                {
                    if(lpStatus->dwTrack == 1)
                        bTrack = VISCATRACK1;
                    else if (lpStatus->dwTrack == 2)
                        bTrack = VISCATRACK2;
                }

                dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_PBTrackInq(achPacket + 1));

                if (dwErr) 
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
                
                switch (lpStatus->dwItem)
                {
                    case MCI_VCR_STATUS_VIDEO:
                        fPlay = (achPacket[2] & bTrack);
                        break;
                    case MCI_VCR_STATUS_AUDIO:
                        fPlay = (achPacket[4] & bTrack);
                        break;
 
                }

                if (fPlay)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
                else
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }
            
            case MCI_VCR_STATUS_TIME_MODE:
            {
                WORD    wDeviceTimeMode = pvcr->Port[iPort].Dev[iDev].uTimeMode;

                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                viscaTimecodeCheckAndSet(iInst);

                switch(pvcr->Port[iPort].Dev[iDev].uTimeMode)
                {
                    case MCI_VCR_TIME_DETECT:
                    case MCI_VCR_TIME_TIMECODE:
                    case MCI_VCR_TIME_COUNTER:
                        lpStatus->dwReturn = MAKEMCIRESOURCE( wDeviceTimeMode, wDeviceTimeMode);
                        return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
                }
            }
            break;

            case MCI_VCR_STATUS_TIME_TYPE:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                viscaTimecodeCheckAndSet(iInst);

                switch(pvcr->Port[iPort].Dev[iDev].bTimeType)
                {
                    case VISCAABSOLUTECOUNTER:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_TIME_TIMECODE,
                                                        MCI_VCR_TIME_TIMECODE);
                        break;

                    case VISCARELATIVECOUNTER:
                        lpStatus->dwReturn = MAKEMCIRESOURCE(MCI_VCR_TIME_COUNTER,
                                                        MCI_VCR_TIME_COUNTER);
                        break;
                }
               
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
            }

            case MCI_VCR_STATUS_POWER_ON:
            {
                if(dwFlags & MCI_TEST)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

                dwErr = viscaDoImmediateCommand(iInst,    (BYTE)(iDev + 1),
                            achPacket,
                            viscaMessageMD_PowerInq(achPacket + 1));
                if (dwErr)
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));

                if (achPacket[2] == VISCAPOWERON)
                    lpStatus->dwReturn = MAKEMCIRESOURCE(TRUE, MCI_TRUE);
                else 
                    lpStatus->dwReturn = MAKEMCIRESOURCE(FALSE, MCI_FALSE);

                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED));
            }


            case MCI_VCR_STATUS_PREROLL_DURATION:
            {
                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                            achPacket,    
                            viscaMessageMD_SegPreRollDurationInq(achPacket + 1));

                // If error, make something up from the device info table 
                if (dwErr)
                {
                    UINT uFrames = pvcr->Port[iPort].Dev[iDev].uPrerollDuration;
                    UINT uDevFPS = pvcr->Port[iPort].Dev[iDev].uFramesPerSecond;

                    (BYTE)achPacket[3] = (BYTE) 0;   // hours expected at 2.
                    (BYTE)achPacket[4] = (BYTE) 0;
                    (BYTE)achPacket[5] = (BYTE) (uFrames / uDevFPS);
                    (BYTE)achPacket[6] = (BYTE) (uFrames % uDevFPS); 
                }
                dwErr = viscaDataToMciTimeFormat(iInst, TRUE, achPacket + 2, &(lpStatus->dwReturn));

                if(!dwErr || (dwErr == MCI_COLONIZED3_RETURN) || (dwErr == MCI_COLONIZED4_RETURN))
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, dwErr));
                else
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
            }

            case MCI_VCR_STATUS_POSTROLL_DURATION:
            {
                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                            achPacket,    
                            viscaMessageMD_SegPostRollDurationInq(achPacket + 1));

                // If error, make something up from the device info table 
                if (dwErr)
                {
                    UINT uFrames = pvcr->Port[iPort].Dev[iDev].uPrerollDuration;
                    UINT uDevFPS = pvcr->Port[iPort].Dev[iDev].uFramesPerSecond;

                    (BYTE)achPacket[3] = (BYTE) 0;   // hours expected at 2.
                    (BYTE)achPacket[4] = (BYTE) 0;
                    (BYTE)achPacket[5] = (BYTE) (uFrames / uDevFPS);
                    (BYTE)achPacket[6] = (BYTE) (uFrames % uDevFPS); 
                }
                dwErr = viscaDataToMciTimeFormat(iInst, TRUE, achPacket + 2, &(lpStatus->dwReturn));

                if(!dwErr || (dwErr == MCI_COLONIZED3_RETURN) || (dwErr == MCI_COLONIZED4_RETURN))
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, dwErr));
                else
                    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, dwErr));
            }

            case MCI_VCR_STATUS_PAUSE_TIMEOUT:
                return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_UNSUPPORTED_FUNCTION));

        }
    }

    return (viscaNotifyReturn(iInst, (HWND) lpStatus->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));
}

/****************************************************************************
 * Function: DWORD viscaMciSet - Set various settings.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_SET_PARMS lpSet - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_SET
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciSet(int iInst, DWORD dwFlags, LPMCI_VCR_SET_PARMS lpSet)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    DWORD   dwErr;

    if (dwFlags & MCI_SET_TIME_FORMAT)
    {
        if( (lpSet->dwTimeFormat >= MCI_FORMAT_MILLISECONDS) &&
            (lpSet->dwTimeFormat <= MCI_FORMAT_TMSF) &&
            (lpSet->dwTimeFormat != MCI_FORMAT_BYTES))
        {
            //
            // First convert DEVICETAPLELENGTH to new time format.
            // We do this by first converting DEVICETAPLENGTH from
            // the current MCI time format to a ViSCA HMSF structure,
            // and then converting back to the new MCI time format.
            //
            if(dwFlags & MCI_TEST)
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            if (pvcr->Port[iPort].Dev[iDev].dwTapeLength != NO_LENGTH)
            {
                BYTE    achData[5];

                viscaMciTimeFormatToViscaData(iInst, TRUE,
                    pvcr->Port[iPort].Dev[iDev].dwTapeLength,
                    achData, VISCADATAHMSF);

                pinst[iInst].dwTimeFormat = lpSet->dwTimeFormat;

                viscaDataToMciTimeFormat(iInst, TRUE, achData, 
                    &(pvcr->Port[iPort].Dev[iDev].dwTapeLength));
            }
            else
            {
                pinst[iInst].dwTimeFormat = lpSet->dwTimeFormat;
            }
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        }
        else
        {
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_BAD_TIME_FORMAT));
        }
        
    }

    if (dwFlags & MCI_SET_DOOR_OPEN)
    {
        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        dwErr = viscaDoImmediateCommand(iInst, (BYTE) (iDev + 1),
                    achPacket,
                    viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1EJECT));

        pvcr->Port[iPort].Dev[iDev].fTimecodeChecked = FALSE;
        
        
        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

    if (dwFlags & MCI_SET_DOOR_CLOSED)
        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_UNSUPPORTED_FUNCTION));

    if (dwFlags & MCI_SET_AUDIO)  // Why not vector this to setvideo? easy.
        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_UNSUPPORTED_FUNCTION));

    if (dwFlags & MCI_SET_VIDEO) 
        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_UNSUPPORTED_FUNCTION));

    if (dwFlags & MCI_VCR_SET_TRACKING)
        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_UNRECOGNIZED_KEYWORD));

    if(dwFlags & MCI_VCR_SET_COUNTER_FORMAT)
    {
        if( (lpSet->dwCounterFormat >= MCI_FORMAT_MILLISECONDS) &&
            (lpSet->dwCounterFormat <= MCI_FORMAT_TMSF) &&
            (lpSet->dwCounterFormat != MCI_FORMAT_BYTES))
            pinst[iInst].dwCounterFormat = lpSet->dwCounterFormat;
        else
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_BAD_TIME_FORMAT));

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
    }

    if (dwFlags & MCI_VCR_SET_TIME_MODE)
    {
        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        switch(lpSet->dwTimeMode)
        {
            case MCI_VCR_TIME_DETECT:
                pvcr->Port[iPort].Dev[iDev].uTimeMode = MCI_VCR_TIME_DETECT;
                pvcr->Port[iPort].Dev[iDev].fTimecodeChecked= TC_UNKNOWN;
                // This guy may be first, do not pause unless necessary 
                viscaTimecodeCheckAndSet(iInst);
                break;

            case MCI_VCR_TIME_TIMECODE:
                pvcr->Port[iPort].Dev[iDev].uTimeMode = MCI_VCR_TIME_TIMECODE;
                viscaSetTimeType(iInst, VISCAABSOLUTECOUNTER);
                break;

            case MCI_VCR_TIME_COUNTER:
                // No need to check this 
                pvcr->Port[iPort].Dev[iDev].uTimeMode = MCI_VCR_TIME_COUNTER;
                viscaSetTimeType(iInst, VISCARELATIVECOUNTER);
                break;
        }
        //
        // Return success 
        //
        pvcr->Port[iPort].Dev[iDev].fTimecodeChecked = FALSE;

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
    }

    if (dwFlags & MCI_VCR_SET_RECORD_FORMAT)
    {
        BYTE    bSpeed;

        switch (lpSet->dwRecordFormat)
        {
            case MCI_VCR_FORMAT_SP:
                bSpeed = VISCASPEEDSP;
                break;
            case MCI_VCR_FORMAT_LP:
                bSpeed = VISCASPEEDLP;
                break;
            case MCI_VCR_FORMAT_EP:
                bSpeed = VISCASPEEDEP;
                break;
            default:
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_BAD_CONSTANT));
        }

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                    achPacket,
                    viscaMessageMD_RecSpeed(achPacket + 1, bSpeed));

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
            (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));

    }

    if (dwFlags & MCI_VCR_SET_INDEX) 
    {
        //
        // Set page to the currently device selected index 
        //
        BYTE    bPageNo;
        BYTE    fResetQueue = FALSE;
        //
        // We can safely ignore this on CI-1000? or not? 
        //
        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        if( (lpSet->dwIndex >= MCI_VCR_INDEX_TIMECODE) &&
            (lpSet->dwIndex <= MCI_VCR_INDEX_TIME))
        {

            if(viscaDelayedCommand(iInst) == VISCA_SEEK)
            {
                viscaQueueReset(iInst, MCI_PAUSE, MCI_NOTIFY_ABORTED);
                fResetQueue = TRUE;

                // If mode is seeking, then pause the thing.
                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                            achPacket,
                            viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL));
            }

            // These must  be in order
            bPageNo = (BYTE) (lpSet->dwIndex - MCI_VCR_INDEX_TIMECODE + 1);

            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_OSD(achPacket + 1, bPageNo));

            if(fResetQueue)
                viscaReleaseAutoParms(iPort, iDev);

        }
        else
        {
            dwErr = MCIERR_UNRECOGNIZED_KEYWORD;
        }

        if(!dwErr)
            pvcr->Port[iPort].Dev[iDev].uIndexFormat = (UINT) lpSet->dwIndex;

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

    if (dwFlags & MCI_VCR_SET_POWER)
    {
        UINT    cb;

        if (dwFlags & MCI_SET_ON)
        {
            if (dwFlags & MCI_SET_OFF)
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

            if(dwFlags & MCI_TEST)
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));


            cb = viscaMessageMD_Power(achPacket + 1, VISCAPOWERON);
        }
        else if (dwFlags & MCI_SET_OFF)
        {
            if(dwFlags & MCI_TEST)
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            cb = viscaMessageMD_Power(achPacket + 1, VISCAPOWEROFF);
        }
        else
        {
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));
        }

        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1), achPacket, cb);

        pvcr->Port[iPort].Dev[iDev].fTimecodeChecked = FALSE;

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

    if(dwFlags & MCI_VCR_SET_ASSEMBLE_RECORD)
    {
        if (dwFlags & MCI_SET_ON)
        {
            if (dwFlags & MCI_SET_OFF)
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

            if(dwFlags & MCI_TEST)
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            pvcr->Port[iPort].Dev[iDev].bVideoDesired   = 0x01; // on
            pvcr->Port[iPort].Dev[iDev].bTimecodeDesired= 0x01;
            pvcr->Port[iPort].Dev[iDev].bAudioDesired   = 0x03;

            dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_RecTrack(achPacket + 1,
                                            VISCARECORDMODEASSEMBLE,
                                            pvcr->Port[iPort].Dev[iDev].bVideoDesired,   
                                            pvcr->Port[iPort].Dev[iDev].bTimecodeDesired,
                                            pvcr->Port[iPort].Dev[iDev].bAudioDesired));
        }
        else if (dwFlags & MCI_SET_OFF)
        {
            if(dwFlags & MCI_TEST)
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            //
            // This does nothing! You must select tracks to set off.
            // This just resets the desire the tracks to all desired on.
            //
            pvcr->Port[iPort].Dev[iDev].bVideoDesired   = 0x01; // on
            pvcr->Port[iPort].Dev[iDev].bTimecodeDesired= 0x01;
            pvcr->Port[iPort].Dev[iDev].bAudioDesired   = 0x03;

            dwErr = MCIERR_NO_ERROR;

        }
        else
        {
            dwErr = MCIERR_MISSING_PARAMETER;
        }

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
            (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

    if(dwFlags & MCI_VCR_SET_PREROLL_DURATION)
    {
        char    achPreroll[5];
        BYTE    bDataFormat;

        // This is the CI-1000 kludge, it may be relative but, timecode... 
        if(pvcr->Port[iPort].Dev[iDev].bTimeType == VISCAABSOLUTECOUNTER)
            bDataFormat = VISCADATATIMECODENDF;
        else
            bDataFormat = pvcr->Port[iPort].Dev[iDev].bRelativeType;

        // TRUE means we must use timecode for this command. 
        dwErr = viscaMciTimeFormatToViscaData(iInst, TRUE, lpSet->dwPrerollDuration, achPreroll, bDataFormat);

        if(dwErr)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, dwErr));
    
        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                    achPacket,
                    viscaMessageMD_SegPreRollDuration(achPacket, achPreroll));

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
            (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

    if(dwFlags & MCI_VCR_SET_POSTROLL_DURATION)
    {
        BYTE    achPacket[MAXPACKETLENGTH];
        char    achPostroll[5];
        BYTE    bDataFormat;

        // This is the CI-1000 kludge, it may be relative but, timecode... 
        if(pvcr->Port[iPort].Dev[iDev].bTimeType == VISCAABSOLUTECOUNTER)
            bDataFormat = VISCADATATIMECODENDF;
        else
            bDataFormat = pvcr->Port[iPort].Dev[iDev].bRelativeType;

        // TRUE means we must use timecode for this command. 
        dwErr = viscaMciTimeFormatToViscaData(iInst, TRUE, lpSet->dwPostrollDuration, achPostroll, bDataFormat);

        if(dwErr)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, dwErr));
 
    
        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                    achPacket,
                    viscaMessageMD_SegPostRollDuration(achPacket, achPostroll));

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

    if(dwFlags & MCI_VCR_SET_PAUSE_TIMEOUT)
    {
        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_UNSUPPORTED_FUNCTION));
    }

    if(dwFlags & MCI_VCR_SET_TAPE_LENGTH)
    {
        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        pvcr->Port[iPort].Dev[iDev].dwTapeLength = lpSet->dwLength;
        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
    }

    if(dwFlags & MCI_VCR_SET_CLOCK)
    {
        BYTE    achPacket[MAXPACKETLENGTH];
        BYTE    bHours;
        BYTE    bMinutes;
        BYTE    bSeconds;
        UINT    uTicks;
        UINT    uTicksPerSecond = pvcr->Port[iPort].Dev[iDev].uTicksPerSecond;
        //
        // This assumes 300 ticks per second for now, should read at startup 
        //
        viscaMciClockFormatToViscaData(lpSet->dwClock, uTicksPerSecond,
            (BYTE FAR *)&bHours, (BYTE FAR *)&bMinutes, (BYTE FAR *)&bSeconds, (UINT FAR *)&uTicks);

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        // Try to set time (then we must dump the serial line) 
        dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                    achPacket,                    
                    viscaMessageIF_ClockSet(achPacket + 1,
                    bHours,
                    bMinutes,
                    bSeconds,
                    uTicks,
                    (BYTE)0, (BYTE)0, (BYTE)0, (UINT)0));

        if(dwErr == MCIERR_NO_ERROR)
        {
#ifdef _WIN32
            viscaTaskDo(iInst, TASKPUNCHCLOCK, iPort + 1,  iDev);
#else
            DWORD dwWaitTime = 2L; //Must be at least 1 millisecond.
            DWORD dwStart;
            DWORD dwTime;

            EscapeCommFunction(iPort, CLRDTR);
            //
            // The time must be at least 1 millisecond 
            //
            dwStart = GetTickCount();
            while(1)                 
            {
                dwTime = GetTickCount();
                if(MShortWait(dwStart, dwTime, dwWaitTime))
                    break;
                Yield();
            }
            EscapeCommFunction(iPort, SETDTR);
#endif
        }

        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

    if(dwFlags & MCI_VCR_SET_COUNTER_VALUE)
    {
        //
        // You may only RESET THIS COUNTER!! 
        //
        if (lpSet->dwCounter == 0L)
        {
            BOOL fResetQueue = FALSE;
            //
            // Time value will be in current time format
            //
            if(dwFlags & MCI_TEST)
                return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            if(viscaDelayedCommand(iInst) == VISCA_SEEK)
            {
                viscaQueueReset(iInst, MCI_PAUSE, MCI_NOTIFY_ABORTED);
                fResetQueue = TRUE;

                // If mode is seeking, then pause the thing.
                dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                            achPacket,
                            viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL));
            }

            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Subcontrol(achPacket + 1, VISCACOUNTERRESET));

            if(fResetQueue)
                viscaReleaseAutoParms(iPort, iDev);

            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                    (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
        }
        else
        {
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_UNSUPPORTED_FUNCTION));
        }
    }

    if(dwFlags & MCI_VCR_SET_SPEED)
    {
        UINT uCmd;

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        //
        // Set the new speed value, cannot change direction! 
        //
        pvcr->Port[iPort].Dev[iDev].dwPlaySpeed = viscaRoundSpeed(lpSet->dwSpeed, pvcr->Port[iPort].Dev[iDev].fPlayReverse);
        //
        // If the device is playing we must cancel the current command */
        //
        if((uCmd = viscaDelayedCommand(iInst)) && !pvcr->Port[iPort].Dev[iDev].fQueueAbort)
        {
            if((uCmd == VISCA_PLAY) || (uCmd == VISCA_PLAY_TO))
            {
                int     iDevCmd = pvcr->Port[iPort].Dev[iDev].iCmdDone;
                BYTE    bAction;
                BYTE    achPacket[MAXPACKETLENGTH];
                DWORD   dwReply;

                // Need direction!! 
                bAction = viscaMapSpeed(pvcr->Port[iPort].Dev[iDev].dwPlaySpeed, pvcr->Port[iPort].Dev[iDev].fPlayReverse);

                // This command must be immediate, since it does not cancel ongoing transport 
                dwReply = viscaDoImmediateCommand(iInst, (BYTE)(iDev+1),
                                achPacket,
                                viscaMessageMD_Mode1(achPacket + 1, bAction));
            }
        }
        return (viscaNotifyReturn(iInst, (HWND) lpSet->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
    }
}

/****************************************************************************
 * Function: DWORD viscaMciEscape - Escape.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_ESCAPE_PARMS lpEscape - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_ESCAPE
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciEscape(int iInst, DWORD dwFlags, LPMCI_VCR_ESCAPE_PARMS lpEscape)
{
    return (viscaNotifyReturn(iInst, (HWND) lpEscape->dwCallback, dwFlags,
        MCI_NOTIFY_FAILURE, MCIERR_UNRECOGNIZED_COMMAND));
}


/****************************************************************************
 * Function: DWORD viscaMciList - List.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_LIST_PARMS lpList - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_LIST
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciList(int iInst, DWORD dwFlags, LPMCI_VCR_LIST_PARMS lpList)
{
    UINT    uSourceFlag     = 0;
    UINT    uModel          = 0;
    UINT    iDev            = pinst[iInst].iDev;
    UINT    iPort           = pinst[iInst].iPort;
    //
    // Do we have one of the three possible sources specified.
    //
    if((dwFlags & MCI_VCR_LIST_VIDEO_SOURCE) && (dwFlags & MCI_VCR_LIST_AUDIO_SOURCE))
        return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

    if(!((dwFlags & MCI_VCR_LIST_VIDEO_SOURCE) || (dwFlags & MCI_VCR_LIST_AUDIO_SOURCE)))
        return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));

    if((dwFlags & MCI_VCR_LIST_NUMBER) && (dwFlags & MCI_VCR_LIST_COUNT))
        return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));


    if(!((dwFlags & MCI_VCR_LIST_NUMBER) || (dwFlags & MCI_VCR_LIST_COUNT)))
        return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));

    if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

    // Parameter checking is done, now continue.

    if(dwFlags & MCI_VCR_LIST_VIDEO_SOURCE)
        uSourceFlag = VCR_INPUT_VIDEO;
    else
        uSourceFlag = VCR_INPUT_AUDIO;
    //
    // Inputs should be read from the ini file, because they cannot be
    // determined from the hardware.
    //
    if(dwFlags & MCI_VCR_LIST_COUNT)
    {
       if(pvcr->Port[iPort].Dev[iDev].rgInput[uSourceFlag].uNumInputs == -1)
       {
           // Unable to determine the number! So return 0, ? 
           lpList->dwReturn = 0L;
       }
       else
       {
           lpList->dwReturn = pvcr->Port[iPort].Dev[iDev].rgInput[uSourceFlag].uNumInputs;
       }
       return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags,
                   MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
    }
    else if(dwFlags & MCI_VCR_LIST_NUMBER)
    {
        // Return the type of the input, any number is greater than -1! so it works 
        if( ((UINT)lpList->dwNumber == 0) ||
            ((UINT)lpList->dwNumber > (UINT)pvcr->Port[iPort].Dev[iDev].rgInput[uSourceFlag].uNumInputs))
        {
           DPF(DBG_MCI, "\nBad input number has been specified.=%d", (UINT)lpList->dwNumber);
           return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags,
                       MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));
        }
        else
        {
           lpList->dwReturn = MAKEMCIRESOURCE(
               pvcr->Port[iPort].Dev[iDev].rgInput[uSourceFlag].uInputType[(UINT)lpList->dwNumber-1],
               pvcr->Port[iPort].Dev[iDev].rgInput[uSourceFlag].uInputType[(UINT)lpList->dwNumber-1]);

           return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags,
                       MCI_NOTIFY_SUCCESSFUL, MCI_RESOURCE_RETURNED | MCI_RESOURCE_DRIVER));
        }
    }

    return (viscaNotifyReturn(iInst, (HWND) lpList->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_UNSUPPORTED_FUNCTION));
}


/****************************************************************************
 * Function: DWORD viscaMciMark - Write or erase a mark.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_GENERIC_PARMS lpGeneric - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_MARK
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciMark(int iInst, DWORD dwFlags, LPMCI_GENERIC_PARMS lpGeneric)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    DWORD   dwErr;
    UINT    iDev            = pinst[iInst].iDev;
    UINT    iPort           = pinst[iInst].iPort;
    BOOL    fResetQueue     = FALSE;

    if (dwFlags & MCI_VCR_MARK_WRITE)
    {
        if (dwFlags & MCI_VCR_MARK_ERASE)
            return (viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags,
                        MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        if(viscaDelayedCommand(iInst) == VISCA_SEEK)
        {
            fResetQueue = TRUE;
            viscaQueueReset(iInst, MCI_PAUSE, MCI_NOTIFY_ABORTED);

            // If mode is seeking, then pause the thing.
            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL));
        }

        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                    achPacket,
                    viscaMessageMD_Mode2(achPacket + 1, VISCAMODE2INDEXMARK));
    
    }
    else if (dwFlags & MCI_VCR_MARK_ERASE)
    {
        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        if(viscaDelayedCommand(iInst) == VISCA_SEEK)
        {
            viscaQueueReset(iInst, MCI_PAUSE, MCI_NOTIFY_ABORTED);
            fResetQueue = TRUE;

            // If mode is seeking, then pause the thing.
            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL));
        }

        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                    achPacket,
                    viscaMessageMD_Mode2(achPacket + 1, VISCAMODE2INDEXERASE));
    }
    else
    {
        return (viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));
    }

    if(fResetQueue)
        viscaReleaseAutoParms(iPort, iDev);

    if(dwErr == MCIERR_VCR_CONDITION)
        dwErr = MCIERR_VCR_ISWRITEPROTECTED;

    return (viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags,
            (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
}

/*
 * Check if the input is in range.
 */
static BOOL NEAR PASCAL
viscaInputCheck(int iInst, UINT uSource, UINT uRelType, UINT uRelNumber)
{
    UINT    iDev      = pinst[iInst].iDev;
    UINT     iPort    = pinst[iInst].iPort;
    //
    // If the inputs of video or audio are specified, then make sure
    // the range is good.  Otherwise just assume range is ok.
    //
    if(pvcr->Port[iPort].Dev[iDev].rgInput[uSource].uNumInputs != -1)
    {
        int  i;
        UINT uTempRelNumber = 0;
        //
        // Make sure there is a Numberth of that type.
        //
        for(i = 0; i  < pvcr->Port[iPort].Dev[iDev].rgInput[uSource].uNumInputs; i++)
        {
            if(pvcr->Port[iPort].Dev[iDev].rgInput[uSource].uInputType[i] == uRelType)
                uTempRelNumber++;
        }
        //
        // Are there any inputs of that type, or was one given larger then
        // the total number of inputs of that type.
        //
        if((uTempRelNumber == 0) || (uRelNumber > uTempRelNumber))
            return FALSE;
    }
    return TRUE; // Sorry, no check 
}


/****************************************************************************
 * Function: DWORD viscaMciSetAudio - Set audio settings.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_SETAUDIO_PARMS lpSetAudio - Pointer to MCI parameter
 *                                  block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_SETAUDIO
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciSetAudio(int iInst, DWORD dwFlags, LPMCI_VCR_SETAUDIO_PARMS lpSetAudio)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    UINT    iDev     = pinst[iInst].iDev;
    UINT    iPort    = pinst[iInst].iPort;
    DWORD   dwErr;
    UINT    uInputType;
    UINT    uInputNumber;
    BYTE    bAudioTrack;
    BYTE    bTrack = 0x00;
    BYTE    fResetQueue = FALSE;

    if (dwFlags & MCI_VCR_SETAUDIO_SOURCE)
    {
        //
        // We must have a type with this command, absolute is not possible.
        //
        if(!(dwFlags & MCI_VCR_SETAUDIO_TO))
            return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));
        //
        // Make sure that the output flag is not specified.
        //
        if((UINT)lpSetAudio->dwTo == MCI_VCR_SRC_TYPE_OUTPUT)
            return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));
        //
        // Get the type and the number.
        //
        if(dwFlags & MCI_VCR_SETAUDIO_NUMBER)
        {
            // Check if there is a n'th input of type to.
            uInputType      = (UINT) lpSetAudio->dwTo;
            uInputNumber    = (UINT) lpSetAudio->dwNumber;
        }
        else 
        {
            uInputType      = (UINT) lpSetAudio->dwTo;
            uInputNumber    = (UINT) 1;
        }
        //
        // If it is one of the recognized Sony's check its input table.
        //
        if(!viscaInputCheck(iInst, VCR_INPUT_AUDIO,    uInputType, uInputNumber))
            return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_BAD_CONSTANT));

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        //
        // Get the base for that type.
        //
        switch(uInputType)
        {
            case MCI_VCR_SRC_TYPE_LINE:
                uInputType = VISCALINE;
                break;
            case MCI_VCR_SRC_TYPE_TUNER:
                uInputType = 0x00; // tuner #1 gets added so it is 01 
                break;
            case MCI_VCR_SRC_TYPE_SVIDEO:
                uInputType = VISCASVIDEOLINE;
                break;
            case MCI_VCR_SRC_TYPE_AUX:
                uInputType = VISCAAUX;
                break;

            case MCI_VCR_SRC_TYPE_MUTE:
                uInputType =   VISCAMUTE;
                uInputNumber = 0x00;
                break;

        }
        //
        // Set to the correct number of the relative type.
        //
        uInputType = uInputType + uInputNumber;
        
        // Read settings so we don't overwrite current video.
        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_InputSelectInq(achPacket + 1));

        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_InputSelect(achPacket + 1,
                            (BYTE)achPacket[2], /* the old video */
                            (BYTE)uInputType));

    }
    else if (dwFlags & MCI_VCR_SETAUDIO_MONITOR)
    {
        if(lpSetAudio->dwTo == MCI_VCR_SRC_TYPE_OUTPUT)
        {
            if(dwFlags & MCI_TEST)
                return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));


            return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags,
                    MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        }

        dwErr = MCIERR_UNSUPPORTED_FUNCTION;
    }

    else if (dwFlags & MCI_VCR_SETAUDIO_RECORD)
    {
        if((dwFlags & MCI_SET_ON) && (dwFlags & MCI_SET_OFF))
             return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags,
                     MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

        if(dwFlags & MCI_TRACK)
        {
            if((lpSetAudio->dwTrack==0) || ((UINT)lpSetAudio->dwTrack > 2))
                return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));
        }
        else
        {
            lpSetAudio->dwTrack = 1;
        }

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        if(!(dwFlags & MCI_SET_OFF))
            dwFlags |= MCI_SET_ON;

        bTrack = pvcr->Port[iPort].Dev[iDev].bAudioDesired;

        if (dwFlags & MCI_SET_ON)
        {
            if(lpSetAudio->dwTrack==2)
                bTrack |= VISCATRACK2;
            else
                bTrack |= VISCATRACK1;
        }
        else
        {
            if(lpSetAudio->dwTrack==2)
                bTrack &= (BYTE) ~VISCATRACK2;
            else
                bTrack &= (BYTE) ~VISCATRACK1;
        }

        dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                    achPacket,
                    viscaMessageMD_RecTrack(achPacket + 1,
                                            VISCARECORDMODEINSERT,
                                            pvcr->Port[iPort].Dev[iDev].bVideoDesired,      // video
                                            pvcr->Port[iPort].Dev[iDev].bTimecodeDesired,   // data
                                            bTrack)); // audio

        // Why doesn't EVO-9650 return 4A like good visca devices do?
        if( (dwErr == MCIERR_UNSUPPORTED_FUNCTION) ||
            (dwErr == MCIERR_VCR_REGISTER))
        {
            dwErr = MCIERR_VCR_TRACK_FAILURE;
            pvcr->Port[iPort].Dev[iDev].bAudioDesired = bTrack;
        }
        else
        {
            pvcr->Port[iPort].Dev[iDev].bAudioDesired = bTrack;
        }
    }
    else
    {
        // Set playback tracks.

        if((dwFlags & MCI_SET_ON) && (dwFlags & MCI_SET_OFF))
             return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags,
                     MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

        if(dwFlags & MCI_TRACK)
        {
            if((lpSetAudio->dwTrack==0) || ((UINT)lpSetAudio->dwTrack > 2))
                return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));
        }
        else
        {
            lpSetAudio->dwTrack = 1;
        }


        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        if(viscaDelayedCommand(iInst) == VISCA_SEEK)
        {
            viscaQueueReset(iInst, MCI_PAUSE, MCI_NOTIFY_ABORTED);
            fResetQueue = TRUE;

            // If mode is seeking, then pause the thing.
            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL));
        }


        //
        // Get current playback track register values so that we can leave those we're not interested in unchanged.
        //
        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                    achPacket,
                    viscaMessageMD_PBTrackInq(achPacket + 1));

        if(fResetQueue)
            viscaReleaseAutoParms(iPort, iDev);

        if (dwErr)
            return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, dwErr));

        if(!(dwFlags & MCI_SET_OFF))
            dwFlags |= MCI_SET_ON;


        if (dwFlags & MCI_SET_ON)
        {
            if(lpSetAudio->dwTrack==2)
                bTrack |= VISCATRACK2;
            else
                bTrack |= VISCATRACK1;

            bAudioTrack = achPacket[4] | bTrack;
        }
        else
        {
            if(lpSetAudio->dwTrack==2)
                bTrack = (BYTE) ~VISCATRACK2;
            else
                bTrack = (BYTE) ~VISCATRACK1;

            bAudioTrack = achPacket[4] &= bTrack;
        }
        //
        // Now set record track register values with new bAudioTrack value.
        //
        dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                    achPacket,
                    viscaMessageMD_PBTrack(achPacket + 1,
                                            achPacket[2],
                                            achPacket[3],
                                            bAudioTrack));

    }

    return (viscaNotifyReturn(iInst, (HWND) lpSetAudio->dwCallback, dwFlags,
        (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
}


/****************************************************************************
 * Function: DWORD viscaMciSetVideo - Set video settings.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_SETVIDEO_PARMS lpSetVideo - Pointer to MCI parameter
 *                                  block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_SETVIDEO
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciSetVideo(int iInst, DWORD dwFlags, LPMCI_VCR_SETVIDEO_PARMS lpSetVideo)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    UINT    iDev        = pinst[iInst].iDev;
    UINT    iPort       = pinst[iInst].iPort;
    BYTE    bVideoTrack = 0x00;
    DWORD   dwErr;
    UINT    uInputType;
    UINT    uInputNumber;
    BYTE    bTrack = 0x00;
    BYTE    fResetQueue = FALSE;

    if (dwFlags & MCI_VCR_SETVIDEO_SOURCE)
    {
        //
        // We must have a type with this command, absolute is not possible.
        //
        if(!(dwFlags & MCI_VCR_SETVIDEO_TO))
            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));
        //
        // Make sure that the output flag is not specified.
        //
        if((UINT)lpSetVideo->dwTo == MCI_VCR_SRC_TYPE_OUTPUT)
            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));
        //
        // Get the type and the number.
        //
        if(dwFlags & MCI_VCR_SETVIDEO_NUMBER)
        {
            // Check if there is a n'th input of type to.
            uInputType      = (UINT) lpSetVideo->dwTo;
            uInputNumber    = (UINT) lpSetVideo->dwNumber;
        }
        else 
        {
            uInputType      = (UINT) lpSetVideo->dwTo;
            uInputNumber    = (UINT) 1;
        }
        //
        // If it is one of the recognized Sony's check its input table.
        //
        if(!viscaInputCheck(iInst, VCR_INPUT_VIDEO,    uInputType, uInputNumber))
        {
            DPF(DBG_MCI, "\nFailed input check.");;
            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_BAD_CONSTANT));
        }

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        //
        // Get the base for that type.
        //
        switch(uInputType)
        {
            case MCI_VCR_SRC_TYPE_LINE:
                uInputType = VISCALINE;
                break;
            case MCI_VCR_SRC_TYPE_TUNER:
                uInputType = 0x00; // tuner #1 gets added so it is 01 
                break;
            case MCI_VCR_SRC_TYPE_SVIDEO:
                uInputType = VISCASVIDEOLINE;
                break;
            case MCI_VCR_SRC_TYPE_AUX:
                uInputType = VISCAAUX;
                break;

            case MCI_VCR_SRC_TYPE_MUTE:
                uInputType   = VISCAMUTE;
                uInputNumber = 0x00;
                break;
        }
        //
        // Set to the correct number of the releative type.
        //
        uInputType = uInputType + uInputNumber;
        //
        // Read audio setting, so we don't destroy it.
        //
        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_InputSelectInq(achPacket + 1));

        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_InputSelect(achPacket + 1,
                                        (BYTE) uInputType,
                                        achPacket[3]));

    }
    else if (dwFlags & MCI_VCR_SETVIDEO_MONITOR)
    {
        if(lpSetVideo->dwTo == MCI_VCR_SRC_TYPE_OUTPUT)
        {
            if(dwFlags & MCI_TEST)
                return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
                MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        }

        dwErr = MCIERR_UNSUPPORTED_FUNCTION;
    }
    else if (dwFlags & MCI_VCR_SETVIDEO_RECORD)
    {
        if((dwFlags & MCI_SET_ON) && (dwFlags & MCI_SET_OFF))
             return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
                     MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

        if(dwFlags & MCI_TRACK)
        {
            if(lpSetVideo->dwTrack != 1)
                return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));
        }
        else
        {
            lpSetVideo->dwTrack = 1;
        }

        if(!(dwFlags & MCI_SET_OFF))
            dwFlags |= MCI_SET_ON;

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        bTrack = pvcr->Port[iPort].Dev[iDev].bVideoDesired;

        if (dwFlags & MCI_SET_ON)
            bTrack |= VISCATRACK1;
        else
            bTrack &= (BYTE) ~VISCATRACK1;


        dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                    achPacket,
                    viscaMessageMD_RecTrack(achPacket + 1,
                                            VISCARECORDMODEINSERT,
                                            bTrack,
                                            pvcr->Port[iPort].Dev[iDev].bTimecodeDesired,   // data
                                            pvcr->Port[iPort].Dev[iDev].bAudioDesired));     // audio

        // if it was register remember what we wanted to do.
        if( (dwErr == MCIERR_UNSUPPORTED_FUNCTION) ||
            (dwErr == MCIERR_VCR_REGISTER))
        {
            pvcr->Port[iPort].Dev[iDev].bVideoDesired = bTrack;
            dwErr = MCIERR_VCR_TRACK_FAILURE;
        }
        else
        {
            pvcr->Port[iPort].Dev[iDev].bVideoDesired = bTrack;
        }

    }
    else
    {
        // Set playback option.

        if((dwFlags & MCI_SET_ON) && (dwFlags & MCI_SET_OFF))
             return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
                     MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

        if(dwFlags & MCI_TRACK)
        {
            if(lpSetVideo->dwTrack != 1)
                return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_OUTOFRANGE));
        }
        else
        {
            lpSetVideo->dwTrack = 1;
        }

        if(!(dwFlags & MCI_SET_OFF))
            dwFlags |= MCI_SET_ON;

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        if (dwFlags & MCI_SET_ON)
            bVideoTrack |= VISCATRACK1;
        else
            bVideoTrack &= (BYTE) ~VISCATRACK1;

        if(viscaDelayedCommand(iInst) == VISCA_SEEK)
        {
            viscaQueueReset(iInst, MCI_PAUSE, MCI_NOTIFY_ABORTED);
            fResetQueue = TRUE;

            // If mode is seeking, then pause the thing.
            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL));
        }

        //
        // Get current record track register values so that we
        // can leave those we're not interested in unchanged.
        //
        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_PBTrackInq(achPacket + 1));

        if(fResetQueue)
            viscaReleaseAutoParms(iPort, iDev);


        if (dwErr)
            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, dwErr));
        //
        // If current setting is equal to new setting, then don't
        // bother doing anything.
        //
        if (bVideoTrack == (BYTE)achPacket[2])
        {
            return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
                MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        }
        //
        // Now set playback track register values with new bVideoTrack value.
        //
        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(pinst[iInst].iDev + 1),
                            achPacket,
                            viscaMessageMD_PBTrack(achPacket + 1,
                                            bVideoTrack,
                                            achPacket[3],
                                            achPacket[4]));

        // If register failure record the track selection.
    }

    return (viscaNotifyReturn(iInst, (HWND) lpSetVideo->dwCallback, dwFlags,
        (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));

}

/****************************************************************************
 * Function: DWORD viscaMciSetTuner - Set video settings.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_SETTUNER_PARMS lpSetTuner - Pointer to MCI parameter
 *                                  block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_SETTUNER
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciSetTuner(int iInst, DWORD dwFlags, LPMCI_VCR_SETTUNER_PARMS lpSetTuner)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    UINT    uNumber = 1;                // 1 is the default tuner. 

    if(dwFlags & MCI_VCR_SETTUNER_NUMBER)
    {
        uNumber = (UINT) lpSetTuner->dwNumber;
    }

    if (dwFlags & MCI_VCR_SETTUNER_CHANNEL)
    {
        DWORD dwErr;

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetTuner->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                    achPacket, 
                    viscaMessageMD_Channel(achPacket + 1, (UINT)(lpSetTuner->dwChannel)));

        
        return (viscaNotifyReturn(iInst, (HWND) lpSetTuner->dwCallback, dwFlags,
                (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

    if ((dwFlags & MCI_VCR_SETTUNER_CHANNEL_UP) || (dwFlags & MCI_VCR_SETTUNER_CHANNEL_DOWN))
    {
        UINT    uChannel;
        DWORD   dwErr;

        if ((dwFlags & MCI_VCR_SETTUNER_CHANNEL_UP) && (dwFlags & MCI_VCR_SETTUNER_CHANNEL_DOWN))
            return (viscaNotifyReturn(iInst, (HWND) lpSetTuner->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetTuner->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_ChannelInq(achPacket + 1));

        if (dwErr) 
            return (viscaNotifyReturn(iInst, (HWND) lpSetTuner->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, dwErr));

        uChannel = 100 * (achPacket[2] & 0x0F) +
                    10 * (achPacket[3] & 0x0F) +
                         (achPacket[4] & 0x0F);

        if (dwFlags & MCI_VCR_SETTUNER_CHANNEL_UP)
            uChannel = (uChannel + 1) % 1000;
        else
            uChannel = (uChannel + 999) % 1000; // go one down

        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Channel(achPacket + 1, uChannel));

        return (viscaNotifyReturn(iInst, (HWND) lpSetTuner->dwCallback, dwFlags,
                (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));

    }

    if (dwFlags & MCI_VCR_SETTUNER_CHANNEL_SEEK_UP)
        return (viscaNotifyReturn(iInst, (HWND) lpSetTuner->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_UNRECOGNIZED_KEYWORD));

    if (dwFlags & MCI_VCR_SETTUNER_CHANNEL_SEEK_DOWN) 
        return (viscaNotifyReturn(iInst, (HWND) lpSetTuner->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_UNRECOGNIZED_KEYWORD));
}

/****************************************************************************
 * Function: DWORD viscaMciSetTimecode - Set video settings.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_SETTIMECODE_PARMS lpSetTimecode - Pointer to MCI parameter
 *                                  block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_SETTUNER
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciSetTimecode(int iInst, DWORD dwFlags, LPMCI_GENERIC_PARMS lpSetTimecode)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    BYTE    bTrack  = 0x00; 
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    DWORD   dwErr;

    if (dwFlags & MCI_VCR_SETTIMECODE_RECORD)
    {
        if((dwFlags & MCI_SET_ON) && (dwFlags & MCI_SET_OFF))
             return (viscaNotifyReturn(iInst, (HWND) lpSetTimecode->dwCallback, dwFlags,
                     MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

        if(!(dwFlags & MCI_SET_OFF))
            dwFlags |= MCI_SET_ON;

        if(dwFlags & MCI_TEST)
            return (viscaNotifyReturn(iInst, (HWND) lpSetTimecode->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        bTrack = pvcr->Port[iPort].Dev[iDev].bTimecodeDesired;

        if (dwFlags & MCI_SET_ON)
            bTrack |= VISCATRACK1;
        else
            bTrack &= (BYTE) ~VISCATRACK1;


        dwErr = viscaDoImmediateCommand(iInst, (BYTE)(pinst[iInst].iDev + 1),
                    achPacket,
                    viscaMessageMD_RecTrack(achPacket + 1,
                                            VISCARECORDMODEINSERT,
                                            pvcr->Port[iPort].Dev[iDev].bVideoDesired,
                                            bTrack,                                         // data
                                            pvcr->Port[iPort].Dev[iDev].bAudioDesired));     // audio

        // if it was register remember what we wanted to do.
        if((dwErr == MCIERR_UNSUPPORTED_FUNCTION)  ||
            (dwErr == MCIERR_VCR_REGISTER))
        {
            pvcr->Port[iPort].Dev[iDev].bTimecodeDesired = bTrack;
            dwErr = MCIERR_VCR_TRACK_FAILURE;
        }
        else
        {
            pvcr->Port[iPort].Dev[iDev].bTimecodeDesired = bTrack;
        }

        return (viscaNotifyReturn(iInst, (HWND) lpSetTimecode->dwCallback, dwFlags,
            (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
    }

}

/****************************************************************************
 * Function: DWORD viscaMciIndex - Index.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_RECORD_PARMS lpPerform - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This command may not work while seeking.
 *       
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciIndex(int iInst, DWORD dwFlags, LPMCI_GENERIC_PARMS lpIndex)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    MCI_VCR_STATUS_PARMS mciStatus;
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    DWORD   dwModeErr;
    DWORD   dwErr;

    if(dwFlags & MCI_TEST)
        return (viscaNotifyReturn(iInst, (HWND) lpIndex->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

    // What command is currently running on this device.
    if(viscaDelayedCommand(iInst) == VISCA_SEEK)
    {
        DPF(DBG_MCI, "Cannot change index when seeking\n");
        return (viscaNotifyReturn(iInst, (HWND) lpIndex->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_NONAPPLICABLE_FUNCTION));
    }

    // We should also do a status mode to see if we opened and it was seeking.
    // Is it still seeking.
    mciStatus.dwItem = MCI_STATUS_MODE;
    dwErr = viscaMciStatus(iInst, MCI_STATUS_ITEM, &mciStatus);
    if(HIWORD(mciStatus.dwReturn) == MCI_MODE_SEEK)
    {
        DPF(DBG_MCI, "Cannot change index when seeking\n");
        return (viscaNotifyReturn(iInst, (HWND) lpIndex->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_NONAPPLICABLE_FUNCTION));
    }

    //
    // If it is off then do nothing 
    //
    dwModeErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                achPacket,
                viscaMessageMD_OSDInq(achPacket + 1));

    if(dwFlags & MCI_SET_OFF)
    {
        if((achPacket[2] != VISCAOSDPAGEOFF) || dwModeErr)
        {
            // now toggle it 
            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                            achPacket,
                            viscaMessageMD_Subcontrol(achPacket + 1, VISCATOGGLEDISPLAYONOFF));

        }
    }
    else
    {
        // Set page to the currently device selected index 
        BYTE bPageNo;
        //
        // We can safely ignore this on CI-1000? or not? 
        //
        switch(pvcr->Port[iPort].Dev[iDev].uIndexFormat)
        {
            case  MCI_VCR_INDEX_TIMECODE:
                bPageNo = 1;
                break;
            case  MCI_VCR_INDEX_COUNTER:
                bPageNo = 2;
                break;
            case  MCI_VCR_INDEX_DATE   :
                bPageNo = 3;
                break;
            case  MCI_VCR_INDEX_TIME   :
                bPageNo = 4;
                break;
        }
        //
        // Only change if it is not the currently selected page 
        //
        if(((BYTE)achPacket[2] != bPageNo) && !dwModeErr)
        {
            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_OSD(achPacket + 1, bPageNo));
        }
        //
        // Only toggle if it is not already on 
        //
        if((achPacket[2] == VISCAOSDPAGEOFF) || dwModeErr)
        {
            // now toggle it 
            dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                            achPacket,
                            viscaMessageMD_Subcontrol(achPacket + 1, VISCATOGGLEDISPLAYONOFF));
        }
    }

    return (viscaNotifyReturn(iInst, (HWND) lpIndex->dwCallback, dwFlags,
            (dwErr ? MCI_NOTIFY_FAILURE : MCI_NOTIFY_SUCCESSFUL), dwErr));
}

/****************************************************************************
 * Function: DWORD viscaDoImmediateCommand - Perform a synchronous command (wait for response)
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      BYTE  bDest       - Destination device.
 *
 *      LPSTR lpstrPacket - Packet to send.
 *
 *      UINT  cbMessageLength - Length of the packet.
 *
 *      BOOL  fUseAckTimer - Do we want to use the ack-timeout timer, or just call GetTickCount.
 *
 * Returns: an MCI error code.
 *
 ***************************************************************************/
DWORD FAR PASCAL
viscaDoImmediateCommand(int iInst, BYTE bDest, LPSTR lpstrPacket,  UINT cbMessageLength)
{
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;

    if (bDest == BROADCASTADDRESS)
        pvcr->Port[iPort].iBroadcastDev = iDev;

    if(!pvcr->Port[iPort].Dev[iDev].fDeviceOk)
        return MCIERR_VCR_CANNOT_WRITE_COMM;

    if(!viscaWrite(iInst, bDest, lpstrPacket, cbMessageLength, NULL, 0L, FALSE))
        return MCIERR_VCR_CANNOT_WRITE_COMM;

    // Wait completion, False==>we are not waiting on queue.
    if(!viscaWaitCompletion(iInst, FALSE, TRUE))
    {
        // Turn of the waiting flag and return
        pvcr->Port[iPort].Dev[iDev].fDeviceOk = FALSE;
        return MCIERR_VCR_READ_TIMEOUT;
    }

    if(pinst[iInst].bReplyFlags & VISCAF_ERROR_TIMEOUT)
    {
        pvcr->Port[iPort].Dev[iDev].fDeviceOk = FALSE;
        return MCIERR_VCR_READ_TIMEOUT;
    }

    // Copy the return packet 
    _fmemcpy(lpstrPacket, pinst[iInst].achPacket, MAXPACKETLENGTH);

    //
    // Compensate for address messages (which don't fit format)
    // by checking for error completions only.
    //
    if(pinst[iInst].bReplyFlags & VISCAF_ERROR)
        return viscaErrorToMCIERR(VISCAREPLYERRORCODE(pinst[iInst].achPacket));
    else
        return MCIERR_NO_ERROR;
}

MCI_GENERIC_PARMS Generic = { 0 };

/****************************************************************************
 * Function: DWORD viscaMciProc - Process MCI commands.
 *
 * Parameters:
 *
 *      WORD wDeviceID - MCI device ID.
 *
 *      WORD wMessage - MCI command.
 *
 *      DWORD dwParam1 - MCI command flags.
 *
 *      DWORD dwParam2 - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called by DriverProc() to process all MCI commands.
 ***************************************************************************/
DWORD FAR PASCAL
viscaMciProc(WORD wDeviceID, WORD wMessage, DWORD dwParam1, DWORD dwParam2)
{
    DWORD           dwRes;
    int             iInst   = (int)mciGetDriverData(wDeviceID);
    UINT            iPort, iDev;
    //
    // Some nice apps send null instead of structure pointers, give our own if this is the case.
    //
    if(!dwParam2)
        dwParam2 = (DWORD)(LPMCI_GENERIC_PARMS) &Generic;

    if (iInst == -1)
        return (MCIERR_INVALID_DEVICE_ID);

    DPF(DBG_MCI, "---->(enter) viscaMciProc: iInst = %d wMessage = %u \n", iInst, wMessage);
    
    iPort = pinst[iInst].iPort;
    iDev  = pinst[iInst].iDev;
    //
    // Set device to ok at the start of every message.
    //
    pvcr->Port[iPort].Dev[iDev].fDeviceOk = TRUE;
    
    switch (wMessage)
    {
        //
        // Required Commands 
        //
        case MCI_CLOSE_DRIVER:
            dwRes = viscaMciCloseDriver(iInst, dwParam1, (LPMCI_GENERIC_PARMS)dwParam2);
            break;

        case MCI_OPEN_DRIVER:
            dwRes = viscaMciOpenDriver(iInst, dwParam1, (LPMCI_OPEN_PARMS)dwParam2);
            break;

        case MCI_GETDEVCAPS:
            dwRes = viscaMciGetDevCaps(iInst, dwParam1, (LPMCI_GETDEVCAPS_PARMS)dwParam2);
            break;

        case MCI_INFO:
            dwRes = viscaMciInfo(iInst, dwParam1, (LPMCI_INFO_PARMS)dwParam2);
            break;

        case MCI_STATUS:
            dwRes = viscaMciStatus(iInst, dwParam1, (LPMCI_VCR_STATUS_PARMS)dwParam2);
            break;
        //
        // Basic Commands 
        //
        case MCI_SET:
            dwRes = viscaMciSet(iInst, dwParam1, (LPMCI_VCR_SET_PARMS)dwParam2);
            break;
        //
        // Extended Commands 
        //
        case MCI_INDEX:
            dwRes = viscaMciIndex(iInst, dwParam1, (LPMCI_GENERIC_PARMS)dwParam2);
            break;

        case MCI_ESCAPE:
            dwRes = viscaMciEscape(iInst, dwParam1, (LPMCI_VCR_ESCAPE_PARMS)dwParam2);
            break;

        case MCI_LIST:
            dwRes = viscaMciList(iInst, dwParam1, (LPMCI_VCR_LIST_PARMS)dwParam2);
            break;

        case MCI_MARK:
            dwRes = viscaMciMark(iInst, dwParam1, (LPMCI_GENERIC_PARMS)dwParam2);
            break;

        case MCI_SETAUDIO:
            dwRes = viscaMciSetAudio(iInst, dwParam1, (LPMCI_VCR_SETAUDIO_PARMS)dwParam2);
            break;

        case MCI_SETVIDEO:
            dwRes = viscaMciSetVideo(iInst, dwParam1, (LPMCI_VCR_SETVIDEO_PARMS)dwParam2);
            break;

        case MCI_SETTUNER:
            dwRes = viscaMciSetTuner(iInst, dwParam1, (LPMCI_VCR_SETTUNER_PARMS)dwParam2);
            break;

        case MCI_SETTIMECODE:
            dwRes = viscaMciSetTimecode(iInst, dwParam1, (LPMCI_GENERIC_PARMS)dwParam2);
            break;

        //
        // Delayed commands; in mcidelay.c 
        //
        case MCI_SIGNAL:
        case MCI_SEEK:
        case MCI_PAUSE:
        case MCI_PLAY:
        case MCI_RECORD:
        case MCI_RESUME:
        case MCI_STOP:
        case MCI_FREEZE:
        case MCI_UNFREEZE:
        case MCI_CUE:
        case MCI_STEP:
            dwRes = viscaMciDelayed(wDeviceID, wMessage, dwParam1, dwParam2);
            break;

        default:
            dwRes = MCIERR_UNRECOGNIZED_COMMAND;
            break;
    }

    DPF(DBG_MCI, "<----(exit) viscaMciProc: iInst = %d wMessage = %u \n", iInst, wMessage);
    return (dwRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\mcivisca\mcivisca.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992-1999 Microsoft Corporation
 *
 *  MCIVISCA.C
 *
 *  MCI ViSCA Device Driver
 *
 *  Description:
 *
 *      Main Module - Standard Driver Interface and Message Procedures
 *                    DriverProc and DrvOpen and Close Routines.
 *
 *      *1)           mcivisca.c - DriverProc and DriverOpen and Close.
 *       2)           mcicmds.c  - MCI commands.
 *       3)           mcidelay.c - MCI delayed commands (asynchronous)
 *       4)           viscamsg.c - ViSCA message construction procedures.
 *       5)           viscacom.c - Comport procedures.
 *       6)           commtask.c - Background task procedures.
 *
 *
 * Warning: The scanning of system.ini for driver entries is not
 *            recommended, but is done here because of the multiple
 *            devices driver.
 *
 ***************************************************************************/
#define  UNICODE
#include <windows.h>
#include <windowsx.h>
#include "appport.h"
#include <mmsystem.h>
#include <mmddk.h>
#include <string.h>
#include <ctype.h>
#include "vcr.h"
#include "viscamsg.h"
#include "viscadef.h"
#include "mcivisca.h"
#include "cnfgdlg.h"
#include "common.h"

#if (WINVER >= 0x0400)
#include <mcihlpid.h>
#endif

static BOOL NEAR PASCAL viscaDlgUpdateNumDevs(HWND hDlg, int iPort, int iNumDevices);
static BOOL NEAR PASCAL viscaDlgUpdatePort(HWND hDlg, int iPort);
static BOOL NEAR PASCAL viscaDlgRead(HWND hDlg, int iPort);  // Port config to read things into.
static int  NEAR PASCAL viscaComboGetPort(HWND hDlg);
static int  NEAR PASCAL viscaDetectOnCommPort(int iPort);

/*
 * A note about the shared memory.
 *
 * In the NT version all globals and instance structures are shared by
 * using a shared memory block, which is allocated or mapped into a process
 * space when a process attaches.
 *
 * In the WIN16 version the shared memory is just static data.
 *
 * Currently this imposes a maximum restriction on number of instances.
 * Also the inter-process protection is not very robust.
 */

#ifdef _WIN32
#pragma data_seg("MYSEG")
#endif
UINT uProcessCount = 0; //Must be initialized to 0.

#ifdef _WIN32
#pragma data_seg(".data")
#endif

//
// The following are per-instance pointers.
//
// This must be initialized each time this DLL maps into a process.
UINT            uCommandTable = (UINT)MCI_NO_COMMAND_TABLE;   // handle to VCR command table
HINSTANCE       hModuleInstance;    // module instance  (different in NT - DLL instances)
POpenInstance   pinst;              // Pointer to use. (For both versions) NT it's per-instance.
vcrTable        *pvcr;              // Pointer to use. (For both versions) NT it's per-instance.
#ifdef _WIN32
HANDLE          hInstanceMap;       // per-instance map.
HANDLE          hVcrMap;            // per-instance map.
#endif

//
// These are constants, so they don't change per-instance. (or you can share them safely).
//
CODESEGCHAR szNull[]                        = TEXT("");
CODESEGCHAR szIni[]                         = TEXT("MCIVISCA");
CODESEGCHAR szFreezeOnStep[]                = TEXT("FreezeOnStep");
CODESEGCHAR sz1[]                           = TEXT("1");
CODESEGCHAR sz0[]                           = TEXT("0");
WCHAR szAllEntries[ALLENTRIES_LENGTH]; // Big enough for all entries in MCI section.
WCHAR szKeyName[ONEENTRY_LENGTH];

/****************************************************************************
 * Function: BOOL MemInitializeVcrTable - Initialize global variables (now in structure).
 *
 * Returns: TRUE
 *
 ***************************************************************************/
BOOL MemInitializeVcrTable(void)
{
    int iPort;
    //
    // All globals defined and initialized here
    //
    uCommandTable                 = (UINT)MCI_NO_COMMAND_TABLE;   // handle to VCR command table
    pvcr->gfFreezeOnStep          = FALSE;
    pvcr->htaskCommNotifyHandler  = 0;
    pvcr->uTaskState              = TASKINIT;
    pvcr->lParam                  = 0;
    pvcr->hwndCommNotifyHandler   = (HWND) 0;
    pvcr->gfTaskLock              = FALSE;
#ifdef DEBUG
    pvcr->iGlobalDebugMask        = DBGMASK_CURRENT;        //see common.h
#endif
    // Set all port IDs to -1, since 0 is a valid port ID.
    //
    for (iPort = 0; iPort < MAXPORTS; iPort++)
    {
        pvcr->Port[iPort].idComDev = BAD_COMM;
        pvcr->Port[iPort].nUsage   = 0;
    }


    DPF(DBG_MEM, "InitializeVcrTable - completed succesfully");

    return TRUE;
}



/****************************************************************************
 * Function: BOOL MemInitializeInstances - Initialize heap of instances.
 *
 * Returns: TRUE
 *
 ***************************************************************************/
BOOL MemInitializeInstances(void)
{
    int i;

    // Erase any old data.
    _fmemset(pinst, (BYTE)0, sizeof(OpenInstance) * MAX_INSTANCES);

    // (Redundant) Set all In use flags to false.
    for(i = 0; i < MAX_INSTANCES; i++)
        pinst[i].fInUse = FALSE;

    DPF(DBG_MEM, "InitializeInstances - completed successfully");
    return TRUE;
}


/****************************************************************************
 * Function: BOOL MemAllocInstance - Allocate one instance from heap of instances.
 *
 * Returns: TRUE
 *
 ***************************************************************************/
int MemAllocInstance(void)  // Return an offset.
{
    int i;

    for(i = 0; i < MAX_INSTANCES; i++)
    {
        if(!pinst[i].fInUse)
            break;
    }
    if(i == MAX_INSTANCES)
        return 0;

    DPF(DBG_MEM, "MemAllocInstance - instance %x \n", i);

    pinst[i].fInUse = TRUE;

    // Use offsets only, so return

    return i;
}

/****************************************************************************
 * Function: BOOL MemFreeInstance - Free the instance, return it to heap of instances.
 *
 * Parameters:
 *
 *      int  iInstance       - Instance to free.
 *
 * Returns: TRUE
 *
 ***************************************************************************/
BOOL MemFreeInstance(int iInstance)
{
    _fmemset(&pinst[iInstance], (BYTE)0, sizeof(OpenInstance));
    pinst[iInstance].fInUse = FALSE;

    DPF(DBG_MEM, "MemFreeInstance - instance %d \n", iInstance);
    return TRUE;
}


/****************************************************************************
 * Function: BOOL IsSpace - WIN32/16 compatible version of _isspace.
 *
 * Parameters:
 *
 *      WCHAR wchTest - character or wide character to test.
 *
 * Returns: TRUE if it is white character
 *
 ***************************************************************************/
BOOL IsSpace(WCHAR wchTest)
{
    if( (wchTest == TEXT(' ')) || (wchTest == TEXT('\t')) )
        return TRUE;
    else
        return FALSE;

}

/****************************************************************************
 * Function: BOOL IsDigit - WIN32/16 compatible version of _isdigit.
 *
 * Returns: TRUE if it is a digit (0-9)
 *
 ***************************************************************************/
BOOL IsDigit(WCHAR wchTest)
{

    if( (wchTest >= TEXT('0')) && (wchTest <= TEXT('9')) )
        return TRUE;
    else
        return FALSE;

}
/****************************************************************************
 * Function: BOOL IsAlpha - Is it an alphabetical character.
 *
 * Returns: TRUE if it is alpha (A-Z, a-z)
 *
 ***************************************************************************/
BOOL IsAlpha(WCHAR wchTest)
{
    if( ((wchTest >= TEXT('A')) && (wchTest <= TEXT('Z'))) ||
        ((wchTest >= TEXT('a')) && (wchTest <= TEXT('z'))) )
        return TRUE;
    else
        return FALSE;

}
/****************************************************************************
 * Function: BOOL IsAlphaNumeric - Alphabetic or numeric.
 *
 * Returns: TRUE if alpha or numeric.
 *
 ***************************************************************************/
BOOL IsAlphaNumeric(WCHAR wchTest)
{
    if(IsDigit(wchTest))
        return TRUE;

    if(IsAlpha(wchTest))
        return TRUE;

    return FALSE;
}


#ifdef _WIN32
int APIENTRY DLLEntryPoint(PVOID hModule, ULONG Reason, PCONTEXT pContext);

/****************************************************************************
 * Function: int DLLEntryPoint - Each process and thread that attaches causes this to be called.
 *
 * Parameters:
 *
 *      PVOID hModule - This instance of the DLL. (each process has own).
 *
 *      ULONG Reason - Reason | Reason for attaching. (thread or process).
 *
 *      PCONTEXT pContext - I don't know?
 *
 * Returns: TRUE
 *
 ***************************************************************************/
int APIENTRY DLLEntryPoint(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
    BOOL fInitSharedMem, fIgnore;

    if (Reason == DLL_PROCESS_ATTACH)
    {
        /* Create the vcr area - This includes globals used for debugging
         * So it MUST be done before we allocate for the instances.
         */

        hVcrMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,
            PAGE_READWRITE, 0, sizeof(vcrTable),
            TEXT("mciviscaVcrTable"));

        if(hVcrMap == NULL)
            return 0;

        fInitSharedMem = (GetLastError() != ERROR_ALREADY_EXISTS);

        pvcr = (vcrTable *) MapViewOfFile(hVcrMap, FILE_MAP_WRITE, 0, 0, 0);

        if(pvcr == NULL)
            return 0;

        /* Initialize the vcr table, set this before calling the thing. */

        hModuleInstance = hModule;
        if(fInitSharedMem)
            MemInitializeVcrTable();

        /* Create the instance storage area */

        hInstanceMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,
            PAGE_READWRITE, 0, sizeof(OpenInstance) * MAX_INSTANCES,
            TEXT("mciviscaInstanceMap"));

        if(hInstanceMap == NULL)
            return 0;

        fInitSharedMem = (GetLastError() != ERROR_ALREADY_EXISTS);

        pinst = (POpenInstance) MapViewOfFile(hInstanceMap, FILE_MAP_WRITE, 0, 0, 0);

        if(pinst == NULL)
            return 0;

        /* Initialize the instance area if this is the first time. */
        if(fInitSharedMem)
            MemInitializeInstances();


    } else
    {
        if (Reason == DLL_PROCESS_DETACH)
        {
            if(pinst != NULL)
                fIgnore = UnmapViewOfFile(pinst);

            if(hInstanceMap != NULL)
                fIgnore = CloseHandle(hInstanceMap);

            if(pvcr  != NULL)
                fIgnore = UnmapViewOfFile(pvcr);

            if(hVcrMap != NULL)
                fIgnore = CloseHandle(hVcrMap);


        }

    }
    return TRUE;
}
#else
/****************************************************************************
 * Function: int LibMain - Library initialization code.
 *
 * Parameters:
 *
 *      HINSTANCE hModInst - Library instance handle.
 *
 *      WORD wDataSeg - Data segment.
 *
 *      WORD cbHeapSize - Heap size.
 *
 *      LPSTR lpszCmdLine - The command line.
 *
 * Returns: 1 if the initialization was successful and 0 otherwise.
 ***************************************************************************/
int FAR PASCAL
LibMain(HINSTANCE hModInst, WORD wDataSeg, WORD cbHeapSize, LPSTR lpszCmdLine)
{
    hModuleInstance = hModInst;
    return (1);
}
#endif

/*
 *      WIN16 - makes global pointer point to static data.
 */
#ifndef _WIN32
//
// In Win3.1 the static variables are allocated here.
//
OpenInstance arRealInst[MAX_INSTANCES];     // The real non-aliased thing.
vcrTable     vcrReal;                       // The real non-aliased thing.

OpenInstance *MemCreateInstances(void)
{
    pinst =  &arRealInst[0];
    return pinst;
}

vcrTable *MemCreateVcrTable(void)
{
    pvcr  =  &vcrReal;
    return pvcr;
}
#endif


/****************************************************************************
 * Function: LRESULT viscaDrvLoad - Respond to the DRV_LOAD message.
 *                 Perform any one-time initialization.
 *
 * Returns: TRUE on success and FALSE on failure.
 ***************************************************************************/
static LRESULT NEAR PASCAL
viscaDrvLoad(void)
{
    // In WIN16 this shouldn't make a difference since this only gets called once.
    uProcessCount++; //This is the only shared thing!

#ifdef _WIN32
    // In NT we do our own shareable counting.
    // The first time we enter this our process count will be 1.
    if(uProcessCount > 1)
        return ((LRESULT)TRUE);
#else
    // In NT version this is all done in the attach detach section of DLLEntry.
    MemCreateInstances();        // This is only once.
    MemCreateVcrTable();         // In NT maps everything and returns a pointer to mem-map
#endif

#ifndef _WIN32
    //
    // You must always use YOUR view of this memory in all functions.
    //
    MemInitializeVcrTable();        // In NT every process will AUTOMAGICALLY have its own handle.
    MemInitializeInstances();       // Because the globals will be on a per-instance basis.
#endif
    // Alloc the auto-instance pointer-flag for all now.
    pvcr->iInstBackground = MemAllocInstance();

    DPF(DBG_MEM, "viscaDrvLoad - initalized table and instances.");

    return ((LRESULT)TRUE);
}


/****************************************************************************
 * Function: LRESULT viscaDrvClose - Respond to the DRV_CLOSE message.  Perform
 *     any cleanup necessary each time the device is closed.
 *
 * Parameters:
 *
 *     WORD wDeviceID - The device id being closed.
 *
 * Returns: TRUE on success and FALSE on failure.
 ***************************************************************************/
static LRESULT NEAR PASCAL
viscaDrvClose(WORD wDeviceID)
{
    int iInst   = (int)mciGetDriverData(wDeviceID);

     // This cannot be 0
    if(iInst != 0)
        viscaInstanceDestroy(iInst);

    DPF(DBG_COMM, "viscaDrvClose - completed \n");

    return ((LRESULT)TRUE);
}


/****************************************************************************
 * Function: LRESULT viscaDrvFree - Respond to the DRV_FREE message.
 *                 Perform any device shutdown tasks.
 *
 * Returns: TRUE on success and FALSE on failure.
 ***************************************************************************/
static LRESULT NEAR PASCAL
viscaDrvFree(WORD wDeviceID)
{
    int i;
    int iCount = 0;

    // In NT I assume we get this immediately before our DLLEntry gets
    // called with the process detach message.

    uProcessCount--; //This is the only shared thing!

    // If a command table is loaded, then free it.
    if (uCommandTable != MCI_NO_COMMAND_TABLE)
    {
        DPF(DBG_MEM, "Freeing table=%u", uCommandTable);
        mciFreeCommandResource(uCommandTable);
        uCommandTable = (UINT)MCI_NO_COMMAND_TABLE;
    }

    if(uProcessCount > 1)
    {
        // In NT this allows us to maintain accross multiple DrvFree messages.
        DPF(DBG_ERROR, "DrvFree: uProcessCount > 1, uProcessCount=%u", uProcessCount);
        return ((LRESULT)TRUE);
    }

    for(i = 0; i < MAX_INSTANCES; i++)
    {
        if(pinst[i].fInUse)
            iCount++;
    }

    DPF(DBG_MEM, "DrvFree number of instances=%u", iCount);

    if(iCount > 1) // Auto inst is one.
    {
        // Just ignore this message.
        DPF(DBG_ERROR, "DrvFree: Instances != 1, i=%u",iCount);
        return ((LRESULT)TRUE);
    }

    // If there's a background task, then destroy it.
    //
    // Free the global auto-inst.
    //
    MemFreeInstance(pvcr->iInstBackground); //Map goes at exit time.

    if (viscaTaskIsRunning())
    {
        viscaTaskDestroy();
    }

    return ((LRESULT)TRUE);
}


/****************************************************************************
 * Function: LPSTR SkipWord - Skips first word in a string up to the second word.
 *
 * Parameters:
 *
 *      LPWSTR lpcsz - String to parse.
 *
 * Returns: pointer to first character in second word.
 ***************************************************************************/
static LPWSTR NEAR PASCAL
    SkipWord(LPWSTR lpsz)
{
    while ((*lpsz) && !IsSpace(*lpsz))
        lpsz++;

    while(IsSpace(*lpsz))
        lpsz++;

    return (lpsz);
}


/****************************************************************************
 * Function: void ParseParams - Parse port & dev. nos. from a string like "2 1".
 *
 * Parameters:
 *
 *      LPCSTR lpstrParams - String to parse.
 *
 *      UINT FAR * lpnPort - Port # to be filled in (1..4).
 *
 *      UINT FAR * lpnDevice - Device # to be filled in (1..7).
 ***************************************************************************/
static void NEAR PASCAL
ParseParams(LPCWSTR lpstrParams, UINT FAR * lpnPort, UINT FAR * lpnDevice)
{
    UINT    nPort   = DEFAULTPORT;
    UINT    nDevice = DEFAULTDEVICE;

    // Find first digit -- Port #
    while ((*lpstrParams) && (!IsDigit(*lpstrParams)))
        lpstrParams++;

    if (*lpstrParams != TEXT('\0'))
    {
        nPort = (*lpstrParams) - TEXT('0');
        lpstrParams++;
        // Find second digit -- Device #
        while ((*lpstrParams) && (!IsDigit(*lpstrParams)))
            lpstrParams++;

        if (*lpstrParams != TEXT('\0'))
            nDevice = (*lpstrParams) - TEXT('0');
    }

    if (INRANGE(nPort, 1, MAXPORTS))
        *lpnPort = nPort;
    else
        *lpnPort = DEFAULTPORT;

    if (INRANGE(nDevice, 1, MAXDEVICES))
        *lpnDevice = nDevice;
    else
        *lpnDevice = DEFAULTDEVICE;
}


/****************************************************************************
 * Function: LRESULT viscaDrvOpen - Respond to the DRV_OPEN message.  Perform any
 *     initialization which is done once each time the driver is opened.
 *
 * Parameters:
 *
 *      LPWSTR lpstrParams - NULL terminated command line string contains
 *     any characters following the filename in the SYSTEM.INI file.
 *
 *      LPMCI_OPEN_DRIVER_PARMS lpOpen - Pointer to an
 *     MCI_OPEN_DRIVER_PARMS structure with information about this device.
 *
 * Returns: zero on failure or the driver ID that should be passed
 *      to identify this device on subsequent messages.
 *
 *     In this driver, the DRV_OPEN message is used to parse the
 *     parameters string and fill in the device type and custom command
 *     table.  The OPEN_DRIVER message is MCI specific and is used to
 *     register this device with the sample device.
 ***************************************************************************/
static LRESULT NEAR PASCAL
viscaDrvOpen(LPWSTR lpstrParams, MCI_OPEN_DRIVER_PARMS FAR * lpOpen)
{
    UINT                nPort;
    UINT                nDevice;
    int                 iInst;

    // Find port and device # to use
    ParseParams(lpOpen->lpstrParams, &nPort, &nDevice);

    nPort--;
    nDevice--;

    if((nPort >= MAXPORTS) || (nDevice >= MAXDEVICES))
        return 0L;

    // Create each instances thing.
    iInst = viscaInstanceCreate(lpOpen->wDeviceID, nPort, nDevice);

    if (iInst == -1)
        return (0L);


    // If this is the first device to be openned with this driver,
    // then start backgound task and load VCR-specific command table.
    if (!viscaTaskIsRunning())
    {
        WCHAR    szTableName[16];

        if(LoadString(hModuleInstance, IDS_TABLE_NAME, szTableName, sizeof(szTableName) / sizeof(WCHAR)))
        {
            uCommandTable = mciLoadCommandResource(hModuleInstance, szTableName, 0);

            if(uCommandTable == MCI_NO_COMMAND_TABLE)
            {
                DPF(DBG_ERROR, "Failed to load command table\n");
                return 0L;  // Fail the load
            }

            DPF(DBG_MEM, "Table num=%u \n",uCommandTable);
        }

        if (!viscaTaskCreate())
        {
            DPF(DBG_ERROR, "Failed to create task.\n");
            DPF(DBG_MEM, "viscaInstanceDestroy - Freeing iInst = %d \n", iInst);
            return (0L);
        }

    }
#ifdef _WIN32
    else
    {
        WCHAR    szTableName[16];

        if(uCommandTable == MCI_NO_COMMAND_TABLE)
        {
            if(LoadString(hModuleInstance, IDS_TABLE_NAME, szTableName, sizeof(szTableName) / sizeof(WCHAR)))
            {
                uCommandTable = mciLoadCommandResource(hModuleInstance, szTableName, 0);

                if(uCommandTable == MCI_NO_COMMAND_TABLE)
                {
                    DPF(DBG_ERROR, "Failed to load command table\n");
                    return 0L;  // Fail the load
                }
                DPF(DBG_MEM, "Table num=%u \n",uCommandTable);
            }
        }
    }
#endif

    // Fill in return information
    lpOpen->wCustomCommandTable = uCommandTable;
    lpOpen->wType = MCI_DEVTYPE_VCR;   // It will now search vcr.mci for strings. (as default).

    // Kludge for EVO-9650 - forces freeze on every step if using vfw 1.0
    if (GetProfileInt(szIni, (LPWSTR) szFreezeOnStep, 0))
        pvcr->gfFreezeOnStep = TRUE;
    else
        pvcr->gfFreezeOnStep = FALSE;

    DPF(DBG_COMM, "viscaDrvOpen - completed \n");

    /* this return value will be passed in as dwDriverID in future calls. */
    return (lpOpen->wDeviceID);
}

/****************************************************************************
 * Function: void GetCmdParams - Read port & device nos. from system.ini.
 *
 * Parameters:
 *
 *      LPDRVCONFIGINFO lpdci - Pointer to driver configuration struct.
 *
 *      UINT FAR * lpnPort - Port # to be filled in (1..4).
 *
 *      UINT FAR * lpnDevice - Device # to be filled in (1..7).
 ***************************************************************************/
static void NEAR PASCAL
GetCmdParams(LPDRVCONFIGINFO lpdci, UINT FAR * lpnPort, UINT FAR * lpnDevice)
{
    WCHAR    szIniFile[FILENAME_LENGTH];
    WCHAR    szParams[MAX_INI_LENGTH];

    if (LoadString(hModuleInstance, IDS_INIFILE, szIniFile, sizeof(szIniFile)) &&
        GetPrivateProfileString(lpdci->lpszDCISectionName,
                                lpdci->lpszDCIAliasName, szNull, szParams,
                                MAX_INI_LENGTH, szIniFile))
        ParseParams(SkipWord(szParams), lpnPort, lpnDevice);
    else
        ParseParams(szNull, lpnPort, lpnDevice);

}

/****************************************************************************
 * Function: BOOL viscaWriteAllVcrs - Write all configuration to system.ini
 *
 * Parameters:
 *
 *      LPCSTR lpszSectionName - Should be [mci] for Windows 3.1
 *
 * Returns: TRUE if successful.
 *
 ***************************************************************************/
static BOOL NEAR PASCAL
viscaWriteAllVcrs(LPCWSTR lpszSectionName)
{
    int     iPort, iDev;
    WCHAR   sz[MAX_INI_LENGTH];
    WCHAR   szIniFile[FILENAME_LENGTH];
    WCHAR   szVersionName[FILENAME_LENGTH];

    DPF(DBG_CONFIG, "viscaWriteAllVcrs\n");

    if(!LoadString(hModuleInstance, IDS_VERSIONNAME, szVersionName, sizeof(szVersionName)))
        return FALSE;

    if (!LoadString(hModuleInstance, IDS_INIFILE, szIniFile, sizeof(szIniFile)))
        return FALSE;

    for (iPort = 0; iPort < MAXPORTS; iPort++)
    {
        for(iDev = 0; iDev < MAXDEVICES; iDev++)
        {
            if(pvcr->Port[iPort].Dev[iDev].szVcrName[0] != TEXT('\0'))
            {
                wsprintf((LPWSTR)sz, TEXT("%s com%u %u"), (LPWSTR)szVersionName, iPort+1, iDev+1);

                DPF(DBG_CONFIG, "Writing to ini file=%s\n", (LPWSTR)sz);

                WritePrivateProfileString((LPCTSTR)lpszSectionName,
                                    pvcr->Port[iPort].Dev[iDev].szVcrName,
                                    sz,
                                    szIniFile);
            }
        }
    }
    //
    // Write the EVO-9650 kludge out. FreezeOnStep for backwards compatability.
    //
    WriteProfileString(szIni, szFreezeOnStep,
        (pvcr->gfFreezeOnStep) ? sz1 : sz0);

    return TRUE;
}



/****************************************************************************
 * Function: BOOL viscaAllVcrs - Read or delete all configuration to system.ini
 *
 * Parameters:
 *
 *      LPCSTR lpszSectionName - Should be [mci] for Windows 3.1
 *
 *      BOOL fDelete - If TRUE delete all mcivisca, else read all configuration.
 *
 * Returns: TRUE if successful.
 *
 *
 *
 * This function is called to either:
 *      1. Get the current state of all mcivisca.drv
 *      2. Delete all mcivisca.drv entries in system.ini
 *
 *    0. Get all keys in mci section.
 *         1. Get key
 *         2. Get value
 *         3. if first string in value == mcivisca then
 *             1. get comm number
 *             2. get dev number
 *             3. write key at comm, dev.
 *
 *    1. Then done with all keys. (see viscaUpdatePort)
 *         loop for all commports.
 *         find max string.
 *         if there are any holes
 *             make a name (vcrn) (add total of vcr's on each commport).
 *             check no-one else uses it.
 *
 ***************************************************************************/
static BOOL NEAR PASCAL
viscaAllVcrs(LPCWSTR lpszSectionName, BOOL fDelete)
{
    int     iPort, iDev;
    LPWSTR  pchEntry, pchParams, pchOneString; // Pointer to step through list of entries.
    WCHAR   szOneEntry[ONEENTRY_LENGTH];     // Name of one entry.  (LHS)
    WCHAR   szOneString[ONEENTRY_LENGTH];    // String for an entry (RHS)
    WCHAR   szVersionName[FILENAME_LENGTH];
    WCHAR   szIniFile[FILENAME_LENGTH];
    int     i=0;

    if(!LoadString(hModuleInstance, IDS_INIFILE, szIniFile, sizeof(szIniFile)))
        return FALSE;

    if(!LoadString(hModuleInstance, IDS_VERSIONNAME, szVersionName, FILENAME_LENGTH))
        return FALSE;

    DPF(DBG_CONFIG, "VersionName=%s\n", (LPWSTR)szVersionName);
    //
    // Get all entry keys. (check for fail!)
    //
    GetPrivateProfileString((LPCTSTR)lpszSectionName,
                           NULL, szNull, szAllEntries,
                           ALLENTRIES_LENGTH, szIniFile);

    pchEntry = szAllEntries;

    while(*pchEntry)
    {
        //
        // Get one entry name.
        //
        for(i = 0; *pchEntry != TEXT('\0'); pchEntry++, i++)
            szOneEntry[i] = *pchEntry;
        szOneEntry[i] = TEXT('\0'); // Null terminate it.
        //
        // Get the profile string for this entry.
        //
        GetPrivateProfileString((LPCTSTR)lpszSectionName,
                           szOneEntry, szNull, szOneString,
                           ONEENTRY_LENGTH, szIniFile);
        //
        // Skip any leading spaces.
        //
        pchOneString = szOneString;
        while(*pchOneString && IsSpace(*pchOneString))
            pchOneString++;
        //
        // Strip the first word (upto space or null terminated).
        //
        for(i=0; pchOneString[i] && !IsSpace(pchOneString[i]); i++);
        if(pchOneString[i])
            pchOneString[i] = TEXT('\0'); // Null terminate the thing.

        pchParams = &(pchOneString[i+1]); //Always work with arrays instead of ptrs!
                                          //That way it is portable to NT.
        //
        // Is szOneString==mcivisca.drv?
        //
        if(lstrcmpi(pchOneString, szVersionName)==0)
        {
            if(fDelete)
            {
                // Yes it is. So delete it!
                WritePrivateProfileString((LPCTSTR)lpszSectionName,
                            szOneEntry,
                            NULL,   //NULL means DELETE!
                            szIniFile);
            }
            else
            {
                DPF(DBG_CONFIG, "OneEntry == mcivisca.drv\n");

                // Get pchParams pointing to first valid char of command line.
                while(IsSpace(*pchParams))
                    pchParams++;

                ParseParams(pchParams, &iPort, &iDev);
                iPort--;
                iDev--;
                DPF(DBG_CONFIG, "Port=%d Device=%d\n", iPort, iDev);
                //
                // Now store the name (the entry) at the default location.
                //
                if((iPort < MAXPORTS) && (iDev < MAXDEVICES))
                    lstrcpy(pvcr->Port[iPort].Dev[iDev].szVcrName, szOneEntry);
            }
        }
        else
        {
            DPF(DBG_CONFIG, "Entry=%s", (LPWSTR)szOneEntry);
        }
        //
        // Skip junk, and get to the next one.
        //
        while(*pchEntry != TEXT('\0'))
            pchEntry++;
        //
        // Ok, the next character is either null (which means the end)
        // or it is a valid character.
        //
        pchEntry++;
    }

}


/****************************************************************************
 * Function: BOOL viscaDlgUpdatePort - Called every time the commport in the configuration
 *          dialog is changed.
 *
 * Parameters:
 *
 *      HWND hDlg - Configuration dialog window.
 *
 *      int  iPort - index into vcr array corresponding to commport (commport-1).
 *
 * Returns: TRUE if successful.
 *
 ***************************************************************************/
static BOOL NEAR PASCAL
viscaDlgUpdatePort(HWND hDlg, int iPort)  // Sends new commport.
{
    int  iDev;
    int  iNumDevices    = 0;
    HWND hComboPort     = GetDlgItem(hDlg, IDD_COMBO_PORT);
    HWND hComboDevice   = GetDlgItem(hDlg, IDD_COMBO_DEVICE);
    int  i              = 0;
    int  iIndexCombo    = 0;

    DPF(DBG_CONFIG, "viscaDlgUpdatePort - setting port to %d\n", iPort);

    //
    // Reduce the index by the number of ports that don't exist
    //
    for(i=0; i<iPort; i++)
        if(pvcr->Port[i].fExists)
            iIndexCombo++;

    // Make the current settings the default
    ComboBox_SetCurSel(hComboPort, iIndexCombo); // This is the 0 relative one. (so 0==>com1)
    //
    // Get the number of devices on this serial port. (0-7) for a total num of devs.
    //
    for(iDev=0; iDev < MAXDEVICES; iDev++)
    {
        if(pvcr->Port[iPort].Dev[iDev].szVcrName[0] != TEXT('\0'))
            iNumDevices = iDev + 1;
    }

    DPF(DBG_CONFIG, "viscaDlgUpdatePort - setting number of devs to %d\n", iNumDevices);

    ComboBox_SetCurSel(hComboDevice, iNumDevices); // 0==>0, 1==>1, etc.
    pvcr->iLastNumDevs = iNumDevices;  // We assume the last is saved already on a port change.
    //
    // Now tell viscaDlgUpdateNumDevs to fill in the number of devs we have listed.
    //
    viscaDlgUpdateNumDevs(hDlg, iPort, iNumDevices);

    return TRUE;
}


/****************************************************************************
 * Function: BOOL MakeMeAGoodName - Make a name up for a vcr. Make sure it doesn't
 *      already exist in the vcr array or in the configuration dialog.
 *
 * Parameters:
 *
 *      HWND hDlg - Configuration dialog.
 *
 *      int  iPort - index into vcr array for port (commport-1).
 *
 *      int  iThisDev - index into vcr array for this device.
 *                          (daisy_chain_position - 1)
 *
 *      LPWSTR lpszNewName - return buffer with the Good Name!
 *
 * Returns: TRUE if successful.
 *
 ***************************************************************************/
static BOOL NEAR PASCAL
MakeMeAGoodName(HWND hDlg, int iPort, int iThisDev, LPWSTR lpszNewName)
{
    int     iDev         = 0;
    int     iAGoodNumber = 0;  // 0 should map to --> none.
    int     iTempPort    = 0;
    WCHAR   szAGoodTry[ONEENTRY_LENGTH];

    //
    // Read all the names into the array now! (Update any outstanding).
    //
    viscaDlgRead(hDlg, iPort);

    while(1)
    {
        if(iAGoodNumber==0)
            lstrcpy(szAGoodTry, szKeyName);
        else
            wsprintf(szAGoodTry, TEXT("%s%d"), (LPSTR)szKeyName, iAGoodNumber);

        DPF(DBG_CONFIG, "MakeMeAGoodName - Trying=%s\n", (LPWSTR)szAGoodTry);

        for(iTempPort = 0; iTempPort < MAXPORTS; iTempPort++)
        {
            for(iDev = 0; iDev < MAXDEVICES; iDev++)
            {
                if(lstrcmpi(szAGoodTry, pvcr->Port[iTempPort].Dev[iDev].szVcrName) == 0)
                    goto StartOver;
            }
        }
        break; // Success, it was not found anywhere in the table!

        StartOver:
        iAGoodNumber++;
    }
    //
    // We will eventually find a good name and end up here.!
    //
    lstrcpy(lpszNewName, szAGoodTry); //Do it up!
    // Nothing prevents a person from themselves duplicating a name?
    return TRUE;
}


/****************************************************************************
 * Function: BOOL viscaDlgUpdateNumDevs - Called when number of vcrs in configuration
 *          dialog is changed.
 *
 * Parameters:
 *
 *      HWND hDlg - Configuration dialog window.
 *
 *      int  iPort - index into vcr array corresponding to commport (commport-1).
 *
 *      int  iNumDevices - Number of vcrs selected.
 *
 * Returns: TRUE if successful.
 *
 ***************************************************************************/
static BOOL NEAR PASCAL
viscaDlgUpdateNumDevs(HWND hDlg, int iPort, int iNumDevices)  // Sends new commport.
{
    int iDev;

    DPF(DBG_CONFIG, "viscaDlgUpdateNumDevs Port=%d\n", iPort);
#ifdef DEBUG
    //
    // First set all entries to BLANKs (Clearing whats there).
    //
    for(iDev=0; iDev < MAXDEVICES; iDev++)
    {
        EnableWindow(GetDlgItem(hDlg, IDD_VCRONE + iDev), TRUE);
        SetDlgItemText(hDlg, IDD_VCRONE + iDev, (LPWSTR)szNull);
    }
#endif
    //
    // Blank out the end of the list.
    //
    for(iDev = iNumDevices; iDev < MAXDEVICES; iDev++)
        pvcr->Port[iPort].Dev[iDev].szVcrName[0] = TEXT('\0');

    //
    // If user left holes then fill them with made up names.
    //
    if(iNumDevices != 0)
    {
        for(iDev=0; iDev < iNumDevices; iDev++)
        {
            if(pvcr->Port[iPort].Dev[iDev].szVcrName[0] == TEXT('\0'))
            {
                // Make a good name here!
                MakeMeAGoodName(hDlg, iPort, iDev, (LPWSTR)pvcr->Port[iPort].Dev[iDev].szVcrName);
                DPF(DBG_CONFIG, "viscaDlgUpdateNumDevsChange - making a name at Port=%d Dev=%d\n", iPort, iDev);
            }

            DPF(DBG_CONFIG, "viscaDlgUpdateNumDevs Port=%d Dev=%d string=%s", iPort, iDev, (LPWSTR)pvcr->Port[iPort].Dev[iDev].szVcrName);

#ifdef DEBUG
            //
            // Add the names to the list box.
            //
            EnableWindow(GetDlgItem(hDlg, IDD_VCRONE + iDev), TRUE);
            SetDlgItemText(hDlg, IDD_VCRONE + iDev, (LPWSTR)pvcr->Port[iPort].Dev[iDev].szVcrName);
#endif
        }
    }
    //
    // Disable all remaining edit boxes!
    //
#ifdef DEBUG
    for(;iDev < MAXDEVICES; iDev++)
    {
       EnableWindow(GetDlgItem(hDlg, IDD_VCRONE + iDev), FALSE);
    }
#endif

    return TRUE;
}


/****************************************************************************
 * Function: BOOL viscaDlgRead - Read the configuration dialog strings into the vcr array.
 *
 * Parameters:
 *
 *      HWND hDlg - Configuration dialog window.
 *
 *      int  iPort - index into vcr array corresponding to commport (commport-1).
 *
 * Returns: TRUE if successful.
 *
 *       This is done if 1. commport changed, or 2. Ok is pressed.
 *
 ***************************************************************************/
static BOOL NEAR PASCAL
viscaDlgRead(HWND hDlg, int iPort)  // Port config to read things into.
{
    int iNumDevs = ComboBox_GetCurSel(GetDlgItem(hDlg, IDD_COMBO_DEVICE)); // 0 relative
#ifdef DEBUG
    WCHAR szTempVcrName[VCRNAME_LENGTH];
    WCHAR szFailure[MESSAGE_LENGTH];
    WCHAR szTitle[TITLE_LENGTH];
    WCHAR szMessage[MESSAGE_LENGTH];

    int iDev, i, j;

    // Read ALL, so we reset contents of potentially blanked ones.
    for(iDev = 0; iDev < MAXDEVICES; iDev++)
    {
        GetDlgItemText(hDlg, IDD_VCRONE+iDev, (LPWSTR)szTempVcrName, VCRNAME_LENGTH - 1);

        i = 0;

        while((szTempVcrName[i] != TEXT('\0')) && !IsAlphaNumeric(szTempVcrName[i]))
            i++;

        if(IsDigit(szTempVcrName[i]))
        {
            if(LoadString(hModuleInstance, IDS_CONFIG_ERR, szMessage, sizeof(szMessage) / sizeof(WCHAR)))
                if(LoadString(hModuleInstance, IDS_CONFIG_ERR_ILLEGALNAME, szTitle, sizeof(szTitle) / sizeof(WCHAR)))
                {
                    wsprintf((LPWSTR)szFailure, (LPWSTR)szMessage, (LPWSTR)szTempVcrName);
                    MessageBox(hDlg, (LPWSTR)szFailure, (LPWSTR)szTitle, MB_OK);
                    return FALSE;
                }

        }

        j = 0;
        while((szTempVcrName[i] != TEXT('\0')) && IsAlphaNumeric(szTempVcrName[i]))
        {
            pvcr->Port[iPort].Dev[iDev].szVcrName[j] = szTempVcrName[i];
            j++;
            i++;
        }
        pvcr->Port[iPort].Dev[iDev].szVcrName[j] = TEXT('\0');
    }
#endif
    return TRUE;
}


/****************************************************************************
 * Function: BOOL viscaCheckTotalEntries - Make sure there is at least one entry!
 *          0 is bad because then all mcivisca.drv will be removed from
 *          system.ini which means it won't appear in the drivers configuration
 *          list box.
 *
 * Parameters:
 *
 *      HWND hDlg - Configuration dialog window.
 *
 * Returns: TRUE if there is more than 0 enties.
 *
 ***************************************************************************/
static BOOL NEAR PASCAL
viscaCheckTotalEntries(HWND hDlg)
{
    int iPort, iDev;
    int iHitCount = 0;
    WCHAR szTitle[TITLE_LENGTH];
    WCHAR szMessage[MESSAGE_LENGTH];

    for(iPort = 0; iPort < MAXPORTS; iPort++)
    {
        for(iDev = 0; iDev < MAXDEVICES; iDev++)
        {
            if(pvcr->Port[iPort].Dev[iDev].szVcrName[0] != TEXT('\0'))
                iHitCount++;
        }
    }

    if(iHitCount > 0)
        return TRUE;

    DPF(DBG_CONFIG, "viscaCheckTotalEntries HitCount==0");

    if(LoadString(hModuleInstance, IDS_CONFIG_WARN_LASTVCR, szMessage, sizeof(szMessage) / sizeof(WCHAR)))
    {
        if(LoadString(hModuleInstance, IDS_CONFIG_WARN, szTitle, sizeof(szTitle) / sizeof(WCHAR)))
        {
            if(MessageBox(hDlg, (LPWSTR)szMessage, (LPWSTR)szTitle, MB_YESNO) == IDYES)
                return TRUE;
            else
                return FALSE;
        }
    }
}


/****************************************************************************
 * Function: BOOL viscaIsCommPort - Determines if the commport hardware exists.
 *
 * Parameters:
 *
 *      LPSTR lpstrCommPort  - String describing the commport.
 *
 * Returns: TRUE if the commport hardware exists.
 *
 ***************************************************************************/
static BOOL NEAR PASCAL
viscaIsCommPort(LPWSTR lpstrCommPort)
{
    VISCACOMMHANDLE iCommId;
#ifdef _WIN32
    iCommId = CreateFile(lpstrCommPort, GENERIC_READ | GENERIC_WRITE,
                            0,              // exclusive access
                            NULL,           // no security
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL, // | FILE_FLAG_OVERLAPPED
                            NULL);

    if(iCommId==INVALID_HANDLE_VALUE)
        return FALSE;

    if(iCommId != NULL)
        CloseHandle(iCommId);
    return TRUE;
#else
    if((iCommId = OpenComm(lpstrCommPort, 1, 1)) == IE_HARDWARE)
    {
        return FALSE;
    }
    else if(iCommId < 0)
    {
        return TRUE; // Okay maybe it will open later.
    }
    else
    {
        // Good commport Close and return true.
        CloseComm(iCommId);
        return TRUE;
    }
#endif
}


/****************************************************************************
 * Function: BOOL viscaConfigDlgInit - Perform initialization of configuration
 *              dialog box in response to the WM_INITDIALOG message.
 *
 * Parameters:
 *
 *      HWND hDlg - Handle to dialog window.
 *
 *      HWND hwndFocus - Handle to first control that can be given focus.
 *
 *      LPARAM lParam - Pointer to driver configuration
 *                         sturcture.
 *
 * Returns: TRUE if successful, otherwise FALSE.
 ***************************************************************************/
static BOOL NEAR PASCAL
viscaConfigDlgInit(HWND hDlg, HWND hwndFocus, LPARAM lParam)
{
    UINT    nPort;
    UINT    nDevice;
    HWND    hComboPort;
    HWND    hComboDevice;
    WCHAR   szText[PORT_LENGTH];
    int     iPort, iDev;
    int     i;

    // fill in port combo box
    hComboPort = GetDlgItem(hDlg, IDD_COMBO_PORT);
    if (hComboPort == NULL) {
        return (FALSE);
    }
    ComboBox_ResetContent(hComboPort);
    for (nPort = 0; nPort < MAXPORTS; nPort++)
    {
        LoadString(hModuleInstance, IDS_COM1 + nPort, szText, sizeof(szText));
        pvcr->Port[nPort].fExists = FALSE;

        if(pvcr->Port[nPort].nUsage > 0)   // Open and in use right now by a vcr.
             pvcr->Port[nPort].fExists = TRUE;
        else if(viscaIsCommPort(szText))
             pvcr->Port[nPort].fExists = TRUE;

        if(pvcr->Port[nPort].fExists)
            ComboBox_AddString(hComboPort, szText);
    }

    // fill in device combo box
    hComboDevice = GetDlgItem(hDlg, IDD_COMBO_DEVICE);
    if (hComboDevice == NULL)
        return (FALSE);

    // This combo box is now the number of devices, not the device.

    ComboBox_ResetContent(hComboDevice);
    for (nDevice = 0; nDevice <= MAXDEVICES; nDevice++)
    {
        wsprintf(szText, TEXT("%d"), nDevice);
        ComboBox_AddString(hComboDevice, szText);
    }
    lstrcpy(szKeyName, ((LPDRVCONFIGINFO)lParam)->lpszDCIAliasName);
    for(i=0; i < lstrlen(szKeyName); i++)
        if(!IsAlpha(szKeyName[i]))
            szKeyName[i] = TEXT('\0');  // If vcr1 comes in, cut key to vcr
                                        // otherwise when we make names it will all be vcr11, etc.
    //
    // Initialize the VCR table if we are going to read (not on delete).
    //
    for (iPort = 0; iPort < MAXPORTS; iPort++)
    {
        for(iDev = 0; iDev < MAXDEVICES; iDev++)
            pvcr->Port[iPort].Dev[iDev].szVcrName[0] = TEXT('\0');
    }
    //
    // Read the entry names into the Vcr array.
    //
    viscaAllVcrs(((LPDRVCONFIGINFO)lParam)->lpszDCISectionName, FALSE); // Do not delete; read!
    //
    // Some user might have deleted the first entry so check for all.
    //
    for(nPort = 0; nPort < MAXPORTS; nPort++)
    {
        if(!pvcr->Port[nPort].fExists)
        {
            for(nDevice = 0; nDevice < MAXDEVICES; nDevice++)
                pvcr->Port[nPort].Dev[nDevice].szVcrName[0] = TEXT('\0');
        }
        else
        {
            for(nDevice = 0; nDevice < MAXDEVICES; nDevice++)
            {
                if(pvcr->Port[nPort].Dev[nDevice].szVcrName[0] != TEXT('\0'))
                    goto OutOfLoops;
            }
        }
    }

    OutOfLoops:

    if(nPort == MAXPORTS)  // If Max, start with first port that exists.
    {
        for(nPort=0; !pvcr->Port[nPort].fExists && (nPort < MAXPORTS); nPort++);
    }

    if(nPort == MAXPORTS)   // No serial ports exist!!! Error.
        return FALSE;
    //
    // Show the current port and device selection.
    //
    viscaDlgUpdatePort(hDlg, nPort);

    return (TRUE);
}


/****************************************************************************
 * Function: BOOL viscaIsDoubleOnPort - Determines if any of the names appearing
 *          in the 1..7 part of the configuration dialog box is repeated anywhere
 *          in the entire vcr array.
 *
 * Parameters:
 *
 *      HWND hDlg - Configuration dialog window.
 *
 *      int  iPort - index into vcr array corresponding to commport (commport-1).
 *
 * Returns: TRUE if there is at least one repeated name.
 *
 ***************************************************************************/
static BOOL NEAR PASCAL
viscaIsDoubleOnPort(HWND hDlg, int iPort)
{
#ifdef DEBUG
    WCHAR   szTitle[TITLE_LENGTH];
    WCHAR   szMessage[MESSAGE_LENGTH];
    WCHAR   szCheck[VCRNAME_LENGTH];
    WCHAR   szDoubleFailure[MESSAGE_LENGTH];
    int     iDev;
    int     iOtherPort, iOtherDev;
    int     iNumHits;
    int     iNumDevs;
    //
    // Read any outstanding text now. (if bad names, fail here).
    //
#else
    if(!viscaDlgRead(hDlg, iPort))
        return TRUE; // True means something bad happened.
#endif

#ifdef DEBUG

    iNumDevs = ComboBox_GetCurSel(GetDlgItem(hDlg, IDD_COMBO_DEVICE));
    //
    // Loop through all devices listed on this port.
    //
    for(iDev=0; iDev < iNumDevs; iDev++)
    {
        GetDlgItemText(hDlg, IDD_VCRONE+iDev, (LPWSTR) szCheck, VCRNAME_LENGTH - 1);

        iNumHits = 0;
        //
        // Loop through all devices on all ports.
        //
        for(iOtherPort=0; iOtherPort < MAXPORTS; iOtherPort++)
            for(iOtherDev=0; iOtherDev < MAXDEVICES; iOtherDev++)
                if(lstrcmpi((LPWSTR)szCheck, (LPWSTR) pvcr->Port[iOtherPort].Dev[iOtherDev].szVcrName)==0)
                    iNumHits++;

        if(iNumHits > 1)
        {
            DPF(DBG_CONFIG, "viscaIsDoubleOnPort - szDoubleName=%s", (LPWSTR)szCheck);

            if(LoadString(hModuleInstance, IDS_CONFIG_ERR_REPEATNAME, szMessage, sizeof(szMessage) / sizeof(WCHAR)))
            {
                if(LoadString(hModuleInstance, IDS_CONFIG_ERR, szTitle, sizeof(szTitle) / sizeof(WCHAR)))
                {
                    wsprintf((LPWSTR)szDoubleFailure, (LPWSTR)szMessage, (LPWSTR)szCheck);
                    MessageBox(hDlg, (LPWSTR)szDoubleFailure, (LPWSTR)szTitle, MB_OK);
                    return TRUE;
                }
            }
        }
    }
#endif
    return FALSE; //No doubles on this port.
}


/****************************************************************************
 * Function: int viscaComboGetPort - Get the selected port from the combo box.
 *
 * Parameters:
 *
 *      HWND hDlg - Configuration dialog window.
 *
 * Returns: index into vcr array (commport - 1) if successful, otherwise < 0.
 *
 ***************************************************************************/
static int NEAR PASCAL
viscaComboGetPort(HWND hDlg)
{
    int     iIndexCombo = ComboBox_GetCurSel(GetDlgItem(hDlg, IDD_COMBO_PORT));
    int     iExistingCount, i;

    DPF(DBG_CONFIG, "viscaComboGetPort - called.\n");

    DPF(DBG_CONFIG, "viscaComboGetPort - iIndexCombo = %d \n", iIndexCombo);

    //
    // Find the nth (indexcombo) existing port.
    //

    for(iExistingCount=0, i=0; (iExistingCount <= iIndexCombo) && (i < MAXPORTS); i++)
    {
        if(pvcr->Port[i].fExists)
            iExistingCount++;
    }

    if(iExistingCount <= iIndexCombo) //We ran out of ports (can't check max, because it can come true at same time).
        i = 1; //Just set to the first possible commport (not possible).

    DPF(DBG_CONFIG, "viscaComboGetPort - iPort = %d\n", i - 1);

    return i - 1;

}


/****************************************************************************
 * Function: void viscaConfigDlgCommand - Process the WM_COMMAND message for
 *              the configuration dialog box.
 *
 * Parameters:
 *
 *      HWND hDlg - Handle to dialog window.
 *
 *      int id - Identifier of control.
 *
 *      HWND hwndCtl - Handle to control sending the message.
 *
 *      UINT codeNotify - Notification message.
 *
 *
 *  If commport changed,
 *      1. send last commport to read
 *      2. send commport change to updatecommport.
 *
 *  If number of devices changed
 *      1. send commport to updatenumberdevices.
 *
 ***************************************************************************/
static void NEAR PASCAL
viscaConfigDlgCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(id)
    {
        case IDDETECT:
        {
            int iPort    = viscaComboGetPort(hDlg);
            int iNumDevs = 0;

            if(pvcr->Port[iPort].nUsage > 0)
                iNumDevs     = pvcr->Port[iPort].nDevices;
            else {
                HCURSOR    hc;

                hc = SetCursor((HCURSOR)IDC_WAIT);
                iNumDevs     = viscaDetectOnCommPort(iPort);
                SetCursor(hc);
            }

            // On error set the number to 0.
            if(iNumDevs < 0)
                iNumDevs = 0;

            ComboBox_SetCurSel(GetDlgItem(hDlg, IDD_COMBO_DEVICE), iNumDevs); // 0==>0, 1==>1, etc.
            viscaDlgUpdateNumDevs(hDlg, iPort, iNumDevs);
            pvcr->iLastNumDevs = iNumDevs;
        }
        break;

        case IDOK:
        {
            //
            // IsDouble will read all the entries, so don't worry.
            //
            if(!viscaIsDoubleOnPort(hDlg, pvcr->iLastPort))
            {
                if(viscaCheckTotalEntries(hDlg)) //Check if there is at least one.
                    EndDialog(hDlg, TRUE);
            }
        }
            break;

        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;

        case IDD_COMBO_DEVICE:
            if(codeNotify == CBN_SELCHANGE)
            {
                int iNumDevs = ComboBox_GetCurSel(GetDlgItem(hDlg, IDD_COMBO_DEVICE));
                int iPort    = viscaComboGetPort(hDlg); //Array index

                if(iNumDevs != pvcr->iLastNumDevs)
                {
                    // No nead to read the dlg now!
                    viscaDlgUpdateNumDevs(hDlg, iPort, iNumDevs);
                    pvcr->iLastNumDevs = iNumDevs;

                }

            }
            break;

        case IDD_COMBO_PORT:
            if(codeNotify == CBN_SELCHANGE)
            {
                int iPort = viscaComboGetPort(hDlg); //Array index.
                //
                // viscaIsDoubleOnPort will read all the entries, so don't worry.
                //
                if(viscaIsDoubleOnPort(hDlg, pvcr->iLastPort))
                {
                    viscaDlgUpdatePort(hDlg, pvcr->iLastPort);  // Will set port back correctly.
                }
                else
                {
                    if(iPort != pvcr->iLastPort)
                    {
                        viscaDlgUpdatePort(hDlg, iPort);
                        pvcr->iLastPort = iPort;
                    }
                }
            }
            break;
    }
}


/****************************************************************************
 * Function: BOOL viscaConfigDlgProc - Dialog function for configuration dialog.
 *
 * Parameters:
 *
 *      HWND hDlg - Handle to dialog window.
 *
 *      UINT uMsg - Windows message.
 *
 *      WPARAM wParam - First message-specific parameter.
 *
 *      LPARAM lParam - Second message-specific parameter.
 *
 * Returns: TRUE if message was processed, otherwise FALSE.
 ***************************************************************************/
#if (WINVER >= 0x0400)
const static DWORD aHelpIds[] = {  // Context Help IDs
    IDD_COMBO_PORT,                 IDH_MCI_VISCA_COMM,
    IDD_STATIC_PORT,                IDH_MCI_VISCA_COMM,
    IDD_COMBO_DEVICE,               IDH_MCI_VISCA_VCR,
    IDD_STATIC_NUMVCRS,             IDH_MCI_VISCA_VCR,
    IDDETECT,                       IDH_MCI_VISCA_DETECT,

    0, 0
};

static const char cszHelpFile[] = "MMDRV.HLP";
#endif

BOOL CALLBACK LOADDS
viscaConfigDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
        case WM_INITDIALOG:
            return (BOOL)HANDLE_WM_INITDIALOG(hDlg, wParam, lParam,
                                              viscaConfigDlgInit);

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hDlg, wParam, lParam, viscaConfigDlgCommand);
            return (FALSE);

#if (WINVER >= 0x0400)
        case WM_CONTEXTMENU:
            WinHelp ((HWND) wParam, (LPSTR)cszHelpFile, HELP_CONTEXTMENU,
                    (DWORD) (LPSTR) aHelpIds);
            return TRUE;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lParam;
            WinHelp (lphi->hItemHandle, (LPSTR)cszHelpFile, HELP_WM_HELP,
                    (DWORD) (LPSTR) aHelpIds);
            return TRUE;
        }
#endif

    }

    return (FALSE);
}


/****************************************************************************
 * Function: LRESULT viscaConfig - User configuration.
 *
 * Parameters:
 *
 *      HWND hwndParent - Window to use as parent of configuration dialog.
 *
 *      LPDRVCONFIGINFO lpConfig - Config data.
 *
 *      HINSTANCE hInstance - Instance handle of module.
 *
 * Returns: the result of DialogBoxParam().
 ***************************************************************************/
static LRESULT NEAR PASCAL
viscaConfig(HWND hwndParent, LPDRVCONFIGINFO lpConfig, HINSTANCE hInstance)
{
    int iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_VISCACNFG),
                hwndParent, (DLGPROC)viscaConfigDlgProc, (DWORD)lpConfig);

    if(iResult)
    {
        viscaAllVcrs(lpConfig->lpszDCISectionName, TRUE); // Delete.
        viscaWriteAllVcrs(lpConfig->lpszDCISectionName);
    }

    return (DRV_OK);
}


/****************************************************************************
 * Function: LRESULT viscaRemove - Respond to DRV_REMOVE message.
 *
 * Parameters:
 *
 *      HDRVR hDriver - Handle to driver being removed.
 *
 * Returns: TRUE on success, otherwise FALSE.
 ***************************************************************************/
static LRESULT NEAR PASCAL
viscaRemove(HDRVR hDriver)
{
    return ((LRESULT)TRUE);
}


/****************************************************************************
 * Function: int viscaDetectOnCommPort - Detect the number of VCRs on this commport.
 *
 * Parameters:
 *
 *      int  iPort - index into vcr array of port. (commport - 1).
 *
 * Returns: Number of VCRs (can be 0) or -1 for error.
 *
 ***************************************************************************/
static int NEAR PASCAL
viscaDetectOnCommPort(int iPort)
{
    BYTE    achPacket[MAXPACKETLENGTH];
    DWORD   dwErr;
    int     iInst;
    int     iDev = 0; //We will call ourselves the first device on the serial port.

    pvcr->fConfigure = TRUE;    // This also acks to synchronize

    iInst = viscaInstanceCreate(0, iPort, iDev); //0 means don't use MCI
    if (iInst == -1)
        return -1;

    if (!viscaTaskIsRunning())
    {
        if (!viscaTaskCreate())
        {
            DPF(DBG_ERROR, "Failed to create task.\n");
            viscaInstanceDestroy(iInst);
            return -1;
        }
    }
    //
    // Global handles are created immediately when the task starts up.
    //
    DuplicateGlobalHandlesToInstance(pvcr->htaskCommNotifyHandler, iInst);  // Always do this immediately.
    //
    // Okay, open the port.
    //
    viscaTaskDo(iInst, TASKOPENCOMM, iPort + 1, 0);
    if(pvcr->Port[iPort].idComDev < 0)
    {
        viscaInstanceDestroy(iInst);
        return -1;
    }
    DuplicatePortHandlesToInstance(pvcr->htaskCommNotifyHandler, iPort, iInst);
    //
    // Open the device.
    //
    viscaTaskDo(iInst, TASKOPENDEVICE, iPort, iDev);
    DuplicateDeviceHandlesToInstance(pvcr->htaskCommNotifyHandler, iPort, iDev, iInst);
    //
    // We have the green light to begin sending commands.
    //
    pvcr->Port[iPort].Dev[iDev].fDeviceOk = TRUE;
    //
    // There is no completion on non-broadcasted! (so who releases it?)
    //
    dwErr = viscaDoImmediateCommand(iInst, BROADCASTADDRESS,
                        achPacket,
                        viscaMessageIF_Address(achPacket + 1));
    if (dwErr)
    {
        viscaTaskDo(iInst, TASKCLOSECOMM, iPort + 1, 0); //Porthandles destroyed.
        viscaTaskDo(iInst, TASKCLOSEDEVICE, iPort, iDev); //Porthandles destroyed.
        viscaInstanceDestroy(iInst);
        return 0; //No devices.
    }

    viscaTaskDo(iInst, TASKCLOSECOMM, iPort + 1, 0); //Porthandles destroyed.
    viscaTaskDo(iInst, TASKCLOSEDEVICE, iPort, iDev); //Porthandles destroyed.

    viscaInstanceDestroy(iInst);

    pvcr->fConfigure = FALSE;

    DPF(DBG_CONFIG, "viscaDetectOnCommPort --> detect %d", (int)(BYTE)achPacket[2] - 1);

    return (int)(BYTE)achPacket[2] - 1; // -1 for the computer.
}



/***************************************************************************
 * Function: LONG DriverProc - Windows driver entry point.  All Windows driver
 *     control messages and all MCI messages pass through this entry point.
 *
 * Parameters:
 *
 *      DWORD dwDriverId - For most messages, <p dwDriverId> is the DWORD
 *     value that the driver returns in response to a <m DRV_OPEN> message.
 *     Each time that the driver is opened, through the <f DrvOpen> API,
 *     the driver receives a <m DRV_OPEN> message and can return an
 *     arbitrary, non-zero value. The installable driver interface
 *     saves this value and returns a unique driver handle to the
 *     application. Whenever the application sends a message to the
 *     driver using the driver handle, the interface routes the message
 *     to this entry point and passes the corresponding <p dwDriverId>.
 *     This mechanism allows the driver to use the same or different
 *     identifiers for multiple opens but ensures that driver handles
 *     are unique at the application interface layer.
 *
 *     The following messages are not related to a particular open
 *     instance of the driver. For these messages, the dwDriverId
 *     will always be zero.
 *
 *         DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
 *
 *      HDRVR  hDriver - This is the handle returned to the
 *     application by the driver interface.
 *
 *      UINT uMessage - The requested action to be performed. Message
 *     values below <m DRV_RESERVED> are used for globally defined messages.
 *     Message values from <m DRV_RESERVED> to <m DRV_USER> are used for
 *     defined driver protocols.  Messages above <m DRV_USER> are used
 *     for driver specific messages.
 *
 *      LPARAM lParam1 - Data for this message.  Defined separately for
 *     each message
 *
 *      LPARAM lParam2 - Data for this message.  Defined separately for
 *     each message
 *
 * Returns: Defined separately for each message.
 ***************************************************************************/
LRESULT CALLBACK LOADDS
DriverProc(DWORD dwDriverID, HDRVR hDriver, UINT uMessage, LPARAM lParam1, LPARAM lParam2)
{
    switch (uMessage) {

        case DRV_LOAD:
            /* the DRV_LOAD message is received once, when the driver is */
            /* first loaded - any one-time initialization code goes here */
            return (viscaDrvLoad());

        case DRV_FREE:
            /* the DRV_FREE message is received once when the driver is */
            /* unloaded - any final shut down code goes here */
            return (viscaDrvFree(LOWORD(dwDriverID)));

        case DRV_OPEN:
            /* the DRV_OPEN message is received once for each MCI device open */
            if (lParam2) {                  // normal open
                return (viscaDrvOpen((LPWSTR)lParam1,
                        (LPMCI_OPEN_DRIVER_PARMS)lParam2));
            }
            else {                                  // configuration open
                return (0x00010000);
            }

        case DRV_CLOSE:
            /* this message is received once for each MCI device close */
            return (viscaDrvClose(LOWORD(dwDriverID)));

        case DRV_QUERYCONFIGURE:
            /* the DRV_QUERYCONFIGURE message is used to determine if the */
            /* DRV_CONCIGURE message is supported - return 1 to indicate */
            /* configuration is supported */
            return (1L);

        case DRV_CONFIGURE:
            /* the DRV_CONFIGURE message instructs the device to perform */
            /* device configuration. */
            if (lParam2 && lParam1 &&
                (((LPDRVCONFIGINFO)lParam2)->dwDCISize == sizeof(DRVCONFIGINFO)))
            {
                return (viscaConfig((HWND)WINWORD(lParam1), (LPDRVCONFIGINFO)lParam2, hModuleInstance));
            }
            break;

        case DRV_REMOVE:
            /* the DRV_REMOVE message informs the driver that it is being removed */
            /* from the system */
            return (viscaRemove(hDriver));

        default:
            /* all other messages are processed here */

            /* select messages in the MCI range */
            if ((!HIWORD(dwDriverID)) && (uMessage >= DRV_MCI_FIRST) &&
                (uMessage <= DRV_MCI_LAST))
            {
                return (viscaMciProc(LOWORD(dwDriverID), (WORD)uMessage, lParam1, lParam2));
            }
            else
            {
                /* other messages get default processing */
                return (DefDriverProc(dwDriverID, hDriver, uMessage, lParam1, lParam2));
            }
    }
    return (0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\mcivisca\mcidelay.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992-1995 Microsoft Corporation
 * 
 *  MCIDELAY.C
 *
 *  MCI ViSCA Device Driver
 *
 *  Description:
 *
 *      MCI command procedures for delayed commands.
 *
 ***************************************************************************/

#define  UNICODE
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include "appport.h"
#include <mmddk.h>
#include <stdlib.h>
#include <string.h>
#include "vcr.h"
#include "viscadef.h"
#include "mcivisca.h"
#include "viscamsg.h"
#include "common.h"            

#define NO_LENGTH   0xFFFFFFFF              // Invalid length 

// In muldiv.asm 
extern DWORD FAR PASCAL muldiv32(DWORD, DWORD, DWORD);
extern BOOL  FAR PASCAL viscaPacketProcess(UINT iPort, LPSTR lpstrPacket);

//
// Forward references to non-exported functions 
//
static DWORD NEAR PASCAL viscaSeekTo(int iInst, DWORD dwFlags, LPMCI_VCR_SEEK_PARMS lpSeek);
static DWORD NEAR PASCAL viscaMciPlay(int iInst, DWORD dwFlags, LPMCI_VCR_PLAY_PARMS lpPlay);
static DWORD NEAR PASCAL viscaMciRecord(int iInst, DWORD dwFlags, LPMCI_VCR_RECORD_PARMS lpRecord);
static UINT  NEAR PASCAL viscaQueueLength(int iInst);

static DWORD NEAR PASCAL viscaQueueCommand(int iInst,
                                            BYTE  bDest,
                                            UINT  uViscaCmd,
                                            LPSTR lpstrPacket,
                                            UINT cbMessageLength,
                                            UINT  uLoopCount);

static BOOL  NEAR PASCAL viscaCommandCancel(int iInst, DWORD dwReason);
static int   NEAR PASCAL viscaDelayedCommandSocket(int iInst);
static DWORD NEAR PASCAL viscaDoQueued(int iInst, UINT uMciCmd, DWORD dwFlags, HWND hWndCallback);
static DWORD NEAR PASCAL viscaVerifyPosition(int iinst, DWORD dwTo);


/****************************************************************************
 * Function: int viscaDelayedCommandSocket - Delayed command 
 *
 * Parameters:
 *
 *      int iInst - Instance to check for.
 *
 * Returns: a socket number.
 *
 *       This checks if instance has any delayed commands.
 *       
 ***************************************************************************/
static int NEAR PASCAL viscaDelayedCommandSocket(int iInst)
{
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;
    int     iSocket = -1;

    if(pvcr->Port[iPort].Dev[iDev].iInstTransport == iInst)
        iSocket = pvcr->Port[iPort].Dev[iDev].iTransportSocket;

    return iSocket;
}

/****************************************************************************
 * Function: WORD viscaDelayedCommand - Is there a delayed command running on this device.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 * Visca c:ode for current running command.
 *
 *       Returns the current running visca command.
 *       
 ***************************************************************************/
WORD FAR PASCAL viscaDelayedCommand(int iInst)
{
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;
    UINT    uViscaCmd = 0;

    if(pvcr->Port[iPort].Dev[iDev].iInstTransport != -1)
    {
        int iSocket = pvcr->Port[iPort].Dev[iDev].iTransportSocket;

        if(iSocket != -1)
            // Return the current running command 
            uViscaCmd = pvcr->Port[iPort].Dev[iDev].wTransportCmd;
    }
    return uViscaCmd;
}

/****************************************************************************
 * Function: BOOL viscaRemovedDelayedCommand -  This function is called only at exit time.
 *              So notify abort if there are running commands.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 * TRUE - :command removed ok.
 *
 *       Only remove command if we are the instance that started it.
 *
 ***************************************************************************/
BOOL FAR PASCAL viscaRemoveDelayedCommand(int iInst)
{
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;

    //
    // Wait until we can positively determine if this device is running a async command.
    // We won't know until the ack. (when the fTxLock is released).
    //
    if(viscaWaitForSingleObject(pinst[iInst].pfTxLock, FALSE, INFINITE, (UINT)0))
    {
        //
        // Is this instance (which is closing) running any transport comamnds?
        //
        if(pvcr->Port[iPort].Dev[iDev].iInstTransport == iInst)
        {
            // Actually it would be appropriate to notify_superseded, because command continues!
            if(pinst[iInst].hwndNotify != (HWND)NULL)
            {
                mciDriverNotify(pinst[iInst].hwndNotify, pinst[iInst].uDeviceID, MCI_NOTIFY_ABORTED);
                pinst[iInst].hwndNotify = (HWND)NULL;
            }
            //
            // Transfer control of this command to the auto-device instance.
            //
            pvcr->Port[iPort].Dev[iDev].iInstTransport = pvcr->iInstBackground;
            //
            // Now we must release the Mutex and Give it to background task!
            //

        }

    }
    viscaReleaseSemaphore(pinst[iInst].pfTxLock);
    return TRUE;
}


/****************************************************************************
 * Function: DWORD viscaMciSignal - This function sets signals.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_SIGNAL_PARMS lpSeek - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_SIGNAL
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciSignal(int iInst, DWORD dwFlags, LPMCI_VCR_SIGNAL_PARMS lpSignal)
{
    return (viscaNotifyReturn(iInst, (HWND) lpSignal->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_UNSUPPORTED_FUNCTION));
}

/****************************************************************************
 * Function: DWORD viscaMciSeek - Seek.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_SEEK_PARMS lpSeek - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_SEEK
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciSeek(int iInst, DWORD dwFlags, LPMCI_VCR_SEEK_PARMS lpSeek)
{
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    DWORD   dwReply;

    //
    // Seeking to and a reverse parameter are incompatible 
    //
    if ((dwFlags & MCI_TO) && (dwFlags & MCI_VCR_SEEK_REVERSE))
        return (viscaNotifyReturn(iInst, (HWND) lpSeek->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

    if( ((dwFlags & MCI_SEEK_TO_START) || (dwFlags & MCI_SEEK_TO_END)) &&
        (dwFlags & MCI_VCR_SEEK_REVERSE))
         return MCIERR_FLAGS_NOT_COMPATIBLE;

    if(! ( (dwFlags & MCI_TO) || (dwFlags & MCI_SEEK_TO_START) ||
        (dwFlags & MCI_SEEK_TO_END) || (dwFlags & MCI_VCR_SEEK_MARK)))
        return (viscaNotifyReturn(iInst, (HWND) lpSeek->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_MISSING_PARAMETER));

    if(dwFlags & MCI_TO)
    {
        dwReply = viscaVerifyPosition(iInst, lpSeek->dwTo);
        if(dwReply != MCIERR_NO_ERROR)
            return (viscaNotifyReturn(iInst, (HWND) lpSeek->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, dwReply));
    }

    if(dwFlags & MCI_TEST)
        return(viscaNotifyReturn(iInst, (HWND) lpSeek->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

    pvcr->Port[iPort].Dev[iDev].wMciCued = 0;

    if( (viscaDelayedCommand(iInst) == VISCA_SEEK)          &&
        (
            ((dwFlags & MCI_TO) && (pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags & MCI_TO) &&
            (pvcr->Port[iPort].Dev[iDev].mciLastCmd.parm.mciSeek.dwTo == lpSeek->dwTo))                             ||
            ((pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags & MCI_SEEK_TO_START) && (dwFlags & MCI_SEEK_TO_START)) ||
            ((pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags & MCI_SEEK_TO_END) && (dwFlags & MCI_SEEK_TO_END))
        ))
    {
        if(dwFlags & MCI_NOTIFY)
            viscaQueueReset(iInst, MCI_PLAY, MCI_NOTIFY_SUPERSEDED);
        else
            return MCIERR_NO_ERROR;

        DPF(DBG_QUEUE, "///Play interrupt reason. == MCI_NOTIFY_SUPERSEDED\n");
    }
    else
    {
        viscaQueueReset(iInst, MCI_PLAY, MCI_NOTIFY_ABORTED);
        DPF(DBG_QUEUE, "///Play interrupt reason. == MCI_NOTIFY_ABORTED\n");
    }

    //
    // Save info for a possible pause and resume 
    //
    pvcr->Port[iPort].Dev[iDev].mciLastCmd.uMciCmd         = MCI_SEEK;
    pvcr->Port[iPort].Dev[iDev].mciLastCmd.iInstCmd        = iInst;
    pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags         = dwFlags;
    pvcr->Port[iPort].Dev[iDev].mciLastCmd.parm.mciSeek    = *lpSeek;

    //  This cannot fail.
    dwReply = viscaSeekTo(iInst, dwFlags, lpSeek);

    return(viscaDoQueued(iInst, MCI_SEEK, dwFlags, (HWND)lpSeek->dwCallback));
}


/*
 * Verify to position before we use it.
 */
static DWORD NEAR PASCAL viscaVerifyPosition(int iInst, DWORD dwTo)
{
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    DWORD   dwReply;
    char    achTarget[MAXPACKETLENGTH];
    BYTE    bDataFormat;

    if(pvcr->Port[iPort].Dev[iDev].bTimeType == VISCAABSOLUTECOUNTER)
        bDataFormat = (BYTE) VISCADATATIMECODENDF;
    else
        bDataFormat = (BYTE) pvcr->Port[iPort].Dev[iDev].bRelativeType;
 
    dwReply = viscaMciTimeFormatToViscaData(iInst, (BOOL) TRUE, dwTo, (LPSTR) achTarget, bDataFormat);

    // This should NOT occur NOW, it should have been caught already!
    return dwReply;
}
 

/****************************************************************************
 * Function: DWORD viscaSeekTo - Stop at a specific position.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwMCIStopPos - Position at which to stop, in the current
 *               MCI time format.
 *
 *      BOOL fReverse - Is the tape currently going backwards.
 *
 *      BOOL fWait - Should the function wait for the VCR to stop.
 *
 * Returns: an MCI error code.
 *
 *       This function is called by viscaMciPlay and viscaMciRecord
 *       when they are called with the MCI_TO flag.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaSeekTo(int iInst, DWORD dwFlags, LPMCI_VCR_SEEK_PARMS lpSeek)
{
    char    achPacket[MAXPACKETLENGTH];
    char    achTarget[MAXPACKETLENGTH];
    DWORD   dwReply;
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    UINT    cb;
    BOOL    fDone   = FALSE;
    BYTE    bDataFormat;

    if(dwFlags & MCI_TO)
    {
        if(pvcr->Port[iPort].Dev[iDev].bTimeType == VISCAABSOLUTECOUNTER)
            bDataFormat = (BYTE) VISCADATATIMECODENDF;
        else
            bDataFormat = (BYTE) pvcr->Port[iPort].Dev[iDev].bRelativeType;
 
        dwReply = viscaMciTimeFormatToViscaData(iInst, (BOOL) TRUE, lpSeek->dwTo, (LPSTR) achTarget, bDataFormat);

        // This should NOT occur NOW, it should have been caught already!

        if(dwReply != MCIERR_NO_ERROR)
            return dwReply;

        cb = viscaMessageMD_Search(achPacket + 1, achTarget, VISCANOMODE);

    }
    else
    {
        if (dwFlags & MCI_SEEK_TO_START)
            viscaDataTopMiddleEnd(achTarget, VISCATOP);
        else if (dwFlags & MCI_SEEK_TO_END)
            viscaDataTopMiddleEnd(achTarget, VISCAEND);
        else if (dwFlags & MCI_VCR_SEEK_MARK)
            viscaDataIndex(achTarget,
                           (BYTE)((dwFlags & MCI_VCR_SEEK_REVERSE) ?
                                    VISCAREVERSE : VISCAFORWARD),
                           (UINT)(lpSeek->dwMark));

        //
        // Fix CVD1000's problem (it MUST have mode, otherwise it plays).
        //
        if( (pvcr->Port[iPort].Dev[iDev].uModelID == VISCADEVICEVENDORSONY) &&
            (pvcr->Port[iPort].Dev[iDev].uVendorID == VISCADEVICEMODELCVD1000))
            cb = viscaMessageMD_Search(achPacket + 1, achTarget, VISCASTILL);
        else
            cb = viscaMessageMD_Search(achPacket + 1, achTarget, VISCANOMODE);

    }

    //
    // Only necessary to do this on the first alternative 
    //
    if(dwFlags & MCI_VCR_SEEK_AT)
    {
        UINT    uTicksPerSecond = pvcr->Port[iPort].Dev[iDev].uTicksPerSecond;
        BYTE    bHours, bMinutes, bSeconds;
        UINT    uTicks;


        viscaMciClockFormatToViscaData(lpSeek->dwAt, uTicksPerSecond,
            (BYTE FAR *)&bHours, (BYTE FAR *)&bMinutes, (BYTE FAR *)&bSeconds, (UINT FAR *)&uTicks);

        // Convert the integer time to something understandable 
        cb = viscaHeaderReplaceFormat1WithFormat2(achPacket + 1, cb,
                            bHours,
                            bMinutes,
                            bSeconds,
                            uTicks);
    }

    viscaQueueCommand(iInst,
                   (BYTE)(iDev + 1),
                   VISCA_SEEK,
                   (LPSTR) achPacket,
                   cb,
                   (UINT)1);      

    return MCIERR_NO_ERROR;
}

/****************************************************************************
 * Function: DWORD viscaMciPause - Pause.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_GENERIC_PARMS lpGeneric - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_PAUSE
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciPause(int iInst, DWORD dwFlags, LPMCI_GENERIC_PARMS lpGeneric)
{
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    char    achPacket[MAXPACKETLENGTH];
    DWORD    dwBool;

    if(dwFlags & MCI_TEST)
        return(viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

    pvcr->Port[iPort].Dev[iDev].wMciCued = 0;

    dwBool = viscaQueueReset(iInst, MCI_PAUSE, 0);

    if( (pvcr->Port[iPort].Dev[iDev].wCancelledCmd == VISCA_PLAY) ||
        (pvcr->Port[iPort].Dev[iDev].wCancelledCmd == VISCA_PLAY_TO))
        pvcr->Port[iPort].Dev[iDev].uResume = VISCA_PLAY;
    else if( (pvcr->Port[iPort].Dev[iDev].wCancelledCmd == VISCA_RECORD) ||
        (pvcr->Port[iPort].Dev[iDev].wCancelledCmd == VISCA_RECORD_TO))
        pvcr->Port[iPort].Dev[iDev].uResume = VISCA_RECORD;
    else if(pvcr->Port[iPort].Dev[iDev].wCancelledCmd == VISCA_SEEK)
        pvcr->Port[iPort].Dev[iDev].uResume = VISCA_SEEK;
    else
        pvcr->Port[iPort].Dev[iDev].uResume = VISCA_NONE;

    if(pvcr->Port[iPort].Dev[iDev].uResume == VISCA_NONE)
    {
        // Previous commands flags should tell if we need to notify.
        viscaNotifyReturn(pvcr->Port[iPort].Dev[iDev].iCancelledInst,
                (HWND) pvcr->Port[iPort].Dev[iDev].hwndCancelled,
                pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags, // this is not correct flags..
                MCI_NOTIFY_ABORTED, MCIERR_NO_ERROR);
    }
    else
    {
        // 
        // If we have notify then, if the last had flags notify, supersede it.
        //
        if(dwFlags & MCI_NOTIFY)
        {
            viscaNotifyReturn(pvcr->Port[iPort].Dev[iDev].iCancelledInst,
                pvcr->Port[iPort].Dev[iDev].hwndCancelled,
                pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags,
                MCI_NOTIFY_SUPERSEDED, MCIERR_NO_ERROR);
        }
    }


    if(!dwBool)
    {
        // Give up the transport
        pvcr->Port[iPort].Dev[iDev].iInstTransport = -1;
        pvcr->Port[iPort].Dev[iDev].uResume = VISCA_NONE;
            return (viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_HARDWARE));
    }

    pvcr->Port[iPort].Dev[iDev].dwFlagsPause = dwFlags;


    viscaQueueCommand(iInst,
                        (BYTE)(iDev + 1),
                        VISCA_PAUSE,
                        achPacket,
                        viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL),
                        1);

    //
    // If pause fails, it may be because we are in camera mode, so try camera pause.
    //
    viscaQueueCommand(iInst,
                        (BYTE) (iDev + 1),
                        VISCA_PAUSE,
                        achPacket,
                        viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1CAMERARECPAUSE),
                        0);

    //
    // Pause MUST be syncronous, otherwise play/pause/resume, seek/pause/resume loops
    // have problems. This is why we add the wait flag to the pause.
    //
    return(viscaDoQueued(iInst, MCI_PAUSE, dwFlags | MCI_WAIT, (HWND)lpGeneric->dwCallback));
}

/****************************************************************************
 * Function: DWORD viscaStopAt - Stop at a specific position.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwMCIStopPos - Position at which to stop, in the current
 *               MCI time format.
 *
 *      BOOL fReverse - Is the tape currently going backwards.
 *
 *      BOOL fWait - Should the function wait for the VCR to stop.
 *
 * Returns: an MCI error code.
 *
 *       This function is called by viscaMciPlay and viscaMciRecord
 *       when they are called with the MCI_TO flag.
 ***************************************************************************/
static DWORD NEAR PASCAL
    viscaStopAt(int iInst, UINT uViscaCmd,
            DWORD dwFlags, HWND hWnd,
            DWORD dwMCIStopPos, BOOL fReverse)
{
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    UINT    cb;
    char    achPacket[MAXPACKETLENGTH];
    char    achTo[5];
    BYTE    bDataFormat;
    DWORD   dwReply;


    if(dwFlags & MCI_TO)
    {
        if(pvcr->Port[iPort].Dev[iDev].bTimeType == VISCAABSOLUTECOUNTER)
            bDataFormat = VISCADATATIMECODENDF;
        else
            bDataFormat = pvcr->Port[iPort].Dev[iDev].bRelativeType;
 
        cb = viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL);

        dwReply = viscaMciTimeFormatToViscaData(iInst, TRUE, dwMCIStopPos, achTo, bDataFormat);

        if(dwReply != MCIERR_NO_ERROR)
            return dwReply;

        if (fReverse) 
            cb = viscaHeaderReplaceFormat1WithFormat4(achPacket + 1, cb, achTo);
        else 
            cb = viscaHeaderReplaceFormat1WithFormat3(achPacket + 1, cb, achTo);


        viscaQueueCommand(iInst,
                        (BYTE) (iDev + 1),
                        uViscaCmd,
                        achPacket, cb,
                        1);

        //
        // Use camera-rec if rec fails.
        //
        viscaQueueCommand(iInst,
                        (BYTE) (iDev + 1),
                        uViscaCmd,
                        achPacket,
                        viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1CAMERARECPAUSE),
                        0);

        return MCIERR_NO_ERROR;
    }
    else
    {
        char achTarget[MAXPACKETLENGTH];

        if(fReverse)
        {
            viscaDataTopMiddleEnd(achTarget, VISCATOP);
            cb = viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL);
            cb = viscaHeaderReplaceFormat1WithFormat4(achPacket + 1, cb, achTarget);
        }
        else
        {
            viscaDataTopMiddleEnd(achTarget, VISCAEND);
            cb = viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL);
            cb = viscaHeaderReplaceFormat1WithFormat3(achPacket + 1, cb, achTarget);
        }

        viscaQueueCommand(iInst,
                    (BYTE)(iDev + 1),
                    uViscaCmd,
                    achPacket, cb,
                    1);
        //
        // If pause fails, it may be because we are in camera mode, so try camera pause.
        //
        viscaQueueCommand(iInst,
                   (BYTE) (iDev + 1),
                   uViscaCmd,
                   achPacket,
                   viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1CAMERARECPAUSE),
                   0);

        return MCIERR_NO_ERROR;
    }

}

/****************************************************************************
 * Function: DWORD viscaMciFreeze - Freeze.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_RECORD_PARMS lpEdit - Pointer to MCI parameter block.
 *
 * During pause, it doesn't move transport, but does.  During play
 *         it doesn't nec. affect transport.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_EDIT
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciFreeze(int iInst, DWORD dwFlags, LPMCI_GENERIC_PARMS lpFreeze)
{
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    char    achPacket[MAXPACKETLENGTH];
    UINT    cb;

    if(dwFlags & MCI_TEST)
        return(viscaNotifyReturn(iInst, (HWND) lpFreeze->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

    pvcr->Port[iPort].Dev[iDev].wMciCued = 0;

    if(! ((pvcr->Port[iPort].Dev[iDev].uModelID == VISCADEVICEVENDORSONY) &&
         (pvcr->Port[iPort].Dev[iDev].uVendorID == VISCADEVICEMODELEVO9650)))
        return (viscaNotifyReturn(iInst, (HWND) lpFreeze->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_UNSUPPORTED_FUNCTION));

    if(!viscaQueueReset(iInst, MCI_FREEZE, MCI_NOTIFY_ABORTED))
    {
        // Give up the transport
        pvcr->Port[iPort].Dev[iDev].iInstTransport = -1;
        return (viscaNotifyReturn(iInst, (HWND) lpFreeze->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_HARDWARE));
    }

    if(!((dwFlags & MCI_VCR_FREEZE_OUTPUT) || (dwFlags & MCI_VCR_FREEZE_INPUT)))
    {
        dwFlags |= MCI_VCR_FREEZE_OUTPUT;
        DPF(DBG_QUEUE, "^^^No freeze flag, setting to output.\n");
    }

    if(!((dwFlags & MCI_VCR_FREEZE_FIELD) || (dwFlags & MCI_VCR_FREEZE_FRAME)))
    {
        dwFlags |= MCI_VCR_FREEZE_FIELD;
        DPF(DBG_QUEUE, "^^^No freeze field/frame flag, setting to field.\n");
    }

    //
    // Set to DNR if we are freezing the output.
    //
    if(dwFlags & MCI_VCR_FREEZE_OUTPUT)
    {

        if(pvcr->Port[iPort].Dev[iDev].dwFreezeMode!=MCI_VCR_FREEZE_OUTPUT)
        {
            viscaQueueCommand(iInst,
                        (BYTE)(iDev + 1),
                        VISCA_MODESET_OUTPUT,
                        achPacket,
                        viscaMessageENT_FrameMemorySelect(achPacket + 1, VISCADNR),
                        1);
        }

        //
        // Freeze command ! Only on DNR!!!! 
        //
        cb = viscaMessageENT_FrameStill(achPacket + 1, VISCASTILLON);
         
        //
        // All these commands rely on function evaluation before calling 
        //
        viscaQueueCommand(iInst,
                        (BYTE)(iDev + 1),
                        VISCA_FREEZE,
                        achPacket, cb,
                        1);
    
        DPF(DBG_QUEUE, "^^^Setting freeze input mode.\n");

        //
        // Set the field mode, This must be done after Freeze.
        // Note: The lines may not be quite as sharp! Because they are doubled
        // and a result look a little fuzzy in field mode. But no jitters.
        //
        if((dwFlags & MCI_VCR_FREEZE_FIELD) && !pvcr->Port[iPort].Dev[iDev].fField)
        {
            viscaQueueCommand(iInst,
                        (BYTE)(iDev + 1),
                        VISCA_MODESET_FIELD,
                        achPacket,
                        viscaMessageSE_VDEReadMode(achPacket + 1, VISCAFIELD),
                        1);

        }
        else if((dwFlags & MCI_VCR_FREEZE_FRAME) && pvcr->Port[iPort].Dev[iDev].fField)
        {
             viscaQueueCommand(iInst,
                        (BYTE)(iDev + 1),
                        VISCA_MODESET_FRAME,
                        achPacket,
                        viscaMessageSE_VDEReadMode(achPacket + 1, VISCAFRAME),
                        1);
        }

    }
    else if((dwFlags & MCI_VCR_FREEZE_INPUT) && (pvcr->Port[iPort].Dev[iDev].dwFreezeMode!=MCI_VCR_FREEZE_INPUT))
    {
        viscaQueueCommand(iInst,
                        (BYTE)(iDev + 1),
                        VISCA_MODESET_INPUT,
                        achPacket,
                        viscaMessageENT_FrameMemorySelect(achPacket + 1, VISCABUFFER),
                        1);
                                                                
        DPF(DBG_QUEUE, "^^^Setting freeze input mode.\n");

    }

    //
    // When VISCA_FREEZE is complete the timer starts (see waitCompletion) 
    //
    return(viscaDoQueued(iInst, MCI_FREEZE, dwFlags, (HWND)lpFreeze->dwCallback));
}


/****************************************************************************
 * Function: DWORD viscaMciUnfreeze - Unfreeze.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_RECORD_PARMS lpPerform - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the 
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciUnfreeze(int iInst, DWORD dwFlags, LPMCI_GENERIC_PARMS lpUnfreeze)
{
    UINT    iDev   = pinst[iInst].iDev;
    UINT    iPort  = pinst[iInst].iPort;
    char    achPacket[MAXPACKETLENGTH];
    UINT    cb;

    if(dwFlags & MCI_TEST)
        return(viscaNotifyReturn(iInst, (HWND) lpUnfreeze->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

    pvcr->Port[iPort].Dev[iDev].wMciCued = 0;

    if(!viscaQueueReset(iInst, MCI_UNFREEZE, MCI_NOTIFY_ABORTED))
    {
        // Give up the transport
        pvcr->Port[iPort].Dev[iDev].iInstTransport = -1;
        return (viscaNotifyReturn(iInst, (HWND) lpUnfreeze->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_HARDWARE));
    }

    cb = viscaMessageENT_FrameStill(achPacket + 1, VISCASTILLOFF);

    viscaQueueCommand(iInst,
                        (BYTE)(iDev + 1),
                        VISCA_UNFREEZE,
                        achPacket, cb,
                        1);

    //
    // This is transport, but is short command, should be queued 
    //
    return(viscaDoQueued(iInst, MCI_UNFREEZE, dwFlags, (HWND)lpUnfreeze->dwCallback));
}

/****************************************************************************
 * Function: DWORD viscaMciPlay - Play.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_PLAY_PARMS lpPlay - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_PLAY
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciPlay(int iInst, DWORD dwFlags, LPMCI_VCR_PLAY_PARMS lpPlay)
{
    UINT    iDev        = pinst[iInst].iDev;
    UINT    iPort       = pinst[iInst].iPort;
    char    achPacket[MAXPACKETLENGTH];
    BOOL    fLastReverse    = FALSE;
    BOOL    fSameDirection  = FALSE;
    BYTE    bAction;
    DWORD   dwErr;

    if((dwFlags & MCI_TO) && (dwFlags & MCI_VCR_PLAY_REVERSE))
        return (viscaNotifyReturn(iInst, (HWND) lpPlay->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

    if(pvcr->Port[iPort].Dev[iDev].wMciCued == MCI_PLAY)
    {
        if((dwFlags & MCI_FROM) || (dwFlags & MCI_TO) || (dwFlags & MCI_VCR_PLAY_REVERSE))
        {
            return (viscaNotifyReturn(iInst, (HWND) lpPlay->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));
        }
    }

    if(dwFlags & MCI_TO)
    {
        dwErr = viscaVerifyPosition(iInst, lpPlay->dwTo);
        if(dwErr != MCIERR_NO_ERROR)
            return (viscaNotifyReturn(iInst, (HWND) lpPlay->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, dwErr));
    }

    if(dwFlags & MCI_FROM)
    {
        dwErr = viscaVerifyPosition(iInst, lpPlay->dwFrom);
        if(dwErr != MCIERR_NO_ERROR)
            return (viscaNotifyReturn(iInst, (HWND) lpPlay->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, dwErr));
    }


    if(((dwFlags & MCI_FROM) && (dwFlags & MCI_TO)) || (dwFlags & MCI_TO))
    {
        if((dwFlags & MCI_TO) && !(dwFlags & MCI_FROM))
        {
            MCI_VCR_STATUS_PARMS statusParms;
            statusParms.dwItem = MCI_STATUS_POSITION;

            dwErr = viscaMciStatus(iInst,(DWORD) MCI_STATUS_ITEM, &statusParms);
            lpPlay->dwFrom = statusParms.dwReturn;
        }

        if (viscaMciPos1LessThanPos2(iInst, lpPlay->dwTo, lpPlay->dwFrom))
        {
            dwFlags |= MCI_VCR_PLAY_REVERSE;
        }
        else
        {
            if ((dwFlags & MCI_VCR_PLAY_REVERSE) &&
                (viscaMciPos1LessThanPos2(iInst, lpPlay->dwFrom, lpPlay->dwTo)))
            {
                return (viscaNotifyReturn(iInst, (HWND) lpPlay->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));
            }
        }
    }

    if(dwFlags & MCI_TEST)
        return(viscaNotifyReturn(iInst, (HWND) lpPlay->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

    if((pvcr->Port[iPort].Dev[iDev].wMciCued == MCI_PLAY) &&
       ((dwFlags & MCI_VCR_PLAY_REVERSE) ||
       (dwFlags & MCI_TO) ||
       (dwFlags & MCI_FROM) ||
       (dwFlags & MCI_VCR_PLAY_SCAN)))
    {
        if(!(dwFlags & MCI_TEST))
            pvcr->Port[iPort].Dev[iDev].wMciCued = 0;

        return (viscaNotifyReturn(iInst, (HWND) lpPlay->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_VCR_CUE_FAILED_FLAGS));
    }

    pvcr->Port[iPort].Dev[iDev].fPlayReverse = FALSE;
    //
    // Set the play direction, now that we know if we are cued or not 
    //
    if( (dwFlags & MCI_VCR_PLAY_REVERSE) ||
        ((pvcr->Port[iPort].Dev[iDev].wMciCued == MCI_PLAY) &&
         (pvcr->Port[iPort].Dev[iDev].dwFlagsCued & MCI_VCR_CUE_REVERSE)))
    pvcr->Port[iPort].Dev[iDev].fPlayReverse = TRUE;

    //
    // Is the current command going the same direction as last play? 
    //
    fLastReverse = pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags & MCI_VCR_PLAY_REVERSE ? TRUE : FALSE;
    fSameDirection = (fLastReverse  && pvcr->Port[iPort].Dev[iDev].fPlayReverse) ||
                     (!fLastReverse && !pvcr->Port[iPort].Dev[iDev].fPlayReverse);
    //
    // If device is cued, we know the thing is in pause anyway. Must be! 
    //
    if( ((viscaDelayedCommand(iInst) == VISCA_PLAY_TO) ||
         (viscaDelayedCommand(iInst) == VISCA_PLAY))         &&
       !(dwFlags &  MCI_FROM)                                &&
        (pvcr->Port[iPort].Dev[iDev].mciLastCmd.parm.mciPlay.dwTo == lpPlay->dwTo)   &&
        (fSameDirection))
    {
        if(dwFlags & MCI_NOTIFY)
        {
            if(!viscaQueueReset(iInst, MCI_PLAY, MCI_NOTIFY_SUPERSEDED)) /* Cancel status */
            {
                // Give up the transport
                pvcr->Port[iPort].Dev[iDev].iInstTransport = -1;
                return (viscaNotifyReturn(iInst, (HWND) lpPlay->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_HARDWARE));
            }
        }
        else
        {
            return MCIERR_NO_ERROR;
        }

        DPF(DBG_QUEUE, "///Play interrupt reason. == MCI_NOTIFY_SUPERSEDED\n");
    }
    else
    {
        if(!viscaQueueReset(iInst, MCI_PLAY, MCI_NOTIFY_ABORTED))
        {
            return (viscaNotifyReturn(iInst, (HWND) lpPlay->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_HARDWARE));
            // Give up the transport
            pvcr->Port[iPort].Dev[iDev].iInstTransport = -1;
        }

        DPF(DBG_QUEUE, "///Play interrupt reason. == MCI_NOTIFY_ABORTED\n");
    }
    //
    // Save info for a possible pause and resume 
    //
    pvcr->Port[iPort].Dev[iDev].mciLastCmd.uMciCmd       = MCI_PLAY;
    pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags       = dwFlags;
    pvcr->Port[iPort].Dev[iDev].mciLastCmd.iInstCmd      = iInst;
    pvcr->Port[iPort].Dev[iDev].mciLastCmd.parm.mciPlay  = *lpPlay;
    //
    // Now do the seek part 
    //
    if(dwFlags & MCI_FROM)
    {
        MCI_VCR_SEEK_PARMS      seekParms;

        seekParms.dwTo = lpPlay->dwFrom;

        if(!viscaQueueLength(iInst) && (dwFlags & MCI_VCR_PLAY_AT))
        {
            // Do it at some time 
            seekParms.dwAt = lpPlay->dwAt;
            viscaSeekTo(iInst, MCI_TO | MCI_VCR_SEEK_AT, &seekParms);
        }
        else
        {
            viscaSeekTo(iInst,  MCI_TO, &seekParms);
        }
    }
    //
    // Map the Mci speed to the Visca setting 
    //
    #define VERY_FAST 100000L
    if(dwFlags & MCI_VCR_PLAY_SCAN)
        bAction = viscaMapSpeed(VERY_FAST, pvcr->Port[iPort].Dev[iDev].fPlayReverse);
    else
        bAction = viscaMapSpeed(pvcr->Port[iPort].Dev[iDev].dwPlaySpeed, pvcr->Port[iPort].Dev[iDev].fPlayReverse);
    //
    // If speed is 0, then we are paused, so return now 
    //
    if(bAction == VISCAMODE1STILL)
        return (viscaNotifyReturn(iInst, (HWND) lpPlay->dwCallback, dwFlags,
                MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

    if((pvcr->Port[iPort].Dev[iDev].wMciCued == MCI_PLAY) && (pvcr->Port[iPort].Dev[iDev].dwFlagsCued & MCI_VCR_CUE_PREROLL))
    {
        // If at then enter the edit play mode. 
        UINT    uTicksPerSecond = pvcr->Port[iPort].Dev[iDev].uTicksPerSecond;
        BYTE    bHours, bMinutes, bSeconds;
        UINT    uTicks;

        //
        // Edit Record MUST be in format 2. i.e. It must have a time.
        //
        if(!(dwFlags & MCI_VCR_PLAY_AT))
            lpPlay->dwAt = 300L; // Minimum of 1 second (why?)

        viscaMciClockFormatToViscaData(lpPlay->dwAt, uTicksPerSecond,
            (BYTE FAR *)&bHours, (BYTE FAR *)&bMinutes, (BYTE FAR *)&bSeconds, (UINT FAR *)&uTicks);

        viscaQueueCommand(iInst,
                        (BYTE) (iDev + 1),
                        VISCA_PLAY,
                        achPacket,
                        viscaMessageMD_EditControl(achPacket + 1,
                            (BYTE)bHours, (BYTE)bMinutes, (BYTE)bSeconds, (UINT)uTicks, (BYTE) VISCAEDITPLAY),
                        1);
        //
        // When using evo-9650 (in and outpoints) we do not need pause 
        //
        if(!((pvcr->Port[iPort].Dev[iDev].uModelID == VISCADEVICEVENDORSONY) &&
           (pvcr->Port[iPort].Dev[iDev].uVendorID == VISCADEVICEMODELEVO9650)))
        {

            viscaStopAt(iInst, VISCA_PLAY_TO,
                        pvcr->Port[iPort].Dev[iDev].dwFlagsCued, (HWND) lpPlay->dwCallback,
                        pvcr->Port[iPort].Dev[iDev].Cue.dwTo,
                        ((pvcr->Port[iPort].Dev[iDev].dwFlagsCued & MCI_VCR_CUE_REVERSE) != 0L));
        }
    }
    else
    {
        UINT cb = viscaMessageMD_Mode1(achPacket + 1, bAction);

        //
        // Normal play 
        //
        if(!viscaQueueLength(iInst) && (dwFlags & MCI_VCR_PLAY_AT))
        {
            UINT    uTicksPerSecond = pvcr->Port[iPort].Dev[iDev].uTicksPerSecond;
            BYTE    bHours, bMinutes, bSeconds;
            UINT    uTicks;

            cb = viscaMessageMD_Mode1(achPacket + 1, bAction);

            viscaMciClockFormatToViscaData(lpPlay->dwAt, uTicksPerSecond,
                (BYTE FAR *)&bHours, (BYTE FAR *)&bMinutes, (BYTE FAR *)&bSeconds, (UINT FAR *)&uTicks);
            //
            // Convert the integer time to something understandable
            //
            cb = viscaHeaderReplaceFormat1WithFormat2(achPacket + 1, cb,
                        bHours,
                        bMinutes,
                        bSeconds,
                        uTicks);
        }

        viscaQueueCommand(iInst,
                        (BYTE)(iDev + 1),
                        VISCA_PLAY,
                        achPacket, cb,
                        1);

        if(pvcr->Port[iPort].Dev[iDev].wMciCued==MCI_PLAY)
        {
            viscaStopAt(iInst, VISCA_PLAY_TO,
                        pvcr->Port[iPort].Dev[iDev].dwFlagsCued, (HWND) lpPlay->dwCallback,
                        pvcr->Port[iPort].Dev[iDev].Cue.dwTo,
                        ((pvcr->Port[iPort].Dev[iDev].dwFlagsCued & MCI_VCR_CUE_REVERSE) != 0L));
        }
        else
        {
            viscaStopAt(iInst, VISCA_PLAY_TO,
                        dwFlags, (HWND) lpPlay->dwCallback,
                        lpPlay->dwTo,
                        ((dwFlags & MCI_VCR_PLAY_REVERSE) != 0L));
        }
    }
    //
    // If we get to this point we are no longer cued.
    //
    pvcr->Port[iPort].Dev[iDev].wMciCued = 0;
    return(viscaDoQueued(iInst, MCI_PLAY, dwFlags, (HWND)lpPlay->dwCallback));
}


/****************************************************************************
 * Function: DWORD viscaMciRecord - Record.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_RECORD_PARMS lpRecord - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_RECORD
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciRecord(int iInst, DWORD dwFlags, LPMCI_VCR_RECORD_PARMS lpRecord)
{
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    char    achPacket[MAXPACKETLENGTH];
    DWORD   dwErr;
         
    // Flag checks
    if (dwFlags & MCI_RECORD_INSERT)
        return (viscaNotifyReturn(iInst, (HWND) lpRecord->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_UNSUPPORTED_FUNCTION));

    // Flag checks
    if (dwFlags & MCI_VCR_RECORD_PREVIEW)
        return (viscaNotifyReturn(iInst, (HWND) lpRecord->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_UNRECOGNIZED_KEYWORD));

    if(dwFlags & MCI_TO)
    {
        dwErr = viscaVerifyPosition(iInst, lpRecord->dwTo);
        if(dwErr != MCIERR_NO_ERROR)
            return (viscaNotifyReturn(iInst, (HWND) lpRecord->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, dwErr));
    }

    if(dwFlags & MCI_FROM)
    {
        dwErr = viscaVerifyPosition(iInst, lpRecord->dwFrom);
        if(dwErr != MCIERR_NO_ERROR)
            return (viscaNotifyReturn(iInst, (HWND) lpRecord->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, dwErr));
    }

    //
    // Should we return failure when a cued device can't carry out its cue?
    //
    if((pvcr->Port[iPort].Dev[iDev].wMciCued == MCI_RECORD) &&
       ((dwFlags & MCI_TO)  ||
       (dwFlags & MCI_FROM) ||
       (dwFlags & MCI_VCR_RECORD_INITIALIZE)))
    {
        if(!(dwFlags & MCI_TEST))
            pvcr->Port[iPort].Dev[iDev].wMciCued = 0;

        return (viscaNotifyReturn(iInst, (HWND) lpRecord->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_VCR_CUE_FAILED_FLAGS));
    }

    if(!(dwFlags & MCI_TEST))
    {
        if(!viscaQueueReset(iInst, MCI_RECORD, MCI_NOTIFY_ABORTED))
        {
            pvcr->Port[iPort].Dev[iDev].iInstTransport = -1;
            return (viscaNotifyReturn(iInst, (HWND) lpRecord->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_HARDWARE));
        }
    }

    if(!(dwFlags & MCI_TEST))
    {
        if(pvcr->Port[iPort].Dev[iDev].wMciCued == MCI_RECORD)
        {
            if((dwFlags & MCI_FROM) || (dwFlags & MCI_TO) || (dwFlags & MCI_VCR_RECORD_INITIALIZE))
            {
                // Give up the transport
                pvcr->Port[iPort].Dev[iDev].iInstTransport = -1;
                pvcr->Port[iPort].Dev[iDev].wMciCued = 0;
                return (viscaNotifyReturn(iInst, (HWND) lpRecord->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));
            }
        }
    }

    if(dwFlags & MCI_VCR_RECORD_INITIALIZE)
    {
        MCI_VCR_SEEK_PARMS      seekParms;

        if((dwFlags & MCI_TO) || (dwFlags & MCI_FROM))
             return (viscaNotifyReturn(iInst, (HWND) lpRecord->dwCallback, dwFlags,
                        MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

        if(dwFlags & MCI_TEST)
            return(viscaNotifyReturn(iInst, (HWND) lpRecord->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        //
        // Seek to the begining 
        //
        viscaSeekTo(iInst, MCI_SEEK_TO_START, &seekParms);

        //
        // Save the current settings 
        //
        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_RecTrackInq(achPacket + 1));

        _fmemcpy(pvcr->Port[iPort].Dev[iDev].achBeforeInit, achPacket, MAXPACKETLENGTH);
        //
        // Turn all the formatting junk on 
        //
        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                    achPacket,
                    viscaMessageMD_RecTrack(achPacket + 1,
                        VISCARECORDMODEASSEMBLE,
                        VISCAMUTE,
                        VISCATRACK1,
                        VISCAMUTE));

        pvcr->Port[iPort].Dev[iDev].uRecordMode = TRUE;
    }
    else
    {
        //
        // Save info for a possible pause and resume 
        //
        if(!(dwFlags & MCI_TEST))
        {
            pvcr->Port[iPort].Dev[iDev].mciLastCmd.uMciCmd          = MCI_RECORD;
            pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags          = dwFlags;
            pvcr->Port[iPort].Dev[iDev].mciLastCmd.iInstCmd         = iInst;
            pvcr->Port[iPort].Dev[iDev].mciLastCmd.parm.mciRecord   = *lpRecord;
        }

        //
        // Seek to desired start position
        //
        if (dwFlags & MCI_FROM)
        {
            MCI_VCR_SEEK_PARMS      seekParms;

            seekParms.dwTo = lpRecord->dwFrom;
            //
            // Reverse not possible 
            //
            if ((dwFlags & MCI_TO) && (viscaMciPos1LessThanPos2(iInst, lpRecord->dwTo, lpRecord->dwFrom)))
            {
                // Give up the transport
                pvcr->Port[iPort].Dev[iDev].iInstTransport = -1;
                return (viscaNotifyReturn(iInst, (HWND) lpRecord->dwCallback, dwFlags,
                        MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));
            }

            if(dwFlags & MCI_TEST)
                return(viscaNotifyReturn(iInst, (HWND) lpRecord->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
            //
            // If there is an at, and a from, then when to begin the seek. (The entire command).
            //
            if(!viscaQueueLength(iInst) && (dwFlags & MCI_VCR_RECORD_AT))
            {
                seekParms.dwAt = lpRecord->dwAt;
                viscaSeekTo(iInst, MCI_TO | MCI_VCR_SEEK_AT, &seekParms);
            }
            else
            {
                viscaSeekTo(iInst, MCI_TO, &seekParms);
            }

        }
        else if (dwFlags & MCI_TO)
        {
            if(dwFlags & MCI_TEST)
                return(viscaNotifyReturn(iInst, (HWND) lpRecord->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
        }
    }

    if((pvcr->Port[iPort].Dev[iDev].wMciCued==MCI_RECORD) && (pvcr->Port[iPort].Dev[iDev].dwFlagsCued & MCI_VCR_CUE_PREROLL))
    {
        UINT    uTicksPerSecond = pvcr->Port[iPort].Dev[iDev].uTicksPerSecond;
        BYTE    bHours, bMinutes, bSeconds;
        UINT    uTicks;
        MCI_VCR_CUE_PARMS   *lpCue = &(pvcr->Port[iPort].Dev[iDev].Cue);

        //
        // Edit Record MUST be in format 2. i.e. It must have a time.
        //
        if(!(dwFlags & MCI_VCR_RECORD_AT))
            lpRecord->dwAt = 300L; // Minimum of 1 second.

        viscaMciClockFormatToViscaData(lpRecord->dwAt, uTicksPerSecond,
                    (BYTE FAR *)&bHours, (BYTE FAR *)&bMinutes, (BYTE FAR *)&bSeconds, (UINT FAR *)&uTicks);

        viscaQueueCommand(iInst,
                        (BYTE) (iDev + 1),
                        VISCA_RECORD,
                        achPacket, viscaMessageMD_EditControl(achPacket + 1,
                                    (BYTE)bHours, (BYTE)bMinutes, (BYTE)bSeconds, (UINT)uTicks, VISCAEDITRECORD),
                        1);
        //
        // Preroll is assumed, preroll means edit_standby was issued! 
        //
        // Both must be false in order for us to skip this 
        //
        if( !(pvcr->Port[iPort].Dev[iDev].dwFlagsCued & MCI_TO) ||
            !((pvcr->Port[iPort].Dev[iDev].uModelID == VISCADEVICEVENDORSONY) &&
             (pvcr->Port[iPort].Dev[iDev].uVendorID == VISCADEVICEMODELEVO9650))
             )
        {
            viscaStopAt(iInst, VISCA_RECORD_TO,
                        pvcr->Port[iPort].Dev[iDev].dwFlagsCued, (HWND)lpRecord->dwCallback, pvcr->Port[iPort].Dev[iDev].Cue.dwTo, FALSE);
        }

    }
    else
    {
        UINT cb = viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1RECORD);

        if(!viscaQueueLength(iInst) && (dwFlags & MCI_VCR_RECORD_AT))
        {
            UINT    uTicksPerSecond = pvcr->Port[iPort].Dev[iDev].uTicksPerSecond;
            BYTE    bHours, bMinutes, bSeconds;
            UINT    uTicks;

            viscaMciClockFormatToViscaData(lpRecord->dwAt, uTicksPerSecond,
                (BYTE FAR *)&bHours, (BYTE FAR *)&bMinutes, (BYTE FAR *)&bSeconds, (UINT FAR *)&uTicks);

            // Convert the integer time to something understandable 
            cb = viscaHeaderReplaceFormat1WithFormat2(achPacket + 1, cb,
                        bHours,
                        bMinutes,
                        bSeconds,
                        uTicks);
        }
        //
        // No preroll, so edit_rec was not possible 
        //
        viscaQueueCommand(iInst,
                        (BYTE) (iDev + 1),
                        VISCA_RECORD,
                        achPacket, cb,
                        1);

        cb = viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1CAMERAREC);
        //
        // If fails try to camera record, maybe that will work? Alternative. 
        //
        viscaQueueCommand(iInst,
                        (BYTE) (iDev + 1),
                        VISCA_RECORD,
                        achPacket, cb,
                        0);
        //
        // If no preroll send the StopAt after, CVD-1000 has only one transport socket 
        //
        if(pvcr->Port[iPort].Dev[iDev].wMciCued==MCI_RECORD)
        {
            // Use the cued parameter instead of the record one 
            viscaStopAt(iInst, VISCA_RECORD_TO,
                        pvcr->Port[iPort].Dev[iDev].dwFlagsCued, (HWND)lpRecord->dwCallback, pvcr->Port[iPort].Dev[iDev].Cue.dwTo, FALSE);
        }
        else
        {
            viscaStopAt(iInst, VISCA_RECORD_TO,
                        dwFlags, (HWND)lpRecord->dwCallback,lpRecord->dwTo, FALSE);
        }
    }
    //
    // If we get this far. We are no longer cued.
    //
    pvcr->Port[iPort].Dev[iDev].wMciCued = 0; 
    dwErr = viscaDoQueued(iInst, MCI_RECORD, dwFlags, (HWND) lpRecord->dwCallback);

    //
    // Condition error in record probably means it is write protected.
    //
    if(dwErr == MCIERR_VCR_CONDITION)
        dwErr = MCIERR_VCR_ISWRITEPROTECTED;

    return dwErr;
}

/****************************************************************************
 * Function: DWORD viscaMciCue - Cue
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_RECORD_PARMS lpCue - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_CUE
 *       command.
 *       Preroll means: Use editrec_standby and editplay_standby, literally.
 *
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciCue(int iInst, DWORD dwFlags, LPMCI_VCR_CUE_PARMS lpCue)
{
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    char    achPacket[MAXPACKETLENGTH];
    MCI_VCR_STATUS_PARMS    statusParms;
    MCI_VCR_SEEK_PARMS      seekParms;
    DWORD   dwErr;

    if ((dwFlags & MCI_TO) && (dwFlags & MCI_VCR_CUE_REVERSE))
        return (viscaNotifyReturn(iInst, (HWND) lpCue->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));

    if ((dwFlags & MCI_VCR_CUE_INPUT) && (dwFlags & MCI_VCR_CUE_OUTPUT))
        return (viscaNotifyReturn(iInst, (HWND) lpCue->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));


    if(dwFlags & MCI_TO)
    {
        dwErr = viscaVerifyPosition(iInst, lpCue->dwTo);
        if(dwErr != MCIERR_NO_ERROR)
            return (viscaNotifyReturn(iInst, (HWND) lpCue->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, dwErr));
    }

    if(dwFlags & MCI_FROM)
    {
        dwErr = viscaVerifyPosition(iInst, lpCue->dwFrom);
        if(dwErr != MCIERR_NO_ERROR)
            return (viscaNotifyReturn(iInst, (HWND) lpCue->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, dwErr));
    }

    if(!((dwFlags & MCI_VCR_CUE_OUTPUT) || (dwFlags & MCI_VCR_CUE_INPUT)))
        dwFlags |= MCI_VCR_CUE_OUTPUT;    // Neither specified - default to output

    if(dwFlags & MCI_TEST)
        return(viscaNotifyReturn(iInst, (HWND) lpCue->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

    if(!viscaQueueReset(iInst, MCI_CUE, MCI_NOTIFY_ABORTED))
    {
        // Give up the transport
        pvcr->Port[iPort].Dev[iDev].iInstTransport = -1;
        return (viscaNotifyReturn(iInst, (HWND) lpCue->dwCallback, dwFlags,
            MCI_NOTIFY_FAILURE, MCIERR_HARDWARE));
    }

    //
    // We must at least pause, because the from position, etc. 
    //
    dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL));

    //
    // Get from position if TO or FROM is specified.                   
    //
    if(((dwFlags & MCI_FROM) && (dwFlags & MCI_TO)) || (dwFlags & MCI_TO))
    {
        if((dwFlags & MCI_TO) && !(dwFlags & MCI_FROM))
        {
            DWORD   dwStart, dwTime;
            DWORD   dwWaitTime = 200; // Good guess.

            //
            // On Evo-9650 we need a little wait here before position becomes available.
            //
            dwStart = GetTickCount();
            while(1)                 
            {
                dwTime = GetTickCount();
                if(MShortWait(dwStart, dwTime, dwWaitTime))
                    break;
                Yield();
            }

            statusParms.dwItem = MCI_STATUS_POSITION;
            dwErr = viscaMciStatus(iInst,(DWORD) MCI_STATUS_ITEM, &statusParms);
            lpCue->dwFrom = statusParms.dwReturn;
        }

        if (viscaMciPos1LessThanPos2(iInst, lpCue->dwTo, lpCue->dwFrom))
        {
            dwFlags |= MCI_VCR_CUE_REVERSE;
        }
        else
        {
            if ((dwFlags & MCI_VCR_CUE_REVERSE) &&
                (viscaMciPos1LessThanPos2(iInst, lpCue->dwFrom, lpCue->dwTo)))
            {
                return (viscaNotifyReturn(iInst, (HWND) lpCue->dwCallback, dwFlags,
                    MCI_NOTIFY_FAILURE, MCIERR_FLAGS_NOT_COMPATIBLE));
            }
        }
    }


    //
    // Now do the seek part 
    //
    if(dwFlags & MCI_FROM)
    {
        seekParms.dwTo = lpCue->dwFrom;
        viscaSeekTo(iInst,  MCI_TO, &seekParms);
    }

    //
    // Only the EVO 9650 accepts the following commands! (page 6-49)*/
    //
    if((dwFlags & MCI_VCR_CUE_PREROLL) &&       
            ((pvcr->Port[iPort].Dev[iDev].uModelID == VISCADEVICEVENDORSONY) &&
            (pvcr->Port[iPort].Dev[iDev].uVendorID == VISCADEVICEMODELEVO9650)))
    {
        char achTarget[MAXPACKETLENGTH];
        BYTE bEditMode = 0;

        if((dwFlags & MCI_FROM) && (dwFlags & MCI_TO))
            bEditMode = VISCAEDITUSEFROMANDTO;
        else if(dwFlags & MCI_TO)
            bEditMode = VISCAEDITUSETO;
        else if(dwFlags & MCI_FROM)
            bEditMode = VISCAEDITUSEFROM;

        viscaQueueCommand(iInst,
                        (BYTE) (iDev + 1),
                        VISCA_EDITMODES,
                        achPacket,
                        viscaMessageMD_EditModes(achPacket +1, (BYTE)bEditMode),
                        1);

        if(dwFlags & MCI_FROM)
        {
            //
            // If inpoint otherwise use current location
            //
            viscaMciTimeFormatToViscaData(iInst, (BOOL) TRUE, lpCue->dwFrom, (LPSTR) achTarget,(BYTE) VISCADATATIMECODENDF);
            viscaQueueCommand(iInst,
                            (BYTE) (iDev + 1),
                            VISCA_SEGINPOINT,
                            achPacket,
                            viscaMessageMD_SegInPoint(achPacket +1, achTarget),
                            1);
        }

        if(dwFlags & MCI_TO)
        {
            viscaMciTimeFormatToViscaData(iInst, (BOOL) TRUE, lpCue->dwTo, (LPSTR) achTarget,(BYTE) VISCADATATIMECODENDF);
            viscaQueueCommand(iInst,
                        (BYTE) (iDev + 1),
                        VISCA_SEGOUTPOINT,
                        achPacket,
                        viscaMessageMD_SegOutPoint(achPacket +1, achTarget),
                        1);

        }
    }
    //
    // If preroll is not specified then seeking to the inpoint is enough 
    //
    if(dwFlags & MCI_VCR_CUE_INPUT)
    {
        pvcr->Port[iPort].Dev[iDev].wMciCued = MCI_RECORD;

        if((pvcr->Port[iPort].Dev[iDev].uModelID == VISCADEVICEVENDORSONY) &&
               (pvcr->Port[iPort].Dev[iDev].uVendorID == VISCADEVICEMODELEVO9650))
        {
            if(pvcr->Port[iPort].Dev[iDev].dwFreezeMode != MCI_VCR_FREEZE_INPUT)
            {
                // Switch to buffer mode 
                viscaQueueCommand(iInst,
                        (BYTE)(iDev + 1),
                        VISCA_MODESET_INPUT,
                        achPacket,
                        viscaMessageENT_FrameMemorySelect(achPacket + 1, VISCABUFFER),
                        1);

            }
        }
        //
        // Preroll always means edit standby 
        //
        if(dwFlags & MCI_VCR_CUE_PREROLL)
        {
            // All VCRs accept EditRecStnby! But CI-1000 may handle incorrectly 
            viscaQueueCommand(iInst,
                        (BYTE) (iDev + 1),
                        VISCA_RECORD,
                        achPacket,
                        viscaMessageMD_EditControl(achPacket + 1,
                                (BYTE)0, (BYTE)0, (BYTE)0, (UINT)0, VISCAEDITRECSTANDBY),
                        1);
        }
    }
    else if(dwFlags & MCI_VCR_CUE_OUTPUT)
    {
        pvcr->Port[iPort].Dev[iDev].wMciCued = MCI_PLAY;

        if((pvcr->Port[iPort].Dev[iDev].uModelID == VISCADEVICEVENDORSONY) &&
               (pvcr->Port[iPort].Dev[iDev].uVendorID == VISCADEVICEMODELEVO9650))
        {
            if(pvcr->Port[iPort].Dev[iDev].dwFreezeMode != MCI_VCR_FREEZE_OUTPUT)
            {
                viscaQueueCommand(iInst,
                       (BYTE)(iDev + 1),
                       VISCA_MODESET_OUTPUT,
                       achPacket,
                       viscaMessageENT_FrameMemorySelect(achPacket + 1, VISCADNR),
                       1);
            }
        }
        //
        // Preroll always means edit standby 
        //
        if(dwFlags & MCI_VCR_CUE_PREROLL)
        {
            // All VCRs accept EditPlayStnby! But CI-1000 may handle incorrectly 
            viscaQueueCommand(iInst,
                    (BYTE) (iDev + 1),
                    VISCA_PLAY,
                    achPacket, viscaMessageMD_EditControl(achPacket + 1,
                                (BYTE)0, (BYTE)0, (BYTE)0, (UINT)0, VISCAEDITPBSTANDBY),
                    1);
        }
    }
    //
    // Copy the flags into the global 
    //
    pvcr->Port[iPort].Dev[iDev].dwFlagsCued    = dwFlags;
    pvcr->Port[iPort].Dev[iDev].Cue            = *lpCue;
    //
    // The queue length check is not needed, but remains for security 
    //
    if(viscaQueueLength(iInst))
        return(viscaDoQueued(iInst, MCI_CUE, dwFlags, (HWND) lpCue->dwCallback));

    // Give up the transport
    pvcr->Port[iPort].Dev[iDev].iInstTransport = -1;
    // We MUST NOTIFY IN THIS CASE!!
    return (viscaNotifyReturn(iInst, (HWND) lpCue->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));
}


/****************************************************************************
 * Function: DWORD viscaMciResume - Resume play/record from paused state.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_GENERIC_PARMS lpGeneric - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_RESUME
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciResume(int iInst, DWORD dwFlags, LPMCI_GENERIC_PARMS lpGeneric)
{
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;

    if((pvcr->Port[iPort].Dev[iDev].uResume == VISCA_SEEK) &&
       (pvcr->Port[iPort].Dev[iDev].mciLastCmd.uMciCmd == MCI_PLAY) )
    {
        if(dwFlags & MCI_TEST)
            return(viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        if((pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags & MCI_NOTIFY) &&
            (dwFlags & MCI_NOTIFY) && !(pvcr->Port[iPort].Dev[iDev].dwFlagsPause & MCI_NOTIFY))
        {
               viscaNotifyReturn(pvcr->Port[iPort].Dev[iDev].mciLastCmd.iInstCmd,
                (HWND)pvcr->Port[iPort].Dev[iDev].mciLastCmd.parm.mciPlay.dwCallback,
                pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags,
                MCI_NOTIFY_SUPERSEDED, MCIERR_NO_ERROR);
        }

        //
        // If original command had a notify and pause did, but resume does not then
        // the notify on the resume command is cancelled (don't ask me why.).
        //
        if(!(dwFlags & MCI_NOTIFY) && (pvcr->Port[iPort].Dev[iDev].dwFlagsPause & MCI_NOTIFY))
            pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags &= ~MCI_NOTIFY;

        //
        // A seek that was part of a play from was running, so start the play with 
        // the from parameter over again.
        //
        return(viscaMciPlay(iInst, dwFlags | (pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags & ~(MCI_VCR_PLAY_AT)),
            &(pvcr->Port[iPort].Dev[iDev].mciLastCmd.parm.mciPlay)));
    }
    else if((pvcr->Port[iPort].Dev[iDev].uResume == VISCA_SEEK) &&
       (pvcr->Port[iPort].Dev[iDev].mciLastCmd.uMciCmd == MCI_RECORD) )
    {
        if(dwFlags & MCI_TEST)
            return(viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        if((pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags & MCI_NOTIFY) &&
            (dwFlags & MCI_NOTIFY) && !(pvcr->Port[iPort].Dev[iDev].dwFlagsPause & MCI_NOTIFY))
        {
               viscaNotifyReturn(pvcr->Port[iPort].Dev[iDev].mciLastCmd.iInstCmd,
                (HWND)pvcr->Port[iPort].Dev[iDev].mciLastCmd.parm.mciRecord.dwCallback,
                pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags,
                MCI_NOTIFY_SUPERSEDED, MCIERR_NO_ERROR);
        }

        //
        // A seek that was part of a record from was running, so start the record with 
        // the from parameter over again.
        //
        return(viscaMciRecord(iInst, dwFlags | (pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags & ~(MCI_VCR_RECORD_AT)),
            &(pvcr->Port[iPort].Dev[iDev].mciLastCmd.parm.mciRecord)));
    }
    else if(pvcr->Port[iPort].Dev[iDev].uResume == VISCA_PLAY)
    {
        if(dwFlags & MCI_TEST)
            return(viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        if((pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags & MCI_NOTIFY) &&
            (dwFlags & MCI_NOTIFY) && !(pvcr->Port[iPort].Dev[iDev].dwFlagsPause & MCI_NOTIFY))
        {
               viscaNotifyReturn(pvcr->Port[iPort].Dev[iDev].mciLastCmd.iInstCmd,
                (HWND)pvcr->Port[iPort].Dev[iDev].mciLastCmd.parm.mciPlay.dwCallback,
                pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags,
                MCI_NOTIFY_SUPERSEDED, MCIERR_NO_ERROR);
        }

        //
        // If original command had a notify and pause did, but resume does not then
        // the notify on the resume command is cancelled (don't ask me why.).
        //
        if(!(dwFlags & MCI_NOTIFY) && (pvcr->Port[iPort].Dev[iDev].dwFlagsPause & MCI_NOTIFY))
            pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags &= ~MCI_NOTIFY;

        //
        // Will handle notify, just return return code 
        //
        return(viscaMciPlay(iInst, dwFlags | (pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags & ~(MCI_FROM | MCI_VCR_PLAY_AT)),
            &(pvcr->Port[iPort].Dev[iDev].mciLastCmd.parm.mciPlay)));
    }
    else if(pvcr->Port[iPort].Dev[iDev].uResume == VISCA_RECORD)
    {
        if(dwFlags & MCI_TEST)
            return(viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        if((pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags & MCI_NOTIFY) &&
            (dwFlags & MCI_NOTIFY) && !(pvcr->Port[iPort].Dev[iDev].dwFlagsPause & MCI_NOTIFY))
        {
               viscaNotifyReturn(pvcr->Port[iPort].Dev[iDev].mciLastCmd.iInstCmd,
                (HWND)pvcr->Port[iPort].Dev[iDev].mciLastCmd.parm.mciRecord.dwCallback,
                pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags,
                MCI_NOTIFY_SUPERSEDED, MCIERR_NO_ERROR);
        }

        //
        // If original command had a notify and pause did, but resume does not then
        // the notify on the resume command is cancelled (don't ask me why.).
        //
        if(!(dwFlags & MCI_NOTIFY) && (pvcr->Port[iPort].Dev[iDev].dwFlagsPause & MCI_NOTIFY))
            pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags &= ~MCI_NOTIFY;

        //
        // Will handle notify, just return return code 
        //
        return(viscaMciRecord(iInst, dwFlags | (pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags & ~(MCI_FROM | MCI_NOTIFY | MCI_VCR_RECORD_AT)),
            &(pvcr->Port[iPort].Dev[iDev].mciLastCmd.parm.mciRecord)));
    }
    else if(pvcr->Port[iPort].Dev[iDev].uResume == VISCA_SEEK)
    {
        if(dwFlags & MCI_TEST)
            return(viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

        if((pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags & MCI_NOTIFY) &&
            (dwFlags & MCI_NOTIFY) && !(pvcr->Port[iPort].Dev[iDev].dwFlagsPause & MCI_NOTIFY))
        {
               viscaNotifyReturn(pvcr->Port[iPort].Dev[iDev].mciLastCmd.iInstCmd,
                (HWND)pvcr->Port[iPort].Dev[iDev].mciLastCmd.parm.mciSeek.dwCallback,
                pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags,
                MCI_NOTIFY_SUPERSEDED, MCIERR_NO_ERROR);
        }

        //
        // If original command had a notify and pause did, but resume does not then
        // the notify on the resume command is cancelled (don't ask me why.).
        //
        if(!(dwFlags & MCI_NOTIFY) && (pvcr->Port[iPort].Dev[iDev].dwFlagsPause & MCI_NOTIFY))
            pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags &= ~MCI_NOTIFY;

        return(viscaMciSeek(iInst, dwFlags | (pvcr->Port[iPort].Dev[iDev].mciLastCmd.dwFlags & ~MCI_VCR_SEEK_AT),
            &(pvcr->Port[iPort].Dev[iDev].mciLastCmd.parm.mciSeek)));
    }
    else
    {
        return(viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags, MCI_NOTIFY_FAILURE, MCIERR_NONAPPLICABLE_FUNCTION));
    }

}


/****************************************************************************
 * Function: DWORD viscaMciStop - Stop.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_GENERIC_PARMS lpGeneric - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_STOP
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciStop(int iInst, DWORD dwFlags, LPMCI_GENERIC_PARMS lpGeneric)
{
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    char    achPacket[MAXPACKETLENGTH];

    if(dwFlags & MCI_TEST)
       return(viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

    pvcr->Port[iPort].Dev[iDev].wMciCued = 0;

    if(!viscaQueueReset(iInst, MCI_STOP, MCI_NOTIFY_ABORTED))
    {
        // Give up the transport
        pvcr->Port[iPort].Dev[iDev].iInstTransport = -1;
        return (viscaNotifyReturn(iInst, (HWND) lpGeneric->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_HARDWARE));
    }


    viscaQueueCommand(iInst,
                        (BYTE)(iDev + 1),
                        VISCA_STOP,
                        achPacket,
                        viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STOP),
                        1);

    return(viscaDoQueued(iInst, MCI_STOP, dwFlags, (HWND)lpGeneric->dwCallback));

}



/****************************************************************************
 * Function: DWORD viscaMciStep - Step.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      LPMCI_VCR_STEP_PARMS lpStep - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called in response to the MCI_STEP
 *       command.
 ***************************************************************************/
static DWORD NEAR PASCAL
viscaMciStep(int iInst, DWORD dwFlags, LPMCI_VCR_STEP_PARMS lpStep)
{
    UINT    iDev    = pinst[iInst].iDev;
    UINT    iPort   = pinst[iInst].iPort;
    char    achPacket[MAXPACKETLENGTH];
    DWORD   dwFrames = 1L;
    BYTE    bAction;
    DWORD   dwErr;

    if(dwFlags & MCI_TEST)
       return(viscaNotifyReturn(iInst, (HWND) lpStep->dwCallback, dwFlags, MCI_NOTIFY_SUCCESSFUL, MCIERR_NO_ERROR));

    pvcr->Port[iPort].Dev[iDev].wMciCued = 0;

    //
    // We must queue a pause, i.e., seek step must be possible 
    //
    if(!viscaQueueReset(iInst, MCI_STEP, MCI_NOTIFY_ABORTED))
    {
        // Give up the transport
        pvcr->Port[iPort].Dev[iDev].iInstTransport = -1;
        return (viscaNotifyReturn(iInst, (HWND) lpStep->dwCallback, dwFlags,
                MCI_NOTIFY_FAILURE, MCIERR_HARDWARE));
    }

    //
    // We must at least pause, because the from position, etc. 
    //
    dwErr = viscaDoImmediateCommand(iInst, (BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STILL));

    //
    // False means this is a short command */
    //
    if (dwFlags & MCI_VCR_STEP_FRAMES)
        dwFrames = lpStep->dwFrames;
    if (dwFlags & MCI_VCR_STEP_REVERSE)
        bAction = VISCAMODE2FRAMEREVERSE;
    else
        bAction = VISCAMODE2FRAMEFORWARD;
    //
    // Finally send step command as many times as necessary
    //
    if(dwFrames == 0L)
        dwFrames = 1L;

    viscaQueueCommand(iInst,
                        (BYTE) (iDev + 1),
                        VISCA_STEP,
                        achPacket,
                        viscaMessageMD_Mode2(achPacket + 1, bAction),
                        (UINT)dwFrames);

    //
    // This is the backwards compatible kludge.
    //
    if(pvcr->gfFreezeOnStep)
    {
        // Output assumed by default 
        if(pvcr->Port[iPort].Dev[iDev].dwFreezeMode != MCI_VCR_FREEZE_OUTPUT)
        {
            viscaQueueCommand(iInst,
                        (BYTE)(iDev + 1),
                        VISCA_MODESET_OUTPUT,
                        achPacket,
                        viscaMessageENT_FrameMemorySelect(achPacket + 1, VISCADNR),
                        1);
        
    
            DPF(DBG_QUEUE, "^^^Setting freeze input mode.\n");
        }

        viscaQueueCommand(iInst,
                        (BYTE)(iDev + 1),
                        VISCA_FREEZE,
                        achPacket, viscaMessageENT_FrameStill(achPacket + 1, VISCASTILLON),
                        1);
    }
    return(viscaDoQueued(iInst, MCI_STEP, dwFlags, (HWND) lpStep->dwCallback));
}

/****************************************************************************
 * Function: DWORD viscaQueueReset - Reset the queue.
 *
 * Parameters:
 *
 *      int    iInst - Current open instance.
 *
 *      UINT  uMciCmd  - MCI command.
 *             
 *      DWORD dwReason - Reason (abort or supersede) for resetting queue.
 *
 * Returns: TRUE
 *
 ***************************************************************************/
DWORD FAR PASCAL
    viscaQueueReset(int iInst, UINT uMciCmd, DWORD dwReason)
{
    UINT     iPort  = pinst[iInst].iPort;
    UINT     iDev   = pinst[iInst].iDev;
    char     achPacket[MAXPACKETLENGTH];
    DWORD    dwErr;
    int      fTc = 0;

    //
    // Queuelock is here to guarantee the Inst doing the cancel, gets TransportInst next.
    //
    viscaWaitForSingleObject(pinst[iInst].pfQueueLock, FALSE, WAIT_TIMEOUT, pinst[iInst].uDeviceID);
    DPF(DBG_QUEUE, "***Locked Queue.\n");
    //
    // Cancel any ongoing commands.
    //
    if(!viscaCommandCancel(iInst, dwReason))
    {
        // We have failed cancel for some unknown reason!
        viscaReleaseMutex(pinst[iInst].pfQueueLock);
        return (DWORD) FALSE;
    }
    //
    // The mode must be properly set if device is on auto 
    //
    viscaTimecodeCheckAndSet(iInst);

    if(pvcr->Port[iPort].Dev[iDev].uRecordMode == TRUE)
    {
        // Better turn all the settings back to normal eh? 
        dwErr = viscaDoImmediateCommand(iInst,(BYTE)(iDev + 1),
                        achPacket,
                        viscaMessageMD_RecTrack(achPacket + 1,
                                    pvcr->Port[iPort].Dev[iDev].achBeforeInit[2],
                                    pvcr->Port[iPort].Dev[iDev].achBeforeInit[3],
                                    pvcr->Port[iPort].Dev[iDev].achBeforeInit[4],
                                    pvcr->Port[iPort].Dev[iDev].achBeforeInit[5]));

        pvcr->Port[iPort].Dev[iDev].uRecordMode = FALSE;
    }
    //
    // Resume: (play, pause, pause, resume) is ok.
    //
    if(uMciCmd != MCI_PAUSE)
        pvcr->Port[iPort].Dev[iDev].uResume = VISCA_NONE;

    DPF(DBG_QUEUE, "###Claiming transport.\n");

    // scenario: why we need to lock device.
    //  1. play without wait started.
    //  2. pause with wait.
    //  3.
    viscaWaitForSingleObject(pinst[iInst].pfDeviceLock, FALSE, 8000L, 0);
    DPF(DBG_QUEUE, "***Locked device.\n");
    //
    // Claim the transport immediately. It must be null now anyway.
    //
    pvcr->Port[iPort].Dev[iDev].iInstTransport = iInst;
    pvcr->Port[iPort].Dev[iDev].iCmdDone       = 0;
    pvcr->Port[iPort].Dev[iDev].fQueueAbort    = FALSE;
    pvcr->Port[iPort].Dev[iDev].nCmd           = 0;

    viscaReleaseMutex(pinst[iInst].pfDeviceLock);

    //
    // Now that we have claimed we can unlock the queue! 
    //
    viscaReleaseMutex(pinst[iInst].pfQueueLock);
    return (DWORD)TRUE;
}

/****************************************************************************
 * Function: UINT viscaQueueLength - Length of queue.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 * Returns: the length of the queue for this device.
 *
 ***************************************************************************/
static UINT NEAR PASCAL
    viscaQueueLength(int iInst)
{
    UINT iPort  = pinst[iInst].iPort;
    UINT iDev   = pinst[iInst].iDev;

    return pvcr->Port[iPort].Dev[iDev].nCmd;
}

/****************************************************************************
 * Function: BOOL viscaCommandCancel - Cancels ongoing transport commands.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwReason - Reason for cancelling command (abort or supersede)
 *
 * Returns: TRUE if transport can be locked.
 *
 ***************************************************************************/
static BOOL NEAR PASCAL
    viscaCommandCancel(int iInst, DWORD dwReason)
{
    UINT    iPort  = pinst[iInst].iPort;
    UINT    iDev   = pinst[iInst].iDev;
    int     iSocket;

    // cannot lock device until we lock transmission.
    viscaWaitForSingleObject(pinst[iInst].pfTxLock, FALSE, 20000L, pinst[iInst].uDeviceID);
    DPF(DBG_QUEUE, "***Locked transmission\n");

    viscaWaitForSingleObject(pinst[iInst].pfDeviceLock, FALSE, 20000L, 0);
    DPF(DBG_QUEUE, "***Locked device.\n");
    
    if(pvcr->Port[iPort].Dev[iDev].iInstTransport != -1)
    {
        UINT i = 0;
        UINT uBigNum = 60000;

        pvcr->Port[iPort].Dev[iDev].fQueueAbort    = TRUE;
        pvcr->Port[iPort].Dev[iDev].dwReason       = dwReason; // used in commtask when notifying
        //
        // When transmission is not-locked, sockets are valid.
        //
        iSocket = pvcr->Port[iPort].Dev[iDev].iTransportSocket;
        DPF(DBG_QUEUE, "###Cancelling current transport device=%d socket=%d.\n", iDev, iSocket);

        if(iSocket != -1)
        {
            char achPacket[MAXPACKETLENGTH];
            DWORD dwErr;

            // taken from viscamsg.c, there is always a socket with ack. 
            achPacket[1] = MAKESOCKETCANCEL(iSocket);

            // No need wait! This is just a one time spot 
            dwErr = viscaWriteCancel(iInst, (BYTE)(iDev+1), achPacket, 1);
        }

        viscaReleaseSemaphore(pinst[iInst].pfTxLock);


        //
        // No other instance may send commands until we gain control of trasnport!
        //
        if(pvcr->Port[iPort].Dev[iDev].fTimer != FALSE)
        {
            //
            // We must send the abort ourselves, and free transport inst, etc. 
            //
            LPSTR lpstrPacket = pvcr->Port[iPort].Dev[iDev].achPacket;
            UINT  uTimerID    = MAKETIMERID(iPort, iDev);
            //
            // Kill the running timer.
            //
            KillTimer(pvcr->hwndCommNotifyHandler, uTimerID);
            pvcr->Port[iPort].Dev[iDev].fTimer = FALSE;

            DPF(DBG_COMM, "Killed port=%d, device=%d in mcidelay\n", iPort, iDev);
            //
            // packet from address n to address 0
            // 1sss0ddd sss=source ddd=destination, ddd=0
            //
            lpstrPacket[0] = (BYTE) MAKERETURNDEST(iDev);
            lpstrPacket[1] = (BYTE) VISCAREPLYERROR;        // error 
            lpstrPacket[2] = (BYTE) VISCAERRORCANCELLED;    // command cancelled 
            lpstrPacket[3] = (BYTE) VISCAPACKETEND;         // end of packet

            // We must reset now since we will send end.

            viscaResetEvent(pinst[iInst].pfTransportFree);


            pvcr->Port[iPort].Dev[iDev].fTimerMsg = TRUE;
            viscaPacketPrint(lpstrPacket, 4);
            viscaPacketProcess(iPort, lpstrPacket);
            pvcr->Port[iPort].Dev[iDev].fTimerMsg = FALSE;
        }
        else
        {
            viscaResetEvent(pinst[iInst].pfTransportFree);
        }

        viscaReleaseMutex(pinst[iInst].pfDeviceLock);

        // This is a manual reset event. (it holds)
        viscaWaitForSingleObject(pinst[iInst].pfTransportFree, TRUE, 10000L, 0);

    }
    else
    {
        viscaReleaseSemaphore(pinst[iInst].pfTxLock);
        viscaReleaseMutex(pinst[iInst].pfDeviceLock);
    }
    return TRUE;
}

/****************************************************************************
 * Function: DWORD viscaQueueCommand - Queues a command.
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      BYTE  bDest       - Destination device (vcr or BROADCAST).
 *
 *      UINT  uViscaCmd   - The visca command being queued.
 *
 *      LPSTR lpstrPacket - The message being queued.
 *
 *      UINT  cbMessageLength - The length of message being queued.
 *
 *      UINT  uLoopCount  - The number of times this message is to executed.
 *                             If LoopCount = 0, then it is an alternative.
 *
 * Returns: MCIERR_NO_ERROR == 0
 *
 ***************************************************************************/
DWORD NEAR PASCAL
viscaQueueCommand(int iInst,
        BYTE bDest,
        UINT    uViscaCmd,     
        LPSTR   lpstrPacket,  UINT cbMessageLength,
        UINT    uLoopCount)
{
    UINT iPort   = pinst[iInst].iPort;
    UINT iDev    = pinst[iInst].iDev;
    char achPacket[MAXPACKETLENGTH];
    UINT uIndex;
    CmdInfo *lpCmdOne;

#ifdef DEBUG
    UINT i;
#endif
    //
    // Bug in CVD1000 rom. Must put pause between seeks. 
    //
    if( ((pvcr->Port[iPort].Dev[iDev].uModelID == VISCADEVICEVENDORSONY) &&
         (pvcr->Port[iPort].Dev[iDev].uVendorID == VISCADEVICEMODELCVD1000)) &&
        (pvcr->Port[iPort].Dev[iDev].nCmd  ==  0)                            &&
        ((pvcr->Port[iPort].Dev[iDev].wCancelledCmd  == VISCA_SEEK)||
         (pvcr->Port[iPort].Dev[iDev].uLastKnownMode == MCI_MODE_SEEK))      &&
        (uViscaCmd == VISCA_SEEK)                                            &&
        (pvcr->Port[iPort].Dev[iDev].fQueueReenter == FALSE))
    {
        pvcr->Port[iPort].Dev[iDev].fQueueReenter = TRUE;

        viscaQueueCommand(iInst,
                        (BYTE)(iDev + 1),
                        VISCA_SEEK, // Cheat! Say this is a seek (not a stop!)
                        achPacket,
                        viscaMessageMD_Mode1(achPacket + 1, VISCAMODE1STOP),
                        1);

        // This is only used once. When device is freshly opened.
        pvcr->Port[iPort].Dev[iDev].uLastKnownMode = 0;

        DPF(DBG_QUEUE, "---Status: Command cancelled was seek: adding stop to Q.\n");
        pvcr->Port[iPort].Dev[iDev].fQueueReenter = FALSE;
    }
    //
    // Just having a Freeze in queue on step is enough for this 
    //
    if((pvcr->Port[iPort].Dev[iDev].nCmd == 0)  &&
        pvcr->Port[iPort].Dev[iDev].fFrozen     &&
        pvcr->gfFreezeOnStep                    &&
        (pvcr->Port[iPort].Dev[iDev].fQueueReenter == FALSE))
    {

        pvcr->Port[iPort].Dev[iDev].fQueueReenter = TRUE;

        viscaQueueCommand(iInst,
                        (BYTE)(iDev + 1),
                        VISCA_UNFREEZE,
                        achPacket,
                        viscaMessageENT_FrameStill(achPacket + 1, VISCASTILLOFF),
                        1);

        DPF(DBG_QUEUE, "---Status: Adding unfreeze to the queue. Device frozen on auto.\n");
        pvcr->Port[iPort].Dev[iDev].fQueueReenter = FALSE;
    }
    //
    // Do this after any recursive pause call 
    //
    uIndex      = pvcr->Port[iPort].Dev[iDev].nCmd;
    lpCmdOne    = &(pvcr->Port[iPort].Dev[iDev].rgCmd[uIndex]);


    if(uLoopCount != 0)
    {
        // Set the number of alternative to this command to one 
        lpCmdOne->nCmd      = 0;
        lpCmdOne->iCmdDone  = 0;

        // Flags that apply to all the alternatives to this command 
        lpCmdOne->uViscaCmd = uViscaCmd;
        lpCmdOne->uLoopCount= uLoopCount;
        DPF(DBG_QUEUE, "---Status: Q primary cmd #%d:", uIndex);
    }
    else
    {
        // This is an alternative to the last command received 
        uIndex--;
        lpCmdOne = &(pvcr->Port[iPort].Dev[iDev].rgCmd[uIndex]);
        DPF(DBG_QUEUE, "---Status: Q altern. cmd #%d:", uIndex);
    }
    //
    // copy either the primary or the alternative 
    //
    _fmemcpy((LPSTR)lpCmdOne->str[lpCmdOne->nCmd], (LPSTR) lpstrPacket, cbMessageLength + 1);
    lpCmdOne->uLength[lpCmdOne->nCmd] = cbMessageLength;

#ifdef DEBUG 
    for(i=0; i <= lpCmdOne->uLength[lpCmdOne->nCmd]; i++) 
    {
        DPF(DBG_QUEUE, "<%#02x>",((UINT)(BYTE)(lpCmdOne->str[lpCmdOne->nCmd][i])));
    }
    DPF(DBG_QUEUE, "\n");
#endif

    //
    // Always at least one alternative here (the actual command)
    //
    lpCmdOne->nCmd++;

    if(uLoopCount != 0)
    {
        // Increment the total number of commands 
        pvcr->Port[iPort].Dev[iDev].nCmd++;
    }
    return MCIERR_NO_ERROR;
}

/****************************************************************************
 * Function: DWORD viscaDoQueued - Do the queued command (at least start them).
 *
 * Parameters:
 *
 *      int iInst - Current open instance.
 *
 *      DWORD dwFlags - MCI command flags.
 *
 *      HWND  hWnd    - Window to notify on completion.
 *
 * Returns: an MCI error code.
 *
 ***************************************************************************/
DWORD NEAR PASCAL
viscaDoQueued(int iInst, UINT uMciCmd, DWORD dwFlags, HWND hWnd)
{
    UINT    iPort   = pinst[iInst].iPort;
    UINT    iDev    = pinst[iInst].iDev;
    CmdInfo *pcmdCmd        = &(pvcr->Port[iPort].Dev[iDev].rgCmd[0]);// Points to one command.
    LPSTR   lpstrFirst      = pcmdCmd->str[0];
    UINT    cbMessageLength = pcmdCmd->uLength[0];
    BOOL    fWaitResult;

    //
    // Don't need the command cancelled anymore.
    //
    // wCancelled tells us visca command
    //
    pvcr->Port[iPort].Dev[iDev].wCancelledCmd  = 0;
    pvcr->Port[iPort].Dev[iDev].iCancelledInst = 0;
    pvcr->Port[iPort].Dev[iDev].hwndCancelled  = (HWND) 0;
    //
    // Start sending commands.
    //
    if(!viscaWrite(pvcr->Port[iPort].Dev[iDev].iInstTransport, (BYTE) (iDev + 1), lpstrFirst, cbMessageLength, hWnd, dwFlags, TRUE))
        return MCIERR_VCR_CANNOT_WRITE_COMM;

    fWaitResult = viscaWaitCompletion(pvcr->Port[iPort].Dev[iDev].iInstTransport, TRUE, // Yes this is queue.
                            (dwFlags & MCI_WAIT) ? TRUE : FALSE);

    // Timeout errors can only happen while waiting for ack.
    if(pvcr->Port[iPort].Dev[iDev].bReplyFlags & VISCAF_ERROR_TIMEOUT)
    {
        pvcr->Port[iPort].Dev[iDev].fDeviceOk = FALSE;
        // Don't forget to release on error.

        if(pvcr->Port[iPort].Dev[iDev].iInstTransport != -1)
            viscaReleaseAutoParms(iPort, iDev);
        return MCIERR_VCR_READ_TIMEOUT;
    }

    // We must have MCI_WAIT, and this is a break or some other completion error.
    // The error status will always be returned in the notification.
    if(!fWaitResult || (pvcr->Port[iPort].Dev[iDev].bReplyFlags & VISCAF_ERROR))
    {
        // Turn off the waiting flag and return (waiting on error return!)
        if(pvcr->Port[iPort].Dev[iDev].iInstTransport != -1)
            pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].fWaiting = FALSE;

        pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_ACK;

        if(pvcr->Port[iPort].Dev[iDev].bReplyFlags & VISCAF_ERROR)
        {
            // Don't forget to release on error (unless already done).
            if(pvcr->Port[iPort].Dev[iDev].iInstTransport != -1)
                viscaReleaseAutoParms(iPort, iDev);
            return viscaErrorToMCIERR(VISCAREPLYERRORCODE(pinst[iInst].achPacket));
        }
    }

    return MCIERR_NO_ERROR;
}

/****************************************************************************
 * Function: DWORD viscaMciDelayed - Dispatch the delayed (transport) commands.
 *
 * Parameters:
 *
 *      WORD  wDeviceID - MCI device ID.
 *
 *      WORD  wMessage  - MCI command.
 *
 *      DWORD dwParam1  - MCI command flags.
 *
 *      DWORD dwParam2  - Pointer to MCI parameter block.
 *
 * Returns: an MCI error code.
 *
 *       This function is called by viscaMciProc which is called by
 *        DriverProc() to process all MCI commands.
 *
 ***************************************************************************/
DWORD FAR PASCAL
viscaMciDelayed(WORD wDeviceID, WORD wMessage, DWORD dwParam1, DWORD dwParam2)
{
    DWORD           dwRes;
    int   iInst = (int)(UINT)mciGetDriverData(wDeviceID);

    if (iInst == -1)
        return (MCIERR_INVALID_DEVICE_ID);
 
    switch (wMessage)
    {
        case MCI_SIGNAL:
            dwRes = viscaMciSignal(iInst, dwParam1, (LPMCI_VCR_SIGNAL_PARMS)dwParam2);
            break;

        case MCI_SEEK:
            dwRes = viscaMciSeek(iInst, dwParam1, (LPMCI_VCR_SEEK_PARMS)dwParam2);
            break;

        case MCI_PAUSE:
            dwRes = viscaMciPause(iInst, dwParam1, (LPMCI_GENERIC_PARMS)dwParam2);
            break;

        case MCI_PLAY:
            dwRes = viscaMciPlay(iInst, dwParam1, (LPMCI_VCR_PLAY_PARMS)dwParam2);
            break;                
                      
        case MCI_RECORD:
            dwRes = viscaMciRecord(iInst, dwParam1, (LPMCI_VCR_RECORD_PARMS)dwParam2);
            break;                
                      
        case MCI_RESUME:
            dwRes = viscaMciResume(iInst, dwParam1, (LPMCI_GENERIC_PARMS)dwParam2);
            break;

        case MCI_STOP:
            dwRes = viscaMciStop(iInst, dwParam1, (LPMCI_GENERIC_PARMS)dwParam2);
            break;

        case MCI_FREEZE:
            dwRes = viscaMciFreeze(iInst, dwParam1, (LPMCI_GENERIC_PARMS)dwParam2);
            break;

        case MCI_UNFREEZE:
            dwRes = viscaMciUnfreeze(iInst, dwParam1, (LPMCI_GENERIC_PARMS)dwParam2);
            break;

        case MCI_CUE:
            dwRes = viscaMciCue(iInst, dwParam1, (LPMCI_VCR_CUE_PARMS)dwParam2);
            break;

        case MCI_STEP:
            dwRes = viscaMciStep(iInst, dwParam1, (LPMCI_VCR_STEP_PARMS)dwParam2);
            break;
    }

    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\mcivisca\muldiv.asm ===
page    ,132
;---------------------------Module-Header-------------------------------;
;
;   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
;   KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
;   IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
;   PURPOSE.
;
;   Copyright (c) 1992-1995 Microsoft Corporation
;
;   Module Name: MULDIV.ASM
;
;   Contains FIXED point math routines.
;
;-----------------------------------------------------------------------;

?WIN	= 0
?PLM	= 1
?NODATA = 0

        .286

        .xlist
        include cmacros.inc
        include windows.inc
        .list

        externA     __WinFlags

UQUAD   struc
uq0     dw      ?
uq1     dw      ?
uq2     dw      ?
uq3     dw      ?
UQUAD	ends

;       The following two equates are just used as shorthand
;       for the "word ptr" and "byte ptr" overrides.

wptr    equ     word ptr
bptr    equ     byte ptr

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

EAXtoDXAX   macro
        shld    edx,eax,16      ; move HIWORD(eax) to dx
        endm

DXAXtoEAX   macro
        ror     eax,16          ; xchg HIWORD(eax) and LOWORD(eax)
        shrd    eax,edx,16      ; move LOWORD(edx) to HIWORD(eax)
        endm

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs,CodeSeg
	assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; muldiv32
;
; multiples two 32 bit values and then divides the result by a third
; 32 bit value with full 64 bit presision
;
; ulResult = (ulNumber * ulNumerator) / ulDenominator
;
; Entry:
;       dwNumber = number to multiply by nNumerator
;       dwNumerator = number to multiply by nNumber
;       dwDenominator = number to divide the multiplication result by.
;   
; Returns:
;       DX:AX = result of multiplication and division.
; Error Returns:
;       none
; Registers Preserved:
;       DS,ES,SI,DI
; History:
;   Wed 14-June-1990 converted it to 386/286 code. (by checking __WinFlags)
;   Tue 08-May-1990  Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   muldiv32,<PUBLIC,FAR,NODATA,NONWIN>,<>
;       ParmD  ulNumber
;       ParmD  ulNumerator
;       ParmD  ulDenominator
cBegin	<nogen>
	mov	ax,__WinFlags
        test    ax,WF_CPU286+WF_CPU086+WF_CPU186
        jnz     muldiv32_286
        errn$   muldiv32_386
cEnd    <nogen>

cProc   muldiv32_386,<PUBLIC,FAR,NODATA,NONWIN>,<>
;       ParmD  ulNumber
;       ParmD  ulNumerator
;       ParmD  ulDenominator
cBegin  nogen
        .386
        pop     ecx     ; return address
        pop     ebx     ; ulDenominator
        pop     edx     ; ulNumerator
        pop     eax     ; ulNumber

        imul    edx     ; edx:eax = (ulNumber * ulNumerator)
        idiv    ebx     ; eax     = (ulNumber * ulNumerator) / ulDenominator

        EAXtoDXAX       ; covert eax to dx:ax for 16 bit programs

        push    ecx     ; return
        retf

        .286
cEnd    nogen

cProc   muldiv32_286,<PUBLIC,FAR,NODATA,NONWIN>,<di,si>
        ParmD  ulNumber
        ParmD  ulNumerator
        ParmD  ulDenominator
cBegin
        mov     ax,ulNumber.lo
        mov     dx,ulNumber.hi

        mov     bx,ulNumerator.lo
        mov     cx,ulNumerator.hi

        call    dmul

        mov     di,ulDenominator.lo
        mov     si,ulDenominator.hi

        call    qdiv
cEnd

;---------------------------Public-Routine------------------------------;
; idmul
;
; This is an extended precision multiply routine, intended to emulate
; 80386 imul instruction.
;
; Entry:
;       DX:AX = LONG
;       CX:BX = LONG
; Returns:
;       DX:CX:BX:AX = QUAD product
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 23:47:02  Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   idmul,<PUBLIC,NEAR>,<si,di>
        localQ  qTemp
cBegin

; put one argument in safe registers

        mov     si,dx
        mov     di,ax

; do the low order unsigned product

        mul     bx
        mov     qTemp.uq0,ax
        mov     qTemp.uq1,dx

; do the high order signed product

        mov     ax,si
        imul    cx
        mov     qTemp.uq2,ax
        mov     qTemp.uq3,dx

; do a mixed product

        mov     ax,si
        cwd
        and     dx,bx
        sub     qTemp.uq2,dx            ; adjust for sign bit
        sbb     qTemp.uq3,0
        mul     bx
        add     qTemp.uq1,ax
        adc     qTemp.uq2,dx
        adc     qTemp.uq3,0

; do the other mixed product

        mov     ax,cx
        cwd
	and	dx,di
        sub     qTemp.uq2,dx
        sbb     qTemp.uq3,0
        mul     di

; pick up the answer

        mov     bx,ax
        mov     cx,dx
        xor     dx,dx

        mov     ax,qTemp.uq0
        add     bx,qTemp.uq1
        adc     cx,qTemp.uq2
        adc     dx,qTemp.uq3
cEnd

;---------------------------Public-Routine------------------------------;
; dmul
;
; This is an extended precision multiply routine, intended to emulate
; 80386 mul instruction.
;
; Entry:
;       DX:AX = LONG
;       CX:BX = LONG
; Returns:
;       DX:CX:BX:AX = QUAD product
; Registers Destroyed:
;       none
; History:
;  Tue 02-Feb-1988 10:50:44  Copied from idmul and modified.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   dmul,<PUBLIC,NEAR>,<si,di>
        localQ  qTemp
cBegin

; put one argument in safe registers

        mov     si,dx
        mov     di,ax

; do the low order product

        mul     bx
        mov     qTemp.uq0,ax
        mov     qTemp.uq1,dx

; do the high order product

        mov     ax,si
        mul     cx
        mov     qTemp.uq2,ax
        mov     qTemp.uq3,dx

; do a mixed product

        mov     ax,si
        mul     bx
        add     qTemp.uq1,ax
        adc     qTemp.uq2,dx
        adc     qTemp.uq3,0

; do the other mixed product

        mov     ax,cx
        mul     di

; pick up the answer

        mov     bx,ax
        mov     cx,dx
        xor     dx,dx
        mov     ax,qTemp.uq0
        add     bx,qTemp.uq1
        adc     cx,qTemp.uq2
        adc     dx,qTemp.uq3
cEnd

;---------------------------Public-Routine------------------------------;
; iqdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit IDIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two signed numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; This routine just keeps track of the signs and calls qdiv to do the
; real work.
;
; Entry:
;       DX:CX:BX:AX = QUAD Numerator
;       SI:DI       = LONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       DI,SI
; History:
;  Tue 26-Jan-1988 02:49:19  Wrote it.
;-----------------------------------------------------------------------;

WIMP    equ     1

IQDIV_RESULT_SIGN       equ     1
IQDIV_REM_SIGN          equ     2

        assumes ds,nothing
        assumes es,nothing

cProc   iqdiv,<PUBLIC,NEAR>
        localB  flags
cBegin
        mov     flags,0

; take the absolute value of the denominator

        or      si,si
        jns     denominator_is_cool
        xor     flags,IQDIV_RESULT_SIGN
        neg     di
        adc     si,0
        neg     si
denominator_is_cool:

; take the absolute value of the denominator

        or      dx,dx
        jns     numerator_is_cool
        xor     flags,IQDIV_RESULT_SIGN + IQDIV_REM_SIGN
        not     ax
        not     bx
        not     cx
        not     dx
        add     ax,1
        adc     bx,0
        adc     cx,0
        adc     dx,0
numerator_is_cool:

; do the unsigned division

        call    qdiv
ifdef WIMP
        jo      iqdiv_exit
endif

; check for overflow

        or      dx,dx
        jns     have_a_bit_to_spare
ifdef WIMP
        mov     ax,8000h
        dec     ah
        jmp     short iqdiv_exit
else
        int     0                       ; You're toast, Jack!
endif
have_a_bit_to_spare:

; negate the result, if required

        test    flags,IQDIV_RESULT_SIGN
        jz      result_is_done
        neg     ax
        adc     dx,0
        neg     dx
result_is_done:

; negate the remainder, if required

        test    flags,IQDIV_REM_SIGN
        jz      remainder_is_done
        neg     bx
        adc     cx,0
        neg     cx
remainder_is_done:
iqdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; qdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit DIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two unsigned numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; Entry:
;       DX:CX:BX:AX = UQUAD Numerator
;       SI:DI       = ULONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 00:02:09 Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   qdiv,<PUBLIC,NEAR>,<si,di>
        localQ  uqNumerator
        localD  ulDenominator
        localD  ulQuotient
        localW  cShift
cBegin

; stuff the quad word into local memory

        mov     uqNumerator.uq0,ax
        mov     uqNumerator.uq1,bx
        mov     uqNumerator.uq2,cx
        mov     uqNumerator.uq3,dx


; check for overflow

qdiv_restart:
        cmp     si,dx
        ja      qdiv_no_overflow
        jb      qdiv_overflow
        cmp     di,cx
        ja      qdiv_no_overflow
qdiv_overflow:
ifdef WIMP
        mov     ax,8000h
        dec     ah
        jmp     qdiv_exit
else
        int     0                       ; You're toast, Jack!
        jmp     qdiv_restart
endif
qdiv_no_overflow:

; check for a zero Numerator

        or      ax,bx
        or      ax,cx
        or      ax,dx
        jz      qdiv_exit_relay         ; quotient = remainder = 0

; handle the special case when the denominator lives in the low word

        or      si,si
        jnz     not_that_special

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=0):DI

        cmp     di,1                    ; separate out the trivial case
        jz      div_by_one
        xchg    dx,cx                   ; CX = remainder.hi = 0
        mov     ax,bx
        div     di
        mov     bx,ax                   ; BX = quotient.hi
        mov     ax,uqNumerator.uq0
        div     di                      ; AX = quotient.lo
        xchg    bx,dx                   ; DX = quotient.hi, BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit_relay:
        jmp     qdiv_exit

; calculate (DX=0):(CX=0):BX:uqNumerator.uq0 / (SI=0):(DI=1)

div_by_one:
        xchg    dx,bx                   ; DX = quotient.hi, BX = remainder.lo = 0
        mov     ax,uqNumerator.uq0      ; AX = quotient.lo
        jmp     qdiv_exit
not_that_special:

; handle the special case when the denominator lives in the high word

        or      di,di
        jnz     not_this_special_either

; calculate DX:CX:BX:uqNumerator.uq0 / SI:(DI=0)

        cmp     si,1                    ; separate out the trivial case
        jz      div_by_10000h
        mov     ax,cx
        div     si
        mov     cx,ax                   ; CX = quotient.hi
        mov     ax,bx
        div     si                      ; AX = quotient.lo
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
        jmp     qdiv_exit

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=1):(DI=0)

div_by_10000h:
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi = 0
        mov     ax,bx                   ; AX = quotient.lo
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
        jmp     qdiv_exit
not_this_special_either:

; normalize the denominator

        mov     dx,si
        mov     ax,di
        call    ulNormalize             ; DX:AX = normalized denominator
        mov     cShift,cx               ; CX < 16
        mov     ulDenominator.lo,ax
        mov     ulDenominator.hi,dx


; shift the Numerator by the same amount

        jcxz    numerator_is_shifted
        mov     si,-1
        shl     si,cl
        not     si                      ; SI = mask
        mov     bx,uqNumerator.uq3
        shl     bx,cl
        mov     ax,uqNumerator.uq2
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq3,bx
        xor     ax,di
        mov     bx,uqNumerator.uq1
        rol     bx,cl
        mov     di,si
        and     di,bx
        or      ax,di
        mov     uqNumerator.uq2,ax
        xor     bx,di
        mov     ax,uqNumerator.uq0
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq1,bx
        xor     ax,di
        mov     uqNumerator.uq0,ax
numerator_is_shifted:

; set up registers for division

        mov     dx,uqNumerator.uq3
        mov     ax,uqNumerator.uq2
        mov     di,uqNumerator.uq1
        mov     cx,ulDenominator.hi
        mov     bx,ulDenominator.lo

; check for case when Denominator has only 16 bits

        or      bx,bx
        jnz     must_do_long_division
        div     cx
        mov     si,ax
        mov     ax,uqNumerator.uq1
        div     cx
        xchg    si,dx                   ; DX:AX = quotient
        mov     di,uqNumerator.uq0      ; SI:DI = remainder (shifted)
        jmp     short unshift_remainder
must_do_long_division:

; do the long division, part IZ@NL@%

        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      first_division_is_safe
        mov     ulQuotient.hi,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short first_adjuster
first_division_is_safe:
        div     cx
        mov     ulQuotient.hi,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     first_adjuster_done     ; The remainder is UNSIGNED!  We have
first_adjuster:                         ; to use the carry flag to keep track
        dec     ulQuotient.hi           ; of the sign.  The adjuster loop
        add     di,bx                   ; watches for a change to the carry
        adc     si,cx                   ; flag which would indicate a sign
        jnc     first_adjuster          ; change IF we had more bits to keep
first_adjuster_done:                    ; a sign in.

; do the long division, part II

        mov     dx,si
        mov     ax,di
        mov     di,uqNumerator.uq0
        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      second_division_is_safe
        mov     ulQuotient.lo,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short second_adjuster
second_division_is_safe:
        div     cx
        mov     ulQuotient.lo,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     second_adjuster_done
second_adjuster:
        dec     ulQuotient.lo
        add     di,bx
        adc     si,cx
        jnc     second_adjuster
second_adjuster_done:
        mov     ax,ulQuotient.lo
        mov     dx,ulQuotient.hi

; unshift the remainder in SI:DI

unshift_remainder:
        mov     cx,cShift
        jcxz    remainder_unshifted
        mov     bx,-1
        shr     bx,cl
        not     bx
        shr     di,cl
        ror     si,cl
        and     bx,si
        or      di,bx
        xor     si,bx
remainder_unshifted:
        mov     cx,si
        mov     bx,di
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; ulNormalize
;
; Normalizes a ULONG so that the highest order bit is 1.  Returns the
; number of shifts done.  Also returns ZF=1 if the ULONG was zero.
;
; Entry:
;       DX:AX = ULONG
; Returns:
;       DX:AX = normalized ULONG
;       CX    = shift count
;       ZF    = 1 if the ULONG is zero, 0 otherwise
; Registers Destroyed:
;       none
; History:
;  Mon 25-Jan-1988 22:07:03  Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   ulNormalize,<PUBLIC,NEAR>
cBegin

; shift by words

        xor     cx,cx
        or      dx,dx
        js      ulNormalize_exit
        jnz     top_word_ok
        xchg    ax,dx
        or      dx,dx
        jz      ulNormalize_exit        ; the zero exit
        mov     cl,16
        js      ulNormalize_exit
top_word_ok:

; shift by bytes

        or      dh,dh
        jnz     top_byte_ok
        xchg    dh,dl
        xchg    dl,ah
        xchg    ah,al
        add     cl,8
        or      dh,dh
        js      ulNormalize_exit
top_byte_ok:

; do the rest by bits

        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
ulNormalize_exit:
cEnd

sEnd   CodeSeg

       end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\mcivisca\vcr.h ===
/***************************************************************************
 *                                                                         *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY  *
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE    *
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR  *
 *  PURPOSE.                                                               *
 *                                                                         *
 *  Copyright (c) 1993-1995 Microsoft Corporation
 *                                                                         *
 * File:  vcr.h                                                            *
 * Title:           VCR-MCI Command Table Include File                     *
 *                                                                         *
 ***************************************************************************/

/* string resource base for vcr device type */
#define MCI_VCR_OFFSET                          1280

/* system MCI commands */
#define MCI_LIST                                0x0878
#define MCI_SETAUDIO                            0x0873 
#define MCI_SETVIDEO                            0x0876 
#define MCI_SIGNAL                              0x0875 

/* custom MCI commands for VCRs */
#define MCI_MARK                                (MCI_USER_MESSAGES + 0)
#define MCI_INDEX                               (MCI_USER_MESSAGES + 1)
#define MCI_SETTUNER                            (MCI_USER_MESSAGES + 2)
#define MCI_SETVCR                              (MCI_USER_MESSAGES + 3)
#define MCI_SETTIMECODE                         (MCI_USER_MESSAGES + 4)

/* Test is appplicable to all commands */
#define MCI_TEST                                0x00000020L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_VCR_GETDEVCAPS_CAN_DETECT_LENGTH    0x00004001L
#define MCI_VCR_GETDEVCAPS_SEEK_ACCURACY        0x00004002L
#define MCI_VCR_GETDEVCAPS_HAS_CLOCK            0x00004003L
#define MCI_VCR_GETDEVCAPS_CAN_REVERSE          0x00004004L
#define MCI_VCR_GETDEVCAPS_NUMBER_OF_MARKS      0x00004005L
#define MCI_VCR_GETDEVCAPS_CAN_TEST             0x00004006L
#define MCI_VCR_GETDEVCAPS_CAN_PREROLL          0x00004007L
#define MCI_VCR_GETDEVCAPS_CAN_PREVIEW          0x00004008L
#define MCI_VCR_GETDEVCAPS_CAN_MONITOR_SOURCES  0x00004009L
#define MCI_VCR_GETDEVCAPS_HAS_TIMECODE         0x0000400AL
#define MCI_VCR_GETDEVCAPS_CAN_FREEZE           0x0000401BL
#define MCI_VCR_GETDEVCAPS_CLOCK_INCREMENT_RATE 0x0000401CL

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_VCR_INFO_VERSION                    0x00010000L

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_VCR_PLAY_REVERSE                    0x00010000L
#define MCI_VCR_PLAY_AT                         0x00020000L
#define MCI_VCR_PLAY_SCAN                       0x00040000L

/* flags for dwFlags parameter of MCI_RECORD command message */
#define MCI_VCR_RECORD_INITIALIZE               0x00010000L
#define MCI_VCR_RECORD_AT                       0x00020000L
#define MCI_VCR_RECORD_PREVIEW                  0x00040000L

/* flags for dwFlags parameter of MCI_CUE command message */
#define MCI_VCR_CUE_INPUT                       0x00010000L
#define MCI_VCR_CUE_OUTPUT                      0x00020000L
#define MCI_VCR_CUE_PREROLL                     0x00040000L
#define MCI_VCR_CUE_REVERSE                     0x00080000L

/* flags for dwFlags parameter of MCI_SEEK command message */
#define MCI_VCR_SEEK_REVERSE                    0x00010000L
#define MCI_VCR_SEEK_MARK                       0x00020000L
#define MCI_VCR_SEEK_AT                         0x00040000L
                                               
/* flags for dwFlags parameter of MCI_SETTUNER command message */
#define MCI_VCR_SETTUNER_CHANNEL                0x00010000L
#define MCI_VCR_SETTUNER_CHANNEL_UP             0x00020000L
#define MCI_VCR_SETTUNER_CHANNEL_DOWN           0x00040000L
#define MCI_VCR_SETTUNER_CHANNEL_SEEK_UP        0x00080000L
#define MCI_VCR_SETTUNER_CHANNEL_SEEK_DOWN      0x00100000L
#define MCI_VCR_SETTUNER_NUMBER                 0x00200000L

/* flags for dwFlags parameter of MCI_SET command message */
#define MCI_VCR_SET_TIME_MODE                   0x00010000L
#define MCI_VCR_SET_POWER                       0x00020000L
#define MCI_VCR_SET_RECORD_FORMAT               0x00040000L
#define MCI_VCR_SET_COUNTER_FORMAT              0x00080000L
#define MCI_VCR_SET_INDEX                       0x00100000L
#define MCI_VCR_SET_ASSEMBLE_RECORD             0x00200000L
#define MCI_VCR_SET_TRACKING                    0x00400000L
#define MCI_VCR_SET_SPEED                       0x00800000L
#define MCI_VCR_SET_TAPE_LENGTH                 0x01000000L
#define MCI_VCR_SET_COUNTER_VALUE               0x02000000L
#define MCI_VCR_SET_CLOCK                       0x04000000L
#define MCI_VCR_SET_PAUSE_TIMEOUT               0x08000000L
#define MCI_VCR_SET_PREROLL_DURATION            0x10000000L
#define MCI_VCR_SET_POSTROLL_DURATION           0x20000000L

/* flags for dwItem parameter of MCI_SETTIMECODE commmand message */
#define MCI_VCR_SETTIMECODE_RECORD              0x00010000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_VCR_STATUS_FRAME_RATE               0x00004001L /* Frame rate   */
#define MCI_VCR_STATUS_SPEED                    0x00004002L /* Speed        */
#define MCI_VCR_STATUS_MEDIA_TYPE               0x00004003L
#define MCI_VCR_STATUS_RECORD_FORMAT            0x00004004L
#define MCI_VCR_STATUS_PLAY_FORMAT              0x00004005L
#define MCI_VCR_STATUS_AUDIO_SOURCE             0x00004006L
#define MCI_VCR_STATUS_AUDIO_SOURCE_NUMBER      0x00004007L
#define MCI_VCR_STATUS_VIDEO_SOURCE             0x00004008L
#define MCI_VCR_STATUS_VIDEO_SOURCE_NUMBER      0x00004009L
#define MCI_VCR_STATUS_AUDIO_MONITOR            0x0000400AL
#define MCI_VCR_STATUS_AUDIO_MONITOR_NUMBER     0x0000400BL
#define MCI_VCR_STATUS_VIDEO_MONITOR            0x0000400CL
#define MCI_VCR_STATUS_VIDEO_MONITOR_NUMBER     0x0000400DL
#define MCI_VCR_STATUS_INDEX_ON                 0x0000400EL
#define MCI_VCR_STATUS_INDEX                    0x0000400FL
#define MCI_VCR_STATUS_COUNTER_FORMAT           0x00004010L
#define MCI_VCR_STATUS_COUNTER_RESOLUTION       0x00004011L
#define MCI_VCR_STATUS_TIMECODE_TYPE            0x00004012L
#define MCI_VCR_STATUS_COUNTER_VALUE            0x00004013L
#define MCI_VCR_STATUS_TUNER_CHANNEL            0x00004014L
#define MCI_VCR_STATUS_WRITE_PROTECTED          0x00004015L
#define MCI_VCR_STATUS_TIMECODE_RECORD          0x00004016L
#define MCI_VCR_STATUS_VIDEO_RECORD             0x00004017L
#define MCI_VCR_STATUS_AUDIO_RECORD             0x00004018L
#define MCI_VCR_STATUS_TIME_TYPE                0x00004019L
#define MCI_VCR_STATUS_TIME_MODE                0x0000401AL
#define MCI_VCR_STATUS_POWER_ON                 0x0000401BL
#define MCI_VCR_STATUS_CLOCK                    0x0000401CL
#define MCI_VCR_STATUS_ASSEMBLE_RECORD          0x0000401DL
#define MCI_VCR_STATUS_TIMECODE_PRESENT         0x0000401EL
#define MCI_VCR_STATUS_NUMBER_OF_VIDEO_TRACKS   0x0000401FL
#define MCI_VCR_STATUS_NUMBER_OF_AUDIO_TRACKS   0x00004020L
#define MCI_VCR_STATUS_CLOCK_ID                 0x00004021L
#define MCI_VCR_STATUS_PAUSE_TIMEOUT            0x00004022L
#define MCI_VCR_STATUS_PREROLL_DURATION         0x00004023L
#define MCI_VCR_STATUS_POSTROLL_DURATION        0x00004024L
#define MCI_VCR_STATUS_VIDEO                    0x00004025L
#define MCI_VCR_STATUS_AUDIO                    0x00004026L

#define MCI_VCR_STATUS_NUMBER                   0x00080000L

/* flags for dwFlags parameter of MCI_ESCAPE command message */
#define MCI_VCR_ESCAPE_STRING                   0x00000100L

/* flags for dwFlags parameter of MCI_LIST command message */
#define MCI_VCR_LIST_VIDEO_SOURCE               0x00010000L
#define MCI_VCR_LIST_AUDIO_SOURCE               0x00020000L
#define MCI_VCR_LIST_COUNT                      0x00040000L
#define MCI_VCR_LIST_NUMBER                     0x00080000L

/* flags for dwFlags parameter of MCI_MARK command message */
#define MCI_VCR_MARK_WRITE                      0x00010000L
#define MCI_VCR_MARK_ERASE                      0x00020000L

/* flags for dwFlags parameter for MCI_SETAUDIO command message */
#define MCI_VCR_SETAUDIO_RECORD                 0x00010000L
#define MCI_VCR_SETAUDIO_SOURCE                 0x00020000L
#define MCI_VCR_SETAUDIO_MONITOR                0x00040000L
#define MCI_VCR_SETAUDIO_TO                     0x00200000L
#define MCI_VCR_SETAUDIO_NUMBER                 0x00400000L

/* flags for dwFlags parameter for MCI_SETVIDEO command message */
#define MCI_VCR_SETVIDEO_RECORD                 0x00010000L
#define MCI_VCR_SETVIDEO_SOURCE                 0x00020000L
#define MCI_VCR_SETVIDEO_MONITOR                0x00040000L
#define MCI_VCR_SETVIDEO_TO                     0x00100000L
#define MCI_VCR_SETVIDEO_NUMBER                 0x00200000L

/* The following is the function digitalvideo drivers must use 
 * to signal when a frame marked by the SIGNAL command has been rendered:
 *
 *  SEND_VCRSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos )
 *
 * The following is a description of the parameters:
 *
 *  dwFlags    - the dwFlags parameter passed when the signal was set
 *  dwCallback - the dwCallback value from the MCI_VCR_SIGNAL_PARMS struct
 *               used to set the signal
 *  hDriver    - the handle assigned to the driver by MMSYSTEM when the 
 *               device was opened
 *  wDeviceID  - the device ID
 *  dwUser     - the dwUserParm value from the MCI_VCR_SIGNAL_PARMS struct
 *               used to set the signal
 *  dwPos      - the position at which the signal was sent, in the current
 *               time format.
 *
 * The window indicated by the handle in the dwCallback field is notified 
 * by means of a Windows message with the following form:
 *
 * msg    = MM_MCISIGNAL
 * wParam = wDeviceID of the sending driver 
 * lParam = the uservalue specified or the position the signal was sent
 *          at; the latter if the MCI_VCR_SIGNAL_POSITION flag was set 
 *          in the dwFlags parameter when the signal was created.
 */

#define SEND_VCRSIGNAL(dwFlags, dwCallback, hDriver, wDeviceID, dwUser, dwPos ) \
  DriverCallback( (dwCallback), DCB_WINDOW, (HANDLE)(wDeviceID), MM_MCISIGNAL,\
  hDriver, ((dwFlags) & MCI_VCR_SIGNAL_POSITION) ? (dwPos):(dwUser),\
  ((dwFlags) & MCI_VCR_SIGNAL_POSITION) ? (dwUser):(dwPos))


/* Window message for signal notification */
#define MM_MCISIGNAL                            0x3CB

/* flags for dwFlags parameter of MCI_SIGNAL command message */
#define MCI_VCR_SIGNAL_AT                       0x00010000L
#define MCI_VCR_SIGNAL_EVERY                    0x00020000L
#define MCI_VCR_SIGNAL_USERVAL                  0x00040000L
#define MCI_VCR_SIGNAL_CANCEL                   0x00080000L
#define MCI_VCR_SIGNAL_POSITION                 0x00100000L

/* flags for dwFlags parameter of MCI_STEP command message */
#define MCI_VCR_STEP_FRAMES                     0x00010000L
#define MCI_VCR_STEP_REVERSE                    0x00020000L

/* flags for dwFlags parameter of MCI_FREEZE command message */
#define MCI_VCR_FREEZE_INPUT                    0x00010000L
#define MCI_VCR_FREEZE_OUTPUT                   0x00020000L
#define MCI_VCR_FREEZE_FIELD                    0x00040000L
#define MCI_VCR_FREEZE_FRAME                    0x00080000L

/* flags for dwFlags parameter of MCI_UNFREEZE command message */
#define MCI_VCR_UNFREEZE_INPUT                  0x00010000L
#define MCI_VCR_UNFREEZE_OUTPUT                 0x00020000L

/* string resource values for vcr media types */
#define MCI_VCR_MEDIA_8MM                       (MCI_VCR_OFFSET + 1)
#define MCI_VCR_MEDIA_HI8                       (MCI_VCR_OFFSET + 2)
#define MCI_VCR_MEDIA_VHS                       (MCI_VCR_OFFSET + 3)
#define MCI_VCR_MEDIA_SVHS                      (MCI_VCR_OFFSET + 4)
#define MCI_VCR_MEDIA_BETA                      (MCI_VCR_OFFSET + 5)
#define MCI_VCR_MEDIA_EDBETA                    (MCI_VCR_OFFSET + 6)
#define MCI_VCR_MEDIA_OTHER                     (MCI_VCR_OFFSET + 7)

/* string resource values for vcr play/record formats */
#define MCI_VCR_FORMAT_SP                       (MCI_VCR_OFFSET + 8)
#define MCI_VCR_FORMAT_LP                       (MCI_VCR_OFFSET + 9)
#define MCI_VCR_FORMAT_EP                       (MCI_VCR_OFFSET + 10)
#define MCI_VCR_FORMAT_OTHER                    (MCI_VCR_OFFSET + 11)

/* string resource values for timecode types */
#define MCI_VCR_TIME_TIMECODE                   (MCI_VCR_OFFSET + 12)
#define MCI_VCR_TIME_COUNTER                    (MCI_VCR_OFFSET + 13)
#define MCI_VCR_TIME_DETECT                     (MCI_VCR_OFFSET + 14)

/* string resource values for src types */
#define MCI_VCR_SRC_TYPE_TUNER                  (MCI_VCR_OFFSET + 15)
#define MCI_VCR_SRC_TYPE_LINE                   (MCI_VCR_OFFSET + 16)
#define MCI_VCR_SRC_TYPE_SVIDEO                 (MCI_VCR_OFFSET + 17)
#define MCI_VCR_SRC_TYPE_RGB                    (MCI_VCR_OFFSET + 18)
#define MCI_VCR_SRC_TYPE_AUX                    (MCI_VCR_OFFSET + 19)
#define MCI_VCR_SRC_TYPE_GENERIC                (MCI_VCR_OFFSET + 20)
#define MCI_VCR_SRC_TYPE_MUTE                   (MCI_VCR_OFFSET + 21)
#define MCI_VCR_SRC_TYPE_OUTPUT                 (MCI_VCR_OFFSET + 22)

/* string resource values for vcr counters */
#define MCI_VCR_INDEX_TIMECODE                  (MCI_VCR_OFFSET + 23)         
#define MCI_VCR_INDEX_COUNTER                   (MCI_VCR_OFFSET + 24)   
#define MCI_VCR_INDEX_DATE                      (MCI_VCR_OFFSET + 25)
#define MCI_VCR_INDEX_TIME                      (MCI_VCR_OFFSET + 26)

/* string resources for timecode type and counter resolution */
#define MCI_VCR_COUNTER_RES_SECONDS             (MCI_VCR_OFFSET + 27)            
#define MCI_VCR_COUNTER_RES_FRAMES              (MCI_VCR_OFFSET + 28)

#define MCI_VCR_TIMECODE_TYPE_SMPTE             (MCI_VCR_OFFSET + 29)
#define MCI_VCR_TIMECODE_TYPE_SMPTE_DROP        (MCI_VCR_OFFSET + 30)
#define MCI_VCR_TIMECODE_TYPE_OTHER             (MCI_VCR_OFFSET + 31)
#define MCI_VCR_TIMECODE_TYPE_NONE              (MCI_VCR_OFFSET + 32)

#define MCI_VCR_PLUS                            (MCI_VCR_OFFSET + 33)
#define MCI_VCR_MINUS                           (MCI_VCR_OFFSET + 34)
#define MCI_VCR_RESET                           (MCI_VCR_OFFSET + 35)

#ifndef RC_INVOKED

/* parameter block for MCI_SEEK command message */
typedef struct tagMCI_VCR_SEEK_PARMS {
    DWORD   dwCallback;
    DWORD   dwTo;
    DWORD   dwMark;
    DWORD   dwAt;
} MCI_VCR_SEEK_PARMS;
typedef MCI_VCR_SEEK_PARMS FAR *LPMCI_VCR_SEEK_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_VCR_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTimeMode;
    DWORD   dwRecordFormat;
    DWORD   dwCounterFormat;
    DWORD   dwIndex;
    DWORD   dwTracking;
    DWORD   dwSpeed;
    DWORD   dwLength;
    DWORD   dwCounter;
    DWORD   dwClock;
    DWORD   dwPauseTimeout;
    DWORD   dwPrerollDuration;
    DWORD   dwPostrollDuration;
} MCI_VCR_SET_PARMS;
typedef MCI_VCR_SET_PARMS FAR *LPMCI_VCR_SET_PARMS;

/* parameter block for MCI_VCR_SETTUNER command message */
typedef struct tagMCI_VCR_SETTUNER_PARMS {
    DWORD   dwCallback;
    DWORD   dwChannel;
    DWORD   dwNumber;
} MCI_VCR_SETTUNER_PARMS;
typedef MCI_VCR_SETTUNER_PARMS FAR *LPMCI_VCR_SETTUNER_PARMS;

/* parameter block for MCI_ESCAPE command message */
typedef struct tagMCI_VCR_ESCAPE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrCommand;
} MCI_VCR_ESCAPE_PARMS;
typedef MCI_VCR_ESCAPE_PARMS FAR *LPMCI_VCR_ESCAPE_PARMS;

/* parameter block for MCI_LIST command message */
typedef struct tagMCI_VCR_LIST_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwNumber;
} MCI_VCR_LIST_PARMS;
typedef MCI_VCR_LIST_PARMS FAR *LPMCI_VCR_LIST_PARMS;

/* parameter block for MCI_RECORD command message */
typedef struct tagMCI_VCR_RECORD_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwAt;
} MCI_VCR_RECORD_PARMS;
typedef MCI_VCR_RECORD_PARMS FAR *LPMCI_VCR_RECORD_PARMS;

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_VCR_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwAt;
} MCI_VCR_PLAY_PARMS;
typedef MCI_VCR_PLAY_PARMS FAR *LPMCI_VCR_PLAY_PARMS;

/* parameter block for MCI_SETAUDIO command message */
typedef struct tagMCI_VCR_SETAUDIO_PARMS {
    DWORD   dwCallback;
    DWORD   dwTrack;
    DWORD   dwTo;
    DWORD   dwNumber;
} MCI_VCR_SETAUDIO_PARMS;
typedef MCI_VCR_SETAUDIO_PARMS FAR *LPMCI_VCR_SETAUDIO_PARMS;

/* parameter block for MCI_SIGNAL command message */
typedef struct tagMCI_VCR_SIGNAL_PARMS {
    DWORD   dwCallback;
    DWORD   dwPosition;
    DWORD   dwPeriod;
    DWORD   dwUserParm;
} MCI_VCR_SIGNAL_PARMS;
typedef MCI_VCR_SIGNAL_PARMS FAR * LPMCI_VCR_SIGNAL_PARMS;

/* parameter block for MCI_VCR_STATUS command message */
typedef struct tagMCI_VCR_STATUS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
    DWORD   dwNumber;
} MCI_VCR_STATUS_PARMS;
typedef MCI_VCR_STATUS_PARMS FAR * LPMCI_VCR_STATUS_PARMS;

/* parameter block for MCI_SETVIDEO command message */
typedef struct tagMCI_VCR_SETVIDEO_PARMS {
    DWORD   dwCallback;
    DWORD   dwTrack;
    DWORD   dwTo;
    DWORD   dwNumber;
} MCI_VCR_SETVIDEO_PARMS;
typedef MCI_VCR_SETVIDEO_PARMS FAR *LPMCI_VCR_SETVIDEO_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_VCR_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VCR_STEP_PARMS;
typedef MCI_VCR_STEP_PARMS FAR *LPMCI_VCR_STEP_PARMS;

/* parameter block for MCI_CUE command message */
typedef struct tagMCI_VCR_CUE_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_VCR_CUE_PARMS;
typedef MCI_VCR_CUE_PARMS FAR *LPMCI_VCR_CUE_PARMS;

#endif /* NOT RC_INVOKED */

/* VCR error codes */
#define MCIERR_VCR_CANNOT_OPEN_COMM         (MCIERR_CUSTOM_DRIVER_BASE + 1)
#define MCIERR_VCR_CANNOT_WRITE_COMM        (MCIERR_CUSTOM_DRIVER_BASE + 2)
#define MCIERR_VCR_READ_TIMEOUT             (MCIERR_CUSTOM_DRIVER_BASE + 3)
#define MCIERR_VCR_COMMAND_BUFFER_FULL      (MCIERR_CUSTOM_DRIVER_BASE + 4)
#define MCIERR_VCR_COMMAND_CANCELLED        (MCIERR_CUSTOM_DRIVER_BASE + 5)
#define MCIERR_VCR_POWER_OFF                (MCIERR_CUSTOM_DRIVER_BASE + 6)
#define MCIERR_VCR_COMMAND_FAILED           (MCIERR_CUSTOM_DRIVER_BASE + 7)
#define MCIERR_VCR_SEARCH                   (MCIERR_CUSTOM_DRIVER_BASE + 8)
#define MCIERR_VCR_CONDITION                (MCIERR_CUSTOM_DRIVER_BASE + 9)
#define MCIERR_VCR_CAMERA_MODE              (MCIERR_CUSTOM_DRIVER_BASE + 10)
#define MCIERR_VCR_VCR_MODE                 (MCIERR_CUSTOM_DRIVER_BASE + 11)
#define MCIERR_VCR_COUNTER_TYPE             (MCIERR_CUSTOM_DRIVER_BASE + 12)
#define MCIERR_VCR_TUNER                    (MCIERR_CUSTOM_DRIVER_BASE + 13)
#define MCIERR_VCR_EMERGENCY_STOP           (MCIERR_CUSTOM_DRIVER_BASE + 14)
#define MCIERR_VCR_MEDIA_UNMOUNTED          (MCIERR_CUSTOM_DRIVER_BASE + 15)
#define MCIERR_VCR_REGISTER                 (MCIERR_CUSTOM_DRIVER_BASE + 16)
#define MCIERR_VCR_TRACK_FAILURE            (MCIERR_CUSTOM_DRIVER_BASE + 17)
#define MCIERR_VCR_CUE_FAILED_FLAGS         (MCIERR_CUSTOM_DRIVER_BASE + 18)
#define MCIERR_VCR_ISWRITEPROTECTED         (MCIERR_CUSTOM_DRIVER_BASE + 19)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\mcivisca\mcivisca.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992-1995 Microsoft Corporation
 *
 *  MCIVISCA.H
 *
 *  MCI ViSCA Device Driver
 *
 *  Description:
 *
 *      Driver constants, macros, structures, and globals
 *
 ***************************************************************************/

//
// Defines for NT compatibility.
//
#ifdef _WIN32
#define CODESEGCHAR     WCHAR
#define LOADDS
#define VISCADEVHANDLE  HANDLE
#define VISCAINSTHANDLE HANDLE
#define VISCACOMMHANDLE HANDLE
#define VISCAHTASK      DWORD
#define OWNED(a)        a
#define WINWORD(a)      a
#define BAD_COMM        NULL
#define MCloseComm(a)   CloseHandle(a)
#define MGetCurrentTask GetCurrentProcessId
#define MY_INFINITE     INFINITE
#else
#define CODESEGCHAR     char  _based(_segname("_CODE"))
#define TEXT(a)         a
#define LOADDS          __loadds
#define WCHAR           char
#define VISCADEVHANDLE  BOOL
#define VISCAINSTHANDLE BOOL FAR *
#define VISCACOMMHANDLE int
#define VISCAHTASK      HTASK
#define WAIT_TIMEOUT    0xffffffff
#define MY_INFINITE     0xffffffff
#define LPWSTR          LPSTR
#define LPCWSTR         LPCSTR
#define OWNED(a)        &a
#define WINWORD(a)      LOWORD(a)
#define BAD_COMM        -1
#define MCloseComm(a)   CloseComm(a)
#define MGetCurrentTask GetCurrentTask
#endif

#define MINMAX(x,l,u)   (MIN(MAX((x), (l)), (u))
#define INRANGE(x,l,u)  (((x) >= (l)) && ((x) <= (u)))
#define ROLLOVER        0xFFFFFFFF
#define MShortWait(st, t, w) (((t < st) && ((t + (ROLLOVER - st)) > w)) || ((t - st) > w))


#define VCRNAME_LENGTH     30       //Length of name in table.
#define FILENAME_LENGTH    20       //mcivisca.drv type stuff.
#define ALLENTRIES_LENGTH  512      //Allentries (like vcr, vcr1, waveaudio, cd, 
#define ONEENTRY_LENGTH    128      //Oneentry (the name, i.e. vcr, vcr1)
#define MESSAGE_LENGTH     128      //Messages for config. dialog mess. boxes.
#define TITLE_LENGTH       30       //Title for configuration dialog mess. boxes.
#define PORT_LENGTH        10       //Sizeof commport string

//
// Timecode checing status
//
#define TC_UNKNOWN    0
#define TC_WAITING    1
#define TC_DONE       2

#ifndef RC_INVOKED

#define MCIERR_NO_ERROR MMSYSERR_NOERROR

#define MAX_INSTANCES   100

#define MAXPORTS        4                   // maximum # of serial ports 
#define MAXDEVICES      7                   // maximum # of ViSCA devices per serial port (computer makes 8)
#define MAXSOCKETS      0x0f                // maximum # of sockets per ViSCA device 
#define MAXINPUTS       5                   // maximum # of inputs per ViSCA device 

#define MAXQUEUED       8

#define DEFAULTPORT     1
#define DEFAULTDEVICE   1

//
// The following are needed for the background task that reads comm input 
//
#define TASKINIT            1
#define TASKIDLE            2
#define TASKCLOSE           3
#define TASKOPENCOMM        4
#define TASKCLOSECOMM       5
#define TASKOPENDEVICE      6
#define TASKCLOSEDEVICE     7
#define TASKPUNCHCLOCK      8

//
// This structure is free-floating, and is allocated
// for every open instance of the driver (with open vcr alias a)
//
typedef struct tagOpenInstance {
    BOOL                    fInUse;
    DWORD                   pidThisInstance;
    VISCADEVHANDLE          fCompletionEvent;  // We own these.
    VISCADEVHANDLE          fAckEvent;
    UINT                    uDeviceID;      // MCI Device ID
    UINT                    iPort;          // Serial comm port # (0..3)
    UINT                    iDev;           // Device # in chain (0..6)
    int                     nSignals;       // Number of signals to this instance.
    DWORD                   dwSIgnalFlags;  // Flags for signal.
    MCI_VCR_SIGNAL_PARMS    signal;         // The signal structure.
    DWORD                   dwTimeFormat;   // Time format
    DWORD                   dwCounterFormat;// Counter format
    HWND                    hwndNotify;     // Window to receive notify, NULL if none
    BOOL                    fWaiting;       // Waiting for response?
    BYTE                    bReplyFlags;    // Reply flags.
    //
    // All Locks are aliased into each instance, so everyone has a private
    // version of each handle (and the background uses the ones in their
    // initial places (global, port, or device).
    //
    BOOL                    fGlobalHandles;
    BOOL                    fPortHandles;
    BOOL                    fDeviceHandles;
    VISCAINSTHANDLE         pfTxLock;
    VISCAINSTHANDLE         pfQueueLock;
    VISCAINSTHANDLE         pfTaskLock;
    VISCAINSTHANDLE         pfTaskWorkDone;
    VISCAINSTHANDLE         pfTransportFree;
    VISCAINSTHANDLE         pfDeviceLock;
    VISCAINSTHANDLE         pfAutoCompletion;
    VISCAINSTHANDLE         pfAutoAck;
#ifdef _WIN32    
    VISCAINSTHANDLE         pfTxBuffer;
    VISCAINSTHANDLE         pfTxReady;
#endif
    char                    achPacket[MAXPACKETLENGTH];
} OpenInstance, *POpenInstance;
//
// Each port/device has multiple sockets with multiple reply instances 
//
#define SOCKET_NONE         0
#define SOCKET_WAITING      1
#define SOCKET_NOTIFY       2


#define VISCA_WAITTIMEOUT           20000          // 20 seconds.
#define ACK_TIMEOUT                 8000
#define ACK_TIMERID                 0x9999          // 7 ports/ 7 devs max so this is bigger than all.
#define MAKEDEST(bDest)             ((BYTE)(0x80 | (MASTERADDRESS << 4) | (bDest & 0x0F)))
#define MAKESOCKETCANCEL(iSocket)   ((BYTE)(0x20 | (0x0F & (iSocket+1))))

#define MAKETIMERID(iPort, iDev)    ((UINT) (iPort+1)       | ((iDev+1) << 8))
#define MAKEACKTIMERID(iPort, iDev) ((UINT) ((iPort+1)<< 4) | ((iDev+1) << 12))
#define ISACKTIMER(a)               (((UINT)a & 0xf000) ? TRUE : FALSE)

#define MAKERETURNDEST(iDev)        ((BYTE)(0x80 | (BYTE)((iDev + 1) << 4)))
#define PACKET_TIMEOUT              3000             // Packet lasts max of 500ms from comm_notify

typedef struct tagSocketInfo {
    int           iInstReply;     // This is kept for the life of the socket!
    UINT          uViscaCmd;      // Viscacmd running in socket or cmd.
} SocketInfo;

typedef struct tagCmdInfo {
    UINT        nCmd;                       // Number of alternative commands (at least 1)
    UINT        iCmdDone;                   // Number of command alternatives issued.
    UINT        uViscaCmd;                  // The actual visca command this corresponds to 
    char        str[3][MAXPACKETLENGTH];    // max of 3 of these 
    char        strRet[3][MAXPACKETLENGTH]; // Return package 
    UINT        uLength[3];                 // max of 3 of these (we do not need this !) 
    UINT        uLoopCount;                 // Looping count (for step).
} CmdInfo;

// Break is not here, because it is a return value of false.
#define VISCAF_ACK                  0x01    // Ack will get set for each command (but not for entire queue).
#define VISCAF_COMPLETION           0x02    // Completion can be with or without error flag set.
#define VISCAF_ERROR                0x04    // Completion must be set.
#define VISCAF_ERROR_TIMEOUT        0x08    // Timeout error.

#define AUTOBLOCK_OFF               0 
#define AUTOBLOCK_NORMAL            1
#define AUTOBLOCK_ERROR             2

#define MAXINPUTTYPES               2       // video and audio  
#define VCR_INPUT_VIDEO             0       // Index
#define VCR_INPUT_AUDIO             1       // Index
//
// Each input of audio/video has one of these
//
typedef struct tagGenericInput
{
    int         uNumInputs;
    UINT        uInputType[MAXINPUTS];
} GenericInput;
//
// Holds either a record, play or seek, for Resume!
//
typedef struct tagmciCmd {
    UINT  uMciCmd;                        // The REAL MCI command in progress.
    DWORD dwFlags;
    int   iInstCmd;
    union
    {
        MCI_VCR_PLAY_PARMS      mciPlay;
        MCI_VCR_RECORD_PARMS    mciRecord;
        MCI_VCR_SEEK_PARMS      mciSeek;
    } parm;
} mciCmd;
//
// Device specific structure.
//
typedef struct tagDeviceEntry {

    // Device management

    BOOL                fDeviceOk;          // Device is Ok and running.
    UINT                nUsage;             // # of active opens
    BOOL                fShareable;         // Is device opened shareable?
    WCHAR               szVcrName[VCRNAME_LENGTH];      // My drivers name! (only used at config time).

    // Device information

    UINT                uTicksPerSecond;    // Ticks per second this device runs at.
    UINT                uFramesPerSecond;   // # frames per second
    DWORD               dwTapeLength;       // Length of tape
    BYTE                uRecordMode;        // Are we initializing the tape.
    BYTE                bTimeType;          // Are we using timecode or counter
    BYTE                bRelativeType;      // Are we using HMS or HMSF counter
    UINT                uTimeMode;          // Are we in detect, timecode, or counter
    UINT                uIndexFormat;       // The current index (on-screen-display)
    DWORD               dwPlaySpeed;        // Our current play speed
    BOOL                fPlayReverse;       // Are we playing in reverse
    DWORD               dwFreezeMode;       // Are we DNR or Buffer (Evo9650)
    BOOL                fFrozen;            // Are we frozen now    (Evo9650)
    BOOL                fField;             // Freeze frame or field(Evo9650)
    UINT                uLastKnownMode;     // Last known state from mode. (not generally applicable)
    BYTE                bVideoDesired;      // Help independently select tracks.
    BYTE                bAudioDesired;      // Help independently select tracks.
    BYTE                bTimecodeDesired;   // Help independently select tracks.


    // Management of transmission queues and reception

    int                 iInstTransport;     // Instance invoking this transport command.
    int                 iInstReply;         // Pointer to instance awaiting reply from this VCR
    int                 iTransportSocket;   // Socket which is running transport
    WORD                wTransportCmd;      // The current transport action.
    WORD                wCancelledCmd;      // Command that was cancelled.
    int                 iCancelledInst;     // Cancelled inst.
    HWND                hwndCancelled;      // Cancelled window to notify
    BYTE                fQueueAbort;        // Set to false to abort queueing!!
    SocketInfo          rgSocket[MAXSOCKETS];// Status of each socket
    CmdInfo             rgCmd[MAXQUEUED];   // Maximum queued commands per device.
    UINT                nCmd;               // How many commands are queued in automatic instance
    UINT                iCmdDone;           // How many commands have been executed in automatic instance
    UINT                uAutoBlocked;       // A fix to prevent reading task from blocking.
    char                achPacket[MAXPACKETLENGTH]; // Our general purporse return packet
    BOOL                fQueueReenter;      // Prevents reentering the Queue function.
    BYTE                bReplyFlags;        // Reply is to device when autoinst is in control.
    BOOL                fAckTimer;          // Use ack timer or just wait in GetTickCount loop.

    // In Win32 these handles are owned by the background process.
    // If an instance wants access to them, it must first duplicate them
    // into its own address space.

    VISCADEVHANDLE      fTxLock;            // Lock transmission per device until ack is received.
    VISCADEVHANDLE      fQueueLock;         // The instance that cancels gets to claim the queue.
    VISCADEVHANDLE      fTransportFree;     // On free of transport.
    VISCADEVHANDLE      fDeviceLock;        // Lock the device.
    VISCADEVHANDLE      fAutoCompletion;    // Lock the device.
    VISCADEVHANDLE      fAutoAck;           // First ack from auto.

    // Resume and Cue, and Record Init states.

    mciCmd              mciLastCmd;         // For resume
    UINT                uResume;            // Used for pause and resume.
    DWORD               dwFlagsPause;      // Used for pause/resume notifies.
    WORD                wMciCued;           // Is Play=output, or record=input cued
    MCI_VCR_CUE_PARMS   Cue;                // The complete cue command structure
    DWORD               dwFlagsCued;        // Flags on the cue command
    char                achBeforeInit[MAXPACKETLENGTH]; // Restore the state after init

    // Vendor and device information that is queryable or should be

    UINT                uVendorID;          // See Sony model table
    UINT                uModelID;           // See Sony model table
    GenericInput        rgInput[MAXINPUTTYPES]; // The inputs array
    UINT                uPrerollDuration;   // What is out preroll duration

    // General purpose stuff 

    BOOL                fTimecodeChecked;   // Have we checked the timecode
    BOOL                fCounterChecked;    // Have we already checked the counter
    DWORD               dwStartTime;        // Start time for timecode checker
    BOOL                fTimer;             // Do we have a timer running
    BOOL                fTimerMsg;          // Flag so we don't reenter packetprocess is commtask.c
    DWORD               dwReason;           // The reason the transport command was aborted
} DeviceEntry;
//
// Port specific stucture, a port is an array of device entries (1..7).
//
typedef struct tagPortEntry
{
    BOOL                fOk;                    // Is port ok?
    BOOL                fExists;                // Does this commport exist?
    VISCACOMMHANDLE     idComDev;               // ID returned by OpenComm
    UINT                nDevices;               // # of ViSCA devices on port
    DeviceEntry         Dev[MAXDEVICES];        // list of device entries
    UINT                nUsage;                 // # of open instances
    int                 iInstReply;             // Pointer to instance awaiting reply (for ADDRESS message)
    int                 iBroadcastDev;          // Device# which sent broadcast message.
#ifdef _WIN32    
    HANDLE              fTxBuffer;              // Synchronizes port access.
    HANDLE              fTxReady;
    BYTE                achTxPacket[MAXPACKETLENGTH];
    UINT                nchTxPacket;
    BYTE                achRxPacket[MAXPACKETLENGTH];
    BYTE                achTempRxPacket[3];
    HANDLE              hRxThread;
    HANDLE              hTxThread;
#endif

} PortEntry;

typedef struct tagVcr
{
    int                 iInstBackground;        // Background task instance. (do not use port & dev!)
    BOOL                gfFreezeOnStep;         // Global kludge man
    HWND                hwndCommNotifyHandler;  // In commtask.c
    VISCAHTASK          htaskCommNotifyHandler; // Task or PID in NT.
    UINT                uTaskState;
    DWORD               lParam;                 // Information to be passed to background task.
    PortEntry           Port[MAXPORTS];         // Port table lookup.
    VISCADEVHANDLE      gfTaskLock;             // Handle(NT) or boolean(Win3.1)
    VISCADEVHANDLE      gfTaskWorkDone;         // Wait for the task to do something.
    int                 iLastNumDevs;
    int                 iLastPort;
    BOOL                fConfigure;             // Are we configuring(detect number of devs attached).
#ifdef DEBUG
    int                 iGlobalDebugMask;
#endif
} vcrTable;

//
// The only globals.
//
extern POpenInstance pinst;                     // Pointer to use. (For both versions) NT it's per-instance.
extern vcrTable      *pvcr;                     // Pointer to use. (For both versions) NT it's per-instance.

// defines for reading and writing configuration info 
#define MAX_INI_LENGTH  128                    // maximum length of an INI entry  

//
// Function prototypes.
//
// in mcivisca.c
extern int  FAR  PASCAL viscaInstanceCreate(UINT uDeviceID, UINT nPort, UINT nDevice);
extern void FAR  PASCAL viscaInstanceDestroy(int iInst);
extern int              MemAllocInstance(void);
extern BOOL             MemFreeInstance(int iInstTemp);

// in mcicmds.c 
extern DWORD FAR PASCAL viscaMciProc(WORD wDeviceID, WORD wMessage, DWORD dwParam1, DWORD dwParam2);
extern DWORD FAR PASCAL viscaNotifyReturn(int iInst, HWND hwndNotify, DWORD dwFlags, UINT uNotifyMsg, DWORD dwReturnMsg);
extern DWORD FAR PASCAL viscaMciStatus(int iInst, DWORD dwFlags, LPMCI_VCR_STATUS_PARMS lpStatus);
extern DWORD FAR PASCAL viscaDoImmediateCommand(int iInst, BYTE bDest, LPSTR lpstrPacket,  UINT cbMessageLength);
extern BOOL  FAR PASCAL viscaTimecodeCheckAndSet(int iInst);
extern BOOL  FAR PASCAL viscaMciPos1LessThanPos2(int iInst, DWORD dwPos1, DWORD dwPos2);
extern DWORD FAR PASCAL viscaMciClockFormatToViscaData(DWORD dwTime, UINT uTicksPerSecond,
                          BYTE FAR *bHours, BYTE FAR *bMinutes, BYTE FAR *bSeconds, UINT FAR *uTicks);
extern DWORD FAR PASCAL viscaMciTimeFormatToViscaData(int iInst, BOOL fTimecode, DWORD dwTime, LPSTR lpstrData, BYTE bDataFormat);
extern DWORD FAR PASCAL viscaReplyStatusToMCIERR(DWORD dwReply, LPSTR lpstrPacket);
extern DWORD FAR PASCAL viscaRoundSpeed(DWORD dwSpeed, BOOL fReverse);
extern BYTE  FAR PASCAL viscaMapSpeed(DWORD dwSpeed, BOOL fReverse);
extern WORD  FAR PASCAL viscaDelayedCommand(int iInst);
extern DWORD FAR PASCAL viscaSetTimeType(int iInst, BYTE bType);

// in viscacom.c 
extern BOOL  FAR PASCAL viscaRemoveDelayedCommand(int iInst);
extern VISCACOMMHANDLE FAR PASCAL viscaCommPortSetup(UINT nComPort);
extern int   FAR PASCAL viscaCommPortClose(VISCACOMMHANDLE idComDev, UINT iPort);
extern void  FAR PASCAL viscaPacketPrint(LPSTR lpstrData, UINT cbData);
extern BOOL  FAR PASCAL viscaWaitCompletion(int iInst, BOOL fQueue, BOOL fWait);
extern BOOL  FAR PASCAL viscaWriteCancel(int iInst, BYTE bDest, LPSTR lpstrPacket, UINT cbMessageLength);
extern BOOL  FAR PASCAL viscaWrite(int iInst,  BYTE bDest, LPSTR lpstrPacket, UINT cbMessageLength,
                            HWND hWnd, DWORD dwFlags, BOOL fQueue);
extern BOOL  FAR PASCAL viscaReleaseMutex(VISCAINSTHANDLE gfReadBlocked);
extern BOOL  FAR PASCAL viscaReleaseSemaphore(VISCAINSTHANDLE gfReadBlocked);
extern BOOL  FAR PASCAL viscaResetEvent(VISCAINSTHANDLE gfReadBlocked);
extern BOOL  FAR PASCAL viscaSetEvent(VISCAINSTHANDLE gfReadBlocked);
extern DWORD FAR PASCAL viscaWaitForSingleObject(VISCAINSTHANDLE gfFlag, BOOL fManual, DWORD dwTimeout, UINT uDeviceID);
extern DWORD FAR PASCAL viscaErrorToMCIERR(BYTE bError);
extern void  FAR PASCAL viscaReleaseAutoParms(int iPort, int iDev);

// in commtask.c 
extern BOOL  FAR PASCAL viscaTaskCreate(void);
extern BOOL  FAR PASCAL viscaTaskIsRunning(void);
extern BOOL  FAR PASCAL viscaTaskDestroy(void);
extern BOOL  FAR PASCAL viscaCommWrite(int idComDev, LPSTR lpstrData, UINT cbData);
extern BOOL  FAR PASCAL viscaTaskDo(int iInst, UINT uDo, UINT uInfo, UINT uMoreInfo);
extern BOOL  FAR PASCAL CreateDeviceHandles(DWORD pidBackground, UINT iPort, UINT iDev);
extern BOOL  FAR PASCAL DuplicateDeviceHandlesToInstance(DWORD pidBackground, UINT iPort, UINT iDev, int iInst);
extern BOOL  FAR PASCAL CloseDeviceHandles(DWORD pidBackground, UINT iPort, UINT iDev);
extern BOOL  FAR PASCAL CreatePortHandles(DWORD pidBackground, UINT iPort);
extern BOOL  FAR PASCAL DuplicatePortHandlesToInstance(DWORD pidBackground, UINT iPort, int iInst);
extern BOOL  FAR PASCAL ClosePortHandles(DWORD pidBackground, UINT iPort);
extern BOOL  FAR PASCAL CreateGlobalHandles(DWORD pidBackground);
extern BOOL  FAR PASCAL DuplicateGlobalHandlesToInstance(DWORD pidBackground, int iInst);
extern BOOL  FAR PASCAL CloseGlobalHandles(DWORD pidBackground);
extern BOOL  FAR PASCAL CloseAllInstanceHandles(int iInst);

// in mcidelay.c
extern DWORD FAR PASCAL viscaMciDelayed(WORD wDeviceID, WORD wMessage, DWORD dwParam1, DWORD dwParam2);
extern DWORD FAR PASCAL viscaQueueReset(int iInst, UINT uMciCmd, DWORD dwReason);

// In commtask.c 

#endif /* NOT RC_INVOKED */ 

// define string resource constants 
#define IDS_TABLE_NAME                      0
#define IDS_VERSION                         1
#define IDS_INIFILE                         2
#define IDS_VERSIONNAME                     3

#define IDS_COM1                            4
#define IDS_COM2                            5
#define IDS_COM3                            6
#define IDS_COM4                            7
#define IDS_COM5                            8

#define IDS_CONFIG_ERR_ILLEGALNAME          40
#define IDS_CONFIG_ERR_REPEATNAME           41
#define IDS_CONFIG_WARN_LASTVCR             42
#define IDS_CONFIG_ERR                      43
#define IDS_CONFIG_WARN                     44

#define IDS_DEFAULT_INFO_PRODUCT            10
#define IDS_VENDORID1_BASE                  18
#define IDS_MODELID2_BASE                   26

#define VISCA_NONE                          0
#define VISCA_PLAY                          1
#define VISCA_PLAY_TO                       2
#define VISCA_RECORD                        3
#define VISCA_RECORD_TO                     4
#define VISCA_SEEK                          5    
#define VISCA_FREEZE                        6
#define VISCA_UNFREEZE                      7
#define VISCA_PAUSE                         8
#define VISCA_STOP                          9
#define VISCA_STEP                          10
#define VISCA_EDIT_RECORD_TO                11
#define VISCA_NFRAME                        12
#define VISCA_SEGINPOINT                    13
#define VISCA_SEGOUTPOINT                   14
#define VISCA_EDITMODES                     15
#define VISCA_MODESET_OUTPUT                16
#define VISCA_MODESET_INPUT                 17
#define VISCA_MODESET_FIELD                 18
#define VISCA_MODESET_FRAME                 19

#define FREEZE_INIT                         0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\mcivisca\viscamsg.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 * 
 *  VISCAMSG.C
 *
 *  MCI ViSCA Device Driver
 *
 *  Description:
 *
 *      ViSCA packet creation procedures
 *        ViSCA Message??_??? (MD_Mode1, MD_Mode2, etc.)
 *
 ***************************************************************************/

#define  UNICODE
#include <windows.h>
#include <windowsx.h>
#include "appport.h"
#include <math.h>
#include <string.h>
#include "viscadef.h"

//
//    The following functions prepare message headers.
//    See VISCA Developer Manual 1.0, Chapter 2.
//

/****************************************************************************
 * Function: UINT viscaHeaderFormat1 - Create a ViSCA "Format 1" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrHeader - Buffer in which to create header.
 *
 *      BYTE bCategoryCode - ViSCA category code.
 *
 * Returns: length of header (2).
 ***************************************************************************/
static UINT NEAR PASCAL
viscaHeaderFormat1(LPSTR lpstrHeader, BYTE bCategoryCode)
{
    lpstrHeader[0] = 0x01;
    lpstrHeader[1] = bCategoryCode;
    return (2);
}


/****************************************************************************
 * Function: UINT viscaHeaderFormat2 - Create a ViSCA "Format 2" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrHeader - Buffer in which to create header.
 *
 *      BYTE bCategoryCode - ViSCA category code.
 *
 *      BYTE bHour - Hour.
 *
 *      BYTE bMinute - Minute.
 *
 *      BYTE bSecond - Second.
 *
 *      UINT uTicks - Ticks.
 *
 * Returns: length of header (7).
 ***************************************************************************/
static UINT NEAR PASCAL
viscaHeaderFormat2(
               LPSTR   lpstrHeader,
               BYTE    bCategoryCode,
               BYTE    bHour,
               BYTE    bMinute,
               BYTE    bSecond,
               UINT    uTicks)
{
    lpstrHeader[0] = 0x02;
    lpstrHeader[1] = bCategoryCode;
    lpstrHeader[2] = TOBCD(bHour);
    lpstrHeader[3] = TOBCD(bMinute);
    lpstrHeader[4] = TOBCD(bSecond);
    lpstrHeader[5] = TOBCD(uTicks / 10);
    lpstrHeader[6] = TOBCD(uTicks % 10);
    return (7);
}


/****************************************************************************
 * Function: UINT viscaHeaderFormat3 - Create a ViSCA "Format 3" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrHeader - Buffer in which to create header.
 *
 *      BYTE bCategoryCode - ViSCA category code.
 *
 *      LPSTR lpstrPosition - Position.
 *
 * Returns: length of header (7).
 ***************************************************************************/
static UINT NEAR PASCAL
viscaHeaderFormat3(
                LPSTR   lpstrHeader,
                BYTE    bCategoryCode,
                LPSTR   lpstrPosition)
{
    lpstrHeader[0] = 0x03;
    lpstrHeader[1] = bCategoryCode;
    _fmemcpy(lpstrHeader + 2, lpstrPosition, 5);
    return (7);
}


/****************************************************************************
 * Function: UINT viscaHeaderFormat4 - Create a ViSCA "Format 4" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrHeader - Buffer in which to create header.
 *
 *      BYTE bCategoryCode - ViSCA category code.
 *
 *      LPSTR lpstrPosition - Position.
 *
 * Returns: length of header (7).
 ***************************************************************************/
static UINT NEAR PASCAL
viscaHeaderFormat4(
                LPSTR   lpstrHeader,
                BYTE    bCategoryCode,
                LPSTR   lpstrPosition)
{
    lpstrHeader[0] = 0x04;
    lpstrHeader[1] = bCategoryCode;
    _fmemcpy(lpstrHeader + 2, lpstrPosition, 5);
    return (7);
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaHeaderFormat3 - Create a ViSCA "Vendor Exclusive" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrHeader - Buffer in which to create header.
 *
 *      BYTE bVendorID1 - Byte 1 of vendor ID.
 *
 *      BYTE bVendorID2 - Byte 2 of vendor ID.
 *
 *      BYTE bModelID1 - Byte 1 of model ID.
 *
 *      BYTE bModelID2 - Byte 2 of model ID.
 *
 * Returns: length of header (6).
 ***************************************************************************/
static UINT NEAR PASCAL
viscaHeaderVendorExclusive(
                LPSTR   lpstrHeader,
                BYTE    bVendorID1,
                BYTE    bVendorID2,
                BYTE    bModelID1,
                BYTE    bModelID2)
{
    lpstrHeader[0] = 0x01;
    lpstrHeader[1] = 0x7F;      /* category code */
    lpstrHeader[2] = bVendorID1;
    lpstrHeader[3] = bVendorID2;
    lpstrHeader[4] = bModelID1;
    lpstrHeader[5] = bModelID2;
    return (6);
}
#endif


/****************************************************************************
 * Function: UINT viscaHeaderFormat3 - Create a ViSCA "Inquiry" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrHeader - Buffer in which to create header.
 *
 *      BYTE bCategoryCode - ViSCA category code.
 *
 * Returns: length of header in (2).
 ***************************************************************************/
static UINT NEAR PASCAL
viscaHeaderInquiry(
                LPSTR   lpstrHeader,
                BYTE    bCategoryCode)
{
    lpstrHeader[0] = 0x09;
    lpstrHeader[1] = bCategoryCode;
    return (2);
}

//
// All the viscaMessageXXXXX functions below construct messages
// with the ViSCA command format 1 header.  This is because virtually
// the entire MCI command set is written so as to be executed immediately.
// Occasionally though, it is necessary to have messages with other
// format headers.  (In particular, format 3 and 4 headers are used
// to implement to MCI_TO functionality of the MCI_PLAY and MCI_RECORD
// commands.)  Therefore the following functions convert messages
// with a format 1 header to messages with other types of headers.
//

/****************************************************************************
 * Function: UINT viscaHeaderReplaceFormat1WithFormat2 - Takes a ViSCA message
 *              with a "Format 1" header and converts it to a ViSCA message
 *              with a "Format 2" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - A "Format 1" message.
 *
 *      UINT cbLen - Length of message.
 *
 *      BYTE bHour - Hour.
 *
 *      BYTE bMinute - Minute.
 *
 *      BYTE bSecond - Second.
 *
 *      BYTE bTicks - Ticks.
 *
 * Returns: length message.
 ***************************************************************************/
UINT FAR PASCAL
viscaHeaderReplaceFormat1WithFormat2(
                LPSTR   lpstrMessage,
                UINT    cbLen,
                BYTE    bHour,
                BYTE    bMinute,
                BYTE    bSecond,
                UINT    uTicks)
{
    char    achTemp[MAXPACKETLENGTH];
    UINT    cb;

    cb = viscaHeaderFormat2(achTemp, lpstrMessage[1],
                            bHour, bMinute, bSecond, uTicks);
    _fmemcpy(achTemp + cb, lpstrMessage + 2, cbLen - 2);
    _fmemcpy(lpstrMessage, achTemp, cb + cbLen - 2);
    return (cb + cbLen - 2);
}


/****************************************************************************
 * Function: UINT viscaHeaderReplaceFormat1WithFormat3 - Takes a ViSCA message
 *              with a "Format 1" header and converts it to a ViSCA message
 *              with a "Format 3" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - A "Format 1" message.
 *
 *      UINT cbLen - Length of message.
 *
 *      LPSTR lpstrPosition - Position.
 *
 * Returns: length message.
 ***************************************************************************/
UINT FAR PASCAL
viscaHeaderReplaceFormat1WithFormat3(
                LPSTR   lpstrMessage,
                UINT    cbLen,
                LPSTR   lpstrPosition)
{
    char    achTemp[MAXPACKETLENGTH];
    UINT    cb;

    cb = viscaHeaderFormat3(achTemp, lpstrMessage[1], lpstrPosition);
    _fmemcpy(achTemp + cb, lpstrMessage + 2, cbLen - 2);
    _fmemcpy(lpstrMessage, achTemp, cb + cbLen - 2);
    return (cb + cbLen - 2);
}


/****************************************************************************
 * Function: UINT viscaHeaderReplaceFormat1WithFormat4 - Takes a ViSCA message
 *              with a "Format 1" header and converts it to a ViSCA message
 *              with a "Format 4" header.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - A "Format 1" message.
 *
 *      UINT cbLen - Length of message.
 *
 *      LPSTR lpstrPosition - Position.
 *
 * Returns: length message.
 ***************************************************************************/
UINT FAR PASCAL
viscaHeaderReplaceFormat1WithFormat4(
                LPSTR   lpstrMessage,
                UINT    cbLen,
                LPSTR   lpstrPosition)
{
    char    achTemp[MAXPACKETLENGTH];
    UINT    cb;

    cb = viscaHeaderFormat4(achTemp, lpstrMessage[1], lpstrPosition);
    _fmemcpy(achTemp + cb, lpstrMessage + 2, cbLen - 2);
    _fmemcpy(lpstrMessage, achTemp, cb + cbLen - 2);
    return (cb + cbLen - 2);
}




//
//  The following are functions to create VISCA data types.
//  See VISCA Developer Manual 1.0, Chapter 3.
//


/****************************************************************************
 * Function: UINT viscaDataTopMiddleEnd - Create a ViSCA Top/Middle/End
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      BYTE bTopMiddleEnd - Position.  May be one of VISCATOP,
 *              VISCAMIDDLE, and VISCAEND.
 *
 * Returns: length of data structure (5).
 ***************************************************************************/
UINT FAR PASCAL
viscaDataTopMiddleEnd(
                LPSTR   lpstrData,
                BYTE    bTopMiddleEnd)
{
    lpstrData[0] = VISCADATATOPMIDDLEEND;       /* Data type ID:  Top/Middle/End */
    lpstrData[1] = bTopMiddleEnd;
    lpstrData[2] = 0x00;
    lpstrData[3] = 0x00;
    lpstrData[4] = 0x00;
    return (5);
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaData4DigitDecimal - Create a ViSCA 4-Digit Decimal
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      UINT uDecimal - Decimal number.
 *
 * Returns: length of data structure (5).
 ***************************************************************************/
UINT FAR PASCAL
viscaData4DigitDecimal(
                LPSTR   lpstrData,
                UINT    uDecimal)
{
    lpstrData[0] = VISCADATA4DIGITDECIMAL;      /* Data type ID:  4 digit decimal */
    lpstrData[1] = (BYTE)( uDecimal / 1000);
    lpstrData[2] = (BYTE)((uDecimal / 100) % 10);
    lpstrData[3] = (BYTE)((uDecimal /  10) % 10);
    lpstrData[4] = (BYTE)( uDecimal        % 10);
    return (5);
}
#endif


/****************************************************************************
 * Function: UINT viscaDataPosition - Create a ViSCA position
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      BYTE bTimeFormat - Time format.  May be one of:
 *              VISCADATAHMS, VISCADATAHMSF, VISCATIMECODENDF, and
 *              VISCADATATIMECODEDF.
 *
 *      BYTE bHours - Hours.
 *
 *      BYTE bMinutes - Minutes.
 *
 *      BYTE bSeconds - Seconds.
 *
 *      BYTE bFrames - Frames.
 *
 * Returns: length of data structure (5).
 ***************************************************************************/
UINT FAR PASCAL    
viscaDataPosition(
                LPSTR   lpstrData,
                BYTE    bTimeFormat,
                BYTE    bHours,
                BYTE    bMinutes,
                BYTE    bSeconds,
                BYTE    bFrames)
{
    lpstrData[0] = bTimeFormat;
    lpstrData[1] = TOBCD(bHours);
    lpstrData[2] = TOBCD(bMinutes);
    lpstrData[3] = TOBCD(bSeconds);
    if(bTimeFormat == VISCADATAHMS)
        lpstrData[4] = 0; /* We only support second accuracy */
    else
        lpstrData[4] = TOBCD(bFrames);
    return (5);
}


/****************************************************************************
 * Function: UINT viscaDataIndex - Create a ViSCA Index
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      BYTE bDirection - Direction in which to search for index.
 *              May be VISCAFORWARD or VISCAREVERSE.
 *
 *      UINT uNum - Number of indices to search.
 *
 * Returns: length of data structure (5).
 ***************************************************************************/
UINT FAR PASCAL
viscaDataIndex(
                LPSTR   lpstrData,
                BYTE    bDirection,
                UINT    uNum)
{
    lpstrData[0] = VISCADATAINDEX;          // Data type ID:  Index 
    lpstrData[1] = bDirection;
    lpstrData[2] = 0x00;
    lpstrData[3] = (BYTE)(uNum / 10);
    lpstrData[4] = (BYTE)(uNum % 10);
    return (5);
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaDataChapter - Create a ViSCA Chapter
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      UINT uNum - Chapter number.
 *
 * Returns: length of data structure (5).
 ***************************************************************************/
UINT FAR PASCAL
viscaDataChapter(
                LPSTR   lpstrData,
                UINT    uNum)
{
    lpstrData[0] = VISCADATACHAPTER;        // Data type ID:  Chapter 
    lpstrData[1] = 0x00;
    lpstrData[2] = 0x00;
    lpstrData[3] = (BYTE)(uNum / 10);
    lpstrData[4] = (BYTE)(uNum % 10);
    return (5);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaDataDate - Create a ViSCA Date
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      BYTE bYear - Year.
 *
 *      BYTE bMonth - Month.
 *
 *      BYTE bDay - Day.
 *
 *      BYTE bDirection - Direction.  May be VISCAFORWARD or VISCAREVERSE.
 *
 * Returns: length of data structure (5).
 ***************************************************************************/
UINT FAR PASCAL
viscaDataDate(
                LPSTR   lpstrData,
                BYTE    bYear,
                BYTE    bMonth,
                BYTE    bDay,
                BYTE    bDirection)
{
    lpstrData[0] = VISCADATADATE;           // Data type ID:  Date 
    lpstrData[1] = (BYTE)((BYTE)((bYear / 10) * 10) | (bDirection << 4));
    lpstrData[2] = (BYTE)(bYear % 10);
    lpstrData[3] = TOBCD(bMonth);
    lpstrData[4] = TOBCD(bDay);
    return (5);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaDataTime - Create a ViSCA Time
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      BYTE bHour - Hour.
 *
 *      BYTE bMinute - Minute.
 *
 *      BYTE bSecond - Second.
 *
 *      BYTE bDirection - Direction.  May be VISCAFORWARD or VISCAREVERSE.
 *
 * Returns: length of data structure (5).
 ***************************************************************************/
UINT FAR PASCAL
viscaDataTime(
                LPSTR   lpstrData,
                BYTE    bHour,
                BYTE    bMinute,
                BYTE    bSecond,
                BYTE    bDirection)
{
    lpstrData[0] = VISCADATATIME;           // Data type ID:  Time 
    lpstrData[1] = (BYTE)(TOBCD(bHour) | (bDirection << 4));
    lpstrData[2] = TOBCD(bMinute);
    lpstrData[3] = TOBCD(bSecond);
    lpstrData[4] = 0x00;
    return (5);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaDataUserData - Create a ViSCA User Data
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      BYTE nByte - Byte number.
 *
 *      BYTE bDirection - Direction.  May be VISCAFORWARD or VISCAREVERSE.
 *
 *      BYTE bData - Byte value.
 *
 * Returns: length of data structure (5).
 ***************************************************************************/
UINT FAR PASCAL
viscaDataUserData(
                LPSTR   lpstrData,
                BYTE    nByte,
                BYTE    bDirection,
                BYTE    bData)
{
    lpstrData[0] = (char)(0x70 | (0x0F & nByte));    /* Data type ID:  User Data */
    lpstrData[1] = bDirection;
    lpstrData[2] = 0x00;
    lpstrData[3] = (char)(0x0F & (bData >> 4));
    lpstrData[4] = (char)(0x0F & bData);
    return (5);
}
#endif


#ifdef NOTUSED
#ifdef USEFLOATINGPOINT
/****************************************************************************
 * Function: UINT viscaDataFloatingPoint - Create a ViSCA Floating Point
 *              data structure.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Buffer to hold ViSCA data structure.
 *
 *      double dblFloat - Floating point value.
 *
 * Returns: length of data structure (5).
 *
 *        The following code has never been tested.
 *
 ***************************************************************************/
UINT FAR PASCAL
viscaDataFloatingPoint(
                LPSTR   lpstrData,
                double  dblFloat)
{
    BOOL    bNegative = (dblFloat < 0.0);
    BYTE    bExponent = 0;
    BYTE    b1000, b100, b10, b1;
    double  dblExponent;

    if (dblFloat == 0.0) {
        b1000 = b100 = b10 = b1 = 0;
    }
    else {
        if (bNegative) {
            dblFloat = (-dblFloat);
        }
        dblExponent = 3.0 - floor(log10(dblFloat));
        if ((dblExponent < 0.0) || (dblExponent > 15.0)) { /* can't store # */
            b1000 = b100 = b10 = b1 = 0;
        }
        else {
            bExponent = (char)(UINT)dblExponent;
            dblFloat *= pow(10.0, dblExponent);
            b1000 = (char)(UINT)floor(dblFloat / 1000);
            b100  = (char)(UINT)floor(fmod(dblFloat / 100, 10.0));
            b10   = (char)(UINT)floor(fmod(dblFloat / 10 , 10.0));
            b1    = (char)(UINT)floor(fmod(dblFloat     , 10.0));
        }
    }

    lpstrData[0] = (char)(0x50 | (0x0F & bExponent));   /* Data type ID:  Floating Point */
    lpstrData[1] = (char)(b1000 | (bNegative ? (1<<6) : 0));
    lpstrData[2] = b100;
    lpstrData[3] = b10;
    lpstrData[4] = b1;
    return (5);
}
#endif
#endif

//
//    The following functions create VISCA Interface messages.
//    See VISCA Developer Manual 1.0, Chapter 4.
//
/****************************************************************************
 * Function: UINT viscaMessageIF_Address - Create a ViSCA IF_Address
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message (2).
 *
 *       Address message, to initialize the addresses of all devices
 *
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageIF_Address(
                LPSTR   lpstrMessage)
{
    lpstrMessage[0] = 0x30;             /* address message */
    lpstrMessage[1] = 0x01;             /* set first device to 1 */
    return (2);
}


/****************************************************************************
 * Function: UINT viscaMessageIF_Cancel - Create a ViSCA IF_Cancel
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSocket - Socket number of command to cancel.
 *
 * Returns: length of message (1).
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageIF_Cancel(
                LPSTR   lpstrMessage,
                BYTE    bSocket)
{
    *lpstrMessage = (char)(0x20 | (0x0F & bSocket));
    return (1);
}


/****************************************************************************
 * Function: UINT viscaMessageIF_Clear - Create a ViSCA IF_Clear
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageIF_Clear(
                LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x00);

    lpstrMessage[cb] = 0x01;        /* Clear */
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageIF_DeviceTypeInq - Create a ViSCA IF_DeviceTypeInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageIF_DeviceTypeInq(
                LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x00);

    lpstrMessage[cb] = 0x02;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageIF_ClockInq - Create a ViSCA IF_ClockInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageIF_ClockInq(LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x00);

    lpstrMessage[cb] = 0x03;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageIF_ClockSet - Create a ViSCA IF_ClockSet
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bHours - Hours.
 *
 *      BYTE bMinutes - Minutes.
 *
 *      BYTE bSeconds - Seconds.
 *
 *      UINT uTicks - Ticks.
 *
 *      BYTE dbHours - Hours increment.
 *
 *      BYTE dbMinutes - Minutes increment.
 *
 *      BYTE dbSeconds - Seconds increment.
 *
 *      UINT duTicks - Ticks increment.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageIF_ClockSet(
                LPSTR   lpstrMessage,
                BYTE    bHours,
                BYTE    bMinutes,
                BYTE    bSeconds,
                UINT    uTicks,
                BYTE    dbHours,
                BYTE    dbMinutes,
                BYTE    dbSeconds,
                UINT    duTicks)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x00);

    lpstrMessage[cb] = 0x03;
    lpstrMessage[cb + 1] = TOBCD(bHours);
    lpstrMessage[cb + 2] = TOBCD(bMinutes);
    lpstrMessage[cb + 3] = TOBCD(bSeconds);
    lpstrMessage[cb + 4] = (char)(((uTicks / 100) << 4) | ((uTicks / 10) % 10));
    lpstrMessage[cb + 5] = (char)(uTicks % 10);
    lpstrMessage[cb + 6] = TOBCD(dbHours);
    lpstrMessage[cb + 7] = TOBCD(dbMinutes);
    lpstrMessage[cb + 8] = TOBCD(dbSeconds);
    lpstrMessage[cb + 9] = (char)(((duTicks / 100) << 4) | ((duTicks / 10) % 10));
    lpstrMessage[cb +10] = (char)(duTicks % 10);
    return (cb + 11);
}


//
//  The following functions create VISCA Control-S messages.
//  See VISCA Developer Manual 1.0, Chapter 5.
//
//  * We regret to inform you that the control-S messages have not been implemented. *
//

//
//  The following functions create VISCA Media Device messages.
//  See VISCA Developer Manual 1.0, Chapter 6.
//

#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_CameraFocus - Create a ViSCA MD_CameraFocus
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSubCode - Focus action.  May be one of:  VISCAFOCUSSTOP,
 *              VISCAFOCUSFAR, and VISCAFOCUSNEAR.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_CameraFocus(
            LPSTR   lpstrMessage,
            BYTE    bSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x08;
    lpstrMessage[cb + 1] = bSubCode;
    return (cb + 2);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_CameraZoom - Create a ViSCA MD_CameraZoom
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSubCode - Zoom action.  May be one of:  VISCAZOOMSTOP,
 *              VISCAZOOMTELE, and VISCAZOOMWIDE.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_CameraZoom(
            LPSTR   lpstrMessage,
            BYTE    bSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x07;
    lpstrMessage[cb + 1] = bSubCode;
    return (cb + 2);
}
#endif

/****************************************************************************
 * Function: UINT viscaMessageMD_EditModes - Create a ViSCA MD_EditModes
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSubCode - Edit mode. VISCAEDITUSEFROM
 *                                    VISCAEDITUSETO
 *                                    VISCAEDITUSEFROMANDTO
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_EditModes(
            LPSTR   lpstrMessage,
            BYTE    bSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb]        = 0x60;
    lpstrMessage[cb + 1]    = bSubCode;
    return (cb + 2);
}

/****************************************************************************
 * Function: UINT viscaMessageMD_Channel - Create a ViSCA MD_Channel
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      UINT uChannel - Channel number to select.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_Channel(
            LPSTR   lpstrMessage,
            UINT    uChannel)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x04;
    lpstrMessage[cb + 1] = (BYTE)(uChannel / 100);
    lpstrMessage[cb + 2] = (BYTE)((uChannel / 10) % 10);
    lpstrMessage[cb + 3] = (BYTE)(uChannel % 10);
    return (cb + 4);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_ChannelInq - Create a ViSCA MD_ChannelInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_ChannelInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x04;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_EditControl - Create a ViSCA MD_EditControl
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *        
 *      BYTE bSubCode - Edit action.  May be one of:
 *              VISCAEDITPBSTANDBY, VISCAEDITPLAY, VISCAEDITPLAYSHUTTLESPEED,
 *              VISCAEDITRECSTANDBY, VISCAEDITRECORD, and
 *              VISCAEDITRECORDSHUTTLESPEED.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_EditControl(
            LPSTR   lpstrMessage,
            BYTE    bHours,
            BYTE    bMinutes,
            BYTE    bSeconds,
            UINT    uTicks,
            BYTE    bSubCode)
{
    UINT    cb;

    /* these do not perform conversions, merely pick headers and add junk,
     * Headers are responsible for knowing position of atomic units only.
     */

    if ((bSubCode == VISCAEDITPBSTANDBY) ||
        (bSubCode == VISCAEDITRECSTANDBY))
    {
        cb = viscaHeaderFormat1(lpstrMessage, 0x02);
    }
    else
    {

        cb = viscaHeaderFormat2(lpstrMessage, 0x02,
                bHours,
                bMinutes,
                bSeconds,
                uTicks);

    }
    lpstrMessage[cb] = 0x05;
    lpstrMessage[cb + 1] = bSubCode;
    return (cb + 2);
}

/****************************************************************************
 * Function: UINT viscaMessageMD_EditControlInq - Create a ViSCA
 *              MD_EditControlInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_EditControlInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x05;
    lpstrMessage[cb+1] = 0x01;

    return (cb + 2);
}




/****************************************************************************
 * Function: UINT viscaMessageMD_Mode1 - Create a ViSCA MD_Mode1
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bModeCode - Mode to enter.  May be one of:
 *              VISCAMODE1STOP, VISCAMODE1FASTFORWARD, VISCAMODE1REWIND,
 *              VISCAMODE1EJECT, VISCAMODE1STILL, VISCAMODE1SLOW2,
 *              VISCAMODE1SLOW1, VISCAMODE1PLAY, VISCAMODE1SHUTTLESPEEDPLAY,
 *              VISCAMODE1FAST1, VISCAMODE1FAST2, VISCAMODE1SCAN,
 *              VISCAMODE1REVERSESLOW2, VISCAMODE1REVERSESLOW1,
 *              VISCAMODE1REVERSEPLAY, VISCAMODE1REVERSEFAST1,
 *              VISCAMODE1REVERSEFAST2, VISCAMODE1REVERSESCAN,
 *              VISCAMODE1RECPAUSE, VISCAMODE1RECORD,
 *              VISCAMODE1SHUTTLESPEEDRECORD, VISCAMODE1CAMERARECPAUSE,
 *              VISCAMODE1CAMERAREC, VISCAMODE1EDITSEARCHFORWARD, and
 *              VISCAMODE1EDITSEARCHREVERSE.
 *
 * Returns: length of message.
 *
 *       Right now the Mode1 "Shuttle speed play/record" messages are not
 *       supported, as they require a floating point parameter.
 *       Also, the Sony Vbox CI-1000 and Vdeck CVD-1000 do not support
 *       these commands.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_Mode1(
            LPSTR   lpstrMessage,
            BYTE    bModeCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x01;
    lpstrMessage[cb + 1] = bModeCode;
    return (cb + 2);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_Mode1Inq - Create a ViSCA MD_Mode1Inq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_Mode1Inq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x01;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_Mode2 - Create a ViSCA MD_Mode2
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bModeCode - Mode to enter.  May be one of:
 *              VISCAMODE2FRAMEFORWARD, VISCAMODE2FRAMEREVERSE,
 *              VISCAMODE2INDEXERASE, VISCAMODE2INDEXMARK, and
 *              VISCAMODE2FRAMERECORDFORWARD.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_Mode2(
            LPSTR   lpstrMessage,
            BYTE    bModeCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x02;
    lpstrMessage[cb + 1] = bModeCode;
    return (cb + 2);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_PositionInq - Create a ViSCA MD_PositionInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bCounterType - Counter type to request.  May be one of:
 *              VISCADATATOPMIDDLEEND, VISCADATA4DIGITDECIMAL,
 *              VISCADATAHMS, VISCADATAHMSF, VISCADATATIMECODENDF,
 *              VISCADATATIMECODEDF, VISCADATACHAPTER, VISCADATADATE,
 *              VISCADATATIME, and VISCADATAUSERDATA.  In addition,
 *              VISCADATARELATIVE and VISCADATAABSOLUTE may be specified,
 *              in which case the ViSCA device will select the data type
 *              to return.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_PositionInq(
            LPSTR   lpstrMessage,
            BYTE    bCounterType)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x03;
    lpstrMessage[cb + 1] = bCounterType;
    return (cb + 2);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_Power - Create a ViSCA MD_Power
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSubCode - Action to take.  May be VISCAPOWERON or
 *              VISCAPOWEROFF.
 *
 * Returns: length of message.
 *
 *       Most media devices will enter "Standby" mode when set to OFF.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_Power(
            LPSTR   lpstrMessage,
            BYTE    bSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x00;
    lpstrMessage[cb + 1] = bSubCode;
    return (cb + 2);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_PowerInq - Create a ViSCA MD_PowerInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_PowerInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x00;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_Search - Create a ViSCA MD_Search
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      LPSTR lpstrDataTarget - ViSCA data structure specifying position
 *               to which to search.
 *
 *      LPSTR bMode - Mode to enter after searching.  May be one of
 *               VISCASTOP, VISCASTILL, VISCAPLAY, and VISCANOMODE.
 *
 * Returns: length of message.
 *
 *       The mode component of the MD_Search message is optional.
 *       To ommitt the mode entry, specify VISCANOMODE.
 *       The Sony Vbox CI-1000 does not accept the mode parameter, and
 *       so VISCANOMODE must be specified if the driver is to work
 *       in the most general case.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_Search(
            LPSTR   lpstrMessage,
            LPSTR   lpstrDataTarget,
            BYTE    bMode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x03;
    _fmemcpy(&(lpstrMessage[cb + 1]), lpstrDataTarget, 5);
    if (bMode == VISCANOMODE) {     // CI-1000 V-box doesn't support mode
        return (cb + 6);
    }
    else {
        lpstrMessage[cb + 6] = bMode;
        return (cb + 7);
    }
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_TransportInq - Create a ViSCA MD_TransportInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_TransportInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x0A;
    return (cb + 1);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_ClockSet - Create a ViSCA MD_ClockSet
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bClockMode - Clock mode.  May be VISCACLOCKSTART or
 *              VISCACLOCKSTOP.
 *
 *      LPSTR lpstrData - ViSCA data structure specifying value to
 *               which to set the clock.
 *
 * Returns: length of message.
 *
 *       The Sony Vdec CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_ClockSet(
            LPSTR   lpstrMessage,
            BYTE    bClockMode,
            LPSTR   lpstrData)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x16;
    lpstrMessage[cb + 1] = bClockMode;
    _fmemcpy(&(lpstrMessage[cb + 2]), lpstrData, 5);
    return (cb + 7);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_ClockInq - Create a ViSCA MD_ClockInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bDataType - ViSCA data type to use to retrieve clock value.
 *              May be VISCADATADATE or VISCADATATIME.
 * Returns: length of message.
 *
 *       The Sony Vbox CI-1000 and Vdeck CVD-1000 do not accept this inquiry.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_ClockInq(
            LPSTR   lpstrMessage,
            BYTE    bDataType)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x16;
    lpstrMessage[cb + 1] = bDataType;
    return (cb + 2);
}
#endif


/****************************************************************************
 * Function: UINT viscaMessageMD_MediaInq - Create a ViSCA MD_MediaInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_MediaInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x12;
    return (cb + 1);
}

/****************************************************************************
 * Function: UINT viscaMessageMD_InputSelect - Create a ViSCA MD_InputSelect
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bType - LINEVIDEO or SVIDEO or AUX, type to be set
 *
 *      BYTE bVideo - Video input selector.
 *
 *      BYTE bAudio - Audio input selector.
 *
 * Returns: length of message.
 *
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_InputSelect(
            LPSTR   lpstrMessage,
            BYTE    bVideo,
            BYTE    bAudio)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);


    lpstrMessage[cb] = 0x13;
    lpstrMessage[cb + 1] = bVideo;
    lpstrMessage[cb + 2] = bAudio;
    
    return (cb + 3);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_InputSelectInq - Create a ViSCA
 *              MD_InputSelectInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_InputSelectInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x13;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_OSD - Create a ViSCA MD_OSD
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bPage - Page to which to set on-screen display.  May be
 *              VISCAOSDPAGEOFF, VISCAOSDPAGEDEFAULT, or a page number
 *              greater than or equal to 0x02.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_OSD(
            LPSTR   lpstrMessage,
            BYTE    bPage)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x15;
    lpstrMessage[cb + 1] = TOBCD(bPage);
    return (cb + 2);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_OSDInq - Create a ViSCA MD_OSDInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_OSDInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x15;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_Subcontrol - Create a ViSCA MD_Subcontrol
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSubCode - Item to control.  May be one of:
 *              VISCACOUNTERRESET, VISCAABSOLUTECOUNTER, VISCARELATIVECOUNTER,
 *              VISCASTILLADJUSTMINUS, VISCASTILLADJUSTPLUS,
 *              VISCASLOWADJUSTMINUS, VISCASLOWADJUSTPLUS,
 *              VISCATOGGLEMAINSUBAUDIO, VISCATOGGLERECORDSPEED,
 *              VISCATOGGLEDISPLAYONOFF, and VISCACYCLEVIDEOINPUT.
 *
 * Returns: length of message.
 *
 *       The Sony Vbox CI-1000 does not accept the still- and slow-adjust
 *       commands.  The Sony Vdeck CVD-1000 does not accept the
 *       VISCATOGGLEMAINSUBAUDIO, VISCATOGGLERECORDSPEED, and
 *       VISCACYCLEVIDEOINPUT commands.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_Subcontrol(
            LPSTR   lpstrMessage,
            BYTE    bSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x10;
    lpstrMessage[cb + 1] = bSubCode;
    return (cb + 2);
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_ConfigureIF - Create a ViSCA MD_ConfigureIF
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bFrameRate - Frame rate in frames per second.  May be
 *              VISCA25FPS or VISCA30FPS.
 *
 *      BYTE bInterfaceType - Interface type.  Should be VISCALEVEL1.
 *
 *      BYTE bControlCode - Control code.  May be VISCACONTROLNONE,
 *              VISCACONTROLSYNC, VISCACONTROLLANC, or VISCACONTROLF500
 *              (which is synonymous with VISCACONTROLLANC).
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_ConfigureIF(
            LPSTR   lpstrMessage,
            BYTE    bFrameRate,
            BYTE    bInterfaceType,
            BYTE    bControlCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x20;
    lpstrMessage[cb + 1] = bFrameRate;
    lpstrMessage[cb + 2] = bInterfaceType;
    lpstrMessage[cb + 3] = bControlCode;
    return (cb + 4);
}
#endif


/****************************************************************************
 * Function: UINT viscaMessageMD_ConfigureIFInq - Create a ViSCA
 *              MD_ConfigureIFInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_ConfigureIFInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x20;
    return (cb + 1);
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_PBReset - Create a ViSCA MD_PBReset
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 *
 *       Reset playback registers.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_PBReset(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x30;
    lpstrMessage[cb + 1] = 0x00;   
    return (cb + 2);
}
#endif


/****************************************************************************
 * Function: UINT viscaMessageMD_PBTrack - Create a ViSCA MD_PBTrack
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bVideoTrack - Video track.  May be VISCATRACKNONE or
 *              VISCATRACK1.
 *
 *      BYTE bDataTrack - Data track.  May be VISCATRACKNONE or
 *              VISCATRACKTIMECODE.
 *
 *      BYTE bAudioTrack - Audio track.  May be VISCATRACKNONE,
 *              VISCATRACK8MMAFM, VISCATRACK8MMPCM,
 *              VISCATRACKVHSLINEAR, VISCATRACKVHSHIFI, or
 *              VISCATRACKVHSPCM.
 *
 * Returns: length of message.
 *
 *       Set the track registers which indicate the tracks to be played.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_PBTrack(
            LPSTR   lpstrMessage,
            BYTE    bVideoTrack,
            BYTE    bDataTrack,
            BYTE    bAudioTrack)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x31;
    lpstrMessage[cb + 1] = bVideoTrack;
    lpstrMessage[cb + 2] = bDataTrack;
    lpstrMessage[cb + 3] = bAudioTrack;
    return (cb + 4);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_PBTrackInq - Create a ViSCA MD_PBTrackInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 *
 *       Inquire for playback track register values.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_PBTrackInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x31;
    return (cb + 1);
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_PBTrackMode - Create a ViSCA MD_PBTrackMode
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bTrackType - Track type.  May be VISCATRACKVIDEO,
 *              VISCATRACKDATA, or VISCATRACKAUDIO.
 *
 *      BYTE bTrackNumber - Track number (0..7).
 *
 *      BYTE bTrackMode - Track mode.
 *              For video tracks, may be VISCAVIDEOMODENORMAL or
 *              VISCAVIDEOMODEEDIT.
 *              For auido tracks, may be VISCAAUDIOMODENORMAL,
 *              VISCAAUDIOMODEMONO, VISCAAUDIOMODESTEREO,
 *              VISCAAUDIOMODERIGHTONLY, VISCAAUDIOMODELEFTONLY,
 *              VISCAAUDIOMODEMULTILINGUAL, VISCAAUDIOMODEMAINCHANNELONLY, or
 *              VISCAAUDIOMODESUBCHANNELONLY.
 *
 * Returns: length of message.
 *
 *       Set the track mode register used to play a track.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_PBTrackMode(
            LPSTR   lpstrMessage,
            BYTE    bTrackType,
            BYTE    bTrackNumber,
            BYTE    bTrackMode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x32;
    lpstrMessage[cb + 1] = bTrackType;
    lpstrMessage[cb + 2] = bTrackNumber;
    lpstrMessage[cb + 3] = bTrackMode;
    return (cb + 4);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_PBTrackModeInq - Create a ViSCA 
 *              MD_PBTrackModeInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bTrackType - Track type.  May be VISCATRACKVIDEO,
 *              VISCATRACKDATA, or VISCATRACKAUDIO.
 *
 *      BYTE bTrackNumber - Track number (0..7).
 *
 * Returns: length of message.
 *
 *       Inquire for playback track mode register values.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_PBTrackModeInq(
            LPSTR   lpstrMessage,
            BYTE    bTrackType,
            BYTE    bTrackNumber)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x32;
    lpstrMessage[cb + 1] = bTrackType;
    lpstrMessage[cb + 2] = bTrackNumber;
    return (cb + 3);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_RecData - Create a ViSCA MD_RecData
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bTrackNumber - Track number (0..7).
 *
 *      LPSTR lpstrData - Data to store.
 *
 * Returns: length of message.
 *
 *       Set the record data registers.
 *       The Sony Vbox CI-1000 and Vdeck CVD-1000 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecData(
            LPSTR   lpstrMessage,
            BYTE    bTrackNumber,
            LPSTR   lpstrData)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x43;
    lpstrMessage[cb + 1] = bTrackNumber;
    _fmemcpy(&(lpstrMessage[cb + 2]), lpstrData, 5);
    return (cb + 7);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_RecDataInq - Create a ViSCA MD_RecDataInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bTrackNumber - Track number (0..7).
 *
 *      BYTE bDataType - Data type to retrieve.  May be VISCADATACHAPTER
 *              or VISCADATAUSERDATA.
 *
 * Returns: length of message.
 *
 *       Inquire for a track record data register value.
 *       The Sony Vbox CI-1000 and Vdeck CVD-1000 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecDataInq(
            LPSTR   lpstrMessage,
            BYTE    bTrackNumber,
            BYTE    bDataType)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x43;
    lpstrMessage[cb + 1] = bTrackNumber;
    lpstrMessage[cb + 2] = bDataType;
    return (cb + 3);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_RecReset - Create a ViSCA MD_RecReset
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 *
 *       Reset record registers.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecReset(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x40;
    lpstrMessage[cb + 1] = 0x00;
    return (cb + 2);
}
#endif


/****************************************************************************
 * Function: UINT viscaMessageMD_RecSpeed - Create a ViSCA MD_RecSpeed
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSpeed - Recording speed.  May be VISCASPEEDSP,
 *              VISCASPEEDLP, VISCASPEEDEP, VISCASPEEDBETAI,
 *              VISCASPEEDBETAII, or VISCASPEEDBETAIII.
 *
 * Returns: length of message.
 *
 *       Set the record speed register used for recording.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecSpeed(
            LPSTR   lpstrMessage,
            BYTE    bSpeed)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x4B;
    lpstrMessage[cb + 1] = bSpeed;
    return (cb + 2);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_RecSpeedInq - Create a ViSCA MD_RecSpeedInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 *
 *       Inquire for the record speed register value.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecSpeedInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x4B;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_RecTrack - Create a ViSCA MD_RecTrack
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bRecordMode - Record mode.  May be VISCARECORDMODEASSEMBLE or
 *              VISCARECORDMODEINSERT.
 *
 *      BYTE bVideoTrack - Video track.  May be VISCATRACKNONE or
 *              VISCATRACK1.
 *
 *      BYTE bDataTrack - Data track.  May be VISCATRACKNONE or
 *              VISCATRACKTIMECODE.
 *
 *      BYTE bAudioTrack - Audio track.  May be VISCATRACKNONE,
 *              VISCATRACK8MMAFM, VISCATRACK8MMPCM,
 *              VISCATRACKVHSLINEAR, VISCATRACKVHSHIFI, or
 *              VISCATRACKVHSPCM.
 *
 * Returns: length of message.
 *
 *       Set the record track registers that indicate the tracks to be
 *       recorded.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecTrack(
            LPSTR   lpstrMessage,
            BYTE    bRecordMode,
            BYTE    bVideoTrack,
            BYTE    bDataTrack,
            BYTE    bAudioTrack)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x41;
    lpstrMessage[cb + 1] = bRecordMode;
    lpstrMessage[cb + 2] = bVideoTrack;
    lpstrMessage[cb + 3] = bDataTrack;
    lpstrMessage[cb + 4] = bAudioTrack;
    return (cb + 5);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_RecTrackInq - Create a ViSCA MD_RecTrackInq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 *
 *       Inquire for the record track register values.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecTrackInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x41;
    return (cb + 1);
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_RecTrackMode - Create a ViSCA MD_RecTrackMode
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bTrackType - Track type.  May be VISCATRACKVIDEO,
 *              VISCATRACKDATA, or VISCATRACKAUDIO.
 *
 *      BYTE bTrackNumber - Track number (0..7).
 *
 *      BYTE bTrackMode - Track mode.
 *              For video tracks, may be VISCAVIDEOMODENORMAL,
 *              VISCAVIDEOMODESTANDARD, or VISCAVIDEOMODEHIQUALITY.
 *              For data tracks, may be VISCADATAMODENORMAL,
 *              VISCADATAMODETIMECODE, VISCADATAMODEDATEANDTIMECODE, or
 *              VISCADATAMODECHAPTERANDUSERDATAANDTIMECODE.
 *              For auido tracks, may be VISCAAUDIOMODENORMAL,
 *              VISCAAUDIOMODEMONO, VISCAAUDIOMODESTEREO,
 *              VISCAAUDIOMODERIGHTONLY, VISCAAUDIOMODELEFTONLY,
 *              VISCAAUDIOMODEMULTILINGUAL, VISCAAUDIOMODEMAINCHANNELONLY, or
 *              VISCAAUDIOMODESUBCHANNELONLY.
 *
 * Returns: length of message.
 *
 *       Set the track mode register used when recording a track.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecTrackMode(
            LPSTR   lpstrMessage,
            BYTE    bTrackType,
            BYTE    bTrackNumber,
            BYTE    bTrackMode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x42;
    lpstrMessage[cb + 1] = bTrackType;
    lpstrMessage[cb + 2] = bTrackNumber;
    lpstrMessage[cb + 3] = bTrackMode;
    return (cb + 4);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_RecTrackModeInq - Create a ViSCA 
 *              MD_RecTrackModeInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bTrackType - Track type.  May be VISCATRACKVIDEO,
 *              VISCATRACKDATA, or VISCATRACKAUDIO.
 *
 *      BYTE bTrackNumber - Track number (0..7).
 *
 * Returns: length of message.
 *
 *       Inquire for the record track register values.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_RecTrackModeInq(
            LPSTR   lpstrMessage,
            BYTE    bTrackType,
            BYTE    bTrackNumber)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x42;
    lpstrMessage[cb + 1] = bTrackType;
    lpstrMessage[cb + 2] = bTrackNumber;
    return (cb + 3);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_MediaSpeedInq - Create a ViSCA 
 *              MD_MediaSpeedInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 *
 *       Inquire for the recorded speed of the mounted media.
 *       The Sony Vbox CI-1000 and Vdeck CVD-1000 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_MediaSpeedInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x5B;
    return (cb + 1);
}
#endif


/****************************************************************************
 * Function: UINT viscaMessageMD_MediaTrackInq - Create a ViSCA 
 *              MD_MediaTrackInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 *
 *       Inquire for the tracks available on the mounted media.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_MediaTrackInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x51;
    return (cb + 1);
}


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageMD_MediaTrackModeInq - Create a ViSCA 
 *              MD_MediaTrackModeInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bTrackType - Track type.  May be VISCATRACKVIDEO,
 *              VISCATRACKDATA, or VISCATRACKAUDIO.
 *
 *      BYTE bTrackNumber - Track number (0..7).
 *
 * Returns: length of message.
 *
 *       Inquire for the mode used to record a track on the mounted media.
 *       The Sony Vbox CI-1000 does not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_MediaTrackModeInq(
            LPSTR   lpstrMessage,
            BYTE    bTrackType,
            BYTE    bTrackNumber)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x52;
    lpstrMessage[cb + 1] = bTrackType;
    lpstrMessage[cb + 2] = bTrackNumber;
    return (cb + 3);
}
#endif


/****************************************************************************
 * Function: UINT viscaMessageMD_SegInPoint - Create a ViSCA 
 *              MD_SegInPoint message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      LPSTR lpstrData - ViSCA data to store.
 *
 * Returns: length of message.
 *
 *       Set the segment in point register.
 *       The Sony Vbox CI-1000 and Vdeck CVD-100 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_SegInPoint(
            LPSTR   lpstrMessage,
            LPSTR   lpstrData)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x61;
    _fmemcpy(&(lpstrMessage[cb + 1]), lpstrData, 5);
    return (cb + 6);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_SegInPointInq - Create a ViSCA 
 *              MD_SegInPointInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *       Inquire for the segment in point register value.
 *       The Sony Vbox CI-1000 and Vdeck CVD-100 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_SegInPointInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x61;
    return (cb + 1);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_SegOutPoint - Create a ViSCA 
 *              MD_SegOutPoint message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      LPSTR lpstrData - ViSCA data to store.
 *
 * Returns: length of message.
 *
 *       Set the segment out point register.
 *       The Sony Vbox CI-1000 and Vdeck CVD-100 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_SegOutPoint(
            LPSTR   lpstrMessage,
            LPSTR   lpstrData)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x62;
    _fmemcpy(&(lpstrMessage[cb + 1]), lpstrData, 5);
    return (cb + 6);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_SegOutPointInq - Create a ViSCA 
 *              MD_SegOutPointInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *       Inquire for the segment out point register value.
 *       The Sony Vbox CI-1000 and Vdeck CVD-100 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_SegOutPointInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x62;
    return (cb + 1);
}

/****************************************************************************
 * Function: UINT viscaMessageMD_SegPreRollDuration - Create a ViSCA 
 *              MD_SegPreRollDuration message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      LPSTR lpstrData - ViSCA data to store.
 *
 * Returns: length of message.
 *
 *       Set the segment pre-roll duration register.
 *       The Sony Vbox CI-1000 and Vdeck CVD-100 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_SegPreRollDuration(
            LPSTR   lpstrMessage,
            LPSTR   lpstrData)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x63;
    _fmemcpy(&(lpstrMessage[cb + 1]), lpstrData, 5);
    return (cb + 6);
}


/****************************************************************************
 * Function: UINT viscaMessageMD_SegPreRollDurationInq - Create a ViSCA 
 *              MD_SegPreRollDurationInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *       Inquire for the segment pre-roll duration register value.
 *       The Sony Vbox CI-1000 and Vdeck CVD-100 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_SegPreRollDurationInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x63;
    return (cb + 1);
}

/****************************************************************************
 * Function: UINT viscaMessageMD_SegPostRollDuration - Create a ViSCA 
 *              MD_SegPostRollDuration message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      LPSTR lpstrData - ViSCA data to store.
 *
 * Returns: length of message.
 *
 *       Set the segment post-roll duration register.
 *       The Sony Vbox CI-1000 and Vdeck CVD-100 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_SegPostRollDuration(
            LPSTR   lpstrMessage,
            LPSTR   lpstrData)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x64;
    _fmemcpy(&(lpstrMessage[cb + 1]), lpstrData, 5);
    return (cb + 6);
}

/****************************************************************************
 * Function: UINT viscaMessageMD_SegPostRollDurationInq - Create a ViSCA 
 *              MD_SegPostRollDurationInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 *
 *       Inquire for the segment post-roll duration register value.
 *       The Sony Vbox CI-1000 and Vdeck CVD-100 do not accept this command.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageMD_SegPostRollDurationInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x02);

    lpstrMessage[cb] = 0x64;
    return (cb + 1);
}

//
// The following are special mode commands taken from Sony EVO-9650 VISCA reference
//
//

/****************************************************************************
 * Function: UINT viscaMessageENT_FrameStill - Create a ViSCA ENT_FrameStill
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSubCode - Action to take.  May be VISCSTILLON or
 *              VISCASTILLOFF
 *
 * Returns: length of message.
 *
 *       Most media devices will enter "Standby" mode when set to OFF.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageENT_FrameStill(
            LPSTR   lpstrMessage,
            BYTE    bSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x7E);
    
    /*  -- This is category 7e! */
    
    lpstrMessage[cb]     = 0x00;
    lpstrMessage[cb + 1] = 0x01;
    lpstrMessage[cb + 2] = 0x02;
    lpstrMessage[cb + 3] = 0x03;
    lpstrMessage[cb + 4] = 0x04;    
    lpstrMessage[cb + 5] = bSubCode;    
    
    return (cb + 6);
}

/****************************************************************************
 * Function: UINT viscaMessageENT_FrameMemorySelect - Create a ViSCA ENT_FrameMemorySelect
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE bSubCode - Action to take.  May be VISCABUFFER or
 *              VISCADNR
 *
 * Returns: length of message.
 *
 *       Most media devices will enter "Standby" mode when set to OFF.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageENT_FrameMemorySelect(
            LPSTR   lpstrMessage,
            BYTE    bSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x7E);
    
    /*  -- This is category 7e! */
    
    lpstrMessage[cb]     = 0x00;
    lpstrMessage[cb + 1] = 0x01;
    lpstrMessage[cb + 2] = 0x02;
    lpstrMessage[cb + 3] = 0x03;
    lpstrMessage[cb + 4] = 0x05;    
    lpstrMessage[cb + 5] = bSubCode;    
    
    return (cb + 6);
}


/****************************************************************************
 * Function: UINT viscaMessageENT_FrameMemorySelectInq - Create a ViSCA MD_Mode1Inq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageENT_FrameMemorySelectInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x7E);

    lpstrMessage[cb]    = 0x00;
    lpstrMessage[cb+1]  = 0x01;
    lpstrMessage[cb+2]  = 0x02;
    lpstrMessage[cb+3]  = 0x03;
    lpstrMessage[cb+4]  = 0x05;

    return (cb + 5);
}


/****************************************************************************
 * Function: UINT   viscaMessageENT_NFrameRec - Create a ViSCA ENT_FrameMemorySelect
 *                      message.
 *
 * Parameters:
 *
 *      LPSTR  lpstrMessage  - Buffer to hold ViSCA message.
 *
 *      int    iSubCode      - Number of frames
 *
 * Returns: length of message.
 *
 *       Most media devices will enter "Standby" mode when set to OFF.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageENT_NFrameRec(
            LPSTR   lpstrMessage,
            int     iSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x7E);
    
    /*  -- This is category 7e! */
    
    lpstrMessage[cb]     = 0x00;
    lpstrMessage[cb + 1] = 0x01;
    lpstrMessage[cb + 2] = 0x02;
    lpstrMessage[cb + 3] = 0x03;
    lpstrMessage[cb + 4] = 0x03;
    lpstrMessage[cb + 5] = 0x00;
    lpstrMessage[cb + 6] = (BYTE)(iSubCode / 100);
    lpstrMessage[cb + 7] = (BYTE)((iSubCode / 10) % 10);
    lpstrMessage[cb + 8] = (BYTE)(iSubCode % 10);
    
    return (cb + 9);
}

//
// The following are special effects modes taken from Sony EVO-9650 VISCA manual.
//
//

/****************************************************************************
 * Function: UINT   viscaMessageSE_VDEReadMode - 
 *              message.
 *
 * Parameters:
 *
 *      LPSTR  lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE   bSubCode - Action to take.  May be VISCABUFFER or
 *                  VISCADNR
 *
 * Returns: length of message.
 *
 *       Most media devices will enter "Standby" mode when set to OFF.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageSE_VDEReadMode(
            LPSTR   lpstrMessage,
            BYTE    bSubCode)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x03);
    
    lpstrMessage[cb]     = 0x43;
    lpstrMessage[cb + 1] = 0x01;
    lpstrMessage[cb + 2] = bSubCode;
    
    return (cb + 3);
}

/****************************************************************************
 * Function: UINT viscaMessageSE_VDEReadModeInq - Create a ViSCA MD_Mode1Inq
 *              message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 * Returns: length of message.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageSE_VDEReadModeInq(
            LPSTR   lpstrMessage)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x03);

    lpstrMessage[cb]    = 0x43;
    lpstrMessage[cb+1]  = 0x01;

    return (cb + 2);
}

//
//  The following functions create VISCA Switcher messages.
//  See VISCA Developer Manual 1.0, Chapter 7.
//

#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageSwitcher_IO - Create a ViSCA 
 *              Switcher_IO message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE nMatrix - Matrix number.
 *
 *      BYTE nVidOutChannel - Video output channel.
 *
 *      BYTE nVidInChannel - Video input channel.
 *
 *      BYTE nAudOutChannel - Audio output channel.
 *
 *      BYTE nAudInChannel - Audio input channel.
 *
 * Returns: length of message.
 *
 *       Route audio and video signals from inputs to outputs.
 *       If audio and video signals cannot be routed independently,
 *       then the audio input/output channel numbers will be ignored.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageSwitcher_IO(
                LPSTR   lpstrMessage,
                BYTE    nMatrix,
                BYTE    nVidOutChannel,
                BYTE    nVidInChannel,
                BYTE    nAudOutChannel,
                BYTE    nAudInChannel)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x03);

    lpstrMessage[cb] = 0x11;
    lpstrMessage[cb + 1] = TOBCD(nMatrix);
    lpstrMessage[cb + 2] = TOBCD(nVidOutChannel);
    lpstrMessage[cb + 3] = TOBCD(nVidInChannel);
    lpstrMessage[cb + 4] = TOBCD(nAudOutChannel);
    lpstrMessage[cb + 5] = TOBCD(nAudInChannel);
    return (cb + 6);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageSwitcher_IOConfigInq - Create a ViSCA 
 *              Switcher_IOConfigInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE nMatrix - Matrix number.
 *
 * Returns: length of message.
 *
 *       Inquire for configuration of a selector matrix.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageSwitcher_IOConfigInq(
                LPSTR   lpstrMessage,
                BYTE    nMatrix)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x03);

    lpstrMessage[cb] = 0x10;
    lpstrMessage[cb + 1] = TOBCD(nMatrix);
    return (cb + 2);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageSwitcher_IOInq - Create a ViSCA 
 *              Switcher_IOInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE nMatrix - Matrix number.
 *
 *      BYTE nVidOutChannel - Video output channel.
 *
 *      BYTE nAudOutChannel - Audio output channel.
 *
 * Returns: length of message.
 *
 *       Inquire for inputs selected for the specified outputs.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageSwitcher_IOInq(
                LPSTR   lpstrMessage,
                BYTE    nMatrix,
                BYTE    nVidOutChannel,
                BYTE    nAudOutChannel)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x03);

    lpstrMessage[cb] = 0x11;
    lpstrMessage[cb + 1] = TOBCD(nMatrix);
    lpstrMessage[cb + 2] = TOBCD(nVidOutChannel);
    lpstrMessage[cb + 3] = TOBCD(nAudOutChannel);
    return (cb + 4);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageSwitcher_FX - Create a ViSCA 
 *              Switcher_FX message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE nEffector - Effector number.
 *
 *      BYTE nEffectMode - Effect mode.
 *
 *      BYTE bTargetLevel - Target level (0..255).
 *
 *      BYTE cDurationSeconds - Duration (seconds).
 *
 *      BYTE cDurationFrames - Duration (frames).
 *
 * Returns: length of message.
 *
 *       Start an effect.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageSwitcher_FX(
                LPSTR   lpstrMessage,
                BYTE    nEffector,
                BYTE    nEffectMode,
                BYTE    bTargetLevel,
                BYTE    cDurationSeconds,
                BYTE    cDurationFrames)
{
    UINT    cb = viscaHeaderFormat1(lpstrMessage, 0x03);

    lpstrMessage[cb] = 0x21;
    lpstrMessage[cb + 1] = nEffector;
    lpstrMessage[cb + 2] = nEffectMode;
    lpstrMessage[cb + 3] = (BYTE)(bTargetLevel >> 4);
    lpstrMessage[cb + 4] = (BYTE)(bTargetLevel & 0x0F);
    lpstrMessage[cb + 5] = TOBCD(cDurationSeconds);
    lpstrMessage[cb + 6] = TOBCD(cDurationFrames);
    return (cb + 7);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageSwitcher_FXConfigInq - Create a ViSCA 
 *              Switcher_FXConfigInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE nEffector - Effector number.
 *
 * Returns: length of message.
 *
 *       Inquire for effector configuration.
 *       If nEffector is 0, then inquires for number of effectors.
 *       If nEffector is 1 or greater, then inquires for configuration
 *       of the specified effector.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageSwitcher_FXConfigInq(
                LPSTR   lpstrMessage,
                BYTE    nEffector)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x03);

    lpstrMessage[cb] = 0x20;
    lpstrMessage[cb + 1] = TOBCD(nEffector);
    return (cb + 2);
}
#endif


#ifdef NOTUSED
/****************************************************************************
 * Function: UINT viscaMessageSwitcher_FXInq - Create a ViSCA 
 *              Switcher_FXInq message.
 *
 * Parameters:
 *
 *      LPSTR lpstrMessage - Buffer to hold ViSCA message.
 *
 *      BYTE nEffector - Effector number.
 *
 * Returns: length of message.
 *
 *       Inquire for level of the specified effector.
 ***************************************************************************/
UINT FAR PASCAL
viscaMessageSwitcher_FXInq(
                LPSTR   lpstrMessage,
                BYTE    nEffector)
{
    UINT    cb = viscaHeaderInquiry(lpstrMessage, 0x03);

    lpstrMessage[cb] = 0x21;
    lpstrMessage[cb + 1] = TOBCD(nEffector);
    return (cb + 2);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\mcivisca\msmcivcr.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992-1995 Microsoft Corporation
 * 
 *  MSMCIVCR.C
 *
 *  Description:
 *
 *      Runs the background VCR task in NT.
 *
 *  Notes:
 *
 *      WinMain() - calls initialization function, processes message loop
 *
 **************************************************************************/
#define UNICODE

#include <windows.h>    // required for all Windows applications
#include <windowsx.h>

#ifdef DEBUG
#define DOUTSTR(a)  OutputDebugString(a);
#else
#define DOUTSTR(a)  //
#endif

#if !defined(_WIN32)     // Windows 3.x uses a FARPROC for dialogs
#define DLGPROC FARPROC
#endif
#if !defined (APIENTRY) // Windows NT defines APIENTRY, but 3.x doesn't
#define APIENTRY far pascal
#endif

HINSTANCE hInst;          // current instance

/****************************************************************************

    FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)

    PURPOSE: calls initialization function, processes message loop

    COMMENTS:

        Windows recognizes this function by name as the initial entry point
        for the program.  This function calls the application initialization
        routine, if no other instance of the program is running, and always
        calls the instance initialization routine.  It then executes a message
        retrieval and dispatch loop that is the top-level control structure
        for the remainder of execution.  The loop is terminated when a WM_QUIT
        message is received, at which time this function exits the application
        instance by returning the value passed by PostQuitMessage().

        If this function must abort before entering the message loop, it
        returns the conventional value NULL.

****************************************************************************/
int APIENTRY WinMain(
    HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{

    MSG msg;
    HINSTANCE hLibrary;
    FARPROC   lpFunc;

    /* Perform initializations that apply to a specific instance */
    DOUTSTR(L"** ** ** ** ** ** We are in the process...\n")

    hLibrary = LoadLibrary(L"mcivis32.dll"); // It's DLL in NT.

    if(!hLibrary)
    {
        DOUTSTR(L"===Error mcivisca.drv not found.\n")
    }

    lpFunc = GetProcAddress(hLibrary, "viscaTaskCommNotifyHandlerProc");

    if(lpFunc != (FARPROC)NULL)
    {
        (*lpFunc)((DWORD)hInstance);
    }
    else
    {
        DOUTSTR(L"Null function in msmcivcr.exe\n")
    }


    DOUTSTR(L"Going into message loop in msmcivcr.exe.\n")

    /* Acquire and dispatch messages until a WM_QUIT message is received. */

    while (GetMessage(&msg, // message structure
       (HWND)NULL,   // handle of window receiving the message
       0,      // lowest message to examine
       0))     // highest message to examine
    {
        TranslateMessage(&msg); // Translates virtual key codes
        DispatchMessage(&msg);  // Dispatches message to window
    }

    DOUTSTR(L"MsMciVcr.Exe Quitting _Goodbye_ *hei*.\n")

    FreeLibrary(hLibrary);

    return (msg.wParam); // Returns the value from PostQuitMessage

    lpCmdLine; // This will prevent 'unused formal parameter' warnings
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\mcivisca\viscacom.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 * 
 *  VISCACOM.C
 *
 *  MCI ViSCA Device Driver
 *
 *  Description:
 *
 *      Comm port procedures
 *
 ***************************************************************************/

#define  UNICODE
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include "appport.h"
#include <mmddk.h>
#include <string.h>
#include "vcr.h"
#include "viscadef.h"
#include "mcivisca.h"
#include "common.h"     //debugging macros

//
// This is used internally within this file. It is never returned to the calling process.
//
#define MCIERR_VCR_BREAK                    (MCIERR_CUSTOM_DRIVER_BASE)

/****************************************************************************
 * Function: BOOL viscaReleaseMutex  - Unlock the synchronization flag.
 *
 * Parameters:
 *
 *      BOOL FAR * gfFlag - Pointer to synchronization flag.
 *
 * Returns: state before unlock (either locked==0 or unlocked==1)
 *        
 ***************************************************************************/
BOOL FAR PASCAL viscaReleaseMutex(VISCAINSTHANDLE gfFlag)
{
#ifdef _WIN32
    DWORD dwResult;

    if(!ReleaseMutex(gfFlag))
    {
        dwResult = GetLastError();
        DPF(DBG_ERROR, "ReleaseMutex failed. %x Error:%u \n", gfFlag, dwResult);
        return FALSE;
    }

    DPF(DBG_SYNC, "viscaReleaseMutex. %x\n", gfFlag);
    return TRUE;
#else
    // Releasing a semaphore/mutex just increments its count/or sets it to true.
    BOOL fBefore = *gfFlag;
    *gfFlag = TRUE;
    return fBefore;
#endif
}


/****************************************************************************
 * Function: BOOL viscaReleaseMutex  - Unlock the synchronization flag.
 *
 * Parameters:
 *
 *      BOOL FAR * gfFlag - Pointer to synchronization flag.
 *
 * Returns: state before unlock (either locked==0 or unlocked==1)
 *        
 ***************************************************************************/
BOOL FAR PASCAL viscaReleaseSemaphore(VISCAINSTHANDLE gfFlag)
{
#ifdef _WIN32
    DWORD dwResult;

    if(!ReleaseSemaphore(gfFlag, 1, NULL))
    {
        dwResult = GetLastError();
        DPF(DBG_ERROR, "ReleaseSemaphore failed. %x Error:%u \n", gfFlag, dwResult);
        return FALSE;
    }

    DPF(DBG_SYNC, "viscaReleaseSemaphore. %x\n", gfFlag);
    return TRUE;
#else
    // Releasing a semaphore/mutex just increments its count/or sets it to true.
    BOOL fBefore = *gfFlag;
    *gfFlag      = TRUE;
    return fBefore;
#endif
}


/****************************************************************************
 * Function: BOOL viscaResetEvent  - Unlock the synchronization flag.
 *
 * Parameters:
 *
 *      BOOL FAR * gfFlag - Pointer to synchronization flag.
 *
 * Returns: state before unlock (either locked==0 or unlocked==1)
 *        
 ***************************************************************************/
BOOL FAR PASCAL viscaResetEvent(VISCAINSTHANDLE gfFlag)
{
#ifdef _WIN32
    DWORD dwResult;

    if(!ResetEvent(gfFlag))
    {
        dwResult = GetLastError();
        DPF(DBG_ERROR, "ResetEvent failed. %x Error:%u \n", gfFlag, dwResult);
        return FALSE;
    }
    DPF(DBG_SYNC, "viscaResetEvent %x.\n", gfFlag);
    return TRUE;
#else
    BOOL fBefore = *gfFlag;
    *gfFlag = FALSE;
    return fBefore;
#endif
}


/****************************************************************************
 * Function: BOOL viscaSetEvent  - Unlock the synchronization flag.
 *
 * Parameters:
 *
 *      BOOL FAR * gfFlag - Pointer to synchronization flag.
 *
 * Returns: state before unlock (either locked==0 or unlocked==1)
 *        
 ***************************************************************************/
BOOL FAR PASCAL viscaSetEvent(VISCAINSTHANDLE gfFlag)
{
#ifdef _WIN32
    DWORD dwResult;

    if(!SetEvent(gfFlag))
    {
        dwResult = GetLastError();
        DPF(DBG_ERROR, "SetEvent failed. %x Error:%u \n", gfFlag, dwResult);
        return FALSE;
    }
    DPF(DBG_SYNC, "viscaSetEvent %x.\n", gfFlag);
    return TRUE;
#else
    BOOL fBefore = *gfFlag;
    *gfFlag = TRUE;
    return fBefore;
#endif
}


/****************************************************************************
 * Function: BOOL viscaWaitForSingleObject - Wait for unlock, and then lock.
 *
 * Returns: true if unlock came before timeout.
 *        
 ***************************************************************************/
DWORD FAR PASCAL viscaWaitForSingleObject(VISCAINSTHANDLE gfFlag, BOOL fManual, DWORD dwTimeout, UINT uDeviceID)
{
#ifdef _WIN32
    DWORD dwResult, dwErrorResult;
    DWORD dwBreakTimeout = 250;

    // Succees is WAIT_ABANDONED, WAIT_OBJECT_0, WAIT_TIMEOUT
    // Failure is WAIT_FAILED == 0xffffffff            

    if(uDeviceID == 0)
    {
        dwResult = WaitForSingleObject(gfFlag, dwTimeout); // Infinite wait, and auto lock.
    }
    else
    {
        // Should be infinite for all these cases!
        while(1)
        {
            dwResult = WaitForSingleObject(gfFlag, dwBreakTimeout);

            if(dwResult == WAIT_TIMEOUT)
            {
                if (mciDriverYield(uDeviceID))
                {
                    DPF(DBG_SYNC, "Break received, relocking the device\n");
                    return FALSE;
                }
            }
            else
            {
                // Wait failed or wait success!
                break;
            }
        }
    }

    if(dwResult == WAIT_FAILED)
    {
        dwErrorResult = GetLastError();
        DPF(DBG_ERROR, "WaitForSingleObject %x Error:%u\n", gfFlag, dwErrorResult);
        return FALSE;
    }
    else if(dwResult == WAIT_TIMEOUT)
    {
        DPF(DBG_ERROR, "WaitForSingleObject %x Error:Timeout:%u", gfFlag, dwTimeout);
        return WAIT_TIMEOUT;
    }

    DPF(DBG_SYNC, "viscaWaitForSingleObject %x.\n", gfFlag);
#else
    DWORD   dwTime0     = GetTickCount();
    DWORD   dwTime;

    // It is locked when it is false.
    //
    // Wait until it goes to true. i.e. becomes unlocked.
    // Then set it to locked. i.e. Set it to false again.
    // So when we exit we are in locked state.
    //
    DPF(DBG_SYNC, "viscaWait <----- enter. &flag=%x\n", gfFlag);

    while(!*gfFlag)
    {
        if(dwTimeout != MY_INFINITE)
        {
            dwTime = GetTickCount();
            if (((dwTime < dwTime0) && ((dwTime + (ROLLOVER - dwTime0)) > dwTimeout)) ||
                    ((dwTime - dwTime0) > dwTimeout))
            {
                DPF(DBG_ERROR, "viscaWait - Timeout.\n");
                return WAIT_TIMEOUT;
            }
        }

        if(uDeviceID != 0)
        {
            if (mciDriverYield(uDeviceID))
            {
                DPF(DBG_SYNC, "Break received, relocking the device\n");
                return FALSE;
            }
        }
        else
        {
            Yield();
        }
    }

    DPF(DBG_SYNC, "viscaWait ----> exit. &flag=%x\n", gfFlag);

    if(!fManual)
        *gfFlag = FALSE;

#endif
    return 1L;
}

/****************************************************************************
 * Function: DWORD viscaErrorToMCIERR - Convert a ViSCA error code to an
 *               MCI error code (MCIERR_XXXX).
 *
 * Parameters:
 *
 *      BYTE bError - ViSCA error code.
 *
 * Returns: an MCI error code.
 *
 *       Converts a ViSCA error code to an MCI error code.
 *       If the ViSCA error code is not one of the predefined error codes,
 *       then MCIERR_DRIVER is returned.
 ***************************************************************************/
DWORD FAR PASCAL
    viscaErrorToMCIERR(BYTE bError)
{
    switch (bError) {
        case (BYTE)0x00:
            return (MCIERR_NO_ERROR);
        case VISCAERRORBUFFERFULL:
            return (MCIERR_VCR_COMMAND_BUFFER_FULL);
        case VISCAERRORCANCELLED:
            return (MCIERR_VCR_COMMAND_CANCELLED);
        case VISCAERRORPOWEROFF:
            return (MCIERR_VCR_POWER_OFF);
        case VISCAERRORCOMMANDFAILED:
            return (MCIERR_VCR_COMMAND_FAILED);
        case VISCAERRORSEARCH:
            return (MCIERR_VCR_SEARCH);
        case VISCAERRORCONDITION:
            return (MCIERR_VCR_CONDITION);
        case VISCAERRORCAMERAMODE:
            return (MCIERR_VCR_CAMERA_MODE);
        case VISCAERRORVCRMODE:
            return (MCIERR_VCR_VCR_MODE);
        case VISCAERRORCOUNTERTYPE:
            return (MCIERR_VCR_COUNTER_TYPE);
        case VISCAERRORTUNER:
            return (MCIERR_VCR_TUNER);
        case VISCAERROREMERGENCYSTOP:
            return (MCIERR_VCR_EMERGENCY_STOP);
        case VISCAERRORMEDIAUNMOUNTED:
            return (MCIERR_VCR_MEDIA_UNMOUNTED);
        case VISCAERRORSYNTAX:
            return (MCIERR_UNSUPPORTED_FUNCTION);
        case VISCAERRORREGISTER:
        case VISCAERRORREGISTERMODE:
            return (MCIERR_VCR_REGISTER);
        case VISCAERRORMESSAGELENGTH:
        case VISCAERRORNOSOCKET:
        default:
            return (MCIERR_DRIVER_INTERNAL);
    }
}

#ifdef DEBUG
/****************************************************************************
 * Function: void viscaPacketPrint - Print a ViSCA packet.
 *
 * Parameters:
 *
 *      LPSTR lpstrData - Data to print.
 *
 *      UINT cbData - Number of bytes to print.
 ***************************************************************************/
void FAR PASCAL
viscaPacketPrint(LPSTR lpstrData, UINT cbData)
{
    char    sz[128];
    LPSTR   lpch = sz;
    UINT    i;

    for (i = 0; i < cbData; i++, lpch += 5)
    {
#ifdef _WIN32
        wsprintfA(lpch, "%#02x ", (UINT)(BYTE)(lpstrData[i]));
#else
        wsprintf(lpch, "%#02x ", (UINT)(BYTE)(lpstrData[i]));
#endif
    }
    *lpch++ = '\n';
    *lpch = '\0';
#ifdef _WIN32
    OutputDebugStringA(sz);  // This MUST print in ASCII, override unicode!
#else
    DPF(DBG_COMM, sz);
#endif
}
#endif

/****************************************************************************
 * Function: BOOL viscaWriteCancel - Write cancel command
 *
 * Parameters:
 *
 *      int iInst - Comm device ID.
 *
 *      BYTE  bDest - Destination device (where to cancel)
 *
 *      LPSTR lpstrPacket - the cancel message.
 *
 *      UINT  cbMessageLength - message length.
 *
 * Returns: TRUE if successful or FALSE
 *
 ***************************************************************************/
BOOL FAR PASCAL
viscaWriteCancel(int iInst, BYTE bDest, LPSTR lpstrPacket, UINT cbMessageLength)
{
    lpstrPacket[0]                   = MAKEDEST(bDest);
    lpstrPacket[cbMessageLength + 1] = VISCAPACKETEND;

    DPF(DBG_QUEUE, "###Wrote Cancel: ");
    viscaPacketPrint(lpstrPacket, cbMessageLength + 2);

    // Do not lock here. Already should have been acquired.
#ifdef _WIN32
    WaitForSingleObject(pinst[iInst].pfTxBuffer, MY_INFINITE);  // This synchronizes to port.

    // Copy it to the Port Tx buffer.
    _fmemcpy(pvcr->Port[pinst[iInst].iPort].achTxPacket, lpstrPacket, cbMessageLength + 2);
    pvcr->Port[pinst[iInst].iPort].nchTxPacket = cbMessageLength + 2;

    // Signal that it is time to transmit. (we must use our version of the handle).
    SetEvent(pinst[iInst].pfTxReady);
#else
    if(!viscaCommWrite(pvcr->Port[pinst[iInst].iPort].idComDev, lpstrPacket, cbMessageLength + 2))
        return FALSE;
#endif

    return TRUE;
}


/****************************************************************************
 * Function: BOOL viscaWrite - Write a ViSCA packet.
 *
 * Parameters:
 *
 *      int iInst - Pointer to OpenInstance struct identifying
 *                               the MCI device which is doing the writing.
 *
 *      BYTE bDest - Destination device ID (1..7).
 *
 *      LPSTR lpstrPacket - Buffer containing ViSCA packet.
 *                             The ViSCA message is assumed to exist already
 *                             starting at lpstrPacket + 1.
 *
 *      UINT  cbMessageLength - Length of ViSCA message.
 *
 *      HWND  hwndNotify   - Window to notify on completion.
 *
 *      DWORD dwFlags      - MCI-flags (MCI_WAIT and/or MCI_NOTIFY)
 *
 *      BOOL  fQueue       - Is this a queued command or just syncrhonous.
 *
 * Returns: TRUE if things went ok, FALSE otherwise.
 *
 ***************************************************************************/
BOOL FAR PASCAL
    viscaWrite(int iInst,  BYTE bDest, LPSTR lpstrPacket,
        UINT cbMessageLength, HWND hwndNotify, DWORD dwFlags, BOOL fQueue)
{
    UINT iPort = pinst[iInst].iPort;
    UINT iDev  = pinst[iInst].iDev;
    UINT uTimerID = 0;

    if (bDest == BROADCASTADDRESS)
        pvcr->Port[iPort].iBroadcastDev = iDev;

    lpstrPacket[0]                   = MAKEDEST(bDest);
    lpstrPacket[cbMessageLength + 1] = VISCAPACKETEND;
    //
    // Allow only one out-standing message to a device at a time 
    //
    if(viscaWaitForSingleObject(pinst[iInst].pfTxLock, FALSE, 10000L, pinst[iInst].uDeviceID) == WAIT_TIMEOUT)
    {
        DPF(DBG_ERROR, "Failed waiting pfTxLock in viscaWrite.\n");
        return FALSE;
    }
    //
    // Set the packet flags.
    //
    if(fQueue)
    {
        // The autoinstance will take control after transmission. This will be an asynchronous command.
        _fmemset(pinst[iInst].achPacket, '\0', MAXPACKETLENGTH);
        pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].hwndNotify    = NULL;
        pvcr->Port[iPort].Dev[iDev].bReplyFlags                         = (BYTE) 0;
        pvcr->Port[iPort].Dev[iDev].iInstReply                          = pvcr->iInstBackground;
    
        if(dwFlags & MCI_NOTIFY)
            pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].hwndNotify = hwndNotify;
    
        if(dwFlags & MCI_WAIT)
            pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].fWaiting   = TRUE;
        else
            pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].fWaiting   = FALSE;

        viscaResetEvent(pinst[iInst].pfAutoCompletion);
        viscaResetEvent(pinst[iInst].pfAutoAck); //First ack to make sure it is alive.
    }
    else
    {
        // This is going to be a synchronous command with response to inst.
        _fmemset(pinst[iInst].achPacket, '\0', MAXPACKETLENGTH);
        pvcr->Port[iPort].Dev[iDev].iInstReply = iInst; 
        pinst[iInst].bReplyFlags               = 0;

        viscaResetEvent(OWNED(pinst[iInst].fCompletionEvent));
        viscaResetEvent(OWNED(pinst[iInst].fAckEvent));
    }


#ifdef _WIN32
    // Get a buffer to the port.
    if(viscaWaitForSingleObject(pinst[iInst].pfTxBuffer, FALSE, 10000L, 0) == WAIT_TIMEOUT)
    {
        DPF(DBG_ERROR, "Failed waiting pfTxBuffer in viscaWrite.\n");
    }
#endif

    DPF(DBG_COMM, "---Wrote: ");
    DF(DBG_COMM, viscaPacketPrint(lpstrPacket, cbMessageLength + 2));

    //
    // Try to write packet
    //
#ifdef _WIN32
    // Copy it to the Tx buffer. (I really should have a tx queue!
    _fmemcpy(pvcr->Port[iPort].achTxPacket, lpstrPacket, cbMessageLength + 2);
    pvcr->Port[iPort].nchTxPacket = cbMessageLength + 2;

    // Signal that it is time to transmit. (we must use our version of the handle).
    if(!SetEvent(pinst[iInst].pfTxReady))
    {
        DPF(DBG_ERROR, "Failed SetEvent pfTxReady. \n");
    }
#else
    if (!viscaCommWrite(pvcr->Port[pinst[iInst].iPort].idComDev, lpstrPacket, cbMessageLength + 2))
    {
        DPF(DBG_ERROR, "viscaWrite - viscaCommWrite has failed, unlock Tx now.\n");
        pvcr->Port[iPort].Dev[iDev].iInstReply = -1;

        viscaReleaseSemaphore(pinst[iInst].pfTxLock);
        return FALSE;
    }
#endif

    return TRUE;
}


/****************************************************************************
 * Function: DWORD viscaWaitCompletion. - Wait for completion of command.
 *
 * Parameters:
 *
 *      int iInst - Pointer to OpenInstance struct identifying
 *                               the MCI device which is awaiting a reply.
 *
 *      BOOL  fQueue - Is this a transport command?
 *
 *      BOOL  fUseAckTimer - Should we use ack timer for timeout, or use GetTickCount.
 *
 * Returns: TRUE if the wait runs until a completion, FALSE if someone breaks it.
 *
 ***************************************************************************/
BOOL FAR PASCAL
    viscaWaitCompletion(int iInst, BOOL fQueue, BOOL fWait)
{
    UINT    uDeviceID   = pinst[iInst].uDeviceID;
    UINT    iDev        = pinst[iInst].iDev;
    UINT    iPort       = pinst[iInst].iPort;
    DWORD   dwResult    = 0L;

    //
    // Always wait for the ack to instance on this command.
    // Auto-ack will signal first ack of an auto-command.
    //
    if(fQueue)
        dwResult = viscaWaitForSingleObject(pinst[iInst].pfAutoAck, TRUE, 4000L, 0);
    else
        dwResult = viscaWaitForSingleObject(OWNED(pinst[iInst].fAckEvent), TRUE, 4000L, 0);

    if(dwResult == WAIT_TIMEOUT)
    {
        DPF(DBG_ERROR, "Failed wait for AckEvent in viscaWaitCompletion.\n");
        pvcr->Port[iPort].Dev[iDev].iInstReply     = -1;
        if(fQueue)
        {
            pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_COMPLETION;
            pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_ERROR;
            pvcr->Port[iPort].Dev[iDev].bReplyFlags |= VISCAF_ERROR_TIMEOUT;

            // Transport command was not set until sucessful ack, and long running.
            pvcr->Port[iPort].Dev[iDev].wTransportCmd  = 0;
            pinst[iInst].hwndNotify                    = (HWND)NULL;
            viscaSetEvent(pinst[iInst].pfTransportFree);
            viscaReleaseSemaphore(pinst[iInst].pfTxLock);
            if(pvcr->Port[iPort].Dev[iDev].iInstTransport != -1)
                pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].fWaiting   = FALSE;
            pvcr->Port[iPort].Dev[iDev].iInstTransport = -1;
        }
        else
        {
            pinst[iInst].bReplyFlags |= VISCAF_COMPLETION;
            pinst[iInst].bReplyFlags |= VISCAF_ERROR;
            pinst[iInst].bReplyFlags |= VISCAF_ERROR_TIMEOUT;
            viscaReleaseSemaphore(pinst[iInst].pfTxLock);
        }
        return FALSE; 
    }

    if(fQueue && fWait)
    {
        if(viscaWaitForSingleObject(pinst[iInst].pfAutoCompletion, TRUE, MY_INFINITE, pinst[iInst].uDeviceID)==0)
            goto NotDone;            
        //
        // We must be sure of receiving the event before allowing another to be issued.
        // That's why the release is done in viscacom.c and not commtask.c
        //
        // We lock the device so noone (in mcidelay.c) sees -1 before tport free is signalled. (does it matter?)
        viscaWaitForSingleObject(pinst[iInst].pfDeviceLock, FALSE, MY_INFINITE, 0);

        DPF(DBG_QUEUE, "###Releasing transport in viscacom.c\n");
        viscaReleaseAutoParms(iPort, iDev);
        //
        // We are a foreground thread, so we must use our version.
        //
        viscaSetEvent(pinst[iInst].pfTransportFree); //Someone may be waiting for this.
        viscaReleaseMutex(pinst[iInst].pfDeviceLock);

    }
    else if(!fQueue)
    {
        if(WAIT_TIMEOUT == viscaWaitForSingleObject(OWNED(pinst[iInst].fCompletionEvent), TRUE, MY_INFINITE, pinst[iInst].uDeviceID))
        {
            DPF(DBG_ERROR, "Failed wait for CompletionEvent in viscaWaitCompletion.\n");
        }
    }

    NotDone:
    // This can be set done here before we get here.
    if(pvcr->Port[iPort].Dev[iDev].iInstTransport != -1)
        pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].fWaiting   = FALSE;

    return TRUE;
}


void FAR PASCAL viscaReleaseAutoParms(int iPort, int iDev)
{
    pvcr->Port[iPort].Dev[iDev].wCancelledCmd  = pvcr->Port[iPort].Dev[iDev].wTransportCmd;
    pvcr->Port[iPort].Dev[iDev].iCancelledInst = pvcr->Port[iPort].Dev[iDev].iInstTransport;
    pvcr->Port[iPort].Dev[iDev].hwndCancelled  = pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].hwndNotify;

    pvcr->Port[iPort].Dev[iDev].wTransportCmd  = 0;
    pinst[pvcr->Port[iPort].Dev[iDev].iInstTransport].hwndNotify = (HWND)NULL;
    pvcr->Port[iPort].Dev[iDev].iInstTransport = -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciwave\config.h ===
/****************************************************************************/

/*
**  Copyright (c) 1985-1992 Microsoft Corporation
**
**  Title: config.h Multimedia Systems Media Control Interface
**  streaming digital audio driver internal header file.
**
**  Version:    1.00
**
**  Date:       ?
**
**  Author:     ROBWI
*/

/****************************************************************************/

/*
**  Change log:
**
**  DATE        REV     DESCRIPTION
**  ----------- -----   ------------------------------------------
**                      Original
**  10-Jan-1992 MikeTri Ported to NT
**                  @@@ need to change slash slash comments to slash star
*/

/****************************************************************************/

#define IDD_CONFIG  1

#define IDSCROLL   0x00000100
#define IDCOUNT    0x00000101

// Stretched the above to make them DWORD rather than WORD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\mcivisca\viscadef.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 * 
 *  VISCADEF.H
 *
 *  MCI ViSCA Device Driver
 *
 *  Description:
 *
 *      ViSCA constant declarations
 *
 ***************************************************************************/

#define MAXPACKETLENGTH             16

/* defines for addresses */
#define MASTERADDRESS               (BYTE)0x00    /* address of the computer */
#define BROADCASTADDRESS            (BYTE)0x08    /* address for broadcasts to all devices */

#define VISCA_READ_COMPLETE_OK      (BYTE)0x00
#define VISCA_READ_ACK_OK           (BYTE)0x01
#define VISCA_READ_BREAK            (BYTE)0x02
#define VISCA_READ_TIMEOUT          (BYTE)0x03
#define VISCA_READ_ACK_ERROR        (BYTE)0x04
#define VISCA_READ_COMPLETE_ERROR   (BYTE)0x05

#define VISCA_WRITE_ERROR           (BYTE)0x06
#define VISCA_WRITE_OK              (BYTE)0x07
#define VISCA_WRITE_BREAK           (BYTE)0x08

/* defines for reply types */
#define VISCAREPLYTYPEMASK          (BYTE)0xF0
#define VISCAREPLYSOCKETMASK        (BYTE)0x0F
#define VISCAREPLYADDRESS           (BYTE)0x30
#define VISCAREPLYACK               (BYTE)0x40
#define VISCAREPLYCOMPLETION        (BYTE)0x50
#define VISCAREPLYERROR             (BYTE)0x60
#define VISCAREPLYDEVICE(lp)        (BYTE)((((LPSTR)(lp))[0] & 0x70) >> 4)
#define VISCAREPLYTODEVICE(lp)      (BYTE)(((LPSTR)(lp))[0] & 0x07)
#define VISCAREPLYBROADCAST(lp)     (BYTE)(((LPSTR)(lp))[0] & 0x08)
#define VISCAREPLYSOCKET(lp)        (BYTE)(((LPSTR)(lp))[1] & VISCAREPLYSOCKETMASK)
#define VISCAREPLYTYPE(lp)          (BYTE)(((LPSTR)(lp))[1] & VISCAREPLYTYPEMASK)
#define VISCAREPLYERRORCODE(lp)     (BYTE)(((LPSTR)(lp))[2])

#define VISCABROADCAST              (BYTE)0x88


/* defines for reply error codes */
#define VISCAERRORMESSAGELENGTH     (BYTE)0x01
#define VISCAERRORSYNTAX            (BYTE)0x02
#define VISCAERRORBUFFERFULL        (BYTE)0x03
#define VISCAERRORCANCELLED         (BYTE)0x04
#define VISCAERRORNOSOCKET          (BYTE)0x05
#define VISCAERRORPOWEROFF          (BYTE)0x40
#define VISCAERRORCOMMANDFAILED     (BYTE)0x41
#define VISCAERRORSEARCH            (BYTE)0x42
#define VISCAERRORCONDITION         (BYTE)0x43
#define VISCAERRORCAMERAMODE        (BYTE)0x44
#define VISCAERRORVCRMODE           (BYTE)0x45
#define VISCAERRORCOUNTERTYPE       (BYTE)0x46
#define VISCAERRORTUNER             (BYTE)0x47
#define VISCAERROREMERGENCYSTOP     (BYTE)0x48
#define VISCAERRORMEDIAUNMOUNTED    (BYTE)0x49
#define VISCAERRORREGISTER          (BYTE)0x4A
#define VISCAERRORREGISTERMODE      (BYTE)0x4B


/*** DEFINES FOR VISCA DATA TYPES ***/

/* defines for VISCA data types, also used in
   MD_PositionInq and MD_RecDataInq messages */
#define VISCADATATOPMIDDLEEND       (BYTE)0x01
#define VISCADATARELATIVE           (BYTE)0x10
#define VISCADATA4DIGITDECIMAL      (BYTE)0x11
#define VISCADATAHMS                (BYTE)0x12
#define VISCADATAHMSF               (BYTE)0x13
#define VISCADATAINDEX              (BYTE)0x32
#define VISCADATAABSOLUTE           (BYTE)0x20
#define VISCADATATIMECODENDF        (BYTE)0x21
#define VISCADATATIMECODEDF         (BYTE)0x22
#define VISCADATACHAPTER            (BYTE)0x31
#define VISCADATADATE               (BYTE)0x41
#define VISCADATATIME               (BYTE)0x42

/* defines to convert to and from binary coded decimal */
#define FROMBCD(b)                  (UINT)(10 * ((BYTE)(b) >> 4) + ((BYTE)(b) & 0x0F))
#define TOBCD(n)                    (BYTE)((((UINT)(n) / 10) << 4) + ((UINT)(n) % 10))

/* defines to extract hours, minutes, seconds, frames from a data type */
#define VISCANEGATIVE(lp)           (BOOL)(((BYTE FAR *)(lp))[1] & 0x40)
#define VISCAHOURS(lp)              FROMBCD(((BYTE FAR *)(lp))[1])
#define VISCAMINUTES(lp)            FROMBCD(((BYTE FAR *)(lp))[2])
#define VISCASECONDS(lp)            FROMBCD(((BYTE FAR *)(lp))[3])
#define VISCAFRAMES(lp)             FROMBCD(((BYTE FAR *)(lp))[4])

/* defines for Top/Middle/End data type */
#define VISCATOP                    (BYTE)0x01
#define VISCAMIDDLE                 (BYTE)0x02
#define VISCAEND                    (BYTE)0x03

/* defines for Index, Date, Time, User Data data types */
#define VISCAFORWARD                (BYTE)0x00
#define VISCAREVERSE                (BYTE)0x40

#define VISCASTILLON                (BYTE)0x01
#define VISCASTILLOFF               (BYTE)0x00

/*** DEFINES FOR VISCA MESSSSAGES ***/

/* defines for MD_CameraFocus message */
#define VISCAFOCUSSTOP              (BYTE)0x00
#define VISCAFOCUSFAR               (BYTE)0x02
#define VISCAFOCUSNEAR              (BYTE)0x03

/* defines for MD_CameraZoom message */
#define VISCAZOOMSTOP               (BYTE)0x00
#define VISCAZOOMTELE               (BYTE)0x02
#define VISCAZOOMWIDE               (BYTE)0x03

/* defines for MD_EditControl message */
#define VISCAEDITPBSTANDBY          (BYTE)0x20
#define VISCAEDITPLAY               (BYTE)0x28    /* Format 2 only */
#define VISCAEDITPLAYSHUTTLESPEED   (BYTE)0x29    /* Format 2 only */
#define VISCAEDITRECSTANDBY         (BYTE)0x40
#define VISCAEDITRECORD             (BYTE)0x48    /* Format 2 only */
#define VISCAEDITRECORDSHUTTLESPEED (BYTE)0x49    /* Format 2 only */

/* defines for MD_Mode1 and responses to MD_Mode1 and MD_TransportInq messages */
#define VISCAMODE1STOP              (BYTE)0x00
#define VISCAMODE1STOPTOP           (BYTE)0x02
#define VISCAMODE1STOPEND           (BYTE)0x04
#define VISCAMODE1STOPEMERGENCY     (BYTE)0x06
#define VISCAMODE1FASTFORWARD       (BYTE)0x08
#define VISCAMODE1REWIND            (BYTE)0x10
#define VISCAMODE1EJECT             (BYTE)0x18
#define VISCAMODE1STILL             (BYTE)0x20
#define VISCAMODE1SLOW2             (BYTE)0x24
#define VISCAMODE1SLOW1             (BYTE)0x26
#define VISCAMODE1PLAY              (BYTE)0x28
#define VISCAMODE1SHUTTLESPEEDPLAY  (BYTE)0x29
#define VISCAMODE1FAST1             (BYTE)0x2A
#define VISCAMODE1FAST2             (BYTE)0x2C
#define VISCAMODE1SCAN              (BYTE)0x2E
#define VISCAMODE1REVERSESLOW2      (BYTE)0x34
#define VISCAMODE1REVERSESLOW1      (BYTE)0x36
#define VISCAMODE1REVERSEPLAY       (BYTE)0x38
#define VISCAMODE1REVERSEFAST1      (BYTE)0x3A
#define VISCAMODE1REVERSEFAST2      (BYTE)0x3C
#define VISCAMODE1REVERSESCAN       (BYTE)0x3E
#define VISCAMODE1RECPAUSE          (BYTE)0x40
#define VISCAMODE1RECORD            (BYTE)0x48
#define VISCAMODE1SHUTTLESPEEDRECORD    (BYTE)0x49
#define VISCAMODE1CAMERARECPAUSE    (BYTE)0x50
#define VISCAMODE1CAMERAREC         (BYTE)0x58
#define VISCAMODE1EDITSEARCHFORWARD (BYTE)0x5C
#define VISCAMODE1EDITSEARCHREVERSE (BYTE)0x5E

/* defines for MD_Mode2 message */
#define VISCAMODE2FRAMEFORWARD      (BYTE)0x02
#define VISCAMODE2FRAMEREVERSE      (BYTE)0x03
#define VISCAMODE2INDEXERASE        (BYTE)0x10
#define VISCAMODE2INDEXMARK         (BYTE)0x11
#define VISCAMODE2FRAMERECORDFORWARD    (BYTE)0x42

/* defines for MD_Power message */
#define VISCAPOWERON                (BYTE)0x02
#define VISCAPOWEROFF               (BYTE)0x03

/* defines for MD_Search message */
#define VISCASTOP                   (BYTE)0x00
#define VISCASTILL                  (BYTE)0x20
#define VISCAPLAY                   (BYTE)0x28
#define VISCANOMODE                 (BYTE)0xFF

/* defines for reply to MD_TransportInq message */
#define VISCATRANSPORTEDIT          (BYTE)0x04    /* Bit 2 */
#define VISCATRANSPORTSEARCH        (BYTE)0x02    /* Bit 1 */
#define VISCATRANSPORTINTRANSITION  (BYTE)0x01    /* Bit 0 */

/* defines for MD_ClockSet message */
#define VISCACLOCKSTART             (BYTE)0x02
#define VISCACLOCKSTOP              (BYTE)0x03

/* defines for reply to MD_MediaInq message */
#define VISCAFORMAT8MM              (BYTE)0x01
#define VISCAFORMATVHS              (BYTE)0x02
#define VISCAFORMATBETA             (BYTE)0x03
#define VISCAFORMATHI8              (BYTE)0x41
#define VISCAFORMATSVHS             (BYTE)0x42
#define VISCAFORMATEDBETA           (BYTE)0x43
#define VISCATYPEHG                 (BYTE)0x08    /* Bit 3 */
#define VISCATYPETHIN               (BYTE)0x04    /* Bit 2 */
#define VISCATYPEME                 (BYTE)0x02    /* Bit 1 */
#define VISCATYPEPLAYBACKONLY       (BYTE)0x01    /* Bit 0 */

/* defines for MD_RecSpeed and replies to MD_MediaInq and MD_RecSpeedInq message */
#define VISCASPEEDSP                (BYTE)0x01
#define VISCASPEEDBETAI             VISCASPEEDSP
#define VISCASPEEDLP                (BYTE)0x02
#define VISCASPEEDBETAII            VISCASPEEDLP
#define VISCASPEEDEP                (BYTE)0x03
#define VISCASPEEDBETAIII           VISCASPEEDEP

/* defines for MD_InputSelect and reply to MD_InputSelectInq messages */
#define VISCAMUTE                   (BYTE)0x00
#define VISCAOTHERLINE              (BYTE)0x03
#define VISCATUNER                  (BYTE)0x01
#define VISCAOTHER                  (BYTE)0x07    /* BS Tuner */
#define VISCALINE                   (BYTE)0x10    /* | with line # */
#define VISCASVIDEOLINE             (BYTE)0x20    /* | with line # */
#define VISCAAUX                    (BYTE)0x30    /* | with line # */
#define VISCARGB                    VISCAAUX

/* defines for MD_OSD and reply to MD_OSDInq messages */
#define VISCAOSDPAGEOFF             (BYTE)0x00
#define VISCAOSDPAGEDEFAULT         (BYTE)0x01

/* defines for MD_Subcontrol message */
#define VISCACOUNTERRESET           (BYTE)0x01
#define VISCAABSOLUTECOUNTER        (BYTE)0x21
#define VISCARELATIVECOUNTER        (BYTE)0x22
#define VISCASTILLADJUSTMINUS       (BYTE)0x30
#define VISCASTILLADJUSTPLUS        (BYTE)0x31
#define VISCASLOWADJUSTMINUS        (BYTE)0x32
#define VISCASLOWADJUSTPLUS         (BYTE)0x33
#define VISCATOGGLEMAINSUBAUDIO     (BYTE)0x43
#define VISCATOGGLERECORDSPEED      (BYTE)0x44
#define VISCATOGGLEDISPLAYONOFF     (BYTE)0x45
#define VISCACYCLEVIDEOINPUT        (BYTE)0x46

/* defines for MD_ConfigureIF and reply to MD_ConfigureIFInq messages */
#define VISCA25FPS                  (BYTE)0x25
#define VISCA30FPS                  (BYTE)0x30
#define VISCALEVEL1                 (BYTE)0x01
#define VISCACONTROLNONE            (BYTE)0x00
#define VISCACONTROLSYNC            (BYTE)0x01
#define VISCACONTROLLANC            (BYTE)0x02
#define VISCACONTROLF500            VISCALANC

/* defines for MD_PBTrack and MD_RecTrack,
   and replies to MD_PBTrackInq and MD_RecTrackInq messages */
#define VISCATRACKNONE              (BYTE)0x00
#define VISCATRACK1                 (BYTE)0x01    /* Bit 0 */
#define VISCATRACK2                 (BYTE)0x02    /* Bit 1 */
#define VISCATRACK3                 (BYTE)0x04    /* Bit 2 */
#define VISCATRACK1AND2             (BYTE)0x03
#define VISCATRACKTIMECODE          VISCATRACK1
#define VISCATRACK8MMAFM            VISCATRACK1
#define VISCATRACKVHSLINEAR         VISCATRACK1
#define VISCATRACK8MMPCM            VISCATRACK2
#define VISCATRACKVHSHIFI           VISCATRACK2
#define VISCATRACKVHSPCM            VISCATRACK3

/* defines for MD_PBTrackMode and MD_RecTrackMode,
   and replies to MD_PBTrackModeInq, MD_RecTrackModeInq, and MD_MediaTrackModeInq messages */
#define VISCATRACKVIDEO             (BYTE)0x01
#define VISCATRACKDATA              (BYTE)0x02
#define VISCATRACKAUDIO             (BYTE)0x03
#define VISCAVIDEOMODENORMAL        (BYTE)0x00
#define VISCAVIDEOMODEEDIT          (BYTE)0x01    /* for dubbing */
#define VISCAVIDEOMODESTANDARD      (BYTE)0x01
#define VISCAVIDEOMODEHIQUALITY     (BYTE)0x40    /* e.g. S-VHS, ED-Beta, Hi-8 */
#define VISCADATAMODENORMAL         (BYTE)0x00
#define VISCADATAMODETIMECODE       (BYTE)0x10
#define VISCADATAMODEDATEANDTIMECODE    (BYTE)0x11
#define VISCADATAMODECHAPTERANDUSERDATAANDTIMECODE  (BYTE)0x12
#define VISCAAUDIOMODENORMAL        (BYTE)0x00
#define VISCAAUDIOMODEMONO          (BYTE)0x01
#define VISCAAUDIOMODESTEREO        (BYTE)0x10
#define VISCAAUDIOMODERIGHTONLY     (BYTE)0x11
#define VISCAAUDIOMODELEFTONLY      (BYTE)0x12
#define VISCAAUDIOMODEMULTILINGUAL  (BYTE)0x20
#define VISCAAUDIOMODEMAINCHANNELONLY   (BYTE)0x21
#define VISCAAUDIOMODESUBCHANNELONLY    (BYTE)0x22

/* defines for MD_RecTrack and reply to MD_RecTrackInq messages */
#define VISCARECORDMODEASSEMBLE     (BYTE)0x00
#define VISCARECORDMODEINSERT       (BYTE)0x01

/* defines for Vendors and machine types */
#define VISCADEVICEVENDORSONY       (BYTE)0x01
#define VISCADEVICEMODELCI1000      (BYTE)0x01
#define VISCADEVICEMODELCVD1000     (BYTE)0x02
#define VISCADEVICEMODELEVO9650     (BYTE)0x03

#define MUTE                        (BYTE)0x00
#define TUNER                       (BYTE)0x01
#define OTHER                       (BYTE)0x07
#define LINEVIDEO_BASE              (BYTE)0x10
#define SVIDEO_BASE                 (BYTE)0x20
#define AUXVIDEO_BASE               (BYTE)0x30

#define VISCABUFFER                 (BYTE)0x01
#define VISCADNR                    (BYTE)0x02

#define VISCAFRAME                  (BYTE)0x01
#define VISCAFIELD                  (BYTE)0x02

#define VISCAEDITUSEFROM            (BYTE)0x01
#define VISCAEDITUSETO              (BYTE)0x02
#define VISCAEDITUSEFROMANDTO       (BYTE)0x03

#define VISCAPACKETEND              (BYTE)0xff
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\mcivisca\viscamsg.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 * 
 **************************************************************************/

extern	UINT PASCAL FAR viscaHeaderReplaceFormat1WithFormat2(char FAR *lpstrMessage,UINT cbLen,unsigned char bHour,unsigned char bMinute,unsigned char bSecond,UINT uTicks);
extern	UINT PASCAL FAR viscaHeaderReplaceFormat1WithFormat3(char FAR *lpstrMessage,UINT cbLen,char FAR *lpstrPosition);
extern	UINT PASCAL FAR viscaHeaderReplaceFormat1WithFormat4(char FAR *lpstrMessage,UINT cbLen,char FAR *lpstrPosition);
extern	UINT PASCAL FAR viscaDataTopMiddleEnd(char FAR *lpstrData,unsigned char bTopMiddleEnd);
extern	UINT PASCAL FAR viscaDataPosition(char FAR *lpstrData,unsigned char bTimeFormat,unsigned char bHours,unsigned char bMinutes,unsigned char bSeconds,unsigned char bFrames);
extern	UINT PASCAL FAR viscaDataIndex(char FAR *lpstrData,unsigned char bDirection,UINT uNum);
extern	UINT PASCAL FAR viscaMessageIF_Address(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageIF_Cancel(char FAR *lpstrMessage,unsigned char bSocket);
extern	UINT PASCAL FAR viscaMessageIF_Clear(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageIF_DeviceTypeInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageIF_ClockInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageIF_ClockSet(char FAR *lpstrMessage,unsigned char bHours,unsigned char bMinutes,unsigned char bSeconds,UINT uTicks,
                BYTE dbHours, BYTE dbMinutes, BYTE dbSeconds, UINT duTicks);
extern	UINT PASCAL FAR viscaMessageMD_Channel(char FAR *lpstrMessage,UINT uChannel);
extern	UINT PASCAL FAR viscaMessageMD_ChannelInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_EditModes(char FAR *lpstrMessage,unsigned char bSubCode);
extern	UINT PASCAL FAR viscaMessageMD_EditControl(char FAR *lpstrMessage,unsigned char bHours,unsigned char bMinutes,unsigned char bSeconds,UINT uTicks,unsigned char bSubCode);
extern	UINT PASCAL FAR viscaMessageMD_EditControlInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageENT_FrameStill(char FAR *lpstrMessage,unsigned char bSubCode);
extern	UINT PASCAL FAR viscaMessageENT_NFrameRec(char FAR *lpstrMessage, int iSubCode);
extern	UINT PASCAL FAR viscaMessageENT_FrameMemorySelect(char FAR *lpstrMessage,unsigned char bSubCode);
extern	UINT PASCAL FAR viscaMessageENT_FrameMemorySelectInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageSE_VDEReadMode(char FAR *lpstrMessage,unsigned char bSubCode);
extern	UINT PASCAL FAR viscaMessageSE_VDEReadModeInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_Mode1(char FAR *lpstrMessage,unsigned char bModeCode);
extern	UINT PASCAL FAR viscaMessageMD_Mode1Inq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_Mode2(char FAR *lpstrMessage,unsigned char bModeCode);
extern	UINT PASCAL FAR viscaMessageMD_PositionInq(char FAR *lpstrMessage,unsigned char bCounterType);
extern	UINT PASCAL FAR viscaMessageMD_Power(char FAR *lpstrMessage,unsigned char bSubCode);
extern	UINT PASCAL FAR viscaMessageMD_PowerInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_Search(char FAR *lpstrMessage,char FAR *lpstrDataTarget,unsigned char bMode);
extern	UINT PASCAL FAR viscaMessageMD_MediaInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_InputSelect(char FAR *lpstrMessage,unsigned char bVideo,unsigned char bAudio);
extern	UINT PASCAL FAR viscaMessageMD_InputSelectInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_OSD(char FAR *lpstrMessage,unsigned char bPage);
extern	UINT PASCAL FAR viscaMessageMD_OSDInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_Subcontrol(char FAR *lpstrMessage,unsigned char bSubCode);
extern	UINT PASCAL FAR viscaMessageMD_ConfigureIFInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_RecSpeed(char FAR *lpstrMessage,unsigned char bSpeed);
extern	UINT PASCAL FAR viscaMessageMD_RecSpeedInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_RecTrack(char FAR *lpstrMessage,unsigned char bRecordMode,unsigned char bVideoTrack,unsigned char bDataTrack,unsigned char bAudioTrack);
extern	UINT PASCAL FAR viscaMessageMD_RecTrackInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_MediaTrackInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_SegPreRollDurationInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_SegPostRollDurationInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_SegInPoint(char FAR *lpstrMessage, char FAR *lpstrDataTarget);
extern	UINT PASCAL FAR viscaMessageMD_SegInPointInq(char FAR *lpstrMessage);
extern	UINT PASCAL FAR viscaMessageMD_SegOutPoint(char FAR *lpstrMessage, char FAR *lpstrDataTarget);
extern	UINT PASCAL FAR viscaMessageMD_SegOutPointInq(char FAR *lpstrMessage);
extern  UINT PASCAL FAR viscaMessageMD_SegPreRollDuration(char FAR *lpstrMessage, char FAR *lpstrData);
extern  UINT PASCAL FAR viscaMessageMD_SegPostRollDuration(char FAR *lpstrMessage, char FAR *lpstrData);
extern  UINT PASCAL FAR viscaMessageMD_PBTrack(char FAR *lpstrMessage, unsigned char bVideoTrack, unsigned char bDataTrack, unsigned char bAudioTrack);
extern  UINT PASCAL FAR viscaMessageMD_PBTrackInq(char FAR *lpstrMessage);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mcivisca\msmcivcr\msmcivcr.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992-1995 Microsoft Corporation
 * 
 *  MSMCIVCR.C
 *
 *  Description:
 *
 *      Runs the background VCR task in NT.
 *
 *  Notes:
 *
 *      WinMain() - calls initialization function, processes message loop
 *
 **************************************************************************/
#define UNICODE

#include <windows.h>    // required for all Windows applications
#include <windowsx.h>

#ifdef DEBUG
#define DOUTSTR(a)  OutputDebugString(a);
#else
#define DOUTSTR(a)  //
#endif

#if !defined(_WIN32)     // Windows 3.x uses a FARPROC for dialogs
#define DLGPROC FARPROC
#endif
#if !defined (APIENTRY) // Windows NT defines APIENTRY, but 3.x doesn't
#define APIENTRY far pascal
#endif

HINSTANCE hInst;          // current instance

/****************************************************************************

    FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int)

    PURPOSE: calls initialization function, processes message loop

    COMMENTS:

        Windows recognizes this function by name as the initial entry point
        for the program.  This function calls the application initialization
        routine, if no other instance of the program is running, and always
        calls the instance initialization routine.  It then executes a message
        retrieval and dispatch loop that is the top-level control structure
        for the remainder of execution.  The loop is terminated when a WM_QUIT
        message is received, at which time this function exits the application
        instance by returning the value passed by PostQuitMessage().

        If this function must abort before entering the message loop, it
        returns the conventional value NULL.

****************************************************************************/
int APIENTRY WinMain(
    HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{

    MSG msg;
    HINSTANCE hLibrary;
    FARPROC   lpFunc;

    /* Perform initializations that apply to a specific instance */
    DOUTSTR(L"** ** ** ** ** ** We are in the process...\n")

    hLibrary = LoadLibrary(L"mcivis32.dll"); // It's DLL in NT.

    if(!hLibrary)
    {
        DOUTSTR(L"===Error mcivisca.drv not found.\n")
    }

    lpFunc = GetProcAddress(hLibrary, "viscaTaskCommNotifyHandlerProc");

    if(lpFunc != (FARPROC)NULL)
    {
        (*lpFunc)((DWORD)hInstance);
    }
    else
    {
        DOUTSTR(L"Null function in msmcivcr.exe\n")
    }


    DOUTSTR(L"Going into message loop in msmcivcr.exe.\n")

    /* Acquire and dispatch messages until a WM_QUIT message is received. */

    while (GetMessage(&msg, // message structure
       (HWND)NULL,   // handle of window receiving the message
       0,      // lowest message to examine
       0))     // highest message to examine
    {
        TranslateMessage(&msg); // Translates virtual key codes
        DispatchMessage(&msg);  // Dispatches message to window
    }

    DOUTSTR(L"MsMciVcr.Exe Quitting _Goodbye_ *hei*.\n")

    FreeLibrary(hLibrary);

    return (msg.wParam); // Returns the value from PostQuitMessage

    lpCmdLine; // This will prevent 'unused formal parameter' warnings
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciwave\config.c ===
/************************************************************************/

/*
**  Copyright (c) 1985-1998 Microsoft Corporation
**
**  Title: config.c - Multimedia Systems Media Control Interface
**  waveform audio driver for RIFF wave files.
**
**  Version:    1.00
**
**  Date:       18-Apr-1990
**
**  Author:     ROBWI
*/

/************************************************************************/

/*
**  Change log:
**
**  DATE        REV     DESCRIPTION
**  ----------- -----   ------------------------------------------
**  10-Jan-1992 MikeTri Ported to NT
**                  @@@ need to change slash slash comments to slash star
*/

/************************************************************************/
#define UNICODE

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOOPENFILE
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOPROFILER
#define NODEFERWINDOWPOS

#define NOMMDRV
#define MMNOMMIO
#define MMNOJOY
#define MMNOTIMER
#define MMNOAUX
#define MMNOMIDI
#define MMNOWAVE

#include <windows.h>
#include "mciwave.h"
#include <mmddk.h>
#include "config.h"
#include <mcihlpid.h>

/************************************************************************/

#define MAXINIDRIVER    132

PRIVATE SZCODE aszNULL[] = L"";
PRIVATE SZCODE aszSystemIni[] = L"system.ini";
PRIVATE WCHAR  aszWordFormat[] = L"%u";
PRIVATE WCHAR  aszTailWordFormat[] = L" %u";

const static DWORD aHelpIds[] = {  // Context Help IDs
    IDSCROLL,    IDH_MCI_WAVEFORM_DRIVER,
    (DWORD)-1,   IDH_MCI_WAVEFORM_DRIVER,
    IDCOUNT,     IDH_MCI_WAVEFORM_DRIVER,
    0, 0
};

const static TCHAR cszHelpFile[] = TEXT("MMDRV.HLP");

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   SSZ | GetTail |
    This function returns a pointer into the given string at the
    first non-blank character after the current word.  If it fails to find
    a second word, a pointer to the terminating NULL character is returned.

@parm   SSZ | ssz |
    Points to the string whose tail is to be returned.

@rdesc  Returns a pointer into the string passed.
*/

PRIVATE SSZ PASCAL NEAR GetTail(
    SSZ ssz)
{
    while (*ssz && *ssz != ' ')
        ssz++;
    while (*ssz == ' ')
        ssz++ ;
    return ssz;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   UINT | GetCmdParm |
    This function retrieves the current audio buffers parameter using
    the INI strings contained in the configuration block.  The audio
    buffers parameter is a number included in the INI entry for this
    driver as a parameter.

@parm   <t>LPDRVCONFIGINFO<d> | lpdci |
    Points to the driver configuration information passed to the
    dialog creation function.

@rdesc  Returns the current audio buffers.
*/

STATICFN UINT PASCAL NEAR GetCmdParm(
    LPDRVCONFIGINFO lpdci)
{
    WCHAR    aszDriver[MAXINIDRIVER];
    SSZ      pszTail;


    // Assume things will go wrong... initialise variables
    pszTail = aszDriver;

    if (GetPrivateProfileString( lpdci->lpszDCISectionName,
                                 lpdci->lpszDCIAliasName,
                                 aszNULL,
                                 aszDriver,
                                 sizeof(aszDriver) / sizeof(WCHAR),
                                 aszSystemIni))
    {
        // We have got the name of the driver
        // Just in case the user has added the command parameter to the
        // end of the name we had better make sure there is only one token
        // on the line.
        WCHAR parameters[6];
        LPWSTR pszDefault;

        pszTail = GetTail((SSZ)aszDriver);
        pszDefault = pszTail;     // Either the number on the end, or NULL

        if (*pszTail) {
            // RATS!!  Not a simple name
            while (*--pszTail == L' ') {
            }
            *++pszTail = L'\0';  // Terminate the string after the DLL name
        }

        if (GetProfileString(aszDriver, lpdci->lpszDCIAliasName, pszDefault, parameters, sizeof(parameters)/sizeof(WCHAR))) {
            pszTail = parameters;
        }

    } else {
        aszDriver[0] = L'\0';
    }
    return(GetAudioSeconds(pszTail));

}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   UINT | PutCmdParm |
    This function saves the current audio buffers parameter using
    the INI strings contained in the configuration block.

@parm   <t>LPDRVCONFIGINFO<d> | lpdci |
    Points to the driver configuration information passed to the
    dialog creation function.

@parm  UINT | wSeconds |
    Contains the audio buffer seconds parameter to save.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR PutCmdParm(
    LPDRVCONFIGINFO lpdci,
    UINT            wSeconds)
{
    WCHAR    aszDriver[MAXINIDRIVER];
    SSZ sszDriverTail;

    if (GetPrivateProfileString( lpdci->lpszDCISectionName,
                                 lpdci->lpszDCIAliasName,
                                 aszNULL,
                                 aszDriver,
                                 (sizeof(aszDriver) / sizeof(WCHAR)) - 6,
                                 aszSystemIni)) {
        WCHAR parameters[10];

        // There might be a command parameter on the end of the DLL name.
        // Ensure we only have the first token

        sszDriverTail = GetTail((SSZ)aszDriver);
        if (*sszDriverTail) {
            // RATS!!  Not a simple name
            while (*--sszDriverTail == L' ') {
            }
            *++sszDriverTail = L'\0';  // Terminate the string after the DLL name
        }

        wsprintfW(parameters, aszWordFormat, wSeconds);
        WriteProfileString(aszDriver, lpdci->lpszDCIAliasName, parameters);
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   BOOL | ConfigDlgProc |
    This function is the message handle for the driver configuration
    window.

@parm   HWND | hwndDlg |
    Window handle to the dialog.

@parm   UINT | wMsg |
    Current message being sent.

@flag   WM_INITDIALOG |
    During dialog initialization, the pointer to the configuration
    parameter block is saved to a static pointer.  Note that there should
    only be a single instance of this dialog box at any one time.  The
    current audio dialog buffer seconds is set from the INI file entry.

@flag   WM_HSCROLL |
    This responds to the scroll bar by changing the currently displayed
    value of audio seconds and updating the scroll bar thumb.  To look
    nice, the count and scroll bar are only updated if the value actually
    changes.  Note that the error return for GetDlgItemInt is not checked
    because it is initially set to an integer value, so it is always
    valid.

@flag   WM_CLOSE |
    If the close box is used, cancel the dialog, returning DRVCNF_CANCEL.

@flag   WM_COMMAND |
    If the message is being sent on behalf of the OK button, the current
    audio seconds value is saved, and the dialog is terminated, returning
    the DRVCNF_OK value to the driver entry.  Note that the error return for
    GetDlgItemInt is not checked because it is initially set to an integer
    value, so it is always valid.  If the message is being sent on behalf
    of the Cancel button, the dialog is terminated returning the
    DRVCNF_CANCEL value.

@parm   WPARAM | wParam |
    Message parameter.

@parm   LPARAM | lParam |
    Message parameter.

@rdesc  Depends on the message sent.
*/

PUBLIC  INT_PTR PASCAL ConfigDlgProc(
    HWND    hwndDlg,
    UINT    wMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    UINT    wSeconds;
    UINT    wNewSeconds;
    BOOL    fTranslated;
    HWND    hwndItem;
    static LPDRVCONFIGINFO  lpdci;

    switch (wMsg) {
    case WM_INITDIALOG:
        lpdci = (LPDRVCONFIGINFO)lParam;
        wSeconds = GetCmdParm(lpdci);
        hwndItem = GetDlgItem(hwndDlg, IDSCROLL);
        SetScrollRange(hwndItem, SB_CTL, MinAudioSeconds, MaxAudioSeconds, FALSE);
        SetScrollPos(hwndItem, SB_CTL, wSeconds, FALSE);
        SetDlgItemInt(hwndDlg, IDCOUNT, wSeconds, FALSE);
        break;

    case WM_HSCROLL:
        wSeconds = GetDlgItemInt(hwndDlg, IDCOUNT, &fTranslated, FALSE);
        hwndItem = (HWND)lParam;

        switch (LOWORD(wParam)) {
        case SB_PAGEDOWN:
        case SB_LINEDOWN:
            wNewSeconds = min(MaxAudioSeconds, wSeconds + 1);
            break;

        case SB_PAGEUP:
        case SB_LINEUP:
            wNewSeconds = max(MinAudioSeconds, wSeconds - 1);
            break;

        case SB_TOP:
            wNewSeconds = MinAudioSeconds;
            break;

        case SB_BOTTOM:
            wNewSeconds = MaxAudioSeconds;
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            wNewSeconds = HIWORD(wParam);
            break;

        default:
            return FALSE;
        }

        if (wNewSeconds != wSeconds) {
            SetScrollPos(hwndItem, SB_CTL, wNewSeconds, TRUE);
            SetDlgItemInt(hwndDlg, IDCOUNT, wNewSeconds, FALSE);
        }
        break;

    case WM_CLOSE:
        EndDialog(hwndDlg, DRVCNF_CANCEL);
        break;

    case WM_CONTEXTMENU:
        WinHelp ((HWND)wParam, cszHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)aHelpIds);
        return TRUE;

    case WM_HELP:
    {
        LPHELPINFO lphi = (LPVOID) lParam;
        WinHelp (lphi->hItemHandle, cszHelpFile, HELP_WM_HELP, (ULONG_PTR)aHelpIds);
        return TRUE;
    }

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            PutCmdParm(lpdci, GetDlgItemInt(hwndDlg, IDCOUNT, &fTranslated, FALSE));
            EndDialog(hwndDlg, DRVCNF_OK);
            break;

        case IDCANCEL:
            EndDialog(hwndDlg, DRVCNF_CANCEL);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   int | Config |
    This function creates the configuration dialog, and returns the
    value from dialog box call.

@parm   HWND | hwnd |
    Contains the handle of what is to be the parent of the dialog.

@parm   <t>LPDRVCONFIGINFO<d> | lpdci |
    Points to the driver configuration information passed to the
    configuration message.

@parm   HINSTANCE | hInstance |
    Contains a handle to the module in which the dialog is stored.

@rdesc  Returns the dialog box call function return.
*/

PUBLIC INT_PTR PASCAL FAR Config(
    HWND            hwnd,
    LPDRVCONFIGINFO lpdci,
    HINSTANCE       hInstance)
{
    return DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_CONFIG), hwnd, ConfigDlgProc, (LPARAM)lpdci);
}

/************************************************************************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciwave\debug.c ===
/* Copyright (c) 1991-1994 Microsoft Corporation */
/*
    debug.c

    Support code for the dprintf routines.

    Note that all of this is conditional on the DBG flag

*/

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOMINMAX
#define NOOPENFILE
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS

#define NOMMDRV
#define MMNOMMIO
#define MMNOJOY
#define MMNOTIMER
#define MMNOAUX
#define MMNOMIDI
#define MMNOWAVE

#include <windows.h>
#include "mciwave.h"            // private include file
#include <stdarg.h>

#if DBG
    #ifdef MEDIA_DEBUG
        int mciwaveDebugLevel = 1;
    #else
        int mciwaveDebugLevel = 1;
    #endif

/***************************************************************************

    @doc INTERNAL

    @api void | mciwaveDbgOut | This function sends output to the current
        debug output device.

    @parm LPSTR | lpszFormat | Pointer to a printf style format string.
    @parm ??? | ... | Args.

    @rdesc There is no return value.

****************************************************************************/

void mciwaveDbgOut(LPSTR lpszFormat, ...)
{
    char buf[256];
    UINT n;
    va_list va;
    UINT offset;

    // If the last character is a comma, do not add the newline
    // If the first character is a period, do not add thread/module info

    n = wsprintf(buf, "MCIWAVE: (tid %x) ", GetCurrentThreadId());
    offset = n;

    va_start(va, lpszFormat);
    n += vsprintf(buf+n, lpszFormat, va);
    if (*(buf+offset) == '.') {
	offset++;
    } else {
	offset = 0;
    }
    va_end(va);

    if (',' != buf[n-1]) {
	buf[n++] = '\n';
    }
    buf[n] = 0;
    OutputDebugString(buf+offset);
    Sleep(10);  // let terminal catch up
}

void mciwaveInitDebugLevel(void)
{
    UINT level = GetProfileInt("MMDEBUG", "MCIWAVE", 99);
    if (level != 99) {
        mciwaveDebugLevel = level;
    }
}


/***************************************************************************

    @doc INTERNAL

    @api void | dDbgAssert | This function prints an assertion message.

    @parm LPSTR | exp | Pointer to the expression string.
    @parm LPSTR | file | Pointer to the file name.
    @parm int | line | The line number.

    @rdesc There is no return value.

****************************************************************************/

void dDbgAssert(LPSTR exp, LPSTR file, int line)
{
    dprintf1(("Assertion failure:"));
    dprintf1(("  Exp: %s", exp));
    dprintf1(("  File: %s, line: %d", file, line));
    DebugBreak();
}

#endif // DBG

/**************************************************************************

    @doc INTERNAL

    @api void | mciwaveSetDebugLevel | Set the current debug level

    @parm int | iLevel | The new level to set

    @rdesc There is no return value

**************************************************************************/

void mciwaveSetDebugLevel(int level)
{
#if DBG
    mciwaveDebugLevel = level;
    dprintf(("debug level set to %d", mciwaveDebugLevel));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciwave\gmem.h ===
// Copyright (c) 1994 Microsoft Corporation
/*
    gmem.h

    This module supplies macros for fixed global memory
    allocation compatible with those used in the Multimedia
    extensions to Windows 3.x.  It is included to simplify
    porting of the Windows 3.x 16 bit code.

    Jul-16-91   NigelT

*/

#ifndef _GMEMMACROS_
#define _GMEMMACROS_

__inline LPBYTE GlobalAllocPtr(DWORD flags, DWORD cb)
{
    HANDLE h;
    LPBYTE lp = NULL;
    h = GlobalAlloc(flags, cb);
    if (h) {
	lp = GlobalLock(h);
    }
    return(lp);
}


#define     GlobalFreePtr(lp)			\
	    {				        \
		HANDLE h;			\
		h = GlobalHandle(lp);		\
		if (GlobalUnlock(h)) {          \
		    /* memory still locked!! */ \
		}				\
		h = GlobalFree(h);		\
	    }
#endif // _GMEMMACROS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciwave\drvproc.c ===
/************************************************************************/

/*
**  Copyright (c) 1985-1999 Microsoft Corporation
**
**  Title: drvproc.c - Multimedia Systems Media Control Interface
**  waveform audio driver for RIFF wave files.
**
**  Version:    1.00
**
**  Date:       18-Apr-1990
**
**  Author:     ROBWI
*/

/************************************************************************/

/*
**  Change log:
**
**  DATE        REV     DESCRIPTION
**  ----------- -----   ------------------------------------------
**  10-Jan-1992 MikeTri Ported to NT
**                  @@@ need to change slash slash comments to slash star
*/

/************************************************************************/
// #define DEBUGLEVELVAR mciwaveDebugLevel
#define UNICODE

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOMINMAX
#define NOOPENFILE
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS


#define MMNOMMIO
#define MMNOJOY
#define MMNOTIMER
#define MMNOAUX
#define MMNOMIDI

#include <windows.h>
#include "mciwave.h"
#include <mmddk.h>

/************************************************************************/

/*
**  This constant is used for a return value when opening the MCI
**  driver for configuration.  Setting the high-order word of the
**  dwDriverID identifies configuration opens.
*/

#define CONFIG_ID   10000L

#define MAXINISTRING    32

/************************************************************************/

/*
**  wTableEntry Contains the wave command table identifier.
*/

#ifndef MCI_NO_COMMAND_TABLE
#define MCI_NO_COMMAND_TABLE    -1
#endif

PRIVATE UINT wTableEntry = MCI_NO_COMMAND_TABLE;

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   UINT | GetAudioSeconds |
    This converts the given string to a UINT which represents the
    number of seconds of audio buffers that should be available.  The
    number is bounded by the minimum and maximum number of seconds as
    defined by MinAudioSeconds and MaxAudioSeconds.

@parm   LPCSTR | lszNumber |
    Points to the string containing the string representation of the
    number to convert.

@rdesc  Returns the int representation of the number passed.  If the number
    is out of range, the default number of audio seconds is returned.
*/

PUBLIC  UINT PASCAL FAR GetAudioSeconds(
    LPCWSTR  lszNumber)
{
    UINT    wSeconds;

    for (wSeconds = 0;
         (wSeconds < MaxAudioSeconds) && (*lszNumber >= TEXT('0')) && (*lszNumber <= TEXT('9'));
         lszNumber++)
        wSeconds = wSeconds * 10 + (*lszNumber - '0');

    if ((wSeconds > MaxAudioSeconds) || (wSeconds < MinAudioSeconds))
        wSeconds = AudioSecondsDefault;

    return wSeconds;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    BOOL | mwLoadDriver |
    This function is called in response to a <m>DRV_LOAD<d> message, and
    performs driver initialization.  It determines the total number of
    input and output devices for use in trying to open any device.
    The function then tries to register the extended wave command table.

@rdesc  Returns TRUE on success, else FALSE.
*/

PRIVATE BOOL PASCAL NEAR mwLoadDriver(
    VOID)
{
    WCHAR    aszResource[MAXINISTRING];

    dprintf3(("mwLoadDriver called"));

    cWaveOutMax = waveOutGetNumDevs();
    cWaveInMax = waveInGetNumDevs();

#if DBG
    if (cWaveOutMax + cWaveInMax) {
        dprintf4(("Number of Wave Out devices = %d,  Wave In devices = %d", cWaveOutMax, cWaveInMax));
    } else {
        dprintf1(("NO wave input or output devices detected"));
    }
#endif

    if (LoadString( hModuleInstance,
                    IDS_COMMANDS,
                    aszResource,
                    sizeof(aszResource) / sizeof(WCHAR) ))
    {
        wTableEntry = mciLoadCommandResource(hModuleInstance, aszResource, 0);

        if (wTableEntry != MCI_NO_COMMAND_TABLE) {
            dprintf4(("Loaded MCIWAVE command table, table number %d", wTableEntry));
            return TRUE;
        }
#if DBG
        else
            dprintf1(("mwLoadDriver: mciLoadCommandResource failed"));
    }
    else
    {
        dprintf1(("mwLoadDriver: LoadString of command table identifier failed"));

#endif
    }

    dprintf1(("mwLoadDriver returning FALSE"));
    return FALSE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    BOOL | mwFreeDriver |
    Perform driver cleanup in response to DRV_FREE message.  This is only
    called at driver unload time if a previous DRV_LOAD message succeeded.

@rdesc  Returns TRUE always.
*/

PRIVATE BOOL PASCAL NEAR mwFreeDriver(
    VOID)
{
    if (wTableEntry != MCI_NO_COMMAND_TABLE) {
        mciFreeCommandResource(wTableEntry);
        wTableEntry = MCI_NO_COMMAND_TABLE;
    }
    return TRUE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    LRESULT | DriverProc |
    The entry point for an installable driver.

@parm   DWORD | dDriverId |
    For most messages, <p>dDriverId<d> is the DWORD value that the driver
    returns in response to a <m>DRV_OPEN<d> message.  Each time that the
    driver is opened, through the DrvOpen API, the driver receives a
    <m>DRV_OPEN<d> message and can return an arbitrary, non-zero, value.

    The installable driver interface saves this value and returns a unique
    driver handle to the application. Whenever the application sends a
    message to the driver using the driver handle, the interface routes the
    message to this entry point and passes the corresponding
    <p>dDriverId<d>.

    This mechanism allows the driver to use the same or different
    identifiers for multiple opens but ensures that driver handles are
    unique at the application interface layer.

    The following messages are not related to a particular open instance
    of the driver. For these messages, the <p>dDriverId<d> will always
    be ZERO: <m>DRV_LOAD<d>, <m>DRV_FREE<d>, <m>DRV_ENABLE<d>,
    <m>DRV_DISABLE<d>, <m>DRV_OPEN<d>.

@parm   HANDLE | hDriver |
    This is the handle returned to the application by the driver interface.

@parm   UINT | wMessage |
    The requested action to be performed. Message values below
    <m>DRV_RESERVED<d> are used for globally defined messages.  Message
    values from <m>DRV_RESERVED<d> to <m>DRV_USER<d> are used for defined
    driver portocols. Messages above <m>DRV_USER<d> are used for driver
    specific messages.

@flag   DRV_LOAD |
    Load the driver.

@flag   DRV_FREE |
    Free the driver.

@flag   DRV_OPEN |
    Open the driver.  If <p>dParam2<d> is NULL, the driver is being
    opened for configuration, else the parameter points to an open
    parameters block.  The command line in the open parameters optionally
    contains a replacement for the default audio seconds parameter.  If so,
    the current default is replaced with this new number.

    The rest of the open parameters block is filled in with the driver's
    extended command table and device type.  The device ID is then
    returned.

@flag   DRV_CLOSE |
    Close the driver.  Returns TRUE.

@flag   DRV_QUERYCONFIGURE |
    Query as to whether the driver can be configured.  Returns TRUE.

@flag   DRV_CONFIGURE |
    After verifying <p>dParam1<d> and <p>dParam2<d>, configure the
    driver.  Opens the driver configuration dialog.

@flag   DRV_ENABLE |
    Enable the driver.  Use DefDriverProc.

@flag   DRV_DISABLE |
    Disable the driver.  Use DefDriverProc.

@parm   LPARAM | lParam1 |
    Data for this message.  Defined separately for each message.

@parm   LPARAM | lParam2 |
    Data for this message.  Defined separately for each message.

@rdesc  Defined separately for each message.
*/

#if 0
PUBLIC  LRESULT PASCAL DefDriverProc(
    DWORD   dDriverID,
    HANDLE  hDriver,
    UINT    wMessage,
    LONG    lParam1,
    LONG    lParam2);
#endif

PUBLIC  LRESULT PASCAL DriverProc(
    DWORD   dDriverID,
    HANDLE  hDriver,
    UINT    wMessage,
    DWORD_PTR    lParam1,
    DWORD_PTR    lParam2)
{
    LPMCI_OPEN_DRIVER_PARMS lpOpen;

    switch (wMessage) {
    case DRV_LOAD:
        return (LRESULT)(LONG)mwLoadDriver();

    case DRV_FREE:
        return (LRESULT)(LONG)mwFreeDriver();

    case DRV_OPEN:
        if (!(LONG)lParam2)
            return (LRESULT)CONFIG_ID;
        lpOpen = (LPMCI_OPEN_DRIVER_PARMS)lParam2;
        if (lpOpen->lpstrParams != NULL)
            wAudioSeconds = GetAudioSeconds(lpOpen->lpstrParams);
        else
            wAudioSeconds = AudioSecondsDefault;
        lpOpen->wCustomCommandTable = wTableEntry;
        lpOpen->wType = MCI_DEVTYPE_WAVEFORM_AUDIO;
        return (LRESULT)(LONG)lpOpen->wDeviceID;

    case DRV_CLOSE:
    case DRV_QUERYCONFIGURE:
        return (LRESULT)1;

    case DRV_INSTALL:
    case DRV_REMOVE:
        return (LRESULT)DRVCNF_OK;

    case DRV_CONFIGURE:
        if ((LONG)lParam2 && (LONG)lParam1 && (((LPDRVCONFIGINFO)lParam2)->dwDCISize == sizeof(DRVCONFIGINFO)))
            return (LRESULT)(LONG)Config((HWND)lParam1, (LPDRVCONFIGINFO)lParam2, hModuleInstance);
        return (LRESULT)DRVCNF_CANCEL;

    default:
        if (!HIWORD(dDriverID) && wMessage >= DRV_MCI_FIRST && wMessage <= DRV_MCI_LAST)
            return mciDriverEntry((WORD)dDriverID, wMessage, (DWORD)lParam1, (LPMCI_GENERIC_PARMS)lParam2);
        else
            return DefDriverProc(dDriverID, hDriver, wMessage, lParam1, lParam2);
    }
}

/**************************************************************************

    @doc EXTERNAL

    @api BOOL | DllInstanceInit | This procedure is called whenever a
        process attaches or detaches from the DLL.

    @parm PVOID | hModule | Handle of the DLL.

    @parm ULONG | Reason | What the reason for the call is.

    @parm PCONTEXT | pContext | Some random other information.

    @rdesc The return value is TRUE if the initialisation completed ok,
        FALSE if not.

**************************************************************************/

BOOL DllInstanceInit(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
    UNREFERENCED_PARAMETER(pContext);

    if (Reason == DLL_PROCESS_ATTACH) {

#if DBG
        WCHAR strname[50];
#endif

        DisableThreadLibraryCalls(hModule);
        mciwaveInitDebugLevel ();

        InitCrit();
        hModuleInstance = hModule;

#if DBG
        GetModuleFileName(NULL, strname, sizeof(strname) / sizeof(WCHAR) );
        dprintf2(("Process attaching, exe=%ls (Pid %x  Tid %x)", strname, GetCurrentProcessId(), GetCurrentThreadId()));
        dprintf2(("  starting debug level=%d", mciwaveDebugLevel));
#endif

    } else if (Reason == DLL_PROCESS_DETACH) {
        dprintf2(("Process ending (Pid %x  Tid %x)", GetCurrentProcessId(), GetCurrentThreadId()));
        DeleteCrit();  // Something nasty happens if we don't do this
    } else {
        dprintf2(("DllInstanceInit - reason %d", Reason));
    }
    return TRUE;
}

/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciwave\mciwave.h ===
/*
**  Copyright (c) 1985-1998 Microsoft Corporation
**
**  Title: mciwave.h - Multimedia Systems Media Control Interface
**  streaming digital audio driver internal header file.
*/


/*
**  Change log:
**
**  DATE        REV     DESCRIPTION
**  ----------- -----   ------------------------------------------
**  18-APR-1990 ROBWI   Original
**  10-Jan-1992 MikeTri Ported to NT
**     Aug 1994 Lauriegr Tried to add some explanation
*/


/********************* The OVERALL SCHEME OF THINGS ************************\

There are normally one or two files on the go.  One is the original wave file,
the other is a temporary file.  The data in these files is described by a
WAVEDESC which contains a pointer to an array of WAVEDATANODEs.
Each WAVEDATANODE identifies some part of one of the files.
The high order bit of the length field identifies which file (totally naff,
if you ask me, but I didn't invent it).  Concatenate all the sections that
the WAVEDATANODEs identify and that's the wave data.

The WAVEDATANODEs actually form a linked list (linked by array indices not
pointers) and it is the concatenation of that list which defines the file.
There may also be some WAVEDATANODEs that define free space.

I'm confused about what exactly the dDataStart in the NODEs means.  Is it the
position in the logical file or in one or other of the physical files?  Either
way it probably gets messed up if you try deleting anything (KNOWN BUG).

LaurieGr

\***************************************************************************/



#ifndef MCIWAVE_H
 #define MCIWAVE_H

#include <stdio.h>
#include <mmsystem.h>

#define WAIT_FOREVER ((DWORD)(-1))

#if DBG
    #define PUBLIC  extern      /* Public label.    SO DEBUGGER CAN   */
    #define PRIVATE extern      /* Private label.   SEE THE SYMBOLS   */
#else
    #define PUBLIC  extern      /* Public label.        */
    #define PRIVATE extern      /* Private label.       */
#endif
#define REALLYPRIVATE static

#define EXPORT              /* Export function.     */


#ifndef RC_INVOKED  /* These are defined to RC */
#define STATICDT
#define STATICFN
#define STATIC
#endif  /* RC_INVOKED */

/*
**  This constant defines the maximum length of strings containing
**  file paths.  This number is the same as the string in OFSTRUCT.
*/

#define _MAX_PATH   MAX_PATH

/*
**  These two constants define extended commands that are use within the
**  wave handler.  The first can be sent to the MCI entry point, and the
**  second is used entirely internally.
*/

#define MCI_MCIWAVE_PLAY_HOLD   0x01000000L
#define MCI_MCIWAVE_CUE         0x02000000L

/*
**  The first two constants represent the maximum and minimum number of
**  seconds of buffering that can be specified either on the SYSTEM.INI
**  device driver entry, or in the MCI_OPEN command.
**  The third constant defines the default number of seconds to use when
**  calculating the number of seconds of buffering to allocate.
*/

#define MaxAudioSeconds     9
#define MinAudioSeconds     2
#define AudioSecondsDefault 4

/*
**  This constant is used for recording when no record stopping point
**  is specified.
*/

#define INFINITEFILESIZE    0X7FFFFFFFL

/*
**  These constants represent the various RIFF components of the file.
*/

#define mmioWAVE    mmioFOURCC('W','A','V','E')
#define mmioFMT     mmioFOURCC('f','m','t',' ')
#define mmioDATA    mmioFOURCC('d','a','t','a')

/*
**  The following represent identifiers for string resources.
*/

#define IDS_PRODUCTNAME     0
#define IDS_MAPPER          1
#define IDS_COMMANDS        2

/*
**  The following constant is used to specify the sample size when
**  determing the input level during a Cued record.  This number must
**  be divisible by 4.
*/

#define NUM_LEVEL_SAMPLES   64L

/*
**  The following constants represent specific task modes and task
**  commands.
*/

#define MODE_PLAYING        0x0001
#define MODE_INSERT         0x0002
#define MODE_OVERWRITE      0x0004
#define MODE_PAUSED         0x0008
#define MODE_CUED           0x0010
#define MODE_HOLDING        0x0020
#define MODE_CLEANUP        0x0040
#define MODE_WAIT           0x0080
#define COMMAND_NEW         0x0100
#define COMMAND_PLAY        0x0200
#define COMMAND_INSERT      0x0400
#define COMMAND_OVERWRITE   0x0800
#define COMMAND_STOP        0x1000
#define COMMAND_CUE         0x2000
#define COMMAND_HOLD        0x4000

/*
**  The following macros allow modes and commands to be added, removed,
**  queried, set, and get.
*/

#define ADDMODE(pwd, m)     ((pwd)->wMode |= (m))
#define REMOVEMODE(pwd, m)  ((pwd)->wMode &= ~(m))
#define ISMODE(pwd, m)      ((pwd)->wMode & (m))
#define SETMODE(pwd, m)     ((pwd)->wMode = (m))
#define GETMODE(pwd)        ((pwd)->wMode)

/*
**  The following macros allow testing and setting of the current task
**  state.
*/

#define ISTASKSTATE(pwd, s)   ((pwd)->wTaskState == (s))
#define SETTASKSTATE(pwd, s)  ((pwd)->wTaskState = (s))
#define TASKSTATE(pwd)        ((pwd)->wTaskState)

/*
**  Define message for state changes for device tasks
*/

#define WTM_STATECHANGE (WM_USER + 1)

/*
@doc    INTERNAL MCIWAVE

@types  DIRECTION |
    The Direction enumeration is used internally in the MCI wave handler
    to indicate the current direction of data flow.  This is either input
    (record), or output (play).

@flag   input |
    Indicates the direction is record.

@flag   output |
    Indicates the direction is playback.

@tagname    tagDirection
*/

typedef enum tagDirection {
    input,
    output
}   DIRECTION;

/*
**  The following constants represent specific task states.
*/

#define TASKNONE    0
#define TASKINIT    1
#define TASKIDLE    2
#define TASKBUSY    3
#define TASKCLOSE   4
#define TASKSAVE    5
#define TASKDELETE  6
#define TASKCUT     7

/*
**  The following constants and macros are used in dealing with data nodes,
**  which are pointers to blocks of data.  The first constant is used
**  within these macros as a mask for block pointers which refer to data
**  located in the temporary file, and not in the original read-only file.
*/

#define TEMPDATAMASK            (0x80000000)
#define ENDOFNODES              (-1)
#define ISTEMPDATA(lpwdn)       (((lpwdn)->dDataStart & TEMPDATAMASK) != 0)
#define MASKDATASTART(d)        ((d) | TEMPDATAMASK)
#define UNMASKDATASTART(lpwdn)  ((lpwdn)->dDataStart & ~TEMPDATAMASK)
#define LPWDN(pwd, d)           ((pwd)->lpWaveDataNode + (d))
#define RELEASEBLOCKNODE(lpwdn) ((lpwdn)->dDataLength = (DWORD)-1)
#define ISFREEBLOCKNODE(lpwdn)  ((lpwdn)->dDataLength == (DWORD)-1)

/*
**  The following constant is used to determine the allocation increments
**  for data pointers
*/

#define DATANODEALLOCSIZE   32

/*
**  The following macro is used to round a data offset to the next nearest
**  buffer size increment.
*/

#define ROUNDDATA(pwd, d)   ((((DWORD)(d) + (pwd)->dAudioBufferLen - 1) / (pwd)->dAudioBufferLen) * (pwd)->dAudioBufferLen)
#define BLOCKALIGN(pwd, d)  ((((DWORD)(d) + (pwd)->pwavefmt->nBlockAlign - 1) / (pwd)->pwavefmt->nBlockAlign) * (pwd)->pwavefmt->nBlockAlign)

/************************************************************************/

/*
@doc    INTERNAL MCIWAVE

@types  WAVEDATANODE |
    The Wave Data Node structure is used internally in the MCI wave
    handler to store information about a block of wave data, located either
    in the original file, or in the temporary data file.  These structures
    are used to form a linked list of wave data nodes that describe the
    data in the entire file as it currently exists.

    The headers themselves are allocated as an expandable array of global
    memory, using <e>WAVEDATANODE.dDataLength<d> as an in-use flag when
    searching the list for free entries to use.  Note that a free entry
    can also have free temporary data attached to it, as in the case of
    performing a delete in which all the data for a specific node is
    removed.

@field  DWORD | dDataStart |
    Indicates the absolute position at which the data for this node begins.
    This element is also used in determining if the data pointed to by this
    node is original data, or newly created temporary data.  This is done
    by masking the length with <f>TEMPDATAMASK<d>.  The length can be
    accessed by using <f>UNMASKDATASTART<d>.

@field  DWORD | dDataLength |
    Indicates the length of active data pointed to by the node.  This
    could be zero if say, a write failed.  This contains -1 if the node
    is not part of the linked list of active nodes.

@field  DWORD | dTotalLength |
    Indicates the actual total length of data available to this node.  For
    original data, this will always be the same as the
    <e>WAVEDATANODE.dDataLength<d> element, but for temporary data, this
    may be longer, as it is a block aligned number, the block lengths being
    based on the size of wave data buffers.  If the node is not in use, it
    still may have data associated with it.  If there is no data associated
    with a free node, the total length is set to zero.

@field  DWORD | dNextWaveDataNode |
    This element is used for active nodes, and contains an index into the
    array of nodes indicating the location of the next active node, or
    <f>ENDOFNODES<d> to indicate the end of the list of active nodes.

@othertype  WAVEDATANODE NEAR * | LPWAVEDATANODE |
    A far pointer to the structure.

@tagname    tagWaveDataNode
*/

typedef struct tagWaveDataNode {
    DWORD   dDataStart;
    DWORD   dDataLength;
    DWORD   dTotalLength;
    DWORD   dNextWaveDataNode;
}   WAVEDATANODE,
    FAR * LPWAVEDATANODE;

/*
@doc    INTERNAL MCIWAVE

@types  WAVEDESC |
    The Wave Description structure is used internally in the MCI wave
    handler to store details for each device, along with any state information.

@field  MCIDEVICEID | wDeviceID |
    MCI device identifier passed to the driver during driver open.

@field  UINT | wMode |
    Contains the current mode of the background task, if there is a task.

@flag   MODE_PLAYING |
    This mode is set when the task is actually doing playback.  It is reset
    before Cleanup mode is entered.

@flag   MODE_INSERT |
    This mode is set when the task is actually doing insert recording.  It
    is reset before Cleanup mode is entered.

@flag   MODE_OVERWRITE |
    This mode is set when the task is actually doing overwrite recording.
    It is reset before Cleanup mode is entered.

@flag   MODE_PAUSED |
    This mode is set if playback or recording has been paused by an
    MCI_PAUSE command.

@flag   MODE_CUED |
    This mode is entered when playback or recording has actually been cued.

@flag   MODE_HOLDING |
    This mode is entered when playback is about to block itself and hold
    after doing playback.

@flag   MODE_CLEANUP |
    This mode is entered after playback or recording has finished, but
    before the task has entered idle state, and new commands are being
    ignored.

@flag   MODE_WAIT |
    This mode flag is used by both the calling task and the background
    task.  If the calling task received a Record or Play command with the
    Wait flag, then this mode is set, so that if an error occurs during
    playback or recording, the background task does not perform
    notification, but just clears the notification callback handle.  Just
    before it performs notification, the background task clears this
    flag so that the calling task will know that it should not return an
    error condition.  If the calling task is broken out of the wait loop,
    it checks this flag to determine if it should report an error
    condition.

@flag   COMMAND_NEW |
    This command specifies that a new command has been set.

@flag   COMMAND_PLAY |
    This command indicates that playback should be performed on the preset
    parameters.

@flag   COMMAND_INSERT |
    This command indicates that insert recording should be performed on
    the preset parameters.

@flag   COMMAND_OVERWRITE |
    This command indicates that overwrite recording should be performed on
    the preset parameters.

@flag   COMMAND_STOP |
    This command indicates that playback or recording should stop.

@flag   COMMAND_CUE |
    This command indicates that playback should initially pause itself
    before writing then enter Cue mode when all buffers have been written.
    For recording, it should enter a level checking loop and wait for
    further commands.

@flag   COMMAND_HOLD |
    This command specifies that playback should enter a hold state after
    completing playback.

@field  DWORD | dTimeFormat |
    Indicates the current format of position values used in messages.

@flag   MCI_FORMAT_MILLISECONDS |
    Milliseconds.

@flag   MCI_FORMAT_SAMPLES |
    Samples.

@flag   MCI_FORMAT_BYTES |
    Bytes.

@field  UINT | wSeconds |
    Contains the desired amount of buffering in terms of seconds.  This
    is then converted to actual buffers, and limited by the predefined
    min and max values.

@field  HWND | hwndCallback |
    If a message has specified notification, this contains the window
    handle to where notification is to be sent.  The handle is stored
    here for delayed notification, and can be checked when the function
    has finished or was interrupted.

@field  HTASK | hTask |
    If the MCI wave device instance was opened with an element attached,
    this element contains the handle to the background task used for
    playback and recording.

@field  <t>DIRECTION<d> | Direction |
    Indicates the current direction of data flow.

@flag   input |
    Indicates the direction is inwards, i.e. recording.

@flag   output |
    Indicates the direction is outwards, i.e. playback.

@field  UINT | wTaskState |
    MCIWAVE has a separate background task for every open instance of
    mciwave. The task handle and task state are stored  in the
    per-instance data structure.  The task can be in one of four states.

@flag   TASKNONE |
    This state is only set if the requested file cannot be opened during
    task initialization.  It is used so that the task create loop is able
    to abort on an initialization failure.

@flag   TASKINIT |
    This is the initial task state set when the instance data structure is
    initialized in <f>mwOpenDevice<d> before the actual task is created by
    <f>mmTaskCreate<d>.  After the task is created, <f>mwOpenDevice<d>
    waits until the task state changes to TASKIDLE before returning success
    so that the background task is definitely initialized after an open
    call.

@flag   TASKIDLE |
    The task sets the state to TASKIDLE and blocks whenever there is
    nothing to do.  When the task wakes, the state is either TASKCLOSE if
    the instance is being closed or else TASKBUSY if the task is to begin
    recording or playback of the file.

@flag   TASKCLOSE |
    <f>mwCloseDevice<d> stops playback or recording which forces the task
    state to TASKIDLE and then sets the state to TASKCLOSE and wakes the
    task so that the task will destroy itself.

@flag   TASKBUSY |
    The task is in this state during playback and recording.

@flag   TASKCLOSE |
    The task is closing and about to terminate.

@flag   TASKSAVE |
    The task saving the current data to the specified file.

@flag   TASKDELETE |
    The task deleting the specified data.

@flag   TASKCUT |
    The task cutting the specified data (Not implemented).

@field  UINT | idOut |
    Wave device id of output device to use, or WAVE_MAPPER for any.

@field  UINT | idIn |
    Wave device id of input device to use, or WAVE_MAPPER for any.

@field  HWAVEOUT | hWaveOut |
    Output wave device handle when in use.

@field  HWAVEIN | hWaveIn |
    Input wave device handle when in use.

@field  <t>LPWAVEHDR<d> | rglpWaveHdr |
    Pointer to array of audio buffers for wave buffering.

@field  DWORD | dCur |
    Current position in file in bytes.

@field  DWORD | dFrom |
    Position in bytes at which playback or recording should begin.

@field  DWORD | dTo |
    Position in bytes at which playback or recording should terminate,
    or <f>INFINITEFILESIZE<d> if recording should continue until stopped.

@field  DWORD | dSize |
    Actual wave data size in bytes.

@field  char | aszFile |
    Contains the name of the element attached to the MCI wave device
    instance, if any.  This might be a zero length string if the file is
    new and has not been named yet.

@field  char | aszTempFile |
    Contains the name of the temporary data file, if any.

@field  <t>HMMIO<d> | hmmio |
    MMIO identifier of the element attached to the MCI wave device
    instance, if any.

@field  HFILE | hfTempBuffers |
    Contains the temporary data DOS file handle, if any, else HFILE_ERROR.

@field  <t>LPMMIOPROC<d> | pIOProc |
    Contains a pointer to the alternate MMIO IO procedure, if any, else
    NULL.

@field  <t>LPWAVEDATANODE<d> | lpWaveDataNode |
    Points to the array of wave data nodes.  This is allocated when the
    file opens, so it is always valid.  The array is expanded as needed.

@field  DWORD | dRiffData |
    This contains an offset into the original file, if any, indicating
    the actual starting point of the wave data, which in a RIFF file will
    not be zero.

@field  DWORD | dWaveDataStartNode |
    This contains an index to the first active data pointer in the linked
    list of data pointer nodes.

@field  DWORD | dWaveDataCurrentNode |
    This contains an index to the current active data pointer in the
    linked list of data pointer nodes.

@field  DWORD | dVirtualWaveDataStart |
    This contains a virtual starting point representing logically where in
    the file the data for the current node begins.

@field  DWORD | dWaveDataNodes |
    This indicates the total number of data pointer nodes available.

@field  DWORD | dWaveTempDataLength |
    This contains the current length of the temporary data file, if any.

@field  DWORD | dLevel |
    Current input level if it is being scanned.

@field  UINT | wTaskError |
    Task error return.

@field  UINT | wAudioBuffers |
    Number of audio buffers actually allocated during playback or recording.

@field  DWORD | wAudioBufferLen |
    Length of each audio buffer.

@field  PSTR | szSaveFile |
    During a save command, this optionally contains the name of the file
    to save to, unless data is being saved to the original file.

@field  UINT | wFormatSize |
    This contains the size of the wave header, which is used when saving
    data to a new file.

@field  <t>WAVEFORMAT<d> | pwavefmt |
    Pointer to the wave format header.

@field  HANDLE | hTaskHandle |
    Handle to the thread that started this request

@field  CRITCAL_SECTION | CritSec |
    Serialisation object for threads accessing this <t>WAVEDESC<d> structure

@othertype  WAVEDESC NEAR * | PWAVEDESC |
    A near pointer to the structure.

@tagname    tagWaveDesc
*/

#ifndef MMNOMMIO
#ifndef MMNOWAVE

typedef struct tagWaveDesc {
    MCIDEVICEID     wDeviceID;
    UINT            wMode;
    DWORD           dTimeFormat;
    UINT            wSeconds;
    HWND            hwndCallback;
    DWORD           hTask;
    //HANDLE          hTask;
    DIRECTION       Direction;
    UINT            wTaskState;
    UINT            idOut;
    UINT            idIn;
    HWAVEOUT        hWaveOut;
    HWAVEIN         hWaveIn;
    DWORD           dCur;
    DWORD           dFrom;
    DWORD           dTo;
    DWORD           dSize;
    HMMIO           hmmio;
    HANDLE          hTempBuffers;
    LPMMIOPROC      pIOProc;
    LPWAVEDATANODE  lpWaveDataNode;
    DWORD           dRiffData;
    DWORD           dWaveDataStartNode;
    DWORD           dWaveDataCurrentNode;
    DWORD           dVirtualWaveDataStart;
    DWORD           dWaveDataNodes;
    DWORD           dWaveTempDataLength;
    DWORD           dLevel;
    UINT            wTaskError;
    UINT            wAudioBuffers;
    DWORD           dAudioBufferLen;
    LPWSTR          szSaveFile;
    UINT            wFormatSize;
    WAVEFORMAT NEAR * pwavefmt;
    HANDLE          hTaskHandle;  // Handle of the thread running this job
    LPWAVEHDR       rglpWaveHdr[MaxAudioSeconds];
    WCHAR           aszFile[_MAX_PATH];
    WCHAR           aszTempFile[_MAX_PATH];
}   WAVEDESC;
typedef WAVEDESC * PWAVEDESC;


/************************************************************************/

//PRIVATE DWORD PASCAL FAR time2bytes(
//        PWAVEDESC  pwd,
//        DWORD      dTime,
//        DWORD      dFormat);
//
//PRIVATE DWORD PASCAL FAR bytes2time(
//        PWAVEDESC  pwd,
//        DWORD      dBytes,
//        DWORD      dFormat);

PUBLIC  VOID PASCAL FAR mwDelayedNotify(
        PWAVEDESC  pwd,
        UINT       uStatus);

PUBLIC  LPWAVEHDR * PASCAL FAR NextWaveHdr(
        PWAVEDESC  pwd,
        LPWAVEHDR  * lplpWaveHdr);

PUBLIC  UINT PASCAL FAR PlayFile(
        register PWAVEDESC  pwd);

PUBLIC  UINT PASCAL FAR RecordFile(
        register PWAVEDESC  pwd);

PUBLIC  DWORD PASCAL FAR mwInfo(
        PWAVEDESC         pwd,
        DWORD             dFlags,
        LPMCI_INFO_PARMS  lpInfo);

PUBLIC  DWORD PASCAL FAR mwGetDevCaps(
        PWAVEDESC               pwd,
        DWORD                   dFlags,
        LPMCI_GETDEVCAPS_PARMS  lpCaps);

PUBLIC  DWORD PASCAL FAR mwAllocMoreBlockNodes(
        PWAVEDESC   pwd);

PUBLIC  DWORD PASCAL FAR mwFindAnyFreeDataNode(
        PWAVEDESC   pwd,
        DWORD   dMinDataLength);

PUBLIC  VOID PASCAL FAR mwDeleteData(
        PWAVEDESC   pwd);

PUBLIC  VOID PASCAL FAR mwSaveData(
        PWAVEDESC   pwd);

PUBLIC  VOID PASCAL FAR InitMMIOOpen(
        PWAVEDESC   pwd,
        LPMMIOINFO  lpmmioInfo);

#endif  // MMNOWAVE
#endif  // MMNOMMIO

PUBLIC  LRESULT PASCAL FAR mciDriverEntry(
        MCIDEVICEID         wDeviceID,
        UINT                uMessage,
        DWORD               dFlags,
        LPMCI_GENERIC_PARMS lpParms);

PUBLIC  INT_PTR PASCAL FAR Config(
        HWND    hWnd,
        LPDRVCONFIGINFO lpdci,
        HINSTANCE   hInstance);

PUBLIC  UINT PASCAL FAR GetAudioSeconds(
        LPCWSTR  pch);

__inline BOOL MySeekFile(HANDLE hFile, LONG Position)
{
    return 0xFFFFFFFF != SetFilePointer(hFile, Position, NULL, FILE_BEGIN);
}

__inline BOOL MyReadFile(HANDLE hFile, LPVOID pBuffer, ULONG cBytesToRead, PULONG pcBytesRead)
{
    BOOL fReturn;
    ULONG cBytesRead;
    if (!pcBytesRead) pcBytesRead = &cBytesRead;
    fReturn = ReadFile(hFile, pBuffer, cBytesToRead, pcBytesRead, NULL);
    if (fReturn && (*pcBytesRead == cBytesToRead))
    {
	return TRUE;
    }
    *pcBytesRead = -1;
    return FALSE;
}

__inline BOOL MyWriteFile(HANDLE hFile, LPCVOID pBuffer, ULONG cBytesToWrite, PULONG pcBytesWritten)
{
    BOOL fReturn;
    ULONG cBytesWritten;
    if (!pcBytesWritten) pcBytesWritten = &cBytesWritten;
    fReturn = WriteFile(hFile, pBuffer, cBytesToWrite, pcBytesWritten, NULL);
    if (fReturn && (*pcBytesWritten == cBytesToWrite))
    {
	return TRUE;
    }
    *pcBytesWritten = -1;
    return FALSE;
}

/************************************************************************/

/*
**  This defines a stack and code based pointer types.
*/

//#define STACK   _based(_segname("_STACK"))
//#define SZCODE  char _based(_segname("_CODE"))
//typedef char    STACK * SSZ;

#define SZCODE  WCHAR        // Should be sufficient,
typedef WCHAR   *SSZ;        // as segments no longer matter in Win32

/************************************************************************/

PUBLIC  HINSTANCE hModuleInstance;
PUBLIC  UINT   cWaveOutMax;
PUBLIC  UINT   cWaveInMax;
PUBLIC  UINT   wAudioSeconds;


/***************************************************************************

    Synchronisation support

***************************************************************************/


VOID InitCrit(VOID);

VOID DeleteCrit(VOID);

#if DBG
extern VOID DbgEnterCrit(UINT ln, LPCSTR lpszFile);
#define EnterCrit()    DbgEnterCrit(__LINE__, __FILE__)
#else
VOID EnterCrit(VOID);
#endif


VOID LeaveCrit(VOID);

VOID TaskWaitComplete(HANDLE h);

UINT TaskBlock(VOID);

BOOL TaskSignal(DWORD h, UINT Msg);

#ifndef MMNOMMIO
#ifndef MMNOWAVE

#if DBG
extern  DWORD dwCritSecOwner;
#define mmYield(pwd)  mmDbgYield(pwd, __LINE__, __FILE__)

extern VOID mmDbgYield(PWAVEDESC pwd, UINT ln, LPCSTR lpszFile);

#define CheckIn()  WinAssert((GetCurrentThreadId() == dwCritSecOwner))
#define CheckOut() WinAssert((GetCurrentThreadId() != dwCritSecOwner))

#else

#define CheckIn()
#define CheckOut()
#define mmYield(pwd)           \
          {                    \
              LeaveCrit();     \
              Sleep(10);       \
              EnterCrit();     \
          }
#endif

#endif
#endif


/***************************************************************************

    DEBUGGING SUPPORT

***************************************************************************/


#if DBG

    extern void mciwaveDbgOut(LPSTR lpszFormat, ...);
    extern void mciwaveInitDebugLevel(void);
    extern void dDbgAssert(LPSTR exp, LPSTR file, int line);

    #define WinAssert(exp) \
        ((exp) ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__))

    #define WinEval(exp) \
        ((__dwEval=(DWORD)(exp)),  \
          __dwEval ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__), __dwEval)

    int mciwaveDebugLevel;

    #define dprintf( _x_ )                              mciwaveDbgOut _x_
    #define dprintf1( _x_ ) if (mciwaveDebugLevel >= 1) mciwaveDbgOut _x_
    #define dprintf2( _x_ ) if (mciwaveDebugLevel >= 2) mciwaveDbgOut _x_
    #define dprintf3( _x_ ) if (mciwaveDebugLevel >= 3) mciwaveDbgOut _x_
    #define dprintf4( _x_ ) if (mciwaveDebugLevel >= 4) mciwaveDbgOut _x_

#else  // DBG

    #define mciwaveInitDebugLevel() 0

    #define WinAssert(exp) 0
    #define WinEval(exp) (exp)

    #define dprintf(x)
    #define dprintf1(x)
    #define dprintf2(x)
    #define dprintf3(x)
    #define dprintf4(x)

#endif

#endif // MCIWAVE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciwave\mciwave.c ===
/************************************************************************/

/*
**  Copyright (c) 1985-1998 Microsoft Corporation
**
**  Title: mciwave.c - Multimedia Systems Media Control Interface
**  waveform audio driver for RIFF wave files.
**
**  Version:    1.00
**
**  Date:       18-Apr-1990
**
**  Author:     ROBWI
*/

/************************************************************************/

/*
**  Change log:
**
**  DATE        REV DESCRIPTION
**  ----------- -----   ------------------------------------------
**  18-APR-1990 ROBWI   Original
**  19-JUN-1990 ROBWI   Added wave in
**  13-Jan-1992 MikeTri Ported to NT
**                  @@@ To be changed
**   3-Mar-1992 SteveDav Continue port
*/

/************************************************************************/
#define UNICODE

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOOPENFILE
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
//#define NOWINOFFSETS  Hides definition of GetDesktopWindow
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS

#include <windows.h>
#include "mciwave.h"
#include <mmddk.h>
#include <wchar.h>
#include <gmem.h>


STATICFN LPBYTE GlobalReAllocPtr(LPVOID lp, DWORD cbNew, DWORD flags)
{
    HANDLE h, hNew;
    LPBYTE lpNew = NULL;

    h = GlobalHandle(lp);
    if (!h) {
   return(NULL);
    }

    GlobalUnlock(h);

    hNew = GlobalReAlloc(h , cbNew, flags);
    if (hNew) {
   lpNew = GlobalLock(hNew);
   if (!lpNew) {
       dprintf1(("FAILED to lock reallocated memory handle %8x (%8x)", hNew, lp));
       // we still return the lpNew pointer, even though the memory
       // is not locked down.  Perhaps this should be an error?
       // At this point the existing block could have been trashed!
   } else {
       dprintf3(("Reallocated ptr %8x to %8x (Handle %8x)", lp, lpNew, h));
   }
    } else {
   dprintf1(("FAILED to realloc memory handle %8x (%8x)", h, lp));
   GlobalLock(h);    // restore the lock
    }
    return(lpNew);
}

PRIVATE DWORD PASCAL FAR time2bytes(
        PWAVEDESC  pwd,
        DWORD      dTime,
        DWORD      dFormat);

PRIVATE DWORD PASCAL FAR bytes2time(
        PWAVEDESC  pwd,
        DWORD      dBytes,
        DWORD      dFormat);
PRIVATE UINT PASCAL NEAR mwCheckDevice(
        PWAVEDESC   pwd,
        DIRECTION   Direction);

/************************************************************************/

/*
**  The following constants define the default values used when creating
**  a new wave file during the MCI_OPEN command.
*/

#define DEF_CHANNELS    1
#define DEF_AVGBYTESPERSEC  11025L

/************************************************************************/

/*
**  hModuleInstance Instance handle of the wave driver module.
**  cWaveOutMax Number of wave output devices available.
**  cWaveInMax  Number of wave output devices available.
**  wAudioSeconds   Contains the number of seconds of audio buffers to
**          allocate for playback and recording.  This is set
**          during the DRV_OPEN message.
**  aszPrefix   Contains the prefix to use for temporary file names.
*/

HINSTANCE   hModuleInstance;
UINT    cWaveOutMax;
UINT    cWaveInMax;
UINT    wAudioSeconds;
PRIVATE SZCODE aszPrefix[] = L"mci";

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   VOID | ReleaseWaveBuffers |
    This function releases all buffers that have been added to the wave
    input or output device if any device is present.  This has the side
    affect of immediately posting signals to the task for each buffer
    released.  That allows a task to be released if it is waiting for
    a buffer to be freed, and to leave the current state.

    It also has the effect of resetting the byte input and output counters
    for the wave device, so that accurate byte counts must be retrieved
    before calling this function.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR ReleaseWaveBuffers(
    PWAVEDESC   pwd)
{
    if (pwd->hWaveOut || pwd->hWaveIn) {

        if (pwd->Direction == output)
            waveOutReset(pwd->hWaveOut);
        else
            waveInReset(pwd->hWaveIn);
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    DWORD | time2bytes |
    Converts the specified time format to a byte equivalent.  For
    converting milliseconds, the <f>MulDiv<d> function is used to
    avoid overflows on large files with high average sample rates.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dTime |
    Position in Bytes, Samples or Milliseconds.

@parm   DWORD | dFormat |
    Indicates whether time is in Samples, Bytes or Milliseconds.

@rdesc  Returns byte offset equivalent of the <p>lTime<d> passed.
*/

PRIVATE DWORD PASCAL FAR time2bytes(
    PWAVEDESC   pwd,
    DWORD   dTime,
    DWORD   dFormat)
{
    if (dFormat == MCI_FORMAT_SAMPLES)
        dTime = (DWORD)(MulDiv((LONG)dTime, pwd->pwavefmt->nAvgBytesPerSec, pwd->pwavefmt->nSamplesPerSec) / pwd->pwavefmt->nBlockAlign) * pwd->pwavefmt->nBlockAlign;
    else if (dFormat == MCI_FORMAT_MILLISECONDS)
        dTime = (DWORD)MulDiv((LONG)dTime, pwd->pwavefmt->nAvgBytesPerSec, 1000L);

    return dTime;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    DWORD | bytes2time |
    Converts a byte offset to the specified time format equivalent.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dBytes |
    Position in bytes.

@parm   DWORD | dFormat |
    Indicates whether the return time is in Samples, Bytes or Milliseconds.

@rdesc  Returns the specified time equivalent.
*/

PRIVATE DWORD PASCAL FAR bytes2time(
    PWAVEDESC   pwd,
    DWORD   dBytes,
    DWORD   dFormat)
{
    if (dFormat == MCI_FORMAT_SAMPLES)
        dBytes = (DWORD)MulDiv((LONG)dBytes, pwd->pwavefmt->nSamplesPerSec, pwd->pwavefmt->nAvgBytesPerSec);
    else if (dFormat == MCI_FORMAT_MILLISECONDS)
        dBytes = (DWORD)MulDiv((LONG)dBytes, 1000L, pwd->pwavefmt->nAvgBytesPerSec);

    return dBytes;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | mwCloseFile |
    Close the currently open file by releasing the MMIO handle and closing
    the temporary buffer file, if any.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR mwCloseFile(
    PWAVEDESC   pwd)
{
    if (pwd->hmmio) {
        mmioClose(pwd->hmmio, 0);
        pwd->hmmio = NULL;
    }

    if (pwd->hTempBuffers != INVALID_HANDLE_VALUE) {
	CloseHandle(pwd->hTempBuffers);

        DeleteFile( pwd->aszTempFile );

        pwd->hTempBuffers = 0;
    }

    if (pwd->lpWaveDataNode) {
        GlobalFreePtr(pwd->lpWaveDataNode);
        pwd->lpWaveDataNode = NULL;
    }

    if (pwd->pwavefmt) {
        LocalFree(pwd->pwavefmt);
        pwd->pwavefmt = NULL;
    }

}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | SetMMIOError |
    Converts the specified MMIO error to an MCI error, and sets the task
    error <e>PWAVEDESC.wTaskError<d>.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   UINT | wError |
    Indicates the MMIO error that is to be converted to an MCI error.  An
    unknown MMIO error will generate an MCIERR_INVALID_FILE MCI error.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR SetMMIOError(
    PWAVEDESC   pwd,
    UINT    wError)
{
    //Assumes that we already own pwd

    switch (wError) {
    case MMIOERR_FILENOTFOUND:
        wError = MCIERR_FILE_NOT_FOUND;
        break;

    case MMIOERR_OUTOFMEMORY:
        wError = MCIERR_OUT_OF_MEMORY;
        break;

    case MMIOERR_CANNOTOPEN:
        wError = MCIERR_FILE_NOT_FOUND;
        break;

    case MMIOERR_CANNOTREAD:
        wError = MCIERR_FILE_READ;
        break;

    case MMIOERR_CANNOTWRITE:
        wError = MCIERR_FILE_WRITE;
        break;

    case MMIOERR_CANNOTSEEK:
        wError = MCIERR_FILE_READ;
        break;

    case MMIOERR_CANNOTEXPAND:
        wError = MCIERR_FILE_WRITE;
        break;

    case MMIOERR_CHUNKNOTFOUND:
    default:
        wError = MCIERR_INVALID_FILE;
        break;
    }
    pwd->wTaskError = wError;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    BOOL | ReadWaveHeader |
    Reads the RIFF header, and wave header chunk from the file.  Allocates
    memory to hold that chunk, and descends into the wave data chunk,
    storing the offset to the beginning of the actual wave data.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns TRUE if the current file is a valid RIFF format wave file,
    and can be read, else FALSE if a read error occurs, or invalid data is
    encountered.
*/

PRIVATE BOOL PASCAL NEAR ReadWaveHeader(
    PWAVEDESC   pwd)
{
    MMCKINFO    mmckRIFF;
    MMCKINFO    mmck;
    UINT    wError;

    mmckRIFF.fccType = mmioWAVE;
    if (0 != (wError = mmioDescend(pwd->hmmio, &mmckRIFF, NULL, MMIO_FINDRIFF))) {
        SetMMIOError(pwd, wError);
        return FALSE;
    }

    mmck.ckid = mmioFMT;
    if (0 != (wError = mmioDescend(pwd->hmmio, &mmck, &mmckRIFF, MMIO_FINDCHUNK))) {
        SetMMIOError(pwd, wError);
        return FALSE;
    }

    if (mmck.cksize < (LONG)sizeof(PCMWAVEFORMAT)) {
        pwd->wTaskError = MCIERR_INVALID_FILE;
        return FALSE;
    }

    pwd->wFormatSize = mmck.cksize;
    pwd->pwavefmt = (WAVEFORMAT NEAR *)LocalAlloc(LPTR, pwd->wFormatSize);
    if (!pwd->pwavefmt) {
        pwd->wTaskError = MCIERR_OUT_OF_MEMORY;
        return FALSE;
    }

    if ((DWORD)mmioRead(pwd->hmmio, (HPSTR)pwd->pwavefmt, mmck.cksize) != mmck.cksize) {
        pwd->wTaskError = MCIERR_FILE_READ;
        return FALSE;
    }

    if (0 != (wError = mmioAscend(pwd->hmmio, &mmck, 0))) {
        SetMMIOError(pwd, wError);
        return FALSE;
    }

    mmck.ckid = mmioDATA;
    if (0 != (wError = mmioDescend(pwd->hmmio, &mmck, &mmckRIFF, MMIO_FINDCHUNK))) {
        SetMMIOError(pwd, wError);
        return FALSE;
    }

    pwd->dSize = mmck.cksize;
    pwd->dRiffData = mmck.dwDataOffset;
    pwd->dAudioBufferLen = BLOCKALIGN(pwd, pwd->pwavefmt->nAvgBytesPerSec);
    return TRUE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    DWORD | mwAllocMoreBlockNodes |
    This function is called in order to force more wave data nodes to be
    allocated.  This is done in increments of DATANODEALLOCSIZE, and the
    index to the first new node is returned.  The new nodes are initialized
    as free nodes.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns the index to the first of the new nodes allocated, else -1 if
    no memory was available, in which case the task error is set.  The
    node returned is marked as a free node, and need not be discarded if
    not used.
*/

PUBLIC  DWORD PASCAL FAR mwAllocMoreBlockNodes(
    PWAVEDESC   pwd)
{
    LPWAVEDATANODE  lpwdn;
    DWORD   dNewBlockNode;

#ifdef DEBUG
    if (pwd->thread) {
   dprintf(("reentering mwAllocMoreBlockNodes!!"));
    }
#endif

    //EnterCrit();
    if (pwd->dWaveDataNodes)
        lpwdn = (LPWAVEDATANODE)GlobalReAllocPtr(pwd->lpWaveDataNode, (pwd->dWaveDataNodes + DATANODEALLOCSIZE) * sizeof(WAVEDATANODE), GMEM_MOVEABLE | GMEM_ZEROINIT);
    else
        lpwdn = (LPWAVEDATANODE)GlobalAllocPtr(GMEM_MOVEABLE | GMEM_ZEROINIT, DATANODEALLOCSIZE * sizeof(WAVEDATANODE));

    if (lpwdn) {
   dprintf2(("Set lpWaveDataNode to %8x (it was %8x)", lpwdn, pwd->lpWaveDataNode));
        pwd->lpWaveDataNode = lpwdn;
        for (lpwdn = LPWDN(pwd, pwd->dWaveDataNodes), dNewBlockNode = 0; dNewBlockNode < DATANODEALLOCSIZE; lpwdn++, dNewBlockNode++)
            RELEASEBLOCKNODE(lpwdn);
        dNewBlockNode = pwd->dWaveDataNodes;
        pwd->dWaveDataNodes += DATANODEALLOCSIZE;
    } else {
   dprintf1(("** ERROR ** Allocating more block nodes (%8x)", pwd->lpWaveDataNode));
        dNewBlockNode =  (DWORD)-1;
        pwd->wTaskError = MCIERR_OUT_OF_MEMORY;
    }

    //LeaveCrit();
    return dNewBlockNode;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    BOOL | CreateTempFile |
    This function creates the temporary data file used to store newly
    recorded data before a Save command is issued to perminently store
    the data in a RIFF format file.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns TRUE if the temporary data file was created, else FALSE, in
    which case the task error is set.
*/

PRIVATE BOOL PASCAL NEAR CreateTempFile(
    PWAVEDESC   pwd)
{
    UINT n;
    TCHAR tempbuf[_MAX_PATH];
    /* First find out where the file should be stored */
    n = GetTempPath(sizeof(tempbuf)/sizeof(TCHAR), tempbuf);

    if (n && GetTempFileName(tempbuf, aszPrefix, 0, pwd->aszTempFile)) {

        pwd->hTempBuffers = CreateFile( pwd->aszTempFile,
					GENERIC_READ | GENERIC_WRITE,
					0,
					NULL,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					NULL );


        if ( pwd->hTempBuffers != INVALID_HANDLE_VALUE) {
            return TRUE;
        } else {
            dprintf2(("hTempBuffers == INVALID_HANDLE_VALUE in CreateTempFile"));
        }

    } else {
        dprintf2(("Error %d from GetTempFileName or GetTempPath in CreateTempFile", GetLastError()));
    }
    pwd->wTaskError = MCIERR_FILE_WRITE;
    return FALSE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    DWORD | mwFindAnyFreeDataNode |
    This function is used to find a free wave data node with a minimum of
    <p>dMinDataLength<d> temporary data space attached.  To do this, all
    the current data nodes are traversed, looking for free ones with at
    least the specified amount of temporary data storage attached.

    As the nodes are being traversed, if a free block is encountered that
    has no data attached, it is saved.  Also, if a node with data attached
    that is too short, but is at the end of the temporary data storage file
    is found, that also is saved.  These will then be used if an
    appropriate node can not be found.

    If an appropriate node can not be found, but a node pointing to the
    last of the temporary data was found, then the data is expanded, and
    that node is returned.  Else if an empty node was found, then it is
    returned with data attached, else a new empty node is created.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dMinDataLength |
    Indicates the minimum amount of temporary data space that must be
    attached to the wave data node returned.  This number is rounded up to
    the nearest block aligned size.

@rdesc  Returns a node with a least the minimum request size of temporary
    data attached, else -1 if not enough memory was available, or the
    temporary data file could not be created.  In that case, the task error
    is set.  The node returned is marked as in use, and must be discarded
    if not used.
*/

PUBLIC  DWORD PASCAL FAR mwFindAnyFreeDataNode(
    PWAVEDESC   pwd,
    DWORD   dMinDataLength)
{
    LPWAVEDATANODE  lpwdn;
    DWORD   dNewBlockNode;
    DWORD   dEmptyBlockNode;
    DWORD   dEmptyDataNode;

    dEmptyBlockNode = (DWORD)-1;
    dEmptyDataNode = (DWORD)-1;
    for (lpwdn = LPWDN(pwd, 0), dNewBlockNode = 0; dNewBlockNode < pwd->dWaveDataNodes; lpwdn++, dNewBlockNode++) {
        if (ISFREEBLOCKNODE(lpwdn)) {
            if (lpwdn->dTotalLength >= dMinDataLength) {
                lpwdn->dDataLength = 0;
                return dNewBlockNode;
            }
            if (!lpwdn->dTotalLength)
                dEmptyBlockNode = dNewBlockNode;
            else if (lpwdn->dDataStart + lpwdn->dTotalLength == pwd->dWaveTempDataLength)
                dEmptyDataNode = dNewBlockNode;
        }
    }

    dMinDataLength = ROUNDDATA(pwd, dMinDataLength);
    if (dEmptyDataNode != -1) {
        lpwdn = LPWDN(pwd, dEmptyDataNode);
        lpwdn->dDataLength = 0;
        lpwdn->dTotalLength = dMinDataLength;
        if (UNMASKDATASTART(lpwdn) + lpwdn->dTotalLength > pwd->dWaveTempDataLength)
            pwd->dWaveTempDataLength = UNMASKDATASTART(lpwdn) + lpwdn->dTotalLength;
    } else {
        if ((pwd->hTempBuffers == INVALID_HANDLE_VALUE) && !CreateTempFile(pwd))
            return (DWORD)-1;
        if (dEmptyBlockNode != -1) {
            dNewBlockNode = dEmptyBlockNode;
        } else if ((dNewBlockNode = mwAllocMoreBlockNodes(pwd)) == -1)
            return (DWORD)-1;
        lpwdn = LPWDN(pwd, dNewBlockNode);
        lpwdn->dDataStart = MASKDATASTART(pwd->dWaveTempDataLength);
        lpwdn->dDataLength = 0;
        lpwdn->dTotalLength = dMinDataLength;
        pwd->dWaveTempDataLength += lpwdn->dTotalLength;
    }
    return dNewBlockNode;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | InitMMIOOpen |
    This function initializes the MMIO open structure by zeroing out all
    entries, and setting the IO procedure or file type if needed.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   <t>LPMMIOINFO<d> | lpmmioInfo |
    Points to the MMIO structure to initialize.

@rdesc  nothing.
*/

PUBLIC  VOID PASCAL FAR InitMMIOOpen(
    PWAVEDESC   pwd,
    LPMMIOINFO  lpmmioInfo)
{
    memset(lpmmioInfo, 0, sizeof(MMIOINFO));
    lpmmioInfo->pIOProc = pwd->pIOProc;
    lpmmioInfo->htask = mciGetCreatorTask(pwd->wDeviceID);
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    BOOL | mwOpenFile |
    This function opens and verifies the file specified in the wave
    descriptor block.  If no file is specified in the block, a new,
    unnamed wave format file is opened.

    If <e>WAVEDESC.aszFile<d> specifies a non-zero length string, it is
    assumed to contain the file name to open.  The function attempts to
    open this file name, setting the <e>WAVEDESC.hmmio<d> element, and
    returns any error.

    If on the other hand the file name element is zero length, the
    function assumes that it is to open a new, unnamed wave file.  It
    attempts to do so using the default parameters.

    If the file can be opened, the format information is set.  In order to be
    able to work with formats other than PCM, the length of the format block
    is not assumed, although the start of the block is assumed to be in PCM
    header format.  The format for a new file is PCM.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns TRUE if file opened and the header information read, else
    FALSE, in which case the <e>WAVEDESC.wTaskError<d> flag is set with
    the MCI error.
*/

PRIVATE BOOL PASCAL NEAR mwOpenFile(
    PWAVEDESC   pwd)
{
    LPWAVEDATANODE  lpwdn;

    pwd->dWaveDataStartNode = mwAllocMoreBlockNodes(pwd);
    if (pwd->dWaveDataStartNode == -1)
        return FALSE;

    if (*pwd->aszFile) {
        MMIOINFO    mmioInfo;

        InitMMIOOpen(pwd, &mmioInfo);
        pwd->hmmio = mmioOpen(pwd->aszFile, &mmioInfo, MMIO_READ | MMIO_DENYWRITE);

        if (pwd->hmmio == NULL)
            SetMMIOError(pwd, mmioInfo.wErrorRet);
        else if (ReadWaveHeader(pwd)) {
            lpwdn = LPWDN(pwd, pwd->dWaveDataStartNode);
            lpwdn->dDataLength = pwd->dSize;
            lpwdn->dTotalLength = pwd->dSize;
            lpwdn->dNextWaveDataNode = (DWORD)ENDOFNODES;

            pwd->wTaskError = mwCheckDevice( pwd, pwd->Direction );
            if (pwd->wTaskError) {
                mwCloseFile(pwd);
                return FALSE;
            }
            else {
                return TRUE;
            }
        }
    } else {
        pwd->pwavefmt = (WAVEFORMAT NEAR *)LocalAlloc(LPTR, sizeof(PCMWAVEFORMAT));

        if (pwd->pwavefmt) {
            pwd->pwavefmt->wFormatTag = WAVE_FORMAT_PCM;
            pwd->pwavefmt->nChannels = DEF_CHANNELS;
            pwd->pwavefmt->nAvgBytesPerSec = DEF_AVGBYTESPERSEC;
            pwd->pwavefmt->nSamplesPerSec = DEF_AVGBYTESPERSEC / DEF_CHANNELS;
            pwd->pwavefmt->nBlockAlign = (WORD)(pwd->pwavefmt->nSamplesPerSec / pwd->pwavefmt->nAvgBytesPerSec);
            ((NPPCMWAVEFORMAT)(pwd->pwavefmt))->wBitsPerSample = (WORD)pwd->pwavefmt->nBlockAlign * (WORD)8;
            pwd->wFormatSize = sizeof(PCMWAVEFORMAT);
            pwd->dAudioBufferLen = BLOCKALIGN(pwd, DEF_AVGBYTESPERSEC);

            if ((pwd->dWaveDataStartNode = mwFindAnyFreeDataNode(pwd, pwd->dAudioBufferLen)) != -1) {
                pwd->dWaveDataCurrentNode = pwd->dWaveDataStartNode;
                lpwdn = LPWDN(pwd, pwd->dWaveDataStartNode);
                lpwdn->dNextWaveDataNode = (DWORD)ENDOFNODES;
                return TRUE;
            }
        } else
            pwd->wTaskError = MCIERR_OUT_OF_MEMORY;
    }

    mwCloseFile(pwd);
    return FALSE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | mwFreeDevice |
    This function frees the current wave device, if any.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR mwFreeDevice(
    PWAVEDESC   pwd)
{
    if (pwd->hWaveOut || pwd->hWaveIn) {
        if (pwd->Direction == output) {
            waveOutClose(pwd->hWaveOut);
            pwd->hWaveOut = NULL;
        } else {
            waveInClose(pwd->hWaveIn);
            pwd->hWaveIn = NULL;
        }

        while (TaskBlock() != WM_USER);
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwCheckDevice |
    This function checks whether given the specified parameters, a
    compatible wave device is available.  Depending upon the current
    settings in the wave descriptor block, a specific device, or all
    devices might be checked for the specified direction.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DIRECTION | Direction |
    Indicates whether the parameters are being checked for input or
    for output.

@rdesc  Returns zero on success, else an MCI error code.
*/

PRIVATE UINT PASCAL NEAR mwCheckDevice(
    PWAVEDESC   pwd,
    DIRECTION   Direction)
{
    UINT    wReturn;

    if (!pwd->pwavefmt->nBlockAlign)
        return MCIERR_OUTOFRANGE;
    wReturn = 0;

    if (Direction == output) {
        if (waveOutOpen(NULL, pwd->idOut, (NPWAVEFORMATEX)pwd->pwavefmt, 0L, 0L, (DWORD)WAVE_FORMAT_QUERY))
            wReturn = (pwd->idOut == WAVE_MAPPER) ? MCIERR_WAVE_OUTPUTSUNSUITABLE : MCIERR_WAVE_SETOUTPUTUNSUITABLE;

    } else if (waveInOpen(NULL, pwd->idOut, (NPWAVEFORMATEX)pwd->pwavefmt, 0L, 0L, (DWORD)WAVE_FORMAT_QUERY))
        wReturn = (pwd->idOut == WAVE_MAPPER) ? MCIERR_WAVE_INPUTSUNSUITABLE : MCIERR_WAVE_SETINPUTUNSUITABLE;

    return wReturn;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwGetDevice |
    This function opens the specified input or output wave device.
    If the device id is -1, then the first available device which supports
    the format will be opened.

    If the function fails to get a suitable device, it checks to see if
    there are any that would have worked if they were not in use.  This is
    in order to return a more clear error to the calling function.

    The function initially tries to open the device requested or the
    default device.  Failing this, if the wave information block
    specifies that any device can be used, it attempts to open an
    appropriate device.

    If all else fails, the current configuration is checked to determine
    if any device would have worked had it been available, and the
    appropriate error is returned.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns 0 if wave device is successfully opened, else an MCI error.
*/

PRIVATE UINT PASCAL NEAR mwGetDevice(
    PWAVEDESC   pwd)
{
    UINT    wReturn;

#if DBG
    if (GetCurrentThreadId() != dwCritSecOwner) {
        dprintf1(("mwGetDevice called while outside the critical section"));
    }

#endif

    wReturn = 0;
    if (pwd->Direction == output) {
        if (waveOutOpen(&(pwd->hWaveOut),
                        pwd->idOut,
                        (NPWAVEFORMATEX)pwd->pwavefmt,
                        (DWORD)pwd->hTask,
                        0L,
                        (DWORD)CALLBACK_TASK)) {
            pwd->hWaveOut = NULL;
            wReturn = mwCheckDevice(pwd, pwd->Direction);
            if (!wReturn) {
                if (pwd->idOut == WAVE_MAPPER)
                    wReturn = MCIERR_WAVE_OUTPUTSINUSE;
                else
                    wReturn = MCIERR_WAVE_SETOUTPUTINUSE;
            }
        }
    } else if (waveInOpen(&(pwd->hWaveIn),
                          pwd->idIn,
                          (NPWAVEFORMATEX)pwd->pwavefmt,
                          (DWORD)pwd->hTask,
                          0L,
                          (DWORD)CALLBACK_TASK)) {
        pwd->hWaveIn = NULL;
        wReturn = mwCheckDevice(pwd, pwd->Direction);
        if (!wReturn) {
            if (pwd->idIn == WAVE_MAPPER)
                wReturn = MCIERR_WAVE_INPUTSINUSE;
            else
                wReturn = MCIERR_WAVE_SETINPUTINUSE;
        }
    }
    return wReturn;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    DWORD | mwDelayedNotify |
    This is a utility function that sends a notification saved with
    <f>mwSaveCallback<d> to mmsystem which posts a message to the
    application.  If there is no current notification callback handle,
    no notification is attempted.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   UINT | wStatus |
    Speicifies the type of notification to use.

@flag   MCI_NOTIFY_SUCCESSFUL |
    Operation completed successfully.

@flag   MCI_NOTIFY_SUPERSEDED |
    A new command which specified notification, but did not interrupt
    the current operation was received.

@flag   MCI_NOTIFY_ABORTED |
    The current command was aborted due to receipt of a new command.

@flag   MCI_NOTIFY_FAILURE |
    The current operation failed.

@rdesc  Nothing.
*/

PUBLIC  VOID PASCAL FAR mwDelayedNotify(
    PWAVEDESC   pwd,
    UINT    wStatus)
{
    if (pwd->hwndCallback) {
        dprintf3(("Calling driver callback"));
        mciDriverNotify(pwd->hwndCallback, pwd->wDeviceID, wStatus);
        pwd->hwndCallback = NULL;
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | mwImmediateNotify |
    This is a utility function that sends a successful notification
    message to mmsystem.

@parm   MCIDEVICEID | wDeviceID |
    Device ID.

@parm   <t>LPMCI_GENERIC_PARMS<d> | lpParms |
    Far pointer to an MCI parameter block. The first field of every MCI
    parameter block is the callback handle.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR mwImmediateNotify(
    MCIDEVICEID     wDeviceID,
    LPMCI_GENERIC_PARMS lpParms)
{
    mciDriverNotify((HWND)(lpParms->dwCallback), wDeviceID, MCI_NOTIFY_SUCCESSFUL);
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | mwSaveCallback |
    This is a utility function that saves a new callback in the instance
    data block.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   HHWND | hwndCallback |
    Callback handle to save.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR mwSaveCallback(
    PWAVEDESC   pwd,
    HWND    hwndCallback)
{
    pwd->hwndCallback = hwndCallback;
}

/************************************************************************/

/*
@doc    INTERNAL MCIWAVE

@api    <t>LPWAVEHDR<d> * | NextWaveHdr |
    This function returns the next wave buffer based on the buffer passed.
    It either returns the next buffer in the list, or the first buffer
    in the list of the last buffer is passed.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   <t>LPWAVEHDR<d> * | lplpWaveHdr |
    Points to the array of wave buffer pointers from which a buffer pointer
    is returned.

@rdesc  Returns the next wave buffer to use.
*/

PUBLIC  LPWAVEHDR * PASCAL FAR NextWaveHdr(
    PWAVEDESC   pwd,
    LPWAVEHDR   *lplpWaveHdr)
{
    if (lplpWaveHdr < (pwd->rglpWaveHdr + pwd->wAudioBuffers - 1))
        return lplpWaveHdr + 1;
    else
        return pwd->rglpWaveHdr;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | GetPlayRecPosition |
    Gets the current playback or recording position.  For output, this
    means also determining how much data has actually passed through the
    wave device if a device is currently open.  This must be added to the
    starting playback position.  For input however, only the amount that
    has actually be written to disk is returned.

    Note that the return value from the driver is verified against the
    actual length of the data.  This is to protect against problems
    encountered in drivers that return bytes when samples are requested.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   LPDWORD | lpdTime |
    Points to a buffer to play the current position.

@parm   DWORD | dFormatReq |
    Indicates whether time is in samples, bytes or milliseconds.

@rdesc  Returns zero on success, else the device error on error.  This can
    only fail if getting the current playback position.  The recording
    position will alway succeed.
*/

PRIVATE UINT PASCAL NEAR GetPlayRecPosition(
    PWAVEDESC   pwd,
    LPDWORD lpdTime,
    DWORD   dFormatReq)
{
    if (pwd->Direction == output) {
        MMTIME  mmtime;
        DWORD   dDelta;
        UINT    wErrorRet;

        mmtime.wType = TIME_BYTES;
        if (!pwd->hWaveOut)
            mmtime.u.cb = 0;
        else if (0 != (wErrorRet = waveOutGetPosition(pwd->hWaveOut, &mmtime, sizeof(MMTIME))))
            return wErrorRet;

        dDelta = mmtime.u.cb;

//#ifdef DEBUG
        if (pwd->dFrom + dDelta > pwd->dSize)
            dDelta = pwd->dSize - pwd->dFrom;
//#endif
        *lpdTime = bytes2time(pwd, pwd->dFrom + dDelta, dFormatReq);
    } else
        *lpdTime = bytes2time(pwd, pwd->dCur, dFormatReq);
    return 0;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | SetCurrentPosition |
    Sets the starting and current file position, that is, the the point
    at which playback or recording will start at.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dByteOffset |
    Indicates the position to set in bytes.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR SetCurrentPosition(
    PWAVEDESC   pwd,
    DWORD   dByteOffset)
{
    LPWAVEDATANODE  lpwdn;

    lpwdn = LPWDN(pwd, 0);
    if (lpwdn) {
        if (dByteOffset >= pwd->dVirtualWaveDataStart)
            lpwdn += pwd->dWaveDataCurrentNode;
        else {
            lpwdn += pwd->dWaveDataStartNode;
            pwd->dVirtualWaveDataStart = 0;
            pwd->dWaveDataCurrentNode = pwd->dWaveDataStartNode;
        }
        for (; dByteOffset > pwd->dVirtualWaveDataStart + lpwdn->dDataLength;) {
            pwd->dVirtualWaveDataStart += lpwdn->dDataLength;
            pwd->dWaveDataCurrentNode = lpwdn->dNextWaveDataNode;
            lpwdn = LPWDN(pwd, pwd->dWaveDataCurrentNode);
        }
        pwd->dFrom = dByteOffset;
        pwd->dCur = dByteOffset;
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | RoundedBytePosition |
    This function returns the rounded byte format time position from the
    specified position parameter in the specified time format.  It
    transforms the position to byte format and rounds against the current
    block alignment.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dTime |
    Specifies the time position to translate and round.

@parm   DWORD | dFormat |
    Indicates the time format of <p>dTime<d>.

@rdesc  Returns the rounded byte formate of the position passed.
*/

PRIVATE DWORD PASCAL NEAR RoundedBytePosition(
    PWAVEDESC   pwd,
    DWORD   dTime,
    DWORD   dFormat)
{
    DWORD   dBytes;

    dBytes = time2bytes(pwd, dTime, dFormat);

    /*
    **  Get the end position right.  Because lots of compressed files don't
    **  end with a complete sample we make sure that the end stays the
    **  end.
    */

    if (dBytes >= pwd->dSize && pwd->Direction == output)
        return pwd->dSize;

    return dBytes - (dBytes % pwd->pwavefmt->nBlockAlign);
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | mwStop |
    This function is called in response to an <m>MCI_STOP<d> message, and
    internally by several function, and is used to stop playback or
    recording if the task is currently not idle.  The function yields
    until the task has actually become idle.  This has the side affect of
    releasing any buffers currently added to the pwave input or output
    device, and thus signalling the task that the buffers are available.

    Note that if the task is in Cleanup mode, indicating that it is
    blocking to remove extra signals, and ignoring any commands, the
    function just waits for the task to enter Idle state without signalling
    the task.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR mwStop(
    PWAVEDESC   pwd)
{
    if (ISTASKSTATE(pwd, TASKBUSY)) {
        if (!ISMODE(pwd, MODE_CLEANUP)) {
            DWORD   dPosition;

            ADDMODE(pwd, COMMAND_NEW | COMMAND_STOP);

            if (!GetPlayRecPosition(pwd, &dPosition,  MCI_FORMAT_BYTES))
                SetCurrentPosition(pwd, RoundedBytePosition(pwd, dPosition, MCI_FORMAT_BYTES));

            ReleaseWaveBuffers(pwd);

//!!            if (ISMODE(pwd, MODE_PAUSED | MODE_HOLDING) || (ISMODE(pwd, MODE_PLAYING) && ISMODE(pwd, MODE_CUED)))
            if (ISMODE(pwd, MODE_PAUSED | MODE_HOLDING))
                TaskSignal(pwd->hTask, WTM_STATECHANGE);
        }

        while (!ISTASKSTATE(pwd, TASKIDLE))
            mmYield(pwd);
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | AllocateBuffers |
    Allocates and prepares an array of wave buffers used for playback or
    recording, up to the maximum number of seconds specified.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns number of buffers successfully allocated.
*/

PRIVATE UINT PASCAL NEAR AllocateBuffers(
    PWAVEDESC   pwd)
{
    UINT    wAllocatedBuffers;

    for (wAllocatedBuffers = 0; wAllocatedBuffers < pwd->wSeconds; wAllocatedBuffers++) {
        if (!(pwd->rglpWaveHdr[wAllocatedBuffers] = (LPWAVEHDR)GlobalAllocPtr(GMEM_MOVEABLE, (DWORD)(sizeof(WAVEHDR) + pwd->dAudioBufferLen))))
            break;

        dprintf3(("Allocated %8X", pwd->rglpWaveHdr[wAllocatedBuffers]));
        pwd->rglpWaveHdr[wAllocatedBuffers]->dwFlags = WHDR_DONE;
        pwd->rglpWaveHdr[wAllocatedBuffers]->lpData = (LPSTR)(pwd->rglpWaveHdr[wAllocatedBuffers] + 1);
        pwd->rglpWaveHdr[wAllocatedBuffers]->dwBufferLength = pwd->dAudioBufferLen;
        if (pwd->Direction == output) {
            if (!waveOutPrepareHeader(pwd->hWaveOut, pwd->rglpWaveHdr[wAllocatedBuffers], sizeof(WAVEHDR)))
            {
                pwd->rglpWaveHdr[wAllocatedBuffers]->dwFlags |= WHDR_DONE;
                continue;
            }
        } else if (!waveInPrepareHeader(pwd->hWaveIn, pwd->rglpWaveHdr[wAllocatedBuffers], sizeof(WAVEHDR))) {

            /*
            **  Initialize the bytes recorded or mwGetLevel can fall over
            */
            pwd->rglpWaveHdr[wAllocatedBuffers]->dwBytesRecorded = 0;
            continue;
        }
        GlobalFreePtr(pwd->rglpWaveHdr[wAllocatedBuffers]);
        pwd->rglpWaveHdr[wAllocatedBuffers] = 0;
        break;
    }

    dprintf2(("Allocated %u Buffers", wAllocatedBuffers));
    return wAllocatedBuffers;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | FreeBuffers |
    Frees the array of wave buffers.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR FreeBuffers(
    PWAVEDESC   pwd)
{
    UINT    wAllocatedBuffers;

    for (wAllocatedBuffers = pwd->wAudioBuffers; wAllocatedBuffers--;) {
        if (!pwd->rglpWaveHdr[wAllocatedBuffers]) continue;

        if (pwd->Direction == output)
            waveOutUnprepareHeader(pwd->hWaveOut, pwd->rglpWaveHdr[wAllocatedBuffers], sizeof(WAVEHDR));
        else
            waveInUnprepareHeader(pwd->hWaveIn, pwd->rglpWaveHdr[wAllocatedBuffers], sizeof(WAVEHDR));
   GlobalFreePtr(pwd->rglpWaveHdr[wAllocatedBuffers]);
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    VOID | mwTask |
    This function represents the background task which plays or records
    wave audio.  It is called as a result of the call to <f>mmTaskCreate<d>
    <f>mwOpenDevice<d>.  When this function returns, the task is destroyed.

    In short, the task opens the designated file, and blocks itself in a
    loop until it is told to do something (close, play, or record).
    Upon entering the function, the signal count is zero,
    <e>WAVEDESC.wTaskState<d> is TASKINIT.  Note that <e>WAVEDESC.wMode<d>
    is left as is.  This is because of the Wait mode feature, in which
    the Wait mode flag needs to be tested by the calling task to determine
    if this task has already performed successful notification.  This
    means that in checking the current task mode, the task state must
    also be verified (except in cases of Recording and Playing modes,
    which are reset after leaving their functions).

    If the requested file is opened, the function enters a loop to allow
    it to act on the current task state when the task is signalled.  It
    then waits in a blocked state with <e>WAVEDESC.wTaskState<d> set to
    TASKIDLE until the state is changed.  So unless the task is closing,
    playing, or recording, it is idle and blocked.

    If the requested file cannot be opened, the task state must be reset
    to TASKNONE so that the task create wait loop recognizes that the
    create has failed.

    When the task is signalled, it again checks the current state just
    as a precaution.  This should be removed eventually.

    A TASKCLOSE state simply breaks out of the outer infinite loop,
    allowing the wave file to be closed, and the task function exited.
    This in turn terminates the task.

    A TASKBUSY state indicates that a wave device has been opened for
    either playback or recording, which is where the signal originated
    from.  The task must first then calculate and allocate the wave
    buffers.  The allocation function will provide up to the number of
    buffers requested, but may be constrained by current memory use.  The
    number of buffers allocated must meet a minimum requirement though to
    allow smooth playback and recording.

    If not enough buffers can be allocated, the current task error is
    set to an out of memory condition, and the function returns to an
    idle state.  Note that the current command mode is reset before
    entering the idle loop.  This ensures that all previous commands are
    removed before allowing the next set of commands to be set.

    If enough buffers are allocated the current task error is reset, and
    the playback or recording function is called to act on the previously
    set parameters.  When the recording or playback function returns, it
    may or may not have successfully finished.  The current position is
    set as based on where the recording or playback actually got to.
    For playback, this is how much data was processed by the wave device.
    For recording, this is how much data was written to disk.  To ensure
    that all buffers have been released by the wave device, the
    <f>ReleaseWaveBuffers<d> function is called in all cases after
    determining the current position.

    In determining the optional notification, the
    <e>WAVEDESC.wTaskError<d> will contain any failure error which
    occurred during the playback or recording.  If no error is set, then
    the only other error could be whether or not playback or recording was
    interrupted by another command.

    After freeing the buffers, the Cleanup mode is set.  This indicates
    that the task is not able to accept new commands until it reaches an
    idle state.  The reason for this flag is that the task must retrieve
    any left over signals from the message queue generated by releasing
    the wave buffers, and by freeing the wave device.  While getting the
    signals, it is possible for the task that opened the MCI wave device
    instance to try and send new commands.  These commands would be
    ignored, so the task must wait until cleanup is done.

    After entering Cleanup mode, the wave device is freed here, even though
    the calling task opened it.  This is bad, in that it assumes that wave
    drivers allocate either local memory, or global memory using
    GMEM_DDESHARE.  This of course generates another task signal from the
    wave device, which is ignored by the Free Device function.  The task
    can now remove any left over signals from the queue, if any, from the
    releasing of the wave buffers.

    Note that notification is only performed if the calling task is no
    longer waiting for this task, and no task error occurred (If the
    calling task is waiting, then notification must be either Failure or
    Successful, since nothing could abort this task).  If notification
    needs to take place, the Wait mode flag is cleared, else the callback
    is cleared.  The calling task will now know that either the background
    task failed, or succeeded and performed notification.

    Note that when terminating the task, the <e>WAVEDESC.hTask<d> must be
    set to NULL to indicate to the <f>mwCloseDevice<d> function that the
    task has indeed terminated itself.

@parm   DWORD | dInstanceData |
    This contains the instance data passed to the <f>mmTaskCreate<d>
    function.  It contains a pointer to the wave audio data in the
    high-order word.  The low-order word is not used.

@rdesc  Nothing.

@xref   mwOpenDevice.
*/

PUBLIC  VOID PASCAL EXPORT mwTask(
    DWORD_PTR dInstanceData)
{
    register PWAVEDESC  pwd;

    EnterCrit();

    /*
    ** Make a safe "user" call so that user knows about our thread.
    ** This is to allow WOW setup/initialisation on this thread
    */
    GetDesktopWindow();

    pwd = (PWAVEDESC)dInstanceData;

    pwd->hTask = mmGetCurrentTask();
    pwd->wTaskError = 0;

    dprintf2(("Bkgd Task %X", pwd->hTask));

    if (mwOpenFile(pwd)) {
        for (; !ISTASKSTATE(pwd, TASKCLOSE);) {
            UINT    wNotification;
            UINT    wBuffersOutstanding;

            SETTASKSTATE(pwd, TASKIDLE);
            while (ISTASKSTATE(pwd, TASKIDLE)) {

                dprintf2(("Task is IDLE"));
                while (TaskBlock() != WTM_STATECHANGE) {
                }
            }
            pwd->wTaskError = 0;

            switch (TASKSTATE(pwd)) {
            case TASKBUSY:
#if DBG
                dprintf2(("Task is BUSY"));
#endif

//!!            if (pwd->wTaskError = mwGetDevice(pwd)) {
//!!                mwDelayedNotify(pwd, MCI_NOTIFY_FAILURE);
//!!                break;
//!!            }
//!!            Leave(pwd);
//!!            mmTaskBlock(NULL);
//!!            Enter(pwd);

                pwd->wAudioBuffers = AllocateBuffers(pwd);
                if (pwd->wAudioBuffers >= MinAudioSeconds) {
                    DWORD   dPosition;

                    if (pwd->Direction == output)
                        wBuffersOutstanding = PlayFile(pwd);
                    else
                        wBuffersOutstanding = RecordFile(pwd);

                    /*
                    **  If we've played everything don't rely on the wave
                    **  device because for compressed files it only gives
                    **  and approximate answer based on the uncompressed
                    **  format
                    */

                    if (pwd->Direction == output && wBuffersOutstanding == 0) {
                        dPosition = pwd->dTo;
                        SetCurrentPosition(pwd, RoundedBytePosition(pwd, dPosition, MCI_FORMAT_BYTES));
                    } else {
                        if (!GetPlayRecPosition(pwd, &dPosition,  MCI_FORMAT_BYTES))
                            SetCurrentPosition(pwd, RoundedBytePosition(pwd, dPosition, MCI_FORMAT_BYTES));
                    }

                    ReleaseWaveBuffers(pwd);

                    if (pwd->wTaskError)
                        wNotification = MCI_NOTIFY_FAILURE;
                    else if (pwd->dCur >= pwd->dTo)
                        wNotification = MCI_NOTIFY_SUCCESSFUL;
                    else
                        wNotification = MCI_NOTIFY_ABORTED;

                } else {
                    dprintf1(("MinAudioSeconds <= wAudioBuffers  MCI_NOTIFY_FAILURE"));
                    pwd->wTaskError = MCIERR_OUT_OF_MEMORY;
                    wNotification = MCI_NOTIFY_FAILURE;
                    wBuffersOutstanding = 0;
                }

                FreeBuffers(pwd);
                ADDMODE(pwd, MODE_CLEANUP);

                if (!ISMODE(pwd, MODE_WAIT) || !pwd->wTaskError) {
                    REMOVEMODE(pwd, MODE_WAIT);
                    mwDelayedNotify(pwd, wNotification);
                } else
                    mwSaveCallback(pwd, NULL);

                mwFreeDevice(pwd);

                for (; wBuffersOutstanding; wBuffersOutstanding--) {
                    while (TaskBlock() != WM_USER) {
                    }
                }
                break;

            case TASKCLOSE:
#if DBG
                dprintf2(("Task is CLOSING"));
#endif
                break;

            case TASKSAVE:
                dprintf2(("mwTask: saving data"));
                mwSaveData(pwd);
                break;

            case TASKDELETE:
                dprintf2(("mwTask: deleting data"));
                mwDeleteData(pwd);
                break;

            case TASKCUT:
                dprintf2(("mwTask: Task CUT"));
                break;
            }
        }
        dprintf2(("Closing file %ls", pwd->aszFile));
        mwCloseFile(pwd);

    } else {
        dprintf1(("Cannot open file %ls", pwd->aszFile));
        SETTASKSTATE(pwd, TASKNONE);
    }

#if DBG
    dprintf2(("Background thread %x is terminating\r\n", pwd->hTask));
#endif
    pwd->hTask = 0; //NULL;

    LeaveCrit();
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwCloseDevice |
    This function is called in response to an <m>MCI_CLOSE_DRIVER<d>
    message, and is used to close the MCI device.  Note that since the
    message can be sent to an MCI device that just represents the wave
    device itself, and has no file or <t>WAVEDESC<d>, it must check and
    return success in that instance.

    If there is actually data attached to this MCI device, the function
    checks to determine if a task was successfully created for the device.
    This might not have happened if the <m>MCI_OPEN_DRIVER<d> message
    failed to create a task, or the wave device itself was being opened,
    and no task was created.

    If there is a task, it must first stop any playback or recording that
    is in progress, then inform the task that it must cease and desist by
    setting the task state to TASKCLOSE and signalling the task.  The
    function must then wait for the task to respond by terminating itself.
    Note that the last thing the task does is set <t>WAVEDESC.hTask<d> to
    NULL, thus allowing the wait loop to exit.

    After optionally terminating the task, the wave description data is
    freed, and the function returns success.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns zero on success, else an MCI error code.  The function cannot
    at this time fail.

@xref   mwOpenDevice.
*/

PRIVATE UINT PASCAL NEAR mwCloseDevice(
    PWAVEDESC   pwd)
{
    if (pwd) {
        if (pwd->hTask) {
            mwStop(pwd);
            SETTASKSTATE(pwd, TASKCLOSE);
            TaskSignal(pwd->hTask, WTM_STATECHANGE);
            TaskWaitComplete(pwd->hTaskHandle);
            //while (pwd->hTask)
            //    mmYield(pwd);
            dprintf3(("Waiting for task thread to complete"));
        } else {
        }
        LocalFree(pwd);

    }
    return 0;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwOpenDevice |
    This function is called in response to an <m>MCI_OPEN_DRIVER<d>
    message, and is used to open the MCI device, optionally allocating
    a wave description block and create a background playback and
    recording task.

    It is possible that the MCI device is being opened for information
    only.  In this case there is no element name or ID and no wave
    description block need be allocated.

    If an element or element ID is present, the wave descriptor block is
    allocated and initialized with the current device, default time
    formate, etc.  After storing either the element, or element ID, the
    secondary task is created, and the task state is set to TASKINIT.

    The first thing that the task must do is try and open the file
    specified in the descriptor block passed to the task function.  The
    calling task must yield upon successfully creating the task until
    the task has opened the wave file and entered its idle loop, or has
    failed the open and returned and error.  An error state indicates
    that the wave descriptor block is to be freed.

    Note that driver data, which is where the pointer to the wave
    descriptor data is stored, is not guarenteed to be initialized to any
    specific value, and must be initialized even if no descriptor block is
    being allocated.  To be to be on the safe side, the driver data is set
    to NULL on an error.  This data parameter can then be accessed by the
    MCI driver through the <p>wDeviceID<d> when processing driver messages.

@parm   DWORD | dFlags |
    Contains the open flags passed with the message (see mmsystem.h).
    The following flags are responded to specifically.  All others are
    ignored.

@flag   MCI_OPEN_ELEMENT |
    Specifies that a file name is present in the open message.  This is
    mutually incompatible with the MCI_OPEN_ELEMENT_ID flag.  If neither
    of these flags exist, no wave descriptor data or secondary task will
    be created.

@flag   MCI_OPEN_ELEMENT_ID |
    Specifies that an alternate IO function is present in the open
    message.  This is mutually incompatible with the MCI_OPEN_ELEMENT
    flag.  If neither of these flags exist, no wave descriptor data or
    secondary task will be created.

@flag   MCI_OPEN_SHAREABLE |
    Specifies that the more than one task can communicate with this
    MCI device.  The wave driver does not support this.

@flag   MCI_WAVE_OPEN_BUFFER |
    Indicates that the <e>MCI_OPEN_PARMS.dwBufferSeconds<d> parameter
    contains the number of seconds of audio to allow to be buffered.
    This number is constrained by the minimum and maximum numbers
    contained in mciwave.h.  If this flag is not present, the default
    value is used, which may have been set during driver open time.

@parm   <t>LPMCI_OPEN_PARMS<d> | lpOpen |
    Open parameters (see mmsystem.h)

@parm   MCIDEVICEID | wDeviceID |
    The MCI Driver ID for the new device.

@rdesc  Returns zero on success, else an MCI error code.

@xref   mwCloseDevice.
*/

PRIVATE UINT PASCAL NEAR mwOpenDevice(
    DWORD   dFlags,
    LPMCI_WAVE_OPEN_PARMS   lpOpen,
    MCIDEVICEID wDeviceID)
{
    UINT    wReturn;
    UINT    wSeconds;

    wReturn = 0;

    if (!(dFlags & MCI_WAVE_OPEN_BUFFER))
        wSeconds = wAudioSeconds;
    else {
        wSeconds = lpOpen->dwBufferSeconds;
        if ((wSeconds > MaxAudioSeconds) || (wSeconds < MinAudioSeconds))
            wReturn = MCIERR_OUTOFRANGE;
    }

    if (!wReturn && (dFlags & (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID))) {
        PWAVEDESC   pwd;

        if (dFlags & MCI_OPEN_SHAREABLE)
            wReturn = MCIERR_UNSUPPORTED_FUNCTION;

        else if ((dFlags & (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID)) == (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID))
            return MCIERR_FLAGS_NOT_COMPATIBLE;

//@@@
//@@@   else if ((dFlags & MCI_OPEN_ELEMENT_ID) && !ValidateIOCallback(lpOpen))
//@@@       return MCIERR_MISSING_PARAMETER;
//@@@ See notes re. ValidateIOCallback at the top of this file
//@@@

        else if (!(pwd = (PWAVEDESC)LocalAlloc(LPTR, sizeof(WAVEDESC))))
            wReturn = MCIERR_OUT_OF_MEMORY;

        else {
            pwd->wDeviceID = wDeviceID;
            pwd->dTimeFormat = MCI_FORMAT_MILLISECONDS;
            pwd->Direction = output;
            pwd->idOut = (DWORD)WAVE_MAPPER;
            pwd->idIn = (DWORD)WAVE_MAPPER;
            pwd->wSeconds = wSeconds;
            pwd->hTempBuffers = INVALID_HANDLE_VALUE;

            if (dFlags & MCI_OPEN_ELEMENT_ID)
                pwd->pIOProc = (LPMMIOPROC)(lpOpen + 1);

            if (*lpOpen->lpstrElementName) {
                MMIOINFO    mmioInfo;

                pwd->aszFile[ (sizeof(pwd->aszFile) / sizeof(WCHAR)) - 1] = '\0';
                wcsncpy( pwd->aszFile,
                         lpOpen->lpstrElementName,
                         ( sizeof(pwd->aszFile) / sizeof(WCHAR) ) - 1
                       );
                InitMMIOOpen(pwd, &mmioInfo);
                if (!mmioOpen(pwd->aszFile, &mmioInfo, MMIO_PARSE))
                    wReturn = MCIERR_FILENAME_REQUIRED;
            }

            if (!wReturn) {
                SETTASKSTATE(pwd, TASKINIT);

                switch (mmTaskCreate(mwTask, &pwd->hTaskHandle, (DWORD_PTR)pwd)) {
                case 0:
                    while (ISTASKSTATE(pwd, TASKINIT)) {
                        mmYield(pwd);
                    }

                    if (ISTASKSTATE(pwd,TASKNONE)) {
                        // Task detected an error and stopped itself
                        wReturn = pwd->wTaskError;
                        TaskWaitComplete(pwd->hTaskHandle);  // Wait for thread to completely terminate
                    }
                    else {
                        mciSetDriverData(wDeviceID, (DWORD_PTR)pwd);
                    }
                    break;

                case TASKERR_OUTOFMEMORY:
                case TASKERR_NOTASKSUPPORT:
                default:
                    wReturn = MCIERR_OUT_OF_MEMORY;
                    break;
                }
            }

            if (wReturn) {
                LocalFree(pwd);
            } else {
            }
        }
    }
    return wReturn;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | VerifyRangeStart |
    Verifies and rounds range start value.  Note that the internal byte
    format time is converted to the current external time format in order
    to compensate for rounding errors.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dStart |
    Value to verify.

@rdesc  Returns the verified value, else -1 on range error.
*/

PRIVATE DWORD PASCAL NEAR VerifyRangeStart(
    PWAVEDESC   pwd,
    DWORD   dStart)
{
    if (dStart <= bytes2time(pwd, pwd->dSize, pwd->dTimeFormat)) {
        dStart = RoundedBytePosition(pwd, dStart, pwd->dTimeFormat);
        if (dStart > pwd->dSize)
            dStart = pwd->dSize;
    } else
        dStart = (DWORD)(-1);

    return dStart;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | VerifyRangeEnd |
    Verifies and rounds range end value.  Note that the internal byte
    format time is converted to the current external time format in order
    to compensate for rounding errors.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dEnd |
    Value to verify.

@parm   BOOL | fVerifyLength |
    Indicates that the value specified should be verified against the
    current file length.  This is not done in circumstances such as
    recording, where the length might need to be expanded beyond the
    current value.

@rdesc  Returns the verified value, else -1 on range error.
*/

PRIVATE DWORD PASCAL NEAR VerifyRangeEnd(
    PWAVEDESC   pwd,
    DWORD   dEnd,
    BOOL    fVerifyLength)
{
    DWORD   dTimeSize;

    dTimeSize = bytes2time(pwd, pwd->dSize, pwd->dTimeFormat);

    if (!fVerifyLength || (dEnd <= dTimeSize)) {
        if (dEnd == dTimeSize)
            dEnd = pwd->dSize;
        else {
            dEnd = RoundedBytePosition(pwd, dEnd, pwd->dTimeFormat);
            if (fVerifyLength && (dEnd > pwd->dSize))
                dEnd = pwd->dSize;
        }
    } else
        dEnd = (DWORD)(-1);

    return dEnd;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   UINT | SetRange |
    This function sets the "to" and "from" range for recording or playback
    after validating them.  Note that the "from" parameter defaults to the
    current position, but the "to" parameter defaults to either the end of
    the file for playback, or infinity for recording.

    If either the "from" parameter is specified, or the "to" position is
    different than the current parameter, abort notification is attempted,
    else supersede notification is attempted later.  The "to" position
    could be changed by merely not specifying the MCI_TO flag if a current
    "to" position is in effect that does not specify the end of the data.

@parm   <t>PWAVEDESC<d> | pwd |
    Points to the data block for this device.

@parm   DWORD | dFlags |
    Contains the flags used to determine the parameters set in the
    <p>lpplay<d> structure.

@flag   MCI_FROM |
    Indicates the <e>MCI_PLAY_PARMS.dwFrom<d> contains a starting point.
    If this flag is not specified, the parameter defaults to the current
    position.  Setting this flag has the effect of resetting the wave
    output device so that any hold condition is signalled to continue.

    This is also important in that for output, it resets the wave device's
    byte counter of how much data has actually been processed.  This
    enables an accurate count to be retrieved when playback is either
    stopped, or finishes normally.

@flag   MCI_TO |
    Indicates the <e>MCI_PLAY_PARMS.dwTo<d> contains an ending point.
    If this flag is not specified, the parameter defaults to either the
    end of the file for playback, or infinity for recording.

@parm   <t>LPMCI_PLAY_PARMS<d> | lpplay |
    Optionally points to a structure containing "to" and "from" parameters.

@rdesc  Returns 0 on success, or MCIERR_OUTOFRANGE if a "to" or "from"
    parameter is not within the current file length, or "to" is less than
    "from".

@xref   mwSetup.
*/

PRIVATE UINT PASCAL NEAR SetRange(
    PWAVEDESC   pwd,
    DWORD   dFlags,
    LPMCI_PLAY_PARMS    lpPlay)
{
    DWORD   dFromBytePosition;
    DWORD   dToBytePosition;

    if (dFlags & MCI_FROM) {
        dFromBytePosition = VerifyRangeStart(pwd, lpPlay->dwFrom);
        if (dFromBytePosition == -1)
            return MCIERR_OUTOFRANGE;
    } else
        dFromBytePosition = pwd->dFrom;

    if (dFlags & MCI_TO) {
        dToBytePosition = VerifyRangeEnd(pwd, lpPlay->dwTo, pwd->Direction == output);
        if (dToBytePosition == -1)
            return MCIERR_OUTOFRANGE;
    } else if (pwd->Direction == output)
        dToBytePosition = pwd->dSize;
    else
        dToBytePosition = RoundedBytePosition(pwd, INFINITEFILESIZE, MCI_FORMAT_BYTES);

    if ((dFlags & MCI_TO) && !(dFlags & MCI_FROM) && (pwd->dCur > dToBytePosition)) {
        UINT    wErrorRet;

        if (0 != (wErrorRet = GetPlayRecPosition(pwd, &dFromBytePosition, MCI_FORMAT_BYTES)))
            return wErrorRet;
        if (dToBytePosition < dFromBytePosition)
            return MCIERR_OUTOFRANGE;
        SetCurrentPosition(pwd, RoundedBytePosition(pwd, dFromBytePosition, MCI_FORMAT_BYTES));
        ReleaseWaveBuffers(pwd);
    } else {
        if (dToBytePosition < dFromBytePosition)
            return MCIERR_OUTOFRANGE;
        if (dFlags & MCI_FROM) {
            SetCurrentPosition(pwd, dFromBytePosition);
            ReleaseWaveBuffers(pwd);
        }
    }

    if ((dFlags & MCI_FROM) || (dToBytePosition != pwd->dTo))
        mwDelayedNotify(pwd, MCI_NOTIFY_ABORTED);
    pwd->dTo = dToBytePosition;

    return 0;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwSetup |
    This function is called in response to an <m>MCI_PLAY<d>,
    <m>MCI_RECORD<d>, and indirectly through <m>MCI_CUE<d> and
    <m>MCI_STATUS<d> messages, and is used to set up for playing or
    recording a wave file and then signals the background task to begin.

    Before trying to set up for recording or playback, the input or output
    direction must match the request that is being made.  If it does not
    currently match, the current command, if any, is stopped, and the
    direction indicator is reset.  This action might cause an abort
    notification to occur.

    If however, the current direction matches the requested direction,
    the function must still wait if the task is currently in Cleanup mode
    and ignoring new commands.  This check does not need to be performed
    if the stop command is sent, as <f>mwStop<d> performs the same logic.
    If the task is currently in Idle state, the Cleanup mode is probably
    set, but the loop will immediately drop out anyway.

    If the start and end points are successfully parsed, the function
    begins either playback or recording.  If the task is idle, it must
    set the TASKBUSY state, else it must check to see if the task needs to
    be possibly un-paused by starting the wave device.  It does not check
    for a MODE_PAUSED or MODE_CUED state, as any <f>WaveOutReset<d> or
    <f>WaveInReset<d> will stop output or input.

    If the task was idle, the act of opening a wave device sends a signal
    to the task, and it is ready to go as soon as this task yields.  Else
    the task was already running, and this task just needs to yield.

    In the case of playback, the task may be additionally blocked by a
    previous Hold command, for which the function must send an extra
    signal to the task.

    For recording, there are two modes, Insert and Overwrite.  One can
    change between the two modes of recording with what normally is only
    a very slight delay between switching.  A check must be made to see if
    the task is currently recording, and if that method of recording is
    being changed (from Insert to Overwrite, or visa versa).  If so, then
    the current position must be logged, and the wave buffers released.
    This is so that only data up to this point is recorded in the previous
    method, and all new data is recorded in the new method.  Notice that
    in the recording function, if a new command is received, no new buffers
    are handed to the wave device until all the old buffers are dealt with
    and the new command is enacted.

    If the command flags where successfully set, and all needed signalling
    and un-pausing was performed, then before the task can be allowed to
    run, the notification parameter must be set.  If the previous command
    was not cancelled by a Stop, then a superseded notification is sent,
    and the current notification status is saved.

    At this point, the background task is ready to be begun.  If the
    Wait flag has been set, the calling task must now yield until the
    background task is finished the command (which means different
    things for different commands), else it can just return to the caller
    without waiting.  As this is the driver wait loop, it must use the
    <f>mciDriverYield<d> function in order to execute the driver callback
    function (and thus process the Break key, or whatever the callback
    performs).

    In order to make return values from a Record or Play command with the
    wait flag act as other commands, there is a special Wait mode flag.
    This tells the background task that the calling task is waiting for it
    to complete.  If the background task encounters an error, it does not
    perform notification, but just returns to Idle state and allows the
    calling task to return the error that was encountered.

    If the wait loop is broken out of, then it can check the Wait mode
    flag to determine if it should return the background task error.  In
    the case of Cue and Hold, the Wait mode can be removed, and the task
    error would presumably be zero.

    Note that the task error is set to zero before doing the first call
    to <f>mciDriverYield<d>, just in case an interrupt is received before
    the background task has a chance to run at all.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dFlags |
    Play flags.

@flag   MCI_TO |
    This flag indicates that a TO parameter is present in the <p>lpPlay<d>
    parameter block.

@flag   MCI_FROM |
    This flag indicates that a FROM parameter is present in the
    <p>lpPlay<d> parameter block.

@flag   MCI_WAIT |
    Wait for command to complete.

@flag   MCI_NOTIFY |
    Notify upon command completion.

@flag   MCI_RECORD_OVERWRITE |
    This flag indicates the recording should overwrite existing data.

@flag   MCI_RECORD_INSERT |
    This flag indicates the recording should insert in existing data.  This
    is the default recording method.

@flag   MCI_MCIWAVE_PLAY_HOLD |
    This flag indicates that playback should not release buffers after
    the TO position has been release, but instead go into a Paused state.

@flag   MCI_MCIWAVE_CUE |
    This internal flag indicates that Recording or Playback is being cued.

@parm   <t>LPMCI_PLAY_PARMS<d> | lpPlay |
    Play parameters.

@parm   DIRECTION | Direction |
    Indicates the direction being set up for.

@flag   output |
    Playback.

@flag   input |
    Recording.

@rdesc  Returns 0 if playback or recording was started, else an MCI error.
*/

PRIVATE UINT PASCAL NEAR mwSetup(
    PWAVEDESC   pwd,
    DWORD   dFlags,
    LPMCI_PLAY_PARMS    lpPlay,
    DIRECTION   Direction)
{
    UINT    wReturn;
    register UINT   wMode;

    wReturn = 0;

    if (Direction != pwd->Direction) {
        mwStop(pwd);
        pwd->Direction = Direction;
    } else if (ISMODE(pwd, MODE_CLEANUP)) {
        while (!ISTASKSTATE(pwd, TASKIDLE))
            mmYield(pwd);
    }

    if (0 != (wReturn = SetRange(pwd, dFlags, lpPlay)))
        return wReturn;

    wMode = COMMAND_NEW;

    if (dFlags & MCI_MCIWAVE_PLAY_HOLD)
        wMode |= COMMAND_HOLD;

    if (dFlags & MCI_MCIWAVE_CUE)
        wMode |= COMMAND_CUE;

    if (dFlags & MCI_WAIT)
        wMode |= MODE_WAIT;

    if (pwd->Direction == output) {
        wMode |= COMMAND_PLAY;

        if (ISTASKSTATE(pwd, TASKIDLE)) {
            if (!(wReturn = mwGetDevice(pwd)))
                SETTASKSTATE(pwd, TASKBUSY);
                TaskSignal(pwd->hTask, WTM_STATECHANGE);
        } else {
            if (ISMODE(pwd, COMMAND_PLAY)) {
                if (0 != (wReturn = waveOutRestart(pwd->hWaveOut)))
                    return wReturn;
                else
                    wMode |= MODE_PLAYING;
            }
            if (ISMODE(pwd, MODE_HOLDING))
                TaskSignal(pwd->hTask, WTM_STATECHANGE);
        }

    } else if ((dFlags & (MCI_RECORD_OVERWRITE | MCI_RECORD_INSERT)) == (MCI_RECORD_OVERWRITE | MCI_RECORD_INSERT))
        wReturn = MCIERR_FLAGS_NOT_COMPATIBLE;
    else {
        if (dFlags & MCI_RECORD_OVERWRITE)
            wMode |= COMMAND_OVERWRITE;
        else
            wMode |= COMMAND_INSERT;

        if (ISTASKSTATE(pwd, TASKIDLE)) {
            if (!(wReturn = mwGetDevice(pwd)))
                SETTASKSTATE(pwd, TASKBUSY);
                TaskSignal(pwd->hTask, WTM_STATECHANGE);

        } else if (ISMODE(pwd, COMMAND_INSERT | COMMAND_OVERWRITE)) {

            if ((ISMODE(pwd, COMMAND_OVERWRITE)
             && !(dFlags & MCI_RECORD_OVERWRITE))
             || (ISMODE(pwd, COMMAND_INSERT)
             && (dFlags & MCI_RECORD_OVERWRITE))) {
                DWORD   dPosition;

                GetPlayRecPosition(pwd, &dPosition,  MCI_FORMAT_BYTES);
                SetCurrentPosition(pwd, RoundedBytePosition(pwd, dPosition, MCI_FORMAT_BYTES));
                ReleaseWaveBuffers(pwd);
            }

            if (!(wReturn = waveInStart(pwd->hWaveIn)))
                if (ISMODE(pwd, COMMAND_INSERT))
                    wMode |= MODE_INSERT;
                else
                    wMode |= MODE_OVERWRITE;
        }
    }

    if (!wReturn) {
        if (dFlags & MCI_NOTIFY) {
            mwDelayedNotify(pwd, MCI_NOTIFY_SUPERSEDED);
            mwSaveCallback(pwd, (HWND)(lpPlay->dwCallback));
        }
        SETMODE(pwd, wMode);
        if (dFlags & MCI_WAIT) {
            pwd->wTaskError = 0;

            //
            // Wait for the device task to complete the function
            //
            for (;;) {
               LeaveCrit();
               if (mciDriverYield(pwd->wDeviceID)) {
                   EnterCrit();
                   break;
               }
               Sleep(10);
               EnterCrit();

               if (ISTASKSTATE(pwd, TASKIDLE) ||
                   ISMODE(pwd, MODE_HOLDING | MODE_CUED)) {
                   break;
               }
            }

            if (ISMODE(pwd, MODE_WAIT)) {
                REMOVEMODE(pwd, MODE_WAIT);
                wReturn = pwd->wTaskError;
            }
        }
    } else
        mwStop(pwd);

    return wReturn;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwPause |
    This function is called in response to an <m>MCI_PAUSE<d> message, and
    is used to pause wave file output or input.  By calling the
    <f>waveOutPause<d> or <f>waveInStop<d> function, all buffers added to
    the driver's queue will not be used, and thus eventually cause the
    background task to block itself waiting for buffers to be released.

    Note that this is only done if playback or recording is currently
    in progress, and cueing is not also being performed.  If the Cue
    command has been used, then the wave device is already in a paused
    state.  Also note that pausing can only be successfully performed
    if playback or recording is currently being performed, and the cleanup
    state has not been entered.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dFlags |
    Contains the pause flags passed with the message

@flag   MCI_WAIT |
    Wait for command to complete.

@flag   MCI_NOTIFY |
    Notify upon command completion.

@rdesc  Returns 0 if playback or recording was paused, else an MCI error.
*/

PRIVATE UINT PASCAL NEAR mwPause(
    PWAVEDESC   pwd,
    DWORD   dFlags)
{
    UINT    wReturn;

    if (dFlags & ~(MCI_NOTIFY | MCI_WAIT))
        return MCIERR_UNRECOGNIZED_KEYWORD;

    if (ISTASKSTATE(pwd, TASKBUSY) && !ISMODE(pwd, COMMAND_CUE | MODE_HOLDING)) {
        wReturn = 0;
        if (!ISMODE(pwd, MODE_PAUSED)) {
            if (ISMODE(pwd, COMMAND_PLAY)) {
                if (ISMODE(pwd, MODE_CLEANUP))
                    wReturn = MCIERR_NONAPPLICABLE_FUNCTION;
                else
                    wReturn = waveOutPause(pwd->hWaveOut);
            } else if (ISMODE(pwd, MODE_CLEANUP))
                wReturn = MCIERR_NONAPPLICABLE_FUNCTION;
            else
                wReturn = waveInStop(pwd->hWaveIn);
            if (!wReturn)
                ADDMODE(pwd, MODE_PAUSED);
        }
    } else
        wReturn = MCIERR_NONAPPLICABLE_FUNCTION;

    return wReturn;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwResume |
    This function is called in response to an <m>MCI_RESUME<d> message, and
    is used to resume wave file output or input if it was previously
    paused from output or input using MCI_PAUSE.

    Note that this is only done if playback or recording is currently
    paused, and cueing is not also being performed.  If the Cue command
    or Play Hold command is currently in effect, then there is no Play or
    Record command to resume, and the command is ignored.  If playback
    or recording is currently in effect, the command is ignored.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dFlags |
    Contains the resume flags passed with the message

@flag   MCI_WAIT |
    Wait for command to complete.

@flag   MCI_NOTIFY |
    Notify upon command completion.

@rdesc  Returns 0 if playback or recording was resumed, else an MCI error.
*/

PRIVATE UINT PASCAL NEAR mwResume(
    PWAVEDESC   pwd,
    DWORD   dFlags)
{
    UINT    wReturn;

    if (dFlags & ~(MCI_NOTIFY | MCI_WAIT))
        return MCIERR_UNRECOGNIZED_KEYWORD;

    if (ISTASKSTATE(pwd, TASKBUSY)) {
        wReturn = 0;
        if (!ISMODE(pwd, COMMAND_CUE) && ISMODE(pwd, MODE_PAUSED)) {
            if (ISMODE(pwd, COMMAND_PLAY))
                wReturn = waveOutRestart(pwd->hWaveOut);
            else
                wReturn = waveInStart(pwd->hWaveIn);
            if (!wReturn)
                REMOVEMODE(pwd, MODE_PAUSED);
        }
    } else
        wReturn = MCIERR_NONAPPLICABLE_FUNCTION;

    return wReturn;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwCue |
    This function is called in response to an <m>MCI_CUE<d> message, and
    is used to cue wave file input or output.  Cueing for playback simply
    causes the output device to be opened but paused, and all the buffers
    to fill.  Cueing for record puts the device into a level checking loop,
    using one buffer at a time.

    Note that the internal flag MCI_MCIWAVE_CUE is passed to the
    <f>mwSetup<d> function in order to indicate that it should use the Cue
    command when starting playback or recording.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dFlags |
    Contains the flags used to cue the MCI device.

@flag   MCI_WAVE_INPUT |
    Indicates that the MCI device should be cued for input.

@flag   MCI_WAVE_OUTPUT |
    Indicates that the MCI device should be cued for output.  This is the
    default case.

@flag   MCI_WAIT |
    Wait for command to complete.

@flag   MCI_NOTIFY |
    Notify upon command completion.

@parm   <t>LPMCI_GENERIC_PARMS<d> | lpGeneric |
    Far pointer to parameter block for cue.

@rdesc  Returns 0 if playback or recording was cued, else an MCI error.
*/

PRIVATE UINT PASCAL NEAR mwCue(
    PWAVEDESC   pwd,
    DWORD   dFlags,
    LPMCI_GENERIC_PARMS lpGeneric)
{
    MCI_PLAY_PARMS  mciPlay;
    DWORD   dWaveFlags;
    DIRECTION   Direction;

    dWaveFlags = dFlags & ~(MCI_NOTIFY | MCI_WAIT);
    if (dWaveFlags != (dWaveFlags & (MCI_WAVE_INPUT | MCI_WAVE_OUTPUT)))
        return MCIERR_UNRECOGNIZED_KEYWORD;

    switch (dWaveFlags) {
    case MCI_WAVE_INPUT:
        Direction = input;
        break;

    case MCI_WAVE_OUTPUT:
    case 0:
        Direction = output;
        break;

    default:
        return MCIERR_FLAGS_NOT_COMPATIBLE;
    }

    if (ISTASKSTATE(pwd, TASKBUSY)) {
        if (ISMODE(pwd, COMMAND_CUE) && (pwd->Direction == Direction)) {
            mwDelayedNotify(pwd, MCI_NOTIFY_SUPERSEDED);
            if (dFlags & MCI_NOTIFY)
                mwImmediateNotify(pwd->wDeviceID, lpGeneric);
            return 0L;
        }
        return MCIERR_NONAPPLICABLE_FUNCTION;
    }

    if (lpGeneric && (dFlags & MCI_NOTIFY))
        mciPlay.dwCallback = lpGeneric->dwCallback;

    dFlags &= ~(MCI_WAVE_INPUT | MCI_WAVE_OUTPUT);
    return mwSetup(pwd, dFlags | MCI_MCIWAVE_CUE, &mciPlay, Direction);
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwSeek |
    This function is called in response to an <m>MCI_SEEK<d> message, and
    is used to seek to position in wave file.

    This function has the side effect of stopping any current playback or
    recording.  If successful, the current position is set to the
    position specified.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dFlags |
    Contains the flags for seek message.

@flag   MCI_TO |
    This flag indicates that the parameter block contains the position to
    seek to.

@flag   MCI_SEEK_TO_START |
    This flag indicates that the current position should be moved to the
    start of the media.

@flag   MCI_SEEK_TO_END |
    This flag indicates that the current position should be moved to the
    end of the media.

@flag   MCI_WAIT |
    Wait for command to complete.

@flag   MCI_NOTIFY |
    Notify upon command completion.

@parm   <t>LPMCI_SEEK_PARMS<d> | lpmciSeek |
    Contains the seek parameters.

@rdesc  Returns 0 if the current position was successfully set, else an MCI
    error.
*/

PRIVATE UINT PASCAL NEAR mwSeek(
    PWAVEDESC   pwd,
    DWORD   dFlags,
    LPMCI_SEEK_PARMS    lpmciSeek)
{
    DWORD   dToBytePosition;

    dFlags &= ~(MCI_NOTIFY | MCI_WAIT);

    if (!dFlags)
        return MCIERR_MISSING_PARAMETER;

    if (dFlags != (dFlags & (MCI_TO | MCI_SEEK_TO_START | MCI_SEEK_TO_END)))
        return MCIERR_UNRECOGNIZED_KEYWORD;

    switch (dFlags) {
    case MCI_TO:
        dToBytePosition = VerifyRangeEnd(pwd, lpmciSeek->dwTo, TRUE);
        if (dToBytePosition == -1)
            return MCIERR_OUTOFRANGE;
        break;

    case MCI_SEEK_TO_START:
        dToBytePosition = 0;
        break;

    case MCI_SEEK_TO_END:
        dToBytePosition = pwd->dSize;
        break;

    default:
        return MCIERR_FLAGS_NOT_COMPATIBLE;
    }

    mwStop(pwd);
    SetCurrentPosition(pwd, dToBytePosition);
    return 0;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    DWORD | mwStatus |
    This function is called in response to an <m>MCI_STATUS<d> message, and
    is used to return numeric status information, including resource IDs.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   UINT | dFlags |
    Contains the status flags.

@flag   MCI_STATUS_ITEM |
    This flag must be set, and specifies that a specific item is being
    queried.

@flag   MCI_TRACK |
    This flag specifies that track information is being queried of the
    item.  This flag is only valid with Position and Status queries.

@parm   <t>LPMCI_STATUS_PARMS<d> | lpStatus |
    Status parameters.

@flag   MCI_STATUS_POSITION |
    Queries the current position.  If the Track flag is set, then the
    starting position of the track is being queried.  As there is only
    one track, and it starts at the beginning, this returns zero.  Else
    if the Start flag is set, the starting position of the audio is
    returned.  Else the current position within the wave file is returned.

@flag   MCI_STATUS_LENGTH |
    Queries the current length.  If the Track flag is set, then the length
    of the track is being queried.  As there is only one track, the track
    number must be one.  In either case, the length of the wave file is
    returned.

@flag   MCI_STATUS_NUMBER_OF_TRACKS |
    Queries the number of track.  There is always one track.

@flag   MCI_STATUS_CURRENT_TRACK |
    Queries the current of track.  As there is one track, this returns one.

@flag   MCI_STATUS_READY |
    Queries as to whether the MCI wave device can receive commands.  This
    is always TRUE.

@flag   MCI_STATUS_MODE |
    Queries the current mode of the MCI wave device instance.  This can be
    one of Paused, Playing, Recording, or Stopped.

@flag   MCI_STATUS_MEDIA_PRESENT |
    Queries as to whether there is media present.  Since there must be a
    wave file present to enter this function, this always returns TRUE.

@flag   MCI_STATUS_TIME_FORMAT |
    Queries the current time format.  This can be one of Bytes, Samples,
    or Milliseconds.

@flag   MCI_WAVE_STATUS_FORMATTAG |
    Queries the current format tag.  There is only PCM now, but it will
    return identifiers for other tag formats.

@flag   MCI_WAVE_STATUS_CHANNELS |
    Queries the number of channels.  This is one or two.

@flag   MCI_WAVE_STATUS_SAMPLESPERSEC |
    Queries the number of samples per second for playback and recording.

@flag   MCI_WAVE_STATUS_AVGBYTESPERSEC |
    Queries the average number of bytes per second for playback and
    recording.

@flag   MCI_WAVE_STATUS_BLOCKALIGN |
    Queries the current block alignment.

@flag   MCI_WAVE_STATUS_BITSPERSAMPLE |
    Queries the number of bits per sample.

@flag   MCI_WAVE_INPUT |
    Queries the current input wave device in use, if any.  If no device
    suits the current format, an error is returned.  If a device suits
    the current format, but the MCI wave device instance is not recording,
    then an error is also returned.  Else the device in use is returned.

@flag   MCI_WAVE_OUTPUT |
    Queries the current output wave device in use, if any.  If no device
    suits the current format, an error is returned.  If a device suits
    the current format, but the MCI wave device instance is not playing,
    then an error is also returned.  Else the device in use is returned.

@flag   MCI_WAVE_STATUS_LEVEL |
    Returns the current input level, if possible.  Before checking the
    task state, the function must make sure the task is not in Cleanup
    mode.  If it is, it must wait for the task to enter Idle state before
    sending new commands.  If the task is currently busy, and in-use error
    is returned.  If the task is idle, recording is Cued.  The function
    then waits for the background task to enter the Cued state (which it
    might have already been in), and retrieves the level sample.

@flag   MCI_WAIT |
    Wait for command to complete.

@flag   MCI_NOTIFY |
    Notify upon command completion.

@rdesc  Returns 0 if the request status was successfully returned, else an MCI
    error.
*/

PRIVATE DWORD PASCAL NEAR mwStatus(
    PWAVEDESC   pwd,
    DWORD   dFlags,
    LPMCI_STATUS_PARMS  lpStatus)
{
    DWORD   dReturn;
    #ifdef _WIN64
    DWORD   dwPos;
    #endif

    dReturn = 0;
    dFlags &= ~(MCI_NOTIFY | MCI_WAIT);

    if (dFlags & MCI_STATUS_ITEM) {
        dFlags &= ~MCI_STATUS_ITEM;

        if ((dFlags & MCI_TRACK)
            && !(lpStatus->dwItem == MCI_STATUS_POSITION || lpStatus->dwItem == MCI_STATUS_LENGTH))
            return MCIERR_FLAGS_NOT_COMPATIBLE;

        else if ((dFlags & MCI_STATUS_START) && (lpStatus->dwItem != MCI_STATUS_POSITION))
            return MCIERR_FLAGS_NOT_COMPATIBLE;

        switch (lpStatus->dwItem) {
            UINT    wResource;

        case MCI_STATUS_POSITION:
            switch (dFlags) {
            case 0:
                #ifndef _WIN64
                dReturn = GetPlayRecPosition(pwd, &(lpStatus->dwReturn), pwd->dTimeFormat);
                #else
                dwPos = (DWORD)lpStatus->dwReturn;
                dReturn = GetPlayRecPosition(pwd, &dwPos, pwd->dTimeFormat);
                lpStatus->dwReturn = dwPos;
                #endif
                break;

            case MCI_TRACK:
                if (lpStatus->dwTrack != 1)
                    dReturn = MCIERR_OUTOFRANGE;
                else
                    lpStatus->dwReturn = 0L;
                break;

            case MCI_STATUS_START:
                lpStatus->dwReturn = 0L;
                break;

            default:
                dReturn = MCIERR_UNRECOGNIZED_KEYWORD;
                break;
            }
            break;

        case MCI_STATUS_LENGTH:
            switch (dFlags) {
            case 0:
                lpStatus->dwReturn = bytes2time(pwd, pwd->dSize, pwd->dTimeFormat);
                break;

            case MCI_TRACK:
                if (lpStatus->dwTrack != 1)
                    dReturn = MCIERR_OUTOFRANGE;
                else
                    lpStatus->dwReturn = bytes2time(pwd, pwd->dSize, pwd->dTimeFormat);
                break;

            default:
                dReturn = MCIERR_UNRECOGNIZED_KEYWORD;
                break;
            }
            break;

        case MCI_STATUS_NUMBER_OF_TRACKS:
        case MCI_STATUS_CURRENT_TRACK:
            lpStatus->dwReturn = 1L;
            break;

        case MCI_STATUS_READY:
            lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(TRUE, MCI_TRUE);
            dReturn = MCI_RESOURCE_RETURNED;
            break;

        case MCI_STATUS_MODE:
            if (ISTASKSTATE(pwd, TASKBUSY)) {
                if (ISMODE(pwd, MODE_PAUSED | COMMAND_CUE | MODE_HOLDING))
                    wResource = MCI_MODE_PAUSE;
                else if (ISMODE(pwd, COMMAND_PLAY))
                    wResource = MCI_MODE_PLAY;
                else
                    wResource = MCI_MODE_RECORD;
            } else
                wResource = MCI_MODE_STOP;
            lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(wResource, wResource);
            dReturn = MCI_RESOURCE_RETURNED;
            break;

        case MCI_STATUS_MEDIA_PRESENT:
            lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(TRUE, MCI_TRUE);
            dReturn = MCI_RESOURCE_RETURNED;
            break;

        case MCI_STATUS_TIME_FORMAT:
            wResource = LOWORD(pwd->dTimeFormat);
            lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(wResource, wResource + MCI_FORMAT_RETURN_BASE);
            dReturn = MCI_RESOURCE_RETURNED;
            break;

        case MCI_WAVE_STATUS_FORMATTAG:
            if (pwd->pwavefmt->wFormatTag == WAVE_FORMAT_PCM) {
                lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(WAVE_FORMAT_PCM, WAVE_FORMAT_PCM_S);
                dReturn = MCI_RESOURCE_RETURNED;
            } else
                lpStatus->dwReturn = MAKELONG(pwd->pwavefmt->wFormatTag, 0);
            break;

        case MCI_WAVE_STATUS_CHANNELS:
            lpStatus->dwReturn = MAKELONG(pwd->pwavefmt->nChannels, 0);
            break;

        case MCI_WAVE_STATUS_SAMPLESPERSEC:
            lpStatus->dwReturn = pwd->pwavefmt->nSamplesPerSec;
            break;

        case MCI_WAVE_STATUS_AVGBYTESPERSEC:
            lpStatus->dwReturn = pwd->pwavefmt->nAvgBytesPerSec;
            break;

        case MCI_WAVE_STATUS_BLOCKALIGN:
            lpStatus->dwReturn = MAKELONG(pwd->pwavefmt->nBlockAlign, 0);
            break;

        case MCI_WAVE_STATUS_BITSPERSAMPLE:

            if (pwd->pwavefmt->wFormatTag == WAVE_FORMAT_PCM)
                lpStatus->dwReturn = (((NPPCMWAVEFORMAT)(pwd->pwavefmt))->wBitsPerSample);
            else
                dReturn = MCIERR_UNSUPPORTED_FUNCTION;
            break;

        case MCI_WAVE_INPUT:

            if (pwd->idIn == WAVE_MAPPER) {
                lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(WAVE_MAPPER, WAVE_MAPPER_S);
                dReturn = MCI_RESOURCE_RETURNED;
            } else
                lpStatus->dwReturn = pwd->idIn;
            break;

        case MCI_WAVE_OUTPUT:

            if (pwd->idOut == WAVE_MAPPER) {
                lpStatus->dwReturn = (DWORD)MAKEMCIRESOURCE(WAVE_MAPPER, WAVE_MAPPER_S);
                dReturn = MCI_RESOURCE_RETURNED;
            } else
                lpStatus->dwReturn = pwd->idOut;
            break;

        case MCI_WAVE_STATUS_LEVEL:

            if (ISMODE(pwd, MODE_CLEANUP)) {
                while (!ISTASKSTATE(pwd, TASKIDLE))
                    mmYield(pwd);
            }

            if (ISTASKSTATE(pwd, TASKIDLE)) {
                pwd->Direction = input;
                TaskSignal(pwd->hTask, WTM_STATECHANGE);

                if (0 != (dReturn = mwGetDevice(pwd)))
                    break;

                SETMODE(pwd, COMMAND_NEW | COMMAND_INSERT | COMMAND_OVERWRITE | COMMAND_CUE);
                SETTASKSTATE(pwd, TASKBUSY);

            } else if (!ISMODE(pwd, COMMAND_INSERT | COMMAND_OVERWRITE)
                    || !ISMODE(pwd, COMMAND_CUE)) {

                dReturn = MCIERR_WAVE_INPUTSINUSE;
                break;
            }

            while (!ISMODE(pwd, MODE_CUED) && !ISTASKSTATE(pwd, TASKIDLE))
                mmYield(pwd);

            if (pwd->wTaskError)
                dReturn = pwd->wTaskError;
            else
                lpStatus->dwReturn = pwd->dLevel;

            break;

        default:
            dReturn = MCIERR_UNSUPPORTED_FUNCTION;
            break;
        }
    } else
        dReturn = MCIERR_MISSING_PARAMETER;

    return dReturn;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwSet |
    This function is called in response to an <m>MCI_SET<d> message, and
    is used to set the specified parameters in the MCI device information
    block.  Note that format changes can only be performed on a file with
    no data, as data conversion is not performed.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   UINT | dFlags |
    Contains the status flags.

@flag   MCI_WAVE_INPUT |
    Sets the input wave device to be used to the specified device ID.
    This causes playback and recording to be stopped.

@flag   MCI_WAVE_OUTPUT |
    Sets the output wave device to be used to the specified device ID.
    This causes playback and recording to be stopped.

@flag   MCI_WAVE_SET_ANYINPUT |
    Enables recording to use any wave input device.

@flag   MCI_WAVE_SET_ANYOUTPUT |
    Enables recording to use any wave input device.

@flag   MCI_SET_TIME_FORMAT |
    Sets the time format used when interpreting or returning time-based
    command arguments.  Note that the time format can only be set to bytes
    if the file format is currently PCM, it does not care if

@flag   MCI_WAVE_SET_FORMATTAG |
    Sets the wave format tag.  This causes playback and recording to be
    stopped, and saves a copy of the current wave format header in case
    the new format is not valid for either recording or playback.

@flag   MCI_WAVE_SET_CHANNELS |
    Sets the number of channels.  This causes playback and recording to be
    stopped, and saves a copy of the current wave format header in case
    the new format is not valid for either recording or playback.

@flag   MCI_WAVE_SET_SAMPLESPERSEC |
    Sets the number of samples per second for recording and playback.  This
    causes playback and recording to be stopped, and saves a copy of the
    current wave format header in case the new format is not valid for
    either recording or playback.

@flag   MCI_WAVE_SET_AVGBYTESPERSEC |
    Sets the average number of bytes per second for recording and playback.
    This causes playback and recording to be stopped, and saves a copy of
    the current wave format header in case the new format is not valid for
    either recording or playback.

@flag   MCI_WAVE_SET_BLOCKALIGN |
    Sets the block alignment.  This causes playback and recording to be
    stopped, and saves a copy of the current wave format header in case
    the new format is not valid for either recording or playback.

@flag   MCI_WAVE_SET_BITSPERSAMPLE |
    Sets the number of bits per sample.  This causes playback and recording
    to be stopped, and saves a copy of the current wave format header in
    case the new format is not valid for either recording or playback.

@flag   MCI_SET_AUDIO |
    This is an unsupported function.

@flag   MCI_SET_DOOR_OPEN |
    This is an unsupported function.

@flag   MCI_SET_DOOR_CLOSED |
    This is an unsupported function.

@flag   MCI_SET_VIDEO |
    This is an unsupported function.

@flag   MCI_SET_ON |
    This is an unsupported function.

@flag   MCI_SET_OFF |
    This is an unsupported function.

@flag   MCI_WAIT |
    Wait for command to complete.

@flag   MCI_NOTIFY |
    Notify upon command completion.

@parm   <t>LPMCI_WAVE_SET_PARMS<d> | lpSet |
    Set parameters.

@rdesc  Returns 0 if the requested parameters were successfully set, else an
    MCI error if one or more error occurred.
*/

PRIVATE UINT PASCAL NEAR mwSet(
    PWAVEDESC   pwd,
    DWORD   dFlags,
    LPMCI_WAVE_SET_PARMS    lpSet)
{
    UINT    wReturn;

    dFlags &= ~(MCI_NOTIFY | MCI_WAIT);
    if (!dFlags)
        return MCIERR_MISSING_PARAMETER;

    wReturn = 0;
    if (dFlags & (MCI_WAVE_INPUT | MCI_WAVE_OUTPUT)) {
        mwStop(pwd);
        if (dFlags & MCI_WAVE_INPUT) {
            if (lpSet->wInput < cWaveInMax)
                pwd->idIn = lpSet->wInput;
            else
                wReturn = MCIERR_OUTOFRANGE;
        }
        if (dFlags & MCI_WAVE_OUTPUT) {
            if (lpSet->wOutput < cWaveOutMax)
                pwd->idOut = lpSet->wOutput;
            else
                wReturn = MCIERR_OUTOFRANGE;
        }
    }
    if (dFlags & MCI_WAVE_SET_ANYINPUT)
        pwd->idIn = (DWORD)WAVE_MAPPER;

    if (dFlags & MCI_WAVE_SET_ANYOUTPUT)
        pwd->idOut = (DWORD)WAVE_MAPPER;

    if (dFlags & MCI_SET_TIME_FORMAT) {
        if ((lpSet->dwTimeFormat == MCI_FORMAT_MILLISECONDS)
         || (lpSet->dwTimeFormat == MCI_FORMAT_SAMPLES)
         || ((lpSet->dwTimeFormat == MCI_FORMAT_BYTES) && (pwd->pwavefmt->wFormatTag == WAVE_FORMAT_PCM)))
            pwd->dTimeFormat = lpSet->dwTimeFormat;
        else
            wReturn = MCIERR_BAD_TIME_FORMAT;
    }

    if (dFlags
        & (MCI_WAVE_SET_FORMATTAG | MCI_WAVE_SET_CHANNELS | MCI_WAVE_SET_SAMPLESPERSEC | MCI_WAVE_SET_AVGBYTESPERSEC | MCI_WAVE_SET_BLOCKALIGN | MCI_WAVE_SET_BITSPERSAMPLE)) {

        if (pwd->dSize) {
            wReturn = MCIERR_NONAPPLICABLE_FUNCTION;
        } else {
            PBYTE   pbWaveFormat;

            mwStop(pwd);
            pbWaveFormat = (PBYTE)LocalAlloc(LPTR, pwd->wFormatSize);

            if (!pbWaveFormat)
                return MCIERR_OUT_OF_MEMORY;

            memcpy(pbWaveFormat, pwd->pwavefmt, pwd->wFormatSize);

            if (dFlags & MCI_WAVE_SET_FORMATTAG)
                pwd->pwavefmt->wFormatTag = lpSet->wFormatTag;

            if (dFlags & MCI_WAVE_SET_CHANNELS)
                pwd->pwavefmt->nChannels = lpSet->nChannels;

            if (dFlags & MCI_WAVE_SET_SAMPLESPERSEC)
                pwd->pwavefmt->nSamplesPerSec = lpSet->nSamplesPerSec;

            if (dFlags & MCI_WAVE_SET_AVGBYTESPERSEC)
                pwd->pwavefmt->nAvgBytesPerSec = lpSet->nAvgBytesPerSec;

            if (dFlags & MCI_WAVE_SET_BITSPERSAMPLE)
                if (pwd->pwavefmt->wFormatTag == WAVE_FORMAT_PCM)
                    ((NPPCMWAVEFORMAT)(pwd->pwavefmt))->wBitsPerSample = lpSet->wBitsPerSample;
                else
                    wReturn = MCIERR_UNSUPPORTED_FUNCTION;

            if (dFlags & MCI_WAVE_SET_BLOCKALIGN)
                pwd->pwavefmt->nBlockAlign = lpSet->nBlockAlign;
            else if (pwd->pwavefmt->wFormatTag == WAVE_FORMAT_PCM)
                pwd->pwavefmt->nBlockAlign = (WORD)pwd->pwavefmt->nSamplesPerSec / (WORD)pwd->pwavefmt->nAvgBytesPerSec;

            if (mwCheckDevice(pwd, output) && mwCheckDevice(pwd, input)) {
                wReturn = MCIERR_OUTOFRANGE;
                memcpy(pwd->pwavefmt, pbWaveFormat, pwd->wFormatSize);
            } else
                pwd->dAudioBufferLen = BLOCKALIGN(pwd, pwd->pwavefmt->nAvgBytesPerSec);

            LocalFree(pbWaveFormat);
        }
    }

    if (dFlags & (MCI_SET_DOOR_OPEN | MCI_SET_DOOR_CLOSED | MCI_SET_AUDIO | MCI_SET_VIDEO | MCI_SET_ON | MCI_SET_OFF))
        wReturn = MCIERR_UNSUPPORTED_FUNCTION;

    return wReturn;
}

/************************************************************************/

/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwDelete |
    This function is called in response to an <m>MCI_DELETE<d> message, and
    is used to delete a portion of the wave file.

    The range checking performed on the "to" and "from" parameters is
    almost identical to that of playback and recording, except that the
    the "to" position cannot be larger than the file length.

    If the parameters are equal, the function sets the current position to
    the "from" parameter, and returns success without actually doing
    anything, else the specified range is deleted from the file.

    On success, the current position is set to the "from" position.  This
    is consistent with the other commands that have "to" and "from"
    paramters since the "to" position becomes the same as the "from"
    position after a deletion.

    In the future, support for Cut/Copy/Paste should be added.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dFlags |
    Contains the flags for delete message.

@flag   MCI_FROM |
    Indicates a starting position is present in <p>lpDelete<d>, else the
    current position is used.

@flag   MCI_TO |
    Indicates an ending position is present in <p>lpDelete<d>, else the file
    size is used.

@parm   <t>LPMCI_WAVE_DELETE_PARMS<d> | lpDelete |
    Optionally contains the delete parameters.

@rdesc  Returns 0 if the range was deleted, else MCIERR_OUTOFRANGE for invalid
    parameters or MCIERR_OUT_OF_MEMORY if the delete failed.
*/

PRIVATE UINT PASCAL NEAR mwDelete(
    PWAVEDESC   pwd,
    DWORD   dFlags,
    LPMCI_WAVE_DELETE_PARMS lpDelete)
{
    DWORD   dFrom;
    DWORD   dTo;

    mwStop(pwd);
    if (dFlags & MCI_FROM) {
        dFrom = VerifyRangeStart(pwd, lpDelete->dwFrom);
        if (dFrom == -1)
            return MCIERR_OUTOFRANGE;
    } else
        dFrom = pwd->dCur;

    if (dFlags & MCI_TO) {
        dTo = VerifyRangeEnd(pwd, lpDelete->dwTo, TRUE);
        if (dTo == -1)
            return MCIERR_OUTOFRANGE;
    } else
        dTo = pwd->dSize;

    if (dTo < dFrom)
        return MCIERR_OUTOFRANGE;

    SetCurrentPosition(pwd, dFrom);

    if (dTo == dFrom)
        return 0L;

    pwd->dTo = dTo;
    SETTASKSTATE(pwd, TASKDELETE);
    TaskSignal(pwd->hTask, WTM_STATECHANGE);

    while (!ISTASKSTATE(pwd, TASKIDLE))
        mmYield(pwd);

    return pwd->wTaskError;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    UINT | mwSave |
    This function is called in response to an <m>MCI_SAVE<d> message, and
    is used to save the file attached to the MCI device.  This has the
    side effect of stopping any current playback or recording.

    If the file is not named, the MCI_SAVE_FILE flag must be used and a
    named provided, else the function will fail.  If the function succeeds,
    and a name has been provided, the name attached to the MCI device will
    be changed, otherwise it will remain the same.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dFlags |
    Contains the save flags.

@flag   MCI_SAVE_FILE |
    Indicates that a file name has been provided in the <p>lpSave<d>
    structure.

@parm   <t>LPMCI_SAVE_PARMS<d> | lpSave |
    Structure optionally contains a pointer to a file name to save to.
    The current file name is only changed if the save is successful.

@rdesc  Returns 0 if the file was saved, else an MCI error.
*/

PRIVATE UINT PASCAL NEAR mwSave(
    PWAVEDESC   pwd,
    DWORD   dFlags,
    LPMCI_SAVE_PARMS    lpSave)
{
    if (((dFlags & MCI_SAVE_FILE) && !lpSave->lpfilename)
        || (!*pwd->aszFile && !(dFlags & MCI_SAVE_FILE)))
        return MCIERR_UNNAMED_RESOURCE;

    if (dFlags & MCI_SAVE_FILE) {

        MMIOINFO    mmioInfo;

        WCHAR    aszSaveFile[_MAX_PATH];

        aszSaveFile[ (sizeof(aszSaveFile) / sizeof(WCHAR)) - 1] = '\0';
        wcsncpy(aszSaveFile, lpSave->lpfilename, (sizeof(aszSaveFile) / sizeof(WCHAR)) - 1);

        InitMMIOOpen(pwd, &mmioInfo);

        if (!mmioOpen(aszSaveFile, &mmioInfo, MMIO_PARSE))
            return MCIERR_FILENAME_REQUIRED;
        // The fully qualified name is in aszSaveFile

        if (lstrcmp(aszSaveFile, pwd->aszFile)) {
            pwd->szSaveFile = (LPWSTR)LocalAlloc(LPTR,
                            sizeof(WCHAR)*lstrlen(aszSaveFile) + sizeof(WCHAR));
            if (pwd->szSaveFile)
                lstrcpy(pwd->szSaveFile, aszSaveFile);
            else
                return MCIERR_OUT_OF_MEMORY;
        }
    }

    mwStop(pwd);
    SETTASKSTATE(pwd, TASKSAVE);
    TaskSignal(pwd->hTask, WTM_STATECHANGE);

    while (!ISTASKSTATE(pwd, TASKIDLE))
        mmYield(pwd);

    if (pwd->szSaveFile) {
        LocalFree(pwd->szSaveFile);
        pwd->szSaveFile = NULL;
    }

    return pwd->wTaskError;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    LRESULT | mciDriverEntry |
    Single entry point for MCI drivers.

    After executing the command, if notification has been specified, any
    previous notification is superseded, and new notification is performed.
    Any command which performs delayed notification, or the special case
    of Cue, has already returned by this point.

@parm   MCIDEVICEID | wDeviceID |
    Contains the MCI device ID.

@parm   UINT | wMessage |
    The requested action to be performed.

@flag   MCI_OPEN_DRIVER |
    Open an instance of the MCI wave device driver, possibly attaching an
    element to the device.

@flag   MCI_CLOSE_DRIVER |
    Close an instance of the MCI wave device driver, closing any element
    attached to the device.

@flag   MCI_PLAY |
    Play the element attached to the instance of the MCI wave device
    driver.

@flag   MCI_RECORD |
    Record to the element attached to the instance of the MCI wave device
    driver.

@flag   MCI_STOP |
    Stop playback or recording of the element attached to the instance of
    the MCI wave device driver.

@flag   MCI_CUE |
    Cue playback or recording of the element attached to the instance of
    the MCI wave device driver.

@flag   MCI_SEEK |
    Set the current position in the element attached to the instance of
    the MCI wave device driver.

@flag   MCI_PAUSE |
    Pause playback or recording of the element attached to the instance of
    the MCI wave device driver.

@flag   MCI_RESUME |
    Resumes playback or recording of the element attached to the instance
    of the MCI wave device driver.

@flag   MCI_STATUS |
    Retrieve the specified status of the element attached to the instance
    of the MCI wave device driver.

@flag   MCI_GETDEVCAPS |
    Retrieve the specified device capabilities of the instance of the MCI
    wave device driver.

@flag   MCI_INFO |
    Retrieve the specified information from the element or the instance of
    the MCI wave device driver.

@flag   MCI_SET |
    Set the specified parameters of the element attached to the instance
    of the MCI wave device driver.

@flag   MCI_SAVE |
    Save the element attached to the instance of the MCI wave device
    driver.

@flag   MCI_DELETE |
    Delete data from the element attached to the instance of the MCI wave
    device driver.

@flag   MCI_LOAD |
    This is an unsupported function.

@parm   DWORD | dFlags |
    Data for this message.  Defined seperately for each message.

@parm   <t>LPMCI_GENERIC_PARMS<d> | lpParms |
    Data for this message.  Defined seperately for each message

@rdesc  Defined separately for each message.
*/

PUBLIC  LRESULT PASCAL FAR mciDriverEntry(
    MCIDEVICEID wDeviceID,
    UINT    wMessage,
    DWORD   dFlags,
    LPMCI_GENERIC_PARMS lpParms)
{
    PWAVEDESC   pwd;
    LRESULT     lReturn;

    if (!(pwd = (PWAVEDESC)(mciGetDriverData(wDeviceID))))
        switch (wMessage) {
        case MCI_PLAY:
        case MCI_RECORD:
        case MCI_STOP:
        case MCI_CUE:
        case MCI_SEEK:
        case MCI_PAUSE:
        case MCI_RESUME:
        case MCI_STATUS:
        case MCI_SET:
        case MCI_SAVE:
        case MCI_DELETE:
        case MCI_COPY:
        case MCI_PASTE:
            return (LRESULT)MCIERR_UNSUPPORTED_FUNCTION;
        }

    EnterCrit();

    switch (wMessage) {
    case MCI_OPEN_DRIVER:
        lReturn = mwOpenDevice(dFlags, (LPMCI_WAVE_OPEN_PARMS)lpParms, wDeviceID);
        break;

    case MCI_CLOSE_DRIVER:
        lReturn = mwCloseDevice(pwd);
        pwd = NULL;
        break;

    case MCI_PLAY:
        lReturn = (LRESULT)(LONG)mwSetup(pwd, dFlags, (LPMCI_PLAY_PARMS)lpParms, output);
        LeaveCrit();
        return lReturn;

    case MCI_RECORD:
        lReturn = (LRESULT)(LONG)mwSetup(pwd, dFlags, (LPMCI_PLAY_PARMS)lpParms, input);
        LeaveCrit();
        return lReturn;

    case MCI_STOP:
        mwStop(pwd);
        lReturn = 0;
        break;

    case MCI_CUE:
        lReturn = (LRESULT)(LONG)mwCue(pwd, dFlags, lpParms);
        LeaveCrit();
        return lReturn;

    case MCI_SEEK:
        lReturn = mwSeek(pwd, dFlags, (LPMCI_SEEK_PARMS)lpParms);
        break;

    case MCI_PAUSE:
        lReturn = mwPause(pwd, dFlags);
        break;

    case MCI_RESUME:
        lReturn = mwResume(pwd, dFlags);
        break;

    case MCI_STATUS:
        lReturn = mwStatus(pwd, dFlags, (LPMCI_STATUS_PARMS)lpParms);
        break;

    case MCI_GETDEVCAPS:
        lReturn = mwGetDevCaps(pwd, dFlags, (LPMCI_GETDEVCAPS_PARMS)lpParms);
        break;

    case MCI_INFO:
        lReturn = mwInfo(pwd, dFlags, (LPMCI_INFO_PARMS)lpParms);
        break;

    case MCI_SET:
        lReturn = mwSet(pwd, dFlags, (LPMCI_WAVE_SET_PARMS)lpParms);
        break;

    case MCI_SAVE:
        lReturn = mwSave(pwd, dFlags, (LPMCI_SAVE_PARMS)lpParms);
        break;

    case MCI_DELETE:
        lReturn = mwDelete(pwd, dFlags, (LPMCI_WAVE_DELETE_PARMS)lpParms);
        break;

    case MCI_COPY:
    case MCI_PASTE:
    case MCI_LOAD:
        lReturn = MCIERR_UNSUPPORTED_FUNCTION;
        break;

    default:
        lReturn = MCIERR_UNRECOGNIZED_COMMAND;
        break;
    }
    if (!LOWORD(lReturn) && (dFlags & MCI_NOTIFY)) {
        if (pwd)
            mwDelayedNotify(pwd, MCI_NOTIFY_SUPERSEDED);
        mwImmediateNotify(wDeviceID, lpParms);
    }

    LeaveCrit();
    return lReturn;
}

/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciwave\mwinfo.c ===
/************************************************************************/

/*
**  Copyright (c) 1985-1994 Microsoft Corporation
**
**  Title: mwinfo.c - Multimedia Systems Media Control Interface
**  waveform digital audio driver for RIFF wave files.
**
**  Version:    1.00
**
**  Date:       18-Apr-1990
**
**  Author:     ROBWI
*/

/************************************************************************/

/*
**  Change log:
**
**  DATE        REV DESCRIPTION
**  ----------- -----   ------------------------------------------
**  18-APR-1990 ROBWI   Original
**  19-JUN-1990 ROBWI   Added wave in
**  10-Jan-1992 MikeTri Ported to NT
**                  @@@ Change slash slash comments to slash star
*/

/************************************************************************/
#define UNICODE

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOOPENFILE
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS

#include <windows.h>
#include "mciwave.h"
#include <mmddk.h>
#include <wchar.h>

/************************************************************************/

/*
**  The following two constants are used to describe the mask of flags
**  that are dealt with in the Info and Capability commands.
*/

#define MCI_WAVE_INFO_MASK  (MCI_INFO_FILE | MCI_INFO_PRODUCT | \
            MCI_WAVE_INPUT | MCI_WAVE_OUTPUT)

#define MCI_WAVE_CAPS_MASK  (MCI_WAVE_GETDEVCAPS_INPUTS    | \
            MCI_WAVE_GETDEVCAPS_OUTPUTS | MCI_GETDEVCAPS_CAN_RECORD   | \
            MCI_GETDEVCAPS_CAN_PLAY | MCI_GETDEVCAPS_CAN_SAVE         | \
            MCI_GETDEVCAPS_HAS_AUDIO | MCI_GETDEVCAPS_USES_FILES      | \
            MCI_GETDEVCAPS_COMPOUND_DEVICE | MCI_GETDEVCAPS_HAS_VIDEO | \
            MCI_GETDEVCAPS_CAN_EJECT | MCI_GETDEVCAPS_DEVICE_TYPE)

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    DWORD | mwInfo |
    Respond to info command.  The function tries to thoroughly check
    the <p>dFlags<d> parameter by masking out unrecognized commands
    and comparing against the original.  It then makes sure that only
    one command is present by doing a switch() on the flags, and returning
    an error condition if some combination of flags is present.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dFlags |
    Command flags.

@flag   MCI_INFO_FILE |
    Return the file name associated with the MCI wave device instance.
    The instance must have file information attached, that is, not just
    opened for configuration or capabilities checking.  The file name
    returned might be zero length if a name has not been associated with
    a new file.

@flag   MCI_INFO_PRODUCT |
    Return the product name of the driver.

@flag   MCI_WAVE_OUTPUT |
    Return the product name of the current wave output device.  This
    function also requires file information to be attached.  If any
    output can be used and playback is not currently in progress, then
    no device is currently selected.  Else the specific device in use
    is returned.

@flag   MCI_WAVE_INPUT |
    Return the product name of the current wave input device.  This
    function also requires file information to be attached.  If any
    input can be used and recording is not currently in progress, then
    no device is currently selected.  Else the specific device in use
    is returned.

@parm   <t>LPMCI_INFO_PARMS<d> | lpInfo |
    Info parameters.

@rdesc  Returns zero on success, or an MCI error code.
*/

PUBLIC  DWORD PASCAL FAR mwInfo(
    PWAVEDESC         pwd,
    DWORD             dFlags,
    LPMCI_INFO_PARMS  lpInfo)
{
    UINT    wReturnLength;
    UINT    wReturnBufferLength;
    UINT    wErrorRet;

    wReturnBufferLength = lpInfo->dwRetSize; // Win 16 only uses the loword

    if (!lpInfo->lpstrReturn || !wReturnBufferLength)
        return MCIERR_PARAM_OVERFLOW;

    // Turn off the uninteresting flags
    dFlags &= ~(MCI_NOTIFY | MCI_WAIT);

    // See if the user wants anything
    if (!dFlags)
        return MCIERR_MISSING_PARAMETER;

    if (dFlags != (dFlags & MCI_WAVE_INFO_MASK))
        return MCIERR_UNRECOGNIZED_KEYWORD;

    *(lpInfo->lpstrReturn + wReturnBufferLength - 1) = '\0';

    switch (dFlags) {
    case MCI_INFO_FILE:
        if (!pwd)
            return MCIERR_UNSUPPORTED_FUNCTION;

        if (!*pwd->aszFile)
            return MCIERR_NONAPPLICABLE_FUNCTION;

        // BYTE!!CHARACTER count ??
        wcsncpy(lpInfo->lpstrReturn, pwd->aszFile, wReturnBufferLength);
        // Note: the return length may be BIGGER than the buffer provided
        wReturnLength = lstrlen(pwd->aszFile);
        break;

    case MCI_INFO_PRODUCT:
        wReturnLength = LoadString(hModuleInstance, IDS_PRODUCTNAME, lpInfo->lpstrReturn, wReturnBufferLength);
        break;

    case MCI_WAVE_OUTPUT:
        if (pwd) {
            WAVEOUTCAPS waveOutCaps;
            UINT    idOut;

            if ((pwd->idOut == WAVE_MAPPER) && ISMODE(pwd, MODE_PLAYING))
                waveOutGetID(pwd->hWaveOut, &idOut);
            else
                idOut = pwd->idOut;

            if (0 != (wErrorRet = waveOutGetDevCaps(idOut, &waveOutCaps, sizeof(WAVEOUTCAPS)))) {
                if (idOut == WAVE_MAPPER)
                    wReturnLength = LoadString(hModuleInstance, IDS_MAPPER, lpInfo->lpstrReturn, wReturnBufferLength);
                else
                    return wErrorRet;
            } else {
            wcsncpy(lpInfo->lpstrReturn, waveOutCaps.szPname, wReturnBufferLength);
                wReturnLength = lstrlen(waveOutCaps.szPname);
                wReturnLength = min(wReturnLength, wReturnBufferLength);
            }
        } else
            return MCIERR_UNSUPPORTED_FUNCTION;
        break;

    case MCI_WAVE_INPUT:
        if (pwd) {
            WAVEINCAPS  waveInCaps;
            UINT    idIn;

            if ((pwd->idIn == WAVE_MAPPER) && ISMODE(pwd, MODE_INSERT | MODE_OVERWRITE))
                waveInGetID(pwd->hWaveIn, &idIn);
            else
                idIn = pwd->idIn;
            if (0 != (wErrorRet = waveInGetDevCaps(idIn, &waveInCaps, sizeof(WAVEINCAPS)))) {
                if (idIn == WAVE_MAPPER)
                    wReturnLength = LoadString(hModuleInstance, (UINT)IDS_MAPPER, lpInfo->lpstrReturn, wReturnBufferLength);
                else
                    return wErrorRet;
            } else {
            wcsncpy(lpInfo->lpstrReturn, waveInCaps.szPname, wReturnBufferLength);
                wReturnLength = lstrlen(waveInCaps.szPname);
                wReturnLength = min(wReturnLength, wReturnBufferLength);
            }
        } else
            return MCIERR_UNSUPPORTED_FUNCTION;
        break;

    default:
        return MCIERR_FLAGS_NOT_COMPATIBLE;
    }

    lpInfo->dwRetSize = (DWORD)wReturnLength;
    if (*(lpInfo->lpstrReturn + wReturnBufferLength - 1) != '\0')
        return MCIERR_PARAM_OVERFLOW;
    return 0;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@api    DWORD | mwGetDevCaps |
    Respond to device capabilities command.  The function tries to
    thoroughly check the <p>dFlags<d> parameter by masking out
    unrecognized commands and comparing against the original.  It then
    makes sure that only one command is present by doing a switch() on the
    flags, and returning an error condition if some combination of flags
    is present.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   UINT | dFlags |
    Command flags.

@flag   MCI_WAVE_GETDEVCAPS_INPUTS |
    Queries the number of wave audio input devices.

@flag   MCI_WAVE_GETDEVCAPS_OUTPUTS |
    Queries the number of wave audio output devices.

@flag   MCI_GETDEVCAPS_CAN_RECORD |
    Queries whether or not recording can be done.  This depends upon if
    there are any wave audio input devices.

@flag   MCI_GETDEVCAPS_CAN_PLAY |
    Queries whether or not playback can be done.  This depends upon if
    there are any wave audio output devices.

@flag   MCI_GETDEVCAPS_CAN_SAVE |
    Queries as to whether audio can be saved.  This returns TRUE.

@flag   MCI_GETDEVCAPS_HAS_AUDIO |
    Queries as to whether the device has audio.  As this is an audio
    device, this returns TRUE.

@flag   MCI_GETDEVCAPS_USES_FILES |
    Queries as to whether the device uses file to play or record.  This
    returns TRUE.

@flag   MCI_GETDEVCAPS_COMPOUND_DEVICE |
    Queries as to whether the device can deal with compound files.  This
    returns TRUE.

@flag   MCI_GETDEVCAPS_HAS_VIDEO |
    Queries as to whether the device has video capability.  This returns
    FALSE.

@flag   MCI_GETDEVCAPS_CAN_EJECT |
    Queries as to whether the device can eject media.  This returns FALSE.

@flag   MCI_GETDEVCAPS_DEVICE_TYPE |
    Queries the type of device.  This returns the wave audio device
    string resource identifier.

@parm   <t>LPMCI_GETDEVCAPS_PARMS<d> | lpCaps |
    Capability parameters.

@rdesc  Returns zero on success, or an MCI error code.
*/

PUBLIC  DWORD PASCAL FAR mwGetDevCaps(
    PWAVEDESC   pwd,
    DWORD       dFlags,
    LPMCI_GETDEVCAPS_PARMS  lpCaps)
{
    DWORD   dRet;

    dFlags &= ~(MCI_NOTIFY | MCI_WAIT);

    if (!dFlags || !lpCaps->dwItem)
        return MCIERR_MISSING_PARAMETER;

    if ((dFlags != MCI_GETDEVCAPS_ITEM) || (lpCaps->dwItem != (lpCaps->dwItem & MCI_WAVE_CAPS_MASK)))
        return MCIERR_UNRECOGNIZED_KEYWORD;

    switch (lpCaps->dwItem) {
    case MCI_WAVE_GETDEVCAPS_INPUTS:
        lpCaps->dwReturn = cWaveInMax;
        dRet = 0L;
        break;

    case MCI_WAVE_GETDEVCAPS_OUTPUTS:
        lpCaps->dwReturn = cWaveOutMax;
        dRet = 0L;
        break;

    case MCI_GETDEVCAPS_CAN_RECORD:
        if (cWaveInMax)
            lpCaps->dwReturn = MAKELONG(TRUE, MCI_TRUE);
        else
            lpCaps->dwReturn = MAKELONG(FALSE, MCI_FALSE);
        dRet = MCI_RESOURCE_RETURNED;
        break;

    case MCI_GETDEVCAPS_CAN_PLAY:
        if (cWaveOutMax)
            lpCaps->dwReturn = MAKELONG(TRUE, MCI_TRUE);
        else
            lpCaps->dwReturn = MAKELONG(FALSE, MCI_FALSE);
        dRet = MCI_RESOURCE_RETURNED;
        break;

    case MCI_GETDEVCAPS_CAN_SAVE:
    case MCI_GETDEVCAPS_HAS_AUDIO:
    case MCI_GETDEVCAPS_USES_FILES:
    case MCI_GETDEVCAPS_COMPOUND_DEVICE:
        lpCaps->dwReturn = MAKELONG(TRUE, MCI_TRUE);
        dRet = MCI_RESOURCE_RETURNED;
        break;

    case MCI_GETDEVCAPS_HAS_VIDEO:
    case MCI_GETDEVCAPS_CAN_EJECT:
        lpCaps->dwReturn = MAKELONG(FALSE, MCI_FALSE);
        dRet = MCI_RESOURCE_RETURNED;
        break;

    case MCI_GETDEVCAPS_DEVICE_TYPE:
        lpCaps->dwReturn = MAKELONG(MCI_DEVTYPE_WAVEFORM_AUDIO, MCI_DEVTYPE_WAVEFORM_AUDIO);
        dRet = MCI_RESOURCE_RETURNED;
        break;

    default:
        dRet = MCIERR_UNSUPPORTED_FUNCTION;
        break;
    }
    return dRet;
}

/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciwave\support.c ===
/*******************************Module*Header*********************************\
* Module Name: support.c
*
* MultiMedia Systems MCIWAVE DLL
*
* Created: 27-Feb-1992
* Author:  ROBINSP
*
* History:
*
* Copyright (c) 1985-1996 Microsoft Corporation
*
\******************************************************************************/
#define UNICODE

#include <windows.h>
#include <mciwave.h>

STATICDT CRITICAL_SECTION CritSec;
#if DBG
STATICDT UINT             cCritSec = 0;
         DWORD            dwCritSecOwner = 0;
#endif

/*************************************************************************
 *
 * Cut-down critical section stuff
 *
 * This critical section is used to simulate windows tasking
 * The owner of the critical section runs exclusively in this
 * DLL.
 *
 * At the front of each function request the critical section is
 * grabbed and only release on mmYield or TaskBlock.
 *
 * Extra 'tasks' (threads) per device hold the critical section when
 * they are working.
 *
 * This method has been used to simplify porting the code from
 * windows.  A rewrite would use a different mechanism.
 *
 ************************************************************************/

VOID InitCrit(VOID)
{
    InitializeCriticalSection(&CritSec);
}


VOID DeleteCrit(VOID)
{
    DeleteCriticalSection(&CritSec);
}

#if DBG
VOID DbgEnterCrit(UINT ln, LPCSTR lpszFile)
{
    BOOL fPossibleWait;
    if (dwCritSecOwner) {
        dprintf3(("Critical section owned by thread %x", dwCritSecOwner));
        fPossibleWait = TRUE;
    } else {
        fPossibleWait = FALSE;
    }

    EnterCriticalSection(&CritSec);
    if (fPossibleWait) {
        dprintf2(("...entered critical section after possible wait"));
    }

    if (!cCritSec++) {
        // This is the first time into the critcal section
        dwCritSecOwner = GetCurrentThreadId();
        dprintf3(("...entered critical section (%d) at line %d in file %s", cCritSec, ln, lpszFile));
    } else {
        dprintf1(("Reentering critical section, count = %d", cCritSec));
	WinAssert(0);
	// Note: if the memory allocation stuff starts to be synchronised
	// then this assertion becomes invalid.
    }
}

#else

VOID EnterCrit(VOID)
{
    EnterCriticalSection(&CritSec);
}
#endif

VOID LeaveCrit(VOID)
{
#if DBG
        if (!--cCritSec) {
                // Relinquishing control of the critcal section
                dwCritSecOwner = 0;
                dprintf2(("...relinquished critical section (%d)",cCritSec));
        } else {
                dprintf3(("Leaving critical section, count = %d", cCritSec));
        }
#endif
    LeaveCriticalSection(&CritSec);
}

/*************************************************************************
 *
 * @doc     MCIWAVE
 *
 * @func    UINT | TaskBlock |  This function blocks the current
 *          task context if its event count is 0.
 *
 * @rdesc   Returns the message value of the signal sent.
 *
 ************************************************************************/

UINT TaskBlock(VOID)
{
   MSG msg;

   dprintf3(("Thread %x blocking", GetCurrentThreadId()));

   LeaveCrit();

   /*
    *   Loop until we get the message we want
    */
   for (;;) {
       /*
        *   Retrieve any message for task
        */
       GetMessage(&msg, NULL, 0, 0);

       /*
        *   If the message is for a window dispatch it
        */
       if (msg.hwnd != NULL) {
           DispatchMessage(&msg);
       } else {
           if (msg.message != WM_USER &&
               msg.message != WTM_STATECHANGE) {
               dprintf1(("Got thread message %8X", msg.message));
           }
           //
           // Because MCIWAVE background task can't cope with getting 
           // random(?) messages like MM_WIM_DATA because it thinks that 
           // WM_USER IS its MM_WIM_DATA.  Let the expected WM_USER 
           // messages go through, but trap the MM_WIM_DATA so that 
           // MCIWAVE's buffers don't get all messed up.
           //
           if (msg.message != MM_WIM_DATA)
               break;
       }
   }

   dprintf3(("TaskBlock returning with message 0x%x", msg.message));
   EnterCrit();

   return msg.message;
}


/*************************************************************************
 *
 * @doc     MCIWAVE
 *
 * @func    BOOL | TaskSignal |  This function signals the specified
 *          task, incrementing its event count and unblocking
 *          it.
 *
 * @parm    HANDLE | h | Task handle. For predictable results, get the
 *          task handle from <f mmGetCurrentTask>.
 *
 * @parm    UINT | Msg | Signal message to send.
 *
 * @rdesc   Returns TRUE if the signal was sent, else FALSE if the message
 *          queue was full.
 *
 * @xref    mmTaskBlock  mmTaskCreate
 *
 * @comm    For predictable results, must only be called from a task
 *          created with <f mmTaskCreate>.
 *
 ************************************************************************/
BOOL TaskSignal(DWORD h, UINT Msg)
{
#ifdef DBG
    BOOL fErr;
    dprintf2(("Signalling Thread %x", (ULONG)h));
    fErr = PostThreadMessage(h, Msg, 0, 0);
        if (!fErr) {
                dprintf1(("Error %d signalling Thread %x", GetLastError(), (ULONG)h));
        }
        return(fErr);
#else
    return PostThreadMessage(h, Msg, 0, 0);
#endif
}


/*************************************************************************
 *
 * @doc     MCIWAVE
 *
 * @func    VOID | TaskWaitComplete |  This function waits for the
 *          specified task to terminate.
 *
 * @parm    HANDLE | h | Task handle. For predictable results, get the
 *          task handle from <f mmGetCurrentTask>.
 *
 * @rdesc   No return code
 *
 ************************************************************************/
VOID TaskWaitComplete(HANDLE h)
{
    UINT Rc;

    LeaveCrit();

    /* Wait (no timeout) for thread to complete */

    Rc = WaitForSingleObject(h, INFINITE);

    if (Rc != 0) {
        dprintf(("Error terminating thread - WaitForSingleObject returned non-zero !!!"));
    }

    /* Note that the handle must be freed by us */

    CloseHandle(h);
    EnterCrit();
}

#if DBG
/*************************************************************************
 *
 * @doc     MCIWAVE
 *
 * @func    VOID | mmYield |  This function checks that we are in the
 *          critical section before Yielding.  If we are then the
 *                      critical section is reentered after yielding.
 *
 * @parm   <t>PWAVEDESC<d> | pwd |
 *          Pointer to the wave device descriptor.
 *
 * @rdesc   No return code
 *
 ************************************************************************/
VOID mmDbgYield(
        PWAVEDESC pwd,
        UINT      ln,
        LPCSTR    lpszFile)
{

        if (GetCurrentThreadId() != dwCritSecOwner) {
                dprintf1(("mmYield called while not in the critical section from line %d in file %s", ln, lpszFile));
        }

        CheckIn();
    LeaveCrit();
        CheckOut();
    Sleep(10);
    EnterCrit();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciwave\mwplay.c ===
/************************************************************************/

/*
**  Copyright (c) 1985-1998 Microsoft Corporation
**
**  Title: mwplay.c - Multimedia Systems Media Control Interface
**  waveform digital audio driver for RIFF wave files.
**  Routines for playing wave files
**
**  Version:    1.00
**
**  Date:       18-Apr-1990
**
**  Author:     ROBWI
*/

/************************************************************************/

/*
**  Change log:
**
**  DATE        REV DESCRIPTION
**  ----------- -----   ------------------------------------------
**  18-APR-1990 ROBWI   Original
**  19-JUN-1990 ROBWI   Added wave in
**  10-Jan-1992 MikeTri Ported to NT
**                  @@@ Need to change comments from slash slash to slash star
**   4-Mar-1992 SteveDav Continue the port.  Update to current Win 3.1
*/

/************************************************************************/
#define UNICODE

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOOPENFILE
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS

#include <windows.h>
#include "mciwave.h"
#include <mmddk.h>

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | mwRead |
    This function reads a buffer of wave data from either the input file,
    or the temporary data file.  The position is taken from the
    <e>WAVEDESC.dCur<d> pointer, which is updated with the number of bytes
    actually read.

    The data needed may come from several consecutively linked nodes, so
    first the virtual data ending position for the current wave data node
    is checked against the the current position.  This is to determine if
    the next node needs to be accessed.  The function then reads the data
    from the appropriate source, either the temporary data file, or the
    original file.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   LPBYTE | lpbBuffer |
    Points to a buffer to contain the data read.

@parm   DWORD | dBufferLength |
    Indicates the maximum number of bytes to read into the buffer.

@rdesc  Returns number of bytes read, else 0 on an error wherein no bytes
    could be read.  This means that there is not distinction between a
    read of zero bytes, or an error, but the function is never called
    if no bytes are to be read.
*/

PRIVATE DWORD PASCAL NEAR mwRead(
    PWAVEDESC   pwd,
    LPBYTE  lpbBuffer,
    DWORD   dBufferLength)
{
    DWORD   dTotalRead;
    LPWAVEDATANODE  lpwdn;

    lpwdn = LPWDN(pwd, pwd->dWaveDataCurrentNode);
    for (dTotalRead = 0; dBufferLength;) {
        DWORD   dStartRead;
        DWORD   dReadSize;
        DWORD   dBytesRead;

        if (pwd->dVirtualWaveDataStart + lpwdn->dDataLength <= (DWORD)pwd->dCur) {
            pwd->dWaveDataCurrentNode = lpwdn->dNextWaveDataNode;
            pwd->dVirtualWaveDataStart += lpwdn->dDataLength;
            lpwdn = LPWDN(pwd, lpwdn->dNextWaveDataNode);
        }

        dStartRead = pwd->dCur - pwd->dVirtualWaveDataStart;
        dReadSize = min(dBufferLength, lpwdn->dDataLength - dStartRead);

        if (ISTEMPDATA(lpwdn)) {
            if (MySeekFile(pwd->hTempBuffers, UNMASKDATASTART(lpwdn) + dStartRead))
		MyReadFile(pwd->hTempBuffers, lpbBuffer, dReadSize, &dBytesRead);
            else
                dBytesRead = (DWORD)-1;
        } else {
            if (mmioSeek(pwd->hmmio, pwd->dRiffData + lpwdn->dDataStart + dStartRead, SEEK_SET) != -1)
                dBytesRead = (DWORD)mmioRead(pwd->hmmio, lpbBuffer, (LONG)dReadSize);
            else
                dBytesRead = (DWORD)-1;
        }

        if (dBytesRead != -1) {
            dTotalRead += dBytesRead;
            dBufferLength -= dBytesRead;
            lpbBuffer += dBytesRead;
            pwd->dCur += dBytesRead;
        }

        if (dBytesRead != dReadSize) {
            pwd->wTaskError = MCIERR_FILE_READ;
            break;
        }
    }
    return dTotalRead;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   BOOL | CheckNewCommand |
    This function is called when a New command flag is found during the
    playback loop.  It determines if the new commands affect current
    playback enough that it must be terminated.  This can happen if either
    a Stop command is received, or a Cue command is received and an error
    occurs while pausing the output wave device.

    Any other playback change does not need to stop current playback, as
    they should just release all the buffers from the wave device before
    setting the command.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns TRUE if the new commands do not affect playback and it should
    continue, else FALSE if the new commands affect the playback, and it
    should be aborted.
*/

REALLYPRIVATE   BOOL PASCAL NEAR CheckNewCommand(
    PWAVEDESC   pwd)
{
    if (ISMODE(pwd, COMMAND_STOP))
        return FALSE;

    if (ISMODE(pwd, COMMAND_CUE)
      && (0 != (pwd->wTaskError = waveOutPause(pwd->hWaveOut))))
        return FALSE;

    REMOVEMODE(pwd, COMMAND_NEW);
    return TRUE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   VOID | HoldPlayback |
    This function blocks the task, waiting to be signalled that it can
    continue from the Hold command.  Since the Play Hold command is
    considered to be "finished" when playback is done, but before any
    buffers are freed, the optional notification is performed here.  When
    the task is signalled, it can then check for new commands, which may
    continue playback, or exit the playback loop.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Nothing.
*/

PRIVATE VOID PASCAL NEAR HoldPlayback(
    PWAVEDESC   pwd)
{
    ADDMODE(pwd, MODE_HOLDING);
    mwDelayedNotify(pwd, MCI_NOTIFY_SUCCESSFUL);
    while (TaskBlock() != WTM_STATECHANGE);
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   UINT | PlayFile |
    This function is used to Cue or Play a wave file.  The function
    basically reads buffers from the wave file, and sends them out to the
    wave device, blocking for each buffer sent.  It also makes sure to
    call <f>mmTaskYield<d> while both reading in new buffers, and waiting
    for buffers to be released.

    Within the playback loop, the function first checks for the new command
    flag, which can possibly interrupt or change the current playback.
    The only thing that can really make a difference is setting the stop
    flag.  Changing the playback TO and FROM positions should not affect
    the loop, and setting the Cue command only pauses the output of the
    wave device.

    When the playback loop is first entered, the New command flag is
    set, and this condition is entered.  This allows the Cue command to
    be sent with the Play command, and initially pause the wave output
    device.  Calling <f>waveOutPause<d> stops any data from going out the
    DACs but, but still allows all the buffers to be queued up.

    After checking for a new command, the loop checks to see if there is
    any more data to play from the wave file, and if there are any empty
    buffers to read it in to.  If so, that data is read and written to the
    wave device, with the appropriate error checking, the in-use buffer
    count in incremented, and a pointer to the next data buffer to use is
    retrieved.

    After checking for more data to play, there is a check to see if any
    more buffers are outstanding.  If so, the task blocks until a buffer
    is released by the wave device.  Normally during the end of playback,
    this condition is performed for each outstanding buffer until all
    buffers have been released, then the function would enter the default
    condition and fall out of the loop.  It just blocks the task, waiting
    for the wave device to signal this task after releasing the buffer,
    and the in-use buffer count is decremented.  Note that since the task
    blocked itself, a new command could have been sent, so the playback
    loop starts again after doing a task yield, as it does after each of
    conditional parts of the playback loop.

    Before blocking the Cue command must be checked for in order to
    determine if the optional notification should be sent.  This is
    because a Cue Output command is considered "finished" when the buffers
    have been filled.

    After all playback buffers have been released by the wave device, if
    the hold command was given with the current play command, the task is
    blocked (and thus does not release the memory used by the playback
    buffers, nor leave the playback loop), waiting for a signal, which
    may stop or continue playback with a new set of parameters.

    The final default condition occurs when all the data has been read,
    all the buffers have been released, and the hold flag was not set.
    In this case, playback is done, and the playback loop is exited.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns the number of outstanding buffers written to the wave device.
    This can be used when removing task signal from the message queue.
    In cases of error, the <e>WAVEDESC.wTaskError<d> flag is set.  This
    specific error is not currently returned, as the calling task may not
    have waited for the command to complete.  But it is at least used for
    notification in order to determine if Failure status should be sent.

@xref   RecordFile.
*/

PUBLIC  UINT PASCAL FAR PlayFile(
    register PWAVEDESC  pwd)
{
    LPWAVEHDR   *lplpWaveHdr;
    register UINT   wBuffersOutstanding;

    ADDMODE(pwd, MODE_PLAYING);

    for (wBuffersOutstanding = 0, lplpWaveHdr = pwd->rglpWaveHdr;;) {

        if (ISMODE(pwd, COMMAND_NEW) && !CheckNewCommand(pwd))
            break;

        if ((wBuffersOutstanding < pwd->wAudioBuffers) && (pwd->dCur < pwd->dTo)) {
            if (!((*lplpWaveHdr)->dwFlags & WHDR_DONE)) {
                #if DBG
                dprintf1(("\nMCIWAVE Buffer not complete ! %8X", *lplpWaveHdr));
                DebugBreak();
                #endif
            }

            if (!((*lplpWaveHdr)->dwBufferLength = mwRead(pwd, (LPBYTE)(*lplpWaveHdr)->lpData, min(pwd->dAudioBufferLen, pwd->dTo - pwd->dCur))))
                break;

            (*lplpWaveHdr)->dwFlags &= ~(WHDR_DONE | WHDR_BEGINLOOP | WHDR_ENDLOOP);

            if (0 != (pwd->wTaskError = waveOutWrite(pwd->hWaveOut, *lplpWaveHdr, sizeof(WAVEHDR))))
                break;

            wBuffersOutstanding++;
            lplpWaveHdr = NextWaveHdr(pwd, lplpWaveHdr);

        } else if (wBuffersOutstanding) {

            if (ISMODE(pwd, COMMAND_CUE)) {
                ADDMODE(pwd, MODE_CUED);
                mwDelayedNotify(pwd, MCI_NOTIFY_SUCCESSFUL);
            }

            if (TaskBlock() == WM_USER)
                wBuffersOutstanding--;

        } else if (ISMODE(pwd, COMMAND_HOLD)) {
            HoldPlayback(pwd);
        }
        else
            break;

//@@    mmTaskYield();
        mmYield(pwd);

    }

    REMOVEMODE(pwd, MODE_PLAYING);
    return wBuffersOutstanding;
}

/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mciwave\mwrec.c ===
/*
**  Copyright (c) 1985-1998 Microsoft Corporation
**
**  Title: mwrec.c - Multimedia Systems Media Control Interface
**  waveform digital audio driver for RIFF wave files.
**  Routines for recording wave files
*/

/*
**  Change log:
**
**  DATE        REV DESCRIPTION
**  ----------- -----   ------------------------------------------
**  18-APR-1990 ROBWI   Original
**  19-JUN-1990 ROBWI   Added wave in
**  13-Jan-1992 MikeTri Ported to NT
**     Aug-1994 Lauriegr This is all out of date
*/


/*******************************************************************************
**                         !!READ THIS!!                                       *
**                         !!READ THIS!!                                       *
**                         !!READ THIS!!                                       *
**                                                                             *
** SEE MWREC.NEW FOR A SLIGHTLY BETTER PATCHED UP VERSION WITH MORE EXPLANATION
** ADDED.  YOU MIGHT WANT TO START FROM THERE INSTEAD
**
** As far as I can make out, this code was never finished.
** The scheme (which I tried to start writing up in MCIWAVE.H) is that there are
** a series of NODEs which describe a wave file.  As long as there is in fact
** only one NODE for the file (which is probably the only common case) then this
** all works fine.  If there are multiple NODEs (which you arrive at by inserting
** bits or deleting bits from the middle) then it all falls apart.
**
** We're pretty sure nobody's ever used this stuff as it's been broken for years
** in 16 and 32 bit.  We've discovered it just as Daytona is about to ship (that's
** Windows/NT version 3.5).  Maybe NMM wil replace it all anyway.
**
** This is a half-patched up version with several questions left outstanding.
**
*/




#define UNICODE

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOOPENFILE
#define NOSCROLL
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS

#include <windows.h>
#include "mciwave.h"
#include <mmddk.h>
#include <gmem.h>  // 'cos of GAllocPtrF etc.

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   int | abs |
    This macro returns the absolute value of the signed integer passed to
    it.

@parm   int | x |
    Contains the integer whose absolute value is to be returned.

@rdesc  Returns the absolute value of the signed parameter passed.
*/

#define abs(x)  ((x) > 0 ? (x) : -(x))

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | mwFindThisFreeDataNode |
    Attempts to locate a free wave data node whose temporary data points to
    <p>dDataStart<d>.  This allows data from one node to be expanded to
    adjacent free data of another node.  Note that this depends upon any
    free data nodes that previously pointed to original data to have their
    total length zeroed when freed.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dDataStart |
    Indicates the data start position to match.

@rdesc  Returns the free data node with adjacent free temporary data, else -1
    if there is none.
*/

PRIVATE DWORD PASCAL NEAR mwFindThisFreeDataNode(
    PWAVEDESC   pwd,
    DWORD   dDataStart)
{
    LPWAVEDATANODE  lpwdn;
    DWORD   dBlockNode;

    for (lpwdn = LPWDN(pwd, 0), dBlockNode = 0; dBlockNode < pwd->dWaveDataNodes; lpwdn++, dBlockNode++)
        if (ISFREEBLOCKNODE(lpwdn) && lpwdn->dTotalLength && (UNMASKDATASTART(lpwdn) == dDataStart))
            return dBlockNode;
    return (DWORD)-1;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | mwFindAnyFreeBlockNode |
    Locates a free node with no data attached.  If there is none, it forces
    more to be allocated.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns a node with no data attached, else -1 if no memory is available.
    The node returned is marked as a free node, and need not be discarded if
    not used.
*/

PRIVATE DWORD PASCAL NEAR mwFindAnyFreeBlockNode(
    PWAVEDESC   pwd)
{
    LPWAVEDATANODE  lpwdn;
    DWORD   dCurBlockNode;

    for (lpwdn = LPWDN(pwd, 0), dCurBlockNode = 0; dCurBlockNode < pwd->dWaveDataNodes; lpwdn++, dCurBlockNode++)
        if (ISFREEBLOCKNODE(lpwdn) && !lpwdn->dTotalLength)
            return dCurBlockNode;
    return mwAllocMoreBlockNodes(pwd);
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   BOOL | CopyBlockData |
    Copies <p>wLength<d> bytes of data pointed to by the <p>lpwdnSrc<d>
    node to the data pointed to by the <p>lpwdnDst<d> node, starting at
    <p>dSrc<d> to <p>dDst<d>.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   <t>LPWAVEDATANODE<d> | lpwdnSrc |
    Points to the source node.

@parm   <t>LPWAVEDATANODE<d> | lpwdnDst |
    Points to the destination node.

@parm   DWORD | dSrc |
    Indicates the starting offset at which the data is located.

@parm   DWORD | dDst |
    Indicates the starting offset at which to place the data.

@parm   DWORD | dLength |
    Indicates the number of bytes of data to move.

@rdesc  Returns TRUE if the data was copied, else FALSE if no memory is
    available, or if a read or write error occured.  If an error occurs,
    the task error state is set.

@comm   Note that this function will not compile with C 6.00A -Ox.
*/

PRIVATE BOOL PASCAL NEAR CopyBlockData(
    PWAVEDESC   pwd,
    LPWAVEDATANODE  lpwdnSrc,
    LPWAVEDATANODE  lpwdnDst,
    DWORD   dSrc,
    DWORD   dDst,
    DWORD   dLength)
{
    LPBYTE  lpbBuffer;
    UINT    wError;

    if (0 != (lpbBuffer = GlobalAlloc(GMEM_FIXED, dLength))) {
	if (!MySeekFile(pwd->hTempBuffers, UNMASKDATASTART(lpwdnSrc) + dSrc) ||
	    !MyReadFile(pwd->hTempBuffers, lpbBuffer, dLength, NULL) ||
	    !MySeekFile(pwd->hTempBuffers, UNMASKDATASTART(lpwdnDst) + dDst))
	{
	    wError = MCIERR_FILE_READ;
	} else {
	    if (MyWriteFile(pwd->hTempBuffers, lpbBuffer, dLength, NULL))
	    {
		wError = 0;
	    } else {
		wError = MCIERR_FILE_WRITE;
	    }
	}
        GlobalFree(lpbBuffer);
    } else
        wError = MCIERR_OUT_OF_MEMORY;

    if (wError) {
        pwd->wTaskError = wError;
        return FALSE;
    }
    return TRUE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | mwSplitCurrentDataNode |
    Splits the current node at the current position, creating a new node
    to contain the rest of the data, and possibly creating a second node
    to hold data not aligned on a block boundary, in the case of temporary
    data.  The new node returned will have free temporary data space
    attached that is at least <p>wMinDataLength<d> bytes in length.

    If the split point is at the start of the current node, then the new
    node is just inserted in front of the current node.

    If the split point is at the end of the data of the current node, then
    the new node is just inserted after the current node.

    Else the current node must actually be split.  This means that a new
    block to point to the data after the split point is created.  If the
    current node points to temporary data and the split point is not block
    aligned, then any extra data needs to be copied over to the new node
    that is being inserted.  This is because all starting points for
    temporary data are block aligned.  If this is not temporary data,
    then the starting and ending points can just be adjusted to the exact
    split point, instead of having to be block aligned.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dMinDataLength |
    Indicates the minimum size of temporary data space that is to be
    available to the new data node returned.

@rdesc  Returns the new node after the split, which is linked to the point
    after the current position in the current node.  This node becomes the
    current node.  Returns -1 if no memory was available, or a file error
    occurred, in which case the task error code is set.
*/

PRIVATE DWORD PASCAL NEAR mwSplitCurrentDataNode(
    PWAVEDESC   pwd,
    DWORD   dMinDataLength)
{
    LPWAVEDATANODE  lpwdn;
    LPWAVEDATANODE  lpwdnNew;
    DWORD   dNewDataNode;
    DWORD   dSplitAtData;
    BOOL    fTempData;

    dSplitAtData = pwd->dCur - pwd->dVirtualWaveDataStart;
    lpwdn = LPWDN(pwd, pwd->dWaveDataCurrentNode);
    fTempData = ISTEMPDATA(lpwdn);
    if (fTempData)
        dMinDataLength += pwd->dAudioBufferLen;
    dNewDataNode = mwFindAnyFreeDataNode(pwd, dMinDataLength);
    if (dNewDataNode == -1)
        return (DWORD)-1;
    lpwdnNew = LPWDN(pwd, dNewDataNode);
    if (!dSplitAtData) {
        if (pwd->dWaveDataCurrentNode == pwd->dWaveDataStartNode)
            pwd->dWaveDataStartNode = dNewDataNode;
        else {
            LPWAVEDATANODE  lpwdnCur;

            for (lpwdnCur = LPWDN(pwd, pwd->dWaveDataStartNode); lpwdnCur->dNextWaveDataNode != pwd->dWaveDataCurrentNode; lpwdnCur = LPWDN(pwd, lpwdnCur->dNextWaveDataNode))
                ;
            lpwdnCur->dNextWaveDataNode = dNewDataNode;
        }
        lpwdnNew->dNextWaveDataNode = pwd->dWaveDataCurrentNode;
    } else if (dSplitAtData == lpwdn->dDataLength) {
        lpwdnNew->dNextWaveDataNode = lpwdn->dNextWaveDataNode;
        lpwdn->dNextWaveDataNode = dNewDataNode;
        pwd->dVirtualWaveDataStart += lpwdn->dDataLength;
    } else {
        DWORD   dEndBlockNode;
        LPWAVEDATANODE  lpwdnEnd;
        DWORD   dSplitPoint;

        if ((dEndBlockNode = mwFindAnyFreeBlockNode(pwd)) == -1) {
            RELEASEBLOCKNODE(lpwdnNew);
            return (DWORD)-1;
        }
        lpwdnEnd = LPWDN(pwd, dEndBlockNode);
        if (fTempData) {
            dSplitPoint = ROUNDDATA(pwd, dSplitAtData);
            if (dSplitPoint != dSplitAtData) {
                if (!CopyBlockData(pwd, lpwdn, lpwdnNew, dSplitAtData, 0, dSplitPoint - dSplitAtData)) {
                    RELEASEBLOCKNODE(lpwdnNew);
                    return (DWORD)-1;
                }
                lpwdnNew->dDataLength = dSplitPoint - dSplitAtData;
            }
        } else
            dSplitPoint = dSplitAtData;
        lpwdnEnd->dNextWaveDataNode = lpwdn->dNextWaveDataNode;
        lpwdnEnd->dDataStart = lpwdn->dDataStart + dSplitPoint;
        lpwdnEnd->dDataLength = lpwdn->dDataLength - dSplitPoint;
        lpwdnEnd->dTotalLength = lpwdn->dTotalLength - dSplitPoint;
        lpwdnNew->dNextWaveDataNode = dEndBlockNode;
        lpwdn->dDataLength = dSplitAtData;
        lpwdn->dTotalLength = dSplitPoint;
        lpwdn->dNextWaveDataNode = dNewDataNode;
        pwd->dVirtualWaveDataStart += lpwdn->dDataLength;
    }
    pwd->dWaveDataCurrentNode = dNewDataNode;
    return dNewDataNode;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | GatherAdjacentFreeDataNodes |
    This function is used to attempt to consolidate adjacent temporary
    data pointed to by free nodes so that a write can place data into
    a single node.  This is done by repeatedly requesting any free data
    node whose data points to the end of the node's data passed.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   <t>LPWAVEDATANODE<d> | lpwdn |
    Points to the node which is to collect adjacent temporary data.

@parm   DWORD | dStartPoint |
    Indicates the starting point to use when calculating the amount of
    data retrieved.  This is just subtracted from the total length of
    the data attached to the node.

@parm   DWORD | dBufferLength |
    Indicates the amount of data to retrieve.

@rdesc  Returns the amount of data actually retrieved, adjusted by
    <d>dStartPoint<d>.
*/

PRIVATE DWORD PASCAL NEAR GatherAdjacentFreeDataNodes(
    PWAVEDESC   pwd,
    LPWAVEDATANODE  lpwdn,
    DWORD   dStartPoint,
    DWORD   dBufferLength)
{
    for (; lpwdn->dTotalLength - dStartPoint < dBufferLength;) {
        DWORD   dFreeDataNode;
        LPWAVEDATANODE  lpwdnFree;

        dFreeDataNode = mwFindThisFreeDataNode(pwd, UNMASKDATASTART(lpwdn) + lpwdn->dTotalLength);
        if (dFreeDataNode == -1)
            break;
        lpwdnFree = LPWDN(pwd, dFreeDataNode);
        lpwdn->dTotalLength += lpwdnFree->dTotalLength;
        lpwdnFree->dTotalLength = 0;
    }
    return min(dBufferLength, lpwdn->dTotalLength - dStartPoint);
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   <t>LPWAVEDATANODE<d> | NextDataNode |
    Locates a free data node with the specified amount of data, and inserts
    it after the current node, setting the current node to be this new
    node.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   DWORD | dBufferLength |
    Indicates the minimum amount of data that is to be available to the
    new node inserted.

@rdesc  Returns the newly inserted node, else NULL on error, in which case the
    task error code is set.
*/

PRIVATE LPWAVEDATANODE PASCAL NEAR NextDataNode(
    PWAVEDESC   pwd,
    DWORD   dBufferLength)
{
    DWORD   dWaveDataNew;
    LPWAVEDATANODE  lpwdn;
    LPWAVEDATANODE  lpwdnNew;

    if ((dWaveDataNew = mwFindAnyFreeDataNode(pwd, dBufferLength)) == -1)
        return NULL;
    lpwdn = LPWDN(pwd, pwd->dWaveDataCurrentNode);
    lpwdnNew = LPWDN(pwd, dWaveDataNew);
    lpwdnNew->dNextWaveDataNode = lpwdn->dNextWaveDataNode;
    lpwdn->dNextWaveDataNode = dWaveDataNew;
    pwd->dWaveDataCurrentNode = dWaveDataNew;
    pwd->dVirtualWaveDataStart += lpwdn->dDataLength;
    return lpwdnNew;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   BOOL | AdjustLastTempData |
    This function makes two passes through the nodes that are affected by
    an overwrite record.  These are nodes that are either no longer needed,
    or whose starting point needs to be adjusted.  The two passes allow
    any data to be successfully copied before removing any unneeded nodes.
    This creates a more graceful exit to any failure.

    The first pass locates the last node affected.  If that node points to
    temporary data, and the end of the overwrite does not fall on a block
    aligned boundary, then any extra data must be copied to a block aligned
    boundary.  This means that a new node might need to be created if the
    amount of data to be copied is greater than one block's worth.  If the
    end of overwrite happens to fall on a block boundary, then no copying
    need be done.  In either case the data start point is adjusted to
    compensate for the data logically overwritten in this node, and the
    total overwrite length is adjusted so that this node is not checked on
    the second pass.

    The second pass just frees nodes that become empty, and removes them
    from the linked list of in-use nodes.  When the last node affected is
    encountered, either it will point to temporary data, in which case be
    already adjusted, or point to original data, which must be adjusted.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   <t>LPWAVEDATANODE<d> | lpwdn |
    Points to the node which is being adjusted for.  It contains the new
    data.

@parm   DWORD | dStartPoint |
    Contains the starting point at which data was overwritten.

@parm   DWORD | dWriteSize |
    Contains the amount of data overwritten.

@rdesc  Returns TRUE if the nothing needed to be adjusted, or the last node
    in the overwrite pointed to temporary data, and it was moved correctly,
    else FALSE if no memory was available, or a file error occurred.  In
    that case the task error code is set.
*/

PRIVATE BOOL PASCAL NEAR AdjustLastTempData(
    PWAVEDESC   pwd,
    LPWAVEDATANODE  lpwdn,
    DWORD   dStartPoint,
    DWORD   dWriteSize)
{
    LPWAVEDATANODE  lpwdnCur;
    DWORD   dLength;

    if ((lpwdn->dDataLength - dStartPoint >= dWriteSize) || (lpwdn->dNextWaveDataNode == ENDOFNODES))
        return TRUE;
    dWriteSize -= (lpwdn->dDataLength - dStartPoint);
    for (dLength = dWriteSize, lpwdnCur = lpwdn;;) {
        LPWAVEDATANODE  lpwdnNext;

        lpwdnNext = LPWDN(pwd, lpwdnCur->dNextWaveDataNode);
        if (lpwdnNext->dDataLength >= dLength) {
            DWORD   dNewBlockNode;
            DWORD   dMoveData;

            if (!ISTEMPDATA(lpwdnNext) || (lpwdnNext->dDataLength == dLength))
                break;
            if (lpwdnNext->dDataLength - dLength > ROUNDDATA(pwd, 1)) {
                if ((dNewBlockNode = mwFindAnyFreeBlockNode(pwd)) == -1)
                    return FALSE;
            } else
                dNewBlockNode = (DWORD)-1;
            dMoveData = min(ROUNDDATA(pwd, dLength), lpwdnNext->dDataLength) - dLength;
            if (dMoveData && !CopyBlockData(pwd, lpwdnNext, lpwdnNext, dLength, 0, dMoveData))
                return FALSE;
            if (dNewBlockNode != -1) {
                lpwdnCur = LPWDN(pwd, dNewBlockNode);
                lpwdnCur->dDataStart = lpwdnNext->dDataStart + dLength + dMoveData;
                lpwdnCur->dDataLength = lpwdnNext->dDataLength - (dLength + dMoveData);
                lpwdnCur->dTotalLength = lpwdnNext->dTotalLength - (dLength + dMoveData);
                lpwdnCur->dNextWaveDataNode = lpwdnNext->dNextWaveDataNode;
                lpwdnNext->dNextWaveDataNode = dNewBlockNode;
                lpwdnNext->dTotalLength = dLength + dMoveData;
            }
            lpwdnNext->dDataLength = dMoveData;
            dWriteSize -= dLength;
            break;
        } else if ((!ISTEMPDATA(lpwdnNext)) && (lpwdnNext->dNextWaveDataNode == ENDOFNODES))
            break;
        dLength -= lpwdnNext->dDataLength;
        lpwdnCur = lpwdnNext;
    }
    for (;;) {
        LPWAVEDATANODE  lpwdnNext;

        lpwdnNext = LPWDN(pwd, lpwdn->dNextWaveDataNode);
        if (lpwdnNext->dDataLength > dWriteSize) {
            if (dWriteSize) {
                lpwdnNext->dDataStart += dWriteSize;
                lpwdnNext->dDataLength -= dWriteSize;
                lpwdnNext->dTotalLength -= dWriteSize;
            }
            return TRUE;
        }
        dWriteSize -= lpwdnNext->dDataLength;
        lpwdn->dNextWaveDataNode = lpwdnNext->dNextWaveDataNode;
        if (!ISTEMPDATA(lpwdnNext))
            lpwdnNext->dTotalLength = 0;
        RELEASEBLOCKNODE(lpwdnNext);
        if (lpwdn->dNextWaveDataNode == ENDOFNODES)
            return TRUE;
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   BOOL | mwOverWrite |
    This function overwrites data in the wave file from the specified wave
    buffer.  The position is taken from the <e>WAVEDESC.dCur<d> pointer,
    which is updated with the number of bytes actually overwritten.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   LPBYTE | lpbBuffer |
    Points to a buffer to containing the data written.

@parm   DWORD | dBufferLength |
    Indicates the byte length of the buffer.

@rdesc  Returns TRUE if overwrite succeeded, else FALSE on an error.
*/

PRIVATE BOOL PASCAL NEAR mwOverWrite(
    PWAVEDESC   pwd,
    LPBYTE  lpbBuffer,
    DWORD   dBufferLength)
{
    LPWAVEDATANODE  lpwdn;

    lpwdn = LPWDN(pwd, pwd->dWaveDataCurrentNode);
    for (; dBufferLength;)
        if (ISTEMPDATA(lpwdn)) {
            DWORD   dStartPoint;
            DWORD   dRemainingSpace;
            DWORD   dMaxWrite;

            dStartPoint = pwd->dCur - pwd->dVirtualWaveDataStart;
            dRemainingSpace = min(dBufferLength, lpwdn->dTotalLength - dStartPoint);
            if (dRemainingSpace == dBufferLength)
                dMaxWrite = dBufferLength;
            else if (UNMASKDATASTART(lpwdn) + lpwdn->dTotalLength == pwd->dWaveTempDataLength) {
                dMaxWrite = dBufferLength;
                lpwdn->dTotalLength += ROUNDDATA(pwd, dBufferLength - dRemainingSpace);
                pwd->dWaveTempDataLength += ROUNDDATA(pwd, dBufferLength - dRemainingSpace);
            } else
                dMaxWrite = GatherAdjacentFreeDataNodes(pwd, lpwdn, dStartPoint, dBufferLength);
            if (dMaxWrite) {
                DWORD   dWriteSize;

		if (!MySeekFile(pwd->hTempBuffers, UNMASKDATASTART(lpwdn) + dStartPoint)) {
                    pwd->wTaskError = MCIERR_FILE_WRITE;
                    break;
                }
		if (MyWriteFile(pwd->hTempBuffers, lpbBuffer, dMaxWrite, &dWriteSize)) {
                    if (!AdjustLastTempData(pwd, lpwdn, dStartPoint, dWriteSize))
                        break;
                    if (lpwdn->dDataLength < dStartPoint + dWriteSize)
                        lpwdn->dDataLength = dStartPoint + dWriteSize;
                    lpbBuffer += dWriteSize;
                    dBufferLength -= dWriteSize;
                    pwd->dCur += dWriteSize;
                    if (pwd->dVirtualWaveDataStart + lpwdn->dDataLength > pwd->dSize)
                        pwd->dSize = pwd->dVirtualWaveDataStart + lpwdn->dDataLength;
                }
                if (dWriteSize != dMaxWrite) {
                    pwd->wTaskError = MCIERR_FILE_WRITE;
                    break;
                }
            }
            if (dBufferLength && !(lpwdn = NextDataNode(pwd, dBufferLength)))
                break;
        } else {
            DWORD   dWaveDataNew;

            if ((dWaveDataNew = mwSplitCurrentDataNode(pwd, dBufferLength)) != -1)
                lpwdn = LPWDN(pwd, dWaveDataNew);
            else
                break;
        }
    return !dBufferLength;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   BOOL | mwInsert |
    This function inserts data to the wave file from the specified wave
    buffer.  The position is taken from the <e>WAVEDESC.dCur<d> pointer,
    which is updated with the number of bytes actually written.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   LPBYTE | lpbBuffer |
    Points to a buffer to containing the data written.

@parm   DWORD | dBufferLength |
    Indicates the byte length of the buffer.

@rdesc  Returns TRUE if insert succeeded, else FALSE on an error.
*/

PRIVATE BOOL PASCAL NEAR mwInsert(
    PWAVEDESC   pwd,
    LPBYTE  lpbBuffer,
    DWORD   dBufferLength)
{
    LPWAVEDATANODE  lpwdn;

    lpwdn = LPWDN(pwd, pwd->dWaveDataCurrentNode);
    for (; dBufferLength;)
        if (ISTEMPDATA(lpwdn) && (pwd->dCur == pwd->dVirtualWaveDataStart + lpwdn->dDataLength)) {
            DWORD   dStartPoint;
            DWORD   dRemainingSpace;
            DWORD   dMaxInsert;

            dStartPoint = pwd->dCur - pwd->dVirtualWaveDataStart;
            dRemainingSpace = min(dBufferLength, lpwdn->dTotalLength - lpwdn->dDataLength);
            if (dRemainingSpace == dBufferLength)
                dMaxInsert = dBufferLength;
            else if (UNMASKDATASTART(lpwdn) + lpwdn->dTotalLength == pwd->dWaveTempDataLength) {
                dMaxInsert = dBufferLength;
                lpwdn->dTotalLength += ROUNDDATA(pwd, dBufferLength - dRemainingSpace);
                pwd->dWaveTempDataLength += ROUNDDATA(pwd, dBufferLength - dRemainingSpace);
            } else
                dMaxInsert = GatherAdjacentFreeDataNodes(pwd, lpwdn, dStartPoint, dBufferLength);
            if (dMaxInsert) {
                DWORD   dWriteSize;

		if (!MySeekFile(pwd->hTempBuffers, UNMASKDATASTART(lpwdn) + dStartPoint)) {
                    pwd->wTaskError = MCIERR_FILE_WRITE;
                    break;
                }
		if (MyWriteFile(pwd->hTempBuffers, lpbBuffer, dMaxInsert, &dWriteSize)) {
                    lpwdn->dDataLength += dWriteSize;
                    lpbBuffer += dWriteSize;
                    dBufferLength -= dWriteSize;
                    pwd->dCur += dWriteSize;
                    pwd->dSize += dWriteSize;
                }
                if (dWriteSize != dMaxInsert) {
                    pwd->wTaskError = MCIERR_FILE_WRITE;
                    break;
                }
            }
            if (dBufferLength && !(lpwdn = NextDataNode(pwd, dBufferLength)))
                break;
        } else {
            DWORD   dWaveDataNew;

            if ((dWaveDataNew = mwSplitCurrentDataNode(pwd, dBufferLength)) != -1)
                lpwdn = LPWDN(pwd, dWaveDataNew);
            else
                break;
        }
    return !dBufferLength;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   DWORD | mwGetLevel |
    This function finds the highest level in the specified wave sample.
    Note that the function assumes that in some cases the sample size
    is evenly divisable by 4.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   LPBYTE | lpbBuffer |
    Points to a buffer containing the sample whose highest level is to be
    returned.

@parm   int | cbBufferLength |
    Indicates the byte length of the sample buffer.

@rdesc  Returns the highest level encountered in the sample for PCM data only.
    If the device has been opened with one channel, the level is contained
    in the low-order word.  Else if the device has been opened with two
    channels, one channel is in the low-order word, and the other is in the
    high-order word.
*/

PRIVATE DWORD PASCAL NEAR mwGetLevel(
    PWAVEDESC   pwd,
    LPBYTE  lpbBuffer,
    register int    cbBufferLength)
{
    if (pwd->pwavefmt->wFormatTag != WAVE_FORMAT_PCM)
        return 0;
    else if (pwd->pwavefmt->nChannels == 1) {
        int iMonoLevel;

        iMonoLevel = 0;
        if (((NPPCMWAVEFORMAT)(pwd->pwavefmt))->wBitsPerSample == 8)
            for (; cbBufferLength--; lpbBuffer++)
                iMonoLevel = max(*lpbBuffer > 128 ? *lpbBuffer - 128 : 128 - *lpbBuffer, iMonoLevel);
        else if (((NPPCMWAVEFORMAT)(pwd->pwavefmt))->wBitsPerSample == 16)
            for (; cbBufferLength; lpbBuffer += sizeof(SHORT)) {
                iMonoLevel = max(abs(*(PSHORT)lpbBuffer), iMonoLevel);
                cbBufferLength -= sizeof(SHORT);
            }
        else
            return 0;
        return (DWORD)iMonoLevel;
    } else if (pwd->pwavefmt->nChannels == 2) {
        int iLeftLevel;
        int iRightLevel;

        iLeftLevel = 0;
        iRightLevel = 0;
        if (((NPPCMWAVEFORMAT)(pwd->pwavefmt))->wBitsPerSample == 8)
            for (; cbBufferLength;) {
                iLeftLevel = max(*lpbBuffer > 128 ? *lpbBuffer - 128 : 128 - *lpbBuffer, iLeftLevel);
                lpbBuffer++;
                iRightLevel = max(*lpbBuffer > 128 ? *lpbBuffer - 128 : 128 - *lpbBuffer, iRightLevel);
                lpbBuffer++;
                cbBufferLength -= 2;
            }
        else if (((NPPCMWAVEFORMAT)(pwd->pwavefmt))->wBitsPerSample == 16)
            for (; cbBufferLength;) {
                iLeftLevel = max(abs(*(PSHORT)lpbBuffer), iLeftLevel);
                lpbBuffer += sizeof(SHORT);
                iRightLevel = max(abs(*(PSHORT)lpbBuffer), iRightLevel);
                lpbBuffer += sizeof(SHORT);
                cbBufferLength -= 2 * sizeof(SHORT);
            }
        else
            return 0;
        return MAKELONG(iLeftLevel, iRightLevel);
    }
    return 0;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   BOOL | CheckNewCommand |
    This function is called when a New command flag is found during the
    record loop.  It determines if the new commands affect current
    recording enough that it must be terminated.  This can happen if a
    Stop command is received.

    Any other record change does not need to stop current recording, as
    they should just release all the buffers from the wave device before
    setting the command.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns TRUE if the new commands do not affect recording and it should
    continue, else FALSE if the new commands affect the recording, and it
    should be aborted.
*/

REALLYPRIVATE   BOOL PASCAL NEAR CheckNewCommand(
    PWAVEDESC   pwd)
{
    if (ISMODE(pwd, COMMAND_STOP))
        return FALSE;
    if (ISMODE(pwd, COMMAND_INSERT))
        ADDMODE(pwd, MODE_INSERT);
    else
        ADDMODE(pwd, MODE_OVERWRITE);
    REMOVEMODE(pwd, COMMAND_NEW);
    return TRUE;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   <t>HMMIO<d> | CreateSaveFile |
    This function creates the file to which the current data is to be
    saved to in RIFF format.  This is either a temporary file created on
    the same logical disk as the original file (so that this file can
    replace the original file), else a new file.

    The RIFF header and wave header chunks are written to the new file,
    and the file position is at the start of the data to be copied.  Note
    that all the RIFF chunk headers will contain correct lengths, so there
    is no need to ascend out of the data chunk when complete.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@parm   SSZ | sszTempSaveFile |
    Points to a buffer to contain the name of the temporary file created,
    if any.  This is zero length if a new file is to be created instead of
    a temporary file that would replace the original file.

@rdesc  Returns the handle to the save file, else NULL if a create error or
    write error occurred.

@comm   Note that this needs to be fixed so that non-DOS IO systems can save
    the file to the original name by creating a temporary file name through
    MMIO.
*/

PRIVATE HMMIO PASCAL NEAR CreateSaveFile(
    PWAVEDESC   pwd,
    LPWSTR sszTempSaveFile)
{
    MMIOINFO    mmioInfo;
    HMMIO   hmmio;
    LPWSTR   lszFile;

    InitMMIOOpen(pwd, &mmioInfo);
    if (pwd->szSaveFile) {
        *sszTempSaveFile = (char)0;
        lszFile = pwd->szSaveFile;
    } else {
        lstrcpy(sszTempSaveFile, pwd->aszFile);
        if (!mmioOpen(sszTempSaveFile, &mmioInfo, MMIO_GETTEMP)) {
            pwd->wTaskError = MCIERR_FILE_WRITE;
            return NULL;
        }
        lszFile = sszTempSaveFile;
    }
    if (0 != (hmmio = mmioOpen(lszFile, &mmioInfo, MMIO_CREATE | MMIO_READWRITE | MMIO_DENYWRITE))) {
        MMCKINFO    mmck;

        mmck.cksize = sizeof(FOURCC) + sizeof(FOURCC) + sizeof(DWORD) + pwd->wFormatSize + sizeof(FOURCC) + sizeof(DWORD) + pwd->dSize;
        if (pwd->wFormatSize & 1)
            mmck.cksize++;
        mmck.fccType = mmioWAVE;
        if (!mmioCreateChunk(hmmio, &mmck, MMIO_CREATERIFF)) {
            mmck.cksize = pwd->wFormatSize;
            mmck.ckid = mmioFMT;
            if (!mmioCreateChunk(hmmio, &mmck, 0) && (mmioWrite(hmmio, (LPSTR)pwd->pwavefmt, (LONG)pwd->wFormatSize) == (LONG)pwd->wFormatSize) && !mmioAscend(hmmio, &mmck, 0)) {
                mmck.cksize = pwd->dSize;
                mmck.ckid = mmioDATA;
                if (!mmioCreateChunk(hmmio, &mmck, 0))
                    return hmmio;
            }
        }
        pwd->wTaskError = MCIERR_FILE_WRITE;
        mmioClose(hmmio, 0);
    } else
        pwd->wTaskError = MCIERR_FILE_NOT_SAVED;
    return NULL;
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   VOID | mwSaveData |
    This function is used by the background task to save the data to a
    specified file.  This has the effect of making all the temporary data
    now original data, and removing any temporary data file.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Nothing.
*/

PUBLIC  VOID PASCAL FAR mwSaveData(
    PWAVEDESC   pwd)
{
    LPBYTE  lpbBuffer = NULL;
    HANDLE  hMem;
    DWORD   AllocSize = max(min(pwd->dAudioBufferLen, pwd->dSize),1);

    // If there is no wave data, we still allocate 1 byte in order to save a NULL
    // file.  Otherwise we have no choice but to return an error saying "Out of memory"
    hMem = GlobalAlloc(GMEM_MOVEABLE, AllocSize);
    if (hMem) {
	lpbBuffer = GlobalLock(hMem);
	dprintf3(("mwSaveData allocated %d bytes at %8x, handle %8x",
	    	    AllocSize, lpbBuffer, hMem));
	dprintf3(("pwd->AudioBufferLen = %d, pwd->dSize = %d",
	            pwd->dAudioBufferLen, pwd->dSize));
    }
    if (lpbBuffer) {
        WCHAR   aszTempSaveFile[_MAX_PATH];
        HMMIO   hmmioSave;

        if (0 != (hmmioSave = CreateSaveFile(pwd, (SSZ)aszTempSaveFile))) {
            LPWAVEDATANODE  lpwdn;

            lpwdn = LPWDN(pwd, pwd->dWaveDataStartNode);
            for (;;) {
                DWORD   dDataLength;
                BOOL    fTempData;

                fTempData = ISTEMPDATA(lpwdn);
                if (fTempData)
                    MySeekFile(pwd->hTempBuffers, UNMASKDATASTART(lpwdn));
                else
                    mmioSeek(pwd->hmmio, pwd->dRiffData + lpwdn->dDataStart, SEEK_SET);
                for (dDataLength = lpwdn->dDataLength; dDataLength;) {
                    DWORD   dReadSize;

                    dReadSize = min(pwd->dAudioBufferLen, dDataLength);

		    if (dReadSize >= AllocSize) {
			dprintf(("READING TOO MUCH DATA!!"));
		    }

                    if (fTempData) {
                        if (!MyReadFile(pwd->hTempBuffers, lpbBuffer, dReadSize, NULL)) {
                            pwd->wTaskError = MCIERR_FILE_READ;
                            break;
                        }
                    } else if ((DWORD)mmioRead(pwd->hmmio, lpbBuffer, (LONG)dReadSize) != dReadSize) {
                        pwd->wTaskError = MCIERR_FILE_READ;
                        break;
                    }

                    if ((DWORD)mmioWrite(hmmioSave, lpbBuffer, (LONG)dReadSize) != dReadSize) {
                        pwd->wTaskError = MCIERR_FILE_WRITE;
                        break;
                    }
                    dDataLength -= dReadSize;
                }
                if (pwd->wTaskError)
                    break;
                if (lpwdn->dNextWaveDataNode == ENDOFNODES)
                    break;
                lpwdn = LPWDN(pwd, lpwdn->dNextWaveDataNode);
            }
            mmioClose(hmmioSave, 0);
            if (!pwd->wTaskError) {
                MMIOINFO    mmioInfo;
                MMCKINFO    mmckRiff;
                MMCKINFO    mmck;

                if (pwd->hmmio)
                    mmioClose(pwd->hmmio, 0);
                InitMMIOOpen(pwd, &mmioInfo);
                if (pwd->szSaveFile)
                    lstrcpy(pwd->aszFile, pwd->szSaveFile);
                else {
                    if (!mmioOpen(pwd->aszFile, &mmioInfo, MMIO_DELETE))
                        pwd->wTaskError = MCIERR_FILE_WRITE;
                    if (!pwd->wTaskError)
                        if (mmioRename(aszTempSaveFile, pwd->aszFile, &mmioInfo, 0)) {
                            lstrcpy(pwd->aszFile, aszTempSaveFile);
                            *aszTempSaveFile = (char)0;
                        }
                }
                pwd->hmmio = mmioOpen(pwd->aszFile, &mmioInfo, MMIO_READ | MMIO_DENYWRITE);
                if (!pwd->wTaskError) {
                    LPWAVEDATANODE  lpwdn;

                    mmckRiff.fccType = mmioWAVE;
                    mmioDescend(pwd->hmmio, &mmckRiff, NULL, MMIO_FINDRIFF);
                    mmck.ckid = mmioDATA;
                    mmioDescend(pwd->hmmio, &mmck, &mmckRiff, MMIO_FINDCHUNK);
                    pwd->dRiffData = mmck.dwDataOffset;
                    if (pwd->hTempBuffers != INVALID_HANDLE_VALUE) {

			CloseHandle(pwd->hTempBuffers);
                        pwd->dWaveTempDataLength = 0;

                        DeleteFile( pwd->aszTempFile );

                        pwd->hTempBuffers = INVALID_HANDLE_VALUE;
                    }
                    if (pwd->lpWaveDataNode) {
                        GlobalFreePtr(pwd->lpWaveDataNode);
                        pwd->lpWaveDataNode = NULL;
                        pwd->dWaveDataNodes = 0;
                    }
                    pwd->dVirtualWaveDataStart = 0;
                    pwd->dWaveDataCurrentNode = 0;
                    pwd->dWaveDataStartNode = 0;
                    mwAllocMoreBlockNodes(pwd);
                    lpwdn = LPWDN(pwd, 0);
                    lpwdn->dNextWaveDataNode = (DWORD)ENDOFNODES;
                    lpwdn->dDataLength = pwd->dSize;
                    lpwdn->dTotalLength = pwd->dSize;
                    if (!pwd->szSaveFile && !*aszTempSaveFile)
                        pwd->wTaskError = MCIERR_FILE_WRITE;
                }
            }
        }
        GlobalUnlock(hMem);
    } else {
        pwd->wTaskError = MCIERR_OUT_OF_MEMORY;
    }

    if (hMem) {
        GlobalFree(hMem);
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   VOID | mwDeleteData |
    This function is used by the background task to delete data.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Nothing.
*/

PUBLIC  VOID PASCAL FAR mwDeleteData(
    PWAVEDESC   pwd)
{
    DWORD   dTotalToDelete;
    LPWAVEDATANODE  lpwdn;
    LPWAVEDATANODE  lpwdnCur;
    DWORD dVirtualWaveDataStart;

    lpwdn = LPWDN(pwd, pwd->dWaveDataCurrentNode);
    dTotalToDelete = pwd->dTo - pwd->dFrom;

    if (dTotalToDelete == pwd->dSize) {
		// The whole wave chunk is to be deleted - nice and simple
        DWORD   dNewDataNode;

        if ((dNewDataNode = mwFindAnyFreeDataNode(pwd, 1)) == -1) {
			dprintf2(("mwDeleteData - no free data node"));
            return;
		}
        RELEASEBLOCKNODE(LPWDN(pwd, dNewDataNode));
    }

	dprintf3(("mwDeleteData - size to delete = %d", dTotalToDelete));
    for (dVirtualWaveDataStart = pwd->dVirtualWaveDataStart; dTotalToDelete;) {
        DWORD   dDeleteLength;

        dDeleteLength = min(dTotalToDelete, lpwdn->dDataLength - (pwd->dFrom - dVirtualWaveDataStart));
		dprintf4(("mwDelete dTotalToDelete = %d, dDeleteLength = %d", dTotalToDelete, dDeleteLength));

		if (!dDeleteLength) {
			// Nothing to be deleted from this block
			dprintf3(("mwDelete skipping to next block"));
            dVirtualWaveDataStart += lpwdn->dDataLength;
            lpwdn = LPWDN(pwd, lpwdn->dNextWaveDataNode);
			continue;  // iterate around the for loop
		}
		// Note: the block above is new to NT.  Windows 3.1 as shipped fails.
		// The problem can be seen with a wave file > 3 seconds long and
		// the following two commands:
		// delete wave from 1000 to 2000
		// delete wave from 1000 to 2000
		// Because of the fragmentation the second delete fails.  It decided
		// that NO data can be deleted from the first block, but never
		// stepped on to the next block.

        if (ISTEMPDATA(lpwdn)) {
			dprintf3(("mwDeleteData - temporary data"));
            if (dVirtualWaveDataStart + lpwdn->dDataLength <= pwd->dFrom + dTotalToDelete)
                lpwdn->dDataLength -= dDeleteLength;  // Delete data in this block
            else {
                DWORD   dNewBlockNode;
                DWORD   dDeleteStart;
                DWORD   dEndSplitPoint;
                DWORD   dMoveData;

                dDeleteStart = pwd->dFrom - dVirtualWaveDataStart;
                dEndSplitPoint = min(ROUNDDATA(pwd, dDeleteStart + dDeleteLength), lpwdn->dDataLength);
                if (dEndSplitPoint < lpwdn->dDataLength) {
                    if ((dNewBlockNode = mwFindAnyFreeBlockNode(pwd)) == -1)
                        break;
                } else
                    dNewBlockNode = (DWORD)-1;
                dMoveData = dEndSplitPoint - (dDeleteStart + dDeleteLength);
                if (dMoveData && !CopyBlockData(pwd, lpwdn, lpwdn, dDeleteStart + dDeleteLength, dDeleteStart, dMoveData))
                    break;
                if (dNewBlockNode != -1) {
                    lpwdnCur = LPWDN(pwd, dNewBlockNode);
                    lpwdnCur->dDataStart = lpwdn->dDataStart + dEndSplitPoint;
                    lpwdnCur->dDataLength = lpwdn->dDataLength - dEndSplitPoint;
                    lpwdnCur->dTotalLength = lpwdn->dTotalLength - dEndSplitPoint;
                    lpwdnCur->dNextWaveDataNode = lpwdn->dNextWaveDataNode;
                    lpwdn->dNextWaveDataNode = dNewBlockNode;
                    lpwdn->dTotalLength = dEndSplitPoint;
                }
                lpwdn->dDataLength = dDeleteStart + dMoveData;
            }
        } else if (dVirtualWaveDataStart == pwd->dFrom) {
			// FROM point is the same as the virtual start point, hence we are
			// deleting from the beginning of this wave data block.  We can
			// simply adjust the total length and start point.
			dprintf4(("mwDeleteData - From == Start, deleting from start of block"));
            lpwdn->dDataStart += dDeleteLength;
            lpwdn->dDataLength -= dDeleteLength;
            lpwdn->dTotalLength = lpwdn->dDataLength;
        } else if (dVirtualWaveDataStart + lpwdn->dDataLength <= pwd->dFrom + dTotalToDelete) {
			// FROM point plus amount to delete takes us to the end of the wave
			// data - meaning that the data block can be truncated. We can
			// simply adjust the total length.
			dprintf4(("mwDeleteData - delete to end of block"));
            lpwdn->dDataLength -= dDeleteLength;
            lpwdn->dTotalLength = lpwdn->dDataLength;
        } else {
			// We have to delete a chunk out of the middle.
            DWORD   dNewBlockNode;
            DWORD   dDeleteStart;

			// The existing single block will now be covered by two blocks
			// Find a new node, then set the current node start->deletefrom
			// and the new node deletefrom+deletelength for the remaining
			// length of this node.  It all hinges on finding a free node...
            if ((dNewBlockNode = mwFindAnyFreeBlockNode(pwd)) == -1) {
				dprintf2(("mwDeleteData - cannot find free node"));
                break;
			}

            dDeleteStart = pwd->dFrom - dVirtualWaveDataStart;
            lpwdnCur = LPWDN(pwd, dNewBlockNode);
            lpwdnCur->dDataStart = dVirtualWaveDataStart + dDeleteStart + dDeleteLength;
            lpwdnCur->dDataLength = lpwdn->dDataLength - (dDeleteStart + dDeleteLength);
            lpwdnCur->dTotalLength = lpwdnCur->dDataLength;
            lpwdnCur->dNextWaveDataNode = lpwdn->dNextWaveDataNode;
            lpwdn->dDataLength = dDeleteStart;
            lpwdn->dTotalLength = dDeleteStart;
            lpwdn->dNextWaveDataNode = dNewBlockNode;
        }
        dTotalToDelete -= dDeleteLength;
        if (!lpwdn->dDataLength && dTotalToDelete) {
            dVirtualWaveDataStart += lpwdn->dDataLength;
            lpwdn = LPWDN(pwd, lpwdn->dNextWaveDataNode);
			dprintf4(("mwDeleteData - more to delete, iterating"));
		}
    }

    pwd->dSize -= ((pwd->dTo - pwd->dFrom) + dTotalToDelete);
    for (lpwdn = NULL, lpwdnCur = LPWDN(pwd, pwd->dWaveDataStartNode);;) {
        if (!lpwdnCur->dDataLength) {
            if (lpwdn) {
                if (pwd->dWaveDataCurrentNode == lpwdn->dNextWaveDataNode)
                    pwd->dWaveDataCurrentNode = lpwdnCur->dNextWaveDataNode;
                lpwdn->dNextWaveDataNode = lpwdnCur->dNextWaveDataNode;
            } else {
                if (pwd->dWaveDataCurrentNode == pwd->dWaveDataStartNode)
                    pwd->dWaveDataCurrentNode = lpwdnCur->dNextWaveDataNode;
                pwd->dWaveDataStartNode = lpwdnCur->dNextWaveDataNode;
            }
            RELEASEBLOCKNODE(lpwdnCur);
        }
        if (lpwdnCur->dNextWaveDataNode == ENDOFNODES){
            break;
		}
        lpwdn = lpwdnCur;
        lpwdnCur = LPWDN(pwd, lpwdn->dNextWaveDataNode);
    }

    if (!pwd->dSize) {

        pwd->dWaveDataStartNode = mwFindAnyFreeDataNode(pwd, 1);
        pwd->dWaveDataCurrentNode = pwd->dWaveDataStartNode;
        lpwdn = LPWDN(pwd, pwd->dWaveDataStartNode);
        lpwdn->dNextWaveDataNode = (DWORD)ENDOFNODES;

    } else if (pwd->dWaveDataCurrentNode == ENDOFNODES) {

        pwd->dVirtualWaveDataStart = 0;
        pwd->dWaveDataCurrentNode = pwd->dWaveDataStartNode;

        for (lpwdn = LPWDN(pwd, pwd->dWaveDataStartNode); pwd->dFrom > pwd->dVirtualWaveDataStart + lpwdn->dDataLength;) {

            pwd->dVirtualWaveDataStart += lpwdn->dDataLength;
            pwd->dWaveDataCurrentNode = lpwdn->dNextWaveDataNode;
            lpwdn = LPWDN(pwd, pwd->dWaveDataCurrentNode);
        }
    }
}

/************************************************************************/
/*
@doc    INTERNAL MCIWAVE

@func   UINT | RecordFile |
    This function is used to Cue or Record wave device input.  For normal
    recording mode the function basically queues buffers on the wave
    device, and writes them to a file as they are filled, blocking for
    each buffer.  It also makes sure to call <f>mmYield<d> while both
    writing out new buffers, and waiting for buffers to be filled.  This
    means that it will try to add all the buffers possible to the input
    wave device, and then write them as fast as possible.

    For Cue mode, the function also tries to add buffers to the wave
    input device, but nothing is ever written out, and only the highest
    level is calculated.

    Within the record loop, the function first checks to see if there
    is a Cue mode buffer waiting, and if so, waits for it.  This allows
    only one buffer to be added to the device when in Cue mode.  The
    current level is calculated with the contents of the buffer.

    If the function is not in Cue mode, or there is not currently a
    queued buffer, the function tries to add a new buffer to the input
    wave device.  This cannot occur if a new command is pending, or there
    are no buffers available.  This means that in normal recording mode,
    there will possibly be extra data recorded that does not need to be.
    If an error occurs adding the buffer to the wave device, the record
    function is aborted with an error, else the current outstanding buffer
    count is incremented, and a pointer to the next available recording
    buffer is fetched.

    If no new buffers can be added, the existing buffers are written to
    the file.  This section cannot be entered in Cue mode, as it is
    dealt with in the first condition.  The task is blocked pending a
    signal from the wave device that a buffer has been filled.  It then
    checks to see if any more data needs to be recorded before attempting
    to write that data.  Note that all filled buffers are dealt with one
    after the other without yielding or otherwise adding new record
    buffers.  If the input capability is much faster than the machine,
    this means that instead of getting a lot of disconnect samples, large
    gaps will be produced.  This loop is broken out of when either all the
    buffers that were added are written, or no more buffers are currently
    ready (checks the WHDR_DONE flag).

    If no buffers need to be written, the loop checks for the new command
    flag, which can possibly interrupt or change the current recording.
    The only thing that can really make a difference is a stop command,
    and as this case is handled after all buffers are written, the loop
    can immediately exit.

    The final default condition occurs when all the data has been recorded,
    all the buffers have been released, and no new command was encountered.
    In this case, recording is done, and the record loop is exited.

@parm   <t>PWAVEDESC<d> | pwd |
    Pointer to the wave device descriptor.

@rdesc  Returns the number of outstanding buffers added to the wave device.
    This can be used when removing task signal from the message queue.
    In cases of error, the <e>WAVEDESC.wTaskError<d> flag is set.  This
    specific error is not currently returned, as the calling task may not
    have waited for the command to complete.  But it is at least used for
    notification in order to determine if Failure status should be sent.

@xref   PlayFile.
*/

PUBLIC  UINT PASCAL FAR RecordFile(
    register PWAVEDESC  pwd)
{
    LPWAVEHDR   *lplpWaveHdrRecord;
    LPWAVEHDR   *lplpWaveHdrWrite;
    UINT        wMode;
    register UINT   wBuffersOutstanding;

    if (0 != (pwd->wTaskError = waveInStart(pwd->hWaveIn)))
        return 0;

    for (wBuffersOutstanding = 0, lplpWaveHdrRecord = lplpWaveHdrWrite = pwd->rglpWaveHdr;;) {

        if (ISMODE(pwd, COMMAND_CUE) && wBuffersOutstanding) {
            if (TaskBlock() == WM_USER) {
                wBuffersOutstanding--;
            }

            if (!ISMODE(pwd, COMMAND_NEW)) {
                pwd->dLevel = mwGetLevel(pwd, (*lplpWaveHdrWrite)->lpData, (int)(*lplpWaveHdrWrite)->dwBytesRecorded);
                ADDMODE(pwd, MODE_CUED);
            }

            lplpWaveHdrWrite = NextWaveHdr(pwd, lplpWaveHdrWrite);

        } else if (!ISMODE(pwd, COMMAND_NEW) && (wBuffersOutstanding < pwd->wAudioBuffers)) {

            (*lplpWaveHdrRecord)->dwBufferLength = (pwd->wMode & COMMAND_CUE) ? NUM_LEVEL_SAMPLES : min(pwd->dAudioBufferLen, pwd->dTo - pwd->dCur);
            (*lplpWaveHdrRecord)->dwFlags &= ~(WHDR_DONE | WHDR_BEGINLOOP | WHDR_ENDLOOP);
            if (0 != (pwd->wTaskError = waveInAddBuffer(pwd->hWaveIn, *lplpWaveHdrRecord, sizeof(WAVEHDR))))
                break;

            wBuffersOutstanding++;
            lplpWaveHdrRecord = NextWaveHdr(pwd, lplpWaveHdrRecord);

        } else if (wBuffersOutstanding) {

            BOOL    fExitRecording;

            for (fExitRecording = FALSE; wBuffersOutstanding && !fExitRecording;) {

                if (TaskBlock() == WM_USER) {
                    wBuffersOutstanding--;
                }
                if (pwd->dTo == pwd->dCur) {
                    fExitRecording = TRUE;
                    break;
                }
                if (!(pwd->wMode & COMMAND_CUE))
                    if (pwd->wMode & MODE_INSERT) {
                        if (!mwInsert(pwd, (LPBYTE)(*lplpWaveHdrWrite)->lpData, min((*lplpWaveHdrWrite)->dwBytesRecorded, pwd->dTo - pwd->dCur)))
                            fExitRecording = TRUE;
                    } else if (!mwOverWrite(pwd, (LPBYTE)(*lplpWaveHdrWrite)->lpData, min((*lplpWaveHdrWrite)->dwBytesRecorded, pwd->dTo - pwd->dCur)))
                        fExitRecording = TRUE;
                lplpWaveHdrWrite = NextWaveHdr(pwd, lplpWaveHdrWrite);
                if (!((*lplpWaveHdrWrite)->dwFlags & WHDR_DONE))
                    break;
            }

            if (fExitRecording)
                break;

        } else if (!ISMODE(pwd, COMMAND_NEW) || !CheckNewCommand(pwd))
            break;
        else
            wMode = GETMODE(pwd);

        mmYield(pwd);
    }
    REMOVEMODE(pwd, MODE_INSERT | MODE_OVERWRITE);
    return wBuffersOutstanding;
}

/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\clisti.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  CLISTI.ASM - Enter/leave critical sections
;
; Created:  18 April 1994
; Author:   Jim Geist [jimge]
;
; Copyright (c) 1984-1995 Microsoft Corporation
;
;-----------------------------------------------------------------------;

        ?PLM    = 1
        ?WIN    = 0
        PMODE   = 1

        .xlist
        include cmacros.inc
        .list

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs, CodeSeg

        public  EnterCrit
EnterCrit       proc    near
                pop     ax                      ; Near return address
                pushf                           ; Save flags
                cli                             ; Interrupts off
                push    ax                      ; Near return address
                ret                             ; and return
EnterCrit       endp

        public  LeaveCrit
LeaveCrit       proc    near
                pop     ax                      ; Near return address
                pop     bx                      ; Flag state
                test    bx, 0200h               ; Interrupts should be on?
                jz      short @F                ; Nope
                sti                             ; Yep
@@:             push    ax                      ; Near return address
                ret                             ; and return
LeaveCrit       endp

sEnd    CodeSeg

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\cookmap.c ===
/**********************************************************************

  Copyright (c) 1992-1998 Microsoft Corporation

  cookmap.c

  DESCRIPTION:
    Non-fixed code for doing cooked-mode output mapping. 

  HISTORY:
     03/04/94       [jimge]        created.

*********************************************************************/

#include "preclude.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "idf.h"

#include <memory.h>

#include "midimap.h"
#include "debug.h"

/***************************************************************************
  
   @doc internal
  
   @api int | MapCookedBuffer | Perform output mapping of a polymsg buffer.

   @parm PINSTANCE | pinstance | Instance owning the polymsg buffer.

   @parm LPMIDIHDR | lpmh | The buffer to map.

   @comm
    Map this buffer (which may allocate more channels to us).

    Build array of used ports and physical channels used on each port.

    Acquire shadow buffers and a sync object and set them up.

    Queue the sync object and send it if there isn't anything playing.

   @rdesc | MMSYSERR_xxx.
       
***************************************************************************/
#define SKIP_BYTES(x,s)                 \
{                                       \
    if (cbBuffer < (x))                 \
    {                                   \
        DPF(1, TEXT ("MapCookedBuffer: ran off end of polymsg buffer in parse! %ls"), (LPTSTR)(s)); \
        mmRet = MMSYSERR_INVALPARAM;    \
        goto CLEANUP;                   \
    }                                   \
    ((LPBYTE)lpdwBuffer) += (x);        \
    cbBuffer -= (x);                    \
}

MMRESULT FNGLOBAL MapCookedBuffer(
    PINSTANCE               pinstance,
    LPMIDIHDR               lpmhParent)
{
    LPDWORD                 lpdwBuffer;
    DWORD                   cbBuffer;
    BYTE                    bEventType;
    DWORD                   dwEvent;
    DWORD                   dwStreamID = 0;
    MMRESULT                mmRet;
    LPMIDIHDR               lpmh;
    PSHADOWBLOCK            psb;

    mmRet = MMSYSERR_NOERROR;

    psb = (PSHADOWBLOCK)(UINT_PTR)lpmhParent->dwReserved[MH_SHADOW];
    lpmh = psb->lpmhShadow;
    
    DPF(2, TEXT ("Map: pinstance %04X lpmh %p"), (WORD)pinstance, lpmh);

    lpmh->reserved = lpmhParent->reserved;
    lpmh->dwBytesRecorded = lpmhParent->dwBytesRecorded;

    lpmh->dwReserved[MH_MAPINST] = (DWORD_PTR)pinstance;
    
    // In-place map the buffer. Run through it, mapping all of the
    // short events.
    //
    lpdwBuffer = (LPDWORD)lpmh->lpData;
    cbBuffer   = lpmh->dwBytesRecorded;

    while (cbBuffer)
    {
        SKIP_BYTES(sizeof(DWORD), TEXT ("d-time"));

        if (cbBuffer < 2*sizeof(DWORD))
            return MMSYSERR_INVALPARAM;
        
        bEventType = MEVT_EVENTTYPE(lpdwBuffer[1]);
        dwEvent    = MEVT_EVENTPARM(lpdwBuffer[1]);
        
        if (bEventType == MEVT_SHORTMSG)
        {
            dwEvent = MapSingleEvent(pinstance,
                                     dwEvent,
                                     MSE_F_RETURNEVENT,
                                     (DWORD BSTACK *)&dwStreamID);
            
            lpdwBuffer[0] = dwStreamID;
            lpdwBuffer[1] = dwEvent;
        }

        SKIP_BYTES(sizeof(DWORD), TEXT ("stream-id"));
        SKIP_BYTES(sizeof(DWORD), TEXT ("event type"));

        if (bEventType & (MEVT_F_LONG >> 24))
        {
            dwEvent = (dwEvent+3)&~3;
            SKIP_BYTES(dwEvent, TEXT ("long event data"));
        }
    }

    mmRet = midiStreamOut(ghMidiStrm, lpmh, sizeof(MIDIHDR));
    
CLEANUP:
    return mmRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\debug.c ===
//==========================================================================; 
//
//      Copyright (c) 1991-1995 Microsoft Corporation
//
//      You have a royalty-free right to use, modify, reproduce and 
//      distribute the Sample Files (and/or any modified version) in 
//      any way you find useful, provided that you agree that 
//      Microsoft has no warranty obligations or liability for any 
//      Sample Application Files which are modified. 
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//  History:
//      11/23/92    cjp     [curtisp] 
//
//==========================================================================;

#ifdef   DEBUG

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <stdarg.h>

#include "debug.h"

#ifdef WIN32
   #define  BCODE
#else
   #define  BCODE                   __based(__segname("_CODE"))
#endif // End #ifdef WIN32

#ifdef WIN32
   #define GlobalSmartPageLock(a) (TRUE)
#endif // End #ifdef WIN32


#define WSPRINTF_LIMIT 1024

typedef struct tagLOG
{
     LPTSTR             lpszQueue;  // TCHAR Representation
     UINT               cchBuffer;  // Size of Log in TCHAR's
     UINT               idxRead;    // Read index
     UINT               idxWrite;   // Write index
} LOG, FAR *LPLOG;

#define LOG_INCIDX(pl,x) ((++x >= pl->cchBuffer) ? x = 0 : x)

void FAR CDECL DbgVPrintF (LPTSTR szFmt, va_list va);

BOOL NEAR PASCAL LogInit (LPLOG lpLog, UINT ckBuffer);
void NEAR PASCAL LogWrite (LPLOG lpLog, LPTSTR lpstrEvent);
BOOL NEAR PASCAL LogRead (LPLOG lpLog, LPTSTR lpstrBuffer, UINT cchBuffer);

#ifdef ISRDEBUG
int wivsprintf (LPTSTR lpOut, LPCTSTR lpFmt, VOID FAR* lpParms) ;

LPCTSTR NEAR PASCAL SP_GetFmtValue (LPCTSTR lpch, UINT * lpw) ;
UINT    NEAR PASCAL SP_PutNumber (LPTSTR lpb, DWORD n, UINT limit, UINT radix, UINT icase) ;
VOID    NEAR PASCAL SP_Reverse (LPTSTR lpFirst, LPTSTR lpLast) ;
UINT    NEAR PASCAL ilstrlen (LPTSTR lpstr) ;
VOID    NEAR PASCAL ilstrcat (LPTSTR lpstrDest, LPTSTR lpstrSrc) ;
#endif


//
// Use interruptable versions of functions
//

#ifdef ISRDEBUG
   #define wvsprintf        wivsprintf
   #define lstrcat          ilstrcat
   #define lstrlen          ilstrlen    
#endif


//
//
//
BOOL    __gfDbgEnabled  = TRUE;     // master enable
UINT    __guDbgLevel    = 0;        // current debug level
BOOL    __gfLogging     = 0;        // Are we logging as well?

HWND    ghWndCB         = (HWND)NULL;
LOG     gLog;
WORD    wDebugLevel     = 0;


//************************************************************************
//**
//**  WinAssert();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     LPSTR lpstrExp
//**     LPSTR lpstrFile
//**     DWORD dwLine  
//**
//**  RETURNS:
//**     void 
//**
//**  HISTORY:
//**
//************************************************************************

VOID WINAPI WinAssert(
    LPSTR           lpstrExp,
    LPSTR           lpstrFile,
    DWORD           dwLine)
{
    static TCHAR szWork[256];
    static TCHAR BCODE szFormat[] =
        TEXT ("Assertion failed!\n\nFile:\t%s\nLine:\t%lu\n\n[%s]");
    static TCHAR BCODE szOops[] =
        DEBUG_MODULE_NAME TEXT (" is confused"); 

    // Use regular wsprintf here; assert's can't be at interrupt time
    // anyway. 
    //

#ifdef UNICODE
    static TCHAR szFile[256];
    static TCHAR szMsg[256];

      // Convert File to UNICODE
    INT cLen = lstrlenA (lpstrFile);
    if (cLen >= 255)
      cLen = 255;

    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED,
                         lpstrFile, cLen, szFile, 256);
    szFile[cLen] = 0;

      // Convert Message to UNICODE
    cLen = lstrlenA (lpstrExp);
    if (cLen >= 255)
      cLen = 255;

    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED,
                         lpstrExp, cLen, szMsg, 256);
    szMsg[cLen] = 0;

      // Create Assert String
    wsprintf (szWork, szFormat, szFile, dwLine, szMsg);
#else
    wsprintf (szWork, szFormat, lpstrFile, dwLine, lpstrExp);
#endif

    if (IDCANCEL == MessageBox(NULL, szWork, szOops, MB_OKCANCEL|MB_ICONEXCLAMATION))
        DebugBreak();

}


//************************************************************************
//**
//**  DbgVPrintF();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     LPSTR szFmt
//**     LPSTR va
//**
//**  RETURNS:
//**     void 
//**
//**  HISTORY:
//**
//************************************************************************

void FAR CDECL DbgVPrintF(
   LPTSTR   szFmt, 
   va_list  va)
{
    TCHAR   ach[DEBUG_MAX_LINE_LEN];
    BOOL    fDebugBreak = FALSE;
    BOOL    fPrefix     = TRUE;
    BOOL    fCRLF       = TRUE;

    ach[0] = TEXT ('\0');

    for (;;)
    {
        switch(*szFmt)
        {
            case '!':
                fDebugBreak = TRUE;
                szFmt++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFmt++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFmt++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = TEXT ('\007');
        ach[1] = TEXT ('\0');
    }

    if (fPrefix)
        lstrcat (ach, DEBUG_MODULE_NAME TEXT (": "));

    wvsprintf (ach + lstrlen(ach), szFmt, va);

    if (fCRLF)
        lstrcat (ach, TEXT ("\r\n") );

    if (__gfLogging)
    {
        LogWrite (&gLog, ach);
        if (ghWndCB)
            PostMessage (ghWndCB, WM_DEBUGUPDATE, 0, 0);
    }

    OutputDebugString (ach);

    if (fDebugBreak)
        DebugBreak();
} //** DbgVPrintF()


//************************************************************************
//**
//**  dprintf();
//**
//**  DESCRIPTION:
//**     dprintf() is called by the DPF macro if DEBUG is defined at compile
//**     time.
//**     
//**     The messages will be send to COM1: like any debug message. To
//**     enable debug output, add the following to WIN.INI :
//**
//**     [debug]
//**     ICSAMPLE=1
//**
//**
//**  ARGUMENTS:
//**     UINT     uDbgLevel
//**     LPCSTR   szFmt
//**     ...
//**
//**  RETURNS:
//**     void 
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]      
//**
//************************************************************************

void FAR CDECL dprintf(
   UINT     uDbgLevel, 
   LPTSTR   szFmt, 
   ...)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start (va, szFmt);
    DbgVPrintF (szFmt, va);
    va_end (va);
} //** dprintf()


//************************************************************************
//**
//**  DbgEnable();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     BOOL fEnable
//**
//**  RETURNS:
//**     BOOL 
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]      
//**
//************************************************************************

BOOL WINAPI DbgEnable(
   BOOL fEnable)
{
    BOOL    fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} //** DbgEnable()



//************************************************************************
//**
//**  DbgSetLevel();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     UINT uLevel
//**
//**  RETURNS:
//**     UINT 
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]      
//**
//************************************************************************

UINT WINAPI DbgSetLevel(
   UINT uLevel)
{
    UINT    uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = wDebugLevel = uLevel;

    return (uOldLevel);
} //** DbgSetLevel()


//--------------------------------------------------------------------------;
//
//  UINT DbgInitialize(void)
//
//  Description:
//      
//
//  Arguments:
//
//  Return (UINT):
//
//
//  History:
//      11/24/92    cjp     [curtisp] 
//
//--------------------------------------------------------------------------;


UINT WINAPI DbgInitialize(BOOL fEnable)
{
    TCHAR           szTemp[64];
    LPTSTR          pstr;
    UINT            uLevel;
    UINT            uLogMem;
    
    GetProfileString (DEBUG_SECTION, DEBUG_MODULE_NAME, TEXT (""), szTemp, sizeof(szTemp));

    pstr = szTemp;
    uLevel = 0;
    while (*pstr >= TEXT ('0') && *pstr <= TEXT ('9'))
    {
        uLevel = uLevel*10 + (UINT)(*pstr - TEXT ('0'));
        pstr++;
    }

    __gfLogging = FALSE;
    if (*pstr == TEXT (','))
    {
        pstr++;
        uLogMem = 0;
        while (*pstr >= TEXT ('0') && *pstr <= TEXT ('9'))
        {
            uLogMem = uLogMem*10 + (UINT)(*pstr - TEXT ('0'));
            pstr++;
        }

        if (0 == uLogMem) 
           uLogMem = K_DEFAULT_LOGMEM;
        
        if (uLogMem > K_MAX_LOGMEM) 
           uLogMem = K_MAX_LOGMEM;

        __gfLogging = TRUE;
    }
    
    if (__gfLogging)
        __gfLogging = LogInit(&gLog, uLogMem);
    
    DbgSetLevel (GetProfileInt(DEBUG_SECTION, DEBUG_MODULE_NAME, 0));
    DbgEnable (fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

void WINAPI DbgRegisterCallback (HWND hWnd)
{
    ghWndCB = hWnd;
}

BOOL WINAPI DbgGetNextLogEntry (LPTSTR lpstrBuffer, UINT cchBuffer)
{
    if (!__gfLogging)
        return FALSE;

    return LogRead (&gLog, lpstrBuffer, cchBuffer);
}

BOOL NEAR PASCAL LogInit (LPLOG lpLog, UINT ckMem)
{
    DWORD   cbMem = 1024L * ckMem;

    LPTSTR  lpszQueue = GlobalAllocPtr (GPTR, cbMem);
    if (NULL == lpszQueue)
        return FALSE;

    if (! GlobalSmartPageLock (HIWORD(lpszQueue)))
    {
        GlobalFreePtr (lpszQueue);
        return FALSE;
    }

    lpLog->lpszQueue = (LPTSTR)lpszQueue;
    lpLog->cchBuffer = (UINT)cbMem/sizeof(TCHAR);
    lpLog->idxRead   = 0;
    lpLog->idxWrite  = 0;

    return TRUE;
}

void NEAR PASCAL LogWrite (LPLOG lpLog, LPTSTR lpstrEvent)
{
    if (!*lpstrEvent)
        return;

    while (*lpstrEvent)
    {
        lpLog->lpszQueue[lpLog->idxWrite] = *lpstrEvent++;
        LOG_INCIDX (lpLog,lpLog->idxWrite);
    }

    lpLog->idxRead = lpLog->idxWrite;

    while (lpLog->lpszQueue[lpLog->idxRead])
    {
        lpLog->lpszQueue[lpLog->idxRead] = TEXT ('\0');
        LOG_INCIDX(lpLog,lpLog->idxRead);
    }
    
    LOG_INCIDX(lpLog,lpLog->idxRead);
    LOG_INCIDX(lpLog,lpLog->idxWrite);
}

BOOL NEAR PASCAL LogRead(LPLOG lpLog, LPTSTR lpstrBuffer, UINT cchBuffer)
{
    TCHAR                   ch;
    UINT                    idx;

    if (!cchBuffer)
        return FALSE;
    
    idx = lpLog->idxRead;

    while (TEXT ('\0') == lpLog->lpszQueue[idx])
    {
        LOG_INCIDX(lpLog,idx);
        if (idx == lpLog->idxRead)
            return FALSE;
    }

    cchBuffer--;
    while (0 != (ch = lpLog->lpszQueue[idx]))
    {
        if (cchBuffer)
        {
            *lpstrBuffer++ = ch;
            cchBuffer--;
        }
            
        lpLog->lpszQueue[idx] = TEXT ('\0');
        LOG_INCIDX(lpLog,idx);
    }

    *lpstrBuffer = TEXT ('\0');

    LOG_INCIDX (lpLog,idx);

    lpLog->idxRead = idx;
    return TRUE;
}



//--------------------------------------------------------------------------;
//
// The rest of the code is only needed if we're in Win16 and need to be
// interrupt callable.
//
//--------------------------------------------------------------------------;

#ifdef ISRDEBUG

#define OUT(ch) if (--cchLimit) *lpOut++=(ch); else goto error_Out

//************************************************************************
//**
//**  wivsprintf();
//**
//**  DESCRIPTION:
//**     Interrupt callable version of wvsprintf() 
//**
//**
//**  ARGUMENTS:
//**     LPTSTR       lpOut    -  Buffer to format into.
//**     LPCTSTR      lpFmt    -  Format string.
//**     VOID FAR*    lpParms  -  Points to the first of args 
//**                              described by lpFmt.
//**
//**  RETURNS:
//**     int   -  Number of characters stored.
//**
//**  HISTORY:
//**     3/28/93     jfg      [jimge] 
//**
//************************************************************************

int wivsprintf(
    LPTSTR       lpOut,
    LPCTSTR      lpFmt,
    VOID FAR*    lpParms)
{
    int         left ;
    TCHAR       prefix ;
    int         width ;
    int         prec ;
    TCHAR       fillch ;
    int         size ;
    int         sign ;
    int         radix ;
    int         upper ;
    int         cchLimit = WSPRINTF_LIMIT;
    int         cch ;
    LPTSTR      lpT ;
    union
    {
        long            l ;
        unsigned long   ul ;
        TCHAR sz[sizeof(long)] ;
    } val;
                
    while (*lpFmt)
    {
        if (*lpFmt==TEXT ('%'))
        {
            //
            // Read the format flags. 
            //
            left   = 0 ;
            prefix = 0 ;

            while (*++lpFmt)
            {
                if (*lpFmt==TEXT ('-'))
                {    
                    left++;
                }
                else if (*lpFmt==TEXT ('#'))
                {
                    prefix++;
                }
                else
                {
                    break;
                }
            }

            //
            // Find the fill character (either '0' or ' ')
            //
            if (*lpFmt==TEXT ('0'))
            {
                fillch = TEXT ('0') ;
                lpFmt++ ;
            }
            else
            {
                fillch = TEXT (' ') ;
            }

            //
            // Now parse [width[.precision]]
            //
            lpFmt = SP_GetFmtValue(lpFmt,&cch);
            width = cch;

            if (*lpFmt==TEXT ('.'))
            {
                lpFmt = SP_GetFmtValue(++lpFmt,&cch);
                prec = cch;
            }
            else
            {
                prec = (UINT)-1 ;
            }

            //
            // Get the operand size modifier
            //
            if (*lpFmt==TEXT ('l'))
            {
                size = 1 ;
                lpFmt++ ;
            }
            else
            {
                size = 0 ;
                if (*lpFmt==TEXT ('h'))
                {
                    lpFmt++ ;
                }
            }
            
            //
            // We've gotten all the modifier; now format the output
            // based on the type (which should now be pointed at
            // by lpFmt).
            //
            upper = 0 ;
            sign = 0 ;
            radix = 10 ;

            switch (*lpFmt)
            {
                case 0:
                    goto error_Out ;

                case TEXT ('i') :
                case TEXT ('d') :
                    sign++ ;

                case TEXT ('u'):
                    //
                    // Don't show a prefix for decimal formats
                    // 
                    prefix=0 ;
do_Numeric:
                    //
                    // Special cases to act like MSC v5.10
                    //
                    if (left || prec>=0)
                    {
                        fillch = TEXT (' ');
                    }

                    //
                    // Get value from parm list into val union 
                    // 
                    if (size)
                    {
                        val.l=*((long far *)lpParms)++;
                    }
                    else
                    {
                        if (sign)
                        {
                            val.l=(long)*((short far *)lpParms)++;
                        }
                        else
                        {
                            val.ul=(unsigned long)*((unsigned far *)lpParms)++;
                        }
                    }

                    //
                    // Save sign of val.l in sign and set val.l positive.
                    //
                    if (sign && val.l<0L)
                    {
                        val.l=-val.l;
                    }
                    else
                    {
                        sign=0;
                    }

                    //
                    // Save start of output stream for later reverse
                    //
                    lpT = lpOut;

                    //
                    // Blast the number backwards into the user buffer 
                    //
                    cch = SP_PutNumber(lpOut,val.l,cchLimit,radix,upper) ;
                    if (!(cchLimit-=cch))
                        goto error_Out ;

                    lpOut += cch ;
                    width -= cch ;
                    prec -= cch ;

                    if (prec>0)
                    {
                        width -= prec ;
                    }

                    //
                    // Fill in up to precision
                    //
                    while (prec-- > 0)
                    {
                        OUT(TEXT ('0')) ;
                    }

                    if (width>0 && !left)
                    {
                        //
                        // If we're filling with spaces, put sign first 
                        //
                        if (fillch != '0')
                        {
                            if (sign)
                            {
                                sign = 0 ;
                                OUT(TEXT ('-')) ;
                                width-- ;
                            }

                            if (prefix)
                            {
                                OUT(prefix) ;
                                OUT(TEXT ('0')) ;
                                prefix = 0 ;
                            }
                        }

                        if (sign)
                        {
                            width-- ;
                        }

                        //
                        // Now fill to width
                        //
                        while (width-- > 0)
                        {
                            OUT(fillch) ;
                        }

                        //
                        // Still have a sign? 
                        //
                        if (sign)
                        {
                            OUT(TEXT ('-')) ;
                        }

                        if (prefix)
                        {
                            OUT(prefix) ;
                            OUT(TEXT ('0')) ;
                        }

                        //
                        // Now reverse the string in place
                        //
                        SP_Reverse(lpT,lpOut-1);
                    }
                    else
                    {
                        //
                        // Add the sign character
                        //
                        if (sign)
                        {
                            OUT(TEXT ('-')) ;
                            width-- ;
                        }

                        if (prefix)
                        {
                            OUT(prefix);
                            OUT(TEXT ('0'));
                        }

                        //
                        // Now reverse the string in place
                        //
                        SP_Reverse(lpT,lpOut-1);

                        //
                        // Pad to the right of the string in case left aligned 
                        //
                        while (width-- > 0)
                        {
                            OUT(fillch) ;
                        }
                    }
                    break ;

                case TEXT ('X'):
                    upper++ ;
                    //
                    // Falling through...
                    //

                case TEXT ('x'):
                    radix=16 ;
                    if (prefix)
                    {
                        prefix = upper ? TEXT ('X') : TEXT ('x') ;
                    }
                    goto do_Numeric ;

                case TEXT ('c'):
                    //
                    // Save as one character string and join common code
                    // 
                    val.sz[0] = *((TCHAR far*)lpParms) ;
                    val.sz[1] = 0 ;
                    lpT = val.sz ;
                    cch = 1 ;  

                    // Note: this may need to be fixed for UNICODE
                    (BYTE far*)lpParms += sizeof(WORD) ;

                    goto put_String ;

                case 's':
                    lpT = *((LPTSTR FAR *)lpParms)++ ;
                    cch = ilstrlen(lpT) ;
put_String:
                    if (prec>=0 && cch>prec)
                    {
                        cch = prec ;
                    }

                    width -= cch ;

                    if (left)
                    {
                        while (cch--)
                        {
                            OUT(*lpT++) ;
                        }

                        while (width-->0)
                        {
                            OUT(fillch) ;
                        }
                    }
                    else
                    {
                        while (width-- > 0)
                        {
                            OUT(fillch) ;
                        }

                        while (cch--)
                        {
                            OUT(*lpT++) ;
                        }
                    }
                    break ;

                default:
                    //
                    // An unsupported type character was given. We just
                    // print the character and go on. 
                    //
                    OUT(*lpFmt) ;
                    break ;

            } // switch(*lpfmt)
        } // if (*lpfmt == '%')
        else
        {
            //
            // Normal not-format character
            //
            OUT(*lpFmt) ;
        }
                
        lpFmt++ ;
    } // while (*lpFmt) 

error_Out:
    *lpOut = 0 ;

    return WSPRINTF_LIMIT-cchLimit ;
} //** wivsprintf()


//************************************************************************
//**
//**  SP_GetFmtValue();
//**
//**  DESCRIPTION:
//**     Parse a decimal integer forming part of a format string.
//**
//**
//**  ARGUMENTS:
//**     LPCSTR   lpch  -  Points to the string to parse.
//**     LPWORD   lpw   -  Points to a word where the value will be 
//**                       returned.
//**
//**  RETURNS:
//**     LPCSTR   -  Pointer of first character past the format value.
//**
//**  HISTORY:
//**     3/28/93     jfg      [jimge] 
//**
//************************************************************************

LPCTSTR NEAR PASCAL SP_GetFmtValue(
   LPCTSTR   lpch,
   UINT *    lpw)
{
    UINT       i = 0 ;

    while (*lpch>=TEXT ('0') && *lpch<=TEXT ('9'))
    {
        i *= 10;
        i += (UINT)(*lpch++-TEXT ('0'));
    }     

    *lpw = i;

    return(lpch); 
} //** SP_GetFmtValue()

//************************************************************************
//**
//**  SP_PutNumber();
//**
//**  DESCRIPTION:
//**     Formats the given number in the given radix into the buffer
//**     *backwards*. The entire string will be reversed after printf
//**     has added sign, prefix, etc. to it.
//**
//**  
//**  ARGUMENTS:
//**     LPSTR lpb   -  Points to the output buffer.
//**     DWORD n     -  Number to convert.
//**     UINT  limit -  Maximum number of characters to store.
//**     UINT  radix -  Base to format in.
//**     UINT  icase -  Non-zero if the string should be upper case (hex).
//**
//**  RETURNS:
//**     UINT  -  Number of characters output.
//**
//**  HISTORY:
//**
//************************************************************************

UINT NEAR PASCAL SP_PutNumber(
   LPTSTR   lpb,
   DWORD    n,
   UINT     limit,
   UINT     radix,
   UINT     icase)
{
   TCHAR  bTemp;
   UINT   cchStored = 0;

   //
   // Set icase to the offset to add to the character if it
   // represents a value > 10
   //
   icase = (icase ? TEXT ('A') : TEXT ('a')) - TEXT ('0') - 10 ;

   while (limit--)
   {
      bTemp = TEXT ('0') + (TCHAR)(n%radix);

      if (bTemp > TEXT ('9'))
      {
         bTemp += icase ;
      }

      *lpb++ = bTemp;
      ++cchStored;

      n /= radix;

      if (n == 0)
      {
         break ;
      }    
   }

   return cchStored ;
} //** SP_PutNumber()


//************************************************************************
//**
//**  SP_Reverse();
//**
//**  DESCRIPTION:
//**     Reverse string in place.
//**
//**  ARGUMENTS:
//**     LPSTR pFirst
//**     LPSTR pLast
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**
//************************************************************************

VOID NEAR PASCAL SP_Reverse(
   LPTSTR pFirst,
   LPTSTR pLast)
{
   UINT   uSwaps = (pLast - pFirst + sizeof(TCHAR)) / (2 * sizeof(TCHAR));
   TCHAR  bTemp;

   while (uSwaps--)
   {
      bTemp   = *pFirst;
      *pFirst = *pLast;
      *pLast  = bTemp;

      pFirst++, pLast--;
   }
} //** SP_Reverse()

//************************************************************************
//**
//**  ilstrlen();
//**
//**  DESCRIPTION:
//**     Interrupt callable version of strlen().
//**
//**  ARGUMENTS:
//**     LPSTR   pstr
//**
//**  RETURNS:
//**     UINT 
//**
//**  HISTORY:
//**
//************************************************************************

UINT NEAR PASCAL ilstrlen(
    LPTSTR   pstr)
{
   UINT    cch = 0 ;

   while (*pstr++)
      ++cch;

   return(cch);
} //** ilstrlen()

//************************************************************************
//**
//**  ilstrcat();
//**
//**  DESCRIPTION:
//**     Interrupt callable version of lstrcat().
//**
//**  ARGUMENTS:
//**     LPSTR   pstrDest
//**     LPSTR   pstrSrc
//**
//**  RETURNS:
//**     VOID 
//**
//**  HISTORY:
//**
//************************************************************************

VOID NEAR PASCAL ilstrcat(
    LPTSTR   pstrDest,
    LPTSTR   pstrSrc)
{
   while (*pstrDest)
      pstrDest++;

   while (*pstrDest++ = *pstrSrc++)
      ;

} //** ilstrcat()

#endif // #ifdef ISRDEBUG

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\drvproc.c ===
/**********************************************************************

  Copyright (c) 1992-1999 Microsoft Corporation

  drvproc.c

  DESCRIPTION:
    Driver procedure for the Midi Mapper.

  HISTORY:
     06/09/93       [t-kyleb]      created.

*********************************************************************/

#include "preclude.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "idf.h"

#include <memory.h>

#include "midimap.h"
#include "debug.h"

//=========================== Globals ======================================
//
PCHANNEL                gapChannel[MAX_CHANNELS]    = {NULL};
WORD                    gwConfigWhere       = 0;
UINT                    gcPorts             = 0;
WORD                    gwFlags             = 0;

HINSTANCE               ghinst              = NULL;
PPORT                   gpportList          = NULL;
PINSTANCE               gpinstanceList      = NULL;
PINSTANCE               gpIoctlInstance     = NULL;
PINSTRUMENT             gpinstrumentList    = NULL;
QUEUE                   gqFreeSyncObjs;
HMIDISTRM               ghMidiStrm          = NULL;
TCHAR                   szVersion[]         = TEXT (__DATE__)
                                              TEXT ("@")
                                              TEXT (__TIME__);
DWORD                   gdwVolume           = 0xFFFFFFFFL;

HANDLE			hMutexRefCnt		= NULL;
static const TCHAR	gszRefCnt[]		= TEXT ("MidiMapper_modLongMessage_RefCnt");

HANDLE			hMutexConfig		= NULL;
static const TCHAR	gszConfigure[]		= TEXT ("MidiMapper_Configure");

static const TCHAR      gszReconfigure[]        = TEXT("MidiMapper_Reconfig");

//=========================== Prototypes ===================================
//
PRIVATE LRESULT FNLOCAL GetMapperStatus(
    LPMAPPERSTATUS          lpStat);

/***************************************************************************

   @doc INTERNAL

   @api LRESULT | DriverProc | The entry point for an installable driver.

   @parm DWORD | dwID | For most messages, <p dwID> is the DWORD value
       that the driver returns in response to a <m DRV_OPEN> message.
       Each time that the driver is opened, through the <f DrvOpen> API,
       the driver receives a <m DRV_OPEN> message and can return an
       arbitrary, non-zero value. The installable driver interface
       saves this value and returns a unique driver handle to the
       application. Whenever the application sends a message to the
       driver using the driver handle, the interface routes the message
       to this entry point and passes the corresponding <p dwID>.
       This mechanism allows the driver to use the same or different
       identifiers for multiple opens but ensures that driver handles
       are unique at the application interface layer.

       The following messages are not related to a particular open
       instance of the driver. For these messages, the dwID will always
       be zero.

           DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN

   @parm HDRVR  | hdrvr | This is the handle returned to the application
       by the driver interface.

   @parm UINT | umsg | The requested action to be performed. Message
       values below <m DRV_RESERVED> are used for globally defined messages.
       Message values from <m DRV_RESERVED> to <m DRV_USER> are used for
       defined driver protocols. Messages above <m DRV_USER> are used
       for driver specific messages.

   @parm LPARAM | lParam1 | Data for this message.  Defined separately for
       each message

   @parm LPARAM | lParam2 | Data for this message.  Defined separately for
       each message

   @rdesc Defined separately for each message.

****************************************************************************/

LRESULT FNEXPORT DriverProc(
    DWORD_PTR           dwID,
    HDRVR               hdrvr,
    UINT                umsg,
    LPARAM              lParam1,
    LPARAM              lParam2)
{
    //
    //  NOTE DS is not valid here.
    //
    switch (umsg)
    {
        case DRV_LOAD:
            return(1L);

        case DRV_FREE:
            return(0L);

        case DRV_OPEN:
        case DRV_CLOSE:
            return(1L);

        case DRV_ENABLE:
				// Prevent Synchronization problems
				// During Configuration
            if (NULL != hMutexConfig)
				WaitForSingleObject (hMutexConfig, INFINITE);

            SET_ENABLED;
            DPF(1, TEXT ("Enable!"));
            Configure(0);

            if (NULL != hMutexConfig)
				ReleaseMutex (hMutexConfig);
            return(0L);

        case DRV_DISABLE:
            CLR_ENABLED;
            return(0L);

        case DRV_INSTALL:
        case DRV_REMOVE:
            // If the user installs or removes the driver then let them
            // know that they will have to restart.
            //
            return((LRESULT)DRVCNF_RESTART);

        case DRV_ENABLE_DEBUG:
            return(DbgEnable((BOOL)lParam1));

        case DRV_SET_DEBUG_LEVEL:
            return(DbgSetLevel((UINT)lParam1));

        case DRV_GETMAPPERSTATUS:
            return GetMapperStatus((LPMAPPERSTATUS)lParam1);

#ifdef DEBUG
        case DRV_REGISTERDEBUGCB:
            DbgRegisterCallback((HWND)lParam1);
            return 1L;

        case DRV_GETNEXTLOGENTRY:
            return (LRESULT)DbgGetNextLogEntry((LPTSTR)lParam1, (UINT)lParam2);
#endif

            // Let the default handler handle everything else.
            //
        default:
            DPF(1, TEXT ("DriverProc unsupported=%08lX"), (DWORD)umsg);
            return(DefDriverProc(dwID, hdrvr, umsg, lParam1, lParam2));
    }
} //** DriverProc()

/***************************************************************************

   @doc internal

   @api LRESULT | GetMapperStatus | Return information about the current
    mapper setup to a debug application.

   @parm LPMAPPERSTATUS | lpStat | Pointer to a structure to receive
    the mapper information. lpStat->cbStruct must be filled in.

   @rdesc | Always returns 0;

***************************************************************************/

PRIVATE LRESULT FNLOCAL GetMapperStatus(
    LPMAPPERSTATUS          lpStat)
{
    MAPPERSTATUS            stat;


    if (lpStat->cbStruct < sizeof(stat))
        DPF(1, TEXT ("MAPPERSTATUS struct too small -- recompile MAPWATCH!!!"));

    stat.cbStruct               = lpStat->cbStruct;
//    stat.DS                     = __segname("_DATA");
    stat.ghinst                 = ghinst;
    stat.gwFlags                = gwFlags;
    stat.gwConfigWhere          = gwConfigWhere;
    stat.pgapChannel            = gapChannel;
    stat.gpportList             = gpportList;
    stat.gpinstanceList         = gpinstanceList;
    stat.gpinstrumentList       = gpinstrumentList;
    stat.lpszVersion            = szVersion;

    hmemcpy(lpStat, &stat, (UINT)lpStat->cbStruct);

    return 0;
}


/***************************************************************************

   @doc internal

   @api BOOL | DllEntryPoint | Entry point for the DLL

   @parm HINSTANCE | hinstDLL | handle of DLL module

   @parm DWORD | fdwReason | Why function was called

   @parm LPVOID | lpvReserved | Reserved = must be NULL

   @rdesc | Should always return TRUE for success.

***************************************************************************/
BOOL WINAPI DllEntryPoint(
   HINSTANCE         hinstDLL,
   DWORD             fdwReason,
   LPVOID            lpvReserved)
{
   static TCHAR BCODE   szSection[]    = TEXT ("MIDIMAP");
   static TCHAR BCODE   szSystemIni[]  = TEXT ("system.ini");
   static HANDLE        hThread        = NULL;
   DWORD                dw;

   switch (fdwReason)
      {
      case DLL_PROCESS_ATTACH:
#ifdef DEBUG
         {
            UINT     uDebugLevel;

            uDebugLevel = DbgInitialize(TRUE);

            DPF(0, TEXT ("DllEntryPoint - DLL_PROCESS_ATTACH (hinstDLL=%.4Xh, lpvReserved=%.08lXh)"),
                hinstDLL, lpvReserved);

            DPF(0, TEXT ("Debug Level = %u"), uDebugLevel);

            if (2 <= uDebugLevel)
               DebugBreak();
         }
#endif
         // Save our instance handle in a global.
         //
         ghinst = hinstDLL;

         // Initialize Synchronization object
         //
         QueueInit(&gqFreeSyncObjs);

	 // Initialize modLongMessage RefCnt Synchronization Object
	 hMutexRefCnt = CreateMutex (NULL, FALSE, gszRefCnt);

	 // Initialize Configure Synchronization Object
	 hMutexConfig = CreateMutex (NULL, FALSE, gszConfigure);

         break;

      case DLL_THREAD_ATTACH:
#ifdef DEBUG
         DPF(0, TEXT ("DllEntryPoint - DLL_THREAD_ATTACH (hinstDLL=%.4Xh, lpvReserved=%.08lXh)"),
                hinstDLL, lpvReserved);
#endif
         break;

      case DLL_THREAD_DETACH:
#ifdef DEBUG
         DPF(0, TEXT ("DllEntryPoint - DLL_THREAD_DETACH (hinstDLL=%.4Xh, lpvReserved=%.08lXh)"),
                hinstDLL, lpvReserved);
#endif
         break;

      case DLL_PROCESS_DETACH:
	 // Cleanup Configure Synchronization Object
	 //
         if (NULL != hMutexConfig) CloseHandle (hMutexConfig);

	 // Cleanup modLongMessage RefCnt Synchronization Object
	 //
	 if (NULL != hMutexRefCnt) CloseHandle (hMutexRefCnt);

	 // Cleanup Synchronization object
         //
         QueueCleanup(&gqFreeSyncObjs);

         // cleanup instance handle
         //
         ghinst = NULL;

#ifdef DEBUG
         DPF(0, TEXT ("DllEntryPoint - DLL_PROCESS_DETACH (hinstDLL=%.4Xh, lpvReserved=%.08lXh)"),
                hinstDLL, lpvReserved);
#endif
         break;
      } // End switch (fdwReason)

   return TRUE;
} // End DllEntryPoint
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\cookfix.c ===
/**********************************************************************

  Copyright (c) 1992-1995 Microsoft Corporation

  cookfix.c

  DESCRIPTION:
    Fixed code for doing output mapping. KEEP THE SIZE OF THIS CODE
    TO A MINIMUM!

  HISTORY:
     03/04/94       [jimge]        created.

*********************************************************************/

#include "preclude.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "idf.h"

#include "midimap.h"
#include "debug.h"

/***************************************************************************
  
   @doc internal
  
   @api void | SendNextCookedBuffer | Sends the next cooked buffer on a
    mapper handle.

   @parm PINSTANCE | pinstance | Pointer to an open instance.
   
***************************************************************************/
void FNGLOBAL SendNextCookedBuffer(
    PINSTANCE           pinstance)
{
    PCOOKSYNCOBJ        pcooksyncobj;
    UINT                idx;
    LPMIDIHDR           lpmh;
    MMRESULT            mmr;
    
    pcooksyncobj = (PCOOKSYNCOBJ)QueueGet(&pinstance->qCookedHdrs);
    if (NULL == pcooksyncobj)
    {
        DPF(1, TEXT ("SendNextCookedBuffer: No more buffers."));
        return;
    }

    lpmh = pcooksyncobj->lpmh;
    pcooksyncobj->cSync = 0;
    
    for (idx = 0; idx < pcooksyncobj->cLPMH; ++idx)
    {
        ++pcooksyncobj->cSync;
        
        mmr = midiOutPolyMsg(
                             (HMIDI)(HIWORD(lpmh->dwUser)),
                             lpmh,
                             sizeof(*lpmh));

        if (MMSYSERR_NOERROR != mmr)
        {
            --pcooksyncobj->cSync;
            DPF(1, TEXT ("midiOutPolyMsg *FAILED* mmr=%08lX"), (DWORD)mmr);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\config.c ===
/**********************************************************************

  Copyright (c) 1992-1999 Microsoft Corporation

  config.c

  DESCRIPTION:
    Code to configure the mapper when a device is added or deleted.

  HISTORY:
     02/21/93       [jimge]        created.

*********************************************************************/

#include "preclude.h"
#include <windows.h>
#include <winerror.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <mmddk.h>
#include <regstr.h>
#include "idf.h"

#include <memory.h>
#include <ctype.h>

#include "midimap.h"
#include "debug.h"




//=========================== Globals ======================================
//
static TCHAR BCODE gszMidiMapKey[]   =
    REGSTR_PATH_MULTIMEDIA TEXT ("\\MIDIMap");

static TCHAR BCODE gszSchemeListKey[] =
    REGSTR_PATH_PRIVATEPROPERTIES TEXT ("\\MIDI\\Schemes");

static TCHAR BCODE gsz2Keys[] =
    TEXT ("%s\\%s");  

static TCHAR BCODE gszMediaRsrcKey[] =
    REGSTR_PATH_MEDIARESOURCES TEXT ("\\MIDI");

static TCHAR BCODE gszDriverKey[] =
    REGSTR_PATH_MEDIARESOURCES TEXT ("\\MIDI\\%s");

#ifdef DEBUG
static TCHAR BCODE gszSystemINI[]        = TEXT ("system.ini");
static TCHAR BCODE gszMIDIMapSect[]      = TEXT ("MIDIMAP");
static TCHAR BCODE gszRunOnceValue[]     = TEXT ("RunOnce");
static TCHAR BCODE gszBreakOnConfigValue[]=TEXT ("BreakOnConfig");
#endif

static TCHAR BCODE gszUseSchemeValue[]   = TEXT ("UseScheme");
static TCHAR BCODE gszCurSchemeValue[]   = TEXT ("CurrentScheme");
static TCHAR BCODE gszCurInstrValue[]    = TEXT ("CurrentInstrument");
static TCHAR BCODE gszChannelsValue[]    = TEXT ("Channels");
static TCHAR BCODE gszPortValue[]        = TEXT ("Port");
static TCHAR BCODE gszDefinitionValue[]  = TEXT ("Definition");
static TCHAR BCODE gszFriendlyNameValue[]= TEXT ("FriendlyName");
static TCHAR BCODE gszDescription[]      = TEXT ("Description");
static TCHAR BCODE gszAutoSchemeValue[]  = TEXT ("AutoScheme");
static TCHAR BCODE gszDefaultFile[]      = TEXT ("<internal>");
static TCHAR BCODE gszDefaultInstr[]     = TEXT ("Default");
static TCHAR BCODE gszDoRunOnce[]        = TEXT ("RunDll32.exe mmsys.cpl,RunOnceSchemeInit");
static TCHAR BCODE gszSetupKey[]         = TEXT ("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup");
static TCHAR BCODE gszMachineDir[]       = TEXT ("WinDir");
static TCHAR BCODE gszConfigDir[]        = TEXT ("config\\");

extern BOOL        gfReconfigured;

//=========================== Prototypes ===================================
//
PRIVATE void FNLOCAL ConfigureFromToast(
    void);

PRIVATE void FNLOCAL ConfigureScheme(
    LPTSTR              pstrScheme);

PRIVATE void FNLOCAL ConfigureInstrument(
    LPTSTR              pstrInstr);                                    

PRIVATE UINT FNLOCAL AddDevice(
    WORD                wChannelMask,
    UINT                uDeviceID,
    LPTSTR              pstrDefinition);

#define PSIK_INVALID            ((UINT)(-1))

PRIVATE PPORT FNLOCAL GetPort(
    UINT                uDeviceID);                              

PRIVATE void FNLOCAL PortAddRef(
    PPORT               pport);

PRIVATE void FNLOCAL PortReleaseRef(
    PPORT               pport);

PRIVATE PINSTRUMENT FNLOCAL GetInstrument(
    LPTSTR              pstrFilename,                                  
    LPTSTR              pstrInstrument);

PRIVATE void FNLOCAL InstrumentAddRef(
    PINSTRUMENT         pinstrument);

PRIVATE void FNLOCAL InstrumentReleaseRef(
    PINSTRUMENT         pinstrument);

PRIVATE PINSTRUMENT FNLOCAL LoadInstrument(
    LPTSTR              pstrFileName,
    LPTSTR              pstrInstrument);

PRIVATE PINSTRUMENT FNLOCAL MakeDefInstrument(
    void);

#define GDID_INVALID        ((UINT)(-2))

PRIVATE BOOL FNLOCAL GetIDFDirectory(
    LPTSTR                  pszDir,
    DWORD                   cchDir);

PRIVATE VOID FNLOCAL ValidateChannelTypes(
    VOID);

//extern UINT FAR PASCAL wmmMIDIRunOnce();

#if 1
/***************************************************************************

    @doc internal

    @api void | Configure | Configure the mapper.

    @comm

     Uses new Windowws 2000 message to winmm to get the
     current preferred MIDI ID.
      
***************************************************************************/
BOOL FNGLOBAL Configure(DWORD fdwUpdate)
{
    UINT MidiOutId;
    DWORD dwFlags;
    MMRESULT mmr;

    gfReconfigured = TRUE;

    mmr = midiOutMessage((HMIDIOUT)(UINT_PTR)MIDI_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR)&MidiOutId, (DWORD_PTR)&dwFlags);
    if (!mmr && (MIDI_MAPPER != MidiOutId)) AddDevice(ALL_CHANNELS, MidiOutId, TEXT("\0"));
    return FALSE;
}

#else
// Obsolete in Windows 2000:
/***************************************************************************

    @doc internal

    @api void | Configure | Configure the mapper.

    @comm

     Read HKCU\...\UseScheme to determine if we're loading a scheme or
      instrument.

     Read either HKCU\...\CurrentScheme or HKCU\...\CurrentInstrument
      and call the correct configuration routine.

***************************************************************************/
BOOL FNGLOBAL Configure(
    DWORD               fdwUpdate)
{
    HKEY                hKeyMidiMap     = NULL;
    HKEY                hKeySchemes     = NULL;
    LPTSTR              pstrValueStr    = NULL;
    DWORD               cbValueStr;
    DWORD               cbValue;
    DWORD               dwType;
    DWORD               dwUseScheme;
    DWORD               dwAutoScheme;
    MMRESULT            mmr;
    MIDIOUTCAPS         moc;
#ifdef DEBUG
    DWORD               dwBreak;
    DWORD               dwRunOnce;
#endif
    BOOL                fRanRunOnce = FALSE;

    static TCHAR        szConfigErr[256];
    static TCHAR        szConfigErrMsg[256];
    
    DPF(2, TEXT ("--- Configure start ---"));

#ifdef DEBUG
    dwBreak = (DWORD)GetPrivateProfileInt(gszMIDIMapSect, gszBreakOnConfigValue, 0, gszSystemINI);
    if (dwBreak)
	DebugBreak();
#endif

    SET_CONFIGERR;
    SET_NEEDRUNONCE;

    // Rest of configuration assumes we're starting from total scratch
    //
    assert(NULL == gpportList);
    assert(NULL == gpinstrumentList);
    
#ifdef DEBUG
    dwRunOnce = (DWORD)GetPrivateProfileInt(gszMIDIMapSect, gszRunOnceValue, 1, gszSystemINI);
#endif

		// Create List of Active MIDIOUT devices
    if (!mdev_Init())
    {
	DPF(1, TEXT ("Could not mdev_Init"));
	goto Configure_Cleanup;
    }

    if (ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER,
				    gszMidiMapKey,
				    &hKeyMidiMap))
    {
	DPF(1, TEXT ("Could not open MidiMap"));
	goto Configure_Cleanup;
    }

    cbValueStr = max(CB_MAXSCHEME, CB_MAXINSTR) * sizeof(TCHAR);
    if (NULL == (pstrValueStr = (LPTSTR)LocalAlloc(LPTR, (UINT)cbValueStr)))
    {
	DPF(1, TEXT ("No memory for pstrValueStr"));
	goto Configure_Cleanup;
    }

    // Get Scheme Values
#if 0
    cbValue = sizeof(dwUseScheme);
    if (ERROR_SUCCESS != RegQueryValueEx(hKeyMidiMap,
					 gszUseSchemeValue,
					 NULL,
					 &dwType,
					 (LPSTR)&dwUseScheme,
					 &cbValue))
    {
	DPF(1, TEXT ("Missing UseScheme; assuming scheme"));
	dwUseScheme = 1;
    }
#else
    // Windows 2000 does not support schemes.
    dwUseScheme = 0;
#endif

    cbValue = sizeof(dwAutoScheme);
    if (ERROR_SUCCESS != RegQueryValueEx(hKeyMidiMap,
					 gszAutoSchemeValue,
					 NULL,
					 &dwType,
					 (LPSTR)&dwAutoScheme,
					 &cbValue))
    {
	DPF(1, TEXT ("Missing AutoScheme; assuming TRUE"));
	dwAutoScheme = 1;
    }

    if (dwUseScheme)
    {
			// Get Scheme Name
	cbValue = cbValueStr;
	if (ERROR_SUCCESS != RegQueryValueEx(hKeyMidiMap,
					     gszCurSchemeValue,
					     NULL,
					     &dwType,
					     (LPSTR)pstrValueStr,
					     &cbValue))
	{
	    DPF(1, TEXT ("Could not read scheme"));

	    // Couldn't read scheme? Let's try to get the first one
	    //

	    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
					    gszSchemeListKey,
					    &hKeySchemes))
	    {
		if (ERROR_SUCCESS == RegEnumKey(hKeySchemes,
						0,
						pstrValueStr,
						cbValueStr))
		{
		    CLR_CONFIGERR;
		    DPF(1, TEXT ("Using default scheme %s"), (LPTSTR)pstrValueStr);
		}
		else
		{
		    DPF(1, TEXT ("Could not enum schemes key"));
		}
	    }
	    else
	    {
		DPF(1, TEXT ("Could not open [%s]"), (LPTSTR)gszSchemeListKey);
	    }
	}
	else
	{
	    CLR_CONFIGERR;
	    CLR_NEEDRUNONCE;
	}
	
	if (!IS_CONFIGERR)
	{
	    DPF(1, TEXT ("Using scheme [%s]"), (LPTSTR)pstrValueStr);
	    ConfigureScheme(pstrValueStr);
	}
    }
    else
    {
	// Not using scheme -- try to configure via instrument description
	//
	cbValue = cbValueStr;
	if (ERROR_SUCCESS == RegQueryValueEx(hKeyMidiMap,
					     gszCurInstrValue,
					     NULL,
					     &dwType,
					     (LPSTR)pstrValueStr,
					     &cbValue))
	{
	    CLR_CONFIGERR;
	    CLR_NEEDRUNONCE;
	    
	    DPF(1, TEXT ("Using instrument [%s]"), (LPTSTR)pstrValueStr);
	    ConfigureInstrument(pstrValueStr);

	    // If we're autoconfigure and the device we're using isn't
	    // marked as an internal synth and we've added a new device,
	    // do the runonce in case we can find an internal synth
	    //

	    if (dwAutoScheme && ((fdwUpdate & 0xFFFF) == DRV_F_ADD))
	    {
		//assert(gpportList->pNext == NULL);
		if (gpportList == NULL)
		{
		   DPF(0, TEXT ("Configure: gpportList = NULL"));
		   goto Configure_Cleanup;
		}

		DPF(1, TEXT ("AutoScheme && DRV_F_ADD"));

		mmr = midiOutGetDevCaps(gpportList->uDeviceID,
					&moc,
					sizeof(moc));

		if (MMSYSERR_NOERROR != mmr ||
		    MOD_MIDIPORT == moc.wTechnology)
		{
		    UINT        cDev;
		    UINT        idxDev;

		    DPF(1, TEXT ("Bogus or internal"));

		    cDev = midiOutGetNumDevs();
		    for (idxDev = 0; idxDev < cDev; ++idxDev)
			if (MMSYSERR_NOERROR == midiOutGetDevCaps(
			    idxDev,
			    &moc,
			    sizeof(moc)) &&
			    MOD_MIDIPORT != moc.wTechnology)
			{
			    DPF(1, TEXT ("AutoConf: External or bogus port; RunOnce!"));
			    CLR_DONERUNONCE;
			    SET_NEEDRUNONCE;
			    break;
			}
		}
	    }
	}
    }

    // In all cases, if we are autoscheme and there is a new driver,
    // do runonce.
    //

    if (dwAutoScheme && mdev_NewDrivers())
    {
	DPF(1, TEXT ("New driver(s); force runonce."));
	CLR_DONERUNONCE;
	SET_NEEDRUNONCE;
    }
    
Configure_Cleanup:

    // Safe to call this even if mdev_Init() failed
    //
    mdev_Free();
    
    if (IS_CONFIGERR)
    {
	ConfigureFromToast();
    }

    if (IS_NEEDRUNONCE && !IS_DONERUNONCE)
    {
#ifdef DEBUG
	if (dwRunOnce)
	{
#endif
	    DPF(2, TEXT ("Configuration inconsistent -- calling RunOnce"));
	    
//            WinExec(gszDoRunOnce, 0);

	    SET_INRUNONCE;
	    wmmMIDIRunOnce();
	    CLR_INRUNONCE;
	    
	    fRanRunOnce = TRUE;

#ifdef DEBUG
	}
	else
	{
	    DPF(1, TEXT ("Debug and RunOnce==0, not executing RunOnce"));
	}
#endif

	SET_DONERUNONCE;
    }

    ValidateChannelTypes();

    // Call our own midiOutGetDevCaps handler to walk the new list of
    // ports and figure out what we support
    //
    modGetDevCaps(&moc, sizeof(moc));
    
    DPF(2, TEXT ("--- Configure end ---"));
    
    if (NULL != pstrValueStr)   
       LocalFree((HGLOBAL)pstrValueStr);
    
    if (NULL != hKeyMidiMap)    
       RegCloseKey(hKeyMidiMap);
    
    if (NULL != hKeySchemes)    
       RegCloseKey(hKeySchemes);

    return fRanRunOnce;
}
#endif

void FNGLOBAL Unconfigure(
    void)
{
    PCHANNEL                pchannel;
    UINT                    idxChannel;
    UINT                    idx2;
    
    for (idxChannel = 0; idxChannel < MAX_CHANNELS; idxChannel++)
    {
	if (NULL != (pchannel = gapChannel[idxChannel]))
	{
	    if (pchannel->pport)
	    {
		for (idx2 = idxChannel+1; idx2 < MAX_CHANNELS; idx2++)
		    if (NULL != gapChannel[idx2] &&
			pchannel->pport == gapChannel[idx2]->pport)
			gapChannel[idx2]->pport = NULL;

		PortReleaseRef(pchannel->pport);
	    }
	    
	    if (pchannel->pinstrument)
		InstrumentReleaseRef(pchannel->pinstrument);
	    
	    LocalFree((HLOCAL)pchannel);
	    gapChannel[idxChannel] = NULL;
	}
    }
}

/***************************************************************************
  
   @doc internal
  
   @api void | ConfigureFromToast | Build a configuration to use a 1:1 mapping
    of the first internal driver we can find. We use this only if the registry
    is totally blown and we have no other choice.

***************************************************************************/
PRIVATE void FNLOCAL ConfigureFromToast(
    void)
{
    UINT WavetableMidiOutId;
    UINT OtherMidiOutId;
    UINT FmMidiOutId;
    UINT SoftwareMidiOutId;
    UINT ExternalMidiOutId;
    UINT MidiOutId;
    UINT cMidiOutId;
    MIDIOUTCAPS moc;
    
    DPF(1, TEXT ("ConfigureFromToast()"));

    CLR_CONFIGERR;
    
    // In case there's any partial junk leftover
    Unconfigure();

    //
    //
    //
    WavetableMidiOutId = (-1);
    OtherMidiOutId = (-1);
    FmMidiOutId = (-1);
    SoftwareMidiOutId = (-1);
    ExternalMidiOutId = (-1);

    cMidiOutId = midiOutGetNumDevs();
    if (0 != cMidiOutId)
    {
	for (MidiOutId = 0; MidiOutId < cMidiOutId; MidiOutId++)
	{
	    if (!midiOutGetDevCaps(MidiOutId, &moc, sizeof(moc)))
	    {
		if (MOD_SWSYNTH == moc.wTechnology &&
		    MM_MSFT_WDMAUDIO_MIDIOUT == moc.wPid &&
		    MM_MICROSOFT == moc.wMid)
		{
		    SoftwareMidiOutId = MidiOutId;
		} else if (MOD_FMSYNTH == moc.wTechnology) {
		    FmMidiOutId = MidiOutId;
		} else if (MOD_MIDIPORT == moc.wTechnology) {
		    ExternalMidiOutId = MidiOutId;
		} else if (MOD_WAVETABLE == moc.wTechnology) {
		    WavetableMidiOutId = MidiOutId;
		} else {
		    OtherMidiOutId = MidiOutId;
		}
	    }
	}
    }

    if ((-1) != WavetableMidiOutId) MidiOutId = WavetableMidiOutId;
    else if ((-1) != SoftwareMidiOutId) MidiOutId = SoftwareMidiOutId;
    else if ((-1) != OtherMidiOutId) MidiOutId = OtherMidiOutId;
    else if ((-1) != FmMidiOutId) MidiOutId = FmMidiOutId;
    else if ((-1) != ExternalMidiOutId) MidiOutId = ExternalMidiOutId;
    else MidiOutId = (-1);

    if ((-1) == MidiOutId)
    {
	SET_CONFIGERR;
	DPF(1, TEXT (":-( Could not even find an internal device."));
	return;
    }

    DPF(1, TEXT ("CFT: Using device %u"), MidiOutId);

    if (!AddDevice(0xFFFF,
		   MidiOutId,
		   TEXT("\0")))
    {
	DPF(1, TEXT ("CFT: AddDevice failed!!!"));
	SET_CONFIGERR;
    }
}

/***************************************************************************
  
   @doc internal
  
   @api void | ConfigureScheme | Read configuration from registry and set up
    data structures.

   @parm PSTR | pstrScheme | The scheme to load. 

   @comm
   

    hkeyScheme = Open key from HKLM\...\Schemes\%scheme%

    Enumerate subkeys of Scheme -- each subkey is an alias
     GetKey of enumeration key into pstrDevKey
     GetValue of Channels= Value

     hkeyAlias = Open key from HKLM\...\Midi\%pstrDevKey%
     GetValue of Key=
     GetValue of Port=
     GetValue of File=
     GetValue of Instrument=

     If everything succeeded, add entry to configuration

***************************************************************************/
PRIVATE void FNLOCAL ConfigureScheme(
    LPTSTR              pstrScheme)
{
    UINT                cbKeyBuffer;
    LPTSTR              pstrKeyBuffer   = NULL;
    LPTSTR              pstrAlias       = NULL;
    LPTSTR              pstrDevKey      = NULL;
    LPTSTR              pstrDefinition  = NULL;

    DWORD               dwChannelMask;
    DWORD               dwType;
    DWORD               cbValue;
    DWORD               idxEnumKey;
    LPTSTR              pstrMMDevKey;

    UINT                uChannels;
    UINT                uTotalChannels  = 0;
    UINT                uDeviceID;

    BOOL                fSuccess;


    HKEY                hkeyScheme      = NULL;
    HKEY                hkeyAlias       = NULL;

    // Assume something will fail
    // 
    SET_CONFIGERR;
    
    cbKeyBuffer = max(sizeof(gszSchemeListKey) + 1 + CB_MAXSCHEME, sizeof(gszDriverKey) + CB_MAXALIAS);
    
    if (NULL == (pstrKeyBuffer = (LPTSTR)LocalAlloc(LPTR, cbKeyBuffer)) ||
	NULL == (pstrAlias     = (LPTSTR)LocalAlloc(LPTR, CB_MAXALIAS)) ||
	NULL == (pstrDevKey    = (LPTSTR)LocalAlloc(LPTR, CB_MAXDEVKEY)) ||
	NULL == (pstrDefinition= (LPTSTR)LocalAlloc(LPTR, CB_MAXDEFINITION)))
    {
	DPF(1, TEXT ("No memory to read configuration!"));
	goto Configure_Cleanup;
    }

    wsprintf(pstrKeyBuffer, gsz2Keys, (LPTSTR)gszSchemeListKey, (LPSTR)pstrScheme);

    // NOTE: RegOpenKeyEx does not exist in Chicago
    //
    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
				    pstrKeyBuffer,
				    &hkeyScheme))
    {
	SET_NEEDRUNONCE;
	DPF(1, TEXT ("Could not open Schemes\\%s"), (LPTSTR)pstrScheme);
	goto Configure_Cleanup;
    }

    // NOTE: RegEnumKeyEx does not exist in Chicago
    //
    idxEnumKey = 0;
    while (ERROR_SUCCESS == RegEnumKey(hkeyScheme,
				       idxEnumKey++,
				       pstrAlias,
				       CB_MAXALIAS))
    {
	DPF(1, TEXT ("enum scheme component %lu"), idxEnumKey);
	
	if (ERROR_SUCCESS == RegOpenKey(hkeyScheme,
					pstrAlias,
					&hkeyAlias))
	{
	    cbValue = CB_MAXDEVKEY;
	    fSuccess = (ERROR_SUCCESS == RegQueryValue(hkeyAlias,
						       NULL,
						       pstrDevKey,
						       &cbValue));

	    if (!fSuccess)
	    {
		DPF(1, TEXT ("Failure after hkeyAlias"));

		SET_NEEDRUNONCE;
		goto Configure_Cleanup;
	    }

	    DPF(2, TEXT ("hkeyAlias key=%s"), (LPTSTR)pstrDevKey);


	    cbValue = sizeof(dwChannelMask);
	    if (ERROR_SUCCESS != RegQueryValueEx(hkeyAlias,
						 gszChannelsValue,
						 NULL,
						 &dwType,
						 (LPBYTE)&dwChannelMask,   
						 &cbValue))
	    {
		DPF(1, TEXT ("wChannelMask undefined -- using all channels"));
		dwChannelMask = 0xFFFF;
		SET_NEEDRUNONCE;
	    }

	    RegCloseKey(hkeyAlias);
	    hkeyAlias = NULL;
	    
	    if (fSuccess)
	    {
		wsprintf(pstrKeyBuffer, gszDriverKey, (LPTSTR)pstrDevKey);
		if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
						pstrKeyBuffer,
						&hkeyAlias))
		{
		    pstrMMDevKey = pstrDevKey;

		    while (*pstrMMDevKey && *pstrMMDevKey != TEXT ('\\'))
			++pstrMMDevKey;

		    *pstrMMDevKey = TEXT ('\0');

		    DPF(1, TEXT ("pstrMMDevKey %s"), (LPTSTR)pstrDevKey);

		    cbValue = CB_MAXDEFINITION * sizeof (TCHAR);
		    if (ERROR_SUCCESS != RegQueryValueEx(hkeyAlias,
							 gszDefinitionValue,
							 NULL,
							 &dwType,
							 (LPSTR)pstrDefinition,
							 &cbValue))
		    {
			DPF(1, TEXT ("pstrDefinition undefined -- using 1:1 mapping"));
			*pstrDefinition = TEXT ('\0');
		    }

		    uDeviceID = mdev_GetDeviceID(pstrDevKey);

		    if (NO_DEVICEID != uDeviceID)
		    {
			// Success!!!! Add the entry
			//
			DPF(1, TEXT ("AddDevice("));
			DPF(1, TEXT ("  dwChannelMask=%08lX,"), dwChannelMask);
			DPF(1, TEXT ("  uDeviceID=%u,"), uDeviceID);
			DPF(1, TEXT ("  pstrDefinition=%s)"), (LPSTR)pstrDefinition);

			if (0 == (uChannels = AddDevice(
			    (WORD)dwChannelMask,
			    uDeviceID,
			    pstrDefinition)))
			{
			    SET_CONFIGERR;
			    goto Configure_Cleanup;
			}

			uTotalChannels += uChannels;
		    }
		    
		    RegCloseKey(hkeyAlias);
		    hkeyAlias = NULL;
		}
		else
		{
		    DPF(1, TEXT ("Could not open Aliases\\%s"), (LPTSTR)pstrAlias);
		}
	    }
	}
	else
	{
	    DPF(1, TEXT ("Could not open Schemes\\%s"), (LPTSTR)pstrAlias);
	}
    }

    // Fall-through is only path to success.
    //
    if (uTotalChannels)
    {
	CLR_CONFIGERR;
    }
    else
    {
	DPF(1, TEXT ("No channels configured; we're toast!"));
	SET_NEEDRUNONCE;
    }
					 
Configure_Cleanup:
    if (NULL != pstrKeyBuffer) 
	LocalFree((HLOCAL)pstrKeyBuffer);

    if (NULL != pstrAlias)     
	LocalFree((HLOCAL)pstrAlias);

    if (NULL != pstrDevKey)    
	LocalFree((HLOCAL)pstrDevKey);

    if (NULL != pstrDefinition)
	LocalFree((HLOCAL)pstrDefinition);

    if (NULL != hkeyScheme)    
	RegCloseKey(hkeyScheme);

    if (NULL != hkeyAlias)     
       RegCloseKey(hkeyAlias);
}

/***************************************************************************
  
   @doc internal
  
   @api void | ConfigureInstrument | Read configuration from registry and set up
    data structures.

   @parm PSTR | pstrInstrument | The instrument to load. 

   @comm

***************************************************************************/
PRIVATE void FNLOCAL ConfigureInstrument(
    LPTSTR                pstrInstr)
{
    HKEY                hKeyMediaRsrc   = NULL;
    LPTSTR              pstrKeyBuffer   = NULL;
    LPTSTR              pstrDevKey      = NULL;
    LPTSTR              pstrDefinition  = NULL;
#ifndef WINNT
    LPTSTR              pstrSrc;
    LPTSTR              pstrDst;
#endif // End WINNT

    DWORD               dwType;
    DWORD               cbValue;
    UINT                cbKeyBuffer;
    UINT                uDeviceID;
    
    SET_CONFIGERR;
    
    cbKeyBuffer = max(sizeof(gszSchemeListKey) + 1 + CB_MAXSCHEME, sizeof(gszDriverKey) + CB_MAXALIAS);
    if (NULL == (pstrKeyBuffer = (LPTSTR)LocalAlloc (LPTR, cbKeyBuffer * sizeof(TCHAR))) ||
	NULL == (pstrDefinition= (LPTSTR)LocalAlloc (LPTR, CB_MAXDEFINITION * sizeof(TCHAR))) ||
	NULL == (pstrDevKey    = (LPTSTR)LocalAlloc (LPTR, CB_MAXDEVKEY * sizeof(TCHAR))))
    {
	DPF(1, TEXT ("No memory to read configuration!"));
	goto Configure_Cleanup;
    }

#ifdef WINNT
	lstrcpy (pstrDevKey, pstrInstr);
#else

    pstrSrc = pstrInstr;
    pstrDst = pstrDevKey;

    while (*pstrSrc && *pstrSrc != TEXT ('\\'))
	*pstrDst++ = *pstrSrc++;

    *pstrDst = TEXT ('\0');
#endif // WINNT 

    wsprintf(pstrKeyBuffer, gszDriverKey, (LPTSTR)pstrInstr);

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
				    pstrKeyBuffer,
				    &hKeyMediaRsrc))
    {   
	DPF(1, TEXT ("Could not open DevKey %s!"), (LPTSTR)pstrKeyBuffer);
	SET_NEEDRUNONCE;
	goto Configure_Cleanup; 
    }

    cbValue = CB_MAXDEFINITION;
    if (ERROR_SUCCESS != RegQueryValueEx(hKeyMediaRsrc,
					 gszDefinitionValue,
					 NULL,
					 &dwType,
					 (LPSTR)pstrDefinition,
					 &cbValue))
    {
	DPF(1, TEXT ("pstrDefinition undefined -- using 1:1 mapping"));
	*pstrDefinition = TEXT ('\0');
    }

    uDeviceID = mdev_GetDeviceID(pstrDevKey);
    if (NO_DEVICEID != uDeviceID)
    {
	// Success!!!! Add the entry
	//
	DPF(1, TEXT ("AddDevice("));
	DPF(1, TEXT ("  uDeviceID=%u"), uDeviceID);
	DPF(1, TEXT ("  pstrDefinition=%s)"), (LPTSTR)pstrDefinition);

	if (0 != AddDevice(ALL_CHANNELS,
			   uDeviceID,
			   pstrDefinition))
	{   
	    CLR_CONFIGERR;
	}
    }
    
Configure_Cleanup:
    if (NULL != pstrDefinition) 
	LocalFree((HLOCAL)pstrDefinition);

    if (NULL != pstrKeyBuffer)  
	LocalFree((HLOCAL)pstrKeyBuffer);

    if (NULL != pstrDevKey)     
	LocalFree((HLOCAL)pstrDevKey);

    if (NULL != hKeyMediaRsrc)  
	RegCloseKey(hKeyMediaRsrc);
}

PRIVATE UINT FNLOCAL AddDevice(
    WORD                wChannelMask,
    UINT                uDeviceID,
    LPTSTR              pstrDefinition)
{
    UINT                uRet            = 0;
    
    WORD                wChannelBit;
    WORD                wAddedMask      = 0;
    UINT                idxChannel;
    UINT                cbDefinition;
    PPORT               pport           = NULL;
    PINSTRUMENT         pinstrument     = NULL;
    PCHANNEL            pchannel;

    LPTSTR              pstrFile        = NULL;
    LPTSTR              pstrInstrument  = NULL;

    DPF(1, TEXT ("AddDevice: uDeviceID %u pstrDefinition %s"),
	uDeviceID,
	(LPTSTR)pstrDefinition);

    // Parse definition
    //
    // pstrFile -> filename
    // pstrInstrument -> instrument (empty string if none specified)
    //
    cbDefinition = lstrlen(pstrDefinition);

    if (cbDefinition)
    {
	pstrFile = pstrDefinition;

	if (pstrDefinition[cbDefinition-1] == '>')
	{
	    pstrInstrument = pstrDefinition + cbDefinition - 1;
	    *pstrInstrument-- = TEXT ('\0');

	    while (pstrInstrument != pstrDefinition && *pstrInstrument != TEXT ('<'))
		pstrInstrument--;

	    if (pstrInstrument == pstrDefinition)
	    {
		DPF(1, TEXT ("Bogus definition [%s]"), (LPTSTR)pstrDefinition);
		goto Cleanup_AddDevice;
	    }

	    *pstrInstrument++ = TEXT ('\0');
	}
	else
	{
	    pstrInstrument = pstrDefinition + cbDefinition;
	}

	DPF(1, TEXT ("AddDevice: pstrFile [%s]"), (LPTSTR)pstrFile);
	DPF(1, TEXT ("AddDevice: pstrInstrument: [%s]"), (LPTSTR)pstrInstrument);
    
	pinstrument = GetInstrument(pstrFile, pstrInstrument);
	if (NULL == pinstrument)
	{
	    DPF(1, TEXT ("Config Err: Could not load instrument!"));
	    goto Cleanup_AddDevice;
	}
    }
    else
    {
	DPF(1, TEXT ("Using default instrument"));
	// No definition given; use default instrument
	//
	pinstrument = NULL;
    }
    
    // Ok, now iterate through and try to allocate structures
    //
    pport = GetPort(uDeviceID);
    if (NULL == pport)
    {
	DPF(1, TEXT ("Config Err: No memory for port structure!"));
	goto Cleanup_AddDevice;
    }

    PortAddRef(pport);

    
    wChannelBit = 1; 
    for (idxChannel = 0; idxChannel < MAX_CHANNELS; idxChannel++, wChannelBit <<= 1)
    {
	if (wChannelMask & wChannelBit)
	{
	    if (gapChannel[idxChannel])
	    {
		DPF(1, TEXT ("Config Err: Attempt to overload channel!"));
		uRet = 0;
		goto Cleanup_AddDevice;
	    }
	    
	    pchannel = (PCHANNEL)LocalAlloc(LPTR, sizeof(CHANNEL));
	    if (NULL == pchannel)
	    {
		uRet = 0;
		DPF(1, TEXT ("Config Err: LocalAlloc() failed on PCHANNEL"));
		goto Cleanup_AddDevice;
	    }

	    pchannel->fwChannel     = 0;
	    pchannel->pport         = pport;
	    pchannel->uChannel      = idxChannel;       // MSG to change this???
	    pchannel->pinstrument   = pinstrument;
	    pchannel->pbPatchMap    = NULL;
	    if (pinstrument && DRUM_CHANNEL != idxChannel)
		pchannel->pbPatchMap = pinstrument->pbPatchMap;

	    // Port owns mask of channels which are used on itself
	    //
	    pport->wChannelMask |= (1 << idxChannel);

	    if (!pinstrument)
		pchannel->pbKeyMap = NULL;
	    else if (idxChannel != DRUM_CHANNEL)
		pchannel->pbKeyMap = pinstrument->pbGeneralKeyMap;
	    else
		pchannel->pbKeyMap = pinstrument->pbDrumKeyMap;

	    if (pinstrument)
		InstrumentAddRef(pinstrument);

	    gapChannel[idxChannel] = pchannel;
	    wAddedMask |= wChannelBit;

	    ++uRet;
	}
    }

Cleanup_AddDevice:

    if (!uRet)
    {
	DPF(1, TEXT ("AddDevice: gfConfigErr set!!!!"));
	// Something failed! Clean up everything we touched.
	//
	if (NULL != pport)
	{
	    PortReleaseRef(pport);

	    if (NULL != pinstrument)
	    {
		InstrumentAddRef(pinstrument);

		wChannelBit = 1;
		for (idxChannel = 0; idxChannel < MAX_CHANNELS; idxChannel++)
		{
		    if (wAddedMask & wChannelBit)
		    {
			InstrumentReleaseRef(pinstrument);

			LocalFree((HLOCAL)gapChannel[idxChannel]);
			gapChannel[idxChannel] = NULL;
		    }
		    wChannelBit <<= 1;
		}

		InstrumentReleaseRef(pinstrument);
	    }
	}
    }
    
    return uRet;
}

/***************************************************************************
  
   @doc internal
  
   @api PPORT | GetPort | Finds the port structure associated with
    the given device key and device ID, creating a blank port
    structure if one is not found.

   @parm UINT | uDeviceID | The device ID of the port to get
   
   @rdesc The PPORT describing the port or NULL if there was no port
    found and no memory to create a new port structure.
    
***************************************************************************/
PRIVATE PPORT FNLOCAL GetPort(
    UINT                uDeviceID)                              
{

    PPORT               pport;

    for (pport = gpportList; pport; pport = pport->pNext)
	if (pport->uDeviceID == uDeviceID)
	    break;

    if (NULL == pport)
    {
	pport = (PPORT)LocalAlloc(LPTR, sizeof(PORT));
	if (NULL != pport)
	{
	    pport->cRef         = 0;
	    pport->fwPort       = 0;
	    pport->wChannelMask = 0;
	    pport->uDeviceID    = uDeviceID;
	    pport->hmidi        = (HMIDIOUT)NULL;

	    pport->pNext = gpportList;
	    gpportList = pport;

	    ++gcPorts;
	}
    }
    else
    {
	DPF(1, TEXT ("Out of memory trying to create pport for device ID %u"),
	    (UINT)uDeviceID);
    }

    return pport;
}

PRIVATE void FNLOCAL PortAddRef(
    PPORT               pport)                                  
{
    ++pport->cRef;
}

PRIVATE void FNLOCAL PortReleaseRef(
    PPORT               pport)                                  
{
    PPORT               pportPrev;
    PPORT               pportCurr;

    assert(NULL == pport->hmidi);
    
    if (0 == --pport->cRef)
    {
	pportPrev = NULL;
	pportCurr = gpportList;
	
	while (pportCurr)
	{
	    if (pport == pportCurr)
		break;


	    pportPrev = pportCurr;
	    pportCurr = pportCurr->pNext;
	}

	if (pportCurr)
	{
	    if (pportPrev)
		pportPrev->pNext = pport->pNext;
	    else
		gpportList = pport->pNext;
	}
	
	LocalFree((HLOCAL)pport);
    }
}

/***************************************************************************
  
   @doc internal
  
   @api PINSTRUMENT | GetInstrument | Called to get a pointer to an instrument
    structure. 

   @parm PSTR | pstrFilename | Filename of IDF file to use.

   @parm PSTR | pstrInstrument | Description of instrument within file to use.

   @rdesc TRUE on success.

***************************************************************************/
PRIVATE PINSTRUMENT FNLOCAL GetInstrument(
    LPTSTR                pstrFilename,                                  
    LPTSTR                pstrInstrument)                                      
{
    PINSTRUMENT         pinstrument;
    static WORD         wMask;

    // See if we already have this instrument name in our list.
    // If so, no need to load another instance of it.
    //
    for (pinstrument = gpinstrumentList; pinstrument; pinstrument = pinstrument->pNext)
    {
	
	if ((!lstrcmpi(pinstrument->pstrInstrument, pstrInstrument)) &&
	    (!lstrcmpi(pinstrument->pstrFilename, pstrFilename)))
	    break;
    }

    // Instrument not already loaded? Try to load it.
    //
    if (NULL == pinstrument)
    {
	if (lstrcmpi(gszDefaultFile, pstrFilename) ||
	    lstrcmpi(gszDefaultInstr, pstrInstrument))
	{
	    // Not default 1:1 mapping, try to load IDF
	    //
	    pinstrument = LoadInstrument(pstrFilename, pstrInstrument);
	    if (NULL == pinstrument)
		pinstrument = MakeDefInstrument();
	}
	else
	{
	    // Generate a dummy mapping
	    //
	    pinstrument = MakeDefInstrument();
	}
    }

    return pinstrument;
}

PRIVATE void FNLOCAL InstrumentAddRef(
    PINSTRUMENT         pinstrument)                                  
{
    ++pinstrument->cRef;
}

PRIVATE void FNLOCAL InstrumentReleaseRef(
    PINSTRUMENT         pinstrument)                                  
{
    PINSTRUMENT         pinstrumentPrev;
    PINSTRUMENT         pinstrumentCurr;

    if (0 == --pinstrument->cRef)
    {
	pinstrumentPrev = NULL;
	pinstrumentCurr = gpinstrumentList;
	
	while (pinstrumentCurr)
	{
	    if (pinstrument == pinstrumentCurr)
		break;


	    pinstrumentPrev = pinstrumentCurr;
	    pinstrumentCurr = pinstrumentCurr->pNext;
	}

	if (pinstrumentCurr)
	{
	    if (pinstrumentPrev)
	    {
		pinstrumentPrev->pNext = pinstrument->pNext;
	    }
	    else
	    {
		gpinstrumentList = pinstrument->pNext;
	    }
	}

	if (pinstrument->pstrFilename)
	    LocalFree((HLOCAL)pinstrument->pstrFilename);
	
	if (pinstrument->pstrInstrument)
	    LocalFree((HLOCAL)pinstrument->pstrInstrument);
	
	if (pinstrument->pbPatchMap)
	    LocalFree((HLOCAL)pinstrument->pbPatchMap);
	
	if (pinstrument->pbDrumKeyMap)
	    LocalFree((HLOCAL)pinstrument->pbDrumKeyMap);
	
	if (pinstrument->pbGeneralKeyMap)
	    LocalFree((HLOCAL)pinstrument->pbGeneralKeyMap);
	
	LocalFree((HLOCAL)pinstrument);
    }
}

/***************************************************************************
  
   @doc internal
  
   @api PINSTRUMENT | LoadInstrument | Allocate memory for and load the
    contents of an instrument description from an IDF file.

   @parm PSTR | pstrFileName | File name of the IDF to read from.

   @parm PSTR | pstrInstrument | Instrument name within the IDF file
    to load the instrument from.
    
   @comm Load the instrument and add it to the global list of instruments.

    We use GlobalAlloc here instead of LocalAlloc since this isn't done
    very often and so we don't fragment our local heap by allocating/
    deallocating lots of little pieces.

   @rdesc TRUE on success; else FALSE.
       
***************************************************************************/
PRIVATE PINSTRUMENT FNLOCAL LoadInstrument(
    LPTSTR               pstrFileName,
    LPTSTR               pstrInstrument)
{
    HMMIO               hmmio;
    MMCKINFO            chkRIFF;
    MMCKINFO            chkParent;
    MMRESULT            mmr;
    LPIDFHEADER         lpIDFheader;
    LPIDFINSTCAPS       lpIDFinstcaps;
    LPIDFCHANNELINFO    rglpChanInfo[MAX_CHANNELS];
    LPIDFCHANNELINFO    lpChanInfo;
    LPIDFKEYMAP         rglpIDFkeymap[MAX_CHAN_TYPES];
    LPIDFPATCHMAPHDR    lpIDFpatchmaphdr;
    LPIDFCHANNELHDR     lpIDFchanhdr;
    BOOL                fFound;
    BOOL                fSuccess;
    PINSTRUMENT         pinstrument = NULL;
    PCHANINIT           pchaninit;
    UINT                idx;
    LPTSTR              lpsz;
    LPTSTR              pszName  = NULL;
    UINT                cbSize;
    UINT                cchSize;
    LPSTR               pszCHAR;
    LPTSTR              pszTCHAR;
    LPTSTR              pszID    = NULL;

    // Determine if the IDF has any path elements in it.
    //
    for (lpsz = pstrFileName; *lpsz; lpsz++)
	if (TEXT ('\\') == *lpsz || TEXT ('/') == *lpsz || TEXT (':') == *lpsz)
	    break;

    if (!*lpsz)
    {
	// Just a filename; precede it with path
	//
	cbSize = CB_MAXPATH * sizeof (TCHAR);
	if (NULL == (pszName = (LPTSTR)LocalAlloc(LPTR, cbSize)))
	    return NULL;

	if (! GetIDFDirectory(pszName, CB_MAXPATH))
	    lstrcpy(pszName, TEXT (".\\"));

	lstrcat(pszName, pstrFileName);

	lpsz = (LPTSTR)pszName;
    }
    else
    {
	lpsz = pstrFileName;
    }

    DPF(1, TEXT ("LoadInstrument: %s"), lpsz);
    
    // Try to open the IDF.
    //
    if (NULL == (hmmio = mmioOpen(lpsz, NULL, MMIO_ALLOCBUF|MMIO_READ)))
    {
	DPF(1, TEXT ("LoadInstrument: Cannot open [%s]!"), (LPTSTR)pstrFileName);
	goto LoadInstrument_Cleanup;
    }

    // Descend into the main RIFF chunk
    //
    chkRIFF.fccType = mmioFOURCC('I', 'D', 'F', ' ');
    if (MMSYSERR_NOERROR != (mmr = mmioDescend(hmmio, &chkRIFF, NULL, MMIO_FINDRIFF)))
    {
	DPF(1, TEXT ("mmioDescend returned %u on RIFF chunk"), mmr);
	mmioClose(hmmio, 0);
	goto LoadInstrument_Cleanup;
    }

    // Ensure valid format and scan for the instrument the caller specified.
    //
    fFound = FALSE;
    fSuccess = FALSE;
    pinstrument = NULL;
    
    while (!fFound)
    {
	chkParent.fccType = mmioFOURCC('M', 'M', 'A', 'P');
	if (MMSYSERR_NOERROR != (mmr = mmioDescend(hmmio, &chkParent, &chkRIFF, MMIO_FINDLIST)))
	{
	    DPF(1, TEXT ("mmioDescend returned %u before [%s] found."), (UINT)mmr, (LPTSTR)pstrInstrument);
	    mmioClose(hmmio, 0);
	    goto LoadInstrument_Cleanup;
	}

	if (NULL == (lpIDFheader = ReadHeaderChunk(hmmio, &chkParent)))
	{
	    DPF(1, TEXT ("No header chunk!"));
	}
	else
	{
	    //  Copy ID single byte string to UNICODE string 
	    //
	    cchSize = lstrlenA (lpIDFheader->abInstID);
	    cbSize = cchSize + 1 * sizeof(TCHAR);
	    pszID = (LPTSTR) LocalAlloc(LPTR, cbSize);

	    pszCHAR = (LPSTR)lpIDFheader->abInstID;
	    pszTCHAR = pszID;

	    while (0 != (*pszTCHAR++ = *pszCHAR++))
	       ;

	    if (NULL == pszID)
	       {
	       mmioClose(hmmio,0);
	       goto LoadInstrument_Cleanup;
	       }

	    DPF(1, TEXT ("Header chunk found! [%s]"), (LPTSTR)pszID);

	    // NOTE: Unspecified pstrInstrument (empty string) means get
	    // first one
	    //
	    if ((!*pstrInstrument) || !lstrcmpi(pszID, pstrInstrument))
		fFound = TRUE;

#ifdef DEBUG
	    if (!*pstrInstrument)
	    {
		DPF(1, TEXT ("LoadInstrument: Asked for first; got [%s]"), (LPTSTR)pszID);
	    }
#endif

	    if (pszID)
	       LocalFree ((HLOCAL)pszID);

	    if (fFound)
	    {
		DPF(1,TEXT ("Instrument found!"));

		// Pull in the rest of the stuff we need from the IDF. Don't
		// actually try to allocate the instrument structure
		// until we're sure eveything is OK.
		//

		lpIDFinstcaps       = ReadCapsChunk(hmmio, &chkParent);
		lpIDFchanhdr        = ReadChannelChunk(hmmio, &chkParent, (LPIDFCHANNELINFO BSTACK *)rglpChanInfo);
		lpIDFpatchmaphdr    = ReadPatchMapChunk(hmmio, &chkParent);
		ReadKeyMapChunk(hmmio, &chkParent, (LPIDFKEYMAP BSTACK *)rglpIDFkeymap);
		

		if (lpIDFinstcaps && lpIDFchanhdr)
		{
		    // We read all the chunks - now construct the PINSTRUMENT
		    // and add it to the list.
		    //
		    pinstrument = (PINSTRUMENT)LocalAlloc(LPTR, sizeof(INSTRUMENT));
		    if (NULL == pinstrument)
		    {
			DPF(1, TEXT ("[Local]Alloc failed on PINSTRUMENT!!!"));
		    }
		    else
		    {
			pinstrument->pstrInstrument     = NULL;
			pinstrument->cRef               = 0;
			pinstrument->fdwInstrument      = lpIDFchanhdr->fdwFlags;
			pinstrument->dwGeneralMask      = lpIDFchanhdr->dwGeneralMask;
			pinstrument->dwDrumMask         = lpIDFchanhdr->dwDrumMask;
			pinstrument->pbPatchMap         = NULL;
			pinstrument->pbDrumKeyMap       = NULL;
			pinstrument->pbGeneralKeyMap    = NULL;

			pchaninit = pinstrument->rgChanInit;
			for (idx = 0; idx < MAX_CHANNELS; idx++)
			{
			    pchaninit->cbInit        = 0;
			    pchaninit->pbInit        = NULL;
			    
			    pchaninit++;
			}

			// Save the instrument name and file name so we can identify future
			// instances. 
			//
			
			cbSize = lstrlen(pstrFileName)+1 * sizeof (TCHAR);
			pinstrument->pstrFilename = (LPTSTR)LocalAlloc(LPTR, cbSize);
			if (NULL == pinstrument->pstrFilename)
			    goto Instrument_Alloc_Failed;

			lstrcpy(pinstrument->pstrFilename, pstrFileName);
			
			cbSize = lstrlen(pstrInstrument)+1 * sizeof (TCHAR);
			pinstrument->pstrInstrument = (LPTSTR)LocalAlloc(LPTR, cbSize);
			if (NULL == pinstrument->pstrInstrument)
			    goto Instrument_Alloc_Failed;

			lstrcpy(pinstrument->pstrInstrument, pstrInstrument);

			// Alloc and save the patch and key maps, if any
			//

			if (NULL != lpIDFpatchmaphdr)
			{
			    pinstrument->pbPatchMap = (PBYTE)LocalAlloc(LPTR, sizeof(lpIDFpatchmaphdr->abPatchMap));
			    if (NULL == pinstrument->pbPatchMap)
				goto Instrument_Alloc_Failed;

			    hmemcpy(
				     pinstrument->pbPatchMap,
				     lpIDFpatchmaphdr->abPatchMap,
				     sizeof(lpIDFpatchmaphdr->abPatchMap));
			}

			// Alloc and copy whatever key maps were in the IDF
			//
			if (rglpIDFkeymap[IDX_CHAN_GEN])
			{
			    pinstrument->pbGeneralKeyMap = (PBYTE)LocalAlloc(LPTR, sizeof(rglpIDFkeymap[IDX_CHAN_GEN]->abKeyMap));
			    if (NULL == pinstrument->pbGeneralKeyMap)
				goto Instrument_Alloc_Failed;

			    hmemcpy(
				    pinstrument->pbGeneralKeyMap,
				    rglpIDFkeymap[IDX_CHAN_GEN]->abKeyMap,
				    sizeof(rglpIDFkeymap[IDX_CHAN_GEN]->abKeyMap));
			}
			    
			if (rglpIDFkeymap[IDX_CHAN_DRUM])
			{
			    pinstrument->pbDrumKeyMap = (PBYTE)LocalAlloc(LPTR, sizeof(rglpIDFkeymap[IDX_CHAN_DRUM]->abKeyMap));
			    if (NULL == pinstrument->pbDrumKeyMap)
				goto Instrument_Alloc_Failed;

			    hmemcpy(
				    pinstrument->pbDrumKeyMap,
				    rglpIDFkeymap[IDX_CHAN_DRUM]->abKeyMap,
				    sizeof(rglpIDFkeymap[IDX_CHAN_DRUM]->abKeyMap));
			}
			   

			// Now build the channel init structures
			//
			for (idx = 0; idx < MAX_CHANNELS; idx++)
			{
			    if (NULL != (lpChanInfo = rglpChanInfo[idx]))
			    {
				if (lpChanInfo->cbInitData & 0xFFFF0000)
				{
				    DPF(1, TEXT ("IDF specifies init data > 64K! Ignored."));
				    continue;
				}
				
				pchaninit = &pinstrument->rgChanInit[idx];

				if (lpChanInfo->cbInitData)
				{
				    if (NULL == (pchaninit->pbInit = (PBYTE)
					LocalAlloc(LPTR, (UINT)lpChanInfo->cbInitData)))
					goto Instrument_Alloc_Failed;

				    hmemcpy(
					     pchaninit->pbInit,
					     lpChanInfo->abData,
					     (UINT)lpChanInfo->cbInitData);

				    pchaninit->cbInit = lpChanInfo->cbInitData;
				}
			    }
			}
		    }
		}

Instrument_Alloc_Failed:                
		// Make sure we free anything the parse threw at us.
		//
		if (NULL != lpIDFinstcaps)
		    GlobalFreePtr(lpIDFinstcaps);
		
		if (NULL != lpIDFpatchmaphdr)
		    GlobalFreePtr(lpIDFpatchmaphdr);

		if (NULL != lpIDFchanhdr)
		    GlobalFreePtr(lpIDFchanhdr);
		
		for (idx = 0; idx < MAX_CHAN_TYPES; idx++)
		    if (NULL != rglpIDFkeymap[idx])
			GlobalFreePtr(rglpIDFkeymap[idx]);
	    }
	}

	GlobalFreePtr(lpIDFheader);
	mmioAscend(hmmio, &chkParent, 0);
    }

    if (!fSuccess)
    {
	// Clean up anything we might have possibly allocated
	//
    }
    
    if (pinstrument)
    {
	DPF(1, TEXT ("LoadInstrument success!"));
	pinstrument->pNext = gpinstrumentList;
	gpinstrumentList = pinstrument;
    }
    else
    {
	DPF(1, TEXT ("LoadInstrument failure."));
    }

    mmioAscend(hmmio, &chkRIFF, 0);
    mmioClose(hmmio, 0);


LoadInstrument_Cleanup:
    
    if (pszName) 
	LocalFree((HLOCAL)pszName);

    return pinstrument;
}

PRIVATE PINSTRUMENT FNLOCAL MakeDefInstrument(
    void)
{
    PINSTRUMENT             pinstrument;
    PCHANINIT               pchaninit; 
    UINT                    idx;
    UINT                    cbSize;
    
    pinstrument = (PINSTRUMENT)LocalAlloc(LPTR, sizeof(INSTRUMENT));
    if (NULL == pinstrument)
    {
	DPF(1, TEXT ("[Local]Alloc failed on PINSTRUMENT!!!"));
	return NULL;
    }

    pinstrument->pstrInstrument     = NULL;
    pinstrument->cRef               = 0;
    pinstrument->fdwInstrument      = 0;
    pinstrument->pbPatchMap         = NULL;
    pinstrument->pbDrumKeyMap       = NULL;
    pinstrument->pbGeneralKeyMap    = NULL;

    pchaninit = pinstrument->rgChanInit;
    for (idx = 0; idx < MAX_CHANNELS; idx++, pchaninit++)
    {
	pchaninit->cbInit = 0;
	pchaninit->pbInit = NULL;
    }

    // Save the instrument name and file name so we can identify future
    // instances. 
    //
    cbSize = (lstrlen(gszDefaultFile) + 1) * sizeof(TCHAR);

    pinstrument->pstrFilename = (LPTSTR)LocalAlloc(LPTR, cbSize);
    if (NULL == pinstrument->pstrFilename)
    {
	LocalFree((HLOCAL)pinstrument);
	return NULL;
    }

    lstrcpy(pinstrument->pstrFilename, gszDefaultFile);


    cbSize = (lstrlen(gszDefaultInstr) + 1) * sizeof(TCHAR);
    
    pinstrument->pstrInstrument = (LPTSTR)LocalAlloc(LPTR, cbSize);
    if (NULL == pinstrument->pstrInstrument)
    {
	LocalFree((HLOCAL)pinstrument->pstrFilename);
	LocalFree((HLOCAL)pinstrument);
	return NULL;
    }

    lstrcpy(pinstrument->pstrInstrument, gszDefaultInstr);

    
    return pinstrument;
}

/***************************************************************************
  
   @doc internal
  
   @api BOOL | UpdateInstruments | Called to reconfigure the mapper when
    control panel pokes at it.

   @rdesc TRUE on success; FALSE if the request was deferred because
    there are open instances.

***************************************************************************/
BOOL FNGLOBAL UpdateInstruments(     
    BOOL                fFromCPL,
    DWORD               fdwUpdate)

{
    if (IS_INRUNONCE)
    {
	DPF(1, TEXT ("Got reconfig while RunOnce going...ignored"));
	return TRUE;
    }
    
    if ((fdwUpdate & 0xFFFF) == DRV_F_PROP_INSTR)
       {
       DPF(1, TEXT ("Reconfig from CPL or RunOnce"));
       }
    
    DPF(1, TEXT ("UpdateInstruments called."));
    if (IS_DEVSOPENED)
    {
	SET_RECONFIGURE;
	return FALSE;
    }
    else
    {
	Unconfigure();

	if (Configure(fdwUpdate))
	{
	    Unconfigure();
	    if (Configure(fdwUpdate))
		DPF(1, TEXT ("Tried to reconfigure more than twice -- uh-oh"));
	}
    }

    return TRUE;
}

/*+ GetIDFDirectory
 *
 *-=================================================================*/

PRIVATE BOOL FNLOCAL GetIDFDirectory (
    LPTSTR                  pszDir,
    DWORD                   cchDir)
{
    HKEY                    hKey;
    UINT                    cbSize;

    *pszDir = 0;

    cbSize = cchDir * sizeof(TCHAR);

    if (!RegOpenKey (HKEY_LOCAL_MACHINE, gszSetupKey, &hKey))
    {
	RegQueryValueEx (hKey, 
			 gszMachineDir, 
			 NULL, 
			 NULL, 
			 (LPBYTE)pszDir, 
			 &cbSize);
	RegCloseKey (hKey);
	
	cchDir = cbSize / sizeof(TCHAR);
	if (!cchDir--)
	    return FALSE;
    }
    else if (!GetWindowsDirectory(pszDir, (UINT)cchDir))
	return FALSE;

    cchDir = lstrlen (pszDir);
    if (pszDir[cchDir -1] != TEXT ('\\'))
	pszDir[cchDir++] = TEXT ('\\');
    lstrcpy (pszDir + cchDir, gszConfigDir);

    return TRUE;
}

/***************************************************************************
  
   @doc internal
  
   @api VOID | ValidateChannelTypes | Ensure that the given channel
    assignments in the registry are correct in terms of the IDF's. Make an
    attempt to find a drum channel if needed; it might be on channel 16
    for a hindered driver.

***************************************************************************/
PRIVATE VOID FNLOCAL DeassignChannel(
    UINT                uChannel)
{
    UINT                idx;

    assert(uChannel < MAX_CHANNELS);

    if (!gapChannel[uChannel])
	return;
    
    for (idx = 0; idx < MAX_CHANNELS; idx++)
    {
	if (gapChannel[idx])
	{
	    if ((idx != uChannel) &&
		(gapChannel[uChannel]->pport == gapChannel[idx]->pport))
	    {
		break;
	    }
	}
    }

    if (idx == MAX_CHANNELS)
	PortReleaseRef(gapChannel[uChannel]->pport);

    InstrumentReleaseRef(gapChannel[uChannel]->pinstrument);
    LocalFree((HLOCAL)gapChannel[uChannel]);
    gapChannel[uChannel] = NULL;
}

PRIVATE VOID FNLOCAL ValidateChannelTypes(
    VOID)
{
    UINT                idxChan;
    DWORD               dwChanBit;
    DWORD               dwIDFMask;
    PCHANNEL            pchannel;
    UINT                uNewDrumChan;
    PINSTRUMENT         pinst;

    DPF(2, TEXT ("  --- ValidateChannelTypes ---"));
    // First, mute any channel that doesn't match the correct channel type
    //
    for (idxChan = 0,           dwChanBit = 1;
	 idxChan < MAX_CHANNELS;
	 ++idxChan,             dwChanBit <<= 1)
    {
	if (NULL == (pchannel = gapChannel[idxChan]))
	{
	    DPF(2, TEXT ("  Channel %u was never allocated"), idxChan);
	    continue;
	}

	if (NULL == pchannel->pinstrument)
	{
	    DPF(2, TEXT ("  Channel %u contains default instrument"), idxChan);
	    continue;
	}

	dwIDFMask = (idxChan != DRUM_CHANNEL) ?
			pchannel->pinstrument->dwGeneralMask :
			pchannel->pinstrument->dwDrumMask;

	if (dwIDFMask & dwChanBit)
	    continue;

	DPF(2, TEXT ("  Muting channel %u"), idxChan);

	pchannel->fwChannel |= CHAN_F_MUTED;
    }

    // Now, if the drum channel is assigned but muted, attempt to find a drum
    // channel on the same instrument.
    //
    if (NULL == (pchannel = gapChannel[DRUM_CHANNEL]))
    {
	DPF(2, TEXT ("  No drum channel"));
	goto Validate_Cleanup;
    }

    if (!(pchannel->fwChannel & CHAN_F_MUTED))
    {
	DPF(2, TEXT ("  Drum channel already valid"));
	goto Validate_Cleanup;
    }

    pinst = pchannel->pinstrument;
    assert(pinst);

    dwIDFMask = pchannel->pinstrument->dwDrumMask;

    for (uNewDrumChan = 0,              dwChanBit = 1;
	 uNewDrumChan < MAX_CHANNELS;
	 ++uNewDrumChan,                dwChanBit <<= 1)
	if (dwChanBit & dwIDFMask)
	    break;

    if (uNewDrumChan != MAX_CHANNELS)
    {
	DPF(2, TEXT ("  New drum channel %u"), uNewDrumChan);
	
	// We've found a new drum channel; mute anything that's using it as a
	// general channel
	//
	for (idxChan = 0; idxChan < MAX_CHANNELS; ++idxChan)
	    if (idxChan != DRUM_CHANNEL &&
		gapChannel[idxChan] &&
		gapChannel[idxChan]->pinstrument == pinst &&
		gapChannel[idxChan]->uChannel == uNewDrumChan)
	    {
		DPF(2, TEXT ("  Channel %u was on new drum channel"), idxChan);
		gapChannel[idxChan]->fwChannel |= CHAN_F_MUTED;
	    }

	// Now assign it is a drum channel
	//

	pchannel->fwChannel     &= ~CHAN_F_MUTED;
	pchannel->uChannel      = uNewDrumChan;
	pchannel->pbPatchMap    = NULL;
	pchannel->pbKeyMap      = pinst->pbDrumKeyMap;
    }
	
    // Now go through and deassign all muted channels. This will free
    // their memory
    //

Validate_Cleanup:
    DPF(2, TEXT ("  Validate cleanup"));
    
    for (idxChan = 0; idxChan < MAX_CHANNELS; ++idxChan)
	if (gapChannel[idxChan] &&
	    (gapChannel[idxChan]->fwChannel & CHAN_F_MUTED))
	{
	    DPF(2, TEXT ("  Deassign %u"), idxChan);
	    DeassignChannel(idxChan);
	}

    DPF(2, TEXT ("  --- Validate End ---"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\debug.h ===
//==========================================================================;
//
//      Copyright (c) 1991-1995 Microsoft Corporation
//
//      You have a royalty-free right to use, modify, reproduce and 
//      distribute the Sample Files (and/or any modified version) in 
//      any way you find useful, provided that you agree that 
//      Microsoft has no warranty obligations or liability for any 
//      Sample Application Files which are modified. 
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//  Notes:
//
//      To use this library at interrupt time under Win16, you must do
//      the following:
//
//      1. Defined ISRDEBUG when compiling debug.c
//  
//      2. Add a line in the SEGMENTS section of your .DEF file to
//         define the DEBUG_TEXT segment:
//
//
//      SEGMENTS
//          DEBUG_TEXT FIXED PRELOAD
//
//
//      These routines are callable at interrupt time under Win32 by
//      default.
//
//      3. No need for UNICODE support for debug routines
//
//  win.ini
//  [debug]
//  MIDIMAP=0|1|2|3|4
//
//  History:
//      11/23/92    cjp     [curtisp] 
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//  
//
//
//
#define  ISRDEBUG             1
#define  DEBUG_SECTION        TEXT ("debug")   // section name for 
#define  DEBUG_MODULE_NAME    TEXT ("MIDIMAP") // key name and prefix for output
#define  DEBUG_MAX_LINE_LEN   255              // max line length (bytes)

#define  K_DEFAULT_LOGMEM     32
#define  K_MAX_LOGMEM         63
    
#define  DRV_ENABLE_DEBUG     (DRV_USER+1)   // Enable/disable debug message
#define  DRV_SET_DEBUG_LEVEL  (DRV_USER+2)   // Message to set the debug level

#define WM_DEBUGUPDATE        (WM_USER+1000)

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    VOID WINAPI WinAssert(LPSTR lpstrExp, LPSTR lpstrFile, DWORD dwLine);
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI DbgRegisterCallback(HWND hWnd);
    BOOL WINAPI DbgGetNextLogEntry(LPTSTR lpstrBuffer, UINT cbBuffer);

    void FAR CDECL dprintf(UINT uDbgLevel, LPTSTR szFmt, ...);

    #define assert(exp) \
        ( (exp) ? (void) 0 : WinAssert(#exp, __FILE__, __LINE__) )

    #define DPF                  dprintf

    #define D1(sz)               dprintf(1,sz) 
    #define D2(sz)               dprintf(2,sz) 
    #define D3(sz)               dprintf(3,sz) 
    #define D4(sz)               dprintf(4,sz) 
#else
    #define assert(exp)          ((void)0)
    
    #define DbgEnable(x)         FALSE
    #define DbgSetLevel(x)       0
    #define DbgInitialize(x)     0

    #define DPF                  1 ? (void)0 : (void)

    #define D1(sz)
    #define D2(sz)
    #define D3(sz)
    #define D4(sz)
#endif


#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\idf.h ===
//************************************************************************
//**
//**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//**  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//**  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//**  A PARTICULAR PURPOSE.
//**
//**  Copyright (c) 1993-1995 Microsoft Corporation
//**
//**  IDF.h
//**
//**  DESCRIPTION:
//**     This file contains the format of the .IDF files.
//**
//**  HISTORY:
//**     04/29/93       created.
//**     07/04/93       added UNICODE for displayable strings.
//**     09/04/93       added keymaps.
//**     09/05/93       added ID's for channel types.
//**
//************************************************************************

/*
@doc  EXTERNAL SDK

@types   IDFHEADER |
   This is the format of the "hdr " chunk in a Microsoft IDF file.
   This will be the first subchunk of a "MMAP" list chunk.  This will 
   provide information on the IDF itself; what version, who created it,
   and a unique ASCII ID for the instrument.

@field   DWORD | cbStruct |
   This is the inclusive size of the header structure.

@field   DWORD | dwVersion |
   This is the version of the IDF file.
   under.

@field   DWORD | dwCreator |
   This is the creator ID for the IDF.

@field   DWORD | cbInstID |
   This is the size of the unique instrument identifier including the NULL.

@field   BYTE | abInstID[] |
   This is the actual ASCII bytes of the unique instrument id. This _IS_ 
   NULL terminated.  There is no UNICODE version of this since this will
   only be used internally and not displayed to the user.

@othertype  IDFHEADER * | PIDFHEADER |
   A memory model dependant pointer to the structure.

@othertype  IDFHEADER FAR* | LPIDFHEADER |
   A far pointer to the structure.
*/

typedef struct tag_IDFHEADER
{
   DWORD cbStruct;

   DWORD dwVersion;
   DWORD dwCreator;

   DWORD cbInstID;
   BYTE  abInstID[1];
} IDFHEADER, *PIDFHEADER, FAR *LPIDFHEADER;


/*
@doc  EXTERNAL SDK

@types   IDFINSTINFO |
   This is the format of the "inst" chunk in a Microsoft IDF file.
   This chunk will contain information on the instrument, e.g. who
   manufactured it, the name of the instrument, it's manufacturer and
   product id's and a revision number.

@field   DWORD | cbStruct |
   This is the inclusive size of the instrument information structure.

@field   DWORD | dwManufactID |
   Manufacturer's ID.

@field   DWORD | dwProductID |
   Product's ID.

@field   DWORD | dwRevision |
   Revision of the product.

@field   DWORD | cbManufactASCII |
   Length of the ASCII version of the manufacturuers name.

@field   DWORD | cbManufactUNICODE |
   Length of the UNICODE version of the manufacturuers name.

@field   DWORD | cbProductASCII |
   Length of the ASCII version of the product name.

@field   DWORD | cbProductUNICODE |
   Length of the UNICODE version of the product name.

@field   BYTE | abData[] |
   Contains the ASCII and UNICODE strings for the manufacturer and product
   names.  NOTE that all strings are separated by a NULL and the NULL IS
   counted in the string lengths.

@othertype  IDFINSTINFO * | PIDFINSTINFO |
   A memory model dependant pointer to the structure.

@othertype  IDFINSTINFO FAR * | LPIDFINSTINFO |
   A far pointer to the structure.

@comm The idea is that the cbManufactXXXXX and cbProductXXXXX will be the
      offsets into the bData array of bytes and it will contain a complete
      string that you can strcpy out.  That is why the NULL is included in
      the byte count and in the actual data.
*/

typedef struct tag_IDFINSTINFO
{
   DWORD cbStruct;

   DWORD dwManufactID;
   DWORD dwProductID;
   DWORD dwRevision;

   DWORD cbManufactASCII;
   DWORD cbManufactUNICODE;
   DWORD cbProductASCII;
   DWORD cbProductUNICODE;

   BYTE  abData[1];
} IDFINSTINFO, FAR *LPIDFINSTINFO;

/*
@doc  EXTERNAL SDK

@types   IDFINSTCAPS |
   This is the format of the "caps" chunk in a Microsoft IDF file.
   This chunk will contain information on the MIDI capabilities of
   the device. e.g. basic channel of the instrument, number of channels
   that the instrument has available. the polyphony of the instrument, 
   whether or not it supports General MIDI, etc....

@field   DWORD | cbStruct |
   This is the size of the capabilities structure.

@field   DWORD | fdwFlags |
   Flags specifiying additional capabilities of an instrument.

@flag IDFINSTCAPS_F_GENERAL_MIDI |
   Instrument supports General MIDI.

@flag IDFINSTCAPS_F_SYSTEMEXCLUSIVE |
   Instrument supports system exclusive messages

@field   DWORD | dwBasicChannel |
   The basic channel for the instrument.

@field   DWORD | cNumChannels |
   Number of channels that the instrument supports to.

@field   DWORD | cInstrumentPolyphony |
   The total polyphony for the instrument.

@field   DWORD | cChannelPolyphony |
   The polyphony per channel.

@othertype  IDFINSTCAPS * | PIDFINSTCAPS |
   A memory model dependant pointer to the structure.

@othertype  IDFINSTCAPS FAR * | LPIDFINSTCAPS |
   A far pointer to the structure.
*/

typedef struct tag_IDFINSTCAPS
{
   DWORD cbStruct;
   DWORD fdwFlags;
   DWORD dwBasicChannel;
   DWORD cNumChannels;
   DWORD cInstrumentPolyphony;
   DWORD cChannelPolyphony;
} IDFINSTCAPS, *PIDFINSTCAPS, FAR *LPIDFINSTCAPS;

#define  IDFINSTCAPS_F_GENERAL_MIDI       0x00000001
#define  IDFINSTCAPS_F_SYSTEMEXCLUSIVE    0x00000002

/*
@doc  EXTERNAL SDK

@types   IDFCHANNELHDR |
   This is the format of the "chan" chunk in a Microsoft IDF file.
   This contains a description on what "type" a channel is, i.e. 
   is it a General MIDI channel, a drum channel, etc... Directly 
   following this header is the actual data on each channel.

@field   DWORD | cbStruct |
   This is the size of the channel header structure.

@field   DWORD | fdwFlags |
   Flags describing the channel type information.

@flag IDFCHANNELHDR_F_GENERAL_MIDI |
   If this flag is set then any channels that are not defined in the 
   IDF are General MIDI channel types.  If this flag is _NOT_ set then
   any channels that are not defined in the IDF are undefined and should 
   NOT be used in mapping. This flag overrides the contents of dwGeneralMask
   and dwDrumMask.

@field DWORD | dwGeneralMask |
   This mask indicates which channels are available for
   use as general channels. The channels will be considered usable even if
   there is no associcate IDFCHANNELINFO structure defined.

@field DWORD | dwDrumMask |
   This mask indicates which channels are available for
   use as drum channels. The channels will be considered usable even if
   there is no associcate IDFCHANNELINFO structure defined.

@field   DWORD | cNumChannels |
   This is the number of channels that follows the header.

@othertype  IDFCHANNELHDR * | PIDFCHANNELHDR |
   A memory model dependant pointer to the structure.

@othertype  IDFCHANNELHDR FAR * | LPIDFCHANNELHDR |
   A far pointer to the structure.
*/

typedef struct tag_IDFCHANNELHDR
{
   DWORD cbStruct;
   DWORD dwGeneralMask;
   DWORD dwDrumMask;
   DWORD dwReserved;                    // Must be zero
   DWORD fdwFlags;
} IDFCHANNELHDR, *PIDFCHANNELHDR, FAR *LPIDFCHANNELHDR;

#define  IDFCHANNELHDR_F_GENERAL_MIDI     0x00000001


/*
@doc  EXTERNAL SDK

@types    IDFCHANNELINFO |
   This is the format of the actual channel information for Microsoft
   authored IDF files. This is the Microsoft supported format for
   channel information.

@field   DWORD | dwChannel |
   This is the channel number that the structure defines.

@field   DWORD | fdwChannel |
   Defines the possible types this channel can be.

   @flag    IDFCHANNELINFO_F_GENERAL_CHANNEL |
       Indicates that this channel may be a general channel.

   @flag    IDFCHANNELINFO_F_DRUM_CHANNEL |
       Indicates that this channel may be a drum channel.

@field   DWORD | cbInitData |
    Specifies the length of the data which should be sent to initialize
    the channel. This data will be send to initialize the channel each
    time the mapper is opened.

@field    BYTE | abData[] |
    This field contains the actual initialization data.
    <f cbInitData> should indicate the length of this sequence,
    byte aligned. However, the actual sequence should be padded so that
    it is actually DWORD aligned (i.e. even multiple
    of four bytes). <f cbStruct> should reflect the padded length of
    the sequences.
        
@othertype  IDFCHANNELINFO * | PIDFCHANNELINFO |
   A memory model dependant pointer to the structure.

@othertype  IDFCHANNELINFO FAR * | LPIDFCHANNELINFO |
   A far pointer to the structure.
*/

typedef struct tag_IDFCHANNELINFO
{
   DWORD cbStruct;
   DWORD dwChannel;
   DWORD cbInitData;
   BYTE  abData[];
} IDFCHANNELINFO, *PIDFCHANNELINFO, FAR *LPIDFCHANNELINFO;

/*
@doc  EXTERNAL SDK

@types   IDFPATCHMAPHDR |
   This is the format of the "map " chunk in a Microsoft IDF file.
   This chunk contains information on the patch map used for the 
   instrument. Directly following this header is the actual mapping 
   information for each patch.

@field   DWORD | cbStruct |
   This is the size of the patch map header structure.

@field   BYTE | abPatchMap[128] |
   This array contains the actual patch map. The incoming patch is
   used to index the array; the array contents are the new patch value
   and must be in the range 0x00-0x7F. Patch maps will only apply to
   channels of type general. If the instrument needs a patch change
   on a drum channel, it should be included in the initialization data
   in the IDFCHANNELINFO.

@othertype  IDFPATCHMAPHDR * | PIDFPATCHMAPHDR |
   A memory model dependant pointer to the structure.

@othertype  IDFPATCHMAPHDR FAR * | LPIDFPATCHMAPHDR |
   A far pointer to the structure.
*/

typedef struct tag_IDFPATCHMAPHDR
{
   DWORD cbStruct;
   BYTE  abPatchMap[128];
           
} IDFPATCHMAPHDR, *PIDFPATCHMAPHDR, FAR *LPIDFPATCHMAPHDR;

/*
@doc  EXTERNAL SDK

@types   IDFKEYMAPHDR |
   This is the format of the "key " chunk in a Microsoft IDF file.
   This chunk contains information on the all of the key maps used 
   for a given instrument. The information that is in this structure
   pertains to all of the key maps for the instrument.  It contains
   the total number of key maps for the instrument and whether or not
   the key maps are General MIDI.

@field   DWORD | cbStruct |
   This is the size of the key map header structure.

@field   DWORD | cNumKeyMaps |
   This is the number of key maps that follow the header.

@field   DWORD | cbKeyMap |
   This is the size of each key map that follows the header.   

@othertype  IDFPATCHMAPHDR * | PIDFPATCHMAPHDR |
   A memory model dependant pointer to the structure.

@othertype  IDFPATCHMAPHDR FAR * | LPIDFPATCHMAPHDR |
   A far pointer to the structure.
*/

typedef struct tag_IDFKEYMAPHDR
{
   DWORD cbStruct;
   DWORD cNumKeyMaps;
   DWORD cbKeyMap;
} IDFKEYMAPHDR, *PIDFKEYMAPHDR, FAR *LPIDFKEYMAPHDR;

/*
@doc  EXTERNAL SDK

@types   IDFKEYMAP |
   This is the format of the "gkey" or "dkey" chunk in a Microsoft
   IDF file. This chunk contains information on the all of the key maps
   used for a given instrument. The information that is in this structure
   pertains to all of the key maps for the instrument.  It contains
   the total number of key maps for the instrument and whether or not
   the key maps are General MIDI.

@field   DWORD | cbStruct |
   This is the size of the key map header structure.

@field   BYTE | abKeyMap[128] |
    This field contains the actual key map. The incoming key number from
    a note on or note off message is used to index this array; the array
    contents are the new key value. If the high bit it set in the new
    key value, then the note on or note off will be ignore; otherwise,
    it will be transmitted with the new key value.
    
@othertype  IDFKEYMAP * | PIDFKEYMAP |
   A memory model dependant pointer to the structure.

@othertype  IDFKEYMAP FAR * | LPIDFKEYMAP |
   A far pointer to the structure.
*/

typedef struct tag_IDFKEYMAP
{
   DWORD cbStruct;
   BYTE  abKeyMap[128];
} IDFKEYMAP, *PIDFKEYMAP, FAR *LPIDFKEYMAP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\file.c ===
/**********************************************************************

  Copyright (c) 1992-1995 Microsoft Corporation

  file.c

  DESCRIPTION:
    Code to read stuff out of IDF files.

  HISTORY:
     02/26/93       [jimge]        created (copied from IDFEDIT).

*********************************************************************/

#include "preclude.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "idf.h"

#include <ctype.h>

#include "midimap.h"
#include "debug.h"

/***************************************************************************
  
   @doc internal
  
   @api LPIDFHEADER | ReadHeaderChunk | Read the header chunk from a IDF
    file. 

   @parm HMMIO | hmmio | Handle to the file to read from.

   @parm LPMMCKINFO | pchkParent | Pointer to a chunk information structure
    which describes the parent chunk.

   @comm
    Must already be descended into the parent chunk.

    This function will GlobalAlloc memory to read the chunk into.
    The caller must free it when he is done with it.

   @rdesc NULL on failure or a far pointer to the header structure.
       
***************************************************************************/
LPIDFHEADER FNLOCAL ReadHeaderChunk(
    HMMIO               hmmio,                                    
    LPMMCKINFO          pchkParent)
{
    LPIDFHEADER         pIDFHeader;
    MMRESULT            mmr;
    MMCKINFO            chkSub;
    LONG                l;

    // We are looking for the instruments header chunk.
    //
    chkSub.ckid = mmioFOURCC('h', 'd', 'r', ' ');

    // Descend to the "hdr " chunk in this list.
    //
    mmioSeek(hmmio, pchkParent->dwDataOffset + sizeof(FOURCC), SEEK_SET);
    mmr = mmioDescend(hmmio, &chkSub, pchkParent, MMIO_FINDCHUNK);
    if (MMSYSERR_NOERROR != mmr)
    {
        // Could not find the chunk.
        //
        DPF(1, TEXT ("ReadHeaderChunk: mmr %u on mmioDescend"), (UINT)mmr);
        return NULL;
    }

    // We found the "hdr " chunk, now check it's size and
    // see if it is one that we can read.
    // We check to make sure that the size of the chunks is
    // greater than a IDFHEADER, this ensures that the IDF
    // has some sort of unique name at the end.
    //
    if (sizeof(IDFHEADER) >= chkSub.cksize)
    {
        // The sizeof the IDF header is not what we expected.
        //
        DPF(1, TEXT ("ReadHeaderChunk: Chunk size too small"));
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;
    }

    // Allocate memory for the header.
    //
    pIDFHeader = (LPIDFHEADER)GlobalAllocPtr(GHND, chkSub.cksize);
    if (NULL == pIDFHeader)
    {
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;
    }

    // Read in the whole chunk into our buffer.
    //
    l = mmioRead(hmmio, (HPSTR)pIDFHeader, chkSub.cksize);
    if (chkSub.cksize != (DWORD)l)
    {
        // We didn't read in the amount of data that was
        // expected, return in error.
        //
        GlobalFreePtr(pIDFHeader);
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;
    }

    // Ascend out of the chunk.
    //
    mmioAscend(hmmio, &chkSub, 0);

    // Return success.
    //
    return pIDFHeader;
}

/***************************************************************************
  
   @doc internal
  
   @api LPIDFINSTCAPS | ReadCapsChunk | Read the instrument capabilty
    chunk from an IDF file. 

   @parm HMMIO | hmmio | Handle to the file to read from.

   @parm LPMMCKINFO | pchkParent | Pointer to a chunk information structure
    which describes the parent chunk.

   @comm
    Must already be descended into the parent chunk.

    This function will GlobalAlloc memory to read the chunk into.
    The caller must free it when he is done with it.

   @rdesc NULL on failure or a far pointer to the header structure.
       
***************************************************************************/
LPIDFINSTCAPS FNLOCAL ReadCapsChunk(
    HMMIO               hmmio,                               
    LPMMCKINFO          pchkParent)
{
    LPIDFINSTCAPS       lpIDFinstcaps;
    MMRESULT            mmr;
    MMCKINFO            chkSub;
    LONG                l;

    // We are looking for the instrument capabilities chunk.
    //
    chkSub.ckid = mmioFOURCC('c', 'a', 'p', 's');

    // Descend to the "caps" chunk in this list.
    //

    mmioSeek(hmmio, pchkParent->dwDataOffset + sizeof(FOURCC), SEEK_SET);
    mmr = mmioDescend(hmmio, &chkSub, pchkParent, MMIO_FINDCHUNK);
    if (MMSYSERR_NOERROR != mmr)
    {
        // Could not find the chunk.
        //
        return NULL;
    }

    // We found the "caps" chunk, now check it's size and
    // see if it is one that we can read.
    //
    if (sizeof(IDFINSTCAPS) != chkSub.cksize)
    {
        // The sizeof the IDF header is not what we expected.
        // 
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;
    }

    lpIDFinstcaps = (LPIDFINSTCAPS)GlobalAllocPtr(GHND, chkSub.cksize);
    if (NULL == lpIDFinstcaps)
    {
        // Could not allocate memory for chunk
        //
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;

    }

    // Read the instrument's capabilities from the file.
    //
    l = mmioRead(hmmio, (HPSTR)lpIDFinstcaps, sizeof(IDFINSTCAPS));
    if (sizeof(IDFINSTCAPS) != l)
    {
        // We didn't read in the amount of data that was
        // expected, return in error.
        //
        GlobalFreePtr(lpIDFinstcaps);
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;
    }

    // Ascend out of the capabilities chunk.
    //
    mmioAscend(hmmio, &chkSub, 0);
    return lpIDFinstcaps;
}

/***************************************************************************
  
   @doc internal
  
   @api LPIDFCHANHELHDR | ReadChannelChunk | Read the channel information 
    chunk from an IDF file. 

   @parm HMMIO | hmmio | Handle to the file to read from.

   @parm LPMMCKINFO | pchkParent | Pointer to a chunk information structure
    which describes the parent chunk.

   @parm LPIDFCHANNELINFO | rglpChanInfo[] | Array of pointers to receive
    the channel information. The pointers will be allocated by this
    function; any channel without a channel description in the IDF file
    will fill the corresponding slot with NULL.

   @comm
    Must already be descended into the parent chunk.

    This function will GlobalAlloc memory to read the chunk into.
    The caller must free it when he is done with it.

    Caller must free memory in array even if function fails.

   @rdesc TRUE on success; else FALSE
       
***************************************************************************/
LPIDFCHANNELHDR FNLOCAL ReadChannelChunk(
    HMMIO               hmmio,                                  
    LPMMCKINFO          pchkParent,
    LPIDFCHANNELINFO BSTACK rglpChanInfo[])
{
    MMRESULT            mmr;
    MMCKINFO            chkSub;
    DWORD               cbIDFchnlinfo;
    LPIDFCHANNELINFO    lpIDFchnlinfo;
    LPIDFCHANNELHDR     lpIDFchanhdr;
    DWORD               c;
    LONG                cbRemain;

    // Default return value
    //
    lpIDFchanhdr = NULL;

    // Nuke anything currently in the return struct
    //
    for (c = 0; c < MAX_CHANNELS; c++)
        rglpChanInfo[c] = NULL;

    // We are looking for the instrument channel definitions.
    //
    chkSub.ckid = mmioFOURCC('c', 'h', 'a', 'n');

    // Descend to the "chnl" chunk in this list.
    //
    
    mmioSeek(hmmio, pchkParent->dwDataOffset + sizeof(FOURCC), SEEK_SET);
    mmr = mmioDescend(hmmio, &chkSub, pchkParent, MMIO_FINDCHUNK);
    if (MMSYSERR_NOERROR != mmr)
    {
        // Could not find the chunk.
        //
        DPF(1, TEXT ("chnl chunk not found."));
        return NULL;
    }

    // We found the "chnl" chunk, now check it's size and
    // make sure it's at least as big as a IDFCHANNELHDR.
    //
    if (sizeof(IDFCHANNELHDR) > chkSub.cksize)
    {
        // The sizeof the IDF header is not what we expected.
        //
        DPF(1, TEXT ("Channel chunk too small"));
        goto Read_Channel_Chunk_Err;
    }

    if (NULL == (lpIDFchanhdr = (LPIDFCHANNELHDR)GlobalAllocPtr(GHND, chkSub.cksize)))
    {
        DPF(1, TEXT ("No memory for channel header"));
        goto Read_Channel_Chunk_Err;
    }

    // Read the channel header in.
    //
    cbRemain = mmioRead(hmmio, (HPSTR)lpIDFchanhdr, chkSub.cksize);
    if (chkSub.cksize != (DWORD)cbRemain)
    {
        // Couldn't read in all of the header.
        //
        DPF(1, TEXT ("Channel chunk header size lied"));
        GlobalFreePtr(lpIDFchanhdr);
        lpIDFchanhdr = NULL;
        goto Read_Channel_Chunk_Err;
    }

    cbRemain -= sizeof(*lpIDFchanhdr);
    lpIDFchnlinfo = (LPIDFCHANNELINFO)(lpIDFchanhdr+1);

    // Read all the channels that are defined in the IDF.
    //
    cbIDFchnlinfo = 0;
    while (cbRemain > 0)
    {
        if (lpIDFchnlinfo->cbStruct < sizeof(IDFCHANNELINFO) ||
            lpIDFchnlinfo->cbStruct > (DWORD)cbRemain)
        {
            DPF(1, TEXT ("Bogus cbStruct in channel info"));
            GlobalFreePtr(lpIDFchanhdr);
            lpIDFchanhdr = NULL;
            goto Read_Channel_Chunk_Err;
        }

        if (lpIDFchnlinfo->dwChannel >= MAX_CHANNELS)
        {
            DPF(1, TEXT ("Channel number out of range (Channel info corrupt?)"));
            GlobalFreePtr(lpIDFchanhdr);
            lpIDFchanhdr = NULL;
            goto Read_Channel_Chunk_Err;
        }
        
        rglpChanInfo[lpIDFchnlinfo->dwChannel] = lpIDFchnlinfo;

        ((LPBYTE)lpIDFchnlinfo) += lpIDFchnlinfo->cbStruct;
        cbRemain -= lpIDFchnlinfo->cbStruct;
    }

Read_Channel_Chunk_Err:

    mmioAscend(hmmio, &chkSub, 0);
    return lpIDFchanhdr;
}

/***************************************************************************
  
   @doc internal
  
   @api LPIDFPATCHMAPHDR | ReadPatchMapChunk | Read the patch map chunk
    from a IDF file. 

   @parm HMMIO | hmmio | Handle to the file to read from.

   @parm LPMMCKINFO | pchkParent | Pointer to a chunk information structure
    which describes the parent chunk.

   @comm
    Must already be descended into the parent chunk.

    This function will GlobalAlloc memory to read the chunk into.
    The caller must free it when he is done with it.

   @rdesc NULL on failure or a far pointer to the header structure.
       
***************************************************************************/
LPIDFPATCHMAPHDR FNLOCAL ReadPatchMapChunk(
    HMMIO               hmmio,                                          
    LPMMCKINFO          pchkParent)
{
    MMRESULT            mmr;
    MMCKINFO            chkSub;
    LONG                l;
    LPIDFPATCHMAPHDR    lpIDFpatchmaphdr;

    // We are looking for the patch map for the instrument.
    //
    chkSub.ckid = mmioFOURCC('p', 'm', 'a', 'p');

    // Descend to the "pmap" chunk in this list.
    //
    mmioSeek(hmmio, pchkParent->dwDataOffset + sizeof(FOURCC), SEEK_SET);
    mmr = mmioDescend(hmmio, &chkSub, pchkParent, MMIO_FINDCHUNK);
    if (MMSYSERR_NOERROR != mmr)
    {
        // Could not find the chunk.
        //
        return NULL;
    }

    // We found the "pmap" chunk, now check it's size and
    // make sure it's at least as big as a IDFPATCHMAPHDR.
    //
    if (sizeof(IDFPATCHMAPHDR) > chkSub.cksize)
    {
        // The sizeof the IDF header is not what we expected.
        // 
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;
    }

    lpIDFpatchmaphdr = (LPIDFPATCHMAPHDR)GlobalAllocPtr(GHND, chkSub.cksize);
    if (NULL == lpIDFpatchmaphdr)
    {
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;
    }

    // Read the channel header in.
    //
    l = mmioRead(hmmio, (HPSTR)lpIDFpatchmaphdr, sizeof(IDFPATCHMAPHDR));
    if (sizeof(IDFPATCHMAPHDR) != l)
    {
        // Couldn't read in all of the header.
        //
        mmioAscend(hmmio, &chkSub, 0);
        return NULL;
    }

    mmioAscend(hmmio, &chkSub, 0);

    // Return success.
    //
    return lpIDFpatchmaphdr;
}

PRIVATE void FNLOCAL ReadSingleKeyMap(
    HMMIO               hmmio,
    LPMMCKINFO          pchkParent,
    LPIDFKEYMAP BSTACK *pIDFkeymap,
    FOURCC              fccChunk)
{
    MMRESULT            mmr;
    MMCKINFO            chkSub;
    LONG                l;

    chkSub.ckid = fccChunk;
    *pIDFkeymap = NULL;

    mmioSeek(hmmio, pchkParent->dwDataOffset + sizeof(FOURCC), SEEK_SET);
    mmr = mmioDescend(hmmio, &chkSub, pchkParent, MMIO_FINDCHUNK);
    if (MMSYSERR_NOERROR == mmr)
    {
        DPF(1, TEXT ("Located key chunk"));

        if (sizeof(IDFKEYMAP) > chkSub.cksize)
        {
            DPF(1, TEXT ("key chunk is incomplete"));
            mmioAscend(hmmio, &chkSub, 0);
            return;
        }

        *pIDFkeymap = (LPIDFKEYMAP)GlobalAllocPtr(GHND, chkSub.cksize);
        if (NULL == *pIDFkeymap)
        {
            DPF(1, TEXT ("No memory for key chunk"));
            mmioAscend(hmmio, &chkSub, 0);
            return;
        }

        l = mmioRead(hmmio, 
                       (HPSTR)(*pIDFkeymap),
                       chkSub.cksize);
        
        if (chkSub.cksize != (DWORD)l)
        {
            DPF(1, TEXT ("Error reading key chunk"));
            mmioAscend(hmmio, &chkSub, 0);
            GlobalFreePtr(*pIDFkeymap);
            *pIDFkeymap = NULL;
        }
    }
}
                                      

/***************************************************************************
  
   @doc internal
  
   @api BOOL | ReadKeyMapChunk | Read the key map information 
    chunk from an IDF file. 

   @parm HMMIO | hmmio | Handle to the file to read from.

   @parm LPMMCKINFO | pchkParent | Pointer to a chunk information structure
    which describes the parent chunk.

   @parm LPIDFKEYMAP | rglpIDFkeymap[] | Array of pointers to receive
    the key map information. The pointers will be allocated by this
    function; any channel without a channel description in the IDF file
    will fill the corresponding slot with NULL.

   @comm
    Must already be descended into the parent chunk.

    This function will GlobalAlloc memory to read the chunk into.
    The caller must free it when he is done with it.

    Caller must free memory in array even if function fails.
    
   @rdesc TRUE on success; else FALSE
       
***************************************************************************/
void FNLOCAL ReadKeyMapChunk(
    HMMIO               hmmio,                                  
    LPMMCKINFO          pchkParent,
    LPIDFKEYMAP BSTACK  rglpIDFkeymap[])
{
    UINT                iKeyMap;
    
    // Initialize the in-memory key maps to default values before
    // we try reading anything. Default is a 1:1 nul mapping.
    //
    for (iKeyMap = 0; iKeyMap < MAX_CHAN_TYPES; iKeyMap++)
        rglpIDFkeymap[iKeyMap] = NULL;

    ReadSingleKeyMap(hmmio,
                     pchkParent,
                     &rglpIDFkeymap[IDX_CHAN_GEN],
                     mmioFOURCC('g', 'k', 'e', 'y'));
        
    ReadSingleKeyMap(hmmio,
                     pchkParent,
                     &rglpIDFkeymap[IDX_CHAN_DRUM],
                     mmioFOURCC('d', 'k', 'e', 'y'));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\locks.c ===
/**********************************************************************

  Copyright (c) 1992-1995 Microsoft Corporation

  locks.c

  DESCRIPTION:
    Code to lock each of the FIX'ed segments so they are only
    fixed when they need to be.

  HISTORY:
     03/03/94       [jimge]        created.

*********************************************************************/

#include "preclude.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "idf.h"

#include "midimap.h"
#include "debug.h"

// Lock/unlock routines for code segments are stored in that segment
// so we know the segment will be in memory when GlobalSmartPageLock
// is called (else it will fail).
//
#ifndef WIN32
   #pragma allocTEXT ext(TEXT EXT, LockMapperData)
   #pragma allocTEXT ext(TEXT EXT, UnlockMapperData)
   #pragma allocTEXT ext(MAPPACKED_FIX, LockPackedMapper)
   #pragma allocTEXT ext(MAPPACKED_FIX, UnlockPackedMapper)
   #pragma allocTEXT ext(MAPCOOKED_FIX, LockCookedMapper)
   #pragma allocTEXT ext(MAPCOOKED_FIX, UnlockCookedMapper)
#endif // End #ifndef WIN32


void FNGLOBAL LockMapperData(
    void)
{
    DPF(2, TEXT ("LockMapperData"));
    if (!GlobalSmartPageLock(__segname("_DATA")))
    {
        DPF(1, TEXT ("LockMapperData: GlobalSmartPageLock() failed!!!"));
    }
}

void FNGLOBAL UnlockMapperData(
    void)
{
    DPF(2, TEXT ("UnlockMapperData"));
    if (!GlobalSmartPageUnlock(__segname("_DATA")))
    {
        DPF(1, TEXT ("UnlockMapperData: GlobalSmartPageUnlock() failed!!!"));
    }
}

void FNGLOBAL LockPackedMapper(
    void)
{
    DPF(2, TEXT ("LockPackedMapper"));
    if (!GlobalSmartPageLock(__segname("MAPPACKED_FIX")))
    {
        DPF(1, TEXT ("LockPackedMapper: GlobalSmartPageLock() failed!!!"));
    }
}

void FNGLOBAL UnlockPackedMapper(
    void)
{
    DPF(2, TEXT ("UnlockPackedMapper"));
    if (!GlobalSmartPageUnlock(__segname("MAPPACKED_FIX")))
    {
        DPF(1, TEXT ("UnlockPackedMapper: GlobalSmartPageUnlock() failed!!!"));
    }
}

void FNGLOBAL LockCookedMapper(
    void)
{
    DPF(2, TEXT ("LockCookedMapper"));
    if (!GlobalSmartPageLock(__segname("MAPCOOKED_FIX")))
    {
        DPF(1, TEXT ("LockCookedMapper: GlobalSmartPageLock() failed!!!"));
    }
}

void FNGLOBAL UnlockCookedMapper(
    void)
{
    DPF(2, TEXT ("UnlockCookedMapper"));
    if (!GlobalSmartPageUnlock(__segname("MAPCOOKED_FIX")))
    {
        DPF(1, TEXT ("UnlockCookedMapper: GlobalSmartPageUnlock() failed!!!"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\libentry.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   LIBENTRY.ASM
;
;   Copyright (c) 1989-1995 Microsoft Corporation
;
;   This module contains the entry point for MidiMap.dll
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        PMODE = 1

        include cmacros.inc                   

?PLM=1  ; pascal call convention
?WIN=0  ; Windows prolog/epilog code

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   extrns
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        externFP LibMain
        externFP LocalInit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
sBegin  Data
assumes DS,Data

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
	__acrtused = 1

sEnd        Data

sBegin  CodeSeg
	assumes cs,CodeSeg
        assumes ds,Data
        assumes es,nothing

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       Library entry point
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used)
;
; Returns:
;       AX = TRUE if success
; Error Returns:
;       AX = FALSE if error (ie fail load process)
; Registers Preserved:
;	SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,ES,FLAGS
; Calls:
;	None
; History:
;
;       06-27-89 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
	;
        ; Push frame for LibMain (hModule,cbHeap,lpszCmdLine)
	;
	push	di
	push	cx
	push	es
	push	si

        ;
        ; Init the local heap (if one is declared in the .def file)
        ;
        jcxz no_heap

        xor     ax,ax
        cCall   LocalInit,<ax,ax,cx>

no_heap:
        cCall   LibMain
cEnd

	assumes ds,nothing
	assumes es,nothing

cProc   WEP, <FAR, PUBLIC, PASCAL>, <>
;	ParmW  fSystemExit
cBegin nogen
	mov	ax, 1
	retf	2
cEnd   nogen

        sEnd CodeSeg

        end LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\midimap.h ===
/**********************************************************************

    Copyright (c) 1992-1999 Microsoft Corporation

    midimap.h

    DESCRIPTION:
      Main private include file for the MIDI mapper.

*********************************************************************/

#ifndef _MIDIMAP_
#define _MIDIMAP_

//
// The following macro defines a CODE based pointer to data, which
// is used for constants that do not need to be placed in the read/write
// DATA segment.
//
#ifdef WIN32
#define __based(a)
#endif


#ifdef WIN32
   #define  BCODE
   #define  BSTACK
#else
   #define  BCODE                   __based(__segname("_CODE"))
   #define  BSTACK                  __based(__segname("_STACK"))
#endif

#include <mmsysp.h>

// Defines Win95 stuff not supported in NT 4.0
// Remove as soon as it is supported
#include "mmcompat.h"

//
// Macro definitions
//
#ifdef DEBUG
#define PRIVATE
#else
#define PRIVATE static
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof((a))/sizeof((a)[0]))
#endif

#define DEF_TRANS_SIZE	512

#define  DEF_CHAN_PER_INST          8   

#define  FNLOCAL                    NEAR PASCAL
#define  FNGLOBAL                   FAR PASCAL
//#define  FNEXPORT                   FAR PASCAL __export
#define  FNEXPORT                   FAR PASCAL 

#define  VERSION_MINOR              0x01
#define  VERSION_MAJOR              0x04
#define  MMAPPER_VERSION            ((DWORD)(WORD)((BYTE)VERSION_MINOR | (((WORD)(BYTE)VERSION_MAJOR) << 8)))

// Indices 3,4,5 into LPMIDIHDR->dwReserved[] are reserved for MIDI mapper
//
#define  MH_MAPINST                 3 // Mapper instance owning this header
#define  MH_SHADOW                  4 // Cross links between parent/child
#define  MH_SHADOWEE                4 //  shadow headers
#define  MH_LMREFCNT                5 // Long message reference count

#define  MAX_CHANNELS               16
#define  ALL_CHANNELS               (0xFFFF)    // Channel mask
#define  DRUM_CHANNEL               9
#define  MAX_CHAN_TYPES             2

#define  IDX_CHAN_GEN               0
#define  IDX_CHAN_DRUM              1

#define  CB_MAXDRIVER               64
#define  CB_MAXSCHEME               64
#define  CB_MAXINSTR                64
#define  CB_MAXALIAS                64
#define  CB_MAXDEVKEY               64
#define  CB_MAXPATH                 256
#define  CB_MAXDEFINITION           (256+64+2)  // file<instrument>

#define  NO_DEVICEID                ((UINT)-2)

#define  MSG_STATUS(dw)      ((BYTE)((dw) & 0xFF))
#define  MSG_PARM1(dw)       ((BYTE)(((dw) >> 8) & 0xFF))
#define  MSG_PARM2(dw)       ((BYTE)(((dw) >> 16) & 0xFF))

#define  MSG_PACK1(bs,b1)    ((DWORD)((((DWORD)(b1)) << 8) | ((DWORD)(bs))))
#define  MSG_PACK2(bs,b1,b2) ((DWORD)((((DWORD)(b2)) << 16) | (((DWORD)(b1)) << 8) | ((DWORD)(bs))))

#define  IS_REAL_TIME(b)    ((b) > 0xF7)
#define  IS_STATUS(b)       ((b) & 0x80)
#define  MSG_EVENT(b)       ((b) & 0xF0)
#define  MSG_CHAN(b)        ((b) & 0x0F)


#define  MIDI_NOTEOFF           ((BYTE)0x80)
#define  MIDI_NOTEON            ((BYTE)0x90)
#define  MIDI_POLYPRESSURE      ((BYTE)0xA0)
#define  MIDI_CONTROLCHANGE     ((BYTE)0xB0)
#define  MIDI_PROGRAMCHANGE     ((BYTE)0xC0)
#define  MIDI_CHANPRESSURE      ((BYTE)0xD0)
#define  MIDI_PITCHBEND         ((BYTE)0xE0)
#define  MIDI_SYSEX             ((BYTE)0xF0)
#define  MIDI_QFRAME			((BYTE)0xF1)
#define	 MIDI_SONGPOINTER		((BYTE)0xF2)
#define	 MIDI_SONGSELECT		((BYTE)0xF3)
#define	 MIDI_F4				((BYTE)0xF4)
#define	 MIDI_F5				((BYTE)0xF5)
#define	 MIDI_TUNEREQUEST		((BYTE)0xF6)
#define  MIDI_SYSEXEND          ((BYTE)0xF7)
#define  MIDI_TIMINGCLOCK       ((BYTE)0xF8)
#define  MIDI_F9				((BYTE)0xF9)
#define	 MIDI_START				((BYTE)0xFA)
#define	 MIDI_CONTINUE			((BYTE)0xFB)
#define	 MIDI_STOP				((BYTE)0xFC)
#define  MIDI_FD				((BYTE)0xFD)
#define  MIDI_ACTIVESENSING		((BYTE)0xFE)
#define  MIDI_META              ((BYTE)0xFF)

#define  DWORD_ROUND(x)         (((x)+3L)&~3L)

// Global flags in gwFlags
//
#define  GF_ENABLED             0x0001
#define  GF_CONFIGERR           0x0002
#define  GF_NEEDRUNONCE         0x0004
#define  GF_DONERUNONCE         0x0008
#define  GF_DEVSOPENED          0x0010
#define  GF_RECONFIGURE         0x0020
#define  GF_INRUNONCE           0x0040
#define  GF_ALLOWVOLUME         0x0080
#define  GF_ALLOWCACHE          0x0100
#define  GF_KILLTHREAD          0x0200

#define  SET_ENABLED            {gwFlags |= GF_ENABLED;}
#define  CLR_ENABLED            {gwFlags &=~GF_ENABLED;}
#define  IS_ENABLED             (gwFlags & GF_ENABLED)

#define  SET_CONFIGERR          {gwFlags |= GF_CONFIGERR;}
#define  CLR_CONFIGERR          {gwFlags &=~GF_CONFIGERR;}
#define  IS_CONFIGERR           (gwFlags & GF_CONFIGERR)

#define  SET_NEEDRUNONCE        {gwFlags |= GF_NEEDRUNONCE;}
#define  CLR_NEEDRUNONCE        {gwFlags &=~GF_NEEDRUNONCE;}
#define  IS_NEEDRUNONCE         (gwFlags & GF_NEEDRUNONCE)

#define  SET_DONERUNONCE        {gwFlags |= GF_DONERUNONCE;}
#define  CLR_DONERUNONCE        {gwFlags &=~GF_DONERUNONCE;}
#define  IS_DONERUNONCE         (gwFlags & GF_DONERUNONCE)

#define  SET_DEVSOPENED         {gwFlags |= GF_DEVSOPENED;}
#define  CLR_DEVSOPENED         {gwFlags &=~GF_DEVSOPENED;}
#define  IS_DEVSOPENED          (gwFlags & GF_DEVSOPENED) 

#define  SET_RECONFIGURE        {gwFlags |= GF_RECONFIGURE;}
#define  CLR_RECONFIGURE        {gwFlags &=~GF_RECONFIGURE;}
#define  IS_RECONFIGURE         (gwFlags & GF_RECONFIGURE)

#define  SET_INRUNONCE          {gwFlags |= GF_INRUNONCE;}
#define  CLR_INRUNONCE          {gwFlags &=~GF_INRUNONCE;}
#define  IS_INRUNONCE           (gwFlags & GF_INRUNONCE)

#define  SET_ALLOWVOLUME        {gwFlags |= GF_ALLOWVOLUME;}
#define  CLR_ALLOWVOLUME        {gwFlags &=~GF_ALLOWVOLUME;}
#define  IS_ALLOWVOLUME         (gwFlags & GF_ALLOWVOLUME)

#define  SET_ALLOWCACHE         {gwFlags |= GF_ALLOWCACHE;}
#define  CLR_ALLOWCACHE         {gwFlags &=~GF_ALLOWCACHE;}
#define  IS_ALLOWCACHE          (gwFlags & GF_ALLOWCACHE)

#define  SET_KILLTHREAD         {gwFlags |= GF_KILLTHREAD;}
#define  CLR_KILLTHREAD         {gwFlags &=~GF_KILLTHREAD;}
#define  IS_KILLTHREAD          (gwFlags & GF_KILLTHREAD)

//=========================== Typedef's=====================================
//

typedef struct tagQUEUE         NEAR *PQUEUE;
typedef struct tagQUEUEELE      NEAR *PQUEUEELE;
typedef struct tagCHANINIT      NEAR *PCHANINIT;
typedef struct tagCHANNEL       NEAR *PCHANNEL;
typedef struct tagPORT          NEAR *PPORT;
typedef struct tagINSTRUMENT    NEAR *PINSTRUMENT;
typedef struct tagINSTPORT      NEAR *PINSTPORT;
typedef struct tagINSTANCE      NEAR *PINSTANCE;
typedef struct tagCOOKSYNCOBJ   NEAR *PCOOKSYNCOBJ;

typedef struct tagQUEUE
{
    CRITICAL_SECTION cs;
    PQUEUEELE        pqeFront;
    PQUEUEELE        pqeRear;
    DWORD            cEle;
}   QUEUE;

#define QueueIsEmpty(q) (NULL == (q)->pqeFront)
#define QueueCount(q)   ((q)->cEle)

typedef struct tagQUEUEELE
{
    PQUEUEELE       pqePrev;
    PQUEUEELE       pqeNext;
    UINT            uPriority;
}   QUEUEELE;

typedef struct tagCHANINIT
{
    DWORD               cbInit;
    PBYTE               pbInit;
}   CHANINIT;

// Flags for this channel which indicate what type of channel it is
// and whether or not it's allocated.
//
#define CHAN_F_OPEN             (0x0001)
#define CHAN_F_ALLOCATED        (0x0002)
#define CHAN_F_DRUM             (0x0004)
#define CHAN_F_GENERAL          (0x0008)
#define CHAN_F_MUTED            (0x0010)

typedef struct tagCHANNEL
{
//    QUEUEELE            q;                  // !!! MUST BE FIRST !!!
    PPORT               pport;
    WORD                fwChannel;
    UINT                uChannel;           // This physical channel #
    PINSTRUMENT         pinstrument;        // -> IDF describing this channel
    PBYTE               pbPatchMap;         // In use patch map
    PBYTE               pbKeyMap;           // In use key map
    DWORD               dwStreamID;         // Stream ID if cooked
}   CHANNEL;

#define PORT_F_REMOVE            (0x0001)
#define PORT_F_HASDRUMCHANNEL    (0x0002)
#define PORT_F_OPENFAILED        (0x0004)
#define PORT_F_RESET             (0x0008)
#define PORT_F_GENERICINSTR      (0x0010)

typedef struct tagPORT
{
    PPORT               pNext;
    UINT                cRef;
    WORD                fwPort;
    WORD                wChannelMask;
    UINT                uDeviceID;
    HMIDIOUT            hmidi;
}   PORT;

#define IDF_F_GENERICINSTR      (0x80000000L)

typedef struct tagINSTRUMENT
{
    PINSTRUMENT         pNext;
    LPTSTR              pstrFilename;       // Filename of IDF
    LPTSTR              pstrInstrument;     // Instrument name from IDF
    UINT                cRef;               // # ports which are using this IDF
    DWORD               fdwInstrument;
    DWORD               dwGeneralMask;
    DWORD               dwDrumMask;
    PBYTE               pbPatchMap;         // -> 128 bytes of patch map
    PBYTE               pbDrumKeyMap;       // -> 128 bytes of key map
    PBYTE               pbGeneralKeyMap;    // -> 128 bytes of key map
    CHANINIT            rgChanInit[MAX_CHANNELS];
}   INSTRUMENT;

#define INST_F_TIMEDIV  (0x0001)            // Instance has received MIDIPROP_TIMEDIV
#define INST_F_TEMPO    (0x0002)            // Instance has received MIDIPROP_TEMPO
#define INST_F_IOCTL    (0x0004)            // IOCTL open

typedef struct tagINSTANCE
{
    PINSTANCE           pNext;

    // stuff we need to save so we can do callbacks
    //
    HMIDI               hmidi;              // MMSYSTEM's handle
    DWORD_PTR           dwCallback;         // Callback address
    DWORD_PTR           dwInstance;         // User instance data
    DWORD               fdwOpen;            // Describe the callback & open mode
    QUEUE               qCookedHdrs;        // Cooked headers pending to be sent
    WORD                fwInstance;         // Instance flags
    BYTE                bRunningStatus;     // Need to track running status

	// Translation Buffer
    CRITICAL_SECTION	csTrans;			// Critical Section for Translation buffer
	LPBYTE				pTranslate;			// Buffer For Translating MODM_LONGDATA messages
	DWORD				cbTransSize;		// Current Translation buffer size				
}   INSTANCE;

#if 0
typedef struct tagCOOKINSTANCE
{
    INSTANCE            inst;               // Common instance data
    UINT                cInstPort;          // # ports in use on instance
    INSTPORT            rginstport[MAX_CHANNELS];
    DWORD               dwTimeDiv;          // MIDIPROP_TIMEDIV
    DWORD               dwTempo;            // MIDIPROP_TEMPO
}   COOKINSTANCE;
#endif

typedef struct tagCOOKSYNCOBJ
{
    QUEUEELE            q;                  // !!! MUST BE FIRST !!!
    
    LPMIDIHDR           lpmh;               // First of our shadow headers
    LPMIDIHDR           lpmhUser;           // Original user header
    PINSTANCE           pinstance;          // Owning pinstance
    UINT                cLPMH;              // # allocated
    UINT                cSync;              // # outstanding
}   COOKSYNCOBJ;

typedef struct tagSHADOWBLOCK
{
    LPMIDIHDR           lpmhShadow;
    DWORD               cRefCnt;
    DWORD               dwBufferLength;
} SHADOWBLOCK, *PSHADOWBLOCK;


#define DRV_GETMAPPERSTATUS     (DRV_USER+3)
#define DRV_REGISTERDEBUGCB     (DRV_USER+4)
#define DRV_GETNEXTLOGENTRY     (DRV_USER+5)

typedef struct tagMAPPERSTATUS
{
    DWORD               cbStruct;
#ifndef WIN32
    __segment           DS;
#endif
    HINSTANCE           ghinst;
    WORD                gwFlags;
    WORD                gwConfigWhere;
    PCHANNEL*           pgapChannel;
    PPORT               gpportList;
    PINSTANCE           gpinstanceList;
    PINSTRUMENT         gpinstrumentList;
    LPTSTR              lpszVersion;
}   MAPPERSTATUS,
    FAR *LPMAPPERSTATUS;

//=========================== Globals ======================================
//
extern PCHANNEL                 gapChannel[];
extern WORD                     gwFlags;
extern WORD                     gwConfigWhere;
extern UINT                     gcPorts;

extern HINSTANCE                ghinst;        
extern PPORT                    gpportList;    
extern PINSTANCE                gpinstanceList;
extern PINSTANCE                gpIoctlInstance;
extern PINSTRUMENT              gpinstrumentList;
extern QUEUE                    gqFreeSyncObjs;
extern HMIDISTRM                ghMidiStrm;
extern DWORD                    gdwVolume;

//=========================== Prototypes ===================================
//

extern BOOL FNGLOBAL UpdateInstruments(     // config.c
    BOOL                fFromCPL,
    DWORD               fdwUpdate);

extern BOOL FNGLOBAL Configure(             // config.c
    DWORD               fdwUpdate);

extern BOOL FNLOCAL AddPort(                // config.c
    UINT                uDeviceID,
    UINT                uPorts,
    PSTR                szSysIniEntry);

extern void FNGLOBAL SyncDeviceIDs(         // config.c
    void);

extern LPIDFHEADER FNLOCAL ReadHeaderChunk( // file.c
    HMMIO               hmmio,
    LPMMCKINFO          pchkParent);

extern LPIDFINSTCAPS FNLOCAL ReadCapsChunk( // file.c
    HMMIO               hmmio,                               
    LPMMCKINFO          pchkParent);

extern LPIDFCHANNELHDR FNLOCAL ReadChannelChunk( // file.c
    HMMIO               hmmio,                                  
    LPMMCKINFO          pchkParent,
    LPIDFCHANNELINFO BSTACK rglpChanInfo[]);

extern LPIDFPATCHMAPHDR FNLOCAL ReadPatchMapChunk( // file.c
    HMMIO               hmmio,                                          
    LPMMCKINFO          pchkParent);

extern void FNLOCAL ReadKeyMapChunk(        // file.c
    HMMIO               hmmio,                                  
    LPMMCKINFO          pchkParent,
    LPIDFKEYMAP BSTACK  rglpIDFkeymap[]);

extern void CALLBACK _loadds modmCallback(  // modfix.c
    HMIDIOUT            hmo,
    WORD                wmsg,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2);                                  

#define MSE_F_SENDEVENT     (0x0000L)
#define MSE_F_RETURNEVENT   (0x0001L)

extern DWORD FNGLOBAL MapSingleEvent(       // modfix.c
    PINSTANCE           pinstance,
    DWORD               dwData,
    DWORD               fdwFlags,
    DWORD BSTACK *      pdwStreamID);

extern DWORD FNLOCAL modLongMsg(            // modfix.c
    PINSTANCE           pinstance,                                
    LPMIDIHDR           lpmh);                                

extern MMRESULT FNGLOBAL MapCookedBuffer(   // cookmap.c
    PINSTANCE           pinstance,
    LPMIDIHDR           lpmh);

extern DWORD FNGLOBAL modGetDevCaps(        // modmsg.c
    LPMIDIOUTCAPS       pmoc,
    DWORD               cbmoc);

extern DWORD FNGLOBAL modOpen(              // modmsg.c
    PDWORD_PTR          lpdwInstance,
    LPMIDIOPENDESC      lpmidiopendesc,
    DWORD               fdwOpen);

extern BOOL FNGLOBAL CanChannelBeDrum(      // modmsg.c
    PQUEUEELE           pqe);

extern DWORD FNGLOBAL modClose(             // modmsg.c
    PINSTANCE           pinstance);

extern DWORD FNGLOBAL modPrepare(
    LPMIDIHDR           lpmh);              // modmsg.c

extern DWORD FNGLOBAL modUnprepare(         // modmsg.c
    LPMIDIHDR           lpmh);

extern DWORD FNGLOBAL modGetPosition(       // modmsg.c
    PINSTANCE           pinstance,
    LPMMTIME            lpmmt,
    DWORD               cbmmt);

extern DWORD FNGLOBAL modSetVolume(         // modmsg.c
    DWORD               dwVolume);

extern void FNGLOBAL QueueInit(             // queue.c
    PQUEUE              pq);

extern void FNGLOBAL QueueCleanup(          // queue.c
    PQUEUE              pq);

extern void FNGLOBAL QueuePut(              // queue.c
    PQUEUE              pq,
    PQUEUEELE           pqe,
    UINT                uPriority);

extern PQUEUEELE FNGLOBAL QueueGet(         // queue.c
    PQUEUE              pq);

extern BOOL FNGLOBAL QueueRemove(           // queue.c
    PQUEUE              pq, 
    PQUEUEELE           pqe);

typedef BOOL (FNGLOBAL *FNFILTER)(PQUEUEELE);

extern PQUEUEELE FNGLOBAL QueueGetFilter(   // queue.c
    PQUEUE              pq,
    FNFILTER            fnf);

extern void FNGLOBAL LockMapperData(        // locks.c
    void);

extern void FNGLOBAL UnlockMapperData(      // locks.c
    void);

extern void FNGLOBAL LockPackedMapper(      // locks.c
    void);

extern void FNGLOBAL UnlockPackedMapper(    // locks.c
    void);

extern void FNGLOBAL LockCookedMapper(      // locks.c
    void);

extern void FNGLOBAL UnlockCookedMapper(    // locks.c
    void);

extern void FNGLOBAL mdev_Free(             // mididev.c
    void);                           

extern BOOL FNGLOBAL mdev_Init(             // mididev.c
    void);

UINT FNGLOBAL mdev_GetDeviceID(             // mididev.c
    LPTSTR                   pszAlias);

BOOL FNGLOBAL mdev_GetAlias(                // mididev.c
    UINT                    uDeviceID,
    LPTSTR                  pszBuffer,
    UINT                    cchSize);

BOOL FNGLOBAL mdev_NewDrivers(              // mididev.c
    void);                              

	// Translation buffer stuff for MODM_LONGDATA
BOOL FNGLOBAL InitTransBuffer (PINSTANCE pinstance);
BOOL FNGLOBAL CleanupTransBuffer (PINSTANCE pinstance);
LPBYTE FNGLOBAL AccessTransBuffer (PINSTANCE pinstance);
void FNGLOBAL ReleaseTransBuffer (PINSTANCE pinstance);
BOOL FNGLOBAL GrowTransBuffer (PINSTANCE pinstance, DWORD cbNewSize);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\mididev.c ===
/**********************************************************************

  Copyright (c) 1992-1999 Microsoft Corporation

  mididev.c

  DESCRIPTION:
    Code to match device ID's with associated registry entries

  HISTORY:
     02/24/95       [jimge]        created.

*********************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <winerror.h>
#include <regstr.h>
#include <mmsystem.h>
#include <mmddkp.h>

#include "idf.h"
#include "midimap.h"
#include "debug.h"

typedef struct tagMDEV_NODE *PMDEV_NODE;
typedef struct tagMDEV_NODE
{
    PMDEV_NODE              pNext;
    TCHAR                   szAlias[CB_MAXALIAS];
    DWORD                   dwDevNode;
    TCHAR                   szDriver[CB_MAXDRIVER];
    UINT                    uDeviceID;
    UINT                    uPort;
    BOOL                    fNewDriver;
} MDEV_NODE;

static TCHAR BCODE gszMediaRsrcKey[] =
    REGSTR_PATH_MEDIARESOURCES TEXT ("\\MIDI");

static TCHAR BCODE gszDriverKey[] =
    REGSTR_PATH_MEDIARESOURCES TEXT ("\\MIDI\\%s");

static TCHAR BCODE gszDriverValue[]          = TEXT ("Driver");
static TCHAR BCODE gszDevNodeValue[]         = TEXT ("DevNode");
static TCHAR BCODE gszPortValue[]            = TEXT ("Port");
static TCHAR BCODE gszActiveValue[]          = TEXT ("Active");
static TCHAR BCODE gszMapperConfig[]         = TEXT ("MapperConfig");

static PMDEV_NODE gpMDevList                = NULL;
static DWORD gdwNewDrivers                  = (DWORD)-1L;

PRIVATE BOOL FNLOCAL mdev_BuildRegList(
    void);

PRIVATE BOOL FNLOCAL mdev_SyncDeviceIDs(
    void);

PRIVATE BOOL FNLOCAL mdev_MarkActiveDrivers(
    void);

#ifdef DEBUG
PRIVATE VOID FNLOCAL mdev_ListActiveDrivers(
    void);                                         
#endif

BOOL FNGLOBAL mdev_Init(
    void)
{
    if (gpMDevList)
        mdev_Free();

    if ((!mdev_BuildRegList()) ||
        (!mdev_SyncDeviceIDs()) ||
        (!mdev_MarkActiveDrivers()))
    {
        mdev_Free();
        return FALSE;
    }
    
#ifdef DEBUG
    mdev_ListActiveDrivers();
#endif
    
    return TRUE;
}

//
// mdev_BuildRegList
//
// Builds the base device list out of the registry
//
// Assumes the list has been cleared
//
// For each alias (key) under MediaResources\MIDI
//  Make sure the Active value exists and is '1'
//  Allocate a list node
//  Try to read the alias's devnode
//  If the alias's devnode is 0 or missing,
//   Read the alias's driver name
//  Read the alias's port number
//  Add the alias to the global list
//
// The uDeviceID member will not be initialized by this routine;
// mdev_SyncDeviceIDs must be called to figure out the current
// device ID mapping.
//
PRIVATE BOOL FNLOCAL mdev_BuildRegList(
    void)
{
    BOOL                    fRet            = FALSE;
    HKEY                    hKeyMediaRsrc   = NULL;
    HKEY                    hKeyThisAlias   = NULL;
    DWORD                   dwEnumAlias     = 0;
    LPTSTR                  pstrAlias       = NULL;
    PMDEV_NODE              pmd             = NULL;
    TCHAR                   szActive[2];
    DWORD                   dwPort;
    DWORD                   cbValue;
    DWORD                   dwType;
    DWORD                   dwMapperConfig;
    
	cbValue = CB_MAXALIAS * sizeof(TCHAR);
    pstrAlias = (LPTSTR)LocalAlloc(LPTR, CB_MAXALIAS * sizeof(TCHAR));
    if (NULL == pstrAlias)
    {
        DPF(1, TEXT ("mdev_Init: Out of memory"));
        goto mBRL_Cleanup;
    }

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
                                    gszMediaRsrcKey,
                                    &hKeyMediaRsrc))
    {
        DPF(1, TEXT ("mdev_Init: Could not open ...\\MediaResoruces\\MIDI"));
        goto mBRL_Cleanup;
    }

    
    while (ERROR_SUCCESS == RegEnumKey(hKeyMediaRsrc,
                                       dwEnumAlias++,
                                       pstrAlias,
                                       CB_MAXALIAS))
    {
        if (ERROR_SUCCESS != (RegOpenKey(hKeyMediaRsrc,
                                         pstrAlias,
                                         &hKeyThisAlias)))
        {
            DPF(1, TEXT ("mdev_Init: Could not open enum'ed key %s"), (LPTSTR)pstrAlias);
            continue;
        }

        // MUST have Active == "1" to be running
        //
        cbValue = sizeof(szActive);
        if (ERROR_SUCCESS != (RegQueryValueEx(hKeyThisAlias,
                                              gszActiveValue,
                                              NULL,
                                              &dwType,
                                              (LPSTR)szActive,
                                              &cbValue)) ||
            *szActive != '1')
        {
            DPF(2, TEXT ("mdev_Init: Device %s exists but is not loaded."),
                (LPTSTR)pstrAlias);
            RegCloseKey(hKeyThisAlias);
            continue;
        }

        // Determine if we have ever configured with this driver before
        //
        cbValue = sizeof(dwMapperConfig);
        if (ERROR_SUCCESS != (RegQueryValueEx(hKeyThisAlias,
                                              gszMapperConfig,
                                              NULL,
                                              &dwType,
                                              (LPSTR)&dwMapperConfig,
                                              &cbValue)))
            dwMapperConfig = 0;

#ifdef DEBUG
        if (!dwMapperConfig)
            DPF(1, TEXT ("Alias '%s' is a new driver."),
                (LPTSTR)pstrAlias);
#endif

        // We have a running driver, go ahead and alloc a node
        // for it
        //
        pmd = (PMDEV_NODE)LocalAlloc(LPTR, sizeof(*pmd));
        if (NULL == pmd)
        {
            DPF(1, TEXT ("mdev_Init: Out of memory allocating node for %s"),
                (LPTSTR)pstrAlias);
            RegCloseKey(hKeyThisAlias);
            continue;
        }

        lstrcpyn(pmd->szAlias, pstrAlias, sizeof(pmd->szAlias) - 1);
        pmd->szAlias[sizeof(pmd->szAlias) - 1] = '\0';

        pmd->fNewDriver = (dwMapperConfig ? FALSE : TRUE);

        // Try to get the DevNode value
        //
        cbValue = sizeof(pmd->dwDevNode);
        if (ERROR_SUCCESS != RegQueryValueEx(hKeyThisAlias,
                                             gszDevNodeValue,
                                             NULL,
                                             &dwType,
                                             (LPSTR)(LPDWORD)&pmd->dwDevNode,
                                             &cbValue))
        {
            // Ok to not have a devnode value, 3.1 drivers don't
            //

            DPF(2, TEXT ("mdev_Init: Device %s has no devnode; must be 3.1"),
                (LPTSTR)pstrAlias);
            pmd->dwDevNode = 0;
        }

        // Leave something reasonable in driver even if we don't
        // expect to use it
        //
        *pmd->szDriver = '\0';

        // If we didn't get a devnode or it was 0, and we can't find the
        // driver name to match against, we can't use this entry. (If it
        // has no ring 3 driver, it can't be running anyway).
        //
        if (!pmd->dwDevNode)
        {
            cbValue = sizeof(pmd->szDriver);
            if (ERROR_SUCCESS != RegQueryValueEx(
                hKeyThisAlias,
                gszDriverValue,
                NULL,
                &dwType,
                (LPSTR)pmd->szDriver,
                &cbValue))
            {
                DPF(1, TEXT ("mdev_Init: Device %s has no ring 3 driver entry"),
                    (LPTSTR)pstrAlias);
                LocalFree((HLOCAL)pmd);
                RegCloseKey(hKeyThisAlias);
                continue;
            }
        }

        // Success! Now try to figure out the port number
        //
        cbValue = sizeof(dwPort);

        // Guard against INF's which only specify a byte's worth of
        // port value
        //
        dwPort = 0;
        if (ERROR_SUCCESS != RegQueryValueEx(hKeyThisAlias,
                                             gszPortValue,
                                             NULL,
                                             &dwType,
                                             (LPSTR)(LPDWORD)&dwPort,
                                             &cbValue))
        {
            DPF(2, TEXT ("mdev_Init: Device %s has no port entry; using 0."),
                (LPTSTR)pstrAlias);
            dwPort = 0;
        }

        pmd->uPort = (UINT)dwPort;

        // We have a valid node, put it into the list
        //
        pmd->pNext = gpMDevList;
        gpMDevList = pmd;

        RegCloseKey(hKeyThisAlias);
    }

    fRet = TRUE;

mBRL_Cleanup:


    if (hKeyMediaRsrc)      RegCloseKey(hKeyMediaRsrc);
    if (pstrAlias)          LocalFree((HLOCAL)pstrAlias);

    return fRet;
}

//
// mdev_SyncDeviceIDs
//
// Traverse the device list and bring the uDeviceID members up to date.
// Also remove any devices which MMSYSTEM claims are not really running.
//
// NOTE: The uDeviceID member is actually the device ID of the base driver.
// If you want to open the device, you have to add uDeviceID and uPort for
// the node you want to open.
//
// Set all uDeviceID's to NO_DEVICEID
// 
// For each base device ID in MMSYSTEM (i.e. port 0 on each loaded driver)
//  Get the matching alias from MMSYSTEM
//  Locate the node with that alias in the device list
//  Set that node's uDeviceID
//
// For each node in the device list with non-zero port
//  If this node has a DevNode
//   Find a matching node by DevNode with port == 0 and get its device ID
//  else
//   Find a matching node by driver name with port == 0 and get its device ID
//
// NOTE: We match by driver name on DevNode == 0 (3.1 devices) because it
// isn't possible to have multiple instances of a 3.1 driver loaded.
//
// For each node in the device list,
//  If the node's uDeviceID is still not set,
//   Remove and free the node
//
PRIVATE BOOL FNLOCAL mdev_SyncDeviceIDs(
    void)
{
    BOOL                    fRet            = FALSE;
    LPTSTR                  pstrAlias       = NULL;
    
    PMDEV_NODE              pmdCurr;
    PMDEV_NODE              pmdPrev;
    PMDEV_NODE              pmdEnum;
    UINT                    cDev;
    UINT                    idxDev;
    DWORD                   cPort;
    MMRESULT                mmr;
	DWORD					cbSize;

	cbSize = CB_MAXALIAS * sizeof(TCHAR);
    pstrAlias = (LPTSTR)LocalAlloc(LPTR, cbSize);
    if (NULL == pstrAlias)
    {
        goto mSDI_Cleanup;
    }
    
    // The device list has been built and the uPort member is valid.
    // Now update the uDeviceID field to be proper. First, walk the list
    // and set them all to NO_DEVICEID.

    for (pmdCurr = gpMDevList; pmdCurr; pmdCurr = pmdCurr->pNext)
        pmdCurr->uDeviceID = NO_DEVICEID;

    // Now walk MMSYSTEM's list of loaded drivers and fill in all the port 0
    // nodes with their proper device ID
    //

    cDev = midiOutGetNumDevs();

    for (idxDev = 0; idxDev < cDev; )
    {
        mmr = (MMRESULT)midiOutMessage((HMIDIOUT)(UINT_PTR)idxDev,
#ifdef WINNT
				       DRV_QUERYNUMPORTS,
#else
                                       MODM_GETNUMDEVS,
#endif // End WINNT
                                       (DWORD_PTR)(LPDWORD)&cPort,
                                       0);
        if (mmr)
        {
            DPF(1, TEXT ("mdev_Sync: Device ID %u returned %u for MODM_GETNUMDEVS"),
                (UINT)idxDev,
                (UINT)mmr);
            
            ++idxDev;
            continue;
        }

        mmr = (MMRESULT)midiOutMessage((HMIDIOUT)(UINT_PTR)idxDev,
                                       DRV_QUERYDRVENTRY,
#ifdef WINNT
                                       (DWORD_PTR)(LPTSTR)pstrAlias,
#else
                                       (DWORD_PTR)(LPTSTR)pstrPath,
#endif // End Winnt

                                       CB_MAXALIAS);

        if (!mmr)
        {
            for (pmdCurr = gpMDevList; pmdCurr; pmdCurr = pmdCurr->pNext)
			{
                if ((0 == pmdCurr->uPort) &&
                    (! lstrcmpi(pstrAlias, pmdCurr->szAlias)))
                {
                    pmdCurr->uDeviceID = idxDev;
                    break;
                }
			}

#ifdef DEBUG
            if (!pmdCurr)
            {
                DPF(1, TEXT ("mdev_Sync: Device ID %u not found in device list."),
                    (UINT)idxDev);
            }
#endif
        }
        else
        {
            DPF(1, TEXT ("mdev_Sync: Device ID %u returned %u for DRV_QUERYDRVENTRY"),
                (UINT)idxDev,
                (UINT)mmr);
        }

        idxDev += (UINT)cPort;
    }

    // Now walk the list again. This time we catch all the non-zero ports
    // and set their uDeviceID properly.
    //
    for (pmdCurr = gpMDevList; pmdCurr; pmdCurr = pmdCurr->pNext)
    {
        if (!pmdCurr->uPort)
            continue;

        if (pmdCurr->dwDevNode)
        {
            for (pmdEnum = gpMDevList; pmdEnum; pmdEnum = pmdEnum->pNext)
                if (0 == pmdEnum->uPort &&
                    pmdEnum->dwDevNode == pmdCurr->dwDevNode)
                {
                    pmdCurr->uDeviceID = pmdEnum->uDeviceID;
                    break;
                }
        }
        else
        {
            for (pmdEnum = gpMDevList; pmdEnum; pmdEnum = pmdEnum->pNext)
                if (0 == pmdEnum->uPort &&
                    !lstrcmpi(pmdEnum->szDriver, pmdCurr->szDriver))
                {
                    pmdCurr->uDeviceID = pmdEnum->uDeviceID;
                    break;
                }
        }

#ifdef DEBUG
        if (!pmdEnum)
        {
            DPF(1, TEXT ("mdev_Sync: No parent driver found for %s"),
                (LPTSTR)pmdCurr->szAlias);
        }
#endif
    }

    // Now we walk the list one more time and discard anyone without a device
    // ID assigned.
    //

    pmdPrev = NULL;
    pmdCurr = gpMDevList;

    while (pmdCurr)
    {
        if (NO_DEVICEID == pmdCurr->uDeviceID)
        {
            DPF(1, TEXT ("mdev_Sync: Removing %s; never found a device ID"),
                (LPTSTR)pmdCurr->szAlias);
            
            if (pmdPrev)
                pmdPrev->pNext = pmdCurr->pNext;
            else
                gpMDevList = pmdCurr->pNext;

            LocalFree((HLOCAL)pmdCurr);

            pmdCurr = (pmdPrev ? pmdPrev->pNext : gpMDevList);
        }
        else
        {
            pmdPrev = pmdCurr;
            pmdCurr = pmdCurr->pNext;
        }
    }

    fRet = TRUE;

mSDI_Cleanup:
    if (pstrAlias)          LocalFree((HLOCAL)pstrAlias);

    return fRet;
}

//
// mdev_MarkActiveDrivers
//
// Mark drivers which are loaded and have not been seen before by
// mapper configuration as seen. Also flag that we want to run
// RunOnce if there are any of these
//
PRIVATE BOOL FNLOCAL mdev_MarkActiveDrivers(
    void)
{
    BOOL                    fRet            = FALSE;
    HKEY                    hKeyMediaRsrc   = NULL;
    HKEY                    hKeyThisAlias   = NULL;

    DWORD                   dwMapperConfig;
    PMDEV_NODE              pmd;

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
                                    gszMediaRsrcKey,
                                    &hKeyMediaRsrc))
    {
        DPF(1, TEXT ("mdev_MarkActiveDrivers: Could not open ")
               TEXT ("...\\MediaResources\\MIDI"));
        goto mMAD_Cleanup;
    }

    gdwNewDrivers = 0;
    for (pmd = gpMDevList; pmd; pmd = pmd->pNext)
        if (pmd->fNewDriver)
        {
            ++gdwNewDrivers;

            // Mark this driver as seen
            //
            if (ERROR_SUCCESS != (RegOpenKey(hKeyMediaRsrc,
                                             pmd->szAlias,
                                             &hKeyThisAlias)))
            {
                DPF(1, TEXT ("mdev_MarkActiveDrivers: Could not open alias '%s'"),
                    (LPTSTR)pmd->szAlias);
                goto mMAD_Cleanup;
            }

            dwMapperConfig = 1;
            RegSetValueEx(hKeyThisAlias,
                          gszMapperConfig,
                          0,
                          REG_DWORD,
                          (LPSTR)&dwMapperConfig,
                          sizeof(dwMapperConfig));

            RegCloseKey(hKeyThisAlias);
        }

    fRet = TRUE;
    
mMAD_Cleanup:

    if (hKeyMediaRsrc)      RegCloseKey(hKeyMediaRsrc);

    return fRet;
}

//
// mdev_ListActiveDrivers
//
// List the currently loaded drivers to debug output
//
#ifdef DEBUG
PRIVATE VOID FNLOCAL mdev_ListActiveDrivers(
    void)
{
    PMDEV_NODE              pmd;
    static TCHAR BCODE       szNo[]  = TEXT ("No");
    static TCHAR BCODE       szYes[] = TEXT ("Yes");

    DPF(2, TEXT ("=== mdev_ListActiveDrivers start ==="));
    for (pmd = gpMDevList; pmd; pmd = pmd->pNext)
    {
        DPF(2, TEXT ("Alias %-31.31s  Driver %-31.31s"),
            (LPTSTR)pmd->szAlias,
            (LPTSTR)pmd->szDriver);
        DPF(2, TEXT ("      dwDevNode %08lX uDeviceID %u uPort %u fNewDriver %s"),
            pmd->dwDevNode,
            pmd->uDeviceID,
            pmd->uPort,
            (LPTSTR)(pmd->fNewDriver ? szYes : szNo));
    }
    DPF(2, TEXT ("=== mdev_ListActiveDrivers end   ==="));
}
#endif

//
// mdev_Free
//
// Discard the current device list
//
void FNGLOBAL mdev_Free(
    void)
{
    PMDEV_NODE              pmdNext;
    PMDEV_NODE              pmdCurr;

    pmdCurr = gpMDevList;
    
    while (pmdCurr)
    {
        pmdNext = pmdCurr->pNext;

        LocalFree((HLOCAL)pmdCurr);
        pmdCurr = pmdNext;
    }

    gpMDevList = NULL;

    gdwNewDrivers = (DWORD)-1L;
}

//
// mdev_GetDeviceID
//
// Get the current device ID for the given alias.
//
UINT FNGLOBAL mdev_GetDeviceID(
    LPTSTR                   lpstrAlias)
{
    PMDEV_NODE              pmd;

    for (pmd = gpMDevList; pmd; pmd = pmd->pNext)
        if (!lstrcmpi(pmd->szAlias, lpstrAlias))
            return pmd->uDeviceID + pmd->uPort;

    DPF(1, TEXT ("mdev_GetDeviceID: Failed for %s"), lpstrAlias);
    return NO_DEVICEID;
}

//
// mdev_GetAlias
//
// Get the registry alias for the requested device ID
//
BOOL FNGLOBAL mdev_GetAlias(
    UINT                    uDeviceID,
    LPTSTR                  lpstrBuffer,
    UINT                    cbBuffer)
{
    PMDEV_NODE              pmd;

    for (pmd = gpMDevList; pmd; pmd = pmd->pNext)
        if (uDeviceID == (pmd->uDeviceID + pmd->uPort))
        {
            lstrcpyn(lpstrBuffer, pmd->szAlias, cbBuffer);
            return TRUE;
        }

    DPF(1, TEXT ("mdev_GetAlias: Failed for device ID %u"), uDeviceID);
    return FALSE;
}

//
// mdev_NewDrivers
//
// Returns TRUE if there were new drivers in the registry that we've never
// encountered before
//
BOOL FNGLOBAL mdev_NewDrivers(
    void)
{
    if (gdwNewDrivers == (DWORD)-1L)
    {
        DPF(0, TEXT ("mdevNewDrivers() called before mdev_Init()!"));
        return FALSE;
    }

    return (BOOL)(gdwNewDrivers != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\mmcompat.h ===
/**********************************************************************

    Copyright (c) 1992-1998 Microsoft Corporation

    mmcompat.h

    DESCRIPTION:
      Win95 Multimedia definitions, structures, and functions
      not currently supported in NT 4.0

*********************************************************************/

#ifndef _MMCOMPAT_
#define _MMCOMPAT_


#define __segname(a)
#define GlobalSmartPageLock(a) (TRUE)
#define GlobalSmartPageUnlock(a) (TRUE)
#define wmmMIDIRunOnce()


//
// Note:  Temporary definitions, please remove when mmddk.h
// have been updated to new standard !!!
//

// Should be defined in <mmddk.h>

#ifndef DRV_F_ADD
   #define DRV_F_ADD             0x00000000L
#endif

#ifndef DRV_F_REMOVE
   #define DRV_F_REMOVE          0x00000001L
#endif

#ifndef DRV_F_CHANGE
   #define DRV_F_CHANGE          0x00000002L
#endif

#ifndef DRV_F_PROP_INSTR
   #define DRV_F_PROP_INSTR      0x00000004L
#endif

#ifndef DRV_F_NEWDEFAULTS
   #define DRV_F_NEWDEFAULTS     0x00000008L
#endif

#ifndef DRV_F_PARAM_IS_DEVNODE
   #define DRV_F_PARAM_IS_DEVNODE   0x10000000L
#endif

#endif // end #ifndef _MMCOMPAT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\modfix.c ===
/**********************************************************************

  Copyright (c) 1992-1999 Microsoft Corporation

  modfix.c

  DESCRIPTION:
    Fixed code for doing output mapping. KEEP THE SIZE OF THIS CODE
    TO A MINIMUM!

  HISTORY:
     02/22/94       [jimge]        created.

*********************************************************************/
#pragma warning(disable:4704)

#include "preclude.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "idf.h"

#include "midimap.h"
#include "debug.h"

extern HANDLE hMutexRefCnt; // Located in DRVPROC.C
extern HANDLE hMutexConfig; // Located in DRVPROC.C

#define MSG_UNKNOWN 0
#define MSG_SHORT	1
#define MSG_LONG	2

INT FNLOCAL MapEvent (
	BYTE  * pStatus,
	DWORD	dwBuffSize,
	DWORD * pSkipBytes,
	DWORD * pShortMsg);

DWORD FNLOCAL modMapLongMsg (
	PINSTANCE pinstance,
    LPMIDIHDR lpmh);

/***************************************************************************

   @doc internal

   @api int | modMessage | Exported entry point for MIDI out messages.
    This function conforms to the definition in the MM DDK.

   @parm UINT | uid | Device ID within driver to open. For mapper, this
    should always be zero.

   @parm UINT | umsg | Message to process. This should be one of the
    #define'd MODM_xxx messages.

   @parm DWORD | dwUser | Points to a DWORD where the driver (us) can
    save instance data. This will store the near pointer to our
    instance. On every other message, this will contain the instance
    data.

   @parm DWORD | dwParam1 | Message specific parameters.

   @parm DWORD | dwParam2 | Message specific parameters.

   @comm This function MUST be in a fixed segment since short messages
    are allowed to be sent at interrupt time.

   @rdesc | MMSYSERR_xxx.

***************************************************************************/
DWORD FNEXPORT modMessage(
    UINT                uid,
    UINT                umsg,
    DWORD_PTR           dwUser,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2)
{
    BYTE                bs;
    PINSTANCE           pinstance;
//    UINT                uDeviceID;
    PPORT               pport;
    MMRESULT            mmrc;
    MMRESULT            mmrc2;
	DWORD				dwResult;

    if (0 != uid)
    {
        DPF(1, TEXT ("Mapper called with non-zero uid!"));
        return MMSYSERR_BADDEVICEID;
    }

    pinstance = (PINSTANCE)(UINT_PTR)(dwUser);

    switch(umsg)
    {
        case MODM_GETDEVCAPS:
            return modGetDevCaps((LPMIDIOUTCAPS)dwParam1,
                                 (DWORD)dwParam2);

        case MODM_OPEN:
            return modOpen((PDWORD_PTR)dwUser,
                           (LPMIDIOPENDESC)dwParam1,
                           (DWORD)dwParam2);

        case MODM_CLOSE:
            return modClose((PINSTANCE)dwUser);

        case MODM_DATA:
            assert(NULL != pinstance);

            // In cooked mode, don't allow non-status short messages.
            // Otherwise (packed mode) maintain running status.
            //
            // TESTTEST -- Make sure running status works properly in
            // MIDI_IO_PACKED - essential for backwards compatibility!!!
            //
            bs = MSG_STATUS(dwParam1);
            if (pinstance->fdwOpen & MIDI_IO_COOKED)
            {
                bs = MSG_STATUS(dwParam1);
                if (!IS_STATUS(bs))
                {
                    DPF(1, TEXT ("Non-status short msg while opened in MIDI_IO_COOKED!"));
                    return MMSYSERR_INVALPARAM;
                }
            }
            else
            {
                // Track running status
                //
                if (IS_STATUS(bs))
                {
                    // Do not use real-time messages as the status 
                    // byte of the next message.
                    if (!IS_REAL_TIME(bs))
                    {
                        pinstance->bRunningStatus = bs;
                    }
                }
                else
                    dwParam1 = (dwParam1 << 8) | (pinstance->bRunningStatus);
            }

            return MapSingleEvent((PINSTANCE)dwUser,
                                  (DWORD)dwParam1,
                                  MSE_F_SENDEVENT,
                                  NULL);

        case MODM_LONGDATA:
            assert(NULL != pinstance);

//            return modLongMsg(pinstance, (LPMIDIHDR)dwParam1);
			return modMapLongMsg (pinstance, (LPMIDIHDR)dwParam1);

        case MODM_PREPARE:
            assert(NULL != pinstance);

            return modPrepare((LPMIDIHDR)dwParam1);

        case MODM_UNPREPARE:
            assert(NULL != pinstance);

            return modUnprepare((LPMIDIHDR)dwParam1);

        case MODM_GETVOLUME:
            if (!IS_ALLOWVOLUME)
                return MMSYSERR_NOTSUPPORTED;

            *(LPDWORD)dwParam1 = gdwVolume;

            return MMSYSERR_NOERROR;

        case MODM_SETVOLUME:
            if (!IS_ALLOWVOLUME)
                return MMSYSERR_NOTSUPPORTED;

            gdwVolume = (DWORD)dwParam1;

            if (ghMidiStrm)
                return midiOutSetVolume((HMIDIOUT)ghMidiStrm, (DWORD)dwParam1);

            return modSetVolume((DWORD)dwParam1);

        case MODM_PROPERTIES:
            assert(NULL != pinstance);

            return midiStreamProperty(ghMidiStrm, (LPVOID)dwParam1, (DWORD)dwParam2);

        case MODM_STRMDATA:
            assert(NULL != pinstance);

            return MapCookedBuffer(pinstance, (LPMIDIHDR)dwParam1);

        case MODM_RESET:
            assert(NULL != pinstance);

            if (ghMidiStrm)
                return midiOutReset((HMIDIOUT)ghMidiStrm);

            mmrc = MMSYSERR_NOERROR;
            for (pport = gpportList; pport; pport=pport->pNext)
                if (MMSYSERR_NOERROR != (mmrc2 =
                    midiOutReset(pport->hmidi)))
                    mmrc = mmrc2;

            return mmrc;

        case MODM_GETPOS:
            assert(NULL != pinstance);

            return modGetPosition((PINSTANCE)pinstance,
                                  (LPMMTIME)dwParam1,
                                  (DWORD)dwParam2  /* cbmmtime */);


        case MODM_PAUSE:
            assert(NULL != pinstance);

            return midiStreamPause(ghMidiStrm);

        case MODM_RESTART:
            assert(NULL != pinstance);

            return midiStreamRestart(ghMidiStrm);

        case MODM_STOP:
            assert(NULL != pinstance);

            return midiStreamStop(ghMidiStrm);

        case MODM_CACHEPATCHES:
            assert(NULL != pinstance);

            if (!IS_ALLOWCACHE)
                return MMSYSERR_NOTSUPPORTED;

            if (ghMidiStrm)
                return midiOutCachePatches(
                        (HMIDIOUT)ghMidiStrm,   // hmidi
                        HIWORD(dwParam2),       // wBank
                        (WORD FAR *)dwParam1,   // lpPatchArray
                        LOWORD(dwParam2));      // wFlags

            mmrc = MMSYSERR_NOERROR;
            for (pport = gpportList; pport; pport=pport->pNext)
                if (MMSYSERR_NOERROR != (mmrc2 =
                    midiOutCachePatches(
                        pport->hmidi,           // hmidi
                        HIWORD(dwParam2),       // wBank
                        (WORD FAR *)dwParam1,   // lpPatchArray
                        LOWORD(dwParam2))) &&   // wFlags
                    MMSYSERR_NOTSUPPORTED != mmrc2)
                    mmrc = mmrc2;

            return mmrc;

        case MODM_CACHEDRUMPATCHES:
            assert(NULL != pinstance);

            if (!IS_ALLOWCACHE)
                return MMSYSERR_NOTSUPPORTED;

            if (ghMidiStrm)
                return midiOutCacheDrumPatches(
                        (HMIDIOUT)ghMidiStrm,   // hmidi
                        HIWORD(dwParam2),       // wBank
                        (WORD FAR *)dwParam1,   // lpKeyArray
                        LOWORD(dwParam2));      // wFlags

            mmrc = MMSYSERR_NOERROR;
            for (pport = gpportList; pport; pport=pport->pNext)
                if (MMSYSERR_NOERROR != (mmrc2 =
                    midiOutCacheDrumPatches(
                        pport->hmidi,           // hmidi
                        HIWORD(dwParam2),       // wBank
                        (WORD FAR *)dwParam1,   // lpKeyArray
                        LOWORD(dwParam2))) &&   // wFlags
                    MMSYSERR_NOTSUPPORTED != mmrc2)
                    mmrc = mmrc2;

            return mmrc;

        case DRVM_MAPPER_RECONFIGURE:

	    DPF(2, TEXT ("DRV_RECONFIGURE"));

	    // Prevent Synchronization problems during Configuration
	    if (NULL != hMutexConfig) WaitForSingleObject (hMutexConfig, INFINITE);
	    dwResult = UpdateInstruments(TRUE, (DWORD)dwParam2);
	    if (NULL != hMutexConfig) ReleaseMutex (hMutexConfig);
	    return dwResult;

    }

    return MMSYSERR_NOTSUPPORTED;
}

/***************************************************************************

   @doc internal

   @api void | modmCallback | Callback for completion of sending of
    long messages. This function conforms to the definition in the SDK.

   @parm HMIDIOUT | hmo | The MMSYSTEM handle of the device which
    complete sending.

   @parm WORD | wmsg | Contains a MOM_xxx code signifying what event
    occurred. We only care about MOM_DONE.

   @parm DWORD | dwInstance | DWORD of instance data given at open time;
    this contains the PPORT which owns the handle.

   @parm DWORD | dwParam1 | Message specific parameters. For MOM_DONE,
    this contains a far pointer to the header which completed.

   @parm DWORD | dwParam2 | Message specific parameters. Contains
    nothinf for MOM_DONE.

   @comm This function MUST be in a fixed segment since the driver
    may call it at interrupt time.

***************************************************************************/
void CALLBACK _loadds modmCallback(
    HMIDIOUT            hmo,
    WORD                wmsg,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2)
{
    LPMIDIHDR           lpmhShadow;
    LPMIDIHDR           lpmhUser;
    PINSTANCE           pinstance;
    PSHADOWBLOCK        psb;
    LPMIDIHDR31         lpmh31;
    BOOL                fNeedCB         = FALSE;

    lpmhShadow = (LPMIDIHDR)dwParam1;

    if (wmsg == MOM_DONE && lpmhShadow)
    {
        DPF(1, TEXT ("Callback: MOM_DONE"));
        pinstance = (PINSTANCE)(UINT_PTR)lpmhShadow->dwReserved[MH_MAPINST];
        lpmhUser = (LPMIDIHDR)lpmhShadow->dwReserved[MH_SHADOWEE];

        if (ghMidiStrm)
            fNeedCB = TRUE;
        else
        {
            lpmh31 = (LPMIDIHDR31)lpmhUser;
            psb = (PSHADOWBLOCK)(UINT_PTR)lpmh31->reserved;
            if (0 == --psb->cRefCnt && !(lpmh31->dwFlags & MHDR_SENDING))
                fNeedCB = TRUE;
        }

        if (fNeedCB)
        {
            DPF(1, TEXT ("Callback: Propogating"));
            lpmhUser->dwFlags |= MHDR_DONE;
            lpmhUser->dwFlags &= ~MHDR_INQUEUE;
            DriverCallback(
                           pinstance->dwCallback,
                           HIWORD(pinstance->fdwOpen),
                           (HANDLE)pinstance->hmidi,
                           MM_MOM_DONE,
                           pinstance->dwInstance,
                           (DWORD_PTR)lpmhUser,
                           0L);
        }
    }
    else if (wmsg == MOM_POSITIONCB && lpmhShadow)
    {
        pinstance = (PINSTANCE)(UINT_PTR)lpmhShadow->dwReserved[MH_MAPINST];
        lpmhUser = (LPMIDIHDR)lpmhShadow->dwReserved[MH_SHADOWEE];

        if (!ghMidiStrm)
        {
            DPF(0, TEXT ("Got MOM_POSITIONCB on non-stream handle?"));
            return;
        }


        lpmhUser->dwOffset = lpmhShadow->dwOffset;
        DriverCallback(
                       pinstance->dwCallback,
                       HIWORD(pinstance->fdwOpen),
                       (HANDLE)pinstance->hmidi,
                       MM_MOM_POSITIONCB,
                       pinstance->dwInstance,
                       (DWORD_PTR)lpmhUser,
                       0L);

    }
}

/***************************************************************************

   @doc internal

   @api DWORD | MapSingleEvent | Map and possibly send a short message.

   @parm PINSTANCE | pinstance | Pointer to an open instance.

   @parm DWORD | dwData | Contains the short message to transmit.

   @parm DWORD | fdwFlags | One of the the following values:
    @flag MSE_F_SENDEVENT | Send the event to the physical channel
    @flag MSE_F_RETURNEVENT | Return the event to be re-packed into
     a buffer.

   @comm Running status should be taken care of before we get
    called.

   @rdesc | Some MMSYSERR_xxx code if MSE_F_SENDEVENT; otherwise the
    mapped event if no error, 0L on error.

***************************************************************************/
DWORD FNGLOBAL MapSingleEvent(
    PINSTANCE       pinstance,
    DWORD           dwData,
    DWORD           fdwFlags,
    DWORD BSTACK *  pdwStreamID)
{
    BYTE            bMsg;
    BYTE            bChan;
    BYTE            b1;
    BYTE            b2;
    PCHANNEL        pchannel;
    MMRESULT        mmr;
    BOOL            frtm;  // isrealtimemessage.

    // Extract message type and channel number.
    //

    bMsg  = MSG_STATUS(dwData);
    frtm  = IS_REAL_TIME(bMsg);
    bChan = MSG_CHAN(bMsg);
    bMsg  = MSG_EVENT(bMsg);

    // Ignore sysex messages. 
    // (MIDI_SYSEX == bMsg) will also eliminate real time
    // messages. Therefore real-time messages are special cased
    // 

    if (MIDI_SYSEX == bMsg && !frtm)
        return !(fdwFlags & MSE_F_RETURNEVENT) ? MMSYSERR_NOERROR : (((DWORD)MEVT_NOP)<<24);

    if (NULL == (pchannel = gapChannel[bChan]))
        return !(fdwFlags & MSE_F_RETURNEVENT) ? MMSYSERR_NOERROR : (((DWORD)MEVT_NOP)<<24);


    bChan = (BYTE)pchannel->uChannel;

    if (pdwStreamID)
        *pdwStreamID = pchannel->dwStreamID;

    switch(bMsg)
    {
        case MIDI_NOTEOFF:
        case MIDI_NOTEON:
            b1 = MSG_PARM1(dwData);
            b2 = MSG_PARM2(dwData);

            if (NULL != pchannel->pbKeyMap)
                b1 = pchannel->pbKeyMap[b1];

            dwData = MSG_PACK2(bMsg|bChan, b1, b2);
            break;

        case MIDI_POLYPRESSURE:
        case MIDI_CONTROLCHANGE:
        case MIDI_PITCHBEND:
            b1 = MSG_PARM1(dwData);
            b2 = MSG_PARM2(dwData);

            dwData = MSG_PACK2(bMsg|bChan, b1, b2);
            break;

        case MIDI_PROGRAMCHANGE:
            b1 = MSG_PARM1(dwData);

            if (NULL != pchannel->pbPatchMap)
                b1 = pchannel->pbPatchMap[b1];

            dwData = MSG_PACK1(bMsg|bChan, b1);
            break;
    }

    if (!(fdwFlags & MSE_F_RETURNEVENT))
    {
        if (dwData)
        {
            if (ghMidiStrm)
                mmr = midiOutShortMsg((HMIDIOUT)ghMidiStrm, dwData);
            else
                mmr = midiOutShortMsg(pchannel->pport->hmidi, dwData);
            if (MMSYSERR_NOERROR != mmr)
            {
                DPF(1, TEXT ("midiOutShortMsg(%04X, %08lX) -> %u"), (WORD)(pchannel->pport->hmidi), dwData, (UINT)mmr);
            }
        }

        return mmr;
    }
    else
        return dwData;
}

/***************************************************************************

   @doc internal

   @api DWORD | modLongMsg | Handle MODM_LONGDATA in compatibility mode.

   @parm LPMIDIHDR | lpmh | The header to broadcast.

   @comm Propogate the header across all drivers. <f modmCallback> handles
    counting the returning callbacks and making sure the caller only gets
    one.

   @rdesc | Some MMSYSERR_xxx code if MSE_F_SENDEVENT; otherwise the
    mapped event if no error, 0L on error.

***************************************************************************/
DWORD FNLOCAL modLongMsg(
    PINSTANCE           pinstance,
    LPMIDIHDR           lpmh)
{
    WORD                wIntStat;
    LPMIDIHDR           lpmhWork;
    PPORT               pport;
    MMRESULT            mmrc            = MMSYSERR_NOERROR;
    BOOL                fNeedCB         = FALSE;
    LPMIDIHDR31         lpmh31          = (LPMIDIHDR31)lpmh;
    PSHADOWBLOCK        psb;

    if (ghMidiStrm)
        psb = (PSHADOWBLOCK)(UINT_PTR)lpmh->dwReserved[MH_SHADOW];
    else
        psb = (PSHADOWBLOCK)(UINT_PTR)lpmh31->reserved;

    lpmhWork = psb->lpmhShadow;

    lpmhWork->dwReserved[MH_MAPINST] = (DWORD_PTR)pinstance;

    if (ghMidiStrm)
    {
        lpmhWork->dwBufferLength = lpmh->dwBufferLength;
        return midiOutLongMsg((HMIDIOUT)ghMidiStrm,
                              lpmhWork,
                              sizeof(*lpmhWork));
    }

    lpmh->dwFlags |= MHDR_SENDING;
    psb->cRefCnt = 0;

    DPF(1, TEXT ("LongMsg: User hdr %p  Shadow %p"), lpmh, lpmhWork);

    for (pport = gpportList; pport; pport=pport->pNext, lpmhWork++)
    {
        lpmhWork->dwBufferLength = lpmh->dwBufferLength;
        mmrc = midiOutLongMsg(pport->hmidi, lpmhWork, sizeof(*lpmhWork));

        if (MMSYSERR_NOERROR != mmrc)
        {
            // Don't turn off MHDR_SENDING; this will prevent any callbacks
            // from being propogated to the user.
            return mmrc;
        }

        ++psb->cRefCnt;
    }

		// Wait for synchronization object
	WaitForSingleObject (hMutexRefCnt, INFINITE);

		// Do we need to do callback
    if (0 == psb->cRefCnt)
        fNeedCB = TRUE;

		// Release synchronization object
	ReleaseMutex (hMutexRefCnt);

    if (fNeedCB)
    {
        lpmh->dwFlags |= MHDR_DONE;
        DriverCallback(
            pinstance->dwCallback,
            HIWORD(pinstance->fdwOpen),
            (HANDLE)pinstance->hmidi,
            MM_MOM_DONE,
            pinstance->dwInstance,
            (DWORD_PTR)lpmh,
            0L);
    }

    return MMSYSERR_NOERROR;
}


/***************************************************************************

   @doc internal

   @api DWORD | modMapLongMsg | Handle MODM_LONGDATA in compatibility mode.

   @parm LPMIDIHDR | lpmh | The header to broadcast.

   @comm if a SYSEXE event Propogate the header across all drivers.
   <f modmCallback> handles counting the returning callbacks and making sure the caller only gets
    one.   Otherwise, parse the Long Message into a bunch of short messages
	and Map each one individually.

   @rdesc | Some MMSYSERR_xxx code if MSE_F_SENDEVENT; otherwise the
    mapped event if no error, 0L on error.

***************************************************************************/
DWORD FNLOCAL modMapLongMsg (
	PINSTANCE pinstance,
    LPMIDIHDR lpmh)
{
    WORD                wIntStat;
    LPMIDIHDR           lpmhWork;
    PPORT               pport;
    MMRESULT            mmrc            = MMSYSERR_NOERROR;
    BOOL                fNeedCB         = FALSE;
    LPMIDIHDR31         lpmh31          = (LPMIDIHDR31)lpmh;
    PSHADOWBLOCK        psb;
	LPBYTE				pbData;		// Pointer to Data
	BYTE				bMsg;
	UINT				uMessageLength;
	LPBYTE				pbTrans;		// Pointer to Translation Buffer
	DWORD				dwCurr;
	DWORD				dwLength;
	DWORD				dwMsg;
	DWORD				dwBuffLen;
	INT					rMsg;				

		// Get Shadow Block
    if (ghMidiStrm)
        psb = (PSHADOWBLOCK)(UINT_PTR)lpmh->dwReserved[MH_SHADOW];
    else
        psb = (PSHADOWBLOCK)(UINT_PTR)lpmh31->reserved;

    lpmhWork = psb->lpmhShadow;

    lpmhWork->dwReserved[MH_MAPINST] = (DWORD_PTR)pinstance;

		// Check for MIDI streaming
    if (ghMidiStrm)
    {
        lpmhWork->dwBufferLength = lpmh->dwBufferLength;
        return midiOutLongMsg((HMIDIOUT)ghMidiStrm,
                              lpmhWork,
                              sizeof(*lpmhWork));
    }

    lpmh->dwFlags |= MHDR_SENDING;
    psb->cRefCnt = 0;

    DPF(1, TEXT ("MapLongMsg: User hdr %p  Shadow %p"), lpmh, lpmhWork);

    pbData = lpmhWork->lpData;
    bMsg  = MSG_EVENT(*pbData);

    if (MIDI_SYSEX == bMsg)
	{
		// Broadcast SYSEX message to all active ports
	    for (pport = gpportList; pport; pport=pport->pNext, lpmhWork++)
		{
			lpmhWork->dwBufferLength = lpmh->dwBufferLength;
			mmrc = midiOutLongMsg(pport->hmidi, lpmhWork, sizeof(*lpmhWork));
			if (MMSYSERR_NOERROR != mmrc)
			{
				// Don't turn off MHDR_SENDING; this will prevent any callbacks
				// from being propogated to the user.
				return mmrc;
			}
			++psb->cRefCnt;
		}
	}
	else
	{
		// Parse and Translate list of Short messages
		dwBuffLen = lpmh->dwBufferLength;

		// Grow Translation buffer to at least this size
		if (!GrowTransBuffer (pinstance, dwBuffLen))
		{
			// That didn't work !!!
			// Default to Broadcast messages to all active ports
			for (pport = gpportList; pport; pport=pport->pNext, lpmhWork++)
			{
				lpmhWork->dwBufferLength = lpmh->dwBufferLength;
				mmrc = midiOutLongMsg(pport->hmidi, lpmhWork, sizeof(*lpmhWork));
				if (MMSYSERR_NOERROR != mmrc)
				{
					// Don't turn off MHDR_SENDING; this will prevent any callbacks
					// from being propogated to the user.
					return mmrc;
				}
				++psb->cRefCnt;
			}
		}
		else
		{
				// Copy buffer to translation buffer
			pbTrans = AccessTransBuffer (pinstance);
			CopyMemory (pbTrans, pbData, dwBuffLen);

				// Parse translation buffer
			dwCurr	= 0L;
			while (dwBuffLen)
			{
					// Map Event
				rMsg = MapEvent (&pbTrans[dwCurr], dwBuffLen, &dwLength, &dwMsg);
				switch (rMsg)
				{
				case MSG_SHORT:
						// Send Short Message
					MapSingleEvent(pinstance,
				  				   dwMsg,
								   MSE_F_SENDEVENT,
								   NULL);
					dwCurr += dwLength;
					break;

				case MSG_LONG:
					//
					//	Note:  For completeness, we should probably broadcast
					//         this, but for now assume that there are no embedded
					//         SYSEX messages in the buffer and skip any we encounter
					//
					dwCurr += dwLength;
					break;

				default:
					dwCurr += dwLength;
					break;
				}

				dwBuffLen -= dwLength;
			} // End While

				// Release Translation Buffer
			ReleaseTransBuffer (pinstance);
		}
	}

		// Wait for synchronization object
	WaitForSingleObject (hMutexRefCnt, INFINITE);

		// Do we need to do callback
    if (0 == psb->cRefCnt)
        fNeedCB = TRUE;

		// Release synchronization object
	ReleaseMutex (hMutexRefCnt);

    if (fNeedCB)
    {
        lpmh->dwFlags |= MHDR_DONE;
        DriverCallback(
            pinstance->dwCallback,
            HIWORD(pinstance->fdwOpen),
            (HANDLE)pinstance->hmidi,
            MM_MOM_DONE,
            pinstance->dwInstance,
            (DWORD_PTR)lpmh,
            0L);
    }

    return MMSYSERR_NOERROR;

} // End modMapLongMsg


	// returns length of various MIDI messages in bytes
INT FNLOCAL MapEvent (
	BYTE  * pStatus,
	DWORD	dwBuffSize,
	DWORD * pSkipBytes,
	DWORD * pShortMsg)
{
	INT	 fResult = MSG_SHORT;
	BYTE bMsg    = 0;
	BYTE bParam1 = 0;
	BYTE bParam2 = 0;

    bMsg  = *pStatus;
	*pSkipBytes = 0;

	// Mask Off Channel bits
    switch (bMsg & 0xF0)
	{
	case MIDI_NOTEOFF:
	case MIDI_NOTEON:
	case MIDI_POLYPRESSURE:
	case MIDI_CONTROLCHANGE:
		bParam1 = *(pStatus+1);
		bParam2 = *(pStatus+2);
		*pShortMsg = MSG_PACK2(bMsg,bParam1,bParam2);
		*pSkipBytes = 3;
		break;

	case MIDI_PROGRAMCHANGE:
	case MIDI_CHANPRESSURE:
		bParam1 = *(pStatus+1);
		*pShortMsg = MSG_PACK1(bMsg,bParam1);
		*pSkipBytes = 2;
		break;

	case MIDI_PITCHBEND:
		bParam1 = *(pStatus+1);
		bParam2 = *(pStatus+2);
		*pShortMsg = MSG_PACK2(bMsg,bParam1,bParam2);
		*pSkipBytes = 3;
		break;

	case MIDI_SYSEX:
			// It's a system message
			// Keep counting system messages until
			// We don't find any more
		fResult = MSG_LONG;
		*pSkipBytes = 0;
		while (((bMsg & 0xF0) == 0xF0) && 
			   (*pSkipBytes < dwBuffSize))
		{
			switch (bMsg)
			{
			case MIDI_SYSEX:
						// Find end of SysEx message
				*pSkipBytes ++;
				while ((*pSkipBytes < dwBuffSize) && 
					   (pStatus[*pSkipBytes] != MIDI_SYSEXEND))
				{
					*pSkipBytes++;
				}
				break;

			case MIDI_QFRAME:
				*pSkipBytes += 2;
				break;

			case MIDI_SONGPOINTER:
				*pSkipBytes += 3;
				break;

			case MIDI_SONGSELECT:
				*pSkipBytes += 2;
				break;

			case MIDI_F4:					// Undefined message
			case MIDI_F5:					// Undefined message
			case MIDI_TUNEREQUEST:
			case MIDI_SYSEXEND:				// Not really a message, but skip it
			case MIDI_TIMINGCLOCK:
			case MIDI_F9:					// Undefined Message
			case MIDI_START:
			case MIDI_CONTINUE:
			case MIDI_STOP:
			case MIDI_FD:					// Undefined Message
			case MIDI_ACTIVESENSING:		
			case MIDI_META:					// Is this how handle this message ?!?
				*pSkipBytes += 1;
				break;			
			} // End Switch

			if (*pSkipBytes < dwBuffSize)
				bMsg = pStatus[*pSkipBytes];
		} // End While
		break;

	default:
			// Unknown just increment skip count
		fResult = MSG_UNKNOWN;
		*pSkipBytes = 1;
		break;
	} // End switch

		// Truncate to end of buffer
	if (*pSkipBytes > dwBuffSize)
		*pSkipBytes = dwBuffSize;

	return fResult;
} // End MapEvent



	// Create Translation buffer
BOOL FNGLOBAL InitTransBuffer (PINSTANCE pinstance)
{
	if (!pinstance)
		return FALSE;

	InitializeCriticalSection (& (pinstance->csTrans));

	EnterCriticalSection (&(pinstance->csTrans));

	pinstance->pTranslate	= NULL;
	pinstance->cbTransSize	= 0;

	LeaveCriticalSection (&(pinstance->csTrans));

	return TRUE;
} // End InitTransBuffer


	// Cleanup Translation Buffer
BOOL FNGLOBAL CleanupTransBuffer (PINSTANCE pinstance)
{
	if (!pinstance)
		return FALSE;

	EnterCriticalSection (&(pinstance->csTrans));

	if (pinstance->pTranslate)
	{
		LocalFree((HLOCAL)(pinstance->pTranslate));
		pinstance->pTranslate = NULL;
		pinstance->cbTransSize = 0L;
	}

	LeaveCriticalSection (&(pinstance->csTrans));

	DeleteCriticalSection (&(pinstance->csTrans));

	return TRUE;
} // End CleanupTransBuffer


	// Get Pointer to translation buffer
LPBYTE AccessTransBuffer (PINSTANCE pinstance)
{
	if (!pinstance)
		return NULL;

	EnterCriticalSection (&(pinstance->csTrans));

	return pinstance->pTranslate;
} // End AccessTransBuffer


	// Release pointer to translation buffer
void FNGLOBAL ReleaseTransBuffer (PINSTANCE pinstance)
{
	if (!pinstance)
		return;

	LeaveCriticalSection (&(pinstance->csTrans));
} // End ReleaseTransBuffer


	// Resize Translation buffer
BOOL FNGLOBAL GrowTransBuffer (PINSTANCE pinstance, DWORD cbNewSize)
{
	LPBYTE pNew;

	if (!pinstance)
		return FALSE;

	EnterCriticalSection (&(pinstance->csTrans));

		// Do we even need to grow buffer
	if (cbNewSize > pinstance->cbTransSize)
	{
		pNew = (LPBYTE)LocalAlloc(LPTR, cbNewSize);
		if (!pNew)
		{
		LeaveCriticalSection (&(pinstance->csTrans));
		return FALSE;
		}

			// Remove old translation buffer, if any
		if (pinstance->pTranslate)
			LocalFree ((HLOCAL)(pinstance->pTranslate));

			// Assign new buffer
		pinstance->pTranslate = pNew;
		pinstance->cbTransSize = cbNewSize;
	}

	LeaveCriticalSection (&(pinstance->csTrans));
	return TRUE;
} // End GrowTransBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\queue.c ===
/**********************************************************************

  Copyright (c) 1992-1995 Microsoft Corporation

  queue.c

  DESCRIPTION:
    Priority queue routines.

  HISTORY:
     02/22/94       [jimge]        created.

*********************************************************************/

#include "preclude.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "idf.h"

#include "midimap.h"

#include "debug.h"

//#pragma warning(disable:4704)

/***************************************************************************
  
   @doc internal
  
   @api void | QueueInit | Prepare a queue for use.
  
   @parm PQUEUE | pq | Queue to clear.
  
***************************************************************************/
void FNGLOBAL QueueInit(
    PQUEUE              pq)
{
    InitializeCriticalSection (&(pq->cs));
    pq->pqeFront = NULL;
    pq->pqeRear  = NULL;
    pq->cEle     = 0;
}



/***************************************************************************
  
   @doc internal
  
   @api void | QueueCleanup | Cleans up a queue after use.
  
   @parm PQUEUE | pq | Queue to clear.
  
***************************************************************************/
void FNGLOBAL QueueCleanup(
    PQUEUE              pq)
{
    DeleteCriticalSection (&(pq->cs));
    pq->pqeFront = NULL;
    pq->pqeRear  = NULL;
    pq->cEle     = 0;
}

/***************************************************************************
  
   @doc internal
  
   @api void | QueuePut | Insert an item into the queue.

   @parm PQUEUE | pq | Queue to insert into.

   @parm PQUEUEELE | pqe | New element to insert.

   @parm UINT | uPriority | Priority of the new element.

   @comm New elements will be inserted in priority order. Low priorities
   go near the front of the queue (first to be dequeued). New elements
   will be inserted at the end of all elements in the queue with
   equal or lower priorities.
  
***************************************************************************/
void FNGLOBAL QueuePut(
    PQUEUE              pq,
    PQUEUEELE           pqe,
    UINT                uPriority)
{
    PQUEUEELE           pqePrev;
    PQUEUEELE           pqeCurr;
    
    EnterCriticalSection(&(pq->cs));
  
    pqePrev = NULL;
    pqeCurr = pq->pqeFront;

    pqe->uPriority = uPriority;

    // Position pqePrev and pqeCurr so that pqe should be
    // inserted between them.
    //
    while (NULL != pqeCurr)
    {
        if (uPriority < pqeCurr->uPriority)
            break;

        pqePrev = pqeCurr;
        pqeCurr = pqeCurr->pqeNext;
    }

    // Now do the actual insertion.
    //
    if (NULL == pqePrev)
        pq->pqeFront = pqe;
    else
        pqePrev->pqeNext = pqe;

    if (NULL == pqeCurr)
        pq->pqeRear = pqe;
    else
        pqeCurr->pqePrev = pqe;

    pqe->pqePrev = pqePrev;
    pqe->pqeNext = pqeCurr;
    ++pq->cEle;

    LeaveCriticalSection(&(pq->cs));
}

/***************************************************************************
  
   @doc internal
  
   @api void | QueueGet | Get and remove the first element from the queue. 

   @parm PQUEUE | pq | Queue to get the element from.

   @rdesc NULL if the queue is empty, otherwise the element pointer. 
  
***************************************************************************/
PQUEUEELE FNGLOBAL QueueGet(
    PQUEUE              pq)
{
    PQUEUEELE           pqe;

    EnterCriticalSection(&(pq->cs));

    pqe = pq->pqeFront;

    if (NULL != pqe)
    {
        pq->pqeFront = pqe->pqeNext;

        if (NULL == pqe->pqeNext)
            pq->pqeRear = NULL;
        else
            pqe->pqeNext->pqePrev = NULL;
    
        pqe->pqePrev = pqe->pqeNext = NULL;

        --pq->cEle;
    }
    
    LeaveCriticalSection(&(pq->cs));

    return pqe;
}

/***************************************************************************
  
   @doc internal
  
   @api void | QueueRemove | Remove a specific element from the queue.

   @parm PQUEUE | pq | Queue to remove from.

   @parm PQUEUEELE | pqe | Element to remove.

   @rdesc TRUE on success, FALSE if the element does not exist in the
    queue.
  
***************************************************************************/
BOOL FNGLOBAL QueueRemove(
    PQUEUE              pq,
    PQUEUEELE           pqe)
{
    PQUEUEELE           pqeCurr;
    
    EnterCriticalSection(&(pq->cs));

    // Ensure that we don't muck around with pointers to some
    // other queue.
    //

    for (pqeCurr = pq->pqeFront; pqeCurr; pqeCurr = pqeCurr->pqeNext)
        if (pqe == pqeCurr)
            break;

    if (NULL == pqeCurr)
    {
        LeaveCriticalSection(&(pq->cs));
        return FALSE;
    }

    // It's in the queue, remove it.
    //
    if (NULL == pqe->pqePrev)
        pq->pqeFront = pqe->pqeNext;
    else
        pqe->pqePrev->pqeNext = pqe->pqeNext;

    if (NULL == pqe->pqeNext)
        pq->pqeRear = pqe->pqePrev;
    else
        pqe->pqeNext->pqePrev = pqe->pqePrev;

    --pq->cEle;
    
    LeaveCriticalSection(&(pq->cs));
    return TRUE;
}

/***************************************************************************
  
   @doc internal
  
   @api PQUEUEELE | QueueGetFilter | Remove the first element from a
    priority queue which matches a filter.

   @parm PQUEUE | pq | Queue to remove from.

   @parm FNFILTER | fnf | Filter function. Should return TRUE if
    the passed PQUEUEELE matches the filter criteria and should
    be removed.

   @rdesc A PQUEUEELE or NULL if none are available that match the
    filter.
  
***************************************************************************/
PQUEUEELE FNGLOBAL QueueGetFilter(
    PQUEUE              pq,
    FNFILTER            fnf)
{
    PQUEUEELE           pqe;
    
    EnterCriticalSection(&(pq->cs));

    for (pqe = pq->pqeFront; pqe; pqe = pqe->pqeNext)
        if (fnf(pqe))
            break;

    if (NULL != pqe)
        QueueRemove(pq, pqe);
    
    LeaveCriticalSection(&(pq->cs));

    return pqe;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\preclude.h ===
// Copyright (c) 1995 Microsoft Corporation

// MMSYSTEM precludes
//
 
#define     MMNOSOUND
#define     MMNOWAVE
#define     MMNOSEQ
#define     MMNOTIMER
#define     MMNOJOY
////#define     MMNOMCI
#define     MMNOTASK

// MMDDK precludes
//
#define     MMNOWAVEDEV
#define     MMNOAUXDEV
#define     MMNOTIMERDEV
#define     MMNOJOYDEV
/////#define     MMNOMCIDEV
#define     MMNOTASKDEV

// WINDOWS precludes
//

#define     NOGDICAPMASKS        //- CC_*, LC_*, PC_*, CP_*, TC_*, RC_
#define     NOVIRTUALKEYCODES    //- VK_*
#define     NOICONS              //- IDI_*
#define     NOKEYSTATES          //- MK_*
#define     NOSYSCOMMANDS        //- SC_*
#define     NORASTEROPS          //- Binary and Tertiary raster ops
#define     OEMRESOURCE          //- OEM Resource values
#define     NOCLIPBOARD          //- Clipboard routines
#define     NOMETAFILE           //- typedef METAFILEPICT
//#define     NOOPENFILE           //- OpenFile(), OemToAnsi, AnsiToOem, and OF_*
#define     NOSOUND              //- Sound driver routines
#define     NOWH                 //- SetWindowsHook and WH_*
#define     NOCOMM               //- COMM driver routines
#define     NOKANJI              //- Kanji support stuff.
//#define     NOHELP               //- Help engine interface.
#define     NOPROFILER           //- Profiler interface.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\regfix.h ===
// Copyright (c) 1995 Microsoft Corporation

/*
**-----------------------------------------------------------------------------
**	File:		RegFix.c
**	Purpose:	fix up registry settings for MIDI-Mapper
**	Mod Log:	Created by Shawn Brown (11/14/95)
**-----------------------------------------------------------------------------
*/
#ifndef REGFIX_H
#define REGFIX_H

#include <windows.h>
#include <mmsystem.h>
#include <regstr.h>

BOOL CheckRegistry (void);

BOOL 

#endif // REGFIX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\res.h ===
/**********************************************************************

    Copyright (c) 1992-1995 Microsoft Corporation

    res.h

    DESCRIPTION:
      Resource ID include file for the MIDI mapper.

*********************************************************************/

#ifndef _RES_
#define _RES_

#define IDS_MIDIMAPPER          1000

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\modmsg.c ===
/**********************************************************************

  Copyright (c) 1992-1999 Microsoft Corporation

  modmsg.c

  DESCRIPTION:
     Non-fixed code for doing output mapping. Keep out of the reach
     of children. This prescription may be refilled twice. May cause
     temporary distortion of reality in your vicinity.

  HISTORY:
     02/21/94       [jimge]        created.

*********************************************************************/

#include "preclude.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include "idf.h"

#include <mmreg.h>
#include <memory.h>

#include "midimap.h"
#include "res.h"
#include "debug.h"


//=========================== Globals ======================================
//
extern HANDLE hMutexConfig; // Located in DRVPROC.C
BOOL          gfReconfigured = FALSE;

//=========================== Prototypes ===================================
//

PRIVATE MMRESULT FNLOCAL SendChannelInitString(
    HMIDIOUT            hmidi,
    PBYTE               pbinit,
    DWORD               cbinit);

/***************************************************************************
  
   @doc internal
  
   @api DWORD | modGetDevCaps | Handles the MODM_GETDEVCAPS message.
  
   @parm LPMIDIOUTCAPS | pmoc | Pointer to a caps structure to fill in.

   @parm DWORD | cbmoc | How big the caller thinks the structure is.
  
   @rdesc Some MMSYSERR_xxx code.
       
***************************************************************************/
DWORD FNGLOBAL modGetDevCaps(
    LPMIDIOUTCAPS   pmoc,
    DWORD           cbmoc)
{
    MIDIOUTCAPS     moc;
    MIDIOUTCAPS     mocWork;
    DWORD           cbCopy;
    WORD            wMask;
    UINT            idx;
    MMRESULT        mmr;
    PPORT           pport;
    
    moc.wMid            = MM_MICROSOFT;
    moc.wPid            = MM_MIDI_MAPPER;
    moc.vDriverVersion  = 0x0500;
    LoadString(ghinst, IDS_MIDIMAPPER, moc.szPname, sizeof(moc.szPname)/sizeof(moc.szPname[0]));
    moc.wTechnology     = MOD_MAPPER;
    moc.wVoices         = 0;
    moc.wNotes          = 0;
    moc.wChannelMask    = 0;

    wMask = 1;
    for (idx = 0; idx < MAX_CHANNELS; idx++)
    {
        if (gapChannel[idx])
            moc.wChannelMask |= wMask;
        wMask <<= 1;
    }

    // If any underlying device supports cache patches, we must support it.
    // Only support volume or lrvolume, however, if ALL devices support it.
    //
    
    do
    {
        gfReconfigured = FALSE;
        moc.dwSupport  = MIDICAPS_STREAM|MIDICAPS_VOLUME|MIDICAPS_LRVOLUME;
        
        for (pport = gpportList; pport; pport=pport->pNext)
        {
            mmr = midiOutGetDevCaps(pport->uDeviceID, &mocWork, sizeof(mocWork));

            //  This prevents a corrupt gpportList in the event of a pnp event
            //  during a midiOutGetDevCaps call...            
            if (gfReconfigured)
                break;
                
            if (MMSYSERR_NOERROR != mmr)
                continue;

            if (!(mocWork.dwSupport & MIDICAPS_LRVOLUME))
                moc.dwSupport &= ~MIDICAPS_LRVOLUME;

            if (!(mocWork.dwSupport & MIDICAPS_VOLUME))
                moc.dwSupport &= ~(MIDICAPS_VOLUME|MIDICAPS_LRVOLUME);

            moc.dwSupport |= (mocWork.dwSupport & MIDICAPS_CACHE);
        }
    } 
    while (gfReconfigured);

    CLR_ALLOWVOLUME;
    if (moc.dwSupport & MIDICAPS_VOLUME)
        SET_ALLOWVOLUME;

    CLR_ALLOWCACHE;
    if (moc.dwSupport & MIDICAPS_CACHE)
        SET_ALLOWCACHE;

    cbCopy = min(cbmoc, sizeof(moc));
    hmemcpy((LPSTR)pmoc, (LPSTR)&moc, cbCopy);

    return MMSYSERR_NOERROR;
}


/***************************************************************************
  
   @doc internal
  
   @api DWORD | modOpen | Handles the MODM_OPEN message.
  
   @parm LPDWORD | lpdwInstance | Points to a DWORD where we can store
    our instance data. We save our PINSTANCE here.
  
   @parm LPMIDIOPENDESC | lpmidiopendesc | Points to parameters from
    MMSYSTEM describing the caller's callback, etc.
  
   @parm DWORD | fdwOpen | Flags describing the callback type.
  
   @rdesc Some MMSYSERR_xxx code.
       
***************************************************************************/
DWORD FNGLOBAL modOpen(
    PDWORD_PTR      lpdwInstance,
    LPMIDIOPENDESC  lpmidiopendesc,
    DWORD           fdwOpen)                  
{
    PINSTANCE       pinstance				= NULL;
    PPORT           pport;
    MMRESULT        mmrc					= MMSYSERR_NOERROR;
    UINT            idx;
    UINT            idx2;
    UINT            auDeviceID[MAX_CHANNELS];

    // Open in MIDI_IO_CONTROL -- only allows reconfigure message. This MUST
    // ALWAYS succeed so we have a chance of recovery on reconfigure no matter
    // how badly messed up the old config was.
    //
    if (!(fdwOpen & MIDI_IO_CONTROL))
    {
        if (IS_DEVSOPENED)
            return MMSYSERR_ALLOCATED;
        
        // Mapper is single instance now
        //
        assert(NULL == gpinstanceList);
    }
    else
    {
        if (NULL != gpIoctlInstance)
            return MMSYSERR_ALLOCATED;
    }
    
#ifdef DEBUG
    if (fdwOpen & MIDI_IO_COOKED)
        DPF(2, TEXT ("Mapper opened in polymsg mode!!!"));
#endif
    
    // Alloc this zero-init so all the initial channel mappings in
    // rgpChannel are NULL.
    //
    if (NULL == (pinstance = (PINSTANCE)LocalAlloc(LPTR, sizeof(INSTANCE))))
        return MMSYSERR_NOMEM;

    pinstance->hmidi        = lpmidiopendesc->hMidi;
    pinstance->dwCallback   = lpmidiopendesc->dwCallback;
    pinstance->dwInstance   = lpmidiopendesc->dwInstance;
    pinstance->fdwOpen      = fdwOpen;

		// Create Translation buffer
	if (! InitTransBuffer (pinstance))
	{
		LocalFree ((HGLOBAL)pinstance);
		return MMSYSERR_NOMEM;
	}

    if (fdwOpen & MIDI_IO_CONTROL)
    {
        *lpdwInstance = (DWORD_PTR)pinstance;

        gpIoctlInstance = pinstance;
        
        DriverCallback(
                       pinstance->dwCallback,
                       HIWORD(pinstance->fdwOpen),
                       (HDRVR)(pinstance->hmidi),
                       MM_MOM_OPEN,
                       pinstance->dwInstance,
                       0L,
                       0L);        


        return MMSYSERR_NOERROR;
    }
    

    DPF(2, TEXT ("modOpen pinstance %04X"), (WORD)pinstance);

    *lpdwInstance = 0;   // Assume failure

    if (IS_CONFIGERR)
    {
        DPF(1, TEXT ("Open failed because configuration invalid"));
        mmrc = MIDIERR_NOMAP;
		goto midi_Out_Open_Cleanup;
    }

	if (fdwOpen & MIDI_IO_COOKED)
	{
		// Build list of device ID's (stream id's emuerate ports) and
		// assign stream id's to channels.
		//
		for (idx = 0, pport = gpportList; pport; idx++,pport=pport->pNext)
		{
			auDeviceID[idx] = pport->uDeviceID;
			for (idx2 = 0; idx2 < MAX_CHANNELS; idx2++)
				if (gapChannel[idx2] && gapChannel[idx2]->pport == pport)
					gapChannel[idx2]->dwStreamID = (DWORD)idx;
		}

		// Attempt to open.
		//
		mmrc = midiStreamOpen(&ghMidiStrm, auDeviceID, idx, (DWORD_PTR)modmCallback, 0L, CALLBACK_FUNCTION);

		// Fall through to cleanup code
		// 
	}
	else
	{
		// Run through the port list and try to open all referenced ports 
		//
		for (pport = gpportList; pport; pport=pport->pNext)
		{
			if (NULL == pport->hmidi)
			{
				mmrc = midiOutOpen(&pport->hmidi,
								   pport->uDeviceID,
								   (DWORD_PTR)modmCallback,
								   (DWORD_PTR)pport,
								   CALLBACK_FUNCTION|MIDI_IO_SHARED);

				if (MMSYSERR_NOERROR != mmrc)
				{
					DPF(1, TEXT ("Could not open pport %04X device %u"), (WORD)pport, pport->uDeviceID);

					// Just in case....
					//
					pport->hmidi = NULL;

					for (pport = gpportList; pport; pport=pport->pNext)
						if (NULL != pport->hmidi)
						{
							midiOutClose(pport->hmidi);
							pport->hmidi = NULL;
						}

					// Return whatever caused the underlying open to fail
					//
					break;
				}
			}
		}
	}
    
midi_Out_Open_Cleanup:
	if (MMSYSERR_NOERROR != mmrc)
	{
			// Cleanup
		CleanupTransBuffer (pinstance);
		if (pinstance) LocalFree((HLOCAL)pinstance);
		return mmrc;
	}

    gdwVolume = 0xFFFFFFFFL;
    
	SET_DEVSOPENED;
	
    // We've succeeded; put the instance into the global instance list
    // and return it as our instance data.
    //
    pinstance->pNext = gpinstanceList;
    gpinstanceList = pinstance;

    *lpdwInstance = (DWORD_PTR)pinstance;
    

    // Lock the segments we need. If we're doing packed mode mapping,
    // we don't need the cooked mode segment in memory. However, the
    // cooked mode mapper DOES call the packed routines, so we need to
    // lock both in that case.
    //
    if (fdwOpen & MIDI_IO_COOKED)
    {
		LockMapperData();
		LockPackedMapper();
		LockCookedMapper();
    }
    else
    {
		LockMapperData();
		LockPackedMapper();
    }

    // Do the (useless) callback
    //
    DriverCallback(
        pinstance->dwCallback,
        HIWORD(pinstance->fdwOpen),
        (HDRVR)(pinstance->hmidi),
        MM_MOM_OPEN,
        pinstance->dwInstance,
        0L,
        0L);        
                   
    
    return MMSYSERR_NOERROR;
}

/***************************************************************************
  
   @doc internal
  
   @api DWORD | modPrepare | Handles the MODM_PREPARE message.

   @parm LPMIDIHDR | lpmh | The user header to prepare.
  
   @rdesc Some MMSYSERR_xxx code.

   @comm

     Create some shadow headers.

     For the case of mapper opened for stream
      we only require one shadow header that we can pass along to our
      mapped-to stream. We need this because the mapped-to stream and
      the mapped-from stream will both want to use the dwReserved[]
      fields in the MIDIHDR.

     For the case of mapper opened not-for-stream
      This must be a long message header that we want to propogate to all
      ports. Therefore we have gcPorts shadow headers and each one is
      prepared on one node of the global port list.

     In either case, we return MMSYSERR_NOTSUPPORTED on success so that
      MMSYSTEM will take its default action and page lock the user MIDIHDR
      for us.
       
***************************************************************************/
DWORD FNGLOBAL modPrepare(
    LPMIDIHDR           lpmh)
{
    LPMIDIHDR           lpmhNew;
    LPMIDIHDR           lpmhWork;
    MMRESULT            mmrcRet         = MMSYSERR_NOERROR;
    PPORT               pport;
    PPORT               pportWork;
    PSHADOWBLOCK        psb             = NULL;

    psb = (PSHADOWBLOCK)LocalAlloc(LPTR, sizeof(*psb));
    if (NULL == psb)
    {
        mmrcRet = MMSYSERR_NOMEM;
        goto modPrepare_Cleanup;
    }
            
    psb->cRefCnt = 0;
    psb->dwBufferLength = lpmh->dwBufferLength;
    
    if (ghMidiStrm)
    {
        psb->lpmhShadow = (LPMIDIHDR)GlobalAllocPtr(
            GMEM_MOVEABLE|GMEM_SHARE,
            sizeof(*lpmhNew));
        
        if (NULL == psb->lpmhShadow)
        {
            mmrcRet = MMSYSERR_NOMEM;
            goto modPrepare_Cleanup;
        }

        lpmhNew = psb->lpmhShadow;
        *lpmhNew = *lpmh;

        lpmhNew->dwReserved[MH_SHADOWEE] = (DWORD_PTR)lpmh;
        lpmh->dwReserved[MH_SHADOW] = (DWORD_PTR)psb;

        lpmhNew->dwFlags |= MHDR_SHADOWHDR;

        mmrcRet = midiOutPrepareHeader((HMIDIOUT)ghMidiStrm, 
                                       lpmhNew, 
                                       sizeof(*lpmhNew));
        if (MMSYSERR_NOERROR != mmrcRet)
            lpmh->dwReserved[MH_SHADOW] = 0;
    }
    else
    {
        LPMIDIHDR31         lpmh31  = (LPMIDIHDR31)lpmh;
        
        // Prepare shadow headers for sending to multiple non-stream
        // drivers
        //
        // NOTE: The parent header is a 3.1 style header; the children
        // are 4.0 and thus are longer.
        //

        psb->lpmhShadow = (LPMIDIHDR)GlobalAllocPtr(
            GMEM_MOVEABLE|GMEM_SHARE|GMEM_ZEROINIT,
            sizeof(*lpmhNew)*gcPorts);
        
        if (NULL == psb->lpmhShadow)
        {
            mmrcRet = MMSYSERR_NOMEM;
            goto modPrepare_Cleanup;
        }

        lpmhNew = psb->lpmhShadow;
        lpmhWork = lpmhNew;
        for (pport = gpportList; pport; pport = pport->pNext, lpmhWork++)
        {
            *(LPMIDIHDR31)lpmhWork = *lpmh31;
            lpmhWork->dwFlags |= MHDR_SHADOWHDR;
            
            mmrcRet = midiOutPrepareHeader(pport->hmidi,
                                        lpmhWork,
                                        sizeof(*lpmhWork));
            if (MMSYSERR_NOERROR != mmrcRet)
            {
                lpmhWork = lpmhNew;
                for (pportWork = gpportList; pportWork != pport; pportWork = pportWork->pNext, lpmhWork++)
                    midiOutUnprepareHeader(pport->hmidi, lpmhWork, sizeof(*lpmhWork));

                goto modPrepare_Cleanup;
            }

            lpmhWork->dwReserved[MH_SHADOWEE] = (DWORD_PTR)lpmh31;
        }

        DPF(1, TEXT ("Prepare: User header %p  Shadow %p"), lpmh, lpmhNew);

        lpmh31->reserved = (DWORD_PTR)psb;
    }

    // This will force MMSYSTEM to do default prepare on the parent header --
    // i.e. page lock it for us.
    //
modPrepare_Cleanup:
    if (MMSYSERR_NOERROR != mmrcRet)
    {
        if (psb)
        {
            if (psb->lpmhShadow) GlobalFreePtr(psb->lpmhShadow);
            LocalFree((HLOCAL)psb);
        }
    }
    
    return (MMSYSERR_NOERROR != mmrcRet) ? mmrcRet : MMSYSERR_NOTSUPPORTED;
}

/***************************************************************************
  
   @doc internal
  
   @api DWORD | modUnprepare | Handles the MODM_UNPREPARE message.

   @parm LPMIDIHDR | lpmh | The user header to unprepare.
  
   @rdesc Some MMSYSERR_xxx code.

   @comm

     Fully undo the effects of the modPrepare call.

     Unprepare and free all shadow headers.

     Return MMSYSERR_NOTSUPPORTED so MMSYSTEM will correctly handle the
      final unprepare of the user header.
       
***************************************************************************/
DWORD FNGLOBAL modUnprepare( 
    LPMIDIHDR           lpmh)
{
    LPMIDIHDR           lpmhNew;
    MMRESULT            mmrc;
    PPORT               pport;
    PSHADOWBLOCK        psb;
    
    if (ghMidiStrm)
    {
        psb = (PSHADOWBLOCK)(UINT_PTR)lpmh->dwReserved[MH_SHADOW];
        lpmhNew = psb->lpmhShadow;

        lpmhNew->dwBufferLength = psb->dwBufferLength;
        mmrc = midiOutUnprepareHeader((HMIDIOUT)ghMidiStrm, 
                                      lpmhNew, 
                                      sizeof(*lpmhNew));
        if (MMSYSERR_NOERROR != mmrc)
            return mmrc;

        LocalFree((HLOCAL)psb);
        GlobalFreePtr(lpmhNew);
        lpmh->dwReserved[MH_SHADOW] = 0;
    }
    else
    {
        LPMIDIHDR31         lpmh31  = (LPMIDIHDR31)lpmh;

        psb = (PSHADOWBLOCK)(UINT_PTR)lpmh31->reserved;
        lpmhNew = psb->lpmhShadow;

        for (pport = gpportList; pport; pport = pport->pNext, ++lpmhNew)
        {
            lpmhNew->dwBufferLength = psb->dwBufferLength;
            midiOutUnprepareHeader(pport->hmidi, lpmhNew, sizeof(*lpmhNew));
        }

        GlobalFreePtr(psb->lpmhShadow);
        LocalFree((HLOCAL)psb);

        lpmh31->reserved = 0;
    }
    
    // Need the default action of unprepare in MMSYSTEM here
    //
    return MMSYSERR_NOTSUPPORTED;
}

/***************************************************************************
  
   @doc internal
  
   @api DWORD | modClose | Handles the MODM_CLOSE message.

   @parm PINSTANCE | pinstance | Pointer to an open instance to close.
  
   @rdesc Some MMSYSERR_xxx code.
       
***************************************************************************/
DWORD FNGLOBAL modClose(
    PINSTANCE       pinstance)
{
    PPORT           pport;

    DPF(1, TEXT ("Mapper close"));
    // Close underlying streams on the query can-close (which is first)
    // and just succeed the actual close
    //

    assert(pinstance);

    if (pinstance->fdwOpen & MIDI_IO_CONTROL)
    {
        assert(pinstance == gpIoctlInstance);
        
        gpIoctlInstance = NULL;
        goto modClose_Cleanup;
    }
    
	// Assert that we're the only thing in the instance list
	//
	assert(gpinstanceList == pinstance);
	assert(pinstance->pNext == NULL);

	gpinstanceList = NULL;

    if (pinstance->fdwOpen & MIDI_IO_COOKED)
		UnlockCookedMapper();
	
	UnlockMapperData();
	UnlockPackedMapper();

	if (ghMidiStrm)
	{
		midiStreamClose(ghMidiStrm);
		ghMidiStrm = NULL;
	}
	else
	{
		for (pport = gpportList; pport; pport = pport->pNext)
		{
			if (NULL != pport->hmidi)
			{
				midiOutClose(pport->hmidi);
				pport->hmidi = NULL;
			}
		}
	}
        
    CLR_DEVSOPENED;
   
    // If reconfigure due, do it!
    //
    if (IS_RECONFIGURE)
    {
				// Prevent Synchronization problems
				// During Configuration
        if (NULL != hMutexConfig)
			WaitForSingleObject (hMutexConfig, INFINITE);

        DPF(1, TEXT ("Delayed reconfigure now being done"));
        UpdateInstruments(FALSE, 0);

        if (NULL != hMutexConfig)
			ReleaseMutex (hMutexConfig);
        
		CLR_RECONFIGURE;

    }
    

modClose_Cleanup:
    DriverCallback(
        pinstance->dwCallback,
        HIWORD(pinstance->fdwOpen),
        (HDRVR)(pinstance->hmidi),
        MM_MOM_CLOSE,
        pinstance->dwInstance,
        0L,
        0L);        
    
    // Free up instance memory.
    //
	CleanupTransBuffer (pinstance);
    LocalFree((HLOCAL)pinstance);

    return MMSYSERR_NOERROR;
}

/***************************************************************************
  
   @doc internal
  
   @api DWORD | modGetPosition | Get the current position in the MIDI stream.
    
   @parm LPINSTANCE | pinstance | Stream we want the position in.

   @parm LPMMTIME | lpmmt | Pointer to a standard MMTIME struct to fill in.

   @parm DWORD | cbmmt | Size of the MMTIME structure passed.

   @comment
     Pass the structure along to the first open subsidiary stream.
     This will be considered the de facto timebase until there's a
     way to set it.

   @rdesc MMSYSERR_xxx       
***************************************************************************/
DWORD FNGLOBAL modGetPosition(
    PINSTANCE           pinstance,
    LPMMTIME            lpmmt,
    DWORD               cbmmt)
{
    return midiStreamPosition(ghMidiStrm,
                              lpmmt,
                              (UINT)cbmmt);
}

DWORD FNGLOBAL modSetVolume(         
    DWORD               dwVolume)
{
    PPORT               pport;
    MMRESULT            mmrc;
    MMRESULT            mmrc2;
    
    // Walk the port list and send the volume change to everyone
    //

    mmrc2 = MMSYSERR_NOERROR;
    for (pport = gpportList; pport; pport = pport->pNext)
    {
        mmrc = midiOutSetVolume(pport->hmidi, dwVolume);
        if (MMSYSERR_NOERROR != mmrc)
            mmrc2 = mmrc;
    }

    return mmrc2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\regfix.c ===
/* Copyright (c) 1995 Microsoft Corporation */
/*
**-----------------------------------------------------------------------------
**	File:		RegFix.c
**	Purpose:	Fix up various registry settings for MidiMapper
**	Mod Log:	Created by Shawn Brown (11/14/95)
**-----------------------------------------------------------------------------
*/

/*
**-----------------------------------------------------------------------------
**	Includes
**-----------------------------------------------------------------------------
*/
#include "RegFix.h"



/*
**-----------------------------------------------------------------------------
**	Local Prototypes
**-----------------------------------------------------------------------------
*/

BOOL CheckMidiOK (void);
BOOL SetMidiOK (BOOL fOK);

BOOL CheckMidiHeader (void);
BOOL CheckMidiSchemes (void);
BOOL CheckMidiDrivers (void);

BOOL CreateDefMidiHeader (void);
BOOL CreateDefMidiSchemes (void);
BOOL CreateDefMidiDrivers (void);


/*
**-----------------------------------------------------------------------------
**	Local Variables
**-----------------------------------------------------------------------------
*/

	// Consider - revisit these and make them use the appropriate roots 
	//			from regstr.h
static const TCHAR l_aszMidiMapKey[]	= TEXT ("Software\\Microsoft\\Multimedia\\MidiMap");

static const TCHAR l_aszMediaPropKey[]	= TEXT ("System\\CurrentControlSet\\Control\\MediaProperties");
static const TCHAR l_aszMediaRsrcKey[]	= TEXT ("System\\CurrentControlSet\\Control\\MediaResources");

static const TCHAR l_aszMRMidiKey[]		= TEXT ("System\\CurrentControlSet\\Control\\MediaResources\\Midi");

static const TCHAR l_aszSchemesKey[]	= TEXT ("System\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\MIDI\\Schemes");

static const TCHAR l_aszMediaKey[]		= TEXT ("Media");
static const TCHAR l_aszMIDIKey[]		= TEXT ("Midi");
static const TCHAR aszInstrumentKey[]	= TEXT ("Instruments");
static const TCHAR aszDrvMIDIKey[]		= TEXT ("Drivers\\MIDI");
static const TCHAR aszPrivateKey[]		= TEXT ("Private Properties");
static const TCHAR aszDefaultKey[]		= TEXT ("Default");

static const TCHAR aszMigratedVal[]		= TEXT ("Migrated");

static const TCHAR aszMIDI[]			= TEXT ("MIDI");
static const TCHAR aszNULL[]			= TEXT ("");

static const TCHAR l_aszOK[]			= TEXT ("Validate");

static const TCHAR aszActiveVal[]		= TEXT ("Active");
static const TCHAR aszDescripVal[]		= TEXT ("Description");
static const TCHAR aszDeviceIDVal[]		= TEXT ("DeviceID");
static const TCHAR aszDevNodeVal[]		= TEXT ("DevNode");
static const TCHAR aszDriverVal[]		= TEXT ("Driver");
static const TCHAR aszFriendlyVal[]		= TEXT ("FriendlyName");
static const TCHAR aszMapCfgVal[]		= TEXT ("MapperConfig");
static const TCHAR aszSoftwareVal[]		= TEXT ("SOFTWAREKEY");

static const TCHAR aszInstallerVal[]	= TEXT ("Installer");
static const TCHAR aszChannelsVal[]		= TEXT ("Channels");

static const TCHAR aszMIDIClass[]		= TEXT ("Midi");
static const TCHAR aszAuxClass[]		= TEXT ("Aux");
static const TCHAR aszWaveClass[]		= TEXT ("Wave");
static const TCHAR aszMixerClass[]		= TEXT ("Mixer");

static const TCHAR aszOne[]				= TEXT ("1");
static const TCHAR aszZeroZeroKey[]		= TEXT ("00");



/*
**-----------------------------------------------------------------------------
**	Name:       CheckRegistry
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/

BOOL CheckRegistry (BOOL fForceUpdate)
{
	if (!fForceUpdate)
	{
			// Check OK flag
		if (CheckMidiOK())
			return TRUE;
	}

		// Fix up Header
	if (! CheckMidiHeader())
		return FALSE;

		// Fix up schemes
	if (! CheckMidiSchemes ())
		return FALSE;

		// Fix up drivers
	if (! CheckMidiDrivers ())
		return FALSE;

		// All done, set OK flag
	SetMIDIOK (TRUE);

	return TRUE;
}



/*
**-----------------------------------------------------------------------------
**	Name:       CheckMidiOK
**  Purpose:	Simple quick check to see if everything is OK
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/

BOOL CheckMidiOK (void)
{
	HKEY	hKey;
	LONG	lResult;
	DWORD	dwType;
	DWORD	dwVal;
	DWORD	cbSize;

	lResult = RegOpenEx (HKEY_CURRENT_USER, l_aszMidiMapKey,
						 0, KEY_ALL_ACCESS, &hKey);
	if (ERROR_SUCCESS != lResult)
		return FALSE;

	dwType = REG_DWORD;
	cbSize = sizeof (DWORD);
	lResult = RegQueryValueEx (hKey, l_aszOK, NULL, &dwType,
							   (LPBYTE)(LPDWORD)&dwVal, &cbSize);
	if (ERROR_SUCCESS != lResult)
	{
		RegCloseKey (hKey);
		return FALSE;
	}
	RegCloseKey (hKey);

	if (0 == dwVal)
		return FALSE;

	return TRUE;
} // End CheckMidiOK


  
/*
**-----------------------------------------------------------------------------
**	Name:       SetMidiOK
**  Purpose:	Set OK value
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/

BOOL SetMidiOK (BOOL fOK)
{
	HKEY	hKey;
	LONG	lResult;
	DWORD	dwType;
	DWORD	dwVal;
	DWORD	cbSize;

	lResult = RegOpenEx (HKEY_CURRENT_USER, l_aszMidiMapKey,
						 0, KEY_ALL_ACCESS, &hKey);
	if (ERROR_SUCCESS != lResult)
		return FALSE;

	dwType	= REG_DWORD;
	dwVal	= (DWORD)fOK;
	cbSize	= sizeof (DWORD);
	lResult = RegSetValueEx (hKey, l_aszOK, 0, &dwType, 
							(LPBYTE)(LPDWORD)&dwVal, &cbSize);
	if (ERROR_SUCCESS != lResult)
	{
		RegCloseKey (hKey);
		return FALSE;
	}
	RegCloseKey (hKey);

	return TRUE;
} // End SetMidiOK



/*
**-----------------------------------------------------------------------------
**	Name:       CheckHeader
**  Purpose:	do we have a valid Midi Header ?!?
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/
 
BOOL CheckMidiHeader (void)
{
	return CreateDefMidiHeader ();
} // End CheckMidiHeader

  

/*
**-----------------------------------------------------------------------------
**	Name:       CreateDefMidiHeader
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/
 
BOOL CreateDefaultHeader (void)
{
} // End CreateDefaultHeader


  
/*
**-----------------------------------------------------------------------------
**	Name:       IsMIDIDriver
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/

BOOL IsMIDIDriver (
	LPCTSTR pszDriverName)		// IN:	driver name
{
	UINT cNumDrivers;
	UINT ii;
	TCHAR	szDriver[MAX_PATH];

		// Look for the MIDI driver
	cNumDrivers = midiOutGetNumDevs ();
	for (ii = 0; ii < cNumDrivers; ii++)
	{
		if (! GetDriverName (aszMIDI, ii, szDriver, MAX_PATH))
			continue;

		if (0 == lstrcmpi (pszDriverName, szDriver))
			return TRUE;
	} // End for

		// Look for the MIDI driver
	cNumDrivers = midiInGetNumDevs ();
	for (ii = 0; ii < cNumDrivers; ii++)
	{
		if (! GetDriverName (aszMIDI, ii, szDriver, MAX_PATH))
			continue;

		if (0 == lstrcmpi (pszDriverName, szDriver))
			return TRUE;
	} // End for

	return FALSE;
} // End IsMIDIDriver
  


/*
**-----------------------------------------------------------------------------
**	Name:       IsMigrated
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/

BOOL IsMigrated (UINT uDeviceID)
{
	TCHAR szDriver[MAX_PATH];
	TCHAR szBuffer[MAX_PATH];
	HKEY  hDriverKey;
	DWORD cbSize;

		// Get Driver 
	if (! GetDriverName (aszMIDI, uDeviceID, szDriver, MAX_PATH))
		return FALSE;

		// Open Driver Key
	wsprintf (szBuffer, TEXT ("%s\\%s<%04ld>"), aszMRMidiKey, szDriver, uDeviceID);
	if (ERROR_SUCCESS != RegOpenKeyEx (HKEY_LOCAL_MACHINE, szBuffer,
									   0, KEY_ALL_ACCESS, &hDriverKey))
		return FALSE;

		// Get Migrated Value
		// The mere existence of the Migrated value indicates
		// we have already successfully migrated this driver
	cbSize = sizeof(szBuffer);
	if (ERROR_SUCCESS != RegQueryValueEx (hDriverKey, aszMigratedVal, 
										  NULL, NULL, (LPBYTE)szBuffer, &cbSize))
	{
		RegCloseKey (hDriverKey);
		return FALSE;
	}

	RegCloseKey (hDriverKey);

	return TRUE;
} // End IsMigrated

  

/*
**-----------------------------------------------------------------------------
**	Name:       MigrateNewMIDIDriver
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/
  
BOOL MigrateNewMIDIDriver (
	UINT uDeviceID)				// IN: MIDI Driver device ID
{
	TCHAR		szDriver[MAX_PATH];
	TCHAR		szFriend[MAX_PATH];
	TCHAR		szDescrip[MAX_PATH];
	TCHAR		szBuffer[MAX_PATH];	
	DWORD		cOut;
	MIDIOUTCAPS moc;
	DWORD		dwDisposition;
	DWORD		cbSize;
	DWORD		dwVal;
	HKEY		hMIDIKey		= NULL;
	HKEY		hDriverKey		= NULL;
	HKEY		hInstrumentKey	= NULL;
	HKEY		hKey			= NULL;
	BOOL		fResult = FALSE;

	cOut = midiOutGetNumDevs ();
	if (uDeviceID >= cOut)
		return FALSE;

		// Get Driver
	if (! GetDriverName (aszMIDI, uDeviceID, szDriver, MAX_PATH))
		return FALSE;

		// Get Friendly Name
	if (! GetDriverFriendlyName (aszMIDI, uDeviceID, szFriend, MAX_PATH))
	{
		lstrcpy (szFriend, szDriver);
	}

		// Get Description
	if (MMSYSERR_NOERROR != midiOutGetDevCaps (uDeviceID, &moc, sizeof(moc)))
		return FALSE;

	if (moc.szPname[0] == 0)
	{
		lstrcpy (szDescrip, szDriver);
	}
	else
	{
		lstrcpy (szDescrip, moc.szPname);
	}

		// Open key, create it if it doesn't already exist
	if (ERROR_SUCCESS != RegCreateKeyEx (HKEY_LOCAL_MACHINE, aszMRMidiKey,
										 0, NULL, 0, KEY_ALL_ACCESS, NULL, 
										 &hMIDIKey, NULL))
	{
		return FALSE;
	}

		// Create new driver key
	wsprintf (szBuffer, TEXT ("%s<%04ld>"), szDriver, uDeviceID);
	if (ERROR_SUCCESS != RegCreateKeyEx (hMIDIKey, szBuffer,
										 0, NULL, 0, KEY_ALL_ACCESS, NULL,
										 &hDriverKey, &dwDisposition))
	{
		goto lblCLEANUP;
	}
	RegCloseKey (hMIDIKey);
	hMIDIKey = NULL;


		//
		// Set Driver Values
		//


		// Set Active = "1" value
	cbSize = sizeof (aszOne);	
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszActiveVal, 0, 
										REG_SZ, (LPBYTE)aszOne, cbSize))
	{
		goto lblCLEANUP;
	}

		// Set Description = szDescrip value
	cbSize = (lstrlen (szDescrip) + 1) * sizeof(TCHAR);	
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszDescripVal, 0, 
										REG_SZ, (LPBYTE)szDescrip, cbSize))
	{
		goto lblCLEANUP;
	}

		// Set DeviceID = "" value
	cbSize = (lstrlen (aszNULL) + 1) * sizeof(TCHAR);
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszDeviceIDVal, 0, 
										REG_SZ, (LPBYTE)aszNULL, cbSize))
	{
		goto lblCLEANUP;
	}

		// Set DevNode =  value
	cbSize = 0;
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszDeviceIDVal, 0, 
										REG_BINARY, (LPBYTE)NULL, cbSize))
	{
		goto lblCLEANUP;
	}

		// Set Driver =  szDriver
	cbSize = (lstrlen (szDriver) + 1) * sizeof(TCHAR);
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszDriverVal, 0, 
										REG_SZ, (LPBYTE)szDriver, cbSize))
	{
		goto lblCLEANUP;
	}

		// Set FriendlyName
	cbSize = (lstrlen (szFriend) + 1) * sizeof(TCHAR);
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszFriendlyVal, 0, 
										REG_SZ, (LPBYTE)szFriend, cbSize))
	{
		goto lblCLEANUP;
	}

		// Set Mapper Config
	cbSize = sizeof(DWORD);
	dwVal = 0;
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszMapCfgVal, 0, 
										REG_DWORD, (LPBYTE)&dwVal, cbSize))
	{
		goto lblCLEANUP;
	}

		// Set SOFTWARE value
	wsprintf (szBuffer, TEXT("%s\\%04ld"), aszServiceKey, uDeviceID);
	cbSize = (lstrlen (szBuffer) + 1) * sizeof(TCHAR);
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszSoftwareVal, 0, 
										REG_SZ, (LPBYTE)szBuffer, cbSize))
	{
		goto lblCLEANUP;
	}

		// Create Instruments Key
	if (ERROR_SUCCESS != RegCreateKeyEx (hDriverKey, aszInstrumentKey, 0, NULL, 
										0, KEY_ALL_ACCESS, NULL,
										&hInstrumentKey, &dwDisposition))
	{
		goto lblCLEANUP;
	}
	RegCloseKey (hInstrumentKey);
	hInstrumentKey = NULL;


		// Create Services\Class\Media\0001\Drivers\midi key
		// Open key, create it if it doesn't already exist
//	wsprintf (szBuffer, TEXT("%s\\%04ld\\%s"), aszServiceKey, uDeviceID, aszDrvMIDIKey);
//	if (ERROR_SUCCESS != RegCreateKeyEx (HKEY_LOCAL_MACHINE, szBuffer,
//										 0, NULL, 0, KEY_ALL_ACCESS, NULL, 
//										 &hMIDIKey, NULL))
//	{
//		goto lblCLEANUP;
//	}

		// Create 

		// Set MIGRATED value
		// NOTE: this is always the very last thing to do to indicate successful migration
	cbSize = (lstrlen (aszOne) + 1) * sizeof(TCHAR);
	if (ERROR_SUCCESS != RegSetValueEx (hDriverKey, aszMigratedVal, 0, REG_SZ, (LPBYTE)aszOne, cbSize))
	{
		goto lblCLEANUP;
	}

			// Success
	fResult = TRUE;

lblCLEANUP:
	if (hInstrumentKey)
		RegCloseKey (hInstrumentKey);

	if (hDriverKey)
		RegCloseKey (hDriverKey);

	if (hMIDIKey)
		RegCloseKey (hMIDIKey);

	return fResult;
} // End MigrateNewMIDIDriver


  
/*
**-----------------------------------------------------------------------------
**	Name:       CreateDefaultMIDISchemes
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/

BOOL CreateDefaultMIDISchemes (void)
{
	HKEY hSchemeKey;
	HKEY hDefaultKey;
	HKEY hZeroKey;
	DWORD dwVal;
	DWORD cbSize;


		// Create MIDI Schemes key
	if (ERROR_SUCCESS != RegCreateKeyEx (HKEY_LOCAL_MACHINE, aszMIDISchemesKey,
										 0, NULL, 0, KEY_ALL_ACCESS, NULL, 
										 &hSchemeKey, NULL))
	{
		return FALSE;
	}


		// Create Default Key
	if (ERROR_SUCCESS != RegCreateKeyEx (hSchemeKey, aszDefaultKey,
										 0, NULL, 0, KEY_ALL_ACCESS, NULL, 
										 &hDefaultKey, NULL))
	{
		RegCloseKey (hSchemeKey);
		return FALSE;
	}
	RegCloseKey (hSchemeKey);


		// Create 00 Key
	if (ERROR_SUCCESS != RegCreateKeyEx (hDefaultKey, aszZeroZeroKey,
										 0, NULL, 0, KEY_ALL_ACCESS, NULL, 
										 &hZeroKey, NULL))
	{
		RegCloseKey (hDefaultKey);
		return FALSE;
	}
	RegCloseKey (hDefaultKey);


		// Create Default Channels Value
	dwVal = 0x0000FFFF;
	cbSize = sizeof(DWORD);
	if (ERROR_SUCCESS != RegSetValueEx (hZeroKey, aszChannelsVal, 0, 
										REG_DWORD, (LPBYTE)&dwVal, cbSize))
	{
		RegCloseKey (hZeroKey);
		return FALSE;
	}
	RegCloseKey (hZeroKey);

		// Success
	return TRUE;
} // End CreateDefaultMIDISchemes


  
  
/*
**-----------------------------------------------------------------------------
**	Name:       MigrateExistingMIDISchemes
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/

BOOL MigrateExistingMIDISchemes (void)
{
	return TRUE;
} // End MigrateExistingMIDISchemes

  

/*
**-----------------------------------------------------------------------------
**	Name:       MigrateMIDIDrivers
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/
  
BOOL MigrateMIDIDrivers (void)
{
	UINT cOut;
	UINT ii;
	BOOL fResult = TRUE;

	if (! CreateDefaultMIDISchemes ())
	{
		return FALSE;
	}

	if (! MigrateExistingMIDISchemes ())
	{
		return FALSE;
	}

	cOut = midiOutGetNumDevs ();
	if (cOut == 0L)
		return FALSE;

	for (ii = 0; ii < cOut; ii++)
	{
		if (IsMigrated (ii))
			continue;

		if (! MigrateNewMIDIDriver (ii))
			fResult = FALSE;
	}

	return fResult;

} // End MigrateMIDIDrivers


  
/*
**-----------------------------------------------------------------------------
**	Name:       DumpDeviceCaps
**  Purpose:
**  Mod Log:    Created by Shawn Brown (11/95)
**-----------------------------------------------------------------------------
*/

BOOL DumpMidiOutDeviceCaps (UINT uDeviceID, LPSTR pszBuff, UINT cchLen)
{
	static const aszMMicrosoft[] = TEXT ("Microsoft(TM)");
	static const aszMMUnknown[]	 = 

	MIDIOUTCAPS moc;
	MMRESULT	mmr;
	DWORD		wMid;
	DWORD		wPid;
	DWORD		dwVerHigh, dwVerLow;
	LPTSTR		pszName;
    WORD		wTechnology; 
    WORD		wVoices; 
    WORD		wNotes; 
    WORD		wChannelMask; 
    DWORD		dwSupport; 

	mmr = midiOutGetDevCaps (uDeviceId, &moc, sizeof(moc));
	if (MMSYSERR_NOERROR != mmr)
		return FALSE;

	
	
	

	return TRUE;
} // End DumpDeviceCaps



/*
**-----------------------------------------------------------------------------
** End of File
**-----------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\midimap\wassert.h ===
// Copyright (c) 1995 Microsoft Corporation
/*
 * Define the assert() macro for windows apps.
 *
 * The macro will only be expanded to a function call if DEBUG is 
 * defined.
 *
 */

#undef  assert

#ifndef DEBUG

#define assert(exp) ((void)0)

#else 

void FAR PASCAL WinAssert
(
    LPSTR       lpstrModule,
    LPSTR       lpstrFile,
    DWORD       dwLine
);

#define assert(exp) \
    ( (exp) ? (void) 0 : WinAssert(#exp, __FILE__, __LINE__) )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mixerapp\dlg.h ===
// Copyright (c) 1995-1998 Microsoft Corporation

#define IDOFFSET   1000

LPBYTE  Dlg_HorizDupe (LPBYTE lpSrc, DWORD cbSrc, int cDups,  DWORD *pcbNew);
HGLOBAL Dlg_LoadResource (HINSTANCE hModule, LPCTSTR lpszName, DWORD *pcbSize);
DWORD   Dlg_CopyDLGITEMTEMPLATE (LPBYTE lpDst, LPBYTE lpSrc, WORD wIdOffset,short xOffset, short yOffset, BOOL bDialogEx);
DWORD   Dlg_CopyDLGTEMPLATE (LPBYTE lpDst, LPBYTE lpSrc, BOOL bDialogEx);
LPBYTE  Dlg_HorizAttach (LPBYTE lpMain, DWORD cbMain, LPBYTE lpAdd, DWORD cbAdd, WORD wIdOffset, DWORD *pcbNew);
DWORD Dlg_HorizSize(LPBYTE lpDlg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mixerapp\helpids.h ===
// Copyright (c) 1995-1998 Microsoft Corporation
#define IDH_SNDVOL32_SELECT_DEVICE			4300
#define IDH_SNDVOL32_SELECT_SOUND			4301
#define IDH_SNDVOL32_VOLCONTROL			4302
#define IDH_SNDVOL32_OPTIONS_PROPERTIES		4303
#define IDH_SNDVOL32_OPTIONS_ADVANCED_CONTROLS	4304
#define IDH_SNDVOL32_OPTIONS_EXIT			4305
#define IDH_SNDVOL32_HELP_HELP_TOPICS		4306
#define IDH_SNDVOL32_HELP_ABOUT			4307
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mixerapp\mixer.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       mixer.c
 *  Purpose:    mixer api specific implementations
 *
 *  Copyright (c) 1985-1999 Microsoft Corporation
 *
 *****************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <commctrl.h>

#include <math.h>
#include "volumei.h"
#include "volids.h"
#include "vu.h"

extern void Mixer_Multichannel(PMIXUIDIALOG pmxud, DWORD dwVolumeID);
extern void Mixer_Advanced(PMIXUIDIALOG pmxud, DWORD dwLineID, LPTSTR szName);
extern HRESULT GetDestination(DWORD mxid, int *piDest);
extern BOOL DeviceChange_Init(HWND hWnd, DWORD dwMixerID);

/*****************************************************************************
 *
 *  INIT SPECIFIC CODE
 *
 *****************************************************************************/

/*
 * Mixer_GetNumDevs
 *
 * */
int Mixer_GetNumDevs()
{
    return mixerGetNumDevs();
}

/*
 * Mixer_GetDeviceName()
 *
 * */
BOOL Mixer_GetDeviceName(
    PMIXUIDIALOG pmxud)
{
    MIXERCAPS       mxcaps;
    MMRESULT        mmr;
    mmr = mixerGetDevCaps( pmxud->mxid, &mxcaps, sizeof(mxcaps));

    if (mmr != MMSYSERR_NOERROR)
        return FALSE;

    lstrcpy(pmxud->szMixer, mxcaps.szPname);
    return TRUE;
}


BOOL Mixer_AreChannelsAtMinimum(MIXERCONTROLDETAILS_UNSIGNED* pmcdVolume,
                                DWORD cChannels)
{
    UINT uiIndx;
    if (pmcdVolume && cChannels > 0)
    {
        for (uiIndx = 0; uiIndx < cChannels; uiIndx++)
        {
           if ((pmcdVolume + uiIndx) -> dwValue != 0)
           {
               return (FALSE);
           }
        }
        return (TRUE);      // Volume of all channels equals zero since we haven't returned yet.

    }
    else return (FALSE);

}






void Mixer_RefreshMixCache (PVOLCTRLDESC pvcd,
                            MIXERCONTROLDETAILS_UNSIGNED* pmcdVolume,
                            DWORD cChannels)
{

    if (pmcdVolume && cChannels > 0)
    {

        // Create cache if necessary
        if (!pvcd->pdblCacheMix)
            pvcd->pdblCacheMix = (double*) GlobalAllocPtr(GHND, sizeof (double) * cChannels);

        // Refresh cache
        if (pvcd->pdblCacheMix)
        {

            UINT uiIndx;
            double* pdblMixPercent;
            DWORD dwVolume;

            // Get the maximum volume
            DWORD dwMaxVol = 0;
            for (uiIndx = 0; uiIndx < cChannels; uiIndx++)
                dwMaxVol = max (dwMaxVol, (pmcdVolume + uiIndx) -> dwValue);

            // Caculate the percentage distance each channel is away from the max
            // value. Creating this cache allows us to maintain the relative distance
            // of the channel levels from each other as the user adjusts the master
            // volume level.
            for (uiIndx = 0; uiIndx < cChannels; uiIndx++)
            {
                dwVolume       = (pmcdVolume + uiIndx) -> dwValue;
                pdblMixPercent = (pvcd->pdblCacheMix + uiIndx);

                // Caculate the percentage this value is from the max ...
                if (dwMaxVol == dwVolume)
                {
                    *pdblMixPercent = 1.0F;
                }
                else
                {
                    // Note: if 0 == dwMaxVol all values would be zero and this part
                    //       of the "if" statement will never execute.
                    *pdblMixPercent = ((double) dwVolume / (double) dwMaxVol);
                }
            }
        }
    }
}

/*
 * Mixer_SetLines
 *
 * Locate mixer/mux relationships.  Fix up uninitialized volume description
 * information.
 *
 * */
static void Mixer_SetLines(
    HMIXEROBJ       hmx,
    PVOLCTRLDESC    pvcd,
    UINT            cPvcd)
{
    LPMIXERCONTROLDETAILS_LISTTEXT pmcd_lt;
    PMIXERCONTROLDETAILS_BOOLEAN pmcd_b;
    MIXERCONTROLDETAILS mxd;
    MMRESULT        mmr;
    UINT            i,j;
    MIXERLINE       mxl;
    DWORD           dwDst;

    //
    // Another test for drivers.  Some drivers (Mediavision)
    // don't return the proper destination / source index in the
    // mixerGetLineInfo call.  Tag a workaround.
    //
    mxl.cbStruct    = sizeof(mxl);
    mxl.dwLineID    = pvcd[0].dwLineID;

    mmr = mixerGetLineInfo(hmx
                           , &mxl
                           , MIXER_GETLINEINFOF_LINEID);

    if (mmr == MMSYSERR_NOERROR)
    {
        dwDst = mxl.dwDestination;
        for (i = 1; i < cPvcd; i++)
        {
            mxl.cbStruct    = sizeof(mxl);
            mxl.dwLineID    = pvcd[i].dwLineID;

            mmr = mixerGetLineInfo(hmx
                                   , &mxl
                                   , MIXER_GETLINEINFOF_LINEID);
            if (mmr != MMSYSERR_NOERROR)
            {
                pvcd[0].dwSupport |= VCD_SUPPORTF_BADDRIVER;
                break;
            }
            if (mxl.dwDestination != dwDst)
            {
                pvcd[0].dwSupport |= VCD_SUPPORTF_BADDRIVER;
                break;
            }
        }
    }

    //
    // for the first pvcd (destination), propogate the mixer/mux control
    // id's to those controls that are part of the list.  0 out the rest.
    // The UI can just do a mixerXXXControlDetails on the control ID to
    // locate the state information
    //
    if (pvcd->dwSupport & VCD_SUPPORTF_MIXER_MIXER)
    {
        pmcd_lt = GlobalAllocPtr(GHND, sizeof(MIXERCONTROLDETAILS_LISTTEXT)
                                 * pvcd->cMixer);
        pmcd_b = GlobalAllocPtr(GHND, sizeof(MIXERCONTROLDETAILS_BOOLEAN)
                                  * pvcd->cMixer);

        if (!pmcd_lt || !pmcd_b)
            return;

        mxd.cbStruct       = sizeof(mxd);
        mxd.dwControlID    = pvcd->dwMixerID;
        mxd.cChannels      = 1;
        mxd.cMultipleItems = pvcd->cMixer;
        mxd.cbDetails      = sizeof(MIXERCONTROLDETAILS_LISTTEXT);
        mxd.paDetails      = pmcd_lt;
        mmr = mixerGetControlDetails(hmx
                                     , &mxd
                                     , MIXER_GETCONTROLDETAILSF_LISTTEXT);

        if (mmr == MMSYSERR_NOERROR)
        {
            //
            // iterate over all source lines s.t. dwMixerID points to the
            // correct control id on the destination and iMixer is the
            // correct index into the value list
            //
            pvcd[0].amcd_bMixer = pmcd_b;
            for (i = 1; i < cPvcd; i++)
            {
                for (j = 0; j < pvcd->cMixer; j++)
                {
                    if (!lstrcmp(pmcd_lt[j].szName,pvcd[i].szName))
                    {
                        pvcd[i].dwMixerID   = pvcd->dwMixerID;
                        pvcd[i].iMixer      = j;
                        pvcd[i].cMixer      = pvcd->cMixer;
                        pvcd[i].dwSupport   |= VCD_SUPPORTF_MIXER_MIXER;
                        pvcd[i].dwVisible   |= VCD_VISIBLEF_MIXER_MIXER;
                        pvcd[i].dwVisible   &= ~VCD_VISIBLEF_MIXER_MUTE;
                        pvcd[i].amcd_bMixer = pmcd_b;
                    }
                }
            }
        }
        GlobalFreePtr(pmcd_lt);
    }

    if (pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUX)
    {
        pmcd_lt = GlobalAllocPtr(GHND, sizeof(MIXERCONTROLDETAILS_LISTTEXT)
                                 * pvcd->cMux);
        pmcd_b = GlobalAllocPtr(GHND, sizeof(MIXERCONTROLDETAILS_BOOLEAN)
                                * pvcd->cMux);

        if (!pmcd_lt || !pmcd_b)
            return;

        mxd.cbStruct       = sizeof(mxd);
        mxd.dwControlID    = pvcd->dwMuxID;
        mxd.cChannels      = 1;
        mxd.cMultipleItems = pvcd->cMux;
        mxd.cbDetails      = sizeof(MIXERCONTROLDETAILS_LISTTEXT);
        mxd.paDetails      = pmcd_lt;

        mmr = mixerGetControlDetails(hmx
                                     , &mxd
                                     , MIXER_GETCONTROLDETAILSF_LISTTEXT);

        if (mmr == MMSYSERR_NOERROR)
        {
            //
            // iterate over all source lines s.t. dwMuxID points to the
            // correct control id on the destination and iMux is the
            // correct index into the value list
            //
            pvcd[0].amcd_bMux = pmcd_b;
            for (i = 1; i < cPvcd; i++)
            {
                for (j = 0; j < pvcd->cMux; j++)
                {
                    if (!lstrcmp(pmcd_lt[j].szName,pvcd[i].szName))
                    {
                        pvcd[i].dwMuxID     = pvcd->dwMuxID;
                        pvcd[i].iMux        = j;
                        pvcd[i].cMux        = pvcd->cMux;
                        pvcd[i].dwSupport   |= VCD_SUPPORTF_MIXER_MUX;
                        pvcd[i].dwVisible   |= VCD_VISIBLEF_MIXER_MUX;
                        pvcd[i].dwVisible   &= ~VCD_VISIBLEF_MIXER_MUTE;
                        pvcd[i].amcd_bMux   = pmcd_b;
                    }
                }
            }
        }
        GlobalFreePtr(pmcd_lt);
    }
}

/*
 * Mixer_CheckdDriver
 *
 * Consistency check for bad mixer drivers.
 * */
static DWORD Mixer_CheckBadDriver(
    HMIXEROBJ           hmx,
    PMIXERLINECONTROLS  pmxlc,
    PMIXERCONTROL       pmxc,
    DWORD               dwControlID,
    DWORD               dwLineID)
{
    MMRESULT mmr;

    pmxlc->cbStruct     = sizeof(MIXERLINECONTROLS);
    pmxlc->dwControlID  = dwControlID;
    pmxlc->cControls    = 1;
    pmxlc->cbmxctrl     = sizeof(MIXERCONTROL);
    pmxlc->pamxctrl     = pmxc;

    mmr = mixerGetLineControls(hmx
                               , pmxlc
                               , MIXER_GETLINECONTROLSF_ONEBYID);

    if (mmr != MMSYSERR_NOERROR)
        return VCD_SUPPORTF_BADDRIVER;

    if (pmxlc->dwLineID != dwLineID)
        return VCD_SUPPORTF_BADDRIVER;

    return 0L;
}

/*
 * IsDestinationMux
 *
 * Helper function to determine if a source line has a mux on its associated
 * destination line
 *
 * */
BOOL IsDestinationMux(
    HMIXEROBJ           hmx,
    DWORD               dwLineID
)
{
    MIXERLINE           mxl;
    MIXERLINECONTROLS   mxlc;
    MIXERCONTROL        mxc;
    MMRESULT            mmr;

    DWORD           dwDst;

    mxl.cbStruct    = sizeof(mxl);
    mxl.dwLineID    = dwLineID;

    // Get the destination number for this line
    mmr = mixerGetLineInfo(hmx
                           , &mxl
                           , MIXER_GETLINEINFOF_LINEID);
    if (mmr != MMSYSERR_NOERROR)
    {
        return FALSE;
    }

    //
    // Get the LineId for this destination number
    //
    // mxl.dwDestination will been filled in by the last
    // call to mixerGetLineInfo
    //
    mmr = mixerGetLineInfo(hmx
                           , &mxl
                           , MIXER_GETLINEINFOF_DESTINATION);
    if (mmr != MMSYSERR_NOERROR)
    {
        return FALSE;
    }

    mxlc.cbStruct       = sizeof(mxlc);
    mxlc.dwLineID       = mxl.dwLineID; // use the dwLineId obtained from mixerGetLinInfo
    mxlc.dwControlType  = MIXERCONTROL_CONTROLTYPE_MUX;
    mxlc.cControls      = 1;
    mxlc.cbmxctrl       = sizeof(mxc);
    mxlc.pamxctrl       = &mxc;

    mmr = mixerGetLineControls(hmx
                               , &mxlc
                               , MIXER_GETLINECONTROLSF_ONEBYTYPE);
    if (mmr == MMSYSERR_NOERROR)
    {
        return TRUE;
    }

    return FALSE;
}

/*
 * Mixer_InitLineControls
 *
 * Initialize the mixer api specific part of the volume control description
 * mark hidden lines.
 * */
static void Mixer_InitLineControls(
    HMIXEROBJ           hmx,
    PVOLCTRLDESC        pvcd,
    DWORD               dwLineID)
{
    MIXERLINECONTROLS   mxlc;
    MIXERCONTROL        mxc;
    MMRESULT            mmr;
    int                 iType;

    const DWORD dwAdvTypes[] = {
        MIXERCONTROL_CONTROLTYPE_BOOLEAN,
        MIXERCONTROL_CONTROLTYPE_ONOFF,
        MIXERCONTROL_CONTROLTYPE_MONO,
        MIXERCONTROL_CONTROLTYPE_LOUDNESS,
        MIXERCONTROL_CONTROLTYPE_STEREOENH,
        MIXERCONTROL_CONTROLTYPE_BASS,
        MIXERCONTROL_CONTROLTYPE_TREBLE
    };


    pvcd->dwLineID      = dwLineID;
    pvcd->dwMeterID     = 0;
    pvcd->dwVolumeID    = 0;
    pvcd->dwMuteID      = 0;
    pvcd->dwMixerID     = 0;
    pvcd->dwMuxID       = 0;

    //
    // advanced controls
    //
    for (iType = 0;
         iType < SIZEOF(dwAdvTypes);
         iType++)
         {
             mxlc.cbStruct       = sizeof(mxlc);
             mxlc.dwLineID       = dwLineID;
             mxlc.dwControlType  = dwAdvTypes[iType];
             mxlc.cControls      = 1;
             mxlc.cbmxctrl       = sizeof(mxc);
             mxlc.pamxctrl       = &mxc;

             mmr = mixerGetLineControls(hmx
                                        , &mxlc
                                        , MIXER_GETLINECONTROLSF_ONEBYTYPE);
             if (mmr == MMSYSERR_NOERROR)
             {
                 pvcd->dwSupport |= VCD_SUPPORTF_MIXER_ADVANCED;
                 break;
             }
         }

    //
    // stock controls
    //

    //
    // peakmeter
    //
    mxlc.cbStruct       = sizeof(mxlc);
    mxlc.dwLineID       = dwLineID;
    mxlc.dwControlType  = MIXERCONTROL_CONTROLTYPE_PEAKMETER;
    mxlc.cControls      = 1;
    mxlc.cbmxctrl       = sizeof(mxc);
    mxlc.pamxctrl       = &mxc;

    mmr = mixerGetLineControls(hmx
                               , &mxlc
                               , MIXER_GETLINECONTROLSF_ONEBYTYPE);
    if (mmr == MMSYSERR_NOERROR)
    {
        pvcd->dwMeterID  = mxc.dwControlID;
        pvcd->dwSupport |= VCD_SUPPORTF_MIXER_METER;
        pvcd->dwSupport |= Mixer_CheckBadDriver(hmx
                                                , &mxlc
                                                , &mxc
                                                , mxc.dwControlID
                                                , dwLineID);
    }

    //
    // mute
    //
    mxlc.cbStruct       = sizeof(mxlc);
    mxlc.dwLineID       = dwLineID;
    mxlc.dwControlType  = MIXERCONTROL_CONTROLTYPE_MUTE;
    mxlc.cControls      = 1;
    mxlc.cbmxctrl       = sizeof(mxc);
    mxlc.pamxctrl       = &mxc;

    mmr = mixerGetLineControls(hmx
                               , &mxlc
                               , MIXER_GETLINECONTROLSF_ONEBYTYPE);
    if (mmr == MMSYSERR_NOERROR)
    {
        pvcd->fdwMuteControl = mxc.fdwControl;
        pvcd->dwMuteID   = mxc.dwControlID;
        pvcd->dwSupport |= VCD_SUPPORTF_MIXER_MUTE;
        pvcd->dwVisible |= VCD_VISIBLEF_MIXER_MUTE;

        pvcd->dwSupport |= Mixer_CheckBadDriver(hmx
                                                , &mxlc
                                                , &mxc
                                                , mxc.dwControlID
                                                , dwLineID);
    }

    //
    // volume
    //
    mxlc.cbStruct       = sizeof(mxlc);
    mxlc.dwLineID       = dwLineID;
    mxlc.dwControlType  = MIXERCONTROL_CONTROLTYPE_VOLUME;
    mxlc.cControls      = 1;
    mxlc.cbmxctrl       = sizeof(mxc);
    mxlc.pamxctrl       = &mxc;

    mmr = mixerGetLineControls(hmx
                               , &mxlc
                               , MIXER_GETLINECONTROLSF_ONEBYTYPE);
    if (mmr == MMSYSERR_NOERROR)
    {
        pvcd->fdwVolumeControl = mxc.fdwControl;
        pvcd->dwVolumeID = mxc.dwControlID;
        pvcd->dwSupport |= VCD_SUPPORTF_MIXER_VOLUME;
        pvcd->dwSupport |= Mixer_CheckBadDriver(hmx
                                                , &mxlc
                                                , &mxc
                                                , mxc.dwControlID
                                                , dwLineID);
    }

    //
    // mixer
    //
    mxlc.cbStruct       = sizeof(mxlc);
    mxlc.dwLineID       = dwLineID;
    mxlc.dwControlType  = MIXERCONTROL_CONTROLTYPE_MIXER;
    mxlc.cControls      = 1;
    mxlc.cbmxctrl       = sizeof(mxc);
    mxlc.pamxctrl       = &mxc;

    mmr = mixerGetLineControls(hmx
                               , &mxlc
                               , MIXER_GETLINECONTROLSF_ONEBYTYPE);
    if (mmr == MMSYSERR_NOERROR)
    {
        pvcd->dwMixerID  = mxc.dwControlID;
        pvcd->cMixer     = mxc.cMultipleItems;
        pvcd->dwSupport |= VCD_SUPPORTF_MIXER_MIXER;
        pvcd->dwSupport |= Mixer_CheckBadDriver(hmx
                                                , &mxlc
                                                , &mxc
                                                , mxc.dwControlID
                                                , dwLineID);
    }

    //
    // mux
    //
    mxlc.cbStruct       = sizeof(mxlc);
    mxlc.dwLineID       = dwLineID;
    mxlc.dwControlType  = MIXERCONTROL_CONTROLTYPE_MUX;
    mxlc.cControls      = 1;
    mxlc.cbmxctrl       = sizeof(mxc);
    mxlc.pamxctrl       = &mxc;

    mmr = mixerGetLineControls(hmx
                               , &mxlc
                               , MIXER_GETLINECONTROLSF_ONEBYTYPE);
    if (mmr == MMSYSERR_NOERROR)
    {
        pvcd->dwMuxID    = mxc.dwControlID;
        pvcd->cMux       = mxc.cMultipleItems;
        pvcd->dwSupport |= VCD_SUPPORTF_MIXER_MUX;
        pvcd->dwSupport |= Mixer_CheckBadDriver(hmx
                                                , &mxlc
                                                , &mxc
                                                , mxc.dwControlID
                                                , dwLineID);
    }
    if (!(pvcd->dwSupport & ( VCD_SUPPORTF_MIXER_MUTE
                              | VCD_SUPPORTF_MIXER_METER
                              | VCD_SUPPORTF_MIXER_VOLUME)))
    {
        if (IsDestinationMux(hmx, dwLineID) &&
            !(pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUX))
        {
            //
            // Visible, and not hidden
            //
            pvcd->dwSupport |= VCD_SUPPORTF_VISIBLE;
            pvcd->dwSupport &= ~VCD_SUPPORTF_DEFAULT;
        }
        else
        {
            //
            // make it invisible in the UI.
            //
            pvcd->dwSupport |= VCD_SUPPORTF_HIDDEN;
        }
    }
    else
    {
        //
        // Visible, and not hidden
        //
        pvcd->dwSupport |= VCD_SUPPORTF_VISIBLE;
    }


}


/*
 * Mixer_CreateVolumeDescription
 *
 * */
PVOLCTRLDESC Mixer_CreateVolumeDescription(
    HMIXEROBJ           hmx,
    int                 iDest,
    DWORD*              pcvd )
{
    MMRESULT            mmr;
    PVOLCTRLDESC        pvcdPrev = NULL, pvcd = NULL;
    MIXERLINE           mlDst;
    DWORD               cLines = 0;
    DWORD               dwSupport = 0L;
    UINT                iSrc;
    int                 newDest=0;

    ZeroMemory(&mlDst, sizeof(mlDst));

    mlDst.cbStruct      = sizeof(mlDst);
    mlDst.dwDestination = iDest;

    mmr = mixerGetLineInfo(hmx
                           , &mlDst
                           , MIXER_GETLINEINFOF_DESTINATION);

    if(!mlDst.cConnections)
    {
        //No lines to list. Try with a different mixer ID.
        GetDestination(0, &newDest);
        mlDst.dwDestination = newDest;

        mmr = mixerGetLineInfo(hmx
                         , &mlDst
                         , MIXER_GETLINEINFOF_DESTINATION);

        //Even if we do not get any connections here lets continue. Nothing more we can do.
        //This will be taken care of before opening the dialog.
    }

    if (mmr == MMSYSERR_NOERROR)
    {
        if (mlDst.cChannels == 1L)
            dwSupport |= VCD_SUPPORTF_MONO;

        if (mlDst.fdwLine & MIXERLINE_LINEF_DISCONNECTED)
            dwSupport |= VCD_SUPPORTF_DISABLED;

        //
        // a default type
        //
        dwSupport |= VCD_SUPPORTF_DEFAULT;
    }
    else
    {
        //
        // we need to add it anyway s.t. a UI comes up
        //
        dwSupport = VCD_SUPPORTF_DISABLED;
    }

    pvcd = PVCD_AddLine(NULL
                       , iDest
                       , VCD_TYPE_MIXER
                       , mlDst.szShortName
                       , mlDst.szName
                       , dwSupport
                       , &cLines );

    if (!pvcd)
        return NULL;

    Mixer_InitLineControls( hmx, pvcd, mlDst.dwLineID );

    pvcdPrev = pvcd;

    for (iSrc = 0; iSrc < mlDst.cConnections; iSrc++)
    {
        MIXERLINE    mlSrc;

        mlSrc.cbStruct          = sizeof(mlSrc);
        mlSrc.dwDestination     = iDest;
        mlSrc.dwSource          = iSrc;

        mmr = mixerGetLineInfo(hmx
                               , &mlSrc
                               , MIXER_GETLINEINFOF_SOURCE);
        dwSupport = 0L;

        if (mmr == MMSYSERR_NOERROR)
        {
            if (mlSrc.cChannels == 1L)
            {
                dwSupport |= VCD_SUPPORTF_MONO;
            }

            if (mlSrc.fdwLine & MIXERLINE_LINEF_DISCONNECTED)
                dwSupport |= VCD_SUPPORTF_DISABLED;

            //
            // Mark these types as "default" just to lessen the shock on
            // some advanced sound cards.
            //
            if (mlDst.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_SPEAKERS
                || mlDst.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_HEADPHONES)
            {
                switch (mlSrc.dwComponentType)
                {
                    case MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT:
                    case MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC:
                    case MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER:
                    case MIXERLINE_COMPONENTTYPE_SRC_LINE:
                        dwSupport |= VCD_SUPPORTF_DEFAULT;
                        break;
                }
            }
            else if (mlDst.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_WAVEIN
                     || mlDst.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_VOICEIN)
            {
                switch (mlSrc.dwComponentType)
                {
                    case MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE:
                    case MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC:
                    case MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER:
                    case MIXERLINE_COMPONENTTYPE_SRC_LINE:
                    case MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED:
                        dwSupport |= VCD_SUPPORTF_DEFAULT;
                        break;
                }
            }
        }
        else
        {
            //
            // we need to add it anyway s.t. lookups aren't under counted
            //
            dwSupport = VCD_SUPPORTF_DISABLED;
        }
        pvcd = PVCD_AddLine(pvcdPrev
                            , iDest
                            , VCD_TYPE_MIXER
                            , mlSrc.szShortName
                            , mlSrc.szName
                            , dwSupport
                            , &cLines );
        if (pvcd)
        {
            Mixer_InitLineControls( hmx, &pvcd[cLines-1], mlSrc.dwLineID );
            pvcdPrev = pvcd;
        }
    }


    //
    // Fixup dependencies
    //
    Mixer_SetLines(hmx, pvcdPrev, cLines);

    *pcvd = cLines;
    return pvcdPrev;
}


/*
 * Mixer_IsValidRecordingDestination
 *
 * */
BOOL Mixer_IsValidRecordingDestination (HMIXEROBJ hmx, MIXERLINE* pmlDst)
{

    BOOL fReturn = FALSE;

    if (pmlDst && MIXERLINE_COMPONENTTYPE_DST_WAVEIN == pmlDst -> dwComponentType)
    {

        UINT uiSrc;
        MIXERLINE mlSrc;

        for (uiSrc = 0; uiSrc < pmlDst -> cConnections; uiSrc++)
        {

            mlSrc.cbStruct      = sizeof (mlSrc);
            mlSrc.dwDestination = pmlDst -> dwDestination;
            mlSrc.dwSource      = uiSrc;

            if (SUCCEEDED (mixerGetLineInfo (hmx, &mlSrc, MIXER_GETLINEINFOF_SOURCE)))
            {
                switch (mlSrc.dwComponentType)
                {
                    case MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE:
                    case MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC:
                    case MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER:
                    case MIXERLINE_COMPONENTTYPE_SRC_LINE:
                    case MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED:
                        fReturn = TRUE;
                        break;
                }
            }
        }
    }

    return fReturn;

}


/*
 * Mixer_CleanupVolumeDescription
 *
 * */
void Mixer_CleanupVolumeDescription(
    PVOLCTRLDESC    avcd,
    DWORD           cvcd)
{
    if (cvcd == 0)
        return;

    if (avcd[0].pdblCacheMix)
    {
        GlobalFreePtr(avcd[0].pdblCacheMix);
    }

    if (avcd[0].dwSupport & VCD_SUPPORTF_MIXER_MIXER)
    {
        if (avcd[0].amcd_bMixer)
            GlobalFreePtr(avcd[0].amcd_bMixer);
    }

    if (avcd[0].dwSupport & VCD_SUPPORTF_MIXER_MUX)
    {
        if (avcd[0].amcd_bMux)
            GlobalFreePtr(avcd[0].amcd_bMux);
    }

}
/*****************************************************************************
 *
 *  ACTIVE GET/SET CODE
 *
 *****************************************************************************/

static
MMRESULT
Mixer_GetMixerLineInfo(
    HMIXEROBJ hmx,      // handle to mixer
    LPMIXERLINE pml,    // Returns destination info
    DWORD dwLineID      //
    )
{
    if (!pml || !hmx)
        return MMSYSERR_INVALPARAM;

    // Get mixerline info
    ZeroMemory( pml, sizeof(*pml) );
    pml->cbStruct = sizeof(*pml);
    pml->dwLineID = dwLineID;

    return (mixerGetLineInfo (hmx, pml, MIXER_GETLINEINFOF_LINEID));
}

/*
 * Mixer_GetMixerVolume
 *
 * */
static MMRESULT Mixer_GetMixerVolume(
    PMIXUIDIALOG pmxud,                          // app instance
    PVOLCTRLDESC pvcd,                           // volume to change
    MIXERCONTROLDETAILS_UNSIGNED* pmcdVolume,    // array for volume levels
    LPDWORD lpSize                               // size of array (or return size needed)
    )
{

    MMRESULT mmr;
    MIXERLINE ml;
    MIXERCONTROLDETAILS mxcd;
    DWORD cChannels;

    if (!lpSize || !pmxud)
        return MMSYSERR_INVALPARAM;

    // Get mixerline info
    if (pvcd->fdwVolumeControl & MIXERCONTROL_CONTROLF_UNIFORM)
    {
        cChannels = 1;
    }
    else
    {
        mmr = Mixer_GetMixerLineInfo ((HMIXEROBJ)(pmxud->hmx), &ml, pvcd->dwLineID);
        if (MMSYSERR_NOERROR != mmr)
        {
            return mmr;
        }
        cChannels = ml.cChannels;
    }

    if (!pmcdVolume)
    {
        // Just return size needed
        *lpSize = cChannels * sizeof (MIXERCONTROLDETAILS_UNSIGNED);
        return MMSYSERR_NOERROR;
    }
    else
    {
        // Verify passed array size
        if (*lpSize < cChannels * sizeof (MIXERCONTROLDETAILS_UNSIGNED))
            return MMSYSERR_INVALPARAM;
    }

    // Get volume levels
    ZeroMemory (&mxcd, sizeof (mxcd));
    mxcd.cbStruct       = sizeof(mxcd);
    mxcd.dwControlID    = pvcd->dwVolumeID;
    mxcd.cChannels      = cChannels;
    mxcd.cbDetails      = sizeof (MIXERCONTROLDETAILS_UNSIGNED);
    mxcd.paDetails      = (LPVOID) pmcdVolume;

    mmr = mixerGetControlDetails((HMIXEROBJ)(pmxud->hmx),
                                 &mxcd,
                                 MIXER_OBJECTF_HANDLE | MIXER_GETCONTROLDETAILSF_VALUE);
    return mmr;

}

static MMRESULT Mixer_Mute(
    HMIXEROBJ               hmx,
    PVOLCTRLDESC            pvcd,
    PMIXERCONTROLDETAILS    pmxcd,
    DWORD                   fMute)
{
    MIXERLINE ml;
    DWORD cChannels;
    DWORD dwSize;
    LPDWORD lpdwCurrent;
    UINT uiIndx;
    MMRESULT mmr;

    // Check the parameters
    if (!hmx || !pvcd || !pmxcd)
        return MMSYSERR_INVALPARAM;

    // Get mixerline info
    if (pvcd->fdwMuteControl & MIXERCONTROL_CONTROLF_UNIFORM)
    {
        cChannels = 1;
    }
    else
    {
        mmr = Mixer_GetMixerLineInfo(hmx, &ml, pvcd->dwLineID);
        if (MMSYSERR_NOERROR != mmr)
        {
            return mmr;
        }
        cChannels = ml.cChannels;
    }

    dwSize = (DWORD)(cChannels * sizeof(DWORD));

    pmxcd->paDetails = LocalAlloc (LPTR, dwSize);
    if (!pmxcd->paDetails)
        return MMSYSERR_NOMEM;

    for (uiIndx = 0; uiIndx < cChannels; uiIndx++)
    {
        lpdwCurrent = ((LPDWORD)pmxcd->paDetails + uiIndx);
        *lpdwCurrent = fMute;
    }

    pmxcd->cbStruct         = sizeof(*pmxcd);
    pmxcd->dwControlID      = pvcd->dwMuteID ;
    pmxcd->cChannels        = cChannels;
    pmxcd->cMultipleItems   = 0;
    pmxcd->cbDetails        = sizeof(DWORD);

    mmr = mixerSetControlDetails(hmx
                               , pmxcd
                               , MIXER_SETCONTROLDETAILSF_VALUE);

    LocalFree (pmxcd->paDetails);
    return mmr;
}


/*
 * Mixer_GetControl
 *
 * Change a UI control in response to a device or initialization event
 *
 * */

void Mixer_GetControl(
    PMIXUIDIALOG        pmxud,
    HWND                hctl,
    int                 imxul,
    int                 itype)
{
    PMIXUILINE      pmxul = &pmxud->amxul[imxul];
    PVOLCTRLDESC    pvcd = pmxul->pvcd;
    DWORD           dwID = 0L;
    BOOL            fSet = FALSE;

    switch (itype)
    {
        case MIXUI_VUMETER:
            fSet = (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_METER);
            if (fSet)
                dwID = pmxul->pvcd->dwMeterID;
            break;

        case MIXUI_SWITCH:
            fSet = (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUTE)
                   && (pmxul->pvcd->dwVisible & VCD_VISIBLEF_MIXER_MUTE);
            if (fSet)
            {
                dwID = pmxul->pvcd->dwMuteID;
                break;
            }

            fSet = (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUX)
                   && (pmxul->pvcd->dwVisible & VCD_VISIBLEF_MIXER_MUX);
            if (fSet)
            {
                dwID = pmxul->pvcd->dwMuxID;
                break;
            }

            fSet = (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_MIXER)
                   && (pmxul->pvcd->dwVisible & VCD_VISIBLEF_MIXER_MIXER);
            if (fSet)
            {
                dwID = pmxul->pvcd->dwMixerID;
                break;
            }
            break;

        case MIXUI_VOLUME:
        case MIXUI_BALANCE:
            fSet = (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_VOLUME);
            if (fSet)
                dwID = pmxul->pvcd->dwVolumeID;
            break;

        default:
            return;
    }
    if (fSet)
        Mixer_GetControlFromID(pmxud, dwID);

}


/*
 * Mixer_SetVolume
 *
 * - Change a mixerControl in response to a user event
 * */
MMRESULT Mixer_SetVolume (
    PMIXUIDIALOG pmxud,         // app instance
    PVOLCTRLDESC pvcd,          // volume to change
    DWORD        dwVolume,      // volume value                         VOLUME_MAX to VOLUME_MIN
    LPDWORD      lpdwBalance    // Balance desired (NULL == No Balance) 0 to 64
    )
{

    MIXERLINE ml;
    DWORD cChannels;
    DWORD dwSize;
    MIXERCONTROLDETAILS_UNSIGNED* pmcdVolume;
    MMRESULT mmr;

    // Check the parameters
    if ( !pvcd || !pmxud || (dwVolume > VOLUME_MAX) )
        return MMSYSERR_INVALPARAM;

    // Find needed buffer size for volumes
    if (pvcd->fdwVolumeControl & MIXERCONTROL_CONTROLF_UNIFORM)
    {
        cChannels = 1;
    }
    else
    {
        mmr = Mixer_GetMixerLineInfo ((HMIXEROBJ)(pmxud->hmx), &ml, pvcd->dwLineID);
        if (MMSYSERR_NOERROR != mmr)
        {
            return mmr;
        }

        cChannels = ml.cChannels;
    }

    dwSize = (DWORD)(cChannels * sizeof (MIXERCONTROLDETAILS_UNSIGNED));

    // Create volume buffer
    pmcdVolume = LocalAlloc (LPTR, dwSize);
    if (!pmcdVolume)
        return MMSYSERR_NOMEM;

    // Note: From here on, do not return without releasing 'pmcdVolume'.

    mmr = Mixer_GetMixerVolume (pmxud, pvcd, pmcdVolume, &dwSize);
    if (MMSYSERR_NOERROR == mmr)
    {

        MIXERCONTROLDETAILS mcd;
        ZeroMemory (&mcd, sizeof (mcd));

        // Create volume mix cache if necessary
        // if we have no cache we make one of course
        // other wise we first check that not all the volumes of the channels are equal to zero
       if (!pvcd->pdblCacheMix || !Mixer_AreChannelsAtMinimum(pmcdVolume,cChannels))
       {
            Mixer_RefreshMixCache (pvcd, pmcdVolume, cChannels);
       }

        // Create volume buffer for new values
        mcd.paDetails = LocalAlloc (LPTR, dwSize);
        if (!mcd.paDetails || !pvcd->pdblCacheMix)
            mmr = MMSYSERR_NOMEM;

        // Caculate the new volume & balance
        if (MMSYSERR_NOERROR == mmr)
        {

            UINT uiIndx;
            MIXERCONTROLDETAILS_UNSIGNED* pmcdCurrent;

            // Account for Balance (only for Stereo)
            if ( lpdwBalance && (cChannels == 2) && (*lpdwBalance <= 64) )
            {
                MIXERCONTROLDETAILS_UNSIGNED* pmcdLeft = ((MIXERCONTROLDETAILS_UNSIGNED*)mcd.paDetails);
                MIXERCONTROLDETAILS_UNSIGNED* pmcdRight = ((MIXERCONTROLDETAILS_UNSIGNED*)mcd.paDetails + 1);
                long lBalance = *lpdwBalance;

                lBalance -= 32; // -32 to 32 range

                // Caculate volume based on balance and refresh mix cache
                if (lBalance > 0) // Balance Right
                {
                    // Left
                    if (lBalance == 32) // Pegged Right
                        pmcdLeft -> dwValue = 0;
                    else
                        pmcdLeft -> dwValue = dwVolume - (lBalance * (dwVolume - VOLUME_MIN))/32;

                    // Right
                    pmcdRight -> dwValue = dwVolume;
                }
                if (lBalance < 0) // Balance Left
                {
                    // Left
                    pmcdLeft -> dwValue = dwVolume;
                    // Right
                    if (lBalance == -32) // Pegged Left
                        pmcdRight -> dwValue = 0;
                    else
                        pmcdRight -> dwValue = dwVolume - (-lBalance * (dwVolume - VOLUME_MIN))/32;
                }
                if (lBalance == 0) // Balance Centered
                {
                    // Left
                    pmcdLeft -> dwValue = dwVolume;
                    // Right
                    pmcdRight -> dwValue = dwVolume;
                }
                Mixer_RefreshMixCache (pvcd, mcd.paDetails, cChannels);
            }
            else
            {
                // Caculate the new volume level for each of the channels. For volume levels
                // at the current max, we simply set the newly requested level (in this case
                // the cache value is 1.0). For those less than the max, we set a value that
                // is a percentage of the max. This maintains the relative distance of the
                // channel levels from each other.
                for (uiIndx = 0; uiIndx < cChannels; uiIndx++)
                {
                    pmcdCurrent = ((MIXERCONTROLDETAILS_UNSIGNED*)mcd.paDetails + uiIndx);
                    // The 0.5f forces rounding (instead of truncation)
                    pmcdCurrent -> dwValue = (DWORD)(*(pvcd->pdblCacheMix + uiIndx) * (double) dwVolume + 0.5f);
                }
            }

            mcd.cbStruct    = sizeof (mcd);
            mcd.dwControlID = pvcd -> dwVolumeID;
            mcd.cChannels   = cChannels;
            mcd.cbDetails   = sizeof (MIXERCONTROLDETAILS_UNSIGNED);
                            // seems like it would be sizeof(mcd.paDetails),
                            // but actually, it is the size of a single value
                            // and is multiplied by channel in the driver.

            // Apply new value only if it is different. This prevents unessary calls to
            // mixerSetControlDetails() when we are pegged.
            if (memcmp (pmcdVolume, mcd.paDetails, dwSize))
            {
                mixerSetControlDetails ((HMIXEROBJ)(pmxud->hmx), &mcd, MIXER_SETCONTROLDETAILSF_VALUE);
            }

        }
        // Free new volume array
        if (mcd.paDetails)
            LocalFree (mcd.paDetails);
    }

    // Free volume array
    LocalFree (pmcdVolume);

    return mmr;

}


/*
 * Mixer_GetControlFromID
 *
 * */
void Mixer_GetControlFromID(
    PMIXUIDIALOG        pmxud,
    DWORD               dwControlID)
{
    MIXERLINE           mxl;
    MIXERLINECONTROLS   mxlc;
    MIXERCONTROL        mxc;
    MIXERCONTROLDETAILS mxcd;
    PMIXUILINE          pmxul;
    PMIXUICTRL          pmxuc;
    PVOLCTRLDESC        pvcd;
    DWORD               ivcd;
    BOOL                fBarf = FALSE;
    MMRESULT            mmr;

    //
    // Retrieve the control information
    //
    mxlc.cbStruct       = sizeof(mxlc);
    mxlc.dwControlID    = dwControlID;
    mxlc.cControls      = 1;
    mxlc.cbmxctrl       = sizeof(mxc);
    mxlc.pamxctrl       = &mxc;

    mmr = mixerGetLineControls((HMIXEROBJ)(pmxud->hmx)
                               , &mxlc
                               , MIXER_GETLINECONTROLSF_ONEBYID);
    if (mmr != MMSYSERR_NOERROR)
        return;

    if (!(pmxud->dwFlags & MXUD_FLAGSF_BADDRIVER))
    {
        //
        // The *correct* code for this lookup using the mixer API.
        //
        // Is this our current destination line?
        //
        mxl.cbStruct    = sizeof(mxl);
        mxl.dwLineID    = mxlc.dwLineID;

        mmr = mixerGetLineInfo((HMIXEROBJ)(pmxud->hmx)
                               , &mxl
                               , MIXER_GETLINEINFOF_LINEID);
        if (mmr != MMSYSERR_NOERROR)
            return;

        if (mxl.dwDestination != pmxud->iDest)
            return;

        //
        // Is this a source line or a destination line?
        //

        ivcd    = (mxl.fdwLine & MIXERLINE_LINEF_SOURCE)? 1 + mxl.dwSource : 0;
        pvcd    = &pmxud->avcd[ivcd];

        //
        // a bad driver was detected!
        //
        if (pvcd->dwLineID != mxlc.dwLineID)
        {
            pmxud->dwFlags |= MXUD_FLAGSF_BADDRIVER;
        }
    }
    if (pmxud->dwFlags & MXUD_FLAGSF_BADDRIVER)
    {
        PVOLCTRLDESC        pvcdTmp;
        //
        // take evasive action if this was a bad driver by doing a brute force
        // search.
        //

        pvcd = NULL;
        for (ivcd = 0; ivcd < pmxud->cvcd; ivcd ++)
        {
            pvcdTmp = &pmxud->avcd[ivcd];
            if ( ( (pvcdTmp->dwSupport & VCD_SUPPORTF_MIXER_VOLUME)
                   && pvcdTmp->dwVolumeID == dwControlID )
                 || ( (pvcdTmp->dwSupport & VCD_SUPPORTF_MIXER_MUTE)
                      && pvcdTmp->dwMuteID == dwControlID )
                 || ( (pvcdTmp->dwSupport & VCD_SUPPORTF_MIXER_MIXER)
                      && pvcdTmp->dwMixerID == dwControlID )
                 || ( (pvcdTmp->dwSupport & VCD_SUPPORTF_MIXER_MUX)
                      && pvcdTmp->dwMuxID == dwControlID )
                 || ( (pvcdTmp->dwSupport & VCD_SUPPORTF_MIXER_METER)
                      && pvcdTmp->dwMeterID == dwControlID ) )
            {
                pvcd = pvcdTmp;
                break;
            }
        }
        if (pvcd == NULL)
            return;
    }

    pmxul   = pvcd->pmxul;

    //
    // Go through our visible lines to determine if this control affects
    // any visible control and change them.
    //
    switch (mxc.dwControlType)
    {
        case MIXERCONTROL_CONTROLTYPE_VOLUME:
        {
            MIXERCONTROLDETAILS_UNSIGNED* pmcdVolume;
            DWORD cChannels;
            DWORD dwSize;
            MIXERLINE ml;

            //
            // A nonvisible line should be shunned
            //
            if (pmxul == NULL)
                return;

            // Find needed buffer size for volumes
            if (pvcd->fdwVolumeControl & MIXERCONTROL_CONTROLF_UNIFORM)
            {
                cChannels = 1;
            }
            else
            {
                mmr = Mixer_GetMixerLineInfo ((HMIXEROBJ)(pmxud->hmx), &ml, pvcd->dwLineID);
                if (MMSYSERR_NOERROR != mmr)
                {
                    return;
                }
                cChannels = ml.cChannels;
            }

            dwSize = (DWORD)(cChannels * sizeof (MIXERCONTROLDETAILS_UNSIGNED));
            // Create volume buffer
            pmcdVolume = LocalAlloc (LPTR, dwSize);
            if (!pmcdVolume)
                return;

            // Note : Do not return without releasing 'pmcdVolume'.

            if (Mixer_GetMixerVolume (pmxud, pvcd, pmcdVolume, &dwSize)
                == MMSYSERR_NOERROR)
            {
                UINT  uindx;
                DWORD dwVolume;
                DWORD dwMax = 0;

                // Set Volume slider
                for (uindx = 0; uindx < cChannels; uindx++)
                    dwMax = max (dwMax, (pmcdVolume + uindx) -> dwValue);
                dwVolume = VOLUME_TO_SLIDER(dwMax);
                dwVolume = VOLUME_TICS - dwVolume;

                pmxuc = &pmxul->acr[MIXUI_VOLUME];
                if (pmxuc->state)
                {
                    SendMessage(pmxuc->hwnd, TBM_SETPOS, TRUE, dwVolume);
                }

                // Set Balance Slider
                pmxuc = &pmxul->acr[MIXUI_BALANCE];
                if (dwVolume < VOLUME_TICS && pmxuc->state && 2 >= cChannels)
                {
                    long lBalance;
                    double dblBalance;

                    if (1 >= cChannels)
                        lBalance = 0;
                    else
                    {
                        // Stereo
                        dblBalance = (double)(32 * (long)(pmcdVolume -> dwValue - (pmcdVolume + 1) -> dwValue))
                                   / (double)(dwMax - VOLUME_MIN);
                        lBalance = (long)((32.0F - dblBalance) + 0.5F); // 0.5 forces rounding
                    }

                    SendMessage(pmxuc->hwnd, TBM_SETPOS, TRUE, lBalance);
                }
            }

            LocalFree (pmcdVolume);

            break;
        }

        case MIXERCONTROL_CONTROLTYPE_MIXER:
        {
            DWORD   i;

            mxcd.cbStruct       = sizeof(mxcd);
            mxcd.dwControlID    = pvcd->dwMixerID ;
            mxcd.cChannels      = 1;
            mxcd.cMultipleItems = pvcd->cMixer;
            mxcd.cbDetails      = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
            mxcd.paDetails      = (LPVOID)pvcd->amcd_bMixer;

            mmr = mixerGetControlDetails((HMIXEROBJ)(pmxud->hmx)
                                         , &mxcd
                                         , MIXER_GETCONTROLDETAILSF_VALUE);

            if (mmr == MMSYSERR_NOERROR)
            {
                for (i = 0; i < pmxud->cvcd; i++)
                {
                    pvcd = &pmxud->avcd[i];
                    if ( (pvcd->dwSupport & VCD_SUPPORTF_MIXER_MIXER)
                         && (pvcd->dwVisible & VCD_VISIBLEF_MIXER_MIXER)
                         && pvcd->pmxul)
                    {
                        pmxuc = &pvcd->pmxul->acr[MIXUI_SWITCH];
                        if (pmxuc->state == MIXUI_CONTROL_INITIALIZED)
                        {
                            SendMessage(pmxuc->hwnd
                                        , BM_SETCHECK
                                        , pvcd->amcd_bMixer[pvcd->iMixer].fValue, 0);
                        }
                    }
                }
            }
            break;
        }

        case MIXERCONTROL_CONTROLTYPE_MUX:
        {
            DWORD   i;

            mxcd.cbStruct       = sizeof(mxcd);
            mxcd.dwControlID    = pvcd->dwMuxID ;
            mxcd.cChannels      = 1;
            mxcd.cMultipleItems = pvcd->cMux;
            mxcd.cbDetails      = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
            mxcd.paDetails      = (LPVOID)pvcd->amcd_bMux;

            mmr = mixerGetControlDetails((HMIXEROBJ)(pmxud->hmx)
                                         , &mxcd
                                         , MIXER_GETCONTROLDETAILSF_VALUE);

            if (mmr == MMSYSERR_NOERROR)
            {
                for (i = 0; i < pmxud->cvcd; i++)
                {
                    pvcd = &pmxud->avcd[i];
                    if ( (pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUX)
                         && (pvcd->dwVisible & VCD_VISIBLEF_MIXER_MUX)
                         && pvcd->pmxul)
                    {
                        pmxuc = &pvcd->pmxul->acr[MIXUI_SWITCH];
                        if (pmxuc->state == MIXUI_CONTROL_INITIALIZED)
                            SendMessage(pmxuc->hwnd
                                        , BM_SETCHECK
                                        , pvcd->amcd_bMux[pvcd->iMux].fValue, 0);
                    }
                }
            }
            break;
        }

        case MIXERCONTROL_CONTROLTYPE_MUTE:
        {
            DWORD fChecked;

            //
            // A nonvisible line should be shunned
            //
            if (pmxul == NULL)
                return;

            if (! (pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUTE
                   && pvcd->dwVisible & VCD_VISIBLEF_MIXER_MUTE))
                return;

            pmxuc = &pmxul->acr[MIXUI_SWITCH];
            if (pmxuc->state != MIXUI_CONTROL_INITIALIZED)
                break;

            mxcd.cbStruct       = sizeof(mxcd);
            mxcd.dwControlID    = pvcd->dwMuteID;
            mxcd.cChannels      = 1;
            mxcd.cMultipleItems = 0;
            mxcd.cbDetails      = sizeof(DWORD);
            mxcd.paDetails      = (LPVOID)&fChecked;

            mmr = mixerGetControlDetails((HMIXEROBJ)(pmxud->hmx)
                                         , &mxcd
                                         , MIXER_GETCONTROLDETAILSF_VALUE);

            if (mmr != MMSYSERR_NOERROR)
                break;

            SendMessage(pmxuc->hwnd, BM_SETCHECK, fChecked, 0);
            break;
        }

        case MIXERCONTROL_CONTROLTYPE_PEAKMETER:
        {
            LONG            lVol;
            DWORD           dwVol;

            //
            // A nonvisible line should be shunned
            //
            if (pmxul == NULL)
                return;

            pmxuc = &pmxul->acr[MIXUI_VUMETER];
            if (pmxuc->state != MIXUI_CONTROL_INITIALIZED)
                break;

            mxcd.cbStruct       = sizeof(mxcd);
            mxcd.dwControlID    = pvcd->dwMeterID;
            mxcd.cChannels      = 1;
            mxcd.cMultipleItems = 0;
            mxcd.cbDetails      = sizeof(DWORD);
            mxcd.paDetails      = (LPVOID)&lVol;

            mmr = mixerGetControlDetails((HMIXEROBJ)(pmxud->hmx)
                                         , &mxcd
                                         , MIXER_GETCONTROLDETAILSF_VALUE);

            if (mmr != MMSYSERR_NOERROR)
                break;

            dwVol = (DWORD)abs(lVol);
            dwVol = (VOLUME_TICS * dwVol) / 32768;

            SendMessage(pmxuc->hwnd, VU_SETPOS, 0, dwVol);
            break;
        }

        default:
            return;
    }
}


/*
 * Mixer_SetControl
 *
 * - Change a mixerControl in response to a user event
 * */
void Mixer_SetControl(
    PMIXUIDIALOG pmxud,         // app instance
    HWND         hctl,          // hwnd of control that changed
    int          iLine,         // visible line index of control that changed
    int          iCtl)          // control id%line of control that changed
{
    MMRESULT            mmr;
    MIXERCONTROLDETAILS mxcd;
    PMIXUILINE          pmxul;
    PMIXUICTRL          pmxuc;
    PVOLCTRLDESC        pvcd = NULL;

    if ((DWORD)iLine >= pmxud->cmxul)
        return;

    pmxul = &pmxud->amxul[iLine];
    pvcd = pmxul->pvcd;

    if (iCtl <= MIXUI_LAST)
    {
        pmxuc = &pmxul->acr[iCtl];
    }

    switch (iCtl)
    {
        case MIXUI_ADVANCED:
            Mixer_Advanced(pmxud, pvcd->dwLineID, pvcd->szName);
            break;

        case MIXUI_MULTICHANNEL:
            // Note: This will always be true:
            // (MXUL_STYLEF_DESTINATION & pmxul->dwStyle)
            Mixer_Multichannel(pmxud, pvcd->dwVolumeID);
            break;

        case MIXUI_VOLUME:
        case MIXUI_BALANCE:
        {
            // Make sure we have a volume slider
            if ( pmxul->acr[MIXUI_VOLUME].state != MIXUI_CONTROL_UNINITIALIZED)
            {
                DWORD   dwVolume;
                DWORD   dwBalance;
                LPDWORD lpdwBalance = NULL;

                dwVolume = (DWORD)SendMessage( pmxul->acr[MIXUI_VOLUME].hwnd
                                        , TBM_GETPOS
                                        , 0
                                        , 0 );

                dwVolume = VOLUME_TICS - dwVolume;
                dwVolume = SLIDER_TO_VOLUME(dwVolume);

                // See if we have a balance slider as well
                if ( pmxul->acr[MIXUI_BALANCE].state != MIXUI_CONTROL_UNINITIALIZED)
                {
                    dwBalance = (DWORD)SendMessage(pmxul->acr[MIXUI_BALANCE].hwnd
                                           , TBM_GETPOS
                                           , 0
                                           , 0);
                    lpdwBalance = &dwBalance;

                }
                Mixer_SetVolume (pmxud, pvcd, dwVolume, lpdwBalance);
            }

            break;
        }

        case MIXUI_SWITCH:
        {
            LONG fChecked;

            if (pmxuc->state != MIXUI_CONTROL_INITIALIZED)
                break;

            fChecked = (LONG)SendMessage(pmxuc->hwnd, BM_GETCHECK, 0, 0);

            //
            // it's unlikely that there is a mixer and a mux and a mute
            // representing the same line. It's most important that when a line
            // is selected that the user gets a response.  If there is a mute
            // but no mux, then mute and mixer should be OFF and ON
            // respectively and vice versa.  If there is a mux and a mute the
            // same is true.
            // If there is a mux and a mixer... then the mux select should
            // correspond.
            //

            if ( pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUTE
                 && pvcd->dwVisible & VCD_VISIBLEF_MIXER_MUTE )
            {
                mmr = Mixer_Mute((HMIXEROBJ)(pmxud->hmx),
                                 pvcd, &mxcd, fChecked);
            }

            if (pvcd->dwSupport & VCD_SUPPORTF_MIXER_MIXER
                && pvcd->dwVisible & VCD_VISIBLEF_MIXER_MIXER )
            {
                //
                // get all other mixer settings, make sure this one is checked
                //
                mxcd.cbStruct       = sizeof(mxcd);
                mxcd.dwControlID    = pvcd->dwMixerID ;
                mxcd.cChannels      = 1;
                mxcd.cMultipleItems = pvcd->cMixer;
                mxcd.cbDetails      = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
                mxcd.paDetails      = (LPVOID)pvcd->amcd_bMixer;

                mmr = mixerGetControlDetails((HMIXEROBJ)(pmxud->hmx)
                                             , &mxcd
                                             , MIXER_GETCONTROLDETAILSF_VALUE);

                if (mmr == MMSYSERR_NOERROR)
                {
                    pvcd->amcd_bMixer[pvcd->iMixer].fValue = fChecked;
                    mmr = mixerSetControlDetails((HMIXEROBJ)(pmxud->hmx)
                                                 , &mxcd
                                                 , MIXER_SETCONTROLDETAILSF_VALUE);
                }

                if (fChecked && pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUTE)
                {
                    mmr = Mixer_Mute((HMIXEROBJ)(pmxud->hmx), pvcd, &mxcd, FALSE);
                }
            }

            if (pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUX
                && pvcd->dwVisible & VCD_VISIBLEF_MIXER_MUX )
            {
                DWORD i;
                //
                // get all other mux settings, make sure this one is checked
                // or unchecked and all others are not.
                //

                for (i = 0; i < pvcd->cMux; i++)
                    pvcd->amcd_bMux[i].fValue = FALSE;

                pvcd->amcd_bMux[pvcd->iMux].fValue = TRUE;

                mxcd.cbStruct       = sizeof(mxcd);
                mxcd.dwControlID    = pvcd->dwMuxID ;
                mxcd.cChannels      = 1;
                mxcd.cMultipleItems = pvcd->cMux;
                mxcd.cbDetails      = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
                mxcd.paDetails      = (LPVOID)pvcd->amcd_bMux;

                mmr = mixerSetControlDetails((HMIXEROBJ)(pmxud->hmx)
                                             , &mxcd
                                             , MIXER_SETCONTROLDETAILSF_VALUE);

                if (fChecked && pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUTE)
                {
                    mmr = Mixer_Mute((HMIXEROBJ)(pmxud->hmx), pvcd, &mxcd, FALSE);
                }
            }

            break;
        }
        default:
            break;
    }
}



/*
 * Mixer_PollingUpdate
 *
 * Controls that need to be updated by a timer.
 *
 * */
void Mixer_PollingUpdate(
    PMIXUIDIALOG pmxud)
{
    DWORD       i;
    MMRESULT    mmr;
    MIXERLINE   mxl;
    //
    // For all visible mixer lines, locate the control id's that need to be
    // updated.
    //
    for (i = 0; i < pmxud->cmxul; i++)
    {
        PMIXUICTRL      pmxuc = &pmxud->amxul[i].acr[MIXUI_VUMETER];
        PVOLCTRLDESC    pvcd = pmxud->amxul[i].pvcd;

        if (pmxuc->state == MIXUI_CONTROL_UNINITIALIZED)
            continue;

        if (!(pvcd->dwSupport & VCD_SUPPORTF_MIXER_METER))
            continue;

        //
        // Is the line active?
        //
        mxl.cbStruct = sizeof(MIXERLINE);
        mxl.dwLineID = pvcd->dwLineID;

        mmr = mixerGetLineInfo((HMIXEROBJ)(pmxud->hmx)
                               , &mxl
                               , MIXER_GETLINEINFOF_LINEID);
        //
        // Force non active or invalid lines to 0
        //
        if (mmr != MMSYSERR_NOERROR || !(mxl.fdwLine & MIXERLINE_LINEF_ACTIVE))
        {
            SendMessage(pmxuc->hwnd, VU_SETPOS, 0, 0L);
            continue;
        }

        //
        // Force a visible update
        //
        Mixer_GetControlFromID(pmxud, pvcd->dwMeterID);
    }
}


void ShowAndEnableWindow (HWND hWnd, BOOL fEnable)
{
    ShowWindow (hWnd, fEnable ? SW_SHOW : SW_HIDE);
    EnableWindow (hWnd, fEnable);
}


/*
 * Mixer_Init
 *
 * Control initialization
 * */
BOOL Mixer_Init(
    PMIXUIDIALOG    pmxud)
{
    MMRESULT        mmr;
    MIXERLINE       mlDst;
    DWORD           iline;
    TCHAR           achFmt[256];
    TCHAR           achTitle[256];
    TCHAR           achAccessible[256];
    int             x;

    ZeroMemory (achFmt, sizeof (achFmt)); // Inital value for prefix

    mmr = mixerOpen((LPHMIXER)&pmxud->hmx
                    , pmxud->mxid
                    , (DWORD_PTR)pmxud->hwnd
                    , 0
                    , CALLBACK_WINDOW);

    if (mmr != MMSYSERR_NOERROR)
    {
        return FALSE;
    }
    else
    {
        DeviceChange_Init(pmxud->hwnd, pmxud->mxid);
    }

    if (mixerMessage((HMIXER)ULongToPtr(pmxud->mxid), DRV_QUERYDEVNODE, (DWORD_PTR)&pmxud->dwDevNode, 0L))
        pmxud->dwDevNode = 0L;

    LoadString(pmxud->hInstance, IDS_APPTITLE, achFmt, SIZEOF(achFmt));

    mlDst.cbStruct      = sizeof ( mlDst );
    mlDst.dwDestination = pmxud->iDest;

    mmr = mixerGetLineInfo((HMIXEROBJ)ULongToPtr(pmxud->mxid)
                           , &mlDst
                           , MIXER_GETLINEINFOF_DESTINATION);

    if (mmr == MMSYSERR_NOERROR)
    {
        lstrcpy(achTitle, mlDst.szName);
    }
    else
    {
        LoadString(pmxud->hInstance, IDS_APPBASE, achTitle, SIZEOF(achTitle));
    }

    SetWindowText(pmxud->hwnd, achTitle);

    //
    // since we cannot get a WM_PARENTNOTIFY, we need to run through
    // all controls and make appropriate modifications.
    //
    for ( iline = 0 ; iline < pmxud->cmxul ; iline++ )
    {
        PMIXUILINE  pmxul = &pmxud->amxul[iline];
        PMIXUICTRL  amxuc = pmxul->acr;
        HWND        ctrl;

        ctrl = Volume_GetLineItem(pmxud->hwnd, iline, IDC_LINELABEL);
        if (ctrl)
        {
            if (pmxud->dwStyle & MXUD_STYLEF_SMALL)
                Static_SetText(ctrl, pmxul->pvcd->szShortName);
            else
                Static_SetText(ctrl, pmxul->pvcd->szName);
        }

        // for MSAA (accessibility), we need to put the control name on the sliders
        for (x = IDC_ACCESS_BALANCE; x <= IDC_ACCESS_VOLUME; x++)
        {
            ctrl = Volume_GetLineItem(pmxud->hwnd, iline, x);
            if (ctrl)
            {
                Static_GetText(ctrl, achFmt, sizeof(achFmt)/sizeof(TCHAR));

                if (pmxud->dwStyle & MXUD_STYLEF_SMALL)
                {
                    wsprintf(achAccessible,achFmt,pmxul->pvcd->szShortName);
                    Static_SetText(ctrl, achAccessible);
                }
                else
                {
                    wsprintf(achAccessible,achFmt,pmxul->pvcd->szName);
                    Static_SetText(ctrl, achAccessible);
                }
            }
        }


        //
        // Master Control Multichannel Support
        //
        // Init multichannel support for master control if available. Note that if a master
        // control exisits on the dialog, it is currently in the first position, but we do
        // NOT rely on that fact here.
        // Note: Not only must there be multiple channels, but Volume must also be
        //       Supported to manipulate the channels.
        if (mlDst.cChannels > 2L &&
            MXUL_STYLEF_DESTINATION & pmxul->dwStyle &&
            pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_VOLUME)
        {
            int idc;
            for (idc = IDC_MASTER_BALANCE_ICON_2; idc >= IDC_MULTICHANNEL; idc--)
            {
                ctrl = Volume_GetLineItem (pmxud->hwnd, iline, idc);
                if (ctrl)
                    ShowAndEnableWindow (ctrl, (IDC_MULTICHANNEL == idc));
            }
            ctrl = Volume_GetLineItem (pmxud->hwnd, iline, IDC_BALANCE);
            if (ctrl)
                ShowAndEnableWindow (ctrl, FALSE);


            switch (mlDst.dwComponentType)
            {
                case MIXERLINE_COMPONENTTYPE_DST_SPEAKERS:
                    // No Change
                    break;

                case MIXERLINE_COMPONENTTYPE_DST_WAVEIN:
                case MIXERLINE_COMPONENTTYPE_DST_VOICEIN:
                    // Recording
                    LoadString(pmxud->hInstance, IDS_MC_RECORDING, achFmt, SIZEOF(achFmt));
                    SetWindowText (ctrl, achFmt);
                    break;

                default:
                    // Anything else...
                    LoadString(pmxud->hInstance, IDS_MC_LEVEL, achFmt, SIZEOF(achFmt));
                    SetWindowText (ctrl, achFmt);
                    break;

            }
        }


        //
        // Advanced escape
        //
        if (MXUD_ADVANCED(pmxud) &&
            !(pmxud->dwStyle & MXUD_STYLEF_SMALL))

        {
            HWND hadv = Volume_GetLineItem(pmxud->hwnd, iline, IDC_ADVANCED);
            if (hadv)
            {
                ShowWindow(hadv,(pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_ADVANCED)?SW_SHOW:SW_HIDE);
                EnableWindow(hadv,
                    (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_ADVANCED)?TRUE:FALSE);
            }
        }

        if (pmxul->pvcd->dwSupport & VCD_SUPPORTF_DISABLED)
            continue;

        //
        // allow init of control structures
        //
        if (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_VOLUME)
        {
            amxuc[MIXUI_VOLUME].state = MIXUI_CONTROL_ENABLED;
            if (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MONO)
            {
                amxuc[MIXUI_BALANCE].state = MIXUI_CONTROL_UNINITIALIZED;
            }
            else
                amxuc[MIXUI_BALANCE].state = MIXUI_CONTROL_ENABLED;

        }
        if (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_METER)
            amxuc[MIXUI_VUMETER].state = MIXUI_CONTROL_ENABLED;

        if (pmxul->pvcd->dwSupport & VCD_SUPPORTF_MIXER_MUTE)
            amxuc[MIXUI_SWITCH].state = MIXUI_CONTROL_ENABLED;

        if ((pmxul->pvcd->dwSupport & ( VCD_SUPPORTF_MIXER_MIXER
                                        | VCD_SUPPORTF_MIXER_MUX))
            && (pmxul->pvcd->dwVisible & ( VCD_VISIBLEF_MIXER_MIXER
                                           | VCD_VISIBLEF_MIXER_MUX)))
        {
            //
            // No longer make the mute visible
            //
            pmxul->pvcd->dwVisible &= ~VCD_VISIBLEF_MIXER_MUTE;

            amxuc[MIXUI_SWITCH].state = MIXUI_CONTROL_ENABLED;
            ctrl = Volume_GetLineItem(pmxud->hwnd, iline, IDC_SWITCH);
            if (ctrl)
            {
                TCHAR ach[256];
                if (LoadString(pmxud->hInstance, IDS_SELECT, ach, SIZEOF(ach)))
                    Button_SetText(ctrl, ach);
            }
        }
    }
    return TRUE;
}

/*
 * Mixer_Shutdown
 *
 * Close handles, etc..
 * */
void Mixer_Shutdown(
    PMIXUIDIALOG    pmxud)
{
    if (pmxud->hmx)
    {
        mixerClose(pmxud->hmx);
        pmxud->hmx = NULL;
    }

    Mixer_CleanupVolumeDescription(pmxud->avcd, pmxud->cvcd);
}


/*      -       -       -       -       -       -       -       -       - */

typedef struct tagAdv {
    PMIXUIDIALOG pmxud;     // IN
    DWORD        dwLineID;  // IN
    HMIXER       hmx;       // IN
    LPTSTR       szName;    // IN

    DWORD        dwSupport;
    DWORD        dwBassID;
    DWORD        dwTrebleID;
    DWORD        dwSwitch1ID;
    DWORD        dwSwitch2ID;

} ADVPARAM, *PADVPARAM;

#define GETPADVPARAM(x)       (ADVPARAM *)GetWindowLongPtr(x, DWLP_USER)
#define SETPADVPARAM(x,y)     SetWindowLongPtr(x, DWLP_USER, y)
#define ADV_HAS_BASS          0x00000001
#define ADV_HAS_TREBLE        0x00000002
#define ADV_HAS_SWITCH1       0x00000004
#define ADV_HAS_SWITCH2       0x00000008


void Mixer_Advanced_Update(
    PADVPARAM       pap,
    HWND            hwnd)
{
    MIXERCONTROLDETAILS mxcd;
    DWORD           dwValue = 0;
    MMRESULT        mmr;

    if (pap->dwSupport & ADV_HAS_TREBLE)
    {
        mxcd.cbStruct       = sizeof(mxcd);
        mxcd.dwControlID    = pap->dwTrebleID ;
        mxcd.cChannels      = 1;
        mxcd.cMultipleItems = 0;
        mxcd.cbDetails      = sizeof(DWORD);
        mxcd.paDetails      = (LPVOID)&dwValue;

        mmr = mixerGetControlDetails((HMIXEROBJ)(pap->hmx)
                                     , &mxcd
                                     , MIXER_GETCONTROLDETAILSF_VALUE);

        if (mmr == MMSYSERR_NOERROR)
        {
            dwValue = VOLUME_TO_SLIDER(dwValue);
            SendMessage(GetDlgItem(hwnd, IDC_TREBLE), TBM_SETPOS, TRUE, dwValue);
        }
    }

    if (pap->dwSupport & ADV_HAS_BASS)
    {
        mxcd.cbStruct       = sizeof(mxcd);
        mxcd.dwControlID    = pap->dwBassID;
        mxcd.cChannels      = 1;
        mxcd.cMultipleItems = 0;
        mxcd.cbDetails      = sizeof(DWORD);
        mxcd.paDetails      = (LPVOID)&dwValue;

        mmr = mixerGetControlDetails((HMIXEROBJ)(pap->hmx)
                                     , &mxcd
                                     , MIXER_GETCONTROLDETAILSF_VALUE);

        if (mmr == MMSYSERR_NOERROR)
        {
            dwValue = VOLUME_TO_SLIDER(dwValue);
            SendMessage(GetDlgItem(hwnd, IDC_BASS), TBM_SETPOS, TRUE, dwValue);
        }
    }

    if (pap->dwSupport & ADV_HAS_SWITCH1)
    {
        mxcd.cbStruct       = sizeof(mxcd);
        mxcd.dwControlID    = pap->dwSwitch1ID;
        mxcd.cChannels      = 1;
        mxcd.cMultipleItems = 0;
        mxcd.cbDetails      = sizeof(DWORD);
        mxcd.paDetails      = (LPVOID)&dwValue;

        mmr = mixerGetControlDetails((HMIXEROBJ)(pap->hmx)
                                     , &mxcd
                                     , MIXER_GETCONTROLDETAILSF_VALUE);

        if (mmr == MMSYSERR_NOERROR)
        {
            Button_SetCheck(GetDlgItem(hwnd,IDC_SWITCH1),dwValue);
        }

    }

    if (pap->dwSupport & ADV_HAS_SWITCH2)
    {
        mxcd.cbStruct       = sizeof(mxcd);
        mxcd.dwControlID    = pap->dwSwitch2ID;
        mxcd.cChannels      = 1;
        mxcd.cMultipleItems = 0;
        mxcd.cbDetails      = sizeof(DWORD);
        mxcd.paDetails      = (LPVOID)&dwValue;

        mmr = mixerGetControlDetails((HMIXEROBJ)(pap->hmx)
                                     , &mxcd
                                     , MIXER_GETCONTROLDETAILSF_VALUE);

        if (mmr == MMSYSERR_NOERROR)
        {
            Button_SetCheck(GetDlgItem(hwnd,IDC_SWITCH2),dwValue);
        }
    }
}

void Mixer_Advanced_OnMixmControlChange(
    HWND            hwnd,
    HMIXER          hmx,
    DWORD           dwControlID)
{
    PADVPARAM     pap = GETPADVPARAM(hwnd);

    if (!pap)
        return;

    if ( ((pap->dwSupport & ADV_HAS_BASS)
          && dwControlID == pap->dwBassID)
         || ((pap->dwSupport & ADV_HAS_TREBLE)
             && dwControlID == pap->dwTrebleID)
         || ((pap->dwSupport & ADV_HAS_SWITCH1)
             && dwControlID == pap->dwSwitch1ID)
         || ((pap->dwSupport & ADV_HAS_SWITCH2)
             && dwControlID == pap->dwSwitch2ID) )
    {
        Mixer_Advanced_Update(pap,hwnd);
    }
}

BOOL Mixer_Advanced_OnInitDialog(
    HWND            hwnd,
    HWND            hwndFocus,
    LPARAM          lParam)
{
    PADVPARAM           pap;
    MIXERLINECONTROLS   mxlc;
    MIXERCONTROL        *pmxc;
    MIXERLINE           ml;
    MMRESULT            mmr;
    DWORD               iCtrl, iSwitch1, iSwitch2;
    TCHAR               ach[MIXER_LONG_NAME_CHARS + 24];
    TCHAR               achFmt[256];

    HWND                hBass,hTreble,hSwitch1,hSwitch2;

    SETPADVPARAM(hwnd, lParam);
    pap = GETPADVPARAM(hwnd);
    if (!pap)
        EndDialog(hwnd, FALSE);

    //
    // clone the mixer handle to catch callbacks
    //
    #ifndef _WIN64
    mmr = mixerOpen((LPHMIXER)&pap->hmx
                    , (UINT)pap->pmxud->hmx
                    , (DWORD_PTR)hwnd
                    , 0
                    , CALLBACK_WINDOW | MIXER_OBJECTF_HMIXER );
    #else
    mmr = mixerOpen((LPHMIXER)&pap->hmx
                    , (UINT)pap->pmxud->mxid
                    , (DWORD_PTR)hwnd
                    , 0
                    , CALLBACK_WINDOW | MIXER_OBJECTF_HMIXER );
    #endif

    if (mmr != MMSYSERR_NOERROR)
        EndDialog(hwnd, FALSE);

    //
    // Get all controls.
    //

    ml.cbStruct      = sizeof(ml);
    ml.dwLineID      = pap->dwLineID;

    mmr = mixerGetLineInfo((HMIXEROBJ)pap->hmx
                           , &ml
                           , MIXER_GETLINEINFOF_LINEID);

    if (mmr != MMSYSERR_NOERROR || ml.cControls == 0L)
        EndDialog(hwnd, FALSE);

    pmxc = (MIXERCONTROL *)GlobalAllocPtr(GHND,
                                          sizeof(MIXERCONTROL) * ml.cControls);
    if (!pmxc)
    {
        EndDialog(hwnd, FALSE);
        return FALSE; // Bail on error
    }

    mxlc.cbStruct   = sizeof(mxlc);
    mxlc.dwLineID   = pap->dwLineID;
    mxlc.cControls  = ml.cControls;
    mxlc.cbmxctrl   = sizeof(MIXERCONTROL);
    mxlc.pamxctrl   = pmxc;

    mmr = mixerGetLineControls((HMIXEROBJ)(pap->hmx)
                               , &mxlc
                               , MIXER_GETLINECONTROLSF_ALL);
    if (mmr != MMSYSERR_NOERROR)
    {
        GlobalFreePtr(pmxc);
        EndDialog(hwnd, FALSE);
    }

    pap->dwSupport = 0L;
    for (iCtrl = 0; iCtrl < ml.cControls; iCtrl++)
    {
        switch (pmxc[iCtrl].dwControlType)
        {
            case MIXERCONTROL_CONTROLTYPE_BASS:
                if (!(pap->dwSupport & ADV_HAS_BASS))
                {
                    pap->dwBassID  = pmxc[iCtrl].dwControlID;
                    pap->dwSupport |= ADV_HAS_BASS;
                }
                break;
            case MIXERCONTROL_CONTROLTYPE_TREBLE:
                if (!(pap->dwSupport & ADV_HAS_TREBLE))
                {
                    pap->dwTrebleID  = pmxc[iCtrl].dwControlID;
                    pap->dwSupport |= ADV_HAS_TREBLE;
                }
                break;

            case MIXERCONTROL_CONTROLTYPE_BOOLEAN:
            case MIXERCONTROL_CONTROLTYPE_MONO:
            case MIXERCONTROL_CONTROLTYPE_STEREOENH:
            case MIXERCONTROL_CONTROLTYPE_ONOFF:
            case MIXERCONTROL_CONTROLTYPE_LOUDNESS:
                if (!(pap->dwSupport & ADV_HAS_SWITCH1))
                {
                    pap->dwSwitch1ID  = pmxc[iCtrl].dwControlID;
                    pap->dwSupport |= ADV_HAS_SWITCH1;
                    iSwitch1 = iCtrl;
                }
                else if (!(pap->dwSupport & ADV_HAS_SWITCH2))
                {
                    pap->dwSwitch2ID  = pmxc[iCtrl].dwControlID;
                    pap->dwSupport |= ADV_HAS_SWITCH2;
                    iSwitch2 = iCtrl;
                }
                break;
        }
    }

    //
    //
    //

    hBass = GetDlgItem(hwnd, IDC_BASS);
    hTreble = GetDlgItem(hwnd, IDC_TREBLE);
    hSwitch1 = GetDlgItem(hwnd, IDC_SWITCH1);
    hSwitch2 = GetDlgItem(hwnd, IDC_SWITCH2);

    SendMessage(hBass, TBM_SETRANGE, 0, MAKELONG(0, VOLUME_TICS));
    SendMessage(hBass, TBM_SETTICFREQ, (VOLUME_TICS + 5)/6, 0 );

    SendMessage(hTreble, TBM_SETRANGE, 0, MAKELONG(0, VOLUME_TICS));
    SendMessage(hTreble, TBM_SETTICFREQ, (VOLUME_TICS + 5)/6, 0 );

    if (!(pap->dwSupport & ADV_HAS_BASS))
    {
        SendMessage(hBass, TBM_SETPOS, 64, 0 );
        EnableWindow(GetDlgItem(hwnd, IDC_TXT_LOW1), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_TXT_HI1), FALSE);
    }
    EnableWindow(hBass, (pap->dwSupport & ADV_HAS_BASS));

    if (!(pap->dwSupport & ADV_HAS_TREBLE))
    {
        SendMessage(hTreble, TBM_SETPOS, 64, 0 );
        EnableWindow(GetDlgItem(hwnd, IDC_TXT_LOW2), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_TXT_HI2), FALSE);
    }
    EnableWindow(hTreble, (pap->dwSupport & ADV_HAS_TREBLE));

    if (pap->dwSupport & ADV_HAS_SWITCH1)
    {
        LoadString(pap->pmxud->hInstance, IDS_ADV_SWITCH1, achFmt,
            SIZEOF(achFmt));
        wsprintf(ach, achFmt, pmxc[iSwitch1].szName);

        SetWindowText(hSwitch1, ach);
        ShowWindow(hSwitch1, SW_SHOW);
        ShowWindow(GetDlgItem(hwnd, IDC_TXT_SWITCHES), SW_SHOW);
        ShowWindow(GetDlgItem(hwnd, IDC_GRP_OTHER), SW_SHOW);
    }
    EnableWindow(hSwitch1, (pap->dwSupport & ADV_HAS_SWITCH1));

    if (pap->dwSupport & ADV_HAS_SWITCH2)
    {
        LoadString(pap->pmxud->hInstance, IDS_ADV_SWITCH2, achFmt,
            SIZEOF(achFmt));
        wsprintf(ach, achFmt, pmxc[iSwitch2].szName);

        SetWindowText(hSwitch2, ach);
        ShowWindow(hSwitch2, SW_SHOW);
    }

    EnableWindow(hSwitch2, (pap->dwSupport & ADV_HAS_SWITCH2));

    if (pap->dwSupport & (ADV_HAS_SWITCH1 | ADV_HAS_SWITCH2))
    {
        RECT    rcGrp,rcGrp2,rcClose,rcWnd;
        DWORD   dwDY=0L;
        POINT   pos;
        HWND    hClose = GetDlgItem(hwnd, IDOK);
        HWND    hGrp2 = GetDlgItem(hwnd, IDC_GRP_OTHER);

        GetWindowRect(GetDlgItem(hwnd, IDC_GRP_TONE), &rcGrp);
        GetWindowRect(GetDlgItem(hwnd, IDC_GRP_OTHER), &rcGrp2);
        GetWindowRect(hClose, &rcClose);
        GetWindowRect(hwnd, &rcWnd);

        if (pap->dwSupport & ADV_HAS_SWITCH2)
        {
            RECT rc1, rc2;
            GetWindowRect(hSwitch1,&rc1);
            GetWindowRect(hSwitch2,&rc2);

            rcGrp2.bottom += rc2.bottom - rc1.bottom;
        }

        dwDY = rcGrp2.bottom - rcGrp.bottom;

        //
        // resize our main window
        //
        MoveWindow(hwnd, rcWnd.left
                   , rcWnd.top
                   , rcWnd.right - rcWnd.left
                   , (rcWnd.bottom - rcWnd.top) + dwDY
                   , FALSE);

        //
        // move the close button
        //
        MapWindowPoints(NULL, hwnd, (LPPOINT)&rcClose, 2);
        pos.x = rcClose.left;
        pos.y = rcClose.top;

        MoveWindow(hClose, pos.x
                   , pos.y + dwDY
                   , rcClose.right - rcClose.left
                   , rcClose.bottom - rcClose.top
                   , FALSE);

        //
        // resize our group box if necessary
        //
        if (pap->dwSupport & ADV_HAS_SWITCH2)
        {
            MapWindowPoints(NULL, hwnd, (LPPOINT)&rcGrp2, 2);
            pos.x = rcGrp2.left;
            pos.y = rcGrp2.top;

            MoveWindow(hGrp2, pos.x
                       , pos.y
                       , rcGrp2.right - rcGrp2.left
                       , rcGrp2.bottom - rcGrp2.top
                       , FALSE);
        }
    }

    GlobalFreePtr(pmxc);

    {
        TCHAR achTitle[MIXER_LONG_NAME_CHARS+256];
        LoadString(pap->pmxud->hInstance, IDS_ADV_TITLE, achFmt,
            SIZEOF(achFmt));
        wsprintf(achTitle, achFmt, pap->szName);
        SetWindowText(hwnd, achTitle);
    }

    Mixer_Advanced_Update(pap, hwnd);

    return TRUE;
}

void Mixer_Advanced_OnXScroll(
    HWND            hwnd,
    HWND            hwndCtl,
    UINT            code,
    int             pos)
{
    PADVPARAM       pap;
    MIXERCONTROLDETAILS mxcd;
    DWORD           dwVol;
    MMRESULT        mmr;

    pap = GETPADVPARAM(hwnd);

    if (!pap)
        return;

    if (pap->dwSupport & ADV_HAS_TREBLE)
    {
        dwVol = (DWORD)SendMessage( GetDlgItem(hwnd, IDC_TREBLE)
                                , TBM_GETPOS
                                , 0
                                , 0 );


        dwVol = SLIDER_TO_VOLUME(dwVol);

        mxcd.cbStruct       = sizeof(mxcd);
        mxcd.dwControlID    = pap->dwTrebleID ;
        mxcd.cChannels      = 1;
        mxcd.cMultipleItems = 0;
        mxcd.cbDetails      = sizeof(DWORD);
        mxcd.paDetails      = (LPVOID)&dwVol;

        mixerSetControlDetails((HMIXEROBJ)(pap->hmx)
                               , &mxcd
                               , MIXER_SETCONTROLDETAILSF_VALUE);
    }

    if (pap->dwSupport & ADV_HAS_BASS)
    {
        dwVol = (DWORD)SendMessage( GetDlgItem(hwnd, IDC_BASS)
                                , TBM_GETPOS
                                , 0
                                , 0 );

        dwVol = SLIDER_TO_VOLUME(dwVol);

        mxcd.cbStruct       = sizeof(mxcd);
        mxcd.dwControlID    = pap->dwBassID;
        mxcd.cChannels      = 1;
        mxcd.cMultipleItems = 0;
        mxcd.cbDetails      = sizeof(DWORD);
        mxcd.paDetails      = (LPVOID)&dwVol;

        mmr = mixerSetControlDetails((HMIXEROBJ)(pap->hmx)
                                     , &mxcd
                                     , MIXER_SETCONTROLDETAILSF_VALUE);
    }
}

void Mixer_Advanced_OnSwitch(
    HWND            hwnd,
    int             id,
    HWND            hwndCtl)
{
    PADVPARAM       pap;
    MIXERCONTROLDETAILS mxcd;
    DWORD           dwValue;
    MMRESULT        mmr;

    pap = GETPADVPARAM(hwnd);

    if (!pap)
        return;


    dwValue = Button_GetCheck(hwndCtl);

    mxcd.cbStruct       = sizeof(mxcd);
    mxcd.dwControlID    = (id == IDC_SWITCH1)?pap->dwSwitch1ID:pap->dwSwitch2ID;
    mxcd.cChannels      = 1;
    mxcd.cMultipleItems = 0;
    mxcd.cbDetails      = sizeof(DWORD);
    mxcd.paDetails      = (LPVOID)&dwValue;

    mmr = mixerSetControlDetails((HMIXEROBJ)(pap->hmx)
                                 , &mxcd
                                 , MIXER_SETCONTROLDETAILSF_VALUE);

}


BOOL Mixer_Advanced_OnCommand(
    HWND            hwnd,
    int             id,
    HWND            hwndCtl,
    UINT            codeNotify)
{
    switch (id)
    {
        case IDOK:
            EndDialog(hwnd, TRUE);
            break;

        case IDCANCEL:
            EndDialog(hwnd, FALSE);
            break;

        case IDC_SWITCH1:
            Mixer_Advanced_OnSwitch(hwnd, id, hwndCtl);
            break;

        case IDC_SWITCH2:
            Mixer_Advanced_OnSwitch(hwnd, id, hwndCtl);
            break;

    }
    return FALSE;
}

INT_PTR CALLBACK Mixer_Advanced_Proc(
    HWND            hwnd,
    UINT            msg,
    WPARAM          wparam,
    LPARAM          lparam)
{
    switch (msg)
    {
        case WM_INITDIALOG:
            HANDLE_WM_INITDIALOG(hwnd, wparam, lparam, Mixer_Advanced_OnInitDialog);
            return TRUE;

        case MM_MIXM_CONTROL_CHANGE:
            HANDLE_MM_MIXM_CONTROL_CHANGE(hwnd
                                          , wparam
                                          , lparam
                                          , Mixer_Advanced_OnMixmControlChange);
            break;

        case WM_CLOSE:
            EndDialog(hwnd, FALSE);
            break;

        case WM_HSCROLL:
            HANDLE_WM_XSCROLL(hwnd, wparam, lparam, Mixer_Advanced_OnXScroll);
            break;

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wparam, lparam, Mixer_Advanced_OnCommand);
            break;

        case WM_DESTROY:
        {
            PADVPARAM pap = GETPADVPARAM(hwnd);
            if (pap)
            {
                if (pap->hmx)
                    mixerClose(pap->hmx);
            }
            break;
        }

        default:
            break;
    }

    return FALSE;
}

/*
 * Advanced Features for specific mixer lines.
 */
void Mixer_Advanced(
    PMIXUIDIALOG    pmxud,
    DWORD           dwLineID,
    LPTSTR          szName)
{
    ADVPARAM advp;

    ZeroMemory(&advp, sizeof(ADVPARAM));
    advp.pmxud = pmxud;
    advp.dwLineID = dwLineID;
    advp.szName = szName;

    DialogBoxParam(pmxud->hInstance
                   , MAKEINTRESOURCE(IDD_ADVANCED)
                   , pmxud->hwnd
                   , Mixer_Advanced_Proc
                   , (LPARAM)(LPVOID)&advp);
}

typedef void (*MULTICHANNELFUNC)(HWND, UINT, DWORD, DWORD);
void Mixer_Multichannel (PMIXUIDIALOG pmxud, DWORD dwVolumeID)
{
    HMODULE          hModule;
    MULTICHANNELFUNC fnMultiChannel;

    if (pmxud)
    {
        hModule = (HMODULE) LoadLibrary (TEXT ("mmsys.cpl"));
        if (hModule)
        {
            fnMultiChannel = (MULTICHANNELFUNC) GetProcAddress (hModule, "Multichannel");
            if (fnMultiChannel)
            {
                (*fnMultiChannel)(pmxud->hwnd, pmxud->mxid, pmxud->iDest, dwVolumeID);
            }
            FreeLibrary (hModule);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mixerapp\choice.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       choice.c
 *  Purpose:    properties dialog box code
 * 
 *  Copyright (c) 1985-1999 Microsoft Corporation
 *
 *****************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <commctrl.h>

#include "volids.h"
#include "volumei.h"
#include "utils.h"

typedef struct t_DEVICEPROP {
    BOOL            fMixer;             // is mixer
    UINT            uDeviceID;          // device ID
    DWORD           dwPlayback;         // mixerline representing playback
    DWORD           dwRecording;        // mixerline representing recording
    MIXERCAPS       mxcaps;
} DEVICEPROP, *PDEVICEPROP;

typedef struct t_PRIVPROP {
    PMIXUIDIALOG    pmxud;              // app instance data
    PDEVICEPROP     adp;                // array of allocated device props
    PDEVICEPROP     pdpCurSel;          // current device selection
    DWORD           dwDestSel;          // last destination selection
    
    PVOLCTRLDESC    avcd;
    DWORD           cvcd;
    
    // in/out params

    UINT            uDeviceID;
    BOOL            fMixer;
    DWORD           dwDestination;
    DWORD           dwStyle;
    
} PRIVPROP, *PPRIVPROP;

#define PROPATOM        TEXT("privprop")
const TCHAR gszPropAtom[] = PROPATOM;
#define SETPROP(x,y)    SetProp((x), gszPropAtom, (HANDLE)(y))
#define GETPROP(x)      (PPRIVPROP)GetProp((x), gszPropAtom)
#define REMOVEPROP(x)   RemoveProp(x,gszPropAtom)

void SetCheckState (HWND hwndLV, int nItem, BOOL bCheck)
{
    LVITEM item;
	int nCheck = bCheck ? 2 : 1;	// one based index

    ZeroMemory (&item, sizeof (item));
    item.mask = LVIF_STATE;
    item.iItem = nItem;
    item.stateMask = LVIS_STATEIMAGEMASK;
    item.state = INDEXTOSTATEIMAGEMASK (nCheck);
    ListView_SetItem (hwndLV, &item);
}

void EnableOk(
    HWND            hwnd,
    BOOL            fEnable)
{
    HWND    hOk, hCancel;
    BOOL    fWasEnabled;
    
    hOk     = GetDlgItem(hwnd,IDOK);
    hCancel = GetDlgItem(hwnd,IDCANCEL);
    
    fWasEnabled = IsWindowEnabled(hOk);

    if (!fEnable && fWasEnabled)
    {
        Button_SetStyle(hOk, BS_PUSHBUTTON, TRUE);
        SendMessage(hwnd, DM_SETDEFID, IDCANCEL, 0L);
        EnableWindow(hOk, FALSE);
    }
    else if (fEnable && !fWasEnabled)
    {
        EnableWindow(hOk, TRUE);
        Button_SetStyle(hCancel, BS_PUSHBUTTON, TRUE);
        SendMessage(hwnd, DM_SETDEFID, IDOK, 0L);
    }
}

void Properties_GroupEnable(
    HWND            hwnd,
    const int       ids[],
    int             cids,
    BOOL            fEnable)
{
    int i;
    for (i = 0; i < cids; i++)
        EnableWindow(GetDlgItem(hwnd, ids[i]), fEnable);
}
    
void Properties_Enable_Prop_Volumes(
    HWND            hwnd,
    BOOL            fEnable)
{
    const int ids[] = {
        IDC_PROP_VOLUMES,
        IDC_PROP_PLAYBACK,
        IDC_PROP_RECORDING,
        IDC_PROP_OTHER,
        IDC_PROP_OTHERLIST
    };
    if (!fEnable)
        ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_PROP_OTHERLIST), -1);
    Properties_GroupEnable(hwnd, ids, SIZEOF(ids), fEnable);
}

void Properties_Enable_PROP_DEVICELIST(
    HWND            hwnd,
    BOOL            fEnable)
{
    const int ids[] = {
        IDC_PROP_TXT1,
        IDC_PROP_DEVICELIST,
    };
    if (!fEnable)
        ComboBox_SetCurSel(GetDlgItem(hwnd, IDC_PROP_OTHERLIST), -1);
    Properties_GroupEnable(hwnd, ids, SIZEOF(ids), fEnable);
}

void Properties_Enable_PROP_VOLUMELIST(
    HWND            hwnd,
    BOOL            fEnable)
{
    const int ids[] = {
        IDC_PROP_TXT2,
        IDC_PROP_VOLUMELIST,
    };
    Properties_GroupEnable(hwnd, ids, SIZEOF(ids), fEnable);
}


void Properties_CommitState(
    PPRIVPROP       ppr,
    HWND            hlb)
{
    DWORD           i;
    DWORD           cItems = ListView_GetItemCount(hlb);
    
    if (!ppr->avcd)
        return;
               
    for (i=0;i<cItems;i++)
    {
        LV_ITEM         lvi;
        
        lvi.iItem       = i;
        lvi.iSubItem    = 0;
        lvi.mask        = LVIF_PARAM;
        
        if (ListView_GetItem(hlb, &lvi))
        {
            ppr->avcd[lvi.lParam].dwSupport = (ListView_GetCheckState (hlb, i))?0:VCD_SUPPORTF_HIDDEN;
        }
    }
            
    Volume_GetSetRegistryLineStates(ppr->pdpCurSel->mxcaps.szPname
                                    , ppr->avcd[0].szShortName
                                    , ppr->avcd
                                    , ppr->cvcd
                                    , SET );

    Mixer_CleanupVolumeDescription(ppr->avcd, ppr->cvcd);

    GlobalFreePtr(ppr->avcd);
    ppr->avcd = NULL;
    ppr->cvcd = 0L;
}
    

/*
 * Init the destination type groupbox
 * 
 * */
BOOL Properties_Init_Prop_Volumes(
    PPRIVPROP       ppr,
    HWND            hwnd)
{
    HWND            hPlay = GetDlgItem(hwnd, IDC_PROP_PLAYBACK);
    HWND            hRec = GetDlgItem(hwnd, IDC_PROP_RECORDING);
    HWND            hOther = GetDlgItem(hwnd, IDC_PROP_OTHER);
    HWND            hOtherList = GetDlgItem(hwnd, IDC_PROP_OTHERLIST);
    DWORD           iDest, cDest;
    BOOL            fPlay = FALSE, fRec = FALSE;
    
    if (!ppr->pdpCurSel->fMixer)
        return FALSE;

    ComboBox_ResetContent(hOtherList);

    cDest = ppr->pdpCurSel->mxcaps.cDestinations;
    
    EnableWindow(hPlay, FALSE);
    EnableWindow(hRec, FALSE);
    EnableWindow(hOther, FALSE);
    
    for (iDest = 0; iDest < cDest; iDest++)
    {
        MIXERLINE   mlDst;
        int         imx;
        
        mlDst.cbStruct      = sizeof ( mlDst );
        mlDst.dwDestination = iDest;

        if (mixerGetLineInfo((HMIXEROBJ)UIntToPtr(ppr->pdpCurSel->uDeviceID)
                             , &mlDst
                             , MIXER_GETLINEINFOF_DESTINATION)
            != MMSYSERR_NOERROR)
            continue;

        //
        // Conditionally enable selections.  The first type for Play and
        // Record are the default Playback and Recording radiobuttons.
        // The next occurence of the same type is heaped into the Other
        // category.
        //

        if (mlDst.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_SPEAKERS
            && !fPlay)
        {
            EnableWindow(hPlay, TRUE);

            if (iDest == ppr->dwDestSel)
                CheckRadioButton(hwnd, IDC_PROP_PLAYBACK, IDC_PROP_OTHER
                                 , IDC_PROP_PLAYBACK);
            ppr->pdpCurSel->dwPlayback = iDest;
            fPlay = TRUE;
        }
        else if (mlDst.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_WAVEIN
                 && !fRec)
        {
            EnableWindow(hRec, TRUE);

            if (iDest == ppr->dwDestSel)
                CheckRadioButton(hwnd, IDC_PROP_PLAYBACK, IDC_PROP_OTHER
                                 , IDC_PROP_RECORDING);
            ppr->pdpCurSel->dwRecording = iDest;
            fRec = TRUE;
        }
        else
        {
            EnableWindow(hOther, TRUE);
            imx = ComboBox_AddString(hOtherList, mlDst.szName);
            ComboBox_SetItemData(hOtherList, imx, iDest);

            if (iDest == ppr->dwDestSel)
            {
                CheckRadioButton(hwnd, IDC_PROP_PLAYBACK, IDC_PROP_OTHER
                                 , IDC_PROP_OTHER);
                ComboBox_SetCurSel(hOtherList, imx);
            }
        }
    }

    //
    // Disable the "other" drop down if its not selected
    //
    if (!IsDlgButtonChecked(hwnd, IDC_PROP_OTHER))
    {
        ComboBox_SetCurSel(hOtherList, 0);
        EnableWindow(hOtherList, FALSE);
    }
            
    return TRUE;
}
    
BOOL Properties_Init_PROP_VOLUMELIST(
    PPRIVPROP       ppr,
    HWND            hwnd)
{
    HWND            hlb = GetDlgItem(hwnd, IDC_PROP_VOLUMELIST);
    LV_COLUMN       col = {LVCF_FMT | LVCF_WIDTH, LVCFMT_LEFT};
    RECT            rc;
    BOOL            fSet = FALSE;
    PVOLCTRLDESC    avcd = NULL;
    DWORD           cvcd = 0L;
    DWORD           ivcd;
    int             ilvi;
    LV_ITEM         lvi;
        
    
    ListView_DeleteAllItems(hlb);
    ListView_SetExtendedListViewStyleEx (hlb, LVS_EX_CHECKBOXES, LVS_EX_CHECKBOXES);
    ZeroMemory (&lvi, sizeof (lvi));

    GetClientRect(hlb, &rc);
    col.cx = rc.right - 2 * GetSystemMetrics(SM_CXEDGE);
    ListView_InsertColumn(hlb, 0, &col);

    if (ppr->avcd)
    {
        if (ppr->pdpCurSel->fMixer)
            Mixer_CleanupVolumeDescription(ppr->avcd, ppr->cvcd);
//        else
//            Nonmixer_CleanupVolumeDescription(ppr->avcd, ppr->cvcd);

        GlobalFreePtr(ppr->avcd);
                    
        ppr->avcd = NULL;
        ppr->cvcd = 0L;
    }
            
    if (ppr->pdpCurSel->fMixer)
    {
		HMIXER		hmx;
		MMRESULT	mmr;

		//
		//  Mixer API's are much more efficient with mixer handle...
		//

		mmr = mixerOpen(&hmx
				, ppr->pdpCurSel->uDeviceID
				, 0L
				, 0L
				, MIXER_OBJECTF_MIXER);

		if(MMSYSERR_NOERROR == mmr)
		{
	        avcd = Mixer_CreateVolumeDescription((HMIXEROBJ)hmx
	                                             , ppr->dwDestSel
	                                             , &cvcd);

			mixerClose(hmx);
		}
		else
		{
	        avcd = Mixer_CreateVolumeDescription((HMIXEROBJ)UIntToPtr(ppr->pdpCurSel->uDeviceID)
	                                             , ppr->dwDestSel
	                                             , &cvcd);
		}
    }
    else
    {
        avcd = Nonmixer_CreateVolumeDescription(ppr->dwDestSel
                                                , &cvcd);

    }

    if (avcd)
    {
        BOOL fFirstRun;
        //
        // Restore hidden state 
        //
        fFirstRun = !Volume_GetSetRegistryLineStates(ppr->pdpCurSel->mxcaps.szPname
                                                    , avcd[0].szShortName
                                                    , avcd
                                                    , cvcd
                                                    , GET );

        if (fFirstRun)
        {
            for (ivcd = 0; ivcd < cvcd; ivcd++)
            {
                if (!(avcd[ivcd].dwSupport & VCD_SUPPORTF_DEFAULT))
                    avcd[ivcd].dwSupport |= VCD_SUPPORTF_HIDDEN;
            }
            Volume_GetSetRegistryLineStates(ppr->pdpCurSel->mxcaps.szPname
                                            , avcd[0].szShortName
                                            , avcd
                                            , cvcd
                                            , SET);
        }
            
        for (ivcd = 0, ilvi = 0; ivcd < cvcd; ivcd++)
        {
            if (!(avcd[ivcd].dwSupport & VCD_SUPPORTF_VISIBLE))
                continue;

            lvi.iItem           = ilvi;
            lvi.iSubItem        = 0;
            lvi.mask            = LVIF_TEXT|LVIF_PARAM;
            lvi.lParam          = ivcd;
            lvi.pszText         = avcd[ivcd].szName;

            ListView_InsertItem(hlb, &lvi);
        
            if (!(avcd[ivcd].dwSupport & VCD_SUPPORTF_HIDDEN))
            {
                fSet = TRUE;
                SetCheckState (hlb, ilvi, TRUE);
            }
            ilvi++;

        }
    
        ppr->avcd = avcd;
        ppr->cvcd = cvcd;
    }
    
    ListView_SetItemState(hlb, 0, TRUE, LVIS_FOCUSED);

    EnableOk(hwnd, fSet);
        
    return TRUE;
}

/*
 * Init the list of devices.
 *
 * */
BOOL Properties_Init_PROP_DEVICELIST(
    PPRIVPROP       ppr,
    HWND            hwnd)
{
    HWND            hlb = GetDlgItem(hwnd, IDC_PROP_DEVICELIST);
    int             iMixer;
    int             cValidMixers = 0;
    int             cMixers;

    cMixers = mixerGetNumDevs();
    if (!cMixers)
        return FALSE;

    ppr->adp = (PDEVICEPROP)GlobalAllocPtr(GHND,cMixers * sizeof(DEVICEPROP));
    if (ppr->adp == NULL)
        return FALSE;
    
    for (iMixer = 0; iMixer < cMixers; iMixer++)
    {
        int         imx;
        MIXERCAPS*  pmxcaps = &ppr->adp[iMixer].mxcaps;
        MMRESULT    mmr;
        
        mmr = mixerGetDevCaps(iMixer, pmxcaps, sizeof(MIXERCAPS));

        if (mmr != MMSYSERR_NOERROR)
            continue;

        cValidMixers++;
        
        imx = ComboBox_AddString(hlb, pmxcaps->szPname);
        
        ppr->adp[iMixer].uDeviceID  = iMixer;
        ppr->adp[iMixer].fMixer     = TRUE;
        
        ComboBox_SetItemData(hlb, imx, &ppr->adp[iMixer]);
    }
    
    if (cValidMixers == 0)
        return FALSE;

    return TRUE;
}

BOOL Properties_OnCommand(
    HWND            hwnd,
    int             id,
    HWND            hctl,
    UINT            unotify)
{
    PPRIVPROP       ppr = GETPROP(hwnd);
    if (!ppr)
        return FALSE;

    switch (id)
    {
        case IDC_PROP_DEVICELIST:
            if (unotify == CBN_SELCHANGE)
            {
                int         imx;
                PDEVICEPROP pdp;
                
                imx = ComboBox_GetCurSel(hctl);
                pdp = (PDEVICEPROP)ComboBox_GetItemData(hctl, imx);

                if (pdp == ppr->pdpCurSel)
                    break;

                ppr->pdpCurSel = pdp;
                
                if (ppr->pdpCurSel->fMixer)
                    Properties_Init_Prop_Volumes(ppr, hwnd);
                else
                    Properties_Enable_Prop_Volumes(hwnd, FALSE);
                Properties_Init_PROP_VOLUMELIST(ppr, hwnd);
            }
            break;
            
        case IDC_PROP_PLAYBACK:
            EnableWindow(GetDlgItem(hwnd, IDC_PROP_OTHERLIST), FALSE);
            if (ppr->dwDestSel == ppr->pdpCurSel->dwPlayback)
                break;
            ppr->dwDestSel = ppr->pdpCurSel->dwPlayback;            
            Properties_Init_PROP_VOLUMELIST(ppr, hwnd);
            break;
            
        case IDC_PROP_RECORDING:
            EnableWindow(GetDlgItem(hwnd, IDC_PROP_OTHERLIST), FALSE);
            if (ppr->dwDestSel == ppr->pdpCurSel->dwRecording)
                break;
            ppr->dwDestSel = ppr->pdpCurSel->dwRecording;
            Properties_Init_PROP_VOLUMELIST(ppr, hwnd);            
            break;
            
        case IDC_PROP_OTHER:
        {
            HWND        hol;
            DWORD       dwSel;
            
            hol = GetDlgItem(hwnd, IDC_PROP_OTHERLIST);
            EnableWindow(hol, TRUE);
            ComboBox_SetCurSel(hol, 0);
            dwSel = (DWORD)ComboBox_GetItemData(hol, 0);
            
            if (ppr->dwDestSel == dwSel)
                break;

            ppr->dwDestSel = dwSel;
            Properties_Init_PROP_VOLUMELIST(ppr, hwnd);
            break;
        }
        case IDC_PROP_OTHERLIST:
            if (unotify == CBN_SELCHANGE)
            {
                int         idst;
                DWORD       dwSel;
                
                idst = ComboBox_GetCurSel(hctl);
                dwSel = (DWORD)ComboBox_GetItemData(hctl, idst);
                if (ppr->dwDestSel == dwSel)
                    break;
                ppr->dwDestSel = dwSel;
                Properties_Init_PROP_VOLUMELIST(ppr, hwnd);
            }
            break;
        case IDOK:
            //
            // Save out to registry for restaring.
            //
            Properties_CommitState(ppr, GetDlgItem(hwnd, IDC_PROP_VOLUMELIST));

            ppr->uDeviceID      = ppr->pdpCurSel->uDeviceID;
            ppr->fMixer         = TRUE;
            ppr->dwDestination  = ppr->dwDestSel;
            EndDialog(hwnd, TRUE);
            break;
            
        case IDCANCEL:
            Mixer_CleanupVolumeDescription(ppr->avcd, ppr->cvcd);
            if (ppr->avcd)
            {
                GlobalFreePtr(ppr->avcd);
                ppr->avcd = NULL;
                ppr->cvcd = 0L;
            }
            EndDialog(hwnd, FALSE);
            break;
    }
    return FALSE;
}


/*
 * Initialize the dialog
 *
 * */
BOOL Properties_OnInitDialog(
    HWND            hwnd,
    HWND            hwndFocus,
    LPARAM          lParam)
{
    PPRIVPROP       ppr;
    BOOL            fEnable = TRUE;
    HWND            hlv;
    
    SETPROP(hwnd, (PPRIVPROP)lParam);
    
    ppr = GETPROP(hwnd);
    
    if (!ppr)
        fEnable = FALSE;
    
    if (fEnable)
        fEnable = Properties_Init_PROP_DEVICELIST(ppr, hwnd);

    hlv = GetDlgItem(hwnd, IDC_PROP_VOLUMELIST);
    
    if (!fEnable)
    {
        //
        // Bad state, disable everything except cancel
        //
        Properties_Enable_PROP_DEVICELIST(hwnd, FALSE);        
        Properties_Enable_Prop_Volumes(hwnd, FALSE);
        Properties_Enable_PROP_VOLUMELIST(hwnd, FALSE);
        EnableOk(hwnd, FALSE);
        return FALSE;
    }
    else
    {
        int             i;
        PDEVICEPROP     pdp;
        HWND            hdl;

        //
        // make intial device selection
        //
        hdl = GetDlgItem(hwnd, IDC_PROP_DEVICELIST);

        ppr->dwDestSel = 0;
        ComboBox_SetCurSel(hdl, 0);
        ppr->pdpCurSel = (PDEVICEPROP)ComboBox_GetItemData(hdl, 0);
        i = ComboBox_GetCount(hdl);
        
        for (; i > 0 ; i-- )
        {
            pdp = (PDEVICEPROP)ComboBox_GetItemData(hdl,i-1);
            //
            // if things match up, then set the init data
            //
            if (pdp->uDeviceID == ppr->uDeviceID
                && pdp->fMixer == ppr->fMixer)
            {
                ppr->pdpCurSel = pdp;
                ComboBox_SetCurSel(hdl, i-1);
                ppr->dwDestSel = ppr->dwDestination;
                break;
            }
        }
    }

    Properties_Init_Prop_Volumes(ppr, hwnd);
    Properties_Init_PROP_VOLUMELIST(ppr, hwnd);
    
    return FALSE;
}



INT_PTR CALLBACK Properties_Proc(
    HWND            hwnd,
    UINT            msg,
    WPARAM          wparam,
    LPARAM          lparam)
{
    extern TCHAR gszHelpFileName[];
#include "helpids.h"
    static const DWORD aHelpIds[] = {
        IDC_PROP_TXT1,          IDH_SNDVOL32_SELECT_DEVICE,
        IDC_PROP_DEVICELIST,    IDH_SNDVOL32_SELECT_DEVICE,
        IDC_PROP_VOLUMES,       IDH_SNDVOL32_SELECT_SOUND,
        IDC_PROP_PLAYBACK,      IDH_SNDVOL32_SELECT_SOUND,
        IDC_PROP_RECORDING,     IDH_SNDVOL32_SELECT_SOUND,
        IDC_PROP_OTHER,         IDH_SNDVOL32_SELECT_SOUND,
        IDC_PROP_OTHERLIST,     IDH_SNDVOL32_SELECT_SOUND,
        IDC_PROP_TXT2,          IDH_SNDVOL32_VOLCONTROL,
        IDC_PROP_VOLUMELIST,    IDH_SNDVOL32_VOLCONTROL,
        0,                      0
    };
    switch (msg)
    {
        case WM_CONTEXTMENU:
            WinHelp((HWND)wparam, gszHelpFileName, HELP_CONTEXTMENU,
                (UINT_PTR)(LPSTR)aHelpIds);
            break;
            
        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lparam;
            WinHelp (lphi->hItemHandle, gszHelpFileName, HELP_WM_HELP,
                (UINT_PTR) (LPSTR) aHelpIds);
            return TRUE;
        }            
                
        case WM_INITDIALOG:
            HANDLE_WM_INITDIALOG(hwnd, wparam, lparam, Properties_OnInitDialog);
            return TRUE;
            
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hwnd, wparam, lparam, Properties_OnCommand);
            break;

        case WM_CLOSE:
            EndDialog(hwnd, FALSE);
            break;

        case WM_DESTROY:
        {
            PPRIVPROP ppr = GETPROP(hwnd);
            if (ppr)
            {
                if (ppr->adp)
                {
                    GlobalFreePtr(ppr->adp);
                    ppr->adp = NULL;
                }
                REMOVEPROP(hwnd);
            }
            break;
        }

        case WM_NOTIFY:
        {
            NMHDR FAR* lpnm = (NMHDR FAR *)lparam;
            if ((LVN_ITEMCHANGED == lpnm->code) && hwnd)
            {
                HWND hwndLV = GetDlgItem (hwnd, IDC_PROP_VOLUMELIST);
                if (hwndLV)
                {
                    int nItems = ListView_GetItemCount (hwndLV);
                    int indx;

                    for (indx = 0; indx < nItems; indx++)
                        if (ListView_GetCheckState (hwndLV, indx))
                            break;

                    EnableOk (hwnd, nItems != indx);
                }
			}
            break;
        }
    }
    return FALSE;
}

BOOL Properties(
    PMIXUIDIALOG    pmxud,
    HWND            hwnd)
{
    INT_PTR         iret;
    PRIVPROP        pr;

    ZeroMemory(&pr, sizeof(pr));
    pr.dwDestination = pmxud->iDest;
    pr.uDeviceID     = pmxud->mxid;
    pr.fMixer        = pmxud->dwFlags & MXUD_FLAGSF_MIXER;
    pr.dwStyle       = pmxud->dwStyle;
                      
    pr.pmxud         = pmxud;

    iret = DialogBoxParam(pmxud->hInstance
                          , MAKEINTRESOURCE(IDD_PROPERTIES)
                          , hwnd
                          , Properties_Proc
                          , (LPARAM)(LPVOID)&pr );

    if (iret == TRUE)
    {
        pmxud->mxid     = pr.uDeviceID;
        pmxud->iDest    = pr.dwDestination;
        pmxud->dwFlags  &= ~MXUD_FLAGSF_MIXER;
        pmxud->dwFlags  |= (pr.fMixer)?MXUD_FLAGSF_MIXER:0L;
        pmxud->dwStyle  = pr.dwStyle;
    }    

    return (iret == -1) ? FALSE : TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mixerapp\dlg.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       dlg.c
 *  Purpose:    dialog template aggregator
 * 
 *  Copyright (c) 1985-1998 Microsoft Corporation
 *
 *****************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <string.h>
#include "dlg.h"
#include <winuserp.h>

/*
 * DlgLoadResource
 *
 * */
HGLOBAL Dlg_LoadResource(
    HINSTANCE hModule,
    LPCTSTR   lpszName,
    DWORD     *pcbSize)
{
    HRSRC hrsrc;
    HGLOBAL hres;
    HGLOBAL hlock;
    
    hrsrc = FindResource(hModule, lpszName, RT_DIALOG);        
    if (!hrsrc)
        return NULL;

    hres = LoadResource(hModule, hrsrc);
    
    if (!hres)
        return NULL;
    
    hlock = LockResource(hres);
    if (pcbSize)
    {
        if (hlock)
            *pcbSize = SizeofResource(hModule, hrsrc);
        else
            *pcbSize = 0L;
    }
    return hlock;
}


/*
 * DlgHorizAttach
 * - Attaches a dialog template horizontally to another dialog
 * - if lpMain == NULL allocs a new dialog copy.
 *
 * */
LPBYTE Dlg_HorizAttach(
    LPBYTE  lpMain,
    DWORD   cbMain,
    LPBYTE  lpAdd,
    DWORD   cbAdd,
    WORD    wIdOffset,
    DWORD   *pcbNew)
{
    LPBYTE  lpDst;
    LPBYTE  lpDstOffset;
    LPBYTE  lpSrcOffset;        
    DWORD   cbDst;
    DWORD   cbOffset = 0L, cbAddOffset;
    int     idit;
    BOOL    bDialogEx;
    int     iditCount;
    
    DLGTEMPLATE * lpdtDst;
    DLGTEMPLATE * lpdtAdd;    
    DLGTEMPLATE2 * lpdtDst2;
    DLGTEMPLATE2 * lpdtAdd2;    
        
    if (lpMain)
    {
        cbDst = cbMain + cbAdd;
        lpDst = GlobalReAllocPtr(lpMain, cbDst, GHND);
    }
    else
    {
        // no dialog to append to, so just make a copy
        
        lpDst = Dlg_HorizDupe(lpAdd, cbAdd, 1, &cbDst);
        if (!lpDst)
        {
            if (pcbNew)
                *pcbNew = 0L;
            return NULL;
        }
        *pcbNew = cbDst;
        return lpDst;
    }
    
    if (!lpDst)
    {
        if (pcbNew)
            *pcbNew = 0L;
        return NULL;
    }

    // advance to end of dlgitemtemplates already there

    if(((DLGTEMPLATE2 *)lpDst)->wSignature == 0xffff) 
    {    
        //
        //  We assume lpdtDst and lpdtAdd are both the same type of 
        //  template, either DIALOG or DIALOGEX
        //
        lpdtDst2 = (DLGTEMPLATE2 *)lpDst;
        iditCount = lpdtDst2->cDlgItems;
        bDialogEx = TRUE;
    }
    else
    {
        
        lpdtDst = (DLGTEMPLATE *)lpDst;
        iditCount = lpdtDst->cdit;
        bDialogEx = FALSE;
    }
    cbOffset = Dlg_CopyDLGTEMPLATE(NULL, lpDst, bDialogEx);
    
    for (idit = 0; idit < iditCount; idit++)
    {
        DWORD cbDIT;
            
        lpDstOffset = lpDst + cbOffset;
        cbDIT = Dlg_CopyDLGITEMTEMPLATE(NULL
                                       , lpDstOffset
                                       , (WORD)0
                                       , (short)0
                                       , (short)0 
                                       , bDialogEx);
            
        cbOffset    += cbDIT;
    }

    // advance to the start of the dlgitemtemplates to add
    
    if (bDialogEx)
    {
        lpdtAdd2 = (DLGTEMPLATE2 *)lpAdd;
        iditCount = lpdtAdd2->cDlgItems;
    }
    else
    {
        lpdtAdd = (DLGTEMPLATE *)lpAdd;
        iditCount = lpdtAdd->cdit;
    }

    cbAddOffset = Dlg_CopyDLGTEMPLATE(NULL, lpAdd, bDialogEx);

    // add the new dialog templates
    
    for (idit = 0; idit < iditCount; idit++)
    {
        DWORD cbDIT;
        short cx = bDialogEx ? lpdtDst2->cx : lpdtDst->cx;
            
        lpDstOffset = lpDst + cbOffset;
        lpSrcOffset = lpAdd + cbAddOffset;
                
        cbDIT = Dlg_CopyDLGITEMTEMPLATE(lpDstOffset
                                       , lpSrcOffset
                                       , (WORD)wIdOffset
                                       , cx
                                       , (short)0 
                                       , bDialogEx);
            
        cbOffset    += cbDIT;
        cbAddOffset += cbDIT;
    }

    if (bDialogEx)
    {
        lpdtDst2->cDlgItems += lpdtAdd2->cDlgItems;
        lpdtDst2->cx   += lpdtAdd2->cx;
        lpdtDst2->cy   = max(lpdtAdd2->cy, lpdtDst2->cy);
    }
    else
    {
        lpdtDst->cdit += lpdtAdd->cdit;
        lpdtDst->cx   += lpdtAdd->cx;
        lpdtDst->cy   = max(lpdtAdd->cy, lpdtDst->cy);
    }

    if (pcbNew)
        *pcbNew = cbOffset;
    
    return lpDst;
}

/*
 * Dlg_HorizSize
 *
 * Returns width of dialog box in dlu's.
 *
 * */
DWORD Dlg_HorizSize(
    LPBYTE lpDlg)
{
    if(((DLGTEMPLATE2 *)lpDlg)->wSignature == 0xffff) 
    {    
        return (((DLGTEMPLATE2 *)lpDlg)->cx - 2);  // Compensate for right side trimming
    }
    else
    {
        return (((DLGTEMPLATE *)lpDlg)->cx - 2);  // Compensate for right side trimming
    }
}

/*
 * DlgHorizDupe
 *
 * */
LPBYTE Dlg_HorizDupe(
    LPBYTE  lpSrc,
    DWORD   cbSrc,
    int     cDups,
    DWORD   *pcbNew)
{
    int     idit;
    int     iDup;
    DWORD   cbOffset;
    DWORD   cbDTOffset;
    DWORD   cbDT0Offset;
    LPBYTE  lpDst;
    DLGTEMPLATE * lpdt;
    DLGTEMPLATE2 * lpdt2;
    LPBYTE  lpDstOffset;
    LPBYTE  lpSrcOffset;
    DWORD   cbSize;
    int     iCount;
    BOOL    bDialogEx;
    
    cbSize = cDups * cbSrc;
    //DWORD align
    cbSize = (cbSize + 3)&~3;
    
    lpDst = GlobalAllocPtr(GHND, cbSize);
    if (!lpDst)
        return NULL;
    
    if(((DLGTEMPLATE2 *)lpSrc)->wSignature == 0xffff) 
    {
        lpdt2 = (DLGTEMPLATE2 *)lpDst;
        iCount = ((DLGTEMPLATE2 *)lpSrc)->cDlgItems;
        bDialogEx = TRUE;
    }
    else
    {
        lpdt = (DLGTEMPLATE *)lpDst;
        iCount = ((DLGTEMPLATE *)lpSrc)->cdit;
        bDialogEx = FALSE;
    }
    cbDT0Offset = cbDTOffset = cbOffset = Dlg_CopyDLGTEMPLATE(lpDst,lpSrc, bDialogEx);

    for (iDup = 0; iDup < cDups; iDup++)
    {
        // reset the DTOffset to the first DIT
        cbDTOffset = cbDT0Offset;
        
        for (idit = 0; idit < iCount; idit++)
        {
            DWORD cbDIT;
            short cx = bDialogEx ? lpdt2->cx : lpdt->cx;
            
            lpDstOffset = lpDst + cbOffset;
            lpSrcOffset = lpSrc + cbDTOffset;
                
            cbDIT = Dlg_CopyDLGITEMTEMPLATE(lpDstOffset
                , lpSrcOffset
                , (WORD)(iDup * IDOFFSET)   // all id increments are by IDOFFSET
                , (short)(iDup * cx)
                , (short)0                  // no y increments
                , bDialogEx);                 
            
            cbOffset    += cbDIT;
            cbDTOffset  += cbDIT;
        }
    }

    // adjust template width and number of items    
    if (bDialogEx)
    {
        lpdt2->cDlgItems  *= (WORD)cDups;
        lpdt2->cx    *= (short)cDups;
    }
    else
    {
        lpdt->cdit  *= (WORD)cDups;
        lpdt->cx    *= (short)cDups;
    }
    
    if (pcbNew)
        *pcbNew = cbOffset;
    
    return lpDst;
}


/*
 * DlgCopyDLGITEMTEMPLATE
 *
 * if lpDst == NULL only returns offset into lpSrc of next dlgitemtemplate
 * */
DWORD Dlg_CopyDLGITEMTEMPLATE(
    LPBYTE  lpDst,
    LPBYTE  lpSrc,
    WORD    wIdOffset,
    short   xOffset,
    short   yOffset,
    BOOL    bDialogEx)
{
    LPBYTE  lpOffset;
    DWORD   cbDlg=bDialogEx ? sizeof(DLGITEMTEMPLATE2):sizeof(DLGITEMTEMPLATE);
    DLGITEMTEMPLATE * lpdit;
    DLGITEMTEMPLATE2 * lpdit2;
    
    if (bDialogEx)
    {
        lpdit2= (DLGITEMTEMPLATE2 *)lpDst;
    }
    else
    {
        lpdit = (DLGITEMTEMPLATE *)lpDst;
    }
    // Control class
    
    lpOffset = lpSrc + cbDlg;
    if (*(LPWORD)lpOffset == 0xFFFF)
    {
        cbDlg += 2*sizeof(WORD);
    }
    else
    {
        cbDlg += (wcslen((LPWSTR)lpOffset) + 1) * sizeof(WCHAR);
    }

    lpOffset = lpSrc + cbDlg;
    if (*(LPWORD)lpOffset == 0xFFFF)
    {
        cbDlg += 2*sizeof(WORD);
    }
    else
    {
        cbDlg += (wcslen((LPWSTR)lpOffset) + 1) * sizeof(WCHAR);
    }

    cbDlg += sizeof(WORD);
        
    // DWORD align.
    cbDlg = (cbDlg + 3)&~3;

    if (lpDst)
    {
        CopyMemory(lpDst, lpSrc, cbDlg);
    
        if (bDialogEx)
        {
            lpdit2->x    += xOffset;
            lpdit2->y    += yOffset;

            // id offset only if the control isn't static
            if (lpdit2->dwID != -1)
                lpdit2->dwID += wIdOffset;
        }
        else
        {
            lpdit->x    += xOffset;
            lpdit->y    += yOffset;

            // id offset only if the control isn't static
            if (lpdit->id != -1)
                lpdit->id += wIdOffset;
        }
        
    }
    return cbDlg;
}
    
/*
 * DlgCopyDLGTEMPLATE
 *
 * if lpDst == NULL only returns offset into lpSrc to first dlgitemtemplate
 *
 * */
DWORD Dlg_CopyDLGTEMPLATE(
    LPBYTE lpDst,
    LPBYTE lpSrc,
    BOOL   bDialogEx)
{
    LPBYTE  lpOffset;
    UINT    uiStyle;
    DWORD   cbDlg = bDialogEx ? sizeof(DLGTEMPLATE2) : sizeof(DLGTEMPLATE);

    // Menu description

    lpOffset = lpSrc + cbDlg;
    if (*(LPWORD)lpOffset == 0xFFFF)
    {
        cbDlg += 2*sizeof(WORD);
    }
    else if (*(LPWORD)lpOffset == 0x0000)
    {
        cbDlg += sizeof(WORD);
    }
    else
    {
        cbDlg += (wcslen((LPWSTR)lpOffset) + 1)*sizeof(WCHAR);
    }

    // Window class

    lpOffset = lpSrc + cbDlg;
    if (*(LPWORD)lpOffset == 0xFFFF)
    {
        cbDlg += 2*sizeof(WORD);
    }
    else if (*(LPWORD)lpOffset == 0x0000)
    {
        cbDlg += sizeof(WORD);
    }
    else
    {
        cbDlg += (wcslen((LPWSTR)lpOffset) + 1) * sizeof(WCHAR);
    }

    // Title

    lpOffset = lpSrc + cbDlg;
    cbDlg += (wcslen((LPWSTR)lpOffset) + 1) * sizeof(WCHAR);

    // Font
    if (bDialogEx)
    {
        uiStyle = ((DLGTEMPLATE2 * )lpSrc)->style;
    }
    else
    {
        uiStyle = ((DLGTEMPLATE * )lpSrc)->style;
    }

    if (uiStyle & DS_SETFONT) 
    {
        cbDlg += sizeof(WORD);
        if (bDialogEx)
        {
            cbDlg += sizeof(WORD);
            cbDlg += sizeof(BYTE);
            cbDlg += sizeof(BYTE);
        }
        lpOffset = lpSrc + cbDlg;
        cbDlg += (wcslen((LPWSTR)lpOffset) + 1) *sizeof(WCHAR);
    }
    // DWORD align
    
    cbDlg = (cbDlg + 3)&~3;

    // copy the dlgtemplate into the destination.
    if (lpDst)
        CopyMemory(lpDst, lpSrc, cbDlg);
    
    return cbDlg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mixerapp\pvcd.h ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       pvcd.h
 *  Purpose:    Volume Control Descriptor
 *
 *  Copyright (c) 1985-1995 Microsoft Corporation
 *
 *****************************************************************************/

#define VCD_TYPE_MIXER          0
#define VCD_TYPE_AUX            1
#define VCD_TYPE_WAVEOUT        2
#define VCD_TYPE_MIDIOUT        3

#define VCD_SUPPORTF_STEREO     0x00000000
#define VCD_SUPPORTF_MONO       0x00000001
#define VCD_SUPPORTF_DISABLED   0x00000002
#define VCD_SUPPORTF_HIDDEN     0x00000004  // hidden by choice
#define VCD_SUPPORTF_BADDRIVER  0x00000008
#define VCD_SUPPORTF_VISIBLE    0x00000010  // not visible (i.e. no controls)
#define VCD_SUPPORTF_DEFAULT    0x00000020  // default type

#define VCD_SUPPORTF_MIXER_MUTE       0x00010000
#define VCD_SUPPORTF_MIXER_METER      0x00020000
#define VCD_SUPPORTF_MIXER_MUX        0x00040000
#define VCD_SUPPORTF_MIXER_MIXER      0x00080000
#define VCD_SUPPORTF_MIXER_VOLUME     0x00100000
#define VCD_SUPPORTF_MIXER_ADVANCED   0x80000000

#define VCD_VISIBLEF_MIXER_MUTE       0x00000001
#define VCD_VISIBLEF_MIXER_METER      0x00000002
#define VCD_VISIBLEF_MIXER_MUX        0x00000004
#define VCD_VISIBLEF_MIXER_MIXER      0x00000008
#define VCD_VISIBLEF_MIXER_VOLUME     0x00000010
#define VCD_VISIBLEF_MIXER_ADVANCED   0x00008000


//
// The generic volume control descriptor
//
typedef struct t_VOLCTRLDESC {
    //
    // for all
    //
    int         iVCD;                   // descriptor index
    UINT        iDeviceID;              // device identifier

    DWORD       dwType;                 // type bits
    DWORD       dwSupport;              // support bits
    DWORD       dwVisible;              // control visibility flags

    TCHAR       szShortName[MIXER_SHORT_NAME_CHARS];     // short name
    TCHAR       szName[MIXER_LONG_NAME_CHARS];      // line label

    struct t_MIXUILINE * pmxul;         // back pointer to a ui

    union {
        struct {

            //
            // for mixer
            //

            HMIXER      hmx;            // open device handle

            BOOL        fIsSource;      // is source line
            DWORD       dwDest;         // destination index
            DWORD       dwSrc;          // source index
            DWORD       dwLineID;       // mixer line id

            DWORD       dwVolumeID;     // VOLUME control id
            DWORD       fdwVolumeControl; // Control flags for Volume control

            //
            // For mixers and mux
            //

            DWORD       dwMuteID;       // MUTE control id
            DWORD       fdwMuteControl; // Control flags for Mute control
            DWORD       dwMeterID;      // PEAKMETER control id

            DWORD       dwMixerID;      // MUX/MIXER control id
            DWORD       iMixer;         // mixer index
            DWORD       cMixer;         // mixer controls
            PMIXERCONTROLDETAILS_BOOLEAN amcd_bMixer;// mixer array

            DWORD       dwMuxID;        // MUX/MIXER control id
            DWORD       iMux;           // mux index
            DWORD       cMux;           // mux controls
            PMIXERCONTROLDETAILS_BOOLEAN amcd_bMux;// mux array

            double*     pdblCacheMix;   // Volume Channel mix cache

        };
        struct {

            //
            // for wave
            //

            HWAVEOUT    hwo;            // open device handle
        };
        struct {

            //
            // for midi
            //

            HMIDIOUT    hmo;            // open device handle
        };
        struct {

            //
            // for aux
            //

            DWORD       dwParam;        // nothing
        };
    };

} VOLCTRLDESC, *PVOLCTRLDESC;

extern PVOLCTRLDESC Mixer_CreateVolumeDescription(HMIXEROBJ hmx, int iDest, DWORD *pcvcd);
extern void Mixer_CleanupVolumeDescription(PVOLCTRLDESC avcd, DWORD cvcd);

extern int  Mixer_GetNumDevs(void);
extern BOOL Mixer_Init(PMIXUIDIALOG pmxud);
extern void Mixer_GetControlFromID(PMIXUIDIALOG pmxud, DWORD dwControlID);
extern void Mixer_GetControl(PMIXUIDIALOG pmxud, HWND hctl, int imxul, int ictl);
extern void Mixer_SetControl(PMIXUIDIALOG pmxud, HWND hctl, int imxul, int ictl);
extern void Mixer_PollingUpdate(PMIXUIDIALOG pmxud);
extern void Mixer_Shutdown(PMIXUIDIALOG pmxud);
extern BOOL Mixer_GetDeviceName(PMIXUIDIALOG pmxud);
extern BOOL Mixer_IsValidRecordingDestination (HMIXEROBJ hmx, MIXERLINE* pmlDst);

extern PVOLCTRLDESC Nonmixer_CreateVolumeDescription(int iDest, DWORD *pcvcd);
extern int  Nonmixer_GetNumDevs(void);
extern BOOL Nonmixer_Init(PMIXUIDIALOG pmxud);
extern void Nonmixer_GetControl(PMIXUIDIALOG pmxud, HWND hctl, int imxul, int ictl);
extern void Nonmixer_SetControl(PMIXUIDIALOG pmxud, HWND hctl, int imxul, int ictl);
extern void Nonmixer_PollingUpdate(PMIXUIDIALOG pmxud);
extern void Nonmixer_Shutdown(PMIXUIDIALOG pmxud);
extern BOOL Nonmixer_GetDeviceName(PMIXUIDIALOG pmxud);

extern PVOLCTRLDESC PVCD_AddLine(PVOLCTRLDESC pvcd, int iDev, DWORD dwType, LPTSTR szProduct, LPTSTR szLabel, DWORD dwSupport, DWORD *cLines);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mixerapp\nonmixer.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       nonmixer.c
 *  Purpose:    non-mixer api specific implementations
 * 
 *  Copyright (c) 1985-1995 Microsoft Corporation
 *
 *****************************************************************************/
/*
 * These are the volume control api's we have to work with.
 * 
 * WINMMAPI MMRESULT WINAPI midiOutGetVolume(HMIDIOUT hmo, LPDWORD pdwVolume);
 * WINMMAPI MMRESULT WINAPI midiOutSetVolume(HMIDIOUT hmo, DWORD dwVolume);
 * WINMMAPI MMRESULT WINAPI waveOutGetVolume(UINT uId, LPDWORD pdwVolume);
 * WINMMAPI MMRESULT WINAPI waveOutSetVolume(UINT uId, DWORD dwVolume);
 * WINMMAPI MMRESULT WINAPI auxSetVolume(UINT uDeviceID, DWORD dwVolume);
 * WINMMAPI MMRESULT WINAPI auxGetVolume(UINT uDeviceID, LPDWORD pdwVolume);
 *
 * */

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>

#include "volumei.h"

int Nonmixer_GetNumDevs()
{
    UINT    cNumDevs = 0;
    int     iDev;
    UINT    uMxID;
    BOOL    fAdd = FALSE;
    
    //
    // Is aux support required?
    //
    iDev = auxGetNumDevs();
    for (;iDev > 0; iDev --)
    {
        if (mixerGetID((HMIXEROBJ)IntToPtr(iDev-1)
                       , &uMxID
                       , MIXER_OBJECTF_AUX) == MMSYSERR_NODRIVER)
        {
            AUXCAPS     axcaps;
            
            if (auxGetDevCaps(iDev-1, &axcaps, sizeof(AUXCAPS))
                == MMSYSERR_NOERROR)
            {
                if (axcaps.dwSupport & AUXCAPS_VOLUME)
                    fAdd = TRUE;
            }
        }
    }
    if (fAdd)
        cNumDevs++;

    iDev = midiOutGetNumDevs();
    for (; iDev > 0; iDev --)
    {
        if (mixerGetID((HMIXEROBJ)IntToPtr(iDev-1)
                       , &uMxID
                       , MIXER_OBJECTF_MIDIOUT) == MMSYSERR_NODRIVER)
        {
            MIDIOUTCAPS     mocaps;
            
            if (midiOutGetDevCaps(iDev-1, &mocaps, sizeof(MIDIOUTCAPS))
                == MMSYSERR_NOERROR)
            {
                if ((mocaps.dwSupport & MIDICAPS_VOLUME) ||
                    (mocaps.dwSupport & MIDICAPS_LRVOLUME))
                    fAdd = TRUE;
            }
        }
    }
    if (fAdd)
        cNumDevs++;
    
    iDev = waveOutGetNumDevs();
    for (; iDev > 0; iDev --)
    {
        if (mixerGetID((HMIXEROBJ)IntToPtr(iDev-1)
                       , &uMxID
                       , MIXER_OBJECTF_WAVEOUT) == MMSYSERR_NODRIVER)
        {
            WAVEOUTCAPS     wocaps;
            
            if (waveOutGetDevCaps(iDev-1, &wocaps, sizeof(WAVEOUTCAPS))
                == MMSYSERR_NOERROR)
            {
                if ((wocaps.dwSupport & WAVECAPS_VOLUME) ||
                    (wocaps.dwSupport & WAVECAPS_LRVOLUME))
                    fAdd = TRUE;
            }
        }
    }
    if (fAdd)
        cNumDevs++;

    return cNumDevs;
    
}

void Nonmixer_SetLines(
    PVOLCTRLDESC    pvcd)
{
    ;
}

const TCHAR szAuxIn[]	= TEXT ("Aux-In");
const TCHAR szCD[]		= TEXT ("CDROM");
const TCHAR szAux[]		= TEXT ("Aux");
const TCHAR szMidiOut[] = TEXT ("Midi-Out");
                    

/*
 * Nonmixer_CreateVolumeDescription
 *
 * Return an array of volumedescriptions
 *
 */
PVOLCTRLDESC Nonmixer_CreateVolumeDescription (
    int             iDest,
    DWORD *         pcvcd )
{
    int             iDev;
    PVOLCTRLDESC    pvcd = NULL;
    UINT            uMxID;
    DWORD           cLines = 0;
    
    //
    // aux's
    //

    for (iDev = auxGetNumDevs(); iDev > 0; iDev --)
    {
        if (mixerGetID((HMIXEROBJ)IntToPtr(iDev-1)
                       , &uMxID
                       , MIXER_OBJECTF_AUX) == MMSYSERR_NODRIVER)
        {
            AUXCAPS     axcaps;
            
            if (auxGetDevCaps(iDev-1, &axcaps, sizeof(AUXCAPS))
                == MMSYSERR_NOERROR)
            {
                if (axcaps.dwSupport & AUXCAPS_VOLUME)
                {
                    LPCTSTR pszLabel;
                    DWORD dwSupport = 0L;
                    
                    pszLabel = szAux;
                    
                    pszLabel = axcaps.wTechnology & AUXCAPS_CDAUDIO
                               ? szCD : pszLabel;
                    pszLabel = axcaps.wTechnology & AUXCAPS_AUXIN
                               ? szAuxIn : pszLabel;

                    dwSupport |= axcaps.dwSupport & AUXCAPS_LRVOLUME ? VCD_SUPPORTF_STEREO : VCD_SUPPORTF_MONO;
                    
                    pvcd = PVCD_AddLine(pvcd
                                        , iDev
                                        , VCD_TYPE_AUX
                                        , axcaps.szPname
                                        , (LPTSTR)pszLabel
                                        , dwSupport
                                        , &cLines );
                                      
                }
            }
        }
    }
    
    for (iDev = midiOutGetNumDevs(); iDev > 0; iDev --)
    {
        if (mixerGetID((HMIXEROBJ)IntToPtr(iDev-1)
                       , &uMxID
                       , MIXER_OBJECTF_MIDIOUT) == MMSYSERR_NODRIVER)
        {
            MIDIOUTCAPS     mocaps;
            
            if (midiOutGetDevCaps(iDev-1, &mocaps, sizeof(MIDIOUTCAPS))
                == MMSYSERR_NOERROR)
            {
                if (mocaps.dwSupport & MIDICAPS_VOLUME)
                {
                    DWORD dwSupport = 0L;

                    dwSupport |= mocaps.dwSupport & MIDICAPS_LRVOLUME ? VCD_SUPPORTF_STEREO : VCD_SUPPORTF_MONO;
                    
                    pvcd = PVCD_AddLine(pvcd
                                        , iDev
                                        , VCD_TYPE_MIDIOUT
                                        , mocaps.szPname
                                        , (LPTSTR)szMidiOut
                                        , dwSupport
                                        , &cLines );
                }
            }
        }
    }
    
    iDev = waveOutGetNumDevs();
    for (; iDev > 0; iDev --)
    {
        if (mixerGetID((HMIXEROBJ)IntToPtr(iDev-1)
                       , &uMxID
                       , MIXER_OBJECTF_WAVEOUT) == MMSYSERR_NODRIVER)
        {
            WAVEOUTCAPS     wocaps;
            
            if (waveOutGetDevCaps(iDev-1, &wocaps, sizeof(WAVEOUTCAPS))
                == MMSYSERR_NOERROR)
            {
                if (wocaps.dwSupport & WAVECAPS_VOLUME)
                {
                    const TCHAR szWaveOut[] = TEXT ("Wave-Out");
                    DWORD dwSupport = 0L;
                    
                    dwSupport |= wocaps.dwSupport & WAVECAPS_LRVOLUME ? VCD_SUPPORTF_STEREO : VCD_SUPPORTF_MONO;

                    pvcd = PVCD_AddLine(pvcd
                                        , iDev
                                        , VCD_TYPE_WAVEOUT
                                        , wocaps.szPname
                                        , (LPTSTR)szWaveOut
                                        , dwSupport
                                        , &cLines );
                }
            }
        }
    }

    //
    // Setup indicies, etc...
    //
    Nonmixer_SetLines(pvcd);
    
    *pcvcd = cLines;
    
    return pvcd;
}

void Nonmixer_PollingUpdate(
    PMIXUIDIALOG pmxud)
{
    
}
BOOL Nonmixer_Init(
    PMIXUIDIALOG pmxud)
{
    return TRUE;
}

void Nonmixer_GetControl(
    PMIXUIDIALOG    pmxud,
    HWND            hctl,
    int             imxul,
    int             ictl)
{
    ;
}

void Nonmixer_SetControl(
    PMIXUIDIALOG    pmxud,
    HWND            hctl,
    int             imxul,
    int             ictl)
{
    ;
}

void Nonmixer_Shutdown(
    PMIXUIDIALOG    pmxud)
{
    ;
}

const TCHAR szNonMixer[] = TEXT ("Wave,MIDI,Aux");
BOOL Nonmixer_GetDeviceName(
    PMIXUIDIALOG    pmxud)
{
    lstrcpy(pmxud->szMixer, szNonMixer);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mixerapp\pvcd.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       pvcd.c
 *  Purpose:    volume control line meta description
 * 
 *  Copyright (c) 1985-1995 Microsoft Corporation
 *
 *****************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include <windowsx.h>

#include "volumei.h"

PVOLCTRLDESC PVCD_AddLine(
    PVOLCTRLDESC        pvcd,
    int                 iDev,
    DWORD               dwType,
    LPTSTR              szShortName,
    LPTSTR              szName,
    DWORD               dwSupport,
    DWORD               *cLines)
{
    PVOLCTRLDESC        pvcdNew;
    
    if (pvcd)
    {
        pvcdNew = (PVOLCTRLDESC)GlobalReAllocPtr(pvcd, (*cLines+1)*sizeof(VOLCTRLDESC), GHND );
    }
    else
    {
        pvcdNew = (PVOLCTRLDESC)GlobalAllocPtr(GHND, (*cLines+1)*sizeof(VOLCTRLDESC));
    }
    
    if (!pvcdNew)
        return NULL;

    pvcdNew[*cLines].iVCD       = *cLines;
    pvcdNew[*cLines].iDeviceID  = iDev;
    pvcdNew[*cLines].dwType     = dwType;
    pvcdNew[*cLines].dwSupport  = dwSupport;
    
    lstrcpyn(pvcdNew[*cLines].szShortName
             , szShortName
             , MIXER_SHORT_NAME_CHARS);
    
    lstrcpyn(pvcdNew[*cLines].szName
             , szName
             , MIXER_LONG_NAME_CHARS);

    *cLines = *cLines + 1;
    return pvcdNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mixerapp\reg.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       reg.c
 *  Purpose:    registry access functions
 * 
 *  Copyright (c) 1985-1995 Microsoft Corporation
 *
 *****************************************************************************/
#include <windows.h>
#include <regstr.h>

// Note: The following line generates a UNICODE error
//       so it has been replaced by the line after.
//const TCHAR szRegPath[] = REGSTR_PATH_WINDOWSAPPLETS "\\Volume Control";
const TCHAR szRegPath[] = TEXT ("Software\\Microsoft\\Windows\\CurrentVersion\\Applets\\Volume Control");


/* ReadRegistryData
 *
 * Reads information from the registry
 *
 * Parameters:
 *
 *     pEntryNode - The node under Media Player which should be opened
 *         for this data.  If this is NULL, the value is
 *         written directly under szRegPath.
 *
 *     pEntryName - The name of the value under pEntryNode to be retrieved.
 *
 *     pType - Pointer to a buffer to receive type of data read.  May be NULL.
 *
 *     pData - Pointer to a buffer to receive the value data.
 *
 *     Size - Size, in bytes, of the buffer pointed to by pData.
 *
 * Return:
 *
 *     Registry status return (NO_ERROR is good)
 *
 *
 * Andrew Bell (andrewbe) wrote it, 10 September 1992
 *
 */
DWORD ReadRegistryData( LPTSTR pEntryNode,
                        LPTSTR pEntryName,
                        PDWORD pType,
                        LPBYTE pData,
                        DWORD  DataSize )
{
    DWORD  Status;
    HKEY   hkeyRegPath;
    HKEY   hkeyEntryNode;
    DWORD  Size;

    /* Open the top-level node.  For Media Player this is:
     * "Software\\Microsoft\\Windows NT\\CurrentVersion\\Sound Recorder"
     */
    Status = RegOpenKeyEx( HKEY_CURRENT_USER, szRegPath, 0,
                           KEY_READ, &hkeyRegPath );

    if( Status == NO_ERROR )
    {
        /* Open the sub-node:
         */
        if( pEntryNode )
            Status = RegOpenKeyEx( hkeyRegPath, pEntryNode, 0,
                                   KEY_READ, &hkeyEntryNode );
        else
            hkeyEntryNode = hkeyRegPath;

        if( Status == NO_ERROR )
        {
            Size = DataSize;

            /* Read the entry from the registry:
             */
            Status = RegQueryValueEx( hkeyEntryNode,
                                      pEntryName,
                                      0,
                                      pType,
                                      pData,
                                      &Size );

            if( pEntryNode )
                RegCloseKey( hkeyEntryNode );
        }

        RegCloseKey( hkeyRegPath );
    }
    return Status;
}
DWORD QueryRegistryDataSize(
    LPTSTR  pEntryNode,
    LPTSTR  pEntryName,
    DWORD   *pDataSize )
{
    DWORD  Status;
    HKEY   hkeyRegPath;
    HKEY   hkeyEntryNode;
    DWORD  Size;

    /* Open the top-level node.  For Media Player this is:
     * "Software\\Microsoft\\Windows NT\\CurrentVersion\\Sound Recorder"
     */
    Status = RegOpenKeyEx( HKEY_CURRENT_USER, szRegPath, 0,
                           KEY_READ, &hkeyRegPath );

    if( Status == NO_ERROR )
    {
        /* Open the sub-node:
         */
        if( pEntryNode )
            Status = RegOpenKeyEx( hkeyRegPath, pEntryNode, 0,
                                   KEY_READ, &hkeyEntryNode );
        else
            hkeyEntryNode = hkeyRegPath;

        if( Status == NO_ERROR )
        {
            /* Read the entry from the registry:
             */
            Size = 0;
            Status = RegQueryValueEx( hkeyEntryNode,
                                      pEntryName,
                                      0,
                                      NULL,
                                      NULL,
                                      &Size );
            if (Status == NO_ERROR)
                *pDataSize = Size;

            if( pEntryNode )
                RegCloseKey( hkeyEntryNode );
        }

        RegCloseKey( hkeyRegPath );
    }
    return Status;
}
/* WriteRegistryData
 *
 * Writes a bunch of information to the registry
 *
 * Parameters:
 *
 *     pEntryNode - The node under szRegPath which should be created
 *         or opened for this data.  If this is NULL, the value is
 *         written directly under szRegPath.
 *
 *     pEntryName - The name of the value under pEntryNode to be set.
 *
 *     Type - Type of data to read (e.g. REG_SZ).
 *
 *     pData - Pointer to the value data to be written.  If this is NULL,
 *         the value under pEntryNode is deleted.
 *
 *     Size - Size, in bytes, of the buffer pointed to by pData.
 *
 *
 * This routine is fairly generic, apart from the name of the top-level node.
 *
 * The data are stored in the following registry tree:
 *
 * HKEY_CURRENT_USER
 *  
 *   Software
 *      
 *       Microsoft
 *          
 *           Windows NT
 *              
 *               CurrentVersion
 *                  
 *                   Media Player
 *                      
 *                       AVIVideo
 *                      
 *                       DisplayPosition
 *                      
 *                       SysIni
 *
 *
 * Return:
 *
 *     Registry status return (NO_ERROR is good)
 *
 *
 * Andrew Bell (andrewbe) wrote it, 10 September 1992
 *
 */
DWORD WriteRegistryData( LPTSTR pEntryNode,
                         LPTSTR pEntryName,
                         DWORD  Type,
                         LPBYTE pData,
                         DWORD  Size )
{
    DWORD  Status;
    HKEY   hkeyRegPath;
    HKEY   hkeyEntryNode;

    /* Open or create the top-level node.  For Media Player this is:
     * "Software\\Microsoft\\Windows NT\\CurrentVersion\\Media Player"
     */
    Status = RegCreateKeyEx( HKEY_CURRENT_USER, szRegPath, 0,
                             NULL, 0, KEY_WRITE, NULL, &hkeyRegPath, NULL );

    if( Status == NO_ERROR )
    {
        /* Open or create the sub-node.
         */
        if( pEntryNode )
            Status = RegCreateKeyEx( hkeyRegPath, pEntryNode, 0,
                                     NULL, 0, KEY_WRITE, NULL, &hkeyEntryNode, NULL );
        else
            hkeyEntryNode = hkeyRegPath;

        if( Status == NO_ERROR )
        {
            if( pData )
            {
                Status = RegSetValueEx( hkeyEntryNode,
                                        pEntryName,
                                        0,
                                        Type,
                                        pData,
                                        Size );

            }
            else
            {
                Status = RegDeleteValue( hkeyEntryNode, pEntryName );
            }

            if( pEntryNode )
                RegCloseKey( hkeyEntryNode );
        }

        RegCloseKey( hkeyRegPath );
    }


    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mixerapp\volids.h ===
// Copyright (c) 1995-1997 Microsoft Corporation

#define IDD_MIXERDIALOGS                100
#define IDC_MIXERCONTROLS               1000
#define IDS_MIXERSTRINGS                200
#define IDM_MIXERMENUS                  0
#define IDI_MIXERICONS                  300
#define IDR_MIXERRES                    400

/* DIALOGBOX: IDD_DESTINATION */
#define IDD_DESTINATION                 101

/* CONTROLS */
#define IDC_SWITCH                      (IDC_MIXERCONTROLS+0)
#define IDC_VOLUME                      (IDC_MIXERCONTROLS+1)
#define IDC_BALANCE                     (IDC_MIXERCONTROLS+2)
#define IDC_LINELABEL                   (IDC_MIXERCONTROLS+4)
#define IDC_VUMETER                     (IDC_MIXERCONTROLS+5)
#define IDC_STATUSBAR                   (IDC_MIXERCONTROLS+21)
#define IDC_ADVANCED                    (IDC_MIXERCONTROLS+22)
#define IDC_BORDER                      (IDC_MIXERCONTROLS+23)
#define IDC_MULTICHANNEL                (IDC_MIXERCONTROLS+24)
#define IDC_MASTER_BALANCE_TEXT         (IDC_MIXERCONTROLS+25)
#define IDC_MASTER_BALANCE_ICON_1       (IDC_MIXERCONTROLS+26)
#define IDC_MASTER_BALANCE_ICON_2       (IDC_MIXERCONTROLS+27)

/* END DIALOGBOX: IDD_DESTINATION */


/* DIALOGBOX: IDD_SOURCE */
#define IDD_SOURCE                      102

/* CONTROLS */

/* END DIALOGBOX: IDD_SOURCE */


/* DIALOGBOX: IDD_CHOOSEDEVICE */
#define IDD_CHOOSEDEVICE                103

/* CONTROLS */
#define IDC_CHOOSELIST                  (IDC_MIXERCONTROLS+6)

/* END DIALOGBOX: IDD_CHOOSEDEVICE */


/* DIALOGBOX: IDD_CHOOSEOUTPUT */
#define IDD_CHOOSEOUTPUT                104

/* CONTROLS */
#define IDC_NEWWINDOW                   (IDC_MIXERCONTROLS+7)
/* END DIALOGBOX: IDD_CHOOSEOUTPUT */

/* DIALOGBOX: IDD_CHOOSELINES */
#define IDD_CHOOSELINES                 105

/* CONTROLS */

/* END DIALOGBOX: IDD_CHOOSEOUTPUT */

/*  DIALOGBOX: IDD_TRAYMASTER */
#define IDD_TRAYMASTER                  106

/* CONTROLS */
//#define IDC_ICONVOL                     (IDC_MIXERCONTROLS+8)
//#define IDC_ICONBAL                     (IDC_MIXERCONTROLS+9)
#define IDC_TRAYLABEL                   (IDC_MIXERCONTROLS+10)
#define IDC_VOLUMECUE                   (IDC_MIXERCONTROLS+11)
                          
/* END DIALOGBOX: IDD_TRAYMASTER */
                  
/*  DIALOGBOX: IDD_PROPERTIES */
#define IDD_PROPERTIES                  107

/* CONTROLS */
#define IDC_PROP_DEVICELIST             (IDC_MIXERCONTROLS+12)
#define IDC_PROP_PLAYBACK               (IDC_MIXERCONTROLS+13)
#define IDC_PROP_RECORDING              (IDC_MIXERCONTROLS+14)
#define IDC_PROP_OTHER                  (IDC_MIXERCONTROLS+15)
#define IDC_PROP_OTHERLIST              (IDC_MIXERCONTROLS+16)
#define IDC_PROP_VOLUMELIST             (IDC_MIXERCONTROLS+17)
#define IDC_PROP_TXT1                   (IDC_MIXERCONTROLS+18)
#define IDC_PROP_TXT2                   (IDC_MIXERCONTROLS+19)
#define IDC_PROP_VOLUMES                (IDC_MIXERCONTROLS+20)
#define IDC_PROP_ADVANCED               (IDC_MIXERCONTROLS+24)

/* END DIALOGBOX: IDD_TRAYMASTER */

/* DIALOGBOX: IDD_SM SRC/DST */
#define IDD_SMSRC                       108
#define IDD_SMDST                       109
/* END DIALOGBOX: IDD_SM SRC/DST */

/* DIALOGBOX: IDD_ADVANCED */
#define IDD_ADVANCED                    110
#define IDC_BASS                        (IDC_MIXERCONTROLS+25)
#define IDC_TREBLE                      (IDC_MIXERCONTROLS+26)
#define IDC_TXT_LOW1                    (IDC_MIXERCONTROLS+27)
#define IDC_TXT_LOW2                    (IDC_MIXERCONTROLS+28)
#define IDC_TXT_HI1                     (IDC_MIXERCONTROLS+29)
#define IDC_TXT_HI2                     (IDC_MIXERCONTROLS+30)
#define IDC_SWITCH1                     (IDC_MIXERCONTROLS+31)
#define IDC_SWITCH2                     (IDC_MIXERCONTROLS+32)
#define IDC_TXT_SWITCHES                (IDC_MIXERCONTROLS+33)
#define IDC_GRP_TONE                    (IDC_MIXERCONTROLS+34)
#define IDC_GRP_OTHER                   (IDC_MIXERCONTROLS+35)

          
/* END DIALOGBOX: IDD_ADVANCED */

/* FOR ACCESSIBILITY: These must be in a continuous range */
#define IDC_ACCESS_BALANCE              (IDC_MIXERCONTROLS+36)
#define IDC_ACCESS_VOLUME               (IDC_MIXERCONTROLS+37)
/* END FOR ACCESSIBILITY */

                    
/* MENU: */
#define IDR_MIXERMENU                   150
#define IDR_MODIFYMENU                  152

#define IDM_OPEN                        (IDM_MIXERMENUS + 2)
#define IDM_SAVE                        (IDM_MIXERMENUS + 3)
#define IDM_SAVEAS                      (IDM_MIXERMENUS + 4)
#define IDM_EXIT                        (IDM_MIXERMENUS + 5)
#define IDM_CHOOSEINPUT                 (IDM_MIXERMENUS + 6)
#define IDM_ADDINPUT                    (IDM_MIXERMENUS + 7)
#define IDM_CHOOSEOUTPUT                (IDM_MIXERMENUS + 8)
#define IDM_ADDOUTPUT                   (IDM_MIXERMENUS + 9)
#define IDM_HELPINDEX                   (IDM_MIXERMENUS + 10) // dead
#define IDM_HELPABOUT                   (IDM_MIXERMENUS + 11)
#define IDM_MASTERONLY                  (IDM_MIXERMENUS + 12)
#define IDM_TRAYMASTER                  (IDM_MIXERMENUS + 13)
#define IDM_CHOOSEDEVICE                (IDM_MIXERMENUS + 14)
#define IDM_CHOOSELINES                 (IDM_MIXERMENUS + 15)
#define IDM_CONTROLPANEL                (IDM_MIXERMENUS + 17)
#define IDM_STUB                        (IDM_MIXERMENUS + 18)
#define IDM_HELPTOPICS                  (IDM_MIXERMENUS + 19)
#define IDM_VOLUMECONTROL               (IDM_MIXERMENUS + 20)
#define IDM_PROPERTIES                  (IDM_MIXERMENUS + 21)         
#define IDM_SMALLMODESWITCH             (IDM_MIXERMENUS + 22)         
#define IDM_ALLWAYSONTOP                (IDM_MIXERMENUS + 23)
#define IDM_ADVANCED                    (IDM_MIXERMENUS + 24)

// do not exceed IDC_MIXERCONTROLS

/* END MENU: */


/* STRINGTABLE: */
#define IDS_FMTAPPTITLE                 (IDS_MIXERSTRINGS + 0)
#define IDS_APPTITLE                    (IDS_MIXERSTRINGS + 1)
#define IDS_TRAYNAME                    (IDS_MIXERSTRINGS + 2)
#define IDS_APPBASE                     (IDS_MIXERSTRINGS + 3)
#define IDS_LABEL_MASTER                (IDS_MIXERSTRINGS + 4)

#define IDS_LABEL_DST_VOLUME            (IDS_MIXERSTRINGS + 5)
#define IDS_LABEL_DST_RECORDING         (IDS_MIXERSTRINGS + 6)
#define IDS_LABEL_DST_UNDEFINED         (IDS_MIXERSTRINGS + 7)
#define IDS_LABEL_DST_DIGITAL           (IDS_MIXERSTRINGS + 8)
#define IDS_LABEL_DST_LINE              (IDS_MIXERSTRINGS + 9)
#define IDS_LABEL_DST_MONITOR           (IDS_MIXERSTRINGS + 10)
#define IDS_LABEL_DST_SPEAKERS          (IDS_MIXERSTRINGS + 11)
#define IDS_LABEL_DST_HEADPHONES        (IDS_MIXERSTRINGS + 12)
#define IDS_LABEL_DST_TELEPHONE         (IDS_MIXERSTRINGS + 13)
#define IDS_LABEL_DST_WAVEIN            (IDS_MIXERSTRINGS + 14)
#define IDS_LABEL_DST_VOICEIN           (IDS_MIXERSTRINGS + 15)

#define IDS_LABEL_SRC_UNDEFINED         IDS_LABEL_DST_UNDEFINED
#define IDS_LABEL_SRC_DIGITAL           IDS_LABEL_DST_DIGITAL
#define IDS_LABEL_SRC_LINE              IDS_LABEL_DST_LINE
#define IDS_LABEL_SRC_MICROPHONE        (IDS_MIXERSTRINGS + 17)
#define IDS_LABEL_SRC_SYNTHESIZER       (IDS_MIXERSTRINGS + 18)
#define IDS_LABEL_SRC_COMPACTDISC       (IDS_MIXERSTRINGS + 19)
#define IDS_LABEL_SRC_TELEPHONE         IDS_LABEL_DST_TELEPHONE
#define IDS_LABEL_SRC_PCSPEAKER         (IDS_MIXERSTRINGS + 20)
#define IDS_LABEL_SRC_WAVEOUT           (IDS_MIXERSTRINGS + 21)
#define IDS_LABEL_SRC_AUXILIARY         (IDS_MIXERSTRINGS + 22)
#define IDS_LABEL_SRC_ANALOG            (IDS_MIXERSTRINGS + 23)
#define IDS_LABEL_SRC_SNDBLST           (IDS_MIXERSTRINGS + 24)

#define IDS_MMSYSPROPTITLE              (IDS_MIXERSTRINGS + 25)
#define IDS_MMSYSPROPTAB                (IDS_MIXERSTRINGS + 26)

#define IDS_ERR_NODEV                   (IDS_MIXERSTRINGS + 27)
#define IDS_HELPFILENAME                (IDS_MIXERSTRINGS + 28)
#define IDS_HTMLHELPFILENAME            (IDS_MIXERSTRINGS + 29)
#define IDS_OTHERDEVICES                (IDS_MIXERSTRINGS + 30)
#define IDS_SELECT                      (IDS_MIXERSTRINGS + 31)
#define IDS_ERR_HARDWARE                (IDS_MIXERSTRINGS + 32)
#define IDS_IS_RTL                      (IDS_MIXERSTRINGS + 33)
#define IDS_ADV_TITLE                   (IDS_MIXERSTRINGS + 34)
#define IDS_ADV_SWITCH1                 (IDS_MIXERSTRINGS + 35)
#define IDS_ADV_SWITCH2                 (IDS_MIXERSTRINGS + 36)
#define IDS_MC_RECORDING                (IDS_MIXERSTRINGS + 37)
#define IDS_MC_LEVEL                    (IDS_MIXERSTRINGS + 38)

/* END STRINGTABLE: */

#define IDC_STATIC                      -1

/* BEGIN ICONS */
#define IDI_MIXER                       300
#define IDI_LSPEAKER                    301
#define IDI_RSPEAKER                    302
#define IDI_MUTE                        303
#define IDI_TRAY                        304

/* BEGIN OTHER RESOURCES */
#define IDR_VOLUMEACCEL                 401
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mixerapp\utils.h ===
// Copyright (c) 1995-1997 Microsoft Corporation

BOOL Volume_GetSetRegistryRect(
    LPTSTR       szMixer,
    LPTSTR       szDest,
    LPRECT       prc,
    BOOL         Get);
BOOL Volume_GetSetRegistryLineStates(
    LPTSTR       pszMixer,
    LPTSTR       pszDest,
    PVOLCTRLDESC pvcd,
    DWORD        cvcd,
    BOOL         Get);
void Volume_GetSetStyle(
    DWORD*       pdwStyle,
    BOOL         Get);
BOOL Volume_ErrorMessageBox(
    HWND         hwnd,
    HINSTANCE    hInst,
    UINT         id);
MMRESULT Volume_GetDefaultMixerID(
    int         *pid,
	BOOL		fRecord);
DWORD Volume_GetTrayTimeout(
    DWORD       dwTimeout);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mixerapp\volumei.h ===
// Copyright (c) 1995-1998 Microsoft Corporation

/*
 * Tray notification message
 * */
#define MYWM_BASE               (WM_APP+100)
//#define MYWM_NOTIFYICON         (MYWM_BASE+0)
#define MYWM_TIMER              (MYWM_BASE+1)
#define MYWM_RESTART            (MYWM_BASE+2)
//#define MYWM_FREECHILD          (MYWM_BASE+3)
//#define MYWM_ADDCHILD           (MYWM_BASE+4)
#define MYWM_HELPTOPICS         (MYWM_BASE+5)
#define MYWM_WAKEUP             (MYWM_BASE+6)

/*
 * MMSYS.CPL notifcation to kill tray volume
 * */
//#define MYWM_KILLTRAYVOLUME     (WM_USER+100)
//#define REGSTR_PATH_MEDIA       "SYSTEM\\CurrentControlSet\\Control\\MediaResources"
//#define REGSTR_PATH_MEDIATMP    REGSTR_PATH_MEDIA "\\tmp"
//#define REGKEY_TRAYVOL          "TrayVolumeControlWindow"

/*
 * Upon an option change, the dialog box can force a reinit
 * */
#define MIXUI_EXIT          0
#define MIXUI_RESTART       1
#define MIXUI_ERROR         2
#define MIXUI_MMSYSERR      3


#define GET (TRUE)
#define SET (!GET)
 
#define VOLUME_TICS (500L) // VOLUME_TICS * VOLUME_MAX must be less than 0xFFFFFFFF
#define VOLUME_MIN  (0L)
#define VOLUME_MAX  (65535L)
#define VOLUME_RANGE (VOLUME_MAX - VOLUME_MIN)
#define SLIDER_TO_VOLUME(pos) (VOLUME_MIN + ((VOLUME_RANGE * pos + VOLUME_TICS / 2) / VOLUME_TICS))
#define VOLUME_TO_SLIDER(vol) ((VOLUME_TICS * (vol - VOLUME_MIN) + VOLUME_RANGE / 2) / VOLUME_RANGE)

#define MXUC_STYLEF_VISIBLE     0x00000001
#define MXUC_STYLEF_ENABLED     0x00000002

typedef struct t_MIXUICTRL
{
    DWORD       dwStyle;    // ui style (see style flags)
    HWND        hwnd;       // hwnd to control
    int         state;      // app init state

} MIXUICTRL, * PMIXUICTRL, FAR * LPMIXUICTRL;

typedef enum
{
    MIXUI_VOLUME = 0,
    MIXUI_BALANCE,
    MIXUI_SWITCH,
    MIXUI_VUMETER,
    MIXUI_ADVANCED,
    MIXUI_MULTICHANNEL
} MIXUICONTROL;

typedef enum
{
    MIXUI_CONTROL_UNINITIALIZED = 0,
    MIXUI_CONTROL_ENABLED,
    MIXUI_CONTROL_INITIALIZED
};
 
#define MIXUI_FIRST MIXUI_VOLUME
#define MIXUI_LAST  MIXUI_VUMETER

typedef struct t_MIXUILINE
{
    MIXUICTRL   acr [4];    // 5 fixed types
    DWORD       dwStyle;    // line style
    struct t_VOLCTRLDESC * pvcd;        // ptr to volume description
    
} MIXUILINE, * PMIXUILINE, FAR * LPMIXUILINE;

/*
 * LOWORD == type
 * HIWORD == style
 */
#define MXUL_STYLEF_DESTINATION  0x00000001
#define MXUL_STYLEF_SOURCE       0x00000002
#define MXUL_STYLEF_HIDDEN       0x00010000
#define MXUL_STYLEF_DISABLED     0x00020000

/*
 * The MIXUIDIALOG data structure is a global variable baggage to be
 * attached to dialogs and other windows.  This allows to let windows
 * carry state information rather than us keeping track of it.  It also
 * allows us to simply clone off of another dialog state with simple
 * changes.
 */
typedef struct t_MIXUIDIALOG
{
    HINSTANCE   hInstance;  // app instance
    HWND        hwnd;       // this window

    DWORD       dwFlags;    // random flags    
    
    HMIXER      hmx;        // open handle to mixer
    DWORD       mxid;       // mixer id
    DWORD       dwDevNode;  // mixer dev node
    
    DWORD       iDest;      // destination line id
    DWORD       dwStyle;    // visual options.

    TCHAR       szMixer[MAXPNAMELEN];   // product name
    TCHAR       szDestination[MIXER_SHORT_NAME_CHARS]; // line name

    LPBYTE      lpDialog;   // ptr to dialog template
    DWORD       cbDialog;   // sizeof dialog buffer
    
    PMIXUILINE  amxul;      // ptr to array of mixuiline's
    DWORD       cmxul;      // number of lines
    
    struct t_VOLCTRLDESC *avcd;        // array of volume descriptions
    DWORD       cvcd;       // number of volume descriptions
    
    HWND        hParent;    // HWND of parent window
    UINT        uTimerID;   // peakmeter timer
    HWND        hStatus;    // HWND of status bar

    WNDPROC     lpfnTrayVol;// Tray volume subclass trackbar
    DWORD       dwTrayInfo; // Tray volume info
    
    int         nShowCmd;   // init window

    DWORD       dwDeviceState;  // device change state information

    int         cTimeInQueue;   // timer messages in queue

    //
    // Return values from dialogs, etc.. can be put in dwReturn
    // Upon EndDialog, dwReturn gets set to MIXUI_EXIT or MIXUI_RESTART
    //
    
    DWORD       dwReturn;   // return value on exit
    
    MMRESULT    mmr;        // last result      (iff dwReturn == MIXUI_MMSYSERR)
    RECT        rcRestart;  // restart position (iff dwReturn == MIXUI_RESTART)

    int         cxDlgContent;   // size of dialog content
    int         cxDlgWidth;     // width of dialog
    int         xOffset;        // offset if scrolling is needed
    int         cxScroll;       // amount to scroll by

} MIXUIDIALOG, *PMIXUIDIALOG, FAR *LPMIXUIDIALOG;

/*
 * Style bits - these generally determine the look of the app
 */
#define MXUD_STYLEF_TRAYMASTER  0x00000002  // use the tray
#define MXUD_STYLEF_MASTERONLY  0x00000004  // only destination volumes --obsolete
#define MXUD_STYLEF_HORIZONTAL  0x00000008  // horizontal mode
#define MXUD_STYLEF_TWOCHANNEL  0x00000010  // two channel slider volume
#define MXUD_STYLEF_SMALL       0x00000020  // half-pint version
#define MXUD_STYLEF_CHILD       0x00000040  // child window?    --obsolete
#define MXUD_STYLEF_KEEPWINDOW  0x00000080  // keep window      --obsolete
#define MXUD_STYLEF_NOHELP      0x00000100  // no help
#define MXUD_STYLEF_STATUS      0x00000200  // status bar
#define MXUD_STYLEF_TOPMOST     0x00000400  // top most window
#define MXUD_STYLEF_ADVANCED    0x00000800  // show advanced
#define MXUD_STYLEF_CLOSE       0x00001000  // find and close TRAYMASTER window

/*
 * Flag bits - these generally indicate operating modes and internal info
 */
#define MXUD_FLAGSF_MIXER       0x00000001  // bound to a mixer driver
#define MXUD_FLAGSF_USETIMER    0x00000002  // update timer enabled
#define MXUD_FLAGSF_BADDRIVER   0x00000004  // mixer driver with control map bug
#define MXUD_FLAGSF_NOADVANCED  0x00000008  // advanced features disabled

/*
 * Macro - if both advanced style and advanced state
 */
#define MXUD_ADVANCED(x)    (!((x)->dwFlags & MXUD_FLAGSF_NOADVANCED) && (x)->dwStyle & MXUD_STYLEF_ADVANCED)

/*
 * Tray info bits - state bits for the tray volume
 */
#define MXUD_TRAYINFOF_SIGNAL   0x00000001  // has a change been made?


#define GETMIXUIDIALOG(x)       (MIXUIDIALOG *)GetWindowLongPtr(x, DWLP_USER)
#define SETMIXUIDIALOG(x,y)     SetWindowLongPtr(x, DWLP_USER, y)

DWORD ReadRegistryData( LPTSTR pEntryNode,
			LPTSTR pEntryName,
			PDWORD pType,
			LPBYTE pData,
			DWORD  DataSize );

DWORD WriteRegistryData( LPTSTR pEntryNode,
			 LPTSTR pEntryName,
			 DWORD  Type,
			 LPBYTE pData,
			 DWORD  Size );
DWORD QueryRegistryDataSize( LPTSTR  pEntryNode,
			    LPTSTR  pEntryName,
			    DWORD   *pDataSize );

int Volume_NumDevs(void);
HWND Volume_GetLineItem(HWND, DWORD, DWORD);

BOOL Properties(PMIXUIDIALOG pmxud, HWND hwnd);

#define HANDLE_WM_XSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(lParam), (UINT)(LOWORD(wParam)),  (int)(short)HIWORD(wParam)), 0L)
#define HANDLE_MM_MIXM_CONTROL_CHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMIXER)(wParam), (DWORD)(lParam)))
#define HANDLE_MM_MIXM_LINE_CHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMIXER)(wParam), (DWORD)(lParam)))
#define HANDLE_MYWM_TIMER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd)))
#define HANDLE_WM_IDEVICECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), wParam, lParam))
#define HANDLE_MYWM_WAKEUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), wParam))

#ifdef DEBUG
static int _assert(LPSTR szExp, LPSTR szFile, UINT uLine)
{
    const char szAssertText [] = "Assertion failed: %s, file %s, line %u\r\n";
    const char szAppName [] = "SNDVOL32";
    char sz[256];
    DWORD fDialog = 0L;
    
    wsprintf(sz, szAssertText, szExp, szFile, uLine);
    
    ReadRegistryData(NULL, "AssertDialog", NULL, (LPBYTE)&fDialog, sizeof(DWORD));

    if (fDialog)
	MessageBox(NULL, szAppName, sz, MB_OK|MB_ICONHAND);
    else
    {
	OutputDebugString(sz);
	DebugBreak();
    }
    return 1;
}
#define assert(exp) (void)( (exp) || (_assert(#exp, __FILE__, __LINE__), 0) )
#define dout(exp)   OutputDebugString(exp)
static void _dlout(LPSTR szExp, LPSTR szFile, UINT uLine)
{
    char sz[256];
    wsprintf(sz, "%s, file %s, line %u\r\n", szExp, szFile, uLine);
    OutputDebugString(sz);
}
#define dlout(exp)  (void)(_dlout(exp, __FILE__, __LINE__), 0)
#else
#define assert(exp) ((void)0)
#define dout(exp)   ((void)0)
#define dlout(exp)  ((void)0)
#endif

#define VOLUME_TRAYSHUTDOWN_ID    1

#define SIZEOF(x)   (sizeof((x))/sizeof((x)[0]))

#include "pvcd.h"

#ifndef DRV_QUERYDEVNODE
#define DRV_QUERYDEVNODE     (DRV_RESERVED + 2)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mixerapp\utils.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       utils.c
 *  Purpose:    miscellaneous 
 * 
 *  Copyright (c) 1985-1999 Microsoft Corporation
 *
 *****************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>

#include "volumei.h"
#include "volids.h"
#include "mmddkp.h"


/*  misc. */

const  TCHAR gszStateSubkey[] = TEXT ("%s\\%s");
static TCHAR gszAppName[256];

BOOL Volume_ErrorMessageBox(
    HWND            hwnd,
    HINSTANCE       hInst,
    UINT            id)
{
    TCHAR szMessage[256];
    BOOL fRet;
    szMessage[0] = 0;

    if (!gszAppName[0])
        LoadString(hInst, IDS_APPBASE, gszAppName, SIZEOF(gszAppName));
    
    LoadString(hInst, id, szMessage, SIZEOF(szMessage));
    fRet = (MessageBox(hwnd
                       , szMessage
                       , gszAppName
                       , MB_APPLMODAL | MB_ICONINFORMATION
                       | MB_OK | MB_SETFOREGROUND) == MB_OK);
    return fRet;
}
                                  
const TCHAR aszXPos[]           = TEXT ("X");
const TCHAR aszYPos[]           = TEXT ("Y");
const TCHAR aszLineInfo[]       = TEXT ("LineStates");

///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
DWORD GetWaveOutID(BOOL *pfPreferred)
{
    MMRESULT        mmr;
    DWORD           dwWaveID=0;
    DWORD           dwFlags = 0;
    
    if (pfPreferred)
    {
        *pfPreferred = TRUE;
    }

    mmr = waveOutMessage((HWAVEOUT)UIntToPtr(WAVE_MAPPER), DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    if (!mmr && pfPreferred)
    {
        *pfPreferred = dwFlags & 0x00000001;
    }

    return(dwWaveID);
}

///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
DWORD GetWaveInID(BOOL *pfPreferred)
{
    MMRESULT        mmr;
    DWORD           dwWaveID=0;
    DWORD           dwFlags = 0;
    
    if (pfPreferred)
    {
        *pfPreferred = TRUE;
    }

    mmr = waveInMessage((HWAVEIN)UIntToPtr(WAVE_MAPPER), DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR) &dwWaveID, (DWORD_PTR) &dwFlags);

    if (!mmr && pfPreferred)
    {
        *pfPreferred = dwFlags & 0x00000001;
    }

    return(dwWaveID);
}


/*
 * Volume_GetDefaultMixerID
 *
 * Get the default mixer id.  We only appear if there is a mixer associated
 * with the default wave.
 *
 */                                  
MMRESULT Volume_GetDefaultMixerID(
    int         *pid,
	BOOL		fRecord)
{
    MMRESULT    mmr;
    UINT        u, uMxID;
    BOOL        fPreferredOnly = 0;
    
    *pid = 0;
    mmr = MMSYSERR_ERROR;
    
    //
    // We use messages to the Wave Mapper in Win2K to get the preferred device.
    //
	if (fRecord)
	{
        if(waveInGetNumDevs())
        {
            u = GetWaveInID(&fPreferredOnly);
		
            // Can we get a mixer device ID from the wave device?
		    mmr = mixerGetID((HMIXEROBJ)UIntToPtr(u), &uMxID, MIXER_OBJECTF_WAVEIN);
		    if (mmr == MMSYSERR_NOERROR)
		    {
    		    // Return this ID.
			    *pid = uMxID;
		    }
        }
	}
	else
	{
        if(waveOutGetNumDevs())
        {
            u = GetWaveOutID(&fPreferredOnly);
		
            // Can we get a mixer device ID from the wave device?
		    mmr = mixerGetID((HMIXEROBJ)UIntToPtr(u), &uMxID, MIXER_OBJECTF_WAVEOUT);
		    if (mmr == MMSYSERR_NOERROR)
		    {
			    // Return this ID.
			    *pid = uMxID;
		    }
        }
	}
        
    return mmr;
}

            
const TCHAR aszOptionsSection[]  = TEXT ("Options");
/*
 * Volume_GetSetStyle
 *
 * */
void Volume_GetSetStyle(
    DWORD       *pdwStyle,
    BOOL        Get)
{
    const TCHAR aszStyle[]           = TEXT ("Style");
    
    if (Get)
        ReadRegistryData((LPTSTR)aszOptionsSection
                         , (LPTSTR)aszStyle
                         , NULL
                         , (LPBYTE)pdwStyle
                         , sizeof(DWORD));
    else
        WriteRegistryData((LPTSTR)aszOptionsSection
                          , (LPTSTR)aszStyle
                          , REG_DWORD
                          , (LPBYTE)pdwStyle
                          , sizeof(DWORD));
}

/*
 * Volume_GetTrayTimeout
 *
 * */
DWORD Volume_GetTrayTimeout(
    DWORD       dwTimeout)
{
    const TCHAR aszTrayTimeout[]     = TEXT ("TrayTimeout");
    DWORD dwT = dwTimeout;
    ReadRegistryData(NULL
                     , (LPTSTR)aszTrayTimeout
                     , NULL
                     , (LPBYTE)&dwT
                     , sizeof(DWORD));
    return dwT;
}

/*
 * Volume_GetSetRegistryLineStates
 *
 * Get/Set line states s.t. lines can be disabled if not used.
 *
 * */
struct LINESTATE {
    DWORD   dwSupport;
    TCHAR   szName[MIXER_LONG_NAME_CHARS];
};

#define VCD_STATEMASK   (VCD_SUPPORTF_VISIBLE|VCD_SUPPORTF_HIDDEN)

BOOL Volume_GetSetRegistryLineStates(
    LPTSTR      pszMixer,
    LPTSTR      pszDest,
    PVOLCTRLDESC avcd,
    DWORD       cvcd,
    BOOL        Get)
{
    struct LINESTATE *  pls;
    DWORD       ils, cls;
    TCHAR       achEntry[128];

    if (cvcd == 0)
        return TRUE;
    
    wsprintf(achEntry, gszStateSubkey, pszMixer, pszDest);
    
    if (Get)
    {
        UINT cb;
        if (QueryRegistryDataSize((LPTSTR)achEntry
                                  , (LPTSTR)aszLineInfo
                                  , &cb) != NO_ERROR)
            return FALSE;

        pls = (struct LINESTATE *)GlobalAllocPtr(GHND, cb);

        if (!pls)
            return FALSE;
        
        if (ReadRegistryData((LPTSTR)achEntry
                             , (LPTSTR)aszLineInfo
                             , NULL
                             , (LPBYTE)pls
                             , cb) != NO_ERROR)
        {
            GlobalFreePtr(pls);
            return FALSE;
        }

        cls = cb / sizeof(struct LINESTATE);
        if (cls > cvcd)
            cls = cvcd;

        //
        // Restore the hidden state of the line.
        //
        for (ils = 0; ils < cls; ils++)
        {
            if (lstrcmp(pls[ils].szName, avcd[ils].szName) == 0)
            {
                avcd[ils].dwSupport |= pls[ils].dwSupport;
            }
        }
        GlobalFreePtr(pls);
        
    }
    else 
    {
        pls = (struct LINESTATE *)GlobalAllocPtr(GHND, cvcd * sizeof (struct LINESTATE));
        if (!pls)
            return FALSE;

        //
        // Save the hidden state of the line
        //
        for (ils = 0; ils < cvcd; ils++)
        {
            lstrcpy(pls[ils].szName, avcd[ils].szName);
            pls[ils].dwSupport = avcd[ils].dwSupport & VCD_SUPPORTF_HIDDEN;

        }

        if (WriteRegistryData((LPTSTR)achEntry
                              , (LPTSTR)aszLineInfo
                              , REG_BINARY
                              , (LPBYTE)pls
                              , cvcd*sizeof(struct LINESTATE)) != NO_ERROR)
        {
            GlobalFreePtr(pls);
            return FALSE;            
        }
        
        GlobalFreePtr(pls);
    }
    
    return TRUE;
}    

/*
 * Volume_GetSetRegistryRect
 *
 * Set/Get window position for restoring the postion of the app window
 * 
 * */
BOOL Volume_GetSetRegistryRect(
    LPTSTR      szMixer,
    LPTSTR      szDest,
    LPRECT      prc,
    BOOL        Get)
{
    TCHAR  achEntry[128];
    
    wsprintf(achEntry, gszStateSubkey, szMixer, szDest);

    if (Get)
    {
        if (ReadRegistryData((LPTSTR)achEntry
                             , (LPTSTR)aszXPos
                             , NULL
                             , (LPBYTE)&prc->left
                             , sizeof(prc->left)) != NO_ERROR)
        {
            return FALSE;
        }
        if (ReadRegistryData((LPTSTR)achEntry
                              , (LPTSTR)aszYPos
                              , NULL
                              , (LPBYTE)&prc->top
                              , sizeof(prc->top)) != NO_ERROR)
        {
            return FALSE;
        }
    }
    else 
    {
        if (prc)
        {
            if (WriteRegistryData((LPTSTR)achEntry
                                  , (LPTSTR)aszXPos
                                  , REG_DWORD
                                  , (LPBYTE)&prc->left
                                  , sizeof(prc->left)) != NO_ERROR)
            {
                return FALSE;            
            }
            if (WriteRegistryData((LPTSTR)achEntry
                                  , (LPTSTR)aszYPos
                                  , REG_DWORD
                                  , (LPBYTE)&prc->top
                                  , sizeof(prc->top)) != NO_ERROR)
            {
                return FALSE;            
            }        
        }
    }
    return TRUE;
}    


#ifdef DEBUG
void FAR cdecl dprintfA(LPSTR szFormat, ...)
{
    char ach[128];
    int  s,d;
    va_list va;

    va_start(va, szFormat);
    s = wsprintf (ach,szFormat, va);
    va_end(va);

    for (d=sizeof(ach)-1; s>=0; s--)
    {
        if ((ach[d--] = ach[s]) == '\n')
            ach[d--] = '\r';
    }

    OutputDebugStringA("SNDVOL32: ");
    OutputDebugStringA(ach+d+1);
}
#ifdef UNICODE
void FAR cdecl dprintfW(LPWSTR szFormat, ...)
{
    WCHAR ach[128];
    int  s,d;
    va_list va;

    va_start(va, szFormat);
    s = vswprintf (ach,szFormat, va);
    va_end(va);

    for (d=(sizeof(ach)/sizeof(WCHAR))-1; s>=0; s--)
    {
        if ((ach[d--] = ach[s]) == TEXT('\n'))
            ach[d--] = TEXT('\r');
    }

    OutputDebugStringW(TEXT("SNDVOL32: "));
    OutputDebugStringW(ach+d+1);
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mixerapp\volume.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       volume.c
 *  Purpose:    main application module
 *
 *  Copyright (c) 1985-1999 Microsoft Corporation
 *
 *****************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <commctrl.h>
#include <shellapi.h>
#include <dbt.h>
#include <htmlhelp.h>
#include <regstr.h>

#include "vu.h"
#include "dlg.h"
#include "volids.h"

#include "volumei.h"
#include "utils.h"
#include "stdlib.h"
#include "helpids.h"

#if(WINVER >= 0x040A)
//Support for new WM_DEVICECHANGE behaviour in NT5
/////////////////////////////////////////////////
#include <objbase.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <initguid.h>
#include <devguid.h>
#include <mmddkp.h>
#include <ks.h>
#include <ksmedia.h>
#include <wchar.h>

#define HMIXER_INDEX(i)       ((HMIXER)IntToPtr(i))

HDEVNOTIFY DeviceEventContext = NULL;
BOOL bUseHandle = FALSE; //Indicates whether a handle is being used for device notification,
                         //instead of the general KSCATEGORY_AUDIO
//////////////////////////////////////////////////////
//////////////////////////////////////////////////////
#endif /* WINVER >= 0x040A */

void    Volume_SetControl(PMIXUIDIALOG pmxud, HWND hctl, int iLine, int iCtl);
void    Volume_GetControl(PMIXUIDIALOG pmxud, HWND hctl, int iLine, int iCtl);
DWORD   Volume_DialogBox(PMIXUIDIALOG pmxud);
void    Volume_Cleanup(PMIXUIDIALOG pmxud);
void    Volume_InitLine(PMIXUIDIALOG pmxud, DWORD iLine);
HRESULT GetDestLineID(int mxid, DWORD *piDest);
HRESULT GetSrcLineID(int mxid, DWORD *piDest);
HRESULT GetDestination(DWORD mxid, int *piDest);
HICON GetAppIcon (HINSTANCE hInst, UINT uiMixID);
void FreeAppIcon ();
HKEY OpenDeviceRegKey (UINT uiMixID, REGSAM sam);
PTCHAR GetInterfaceName (DWORD dwMixerID);
HKEY OpenDeviceBrandRegKey (UINT uiMixID);


/* string declarations */
const TCHAR gszParentClass[]         = TEXT( "SNDVOL32" );

const TCHAR gszAppClassName[]        = TEXT( "Volume Control" );
const TCHAR gszTrayClassName[]       = TEXT( "Tray Volume" );


/* app global
 * */
TCHAR gszHelpFileName[MAX_PATH];
TCHAR gszHtmlHelpFileName[MAX_PATH];
BOOL gfIsRTL;
BOOL fCanDismissWindow = FALSE;
BOOL gfRecord = FALSE;
HICON ghiconApp = NULL;
static HHOOK     fpfnOldMsgFilter;
static HOOKPROC  fpfnMsgHook;
//Data used for supporting context menu help
BOOL   bF1InMenu=FALSE; //If true F1 was pressed on a menu item.
UINT   currMenuItem=0;  //The current selected menu item if any.
static HWND ghwndApp=NULL;

/*
 * Number of uniquely supported devices.
 *
 * */
int Volume_NumDevs()
{
    int     cNumDevs = 0;

#pragma message("----Nonmixer issue here.")
//    cNumDevs = Nonmixer_GetNumDevs();
    cNumDevs += Mixer_GetNumDevs();

    return cNumDevs;
}

/*
 * Volume_EndDialog
 *
 * */
void Volume_EndDialog(
    PMIXUIDIALOG    pmxud,
    DWORD           dwErr,
    MMRESULT        mmr)
{
    pmxud->dwReturn = dwErr;
    if (dwErr == MIXUI_MMSYSERR)
        pmxud->mmr = mmr;

    if (IsWindow(pmxud->hwnd))
        PostMessage(pmxud->hwnd, WM_CLOSE, 0, 0);
}

/*
 * Volume_OnMenuCommand
 *
 * */
BOOL Volume_OnMenuCommand(
    HWND            hwnd,
    int             id,
    HWND            hctl,
    UINT            unotify)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);

    switch(id)
    {
    case IDM_PROPERTIES:
        if (Properties(pmxud, hwnd))
        {
            Volume_GetSetStyle(&pmxud->dwStyle, SET);
            Volume_EndDialog(pmxud, MIXUI_RESTART, 0);
        }
        break;

    case IDM_HELPTOPICS:
        SendMessage(pmxud->hParent, MYWM_HELPTOPICS, 0, 0L);
        break;

    case IDM_HELPABOUT:
    {
        TCHAR        ach[256];
        GetWindowText(hwnd, ach, SIZEOF(ach));
        ShellAbout(hwnd
               , ach
               , NULL
               , (HICON)SendMessage(hwnd, WM_QUERYDRAGICON, 0, 0L));
        break;
    }

    case IDM_ADVANCED:
    {
        HMENU hmenu;

        pmxud->dwStyle ^= MXUD_STYLEF_ADVANCED;

        hmenu = GetMenu(hwnd);
        if (hmenu)
        {
            CheckMenuItem(hmenu, IDM_ADVANCED, MF_BYCOMMAND
                  | ((pmxud->dwStyle & MXUD_STYLEF_ADVANCED)?MF_CHECKED:MF_UNCHECKED));
        }
        Volume_GetSetStyle(&pmxud->dwStyle, SET);
        Volume_EndDialog(pmxud, MIXUI_RESTART, 0);
        break;
    }

    case IDM_SMALLMODESWITCH:
        if (!(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER))
        {
            pmxud->dwStyle ^= MXUD_STYLEF_SMALL;
            if (pmxud->dwStyle & MXUD_STYLEF_SMALL)
            {
                pmxud->dwStyle &= ~MXUD_STYLEF_STATUS;
            }
            else
                pmxud->dwStyle |= MXUD_STYLEF_STATUS;

            Volume_GetSetStyle(&pmxud->dwStyle, SET);
            Volume_EndDialog(pmxud, MIXUI_RESTART, 0);
        }
        break;

    case IDM_EXIT:
        Volume_EndDialog(pmxud, MIXUI_EXIT, 0);
        return TRUE;
    }
    return FALSE;
}


/*
 * Volume_OnCommand
 *
 * - Process WM_COMMAND
 *
 * Note: We need a 2 way mapping.  Dialog control -> Mixer control
 * and Mixer control -> Dialog control.
 *
 * */
void Volume_OnCommand(
    HWND            hdlg,
    int             id,
    HWND            hctl,
    UINT            unotify)
{
    int             iMixerLine;
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hdlg);

    //
    // Filter menu messages
    //
    if (Volume_OnMenuCommand(hdlg, id, hctl, unotify))
        return;

    // Each control is offset from the original template control by IDOFFSET.
    // e.g.
    // IDC_VOLUME, IDC_VOLUME+IDOFFSET, .. IDC_VOLUME+(IDOFFSET*cMixerLines)
    //
    iMixerLine = id/IDOFFSET - 1;
    switch ((id % IDOFFSET) + IDC_MIXERCONTROLS)
    {
        case IDC_SWITCH:
            Volume_SetControl(pmxud, hctl, iMixerLine, MIXUI_SWITCH);
            break;
        case IDC_ADVANCED:
            if (MXUD_ADVANCED(pmxud) && !(pmxud->dwStyle & MXUD_STYLEF_SMALL))
                Volume_SetControl(pmxud, hctl, iMixerLine, MIXUI_ADVANCED);
            break;
        case IDC_MULTICHANNEL:
            Volume_SetControl(pmxud, hctl, iMixerLine, MIXUI_MULTICHANNEL);
            break;
    }
}

/*
 * Volume_GetLineItem
 *
 * - Helper function.
 * */
HWND Volume_GetLineItem(
    HWND            hdlg,
    DWORD           iLine,
    DWORD           idCtrl)
{
    HWND            hwnd;
    DWORD           id;

    id      = (iLine * IDOFFSET) + idCtrl;
    hwnd    = GetDlgItem(hdlg, id);

    return hwnd;
}

/*      -       -       -       -       -       -       -       -       - */

/*
 * Volume_TimeProc
 *
 * This is the callback for the periodic timer that does updates for
 * controls that need to be polled.  We only allocate one per app to keep
 * the number of callbacks down.
 */
void CALLBACK Volume_TimeProc(
    UINT            idEvent,
    UINT            uReserved,
    DWORD_PTR       dwUser,
    DWORD_PTR       dwReserved1,
    DWORD_PTR       dwReserved2)
{
    PMIXUIDIALOG    pmxud = (PMIXUIDIALOG)dwUser;

    if (!(pmxud->dwFlags & MXUD_FLAGSF_USETIMER))
        return;

    if (pmxud->cTimeInQueue < 5)
    {
        pmxud->cTimeInQueue++;
        PostMessage(pmxud->hwnd, MYWM_TIMER, 0, 0L);
    }
}


#define PROPATOM        TEXT("dingprivprop")
const TCHAR gszDingPropAtom[] = PROPATOM;
#define SETPROP(x,y)    SetProp((x), gszDingPropAtom, (HANDLE)(y))
#define GETPROP(x)      (PMIXUIDIALOG)GetProp((x), gszDingPropAtom)
#define REMOVEPROP(x)   RemoveProp(x,gszDingPropAtom)

LRESULT CALLBACK Volume_TrayVolProc(
    HWND            hwnd,
    UINT            umsg,
    WPARAM          wParam,
    LPARAM          lParam)
{
    PMIXUIDIALOG    pmxud = (PMIXUIDIALOG)GETPROP(hwnd);
    static const TCHAR cszDefSnd[] = TEXT(".Default");

    if (umsg == WM_KILLFOCUS)
    {
        //
        // if we've just been made inactive via keyboard, clear the signal
        //
        pmxud->dwTrayInfo &= ~MXUD_TRAYINFOF_SIGNAL;
    }

    if (umsg == WM_KEYUP && (pmxud->dwTrayInfo & MXUD_TRAYINFOF_SIGNAL))
    {
        if (wParam == VK_UP || wParam == VK_DOWN || wParam == VK_END ||
            wParam == VK_HOME || wParam == VK_LEFT || wParam == VK_RIGHT ||
            wParam == VK_PRIOR || wParam == VK_NEXT || wParam == VK_SPACE)
        {
            PlaySound(cszDefSnd, NULL, SND_ASYNC | SND_ALIAS);
            pmxud->dwTrayInfo &= ~MXUD_TRAYINFOF_SIGNAL;
        }
    }

    if (umsg == WM_LBUTTONUP && (pmxud->dwTrayInfo & MXUD_TRAYINFOF_SIGNAL))
    {
        PlaySound(cszDefSnd, NULL, SND_ASYNC | SND_ALIAS);
        pmxud->dwTrayInfo &= ~MXUD_TRAYINFOF_SIGNAL;

    }
    return CallWindowProc(pmxud->lpfnTrayVol, hwnd, umsg, wParam, lParam);
}


#if(WINVER >= 0x040A)

void DeviceChange_Cleanup()
{
   if (DeviceEventContext)
   {
       UnregisterDeviceNotification(DeviceEventContext);
       DeviceEventContext = 0;
   }

   bUseHandle = FALSE;

   return;
}

/*
**************************************************************************************************
    GetDeviceHandle()

    given a mixerID this functions opens its corresponding device handle. This handle can be used
    to register for DeviceNotifications.

    dwMixerID -- The mixer ID
    phDevice -- a pointer to a handle. This pointer will hold the handle value if the function is
                successful

    return values -- If the handle could be obtained successfully the return vlaue is TRUE.

**************************************************************************************************
*/
BOOL GetDeviceHandle(DWORD dwMixerID, HANDLE *phDevice)
{
    MMRESULT mmr;
    ULONG cbSize=0;
    TCHAR *szInterfaceName=NULL;

    //Query for the Device interface name
    mmr = mixerMessage((HMIXER)ULongToPtr(dwMixerID), DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&cbSize, 0L);
    if(MMSYSERR_NOERROR == mmr)
    {
        szInterfaceName = (TCHAR *)GlobalAllocPtr(GHND, (cbSize+1)*sizeof(TCHAR));
        if(!szInterfaceName)
        {
            return FALSE;
        }

        mmr = mixerMessage((HMIXER)ULongToPtr(dwMixerID), DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)szInterfaceName, cbSize);
        if(MMSYSERR_NOERROR != mmr)
        {
            GlobalFreePtr(szInterfaceName);
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    //Get an handle on the device interface name.
    *phDevice = CreateFile(szInterfaceName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    GlobalFreePtr(szInterfaceName);
    if(INVALID_HANDLE_VALUE == *phDevice)
    {
        return FALSE;
    }

    return TRUE;
}


/*  DeviceChange_Init()
*   First time initialization for WM_DEVICECHANGE messages
*
*   On NT 5.0, you have to register for device notification
*/
BOOL DeviceChange_Init(HWND hWnd, DWORD dwMixerID)
{

    DEV_BROADCAST_HANDLE DevBrodHandle;
    DEV_BROADCAST_DEVICEINTERFACE dbi;
    HANDLE hMixerDevice;
    MMRESULT mmr;

    //If we had registered already for device notifications, unregister ourselves.
    DeviceChange_Cleanup();

    //If we get the device handle register for device notifications on it.
    if(GetDeviceHandle(dwMixerID, &hMixerDevice))
    {
        memset(&DevBrodHandle, 0, sizeof(DEV_BROADCAST_HANDLE));

        DevBrodHandle.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
        DevBrodHandle.dbch_devicetype = DBT_DEVTYP_HANDLE;
        DevBrodHandle.dbch_handle = hMixerDevice;

        DeviceEventContext = RegisterDeviceNotification(hWnd, &DevBrodHandle,
                                                    DEVICE_NOTIFY_WINDOW_HANDLE);

        if(hMixerDevice)
        {
            CloseHandle(hMixerDevice);
            hMixerDevice = NULL;
        }

        if(DeviceEventContext)
        {
            bUseHandle = TRUE;
            return TRUE;
        }
    }

    if(!DeviceEventContext)
    {
        //Register for notifications from all audio devices. KSCATEGORY_AUDIO gives notifications
        //on device arrival and removal. We cannot identify which device the notification has arrived for
        //but we can take some precautionary measures on these messages so that we do not crash.
        dbi.dbcc_size = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
        dbi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        dbi.dbcc_reserved   = 0;
        dbi.dbcc_classguid  = KSCATEGORY_AUDIO;
        dbi.dbcc_name[0] = TEXT('\0');

        DeviceEventContext = RegisterDeviceNotification(hWnd,
                                         (PVOID)&dbi,
                                         DEVICE_NOTIFY_WINDOW_HANDLE);
        if(!DeviceEventContext)
            return FALSE;
    }

    return TRUE;
}

#endif /* WINVER >= 0x040A */


//fixes bug where controls are lopped off on high-contract extra-large modes
void AdjustForStatusBar(PMIXUIDIALOG pmxud)
{
    RECT statusrect, windowrect;
    statusrect.bottom = 0;
    statusrect.top = 0;

    if (pmxud)
    {
        if (pmxud->hStatus)
        {
            GetClientRect(pmxud->hStatus,&statusrect);
            GetWindowRect(pmxud->hwnd,&windowrect);

            if (statusrect.bottom - statusrect.top > 20)
            {
                int y_adjustment = (statusrect.bottom - statusrect.top) - 20;

                MoveWindow(pmxud->hwnd, windowrect.left, windowrect.top, windowrect.right - windowrect.left,
                       (windowrect.bottom - windowrect.top) + y_adjustment, FALSE );

                GetClientRect(pmxud->hwnd,&windowrect);

                MoveWindow(pmxud->hStatus, statusrect.left, windowrect.bottom - (statusrect.bottom - statusrect.top), statusrect.right - statusrect.left,
                       statusrect.bottom - statusrect.top, FALSE );
            }
        } //end if hStatus is valid
    } //end if pmxud is not null
}

/*
 *
 * */
BOOL Volume_Init(
    PMIXUIDIALOG pmxud)
{
    DWORD           iLine, ictrl;
    RECT            rc, rcWnd;


    if (!Mixer_Init(pmxud) && !Nonmixer_Init(pmxud))
    Volume_EndDialog(pmxud, MIXUI_EXIT, 0);

    //
    // For all line controls, make sure we initialize the values.
    //
    for (iLine = 0; iLine < pmxud->cmxul; iLine++)
    {
        //
        // init the ui control
        //
        Volume_InitLine(pmxud, iLine);

        for (ictrl = MIXUI_FIRST; ictrl <= MIXUI_LAST; ictrl++)
        {
            PMIXUICTRL pmxc = &pmxud->amxul[iLine].acr[ictrl];

            //
            // set initial settings
            //
            if (pmxc->state == MIXUI_CONTROL_INITIALIZED)
                Volume_GetControl(pmxud, pmxc->hwnd, iLine, ictrl);
        }
    }

    if (!(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER))
    {
        RECT    rcBase;
        HWND    hBase;
        RECT    rcAdv,rcBorder;
        HWND    hAdv,hBorder;
        DWORD   i;
        LONG    lPrev;
        POINT   pos;
        HMENU   hmenu;
        HMONITOR hMonitor;
        MONITORINFO monitorInfo;

        if (GetWindowRect(pmxud->hwnd, &rcWnd))
        {
            if (pmxud->cmxul == 1)
            {
                // Adjust size if small
                if (pmxud->dwStyle & MXUD_STYLEF_SMALL)
                    rcWnd.right -= 20;
                ShowWindow(GetDlgItem(pmxud->hwnd, IDC_BORDER), SW_HIDE);
            }

            if (!Volume_GetSetRegistryRect(pmxud->szMixer
                          , pmxud->szDestination
                          , &rc
                          , GET))
            {
                rc.left = rcWnd.left;
                rc.top = rcWnd.top;
            }
            else
            {
                // Check if the rect is visible is any of the monitors
                if (!MonitorFromRect(&rc, MONITOR_DEFAULTTONULL))
                {
                    //The window is not visible. Let's center it in the nearest monitor.
                    //Note: the window could be in this state if (1) the display mode was changed from 
                    //a high-resolution to a lower resolution, with the mixer in the corner. Or,
                    //(2) the multi-mon configuration was rearranged.
                    hMonitor = MonitorFromRect(&rc, MONITOR_DEFAULTTONEAREST);
                    if (hMonitor)
                    {
                        monitorInfo.cbSize = sizeof(MONITORINFO);
                        if (GetMonitorInfo(hMonitor, &monitorInfo))
                        {
                            rc.left = ((monitorInfo.rcWork.right - monitorInfo.rcWork.left) - (rcWnd.right - rcWnd.left)) / 2; //center in x
                            rc.top = ((monitorInfo.rcWork.bottom - monitorInfo.rcWork.top) - (rcWnd.bottom - rcWnd.top)) / 3; //and a little towards the top
                        }
                    }
                }
                //else, the window is visible, so let's leave the (x,y) as read from the settings
            }
            //
            // Adjusted bottom to match switch bottom
            //
            if (!(pmxud->dwStyle & MXUD_STYLEF_SMALL))
            {
                hBase = GetDlgItem(pmxud->hwnd, IDC_SWITCH);
                if (hBase && GetWindowRect(hBase, &rcBase))
                {
                    rcWnd.bottom = rcBase.bottom;
                }

                //
                // Adjusted bottom to match "Advanced" bottom
                //
                if (MXUD_ADVANCED(pmxud))
                {
                    hAdv = GetDlgItem(pmxud->hwnd, IDC_ADVANCED);
                    if (hAdv && GetWindowRect(hAdv, &rcAdv))
                    {
                        lPrev = rcWnd.bottom;
                        rcWnd.bottom = rcAdv.bottom;

                        //
                        // Adjust height of all border lines
                        //
                        lPrev = rcWnd.bottom - lPrev;
                        for (i = 0; i < pmxud->cmxul; i++)
                        {
                            hBorder = GetDlgItem(pmxud->hwnd,
                                     IDC_BORDER+(IDOFFSET*i));
                            if (hBorder && GetWindowRect(hBorder, &rcBorder))
                            {
                                MapWindowPoints(NULL, pmxud->hwnd, (LPPOINT)&rcBorder, 2);
                                pos.x = rcBorder.left;
                                pos.y = rcBorder.top;
                                MoveWindow(hBorder
                                       , pos.x
                                       , pos.y
                                       , rcBorder.right - rcBorder.left
                                       , (rcBorder.bottom - rcBorder.top) + lPrev
                                       , TRUE );
                            }
                        }
                    }
                }
                //
                // Allocate some more space.
                //
                rcWnd.bottom += 28;
            }

            MoveWindow(pmxud->hwnd, rc.left, rc.top, rcWnd.right - rcWnd.left,
                   rcWnd.bottom - rcWnd.top, FALSE );

            //
            // Tack on the status bar after resizing the dialog
            //

            //init status bar hwnd variable
            pmxud->hStatus = NULL;

            if (pmxud->dwStyle & MXUD_STYLEF_STATUS)
            {
                MapWindowPoints(NULL, pmxud->hwnd, (LPPOINT)&rcWnd, 2);
                pos.x = rcWnd.left;
                pos.y = rcWnd.bottom;

                pmxud->hStatus = CreateWindowEx ( gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0
                                , STATUSCLASSNAME
                                , TEXT ("X")
                                , WS_VISIBLE | WS_CHILD
                                , 0
                                , pos.y
                                , rcWnd.right - rcWnd.left
                                , 14
                                , pmxud->hwnd
                                , NULL
                                , pmxud->hInstance
                                , NULL);

                if (pmxud->hStatus)
                {
                    SendMessage(pmxud->hStatus, WM_SETTEXT, 0,
                     (LPARAM)(LPVOID)(LPTSTR)pmxud->szMixer);
                }
                else
                    pmxud->dwStyle ^= MXUD_STYLEF_STATUS;
            }

            AdjustForStatusBar(pmxud);

            hmenu = GetMenu(pmxud->hwnd);
            CheckMenuItem(hmenu, IDM_ADVANCED, MF_BYCOMMAND
                  | ((pmxud->dwStyle & MXUD_STYLEF_ADVANCED)?MF_CHECKED:MF_UNCHECKED));

            if (pmxud->dwStyle & MXUD_STYLEF_SMALL || pmxud->dwFlags & MXUD_FLAGSF_NOADVANCED)
                EnableMenuItem(hmenu, IDM_ADVANCED, MF_BYCOMMAND | MF_GRAYED);

        }

        if (pmxud->dwFlags & MXUD_FLAGSF_USETIMER)
        {
            pmxud->cTimeInQueue = 0;
            pmxud->uTimerID = timeSetEvent(100
                           , 50
                           , Volume_TimeProc
                           , (DWORD_PTR)pmxud
                           , TIME_PERIODIC);
            if (!pmxud->uTimerID)
            pmxud->dwFlags &= ~MXUD_FLAGSF_USETIMER;
        }
    }
    else
    {
        WNDPROC lpfnOldTrayVol;
        HWND    hVol;

        hVol = pmxud->amxul[0].acr[MIXUI_VOLUME].hwnd;
        lpfnOldTrayVol = SubclassWindow(hVol, Volume_TrayVolProc);

        if (lpfnOldTrayVol)
        {
            pmxud->lpfnTrayVol = lpfnOldTrayVol;
            SETPROP(hVol, pmxud);
        }
    }

    #if(WINVER >= 0x040A)
    //Register for WM_DEVICECHANGE messages
    DeviceChange_Init(pmxud->hwnd, pmxud->mxid);
    #endif /* WINVER >= 0x040A */


    return TRUE;
}


/*
 * Volume_OnInitDialog
 *
 * - Process WM_INITDIALOG
 *
 * */
BOOL Volume_OnInitDialog(
    HWND            hwnd,
    HWND            hwndFocus,
    LPARAM          lParam)
{
    PMIXUIDIALOG    pmxud;
    HWND            hwndChild;
    RECT            rc;

    //
    // set app instance data
    //
    SETMIXUIDIALOG(hwnd, lParam);

    pmxud       = (PMIXUIDIALOG)(LPVOID)lParam;
    pmxud->hwnd = hwnd;

    if (!Volume_Init(pmxud))
    {
        Volume_EndDialog(pmxud, MIXUI_EXIT, 0);
    }
    else
    {
        if (pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER)
            PostMessage(hwnd, MYWM_WAKEUP, 0, 0);
    }

    //
    //  If we are so big that we need a scroll bar, then make one.
    //
    rc.top = rc.bottom = 0;
    rc.left = 60; // typical width of a dialog template
    rc.right = Dlg_HorizSize(pmxud->lpDialog);
    MapDialogRect(hwnd, &rc);
    pmxud->cxDlgContent = rc.right;
    pmxud->cxScroll = rc.left;
    pmxud->xOffset = 0;

    GetClientRect(hwnd, &rc);
    pmxud->xOffset = 0;
    pmxud->cxDlgWidth = rc.right;
    if (rc.right < pmxud->cxDlgContent)
    {
        RECT rcWindow;
        SCROLLINFO si;
        LONG lStyle = GetWindowStyle(hwnd);
        SetWindowLong(hwnd, GWL_STYLE, lStyle | WS_HSCROLL);

        si.cbSize = sizeof(si);
        si.fMask = SIF_PAGE | SIF_RANGE;
        si.nMin = 0;
        si.nMax = pmxud->cxDlgContent - 1;  // endpoint is inclusive
        si.nPage = rc.right;
        SetScrollInfo(hwnd, SB_HORZ, &si, TRUE);

        // Grow the dialog to accomodate the scrollbar
        GetWindowRect(hwnd, &rcWindow);
        SetWindowPos(hwnd, NULL, 0, 0, rcWindow.right - rcWindow.left,
                     rcWindow.bottom - rcWindow.top + GetSystemMetrics(SM_CYHSCROLL),
                     SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE |
                     SWP_NOOWNERZORDER | SWP_NOZORDER);
    }


    //
    // If we are the tray master, don't ask to set focus
    //
    return (!(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER));
}


/*
 * Volume_OnDestroy
 *
 * Shut down this dialog.  DO NOT TOUCH the hmixer!
 *
 * */
void Volume_OnDestroy(
    HWND            hwnd)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);

    DeviceChange_Cleanup();

    if (!pmxud)
        return;

    if (pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER)
    {
        HWND    hVol;
        hVol = pmxud->amxul[0].acr[MIXUI_VOLUME].hwnd;
        SubclassWindow(hVol, pmxud->lpfnTrayVol);
        REMOVEPROP(hVol);
    }

    Volume_Cleanup(pmxud);

    if (!(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER))
    {
        //
        // save window position
        //
        if (!IsIconic(hwnd))
        {
            RECT    rc;
            GetWindowRect(hwnd, &rc);
            Volume_GetSetRegistryRect(pmxud->szMixer
                          , pmxud->szDestination
                          , &rc
                          , SET);
        }
    }

    if (pmxud->dwReturn == MIXUI_RESTART)
        PostMessage(pmxud->hParent, MYWM_RESTART, 0, (LPARAM)pmxud);
    else
        PostMessage(pmxud->hParent, WM_CLOSE, 0, 0L);
}

/*
 * Volume_SetControl
 *
 * Update system controls from visual controls
 *
 * */
void Volume_SetControl(
    PMIXUIDIALOG    pmxud,
    HWND            hctl,
    int             imxul,
    int             itype)
{
    if (pmxud->dwFlags & MXUD_FLAGSF_MIXER)
        Mixer_SetControl(pmxud, hctl, imxul, itype);
    else
        Nonmixer_SetControl(pmxud, hctl, imxul, itype);
}

/*
 * Volume_GetControl
 *
 * Update visual controls from system controls
 * */
void Volume_GetControl(
    PMIXUIDIALOG    pmxud,
    HWND            hctl,
    int             imxul,
    int             itype)
{
    if (pmxud->dwFlags & MXUD_FLAGSF_MIXER)
        Mixer_GetControl(pmxud, hctl, imxul, itype);
    else
        Nonmixer_GetControl(pmxud, hctl, imxul, itype);
}


extern DWORD GetWaveOutID(BOOL *pfPreferred);
/*
 * Volume_PlayDefaultSound
 *
 * Play the default sound on the current mixer
 *
 * */
void Volume_PlayDefaultSound (PMIXUIDIALOG pmxud)
{
/*
// TODO: Implement for all master volumes. Convert mixerid to wave id then
//       use wave API to play the file

    TCHAR szDefSnd[MAX_PATH];
    long lcb = sizeof (szDefSnd);

    // Get the default sound filename
    if (ERROR_SUCCESS != RegQueryValue (HKEY_CURRENT_USER, REGSTR_PATH_APPS_DEFAULT TEXT("\\.Default\\.Current"), szDefSnd, &lcb) ||
        0 >= lstrlen (szDefSnd))
        return;
*/

    DWORD dwWave = GetWaveOutID (NULL);
    UINT uiMixID;

     // Check Parameter
    if (!pmxud)
        return;

    // Play the sound only if we are on the default mixer...
    if (MMSYSERR_NOERROR == mixerGetID (ULongToPtr(dwWave), &uiMixID, MIXER_OBJECTF_WAVEOUT) &&
        pmxud -> mxid == uiMixID)
    {

        static const TCHAR cszDefSnd[] = TEXT(".Default");
        PlaySound(cszDefSnd, NULL, SND_ASYNC | SND_ALIAS);
    }
}

/*
 * Volume_ScrollTo
 *
 * Move the scrollbar position.
 */
void Volume_ScrollTo(
    PMIXUIDIALOG pmxud,
    int pos
)
{
    RECT rc;

    /*
     *  Keep in range.
     */
    pos = max(pos, 0);
    pos = min(pos, pmxud->cxDlgContent - pmxud->cxDlgWidth);

    /*
     *  Scroll the window contents accordingly.  But don't scroll
     *  the status bar.
     */

    GetClientRect(pmxud->hwnd, &rc);
    if (pmxud->hStatus)
    {
        RECT rcStatus;
        GetWindowRect(pmxud->hStatus, &rcStatus);
        MapWindowRect(NULL, pmxud->hwnd, &rcStatus);
        SubtractRect(&rc, &rc, &rcStatus);
    }

    rc.left = -pmxud->cxDlgContent;
    rc.right = pmxud->cxDlgContent;

    ScrollWindowEx(pmxud->hwnd, pmxud->xOffset - pos, 0,
                   &rc, NULL, NULL, NULL,
                   SW_ERASE | SW_INVALIDATE | SW_SCROLLCHILDREN);
    pmxud->xOffset = pos;

    /*
     *  Move the scrollbar to match.
     */
    SetScrollPos(pmxud->hwnd, SB_HORZ, pos, TRUE);
}

/*
 * Volume_ScrollContent
 *
 * Process scroll bar messages for the dialog itself.
 */

void Volume_ScrollContent(
    PMIXUIDIALOG pmxud,
    UINT code,
    int pos
)
{
    switch (code) {
    case SB_LINELEFT:
        Volume_ScrollTo(pmxud, pmxud->xOffset - pmxud->cxScroll);
        break;

    case SB_LINERIGHT:
        Volume_ScrollTo(pmxud, pmxud->xOffset + pmxud->cxScroll);
        break;

    case SB_PAGELEFT:
        Volume_ScrollTo(pmxud, pmxud->xOffset - pmxud->cxDlgWidth);
        break;

    case SB_PAGERIGHT:
        Volume_ScrollTo(pmxud, pmxud->xOffset + pmxud->cxDlgWidth);
        break;

    case SB_LEFT:
        Volume_ScrollTo(pmxud, 0);
        break;

    case SB_RIGHT:
        Volume_ScrollTo(pmxud, MAXLONG);
        break;

    case SB_THUMBPOSITION:
    case SB_THUMBTRACK:
        Volume_ScrollTo(pmxud, pos);
        break;
    }
}

/*
 * Volume_OnXScroll
 *
 * Process Scroll bar messages
 *
 * */
void Volume_OnXScroll(
    HWND            hwnd,
    HWND            hwndCtl,
    UINT            code,
    int             pos)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);
    UINT            id;
    int             ictl;
    int             iline;

    // If this is a scroll message from the dialog itself, then we need
    // to scroll our content.
    if (hwndCtl == NULL)
    {
        Volume_ScrollContent(pmxud, code, pos);
        return;
    }

    id              = GetDlgCtrlID(hwndCtl);
    iline           = id/IDOFFSET - 1;
    ictl            = ((id % IDOFFSET) + IDC_MIXERCONTROLS == IDC_BALANCE)
              ? MIXUI_BALANCE : MIXUI_VOLUME;

    Volume_SetControl(pmxud, hwndCtl, iline, ictl);

    //
    // Make sure a note gets played
    //
    if (pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER)
    pmxud->dwTrayInfo |= MXUD_TRAYINFOF_SIGNAL;

    // Play a sound on for the master volume or balance slider when the
    // user ends the scroll and we are still in focus and the topmost app.
    if (code == SB_ENDSCROLL && pmxud && !(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER) &&
        pmxud->amxul[iline].pvcd &&
       (MXUL_STYLEF_DESTINATION & pmxud->amxul[iline].dwStyle)
       && hwndCtl ==  GetFocus() && hwnd == GetForegroundWindow ())
    {
        Volume_PlayDefaultSound (pmxud);
    }
}

/*
 * Volume_OnMyTimer
 *
 * Frequent update timer for meters
 * */
void Volume_OnMyTimer(
    HWND            hwnd)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);

    if (!pmxud)
        return;

    if (pmxud->cTimeInQueue > 0)
        pmxud->cTimeInQueue--;

    if (!(pmxud->dwFlags & MXUD_FLAGSF_USETIMER))
        return;

    if (pmxud->dwFlags & MXUD_FLAGSF_MIXER)
        Mixer_PollingUpdate(pmxud);
    else
        Nonmixer_PollingUpdate(pmxud);
}

/*
 * Volume_OnTimer
 *
 * Infrequent update timer for tray shutdown
 * */
void Volume_OnTimer(
    HWND            hwnd,
    UINT            id)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);

    KillTimer(hwnd, VOLUME_TRAYSHUTDOWN_ID);
    Volume_EndDialog(pmxud, MIXUI_EXIT, 0);
}

/*
 * Volume_OnMixmControlChange
 *
 * Handle control changes
 *
 * */
void Volume_OnMixmControlChange(
    HWND            hwnd,
    HMIXER          hmx,
    DWORD           dwControlID)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);
    Mixer_GetControlFromID(pmxud, dwControlID);
}

/*
 * Volume_EnableLine
 *
 * Enable/Disable a line
 *
 * */
void Volume_EnableLine(
    PMIXUIDIALOG    pmxud,
    DWORD           iLine,
    BOOL            fEnable)
{
    DWORD           iCtrl;
     PMIXUICTRL      pmxc;

    for (iCtrl = MIXUI_FIRST; iCtrl <= MIXUI_LAST; iCtrl++ )
    {
        pmxc = &pmxud->amxul[iLine].acr[iCtrl];
        if (pmxc->state == MIXUI_CONTROL_INITIALIZED)
            EnableWindow(pmxc->hwnd, fEnable);
    }

    pmxud->amxul[iLine].dwStyle ^= MXUL_STYLEF_DISABLED;
}

/*
 * Volume_InitLine
 *
 * Initialize the UI controls for the dialog
 *
 * */
void Volume_InitLine(
    PMIXUIDIALOG    pmxud,
    DWORD           iLine)
{
    HWND            ctrl;
    PMIXUICTRL      pmxc;

    //
    // Peakmeter control
    //
    pmxc = &pmxud->amxul[iLine].acr[MIXUI_VUMETER];
    ctrl = Volume_GetLineItem(pmxud->hwnd, iLine, IDC_VUMETER);

    pmxc->hwnd  = ctrl;

    if (! (pmxc->state == MIXUI_CONTROL_ENABLED) )
    {
        if (ctrl)
            ShowWindow(ctrl, SW_HIDE);
    }
    else if (ctrl)
    {
        HWND    hvol;

        SendMessage(ctrl, VU_SETRANGEMAX, 0, VOLUME_TICS);
        SendMessage(ctrl, VU_SETRANGEMIN, 0, 0);

        hvol = Volume_GetLineItem(pmxud->hwnd, iLine, IDC_VOLUME);
        if (hvol)
        {
            RECT    rc;
            POINT   pos;

            GetWindowRect(hvol, &rc);
            MapWindowPoints(NULL, pmxud->hwnd, (LPPOINT)&rc, 2);
            pos.x = rc.left;
            pos.y = rc.top;

            MoveWindow(hvol
                   , pos.x - 15
                   , pos.y
                   , rc.right - rc.left
                   , rc.bottom - rc.top
                   , FALSE);
        }
        //
        // Signal use of update timer
        //
        pmxud->dwFlags |= MXUD_FLAGSF_USETIMER;
        pmxc->state = MIXUI_CONTROL_INITIALIZED;

    }
    else
        pmxc->state = MIXUI_CONTROL_UNINITIALIZED;


    //
    // Balance control
    //
    pmxc = &pmxud->amxul[iLine].acr[MIXUI_BALANCE];
    ctrl = Volume_GetLineItem(pmxud->hwnd, iLine, IDC_BALANCE);

    pmxc->hwnd  = ctrl;

    if (ctrl)
    {
        SendMessage(ctrl, TBM_SETRANGE, 0, MAKELONG(0, 64));
        SendMessage(ctrl, TBM_SETTICFREQ, 32, 0 );
        SendMessage(ctrl, TBM_SETPOS, TRUE, 32);

        if (pmxc->state != MIXUI_CONTROL_ENABLED)
        {
            EnableWindow(ctrl, FALSE);
        }
        else
            pmxc->state = MIXUI_CONTROL_INITIALIZED;

    }
    else
        pmxc->state = MIXUI_CONTROL_UNINITIALIZED;

    //
    // Volume control
    //
    pmxc = &pmxud->amxul[iLine].acr[MIXUI_VOLUME];
    ctrl = Volume_GetLineItem(pmxud->hwnd, iLine, IDC_VOLUME);

    pmxc->hwnd  = ctrl;

    if (ctrl)
    {
        SendMessage(ctrl, TBM_SETRANGE, 0, MAKELONG(0, VOLUME_TICS));
        SendMessage(ctrl, TBM_SETTICFREQ, (VOLUME_TICS + 5)/6, 0 );

        if (pmxc->state != MIXUI_CONTROL_ENABLED)
        {
            SendMessage(ctrl, TBM_SETPOS, TRUE, 128);
            EnableWindow(ctrl, FALSE);
        }
        else
            pmxc->state = MIXUI_CONTROL_INITIALIZED;

    }
    else
        pmxc->state = MIXUI_CONTROL_UNINITIALIZED;

    //
    // Switch
    //
    pmxc = &pmxud->amxul[iLine].acr[MIXUI_SWITCH];
    ctrl = Volume_GetLineItem(pmxud->hwnd, iLine, IDC_SWITCH);

    pmxc->hwnd  = ctrl;

    if (ctrl)
    {
        if (pmxc->state != MIXUI_CONTROL_ENABLED)
            EnableWindow(ctrl, FALSE);
        else
            pmxc->state = MIXUI_CONTROL_INITIALIZED;
    }
    else
        pmxc->state = MIXUI_CONTROL_UNINITIALIZED;

}


/*
 * Volume_OnMixmLineChange
 *
 * */
void Volume_OnMixmLineChange(
    HWND            hwnd,
    HMIXER          hmx,
    DWORD           dwLineID)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);
    DWORD           iLine;

    for (iLine = 0; iLine < pmxud->cmxul; iLine++)
    {
        if ( dwLineID == pmxud->amxul[iLine].pvcd->dwLineID )
        {
            MIXERLINE       ml;
            MMRESULT        mmr;
            BOOL            fEnable;

            ml.cbStruct     = sizeof(ml);
            ml.dwLineID     = dwLineID;

            mmr = mixerGetLineInfo((HMIXEROBJ)hmx, &ml, MIXER_GETLINEINFOF_LINEID);

            if (mmr != MMSYSERR_NOERROR)
            {
                fEnable = !(ml.fdwLine & MIXERLINE_LINEF_DISCONNECTED);
                Volume_EnableLine(pmxud, iLine, fEnable);
            }
        }
    }
}


/*
 * Volume_OnActivate
 *
 * Important for tray volume only.  Dismisses the dialog and starts an
 * expiration timer.
 *
 * */
void Volume_OnActivate(
    HWND            hwnd,
    UINT            state,
    HWND            hwndActDeact,
    BOOL            fMinimized)
{
    PMIXUIDIALOG pmxud = GETMIXUIDIALOG(hwnd);

    if (!(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER))
    {
        return;
    }

    if (state != WA_INACTIVE)
    {
        fCanDismissWindow = TRUE;
    }
    else if (fCanDismissWindow)
    {
        PostMessage(hwnd, WM_CLOSE, 0, 0L);
/*
        DWORD   dwTimeout = 5 * 60 * 1000;
        fCanDismissWindow = FALSE;
        ShowWindow(hwnd, SW_HIDE);
        //
        // Set expiration timer.  If no one adjusts the volume, make the
        // application go away after 5 minutes.
        //
        dwTimeout = Volume_GetTrayTimeout(dwTimeout);
        SetTimer(hwnd, VOLUME_TRAYSHUTDOWN_ID, dwTimeout, NULL);
*/
    }
}


/*
 * Volume_PropogateMessage
 *
 * WM_SYSCOLORCHANGE needs to be send to all child windows (esp. trackbars)
 */
void Volume_PropagateMessage(
    HWND        hwnd,
    UINT        uMessage,
    WPARAM      wParam,
    LPARAM      lParam)
{
    HWND hwndChild;

    for (hwndChild = GetWindow(hwnd, GW_CHILD); hwndChild != NULL;
         hwndChild = GetWindow(hwndChild, GW_HWNDNEXT))
    {
        SendMessage(hwndChild, uMessage, wParam, lParam);
    }
}

/*
 * Volume_OnPaint
 *
 * Handle custom painting
 * */
void Volume_OnPaint(HWND hwnd)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);
    RECT            rc;
    POINT           pos;
    PAINTSTRUCT     ps;
    HDC             hdc;

    hdc = BeginPaint(hwnd, &ps);

    //
    // for all styles other than the tray master, draw an etched
    // line to delinate the menu area
    //
    if (!(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER))
    {
        GetClientRect(hwnd, &rc);
        rc.bottom = 0;
        DrawEdge(hdc, &rc, EDGE_ETCHED, BF_TOP);
        EndPaint(hwnd, &ps);
        return;
    }

    //
    // for the tray master, draw some significant icon to indicate
    // volume
    //
    GetWindowRect(GetDlgItem(hwnd, IDC_VOLUMECUE), &rc);

    MapWindowPoints(NULL, hwnd, (LPPOINT)&rc, 2);

    DrawEdge(hdc, &rc, BDR_RAISEDINNER, BF_DIAGONAL|BF_TOP|BF_LEFT);
    DrawEdge(hdc, &rc, BDR_RAISEDINNER, BF_TOP);
    rc.bottom   -= 8;
    DrawEdge(hdc, &rc, BDR_RAISEDINNER, BF_RIGHT);

    EndPaint(hwnd, &ps);
}

/*
 * Volume_OnClose
 *
 * */
void Volume_OnClose(
    HWND    hwnd)
{
    DestroyWindow(hwnd);
}

/*
 * Volume_OnEndSession
 *
 * */
void Volume_OnEndSession(
    HWND        hwnd,
    BOOL        fEnding)
{
    if (!fEnding)
        return;

    //
    // Be sure to call the close code to free open handles
    //
    Volume_OnClose(hwnd);
}

#define V_DC_STATEF_PENDING     0x00000001
#define V_DC_STATEF_REMOVING    0x00000002
#define V_DC_STATEF_ARRIVING    0x00000004

/*
 * Volume_OnDeviceChange
 *
 * */
void Volume_OnDeviceChange(
    HWND        hwnd,
    WPARAM      wParam,
    LPARAM      lParam)
{
    PMIXUIDIALOG    pmxud = GETMIXUIDIALOG(hwnd);
    MMRESULT        mmr;
    UINT            uMxID;
    PDEV_BROADCAST_DEVICEINTERFACE bdi = (PDEV_BROADCAST_DEVICEINTERFACE)lParam;
    PDEV_BROADCAST_HANDLE bh = (PDEV_BROADCAST_HANDLE)lParam;

    //
    // Determine if this is our event.
    //
    if(!DeviceEventContext)
        return;

    //If we have an handle on the device then we get a DEV_BROADCAST_HDR structure as the lParam.
    //Or else it means that we have registered for the general audio category KSCATEGORY_AUDIO.
    if(bUseHandle)
    {
        if(!bh ||
           bh->dbch_devicetype != DBT_DEVTYP_HANDLE)
        {
            return;
        }
    }
    else if (!bdi ||
       bdi->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE ||
       !IsEqualGUID(&KSCATEGORY_AUDIO, &bdi->dbcc_classguid) ||
       !(*bdi->dbcc_name)
       )
    {
       return;
    }


    switch (wParam)
    {
        case DBT_DEVICEQUERYREMOVE:
            //The mixer has to be shutdown now.
            //Posting a WM_CLOSE message as Volume_EndDialog does will not help.
            if (pmxud->dwFlags & MXUD_FLAGSF_MIXER)
                Mixer_Shutdown(pmxud);
            else
                Nonmixer_Shutdown(pmxud);

            // Don't attempt restart, just exit. The wavemapper is not
            // updated with the new default device, so do not know what
            // to restart as and we should NOT hardcode device #0!
            // pmxud->mxid = (DWORD) 0;
            // GetDestination(pmxud->mxid, &pmxud->iDest);
            Volume_EndDialog(pmxud, MIXUI_EXIT, 0);
            return;


        case DBT_DEVICEQUERYREMOVEFAILED:       // The query failed, the device will not be removed, so lets reopen it.

            mmr = Volume_GetDefaultMixerID(&uMxID, gfRecord);
            pmxud->mxid = (mmr == MMSYSERR_NOERROR)?uMxID:0;
            GetDestination(pmxud->mxid, &pmxud->iDest);
            Volume_EndDialog(pmxud, MIXUI_RESTART, 0);
            return;

        case DBT_DEVNODES_CHANGED:
            //
            // We cannot reliably determine the final state of the devices in
            // the system until this message is broadcast.
            //
            if (pmxud->dwDeviceState & V_DC_STATEF_PENDING)
            {
                pmxud->dwDeviceState ^= V_DC_STATEF_PENDING;
                break;
            }
            return;

        case DBT_DEVICEREMOVECOMPLETE:
            //The mixer has to be shutdown now.
            //Posting a WM_CLOSE message as Volume_EndDialog does will not help.
            if (pmxud->dwFlags & MXUD_FLAGSF_MIXER)
                Mixer_Shutdown(pmxud);
            else
                Nonmixer_Shutdown(pmxud);

            //A DBT_DEVICEQUERYREMOVE is not guaranteed before a DBT_DEVICEREMOVECOMPLETE.
            //There should be a check here to see if this message is meant for this device.
            //We do not know a way of doing that right now.

            // Don't attempt restart, just exit. The wavemapper is not
            // updated with the new default device, so do not know what
            // to restart as and we should NOT hardcode device #0!
            // pmxud->mxid = (DWORD) 0;
            // GetDestination(pmxud->mxid, &pmxud->iDest);
            Volume_EndDialog(pmxud, MIXUI_EXIT, 0);

            pmxud->dwDeviceState = V_DC_STATEF_PENDING
                            | V_DC_STATEF_REMOVING;
                return;
        case DBT_DEVICEARRIVAL:
            //
            //  A devnode is being added to the system
            //
            pmxud->dwDeviceState = V_DC_STATEF_PENDING
                           | V_DC_STATEF_ARRIVING;
            return;

        default:
            return;
    }

    mmr = Volume_GetDefaultMixerID(&uMxID, gfRecord);

    if (pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER)
    {
        if ( mmr == MMSYSERR_NOERROR
             && (pmxud->dwDeviceState & V_DC_STATEF_ARRIVING))
        {
            DWORD dwDevNode;
            if (!mixerMessage((HMIXER)UIntToPtr(uMxID), DRV_QUERYDEVNODE
                      , (DWORD_PTR)&dwDevNode, 0L))
            {
                if (dwDevNode == pmxud->dwDevNode)
                {
                    //
                    // ignore this device, it doesn't affect us
                    //
                    pmxud->dwDeviceState = 0L;
                    return;
                }
            }
        }

        //
        // Our device state has changed.  Just go away.
        //
        Volume_EndDialog(pmxud, MIXUI_EXIT, 0);
    }
    else if (pmxud->dwDeviceState & V_DC_STATEF_REMOVING)
    {
        //
        // Restart with the default mixer if we can.
        //
        pmxud->mxid = (mmr == MMSYSERR_NOERROR)?uMxID:0;
        GetDestination(pmxud->mxid, &pmxud->iDest);
        Volume_EndDialog(pmxud, MIXUI_RESTART, 0);
    }
    pmxud->dwDeviceState = 0L;
}


void Volume_OnWakeup(
    HWND        hwnd,
    WPARAM      wParam)
{
    POINT       pos;
    RECT        rc, rcPopup;
    LONG        w,h;
    LONG        scrw, scrh;
    HWND        hTrack;
    HMONITOR    hMonitor;
    MONITORINFO moninfo;

    PMIXUIDIALOG pmxud = GETMIXUIDIALOG(hwnd);

    if (!(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER))
        return;

    KillTimer(hwnd, VOLUME_TRAYSHUTDOWN_ID);

    if (wParam != 0)
    {
        Volume_EndDialog(pmxud, MIXUI_EXIT, 0);
        return;
    }

    //
    // Make the tray volume come up.
    //

    //Get the current position.
    GetCursorPos(&pos);

    //Get the width and height of the popup.
    GetWindowRect(hwnd, &rc);
    w = rc.right - rc.left; //This value will always be positive as left is always lesser than right.
    h = rc.bottom - rc.top; //This value will always be positive as top is always lesser than bottom.

    //Initialize the rectangle for the popup. Position it so that the popup appears to the right,
    //bottom of the cursor.
    rcPopup.left = pos.x;
    rcPopup.right = pos.x + w;
    rcPopup.top = pos.y;
    rcPopup.bottom = pos.y+h;

    //Get the rectangle for the monitor.
    hMonitor = MonitorFromPoint(pos, MONITOR_DEFAULTTONEAREST);
    moninfo.cbSize = sizeof(moninfo);
    GetMonitorInfo(hMonitor,&moninfo);

    //If the popup rectangle is leaking off from the right of the screen. Make it appear on the
    //left of the cursor.
    if(rcPopup.right > moninfo.rcWork.right)
    {
        OffsetRect(&rcPopup, -w, 0);
    }

    //If the popup rectangle is leaking off from the bottom of the screen. Make it appear on top
    //of the cursor.
    if(rcPopup.bottom > moninfo.rcWork.bottom)
    {
        OffsetRect(&rcPopup, 0, -h);
    }


    SetWindowPos(hwnd
         , HWND_TOPMOST
         , rcPopup.left
         , rcPopup.top
         , w
         , h
         , SWP_SHOWWINDOW);

    // make us come to the front
    SetForegroundWindow(hwnd);
    fCanDismissWindow = TRUE;

    hTrack = GetDlgItem(hwnd, IDC_VOLUME);
    if (hTrack)
        SetFocus(hTrack);
}


/*
 * VolumeProc
 *
 * */
INT_PTR CALLBACK VolumeProc(
    HWND            hdlg,
    UINT            msg,
    WPARAM          wparam,
    LPARAM          lparam)
{
    switch (msg)
    {
        case WM_INITDIALOG:
            return HANDLE_WM_INITDIALOG(hdlg, wparam, lparam, Volume_OnInitDialog);

        case WM_COMMAND:
            HANDLE_WM_COMMAND(hdlg, wparam, lparam, Volume_OnCommand);
            break;

        case WM_CLOSE:
            HANDLE_WM_CLOSE(hdlg, wparam, lparam, Volume_OnClose);
            break;

        case WM_DESTROY:
            HANDLE_WM_DESTROY(hdlg, wparam, lparam, Volume_OnDestroy);
            break;

        case WM_HSCROLL:
        case WM_VSCROLL:
            //
            // balance and volume are essentially the same
            //
            HANDLE_WM_XSCROLL(hdlg, wparam, lparam, Volume_OnXScroll);
            break;

        case WM_MENUSELECT:
            //Keep track of which menu bar item is currently popped up.
            //This will be used for displaying the appropriate help from the mplayer.hlp file
            //when the user presses the F1 key.
            currMenuItem = (UINT)LOWORD(wparam);
            break;

        case MM_MIXM_LINE_CHANGE:
            HANDLE_MM_MIXM_LINE_CHANGE(hdlg
                           , wparam
                           , lparam
                           , Volume_OnMixmLineChange);
            return FALSE;

        case MM_MIXM_CONTROL_CHANGE:
            HANDLE_MM_MIXM_CONTROL_CHANGE(hdlg
                          , wparam
                          , lparam
                          , Volume_OnMixmControlChange);
            return FALSE;

        case WM_ACTIVATE:
            HANDLE_WM_ACTIVATE(hdlg, wparam, lparam, Volume_OnActivate);
            break;

        case MYWM_TIMER:
            HANDLE_MYWM_TIMER(hdlg, wparam, lparam, Volume_OnMyTimer);
            break;

        case WM_TIMER:
            HANDLE_WM_TIMER(hdlg, wparam, lparam, Volume_OnTimer);
            break;

        case WM_PAINT:
            HANDLE_WM_PAINT(hdlg, wparam, lparam, Volume_OnPaint);
            break;

        case WM_SYSCOLORCHANGE:
            Volume_PropagateMessage(hdlg, msg, wparam, lparam);
            break;

        case WM_DEVICECHANGE:
            HANDLE_WM_IDEVICECHANGE(hdlg, wparam, lparam, Volume_OnDeviceChange);
            break;

        case MYWM_WAKEUP:
            HANDLE_MYWM_WAKEUP(hdlg, wparam, lparam, Volume_OnWakeup);
            break;

        case WM_ENDSESSION:
            HANDLE_WM_ENDSESSION(hdlg, wparam, lparam, Volume_OnEndSession);
            break;

        default:
            break;
    }
    return FALSE;
}

/*
 * Volume_AddLine
 *
 * */
BOOL Volume_AddLine(
    PMIXUIDIALOG    pmxud,
    LPBYTE          lpAdd,
    DWORD           cbAdd,
    DWORD           dwStyle,
    PVOLCTRLDESC    pvcd)
{
    LPBYTE          pbNew;
    DWORD           cbNew;
    PMIXUILINE      pmxul;

    if (pmxud->amxul)
    {
        pmxul = (PMIXUILINE)GlobalReAllocPtr(pmxud->amxul
                             , (pmxud->cmxul+1)*sizeof(MIXUILINE)
                             , GHND);
    }
    else
    {
        pmxul = (PMIXUILINE)GlobalAllocPtr(GHND, sizeof(MIXUILINE));
    }

    if (!pmxul)
        return FALSE;

    pbNew = Dlg_HorizAttach(pmxud->lpDialog
                , pmxud->cbDialog
                , lpAdd
                , cbAdd
                , (WORD)(IDOFFSET * pmxud->cmxul)
                , &cbNew );
    if (!pbNew)
    {
        if (!pmxud->amxul)
            GlobalFreePtr(pmxul);

        return FALSE;
    }

    pmxul[pmxud->cmxul].dwStyle  = dwStyle;
    pmxul[pmxud->cmxul].pvcd     = pvcd;

    pmxud->amxul        = pmxul;
    pmxud->lpDialog     = pbNew;
    pmxud->cbDialog     = cbNew;
    pmxud->cmxul ++;

    return TRUE;
}

/*
 * Volume_Cleanup
 *
 * */
void Volume_Cleanup(
    PMIXUIDIALOG pmxud)
{
    if (pmxud->dwFlags & MXUD_FLAGSF_USETIMER)
    {
        timeKillEvent(pmxud->uTimerID);
        pmxud->dwFlags ^= MXUD_FLAGSF_USETIMER;
    }
    if (pmxud->dwFlags & MXUD_FLAGSF_BADDRIVER)
    {
        pmxud->dwFlags ^= MXUD_FLAGSF_BADDRIVER;
    }
    if (pmxud->dwFlags & MXUD_FLAGSF_NOADVANCED)
    {
        pmxud->dwFlags ^= MXUD_FLAGSF_NOADVANCED;
    }

    if (pmxud->dwFlags & MXUD_FLAGSF_MIXER)
        Mixer_Shutdown(pmxud);
    else
        Nonmixer_Shutdown(pmxud);

    if (pmxud->lpDialog)
        GlobalFreePtr(pmxud->lpDialog);

    if (pmxud->amxul)
        GlobalFreePtr(pmxud->amxul);

    if (pmxud->avcd)
        GlobalFreePtr(pmxud->avcd);

    pmxud->amxul    = NULL;
    pmxud->lpDialog = NULL;
    pmxud->cbDialog = 0;
    pmxud->cmxul    = 0;
    pmxud->hwnd     = NULL;
    pmxud->hStatus  = NULL;
    pmxud->uTimerID = 0;
    pmxud->dwDevNode = 0L;

    FreeAppIcon ();
}

/*
 * Volume_CreateVolume
 * */
BOOL Volume_CreateVolume(
    PMIXUIDIALOG    pmxud)
{
    WNDCLASS        wc;
    LPBYTE          lpDst = NULL, lpSrc = NULL, lpMaster = NULL;
    DWORD           cbDst, cbSrc, cbMaster;
    PVOLCTRLDESC    avcd;
    DWORD           cvcd;
    DWORD           ivcd;
    DWORD           imxul;
    DWORD           dwSupport = 0L;
    BOOL            fAddLine = TRUE;

    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon            = GetAppIcon (pmxud->hInstance, pmxud->mxid);
    wc.lpszMenuName     = NULL;
    wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1);
    wc.hInstance        = pmxud->hInstance;
    wc.style            = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc      = DefDlgProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = DLGWINDOWEXTRA;
    wc.lpszClassName    = (pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER)
              ? gszTrayClassName : gszAppClassName;
    RegisterClass(&wc);

    if (pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER)
    {
        lpMaster = (LPBYTE)Dlg_LoadResource(pmxud->hInstance
                           , MAKEINTRESOURCE(IDD_TRAYMASTER)
                           , &cbMaster);
        if (!lpMaster)
            return FALSE;
    }
    else
    {
        if (pmxud->dwStyle & MXUD_STYLEF_SMALL)
        {
            lpDst = (LPBYTE)Dlg_LoadResource(pmxud->hInstance
                             , MAKEINTRESOURCE(IDD_SMDST)
                             , &cbDst);

            lpSrc = (LPBYTE)Dlg_LoadResource(pmxud->hInstance
                             , MAKEINTRESOURCE(IDD_SMSRC)
                             , &cbSrc);

        }
        else
        {
            lpDst = (LPBYTE)Dlg_LoadResource(pmxud->hInstance
                             , MAKEINTRESOURCE(IDD_DESTINATION)
                             , &cbDst);

            lpSrc = (LPBYTE)Dlg_LoadResource(pmxud->hInstance
                             , MAKEINTRESOURCE(IDD_SOURCE)
                             , &cbSrc);
        }

        if (!lpDst || !lpSrc)
            return FALSE;
    }

    pmxud->lpDialog = NULL;
    pmxud->cbDialog = 0;
    pmxud->amxul    = NULL;
    pmxud->cmxul    = 0;
    pmxud->avcd     = NULL;
    pmxud->cvcd     = 0;

    //
    // Create the volume description
    //

    if (pmxud->dwFlags & MXUD_FLAGSF_MIXER)
    {
        HMIXER          hmx;
        MMRESULT        mmr;

        //
        //  Mixer API's work much more efficiently with a mixer handle...
        //
        mmr = mixerOpen(&hmx, pmxud->mxid, 0L, 0L, MIXER_OBJECTF_MIXER);


        if(MMSYSERR_NOERROR == mmr)
        {
            avcd = Mixer_CreateVolumeDescription((HMIXEROBJ)hmx
                                 , pmxud->iDest
                                 , &cvcd);

            mixerClose(hmx);
        }
        else
        {
            avcd = Mixer_CreateVolumeDescription((HMIXEROBJ)ULongToPtr(pmxud->mxid)
                                 , pmxud->iDest
                                 , &cvcd);
        }

        if (!Mixer_GetDeviceName(pmxud))
        {
            GlobalFreePtr(avcd);
            avcd = NULL;
        }
    }
    else
    {
        avcd = Nonmixer_CreateVolumeDescription(pmxud->iDest
                            , &cvcd);
        if (!Nonmixer_GetDeviceName(pmxud))
        {
            GlobalFreePtr(avcd);
            avcd = NULL;
        }
    }


    //
    // Create the dialog box to go along with it
    //
    if (avcd)
    {
        pmxud->avcd = avcd;
        pmxud->cvcd = cvcd;

        if (pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER)
        {
            if (!Volume_AddLine(pmxud
                   , lpMaster
                   , cbMaster
                   , MXUL_STYLEF_DESTINATION
                   , &avcd[0]))
            {
                return FALSE;
            }
        }
        else
        {
            BOOL    fFirstRun;
            //
            // Restore HIDDEN flags.
            //
            // On first run, be sure to re-save state so there's something
            // there.
            //
            fFirstRun = !Volume_GetSetRegistryLineStates(pmxud->szMixer
                                 , pmxud->avcd[0].szShortName
                                 , avcd
                                 , cvcd
                                 , GET);


            for (ivcd = 0; ivcd < cvcd; ivcd++)
            {
                //
                // Lines are marked hidden if a state has been saved in the
                // registry or no state has been saved and there are too many
                // unnecessary lines.
                //
                if (avcd[ivcd].dwSupport & VCD_SUPPORTF_HIDDEN)
                {
                    continue;
                }

                //
                // Lines are marked VISIBLE if they have sufficient controls
                // to be useful.
                //
                if (!(avcd[ivcd].dwSupport & VCD_SUPPORTF_VISIBLE))
                {
                    continue;
                }

                //
                // Show only defaults on first run.
                //
                if (fFirstRun && !(avcd[ivcd].dwSupport & VCD_SUPPORTF_DEFAULT))
                {
                    avcd[ivcd].dwSupport |= VCD_SUPPORTF_HIDDEN;
                    continue;
                }

                //
                // For those lines that have important controls, add them to
                // the UI.
                //
                if ((pmxud->dwFlags & MXUD_FLAGSF_MIXER) && ivcd == 0 )
                    fAddLine = Volume_AddLine(pmxud
                           , lpDst
                           , cbDst
                           , MXUL_STYLEF_DESTINATION
                           , &avcd[ivcd]);
                else
                    fAddLine = Volume_AddLine(pmxud
                           , lpSrc
                           , cbSrc
                           , MXUL_STYLEF_SOURCE
                           , &avcd[ivcd]);

                if (!fAddLine)
                {
                    return FALSE;
                }
            }

            if (fFirstRun)
                Volume_GetSetRegistryLineStates(pmxud->szMixer
                                , pmxud->avcd[0].szShortName
                                , avcd
                                , cvcd
                                , SET);
        }

        //
        // Now that both arrays are now fixed, set back pointers for
        // the vcd's to ui lines.
        //
        for (imxul = 0; imxul < pmxud->cmxul; imxul++)
        {
            pmxud->amxul[imxul].pvcd->pmxul = &pmxud->amxul[imxul];

            //
            // Accumulate support bits
            //
            dwSupport |= pmxud->amxul[imxul].pvcd->dwSupport;
        }

        //
        // Support bits say we have no advanced controls, so don't make
        // them available.
        //
        if (!(dwSupport & VCD_SUPPORTF_MIXER_ADVANCED))
        {
            pmxud->dwFlags |= MXUD_FLAGSF_NOADVANCED;
        }

        //
        // Propogate bad driver bit to be app global.  A bad driver was
        // detected during the construction of a volume description.
        //
        for (ivcd = 0; ivcd < pmxud->cvcd; ivcd++)
        {
            if (pmxud->avcd[ivcd].dwSupport & VCD_SUPPORTF_BADDRIVER)
            {
                dlout("Bad Control->Line mapping.  Marking bad driver.");
                pmxud->dwFlags |= MXUD_FLAGSF_BADDRIVER;
                break;
            }
        }
    }
    //
    // Note: it isn't necessary to free/unlock the lpMaster/lpDst/lpSrc
    // because they are ptr's to resources and Win32 is smart about resources
    //
    return (avcd != NULL);
}


/*
 * Volume_DialogBox
 *
 * */
DWORD Volume_DialogBox(
    PMIXUIDIALOG    pmxud)
{
    pmxud->dwReturn = MIXUI_EXIT;
    if (Volume_CreateVolume(pmxud))
    {
        HWND hdlg;

        if(NULL == pmxud->lpDialog)
        {
            Volume_Cleanup(pmxud);
            return MIXUI_ERROR;
        }

        hdlg = CreateDialogIndirectParam(pmxud->hInstance
                         , (DLGTEMPLATE *)pmxud->lpDialog
                         , NULL
                         , VolumeProc
                         , (LPARAM)(LPVOID)pmxud );

        if (!hdlg)
        {
            Volume_Cleanup(pmxud);
            return MIXUI_ERROR;
        }
        else
        {
            // Unfortunately, re-registering the winclass does not re-apply any
            // new icon correctly, so we must explicitly apply it here.
            SendMessage (hdlg, WM_SETICON, (WPARAM) ICON_BIG,
                        (LPARAM) GetAppIcon (pmxud->hInstance, pmxud->mxid));
        }

        ShowWindow(hdlg, pmxud->nShowCmd);
    }
    else
    {
        return MIXUI_ERROR;
    }

    return (DWORD)(-1);
}

void DoHtmlHelp()
{
    //note, using ANSI version of function because UNICODE is foobar in NT5 builds
    char chDst[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, gszHtmlHelpFileName,
                                            -1, chDst, MAX_PATH, NULL, NULL);
    HtmlHelpA(GetDesktopWindow(), chDst, HH_DISPLAY_TOPIC, 0);
}

void ProcessHelp(HWND hwnd)
{
    static TCHAR HelpFile[] = TEXT("SNDVOL32.HLP");

    //Handle context menu help
    if(bF1InMenu)
    {
        switch(currMenuItem)
        {
            case IDM_PROPERTIES:
                WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SNDVOL32_OPTIONS_PROPERTIES);
            break;
            case IDM_ADVANCED:
                WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SNDVOL32_OPTIONS_ADVANCED_CONTROLS);
            break;
            case IDM_EXIT:
                WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SNDVOL32_OPTIONS_EXIT);
            break;
            case IDM_HELPTOPICS:
                WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SNDVOL32_HELP_HELP_TOPICS);
            break;
            case IDM_HELPABOUT:
                WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SNDVOL32_HELP_ABOUT);
            break;
            default://In the default case just display the HTML Help.
                DoHtmlHelp();
        }
        bF1InMenu = FALSE; //This flag will be set again if F1 is pressed in a menu.
    }
    else
        DoHtmlHelp();
}


/*
 * VolumeParent_WndProc
 *
 * A generic invisible parent window.
 *
 * */
LRESULT CALLBACK VolumeParent_WndProc(
    HWND        hwnd,
    UINT        msg,
    WPARAM      wparam,
    LPARAM      lparam)
{
    PMIXUIDIALOG pmxud;

    switch (msg)
    {
        case WM_CREATE:
        {
            LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lparam;
            pmxud = (PMIXUIDIALOG)lpcs->lpCreateParams;

            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pmxud);
            pmxud->hParent = hwnd;

            if (Volume_DialogBox(pmxud) == MIXUI_ERROR)
            {
                if ( !(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER))
                {
                    if ( Volume_NumDevs() == 0 )
                        Volume_ErrorMessageBox(NULL, pmxud->hInstance, IDS_ERR_NODEV);
                    else
                        Volume_ErrorMessageBox(NULL, pmxud->hInstance, IDS_ERR_HARDWARE);
                }
                PostMessage(hwnd, WM_CLOSE, 0, 0L);
            }
            return 0;
        }
        case WM_CLOSE:
            DestroyWindow(hwnd);
            return 0;

        case WM_DESTROY:
            //
            // Post-close cleanup
            //
            pmxud = (PMIXUIDIALOG)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            if (!(pmxud->dwStyle & MXUD_STYLEF_NOHELP))
                WinHelp(hwnd, gszHelpFileName, HELP_QUIT, 0L);

            PostQuitMessage(0);

            return 0;

        case MYWM_HELPTOPICS:
            //
            // F1 Help
            //
            pmxud = (PMIXUIDIALOG)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            if (!(pmxud->dwStyle & MXUD_STYLEF_NOHELP))
            {
                ProcessHelp(hwnd);
            }
            break;

        case MYWM_RESTART:
            //
            // A device change or other user property change caused a UI
            // change.  Sending a restart to the parent prevents ugly stuff
            // like WinHelp shutting down and exiting our primary message
            // loop.
            //
            pmxud = (PMIXUIDIALOG)GetWindowLongPtr(hwnd, GWLP_USERDATA);

            if (!(pmxud->dwStyle & MXUD_STYLEF_TRAYMASTER))
            {
                if (Volume_NumDevs() == 0)
                {
                    Volume_ErrorMessageBox(NULL
                               , pmxud->hInstance
                               , IDS_ERR_NODEV);
                    PostMessage(hwnd, WM_CLOSE, 0, 0L);

                }
                else if (Volume_DialogBox((PMIXUIDIALOG)lparam) == MIXUI_ERROR)
                {
                    Volume_ErrorMessageBox(NULL
                               , pmxud->hInstance
                               , IDS_ERR_HARDWARE);
                    PostMessage(hwnd, WM_CLOSE, 0, 0L);
                }
            }
            else
            {
                if (Mixer_GetNumDevs() == 0
                    || Volume_DialogBox((PMIXUIDIALOG)lparam) == MIXUI_ERROR)
                    PostMessage(hwnd, WM_CLOSE, 0, 0L);
            }
            break;

        default:
            break;
    }

    return (DefWindowProc(hwnd, msg, wparam, lparam));
}

const TCHAR szNull[] = TEXT ("");

/*
 * Parent Dialog
 * */
HWND VolumeParent_DialogMain(
    PMIXUIDIALOG pmxud)
{
    WNDCLASS    wc;
    HWND        hwnd;

    wc.lpszClassName  = gszParentClass;
    wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon          = NULL;
    wc.lpszMenuName   = NULL;
    wc.hbrBackground  = NULL;
    wc.hInstance      = pmxud->hInstance;
    wc.style          = 0;
    wc.lpfnWndProc    = VolumeParent_WndProc;
    wc.cbClsExtra     = 0;
    wc.cbWndExtra     = 0;

    if (!RegisterClass(&wc))
        return NULL;

    hwnd = CreateWindow(gszParentClass
            , szNull
            , 0
            , 0
            , 0
            , 0
            , 0
            , NULL
            , NULL
            , pmxud->hInstance
            , (LPVOID)pmxud );

    return hwnd;
}

/*
 * Determines if what the recording destination ID
 */

HRESULT GetRecordingDestID(int mxid, DWORD *piDest)
{
    HRESULT         hr = E_FAIL;
    DWORD       cDest;
    int         iDest;
    MMRESULT    mmr;
    MIXERCAPS   mxcaps;

    if (piDest)
    {
        *piDest = 0;

        mmr = mixerGetDevCaps(mxid, &mxcaps, sizeof(MIXERCAPS));

        if (mmr == MMSYSERR_NOERROR)
        {
            cDest = mxcaps.cDestinations;

            for (iDest = cDest - 1; iDest >= 0; iDest--)
            {
                MIXERLINE   mlDst;

                mlDst.cbStruct      = sizeof ( mlDst );
                mlDst.dwDestination = iDest;

                if (mixerGetLineInfo((HMIXEROBJ)IntToPtr(mxid), &mlDst, MIXER_GETLINEINFOF_DESTINATION) != MMSYSERR_NOERROR)
                    continue;

                if (Mixer_IsValidRecordingDestination ((HMIXEROBJ)IntToPtr(mxid), &mlDst))
                {
                    *piDest = iDest;
                    hr = S_OK;
                    break;
                }
            }
        }
    }

    return(hr);

}


/*------------------------------------------------------+
| HelpMsgFilter - filter for F1 key in dialogs          |
|                                                       |
+------------------------------------------------------*/

DWORD FAR PASCAL HelpMsgFilter(int nCode, UINT wParam, DWORD_PTR lParam)
{
    if (nCode >= 0)
    {
        LPMSG    msg = (LPMSG)lParam;

        if (ghwndApp && (msg->message == WM_KEYDOWN) && (msg->wParam == VK_F1))
        {
            if(nCode == MSGF_MENU)
                bF1InMenu = TRUE;
            SendMessage(ghwndApp, WM_COMMAND, (WPARAM)IDM_HELPTOPICS, 0L);
        }
    }
    return 0;
}


/*
 *  Returns the correct Destination ID for the specified device ID
 */

HRESULT GetDestination(DWORD mxid, int *piDest)
{
    if (gfRecord)
    {
        return GetDestLineID(mxid,piDest);
    }
    else
    {
        return GetSrcLineID(mxid,piDest);
    }
}



/*
 * Determines line ID
 */

HRESULT GetDestLineID(int mxid, DWORD *piDest)
{
    HRESULT     hr = E_FAIL;
    MIXERLINE   mlDst;

    if (piDest)
    {
        hr = S_OK;
        *piDest = 0;

        mlDst.cbStruct = sizeof ( mlDst );
        mlDst.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_WAVEIN;

        if (mixerGetLineInfo((HMIXEROBJ)IntToPtr(mxid), &mlDst, MIXER_GETLINEINFOF_COMPONENTTYPE) == MMSYSERR_NOERROR)
        {
            *piDest = mlDst.dwDestination;
        }
    }

   return(hr);
}

/*
 * Determines line ID
 */

HRESULT GetSrcLineID(int mxid, DWORD *piDest)
{
    HRESULT     hr = E_FAIL;
    MIXERLINE   mlDst;

    if (piDest)
    {
        hr = S_OK;
        *piDest = 0;

        mlDst.cbStruct = sizeof ( mlDst );
        mlDst.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;

        if (mixerGetLineInfo((HMIXEROBJ)IntToPtr(mxid), &mlDst, MIXER_GETLINEINFOF_COMPONENTTYPE ) == MMSYSERR_NOERROR)
        {
            *piDest = mlDst.dwDestination;
        }
        else
        {
            mlDst.cbStruct = sizeof ( mlDst );
            mlDst.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_HEADPHONES;

            if (mixerGetLineInfo((HMIXEROBJ)IntToPtr(mxid), &mlDst, MIXER_GETLINEINFOF_COMPONENTTYPE ) == MMSYSERR_NOERROR)
            {
                *piDest = mlDst.dwDestination;
            }
            else
            {
                mlDst.cbStruct = sizeof ( mlDst );
                mlDst.dwComponentType = MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT;

                if (mixerGetLineInfo((HMIXEROBJ)IntToPtr(mxid), &mlDst, MIXER_GETLINEINFOF_COMPONENTTYPE ) == MMSYSERR_NOERROR)
                {
                    *piDest = mlDst.dwDestination;
                }
            }
        }
    }

    return(hr);
}


/*      -       -       -       -       -       -       -       -       - */

/*
 * entry point
 * */
int WINAPI WinMain(
    HINSTANCE       hInst,
    HINSTANCE       hPrev,
    LPSTR           lpCmdLine,
    int             nShowCmd)
{
    int             err = 0;
    MIXUIDIALOG     mxud;
    MSG             msg;
    HWND            hwnd;
    HANDLE          hAccel;
    MMRESULT        mmr;
    TCHAR           ach[2];
    UINT            u;
    BOOL            fGotDevice = FALSE;
    UINT            uDeviceID;

    ach[0] = '\0'; // PREFIX complains if we do not init this.
    LoadString(hInst, IDS_IS_RTL, ach, SIZEOF(ach));
    gfIsRTL = ach[0] == TEXT('1');

    //
    // initialize the app instance data
    //
    ZeroMemory(&mxud, sizeof(mxud));
    mxud.hInstance  = hInst;
    mxud.dwFlags    = MXUD_FLAGSF_MIXER;

    /* setup the message filter to handle grabbing F1 for this task */
    fpfnMsgHook = (HOOKPROC)MakeProcInstance((FARPROC)HelpMsgFilter, ghInst);
    fpfnOldMsgFilter = (HHOOK)SetWindowsHook(WH_MSGFILTER, fpfnMsgHook);

    //
    // parse the command line for "/T"
    //
    u = 0;

    while (lpCmdLine[u] != '\0')
    {
        switch (lpCmdLine[u])
        {
            case TEXT('-'):
            case TEXT('/'):
            {
                u++;

                if (lpCmdLine[u] != '\0')
                {
                    switch (lpCmdLine[u])
                    {
                        case TEXT('T'):
                        case TEXT('t'):
                            mxud.dwStyle |= MXUD_STYLEF_TRAYMASTER;
                            u++;
                            break;

                        case TEXT('S'):
                        case TEXT('s'):
                            mxud.dwStyle |= MXUD_STYLEF_SMALL;
                            u++;
                            break;

                        case TEXT('R'):        // Should run in Record mode, not Playback (default)
                        case TEXT('r'):
                            gfRecord = TRUE;
                            u++;
                        break;

                        case TEXT('X'):
                        case TEXT('x'):
                            mxud.dwStyle |= MXUD_STYLEF_TRAYMASTER | MXUD_STYLEF_CLOSE;
                        break;

                        case TEXT('D'):        // Should use the specified device
                        case TEXT('d'):
                        {
                            u++;            // Skip "d" and any following spaces
                            while (lpCmdLine[u] != '\0' && isspace(lpCmdLine[u]))
                            {
                                u++;
                            }

                            if (lpCmdLine[u] != '\0')
                            {
                                char szDeviceID[255];
                                UINT uDev = 0;

                                while (lpCmdLine[u] != '\0' && !isalpha(lpCmdLine[u]) && !isspace(lpCmdLine[u]))
                                {
                                    szDeviceID[uDev] = lpCmdLine[u];
                                    u++;
                                    uDev++;
                                }

                                szDeviceID[uDev] = '\0';

                                uDeviceID = strtoul(szDeviceID,NULL,10);

                                fGotDevice = TRUE;
                            }
                        }
                        break;

                        default:            // Unknown Command, just ignore it.
                            u++;
                        break;
                    }
                }
            }
            break;

            default:
            {
                u++;
            }
            break;
        }
    }


    //
    // Restore last style
    //
    if (!(mxud.dwStyle & (MXUD_STYLEF_TRAYMASTER|MXUD_STYLEF_SMALL)))
    {
        Volume_GetSetStyle(&mxud.dwStyle, GET);
    }

    if (mxud.dwStyle & MXUD_STYLEF_TRAYMASTER)
    {
        HWND hwndSV;

        //
        // Locate a waiting instance of the tray volume and wake it up
        //
        hwndSV = FindWindow(gszTrayClassName, NULL);
        if (hwndSV) {
            SendMessage(hwndSV, MYWM_WAKEUP,
                (mxud.dwStyle & MXUD_STYLEF_CLOSE), 0);
            goto mxendapp;
        }
    }

    if (mxud.dwStyle & MXUD_STYLEF_CLOSE) {
        goto mxendapp;
    }


    //
    // Init to the default mixer
    //

    if (fGotDevice)
    {
        UINT cWaves;

        if (gfRecord)
        {
            cWaves = waveInGetNumDevs();
        }
        else
        {
            cWaves = waveOutGetNumDevs();
        }

        if (uDeviceID >= cWaves)
        {
            fGotDevice = FALSE;
        }
    }


    if (!fGotDevice)
    {
        mmr = Volume_GetDefaultMixerID(&mxud.mxid, gfRecord);
    }
    else
    {
        mxud.mxid = uDeviceID;
    }

    if (gfRecord)
    {
        if (FAILED(GetRecordingDestID(mxud.mxid,&mxud.iDest)))
        {
            goto mxendapp;
        }
    }
    else
    {
        if (FAILED(GetDestination(mxud.mxid,&mxud.iDest)))
        {
           goto mxendapp;
        }
    }


    //
    // For the tray master, get the mix id associated with the default
    // wave device.  If this fails, go away.
    //
    if (mxud.dwStyle & MXUD_STYLEF_TRAYMASTER)
    {
        if (mmr != MMSYSERR_NOERROR)
            goto mxendapp;
        mxud.dwStyle |= MXUD_STYLEF_NOHELP;
        mxud.nShowCmd = SW_HIDE;

    }
    else
    {
        if (!Volume_NumDevs())
        {
            Volume_ErrorMessageBox(NULL, hInst, IDS_ERR_NODEV);
            goto mxendapp;
        }
        InitVUControl(hInst);
        if (!LoadString(hInst
                , IDS_HELPFILENAME
                , gszHelpFileName
                , SIZEOF(gszHelpFileName)))
            mxud.dwStyle |= MXUD_STYLEF_NOHELP;

        if (!LoadString(hInst
                , IDS_HTMLHELPFILENAME
                , gszHtmlHelpFileName
                , SIZEOF(gszHtmlHelpFileName)))
            mxud.dwStyle |= MXUD_STYLEF_NOHELP;

        mxud.nShowCmd   = (nShowCmd == SW_SHOWMAXIMIZED)
                  ? SW_SHOWNORMAL:nShowCmd;
        if (!(mxud.dwStyle & MXUD_STYLEF_SMALL))
            mxud.dwStyle  |= MXUD_STYLEF_STATUS;   // has status bar
    }

    //
    // Use the common controls
    //
    InitCommonControls();
    hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(IDR_VOLUMEACCEL));

    hwnd = VolumeParent_DialogMain(&mxud);

    //Initialize the handle which the hook for F1 help will use.
    ghwndApp = mxud.hwnd;

    if (hwnd)
    {
        while (GetMessage(&msg, NULL, 0, 0))
        {
            if (mxud.hwnd) {
                if (hAccel && TranslateAccelerator(mxud.hwnd, hAccel, &msg))
                    continue;

                if (IsDialogMessage(mxud.hwnd,&msg))
                    continue;
            }

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
mxendapp:
    /* if the message hook was installed, remove it and free */
    /* up our proc instance for it.                          */
    if (fpfnOldMsgFilter){
        UnhookWindowsHook(WH_MSGFILTER, fpfnMsgHook);
    }
    return err;
}


void FreeAppIcon ()
{
    if (ghiconApp)
    {
        DestroyIcon (ghiconApp);
        ghiconApp = NULL;
    }
}

// TODO: Move to "regstr.h"
#define REGSTR_KEY_BRANDING TEXT("Branding")
#define REGSTR_VAL_AUDIO_BITMAP TEXT("bitmap")
#define REGSTR_VAL_AUDIO_ICON TEXT("icon")
#define REGSTR_VAL_AUDIO_URL TEXT("url")

HKEY OpenDeviceBrandRegKey (UINT uiMixID)
{

    HKEY hkeyBrand = NULL;
    HKEY hkeyDevice = OpenDeviceRegKey (uiMixID, KEY_READ);

    if (hkeyDevice)
    {
        if (ERROR_SUCCESS != RegOpenKey (hkeyDevice, REGSTR_KEY_BRANDING, &hkeyBrand))
            hkeyBrand = NULL; // Make sure NULL on failure

        // Close the Device key
        RegCloseKey (hkeyDevice);
    }

    return hkeyBrand;

}

///////////////////////////////////////////////////////////////////////////////////////////
// Microsoft Confidential - DO NOT COPY THIS METHOD INTO ANY APPLICATION, THIS MEANS YOU!!!
///////////////////////////////////////////////////////////////////////////////////////////
PTCHAR GetInterfaceName (DWORD dwMixerID)
{
    MMRESULT mmr;
    ULONG cbSize=0;
    TCHAR *szInterfaceName=NULL;

    //Query for the Device interface name
    mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACESIZE, (DWORD_PTR)&cbSize, 0L);
    if(MMSYSERR_NOERROR == mmr)
    {
        szInterfaceName = (TCHAR *)GlobalAllocPtr(GHND, (cbSize+1)*sizeof(TCHAR));
        if(!szInterfaceName)
        {
            return NULL;
        }

        mmr = mixerMessage(HMIXER_INDEX(dwMixerID), DRV_QUERYDEVICEINTERFACE, (DWORD_PTR)szInterfaceName, cbSize);
        if(MMSYSERR_NOERROR != mmr)
        {
            GlobalFreePtr(szInterfaceName);
            return NULL;
        }
    }

    return szInterfaceName;
}


HKEY OpenDeviceRegKey (UINT uiMixID, REGSAM sam)
{

    HKEY hkeyDevice = NULL;
    PTCHAR szInterfaceName = GetInterfaceName (uiMixID);

    if (szInterfaceName)
    {
        HDEVINFO DeviceInfoSet = SetupDiCreateDeviceInfoList (NULL, NULL);

        if (INVALID_HANDLE_VALUE != DeviceInfoSet)
        {
            SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
            DeviceInterfaceData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

            if (SetupDiOpenDeviceInterface (DeviceInfoSet, szInterfaceName,
                                            0, &DeviceInterfaceData))
            {
                DWORD dwRequiredSize;
                SP_DEVINFO_DATA DeviceInfoData;
                DeviceInfoData.cbSize = sizeof (SP_DEVINFO_DATA);

                // Ignore error, it always returns "ERROR_INSUFFICIENT_BUFFER" even though
                // the "SP_DEVICE_INTERFACE_DETAIL_DATA" parameter is supposed to be optional.
                (void) SetupDiGetDeviceInterfaceDetail (DeviceInfoSet, &DeviceInterfaceData,
                                                        NULL, 0, &dwRequiredSize, &DeviceInfoData);
                // Open device reg key
                hkeyDevice = SetupDiOpenDevRegKey (DeviceInfoSet, &DeviceInfoData,
                                                   DICS_FLAG_GLOBAL, 0,
                                                   DIREG_DRV, sam);

            }
            SetupDiDestroyDeviceInfoList (DeviceInfoSet);
        }
        GlobalFreePtr (szInterfaceName);
    }

    return hkeyDevice;

}


HICON GetAppIcon (HINSTANCE hInst, UINT uiMixID)
{

    HKEY hkeyBrand = OpenDeviceBrandRegKey (uiMixID);

    FreeAppIcon ();

    if (hkeyBrand)
    {
        WCHAR szBuffer[MAX_PATH];
        DWORD dwType = REG_SZ;
        DWORD cb     = sizeof (szBuffer) / sizeof (szBuffer[0]);

        if (ERROR_SUCCESS == RegQueryValueEx (hkeyBrand, REGSTR_VAL_AUDIO_ICON, NULL, &dwType, (LPBYTE)szBuffer, &cb))
        {
            WCHAR* pszComma = wcschr (szBuffer, L',');
            if (pszComma)
            {
                WCHAR* pszResourceID = pszComma + 1;
                HANDLE hResource;

                // Remove comma delimeter
                *pszComma = L'\0';

                // Should be a resource module and a resource ID
                hResource = LoadLibrary (szBuffer);
                if (!hResource)
                {
                    WCHAR szDriversPath[MAX_PATH];

                    // If we didn't find it on the normal search path, try looking
                    // in the "drivers" directory.
                    if (GetSystemDirectory (szDriversPath, MAX_PATH))
                    {
                        wcscat (szDriversPath, TEXT("\\drivers\\"));
                        wcscat (szDriversPath, szBuffer);
                        hResource = LoadLibrary (szDriversPath);
                    }

                }
                if (hResource)
                {
                    ghiconApp = LoadImage (hResource, MAKEINTRESOURCE(_wtoi (pszResourceID)), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
                    FreeLibrary (hResource);
                }
            }
            else
                // Should be an *.ico file
                ghiconApp = LoadImage (NULL, szBuffer, IMAGE_ICON, 0, 0, LR_DEFAULTSIZE | LR_LOADFROMFILE);
        }
        RegCloseKey (hkeyBrand);

        // Return the custom icon
        if (ghiconApp)
            return ghiconApp;
    }

    return (LoadIcon (hInst, MAKEINTRESOURCE (IDI_MIXER)));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mixerapp\vu.h ===
// Copyright (c) 1995 Microsoft Corporation
#ifdef UNICODE
   #define VUMETER_CLASS L"mixctls_vumeter"
#else
   #define VUMETER_CLASS "mixctls_vumeter"
#endif

BOOL InitVUControl(HINSTANCE hInst);

#define VUS_HORZ                0x0001
#define VUS_VERT                0x0000  /* default */

/*
 * LPARAM == ptr to RGBQUAD array, WPARAM == count RGBQUAD
 * */ 
#define VU_SETCOLORLIST         (WM_USER + 1)

/*
 * LPARAM == ptr to RGBQUAD array
 **/ 
#define VU_GETCOLORLIST         (WM_USER + 2)

/*
 * LPARAM == DWORD value in range
 * */
#define VU_SETPOS               (WM_USER + 3)
#define VU_GETPOS               (WM_USER + 4)

/*
 * LPARAM == DWORD max
 **/
#define VU_SETRANGEMAX          (WM_USER + 5)

/*
 * LPARAM == DWORD min
 * */
#define VU_SETRANGEMIN          (WM_USER + 6)


#define VU_GETRANGEMAX          (WM_USER + 7)
#define VU_GETRANGEMIN          (WM_USER + 8)

/*
 * */
#define VU_SETBREAKFREQ         (WM_USER + 9)
#define VU_GETBREAKFREQ         (WM_USER + 10)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mixerapp\vu.c ===
/*****************************************************************************
 *
 *  Component:  sndvol32.exe
 *  File:       vu.c
 *  Purpose:    peak meter custom control
 * 
 *  Copyright (c) 1985-1998 Microsoft Corporation
 *
 *****************************************************************************/
/*
 * VUMeter Control
 *
 * */
#include <windows.h>
#include <windowsx.h>
#include "vu.h"

const TCHAR gszVUClass[] = VUMETER_CLASS;

LRESULT FAR PASCAL VUMeterProc(HWND hwnd, UINT wMessage, WPARAM wParam, LPARAM lParam);

#define GETVUINST(x)       (VUINST *)GetWindowLongPtr(x, 0)
#define SETVUINST(x,y)     SetWindowLongPtr(x, 0, (LONG_PTR)y)

typedef struct tag_VUINST {
    CREATESTRUCT cs;
    DWORD   dwLevel;        // current value
    DWORD   dwMax;          // value max
    DWORD   dwMin;          // value min
    DWORD   dwBreak;        // last break
    DWORD   dwStyle;        // dbl extra style bits ???
    DWORD   cBreaks;        // no. of breaks
    DWORD   cRGB;           // no. of RGBQUADs
    DWORD   dwHeight;
    DWORD   dwWidth;
    HBITMAP hColor;         // bitmap cache of full display
    HBITMAP hBackground;    // bitmap cache of background   
    RGBQUAD *aRGB;          // array of RGBQUADs describing colors
} VUINST, *PVUINST, FAR *LPVUINST;

const RGBQUAD gaRGBDefault[] = {
    {   0, 127,   0, 0},        // dark green    
    {   0, 127,   0, 0},        // dark green
    {   0, 255,   0, 0},        // light green
    {   0, 255, 255, 0},        // yellow
    {   0,   0, 255, 0}         // red    
};

BOOL InitVUControl(HINSTANCE hInst)
{
    WNDCLASS wc;
    wc.lpszClassName   = (LPTSTR)gszVUClass;
    wc.hCursor         = LoadCursor( NULL, IDC_ARROW );
    wc.lpszMenuName    = (LPTSTR)NULL;
    wc.style           = CS_HREDRAW|CS_VREDRAW|CS_GLOBALCLASS;
    wc.lpfnWndProc     = (WNDPROC) VUMeterProc;
    wc.hInstance       = hInst;
    wc.hIcon           = NULL;
    wc.cbWndExtra      = sizeof(VUINST *);
    wc.cbClsExtra      = 0;
    wc.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1 );

    /* register meter window class */
    if(!RegisterClass(&wc))
    {
        return FALSE;
    }

    return (TRUE);
}

DWORD vu_CalcBreaks(
    PVUINST pvi)
{
    DWORD cBreaks;
    
    if (pvi->dwMax - pvi->dwMin > 0)
    {
        cBreaks = ((pvi->dwLevel - pvi->dwMin) * pvi->cBreaks)
                  / (pvi->dwMax - pvi->dwMin);
        if (!cBreaks && pvi->dwLevel > pvi->dwMin)
            cBreaks++;
    }
    else
        cBreaks = 0;
    
    if (cBreaks > pvi->cBreaks)
        cBreaks = pvi->cBreaks;
    
    return cBreaks;
}

BOOL vu_OnCreate(
    HWND            hwnd,
    LPCREATESTRUCT  lpCreateStruct)
{
    PVUINST pvi;

    //
    // alloc an instance data structure
    pvi = LocalAlloc(LPTR, sizeof(VUINST));
    if (!pvi)
        return FALSE;
    SETVUINST(hwnd, pvi);
    
    pvi->cBreaks    = 10;
    pvi->cRGB       = sizeof(gaRGBDefault)/sizeof(RGBQUAD);
    pvi->aRGB       = (RGBQUAD *)gaRGBDefault;
    pvi->dwMin      = 0;
    pvi->dwMax      = 0;
    pvi->dwLevel    = 0;
    pvi->dwBreak    = 0;
    pvi->hColor     = NULL;
    pvi->hBackground = NULL;
    return TRUE;
}

void vu_ResetControl(
    PVUINST pvi)
{
    if (pvi->hColor)
    {
        DeleteObject(pvi->hColor);
        pvi->hColor = NULL;
    }
    if (pvi->hBackground)
    {
        DeleteObject(pvi->hBackground);
        pvi->hBackground = NULL;
    }
}

void vu_OnDestroy(
    HWND        hwnd)
{
    PVUINST pvi = GETVUINST(hwnd);
    
    if (pvi)
    {
        vu_ResetControl(pvi);
        LocalFree((HLOCAL)pvi);
        SETVUINST(hwnd,0);
    }
}

void vu_OnPaint(
    HWND        hwnd)
{
    PVUINST     pvi = GETVUINST(hwnd);
    RECT        rc, rcB;
    PAINTSTRUCT ps;
    int         i;
    int         iSize;
    DWORD       cBreaks;
    
    if (!GetUpdateRect(hwnd, &rc, FALSE))
        return;

    BeginPaint(hwnd, &ps);
    
    GetClientRect(hwnd, &rc);
    
    //
    // Create the foreground bitmap if not already cached
    //
    if (pvi->hColor == NULL)
    {
        HDC     hdc;
        HBITMAP hbmp, hold;
        HBRUSH  hbr;
        RECT    rcp;
        
        rcp.left    = 0;
        rcp.right   = rc.right - rc.left - 4;
        rcp.top     = 0;
        rcp.bottom  = rc.bottom - rc.top - 4 ;
        
        hdc  = CreateCompatibleDC(ps.hdc);
        hbmp = CreateCompatibleBitmap(ps.hdc, rcp.right, rcp.bottom);
        hold = SelectObject(hdc, hbmp);

        //
        // background
        //
        hbr  = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
        FillRect(hdc, &rcp, hbr);
        if (hbr) DeleteObject(hbr);
        
        //
        // each block will be iSize tall
        //
        iSize = (rcp.bottom - 1) / pvi->cBreaks;

        //
        // color blocks
        //
        for (i = 0; i < (int)pvi->cBreaks; i++)
        {
            int iColor = i / (pvi->cBreaks/pvi->cRGB);
            if (iColor >= (int)pvi->cRGB - 1)
                iColor = (int)pvi->cRGB - 1;

            hbr = CreateSolidBrush(RGB(pvi->aRGB[iColor].rgbRed
                                       ,pvi->aRGB[iColor].rgbGreen
                                       ,pvi->aRGB[iColor].rgbBlue));
            rcB.left    = 0;
            rcB.right   = rcp.right;
            rcB.top     = rcp.bottom - (i+1)*iSize;
//            rcB.bottom  = rcp.bottom - i*iSize;
            rcB.bottom  = rcB.top + iSize - 1;            

            FillRect(hdc, &rcB, hbr);
            DeleteObject(hbr);
        }
        pvi->hColor = SelectObject(hdc, hold);
        DeleteDC(hdc);
    }

    //
    // Paint it
    // 
    {
        HDC     hdc, hdcColor;
        HBITMAP holdColor, hbmp, hold;
        RECT    rcC = rc;
        HBRUSH  hbr;

        
        //
        // always show something if we exceed the minimum
        cBreaks = vu_CalcBreaks(pvi);
        
        rcC.left     = 0;
        rcC.right    = rc.right - rc.left - 4;
        rcC.top      = 0;
        rcC.bottom   = rc.bottom - rc.top - 4;
        
        // each block will be iSize+1 tall
        iSize = (rcC.bottom - 1) / pvi->cBreaks ;
        
        // paint the uncolor area
        hdc  = CreateCompatibleDC(ps.hdc);
        hbmp = CreateCompatibleBitmap(ps.hdc, rcC.right, rcC.bottom);
        hold = SelectObject(hdc, hbmp);
        hbr  = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
        FillRect(hdc, &rcC, hbr);
        if (hbr)
            DeleteObject(hbr);

        if (cBreaks > 0)
        {
            // paint the color area        
            hdcColor  = CreateCompatibleDC(ps.hdc);
            if (hdcColor)
                holdColor = SelectObject(hdcColor, pvi->hColor);

            BitBlt(hdc
                   , 0
                   , rcC.bottom - (iSize * cBreaks)
                   , rcC.right
                   , iSize * cBreaks 
                   , hdcColor
                   , 0
                   , rcC.bottom - (iSize * cBreaks)
                   , SRCCOPY);
        
            SelectObject(hdcColor, holdColor);
            DeleteDC(hdcColor);
        }
        
        //
        // finally, blt into the real dc
        BitBlt(ps.hdc
               , 2
               , 2
               , rcC.right
               , rcC.bottom
               , hdc
               , 0
               , 0
               , SRCCOPY);
        
        SelectObject(hdc, hold);
        if (hbmp) DeleteObject(hbmp);
        DeleteDC(hdc);
    }
    DrawEdge(ps.hdc, &rc, BDR_SUNKENOUTER, BF_RECT);

    EndPaint(hwnd, &ps);
}

void vu_OnSysColorChange(
    HWND        hwnd)
{
    PVUINST pvi = GETVUINST(hwnd);
    vu_ResetControl(pvi);
}

void vu_OnPaletteChanged(
    HWND        hwnd,
    HWND        hwndPaletteChange)
{
    PVUINST pvi = GETVUINST(hwnd);
    vu_ResetControl(pvi);    
}

void vu_OnSize(
    HWND        hwnd,
    UINT        state,
    int         cx,
    int         cy)
{
    PVUINST pvi = GETVUINST(hwnd);
    pvi->dwWidth    = cx;
    pvi->dwHeight   = cy;
    vu_ResetControl(pvi);
}

void vu_OnEnable(
    HWND        hwnd,
    BOOL        fEnable)
{
    PVUINST pvi = GETVUINST(hwnd);

}

void vu_OnPrivateMessage(
    HWND        hwnd,
    UINT        wMessage,
    WPARAM      wParam,
    LPARAM      lParam)
{
    PVUINST pvi = GETVUINST(hwnd);
    switch (wMessage)
    {
        case VU_SETRANGEMIN:
//            OutputDebugString(TEXT ("SetRangeMin\r\n"));
            pvi->dwMin = (DWORD)lParam;
            break;
            
        case VU_SETRANGEMAX:
//            OutputDebugString(TEXT ("SetRangeMax\r\n"));            
            pvi->dwMax = (DWORD)lParam;
            break;

        case VU_SETPOS:
            pvi->dwLevel = (DWORD)lParam;
//            {TCHAR foo[256];
//            wsprintf(foo, TEXT ("v:%lx\r\n"),lParam);
//            OutputDebugString(foo);
//            }
            if (pvi->dwBreak != vu_CalcBreaks(pvi))
            {
                pvi->dwBreak = vu_CalcBreaks(pvi);
                InvalidateRect(hwnd, NULL, TRUE);
            }
            else if (wParam)
                InvalidateRect(hwnd, NULL, TRUE);
            
            break;
    }
}

LRESULT FAR PASCAL
VUMeterProc(
    HWND        hwnd,
    UINT        wMessage,
    WPARAM      wParam,
    LPARAM      lParam)
{
    switch (wMessage)
    {
        HANDLE_MSG(hwnd, WM_CREATE, vu_OnCreate);
        HANDLE_MSG(hwnd, WM_DESTROY, vu_OnDestroy);
        HANDLE_MSG(hwnd, WM_PAINT, vu_OnPaint);
        HANDLE_MSG(hwnd, WM_SYSCOLORCHANGE, vu_OnSysColorChange);
        HANDLE_MSG(hwnd, WM_PALETTECHANGED, vu_OnPaletteChanged);
        HANDLE_MSG(hwnd, WM_SIZE, vu_OnSize);
        HANDLE_MSG(hwnd, WM_ENABLE, vu_OnEnable);
//        HANDLE_MSG(hwnd, WM_TIMER, vu_OnTimer);        
        case VU_SETRANGEMIN:
        case VU_SETRANGEMAX:
        case VU_SETPOS:
            vu_OnPrivateMessage(hwnd, wMessage, wParam, lParam);
            return 0;
        case WM_ERASEBKGND:
            return TRUE;
        default:
            break;
    }
    return DefWindowProc (hwnd, wMessage, wParam, lParam) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mmcaps2k\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1997 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//  Notes:
//
//  History:
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//  
//
//
//
#define DEBUG_SECTION       "Debug"         // section name for 
#define DEBUG_MODULE_NAME   "MMCAPS"        // key name and prefix for output
#define DEBUG_MAX_LINE_LEN  255             // max line length (bytes)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define DPF      dprintf
#else
    #define DbgEnable(x)        FALSE
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)    0

    #pragma warning(disable:4002)
    #define DPF()
#endif


#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mmcaps2k\appport.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1997 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  appport.h -- Win 16/32 Portability Stuff
//
//  Description:
//      This file contains common macros to help with writing code that
//      cross compiles between Win 32 and Win 16. This file should be
//      included _after_ windows.h and windowsx.h.
//
//  History:
//      11/ 8/92    created.
//
//==========================================================================;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 32
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
    #ifndef FNLOCAL
	#define FNLOCAL     _stdcall
	#define FNCLOCAL    _stdcall
	#define FNGLOBAL    _stdcall
	#define FNCGLOBAL   _stdcall
	#define FNCALLBACK  CALLBACK
	#define FNEXPORT    CALLBACK
    #endif

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)    \
	((DWORD)SendMessage((hwndCtl), EM_GETSEL, (WPARAM)pnS, (LPARAM)pnE))

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
	#define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
	#define SIZEOF(x)   sizeof(x)
    #endif

    //
    //  win32 apps [usually] don't have to worry about 'huge' data
    //
    #if !defined hmemcpy
	#define hmemcpy memcpy
    #endif
#endif // #ifdef WIN32


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
	#define FNLOCAL     NEAR PASCAL
	#define FNCLOCAL    NEAR _cdecl
	#define FNGLOBAL    FAR PASCAL
	#define FNCGLOBAL   FAR _cdecl
	#define FNCALLBACK  CALLBACK
	#define FNEXPORT    CALLBACK _export
    #endif

    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
	#define _TCHAR_DEFINED
	typedef char            TCHAR, *PTCHAR;
	typedef unsigned char   TBYTE, *PTUCHAR;

	typedef PSTR            PTSTR, PTCH;
	typedef const PTSTR     PCTSTR;
	typedef LPSTR           LPTSTR, LPTCH;
	typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)

    //
    //
    //
    #define CharNext        AnsiNext
    #define CharPrev        AnsiPrev

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)                        \
    {                                                               \
	DWORD   dw;                                                 \
	dw = (DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L);       \
	*pnE = (int)HIWORD(dw);                                     \
	*pnS = (int)LOWORD(dw);                                     \
    }

    //
    //  common message cracker macros available in windowx.h on NT--these
    //  should be added to the Win 16 windowsx.h and probably will be
    //  in the future.
    //
    //  there is a windowsx.h16 that ships with the NT PDK that defines
    //  these macros. so if that version is being used, don't redefine
    //  message crackers.
    //

#ifndef WM_CTLCOLORMSGBOX
    #define WM_CTLCOLORMSGBOX           0x0132
    #define WM_CTLCOLOREDIT             0x0133
    #define WM_CTLCOLORLISTBOX          0x0134
    #define WM_CTLCOLORBTN              0x0135
    #define WM_CTLCOLORDLG              0x0136
    #define WM_CTLCOLORSCROLLBAR        0x0137
    #define WM_CTLCOLORSTATIC           0x0138
#endif

#ifndef GET_WM_ACTIVATE_STATE
    #define GET_WM_ACTIVATE_STATE(wp, lp)           (wp)
    #define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)      (BOOL)HIWORD(lp)
    #define GET_WM_ACTIVATE_HWND(wp, lp)            (HWND)LOWORD(lp)
    #define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)      (WPARAM)(s), MAKELONG(hwnd, fmin)

    #define GET_WM_CHARTOITEM_CHAR(wp, lp)          (CHAR)(wp)
    #define GET_WM_CHARTOITEM_POS(wp, lp)           HIWORD(lp)
    #define GET_WM_CHARTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd)    (WPARAM)(ch), MAKELONG(hwnd, pos)

    #define GET_WM_COMMAND_ID(wp, lp)               (wp)
    #define GET_WM_COMMAND_HWND(wp, lp)             (HWND)LOWORD(lp)
    #define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(lp)
    #define GET_WM_COMMAND_MPS(id, hwnd, cmd)       (WPARAM)(id), MAKELONG(hwnd, cmd)

    #define GET_WM_CTLCOLOR_HDC(wp, lp, msg)        (HDC)(wp)
    #define GET_WM_CTLCOLOR_HWND(wp, lp, msg)       (HWND)LOWORD(lp)
    #define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)       HIWORD(lp)
    #define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type)    (WPARAM)(hdc), MAKELONG(hwnd, type)

    #define GET_WM_MENUSELECT_CMD(wp, lp)           (wp)
    #define GET_WM_MENUSELECT_FLAGS(wp, lp)         LOWORD(lp)
    #define GET_WM_MENUSELECT_HMENU(wp, lp)         (HMENU)HIWORD(lp)
    #define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)    (WPARAM)(cmd), MAKELONG(f, hmenu)

    // Note: the following are for interpreting MDIclient to MDI child messages.
    #define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (BOOL)(wp)
    #define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
    #define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)

    // Note: the following is for sending to the MDI client window.
    #define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA) (WPARAM)(hwndA), 0

    #define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW)   0, MAKELONG(hmenuF, hmenuW)

    #define GET_WM_MENUCHAR_CHAR(wp, lp)            (CHAR)(wp)
    #define GET_WM_MENUCHAR_HMENU(wp, lp)           (HMENU)LOWORD(lp)
    #define GET_WM_MENUCHAR_FMENU(wp, lp)           (BOOL)HIWORD(lp)
    #define GET_WM_MENUCHAR_MPS(ch, hmenu, f)       (WPARAM)(ch), MAKELONG(hmenu, f)

    #define GET_WM_PARENTNOTIFY_MSG(wp, lp)         (wp)
    #define GET_WM_PARENTNOTIFY_ID(wp, lp)          HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)   (HWND)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_X(wp, lp)           (INT)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_Y(wp, lp)           (INT)HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd)  (WPARAM)(msg), MAKELONG(hwnd, id)
    #define GET_WM_PARENTNOTIFY2_MPS(msg, x, y)     (WPARAM)(msg), MAKELONG(x, y)

    #define GET_WM_VKEYTOITEM_CODE(wp, lp)          (wp)
    #define GET_WM_VKEYTOITEM_ITEM(wp, lp)          (INT)HIWORD(lp)
    #define GET_WM_VKEYTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) (WPARAM)(code), MAKELONG(hwnd, item)

    #define GET_EM_SETSEL_START(wp, lp)             LOWORD(lp)
    #define GET_EM_SETSEL_END(wp, lp)               HIWORD(lp)
    #define GET_EM_SETSEL_MPS(iStart, iEnd)         0, MAKELONG(iStart, iEnd)

    #define GET_EM_LINESCROLL_MPS(vert, horz)       0, MAKELONG(vert, horz)

    #define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)   (HWND)LOWORD(lp)

    #define GET_WM_HSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_HSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_HSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_HSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)

    #define GET_WM_VSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_VSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_VSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_VSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)
#endif

#endif // #ifndef WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mmcaps2k\lowlevel.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1997 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  lowlevel.c
//
//  Description:
//
//
//  History:
//       5/16/93
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>

//#include "msmixmgr.h"

#include "appport.h"
#include "mmcaps.h"

#include "debug.h"


//
//
//
TCHAR       gszDeviceFormatTitle[]  = TEXT("Type\t8!Index\t5!Version\t7!Product Name");
TCHAR       gszDeviceFormatList[]   = TEXT("%-9s\t%d\t%u.%.02u\t%-32s");


//
//
//
//
TCHAR       gszBogusCaps[]       = TEXT("????");
TCHAR       gszTimerDevice[]     = TEXT("Internal PC Timer");
TCHAR       gszDefaultMapper[]   = TEXT("Default Mapper");


#define MMCAPS_DEVTYPE_UNKNOWN      0
#define MMCAPS_DEVTYPE_AUXILIARY    1
#define MMCAPS_DEVTYPE_JOYSTICK     2
#define MMCAPS_DEVTYPE_MIDIIN       3
#define MMCAPS_DEVTYPE_MIDIOUT      4
#define MMCAPS_DEVTYPE_MIXER        5
#define MMCAPS_DEVTYPE_TIMER        6
#define MMCAPS_DEVTYPE_WAVEIN       7
#define MMCAPS_DEVTYPE_WAVEOUT      8

PTSTR gaszDeviceType[] =
{
    gszUnknown,
    TEXT("Auxiliary"),
    TEXT("Joystick"),
    TEXT("MIDI In"),
    TEXT("MIDI Out"),
    TEXT("Mixer"),
    TEXT("Timer"),
    TEXT("Wave In"),
    TEXT("Wave Out")
};





//
//  AUXCAPS
//
//
//
PTSTR gaszAuxCapsTechnology[] =
{
    gszNotSpecified,                //
    TEXT("CD-Audio"),               // AUXCAPS_CDAUDIO
    TEXT("Auxiliary Input")         // AUXCAPS_AUXIN
};

#define AUXCAPS_TECHNOLOGY_LAST     AUXCAPS_AUXIN


PTSTR gaszAuxCapsSupport[32] =
{
    TEXT("Volume"),         // Bit 0    AUXCAPS_VOLUME
    TEXT("L/R Volume"),     // Bit 1    AUXCAPS_LRVOLUME
    NULL,                   // Bit 2
    NULL,                   // Bit 3
    NULL,                   // Bit 4
    NULL,                   // Bit 5
    NULL,                   // Bit 6
    NULL,                   // Bit 7
    NULL,                   // Bit 8
    NULL,                   // Bit 9
    NULL,                   // Bit 10
    NULL,                   // Bit 11
    NULL,                   // Bit 12
    NULL,                   // Bit 13
    NULL,                   // Bit 14
    NULL,                   // Bit 15
    NULL,                   // Bit 16
    NULL,                   // Bit 17
    NULL,                   // Bit 18
    NULL,                   // Bit 19
    NULL,                   // Bit 20
    NULL,                   // Bit 21
    NULL,                   // Bit 22
    NULL,                   // Bit 23
    NULL,                   // Bit 24
    NULL,                   // Bit 25
    NULL,                   // Bit 26
    NULL,                   // Bit 27
    NULL,                   // Bit 28
    NULL,                   // Bit 29
    NULL,                   // Bit 30
    NULL                    // Bit 31
};



//
//  MIDI[IN|OUT]CAPS
//
//
//
PTSTR gaszMidiOutCapsTechnology[] =
{
    gszNotSpecified,
    TEXT("MIDI Port"),                  // MOD_MIDIPORT
    TEXT("Internal Synth"),             // MOD_SYNTH   
    TEXT("Internal Square Wave Synth"), // MOD_SQSYNTH 
    TEXT("Internal FM Synth"),          // MOD_FMSYNTH 
    TEXT("MIDI Mapper")                 // MOD_MAPPER  
};

#define MIDIOUTCAPS_TECHNOLOGY_LAST     MOD_MAPPER


PTSTR gaszMidiOutCapsSupport[32] =
{
    TEXT("Volume"),         // Bit 0    MIDICAPS_VOLUME
    TEXT("L/R Volume"),     // Bit 1    MIDICAPS_LRVOLUME
    TEXT("Patch Caching"),  // Bit 2    MIDICAPS_CACHE
    TEXT("Poly Message"),   // Bit 3    MIDICAPS_POLYMSG (Win 4)
    NULL,                   // Bit 4
    NULL,                   // Bit 5
    NULL,                   // Bit 6
    NULL,                   // Bit 7
    NULL,                   // Bit 8
    NULL,                   // Bit 9
    NULL,                   // Bit 10
    NULL,                   // Bit 11
    NULL,                   // Bit 12
    NULL,                   // Bit 13
    NULL,                   // Bit 14
    NULL,                   // Bit 15
    NULL,                   // Bit 16
    NULL,                   // Bit 17
    NULL,                   // Bit 18
    NULL,                   // Bit 19
    NULL,                   // Bit 20
    NULL,                   // Bit 21
    NULL,                   // Bit 22
    NULL,                   // Bit 23
    NULL,                   // Bit 24
    NULL,                   // Bit 25
    NULL,                   // Bit 26
    NULL,                   // Bit 27
    NULL,                   // Bit 28
    NULL,                   // Bit 29
    NULL,                   // Bit 30
    NULL                    // Bit 31
};




//
//  MIXERCAPS
//
//
//
PTSTR gaszMixerCapsSupport[32] =
{
    NULL,                   // Bit 0
    NULL,                   // Bit 1
    NULL,                   // Bit 2
    NULL,                   // Bit 3
    NULL,                   // Bit 4
    NULL,                   // Bit 5
    NULL,                   // Bit 6
    NULL,                   // Bit 7
    NULL,                   // Bit 8
    NULL,                   // Bit 9
    NULL,                   // Bit 10
    NULL,                   // Bit 11
    NULL,                   // Bit 12
    NULL,                   // Bit 13
    NULL,                   // Bit 14
    NULL,                   // Bit 15
    NULL,                   // Bit 16
    NULL,                   // Bit 17
    NULL,                   // Bit 18
    NULL,                   // Bit 19
    NULL,                   // Bit 20
    NULL,                   // Bit 21
    NULL,                   // Bit 22
    NULL,                   // Bit 23
    NULL,                   // Bit 24
    NULL,                   // Bit 25
    NULL,                   // Bit 26
    NULL,                   // Bit 27
    NULL,                   // Bit 28
    NULL,                   // Bit 29
    NULL,                   // Bit 30
    NULL                    // Bit 31
};





//
//  WAVE[IN|OUT]CAPS
//
//
//
PTSTR gaszWaveInOutCapsFormats[32] =
{
    TEXT("8M11"),           // Bit 0    WAVE_FORMAT_1M08
    TEXT("8S11"),           // Bit 1    WAVE_FORMAT_1S08
    TEXT("16M11"),          // Bit 2    WAVE_FORMAT_1M16
    TEXT("16S11"),          // Bit 3    WAVE_FORMAT_1S16
    TEXT("8M22"),           // Bit 4    WAVE_FORMAT_2M08
    TEXT("8S22"),           // Bit 5    WAVE_FORMAT_2S08
    TEXT("16M22"),          // Bit 6    WAVE_FORMAT_2M16
    TEXT("16S22"),          // Bit 7    WAVE_FORMAT_2S16
    TEXT("8M44"),           // Bit 8    WAVE_FORMAT_4M08
    TEXT("8S44"),           // Bit 9    WAVE_FORMAT_4S08
    TEXT("16M44"),          // Bit 10   WAVE_FORMAT_4M16
    TEXT("16S44"),          // Bit 11   WAVE_FORMAT_4S16
    NULL,                   // Bit 12
    NULL,                   // Bit 13
    NULL,                   // Bit 14
    NULL,                   // Bit 15
    NULL,                   // Bit 16
    NULL,                   // Bit 17
    NULL,                   // Bit 18
    NULL,                   // Bit 19
    NULL,                   // Bit 20
    NULL,                   // Bit 21
    NULL,                   // Bit 22
    NULL,                   // Bit 23
    NULL,                   // Bit 24
    NULL,                   // Bit 25
    NULL,                   // Bit 26
    NULL,                   // Bit 27
    NULL,                   // Bit 28
    NULL,                   // Bit 29
    NULL,                   // Bit 30
    NULL                    // Bit 31
};

PTSTR gaszWaveOutCapsSupport[32] =
{
    TEXT("Pitch"),          // Bit 0    WAVECAPS_PITCH
    TEXT("Playback Rate"),  // Bit 1    WAVECAPS_PLAYBACKRATE
    TEXT("Volume"),         // Bit 2    WAVECAPS_VOLUME
    TEXT("L/R Volume"),     // Bit 3    WAVECAPS_LRVOLUME
    TEXT("Sync"),           // Bit 4    WAVECAPS_SYNC
    NULL,                   // Bit 5
    NULL,                   // Bit 6
    NULL,                   // Bit 7
    NULL,                   // Bit 8
    NULL,                   // Bit 9
    NULL,                   // Bit 10
    NULL,                   // Bit 11
    NULL,                   // Bit 12
    NULL,                   // Bit 13
    NULL,                   // Bit 14
    NULL,                   // Bit 15
    NULL,                   // Bit 16
    NULL,                   // Bit 17
    NULL,                   // Bit 18
    NULL,                   // Bit 19
    NULL,                   // Bit 20
    NULL,                   // Bit 21
    NULL,                   // Bit 22
    NULL,                   // Bit 23
    NULL,                   // Bit 24
    NULL,                   // Bit 25
    NULL,                   // Bit 26
    NULL,                   // Bit 27
    NULL,                   // Bit 28
    NULL,                   // Bit 29
    NULL,                   // Bit 30
    NULL                    // Bit 31
};


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  WORD MyGetVersion
//  
//  Description:
//  
//  
//  Arguments:
//  
//  Return (WORD):
//  
//  History:
//      12/17/98
//  
//--------------------------------------------------------------------------;
WORD MyGetVersion(void)
{
    DWORD dw;
    WORD w;
    dw = GetVersion();
    w = (LOBYTE(LOWORD(dw)) << 8) | (HIBYTE(LOWORD(dw)) >> 8);
    return w;
}
    
//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsDetailAuxiliary
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hedit:
//  
//      int nDevId:
//  
//  Return (BOOL):
//  
//  History:
//      05/11/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsDetailAuxiliary
(
    HWND            hedit,
    int             nDevId
)
{
    TCHAR           ach[MMCAPS_MAX_STRING_MIDPID_CHARS];
    PSTR            psz;
    MMRESULT        mmr;
    AUXCAPS         ac;
    UINT            u;
    DWORD           dw;

    AppMEditPrintF(hedit, "      Device Type: %s\r\n",
		 (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_AUXILIARY]);

    if (-1 == nDevId)
	AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId);
    else
	AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);


    //
    //
    //
    mmr = auxGetDevCaps(nDevId, &ac, sizeof(ac));
    if (MMSYSERR_NOERROR != mmr)
    {
	_fmemset(&ac, 0, sizeof(ac));
	if (-1 != nDevId)
	{
	    lstrcpy(ac.szPname, gszBogusCaps);
	}
	else
	{
	    if (0 != auxGetNumDevs())
	    {
		ac.wMid           = MM_MICROSOFT;
		ac.vDriverVersion = (MMVERSION)MyGetVersion();
		lstrcpy(ac.szPname, gszDefaultMapper);
		mmr = MMSYSERR_NOERROR;
	    }
	}
    }

    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)ac.szPname);

    if (MMSYSERR_NOERROR != mmr)
	return (TRUE);

    //
    //
    //
    //
    MMCapsMidAndPid(ac.wMid, ach, 0, NULL);
    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach);

    MMCapsMidAndPid(ac.wMid, NULL, ac.wPid, ach);
    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach);

    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n",
		 (ac.vDriverVersion >> 8), (BYTE)ac.vDriverVersion);


    if (ac.wTechnology > AUXCAPS_TECHNOLOGY_LAST)
    {
	wsprintf(ach, "[%u], Unknown", ac.wTechnology);
	psz = ach;
    }
    else
    {
	psz = gaszAuxCapsTechnology[ac.wTechnology];
    }

    AppMEditPrintF(hedit, "       Technology: %s\r\n", (LPSTR)psz);

    //
    //
    //
    //
    AppMEditPrintF(hedit, " Standard Support: [%.08lXh]", ac.dwSupport);
    for (u = 0, dw = ac.dwSupport; dw; u++)
    {
	if ((BYTE)dw & (BYTE)1)
	{
	    psz = gaszAuxCapsSupport[u];
	    if (NULL == psz)
	    {
		wsprintf(ach, "Unknown%u", u);
		psz = ach;
	    }

	    AppMEditPrintF(hedit, ", %s", (LPSTR)psz);
	}

	dw >>= 1;
    }
    AppMEditPrintF(hedit, "\r\n");

    return (TRUE);
} // MMCapsDetailAuxiliary()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsDetailJoystick
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hedit:
//  
//      int nDevId:
//  
//  Return (BOOL):
//  
//  History:
//      05/11/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsDetailJoystick
(
    HWND            hedit,
    int             nDevId
)
{
    TCHAR           ach[MMCAPS_MAX_STRING_MIDPID_CHARS];
    MMRESULT        mmr;
    JOYCAPS         jc;


    AppMEditPrintF(hedit, "      Device Type: %s\r\n",
		 (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_JOYSTICK]);

    AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);


    //
    //
    //
    mmr = joyGetDevCaps(nDevId, &jc, sizeof(jc));
    if (MMSYSERR_NOERROR != mmr)
    {
	lstrcpy(jc.szPname, gszBogusCaps);
    }

    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)jc.szPname);

    if (MMSYSERR_NOERROR != mmr)
	return (TRUE);

    //
    //
    //
    //
    MMCapsMidAndPid(jc.wMid, ach, 0, NULL);
    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach);

    MMCapsMidAndPid(jc.wMid, NULL, jc.wPid, ach);
    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach);

    AppMEditPrintF(hedit, "   Driver Version: (sigh)\r\n");

    AppMEditPrintF(hedit, "          Buttons: %u\r\n", jc.wNumButtons);
    AppMEditPrintF(hedit, "    Minimum X Pos: %u\r\n", jc.wXmin);
    AppMEditPrintF(hedit, "    Maximum X Pos: %u\r\n", jc.wXmax);
    AppMEditPrintF(hedit, "    Minimum Y Pos: %u\r\n", jc.wYmin);
    AppMEditPrintF(hedit, "    Maximum Y Pos: %u\r\n", jc.wYmax);
    AppMEditPrintF(hedit, "    Minimum Z Pos: %u\r\n", jc.wZmin);
    AppMEditPrintF(hedit, "    Maximum Z Pos: %u\r\n", jc.wZmax);
    AppMEditPrintF(hedit, "   Minimum Period: %u\r\n", jc.wPeriodMin);
    AppMEditPrintF(hedit, "   Maximum Period: %u\r\n", jc.wPeriodMax);


    return (TRUE);
} // MMCapsDetailJoystick()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsDetailMidiIn
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hedit:
//  
//      int nDevId:
//  
//  Return (BOOL):
//  
//  History:
//      05/11/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsDetailMidiIn
(
    HWND            hedit,
    int             nDevId
)
{
    TCHAR           ach[MMCAPS_MAX_STRING_MIDPID_CHARS];
    MMRESULT        mmr;
    MIDIINCAPS      mic;

    AppMEditPrintF(hedit, "      Device Type: %s\r\n",
		 (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_MIDIIN]);

    if (-1 == nDevId)
	AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId);
    else
	AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);


    //
    //
    //
    mmr = midiInGetDevCaps(nDevId, &mic, sizeof(mic));
    if (MMSYSERR_NOERROR != mmr)
    {
	_fmemset(&mic, 0, sizeof(mic));
	if (-1 != nDevId)
	{
	    lstrcpy(mic.szPname, gszBogusCaps);
	}
	else
	{
	    if (0 != midiInGetNumDevs())
	    {
		mic.wMid           = MM_MICROSOFT;
		mic.vDriverVersion = (MMVERSION)MyGetVersion();
		lstrcpy(mic.szPname, gszDefaultMapper);
		mmr = MMSYSERR_NOERROR;
	    }
	}
    }

    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)mic.szPname);

    if (MMSYSERR_NOERROR != mmr)
	return (TRUE);

    //
    //
    //
    //
    MMCapsMidAndPid(mic.wMid, ach, 0, NULL);
    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach);

    MMCapsMidAndPid(mic.wMid, NULL, mic.wPid, ach);
    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach);

    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n",
		 (mic.vDriverVersion >> 8), (BYTE)mic.vDriverVersion);

    return (TRUE);
} // MMCapsDetailMidiIn()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsDetailMidiOut
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hedit:
//  
//      int nDevId:
//  
//  Return (BOOL):
//  
//  History:
//      05/11/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsDetailMidiOut
(
    HWND            hedit,
    int             nDevId
)
{
    TCHAR           ach[MMCAPS_MAX_STRING_MIDPID_CHARS];
    PSTR            psz;
    MMRESULT        mmr;
    MIDIOUTCAPS     moc;
    UINT            u;
    DWORD           dw;

    AppMEditPrintF(hedit, "      Device Type: %s\r\n",
		 (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_MIDIOUT]);

    if (-1 == nDevId) {
	AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId);
    } else {
	AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);
    }


    //
    //
    //
    mmr = midiOutGetDevCaps(nDevId, &moc, sizeof(moc));
    if (MMSYSERR_NOERROR != mmr)
    {
	_fmemset(&moc, 0, sizeof(moc));
	if (-1 != nDevId)
	{
	    lstrcpy(moc.szPname, gszBogusCaps);
	}
	else
	{
	    if (0 != midiOutGetNumDevs())
	    {
		moc.wMid           = MM_MICROSOFT;
		moc.vDriverVersion = (MMVERSION)MyGetVersion();
		lstrcpy(moc.szPname, gszDefaultMapper);
		mmr = MMSYSERR_NOERROR;
	    }
	}
    }

    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)moc.szPname);

    if (MMSYSERR_NOERROR != mmr)
	return (TRUE);

    //
    //
    //
    //
    MMCapsMidAndPid(moc.wMid, ach, 0, NULL);
    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach);

    MMCapsMidAndPid(moc.wMid, NULL, moc.wPid, ach);
    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach);

    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n",
		 (moc.vDriverVersion >> 8), (BYTE)moc.vDriverVersion);


    if (moc.wTechnology > MIDIOUTCAPS_TECHNOLOGY_LAST)
    {
	wsprintf(ach, "[%u], Unknown", moc.wTechnology);
	psz = ach;
    }
    else
    {
	psz = gaszMidiOutCapsTechnology[moc.wTechnology];
    }

    AppMEditPrintF(hedit, "       Technology: %s\r\n", (LPSTR)psz);
    AppMEditPrintF(hedit, " Voices (Patches): %u (if internal synth)\r\n", moc.wVoices);
    AppMEditPrintF(hedit, "        Polyphony: %u (if internal synth)\r\n", moc.wNotes);
    AppMEditPrintF(hedit, "     Channel Mask: %.04Xh (if internal synth)\r\n", moc.wChannelMask);

    //
    //
    //
    //
    AppMEditPrintF(hedit, " Standard Support: [%.08lXh]", moc.dwSupport);
    for (u = 0, dw = moc.dwSupport; dw; u++)
    {
	if ((BYTE)dw & (BYTE)1)
	{
	    psz = gaszMidiOutCapsSupport[u];
	    if (NULL == psz)
	    {
		wsprintf(ach, "Unknown%u", u);
		psz = ach;
	    }

	    AppMEditPrintF(hedit, ", %s", (LPSTR)psz);
	}

	dw >>= 1;
    }
    AppMEditPrintF(hedit, "\r\n");

    return (TRUE);
} // MMCapsDetailMidiOut()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsDetailMixer
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hedit:
//  
//      int nDevId:
//  
//  Return (BOOL):
//  
//  History:
//      05/11/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsDetailMixer
(
    HWND            hedit,
    int             nDevId
)
{
    TCHAR           ach[MMCAPS_MAX_STRING_MIDPID_CHARS];
    PSTR            psz;
    MMRESULT        mmr;
    MIXERCAPS       mxc;
    UINT            u;
    DWORD           dw;

    AppMEditPrintF(hedit, "      Device Type: %s\r\n",
		 (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_MIXER]);

#ifdef MIXER_MAPPER
    if (-1 == nDevId)
	AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId);
    else
	AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);
#else
    AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);
#endif


    //
    //
    //
    mmr = mixerGetDevCaps(nDevId, &mxc, sizeof(mxc));
    if (MMSYSERR_NOERROR != mmr)
    {
	_fmemset(&mxc, 0, sizeof(mxc));
	if (-1 != nDevId)
	{
	    lstrcpy(mxc.szPname, gszBogusCaps);
	}
	else
	{
	    if (0 != mixerGetNumDevs())
	    {
		mxc.wMid           = MM_MICROSOFT;
		mxc.vDriverVersion = (MMVERSION)MyGetVersion();
		lstrcpy(mxc.szPname, gszDefaultMapper);
		mmr = MMSYSERR_NOERROR;
	    }
	}
    }

    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)mxc.szPname);

    if (MMSYSERR_NOERROR != mmr)
	return (TRUE);

    //
    //
    //
    //
    MMCapsMidAndPid(mxc.wMid, ach, 0, NULL);
    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach);

    MMCapsMidAndPid(mxc.wMid, NULL, mxc.wPid, ach);
    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach);

    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n",
		 (mxc.vDriverVersion >> 8), (BYTE)mxc.vDriverVersion);

    AppMEditPrintF(hedit, "     Destinations: %u\r\n", mxc.cDestinations);

    //
    //
    //
    //
    AppMEditPrintF(hedit, " Standard Support: [%.08lXh]", mxc.fdwSupport);
    for (u = 0, dw = mxc.fdwSupport; dw; u++)
    {
	if ((BYTE)dw & (BYTE)1)
	{
	    psz = gaszMixerCapsSupport[u];
	    if (NULL == psz)
	    {
		wsprintf(ach, "Unknown%u", u);
		psz = ach;
	    }

	    AppMEditPrintF(hedit, ", %s", (LPSTR)psz);
	}

	dw >>= 1;
    }
    AppMEditPrintF(hedit, "\r\n");

    return (TRUE);
} // MMCapsDetailMixer()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsDetailTimer
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hedit:
//  
//      int nDevId:
//  
//  Return (BOOL):
//  
//  History:
//      05/11/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsDetailTimer
(
    HWND            hedit,
    int             nDevId
)
{
    MMRESULT        mmr;
    TIMECAPS        tc;
    MMVERSION       uMMSysVer;

    AppMEditPrintF(hedit, "      Device Type: %s\r\n",
		 (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_TIMER]);

    AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);
    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)gszTimerDevice);

    mmr = timeGetDevCaps(&tc, sizeof(tc));
    if (MMSYSERR_NOERROR != mmr)
	return (TRUE);

    //
    //
    //
    //
    uMMSysVer = (MMVERSION)MyGetVersion();
    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n",
		 (uMMSysVer >> 8), (BYTE)uMMSysVer);

    AppMEditPrintF(hedit, "   Minimum Period: %u\r\n", tc.wPeriodMin);
    AppMEditPrintF(hedit, "   Maximum Period: %u\r\n", tc.wPeriodMax);

    return (TRUE);
} // MMCapsDetailTimer()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsDetailWaveIn
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hedit:
//  
//      int nDevId:
//  
//  Return (BOOL):
//  
//  History:
//      05/11/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsDetailWaveIn
(
    HWND            hedit,
    int             nDevId
)
{
    TCHAR           ach[MMCAPS_MAX_STRING_MIDPID_CHARS];
    PSTR            psz;
    MMRESULT        mmr;
    WAVEINCAPS      wic;
    UINT            u;
    DWORD           dw;

    AppMEditPrintF(hedit, "      Device Type: %s\r\n",
		 (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_WAVEIN]);

    if (-1 == nDevId)
	AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId);
    else
	AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);


    //
    //
    //
    mmr = waveInGetDevCaps(nDevId, &wic, sizeof(wic));
    if (MMSYSERR_NOERROR != mmr)
    {
	_fmemset(&wic, 0, sizeof(wic));
	if (-1 != nDevId)
	{
	    lstrcpy(wic.szPname, gszBogusCaps);
	}
	else
	{
	    if (0 != waveInGetNumDevs())
	    {
		wic.wMid           = MM_MICROSOFT;
		wic.vDriverVersion = (MMVERSION)MyGetVersion();
		lstrcpy(wic.szPname, gszDefaultMapper);
		mmr = MMSYSERR_NOERROR;
	    }
	}
    }

    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)wic.szPname);

    if (MMSYSERR_NOERROR != mmr)
	return (TRUE);

    //
    //
    //
    //
    MMCapsMidAndPid(wic.wMid, ach, 0, NULL);
    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach);

    MMCapsMidAndPid(wic.wMid, NULL, wic.wPid, ach);
    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach);

    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n",
		 (wic.vDriverVersion >> 8), (BYTE)wic.vDriverVersion);

    AppMEditPrintF(hedit, "         Channels: %u\r\n", wic.wChannels);

    //
    //
    //
    //
    AppMEditPrintF(hedit, " Standard Formats: [%.08lXh]", wic.dwFormats);
    for (u = 0, dw = wic.dwFormats; dw; u++)
    {
	if ((BYTE)dw & (BYTE)1)
	{
	    psz = gaszWaveInOutCapsFormats[u];
	    if (NULL == psz)
	    {
		wsprintf(ach, "Unknown%u", u);
		psz = ach;
	    }

	    AppMEditPrintF(hedit, ", %s", (LPSTR)psz);
	}

	dw >>= 1;
    }
    AppMEditPrintF(hedit, "\r\n");


    return (TRUE);
} // MMCapsDetailWaveIn()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsDetailWaveOut
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hedit:
//  
//      int nDevId:
//  
//  Return (BOOL):
//  
//  History:
//      05/11/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsDetailWaveOut
(
    HWND            hedit,
    int             nDevId
)
{
    TCHAR           ach[MMCAPS_MAX_STRING_MIDPID_CHARS];
    PSTR            psz;
    MMRESULT        mmr;
    WAVEOUTCAPS     woc;
    UINT            u;
    DWORD           dw;

    AppMEditPrintF(hedit, "      Device Type: %s\r\n",
		 (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_WAVEOUT]);

    if (-1 == nDevId)
	AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId);
    else
	AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);


    //
    //
    //
    mmr = waveOutGetDevCaps(nDevId, &woc, sizeof(woc));
    if (MMSYSERR_NOERROR != mmr)
    {
	_fmemset(&woc, 0, sizeof(woc));
	if (-1 != nDevId)
	{
	    lstrcpy(woc.szPname, gszBogusCaps);
	}
	else
	{
	    if (0 != waveOutGetNumDevs())
	    {
		woc.wMid           = MM_MICROSOFT;
		woc.vDriverVersion = (MMVERSION)MyGetVersion();
		lstrcpy(woc.szPname, gszDefaultMapper);
		mmr = MMSYSERR_NOERROR;
	    }
	}
    }

    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)woc.szPname);

    if (MMSYSERR_NOERROR != mmr)
	return (TRUE);

    //
    //
    //
    //
    MMCapsMidAndPid(woc.wMid, ach, 0, NULL);
    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach);

    MMCapsMidAndPid(woc.wMid, NULL, woc.wPid, ach);
    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach);

    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n",
		 (woc.vDriverVersion >> 8), (BYTE)woc.vDriverVersion);

    AppMEditPrintF(hedit, "         Channels: %u\r\n", woc.wChannels);

    //
    //
    //
    //
    AppMEditPrintF(hedit, " Standard Formats: [%.08lXh]", woc.dwFormats);
    for (u = 0, dw = woc.dwFormats; dw; u++)
    {
	if ((BYTE)dw & (BYTE)1)
	{
	    psz = gaszWaveInOutCapsFormats[u];
	    if (NULL == psz)
	    {
		wsprintf(ach, "Unknown%u", u);
		psz = ach;
	    }

	    AppMEditPrintF(hedit, ", %s", (LPSTR)psz);
	}

	dw >>= 1;
    }
    AppMEditPrintF(hedit, "\r\n");


    //
    //
    //
    //
    AppMEditPrintF(hedit, " Standard Support: [%.08lXh]", woc.dwSupport);
    for (u = 0, dw = woc.dwSupport; dw; u++)
    {
	if ((BYTE)dw & (BYTE)1)
	{
	    psz = gaszWaveOutCapsSupport[u];
	    if (NULL == psz)
	    {
		wsprintf(ach, "Unknown%u", u);
		psz = ach;
	    }

	    AppMEditPrintF(hedit, ", %s", (LPSTR)psz);
	}

	dw >>= 1;
    }
    AppMEditPrintF(hedit, "\r\n");

    return (TRUE);
} // MMCapsDetailWaveOut()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsDetailLowLevel
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hedit:
//
//      LPARAM lParam:
//  
//  Return (BOOL):
//  
//  History:
//      05/16/93
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL MMCapsDetailLowLevel
   (
    HWND            hedit,
    LPARAM          lParam
   )
{
    int         nDevId;
    UINT        uDevType;

    //
    //  HIWORD(lParam): MMCAPS_DEVTYPE_*
    //  LOWORD(lParam): Device index (id)
    //
    nDevId   = (int)(short)LOWORD(lParam);
    uDevType = HIWORD(lParam);

    //
    //
    //
    //
    switch (uDevType)
    {
	case MMCAPS_DEVTYPE_AUXILIARY:
	    MMCapsDetailAuxiliary(hedit, nDevId);
	    break;

	case MMCAPS_DEVTYPE_JOYSTICK:
	    MMCapsDetailJoystick(hedit, nDevId);
	    break;

	case MMCAPS_DEVTYPE_MIDIIN:
	    MMCapsDetailMidiIn(hedit, nDevId);
	    break;

	case MMCAPS_DEVTYPE_MIDIOUT:
	    MMCapsDetailMidiOut(hedit, nDevId);
	    break;

	case MMCAPS_DEVTYPE_MIXER:
	    MMCapsDetailMixer(hedit, nDevId);
	    break;

	case MMCAPS_DEVTYPE_TIMER:
	    MMCapsDetailTimer(hedit, nDevId);
	    break;

	case MMCAPS_DEVTYPE_WAVEIN:
	    MMCapsDetailWaveIn(hedit, nDevId);
	    break;

	case MMCAPS_DEVTYPE_WAVEOUT:
	    MMCapsDetailWaveOut(hedit, nDevId);
	    break;
    }


    //
    //
    //
    return (TRUE);
} // MMCapsDetailLowLevel()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsEnumerateLowLevel
//  
//  Description:
//  
//  
//  Arguments:
//      PZYZTABBEDLISTBOX ptlb:
//  
//      BOOL fComplete:
//  
//  Return (BOOL):
//  
//  History:
//      05/18/93
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL MMCapsEnumerateLowLevel
(
    PZYZTABBEDLISTBOX   ptlb,
    BOOL                fComplete
)
{
    TCHAR       ach[128];
    MMRESULT    mmr;
    int         n;
    int         nDevs;
    int         nPrefDev;
    DWORD       dwPrefFlags;
    int         nIndex;
    LPARAM      lParam;
    UINT        uDevType;
    MMVERSION   uMMSysVer;
    HWND        hlb;


    //
    //
    //
    //
    //
    if (fComplete)
    {
	TlbSetTitleAndTabs(ptlb, gszDeviceFormatTitle, FALSE);
    }

    hlb = ptlb->hlb;

    uMMSysVer = (MMVERSION)MyGetVersion();


    //
    //
    //
    nDevs = auxGetNumDevs();
    for (n = -1; n < nDevs; n++)
    {
	AUXCAPS         ac;

	mmr = auxGetDevCaps(n, &ac, sizeof(ac));
	if (MMSYSERR_NOERROR != mmr)
	{
	    if (-1 != n)
	    {
		ac.vDriverVersion = 0;
		lstrcpy(ac.szPname, gszBogusCaps);
	    }
	    else
	    {
		if (0 == nDevs)
		    break;

		ac.vDriverVersion = uMMSysVer;
		lstrcpy(ac.szPname, gszDefaultMapper);
	    }
	}

	//
	//
	//
	uDevType = MMCAPS_DEVTYPE_AUXILIARY;
	wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType],
		 n, (ac.vDriverVersion >> 8), (BYTE)ac.vDriverVersion,
		 (LPSTR)ac.szPname);

	nIndex = ListBox_AddString(hlb, ach);
	lParam = MAKELPARAM((WORD)n, (WORD)uDevType);
	ListBox_SetItemData(hlb, nIndex, lParam);
    }


    //
    //
    //
    //
    //
#ifndef WIN32
    nDevs = mixerGetNumDevs();
#ifdef MIXER_MAPPER
    for (n = -1; n < nDevs; n++)
#else
	for (n = 0; n < nDevs; n++)
#endif
	{
	    MIXERCAPS       mxc;

	    mmr = mixerGetDevCaps(n, &mxc, sizeof(mxc));
	    if (MMSYSERR_NOERROR != mmr)
	    {
		if (-1 != n)
		{
		    mxc.vDriverVersion = 0;
		    lstrcpy(mxc.szPname, gszBogusCaps);
		}
		else
		{
		    if (0 == nDevs)
			break;

		    mxc.vDriverVersion = uMMSysVer;
		    lstrcpy(mxc.szPname, gszDefaultMapper);
		}
	    }

	//
	//
	//
	    uDevType = MMCAPS_DEVTYPE_MIXER;
	    wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType],
		     n, (mxc.vDriverVersion >> 8), (BYTE)mxc.vDriverVersion,
		     (LPSTR)mxc.szPname);

	    nIndex = ListBox_AddString(hlb, ach);
	    lParam = MAKELPARAM((WORD)n, (WORD)uDevType);
	    ListBox_SetItemData(hlb, nIndex, lParam);
	}
#endif



    //
    //
    //
    nDevs = midiInGetNumDevs();
    for (n = 0; n < nDevs; n++)
    {
	MIDIINCAPS      mic;

	mmr = midiInGetDevCaps(n, &mic, sizeof(mic));
	if (MMSYSERR_NOERROR != mmr)
	{
	    if (-1 != n)
	    {
		mic.vDriverVersion = 0;
		lstrcpy(mic.szPname, gszBogusCaps);
	    }
	    else
	    {
		if (0 == nDevs)
		    break;

		mic.vDriverVersion = uMMSysVer;
		lstrcpy(mic.szPname, gszDefaultMapper);
	    }
	}

	//
	//
	//
	uDevType = MMCAPS_DEVTYPE_MIDIIN;
	wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType],
		 n, (mic.vDriverVersion >> 8), (BYTE)mic.vDriverVersion,
		 (LPSTR)mic.szPname);

	nIndex = ListBox_AddString(hlb, ach);
	lParam = MAKELPARAM((WORD)n, (WORD)uDevType);
	ListBox_SetItemData(hlb, nIndex, lParam);
    }

    //
    //
    //
    mmr = midiOutMessage((HMIDIOUT)MIDI_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR)&nPrefDev, (DWORD_PTR)&dwPrefFlags);
    if (MMSYSERR_NOERROR != mmr) nPrefDev = -2;

    nDevs = midiOutGetNumDevs();
    for (n = -1; n < nDevs; n++)
    {
	MIDIOUTCAPS     moc;

	mmr = midiOutGetDevCaps(n, &moc, sizeof(moc));
	if (MMSYSERR_NOERROR != mmr)
	{
	    if (-1 != n)
	    {
		moc.vDriverVersion = 0;
		lstrcpy(moc.szPname, gszBogusCaps);
	    }
	    else
	    {
		if (0 == nDevs)
		    break;

		moc.vDriverVersion = uMMSysVer;
		lstrcpy(moc.szPname, gszDefaultMapper);
	    }
	}

	//
	//
	//
	uDevType = MMCAPS_DEVTYPE_MIDIOUT;
	wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType],
		 n, (moc.vDriverVersion >> 8), (BYTE)moc.vDriverVersion,
		 (LPSTR)moc.szPname);

	if (n != -1 && n == nPrefDev) {
	    if (dwPrefFlags & DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY) {
		strcat(ach, TEXT("(**)"));
	    } else {
		strcat(ach, TEXT("(*)"));
	    }
	}

	nIndex = ListBox_AddString(hlb, ach);
	lParam = MAKELPARAM((WORD)n, (WORD)uDevType);
	ListBox_SetItemData(hlb, nIndex, lParam);
    }


    //
    //
    //
    mmr = waveInMessage((HWAVEIN)WAVE_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR)&nPrefDev, (DWORD_PTR)&dwPrefFlags);
    if (MMSYSERR_NOERROR != mmr) nPrefDev = -2;

    nDevs = waveInGetNumDevs();
    for (n = -1; n < nDevs; n++)
    {
	WAVEINCAPS      wic;

	mmr = waveInGetDevCaps(n, &wic, sizeof(wic));
	if (MMSYSERR_NOERROR != mmr)
	{
	    if (-1 != n)
	    {
		wic.vDriverVersion = 0;
		lstrcpy(wic.szPname, gszBogusCaps);
	    }
	    else
	    {
		if (0 == nDevs)
		    break;

		wic.vDriverVersion = uMMSysVer;
		lstrcpy(wic.szPname, gszDefaultMapper);
	    }
	}

	//
	//
	//
	uDevType = MMCAPS_DEVTYPE_WAVEIN;
	wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType],
		 n, (wic.vDriverVersion >> 8), (BYTE)wic.vDriverVersion,
		 (LPSTR)wic.szPname);

	if (n != -1 && n == nPrefDev) {
	    if (dwPrefFlags & DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY) {
		strcat(ach, TEXT("(**)"));
	    } else {
		strcat(ach, TEXT("(*)"));
	    }
	}

	nIndex = ListBox_AddString(hlb, ach);
	lParam = MAKELPARAM((WORD)n, (WORD)uDevType);
	ListBox_SetItemData(hlb, nIndex, lParam);
    }

    //
    //
    //
    mmr = waveOutMessage((HWAVEOUT)WAVE_MAPPER, DRVM_MAPPER_PREFERRED_GET, (DWORD_PTR)&nPrefDev, (DWORD_PTR)&dwPrefFlags);
    if (MMSYSERR_NOERROR != mmr) nPrefDev = -2;

    nDevs = waveOutGetNumDevs();
    for (n = -1; n < nDevs; n++)
    {
	WAVEOUTCAPS     woc;

	mmr = waveOutGetDevCaps(n, &woc, sizeof(woc));
	if (MMSYSERR_NOERROR != mmr)
	{
	    if (-1 != n)
	    {
		woc.vDriverVersion = 0;
		lstrcpy(woc.szPname, gszBogusCaps);
	    }
	    else
	    {
		if (0 == nDevs)
		    break;

		woc.vDriverVersion = uMMSysVer;
		lstrcpy(woc.szPname, gszDefaultMapper);
	    }
	}

	//
	//
	//
	uDevType = MMCAPS_DEVTYPE_WAVEOUT;
	wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType],
		 n, (woc.vDriverVersion >> 8), (BYTE)woc.vDriverVersion,
		 (LPSTR)woc.szPname);

	if (n != -1 && n == nPrefDev) {
	    if (dwPrefFlags & DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY) {
		strcat(ach, TEXT("(**)"));
	    } else {
		strcat(ach, TEXT("(*)"));
	    }
	}

	nIndex = ListBox_AddString(hlb, ach);
	lParam = MAKELPARAM((WORD)n, (WORD)uDevType);
	ListBox_SetItemData(hlb, nIndex, lParam);
    }


    //
    //
    //
    {
	TIMECAPS    tc;

	mmr = timeGetDevCaps(&tc, sizeof(tc));
	if (MMSYSERR_NOERROR == mmr)
	{
	    //
	    //
	    //
	    uDevType = MMCAPS_DEVTYPE_TIMER;
	    wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType],
		     0, (uMMSysVer >> 8), (BYTE)uMMSysVer,
		     (LPSTR)gszTimerDevice);

	    nIndex = ListBox_AddString(hlb, ach);
	    lParam = MAKELPARAM(0, (WORD)uDevType);
	    ListBox_SetItemData(hlb, nIndex, lParam);
	}
    }



    //
    //
    //
    nDevs = joyGetNumDevs();
    for (n = 0; n < nDevs; n++)
    {
	JOYCAPS         jc;

	mmr = joyGetDevCaps(n, &jc, sizeof(jc));
	if (MMSYSERR_NOERROR != mmr)
	{
	    lstrcpy(jc.szPname, gszBogusCaps);
	}

	//
	//
	//
	uDevType = MMCAPS_DEVTYPE_JOYSTICK;
	wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType],
		 n, 0, 0, (LPSTR)jc.szPname);

	nIndex = ListBox_AddString(hlb, ach);
	lParam = MAKELPARAM((WORD)n, (WORD)uDevType);
	ListBox_SetItemData(hlb, nIndex, lParam);
    }



    //
    //
    //
    return (TRUE);
} // MMCapsEnumerateLowLevel()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mmcaps2k\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1997 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//  History:
//      11/23/92
//
//==========================================================================;

#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifdef WIN32
    #include <wchar.h>
#else
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define wvsprintfA          wvsprintf
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
#endif

//
//
//
BOOL    __gfDbgEnabled  = TRUE;     // master enable
UINT    __guDbgLevel    = 0;        // current debug level


//--------------------------------------------------------------------------;
//
//  void DbgVPrintF(LPSTR szFmt, LPSTR va)
//
//  Description:
//      
//
//  Arguments:
//
//  Return (void):
//
//
//  History:
//      11/28/92
//
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF(LPSTR szFmt, LPSTR va)
{
    char    ach[DEBUG_MAX_LINE_LEN];
    BOOL    fDebugBreak = FALSE;
    BOOL    fPrefix     = TRUE;
    BOOL    fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
	switch(*szFmt)
	{
	    case '!':
		fDebugBreak = TRUE;
		szFmt++;
		continue;

	    case '`':
		fPrefix = FALSE;
		szFmt++;
		continue;

	    case '~':
		fCRLF = FALSE;
		szFmt++;
		continue;
	}

	break;
    }

    if (fDebugBreak)
    {
	ach[0] = '\007';
	ach[1] = '\0';
    }

    if (fPrefix)
	lstrcatA(ach, DEBUG_MODULE_NAME ": ");

    wvsprintfA(ach + lstrlenA(ach), szFmt, va);

    if (fCRLF)
	lstrcatA(ach, "\r\n");

    OutputDebugStringA(ach);

    if (fDebugBreak)
	DebugBreak();
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//
//  void dprintf(UINT uDbgLevel, LPSTR szFmt, ...)
//
//  Description:
//      dprintf() is called by the DPF macro if DEBUG is defined at compile
//      time.
//      
//      The messages will be send to COM1: like any debug message. To
//      enable debug output, add the following to WIN.INI :
//
//      [debug]
//      ICSAMPLE=1
//
//  Arguments:
//
//  Return (void):
//
//
//  History:
//      11/23/92
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
	return;

    va_start(va, szFmt);
    DbgVPrintF(szFmt, va);
    va_end(va);
} // dprintf()

//--------------------------------------------------------------------------;
//
//  BOOL DbgEnable(BOOL fEnable)
//
//  Description:
//      
//
//  Arguments:
//
//  Return (BOOL):
//
//
//  History:
//      11/28/92
//
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable(BOOL fEnable)
{
    BOOL    fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//
//  UINT DbgSetLevel(UINT uLevel)
//
//  Description:
//      
//
//  Arguments:
//
//  Return (UINT):
//
//
//  History:
//      11/24/92
//
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel(UINT uLevel)
{
    UINT    uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//
//  UINT DbgInitialize(void)
//
//  Description:
//      
//
//  Arguments:
//
//  Return (UINT):
//
//
//  History:
//      11/24/92
//
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize(BOOL fEnable)
{
    DbgSetLevel(GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, 0));
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mmcaps2k\midspids.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1997 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  midspids.c
//
//
//  Description:
//
//   !!! WARNING DANGER WARNING DANGER WARNING DANGER WARNING DANGER !!!
//
//      This code assumes that the receiving buffers are large enough
//      to contain the largest Mid and Pid--so if some of the strings get
//      obnoxiously long, make sure you update the following defines in
//      MMCAPS.H:
//
//          MMCAPS_MAX_STRING_MID_CHARS
//          MMCAPS_MAX_STRING_PID_CHARS
//
//      Also, this code is horribly disgusting. Its purpose is to convert
//      Manufacturer specific Product Id's to human readable text. And
//      since no standard was defined on how to allocate these Id's,
//      all kinds of inconsistent schemes emerged.
//
//      Therefore, I chose the brute force approach. You are more than
//      welcome to clean this up by finding patterns, etc for each
//      manufacturer--I have better things to do.
//
//   !!! WARNING DANGER WARNING DANGER WARNING DANGER WARNING DANGER !!!
//
//  History:
//       5/13/93
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <commdlg.h>
#include <stdarg.h>

#include "appport.h"
#include "mmcaps.h"

#include "debug.h"


//==========================================================================;
//
//  Manufacturer and Product Id Conversion Hacks
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_MICROSOFT
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_MICROSOFT
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]        = TEXT("Microsoft Corporation");
    static PTSTR aszProductId[] =
    {
	NULL,                                            // 0  
	TEXT("MIDI Mapper"),                             // 1  MM_MIDI_MAPPER
	TEXT("Wave Mapper"),                             // 2  MM_WAVE_MAPPER
	TEXT("Sound Blaster MIDI output port"),          // 3  MM_SNDBLST_MIDIOUT
	TEXT("Sound Blaster MIDI input port"),           // 4  MM_SNDBLST_MIDIIN
	TEXT("Sound Blaster internal synthesizer"),      // 5  MM_SNDBLST_SYNTH
	TEXT("Sound Blaster waveform output"),           // 6  MM_SNDBLST_WAVEOUT
	TEXT("Sound Blaster waveform input"),            // 7  MM_SNDBLST_WAVEIN
	NULL,                                            // 8
	TEXT("Ad Lib-compatible synthesizer"),           // 9  MM_ADLIB
	TEXT("MPU401-compatible MIDI output port"),      // 10 MM_MPU401_MIDIOUT
	TEXT("MPU401-compatible MIDI input port"),       // 11 MM_MPU401_MIDIIN
	TEXT("Joystick adapter"),                        // 12 MM_PC_JOYSTICK
	TEXT("PC Speaker waveform output"),              // 13 MM_PCSPEAKER_WAVEOUT
	TEXT("MS Audio Board waveform input"),           // 14 MM_MSFT_WSS_WAVEIN
	TEXT("MS Audio Board waveform output"),          // 15 MM_MSFT_WSS_WAVEOUT
	TEXT("MS Audio Board Stereo FM synthesizer"),    // 16 MM_MSFT_WSS_FMSYNTH_STEREO
	TEXT("MS Audio Board Mixer Driver"),             // 17 MM_MSFT_WSS_MIXER
	TEXT("MS OEM Audio Board waveform input"),       // 18 MM_MSFT_WSS_OEM_WAVEIN
	TEXT("MS OEM Audio Board waveform Output"),      // 19 MM_MSFT_WSS_OEM_WAVEOUT
	TEXT("MS OEM Audio Board Stereo FM synthesizer"),// 20 MM_MSFT_WSS_OEM_FMSYNTH_STEREO
	TEXT("MS Audio Board Auxiliary Port"),           // 21 MM_MSFT_WSS_AUX
	TEXT("MS OEM Audio Auxiliary Port"),             // 22 MM_MSFT_WSS_OEM_AUX
	TEXT("MS vanilla driver waveform input"),        // 23 MM_MSFT_GENERIC_WAVEIN
	TEXT("MS vanilla driver waveform output"),       // 24 MM_MSFT_GENERIC_WAVEOUT
	TEXT("MS vanilla driver MIDI input"),            // 25 MM_MSFT_GENERIC_MIDIIN
	TEXT("MS vanilla driver external MIDI output"),  // 26 MM_MSFT_GENERIC_MIDIOUT
	TEXT("MS vanilla driver MIDI synthesizer"),      // 27 MM_MSFT_GENERIC_MIDISYNTH
	TEXT("MS vanilla driver aux (line in)"),         // 28 MM_MSFT_GENERIC_AUX_LINE
	TEXT("MS vanilla driver aux (mic)"),             // 29 MM_MSFT_GENERIC_AUX_MIC
	TEXT("MS vanilla driver aux (CD)"),              // 30 MM_MSFT_GENERIC_AUX_CD
	TEXT("MS OEM Audio Board Mixer Driver"),         // 31 MM_MSFT_WSS_OEM_MIXER
    };

    #define PRODUCTID_MICROSOFT_LAST    MM_MSFT_WSS_OEM_MIXER

    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    if ((uPid <= PRODUCTID_MICROSOFT_LAST) && (psz = aszProductId[uPid]))
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    pszPid[0] = '\0';
    return (FALSE);
} // MMCapsMidPid_MM_MICROSOFT()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_CREATIVE
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_CREATIVE
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Creative Labs Inc.");

    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
	case MM_CREATIVE_SB15_WAVEIN:
	    psz = TEXT("SB (r) 1.5 waveform input");
	    break;

	case MM_CREATIVE_SB20_WAVEIN:
	    psz = TEXT("SB (r) 2.0 waveform input");
	    break;

	case MM_CREATIVE_SBPRO_WAVEIN:
	    psz = TEXT("SB Pro (r) waveform input");
	    break;

	case MM_CREATIVE_SBP16_WAVEIN:
	    psz = TEXT("SBP16 (r) waveform input");
	    break;

	case MM_CREATIVE_SB15_WAVEOUT:
	    psz = TEXT("SB (r) 1.5 waveform output");
	    break;

	case MM_CREATIVE_SB20_WAVEOUT:
	    psz = TEXT("SB (r) 2.0 waveform output");
	    break;

	case MM_CREATIVE_SBPRO_WAVEOUT:
	    psz = TEXT("SB Pro (r) waveform output");
	    break;

	case MM_CREATIVE_SBP16_WAVEOUT:
	    psz = TEXT("SBP16 (r) waveform output");
	    break;

	case MM_CREATIVE_MIDIOUT:
	    psz = TEXT("SB (r) MIDI output port");
	    break;

	case MM_CREATIVE_MIDIIN:
	    psz = TEXT("SB (r) MIDI input port");
	    break;

	case MM_CREATIVE_FMSYNTH_MONO:
	    psz = TEXT("SB (r) FM synthesizer");
	    break;

	case MM_CREATIVE_FMSYNTH_STEREO:
	    psz = TEXT("SB Pro (r) stereo FM synthesizer");
	    break;

	case MM_CREATIVE_AUX_CD:
	    psz = TEXT("SB Pro (r) aux (CD)");
	    break;

	case MM_CREATIVE_AUX_LINE:
	    psz = TEXT("SB Pro (r) aux (line in)");
	    break;

	case MM_CREATIVE_AUX_MIC:
	    psz = TEXT("SB Pro (r) aux (mic)");
	    break;
    }

    if (NULL != psz)
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_CREATIVE()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_MEDIAVISION
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_MEDIAVISION
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Media Vision Inc.");

    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
	case MM_PROAUD_MIDIOUT:
	    psz = TEXT("MediaVision MIDI output port");
	    break;

	case MM_PROAUD_MIDIIN:
	    psz = TEXT("MediaVision MIDI input port");
	    break;

	case MM_PROAUD_SYNTH:
	    psz = TEXT("MediaVision synthesizer");
	    break;

	case MM_PROAUD_WAVEOUT:
	    psz = TEXT("MediaVision Waveform output");
	    break;

	case MM_PROAUD_WAVEIN:
	    psz = TEXT("MediaVision Waveform input");
	    break;

	case MM_PROAUD_MIXER:
	    psz = TEXT("MediaVision Mixer");
	    break;

	case MM_PROAUD_AUX:
	    psz = TEXT("MediaVision aux");
	    break;

	case MM_MEDIAVISION_THUNDER:
	    psz = TEXT("Thunderboard Sound Card");
	    break;
    }

    if (NULL != psz)
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_MEDIAVISION()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_FUJITSU
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_FUJITSU
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Fujitsu");


    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_FUJITSU()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_ARTISOFT
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_ARTISOFT
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Artisoft Inc.");

    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
	case MM_ARTISOFT_SBWAVEIN:
	    psz = TEXT("Artisoft Sounding Board waveform input");
	    break;

	case MM_ARTISOFT_SBWAVEOUT:
	    psz = TEXT("Artisoft Sounding Board waveform output");
	    break;
    }

    if (NULL != psz)
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_ARTISOFT()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_TURTLE_BEACH
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_TURTLE_BEACH
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Turtle Beach");


    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_TURTLE_BEACH()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_IBM
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_IBM
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("International Bussiness Machines Corp.");

    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
	case MM_MMOTION_WAVEAUX:
	    psz = TEXT("IBM M-Motion Auxiliary Device");
	    break;

	case MM_MMOTION_WAVEOUT:
	    psz = TEXT("IBM M-Motion Waveform Output");
	    break;

	case MM_MMOTION_WAVEIN: 
	    psz = TEXT("IBM M-Motion Waveform Input");
	    break;
    }

    if (NULL != psz)
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_IBM()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_VOCALTEC
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_VOCALTEC
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Vocaltec LTD.");


    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
	case MM_VOCALTEC_WAVEOUT:
	    psz = TEXT("Vocaltec Waveform output port");
	    break;

	case MM_VOCALTEC_WAVEIN:
	    psz = TEXT("Waveform input port");
	    break;
    }

    if (NULL != psz)
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_VOCALTEC()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_ROLAND
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_ROLAND
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Roland");

    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
	case MM_ROLAND_MPU401_MIDIOUT:
	    psz = TEXT("MM_ROLAND_MPU401_MIDIOUT");
	    break;

	case MM_ROLAND_MPU401_MIDIIN:
	    psz = TEXT("MM_ROLAND_MPU401_MIDIIN");
	    break;

	case MM_ROLAND_SMPU_MIDIOUTA:
	    psz = TEXT("MM_ROLAND_SMPU_MIDIOUTA");
	    break;

	case MM_ROLAND_SMPU_MIDIOUTB:
	    psz = TEXT("MM_ROLAND_SMPU_MIDIOUTB");
	    break;

	case MM_ROLAND_SMPU_MIDIINA:
	    psz = TEXT("MM_ROLAND_SMPU_MIDIINA");
	    break;

	case MM_ROLAND_SMPU_MIDIINB:
	    psz = TEXT("MM_ROLAND_SMPU_MIDIINB");
	    break;

	case MM_ROLAND_SC7_MIDIOUT:
	    psz = TEXT("MM_ROLAND_SC7_MIDIOUT");
	    break;

	case MM_ROLAND_SC7_MIDIIN:
	    psz = TEXT("MM_ROLAND_SC7_MIDIIN");
	    break;
    }

    if (NULL != psz)
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_ROLAND()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_DIGISPEECH
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_DIGISPEECH
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Digispeech, Inc.");

    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
	//case MM_DIGISP_WAVEOUT:
	case MM_DSP_SOLUTIONS_WAVEOUT:
	    psz = TEXT("Digispeech Waveform output port");
	    break;

	//case MM_DIGISP_WAVEIN:
	case MM_DSP_SOLUTIONS_WAVEIN:
	    psz = TEXT("Digispeech Waveform input port");
	    break;
	case MM_DSP_SOLUTIONS_SYNTH:
	case MM_DSP_SOLUTIONS_AUX:
	    break;

    #define  MM_DSP_SOLUTIONS_WAVEOUT       1
#define  MM_DSP_SOLUTIONS_WAVEIN            2       
#define  MM_DSP_SOLUTIONS_SYNTH             3       
#define  MM_DSP_SOLUTIONS_AUX               4       

    }

    if (NULL != psz)
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_DIGISPEECH()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_NEC
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_NEC
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("NEC");


    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_NEC()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_ATI
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_ATI
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("ATI");

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_ATI()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_WANGLABS
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_WANGLABS
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Wang Laboratories, Inc.");

    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
	case MM_WANGLABS_WAVEIN1:
	    psz = TEXT("Wave input on Wang models: Exec 4010, 4030 and 3450; PC 251/25C, PC 461/25S and PC 461/33C");
	    break;

	case MM_WANGLABS_WAVEOUT1:
	    psz = TEXT("Wave output on Wang models: Exec 4010, 4030 and 3450; PC 251/25C, PC 461/25S and PC 461/33C");
	    break;
    }

    if (NULL != psz)
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_WANGLABS()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_TANDY
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_TANDY
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Tandy Corporation");


    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_TANDY()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_VOYETRA
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_VOYETRA
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Voyetra");


    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_VOYETRA()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_ANTEX
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_ANTEX
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Antex");


    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_ANTEX()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_ICL_PS
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_ICL_PS
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("ICL PS");


    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_ICL_PS()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_INTEL
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_INTEL
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Intel");

    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
	case MM_INTELOPD_WAVEIN:
	    psz = TEXT("HID2 WaveAudio Input driver");
	    break;

	case MM_INTELOPD_WAVEOUT:
	    psz = TEXT("HID2 WaveAudio Output driver");
	    break;

	case MM_INTELOPD_AUX:
	    psz = TEXT("HID2 Auxiliary driver (required for mixing functions)");
	    break;
    }

    if (NULL != psz)
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_INTEL()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_GRAVIS
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_GRAVIS
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Gravis");


    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_GRAVIS()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_VAL
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_VAL
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Video Associates Labs");


    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_VAL()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_INTERACTIVE
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_INTERACTIVE
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("InterActive, Inc.");

    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
	case MM_INTERACTIVE_WAVEIN:
	    psz = TEXT("MM_INTERACTIVE_WAVEIN or WAVEOUT ??");
	    break;

#if 0
	//  mmreg.h has in and out defined as same value... how quaint.
	case MM_INTERACTIVE_WAVEOUT:
	    psz = TEXT("MM_INTERACTIVE_WAVEOUT");
	    break;
#endif
    }

    if (NULL != psz)
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_INTERACTIVE()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_YAMAHA
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_YAMAHA
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Yamaha Corp. of America");


    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
	case MM_YAMAHA_GSS_SYNTH:
	    psz = TEXT("Yamaha Gold Sound Standard FM sythesis driver");
	    break;

	case MM_YAMAHA_GSS_WAVEOUT:
	    psz = TEXT("Yamaha Gold Sound Standard wave output driver");
	    break;

	case MM_YAMAHA_GSS_WAVEIN:
	    psz = TEXT("Yamaha Gold Sound Standard wave input driver");
	    break;

	case MM_YAMAHA_GSS_MIDIOUT:
	    psz = TEXT("Yamaha Gold Sound Standard midi output driver");
	    break;

	case MM_YAMAHA_GSS_MIDIIN:
	    psz = TEXT("Yamaha Gold Sound Standard midi input driver");
	    break;

	case MM_YAMAHA_GSS_AUX:
	    psz = TEXT("Yamaha Gold Sound Standard auxillary driver for mixer functions");
	    break;
    }

    if (NULL != psz)
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_YAMAHA()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_EVEREX
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_EVEREX
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Everex Systems, Inc.");

    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
	case MM_EVEREX_CARRIER:
	    psz = TEXT("Everex Carrier SL/25 Notebook");
	    break;
    }

    if (NULL != psz)
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_EVEREX()


BOOL FNLOCAL MMCapsMidPid_MM_ECHO
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Echo Speech Corporation");

    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
	case MM_ECHO_SYNTH:
	    psz = TEXT("Echo EuSythesis driver");
	    break;

	case MM_ECHO_WAVEOUT:
	    psz = TEXT("Wave output driver");
	    break;

	case MM_ECHO_WAVEIN:
	    psz = TEXT("Wave input driver");
	    break;

	case MM_ECHO_MIDIOUT:
	    psz = TEXT("MIDI output driver");
	    break;

	case MM_ECHO_MIDIIN:
	    psz = TEXT("MIDI input driver");
	    break;

	case MM_ECHO_AUX:
	    psz = TEXT("auxillary driver for mixer functions");
	    break;
    }

    if (NULL != psz)
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    return (FALSE);
}


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_SIERRA
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_SIERRA
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Sierra Semiconductor");

    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
	case MM_SIERRA_ARIA_MIDIOUT:
	    psz = TEXT("Sierra Aria MIDI output");
	    break;

	case MM_SIERRA_ARIA_MIDIIN:
	    psz = TEXT("Sierra Aria MIDI input");
	    break;

	case MM_SIERRA_ARIA_SYNTH:
	    psz = TEXT("Sierra Aria Synthesizer");
	    break;

	case MM_SIERRA_ARIA_WAVEOUT:
	    psz = TEXT("Sierra Aria Waveform output");
	    break;

	case MM_SIERRA_ARIA_WAVEIN:
	    psz = TEXT("Sierra Aria Waveform input");
	    break;

	case MM_SIERRA_ARIA_AUX:
	    psz = TEXT("Sierra Aria Auxiliary device");
	    break;
    }

    if (NULL != psz)
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_SIERRA()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_CAT
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_CAT
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Computer Aided Technologies");


    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_CAT()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_APPS
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_APPS
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("APPS Software International");


    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_APPS()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_DSP_GROUP
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_DSP_GROUP
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("DSP Group, Inc.");

    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
	case MM_DSP_GROUP_TRUESPEECH:
	    psz = TEXT("High quality 9.54:1 Speech Compression Vocoder");
	    break;
    }

    if (NULL != psz)
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_DSP_GROUP()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_MELABS
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_MELABS
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("microEngineering Labs");

    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
	case MM_MELABS_MIDI2GO:
	    psz = TEXT("parallel port MIDI interface");
	    break;
    }

    if (NULL != psz)
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_MELABS()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_COMPUTER_FRIENDS
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_COMPUTER_FRIENDS
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Computer Friends, Inc");


    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_COMPUTER_FRIENDS()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_ESS
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_ESS
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("ESS Technology");

    PTSTR       psz;

    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //
    psz = NULL;
    switch (uPid)
    {
	case MM_ESS_AMWAVEOUT:
	    psz = TEXT("ESS Audio Magician Waveform Output Port");
	    break;

	case MM_ESS_AMWAVEIN:
	    psz = TEXT("ESS Audio Magician Waveform Input Port");
	    break;

	case MM_ESS_AMAUX:
	    psz = TEXT("ESS Audio Magician Auxiliary Port");
	    break;

	case MM_ESS_AMSYNTH:
	    psz = TEXT("ESS Audio Magician Internal Music Synthesizer Port");
	    break;

	case MM_ESS_AMMIDIOUT:
	    psz = TEXT("ESS Audio Magician MIDI Output Port");
	    break;

	case MM_ESS_AMMIDIIN:
	    psz = TEXT("ESS Audio Magician MIDI Input Port");
	    break;
    }

    if (NULL != psz)
    {
	lstrcat(pszPid, psz);
	return (TRUE);
    }

    return (FALSE);
} // MMCapsMidPid_MM_ESS()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_AUDIOFILE
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_AUDIOFILE
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Audio, Inc.");


    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_AUDIOFILE()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_MOTOROLA
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_MOTOROLA
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Motorola, Inc.");


    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_MOTOROLA()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidPid_MM_CANOPUS
//  
//  Description:
//  
//  
//  Arguments:
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsMidPid_MM_CANOPUS
(
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR szMid[]    = TEXT("Canopus Co., Ltd.");


    if (NULL != pszMid)
	lstrcpy(pszMid, szMid);

    if (NULL == pszPid)
	return (TRUE);

    //
    //
    //

    return (FALSE);
} // MMCapsMidPid_MM_CANOPUS()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsMidAndPid
//  
//  Description:
//  
//  
//  Arguments:
//      UINT uMid:
//  
//      PTSTR pszMid:
//  
//      UINT uPid:
//  
//      PTSTR pszPid:
//  
//  Return (BOOL):
//  
//  History:
//      05/13/93
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL MMCapsMidAndPid
(
    UINT            uMid,
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
)
{
    static TCHAR    szUnknown[]     = TEXT("Unknown");
    static TCHAR    szFormatId[]    = TEXT("[%u], %s");

    TCHAR       achMid[MMCAPS_MAX_STRING_MID_CHARS];
    TCHAR       achPid[MMCAPS_MAX_STRING_PID_CHARS];
    BOOL        f;

    switch (uMid)
    {
	case MM_MICROSOFT:
	    f = MMCapsMidPid_MM_MICROSOFT(achMid, uPid, achPid);
	    break;

	case MM_CREATIVE:
	    f = MMCapsMidPid_MM_CREATIVE(achMid, uPid, achPid);
	    break;

	case MM_MEDIAVISION:
	    f = MMCapsMidPid_MM_MEDIAVISION(achMid, uPid, achPid);
	    break;

	case MM_FUJITSU:
	    f = MMCapsMidPid_MM_FUJITSU(achMid, uPid, achPid);
	    break;

	case MM_ARTISOFT:
	    f = MMCapsMidPid_MM_ARTISOFT(achMid, uPid, achPid);
	    break;

	case MM_TURTLE_BEACH:
	    f = MMCapsMidPid_MM_TURTLE_BEACH(achMid, uPid, achPid);
	    break;

	case MM_IBM:
	    f = MMCapsMidPid_MM_IBM(achMid, uPid, achPid);
	    break;

	case MM_VOCALTEC:
	    f = MMCapsMidPid_MM_VOCALTEC(achMid, uPid, achPid);
	    break;

	case MM_ROLAND:
	    f = MMCapsMidPid_MM_ROLAND(achMid, uPid, achPid);
	    break;

	//case MM_DIGISPEECH:
	case MM_DSP_SOLUTIONS:
	    f = MMCapsMidPid_MM_DIGISPEECH(achMid, uPid, achPid);
	    break;

	case MM_NEC:
	    f = MMCapsMidPid_MM_NEC(achMid, uPid, achPid);
	    break;

	case MM_ATI:
	    f = MMCapsMidPid_MM_ATI(achMid, uPid, achPid);
	    break;

	case MM_WANGLABS:
	    f = MMCapsMidPid_MM_WANGLABS(achMid, uPid, achPid);
	    break;

	case MM_TANDY:
	    f = MMCapsMidPid_MM_TANDY(achMid, uPid, achPid);
	    break;

	case MM_VOYETRA:
	    f = MMCapsMidPid_MM_VOYETRA(achMid, uPid, achPid);
	    break;

	case MM_ANTEX:
	    f = MMCapsMidPid_MM_ANTEX(achMid, uPid, achPid);
	    break;

	case MM_ICL_PS:
	    f = MMCapsMidPid_MM_ICL_PS(achMid, uPid, achPid);
	    break;

	case MM_INTEL:
	    f = MMCapsMidPid_MM_INTEL(achMid, uPid, achPid);
	    break;

	case MM_GRAVIS:
	    f = MMCapsMidPid_MM_GRAVIS(achMid, uPid, achPid);
	    break;

	case MM_VAL:
	    f = MMCapsMidPid_MM_VAL(achMid, uPid, achPid);
	    break;

	case MM_INTERACTIVE:
	    f = MMCapsMidPid_MM_INTERACTIVE(achMid, uPid, achPid);
	    break;

	case MM_YAMAHA:
	    f = MMCapsMidPid_MM_YAMAHA(achMid, uPid, achPid);
	    break;

	case MM_EVEREX:
	    f = MMCapsMidPid_MM_EVEREX(achMid, uPid, achPid);
	    break;

	case MM_ECHO:
	    f = MMCapsMidPid_MM_ECHO(achMid, uPid, achPid);
	    break;

	case MM_SIERRA:
	    f = MMCapsMidPid_MM_SIERRA(achMid, uPid, achPid);
	    break;

	case MM_CAT:
	    f = MMCapsMidPid_MM_CAT(achMid, uPid, achPid);
	    break;

	case MM_APPS:
	    f = MMCapsMidPid_MM_APPS(achMid, uPid, achPid);
	    break;

	case MM_DSP_GROUP:
	    f = MMCapsMidPid_MM_DSP_GROUP(achMid, uPid, achPid);
	    break;

	case MM_MELABS:
	    f = MMCapsMidPid_MM_MELABS(achMid, uPid, achPid);
	    break;

	case MM_COMPUTER_FRIENDS:
	    f = MMCapsMidPid_MM_COMPUTER_FRIENDS(achMid, uPid, achPid);
	    break;

	case MM_ESS:
	    f = MMCapsMidPid_MM_ESS(achMid, uPid, achPid);
	    break;

	case MM_AUDIOFILE:
	    f = MMCapsMidPid_MM_AUDIOFILE(achMid, uPid, achPid);
	    break;

	case MM_MOTOROLA:
	    f = MMCapsMidPid_MM_MOTOROLA(achMid, uPid, achPid);
	    break;

	case MM_CANOPUS:
	    f = MMCapsMidPid_MM_CANOPUS(achMid, uPid, achPid);
	    break;

	default:
	    lstrcpy(achMid, szUnknown);
	    break;
    }

    //
    //
    //
    if (NULL != pszMid)
    {
	wsprintf(pszMid, szFormatId, uMid, (LPTSTR)achMid);
    }

    if (NULL != pszPid)
    {
	if (f)
	    wsprintf(pszPid, szFormatId, uPid, (LPTSTR)achPid);
	else
	    wsprintf(pszPid, szFormatId, uPid, (LPTSTR)szUnknown);
    }


    //
    //
    //
    return (f);
} // MMCapsMidAndPid()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mmcaps2k\mmcaps.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1997 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  mmcaps.c
//
//  Description:
//
//
//  History:
//      11/ 8/92
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <commdlg.h>
#include <stdarg.h>

#include "appport.h"
#include "mmcaps.h"

#include "debug.h"


//
//  globals, no less
//
HINSTANCE   ghinst;
TCHAR       gszAppSection[]     = TEXT("MMCaps");
TCHAR       gszNull[]           = TEXT("");

TCHAR       gszAppName[APP_MAX_APP_NAME_CHARS];


//
//
//
PZYZTABBEDLISTBOX   gptlbDrivers;

TCHAR       gszUnknown[]        = TEXT("Unknown");
TCHAR       gszNotSpecified[]   = TEXT("Not Specified");

UINT        guDriverType        = MMCAPS_DRIVERTYPE_LOWLEVEL;



//==========================================================================;
//
//  Application helper functions
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL AppProfileWriteBytes
//  
//  Description:
//      This function writes a raw structure of bytes to the application's
//      ini section that can later be retrieved using AppProfileReadBytes.
//      This gives an application the ability to write any structure to
//      the ini file and restore it later--very useful.
//
//      NOTE! Starting with Windows for Workgroups 3.1 there are two new
//      profile functions that provide the same functionality of this
//      function. Specifically, these functions are GetPrivateProfileStruct
//      and WritePrivateProfileStruct. These new functions are provided
//      by the Common Controls DLL. The prototypes are as follows:
//
//      BOOL GetPrivateProfileStruct
//      (
//          LPSTR       szSection,
//          LPSTR       szKey,
//          LPBYTE      lpStruct,
//          UINT        uSizeStruct,
//          LPSTR       szFile
//      );
//
//      BOOL WritePrivateProfileStruct
//      (
//          LPSTR       szSection,
//          LPSTR       szKey,
//          LPBYTE      lpStruct,
//          UINT        uSizeStruct,
//          LPSTR       szFile
//      );
//
//      If you are building an application that is for Window for Workgroups
//      or newer versions of Windows, you will probably want to use the
//      above functions.
//
//  Arguments:
//      PCTSTR pszKey: Pointer to key name for the stored data.
//  
//      LPBYTE pbStruct: Pointer to the data to be saved.
//  
//      UINT cbStruct: Count in bytes of the data to store.
//  
//  Return (BOOL):
//      The return value is TRUE if the function is successful. It is FALSE
//      if it fails.
//  
//  History:
//       3/10/93
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AppProfileWriteBytes
(
    PCTSTR          pszKey,
    LPBYTE          pbStruct,
    UINT            cbStruct
)
{
    static TCHAR achNibbleToChar[] =
    {
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'A', 'B', 'C', 'D', 'E', 'F',
    };
    #define     NIBBLE2CHAR(x)      (achNibbleToChar[x])
    
    TCHAR       ach[APP_MAX_STRING_RC_CHARS];
    LPTSTR      psz;
    LPTSTR      pch;
    UINT        cchTemp;
    BOOL        fAllocated;
    BOOL        fReturn;
    BYTE        b;
    BYTE        bChecksum;

    //
    //  if pbStruct is NULL, then erase the key from the ini file, otherwise
    //  format the raw bytes into a hex string and write that out...
    //
    fAllocated = FALSE;
    psz        = NULL;
    if (NULL != pbStruct)
    {
	//
	//  check if the quick buffer can be used for formatting the output
	//  text--if it cannot, then alloc space for it. note that space
	//  must be available for an ending checksum byte (2 bytes for high
	//  and low nibble) as well as a null terminator.
	//
	psz     = (LPTSTR)ach;
	cchTemp = cbStruct * 2 + 3;
	if (cchTemp > SIZEOF(ach))
	{
	    psz = GlobalAllocPtr(GHND, cchTemp * sizeof(TCHAR));
	    if (NULL == psz)
		return (FALSE);

	    fAllocated = TRUE;
	}
  
	//
	//  step through all bytes in the structure and convert it to
	//  a string of hex numbers...
	//
	bChecksum = 0;
	for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++)
	{
	    //
	    //  grab the next byte and add into checksum...
	    //
	    bChecksum += (b = *pbStruct);
      
	    *pch++ = NIBBLE2CHAR((b >> (BYTE)4) & (BYTE)0x0F);
	    *pch++ = NIBBLE2CHAR(b & (BYTE)0x0F);
	}

	//
	//  add the checksum byte to the end and null terminate the hex
	//  dumped string...
	//
	*pch++ = NIBBLE2CHAR((bChecksum >> (BYTE)4) & (BYTE)0x0F);
	*pch++ = NIBBLE2CHAR(bChecksum & (BYTE)0x0F);
	*pch   = '\0';
    }

    //
    //  write the string of hex bytes out to the ini file...
    //
    fReturn = WriteProfileString(gszAppSection, pszKey, psz);

    //
    //  free the temporary buffer if one was allocated (lots of bytes!)
    //
    if (fAllocated)
	GlobalFreePtr(psz);
  
    return (fReturn);
} // AppProfileWriteBytes


//--------------------------------------------------------------------------;
//  
//  BOOL AppProfileReadBytes
//  
//  Description:
//      This function reads a previously stored structure of bytes from
//      the application's ini file. This data must have been written with
//      the AppProfileWriteBytes function--it is checksumed to keep bad
//      data from blowing up the application.
//  
//      NOTE! Starting with Windows for Workgroups 3.1 there are two new
//      profile functions that provide the same functionality of this
//      function. Specifically, these functions are GetPrivateProfileStruct
//      and WritePrivateProfileStruct. These new functions are provided
//      by the Common Controls DLL. The prototypes are as follows:
//
//      BOOL GetPrivateProfileStruct
//      (
//          LPSTR       szSection,
//          LPSTR       szKey,
//          LPBYTE      lpStruct,
//          UINT        uSizeStruct,
//          LPSTR       szFile
//      );
//
//      BOOL WritePrivateProfileStruct
//      (
//          LPSTR       szSection,
//          LPSTR       szKey,
//          LPBYTE      lpStruct,
//          UINT        uSizeStruct,
//          LPSTR       szFile
//      );
//
//      If you are building an application that is for Window for Workgroups
//      or newer versions of Windows, you will probably want to use the
//      above functions.
//  
//  Arguments:
//      PCTSTR pszKey: Pointer to key that contains the data.
//  
//      LPBYTE pbStruct: Pointer to buffer to receive the data.
//  
//      UINT cbStruct: Number of bytes expected.
//  
//  Return (BOOL):
//      The return value is TRUE if the function is successful. It is FALSE
//      if the function fails (bad checksum, missing key, etc).
//  
//  History:
//       3/10/93
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL AppProfileReadBytes
(
    PCTSTR          pszKey,
    LPBYTE          pbStruct,
    UINT            cbStruct
)
{
    //
    //  note that the following works for both upper and lower case, and
    //  will return valid values for garbage chars
    //
    #define CHAR2NIBBLE(ch) (BYTE)( ((ch) >= '0' && (ch) <= '9') ?  \
				(BYTE)((ch) - '0') :                \
				((BYTE)(10 + (ch) - 'A') & (BYTE)0x0F) )

    TCHAR       ach[APP_MAX_STRING_RC_CHARS];
    LPTSTR      psz;
    LPTSTR      pch;
    UINT        cchTemp;
    UINT        u;
    BOOL        fAllocated;
    BOOL        fReturn;
    BYTE        b;
    BYTE        bChecksum;
    TCHAR       ch;

    //
    //  add one the the number of bytes needed to accomodate the checksum
    //  byte placed at the end by AppProfileWriteBytes...
    //
    cbStruct++;

    //
    //  check if the quick buffer can be used for retrieving the input
    //  text--if it cannot, then alloc space for it. note that there must
    //  be space available for the null terminator (the +1 below).
    //
    fAllocated = FALSE;
    psz        = (LPTSTR)ach;
    cchTemp    = cbStruct * 2 + 1;
    if (cchTemp > SIZEOF(ach))
    {
	psz = GlobalAllocPtr(GHND, cchTemp * sizeof(TCHAR));
	if (NULL == psz)
	    return (FALSE);

	fAllocated = TRUE;
    }

    //
    //  read the hex string... if it is not the correct length, then assume
    //  error and return.
    //
    fReturn = FALSE;
    u = (UINT)GetProfileString(gszAppSection, pszKey, gszNull, psz, cchTemp);
    if ((cbStruct * 2) == u)
    {
	bChecksum = 0;
	for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++)
	{
	    ch = *pch++;
	    b  = CHAR2NIBBLE(ch) << (BYTE)4;
	    ch = *pch++;
	    b |= CHAR2NIBBLE(ch);

	    //
	    //  if this is not the final byte (the checksum byte), then 
	    //  store it and accumulate checksum..
	    //
	    if (cbStruct != 1)
		bChecksum += (*pbStruct = b);
	}

	//
	//  check the last byte read against the checksum that we calculated
	//  if they are not equal then return error...
	//
	fReturn = (bChecksum == b);
    }


    //
    //  free the temporary buffer if one was allocated (lots of bytes!)
    //
    if (fAllocated)
	GlobalFreePtr(psz);
  
    return (fReturn);
} // AppProfileReadBytes


//--------------------------------------------------------------------------;
//
//  int AppMsgBox
//
//  Description:
//      This function displays a message for the application in a standard
//      message box.
//
//      Note that this function takes any valid argument list that can
//      be passed to wsprintf. Because of this, the application must
//      remember to cast near string pointers to FAR when built for Win 16.
//      You will get a nice GP fault if you do not cast them correctly.
//
//  Arguments:
//      HWND hwnd: Handle to parent window for message box holding the
//      message.
//
//      UINT fuStyle: Style flags for MessageBox().
//
//      PCTSTR pszFormat: Format string used for wvsprintf().
//
//  Return (int):
//      The return value is the result of MessageBox() function.
//
//  History:
//       2/13/93
//
//--------------------------------------------------------------------------;

int FNCGLOBAL AppMsgBox
(
    HWND            hwnd,
    UINT            fuStyle,
    PCTSTR          pszFormat,
    ...
)
{
    va_list     va;
    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS];
    int         n;

    //
    //  format and display the message..
    //
    va_start(va, pszFormat);
    wvsprintf(ach, pszFormat, va);
    va_end(va);

    n = MessageBox(hwnd, ach, gszAppName, fuStyle);

    return (n);
} // AppMsgBox()


//--------------------------------------------------------------------------;
//
//  int AppMsgBoxId
//
//  Description:
//      This function displays a message for the application. The message
//      text is retrieved from the string resource table using LoadString.
//
//      Note that this function takes any valid argument list that can
//      be passed to wsprintf. Because of this, the application must
//      remember to cast near string pointers to FAR when built for Win 16.
//      You will get a nice GP fault if you do not cast them correctly.
//
//  Arguments:
//      HWND hwnd: Handle to parent window for message box holding the
//      message.
//
//      UINT fuStyle: Style flags for MessageBox().
//
//      UINT uIdsFormat: String resource id to be loaded with LoadString()
//      and used a the format string for wvsprintf().
//
//  Return (int):
//      The return value is the result of MessageBox() if the string
//      resource specified by uIdsFormat is valid. The return value is zero
//      if the string resource failed to load.
//
//  History:
//       2/13/93
//
//--------------------------------------------------------------------------;

int FNCGLOBAL AppMsgBoxId
(
    HWND            hwnd,
    UINT            fuStyle,
    UINT            uIdsFormat,
    ...
)
{
    va_list     va;
    TCHAR       szFormat[APP_MAX_STRING_RC_CHARS];
    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS];
    int         n;

    n = LoadString(ghinst, uIdsFormat, szFormat, SIZEOF(szFormat));
    if (0 != n)
    {
	//
	//  format and display the message..
	//
	va_start(va, uIdsFormat);
	wvsprintf(ach, szFormat, va);
	va_end(va);

	n = MessageBox(hwnd, ach, gszAppName, fuStyle);
    }

    return (n);
} // AppMsgBoxId()


//--------------------------------------------------------------------------;
//
//  void AppHourGlass
//
//  Description:
//      This function changes the cursor to that of the hour glass or
//      back to the previous cursor.
//
//      This function can be called recursively.
//
//  Arguments:
//      BOOL fHourGlass: TRUE if we need the hour glass.  FALSE if we need
//      the arrow back.
//
//  Return (void):
//      On return, the cursor will be what was requested.
//
//  History:
//      11/ 8/92
//
//--------------------------------------------------------------------------;

void FNGLOBAL AppHourGlass
(
    BOOL            fHourGlass
)
{
    static HCURSOR  hcur;
    static UINT     uWaiting = 0;

    if (fHourGlass)
    {
	if (!uWaiting)
	{
	    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
	    ShowCursor(TRUE);
	}

	uWaiting++;
    }
    else
    {
	--uWaiting;

	if (!uWaiting)
	{
	    ShowCursor(FALSE);
	    SetCursor(hcur);
	}
    }
} // AppHourGlass()


//--------------------------------------------------------------------------;
//
//  int AppDialogBox
//
//  Description:
//      This function is used to display a dialog modal box.
//
//  Arguments:
//      HWND hwnd: Handle to parent window for new dialog.
//
//      LPCSTR pszDlg: Dialog template to use.
//
//      DLGPROC pfnDlg: Pointer to dialog procedure.
//
//      LPARAM lParam: Any lParam to be passed as lParam for WM_INITDIALOG.
//
//  Return (int):
//      The return value is the nResult from EndDialog.
//
//  History:
//      11/ 8/92
//
//--------------------------------------------------------------------------;

int FNGLOBAL AppDialogBox
(
    HWND            hwnd,
    LPCTSTR         pszDlg,
    DLGPROC         pfnDlg,
    LPARAM          lParam
)
{
    int     nResult;

    //
    //  !!! NT doesn't need this--neither does Win 3.1 with C7/C8 !!!
    //
    //
    nResult = 0;
    pfnDlg  = (DLGPROC)MakeProcInstance((FARPROC)pfnDlg, ghinst);
    if (NULL != pfnDlg)
    {
	nResult = DialogBoxParam(ghinst, pszDlg, hwnd, pfnDlg, lParam);
	FreeProcInstance((FARPROC)pfnDlg);
    }

    return (nResult);
} // AppDialogBox()


//--------------------------------------------------------------------------;
//
//  int AppSetWindowText
//
//  Description:
//      This function formats a string and sets the specified window text
//      to the result.
//
//  Arguments:
//      HWND hwnd: Handle to window to receive the new text.
//
//      PCTSTR pszFormat: Pointer to any valid format for wsprintf.
//
//  Return (int):
//      The return value is the number of bytes that the resulting window
//      text was.
//
//  History:
//       2/ 7/93
//
//--------------------------------------------------------------------------;

int FNCGLOBAL AppSetWindowText
(
    HWND            hwnd,
    PCTSTR          pszFormat,
    ...
)
{
    va_list     va;
    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS];
    int         n;

    //
    //  format and display the string in the window...
    //
    va_start(va, pszFormat);
    n = wvsprintf(ach, pszFormat, va);
    va_end(va);

    SetWindowText(hwnd, ach);

    return (n);
} // AppSetWindowText()


//--------------------------------------------------------------------------;
//
//  int AppSetWindowTextId
//
//  Description:
//      This function formats a string and sets the specified window text
//      to the result. The format string is extracted from the string
//      table using LoadString() on the uIdsFormat argument.
//
//  Arguments:
//      HWND hwnd: Handle to window to receive the new text.
//
//      UINT uIdsFormat: String resource id to be loaded with LoadString()
//      and used a the format string for wvsprintf().
//
//  Return (int):
//      The return value is the number of bytes that the resulting window
//      text was. This value is zero if the LoadString() function fails
//      for the uIdsFormat argument.
//
//  History:
//       2/ 7/93
//
//--------------------------------------------------------------------------;

int FNCGLOBAL AppSetWindowTextId
(
    HWND            hwnd,
    UINT            uIdsFormat,
    ...
)
{
    va_list     va;
    TCHAR       szFormat[APP_MAX_STRING_RC_CHARS];
    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS];
    int         n;

    n = LoadString(ghinst, uIdsFormat, szFormat, SIZEOF(szFormat));
    if (0 != n)
    {
	//
	//  format and display the string in the window...
	//
	va_start(va, uIdsFormat);
	n = wvsprintf(ach, szFormat, va);
	va_end(va);

	SetWindowText(hwnd, ach);
    }

    return (n);
} // AppSetWindowTextId()


//--------------------------------------------------------------------------;
//  
//  int AppMEditPrintF
//  
//  Description:
//      This function is used to print formatted text into a Multiline
//      Edit Control as if it were a standard console display. This is
//      a very easy way to display small amounts of text information
//      that can be scrolled and copied to the clip-board.
//  
//  Arguments:
//      HWND hedit: Handle to a Multiline Edit control.
//  
//      PCTSTR pszFormat: Pointer to any valid format for wsprintf. If
//      this argument is NULL, then the Multiline Edit Control is cleared
//      of all text.
//  
//  Return (int):
//      Returns the number of characters written into the edit control.
//
//  History:
//      05/16/93
//  
//--------------------------------------------------------------------------;

int FNCGLOBAL AppMEditPrintF
(
    HWND            hedit,
    PCTSTR          pszFormat,
    ...
)
{
    va_list     va;
    TCHAR       ach[APP_MAX_STRING_RC_CHARS];
    int         n;


    //
    //  if the pszFormat argument is NULL, then just clear all text in
    //  the edit control..
    //
    if (NULL == pszFormat)
    {
	SetWindowText(hedit, gszNull);
	return (0);
    }


    //
    //  format and display the string in the window...
    //
    va_start(va, pszFormat);
    n = wvsprintf(ach, pszFormat, va);
    va_end(va);

    Edit_SetSel(hedit, (WPARAM)-1, (LPARAM)-1);
    Edit_ReplaceSel(hedit, ach);

    return (n);
} // AppMEditPrintF()


//--------------------------------------------------------------------------;
//
//  DWORD AppGetWindowsVersion
//
//  Description:
//      This function returns the version of Windows that the application
//      is running on plus some platform information.
//
//  Arguments:
//      PTSTR pach: Options pointer to buffer to receive text string of
//      the Windows version and platform.
//
//  Return (LRESULT):
//      The return value will be the version and platform information of
//      the current operating system in the following format:
//
//      0xPPPPMMRR where:
//
//      MM      :   major version of Windows
//      RR      :   minor version (revision) of Windows
//      PPPP    :   the platform the application is running on which
//                  will be one of the following:
//
//                  #ifdef WIN32
//                      the HIWORD() is RESERVED except for the high bit:
//                          high bit is 0 = Windows NT
//                          high bit is 1 = Win32s/Windows 3.1
//                  #else
//                      0xMMRR = Major and Minor version of [MS-]DOS
//                      GetWinFlags() & 0x8000 = Windows on OS/2 (WLO)
//                      GetWinFlags() & 0x4000 = Windows on Windows NT (WOW)
//                  #endif
//
//  History:
//       2/13/93
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AppGetWindowsVersion
(
    PTSTR           pszEnvironment,
    PTSTR           pszPlatform
)
{

    BYTE    bVerWinMajor;
    BYTE    bVerWinMinor;
    UINT    uVerEnv;
    DWORD   dw;
    LRESULT lr;

    dw = GetVersion();

    //
    //  massage the version information into something intelligent
    //
    //
    bVerWinMajor = LOBYTE(LOWORD(dw));
    bVerWinMinor = HIBYTE(LOWORD(dw));
    uVerEnv      = HIWORD(dw);
    lr = MAKELPARAM(((UINT)bVerWinMajor << 8) | bVerWinMinor, uVerEnv);

    //
    //  if caller wants the environment string version...
    //
    if (NULL != pszEnvironment)
    {
    //
    //
    //
#ifdef WIN32
{
    static TCHAR    szFormatVersion[]   = TEXT("%s Version %u.%.2u");
    static TCHAR    szEnvWinNT[]        = TEXT("Windows NT");
    static TCHAR    szEnvWin32s[]       = TEXT("Win32s");

    wsprintf(pszEnvironment, szFormatVersion,
	     (LPSTR)((0x8000 & uVerEnv) ? szEnvWin32s : szEnvWinNT),
	     bVerWinMajor, bVerWinMinor);
}
#else
{
#ifndef WF_WINNT
    #define WF_CPUR4000         0x0100
    #define WF_CPUALPHA21064    0x0200
    #define WF_WINNT            0x4000
    #define WF_WLO              0x8000
#endif

    static TCHAR    szFormatSubSys[]= TEXT("Windows Version %u.%.2u (%s%s)\n%s Subsystem, DOS Version %u.%.2u");
    static TCHAR    szFormatDOS[]   = TEXT("Windows Version %u.%.2u (%s%s)\nDOS Version %u.%.2u");
    static TCHAR    szSubSysWLO[]   = TEXT("WLO");
    static TCHAR    szSubSysWOW[]   = TEXT("WOW");
    static TCHAR    szModeEnhanced[]= TEXT("Enhanced");
    static TCHAR    szModeStandard[]= TEXT("Standard");
    static TCHAR    szEnvPaging[]   = TEXT(", Paging");

    DWORD   dwWinFlags;
    PTSTR   pszMode;

    BYTE    bVerEnvMajor    = HIBYTE(LOWORD(uVerEnv));
    BYTE    bVerEnvMinor    = LOBYTE(LOWORD(uVerEnv));

    dwWinFlags = GetWinFlags();

    pszMode = (dwWinFlags & WF_ENHANCED) ? szModeEnhanced : szModeStandard;
    if (dwWinFlags & (WF_WLO | WF_WINNT))
    {
	wsprintf(pszEnvironment, szFormatSubSys, bVerWinMajor, bVerWinMinor,
		 (LPSTR)pszMode,
		 (LPSTR)((dwWinFlags & WF_PAGING) ? szEnvPaging : gszNull),
		 (LPSTR)((dwWinFlags & WF_WINNT) ? szSubSysWOW : szSubSysWLO),
		 bVerEnvMajor, bVerEnvMinor);
    }
    else
    {
	wsprintf(pszEnvironment, szFormatDOS, bVerWinMajor, bVerWinMinor,
		 (LPSTR)pszMode,
		 (LPSTR)((dwWinFlags & WF_PAGING) ? szEnvPaging : gszNull),
		 bVerEnvMajor, bVerEnvMinor);
    }
}
#endif
    }

    //
    //  if caller wants the platform string version...
    //
    if (NULL != pszPlatform)
    {
#ifdef WIN32
{
    static TCHAR    szFormatPlatform[]  = TEXT("%s%u, %u Processor(s)");
    static TCHAR    szProcessorIntel[]  = TEXT("Intel ");
    static TCHAR    szProcessorMIPS[]   = TEXT("MIPS R");
    static TCHAR    szProcessorAlpha[]  = TEXT("DEC Alpha ");
    static TCHAR    szProcessorDunno[]  = TEXT("Dunno zYz");

    SYSTEM_INFO sysinfo;
    PTSTR       pszProcessor;

    //
    //  this is absolutely silly. one would think that the dwOemId member
    //  would provide something useful like the processor class... but
    //  no, it doesn't--it is always 0.
    //
    GetSystemInfo(&sysinfo);
    switch (sysinfo.dwProcessorType)
    {
	case PROCESSOR_INTEL_386:
	case PROCESSOR_INTEL_486:
	    pszProcessor = szProcessorIntel;
	    break;

	case PROCESSOR_MIPS_R4000:
	    pszProcessor = szProcessorMIPS;
	    break;

	case PROCESSOR_ALPHA_21064:
	    pszProcessor = szProcessorAlpha;
	    break;

	default:
	    pszProcessor = szProcessorDunno;
	    break;
    }

    //
    //
    //
    wsprintf(pszPlatform, szFormatPlatform, (LPSTR)pszProcessor,
	     sysinfo.dwProcessorType, sysinfo.dwNumberOfProcessors);
}
#else
{
    static TCHAR    szPlat286[]         = TEXT("80286");
    static TCHAR    szPlat386[]         = TEXT("80386");
    static TCHAR    szPlat486[]         = TEXT("i486");
    static TCHAR    szPlatR4000[]       = TEXT("MIPS R4000, Emulation: ");
    static TCHAR    szPlatAlpha21064[]  = TEXT("Alpha 21064, Emulation: ");
    static TCHAR    szPlat80x87[]       = TEXT(", 80x87");

    DWORD   dwWinFlags;

    dwWinFlags = GetWinFlags();
    pszPlatform[0] = '\0';

    if (dwWinFlags & (WF_WLO | WF_WINNT))
    {
	if (dwWinFlags & WF_CPUR4000)
	    lstrcpy(pszPlatform, szPlatR4000);
	else if (dwWinFlags & WF_CPUALPHA21064)
	    lstrcpy(pszPlatform, szPlatAlpha21064);
    }

    if (dwWinFlags & WF_CPU286)
	lstrcat(pszPlatform, szPlat286);
    else if (dwWinFlags & WF_CPU386)
	lstrcat(pszPlatform, szPlat386);
    else if (dwWinFlags & WF_CPU486)
	lstrcat(pszPlatform, szPlat486);

    if (dwWinFlags & WF_80x87)
	lstrcat(pszPlatform, szPlat80x87);
}
#endif
    }

    //
    //  return the result
    //
    return (lr);
} // AppGetWindowsVersion()


//--------------------------------------------------------------------------;
//
//  HFONT AppChooseFont
//
//  Description:
//      This function is a wrapper for the ChooseFont() common dialog.
//      The purpose of this function is to let the user choose a font that
//      looks good to them--regardless of how stupid it really looks.
//
//  Arguments:
//      HWND hwnd: Handle to parent window for chooser dialog.
//
//      HFONT hfont: Handle to current font (default for chooser dialog).
//
//      PLOGFONT plf: Pointer to optional LOGFONT structure to receive a
//      copy of the LOGFONT information for the newly chosen font.
//
//  Return (HFONT):
//      The return value is the newly chosen font. If no new font was chosen
//      then the return value is NULL.
//
//  History:
//       2/ 7/93
//
//--------------------------------------------------------------------------;

HFONT FNGLOBAL AppChooseFont
(
    HWND            hwnd,
    HFONT           hfont,
    PLOGFONT        plf
)
{
    LOGFONT     lf;
    CHOOSEFONT  cf;
    BOOL        f;
    HFONT       hfontNew;

    //
    //  get the font info for the current font...
    //
    GetObject(hfont, sizeof(LOGFONT), (LPVOID)&lf);

    //
    //  fill in the choosefont structure
    //
    cf.lStructSize  = sizeof(CHOOSEFONT);
    cf.hwndOwner    = hwnd;
    cf.hDC          = NULL;
    cf.Flags        = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT;
    cf.lCustData    = 0;
    cf.lpfnHook     = NULL;
    cf.hInstance    = NULL;
    cf.nFontType    = SCREEN_FONTTYPE;
    cf.lpLogFont    = (LPLOGFONT)&lf;

    //
    //  splash a dialog into the user's face..
    //
    hfontNew = NULL;
    f = ChooseFont(&cf);
    if (f)
    {
	//
	//  create the new font..
	//
	hfontNew = CreateFontIndirect(&lf);
	if (NULL == hfontNew)
	    return (NULL);

	//
	//  copy the logfont structure if caller wants it
	//
	if (NULL != plf)
	    *plf = lf;
    }

    //
    //  return the new font (if one was chosen)
    //
    return (hfontNew);
} // AppChooseFont()


//==========================================================================;
//
//  Misc rarely used application dialogs and stuff...
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL AboutDlgProc
//
//  Description:
//      This dialog procedure is used for the ubiquitous about box.
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (BOOL):
//      The return value is specific to the message that was received. For
//      the most part, it is FALSE if this dialog procedure does not handle
//      a message.
//
//  History:
//       1/ 2/93
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT AboutDlgProc
(
    HWND            hwnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    HWND    hwndT;
    PTSTR   pach;
    UINT    u;

    switch (uMsg)
    {
	case WM_INITDIALOG:
	    //
	    //  display some OS version information
	    //
	    //
	    pach = (PTSTR)LocalAlloc(LPTR, APP_MAX_STRING_RC_BYTES);
	    if (NULL == pach)
		return (TRUE);

	    AppGetWindowsVersion(pach, NULL);
	    hwndT = GetDlgItem(hwnd, IDD_ABOUT_VERSION_OS);
	    SetWindowText(hwndT, pach);

	    AppGetWindowsVersion(NULL, pach);
	    hwndT = GetDlgItem(hwnd, IDD_ABOUT_VERSION_PLATFORM);
	    SetWindowText(hwndT, pach);

	    wsprintf(pach, "MMREG.H V%u.%.02u",
		     (_INC_MMREG / 100), (_INC_MMREG % 100));
	    hwndT = GetDlgItem(hwnd, IDD_ABOUT_VERSION_MMSYSTEM);
	    SetWindowText(hwndT, pach);

	    LocalFree((HLOCAL)pach);

	    //
	    //  return nonzero to set the input focus to the control
	    //  identified by the (hwndFocus = (HWND)wParam) argument.
	    //  a zero return tells the dialog manager that this function
	    //  has set the focus using SetFocus.
	    //
	    return (TRUE);

	case WM_COMMAND:
	    u = GET_WM_COMMAND_ID(wParam, lParam);
	    if ((IDOK == u) || (IDCANCEL == u))
	    {
		EndDialog(hwnd, (IDOK == u));
	    }
	    break;
    }

    return (FALSE);
} // AboutDlgProc()


//==========================================================================;
//
//  Initialization and exit code...
//
//
//==========================================================================;

TCHAR   gszKeyWindow[]      = TEXT("Window");
TCHAR   gszKeyFont[]        = TEXT("Font");

//--------------------------------------------------------------------------;
//
//  BOOL MMCapsChooseFont
//
//  Description:
//      This function lets the user choose a new font for the script window.
//      After a new font is chosen, the font structure is stored to the
//      .ini file so it can be restored on the next run of this application.
//
//  Arguments:
//      HWND hwnd: Handle to main window.
//
//  Return (BOOL):
//      The return value is TRUE if a new font was chosen. It is FALSE if
//      the user canceled the operation.
//
//  History:
//       2/ 7/93
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL MMCapsChooseFont
(
    HWND            hwnd
)
{
    LOGFONT     lf;
    HWND        hlb;
    HFONT       hfont;
    HFONT       hfontNew;

    hlb = GetDlgItem(hwnd, IDD_APP_LIST_DEVICES);

    //
    //  get the current font and pass it to the choose font dialog
    //
    hfont = GetWindowFont(gptlbDrivers->hlb);

    hfontNew = AppChooseFont(hwnd, hfont, &lf);
    if (NULL == hfontNew)
	return (FALSE);

    //
    //  select the new font into the script window and delete the old one
    //
    TlbSetFont(gptlbDrivers, hfontNew, TRUE);
    DeleteFont(hfont);


    //
    //  save the complete description of the chosen font so there can be
    //  no strangness in the font mapping next run. this is overkill, but
    //  it works...
    //
    AppProfileWriteBytes(gszKeyFont, (LPBYTE)&lf, sizeof(lf));

    return (TRUE);
} // MMCapsChooseFont()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsSettingsRestore
//  
//  Description:
//      This function restores state information for the application. This
//      function is called just after the main window is created (it has
//      not been ShowWindow()'d). This function will generate the call
//      to ShowWindow before returning.
//
//  Arguments:
//      HWND hwnd: Handle to main window that has just been created but
//      not shown.
//
//      int nCmdShow: The state that the application window should show as.
//
//  Return (BOOL):
//      The return value is always TRUE.
//  
//  History:
//      05/11/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsSettingsRestore
(
    HWND            hwnd,
    int             nCmdShow
)
{
    WINDOWPLACEMENT wp;
    PRECT           prc;
    HFONT           hfont;
    LOGFONT         lf;
    RECT            rc;
    POINT           pt;
    int             n;
    BOOL            f;



    //
    //  restore the user's preferred font.
    //
    hfont = NULL;
    f = AppProfileReadBytes(gszKeyFont, (LPBYTE)&lf, sizeof(lf));
    if (f)
    {
	hfont = CreateFontIndirect(&lf);
    }

    if (NULL == hfont)
    {
	hfont = GetStockFont(ANSI_VAR_FONT);
    }

    TlbSetFont(gptlbDrivers, hfont, TRUE);


    //
    //  grab the stored window position and size from the .ini file...
    //  there must be four arguments stored or the entry is considered
    //  invalid.
    //
    prc = &wp.rcNormalPosition;
    f = AppProfileReadBytes(gszKeyWindow, (LPBYTE)prc, sizeof(*prc));
    if (f)
    {
	//
	//  to make sure the user can always get at the window, check to
	//  see if the midpoint of the caption is visible--if it is not,
	//  then default to the default position used when creating the
	//  window.
	//
	n = (prc->right - prc->left) / 2;
	pt.x = (n + prc->left);

	n = GetSystemMetrics(SM_CYCAPTION) / 2 + GetSystemMetrics(SM_CXFRAME);
	pt.y = (n + prc->top);

	GetWindowRect(GetDesktopWindow(), &rc);
	if (PtInRect(&rc, pt))
	{
	    //
	    //  fill out the window placement structure--default the
	    //  maximized and minimized states to default placement by
	    //  getting its current placement.
	    //
	    wp.length = sizeof(wp);
	    GetWindowPlacement(hwnd, &wp);

	    wp.flags           = 0;
	    wp.showCmd         = nCmdShow;

	    SetWindowPlacement(hwnd, &wp);
	    return (TRUE);
	}
    }

    //
    //  show defaulted and succeed
    //
    ShowWindow(hwnd, nCmdShow);
    return (TRUE);
} // MMCapsSettingsRestore()


//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsSettingsSave
//  
//  Description:
//      This function saves the current state information for the application.
//      It is called just before the main window is closed (destroyed); or
//      as Windows is exiting (query end session).
//
//      Note that this function should not destroy any resources--it can
//      be called at any time to save a snapshot of the application state.
//
//  Arguments:
//      HWND hwnd: Handle to main window that will be destroyed shortly.
//
//  Return (BOOL):
//      The return value is always TRUE.
//  
//  History:
//      05/11/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsSettingsSave
(
    HWND            hwnd
)
{
    WINDOWPLACEMENT wp;
    PRECT           prc;
    BOOL            f;

    //
    //  save the current window placement--only store the size and location
    //  of the restored window. maximized and minimized states should
    //  remain defaulted on the next invocation of this application.
    //
    wp.length = sizeof(wp);
    f = GetWindowPlacement(hwnd, &wp);
    if (f)
    {
	prc = &wp.rcNormalPosition;

	DPF(0, "WindowPlacement: show=%d, minX=%d, minY=%d, maxX=%d, maxY=%d",
	     wp.showCmd, wp.ptMinPosition.x, wp.ptMinPosition.y,
	     wp.ptMaxPosition.x, wp.ptMaxPosition.y);

	DPF(0, "                 normX=%d, normY=%d, normW=%d, normH=%d",
	     prc->left, prc->top, prc->right, prc->bottom);

	//
	//  save the _bounding rectangle_ of the restored window state...
	//
	AppProfileWriteBytes(gszKeyWindow, (LPBYTE)prc, sizeof(*prc));
    }


    //
    //  succeed
    //
    return (TRUE);
} // MMCapsSettingsSave()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL MMCapsDlgProc
//
//  Description:
//      This dialog procedure is used to display driver capabilities.
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (BOOL):
//      The return value is specific to the message that was received. For
//      the most part, it is FALSE if this dialog procedure does not handle
//      a message.
//
//  History:
//       1/ 2/93
//
//--------------------------------------------------------------------------;

BOOL FNEXPORT MMCapsDlgProc
(
    HWND            hwnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    HWND        hedit;
    UINT        u;

    switch (uMsg)
    {
	case WM_INITDIALOG:
	    hedit = GetDlgItem(hwnd, IDD_DEVCAPS_EDIT_DETAILS);
	    SetWindowFont(hedit, GetStockFont(ANSI_FIXED_FONT), FALSE);

	    //
	    //
	    //
	    switch (guDriverType)
	    {
		case MMCAPS_DRIVERTYPE_LOWLEVEL:
		    MMCapsDetailLowLevel(hedit, lParam);
		    break;

#if 0
		case MMCAPS_DRIVERTYPE_MCI:
		    MMCapsDetailMCI(hedit, lParam);
		    break;

		case MMCAPS_DRIVERTYPE_ACM:
		    MMCapsDetailACM(hedit, lParam);
		    break;

		case MMCAPS_DRIVERTYPE_VIDEO:
		    MMCapsDetailVideo(hedit, lParam);
		    break;
#endif
	    }

	    //
	    //  return nonzero to set the input focus to the control
	    //  identified by the (hwndFocus = (HWND)wParam) argument.
	    //  a zero return tells the dialog manager that this function
	    //  has set the focus using SetFocus.
	    //
	    return (TRUE);

	case WM_COMMAND:
	    u = GET_WM_COMMAND_ID(wParam, lParam);
	    if ((IDOK == u) || (IDCANCEL == u))
	    {
		EndDialog(hwnd, (IDOK == u));
	    }
	    
	    break;
    }

    return (FALSE);
} // MMCapsDlgProc()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL MMCapsRefreshDriverList
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd: Handle of main window.
//  
//  Return (BOOL):
//  
//  History:
//      05/16/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsRefreshDriverList
(
    PZYZTABBEDLISTBOX   ptlb
)
{
    static UINT     uIdPrev = (UINT)-1;

    BOOL        fComplete;

    //
    //
    //
    SetWindowRedraw(ptlb->hlb, FALSE);
    ListBox_ResetContent(ptlb->hlb);


    //
    //  only force complete update if the driver type is different from
    //  previous...
    //
    fComplete = (guDriverType != uIdPrev);
    uIdPrev = guDriverType;

    //
    //
    //
    switch (guDriverType)
    {
	case MMCAPS_DRIVERTYPE_LOWLEVEL:
	    MMCapsEnumerateLowLevel(ptlb, fComplete);
	    break;


#if 0
	case MMCAPS_DRIVERTYPE_MCI:
	    MMCapsEnumerateMCI(ptlb, fComplete);
	    break;

	case MMCAPS_DRIVERTYPE_ACM:
	    MMCapsEnumerateACM(ptlb, fComplete);
	    break;

	case MMCAPS_DRIVERTYPE_VIDEO:
	    MMCapsEnumerateVideo(ptlb, fComplete);
	    break;

	case MMCAPS_DRIVERTYPE_DRIVERS:
	    MMCapsEnumerateDrivers(ptlb, fComplete);
	    break;
#endif

    }

    //
    //
    //
    SetWindowRedraw(ptlb->hlb, TRUE);

    return (TRUE);
} // MMCapsRefreshDriverList()


//==========================================================================;
//
//  Main application window handling code...
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  LRESULT AppCreate
//
//  Description:
//      This function is called to handle the WM_CREATE message for the
//      application's window. The application should finish the creation
//      of the window (create controls, allocate resources, etc). The
//      window has not been displayed (CreateWindow[Ex] has not returned).
//
//  Arguments:
//      HWND hwnd: Handle to the window that is in the process of being
//      created.
//
//      LPCREATESTRUCT pcs: Pointer to a CREATESTRUCT that contains info
//      about the window being created.
//
//  Return (LRESULT):
//      The return value should be nonzero if the application wishes to
//      let the window finish being created. A return of zero tells
//      CreateWindow[Ex] to fail the creation of the window.
//
//  History:
//      11/ 8/92
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AppCreate
(
    HWND            hwnd,
    LPCREATESTRUCT  pcs
)
{
    DPF(0, "AppCreate(hwnd=%Xh, cs.x=%d, cs.y=%d, cs.cx=%d, cs.cy=%d)",
	    hwnd, pcs->x, pcs->y, pcs->cx, pcs->cy);

    //
    //  create the driver selection listbox
    //
    gptlbDrivers = TlbCreate(hwnd, IDD_APP_LIST_DEVICES, NULL);
    if (NULL == gptlbDrivers)
	return (0L);

    //
    //
    //
    MMCapsRefreshDriverList(gptlbDrivers);


    //
    //  we want the focus to default to the device listbox window
    //
    SetFocus(gptlbDrivers->hlb);


    //
    //  return nonzero to succeed the creation of the window
    //
    return (1L);
} // AppCreate()


//--------------------------------------------------------------------------;
//
//  LRESULT AppQueryEndSession
//
//  Description:
//      This function handles the WM_QUERYENDSESSION. This message is sent
//      by USER when ExitWindows has been called to end the Windows session.
//      This function can stop Windows from exiting if it is not convenient
//      for Windows to end.
//
//      Giving the user the option to save modified data before continueing
//      with the shutdown of Windows is a good idea.
//
//      Telling Windows to continue with the exit procedure does not
//      necessarily mean Windows will exit. All applications are queried
//      for shutdown approval. When the actual decision is made on whether
//      Windows will exit, WM_ENDSESSION will be sent with the result.
//
//  Arguments:
//      HWND hwnd: Handle to window that received the message.
//
//  Return (LRESULT):
//      Returns zero to STOP Windows from exiting. Returns non-zero to
//      allows windows to shut down.
//
//  History:
//       2/ 9/93
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AppQueryEndSession
(
    HWND            hwnd
)
{
    DPF(0, "AppQueryEndSession(hwnd=%Xh)", hwnd);

    //
    //  tell Windows to proceed with the shutdown process!
    //
    return (1L);
} // AppQueryEndSession()


//--------------------------------------------------------------------------;
//
//  LRESULT AppEndSession
//
//  Description:
//      This function is called to handle the WM_ENDSESSION message. This
//      message is generated after the application answers the
//      WM_QUERYENDSESSION message. The purpose of the WM_ENDSESSION
//      message is to tell the application if Windows will be exiting
//      (TRUE  == fEndSession) or the end session was canceled by an
//      application (FALSE == fEndSession).
//
//  Arguments:
//      HWND hwnd: Handle to window that received the message.
//
//      BOOL fEndSession: TRUE if Windows is exiting. FALSE if the end
//      session was canceled.
//
//  Return (LRESULT):
//      Returns zero if the message is processed. Note that an application
//      cannot halt the termination of Windows from this message--the
//      WM_QUERYENDSESSION is the only message that allows that behaviour.
//      If fEndSession is TRUE, Windows *WILL* exit--whether you like it
//      or not.
//
//  History:
//       2/ 9/93
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AppEndSession
(
    HWND            hwnd,
    BOOL            fEndSession
)
{
    DPF(0, "AppEndSession(hwnd=%Xh, fEndSession=%d)", hwnd, fEndSession);

    //
    //  we processed the message, return zero..
    //
    return (0L);
} // AppEndSession()


//--------------------------------------------------------------------------;
//
//  LRESULT AppClose
//
//  Description:
//      This function handles the WM_CLOSE message for the application.
//      If the application should close, DestroyWindow() must be called
//      by this function. Otherwise the application will not close.
//
//  Arguments:
//      HWND hwnd: Handle to window that generated the WM_CLOSE message.
//
//  Return (LRESULT):
//      There return value is zero. The DestroyWindow function will have
//      been called if the application should actually close.
//
//  History:
//       2/ 6/93
//
//--------------------------------------------------------------------------;

LRESULT FNGLOBAL AppClose
(
    HWND            hwnd
)
{
    HWND        hlb;
    HFONT       hfont;


    DPF(0, "AppClose(hwnd=%Xh)", hwnd);

    //
    //  save any settings that should be saved on app termination...
    //
    MMCapsSettingsSave(hwnd);


    //
    //  if the Shift key is held down during the close message, then just
    //  save the current state but don't destroy the window... this is
    //  useful if the user does not want to exit the app and rerun it
    //  to make sure the state is saved--just before the user does something
    //  that may crash Windows or something..
    //
    if (GetKeyState(VK_SHIFT) < 0)
    {
	return (0L);
    }


    //
    //  destroy the font we are using... before deleting the font, select
    //  the system font back into the script window so the font won't
    //  be 'in use' anymore.
    //
    hlb = GetDlgItem(hwnd, IDD_APP_LIST_DEVICES);

    hfont = GetWindowFont(hlb);
    SetWindowFont(hlb, NULL, FALSE);
    DeleteFont(hfont);

    //
    //  make the window close and terminate the application
    //
    DestroyWindow(hwnd);

    return (0L);
} // AppClose()


//--------------------------------------------------------------------------;
//
//  LRESULT AppInitMenuPopup
//
//  Description:
//      This function handles the WM_INITMENUPOPUP message. This message
//      is sent to the window owning the menu that is going to become
//      active. This gives an application the ability to modify the menu
//      before it is displayed (disable/add items, etc).
//
//  Arguments:
//      HWND hwnd: Handle to window that generated the WM_INITMENUPOPUP
//      message.
//
//      HMENU hmenu: Handle to the menu that is to become active.
//
//      int nItem: Specifies the zero-based relative position of the menu
//      item that invoked the popup menu.
//
//      BOOL fSysMenu: Specifies whether the popup menu is a System menu
//      (TRUE) or it is not a System menu (FALSE).
//
//  Return (LRESULT):
//      Returns zero if the message is processed.
//
//  History:
//       1/ 2/93
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL AppInitMenuPopup
(
    HWND            hwnd,
    HMENU           hmenu,
    int             nItem,
    BOOL            fSysMenu
)
{
    UINT        u;

    DPF(0, "AppInitMenuPopup(hwnd=%Xh, hmenu=%Xh, nItem=%d, fSysMenu=%d)",
	    hwnd, hmenu, nItem, fSysMenu);

    //
    //  if the system menu is what got hit, succeed immediately... this
    //  application has no stuff in the system menu.
    //
    if (fSysMenu)
	return (0L);

    //
    //  initialize the menu that is being 'popped up'
    //
    switch (nItem)
    {
	case APP_MENU_ITEM_FILE:
	    break;

	case APP_MENU_ITEM_DRIVERS:
	    for (u = IDM_DRIVERS_LOWLEVEL; u <= IDM_DRIVERS_DRIVERS; u++)
	    {
		UINT    uCheck;

		uCheck = (u == guDriverType) ? MF_CHECKED : MF_UNCHECKED;
		CheckMenuItem(hmenu, u, uCheck);
	    }
	    break;
    }

    //
    //  we processed the message--return 0...
    //
    return (0L);
} // AppInitMenuPopup()


//--------------------------------------------------------------------------;
//
//  LRESULT AppCommand
//
//  Description:
//      This function handles the WM_COMMAND message.
//
//  Arguments:
//      HWND hwnd: Handle to window receiving the WM_COMMAND message.
//
//      int nId: Control or menu item identifier.
//
//      HWND hwndCtl: Handle of control if the message is from a control.
//      This argument is NULL if the message was not generated by a control.
//
//      UINT uCode: Notification code. This argument is 1 if the message
//      was generated by an accelerator. If the message is from a menu,
//      this argument is 0.
//
//  Return (LRESULT):
//      Returns zero if the message is processed.
//
//  History:
//      11/ 8/92
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL AppCommand
(
    HWND            hwnd,
    int             nId,
    HWND            hwndCtl,
    UINT            uCode
)
{
    int         n;
    LRESULT     lr;

    switch (nId)
    {
	case IDM_FILE_FONT:
	    MMCapsChooseFont(hwnd);
	    break;

	case IDM_FILE_ABOUT:
	    AppDialogBox(hwnd, DLG_ABOUT, (DLGPROC)AboutDlgProc, 0L);
	    break;

	case IDM_FILE_EXIT:
	    FORWARD_WM_CLOSE(hwnd, SendMessage);
	    break;


	case IDM_DRIVERS_LOWLEVEL:
	case IDM_DRIVERS_MCI:
	case IDM_DRIVERS_ACM:
	case IDM_DRIVERS_VIDEO:
	case IDM_DRIVERS_DRIVERS:
	    if ((UINT)nId == guDriverType)
		break;

	    guDriverType = (UINT)nId;

	    // -- fall through -- //

	case IDM_UPDATE:
	    MMCapsRefreshDriverList(gptlbDrivers);
	    break;


	case IDD_APP_LIST_DEVICES:
	    switch (uCode)
	    {
		case LBN_SELCHANGE:
		    break;

		case LBN_DBLCLK:
		    n  = ListBox_GetCurSel(hwndCtl);
		    lr = ListBox_GetItemData(hwndCtl, n);
		    AppDialogBox(hwnd, DLG_DEVCAPS, (DLGPROC)MMCapsDlgProc, lr);
		    break;
	    }
	    break;
    }

    return (0L);
} // AppCommand()


//--------------------------------------------------------------------------;
//
//  LRESULT AppSize
//
//  Description:
//      This function handles the WM_SIZE message for the application's
//      window. This message is sent to the application window after the
//      size has changed (but before it is painted).
//
//  Arguments:
//      HWND hwnd: Handle to window that generated the WM_SIZE message.
//
//      UINT fuSizeType: Specifies the type of resizing requested. This
//      argument is one of the following: SIZE_MAXIMIZED, SIZE_MINIMIZED,
//      SIZE_RESTORED, SIZE_MAXHIDE, or SIZE_MAXSHOW.
//
//      int nWidth: Width of the new client area for the window.
//
//      int nHeight: Height of the new client area for the window.
//
//  Return (LRESULT):
//      Returns zero if the application processes the message.
//
//  History:
//       2/ 5/93
//
//--------------------------------------------------------------------------;

LRESULT FNLOCAL AppSize
(
    HWND            hwnd,
    UINT            fuSizeType,
    int             nWidth,
    int             nHeight
)
{
    RECT        rc;

    DPF(0, "AppSize(hwnd=%Xh, fuSizeType=%u, nWidth=%d, nHeight=%d)",
	    hwnd, fuSizeType, nWidth, nHeight);

    //
    //  unless this application is the one being resized then don't waste
    //  time computing stuff that doesn't matter. this applies to being
    //  minimized also because this application does not have a custom
    //  minimized state.
    //
    if ((SIZE_RESTORED != fuSizeType) && (SIZE_MAXIMIZED != fuSizeType))
	return (0L);


    //
    //  size the devices listbox to be the total size of the client area--
    //  inflate the rect by one so borders are not visible. note that 
    //  we need to leave room at the top for the title text which is one
    //  line of text in height...
    //
    GetClientRect(hwnd, &rc);
    InflateRect(&rc, 1, 1);


    TlbMove(gptlbDrivers, &rc, FALSE);


    //
    //  we processed the message..
    //
    return (0L);
} // AppSize()


//--------------------------------------------------------------------------;
//  
//  LRESULT AppPaint
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//  Return (LRESULT):
//  
//  History:
//      05/11/93
//  
//--------------------------------------------------------------------------;

LRESULT FNLOCAL AppPaint
(
    HWND            hwnd
)
{
    PAINTSTRUCT ps;

    //
    //
    //
    BeginPaint(hwnd, &ps);

    TlbPaint(gptlbDrivers, hwnd, ps.hdc);

    EndPaint(hwnd, &ps);

    //
    //  we processed the message
    //
    return (0L);
} // AppPaint()


//--------------------------------------------------------------------------;
//
//  LRESULT AppWndProc
//
//  Description:
//      This is the main application window procedure.
//
//  Arguments:
//      HWND hwnd: Handle to window.
//
//      UINT uMsg: Message being sent to the window.
//
//      WPARAM wParam: Specific argument to message.
//
//      LPARAM lParam: Specific argument to message.
//
//  Return (LRESULT):
//      The return value depends on the message that is being processed.
//
//  History:
//      11/ 8/92
//
//--------------------------------------------------------------------------;

LRESULT FNEXPORT AppWndProc
(
    HWND            hwnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    static UINT umsgWinmmDeviceChange = 0;
    LRESULT     lr;

    if (0 == umsgWinmmDeviceChange) {
	umsgWinmmDeviceChange = RegisterWindowMessage(TEXT("winmm_devicechange"));
    }
    if ((uMsg == umsgWinmmDeviceChange) && gptlbDrivers) MMCapsRefreshDriverList(gptlbDrivers);
    
    switch (uMsg)
    {
	case WM_CREATE:
	    lr = HANDLE_WM_CREATE(hwnd, wParam, lParam, AppCreate);
	    return (lr);

	case WM_INITMENUPOPUP:
	    HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, AppInitMenuPopup);
	    return (0L);

	case WM_COMMAND:
	    lr = HANDLE_WM_COMMAND(hwnd, wParam, lParam, AppCommand);
	    return (lr);

	case WM_SIZE:
	    //
	    //  handle what we want for sizing, and then always call the
	    //  default handler...
	    //
	    HANDLE_WM_SIZE(hwnd, wParam, lParam, AppSize);
	    break;

	case WM_PAINT:
	    HANDLE_WM_PAINT(hwnd, wParam, lParam, AppPaint);
	    break;

	case WM_QUERYENDSESSION:
	    lr = HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, AppQueryEndSession);
	    return (lr);

	case WM_ENDSESSION:
	    HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, AppEndSession);
	    return (0L);

	case WM_CLOSE:
	    HANDLE_WM_CLOSE(hwnd, wParam, lParam, AppClose);
	    return (0L);

	case WM_DESTROY:
	    PostQuitMessage(0);
	    return (0L);
    }

    return (DefWindowProc(hwnd, uMsg, wParam, lParam));
} // AppWndProc()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL AppInit
//
//  Description:
//      This function is called to initialize a new instance of the
//      application. We want to parse our command line, create our window,
//      allocate resources, etc.
//
//      The arguments passed to this function are exactly the same as
//      those passed to WinMain.
//
//  Arguments:
//      HINSTANCE hinst: Identifies the current instance of the
//      application.
//
//      HINSTANCE hinstPrev: Identifies the previous instance of the
//      application (NULL if first instance). For Win 32, this argument
//      is _always_ NULL.
//
//      LPTSTR pszCmdLine: Points to null-terminated unparsed command line.
//      If the application is compiled for Unicode, then this argument is
//      ignored.
//
//      int nCmdShow: How the main window for the application is to be
//      shown by default.
//
//  Return (HWND):
//      Returns the newly created handle to the applications main window.
//      This handle is NULL if something went wrong and tells the application
//      to exit immediately.
//
//  History:
//      11/ 8/92
//
//--------------------------------------------------------------------------;

HWND FNGLOBAL AppInit
(
    HINSTANCE       hinst,
    HINSTANCE       hinstPrev,
    LPTSTR          pszCmdLine,
    int             nCmdShow
)
{
    LRESULT FNEXPORT AppWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND        hwnd;
    WNDCLASS    wc;

    DPF(0, "AppInit(hinst=%Xh, hinstPrev=%Xh, pszCmdLine='%s', nCmdShow=%d)",
	    hinst, hinstPrev, pszCmdLine, nCmdShow);

    LoadString(hinst, IDS_APP_NAME, gszAppName, SIZEOF(gszAppName));


    //
    //  determine whether a new window class needs to be registered for
    //  this application. for Win 16, this only needs to be done for the
    //  first instance of the application created. for Win 32, this must
    //  be done for EVERY instance of the application.
    //
    if (NULL == hinstPrev)
    {
	wc.style         = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc   = (WNDPROC)AppWndProc;
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = 0;
	wc.hInstance     = hinst;
	wc.hIcon         = LoadIcon(hinst, ICON_APP);
	wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wc.lpszMenuName  = MENU_APP;
	wc.lpszClassName = gszAppName;

	if (!RegisterClass(&wc)) {
	    return (NULL);
	}
    }


    //
    //  create the application's main window
    //
    //  style bits available:
    //      WS_EX_ACCEPTFILES   :  will receive WM_DROPFILES messages
    //      WS_EX_DLGMODALFRAME :  creates window with double border
    //      WS_EX_NOPARENTNOTIFY:  won't receive WM_PARENTNOTIFY messages
    //      WS_EX_TOPMOST       :  puts window in topmost space
    //      WS_EX_TRANSPARENT   :  a very bizarre style indeed (Win 16 only)
    //
    hwnd = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
			  gszAppName,
			  gszAppName,
			  WS_OVERLAPPEDWINDOW,
			  APP_WINDOW_XOFFSET,
			  APP_WINDOW_YOFFSET,
			  APP_WINDOW_WIDTH,
			  APP_WINDOW_HEIGHT,
			  NULL,
			  NULL,
			  hinst,
			  NULL);

    if (NULL == hwnd)
	return (NULL);

#ifdef UNICODE
    //
    //  the application--which is different than the pszCmdLine argument
    //  passed through WinMain()...
    //
    //  so, skip over the command name to get to the argument string
    //
    pszCmdLine = GetCommandLine();
    if (NULL != pszCmdLine)
    {
	while (('\0' != *pszCmdLine) && (' ' != *pszCmdLine++))
	    ;
    }
#endif


    //
    //
    //
    //
    MMCapsSettingsRestore(hwnd, nCmdShow);


    //
    //  finally, get the window displayed and return success
    //
    //  the ShowWindow call is made during MMCapsInit
    //
//  ShowWindow(hwnd, nCmdShow);
//  UpdateWindow(hwnd);

    return (hwnd);
} // AppInit()


//--------------------------------------------------------------------------;
//
//  int AppExit
//
//  Description:
//      This function is called just before the application exits from
//      WinMain. Its purpose is to clean up any resources that were allocated
//      for running the application: brushes, heaps, etc..
//
//  Arguments:
//      HINSTANCE hinst: Identifies the current instance of the
//      application that is exiting.
//
//      int nResult: The result of the WM_QUIT message (in wParam of the
//      MSG structure. This argument will usually be 0 (even if the message
//      loop was never entered).
//
//  Return (int):
//      The return value is usually nResult--be we give this function the
//      opportunity to modify its value.
//
//  History:
//      11/ 8/92
//
//--------------------------------------------------------------------------;

int FNGLOBAL AppExit
(
    HINSTANCE       hinst,
    int             nResult
)
{
    DPF(0, "AppExit(hinst=%Xh, nResult=%d)", hinst, nResult);

    //
    //
    //
    //

    return (nResult);
} // AppExit()


//==========================================================================;
//
//  Main entry and message dispatching code
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  int WinMain
//
//  Description:
//      This function is called by the system as the initial entry point
//      for a Windows application.
//
//  Arguments:
//      HINSTANCE hinst: Identifies the current instance of the
//      application.
//
//      HINSTANCE hinstPrev: Identifies the previous instance of the
//      application (NULL if first instance). For Win 32, this argument
//      is _always_ NULL.
//
//      LPSTR pszCmdLine: Points to null-terminated unparsed command line.
//      This string is strictly ANSI regardless of whether the application
//      is built for Unicode. To get the Unicode equivalent call the
//      GetCommandLine() function (Win 32 only).
//
//      int nCmdShow: How the main window for the application is to be
//      shown by default.
//
//  Return (int):
//      Returns result from WM_QUIT message (in wParam of MSG structure) if
//      the application is able to enter its message loop. Returns 0 if
//      the application is not able to enter its message loop.
//
//  History:
//      11/ 8/92
//
//--------------------------------------------------------------------------;

int PASCAL WinMain
(
    HINSTANCE       hinst,
    HINSTANCE       hinstPrev,
    LPSTR           pszCmdLine,
    int             nCmdShow
)
{
    int     nResult;
    HWND    hwnd;
    MSG     msg;
    HACCEL  haccl;

    //
    //  our documentation states that WinMain is supposed to return 0 if
    //  we do not enter our message loop--so assume the worst...
    //
    nResult = 0;

    //
    //  make our instance handle global for convenience..
    //
    ghinst = hinst;

    //
    //  init some stuff, create window, etc.. note the explicit cast of
    //  pszCmdLine--this is to mute a warning (and an ugly ifdef) when
    //  compiling for Unicode. see AppInit() for more details.
    //

    hwnd = AppInit(hinst, hinstPrev, (LPTSTR)pszCmdLine, nCmdShow);
    if (hwnd)
    {
	haccl = LoadAccelerators(hinst, ACCEL_APP);

	//
	//  dispatch messages
	//
	while (GetMessage(&msg, NULL, 0, 0))
	{
	    //
	    //  do all the special stuff required for this application
	    //  when dispatching messages..
	    //
	    if (!TranslateAccelerator(hwnd, haccl, &msg))
	    {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	    }
	}

	//
	//  return result of WM_QUIT message.
	//
	nResult = (int)msg.wParam;
    }

    //
    //  shut things down, clean up, etc.
    //
    nResult = AppExit(hinst, nResult);

    return (nResult);
} // WinMain()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mmcaps2k\mmcaps.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1997 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  mmcaps.h
//
//  Description:
//
//
//  History:
//      11/ 8/92
//
//==========================================================================;


//
//  NOTE! we keep a copy of MMREG.H in this project so we can update
//  things by using 'diff'
//
#include "mmreg.h"
#include "zyztlb.h"


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Application Version Information:
//
//
//
//
//  NOTE! all string resources that will be used in app.rcv for the
//  version resource information *MUST* have an explicit \0 terminator!
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define APP_VERSION_MAJOR	    4
#define APP_VERSION_MINOR           0
#define APP_VERSION_BUILD           0
#ifdef UNICODE
#define APP_VERSION_STRING_RC	    "Version 4.00 (Unicode Enabled)\0"
#else
#define APP_VERSION_STRING_RC	    "Version 4.00\0"
#endif

#ifdef WIN32
#define APP_VERSION_NAME_RC         "mmcaps32.exe\0"
#else
#define APP_VERSION_NAME_RC         "mmcaps16.exe\0"
#endif
#define APP_VERSION_COMPANYNAME_RC  "Microsoft Corporation\0"
#define APP_VERSION_COPYRIGHT_RC    "Copyright \251 Microsoft Corp. 1992-1995\0"

#ifdef WIN32
#if (defined(_X86_)) || (defined(i386))
#define APP_VERSION_PRODUCTNAME_RC  "Microsoft Windows NT (i386)\0"
#endif
#if (defined(_MIPS_)) || (defined(MIPS))
#define APP_VERSION_PRODUCTNAME_RC  "Microsoft Windows NT (MIPS)\0"
#endif
#if (defined(_ALPHA_)) || (defined(ALPHA))
#define APP_VERSION_PRODUCTNAME_RC  "Microsoft Windows NT (Alpha)\0"
#endif
#ifndef APP_VERSION_PRODUCTNAME_RC
#define APP_VERSION_PRODUCTNAME_RC  "Microsoft Windows NT\0"
#endif
#else
#define APP_VERSION_PRODUCTNAME_RC  "Microsoft Windows\0"
#endif

#ifdef DEBUG
#define APP_VERSION_DESCRIPTION_RC  "Multimedia Device Capabilities (debug)\0"
#else
#define APP_VERSION_DESCRIPTION_RC  "Multimedia Device Capabilities\0"
#endif


//
//  Unicode versions (if UNICODE is defined)... the resource compiler
//  cannot deal with the TEXT() macro.
//
#define APP_VERSION_STRING          TEXT(APP_VERSION_STRING_RC)
#define APP_VERSION_NAME            TEXT(APP_VERSION_NAME_RC)
#define APP_VERSION_COMPANYNAME     TEXT(APP_VERSION_COMPANYNAME_RC)
#define APP_VERSION_COPYRIGHT       TEXT(APP_VERSION_COPYRIGHT_RC)
#define APP_VERSION_PRODUCTNAME     TEXT(APP_VERSION_PRODUCTNAME_RC)
#define APP_VERSION_DESCRIPTION     TEXT(APP_VERSION_DESCRIPTION_RC)




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)    id
#else
    #define RCID(id)    MAKEINTRESOURCE(id)
#endif


//
//  misc. defines
//
#define APP_MAX_APP_NAME_CHARS      30
#define APP_MAX_APP_NAME_BYTES      (APP_MAX_APP_NAME_CHARS * sizeof(TCHAR))
#define APP_MAX_STRING_RC_CHARS     512
#define APP_MAX_STRING_RC_BYTES     (APP_MAX_STRING_RC_CHARS * sizeof(TCHAR))
#define APP_MAX_STRING_ERROR_CHARS  512
#define APP_MAX_STRING_ERROR_BYTES  (APP_MAX_STRING_ERROR_CHARS * sizeof(TCHAR))

#define APP_WINDOW_XOFFSET          CW_USEDEFAULT
#define APP_WINDOW_YOFFSET          CW_USEDEFAULT
#define APP_WINDOW_WIDTH            500 //CW_USEDEFAULT
#define APP_WINDOW_HEIGHT           300 //CW_USEDEFAULT


//
//
//
//
#define MMCAPS_MAX_STRING_MID_CHARS 80
#define MMCAPS_MAX_STRING_MID_BYTES (MMCAPS_MAX_STRING_MID_CHARS * sizeof(TCHAR))
#define MMCAPS_MAX_STRING_PID_CHARS 128
#define MMCAPS_MAX_STRING_PID_BYTES (MMCAPS_MAX_STRING_PID_CHARS * sizeof(TCHAR))

//
//  max for pid or mid plus some
//
#define MMCAPS_MAX_STRING_MIDPID_CHARS  132



//
//  resource defines...
//
#define ICON_APP                    RCID(10)
#define ACCEL_APP                   RCID(15)


//
//  the application menu...
//
//
#define MENU_APP                    RCID(20)
#define APP_MENU_ITEM_FILE          0
#define IDM_FILE_FONT               1000
#define IDM_FILE_ABOUT              1009
#define IDM_FILE_EXIT               1010

#define APP_MENU_ITEM_DRIVERS       1
#define IDM_DRIVERS_LOWLEVEL        1050
#define IDM_DRIVERS_MCI             1051
#define IDM_DRIVERS_ACM             1052
#define IDM_DRIVERS_VIDEO           1053
#define IDM_DRIVERS_DRIVERS         1054

#define IDM_UPDATE                  1100


//
//
//
#define MMCAPS_DRIVERTYPE_LOWLEVEL  IDM_DRIVERS_LOWLEVEL
#define MMCAPS_DRIVERTYPE_MCI       IDM_DRIVERS_MCI
#define MMCAPS_DRIVERTYPE_ACM       IDM_DRIVERS_ACM
#define MMCAPS_DRIVERTYPE_VIDEO     IDM_DRIVERS_VIDEO
#define MMCAPS_DRIVERTYPE_DRIVERS   IDM_DRIVERS_DRIVERS



//
//  the main window control id's...
//
#define IDD_APP_LIST_DEVICES        100


//
//  misc dlg boxes...
//
#define DLG_ABOUT                   RCID(50)
#define IDD_ABOUT_VERSION_OS        100
#define IDD_ABOUT_VERSION_PLATFORM  101

#define IDD_ABOUT_VERSION_MMSYSTEM  150


#define DLG_DEVCAPS                 RCID(55)
#define IDD_DEVCAPS_EDIT_DETAILS    100



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  string resources
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define IDS_APP_NAME                100



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Public function prototypes
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  mmcaps.c
//
//
//
int FNCGLOBAL AppMEditPrintF
(
    HWND            hedit,
    PCTSTR          pszFormat,
    ...
);




//
//  midspids.c
//
//
//
BOOL FNGLOBAL MMCapsMidAndPid
(
    UINT            uMid,
    PTSTR           pszMid,
    UINT            uPid,
    PTSTR           pszPid
);



//
//
//
//
BOOL FNGLOBAL MMCapsEnumerateLowLevel(PZYZTABBEDLISTBOX ptlb, BOOL fComplete);
BOOL FNGLOBAL MMCapsEnumerateMCI(PZYZTABBEDLISTBOX ptlb, BOOL fComplete);
BOOL FNGLOBAL MMCapsEnumerateACM(PZYZTABBEDLISTBOX ptlb, BOOL fComplete);
BOOL FNGLOBAL MMCapsEnumerateVideo(PZYZTABBEDLISTBOX ptlb, BOOL fComplete);
BOOL FNGLOBAL MMCapsEnumerateDrivers(PZYZTABBEDLISTBOX ptlb, BOOL fComplete);

BOOL FNGLOBAL MMCapsDetailLowLevel(HWND hedit, LPARAM lParam);
BOOL FNGLOBAL MMCapsDetailMCI(HWND hedit, LPARAM lParam);
BOOL FNGLOBAL MMCapsDetailACM(HWND hedit, LPARAM lParam);
BOOL FNGLOBAL MMCapsDetailVideo(HWND hedit, LPARAM lParam);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  global variables, etc.
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

extern HINSTANCE    ghinst;

extern TCHAR        gszAppSection[];
extern TCHAR        gszNull[];

extern TCHAR        gszAppName[APP_MAX_APP_NAME_CHARS];


//
//
//
extern TCHAR        gszUnknown[];
extern TCHAR        gszNotSpecified[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mmcaps2k\zyztlb.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1997 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  zyztlb.c
//
//  Description:
//
//
//  History:
//       5/18/93
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>

#include "appport.h"
#include "zyztlb.h"

#include "debug.h"


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  int GetRealTextMetrics
//  
//  Description:
//      This function gets the textmetrics of the font currently selected
//      into the hdc.  It returns the average char width as the return value.
//
//      This function computes the average character width correctly by
//      using GetTextExtent() on the string "abc...xzyABC...XYZ" which works
//      out much better for proportional fonts. This is also necessary
//      for correct alignment between dialog and client units.
//
//      Note that this function returns the same TEXTMETRIC values that
//      GetTextMetrics() does, it simply has a different return value.
//
//  Arguments:
//      HDC hdc:
//  
//      LPTEXTMETRIC ptm:
//  
//  Return (int):
//  
//  History:
//      05/11/93
//  
//--------------------------------------------------------------------------;

int FNGLOBAL GetRealTextMetrics
(
    HDC             hdc,
    LPTEXTMETRIC    ptm
)
{
    TCHAR       achAlphabet[26 * 2];    // upper and lower case
    SIZE        sSize;
    UINT        u;
    int         nAveWidth;

    //
    //  get the text metrics of the current font. note that GetTextMetrics
    //  gets the incorrect nAveCharWidth value for proportional fonts.
    //
    GetTextMetrics(hdc, ptm);
    nAveWidth = ptm->tmAveCharWidth;

    //
    //  if it's not a variable pitch font GetTextMetrics was correct
    //  so just return.
    //
    if (ptm->tmPitchAndFamily & FIXED_PITCH)
    {
	//
	//
	//
	for (u = 0; u < 26; u++)
	{
	    achAlphabet[u]      = (TCHAR)(u + (UINT)'a');
	    achAlphabet[u + 26] = (TCHAR)(u + (UINT)'A');
	}

	//
	//  round up
	//
	GetTextExtentPoint(hdc, achAlphabet, SIZEOF(achAlphabet), &sSize);
	nAveWidth = ((sSize.cx / 26) + 1) / 2;
    }

    //
    //  return the calculated average char width
    //
    return (nAveWidth);
} // GetRealTextMetrics()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL TlbPaint
//  
//  Description:
//  
//  
//  Arguments:
//      PZYZTABBEDLISTBOX ptlb:
//  
//      HWND hwnd:
//  
//      HDC hdc:
//  
//  Return (BOOL):
//  
//  History:
//      05/17/93
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL TlbPaint
(
    PZYZTABBEDLISTBOX   ptlb,
    HWND                hwnd,
    HDC                 hdc
)
{
    RECT        rc;
    HFONT       hfont;
    COLORREF    crBk;
    COLORREF    crText;
    int         nHeight;

    //
    //
    //
    hfont = GetWindowFont(ptlb->hlb);
    if (NULL == hfont)
	hfont = GetStockFont(SYSTEM_FONT);

    hfont = SelectObject(hdc, hfont);

    crBk   = SetBkColor(hdc, GetSysColor(COLOR_ACTIVECAPTION));
    crText = SetTextColor(hdc, GetSysColor(COLOR_CAPTIONTEXT));

    //
    //  compute bounding rect for title only
    //
    rc = ptlb->rc;
    nHeight = min(ptlb->nFontHeight, rc.bottom - rc.top);
    rc.bottom = rc.top + nHeight;

    ExtTextOut(hdc, rc.left, rc.top, ETO_OPAQUE, &rc, NULL, 0, NULL);
    TabbedTextOut(hdc, rc.left, rc.top,
		  ptlb->pszTitleText,
		  ptlb->cchTitleText,
		  ptlb->uTabStops,
		  ptlb->panTitleTabs, 0);

    //
    //  restore the dc
    //
    SetBkColor(hdc, crBk);
    SetTextColor(hdc, crText);

    SelectObject(hdc, hfont);

    return (TRUE);
} // TlbPaint()


//--------------------------------------------------------------------------;
//  
//  BOOL TlbMove
//  
//  Description:
//  
//  
//  Arguments:
//      PZYZTABBEDLISTBOX ptlb:
//  
//      PRECT prc:
//  
//      BOOL fRedraw:
//  
//  Return (BOOL):
//  
//  History:
//      05/16/93
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL TlbMove
(
    PZYZTABBEDLISTBOX   ptlb,
    PRECT               prc,
    BOOL                fRedraw
)
{
    RECT        rc;
    int         nHeight;
    HWND        hwnd;


    hwnd = GetParent(ptlb->hlb);

    //
    //  invalidate only the region occupied by the current title bar. this
    //  will make sure that area gets repainted. the listbox portion will
    //  be invalidated correctly by the SetWindowPos() function below..
    //
    rc = ptlb->rc;

    nHeight = min(ptlb->nFontHeight, rc.bottom - rc.top);
    rc.bottom = rc.top + nHeight;

    InvalidateRect(hwnd, &rc, TRUE);


    //
    //  now move the listbox--we modify values in the rect structure, so
    //  copy to local storage
    //
    rc = *prc;

    //
    //  leave room at the top of the bounding rect for the title text
    //
    nHeight = min(ptlb->nFontHeight, rc.bottom - rc.top);
    rc.top += nHeight;

    SetWindowPos(ptlb->hlb, NULL, rc.left, rc.top, rc.right - rc.left,
		 rc.bottom - rc.top, SWP_NOZORDER);

    //
    //  save the new location and invalidate the area so it is repainted
    //
    ptlb->rc = *prc;
    InvalidateRect(hwnd, prc, TRUE);

    if (fRedraw)
    {
	UpdateWindow(hwnd);
    }

    return (TRUE);
} // TlbMove()


//--------------------------------------------------------------------------;
//  
//  BOOL TlbRecalcTabs
//  
//  Description:
//  
//  
//  Arguments:
//      PZYZTABBEDLISTBOX ptlb:
//  
//  Return (BOOL):
//  
//  History:
//      05/18/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL TlbRecalcTabs
(
    PZYZTABBEDLISTBOX   ptlb
)
{
    static TCHAR szGonzoThing[] = TEXT("M");

    int         anTabsList[TLB_MAX_TAB_STOPS];
    HDC         hdc;
    HFONT       hfont;
    TEXTMETRIC  tm;
    int         nAveCharWidth;

    UINT        u;
    int         nWidth;
    int         nPrevTabTitle;
    int         nPrevTabList;
    SIZE        sSize;


    //
    //
    //
    hdc = GetDC(NULL);
    {
	//
	//  get the average char width and height of the current font so we
	//  can compute tabs correctly. note that GetTextMetrics is pretty
	//  bogus when it comes to the average char width--it normally gives
	//  you the width of the character 'x'. what it should be is the
	//  average width of all capitals and lower case letters..
	//
	hfont = GetWindowFont(ptlb->hlb);
	if (NULL == hfont)
	    hfont = GetStockFont(SYSTEM_FONT);

	hfont = SelectObject(hdc, hfont);

#if 0
	GetTextMetrics(hdc, &tm);
	nAveCharWidth = tm.tmAveCharWidth;
#else
	nAveCharWidth = GetRealTextMetrics(hdc, &tm);
#endif
	ptlb->nFontHeight = tm.tmHeight;


	//
	//
	//
	GetTextExtentPoint(hdc, szGonzoThing, 1, &sSize);


	//
	//
	//
	hfont = SelectObject(hdc, hfont);
    }
    ReleaseDC(NULL, hdc);


    //
    //  calculate the width of each column
    //
    nPrevTabTitle = 0;
    nPrevTabList  = 0;
    for (u = 0; u < ptlb->uTabStops; u++)
    {
//      nWidth = nAveCharWidth * ptlb->panTabs[u] + nAveCharWidth * 2;
	nWidth = sSize.cx * ptlb->panTabs[u] + (sSize.cx * 2);

	//
	//  set tabstop for title text--this is in client units
	//  for TabbedTextOut in TlbPaint
	//
	ptlb->panTitleTabs[u] = nPrevTabTitle + nWidth;
	nPrevTabTitle = ptlb->panTitleTabs[u];

	//
	//  set tabstop for listbox--this is in dialog units
	//
	anTabsList[u] = nPrevTabList + MulDiv(nWidth, 4, nAveCharWidth);
	nPrevTabList  = anTabsList[u];
    }


    //
    //  now setup the tabstops in the listbox
    //
    ListBox_SetTabStops(ptlb->hlb, ptlb->uTabStops, anTabsList);

    return (TRUE);
} // TlbRecalcTabs()


//--------------------------------------------------------------------------;
//  
//  HFONT TlbSetFont
//  
//  Description:
//  
//  
//  Arguments:
//      PZYZTABBEDLISTBOX ptlb:
//  
//      HFONT hfont:
//  
//      BOOL fRedraw:
//  
//  Return (HFONT):
//  
//  History:
//      05/16/93
//  
//--------------------------------------------------------------------------;

HFONT FNGLOBAL TlbSetFont
(
    PZYZTABBEDLISTBOX   ptlb,
    HFONT               hfont,
    BOOL                fRedraw
)
{
    HFONT       hfontOld;

    //
    //
    //
    hfontOld = GetWindowFont(ptlb->hlb);
    SetWindowFont(ptlb->hlb, hfont, FALSE);

    TlbRecalcTabs(ptlb);
    TlbMove(ptlb, &ptlb->rc, fRedraw);

    return (hfontOld);
} // TlbSetFont()


//--------------------------------------------------------------------------;
//  
//  BOOL TlbSetTitleAndTabs
//  
//  Description:
//      This function sets the title text and tab stops for a Tabbed List
//      Box (TLB). The pszTitleFormat specifies the title text for each
//      column along with the tabstop position for each column. The format
//      of this string is as follows:
//
//      <columnname1>\t<tab1>!<columnname2>
//
//      TCHAR   szTlbThings[] = TEXT("Index\t6!Code\t5!Name");
//
//
//  Arguments:
//      PZYZTABBEDLISTBOX ptlb:
//  
//      PTSTR pszTitleFormat:
//
//      BOOL fRedraw:
//  
//  Return (BOOL):
//  
//  History:
//      05/18/93
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL TlbSetTitleAndTabs
(
    PZYZTABBEDLISTBOX   ptlb,
    PTSTR               pszTitleFormat,
    BOOL                fRedraw
)
{
    TCHAR       szTitleText[TLB_MAX_TITLE_CHARS];
    int         anTabs[TLB_MAX_TAB_STOPS];
    PTSTR       pch;
    PTSTR       pchTitleText;
    UINT        uTabStops;
    UINT        cchTitleText;
    HWND        hwnd;

    //
    //  parse the title format counting tab stops and actual size of title
    //  text
    //
    uTabStops    = 0;
    pchTitleText = szTitleText;
    for (pch = pszTitleFormat; '\0' != *pch; )
    {
	TCHAR       ch;

	//
	//  scan to tab
	//
	while ('\0' != (ch = *pch))
	{
	    *pchTitleText++ = *pch++;

	    if ('\t' == ch)
		break;
	}

	if ('\0' == ch)
	    break;

	//
	//  grab the next tab stop value
	//
	anTabs[uTabStops] = atoi(pch);
	uTabStops++;

	//
	//  skip to start of next column name
	//
	while ('!' != *pch++)
	    ;
    }


    //
    //  terminate the converted title text
    //
    *pchTitleText = '\0';
    cchTitleText = lstrlen(szTitleText);

    //
    //  free the memory used for the previous tab stops and title text
    //
    if (NULL != ptlb->panTabs)
    {
	LocalFree((HLOCAL)ptlb->panTabs);

	ptlb->uTabStops    = 0;
	ptlb->panTabs      = NULL;
	ptlb->panTitleTabs = NULL;
    }

    if (NULL != ptlb->pszTitleText)
    {
	LocalFree((HLOCAL)ptlb->pszTitleText);

	ptlb->cchTitleText = 0;
	ptlb->pszTitleText = NULL;
    }


    //
    //  allocate new space for tab stops. there are two different tab
    //  arrays:
    //
    //      panTabs: original tab values as passed by caller. these are
    //      virtual tab locations represented as number of characters. we
    //      need to keep these values for recomputing the real tabs when
    //      the font changes.
    //
    //      panTitleTabs: these values are computed by TlbRecalcTabs and
    //      are actual tab positions in client coordinates for the title
    //      text (needed for TabbedTextOut in TlbPaint).
    //
    //  the tabs for the listbox are computed and set in TlbRecalcTabs
    //
    if (0 != uTabStops)
    {
	ptlb->panTabs = (PINT)LocalAlloc(LPTR, (uTabStops * sizeof(int)) * 2);
	if (NULL == ptlb->panTabs)
	    return (FALSE);

	ptlb->uTabStops    = uTabStops;
	ptlb->panTitleTabs = ptlb->panTabs + uTabStops;
	memcpy(ptlb->panTabs, anTabs, uTabStops * sizeof(int));
    }


    //
    //  allocate space for the converted title text (stripped of the tab
    //  spacing values). this string is passed directly to TabbedTextOut
    //  in TlbPaint.
    //
    if (0 != cchTitleText)
    {
	ptlb->pszTitleText = (PTSTR)LocalAlloc(LPTR, (cchTitleText + 1) * sizeof(TCHAR));
	if (NULL == ptlb->pszTitleText)
	    return (FALSE);

	ptlb->cchTitleText = cchTitleText;
	lstrcpy(ptlb->pszTitleText, szTitleText);
    }



    //
    //
    //
    TlbRecalcTabs(ptlb);


    //
    //  force a complete repaint of the title text and listbox--redraw
    //  immediately if we are supposed to
    //
    hwnd = GetParent(ptlb->hlb);
    InvalidateRect(hwnd, &ptlb->rc, TRUE);
    if (fRedraw)
    {
	UpdateWindow(hwnd);
    }
    
    return TRUE;
} // TlbSetTitleAndTabs()


//--------------------------------------------------------------------------;
//  
//  PZYZTABBEDLISTBOX TlbDestroy
//  
//  Description:
//  
//  
//  Arguments:
//      PZYZTABBEDLISTBOX ptlb:
//  
//  Return (PZYZTABBEDLISTBOX):
//  
//  History:
//      05/16/93
//  
//--------------------------------------------------------------------------;

PZYZTABBEDLISTBOX FNGLOBAL TlbDestroy
(
    PZYZTABBEDLISTBOX   ptlb
)
{
    HWND        hwnd;
    int         nHeight;

    //
    //  get rid of the listbox
    //
    if (NULL != ptlb->hlb)
    {
	DestroyWindow(ptlb->hlb);

	//
	//  invalidate area where title text was so it will be clean
	//
	nHeight = min(ptlb->nFontHeight, ptlb->rc.bottom - ptlb->rc.top);
	ptlb->rc.bottom = ptlb->rc.top + nHeight;

	hwnd = GetParent(ptlb->hlb);
	InvalidateRect(hwnd, &ptlb->rc, TRUE);


	//
	//  free the memory used for tab stops and title text
	//
	if (NULL != ptlb->panTabs)
	    LocalFree((HLOCAL)ptlb->panTabs);

	if (NULL != ptlb->pszTitleText)
	    LocalFree((HLOCAL)ptlb->pszTitleText);
    }

    LocalFree((HLOCAL)ptlb);

    return (NULL);
} // TlbDestroy()


//--------------------------------------------------------------------------;
//  
//  PZYZTABBEDLISTBOX TlbCreate
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      int nId:
//  
//      PRECT prc:
//  
//  Return (PZYZTABBEDLISTBOX):
//  
//  History:
//      05/16/93
//  
//--------------------------------------------------------------------------;

PZYZTABBEDLISTBOX FNGLOBAL TlbCreate
(
    HWND                hwnd,
    int                 nId,
    PRECT               prc
)
{
    #define TLB_DEF_STYLE   (WS_VISIBLE|WS_CHILD|WS_VSCROLL|WS_BORDER|  \
			     LBS_NOTIFY|LBS_NOINTEGRALHEIGHT|LBS_USETABSTOPS)

    static TCHAR    szNull[]    = TEXT("");
    static TCHAR    szListBox[] = TEXT("ListBox");

    PZYZTABBEDLISTBOX   ptlb;
    HINSTANCE           hinst;


    //
    //  create a new instance data structure..
    //
    ptlb = (PZYZTABBEDLISTBOX)LocalAlloc(LPTR, sizeof(*ptlb));
    if (NULL == ptlb)
	return (NULL);


    //
    //  create the listbox
    //
    hinst = GetWindowInstance(hwnd);

    ptlb->hlb = CreateWindow(szListBox, szNull, TLB_DEF_STYLE,
			     0, 0, 0, 0, hwnd, (HMENU)nId, hinst, NULL);
    if (NULL == ptlb->hlb)
    {
	TlbDestroy(ptlb);
	return (NULL);
    }

    TlbRecalcTabs(ptlb);

    if (NULL != prc)
    {
	ptlb->rc = *prc;
	TlbMove(ptlb, prc, FALSE);
    }

    return (ptlb);
} // TlbCreate()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mmcaps2k\zyztlb.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1997 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//==========================================================================;
//
//  zyztlb.h
//
//  Description:
//
//
//  History:
//       5/18/93
//
//==========================================================================;


//
//
//
//
typedef struct tZYZTABBEDLISTBOX
{
    HWND            hlb;

    int             nFontHeight;
    RECT            rc;

    UINT            uTabStops;
    PINT            panTabs;
    PINT            panTitleTabs;

    UINT            cchTitleText;
    PTSTR           pszTitleText;

} ZYZTABBEDLISTBOX, *PZYZTABBEDLISTBOX;


#define TLB_MAX_TAB_STOPS           20      // max number of columns
#define TLB_MAX_TITLE_CHARS         512


//
//
//
//
//
BOOL FNGLOBAL TlbPaint
(
    PZYZTABBEDLISTBOX   ptlb,
    HWND                hwnd,
    HDC                 hdc
);

BOOL FNGLOBAL TlbMove
(
    PZYZTABBEDLISTBOX   ptlb,
    PRECT               prc,
    BOOL                fRedraw
);

HFONT FNGLOBAL TlbSetFont
(
    PZYZTABBEDLISTBOX   ptlb,
    HFONT               hfont,
    BOOL                fRedraw
);

BOOL FNGLOBAL TlbSetTitleAndTabs
(
    PZYZTABBEDLISTBOX   ptlb,
    PTSTR               pszTitleFormat,
    BOOL                fRedraw
);

PZYZTABBEDLISTBOX FNGLOBAL TlbDestroy
(
    PZYZTABBEDLISTBOX   ptlb
);

PZYZTABBEDLISTBOX FNGLOBAL TlbCreate
(
    HWND                hwnd,
    int                 nId,
    PRECT               prc
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mmdrv\mididd.c ===
/****************************************************************************
 *
 *   mididd.c
 *
 *   Multimedia kernel driver support component (mmdrv)
 *
 *   Copyright (c) 1991-1998 Microsoft Corporation
 *
 *   Driver for midi input and output devices
 *
 *   -- Midi driver entry points (modMessage, midMessage)
 *   -- Auxiliary task (necessary for receiving Apcs and generating
 *      callbacks ASYNCRHONOUSLY)
 *   -- Interface to kernel driver (NtDeviceIoControlFile)
 *   -- Midi parsing code (ported from Windows 3.1).
 *
 *   History
 *      01-Feb-1992 - Robin Speed (RobinSp) wrote it
 *
 ***************************************************************************/

#include "mmdrv.h"
#include <ntddmidi.h>

/*****************************************************************************

    internal declarations

 ****************************************************************************/

#define D1 dprintf1
#define D2 dprintf2
#define D3 dprintf3

//
// Stack size for our auxiliary task
//

#define MIDI_STACK_SIZE 300

#define SYSEX_ERROR    0xFF              // internal error for sysex's on input

//
// Functions for auxiliary thread to perform
//

typedef enum {
    MidiThreadInvalid,
    MidiThreadAddBuffer,
    MidiThreadSetState,
    MidiThreadSetData,
    MidiThreadClose,
    MidiThreadTerminate
} MIDITHREADFUNCTION;

//
// Our local buffers for interfacing to midi input
//

#define LOCAL_MIDI_DATA_SIZE 20
typedef struct _LOCALMIDIHDR {
    OVERLAPPED          Ovl;
    DWORD               BytesReturned;
    struct _LOCALMIDIHDR *lpNext;       // Queueing (really debug only)
    BOOL                Done;           // Driver completed buffer
    PVOID               pClient;        // Our instance data for Apcs
    MIDI_DD_INPUT_DATA  MidiData;       // What the driver wants to process
    BYTE                ExtraData[LOCAL_MIDI_DATA_SIZE - sizeof(ULONG)];
                                        // The rest of our input buffer
} LOCALMIDIHDR, *PLOCALMIDIHDR;

//
// Midi input data
//

#define NUMBER_OF_LOCAL_MIDI_BUFFERS 8

typedef struct {

    //
    // Static data for managing midi input
    //
    BOOL                fMidiInStarted; // Do we think midi in is running ?
    DWORD               dwMsg;          // Current short msg
    DWORD               dwCurData;      // Position in long message
    BYTE                status;         // Running status byte
    BOOLEAN             fSysex;         // Processing extended message
    BOOLEAN             Bad;            // Input not working properly
    BYTE                bBytesLeft;     // Bytes left in short message
    BYTE                bBytePos;       // Position in short message
    DWORD               dwCurTime;      // Latest time from driver
    DWORD               dwMsgTime;      // Time to insert into message
                                        // in milliseconds since device
                                        // was opened
    PLOCALMIDIHDR       DeviceQueue;    // Keep track of what the device
                                        // has (debugging only)
    LOCALMIDIHDR                        // Driver interface buffers
     Bufs[NUMBER_OF_LOCAL_MIDI_BUFFERS];// When input is active these
                                        // are queued on the device
                                        // except while data is being
                                        // processed from them
} LOCALMIDIDATA, *PLOCALMIDIDATA;


//
// per allocation structure for Midi
//

typedef struct tag_MIDIALLOC {
    struct tag_MIDIALLOC *Next;         // Chain of devices
    UINT                DeviceNumber;   // Number of device
    UINT                DeviceType;     // MidiInput or MidiOutput
    DWORD_PTR           dwCallback;     // client's callback
    DWORD_PTR           dwInstance;     // client's instance data
    HMIDI               hMidi;          // handle for stream
    HANDLE              hDev;           // Midi device handle
    LPMIDIHDR           lpMIQueue;      // Buffers sent to device
                                        // This is only required so that
                                        // CLOSE knows when things have
                                        // really finished.
                                        // notify.  This is only accessed
                                        // on the device thread and its
                                        // apcs so does not need any
                                        // synchronized access.
    HANDLE              Event;          // Event for driver syncrhonization
                                        // and notification of auxiliary
                                        // task operation completion.
    MIDITHREADFUNCTION  AuxFunction;    // Function for thread to perform
    union {
        LPMIDIHDR       pHdr;           // Buffer to pass in aux task
        ULONG           State;          // State to set
        struct {
            ULONG       Function;       // IOCTL to use
            PBYTE       pData;          // Data to set or get
            ULONG       DataLen;        // Length of data
        } GetSetData;

    } AuxParam;
                                        // 0 means terminate task.
    HANDLE              ThreadHandle;   // Handle for termination ONLY
    HANDLE              AuxEvent1;      // Aux thread waits on this
    HANDLE              AuxEvent2;      // Aux thread caller waits on this
    DWORD               AuxReturnCode;  // Return code from Aux task
    DWORD               dwFlags;        // Open flags
    PLOCALMIDIDATA      Mid;            // Extra midi input structures
    int                 l;              // Helper global for modMidiLength

} MIDIALLOC, *PMIDIALLOC;

PMIDIALLOC MidiHandleList;              // Our chain of wave handles

/*****************************************************************************

    internal function prototypes

 ****************************************************************************/

STATIC DWORD midiGetDevCaps(DWORD id, UINT DeviceType, LPBYTE lpCaps,
                            DWORD dwSize);
STATIC DWORD midiThread(LPVOID lpParameter);
STATIC void midiCleanUp(PMIDIALLOC pClient);
STATIC DWORD midiThreadCall(MIDITHREADFUNCTION Function, PMIDIALLOC pClient);
STATIC DWORD midiSetState(PMIDIALLOC pClient, ULONG State);
STATIC void midiInOvl(DWORD dwRet, DWORD dwBytes, LPOVERLAPPED pOverlap);
STATIC DWORD midiInWrite(LPMIDIHDR pHdr, PMIDIALLOC pClient);
STATIC DWORD midiOutWrite(PBYTE pData, ULONG Len, PMIDIALLOC pClient);
STATIC void midiBlockFinished(LPMIDIHDR lpHdr, DWORD MsgId);
STATIC void midiCallback(PMIDIALLOC pMidi, DWORD msg, DWORD_PTR dw1, DWORD_PTR dw2);
STATIC int modMIDIlength(PMIDIALLOC pClient, BYTE b);
STATIC void midByteRec(PMIDIALLOC pClient, BYTE byte);
STATIC void midSendPartBuffer(PMIDIALLOC pClient);
STATIC void midFreeQ(PMIDIALLOC pClient);
STATIC void midiFlush(PMIDIALLOC pClient);

/****************************************************************************
 * @doc INTERNAL
 *
 * @api VOID | TerminateMidi | Free all midi resources for mmdrv.dll
 *
 * @rdesc None
 ***************************************************************************/
VOID TerminateMidi(VOID)
{
    //
    // Don't do any cleanup - Midi input resources cleaned up on Close.
    //
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midiGetDevCaps | Get the device capabilities.
 *
 * @parm DWORD | id | Device id
 *
 * @parm UINT | DeviceType | type of device
 *
 * @parm LPBYTE | lpCaps | Far pointer to a MIDIOUTCAPS structure to
 *      receive the information.
 *
 * @parm DWORD | dwSize | Size of the MIDIOUTCAPS structure.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
STATIC DWORD midiGetDevCaps(DWORD id, UINT DeviceType,
                            LPBYTE lpCaps, DWORD dwSize)
{
    return sndGetData(DeviceType, id, dwSize, lpCaps,
                      IOCTL_MIDI_GET_CAPABILITIES);
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midiOpen | Open midi device and set up logical device data
 *    and auxilary task for issuing requests and servicing Apc's
 *
 * @parm MIDIDEVTYPE | DeviceType | Whether it's a midi input or output device
 *
 * @parm DWORD | id | The device logical id
 *
 * @parm DWORD | msg | Input parameter to modMessage
 *
 * @parm DWORD | dwUser | Input parameter to modMessage - pointer to
 *   application's handle (generated by this routine)
 *
 * @parm DWORD | dwParam1 | Input parameter to modMessage
 *
 * @parm DWORD | dwParam2 | Input parameter to modMessage
 *
 * @rdesc modMessage return code.
 ***************************************************************************/

STATIC DWORD midiOpen(UINT      DeviceType,
                      DWORD     id,
                      DWORD_PTR dwUser,
                      DWORD_PTR dwParam1,
                      DWORD_PTR dwParam2)
{
    PMIDIALLOC     pClient;  // pointer to client information structure
    MMRESULT mRet;

    // dwParam1 contains a pointer to a MIDIOPENDESC
    // dwParam2 contains midi driver specific flags in the LOWORD
    // and generic driver flags in the HIWORD

    //
    // allocate my per-client structure
    //
    if (DeviceType == MidiOutDevice) {
        pClient = (PMIDIALLOC)HeapAlloc(hHeap, 0, sizeof(MIDIALLOC));

        if (pClient != NULL) {
            memset(pClient, 0, sizeof(MIDIALLOC));
        }
    } else {
        WinAssert(DeviceType == MidiInDevice);
        pClient = (PMIDIALLOC)HeapAlloc(hHeap, 0,
                   sizeof(struct _x{MIDIALLOC S1; LOCALMIDIDATA S2;}));

        if (pClient != NULL) {
            memset(pClient, 0, sizeof(struct _x{MIDIALLOC S1; LOCALMIDIDATA S2;}));
        }
    }

    if (pClient == NULL) {
        return MMSYSERR_NOMEM;
    }

    if (DeviceType == MidiInDevice) {
        int i;
        pClient->Mid = (PLOCALMIDIDATA)(pClient + 1);
        for (i = 0 ;i < NUMBER_OF_LOCAL_MIDI_BUFFERS ; i++) {
            pClient->Mid->Bufs[i].pClient = pClient;
        }
    }

    //
    // and fill it with info
    //
    // (note that setting everything to 0 correctly initialized our
    //  midi input processing static data).

    pClient->DeviceType  = DeviceType;
    pClient->dwCallback  = ((LPMIDIOPENDESC)dwParam1)->dwCallback;
    pClient->dwInstance  = ((LPMIDIOPENDESC)dwParam1)->dwInstance;
    pClient->hMidi       = ((LPMIDIOPENDESC)dwParam1)->hMidi;
    pClient->dwFlags     = (DWORD)dwParam2;

    //
    // See if we can open our device
    // If it's only a query be sure only to open for read, otherwise
    // we could get STATUS_BUSY if someone else is writing to the
    // device.
    //

    mRet = sndOpenDev(DeviceType,
                       id,
                       &pClient->hDev,
                       (GENERIC_READ | GENERIC_WRITE));

    if (mRet != MMSYSERR_NOERROR) {

        midiCleanUp(pClient);
        return mRet;
    }


    //
    // Create our event for syncrhonization with the device driver
    //

    pClient->Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (pClient->Event == NULL) {
        midiCleanUp(pClient);
        return MMSYSERR_NOMEM;
    }

    if (DeviceType == MidiInDevice) {

        //
        // Create our event pair for synchronization with the auxiliary
        // thread
        //

        pClient->AuxEvent1 = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (pClient->AuxEvent1 == NULL) {
            midiCleanUp(pClient);
            return MMSYSERR_NOMEM;
        }
        pClient->AuxEvent2 = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (pClient->AuxEvent2 == NULL) {
            midiCleanUp(pClient);
            return MMSYSERR_NOMEM;
        }

        //
        // Create our auxiliary thread for sending buffers to the driver
        // and collecting Apcs
        //

        mRet = mmTaskCreate((LPTASKCALLBACK)midiThread,
                            &pClient->ThreadHandle,
                            (DWORD_PTR)pClient);

        if (mRet != MMSYSERR_NOERROR) {
            midiCleanUp(pClient);
            return MMSYSERR_NOMEM;
        }

        //
        // Make sure the thread has really started
        //

        WaitForSingleObject(pClient->AuxEvent2, INFINITE);
    }

    //
    // give the client my driver dw
    //
    {
        PMIDIALLOC *pUserHandle;
        pUserHandle = (PMIDIALLOC *)dwUser;
        *pUserHandle = pClient;
    }

    //
    // sent client his OPEN callback message
    //
    midiCallback(pClient, DeviceType == MidiOutDevice ? MOM_OPEN : MIM_OPEN,
                 0L, 0L);

    return MMSYSERR_NOERROR;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midiCleanUp | Free resources for a midi device
 *
 * @parm PMIDIALLOC | pClient | Pointer to a MIDIALLOC structure describing
 *      resources to be freed.
 *
 * @rdesc There is no return value.
 *
 * @comm If the pointer to the resource is NULL then the resource has not
 *     been allocated.
 ***************************************************************************/
STATIC void midiCleanUp(PMIDIALLOC pClient)
{
    if (pClient->hDev != INVALID_HANDLE_VALUE) {
        CloseHandle(pClient->hDev);
    }
    if (pClient->AuxEvent1) {
        CloseHandle(pClient->AuxEvent1);
    }
    if (pClient->AuxEvent2) {
        CloseHandle(pClient->AuxEvent2);
    }
    if (pClient->Event) {
        CloseHandle(pClient->Event);
    }

    HeapFree(hHeap, 0, (LPSTR)pClient);
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midiOutWrite | Synchronously process a midi output
 *       buffer.
 *
 * @parm LPMIDIHDR | pHdr | Pointer to a midi buffer
 *
 * @parm PMIDIALLOC | pClient | The data associated with the logical midi
 *     device.
 *
 * @rdesc A MMSYS... type return code for the application.
 ***************************************************************************/
STATIC DWORD midiOutWrite(PBYTE pData, ULONG Len, PMIDIALLOC pClient)
{
    DWORD BytesReturned;

    //
    // Try passing the request to our driver
    // We operate synchronously but allow for the driver to operate
    // asynchronously by waiting on an event.
    //

    if (!DeviceIoControl(
                    pClient->hDev,
                    IOCTL_MIDI_PLAY,
                    (PVOID)pData,                // Input buffer
                    Len,                         // Input buffer size
                    NULL,                        // Output buffer
                    0,                           // Output buffer size
                    &BytesReturned,
                    NULL)) {
        return sndTranslateStatus();
    }

    return MMSYSERR_NOERROR;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midiInPutBuffer | Pass a buffer to receive midi input
 *
 * @parm LPMIDIHDR | pHdr | Pointer to a midi buffer
 *
 * @parm PMIDIALLOC | pClient | The data associated with the logical midi
 *     device.
 *
 * @rdesc A MMSYS... type return code for the application.
 ***************************************************************************/
STATIC MMRESULT midiInPutBuffer(PLOCALMIDIHDR pHdr, PMIDIALLOC pClient)
{
    DWORD BytesReturned;
    BOOL Result;

    WinAssert(!pHdr->Done);  // Flag should be clear ready for setting by Apc

    //
    // midiMessages serializes these calls using ENTER_MM_HANDLE
    //

    //
    // Try passing the request to our driver
    // We operate synchronously but allow for the driver to operate
    // asynchronously by waiting on an event.
    //

    Result = ReadFileEx(
                 pClient->hDev,
                 (LPVOID)&pHdr->MidiData,
                 sizeof(pHdr->ExtraData) +
                     sizeof(MIDI_DD_INPUT_DATA),
                 &pHdr->Ovl,
                 midiInOvl);

    //
    // Put the buffer in our queue
    //

    if (Result || GetLastError() == ERROR_IO_PENDING) {
        PLOCALMIDIHDR *ppHdr;
        pHdr->lpNext = NULL;
        ppHdr = &pClient->Mid->DeviceQueue;
        while (*ppHdr) {
           ppHdr = &(*ppHdr)->lpNext;
        }

        *ppHdr = pHdr;

        return MMSYSERR_NOERROR;
    }
    return sndTranslateStatus();
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midiInWrite | Pass a new buffer to the Auxiliary thread for
 *       a midi device.
 *
 * @parm LPMIDIHDR | pHdr | Pointer to a midit buffer
 *
 * @parm PMIDIALLOC | pClient | The data associated with the logical midi
 *     device.
 *
 * @rdesc A MMSYS... type return code for the application.
 *
 * @comm The buffer flags are set and the buffer is passed to the auxiliary
 *     device task for processing.
 ***************************************************************************/
STATIC DWORD midiInWrite(LPMIDIHDR pHdr, PMIDIALLOC pClient)
{
    //
    // Put the request at the end of our queue.
    //
    pHdr->dwFlags |= MHDR_INQUEUE;
    pHdr->dwFlags &= ~MHDR_DONE;
    pClient->AuxParam.pHdr = pHdr;
    return midiThreadCall(MidiThreadAddBuffer, pClient);
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midiSetState | Set a midi device to a given state
 *
 * @parm PMIDIALLOC | pClient | The data associated with the logical midi
 *     output device.
 *
 * @parm ULONG | State | The new state
 *
 * @rdesc A MMSYS... type return code for the application.
 ***************************************************************************/
STATIC DWORD midiSetState(PMIDIALLOC pClient, ULONG State)
{
    MMRESULT mRc;

    mRc = sndSetHandleData(pClient->hDev,
                           sizeof(State),
                           &State,
                           IOCTL_MIDI_SET_STATE,
                           pClient->Event);

    midiFlush(pClient);

    return mRc;
}



/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midiThreadCall | Set the function for the thread to perform
 *     and 'call' the thread using the event pair mechanism.
 *
 * @parm MIDITHREADFUNCTION | Function | The function to perform
 *
 * @parm PMIDIALLOC | Our logical device data
 *
 * @rdesc An MMSYS... type return value suitable for returning to the
 *      application
 *
 * @comm The AuxParam field in the device data is the 'input' to
 *      the function processing loop in MidiThread().
 ***************************************************************************/
STATIC DWORD midiThreadCall(MIDITHREADFUNCTION Function, PMIDIALLOC pClient)
{
    //
    // Set the function code
    //
    pClient->AuxFunction = Function;

    //
    // Kick off the thread
    //
    SetEvent(pClient->AuxEvent1);

    //
    // Wait for it to complete
    //
    WaitForSingleObject(pClient->AuxEvent2, INFINITE);

    //
    // Return the return code that our task set.
    //
    return pClient->AuxReturnCode;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midiInApc | Apc routine.  Called when a kernel sound driver
 *     completes processing of a midi buffer.
 *
 * @parm PVOID | ApcContext | The Apc parameter.  In our case this is a
 *     pointer to our midi device data.
 *
 * @parm PIO_STATUS_BLOCK | pIosb | Pointer to the Io status block
 *     used for the request.
 *
 * @rdesc There is no return code.
 ***************************************************************************/
STATIC void midiInOvl(DWORD dwRet, DWORD dwBytesReturned, LPOVERLAPPED pOverlap)
{
    PLOCALMIDIHDR pHdr;

    pHdr = ((PLOCALMIDIHDR)pOverlap);

    WinAssert(((PMIDIALLOC)pHdr->pClient)->DeviceType == MidiInDevice);

    //
    // Note that the buffer is complete.  We don't do anything else here
    // because funny things happen if we call the client's callback
    // routine from within an Apc.
    //

    pHdr->BytesReturned = dwBytesReturned;
    pHdr->Done = TRUE;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midiFlush | Buffer completion routine.  This completes
 *     the work of the Apc routine at below Apc priority.  This gets
 *     round the nasty situations arising when the user's callback
 *     causes more apcs to run (I strongly suspect this is a kernel
 *     but).
 *
 * @parm PMIDIALLOC | pClient | The client's handle data
 *
 * @rdesc There is no return code.
 ***************************************************************************/

STATIC void midiFlush(PMIDIALLOC pClient)
{
    //
    // Process any completed buffers - the Apc routine
    // set the 'Done' flag in any completed requests.
    // Note that the call to the user's callback can
    // cause more requests to become complete
    //

    if (pClient->DeviceType == MidiInDevice) {  // Output is synchronous
        while (pClient->Mid->DeviceQueue &&
               pClient->Mid->DeviceQueue->Done) {

            PLOCALMIDIHDR pHdr;

            pHdr = pClient->Mid->DeviceQueue;

            //
            // Clear our flag ready for next time
            //

            pHdr->Done = FALSE;

            //
            // Take buffer off the device queue
            //


            pClient->Mid->DeviceQueue = pHdr->lpNext;

            //
            // Grab the latest time estimate - convert from 100ns units
            // to milliseconds
            //

            pClient->Mid->dwCurTime =
                (DWORD)(pHdr->MidiData.Time.QuadPart / 10000);

            //
            // Complete our buffer
            //

            if (!pClient->Mid->Bad) {
                int i;
                for (i = 0;
                             i + sizeof(LARGE_INTEGER) < pHdr->BytesReturned;
                                 i++) {
                    midByteRec(pClient, pHdr->MidiData.Data[i]);
                }
                //
                // Requeue our buffer if we're still recording
                //
                if (pClient->Mid->fMidiInStarted) {
                    if (midiInPutBuffer(pHdr, pClient) != MMSYSERR_NOERROR) {
                        pClient->Mid->Bad = TRUE;
                    }
                }
            }
        } // End of processing completed buffers
    }
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | midiThread | Midi device auxiliary thread.
 *
 * @parm LPVOID | lpParameter | The thread parameter.  In our case this is a
 *     pointer to our midi device data.
 *
 * @rdesc Thread return code.
 ***************************************************************************/
STATIC DWORD midiThread(LPVOID lpParameter)
{
    PMIDIALLOC pClient;
    BOOL Close;

    Close = FALSE;

    pClient = (PMIDIALLOC)lpParameter;

    //
    // Set our thread to high priority so we don't fail to pass
    // new buffers to the device when we get them back.  Also
    // we don't want any gaps if callbacks are meant to play
    // notes just received.
    //

    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    //
    // We start notifying our creator we have started and
    // waiting for something to do.
    //

    SetEvent(pClient->AuxEvent2);
    WaitForSingleObject(pClient->AuxEvent1, INFINITE);

    //
    // Now we're going
    //

    for(;;) {
        //
        // Initialize our return code
        //

        pClient->AuxReturnCode = MMSYSERR_NOERROR;

        //
        // Decode function number to perform
        //

        switch (pClient->AuxFunction) {
        case MidiThreadAddBuffer:

            //
            // Add the buffer to our list to be processed
            //
            {
                LPMIDIHDR *pHdrSearch;

                pClient->AuxParam.pHdr->lpNext = NULL;

                pHdrSearch = &pClient->lpMIQueue;
                while (*pHdrSearch) {
                    pHdrSearch = &(*pHdrSearch)->lpNext;
                }

                *pHdrSearch = pClient->AuxParam.pHdr;
            }
            break;

        case MidiThreadSetState:



            switch (pClient->AuxParam.State) {
            case MIDI_DD_RECORD:
                //
                // Start means we must add our buffers to the driver's list
                //
                if (!pClient->Mid->fMidiInStarted && !pClient->Mid->Bad) {
                    int i;
                    for (i = 0; i < NUMBER_OF_LOCAL_MIDI_BUFFERS; i++) {
                        pClient->AuxReturnCode =
                            midiInPutBuffer(&pClient->Mid->Bufs[i], pClient);

                        if (pClient->AuxReturnCode != MMSYSERR_NOERROR) {
                            //
                            // Failed to add our buffer so give up and
                            // get our buffers back !
                            //
                            pClient->Mid->Bad = TRUE;
                            break;
                        }
                    }
                    //
                    // Set Device state.  By issuing state changes on THIS
                    // thread the calling thread can be sure that all Apc's
                    // generated by buffer completions will complete
                    // BEFORE this function completes.
                    //

                    pClient->AuxReturnCode =
                        midiSetState(pClient, pClient->AuxParam.State);

                    //
                    // If this failed then get our buffers back,
                    // otherwise set our new state
                    //
                    if (pClient->AuxReturnCode != MMSYSERR_NOERROR) {
                        pClient->Mid->Bad = TRUE;
                    } else {
                        pClient->Mid->fMidiInStarted = TRUE;
                    }
                } else {
                    //
                    // Already started or bad
                    //
                }
                break;

            case MIDI_DD_STOP:
                //
                // Set Device state.  By issuing state changes on THIS
                // thread the calling thread can be sure that all Apc's
                // generated by buffer completions will complete
                // BEFORE this function completes.
                //

                if (pClient->Mid->fMidiInStarted) {
                    pClient->Mid->fMidiInStarted = FALSE;

                    //
                    // RESET so we get our buffers back
                    //
                    pClient->AuxReturnCode =
                        midiSetState(pClient, MIDI_DD_RESET);
                        WinAssert(!pClient->Mid->DeviceQueue);

                    if (pClient->AuxReturnCode == MMSYSERR_NOERROR) {
                        midSendPartBuffer(pClient);
                    }
                }
                break;

            case MIDI_DD_RESET:
                //
                // Set Device state.  By issuing state changes on THIS
                // thread the calling thread can be sure that all Apc's
                // generated by buffer completions will complete
                // BEFORE this function completes.
                //

                if (pClient->Mid->fMidiInStarted) {
                    pClient->Mid->fMidiInStarted = FALSE;
                    pClient->AuxReturnCode =
                        midiSetState(pClient, pClient->AuxParam.State);
                        WinAssert(!pClient->Mid->DeviceQueue);

                    if (pClient->AuxReturnCode == MMSYSERR_NOERROR) {
                        pClient->Mid->Bad = FALSE; // Recovered !!
                        midSendPartBuffer(pClient);
                    }
                }
                //
                // We zero the input queue anyway - compatibility with
                // windows 3.1
                //
                midFreeQ(pClient);
                break;

            }
            break;

        case MidiThreadSetData:
            {
                pClient->AuxReturnCode =
                    sndSetHandleData(pClient->hDev,
                                     pClient->AuxParam.GetSetData.DataLen,
                                     pClient->AuxParam.GetSetData.pData,
                                     pClient->AuxParam.GetSetData.Function,
                                     pClient->Event);
            }
            break;

        case MidiThreadClose:
            //
            // Try to complete.
            // If we're completed all our buffers then we can.
            // otherwise we can't
            //
            if (pClient->lpMIQueue == NULL) {
                pClient->AuxReturnCode = MMSYSERR_NOERROR;
                Close = TRUE;
            } else {
                pClient->AuxReturnCode = MIDIERR_STILLPLAYING;
            }
            break;

        default:
            WinAssert(FALSE);   // Invalid call
            break;
        }
        //
        // Trap invalid callers
        //
        pClient->AuxFunction = MidiThreadInvalid;

                //
                // See if apcs completed
                //
                midiFlush(pClient);

        //
        // Release the caller
        //
        SetEvent(pClient->AuxEvent2);

        //
        // Complete ?
        //
        if (Close) {
            break;
        }
        //
        // Wait for more !
        //
        while (WaitForSingleObjectEx(pClient->AuxEvent1, INFINITE, TRUE) ==
                   WAIT_IO_COMPLETION) {
                        //
                        // Complete buffers whose Apcs ran
                        //
                        midiFlush(pClient);
        }
    }

    //
    // We've been asked to terminte
    //

    return 1;
}



/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midiCallback | This calls DriverCallback for a MIDIHDR.
 *
 * @parm PMIDIALLOC | pMidi | Pointer to midi device.
 *
 * @parm DWORD | msg | The message.
 *
 * @parm DWORD | dw1 | message DWORD (dw2 is always set to 0).
 *
 * @rdesc There is no return value.
 ***************************************************************************/
void midiCallback(PMIDIALLOC pMidi, DWORD msg, DWORD_PTR dw1, DWORD_PTR dw2)
{

    // invoke the callback function, if it exists.  dwFlags contains
    // midi driver specific flags in the LOWORD and generic driver
    // flags in the HIWORD

    if (pMidi->dwCallback)
        DriverCallback(pMidi->dwCallback,       // user's callback DWORD
                       HIWORD(pMidi->dwFlags),  // callback flags
                       (HDRVR)pMidi->hMidi,     // handle to the midi device
                       msg,                     // the message
                       pMidi->dwInstance,       // user's instance data
                       dw1,                     // first DWORD
                       dw2);                    // second DWORD
}



/****************************************************************************

    This function conforms to the standard Midi input driver message proc
    (midMessage), which is documented in mmddk.d.

****************************************************************************/
DWORD APIENTRY midMessage(DWORD id, DWORD msg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
    PMIDIALLOC pInClient;

    switch (msg) {

        case MIDM_GETNUMDEVS:
            D2(("MIDM_GETNUMDEVS"));
            return sndGetNumDevs(MidiInDevice);

        case MIDM_GETDEVCAPS:
            D2(("MIDM_GETDEVCAPS"));
            return midiGetDevCaps(id, MidiInDevice, (LPBYTE)dwParam1,
                                  (DWORD)dwParam2);

        case MIDM_OPEN:
            D2(("MIDM_OPEN"));
            return midiOpen(MidiInDevice, id, dwUser, dwParam1, dwParam2);

        case MIDM_CLOSE:
            D2(("MIDM_CLOSE"));
            pInClient = (PMIDIALLOC)dwUser;

            //
            // Call our task to see if it's ready to complete
            //
            if (midiThreadCall(MidiThreadClose, pInClient) != 0L) {
                return MIDIERR_STILLPLAYING;
            }

            //
            // Wait for our thread to terminate and close our device
            //
            WaitForSingleObject(pInClient->ThreadHandle, INFINITE);
            CloseHandle(pInClient->ThreadHandle);

            //
            // Tell the caller we're done
            //
            midiCallback(pInClient, MIM_CLOSE, 0L, 0L);

            midiCleanUp(pInClient);

            return MMSYSERR_NOERROR;

        case MIDM_ADDBUFFER:
            D2(("MIDM_ADDBUFFER"));

            // check if it's been prepared
            if (!(((LPMIDIHDR)dwParam1)->dwFlags & MHDR_PREPARED))
                return MIDIERR_UNPREPARED;

            WinAssert(!(((LPMIDIHDR)dwParam1)->dwFlags & MHDR_INQUEUE));

            // if it is already in our Q, then we cannot do this
            if ( ((LPMIDIHDR)dwParam1)->dwFlags & MHDR_INQUEUE )
                return ( MIDIERR_STILLPLAYING );

            // store the pointer to my MIDIALLOC structure in the midihdr
            pInClient = (PMIDIALLOC)dwUser;
            ((LPMIDIHDR)dwParam1)->reserved = (DWORD_PTR)(LPSTR)pInClient;

            return midiInWrite((LPMIDIHDR)dwParam1, pInClient);

        case MIDM_STOP:
            D2(("MIDM_PAUSE"));
            pInClient = (PMIDIALLOC)dwUser;
            pInClient->AuxParam.State = MIDI_DD_STOP;
            return midiThreadCall(MidiThreadSetState, pInClient);

        case MIDM_START:
            D2(("MIDM_RESTART"));
            pInClient = (PMIDIALLOC)dwUser;
            pInClient->AuxParam.State = MIDI_DD_RECORD;
            return midiThreadCall(MidiThreadSetState, pInClient);

        case MIDM_RESET:
            D2(("MIDM_RESET"));
            pInClient = (PMIDIALLOC)dwUser;
            pInClient->AuxParam.State = MIDI_DD_RESET;
            return midiThreadCall(MidiThreadSetState, pInClient);

        default:
            return MMSYSERR_NOTSUPPORTED;
    }

    //
    // Should not get here
    //

    WinAssert(0);
    return MMSYSERR_NOTSUPPORTED;
}

/****************************************************************************

    This function conforms to the standard Midi output driver message proc
    (modMessage), which is documented in mmddk.d.

****************************************************************************/
DWORD APIENTRY modMessage(DWORD id, DWORD msg, DWORD_PTR dwUser, DWORD_PTR dwParam1,
                          DWORD_PTR dwParam2)
{
    PMIDIALLOC pOutClient;

    switch (msg) {
    case MODM_GETNUMDEVS:
        D2(("MODM_GETNUMDEVS"));
        return sndGetNumDevs(MidiOutDevice);

    case MODM_GETDEVCAPS:
        D2(("MODM_GETDEVCAPS"));
        return midiGetDevCaps(id, MidiOutDevice, (LPBYTE)dwParam1,
                              (DWORD)dwParam2);

    case MODM_OPEN:
        D2(("MODM_OPEN"));
        return midiOpen(MidiOutDevice, id, dwUser, dwParam1, dwParam2);

    case MODM_CLOSE:
        D2(("MODM_CLOSE"));
        pOutClient = (PMIDIALLOC)dwUser;

        midiCallback(pOutClient, MOM_CLOSE, 0L, 0L);

        //
        // Close our device
        //
        midiCleanUp(pOutClient);

        return MMSYSERR_NOERROR;

    case MODM_DATA:
        D2(("MODM_DATA"));
        {
            int i;
            BYTE b[4];
            for (i = 0; i < 4; i ++) {
                b[i] = (BYTE)(dwParam1 % 256);
                dwParam1 /= 256;
            }
            return midiOutWrite(b, modMIDIlength((PMIDIALLOC)dwUser, b[0]),
                                (PMIDIALLOC)dwUser);
        }

    case MODM_LONGDATA:
        D2(("MODM_LONGDATA"));

        pOutClient = (PMIDIALLOC)dwUser;
        {
            LPMIDIHDR lpHdr;
            MMRESULT  mRet;

            //
            // check if it's been prepared
            //
            lpHdr = (LPMIDIHDR)dwParam1;
            if (!(lpHdr->dwFlags & MHDR_PREPARED)) {
                return MIDIERR_UNPREPARED;
            }

            //
            //
            //

            mRet = midiOutWrite(lpHdr->lpData, lpHdr->dwBufferLength,
                                pOutClient);

            // note that clearing the done bit or setting the inqueue bit
            // isn't necessary here since this function is synchronous -
            // the client will not get control back until it's done.

            lpHdr->dwFlags |= MHDR_DONE;

            // notify client

            if (mRet == MMSYSERR_NOERROR) {
                midiCallback(pOutClient, MOM_DONE, (DWORD_PTR)lpHdr, 0L);
            }

            return mRet;
        }


    case MODM_RESET:
        D2(("MODM_RESET"));
        return midiSetState((PMIDIALLOC)dwUser, MIDI_DD_RESET);


    case MODM_SETVOLUME:
        D2(("MODM_SETVOLUME"));
        //pOutClient = (PMIDIALLOC)dwUser;
        //pOutClient->AuxParam.GetSetData.pData = *(PBYTE *)&dwParam1;
        //pOutClient->AuxParam.GetSetData.DataLen = sizeof(DWORD);
        //pOutClient->AuxParam.GetSetData.Function = IOCTL_MIDI_SET_VOLUME;
        //return midiThreadCall(MidiThreadSetData, pOutClient);

        return sndSetData(MidiOutDevice, id, sizeof(DWORD),
                          (PBYTE)&dwParam1, IOCTL_MIDI_SET_VOLUME);


    case MODM_GETVOLUME:
        D2(("MODM_GETVOLUME"));
        //pOutClient = (PMIDIALLOC)dwUser;
        //pOutClient->AuxParam.GetSetData.pData = *(PBYTE *)&dwParam1;
        //pOutClient->AuxParam.GetSetData.DataLen = sizeof(DWORD);
        //pOutClient->AuxParam.GetSetData.Function = IOCTL_MIDI_GET_VOLUME;
        //return midiThreadCall(MidiThreadGetData, pOutClient);

        return sndGetData(MidiOutDevice, id, sizeof(DWORD),
                          (PBYTE)dwParam1, IOCTL_MIDI_GET_VOLUME);

    case MODM_CACHEPATCHES:

        D2(("MODM_CACHEPATCHES"));

        pOutClient = (PMIDIALLOC)dwUser;
        {
            MIDI_DD_CACHE_PATCHES AppData;
            DWORD BytesReturned;

            AppData.Bank = HIWORD(dwParam2);
            AppData.Flags = LOWORD(dwParam2);
            memcpy(AppData.Patches, (PVOID)dwParam1, sizeof(AppData.Patches));

            return DeviceIoControl(
                           pOutClient->hDev,
                           IOCTL_MIDI_CACHE_PATCHES,
                           (PVOID)&AppData,
                           sizeof(AppData),
                           NULL,
                           0,
                           &BytesReturned,
                           NULL) ?
                 MMSYSERR_NOERROR :
                 sndTranslateStatus();
        }

    case MODM_CACHEDRUMPATCHES:

        D2(("MODM_CACHEDRUMPATCHES"));

        pOutClient = (PMIDIALLOC)dwUser;
        {
            MIDI_DD_CACHE_DRUM_PATCHES AppData;
            DWORD BytesReturned;

            AppData.Patch = HIWORD(dwParam2);
            AppData.Flags = LOWORD(dwParam2);
            memcpy(AppData.DrumPatches, (PVOID)dwParam1,
                   sizeof(AppData.DrumPatches));

            return DeviceIoControl(
                           pOutClient->hDev,
                           IOCTL_MIDI_CACHE_DRUM_PATCHES,
                           (PVOID)&AppData,
                           sizeof(AppData),
                           NULL,
                           0,
                           &BytesReturned,
                           NULL) ?
                 MMSYSERR_NOERROR :
                 sndTranslateStatus();
        }

    default:
        return MMSYSERR_NOTSUPPORTED;
    }

    //
    // Should not get here
    //

    WinAssert(0);
    return MMSYSERR_NOTSUPPORTED;
}


/***********************************************************************

 UTILITY ROUTINES PORTED DIRECTLY FROM WIN 3.1

 ***********************************************************************/


/****************************************************************************
 * @doc INTERNAL
 *
 * @api int | modMIDIlength | Get the length of a short midi message.
 *
 * @parm DWORD | dwMessage | The message.
 *
 * @rdesc Returns the length of the message.
 ***************************************************************************/
STATIC int modMIDIlength(PMIDIALLOC pClient, BYTE b)
{
    if (b >= 0xF8) {             // system realtime
        /*  for realtime messages, leave running status untouched */
        return 1;                // write one byte
    }

    switch (b) {
    case 0xF0: case 0xF4: case 0xF5: case 0xF6: case 0xF7:
        pClient->l = 1;
        return pClient->l;

    case 0xF1: case 0xF3:
        pClient->l = 2;
        return pClient->l;

    case 0xF2:
        pClient->l = 3;
        return pClient->l;
    }

    switch (b & 0xF0) {
    case 0x80: case 0x90: case 0xA0: case 0xB0: case 0xE0:
        pClient->l = 3;
        return pClient->l;

    case 0xC0: case 0xD0:
        pClient->l = 2;
        return pClient->l;
    }

    return (pClient->l - 1);        // uses previous value if data byte (running status)
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midBufferWrite | This function writes a byte into the long
 *     message buffer.  If the buffer is full or a SYSEX_ERROR or
 *     end-of-sysex byte is received, the buffer is marked as 'done' and
 *     it's owner is called back.
 *
 * @parm BYTE | byte | The byte received.
 *
 * @rdesc There is no return value
 ***************************************************************************/
STATIC void midBufferWrite(PMIDIALLOC pClient, BYTE byte)
{
LPMIDIHDR  lpmh;
UINT       msg;

    // if no buffers, nothing happens
    if (pClient->lpMIQueue == NULL)
        return;

    lpmh = pClient->lpMIQueue;

    if (byte == SYSEX_ERROR) {
        D2(("sysexerror"));
        msg = MIM_LONGERROR;
    }
    else {
        D2(("bufferwrite"));
        msg = MIM_LONGDATA;
        *((LPSTR)(lpmh->lpData) + pClient->Mid->dwCurData++) = byte;
    }

    // if end of sysex, buffer full or error, send them back the buffer
    if ((byte == SYSEX_ERROR) || (byte == 0xF7) || (pClient->Mid->dwCurData >= lpmh->dwBufferLength)) {
        D2(("bufferdone"));
        pClient->lpMIQueue = pClient->lpMIQueue->lpNext;
        lpmh->dwBytesRecorded = pClient->Mid->dwCurData;
        pClient->Mid->dwCurData = 0L;
        lpmh->dwFlags |= MHDR_DONE;
        lpmh->dwFlags &= ~MHDR_INQUEUE;
        midiCallback(pClient, msg, (DWORD_PTR)lpmh, pClient->Mid->dwMsgTime);
    }

    return;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midByteRec | This function constructs the complete midi
 *     messages from the individual bytes received and passes the message
 *     to the client via his callback.
 *
 * @parm WORD | word | The byte received is in the low order byte.
 *
 * @rdesc There is no return value
 *
 * @comm Note that currently running status isn't turned off on errors.
 ***************************************************************************/
STATIC void midByteRec(PMIDIALLOC pClient, BYTE byte)
{

    if (!pClient->Mid->fMidiInStarted)
        return;

    // if it's a system realtime message, send it
    // this does not affect running status or any current message
    if (byte >= 0xF8) {
        D2((" rt"));
        midiCallback(pClient, MIM_DATA, (DWORD)byte, pClient->Mid->dwCurTime);
    }

    // else if it's a system common message
    else if (byte >= 0xF0) {

        if (pClient->Mid->fSysex) {                        // if we're in a sysex
            pClient->Mid->fSysex = FALSE;                  // status byte during sysex ends it
            if (byte == 0xF7)
            {
                midBufferWrite(pClient, 0xF7);        // write in long message buffer
                return;
            }
            else
                midBufferWrite(pClient, SYSEX_ERROR); // secret code indicating error
        }

        if (pClient->Mid->dwMsg) {              // throw away any incomplete short data
            midiCallback(pClient, MIM_ERROR, pClient->Mid->dwMsg, pClient->Mid->dwMsgTime);
            pClient->Mid->dwMsg = 0L;
        }

        pClient->Mid->status = 0;               // kill running status
        pClient->Mid->dwMsgTime = pClient->Mid->dwCurTime;    // save timestamp

        switch(byte) {

        case 0xF0:
            D2((" F0"));
            pClient->Mid->fSysex = TRUE;
            midBufferWrite(pClient, 0xF0);
            break;

        case 0xF7:
            D2((" F7"));
            if (!pClient->Mid->fSysex)
                midiCallback(pClient, MIM_ERROR, (DWORD)byte, pClient->Mid->dwMsgTime);
            // else already took care of it above
            break;

        case 0xF4:      // system common, no data bytes
        case 0xF5:
        case 0xF6:
            D2((" status0"));
            midiCallback(pClient, MIM_DATA, (DWORD)byte, pClient->Mid->dwMsgTime);
            pClient->Mid->bBytePos = 0;
            break;

        case 0xF1:      // system common, one data byte
        case 0xF3:
            D2((" status1"));
            pClient->Mid->dwMsg |= byte;
            pClient->Mid->bBytesLeft = 1;
            pClient->Mid->bBytePos = 1;
            break;

        case 0xF2:      // system common, two data bytes
            D2((" status2"));
            pClient->Mid->dwMsg |= byte;
            pClient->Mid->bBytesLeft = 2;
            pClient->Mid->bBytePos = 1;
            break;
        }
    }

    // else if it's a channel message
    else if (byte >= 0x80) {

        if (pClient->Mid->fSysex) {                        // if we're in a sysex
            pClient->Mid->fSysex = FALSE;                  // status byte during sysex ends it
            midBufferWrite(pClient, SYSEX_ERROR);     // secret code indicating error
        }

        if (pClient->Mid->dwMsg) {              // throw away any incomplete data
            midiCallback(pClient, MIM_ERROR, pClient->Mid->dwMsg, pClient->Mid->dwMsgTime);
            pClient->Mid->dwMsg = 0L;
        }

        pClient->Mid->status = byte;            // save for running status
        pClient->Mid->dwMsgTime = pClient->Mid->dwCurTime;    // save timestamp
        pClient->Mid->dwMsg |= byte;
        pClient->Mid->bBytePos = 1;

        switch(byte & 0xF0) {

        case 0xC0:         // channel message, one data byte
        case 0xD0:
            D2((" status1"));
            pClient->Mid->bBytesLeft = 1;
            break;

        case 0x80:         // channel message, two data bytes
        case 0x90:
        case 0xA0:
        case 0xB0:
        case 0xE0:
            D2((" status2"));
            pClient->Mid->bBytesLeft = 2;
            break;
        }
    }

    // else if it's an expected data byte for a long message
    else if (pClient->Mid->fSysex) {
        D2((" sxdata"));
        midBufferWrite(pClient, byte);        // write in long message buffer
    }

    // else if it's an expected data byte for a short message
    else if (pClient->Mid->bBytePos != 0) {
        D2((" data"));
        if ((pClient->Mid->status) && (pClient->Mid->bBytePos == 1)) { // if running status
             pClient->Mid->dwMsg |= pClient->Mid->status;
             pClient->Mid->dwMsgTime = pClient->Mid->dwCurTime;        // save timestamp
        }
        pClient->Mid->dwMsg += (DWORD)byte << ((pClient->Mid->bBytePos++) * 8);
        if (--pClient->Mid->bBytesLeft == 0) {
            midiCallback(pClient, MIM_DATA, pClient->Mid->dwMsg, pClient->Mid->dwMsgTime);
            pClient->Mid->dwMsg = 0L;
            if (pClient->Mid->status) {
                pClient->Mid->bBytesLeft = pClient->Mid->bBytePos - (BYTE)1;
                pClient->Mid->bBytePos = 1;
            }
            else {
                pClient->Mid->bBytePos = 0;
            }
        }
    }

    // else if it's an unexpected data byte
    else {
        D2((" baddata"));
        midiCallback(pClient, MIM_ERROR, (DWORD)byte, pClient->Mid->dwMsgTime);
    }

    return;
}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midFreeQ | Free all buffers in the MIQueue.
 *
 * @comm Currently this is only called after sending off any partially filled
 *     buffers, so all buffers here are empty.  The timestamp value is 0 in
 *     this case.
 *
 * @rdesc There is no return value.
 ***************************************************************************/
STATIC void midFreeQ(PMIDIALLOC pClient)
{
LPMIDIHDR   lpH, lpN;

    lpH = pClient->lpMIQueue;              // point to top of the queue
    pClient->lpMIQueue = NULL;             // mark the queue as empty
    pClient->Mid->dwCurData = 0L;

    while (lpH) {
        lpN = lpH->lpNext;
        lpH->dwFlags |= MHDR_DONE;
        lpH->dwFlags &= ~MHDR_INQUEUE;
        lpH->dwBytesRecorded = 0;
        midiCallback(pClient, MIM_LONGDATA, (DWORD_PTR)lpH,
                     pClient->Mid->dwCurTime);
        lpH = lpN;
    }
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | midSendPartBuffer | This function is called from midStop().
 *     It looks at the buffer at the head of the queue and, if it contains
 *     any data, marks it as done as sends it back to the client.
 *
 * @rdesc The return value is the number of bytes transfered. A value of zero
 *     indicates that there was no more data in the input queue.
 ***************************************************************************/
STATIC void midSendPartBuffer(PMIDIALLOC pClient)
{
LPMIDIHDR lpH;

    if (pClient->lpMIQueue && pClient->Mid->dwCurData) {
        lpH = pClient->lpMIQueue;
        pClient->lpMIQueue = pClient->lpMIQueue->lpNext;
        lpH->dwFlags |= MHDR_DONE;
        lpH->dwFlags &= ~MHDR_INQUEUE;
        pClient->Mid->dwCurData = 0L;
        midiCallback(pClient, MIM_LONGERROR, (DWORD_PTR)lpH,
                     pClient->Mid->dwMsgTime);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mmdrv\auxdd.c ===
/****************************************************************************
 *
 *   auxdd.c
 *
 *   Multimedia kernel driver support component (mmdrv)
 *
 *   Copyright (c) 1991-1998 Microsoft Corporation
 *
 *   Driver for wave input and output devices
 *
 *   -- Aux driver entry point(auxMessage)
 *
 *   History
 *      25-Aug-1992 - Robin Speed (RobinSp) wrote it
 *
 ***************************************************************************/

 #include "mmdrv.h"
 #include <ntddaux.h>

/****************************************************************************

    This function conforms to the standard Aux driver message proc
    (auxMessage), which is documented in the DDK.

****************************************************************************/
 DWORD auxMessage(UINT uDevice,
                  UINT uMsg,
                  DWORD_PTR dwUser,
                  DWORD_PTR dwParam1,
                  DWORD_PTR dwParam2)

{
    MMRESULT mRet;
    AUX_DD_VOLUME Volume;

    switch (uMsg) {
    case AUXDM_GETDEVCAPS:
        dprintf2(("AUXDM_GETDEVCAPS"));
        return sndGetData(AuxDevice, uDevice, (DWORD)dwParam2, (LPBYTE)dwParam1,
                          IOCTL_AUX_GET_CAPABILITIES);

    case AUXDM_GETNUMDEVS:
        dprintf2(("AUXDM_GETNUMDEVS"));
        return sndGetNumDevs(AuxDevice);

    case AUXDM_GETVOLUME:
        dprintf2(("AUXDM_GETVOLUME"));

        mRet = sndGetData(AuxDevice, uDevice, sizeof(Volume),
                          (PBYTE)&Volume, IOCTL_AUX_GET_VOLUME);

        if (mRet == MMSYSERR_NOERROR) {
            *(LPDWORD)dwParam1 =
                (DWORD)MAKELONG(HIWORD(Volume.Left),
                                HIWORD(Volume.Right));
        }

        return mRet;

    case AUXDM_SETVOLUME:
        dprintf2(("AUXDM_SETVOLUME"));
        Volume.Left = LOWORD(dwParam1) << 16;
        Volume.Right = HIWORD(dwParam1) << 16;

        return sndSetData(AuxDevice, uDevice, sizeof(Volume),
                          (PBYTE)&Volume, IOCTL_AUX_SET_VOLUME);
    }

    return MMSYSERR_NOTSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mmdrv\drvutil.c ===
/****************************************************************************
 *
 *   drvutil.c
 *
 *   Multimedia kernel driver support component (mmdrv)
 *
 *   Copyright (c) 1992-1995 Microsoft Corporation
 *
 *   Support functions common to multiple multi-media drivers :
 *
 *   -- Open a device
 *   -- Translate a kernel IO return code to a multi-media return code
 *   -- Count the number of devices of a given type
 *   -- Set and Get data synchronously to a kernel device
 *
 *   History
 *      01-Feb-1992 - Robin Speed (RobinSp) wrote it
 *      04-Feb-1992 - Reviewed by SteveDav
 *
 ***************************************************************************/

#include "mmdrv.h"
#include <ntddwave.h>
#include <ntddmidi.h>
#include <ntddaux.h>

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | sndOpenDev | Open the kernel driver device corresponding
 *       to a logical wave device id
 *
 * @parm UINT | DeviceType | The type of device
 *
 * @parm DWORD | dwId | The device id
 *
 * @parm PHANDLE | phDev | Where to return the kernel device handle
 *
 * @parm ACCESS_MASK | Access | The desired access
 *
 * @comm For our sound devices the only relevant access are read and
 *    read/write.  Device should ALWAYS allow opens for read unless some
 *    resource or access-rights restriction occurs.
 ***************************************************************************/
MMRESULT sndOpenDev(UINT DeviceType, DWORD dwId,
                    PHANDLE phDev, DWORD Access)
{
    WCHAR cDev[SOUND_MAX_DEVICE_NAME];

    WinAssert(DeviceType == WaveOutDevice ||
              DeviceType == WaveInDevice  ||
              DeviceType == MidiOutDevice ||
              DeviceType == MidiInDevice  ||
              DeviceType == AuxDevice);

    *phDev = INVALID_HANDLE_VALUE;  // Always initialise the return value

    //
    // Check it's not out of range
    //

    if (dwId > SOUND_MAX_DEVICES) {
        return MMSYSERR_BADDEVICEID;
    }
    //
    // Create the device name and open it - remove '\Device'
    //

    wsprintf(cDev, L"\\\\.%ls%d",
             (DeviceType == WaveOutDevice ? DD_WAVE_OUT_DEVICE_NAME_U :
              DeviceType == WaveInDevice  ? DD_WAVE_IN_DEVICE_NAME_U  :
              DeviceType == MidiOutDevice ? DD_MIDI_OUT_DEVICE_NAME_U :
              DeviceType == MidiInDevice  ? DD_MIDI_IN_DEVICE_NAME_U  :
                                            DD_AUX_DEVICE_NAME_U) +
              strlen("\\Device"),
             dwId);

    *phDev = CreateFile(cDev,
                        Access,
                        FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        Access != GENERIC_READ ? FILE_FLAG_OVERLAPPED : 0,
                        NULL);

    //
    // Check up on the driver for refusing to open
    // multiply for read
    //

    WinAssert(!(GetLastError() == ERROR_ACCESS_DENIED &&
                Access == GENERIC_READ));

    //
    // Return status to caller
    //

    return *phDev != INVALID_HANDLE_VALUE ? MMSYSERR_NOERROR : sndTranslateStatus();
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | sndTranslateStatus | This function translates an NT status
 *     code into a multi-media error code as far as possible.
 *
 * @parm NTSTATUS | Status | The NT base operating system return status.
 *
 *
 * @rdesc The multi-media error code.
 ***************************************************************************/
DWORD sndTranslateStatus(void)
{
#if DBG
    UINT n;
    switch (n=GetLastError()) {
#else
    switch (GetLastError()) {
#endif
    case NO_ERROR:
    case ERROR_IO_PENDING:
        return MMSYSERR_NOERROR;

    case ERROR_BUSY:
        return MMSYSERR_ALLOCATED;

    case ERROR_NOT_SUPPORTED:
    case ERROR_INVALID_FUNCTION:
        return MMSYSERR_NOTSUPPORTED;

    case ERROR_NOT_ENOUGH_MEMORY:
        return MMSYSERR_NOMEM;

    case ERROR_ACCESS_DENIED:
        return MMSYSERR_BADDEVICEID;

    case ERROR_INSUFFICIENT_BUFFER:
        return MMSYSERR_INVALPARAM;

    default:
        dprintf2(("sndTranslateStatus:  LastError = %d", n));
        return MMSYSERR_ERROR;
    }
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | sndGetNumDevs | This function returns the number of (kernel)
 *
 * @parm UINT | DeviceType | The Device type
 *
 * @rdesc The number of devices.
 ***************************************************************************/

DWORD sndGetNumDevs(UINT DeviceType)
{
    //
    // Look for devices until we don't find one
    //
    int i;
    HANDLE h;

    for (i=0;
         sndOpenDev(DeviceType, i, &h, GENERIC_READ) == MMSYSERR_NOERROR;
         i++) {

        //
        // Possible future work -  try calling an actual function to make sure
        // this worked.
        //

        CloseHandle(h);
    }
    //
    // We incremented i each time we found a good device
    //

    return i;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | sndSetData | This function sets the volume given a device id
 *                           and could be used for other soft value setting
 *                           when only read access is required to the device
 *
 * @parm UINT | DeviceType | The Device type
 *
 * @parm UINT | DeviceId | The device id
 *
 * @parm UINT | Length | Length of data to set
 *
 * @parm PBYTE | Data | Data to set
 *
 * @parm ULONG | Ioctl | The Ioctl to use
 *
 * @rdesc MM... return code.
 ***************************************************************************/

 MMRESULT sndSetData(UINT DeviceType, UINT DeviceId, UINT Length, PBYTE Data,
                     ULONG Ioctl)
 {

    HANDLE hDev;
    MMRESULT mRet;
    DWORD BytesReturned;

    //
    // Open the wave output device
    //

    mRet = sndOpenDev(DeviceType, DeviceId, &hDev, GENERIC_READ);
    if (mRet != MMSYSERR_NOERROR) {
         return mRet;
    }

    //
    // Set our data.
    //
    // Setting the overlapped parameter (last) to null means we
    // wait until the operation completes.
    //

    mRet = DeviceIoControl(hDev, Ioctl, Data, Length, NULL, 0,
                           &BytesReturned, NULL) ?
           MMSYSERR_NOERROR : sndTranslateStatus();


    //
    // Close our file and return
    //

    CloseHandle(hDev);

    return mRet;
 }

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | sndGetData | This function gets data from a given device
 *                           specified by device id when read-only access is
 *                           sufficient
 *
 * @parm UINT | DeviceType | The Device type
 *
 * @parm UINT | DeviceId | The device id
 *
 * @parm UINT | Length | Length of data to set
 *
 * @parm PBYTE | Data | Data to set
 *
 * @parm ULONG | Ioctl | The Ioctl to use
 *
 * @rdesc MM... return code.
 ***************************************************************************/

 MMRESULT sndGetData(UINT DeviceType, UINT DeviceId, UINT Length, PBYTE Data,
                     ULONG Ioctl)
 {

    HANDLE hDev;
    MMRESULT mRet;
    DWORD BytesReturned;

    //
    // Open the wave output device
    //

    mRet = sndOpenDev(DeviceType, DeviceId, &hDev, GENERIC_READ);
    if (mRet != MMSYSERR_NOERROR) {
         return mRet;
    }

    //
    // Set our data.
    //
    // Setting the overlapped parameter (last) to null means we
    // wait until the operation completes.
    //

    mRet = DeviceIoControl(hDev, Ioctl, NULL, 0, (LPVOID)Data, Length,
                           &BytesReturned, NULL) ?
           MMSYSERR_NOERROR : sndTranslateStatus();


    //
    // Close our file and return
    //

    CloseHandle(hDev);

    return mRet;
 }


/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | sndGetHandleData | Get data from a device using its handle
 *
 * @parm PWAVEALLOC | pClient | Client handle.
 *
 * @parm DWORD | dwSize | Size of the data
 *
 * @parm PVOID | pData | Where to put the data.
 *
 * @parm ULONG | Function | The Ioctl to use
 *
 * @rdesc MMSYS... return value.
 ***************************************************************************/

MMRESULT sndGetHandleData(HANDLE     hDev,
                          DWORD      dwSize,
                          PVOID      pData,
                          ULONG      Ioctl,
                          HANDLE     hEvent)
{
    OVERLAPPED Overlap;
    DWORD BytesReturned;

    WinAssert(hDev != NULL);

    memset(&Overlap, 0, sizeof(Overlap));

    Overlap.hEvent = hEvent;

    //
    // Issue the IO control.  We must wait with our own event because
    // setting the overlapped object to null will complete if other
    // IOs complete.
    //

    if (!DeviceIoControl(hDev,
                         Ioctl,
                         NULL,
                         0,
                         pData,
                         dwSize,
                         &BytesReturned,
                         &Overlap)) {
         DWORD cbTransfer;

         //
         // Wait for completion if necessary
         //

         if (GetLastError() == ERROR_IO_PENDING) {
             if (!GetOverlappedResult(hDev, &Overlap, &cbTransfer,
                                      TRUE)) {
                  return sndTranslateStatus();
             }
         } else {
             return sndTranslateStatus();
         }
    }

    //
    // We'd better peek aleratbly to flush out any IO
    // completions so that things like RESET only
    // return when all buffers have been completed
    //
    // This relies on the fact that SleepEx will return
    // WAIT_IO_COMPLETION in preference to OK
    //

    while (SetEvent(hEvent) &&
           WaitForSingleObjectEx(hEvent, 0, TRUE) == WAIT_IO_COMPLETION) {}


    return MMSYSERR_NOERROR;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | sndSetHandleData | Pass data to a device using its handle
 *
 * @parm PWAVEALLOC | pClient | Client handle.
 *
 * @parm DWORD | dwSize | Size of the data
 *
 * @parm PVOID | pData | Data to send.
 *
 * @parm ULONG | Function | The Ioctl to use
 *
 * @rdesc MMSYS... return value.
 ***************************************************************************/
MMRESULT sndSetHandleData(HANDLE     hDev,
                          DWORD      dwSize,
                          PVOID      pData,
                          ULONG      Ioctl,
                          HANDLE     hEvent)
{
    OVERLAPPED Overlap;
    DWORD BytesReturned;

    WinAssert(hDev != NULL);

    memset((PVOID)&Overlap, 0, sizeof(Overlap));

    Overlap.hEvent = hEvent;

    //
    // Issue the IO control.  We must wait with our own event because
    // setting the overlapped object to null will complete if other
    // IOs complete.
    //

    if (!DeviceIoControl(hDev,
                         Ioctl,
                         pData,
                         dwSize,
                         NULL,
                         0,
                         &BytesReturned,
                         &Overlap)) {
         DWORD cbTransfer;

         //
         // Wait for completion if necessary
         //

         if (GetLastError() == ERROR_IO_PENDING) {
             if (!GetOverlappedResult(hDev, &Overlap, &cbTransfer,
                                      TRUE)) {
                  return sndTranslateStatus();
             }
         } else {
             return sndTranslateStatus();
         }
    }

    //
    // We'd better peek alertably to flush out any IO
    // completions so that things like RESET only
    // return when all buffers have been completed
    //
    // This relies on the fact that SleepEx will return
    // WAIT_IO_COMPLETION in preference to OK
    //

    while (SleepEx(0, TRUE) == WAIT_IO_COMPLETION) {}

    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mmdrv\mmdrv.c ===
/****************************************************************************
 *
 *   mmdrv.c
 *
 *   Multimedia kernel driver support component (mmdrv)
 *
 *   Copyright (c) 1992-1998 Microsoft Corporation
 *
 *   This module contains
 *
 *   -- the entry point and startup code
 *   -- debug support code
 *
 *   History
 *      01-Feb-1992 - Robin Speed (RobinSp) wrote it
 *      04-Feb-1992 - Reviewed by SteveDav
 *
 ***************************************************************************/

#include "mmdrv.h"
#include <stdarg.h>

CRITICAL_SECTION mmDrvCritSec;  // Serialize access to device lists


/**************************************************************************

    @doc EXTERNAL

    @api BOOL | DllInstanceInit | This procedure is called whenever a
        process attaches or detaches from the DLL.

    @parm PVOID | hModule | Handle of the DLL.

    @parm ULONG | Reason | What the reason for the call is.

    @parm PCONTEXT | pContext | Some random other information.

    @rdesc The return value is TRUE if the initialisation completed ok,
        FALSE if not.

**************************************************************************/

BOOL DllInstanceInit(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{

    UNREFERENCED_PARAMETER(pContext);

    if (Reason == DLL_PROCESS_ATTACH) {
#if DBG
        mmdrvDebugLevel = GetProfileInt(L"MMDEBUG", L"MMDRV", 1);
        dprintf2  (("Starting, debug level=%d", mmdrvDebugLevel));
#endif
        DisableThreadLibraryCalls(hModule);

        //
        // Create our process DLL heap
        //
        hHeap = HeapCreate(0, 800, 0);
        if (hHeap == NULL) {
            return FALSE;
        }

        InitializeCriticalSection(&mmDrvCritSec);

    } else {
		if (Reason == DLL_PROCESS_DETACH) {
                    dprintf2(("Ending"));

                    TerminateMidi();
                    TerminateWave();

                    DeleteCriticalSection(&mmDrvCritSec);
                    HeapDestroy(hHeap);
		}
    }
    return TRUE;
}


/***************************************************************************
 * @doc INTERNAL
 *
 * @api LONG | DriverProc | The entry point for an installable driver.
 *
 * @parm DWORD | dwDriverId | For most messages, <p dwDriverId> is the DWORD
 *     value that the driver returns in response to a <m DRV_OPEN> message.
 *     Each time that the driver is opened, through the <f DrvOpen> API,
 *     the driver receives a <m DRV_OPEN> message and can return an
 *     arbitrary, non-zero value. The installable driver interface
 *     saves this value and returns a unique driver handle to the
 *     application. Whenever the application sends a message to the
 *     driver using the driver handle, the interface routes the message
 *     to this entry point and passes the corresponding <p dwDriverId>.
 *     This mechanism allows the driver to use the same or different
 *     identifiers for multiple opens but ensures that driver handles
 *     are unique at the application interface layer.
 *
 *     The following messages are not related to a particular open
 *     instance of the driver. For these messages, the dwDriverId
 *     will always be zero.
 *
 *         DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
 *
 * @parm HANDLE  | hDriver | This is the handle returned to the
 *     application by the driver interface.
 *
 * @parm UINT | wMessage | The requested action to be performed. Message
 *     values below <m DRV_RESERVED> are used for globally defined messages.
 *     Message values from <m DRV_RESERVED> to <m DRV_USER> are used for
 *     defined driver protocols. Messages above <m DRV_USER> are used
 *     for driver specific messages.
 *
 * @parm LONG | lParam1 | Data for this message.  Defined separately for
 *     each message
 *
 * @parm LONG | lParam2 | Data for this message.  Defined separately for
 *     each message
 *
 * @rdesc Defined separately for each message.
 ***************************************************************************/
LRESULT DriverProc(DWORD_PTR dwDriverID, HANDLE hDriver, UINT wMessage, LPARAM lParam1, LPARAM lParam2)
{
    switch (wMessage)
    {
        case DRV_LOAD:
            dprintf2(("DRV_LOAD"));

            /*
               Sent to the driver when it is loaded. Always the first
               message received by a driver.

               dwDriverID is 0L.
               lParam1 is 0L.
               lParam2 is 0L.

               Return 0L to fail the load.

               DefDriverProc will return NON-ZERO so we don't have to
               handle DRV_LOAD
            */

            return 1L;

        case DRV_FREE:
            dprintf2(("DRV_FREE"));

            /*
               Sent to the driver when it is about to be discarded. This
               will always be the last message received by a driver before
               it is freed.

               dwDriverID is 0L.
               lParam1 is 0L.
               lParam2 is 0L.

               Return value is ignored.
            */

            return 1L;

        case DRV_OPEN:
            dprintf2(("DRV_OPEN"));

            /*
               Sent to the driver when it is opened.

               dwDriverID is 0L.

               lParam1 is a far pointer to a zero-terminated string
               containing the name used to open the driver.

               lParam2 is passed through from the drvOpen call.

               Return 0L to fail the open.

               DefDriverProc will return ZERO so we do have to
               handle the DRV_OPEN message.
             */

            return 1L;

        case DRV_CLOSE:
            dprintf2(("DRV_CLOSE"));

            /*
               Sent to the driver when it is closed. Drivers are unloaded
               when the close count reaches zero.

               dwDriverID is the driver identifier returned from the
               corresponding DRV_OPEN.

               lParam1 is passed through from the drvClose call.

               lParam2 is passed through from the drvClose call.

               Return 0L to fail the close.

               DefDriverProc will return ZERO so we do have to
               handle the DRV_CLOSE message.
            */

            return 1L;

        case DRV_ENABLE:
            dprintf2(("DRV_ENABLE"));

            /*
               Sent to the driver when the driver is loaded or reloaded
               and whenever Windows is enabled. Drivers should only
               hook interrupts or expect ANY part of the driver to be in
               memory between enable and disable messages

               dwDriverID is 0L.
               lParam1 is 0L.
               lParam2 is 0L.

               Return value is ignored.
            */

            return 1L;

        case DRV_DISABLE:
            dprintf2(("DRV_DISABLE"));

            /*
               Sent to the driver before the driver is freed.
               and whenever Windows is disabled

               dwDriverID is 0L.
               lParam1 is 0L.
               lParam2 is 0L.

               Return value is ignored.
            */

            return 1L;

       case DRV_QUERYCONFIGURE:
            dprintf2(("DRV_QUERYCONFIGURE"));

            /*
                Sent to the driver so that applications can
                determine whether the driver supports custom
                configuration. The driver should return a
                non-zero value to indicate that configuration
                is supported.

                dwDriverID is the value returned from the DRV_OPEN
                call that must have succeeded before this message
                was sent.

                lParam1 is passed from the app and is undefined.
                lParam2 is passed from the app and is undefined.

                Return 0L to indicate configuration NOT supported.
            */

            return 0L;        // we don't do configuration at the moment

        case DRV_CONFIGURE:
            dprintf2(("DRV_CONFIGURE"));

            /*
                Sent to the driver so that it can display a custom
                configuration dialog box.

                lParam1 is passed from the app. and should contain
                the parent window handle in the loword.
                lParam2 is passed from the app and is undefined.

                Return value is undefined.

                Drivers should create their own section in system.ini.
                The section name should be the driver name.
            */

            return 0L;

       case DRV_INSTALL:
            dprintf2(("DRV_INSTALL"));
            return DRVCNF_RESTART;

        default:
            return DefDriverProc(dwDriverID, hDriver, wMessage,lParam1,lParam2);
    }
}



#if DBG

int mmdrvDebugLevel = 1;

/***************************************************************************

    @doc INTERNAL

    @api void | mmdrvDbgOut | This function sends output to the current
        debug output device.

    @parm LPSTR | lpszFormat | Pointer to a printf style format string.
    @parm ??? | ... | Args.

    @rdesc There is no return value.

****************************************************************************/

void mmdrvDbgOut(LPSTR lpszFormat, ...)
{
    char buf[256];
    va_list va;

    OutputDebugStringA("MMDRV: ");

    va_start(va, lpszFormat);
    vsprintf(buf, lpszFormat, va);
    va_end(va);

    OutputDebugStringA(buf);
    OutputDebugStringA("\n");
}

/***************************************************************************

    @doc INTERNAL

    @api void | dDbgAssert | This function prints an assertion message.

    @parm LPSTR | exp | Pointer to the expression string.
    @parm LPSTR | file | Pointer to the file name.
    @parm int | line | The line number.

    @rdesc There is no return value.

****************************************************************************/

void dDbgAssert(LPSTR exp, LPSTR file, int line)
{
    dprintf1(("Assertion failure:"));
    dprintf1(("  Exp: %s", exp));
    dprintf1(("  File: %s, line: %d", file, line));
    DebugBreak();
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mmdrv\mmdrv.h ===
/****************************************************************************
 *
 *   mmdrv.h
 *
 *   Multimedia kernel driver support component (mmdrv)
 *
 *   Copyright (c) 1991-1998 Microsoft Corporation
 *
 *   Local declarations :
 *
 *   -- Debug
 *   -- Device types
 *   -- Routine prototypes
 *
 *   History
 *      01-Feb-1992 - Robin Speed (RobinSp) wrote it
 *
 ***************************************************************************/

/****************************************************************************

 General includes

 ***************************************************************************/

#define UNICODE
#ifndef RC_INVOKED

#include <string.h>
#include <stdio.h>

#endif /* RC_INVOKED */

#include <windows.h>
#include <mmsystem.h>
#include <devioctl.h>

#include <mmddk.h>

#if DBG
    #define STATIC
#else
    #define STATIC
#endif


/***************************************************************************

    DEBUGGING SUPPORT

 ***************************************************************************/


#if DBG

    #define DEBUG_RETAIL

    extern int mmdrvDebugLevel;
    extern void mmdrvDbgOut(LPSTR lpszFormat, ...);
    extern void dDbgAssert(LPSTR exp, LPSTR file, int line);

    DWORD __dwEval;

    #define dprintf( _x_ )                            mmdrvDbgOut _x_
    #define dprintf1( _x_ ) if (mmdrvDebugLevel >= 1) mmdrvDbgOut _x_
    #define dprintf2( _x_ ) if (mmdrvDebugLevel >= 2) mmdrvDbgOut _x_
    #define dprintf3( _x_ ) if (mmdrvDebugLevel >= 3) mmdrvDbgOut _x_
    #define dprintf4( _x_ ) if (mmdrvDebugLevel >= 4) mmdrvDbgOut _x_

    #define WinAssert(exp) \
        ((exp) ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__))
    #define WinEval(exp) \
        ((__dwEval=(DWORD)(exp)) ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__), __dwEval)

#else

	#define WinAssert(x) 0
	#define WinEval(exp) exp

    #define dprintf(x)
    #define dprintf1(x)
    #define dprintf2(x)
    #define dprintf3(x)
    #define dprintf4(x)

#endif

/****************************************************************************

 Device Types

 ***************************************************************************/
 enum {
     InvalidDevice,
     WaveInDevice,
     WaveOutDevice,
     MidiInDevice,
     MidiOutDevice,
     AuxDevice
 };

/****************************************************************************

  Our heap

****************************************************************************/

 HANDLE hHeap;

/****************************************************************************

  Our serialization

****************************************************************************/

 CRITICAL_SECTION mmDrvCritSec;  // Serialize access to device lists

/****************************************************************************

 Local routines

 ***************************************************************************/

DWORD    sndTranslateStatus(void);
MMRESULT sndOpenDev(UINT DeviceType, DWORD dwId,
                    PHANDLE phDev, DWORD Access);
DWORD    sndGetNumDevs(UINT DeviceType);
MMRESULT sndSetData(UINT DeviceType, UINT DeviceId, UINT Length, PBYTE Data,
                    ULONG Ioctl);
MMRESULT sndGetData(UINT DeviceType, UINT DeviceId, UINT Length, PBYTE Data,
                    ULONG Ioctl);

MMRESULT sndGetHandleData(HANDLE     hDev,
                          DWORD      dwSize,
                          PVOID      pData,
                          ULONG      Ioctl,
                          HANDLE     hEvent);

MMRESULT sndSetHandleData(HANDLE     hDev,
                          DWORD      dwSize,
                          PVOID      pData,
                          ULONG      Ioctl,
                          HANDLE     hEvent);

VOID     TerminateWave(VOID);
VOID     TerminateMidi(VOID);

/****************************************************************************

  Our local driver procs

****************************************************************************/

DWORD APIENTRY widMessage(DWORD, DWORD, DWORD_PTR, DWORD_PTR, DWORD_PTR);
DWORD APIENTRY wodMessage(DWORD, DWORD, DWORD_PTR, DWORD_PTR, DWORD_PTR);
DWORD APIENTRY midMessage(DWORD, DWORD, DWORD_PTR, DWORD_PTR, DWORD_PTR);
DWORD APIENTRY modMessage(DWORD, DWORD, DWORD_PTR, DWORD_PTR, DWORD_PTR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\mmdrv\wavedd.c ===
/****************************************************************************
 *
 *   wavedd.c
 *
 *   Multimedia kernel driver support component (mmdrv)
 *
 *   Copyright (c) 1991-1998 Microsoft Corporation
 *
 *   Driver for wave input and output devices
 *
 *   -- Wave driver entry points (wodMessage, widMessage)
 *   -- Auxiliary task (necessary for receiving Apcs and generating
 *      callbacks ASYNCRHONOUSLY)
 *   -- Interface to kernel driver (via DeviceIoControl)
 *
 *   Note that if any error occurs then the kernel device is closed
 *   and all subsequent calls requiring calls to the kernel device
 *   return error until the device is closed by the application.
 *
 *   History
 *      01-Feb-1992 - Robin Speed (RobinSp) wrote it
 *      04-Feb-1992 - SteveDav reviewed it
 *      08-Feb-1992 - RobinSp - Redesign to chop up caller's data.
 *                          Also does loops so we can remove them from the
 *                          kernel driver.
 *
 ***************************************************************************/

#include "mmdrv.h"
#include <ntddwave.h>

/*****************************************************************************

    internal declarations

 ****************************************************************************/

#define D1 dprintf1
#define D2 dprintf2
#define D3 dprintf3

// Stack size for our auxiliary task

#define WAVE_STACK_SIZE 300

typedef enum {
    WaveThreadInvalid,
    WaveThreadAddBuffer,
    WaveThreadSetState,
    WaveThreadSetData,
    WaveThreadGetData,
    WaveThreadBreakLoop,
    WaveThreadClose,
    WaveThreadTerminate
} WAVETHREADFUNCTION;


#define MAX_BUFFER_SIZE           8192  // Largest buffer we send to device
#define MAX_WAVE_BYTES          5*8192  // Max bytes we have queued on was 22000

//
// Structure to hide our overlapped structure in so we can get some
// context on IO completion
//

typedef struct {
    OVERLAPPED Ovl;
    LPWAVEHDR WaveHdr;
} WAVEOVL, *PWAVEOVL;

// per allocation structure for wave
typedef struct tag_WAVEALLOC {
    struct tag_WAVEALLOC *Next;         // Chaining
    UINT                DeviceNumber;   // Which device
    UINT                DeviceType;     // WaveInput or WaveOutput
    DWORD_PTR           dwCallback;     // client's callback
    DWORD_PTR           dwInstance;     // client's instance data
    DWORD               dwFlags;        // Open flags
    HWAVE               hWave;          // handle for stream

    HANDLE              hDev;           // Wave device handle
    LPWAVEHDR           DeviceQueue;    // Buffers queued by application
    LPWAVEHDR           NextBuffer;     // Next buffer to send to device
    DWORD               BufferPosition; // How far we're into a large buffer
    DWORD               BytesOutstanding;
                                        // Bytes being processed by device
    LPWAVEHDR           LoopHead;       // Start of loop if any
    DWORD               LoopCount;      // Number more loops to go

    WAVEOVL             DummyWaveOvl;   // For break loop
                                                                                //
    HANDLE              Event;          // Event for driver syncrhonization
                                        // and notification of auxiliary
                                        // task operation completion.
    WAVETHREADFUNCTION  AuxFunction;    // Function for thread to perform
    union {
        LPWAVEHDR       pHdr;           // Buffer to pass in aux task
        ULONG           State;          // State to set
        struct {
            ULONG       Function;       // IOCTL to use
            PBYTE       pData;          // Data to set or get
            ULONG       DataLen;        // Length of data
        } GetSetData;

    } AuxParam;
                                        // 0 means terminate task.
    HANDLE              AuxEvent1;      // Aux thread waits on this
    HANDLE              AuxEvent2;      // Caller of Aux thread waits on this
    HANDLE              ThreadHandle;   // Handle for thread termination ONLY
    MMRESULT            AuxReturnCode;  // Return code from Aux task
}WAVEALLOC, *PWAVEALLOC;

PWAVEALLOC WaveHandleList;              // Our chain of wave handles


//
// extra flag to track buffer completion
//

#define WHDR_COMPLETE 0x80000000

/*****************************************************************************

    internal function prototypes

 ****************************************************************************/

STATIC MMRESULT waveGetDevCaps(DWORD id, UINT DeviceType, LPBYTE lpCaps,
                            DWORD dwSize);
STATIC DWORD    waveThread(LPVOID lpParameter);
STATIC void     waveCleanUp(PWAVEALLOC pClient);
STATIC MMRESULT waveThreadCall(WAVETHREADFUNCTION Function, PWAVEALLOC pClient);
STATIC MMRESULT waveSetState(PWAVEALLOC pClient, ULONG State);
STATIC MMRESULT waveWrite(LPWAVEHDR pHdr, PWAVEALLOC pClient);
STATIC void     waveBlockFinished(LPWAVEHDR lpHdr, DWORD MsgId);
STATIC void     waveCallback(PWAVEALLOC pWave, DWORD msg, DWORD_PTR dw1);
STATIC void     waveCompleteBuffers(PWAVEALLOC pClient);
STATIC void     waveFreeQ(PWAVEALLOC pClient);
STATIC void     waveOvl(DWORD dwErrorCode, DWORD BytesTransferred, LPOVERLAPPED pOverlapped);

/* Attempt to pre-touch up to MIN(iSize,PRETOUCHLIMIT) bytes on from pb.
   If AllowFault then keep going to fault the stuff in.
   Otherwise stop as soon as you notice the clock ticking
*/
//PreTouch(BYTE * pb, int iSize, BOOL AllowFault)
//{
//    DWORD dwTicks = GetTickCount();
//    int pages = 0;
//    static int Headway[100];
//    static int c = 0;
//    static int TotalTouches = 0;
//    static int TimesThrough = 0;   // number of times this code has run.
//
//    if (iSize > PRETOUCHLIMIT) {
//        iSize = PRETOUCHLIMIT;
//    }
//
//    ++TimesThrough;
//
//    // pre-touch the pages but get out if it's taking too long
//    // (which probably means we took a page fault.
//    // Touch at least 2 pages as we may want 2 pages per DMA 1/2 buffer.
//    while (iSize>0) {
//        volatile BYTE b;
//        b = *pb;
//        pb += 4096;    // move to next page.  Are they ALWAYS 4096?
//        iSize -= 4096; // and count it off
//        ++pages;
//        ++TotalTouches;
//        if (dwTicks<GetTickCount() && pages>1 && !AllowFault) break;
//    }
//    Headway[c] = pages;
//    ++c;
//
//    if (c==100){
//        for (c=0; c<=99; c += 10){
//            dprintf(("%5ld %5ld %5ld %5ld %5ld %5ld %5ld %5ld %5ld %5ld",Headway[c],Headway[c+1],Headway[c+2],Headway[c+3],Headway[c+4],Headway[c+5],Headway[c+6],Headway[c+7],Headway[c+8],Headway[c+9]));
//        }
//        dprintf((" "));
//        c = 0;
//    }
//}


/****************************************************************************
 * @doc INTERNAL
 *
 * @api VOID | TerminateWave | Free all wave resources
 *
 * @rdesc None
 ***************************************************************************/
VOID TerminateWave(VOID)
{
#ifdef TERMINATE

    //
    // This is all wrong - we need to find out how to terminate threads !
    //

    PWAVEALLOC pClient;

    //
    // Remove all our threads and their resources
    //

    for (pClient = WaveHandleList; pClient != NULL; pClient = pClient->Next) {
        if (pClient->ThreadHandle) {
            //
            // Kill our thread.  But be careful !  It may
            // already have gone away - so don't wait for
            // it to set its event, just wait for it
            // to finish
            //

            //
            // Set the function code
            //
            pClient->AuxFunction = WaveThreadTerminate;

            //
            // Kick off the thread
            //
            SetEvent(pClient->AuxEvent1);

            //
            // We created our threads with mmTaskCreate so it's
            // safe to wait on them
            //
            WaitForSingleObject(pClient->ThreadHandle, INFINITE);
        }
        waveCleanUp(pClient);
    }
#endif
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api void | waveGetDevCaps | Get the device capabilities.
 *
 * @parm DWORD | id | Device id
 *
 * @parm UINT | DeviceType | type of device
 *
 * @parm LPBYTE | lpCaps | Far pointer to a WAVEOUTCAPS structure to
 *      receive the information.
 *
 * @parm DWORD | dwSize | Size of the WAVEOUTCAPS structure.
 *
 * @rdesc MMSYS.. return code.
 ***************************************************************************/
STATIC MMRESULT waveGetDevCaps(DWORD id, UINT DeviceType,
                            LPBYTE lpCaps, DWORD dwSize)
{
    return sndGetData(DeviceType, id, dwSize, lpCaps,
                      IOCTL_WAVE_GET_CAPABILITIES);
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api DWORD | waveGetPos | Get the stream position in samples.
 *
 * @parm PWAVEALLOC | pClient | Client handle.
 *
 * @parm LPMMTIME | lpmmt | Far pointer to an MMTIME structure.
 *
 * @parm DWORD | dwSize | Size of the MMTIME structure.
 *
 * @rdesc MMSYS... return value.
 ***************************************************************************/
MMRESULT waveGetPos(PWAVEALLOC pClient, LPMMTIME lpmmt, DWORD dwSize)
{
    WAVE_DD_POSITION PositionData;
    MMRESULT mErr;

    if (dwSize < sizeof(MMTIME))
        return MMSYSERR_ERROR;

    //
    // Get the current position from the driver
    //
    mErr = sndGetHandleData(pClient->hDev,
                            sizeof(PositionData),
                            &PositionData,
                            IOCTL_WAVE_GET_POSITION,
                            pClient->Event);

    if (mErr == MMSYSERR_NOERROR) {
        if (lpmmt->wType == TIME_BYTES) {
            lpmmt->u.cb = PositionData.ByteCount;
        }

        // default is samples.
        else {
            lpmmt->wType = TIME_SAMPLES;
            lpmmt->u.sample = PositionData.SampleCount;
        }
    }

    return mErr;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | waveOpen | Open wave device and set up logical device data
 *    and auxilary task for issuing requests and servicing Apc's
 *
 * @parm WAVEDEVTYPE | DeviceType | Whether it's a wave input or output device
 *
 * @parm DWORD | id | The device logical id
 *
 * @parm DWORD | msg | Input parameter to wodMessage
 *
 * @parm DWORD | dwUser | Input parameter to wodMessage - pointer to
 *   application's handle (generated by this routine)
 *
 * @parm DWORD | dwParam1 | Input parameter to wodMessage
 *
 * @parm DWORD | dwParam2 | Input parameter to wodMessage
 *
 * @rdesc wodMessage return cod