m OBJECT_NAME_NOT_FOUND)
                // means it does not exist and we can redirect this device.
                //
                // Create a symbolic link object to the device we are redirecting
                //
                if (!DefineDosDeviceW(
                        DDD_RAW_TARGET_PATH |
                        DDD_NO_BROADCAST_SYSTEM,
                        pLocalName,
                        ConnectionName.Buffer)) {
                    Status = GetLastError();
                } else {
                    Status = WN_SUCCESS;
                }
            }
        } else {

            //
            // QueryDosDevice successfully an existing symbolic link--
            // somebody is already using this device.
            //
            Status = ERROR_ALREADY_ASSIGNED;
        }
    } else {
        TRACE_ERROR(("OpenConnection returned %lx\n",Status));
        Status = RtlNtStatusToDosError(Status);
    }

    if (Status == WN_SUCCESS) {
        INT     Index;
        HANDLE  hMutex, hMemory;
        BOOLEAN FreeEntryFound = FALSE;

        PIFSMRXNP_SHARED_MEMORY  pSharedMemory;

        // The connection was established and the local device mapping
        // added. Include this in the list of mapped devices.

        Status = OpenSharedMemory(
                    &hMutex,
                    &hMemory,
                    (PVOID)&pSharedMemory);

        if (Status == WN_SUCCESS) {
            TRACE_INFO(("NPAddConnection3: Highest Index %d Number Of resources %d\n",
                        pSharedMemory->HighestIndexInUse,pSharedMemory->NumberOfResourcesInUse));

            Index = 0;

            while (Index < pSharedMemory->HighestIndexInUse) {
                if (!pSharedMemory->NetResources[Index].InUse) {
                    FreeEntryFound = TRUE;
                    break;
                }

                Index++;
            }

            if (!FreeEntryFound &&
                (pSharedMemory->HighestIndexInUse < IFSMRXNP_MAX_DEVICES)) {
                pSharedMemory->HighestIndexInUse += 1;
                Index = pSharedMemory->HighestIndexInUse;
                FreeEntryFound = TRUE;
            }

            if (FreeEntryFound) {
                PIFSMRXNP_NETRESOURCE pIfsMrxNetResource;

                pSharedMemory->NumberOfResourcesInUse += 1;

                pIfsMrxNetResource = &pSharedMemory->NetResources[Index];

                pIfsMrxNetResource->InUse = TRUE;

                pIfsMrxNetResource->dwScope = lpNetResource->dwScope;
                pIfsMrxNetResource->dwType = lpNetResource->dwType;
                pIfsMrxNetResource->dwDisplayType = lpNetResource->dwDisplayType;
                pIfsMrxNetResource->dwUsage = RESOURCEUSAGE_CONNECTABLE;

                pIfsMrxNetResource->LocalNameLength = LocalNameLength;
                pIfsMrxNetResource->RemoteNameLength = wcslen(lpNetResource->lpRemoteName) * sizeof(WCHAR);
                pIfsMrxNetResource->ConnectionNameLength = ConnectionName.Length;

                // Copy the local name
                RtlCopyMemory(
                    pIfsMrxNetResource->LocalName,
                    lpNetResource->lpLocalName,
                    pIfsMrxNetResource->LocalNameLength);

                // Copy the remote name
                RtlCopyMemory(
                    pIfsMrxNetResource->RemoteName,
                    lpNetResource->lpRemoteName,
                    pIfsMrxNetResource->RemoteNameLength);

                // Copy the connection name
                RtlCopyMemory(
                    pIfsMrxNetResource->ConnectionName,
                    ConnectionName.Buffer,
                    pIfsMrxNetResource->ConnectionNameLength);
            } else {
                Status = WN_NO_MORE_DEVICES;
            }

            CloseSharedMemory(
                &hMutex,
                &hMemory,
                (PVOID)&pSharedMemory);
        } else {
            TRACE_ERROR(("NpAddConnection3: OpenSharedMemory returned %lx\n",Status));
        }
    }

    if (ConnectionHandle != INVALID_HANDLE_VALUE) {
        NtClose(ConnectionHandle);
    }

    return(Status);
}

DWORD APIENTRY
NPCancelConnection(
    LPWSTR  lpName,
    BOOL    fForce )
/*++

Routine Description:

    This routine cancels ( deletes ) a connection from the list of connections
    associated with this network provider

Arguments:

    lpName - name of the connection

    fForce - forcefully delete the connection

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/

{
    BOOL    bLocalName = TRUE;
    DWORD   Status = 0;

    UNICODE_STRING Name;

    HANDLE  hMutex, hMemory;
    PIFSMRXNP_SHARED_MEMORY  pSharedMemory;

    if (*lpName == L'\\' && *(lpName + 1) == L'\\') {
        bLocalName = FALSE;
    }

    TRACE_CALL(("NPCancelConnection\n"));
    TRACE_INFO(("NPCancelConnection: ConnectionName: %S\n", lpName));

    Name.MaximumLength = Name.Length = wcslen(lpName) * sizeof(WCHAR);
    Name.Buffer = lpName;

    Status = OpenSharedMemory(
                &hMutex,
                &hMemory,
                (PVOID)&pSharedMemory);

    if (Status == WN_SUCCESS) {
        INT  Index;
        BOOL EntryFound = FALSE;
        PIFSMRXNP_NETRESOURCE pNetResource;

        TRACE_INFO(("NPCancelConnection: Highest Index %d Number Of resources %d\n",
                    pSharedMemory->HighestIndexInUse,pSharedMemory->NumberOfResourcesInUse));

        for (Index = 0; Index <= pSharedMemory->HighestIndexInUse; Index++) {
            pNetResource = &pSharedMemory->NetResources[Index];

            if (pNetResource->InUse) {
                UNICODE_STRING EntryName;

                if (bLocalName) {
                    EntryName.MaximumLength = pNetResource->LocalNameLength;
                    EntryName.Length = EntryName.MaximumLength;
                    EntryName.Buffer = pNetResource->LocalName;
                } else {
                    EntryName.MaximumLength = pNetResource->RemoteNameLength;
                    EntryName.Length = EntryName.MaximumLength;
                    EntryName.Buffer = pNetResource->RemoteName;
                }


                TRACE_INFO(("NPCancelConnection: Name %S EntryName %S\n",
                            lpName,EntryName.Buffer));
                TRACE_INFO(("NPCancelConnection: Name Length %d Entry Name Length %d\n",
                           Name.Length,EntryName.Length));

                if (Name.Length == EntryName.Length) {
                    if (RtlEqualUnicodeString(
                            &Name,
                            &EntryName,
                            TRUE)) {
                        EntryFound = TRUE;
                        break;
                    }
                }
            }
        }

        if (EntryFound) {
            HANDLE          ConnectionHandle;
            IO_STATUS_BLOCK IoStatusBlock;
            UNICODE_STRING ConnectionName;

            TRACE_INFO(("NPCancelConnection: Connection Found:\n"));

            ConnectionName.Length = pNetResource->ConnectionNameLength;
            ConnectionName.MaximumLength = ConnectionName.Length;
            ConnectionName.Buffer = pNetResource->ConnectionName;

            Status = OpenConnection(
                         &ConnectionName,
                         FILE_OPEN,
                         NULL,
                         0,
                         &ConnectionHandle);

            if (Status == WN_SUCCESS) {
                Status = NtFsControlFile(
                             ConnectionHandle,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             FSCTL_IFSMRX_DELETE_CONNECTION,
                             NULL,
                             0,
                             NULL,
                             0);

                NtClose(ConnectionHandle);

                TRACE_ERROR(("NPCancelConnection: NtFsControlFile returned Status %lx\n",Status));

                if (bLocalName) {
                    if (DefineDosDevice(
                            DDD_REMOVE_DEFINITION | DDD_RAW_TARGET_PATH | DDD_EXACT_MATCH_ON_REMOVE,
                            lpName,
                            pNetResource->ConnectionName) == FALSE) {
                        TRACE_ERROR(("RemoveDosDevice:  DefineDosDevice error: %d\n", GetLastError()));
                        Status = GetLastError();
                    } else {
                        pNetResource->InUse = FALSE;

                        if (Index == pSharedMemory->HighestIndexInUse) {
                            pSharedMemory->HighestIndexInUse -= 1;
                            pSharedMemory->NumberOfResourcesInUse -= 1;
                        }

                    }
                } else {
                    Status = RtlNtStatusToDosError(Status);
                }
            } else {
                TRACE_ERROR(("NPCancelConnection: OpenConnection returned Status %lx\n",Status));
            }
        } else {
            Status = WN_BAD_NETNAME;
        }

        CloseSharedMemory(
            &hMutex,
            &hMemory,
            (PVOID)&pSharedMemory);
    }

    return(Status);
}

DWORD APIENTRY
NPGetConnection(
    LPWSTR  lpLocalName,
    LPWSTR  lpRemoteName,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the information associated with a connection

Arguments:

    lpLocalName - local name associated with the connection

    lpRemoteName - the remote name associated with the connection

    lpBufferSize - the remote name buffer size

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
    DWORD   Status = 0;

    UNICODE_STRING Name;

    HANDLE  hMutex, hMemory;
    PIFSMRXNP_SHARED_MEMORY  pSharedMemory;

    Name.MaximumLength = Name.Length = wcslen(lpLocalName) * sizeof(WCHAR);
    Name.Buffer = lpLocalName;

    Status = OpenSharedMemory(
                &hMutex,
                &hMemory,
                (PVOID)&pSharedMemory);

    if (Status == WN_SUCCESS) {
        INT  Index;
        BOOL EntryFound = FALSE;
        PIFSMRXNP_NETRESOURCE pNetResource;

        for (Index = 0; Index <= pSharedMemory->HighestIndexInUse; Index++) {
            pNetResource = &pSharedMemory->NetResources[Index];

            if (pNetResource->InUse) {
                UNICODE_STRING EntryName;

                EntryName.MaximumLength = pNetResource->LocalNameLength;
                EntryName.Length = EntryName.MaximumLength;
                EntryName.Buffer = pNetResource->LocalName;

                if (Name.Length == EntryName.Length) {
                    if (RtlEqualUnicodeString(
                            &Name,
                            &EntryName,
                            TRUE)) {
                        EntryFound = TRUE;
                        break;
                    }
                }
            }
        }

        if (EntryFound) {
            if (*lpBufferSize < pNetResource->RemoteNameLength) {
                *lpBufferSize = pNetResource->RemoteNameLength;
                Status = ERROR_BUFFER_OVERFLOW;
            } else {
                *lpBufferSize = pNetResource->RemoteNameLength;
                RtlCopyMemory(
                    lpRemoteName,
                    pNetResource->RemoteName,
                    pNetResource->RemoteNameLength);
                Status = WN_SUCCESS;
            }
        } else {
            Status = ERROR_NO_NET_OR_BAD_PATH;
        }

        CloseSharedMemory(
            &hMutex,
            &hMemory,
            (PVOID)&pSharedMemory);
    }

    return(Status);
}

DWORD APIENTRY
NPGetResourceParent(
    LPNETRESOURCE   lpNetResource,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the parent of a given resource

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpBuffer - the buffer for passing back the parent information

    lpBufferSize - the buffer size

Return Value:

    WN_NOT_SUPPORTED

Notes:

    The current sample does not handle this call.

--*/
{
    return(WN_NOT_SUPPORTED);
}

DWORD APIENTRY
NPGetResourceInformation(
    LPNETRESOURCE   lpNetResource,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize,
    LPWSTR  *lplpSystem )
/*++

Routine Description:

    This routine returns the information associated net resource

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpBuffer - the buffer for passing back the parent information

    lpBufferSize - the buffer size

    lplpSystem -

Return Value:

Notes:

--*/
{
    DWORD dwStatus = 0;
    LPNETRESOURCE   pOutNetResource;
    TRACE_CALL(("NPGetResourceInformation\n"));
    return(dwStatus);
}

DWORD APIENTRY
NPGetUniversalName(
    LPCWSTR lpLocalPath,
    DWORD   dwInfoLevel,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the information associated net resource

Arguments:

    lpLocalPath - the local path name

    dwInfoLevel  - the desired info level

    lpBuffer - the buffer for the univeral name

    lpBufferSize - the buffer size

Return Value:

    WN_SUCCESS if successful

Notes:

--*/
{
    DWORD   dwStatus;

    DWORD   BufferRequired = 0;
    DWORD   UniversalNameLength = 0;
    DWORD   RemoteNameLength = 0;
    DWORD   RemainingPathLength = 0;

    LPWSTR  pDriveLetter,
            pRemainingPath,
            SourceStrings[3];

    WCHAR   RemoteName[MAX_PATH],
            LocalPath[MAX_PATH],
            UniversalName[MAX_PATH],
            ReplacedChar;

    TRACE_CALL(("NPGetUniversalName: lpLocalPath: %S  InfoLevel: %d\n", lpLocalPath, dwInfoLevel));

    if (dwInfoLevel != UNIVERSAL_NAME_INFO_LEVEL &&
        dwInfoLevel != REMOTE_NAME_INFO_LEVEL) {
        TRACE_ERROR(("NPGetUniversalName:  bad dwInfoLevel value: %d\n", dwInfoLevel));
        return(WN_BAD_LEVEL);
    }

    wcscpy(LocalPath, lpLocalPath);
    pDriveLetter = LocalPath;
    if (pRemainingPath = wcschr(pDriveLetter, L':')) {
        ReplacedChar = *(++pRemainingPath);
        *pRemainingPath = L'\0';

    }

    if ((dwStatus = NPGetConnection(pDriveLetter, RemoteName, &RemoteNameLength)) != WN_SUCCESS) {
        TRACE_ERROR(("NPGetUniversalName:  NPGetConnection return dwStatus: %d\n", dwStatus));
        return(dwStatus);
    }

    if (pRemainingPath) {
        *pRemainingPath = ReplacedChar;
    }

    TRACE_INFO(("NPGetUniversalName: pRemainingPath: %S  RemoteName: %S\n", pRemainingPath, RemoteName));

    wcscpy(UniversalName, RemoteName);

    if (pRemainingPath)
        wcscat(UniversalName, pRemainingPath);

    TRACE_INFO(("NPGetUniversalName: UniversalName: %S\n", UniversalName));

    // Determine if the provided buffer is large enough.
    UniversalNameLength = (wcslen(UniversalName) + 1) * sizeof(WCHAR);
    BufferRequired = UniversalNameLength;

    if (dwInfoLevel == UNIVERSAL_NAME_INFO_LEVEL) {
        BufferRequired += sizeof(UNIVERSAL_NAME_INFO);
    }
    else {
        RemoteNameLength = (wcslen(RemoteName) + 1) * sizeof(WCHAR);
        BufferRequired += sizeof(REMOTE_NAME_INFO) + RemoteNameLength;
        if (pRemainingPath) {
            RemainingPathLength = (wcslen(pRemainingPath) + 1) * sizeof(WCHAR);
            BufferRequired += RemainingPathLength;
        }
    }

    if (*lpBufferSize < BufferRequired) {
        TRACE_ERROR(("NPGetUniversalName: WN_MORE_DATA BufferRequired: %d\n", BufferRequired));
        *lpBufferSize = BufferRequired;
        return(WN_MORE_DATA);
    }

    if (dwInfoLevel == UNIVERSAL_NAME_INFO_LEVEL) {
        LPUNIVERSAL_NAME_INFOW pUniversalNameInfo;

        pUniversalNameInfo = (LPUNIVERSAL_NAME_INFOW)lpBuffer;

        pUniversalNameInfo->lpUniversalName = (PWCHAR)((PBYTE)lpBuffer + sizeof(UNIVERSAL_NAME_INFOW));

        RtlCopyMemory(
            pUniversalNameInfo->lpUniversalName,
            UniversalName,
            UniversalNameLength);
    } else {
        LPREMOTE_NAME_INFOW pRemoteNameInfo;

        pRemoteNameInfo = (LPREMOTE_NAME_INFOW)lpBuffer;

        pRemoteNameInfo->lpUniversalName = (PWCHAR)((PBYTE)lpBuffer + sizeof(REMOTE_NAME_INFOW));
        pRemoteNameInfo->lpConnectionName = pRemoteNameInfo->lpUniversalName + UniversalNameLength;
        pRemoteNameInfo->lpRemainingPath = pRemoteNameInfo->lpConnectionName + RemoteNameLength;

        RtlCopyMemory(
            pRemoteNameInfo->lpUniversalName,
            UniversalName,
            UniversalNameLength);

        RtlCopyMemory(
            pRemoteNameInfo->lpConnectionName,
            RemoteName,
            RemoteNameLength);

        RtlCopyMemory(
            pRemoteNameInfo->lpRemainingPath,
            pRemainingPath,
            RemainingPathLength);
    }

    TRACE_CALL(("NPGetUniversalName: WN_SUCCESS\n"));
    return(WN_SUCCESS);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\devfcb.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    devfcb.c

Abstract:

    This module implements the mechanism for deleting an established connection

--*/

#include "precomp.h"
#pragma hdrstop
#include "fsctlbuf.h"

//
//  The local trace mask for this part of the module
//

#define Dbg (DEBUG_TRACE_DEVFCB)


NTSTATUS
MRxIfsDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine handles all the device FCB related FSCTL's in the mini rdr

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    a valid NTSTATUS code.

Notes:

--*/
{
    NTSTATUS Status;
    RxCaptureFobx;
    UCHAR MajorFunctionCode  = RxContext->MajorFunction;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    ULONG ControlCode = LowIoContext->ParamsFor.FsCtl.FsControlCode;

    RxDbgTrace(+1, Dbg, ("MRxIfsDevFcb\n"));
    switch (MajorFunctionCode) {
    case IRP_MJ_FILE_SYSTEM_CONTROL:
        {
            switch (LowIoContext->ParamsFor.FsCtl.MinorFunction) {
            case IRP_MN_USER_FS_REQUEST:
                switch (ControlCode) {
                case FSCTL_IFSMRX_START:
                    {
                        DbgPrint("Processing Start FSCTL\n");
                        Status = RxStartMinirdr(
                                     RxContext,
                                     &RxContext->PostRequest);


                        if (Status == STATUS_SUCCESS) {
                            MRXIFS_STATE State;

                            State = (MRXIFS_STATE)InterlockedCompareExchange(
                                         (PVOID *)&MRxIfsState,
                                         (PVOID)MRXIFS_STARTED,
                                         (PVOID)MRXIFS_STARTABLE);

                            if (State != MRXIFS_STARTABLE) {
                                Status = STATUS_REDIRECTOR_STARTED;
                            }
                        }

                        DbgPrint("Completed Processing Start FSCTL Status %lx\n",Status);
                    }
                    break;


                case FSCTL_IFSMRX_STOP:
                    {
                        DbgPrint("Processing Stop FSCTL\n");

                        ASSERT (!capFobx);
                        Status = RxStopMinirdr( RxContext, &RxContext->PostRequest );

                        DbgPrint("Completed Processing Stop FSCTL Status %lx\n",Status);
                    }
                    break;

                case FSCTL_IFSMRX_DELETE_CONNECTION:
                    ASSERT (capFobx);
                    Status = MRxIfsDeleteConnection( RxContext, &RxContext->PostRequest );
                    break;

                default:
                    Status = STATUS_INVALID_DEVICE_REQUEST;
                }
                break;
            default :  //minor function != IRP_MN_USER_FS_REQUEST
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
        } // FSCTL case
        break;
    case IRP_MJ_DEVICE_CONTROL:
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        {
            switch (ControlCode) {
            default :
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
        }
        break;
    default:
        ASSERT(!"unimplemented major function");
        Status = STATUS_INVALID_DEVICE_REQUEST;

    }

    RxDbgTrace(-1, Dbg, ("MRxIfsDevFcb st,info=%08lx,%08lx\n",
                            Status,RxContext->InformationToReturn));
    return(Status);

}


NTSTATUS
MRxIfsDeleteConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:

    This routine deletes a single vnetroot.

Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context....for later when i need the buffers

Return Value:

RXSTATUS

--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    RxCaptureFobx;

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PNET_ROOT NetRoot;
    PV_NET_ROOT VNetRoot;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxIfsDeleteConnection Fobx %08lx\n", capFobx));

    if (!Wait) {
        //just post right now!
        *PostToFsp = TRUE;
        return(STATUS_PENDING);
    }

    try {

        if (NodeType(capFobx)==RDBSS_NTC_V_NETROOT) {
            VNetRoot = (PV_NET_ROOT)capFobx;
            NetRoot = (PNET_ROOT)VNetRoot->NetRoot;
        } else {
            ASSERT(FALSE);
            try_return(Status = STATUS_INVALID_DEVICE_REQUEST);
            NetRoot = (PNET_ROOT)capFobx;
            VNetRoot = NULL;
        }

        Status = RxFinalizeConnection(NetRoot,VNetRoot,TRUE);

        try_return(Status);

try_exit:NOTHING;

    } finally {
        //DebugTrace(-1, Dbg, NU LL, 0);
        RxDbgTraceUnIndent(-1,Dbg);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\downlvli.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DownLvlI.c

Abstract:

    This module implements downlevel fileinfo, volinfo, and dirctrl.


--*/

#include "precomp.h"
#pragma hdrstop

////
////  The Bug check file id for this module
////
//
//#define BugCheckFileId                   (RDBSS_BUG_CHECK_LOCAL_CREATE)

//#undef Dbg
#define Dbg        (DEBUG_TRACE_VOLINFO)

//#define FORCE_CORE_GETATTRIBUTES
#ifndef FORCE_CORE_GETATTRIBUTES
#define MRxSmbForceCoreGetAttributes FALSE
#else
BOOLEAN MRxSmbForceCoreGetAttributes = TRUE;
#endif

NTSTATUS
SmbPseExchangeStart_CoreInfo(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

// these structures are used for t2_query_fs_info
typedef
struct _QFS_INFO {
    ULONG ulVSN;
    UCHAR cch;
    CHAR szVolLabel[12];   //not unicode
} QFS_INFO, *PQFS_INFO;
#define ACTUAL_QFS_INFO_LENGTH (FIELD_OFFSET(QFS_INFO,szVolLabel[12]))

typedef
struct _QFS_ALLOCATE {
    ULONG ulReserved;
    ULONG cSectorUnit;
    ULONG cUnit;
    ULONG cUnitAvail;
    USHORT cbSector;
} QFS_ALLOCATE, *PQFS_ALLOCATE;
#define ACTUAL_QFS_ALLOCATE_LENGTH (FIELD_OFFSET(QFS_ALLOCATE,cbSector)+sizeof(((PQFS_ALLOCATE)0)->cbSector))

//++
//
// VOID
// NAME_LENGTH(
//     OUT ULONG Length,
//     IN PUCHAR Ptr
//     )
//
// Routine Description:
//
//  Determines the length of a Core filename returned by search. This
//  is normally a NULL terminated string less than MAXIMUM_COMPONENT_CORE.
//  In some cases this is Non-null teminated and space filled.
//
// Arguments:
//
//     Length   -   Returns the string length
//     Ptr      -   The filename to be measured
//
// Return Value:
//
//     None.
//
//--
#define NAME_LENGTH( Length, Ptr, Max ) {                         \
    Length = 0;                                                   \
    while( ((PCHAR)Ptr)[Length] != '\0' ) {                       \
         Length++;                                                \
         if ( Length == Max ) {                                   \
             break;                                               \
         }                                                        \
    }                                                             \
    while( ((PCHAR)Ptr)[Length-1] == ' ' && Length ) {            \
        Length--;                                                 \
    }                                                             \
}
MRxSmbSetDeleteDisposition(
      IN PRX_CONTEXT            RxContext
      );

typedef struct __NativeFs_Name_Entry {
    UCHAR Last;
    UCHAR MaximumComponentNameLength;
    UCHAR FileSystemAttributes;
    UCHAR NameLength;
    PWCHAR  Name;
};
struct __NativeFs_Name_Entry NativeFsNameTable[] = {
    {0,12,0,sizeof(L"FAT")-sizeof(WCHAR),L"FAT"},
    {0,254,FILE_CASE_PRESERVED_NAMES,sizeof(L"HPFS")-sizeof(WCHAR),L"HPFS"},
    {1,254,FILE_CASE_PRESERVED_NAMES,sizeof(L"HPFS386")-sizeof(WCHAR),L"HPFS386"}
    };

NTSTATUS
MRxSmbFabricateAttributesOnNetRoot(
    IN OUT PSMBCE_NET_ROOT psmbNetRoot
    )
/*++

Routine Description:

   This routine uses information stored in the netroot structure to hallucinate the attributes
   of the netroot. it may be that the ascii representation of the filesystem name has already been
   stored in the netroot. If so, expeand it out.....otherwise, it must be FAT.

Arguments:


Return Value:

    NTSTATUS - STATUS_SUCCESS

--*/
{
    NTSTATUS StringStatus;
    WCHAR FileSystemNameBuffer[SMB_MAXIMUM_SUPPORTED_VOLUME_LABEL+1]; //must leave room for the null
    UNICODE_STRING FileSystemNameU;
    OEM_STRING FileSystemNameA;
    UCHAR FileSystemNameALength;

    ASSERT (psmbNetRoot->MaximumComponentNameLength==0);

    FileSystemNameALength = psmbNetRoot->FileSystemNameALength;
    if (FileSystemNameALength == 0) {
        //must be Fat!
        FileSystemNameALength = 3;
        psmbNetRoot->FileSystemNameA[0] = 'F';
        psmbNetRoot->FileSystemNameA[1] = 'A';
        psmbNetRoot->FileSystemNameA[2] = 'T';
    }

    //now, translate the name to Unicode.......

    FileSystemNameA.Length = FileSystemNameALength;
    FileSystemNameA.MaximumLength = FileSystemNameALength;
    FileSystemNameA.Buffer = &psmbNetRoot->FileSystemNameA[0];
    FileSystemNameU.Length = 0;
    FileSystemNameU.MaximumLength = (USHORT)sizeof(FileSystemNameBuffer);
    FileSystemNameU.Buffer = &FileSystemNameBuffer[0];
    StringStatus = RtlOemStringToUnicodeString(&FileSystemNameU, &FileSystemNameA, FALSE);
    ASSERT(StringStatus==STATUS_SUCCESS);

    //copy back the name

    RtlCopyMemory(&psmbNetRoot->FileSystemName[0],FileSystemNameU.Buffer,FileSystemNameU.Length);
    psmbNetRoot->FileSystemNameLength = FileSystemNameU.Length;
    if (FALSE) DbgPrint("NativeFs in unicode %wZ (%d/%d) on netroot %08lx\n",
               &FileSystemNameU,FileSystemNameU.Length,FileSystemNameU.MaximumLength,psmbNetRoot);
    {   struct __NativeFs_Name_Entry *i;
       for (i=NativeFsNameTable;;i++) {
           UCHAR NameLength = i->NameLength;
           if (RtlCompareMemory(&FileSystemNameBuffer[0],
                                i->Name,
                                NameLength) == NameLength) {
              psmbNetRoot->MaximumComponentNameLength = i->MaximumComponentNameLength;
              psmbNetRoot->FileSystemAttributes = i->FileSystemAttributes;
              if (FALSE) {
                  UNICODE_STRING u;
                  u.Buffer = i->Name;
                  u.Length = i->NameLength;
                  DbgPrint("FoundNativeFsStrng %wZ len %d for %d %d\n",&u,i->NameLength,
                                       i->MaximumComponentNameLength,i->FileSystemAttributes);
              }
              break;
           }
           if (i->Last) {

               psmbNetRoot->MaximumComponentNameLength = 255;
               psmbNetRoot->FileSystemAttributes = 0;
               break;
           }
       }
    }



    return(STATUS_SUCCESS);
}

NTSTATUS
MRxSmbCoreInformation(
      IN OUT PRX_CONTEXT          RxContext,
      IN     ULONG                InformationClass,
      IN OUT PVOID                pBuffer,
      IN OUT PULONG               pBufferLength,
      IN     SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint
      )
/*++

Routine Description:

   This routine does a core level getinfo (vol or fileinfo) a file across the network

Arguments:

    RxContext - the RDBSS context
    InformationClass - a class variable that is specific to the call. sometimes it's a SMB class; sometimes
                       an NT class.
    pBuffer - pointer to the user's buffer
    pBufferLength - a pointer to a ulong containing the bufferlength that is updated as we go;
                    if it's a setinfo then we deref and place the actual bufferlength in the OE.

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING RemainingName;
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("MRxSmbDownLevelQueryInformation\n", 0 ));  //0 instead of +1.....the general entrypoint already inc'd

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    //some stuff is early out. catch them here even before we initialize the stufferstate

    switch (EntryPoint) {
    case SMBPSE_OE_FROM_QUERYVOLUMEINFO:
        switch (InformationClass) {
        case FileFsVolumeInformation:
        case FileFsSizeInformation:
            break; //these are actually implemented on the wire
        case FileFsAttributeInformation: {
            ULONG FileSystemNameLength,LengthNeeded;

            PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
            PSMBCE_NET_ROOT psmbNetRoot;

            pNetRootEntry = SmbCeReferenceAssociatedNetRootEntry(capFcb->pNetRoot);
            if (pNetRootEntry == NULL) {
                Status = STATUS_INVALID_PARAMETER;
                goto FINALLY;
            }

            psmbNetRoot = &pNetRootEntry->NetRoot;

            if (psmbNetRoot->MaximumComponentNameLength==0) {
                MRxSmbFabricateAttributesOnNetRoot(psmbNetRoot);
            }

            FileSystemNameLength = psmbNetRoot->FileSystemNameLength;
            LengthNeeded = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName)+FileSystemNameLength;

            if (*pBufferLength < LengthNeeded) {
                Status = STATUS_BUFFER_OVERFLOW;
                SmbCeDereferenceNetRootEntry(pNetRootEntry);
                goto FINALLY;
            }

            {
                PFILE_FS_ATTRIBUTE_INFORMATION pTypedBuffer = (PFILE_FS_ATTRIBUTE_INFORMATION)pBuffer;

                pTypedBuffer->MaximumComponentNameLength = psmbNetRoot->MaximumComponentNameLength;
                pTypedBuffer->FileSystemAttributes = psmbNetRoot->FileSystemAttributes;
                pTypedBuffer->FileSystemNameLength = FileSystemNameLength;

                RtlCopyMemory(pTypedBuffer->FileSystemName, psmbNetRoot->FileSystemName, FileSystemNameLength);
                *pBufferLength -= LengthNeeded;
            }

            SmbCeDereferenceNetRootEntry(pNetRootEntry);
            goto FINALLY;
            }
            //no break needed because of gotofinally
        case FileFsDeviceInformation:
            ASSERT(!"this should have been turned away");
            //no break;
        default:
            Status = STATUS_NOT_IMPLEMENTED;
            goto FINALLY;
        }
        break;
    case SMBPSE_OE_FROM_QUERYFILEINFO:
        //notice that the designators are smb_query_info types
        switch (InformationClass) {
        case SMB_QUERY_FILE_BASIC_INFO:

            if (smbSrvOpen->RxContextSerialNumber == RxContext->SerialNumber) {
                *((PFILE_BASIC_INFORMATION)pBuffer) = smbSrvOpen->FileInfo.Basic;
                *pBufferLength -= sizeof(FILE_BASIC_INFORMATION);
                goto FINALLY;
            }
            break;
        case SMB_QUERY_FILE_STANDARD_INFO:
            if (smbSrvOpen->RxContextSerialNumber == RxContext->SerialNumber) {
                *((PFILE_STANDARD_INFORMATION)pBuffer) = smbSrvOpen->FileInfo.Standard;
                *pBufferLength -= sizeof(FILE_STANDARD_INFORMATION);
                goto FINALLY;
            }
            break;
        case SMB_QUERY_FILE_EA_INFO:
            //downlevel guys have no EAs....turn this backright here
            ((PFILE_EA_INFORMATION)pBuffer)->EaSize = 0;
            *pBufferLength -= sizeof(FILE_EA_INFORMATION);
            goto FINALLY;
        default:
            Status = STATUS_NOT_IMPLEMENTED;
            goto FINALLY;
        }
        break;
    case SMBPSE_OE_FROM_SETFILEINFO:
        switch (InformationClass) {
        case FileBasicInformation:
        case FileEndOfFileInformation:
            //these go thru to the wire
            break;
        case FileDispositionInformation:
            Status = MRxSmbSetDeleteDisposition(RxContext);
            goto FINALLY;
        case FileRenameInformation:
            Status = MRxIfsRename(RxContext,InformationClass,pBuffer,*pBufferLength);
            goto FINALLY;
        default:
            Status = STATUS_NOT_IMPLEMENTED;
            goto FINALLY;
        }
        break;
    case SMBPSE_OE_FROM_EXTENDFILEFORCACHEING:
    case SMBPSE_OE_FROM_QUERYDIRECTORY:
        break;
   }


    OrdinaryExchange = SmbPseCreateOrdinaryExchange(RxContext,
                                                    SrvOpen->pVNetRoot,
                                                    EntryPoint,
                                                    SmbPseExchangeStart_CoreInfo
                                                    );
    if (OrdinaryExchange==NULL) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    OrdinaryExchange->Info.Buffer = pBuffer;
    OrdinaryExchange->Info.pBufferLength = pBufferLength;
    OrdinaryExchange->Info.InfoClass = InformationClass;

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status != STATUS_PENDING); //async was turned away at the top level


    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbDownLevelQueryInformation  exit with status=%08lx\n", Status ));
    return(Status);
}

UNICODE_STRING MRxSmbAll8dot3Files = {sizeof(L"????????.???")-sizeof(WCHAR),sizeof(L"????????.???"),L"????????.???"};

#if DBG
#include "stdarg.h"
#include "stdio.h"
#include "string.h"
VOID
MRxSmbDumpResumeKey(
    PSZ             text,
    PSMB_RESUME_KEY ResumeKey
    )
{
    PBYTE rk = (PBYTE)ResumeKey;
    CHAR Buffer[80];
    PCHAR b;
    ULONG i;


    for (i=0,b=Buffer;i<sizeof(SMB_RESUME_KEY);i++,b+=2) {
        RxSprintf(b,"%02lx  ",rk[i]);
        if (i==0) b+=2;
        if (i==11) b+=2;
        if (i==16) b+=2;
    }

    RxDbgTrace(0, Dbg, ("%s  rk(%08lx)=%s\n", text, ResumeKey, Buffer));
}
#else
#define MRxSmbDumpResumeKey(x,y)
#endif


NTSTATUS
MRxSmbLoadCoreFileSearchBuffer(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a CORE_SMB_SEARCH and leaves the result in the SMBbuf.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SMB_FOBX smbFobx = MRxIfsGetFileObjectExtension(capFobx);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;
    PSMB_HEADER SmbHeader;

    BOOLEAN FindFirst;
    UNICODE_STRING FindFirstPattern;
    USHORT ResumeKeyLength;
    ULONG ReturnCount;
    BOOLEAN EndOfSearchReached;
    // SearchAttributes is hardcoded to the magic number 0x16
    ULONG SearchAttributes =
            (SMB_FILE_ATTRIBUTE_DIRECTORY
                | SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN);
    PULONG pCountRemainingInSmbbuf = &OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf;

    RxDbgTrace(+1, Dbg, ("MRxSmbLoadCoreFileSearchBuffer entering.......OE=%08lx\n",OrdinaryExchange));
    RxDbgTrace( 0, Dbg, (".......smbFobx/resumekey=%08lx/%08lx\n",smbFobx,smbFobx->Enumeration.CoreResumeKey));

    if (!FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST)) {

        PUNICODE_STRING DirectoryName = &capFcb->AlreadyPrefixedName;
        PUNICODE_STRING Template = &capFobx->UnicodeQueryTemplate;
        ULONG DirectoryNameLength,TemplateLength,AllocationLength;
        PBYTE SmbFileName;

        //this is the first time thru....the stuffer cannot handle the intricate logic here so we
        //will have to preallocate for the name

        if (smbFobx->Enumeration.WildCardsFound = FsRtlDoesNameContainWildCards(Template)){
            // we will need to have an upcased template for compares; we do this in place
            RtlUpcaseUnicodeString( Template, Template, FALSE );

            Template = &MRxSmbAll8dot3Files; //we will have to filter on this side
        }
        DirectoryNameLength = DirectoryName->Length;
        TemplateLength = Template->Length;
        AllocationLength = sizeof(WCHAR)  // backslash separator
                            +DirectoryNameLength
                            +TemplateLength;
        RxDbgTrace(0, Dbg, ("  --> d/t/dl/tl/al <%wZ><%wZ>%08lx/%08lx/%08lx!\n",
                      DirectoryName,Template,
                      DirectoryNameLength,TemplateLength,AllocationLength));

        FindFirstPattern.Buffer = (PWCHAR)RxAllocatePoolWithTag( PagedPool,AllocationLength,'0SxR');
        if (FindFirstPattern.Buffer==NULL) {
            RxDbgTrace(0, Dbg, ("  --> Couldn't get the findfind pattern buffer!\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }

        SmbFileName = (PBYTE)FindFirstPattern.Buffer;
        RtlCopyMemory(SmbFileName,DirectoryName->Buffer,DirectoryNameLength);
        SmbFileName += DirectoryNameLength;
        if (*((PWCHAR)(SmbFileName-sizeof(WCHAR))) != L'\\') {
            *((PWCHAR)SmbFileName) = L'\\'; SmbFileName+= sizeof(WCHAR);
        }
        RtlCopyMemory(SmbFileName,Template->Buffer,TemplateLength);
        SmbFileName += TemplateLength;
        if ((TemplateLength == sizeof(WCHAR)) && (Template->Buffer[0]==DOS_STAR)) {
            *((PWCHAR)SmbFileName) = L'.'; SmbFileName+= sizeof(WCHAR);
            *((PWCHAR)SmbFileName) = L'*'; SmbFileName+= sizeof(WCHAR);
        }
        FindFirstPattern.Length = (USHORT)(SmbFileName - (PBYTE)FindFirstPattern.Buffer);
        RxDbgTrace(0, Dbg, ("  --> find1stpattern <%wZ>!\n",&FindFirstPattern));
        FindFirst = TRUE;
        ResumeKeyLength = 0;

    } else {

        RxDbgTrace(0, Dbg, ("-->FINDNEXT\n"));
        FindFirstPattern.Buffer = NULL;
        if (!FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS)) {
            Status = smbFobx->Enumeration.ErrorStatus;
            RxDbgTrace(0, Dbg, ("-->ERROR EARLY OUT\n"));
            goto FINALLY;
        }
        FindFirst = FALSE;
        FindFirstPattern.Length = 0;
        ResumeKeyLength = sizeof(SMB_RESUME_KEY);
        MRxSmbDumpResumeKey("FindNext:",smbFobx->Enumeration.CoreResumeKey);

    }

    //get the correct return count. there are three factors: countremaining from the OE,
    //     how many could fit the the user's buffer, and how many could fit in a negotiated buffer.
    //     we pick the smallest of the three except that we never go for less than 10 unless 10 won't
    //     fit in the smbbuf.
    ReturnCount = OrdinaryExchange->Info.CoreSearch.CountRemaining;

    { ULONG t = (*OrdinaryExchange->Info.pBufferLength) / smbFobx->Enumeration.FileNameOffset;
        if (t<ReturnCount) { ReturnCount = t; }
    }

    if (ReturnCount<10) { ReturnCount = 10; }

    { PSMBCE_SERVER pServer = &OrdinaryExchange->SmbCeContext.pServerEntry->Server;
      ULONG AvailableBufferSize = pServer->MaximumBufferSize -
                                      (sizeof(SMB_HEADER) +
                                         FIELD_OFFSET(RESP_SEARCH,Buffer[0])
                                         +sizeof(UCHAR)+sizeof(USHORT)       //bufferformat,datalength fields
                                      );
      ULONG t = AvailableBufferSize / sizeof(SMB_DIRECTORY_INFORMATION);
      if (t<ReturnCount) { ReturnCount = t; }
    }
    RxDbgTrace( 0, Dbg, ("-------->count=%08lx\n",ReturnCount));
    if (ReturnCount==0) {
        Status = STATUS_MORE_PROCESSING_REQUIRED;
        RxDbgTrace(0, Dbg, ("-->Count==0 EARLY OUT\n"));
        goto FINALLY;
    }

    StufferState = &OrdinaryExchange->AssociatedStufferState;
    ASSERT( StufferState );

    *pCountRemainingInSmbbuf = 0;
    OrdinaryExchange->Info.CoreSearch.NextDirInfo = NULL;

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,
                                          SMB_COM_SEARCH, SMB_REQUEST_SIZE(SEARCH),
                                          NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                          0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    RxDbgTrace(0, Dbg,("core search command initial status = %lu\n",Status));

    MRxSmbStuffSMB (StufferState,
         "0wwB4ywc!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
               ReturnCount,         //  w         _USHORT( MaxCount );                // Number of dir. entries to return
               SearchAttributes,    //  w         _USHORT( SearchAttributes );
               SMB_WCT_CHECK(2)     //  B         _USHORT( ByteCount );               // Count of data bytes; min = 5
                                    //            UCHAR Buffer[1];                    // Buffer containing:
               &FindFirstPattern,   //  4        //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name, may be null
               0x05,                //  y         //UCHAR BufferFormat2;              //  0x05 -- Variable block
               ResumeKeyLength,     //  w         //USHORT ResumeKeyLength;           //  Length of resume key, may be 0
                                    //  c         //UCHAR SearchStatus[];             //  Resume key
               ResumeKeyLength,smbFobx->Enumeration.CoreResumeKey
             );




    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORESEARCH
                                    );

    if (!NT_SUCCESS(Status)) goto FINALLY;

    smbFobx->Enumeration.Flags |= SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST|SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS;
    if (Status== STATUS_SUCCESS && *pCountRemainingInSmbbuf==0) {
         RxDbgTrace( 0, Dbg, ("MRxSmbLoadCoreFileSearchBuffer: no files returned...switch status\n"));
         EndOfSearchReached = TRUE;
         Status = STATUS_NO_MORE_FILES;
    } else {
         EndOfSearchReached = FALSE;
    }
    if (EndOfSearchReached) {
        RxDbgTrace( 0, Dbg, ("MRxSmbLoadCoreFileSearchBuffer: no longer in progress...EOS\n"));
        smbFobx->Enumeration.Flags &= ~SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS;
        smbFobx->Enumeration.ErrorStatus = STATUS_NO_MORE_FILES;
    }
    //we dont save a resume key here since each individual copy operation will have to do that


FINALLY:
    if (FindFirstPattern.Buffer != NULL) {
        RxFreePool(FindFirstPattern.Buffer);
    }
    if (!NT_SUCCESS(Status)&&(Status!= STATUS_MORE_PROCESSING_REQUIRED)) {
        RxDbgTrace( 0, Dbg, ("MRxSmbCoreFileSearch: Failed .. returning %lx\n",Status));
        smbFobx->Enumeration.Flags &= ~SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS;
        smbFobx->Enumeration.ErrorStatus = Status;  //keep returning this
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbLoadCoreFileSearchBuffer exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


#define ASSERT_SAME_FIELD(__field,__t1,__t2) { \
      ASSERT(FIELD_OFFSET(__t1,__field)==FIELD_OFFSET(__t2,__field)); \
      }

#define ASSERT_SAME_DIRINFO_FIELDS(__t1,__t2) {\
      ASSERT_SAME_FIELD(LastWriteTime,__t1,__t2); \
      ASSERT_SAME_FIELD(EndOfFile,__t1,__t2); \
      ASSERT_SAME_FIELD(AllocationSize,__t1,__t2); \
      ASSERT_SAME_FIELD(FileAttributes,__t1,__t2); \
      }
#if DBG
VOID MRxSmbCoreFileSeach_AssertFields(void){
    //just move this out of the main execution path so that we don't have to look at it while
    //we Uing the code
    ASSERT_SAME_DIRINFO_FIELDS(FILE_DIRECTORY_INFORMATION,FILE_FULL_DIR_INFORMATION);
    ASSERT_SAME_DIRINFO_FIELDS(FILE_DIRECTORY_INFORMATION,FILE_BOTH_DIR_INFORMATION);
    ASSERT_SAME_DIRINFO_FIELDS(FILE_DIRECTORY_INFORMATION,FILE_OLE_DIR_INFORMATION);
}
#else
#define MRxSmbCoreFileSeach_AssertFields()
#endif

NTSTATUS
MRxSmbCoreFileSearch(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SMB_FOBX smbFobx = MRxIfsGetFileObjectExtension(capFobx);

    PBYTE pBuffer = OrdinaryExchange->Info.Buffer;
    PULONG pLengthRemaining = OrdinaryExchange->Info.pBufferLength;
    ULONG InformationClass = OrdinaryExchange->Info.InfoClass;

    PFILE_DIRECTORY_INFORMATION pPreviousBuffer = NULL;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    ULONG SuccessCount = 0;

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreFileSearch entering.......OE=%08lx\n",OrdinaryExchange));
    MRxSmbCoreFileSeach_AssertFields();

    OrdinaryExchange->Info.CoreSearch.CountRemaining =
              RxContext->QueryDirectory.ReturnSingleEntry?1:0x7ffffff;

    if ( (smbFobx->Enumeration.CoreResumeKey ==NULL )
             && ((smbFobx->Enumeration.CoreResumeKey = RxAllocatePoolWithTag(PagedPool,sizeof(SMB_RESUME_KEY),'rbms'))==NULL) ){
        RxDbgTrace(0, Dbg, ("...couldn't allocate resume key\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }
    RxDbgTrace( 0, Dbg, (".......smbFobx/resumekey=%08lx/%08lx\n",smbFobx,smbFobx->Enumeration.CoreResumeKey));

    Status = MRxSmbLoadCoreFileSearchBuffer( SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS );

    for (;;) {
        BOOLEAN BufferOverflow = FALSE;
        PSMB_DIRECTORY_INFORMATION NextDirInfo;
        UNICODE_STRING FileNameU;
        OEM_STRING FileNameA;
        WCHAR FileNameU_buffer[14];
        ULONG NameLength;
        PBYTE NextFileName;
        BOOLEAN Match,BufferOverFlow;

        if (!NT_SUCCESS(Status)) {
            if (Status = STATUS_NO_MORE_FILES) {
                if (SuccessCount > 0) {
                    Status = STATUS_SUCCESS;
                }
            } else if (Status = STATUS_MORE_PROCESSING_REQUIRED) {
                if (SuccessCount > 0) {
                    Status = STATUS_SUCCESS;
                } else {
                    Status = STATUS_BUFFER_OVERFLOW;
                }
            }

            goto FINALLY;
        }
        ASSERT ( OrdinaryExchange->Info.CoreSearch.CountRemaining>0 );
        ASSERT ( OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf>0 );
        RxDbgTrace(0, Dbg, ("MRxSmbCoreFileSearch looptopcheck counts=%08lx,%08lx\n",
                    OrdinaryExchange->Info.CoreSearch.CountRemaining,
                    OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf
                    ));

        //next issue: does the next dirinfo match the criteria?!?

        NextDirInfo = OrdinaryExchange->Info.CoreSearch.NextDirInfo;
        NextFileName = &NextDirInfo->FileName[0];

        // According to colinw, some core servers do not remember to insert the null at the end of the name...
        // but the namelength macro handles this correctly. some servers (Xenix, apparently) pad the
        // names with spaces. again, the macro handles it....
        //

        NAME_LENGTH(NameLength, NextFileName,sizeof(NextDirInfo->FileName));

        FileNameA.Length = (USHORT)NameLength;
        FileNameA.MaximumLength = (USHORT)NameLength;
        FileNameA.Buffer = NextFileName;
        FileNameU.Length = sizeof(FileNameU_buffer);
        FileNameU.MaximumLength = sizeof(FileNameU_buffer);
        FileNameU.Buffer = &FileNameU_buffer[0];

        Status = RtlOemStringToUnicodeString(&FileNameU, &FileNameA, TRUE);
        RxDbgTrace(0, Dbg, ("MRxSmbCoreFileSearch considering.......filename=%wZ, template=%wZ\n",
                                    &FileNameU,&capFobx->UnicodeQueryTemplate));

        ASSERT(Status == STATUS_SUCCESS);

        // we deal with a conversion failure by skipping this guy
        Match = (Status == STATUS_SUCCESS);
        if (Match && smbFobx->Enumeration.WildCardsFound ) {
            //DbgBreakPoint();
            Match = FsRtlIsNameInExpression( &capFobx->UnicodeQueryTemplate,
                                                      &FileNameU, TRUE, NULL );
        }

        //next issue: will the next dirinfo fit in the user's buffer?!?
        if (Match) {
            ULONG SpaceNeeded;
            PBYTE pRememberBuffer = pBuffer;
            //QuadAlign!! pBuffer = (PBYTE)LongAlign(pBuffer); //assume that this will fit
            if (SuccessCount != 0) {
                pBuffer = (PBYTE)QuadAlign(pBuffer); //assume that this will fit
            }
            SpaceNeeded = smbFobx->Enumeration.FileNameOffset+FileNameU.Length;
            if (pBuffer+SpaceNeeded > pRememberBuffer+*pLengthRemaining) {
                BufferOverflow = TRUE;
                pBuffer = pRememberBuffer; //rollback
            } else {
                PFILE_DIRECTORY_INFORMATION pThisBuffer = (PFILE_DIRECTORY_INFORMATION)pBuffer;
                SMB_TIME Time;
                SMB_DATE Date;
                PSMBCE_SERVER Server = &Exchange->SmbCeContext.pServerEntry->Server;
                BufferOverflow = FALSE;
                if (pPreviousBuffer != NULL) {
                    pPreviousBuffer->NextEntryOffset = ((PBYTE)pThisBuffer)-((PBYTE)pPreviousBuffer);
                }
                pPreviousBuffer = pThisBuffer;
                RtlZeroMemory(pBuffer,smbFobx->Enumeration.FileNameOffset);
                RtlCopyMemory(pBuffer+smbFobx->Enumeration.FileNameOffset, FileNameU.Buffer,FileNameU.Length);
                *((PULONG)(pBuffer+smbFobx->Enumeration.FileNameLengthOffset)) = FileNameU.Length;
                //hallucinate the record based on specific return type
                switch (InformationClass) {
                case SMB_FIND_FILE_NAMES_INFO:
                    break;
                case SMB_FIND_FILE_DIRECTORY_INFO:
                case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
                case SMB_FIND_FILE_BOTH_DIRECTORY_INFO:
                    //just fill what we have...we do not go to a lot of trouble on allocinfo as rdr1 did.
                    //     actually, rdr1 didn't do that here...only on getfielinfo.......
                    SmbMoveTime (&Time, &NextDirInfo->LastWriteTime);
                    SmbMoveDate (&Date, &NextDirInfo->LastWriteDate);
                    pThisBuffer->LastWriteTime = MRxSmbConvertSmbTimeToTime(Server, Time, Date);
                    pThisBuffer->EndOfFile.LowPart = SmbGetUlong(&NextDirInfo->FileSize);
                    pThisBuffer->FileAttributes = MRxSmbMapSmbAttributes (NextDirInfo->FileAttributes);
                    break;
                default:
                   RxDbgTrace( 0, Dbg, ("MRxSmbCoreFileSearch: Invalid FS information class\n"));
                   ASSERT(!"this can't happen");
                   Status = STATUS_INVALID_PARAMETER;
                   goto FINALLY;
                }
                pBuffer += SpaceNeeded;
                *pLengthRemaining -= pBuffer-pRememberBuffer;
                OrdinaryExchange->Info.CoreSearch.CountRemaining--;
                SuccessCount++;
            }
        }

        //
        // if no match or no overflow, move up in the buffer. this means not only juggling the
        // pointers but also saving the resume key

        if (!Match || !BufferOverflow) {
            MRxSmbDumpResumeKey("BufferKey:",&NextDirInfo->ResumeKey);
            *(smbFobx->Enumeration.CoreResumeKey) = NextDirInfo->ResumeKey;
            MRxSmbDumpResumeKey("SaveKey:  ",smbFobx->Enumeration.CoreResumeKey);
            OrdinaryExchange->Info.CoreSearch.NextDirInfo = NextDirInfo + 1;
            OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf--;
        }

        if (OrdinaryExchange->Info.CoreSearch.CountRemaining==0) {
            Status = STATUS_SUCCESS;
            goto FINALLY;
        }


        if (BufferOverflow) {
            Status = (SuccessCount==0)? STATUS_BUFFER_OVERFLOW : STATUS_SUCCESS;
            goto FINALLY;
        }

        if (OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf==0) {

            Status = MRxSmbLoadCoreFileSearchBuffer( SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS );

        }

    }


FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreFileSearch exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));

    return(Status);
}

NTSTATUS
MrxSmbOemVolumeInfoToUnicode(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG *VolumeLabelLengthReturned
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:


Return Value:

    NTSTATUS - The return status for the operation
    also VolumeLabelLengthReturned is the number of bytes of the label that were stored, if any.

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING VolumeLabelU;
    OEM_STRING VolumeLabelA;
    SMB_DIRECTORY_INFORMATION Buffer;
    ULONG NameLength;
    ULONG BytesToCopy;
    PBYTE VolumeLabel = &OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0];


    NAME_LENGTH(NameLength, VolumeLabel,
               sizeof(OrdinaryExchange->Info.QFSVolInfo.CoreLabel));

    VolumeLabelA.Length = (USHORT)NameLength;
    VolumeLabelA.MaximumLength = (USHORT)NameLength;
    VolumeLabelA.Buffer = VolumeLabel;

    //some core servers put a '.' in the labelname.....if it's there then remove it
    if ((NameLength>8)&& (VolumeLabel[8]=='.') ) {
        ULONG i;
        for (i=8;i<NameLength;i++) {
            VolumeLabel[i] = VolumeLabel[i+1];
        }
    }

    Status = RtlOemStringToUnicodeString(&VolumeLabelU, &VolumeLabelA, TRUE);

    if (NT_SUCCESS(Status)) {

        PULONG pBufferLength = OrdinaryExchange->Info.pBufferLength;
        PFILE_FS_VOLUME_INFORMATION pBuffer = OrdinaryExchange->Info.Buffer;
        ULONG BytesToCopy = min((ULONG)VolumeLabelU.Length, (*pBufferLength-sizeof(FILE_FS_VOLUME_INFORMATION)));

        RtlCopyMemory(&pBuffer->VolumeLabel[0],
                      VolumeLabelU.Buffer,
                      BytesToCopy);

        *VolumeLabelLengthReturned = BytesToCopy;
        pBuffer->VolumeLabelLength = VolumeLabelU.Length;
        IF_DEBUG {
            UNICODE_STRING FinalLabel;
            FinalLabel.Buffer = &pBuffer->VolumeLabel[0];
            FinalLabel.Length = (USHORT)BytesToCopy;
            RxDbgTrace(0, Dbg, ("MrxSmbOemVolumeInfoToUnicode vollabel=%wZ\n",&FinalLabel));
        }

        RtlFreeUnicodeString(&VolumeLabelU);
    }

    return(Status);
}




MrxSmbCoreQueryFsVolumeInfo(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    RxDbgTrace(+1, Dbg, ("MrxSmbCoreQueryFsVolumeInfo entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_SEARCH,
                                SMB_REQUEST_SIZE(SEARCH),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );


    MRxSmbStuffSMB (StufferState,
         "0wwB4yw!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
               1,                   //  w         _USHORT( MaxCount );                // Number of dir. entries to return
                                    //  w         _USHORT( SearchAttributes );
               SMB_FILE_ATTRIBUTE_VOLUME,
               SMB_WCT_CHECK(2)     //  B         _USHORT( ByteCount );               // Count of data bytes; min = 5
                                    //            UCHAR Buffer[1];                    // Buffer containing:
               &MRxSmbAll8dot3Files,//  4         //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                    //           //UCHAR FileName[];                 //  File name, may be null
               0x05,                //  y         //UCHAR BufferFormat2;              //  0x05 -- Variable block
               0                    //  w         //USHORT ResumeKeyLength;           //  Length of resume key, may be 0
                                    //            //UCHAR SearchStatus[];             //  Resume key
             );



    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_COREQUERYLABEL
                                    );


FINALLY:
    RxDbgTrace(-1, Dbg, ("MrxSmbCoreQueryFsVolumeInfo exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MrxSmbQueryFsVolumeInfo(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a downlevel getvolumeinfo/FS_VOLUME_INFORMATION.

Arguments:

    OrdinaryExchange  - duh!

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;


    REQ_QUERY_FS_INFORMATION VolInfo;

    PFILE_FS_VOLUME_INFORMATION pBuffer = OrdinaryExchange->Info.Buffer;
    PULONG pBufferLength = OrdinaryExchange->Info.pBufferLength;

    ULONG VolumeLabelLengthReturned = 0;

    ASSERT(pBuffer!=NULL);

    RxDbgTrace(+1, Dbg, ("MrxSmbQueryFsVolumeInfo entering.......OE=%08lx\n",OrdinaryExchange));


    pBuffer->SupportsObjects = FALSE;
    pBuffer->VolumeCreationTime.LowPart = 0;
    pBuffer->VolumeCreationTime.HighPart = 0;
    pBuffer->VolumeSerialNumber = 0;
    pBuffer->VolumeLabelLength = 0;

    OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0] = 0; //no label

    Status =  MrxSmbCoreQueryFsVolumeInfo(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);

    ASSERT ( *pBufferLength>=sizeof(FILE_FS_VOLUME_INFORMATION));

    RxDbgTrace(0, Dbg, ("MrxSmbQueryFsVolumeInfo OEstatus=%08lx\n",Status));

    if (NT_SUCCESS(Status) &&
        (OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0] != 0) ) {

        Status = MrxSmbOemVolumeInfoToUnicode(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,&VolumeLabelLengthReturned);

    } else if (Status == STATUS_NO_SUCH_FILE) {
        //
        //  If we got no such file, this means that there's no volume label
        //  the remote volume.  Return success with no data.
        //

        Status = STATUS_SUCCESS;

    }

    if (NT_SUCCESS(Status)) {
        *pBufferLength -= FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION,VolumeLabel);
        *pBufferLength -= VolumeLabelLengthReturned;
    }


    RxDbgTrace(-1, Dbg, ("MrxSmbQueryFsVolumeInfo exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MrxSmbCoreQueryDiskAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetDiskAttributes and remembers the reponse in a buffer pointed to
   by the exchange. this is called from the downlevel queryvolumeinfo AND ALSO from
   extend-for-cached-write.

Arguments:

    OrdinaryExchange

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    ASSERT(OrdinaryExchange->Info.Buffer!=NULL);

    RxDbgTrace(+1, Dbg, ("MrxSmbCoreQueryDiskAttributes entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_QUERY_INFORMATION_DISK,
                                SMB_REQUEST_SIZE(QUERY_INFORMATION_DISK),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    RxDbgTrace(0, Dbg,("querydiskattribs command initial status = %lu\n",Status));

    MRxSmbStuffSMB (StufferState,
         "0B!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 0
               SMB_WCT_CHECK(0) 0   //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );


    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_COREQUERYDISKATTRIBUTES
                                    );
FINALLY:
    RxDbgTrace(-1, Dbg, ("MrxSmbCoreQueryDiskAttributes exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MrxSmbQueryDiskAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetDiskAttributes and remembers the reponse in a buffer pointed to
   by the exchange. this is called from the downlevel queryvolumeinfo AND ALSO from
   extend-for-cached-write.

Arguments:

    OrdinaryExchange

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;
    REQ_QUERY_FS_INFORMATION VolInfo;

    ASSERT(OrdinaryExchange->Info.Buffer!=NULL);


    return MrxSmbCoreQueryDiskAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);


}

NTSTATUS
MRxSmbGetFileAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );



NTSTATUS
SmbPseExchangeStart_CoreInfo(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for VOLINFO.

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    ULONG InformationClass = OrdinaryExchange->Info.InfoClass;
    PBYTE pBuffer = (PBYTE)OrdinaryExchange->Info.Buffer;
    PULONG pBufferLength = OrdinaryExchange->Info.pBufferLength;

    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_CoreInfo\n", 0 ));

    ASSERT_ORDINARY_EXCHANGE(OrdinaryExchange);

    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));


    switch (OrdinaryExchange->EntryPoint) {
    case SMBPSE_OE_FROM_QUERYVOLUMEINFO:
        switch (InformationClass) {
        case FileFsVolumeInformation:
            Status = MrxSmbQueryFsVolumeInfo(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
            goto FINALLY;
        case FileFsSizeInformation:
            Status = MrxSmbQueryDiskAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
            goto FINALLY;
        default:
            ASSERT(!"this should have been turned away");
            goto FINALLY;
         }
         ASSERT(!"shouldn't get here1");
         goto FINALLY;
    case SMBPSE_OE_FROM_QUERYFILEINFO:
        Status = MRxSmbGetFileAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
        if (!NT_SUCCESS(Status)) goto FINALLY;
        switch (InformationClass) {
        case SMB_QUERY_FILE_BASIC_INFO:
            *((PFILE_BASIC_INFORMATION)pBuffer) = OrdinaryExchange->Create.FileInfo.Basic;
            *pBufferLength -= sizeof(FILE_BASIC_INFORMATION);
            goto FINALLY;
        case SMB_QUERY_FILE_STANDARD_INFO:
            *((PFILE_STANDARD_INFORMATION)pBuffer) = OrdinaryExchange->Create.FileInfo.Standard;
            *pBufferLength -= sizeof(FILE_STANDARD_INFORMATION);
            goto FINALLY;
        default:
            ASSERT(!"this should have been turned away");
            goto FINALLY;
         }
        ASSERT(!"shouldn't get here2");
        goto FINALLY;
    case SMBPSE_OE_FROM_SETFILEINFO:
        switch (InformationClass) {
        case FileBasicInformation:{
            ULONG LastWriteTimeInSeconds;
            BOOLEAN GoodTime = MRxSmbTimeToSecondsSince1970( &(((PFILE_BASIC_INFORMATION)pBuffer)->LastWriteTime),
                                                             MRxSmbExchangeToServer(OrdinaryExchange),
                                                             &LastWriteTimeInSeconds
                                                             );
            if (GoodTime) {
                ULONG SmbAttributes = MRxSmbMapFileAttributes(((PFILE_BASIC_INFORMATION)pBuffer)->FileAttributes);
                Status = MRxSmbSetFileAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                                   SmbAttributes, LastWriteTimeInSeconds);
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }}
            goto FINALLY;
        case FileEndOfFileInformation:
            if (((PFILE_END_OF_FILE_INFORMATION)pBuffer)->EndOfFile.HighPart) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
                Status = MRxSmbCoreTruncate(
                                  SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                  smbSrvOpen->Fid,
                                  ((PFILE_END_OF_FILE_INFORMATION)pBuffer)->EndOfFile.LowPart);
            }

            goto FINALLY;
        default:
            ASSERT(!"this should have been turned away");
            goto FINALLY;
        }
        ASSERT(!"shouldn't get here3");
        goto FINALLY;
    case SMBPSE_OE_FROM_QUERYDIRECTORY:
        Status = MRxSmbCoreFileSearch(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
        goto FINALLY;
    case SMBPSE_OE_FROM_EXTENDFILEFORCACHEING:{
        PSMBCE_NET_ROOT psmbNetRoot = &OrdinaryExchange->SmbCeContext.pNetRootEntry->NetRoot;
        PMRX_NET_ROOT pNetRoot = OrdinaryExchange->SmbCeContext.pNetRootEntry->pRdbssNetRoot;
        PSMBCE_SERVER psmbServer = &OrdinaryExchange->SmbCeContext.pServerEntry->Server;
        ULONG ClusterSize;
        PLARGE_INTEGER pFileSize = (PLARGE_INTEGER)(OrdinaryExchange->Info.Buffer);
        PLARGE_INTEGER pAllocationSize = (PLARGE_INTEGER)(OrdinaryExchange->Info.pBufferLength);

        //we will need the cluster size
        if (OrdinaryExchange->ServerVersion==pNetRoot->ParameterValidationStamp) {

            ClusterSize=pNetRoot->DiskParameters.ClusterSize;

        } else {

            RxSynchronizeBlockingOperations(RxContext,&psmbNetRoot->ClusterSizeSerializationQueue);
            if (OrdinaryExchange->ServerVersion!=pNetRoot->ParameterValidationStamp) {
                NTSTATUS LocalStatus;
                FILE_FS_SIZE_INFORMATION UsersBuffer;
                ULONG BufferLength = sizeof(FILE_FS_SIZE_INFORMATION);
                //fill in the exchange params so that we can get the params we need
                OrdinaryExchange->Info.Buffer = &UsersBuffer;
                OrdinaryExchange->Info.pBufferLength = &BufferLength;
                LocalStatus = MrxSmbQueryDiskAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
                if (LocalStatus == STATUS_SUCCESS) {
                    ClusterSize = UsersBuffer.BytesPerSector * UsersBuffer.SectorsPerAllocationUnit;
                    pNetRoot->ParameterValidationStamp =OrdinaryExchange->ServerVersion;
                } else {
                    ClusterSize = 0;
                }
                if (ClusterSize==0) {
                    ClusterSize = 1;
                }
                pNetRoot->DiskParameters.ClusterSize = ClusterSize;
                RxDbgTrace(0, Dbg, ("clustersize set to %08lx\n", ClusterSize ));

            }
            RxResumeBlockedOperations_Serially(RxContext,&psmbNetRoot->ClusterSizeSerializationQueue);
        }

        ASSERT (ClusterSize != 0);

        {

            ULONG FileSize,AllocationSize;
            FileSize = pFileSize->LowPart;
            COVERED_CALL(MRxSmbCoreTruncate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                            smbSrvOpen->Fid, FileSize
                                            ));
            //this is what you do if you can't do better
            AllocationSize = (FileSize+ClusterSize)&~(ClusterSize-1);
            pAllocationSize->QuadPart = AllocationSize; //64bit!
            RxDbgTrace(0, Dbg, ("alocatedsize set to %08lx\n", pAllocationSize->LowPart ));
        }


        }
        goto FINALLY;
    }


FINALLY:
    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_CoreInfo exit w %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbFinishSearch (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_SEARCH                Response
      )
/*++

Routine Description:

    This routine actually gets the stuff out of the VolInfo response and finishes the close.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);


    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishSearch\n" ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishSearch:");

    ASSERT( (Response->WordCount==1));
    //ASSERT( (SmbGetUshort(&Response->ByteCount)==0));

    if (OrdinaryExchange->OEType == SMBPSE_OETYPE_COREQUERYLABEL) {
        //here, all we do is to copy the label to wherever is pointed to by
        if (SmbGetUshort(&Response->Count)>0) {
            PBYTE smbDirInfotmp = &Response->Buffer[0]
                                        +sizeof(UCHAR) //bufferformat
                                        +sizeof(USHORT); //datalength
            PSMB_DIRECTORY_INFORMATION smbDirInfo = (PSMB_DIRECTORY_INFORMATION)smbDirInfotmp;
            //PBYTE VolumeLabel = &smbDirInfo->FileName[0];
            RxDbgTrace(+1, Dbg, ("MRxSmbFinishSearch corelabl=%s,size=%d\n",
                                     smbDirInfo->FileName, sizeof(smbDirInfo->FileName) ));
            ASSERT ( sizeof(smbDirInfo->FileName) == 13 ); //straightfrom the spec
            RtlCopyMemory(OrdinaryExchange->Info.QFSVolInfo.CoreLabel,
                          smbDirInfo->FileName, sizeof(smbDirInfo->FileName)
                         );
        } else {
            OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0] = 0; //no label
        }
    } else if (OrdinaryExchange->OEType == SMBPSE_OETYPE_CORESEARCHFORCHECKEMPTY) {
        //here, we 're doing a search SMB to see if the directory is empty. we have to read thru the
        // entries returned (if successful). if we encounter ones that are neither '.' or '..',  set
        // resumekey to null since that will tell the guy above that the directory is nonempty
        ULONG Count = SmbGetUshort(&Response->Count);
        PSMB_DIRECTORY_INFORMATION NextDirInfo =
               (PSMB_DIRECTORY_INFORMATION)(&Response->Buffer[0]+sizeof(UCHAR)+sizeof(USHORT));

        for (;Count>0;Count--,NextDirInfo++) {
            RxDbgTrace(0, Dbg, ("--->emptydirchk: file=%s\n",&NextDirInfo->FileName[0]));
            if (NextDirInfo->FileName[0]=='.') {
                CHAR c1;
                if ((c1=NextDirInfo->FileName[1])==0) {
                    continue; //skip past "."
                } else if ((c1=='.')&&(NextDirInfo->FileName[2]==0)) {
                    continue; //skip past ".."
                } else {
                    NOTHING;
                }
            }
            // here we have found a bad one...make sure there's no resume key and change the status
            Status = STATUS_NO_MORE_FILES;
            OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey = NULL;
        }
        //if we get here with success, set up the resume key and buffer
        if (Status == STATUS_SUCCESS) {
            NextDirInfo--;
            OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKeyBuffer =
                                    NextDirInfo->ResumeKey;
            OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey =
                                    &OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKeyBuffer;
        }
    } else {
        //all that we do here is to setup the nextdirptr and the count in the OE
        ASSERT(OrdinaryExchange->OEType == SMBPSE_OETYPE_CORESEARCH);
        OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf = SmbGetUshort(&Response->Count);
        OrdinaryExchange->Info.CoreSearch.NextDirInfo =
               (PSMB_DIRECTORY_INFORMATION)(&Response->Buffer[0]+sizeof(UCHAR)+sizeof(USHORT));
        IF_DEBUG {
            ULONG tcount = OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf;
            PSMB_DIRECTORY_INFORMATION ndi = OrdinaryExchange->Info.CoreSearch.NextDirInfo;
            RxDbgTrace(0, Dbg, ("--->coresearch: count/ndi=%08lx/%08lx\n",tcount,ndi));
            if (tcount) {

                RxDbgTrace(0, Dbg, ("--->coresearch: firstfile=%s\n",&ndi->FileName[0]));
            }
        }
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishSearch   returning %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbFinishQueryDiskInfo (
      PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
      PRESP_QUERY_INFORMATION_DISK Response
      )
/*++

Routine Description:

    This routine actually gets the stuff out of the VolInfo response and finishes the close.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_FS_SIZE_INFORMATION UsersBuffer = OrdinaryExchange->Info.Buffer;
    PULONG BufferLength = OrdinaryExchange->Info.pBufferLength;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishQueryDiskInfo\n" ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishQueryDiskInfo:");


    IF_DEBUG{
        PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
        RxCaptureFobx;
        PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
        PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);
        ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    }

    ASSERT( (Response->WordCount==5));
    ASSERT( (SmbGetUshort(&Response->ByteCount)==0));

    UsersBuffer->TotalAllocationUnits.QuadPart = SmbGetUshort(&Response->TotalUnits);
    UsersBuffer->AvailableAllocationUnits.QuadPart = SmbGetUshort(&Response->FreeUnits);
    UsersBuffer->SectorsPerAllocationUnit = SmbGetUshort(&Response->BlocksPerUnit);
    UsersBuffer->BytesPerSector = SmbGetUshort(&Response->BlockSize);

    *BufferLength -= sizeof(FILE_FS_SIZE_INFORMATION);

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishQueryDiskInfo   returning %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxIfsExtendFile(
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    )
/*++

Routine Description:

   This routine handles network requests to extend the file for cached IO. we just share the
   core_info skeleton.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb; RxCaptureFobx;

    PMRXIFS_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    PSMB_EXCHANGE Exchange;

    PAGED_CODE();

    if (capFcb->Attributes & FILE_ATTRIBUTE_COMPRESSED) {
        //here, we just get out since disk reservations don't do us any good....
        pNewAllocationSize->QuadPart = (pNewFileSize->QuadPart)<<2;
        return(Status);
    }

    RxDbgTrace(+1, Dbg, ("MRxSmbExtendFile %08lx %08lx %08lx %08lx\n",
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->LowPart
               ));

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );
    if (FALSE) {
        DbgPrint("Extend top  %08lx %08lx %08lx %08lx\n",
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->LowPart);
    }

    //we just pass in our info into MRxSmbCoreInformation thru the existing pointers....
    //we have two pointers.....the first two params are ptrs......
    Status = MRxSmbCoreInformation(RxContext,0,
                                   (PVOID)pNewFileSize,
                                   (PULONG)pNewAllocationSize,
                                   SMBPSE_OE_FROM_EXTENDFILEFORCACHEING
                                   );
    if (FALSE) {
        DbgPrint("Extend exit %08lx %08lx %08lx %08lx\n",
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->LowPart);
    }

    RxLog(("Extend exit %lx %lx %lx %lx %lx\n",
                     RxContext,
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->LowPart));

    RxDbgTrace(-1, Dbg, ("MRxSmbExtendFile  exit with status=%08lx %08lx %08lx\n",
                          Status, pNewFileSize->LowPart, pNewAllocationSize->LowPart));
    return(Status);

}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\downlvlo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DownLvlO.c

Abstract:

    This module implements downlevel opens.


--*/

#include "precomp.h"
#pragma hdrstop
////
////  The Bug check file id for this module
////
//
//#define BugCheckFileId                   (RDBSS_BUG_CHECK_LOCAL_CREATE)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

VOID
MRxSmbPopulateFileInfoInOE(
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    USHORT FileAttributes,
    ULONG LastWriteTimeInSeconds,
    ULONG FileSize
    );

PVOID
MRxSmbPopulateFcbInitPacketForCore(void);


NTSTATUS
MRxSmbFinishPseudoOpenFromGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
      );
NTSTATUS
MRxSmbFinishCoreCreateDirectory (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      USHORT Attributes
      );


NTSTATUS
MRxSmbGetFileAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    RxDbgTrace(+1, Dbg, ("MRxSmbSynchronousGetFileAttributes entering.......OE=%08lx\n",OrdinaryExchange));

    if (FsRtlDoesNameContainWildCards(&capFcb->AlreadyPrefixedName)) {
        Status = STATUS_OBJECT_NAME_INVALID;
        goto FINALLY;
    }

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_QUERY_INFORMATION,
                                SMB_REQUEST_SIZE(QUERY_INFORMATION),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );


    MRxSmbStuffSMB (StufferState,
         "0B4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 0
                SMB_WCT_CHECK(0)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
                &capFcb->AlreadyPrefixedName
                                    //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name
             );



    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_GFA
                                    );

    //
    //save the result into the srvopen for use later..as appropriate
    if (NT_SUCCESS(Status)) {
        PMRX_SMB_SRV_OPEN smbSrvOpen = OrdinaryExchange->Create.smbSrvOpen;
        if (smbSrvOpen!=NULL) {
            ASSERT ( FIELD_OFFSET(SMB_PSE_ORDINARY_EXCHANGE,Create.smbSrvOpen)
                    == FIELD_OFFSET(SMB_PSE_ORDINARY_EXCHANGE,Info.smbSrvOpen));
            ASSERT ( FIELD_OFFSET(SMB_PSE_ORDINARY_EXCHANGE,Create.FileInfo)
                    == FIELD_OFFSET(SMB_PSE_ORDINARY_EXCHANGE,Info.FileInfo));
            smbSrvOpen->FileInfo = OrdinaryExchange->Create.FileInfo;
            smbSrvOpen->RxContextSerialNumber = (RxContext->SerialNumber);
            KeQueryTickCount(&smbSrvOpen->TimeStampInTicks);

        }
    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbSynchronousGetFileAttributes exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCoreDeleteForSupercedeOrClose(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    BOOLEAN DeleteDirectory
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreDeleteForSupercede entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    //
    if (!DeleteDirectory) {
        ULONG SearchAttributes = SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN;  // a la rdr1

        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_DELETE,
                                    SMB_REQUEST_SIZE(DELETE),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                     );


        MRxSmbStuffSMB (StufferState,
             "0wB4!",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 1
                    SearchAttributes,   //  w         _USHORT( SearchAttributes );
                    SMB_WCT_CHECK(1)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                        //            UCHAR Buffer[1];                    // Buffer containing:
                    OrdinaryExchange->pPathArgument1
                                        //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                        //            //UCHAR FileName[];                 //  File name
                 );
    } else {


        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_DELETE_DIRECTORY,
                                    SMB_REQUEST_SIZE(DELETE_DIRECTORY),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                     );


        MRxSmbStuffSMB (StufferState,
             "0B4!",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 0
                    SMB_WCT_CHECK(0)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                        //            UCHAR Buffer[1];                    // Buffer containing:
                    OrdinaryExchange->pPathArgument1
                                        //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                        //            //UCHAR FileName[];                 //  File name
                 );
    }



    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_DELETEFORSUPERSEDEORCLOSE
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreDeleteForSupercede exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbCoreCheckPath(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreCheckPath entering.......OE=%08lx\n",
                                                            OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );


    COVERED_CALL(MRxSmbStartSMBCommand
                                (StufferState,SetInitialSMB_ForReuse,
                                SMB_COM_CHECK_DIRECTORY,
                                SMB_REQUEST_SIZE(CHECK_DIRECTORY),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),
                                RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );



    MRxSmbStuffSMB (StufferState,
         "0B4!",
         //         UCHAR WordCount;       // Count of parameter words = 0
         SMB_WCT_CHECK(0)
         //  B    _USHORT( ByteCount );    // Count of data bytes; min = 2
         //       UCHAR Buffer[1];         // Buffer containing:
         OrdinaryExchange->pPathArgument1
         //  4    UCHAR BufferFormat;      //  0x04 -- ASCII
         //       UCHAR FileName[];        //  File name
    );



    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORECHECKDIRECTORY
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg,
                ("MRxSmbCoreCheckPath exiting.......OE=%08lx, st=%08lx\n",
                 OrdinaryExchange,Status)
              );
    return(Status);
}

NTSTATUS
MRxSmbCoreOpen(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG    OpenShareMode,
    ULONG    Attribute
    )
/*++

Routine Description:

   This routine does a core open.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreOpen entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_OPEN,
                                SMB_REQUEST_SIZE(OPEN),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );


    MRxSmbStuffSMB (StufferState,
         "0wwB4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
                OpenShareMode,      //  w         _USHORT( DesiredAccess );           // Mode - read/write/share
                Attribute,          //  w         _USHORT( SearchAttributes );
                SMB_WCT_CHECK(2)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
                &capFcb->AlreadyPrefixedName
                                    //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name
             );



    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_COREOPEN
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreOpen exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbSetFileAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG SmbAttributes,
    ULONG LastWriteTime
    )
/*++

Routine Description:

   This routine does a core create directory.....

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    RxDbgTrace(+1, Dbg, ("MRxSmbSetFileAttributes entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    if (FlagOn(Exchange->SmbCeContext.pServerEntry->Server.DialectFlags,DF_WFW|DF_W95)){
        LastWriteTime = 0;
    }


    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,
                                SMB_COM_SET_INFORMATION,
                                SMB_REQUEST_SIZE(SET_INFORMATION),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );


    MRxSmbStuffSMB (StufferState,
         "0wdwwwwwB4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 8
                SmbAttributes,      //  w         _USHORT( FileAttributes );
                LastWriteTime,      //  d         _ULONG( LastWriteTimeInSeconds );
                0,0,0,0,0,          //  5*w       _USHORT( Reserved )[5];             // Reserved (must be 0)
                SMB_WCT_CHECK(8)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
                &capFcb->AlreadyPrefixedName
                                    //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name
             );



    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_SFA
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbSFAAfterCreateDirectory exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCoreCreateDirectory(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a core create directory.....

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreCreateDirectory entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse,
                                SMB_COM_CREATE_DIRECTORY,
                                SMB_REQUEST_SIZE(CREATE_DIRECTORY),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );


    MRxSmbStuffSMB (StufferState,
         "0B4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 0
                SMB_WCT_CHECK(0)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
                &capFcb->AlreadyPrefixedName
                                    //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name
             );



    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORECREATEDIRECTORY
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreCreateDirectory exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCoreCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG    Attribute,
    BOOLEAN CreateNew
    )
/*++

Routine Description:

   This routine does a core create.....if the flag is set we use create new.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreCreate entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse,
                                (UCHAR)(CreateNew?SMB_COM_CREATE_NEW:SMB_COM_CREATE),
                                SMB_REQUEST_SIZE(CREATE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );


    MRxSmbStuffSMB (StufferState,
         "0wdB4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 3
                Attribute,          //  w         _USHORT( FileAttributes );          // New file attributes
                0,                  //  d         _ULONG( CreationTimeInSeconds );        // Creation time
                SMB_WCT_CHECK(3)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
                &capFcb->AlreadyPrefixedName
                                    //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name
             );



    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORECREATE
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreCreate exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCloseAfterCoreCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a close.....

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    RxDbgTrace(+1, Dbg, ("MRxSmbCloseAfterCoreCreate entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse,
                                SMB_COM_CLOSE,
                                SMB_REQUEST_SIZE(CLOSE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );


    MRxSmbStuffSMB (StufferState,
         "0wdB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 3
                                    //  w         _USHORT( Fid );                     // File handle
             OrdinaryExchange->Create.FidReturnedFromCreate,
             0,                     //  d         _ULONG( LastWriteTimeInSeconds );   // Time of last write, low and high
             SMB_WCT_CHECK(3) 0     //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );



    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CLOSEAFTERCORECREATE
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCloseAfterCoreCreate exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCoreTruncate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG Fid,
    ULONG FileTruncationPoint
    )
/*++

Routine Description:

   This routine does a truncate to implement FILE_OVERWRITE and FILE_OVERWRITE_IF.....
   it is also used in the "extend-for-cached-write" path.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreTruncate entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse,
                                SMB_COM_WRITE,
                                SMB_REQUEST_SIZE(WRITE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0  STUFFERTRACE(Dbg,'FC'))
                 )


    MRxSmbStuffSMB (StufferState,
         "0wwdwByw!",
                                    //  0   UCHAR WordCount;                    // Count of parameter words = 5
             Fid,                   //  w   _USHORT( Fid );                     // File handle
             0,                     //  w   _USHORT( Count );                   // Number of bytes to be written
             FileTruncationPoint,   //  d   _ULONG( Offset );                   // Offset in file to begin write
             0,                     //  w   _USHORT( Remaining );               // Bytes remaining to satisfy request
             SMB_WCT_CHECK(5)       //  B   _USHORT( ByteCount );               // Count of data bytes
                                    //      //UCHAR Buffer[1];                  // Buffer containing:
             0x01,                  //  y     UCHAR BufferFormat;               //  0x01 -- Data block
             0                      //  w     _USHORT( DataLength );            //  Length of data
                                    //        ULONG Buffer[1];                  //  Data
             );



    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORETRUNCATE
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreTruncate exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbDownlevelCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine implements downlevel creates.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    For core, in particular, this is pretty painful because a different smb must be used
    for different dispositions. In addition, we cannot really open a directory.

    By in large, we will follow a strategy similar to rdr1. If the openmode maps into something that
    a downlevel server won't understand then we don't really open the file.....we just do a GFA to ensure
    that it's there and hope that we can do path-based ops for the duration.

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    RxCaptureFcb; RxCaptureFobx;
    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;

    ULONG CreateOptions = cp->CreateOptions;
    ULONG FileAttributes =  cp->FileAttributes;
    ACCESS_MASK   DesiredAccess = cp->DesiredAccess;
    USHORT        ShareAccess = (USHORT)(cp->ShareAccess);
    ULONG         Disposition = cp->Disposition;

    PUNICODE_STRING  PathName = &capFcb->AlreadyPrefixedName;


    USHORT mappedDisposition = MRxSmbMapDisposition(Disposition);
    USHORT mappedSharingMode = MRxSmbMapShareAccess(ShareAccess);
    USHORT mappedAttributes  = MRxSmbMapFileAttributes(FileAttributes);
    USHORT mappedOpenMode    = MRxSmbMapDesiredAccess(DesiredAccess);

    LARGE_INTEGER AllocationSize = cp->AllocationSize;
    LARGE_INTEGER CurrentTime;
    ULONG SecondsSince1970;

    PMRXIFS_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    BOOLEAN MustBeAFile = (MustBeFile(CreateOptions)!=0);
    BOOLEAN MustBeADirectory = (MustBeDirectory(CreateOptions)!=0)
                                    || BooleanFlagOn(RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_STRIPPED_TRAILING_BACKSLASH);
    BOOLEAN ItsADirectory = FALSE;
    BOOLEAN ItsTheShareRoot = FALSE;

    RxDbgTrace(+1, Dbg, ("MRxSmbDownlevelCreate entering.......OE=%08lx\n",OrdinaryExchange));
    RxDbgTrace( 0, Dbg, ("mapAtt,Shr,Disp,OM %04lx,%04lx,%04lx,%04lx\n",
                                  mappedAttributes,mappedSharingMode,mappedDisposition,mappedOpenMode));

    SmbPseOEAssertConsistentLinkageFromOE("Downlevel Create:");

    StufferState = &OrdinaryExchange->AssociatedStufferState;
    OrdinaryExchange->NeedToReinitializeStufferState = FALSE;

    if (OrdinaryExchange->Create.CreateWithEasSidsOrLongName) {
        Status = STATUS_NOT_SUPPORTED;
        goto FINALLY;
    }

    if (AllocationSize.HighPart != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto FINALLY;
    }


    ASSERT( NodeType(RxContext->Create.pSrvOpen) == RDBSS_NTC_SRVOPEN );
    OrdinaryExchange->Create.smbSrvOpen = MRxIfsGetSrvOpenExtension(RxContext->Create.pSrvOpen);

    //
    // we know that the root a share exists and that it's a directory....the catch is that GetFileAttributes
    // will return a NO_SUCH_FILE error for the root if it's really a root on the server. record this and use it
    // to our advantage later.

    if ((PathName->Length == sizeof(WCHAR)) && (PathName->Buffer[0] == OBJ_NAME_PATH_SEPARATOR)) {
        if (MustBeAFile) {
            Status = STATUS_FILE_IS_A_DIRECTORY;
            goto FINALLY;
        }
        MustBeADirectory = TRUE;   // we know it's a directory!
        ItsTheShareRoot = TRUE;
    }

    if ( (mappedOpenMode == ((USHORT)-1)) ||
         (Disposition == FILE_SUPERSEDE) ||
         (!MustBeAFile)
       ) {
        //
        // go find out what's there.......
        Status = MRxSmbGetFileAttributes(
                                    SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS
                                    );
        RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate gfastatus=%08lx\n",Status));
        if (NT_SUCCESS(Status)) {
            ULONG Attributes = SmbGetUshort(&OrdinaryExchange->Create.FileInfo.Basic.FileAttributes);
            ItsADirectory = BooleanFlagOn(Attributes,SMB_FILE_ATTRIBUTE_DIRECTORY);
            RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate attributes=%08lx\n",Attributes));
            if ((Disposition==FILE_CREATE)) {
                Status = STATUS_OBJECT_NAME_COLLISION;
                goto FINALLY;
            }
            if (MustBeADirectory && !ItsADirectory && (Disposition!=FILE_SUPERSEDE)) {
                Status = STATUS_OBJECT_TYPE_MISMATCH;
                goto FINALLY;
            }
            if (MustBeAFile && ItsADirectory && (Disposition!=FILE_SUPERSEDE)) {
                Status = STATUS_OBJECT_TYPE_MISMATCH;
                goto FINALLY;
            }
            //if (!MustBeAFile && ItsADirectory && (Disposition==FILE_OPEN)){
            if (Disposition==FILE_OPEN){
                //we're done except to finish AND to set the flags in the srvopen
                MRxSmbFinishPseudoOpenFromGFAResponse ( OrdinaryExchange );
                goto FINALLY;
            }
        } else if (Status != STATUS_NO_SUCH_FILE) {
            goto FINALLY;
        } else if ((Disposition==FILE_CREATE)
                     || (Disposition==FILE_OPEN_IF)
                     || (Disposition==FILE_OVERWRITE_IF)
                     || (Disposition==FILE_SUPERSEDE)) {
            NOTHING;
        } else if (ItsTheShareRoot) {
            PMRX_SRV_OPEN SrvOpen = RxContext->Create.pSrvOpen;
            PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);
            //here we have run into a true root....so we can't get attributes. fill in a fake
            //response and finish. also, flip the bit that says we can't gfa this guy.
            RtlZeroMemory(&OrdinaryExchange->Create.FileInfo,sizeof(OrdinaryExchange->Create.FileInfo));
            MRxSmbFinishPseudoOpenFromGFAResponse ( OrdinaryExchange );
            MRxSmbPopulateFileInfoInOE(
                OrdinaryExchange,
                SMB_FILE_ATTRIBUTE_DIRECTORY,
                0,
                0
                );
            smbSrvOpen->Flags |= SMB_SRVOPEN_FLAG_CANT_GETATTRIBS;
            Status = STATUS_SUCCESS;
            goto FINALLY;
        } else {
            goto FINALLY;
        }
    }


    SmbCeResetExchange(&OrdinaryExchange->Exchange);  //must reset!

    if (NT_SUCCESS(Status) &&(Disposition == FILE_SUPERSEDE)) {
        OrdinaryExchange->pPathArgument1 = PathName;
        //
        //we have to get rid of the existing entity...using a delete or a rmdir as appropriate
        Status = MRxSmbCoreDeleteForSupercedeOrClose(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                                      OrdinaryExchange->Create.FileInfo.Standard.Directory
                                                     );
        if (!NT_SUCCESS(Status)) {
            RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate could notsupersede st=%08lx\n",Status));
            goto FINALLY;
        }
        SmbCeResetExchange(&OrdinaryExchange->Exchange);  //must reset!

    }

    if (MustBeADirectory || (ItsADirectory &&(Disposition == FILE_SUPERSEDE)) ) {

        ASSERT (Disposition!=FILE_OPEN);
        Status = MRxSmbCoreCreateDirectory(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
        if (!NT_SUCCESS(Status)) {
            RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate couldn't mkdir st=%08lx\n",Status));
            goto FINALLY;
        }

        if ( (mappedAttributes & ( SMB_FILE_ATTRIBUTE_READONLY
                                       | SMB_FILE_ATTRIBUTE_HIDDEN
                                       | SMB_FILE_ATTRIBUTE_SYSTEM
                                       | SMB_FILE_ATTRIBUTE_ARCHIVE
                                 )!= 0)
           ) {
            //
            //we have to set the attributes
            Status = MRxSmbSetFileAttributes(
                                        SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                        mappedAttributes,0);  //lastwritetime=0
            if (!NT_SUCCESS(Status)) {
                RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate couldn't sfa st=%08lx\n",Status));
            }
        }

        MRxSmbFinishCoreCreateDirectory ( OrdinaryExchange, mappedAttributes );

        goto FINALLY;
    }


    //no pseudoOpens yet
    if ( TRUE ) {

        ULONG workingDisposition = Disposition;
        ULONG iterationcount;
        BOOLEAN MayNeedATruncate = FALSE;

       //
       // we use the disposition as a state and case out.....some are hard and some are easy
       //     for example, if it's CREATE then we use the CREATE_NEW to create the file but
       //                  the resulting open is no good so we close it and open it again using the
       //                  open. for OPEN_IF  we assume that the file will be there
       //                  and drop into create if it's not.

       for (iterationcount=0;;iterationcount++) {
           switch (workingDisposition) {
           case FILE_OVERWRITE:
           case FILE_OVERWRITE_IF:
               MayNeedATruncate = TRUE;
               //lack of break intentional
           case FILE_OPEN_IF:
           case FILE_OPEN:
               Status = MRxSmbCoreOpen(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                           mappedOpenMode|mappedSharingMode,
                                           mappedAttributes);
               if (!((workingDisposition == FILE_OPEN_IF) || (workingDisposition == FILE_OVERWRITE_IF))
                    || (Status != STATUS_NO_SUCH_FILE)
                    || (iterationcount>6)
                    )break;
               SmbCeResetExchange(&OrdinaryExchange->Exchange);  //must reset!
           case FILE_SUPERSEDE:
           case FILE_CREATE:
               Status = MRxSmbCoreCreate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                           mappedAttributes,TRUE); //(workingDisposition==FILE_CREATE));
               if (!NT_SUCCESS(Status)) {
                    RxDbgTrace(-1, Dbg, ("MRxSmbDownlevelCreate exiting.......createnew failed st=%08lx\n",Status));
                    break;
               }

               //now, we have a network handle. BUT, it's a compatibility-mode open. since we don't want that we
               //     need to close and reopen with the parameters specified. there is a window here! what can i do??

               Status = MRxSmbCloseAfterCoreCreate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
               if (!NT_SUCCESS(Status)) {
                    RxDbgTrace(-1, Dbg, ("MRxSmbDownlevelCreate exiting.......closeaftercreatenew failed st=%08lx\n",Status));
                    break;
               }

               workingDisposition = FILE_OPEN_IF;
               continue;     // this wraps back to the switch with a new disposition
               //break;
           default :
               ASSERT(!"Bad Disposition");
               Status = STATUS_INVALID_PARAMETER;
           }
           break; //exit the loop
       }
       if (!NT_SUCCESS(Status))goto FINALLY;
       //we may need a truncate....this is different from rdr1.
       if (MayNeedATruncate
                 && !OrdinaryExchange->Create.FileWasCreated
                 && (OrdinaryExchange->Create.FileSizeReturnedFromOpen!=0)  ) {
           Status = MRxSmbCoreTruncate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                       OrdinaryExchange->Create.FidReturnedFromOpen,
                                       0
           );
       }

       goto FINALLY;
    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbDownlevelCreate exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbFinishGFA (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_QUERY_INFORMATION     Response
      )
/*++

Routine Description:

    This routine copies the response to the GetFileAttributes SMB. But, it must be called synchronously.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_BASIC_INFORMATION BasicInformation = &OrdinaryExchange->Create.FileInfo.Basic;
    PFILE_STANDARD_INFORMATION StandardInformation = &OrdinaryExchange->Create.FileInfo.Standard;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishGFA\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishGFA:");

    ASSERT( (Response->WordCount==10));
    ASSERT( (SmbGetUshort(&Response->ByteCount)==0));

    //what we do here is to put the data into the ordinary exchange...it's locked down do
    //we wcould do this at DPC level

    MRxSmbPopulateFileInfoInOE(
        OrdinaryExchange,
        SmbGetUshort(&Response->FileAttributes),
        SmbGetUlong(&Response->LastWriteTimeInSeconds),
        SmbGetUlong(&Response->FileSize)
        );

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishGFA   returning %08lx\n", Status ));
    return Status;
}



NTSTATUS
MRxSmbCreateFileSuccessTail (
    PRX_CONTEXT  RxContext,
    PBOOLEAN MustRegainExclusiveResource,
    RX_FILE_TYPE StorageType,
    SMB_FILE_ID Fid,
    ULONG ServerVersion,
    UCHAR OplockLevel,
    ULONG CreateAction,
    PSMBPSE_FILEINFO_BUNDLE FileInfo
    );

NTSTATUS
MRxSmbFinishCoreCreate (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_CREATE                Response
      )
/*++

Routine Description:

    This routine copies the fid from a core create response. it does not finish the fcb......if a compatibility
    mode open is acceptable then it could.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishCoreCreate\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishCoreCreate:");

    ASSERT( (Response->WordCount==1));
    ASSERT( (SmbGetUshort(&Response->ByteCount)==0));

    OrdinaryExchange->Create.FidReturnedFromCreate = SmbGetUshort(&Response->Fid);
    OrdinaryExchange->Create.FileWasCreated = TRUE;
    //notice that we didn't finish here! we should IFF a compatibilty-mode open is okay

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishCoreCreate   returning %08lx\n", Status ));
    return Status;
}

#define JUST_USE_THE_STUFF_IN_THE_OE (0xfbad)
VOID
MRxSmbPopulateFileInfoInOE(
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    USHORT FileAttributes,
    ULONG LastWriteTimeInSeconds,
    ULONG FileSize
    )
{
    PFILE_BASIC_INFORMATION BasicInformation = &OrdinaryExchange->Create.FileInfo.Basic;
    PFILE_STANDARD_INFORMATION StandardInformation = &OrdinaryExchange->Create.FileInfo.Standard;

    BasicInformation->FileAttributes = MRxSmbMapSmbAttributes(FileAttributes);
    StandardInformation->NumberOfLinks = 1;
    BasicInformation->CreationTime.QuadPart = 0;
    BasicInformation->LastAccessTime.QuadPart = 0;
    MRxSmbSecondsSince1970ToTime(LastWriteTimeInSeconds,
                                 MRxSmbExchangeToServer(OrdinaryExchange),
                                 &BasicInformation->LastWriteTime);
    BasicInformation->ChangeTime.QuadPart = 0;
    StandardInformation->AllocationSize.QuadPart = FileSize; //rdr1 actually rounds up based of svr disk attribs
    StandardInformation->EndOfFile.QuadPart = FileSize;
    StandardInformation->Directory = BooleanFlagOn(BasicInformation->FileAttributes,FILE_ATTRIBUTE_DIRECTORY);

}


NTSTATUS
MRxSmbFinishCoreOpen (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_OPEN                  Response
      )
/*++

Routine Description:

    This routine finishes a core open.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    NTSTATUS - The return status for the operation

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID Fid;
    ULONG CreateAction;
    FCB_INIT_PACKET InitPacket;

    ULONG FileSize;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishCoreOpen\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishCoreOpen:");

    ASSERT( (Response->WordCount==7));
    ASSERT( (SmbGetUshort(&Response->ByteCount)==0));

    StorageType = FileTypeFile;
    Fid = SmbGetUshort(&Response->Fid);
    OrdinaryExchange->Create.FidReturnedFromOpen = Fid;
    FileSize = OrdinaryExchange->Create.FileSizeReturnedFromOpen = SmbGetUlong(&Response->DataSize);

    CreateAction = (OrdinaryExchange->Create.FileWasCreated)?FILE_CREATED
                        : (OrdinaryExchange->Create.FileWasTruncated)?FILE_OVERWRITTEN
                        :FILE_OPENED;

    MRxSmbPopulateFileInfoInOE(
        OrdinaryExchange,
        SmbGetUshort(&Response->FileAttributes),
        SmbGetUlong(&Response->LastWriteTimeInSeconds),
        FileSize
        );


    MRxSmbCreateFileSuccessTail (   RxContext,
                                    &OrdinaryExchange->Create.MustRegainExclusiveResource,
                                    StorageType,
                                    Fid,
                                    OrdinaryExchange->ServerVersion,
                                    SMB_OPLOCK_LEVEL_NONE,
                                    CreateAction,
                                    &OrdinaryExchange->Create.FileInfo
                                    );

    OrdinaryExchange->Create.FinalCondition = Condition_Good;

    IF_DEBUG{
        RxCaptureFcb;
        RxDbgTrace(-1, Dbg, ("MRxSmbFinishCoreOpen   returning %08lx, fcbstate =%08lx\n", Status, wrapperFcb->FcbState ));
    }
    return Status;
}

NTSTATUS
MRxSmbFinishCoreCreateDirectory (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      USHORT Attributes
      )
/*++

Routine Description:

    This routine finishes a core create directory. but, it is not called from the receive routine......

Arguments:

    OrdinaryExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->Create.pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID Fid;
    ULONG CreateAction;
    FCB_INIT_PACKET InitPacket;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishCoreCreateDirectory\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishCoreCreateDirectory:");

    StorageType = FileTypeDirectory;
    Fid = 0xbadd;

    CreateAction = FILE_CREATED;
    MRxSmbPopulateFileInfoInOE(
        OrdinaryExchange,
        Attributes,
        0,
        0
        );


    MRxSmbCreateFileSuccessTail (   RxContext,
                                    &OrdinaryExchange->Create.MustRegainExclusiveResource,
                                    StorageType,
                                    Fid,
                                    OrdinaryExchange->ServerVersion,
                                    SMB_OPLOCK_LEVEL_NONE,
                                    CreateAction,
                                    &OrdinaryExchange->Create.FileInfo
                                    );

    smbSrvOpen->Flags |=  (SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN | SMB_SRVOPEN_FLAG_CANT_REALLY_OPEN);

    OrdinaryExchange->Create.FinalCondition = Condition_Good;

    IF_DEBUG{
        RxCaptureFcb;
        RxDbgTrace(-1, Dbg, ("MRxSmbFinishCoreCreateDirectory   returning %08lx, fcbstate =%08lx\n", Status, wrapperFcb->FcbState ));
    }
    return Status;
}

NTSTATUS
MRxSmbFinishPseudoOpenFromGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
      )
/*++

Routine Description:

    This routine finishes a directory pseudoopen.

Arguments:

    OrdinaryExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->Create.pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID Fid;
    ULONG CreateAction;

    FCB_INIT_PACKET InitPacket;

    ULONG FileSize;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishPseudoOpenFromGFAResponse\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishPseudoOpenFromGFAResponse:");

    StorageType = OrdinaryExchange->Create.FileInfo.Standard.Directory
                  ? FileTypeDirectory
                  : FileTypeFile;
    Fid = 0xbadd;

    CreateAction = FILE_OPENED;

    MRxSmbCreateFileSuccessTail (   RxContext,
                                    &OrdinaryExchange->Create.MustRegainExclusiveResource,
                                    StorageType,
                                    Fid,
                                    OrdinaryExchange->ServerVersion,
                                    SMB_OPLOCK_LEVEL_NONE,
                                    CreateAction,
                                    &OrdinaryExchange->Create.FileInfo
                                    );

    smbSrvOpen->Flags |=  (SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN | SMB_SRVOPEN_FLAG_CANT_REALLY_OPEN);

    OrdinaryExchange->Create.FinalCondition = Condition_Good;

    IF_DEBUG{
        RxCaptureFcb;
        RxDbgTrace(-1, Dbg, ("MRxSmbFinishPseudoOpenFromGFAResponse   returning %08lx, fcbstate =%08lx\n", Status, wrapperFcb->FcbState ));
    }
    return Status;
}

LARGE_INTEGER
MRxSmbConvertSmbTimeToTime (
    IN PSMBCE_SERVER Server OPTIONAL,
    IN SMB_TIME Time,
    IN SMB_DATE Date
    )

/*++

Routine Description:

    This routine converts an SMB time to an NT time structure.

Arguments:

    IN SMB_TIME Time - Supplies the time of day to convert
    IN SMB_DATE Date - Supplies the day of the year to convert
    IN supplies the server for tz bias.

Return Value:

    LARGE_INTEGER - Time structure describing input time.


--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER OutputTime;

    //
    // This routine cannot be paged because it is called from both the
    // MRxSmbFileDiscardableSection and the MRxSmbVCDiscardableSection.
    //

    if (SmbIsTimeZero(&Date) && SmbIsTimeZero(&Time)) {
        OutputTime.LowPart = OutputTime.HighPart = 0;
    } else {
        TimeFields.Year = Date.Struct.Year + (USHORT )1980;
        TimeFields.Month = Date.Struct.Month;
        TimeFields.Day = Date.Struct.Day;

        TimeFields.Hour = Time.Struct.Hours;
        TimeFields.Minute = Time.Struct.Minutes;
        TimeFields.Second = Time.Struct.TwoSeconds*(USHORT )2;
        TimeFields.Milliseconds = 0;

        //
        //  Make sure that the times specified in the SMB are reasonable
        //  before converting them.
        //

        if (TimeFields.Year < 1601) {
            TimeFields.Year = 1601;
        }

        if (TimeFields.Month > 12) {
            TimeFields.Month = 12;
        }

        if (TimeFields.Hour >= 24) {
            TimeFields.Hour = 23;
        }
        if (TimeFields.Minute >= 60) {
            TimeFields.Minute = 59;
        }
        if (TimeFields.Second >= 60) {
            TimeFields.Second = 59;

        }

        if (!RtlTimeFieldsToTime(&TimeFields, &OutputTime)) {
            OutputTime.HighPart = 0;
            OutputTime.LowPart = 0;

            return OutputTime;
        }

        if (ARGUMENT_PRESENT(Server)) {
            OutputTime.QuadPart = OutputTime.QuadPart + Server->TimeZoneBias.QuadPart;
        }

        ExLocalTimeToSystemTime(&OutputTime, &OutputTime);

    }

    return OutputTime;

}

BOOLEAN
MRxSmbConvertTimeToSmbTime (
    IN PLARGE_INTEGER InputTime,
    IN PSMB_EXCHANGE Exchange OPTIONAL,
    OUT PSMB_TIME Time,
    OUT PSMB_DATE Date
    )

/*++

Routine Description:

    This routine converts an NT time structure to an SMB time.

Arguments:

    IN LARGE_INTEGER InputTime - Supplies the time to convert.
    OUT PSMB_TIME Time - Returns the converted time of day.
    OUT PSMB_DATE Date - Returns the converted day of the year.


Return Value:

    BOOLEAN - TRUE if input time could be converted.


--*/

{
    TIME_FIELDS TimeFields;

    PAGED_CODE();

    if (InputTime->LowPart == 0 && InputTime->HighPart == 0) {
        Time->Ushort = Date->Ushort = 0;
    } else {
        LARGE_INTEGER LocalTime;

        ExSystemTimeToLocalTime(InputTime, &LocalTime);

        if (ARGUMENT_PRESENT(Exchange)) {
            PSMBCE_SERVER Server = &Exchange->SmbCeContext.pServerEntry->Server;
            LocalTime.QuadPart -= Server->TimeZoneBias.QuadPart;
        }

        RtlTimeToTimeFields(&LocalTime, &TimeFields);

        if (TimeFields.Year < 1980) {
            return FALSE;
        }

        Date->Struct.Year = (USHORT )(TimeFields.Year - 1980);
        Date->Struct.Month = TimeFields.Month;
        Date->Struct.Day = TimeFields.Day;

        Time->Struct.Hours = TimeFields.Hour;
        Time->Struct.Minutes = TimeFields.Minute;

        //
        //  When converting from a higher granularity time to a lesser
        //  granularity time (seconds to 2 seconds), always round up
        //  the time, don't round down.
        //

        Time->Struct.TwoSeconds = (TimeFields.Second + (USHORT)1) / (USHORT )2;

    }

    return TRUE;
}


BOOLEAN
MRxSmbTimeToSecondsSince1970 (
    IN PLARGE_INTEGER CurrentTime,
    //IN PSMB_EXCHANGE Exchange OPTIONAL,
    IN PSMBCE_SERVER Server OPTIONAL,
    OUT PULONG SecondsSince1970
    )
/*++

Routine Description:

    This routine returns the CurrentTime in UTC and returns the
    equivalent current time in the servers timezone.


Arguments:

    IN PLARGE_INTEGER CurrentTime - Supplies the current system time in UTC.

    IN PSMB_EXCHANGE Exchange - Supplies the difference in timezones between
                                the server and the workstation. If not supplied
                                then the assumption is that they are in the
                                same timezone.

    OUT PULONG SecondsSince1970 - Returns the # of seconds since 1970 in
                                the servers timezone or MAXULONG if conversion
                                fails.

Return Value:

    BOOLEAN - TRUE if the time could be converted.


--*/

{
    LARGE_INTEGER ServerTime;
    LARGE_INTEGER TempTime;
    BOOLEAN ReturnValue;

    PAGED_CODE();

    if (ARGUMENT_PRESENT(Server)) {

        TempTime.QuadPart = (*CurrentTime).QuadPart - Server->TimeZoneBias.QuadPart;

        ExSystemTimeToLocalTime(&TempTime, &ServerTime);

    } else {

        ExSystemTimeToLocalTime(CurrentTime, &ServerTime);

    }

    ReturnValue = RtlTimeToSecondsSince1970(&ServerTime, SecondsSince1970);

    if ( ReturnValue == FALSE ) {
        //
        //  We can't represent the time legally, peg it at
        //  the max legal time.
        //

        *SecondsSince1970 = MAXULONG;
    }

    return ReturnValue;
}

VOID
MRxSmbSecondsSince1970ToTime (
    IN ULONG SecondsSince1970,
    //IN PSMB_EXCHANGE Exchange OPTIONAL,
    IN PSMBCE_SERVER Server,
    OUT PLARGE_INTEGER CurrentTime
    )
/*++

Routine Description:

    This routine returns the Local system time derived from a time
    in seconds in the servers timezone.


Arguments:

    IN ULONG SecondsSince1970 - Supplies the # of seconds since 1970 in
                                servers timezone.

    IN PSMB_EXCHANGE Exchange - Supplies the difference in timezones between
                                the server and the workstation. If not supplied
                                then the assumption is that they are in the
                                same timezone.

    OUT PLARGE_INTEGER CurrentTime - Returns the current system time in UTC.

Return Value:

    None.


--*/

{
    LARGE_INTEGER LocalTime;

    RtlSecondsSince1970ToTime (SecondsSince1970, &LocalTime);

    ExLocalTimeToSystemTime(&LocalTime, CurrentTime);

    if (ARGUMENT_PRESENT(Server)) {
        (*CurrentTime).QuadPart = (*CurrentTime).QuadPart + Server->TimeZoneBias.QuadPart;
    }

    return;

}

ULONG
MRxSmbMapSmbAttributes (
    IN USHORT SmbAttribs
    )

/*++

Routine Description:

    This routine maps an SMB (DOS/OS2) file attribute into an NT
    file attribute.


Arguments:

    IN USHORT SmbAttribs - Supplies the SMB attribute to map.


Return Value:

    ULONG - NT Attribute mapping SMB attribute


--*/

{
    ULONG Attributes = 0;

    if (SmbAttribs==0) {
        Attributes = FILE_ATTRIBUTE_NORMAL;
    } else {

        ASSERT (SMB_FILE_ATTRIBUTE_READONLY == FILE_ATTRIBUTE_READONLY);
        ASSERT (SMB_FILE_ATTRIBUTE_HIDDEN == FILE_ATTRIBUTE_HIDDEN);
        ASSERT (SMB_FILE_ATTRIBUTE_SYSTEM == FILE_ATTRIBUTE_SYSTEM);
        ASSERT (SMB_FILE_ATTRIBUTE_ARCHIVE == FILE_ATTRIBUTE_ARCHIVE);
        ASSERT (SMB_FILE_ATTRIBUTE_DIRECTORY == FILE_ATTRIBUTE_DIRECTORY);

        Attributes = SmbAttribs & FILE_ATTRIBUTE_VALID_FLAGS;
    }
    return Attributes;
}

USHORT
MRxSmbMapDisposition (
    IN ULONG Disposition
    )

/*++

Routine Description:

    This routine takes an NT disposition, and maps it into an OS/2
    CreateAction to be put into an SMB.


Arguments:

    IN ULONG Disposition - Supplies the NT disposition to map.


Return Value:

    USHORT - OS/2 Access mapping that maps NT access

--*/

{
    PAGED_CODE();

    switch (Disposition) {
    case FILE_OVERWRITE_IF:
    case FILE_SUPERSEDE:
        return SMB_OFUN_OPEN_TRUNCATE | SMB_OFUN_CREATE_CREATE;
        break;

    case FILE_CREATE:
        return SMB_OFUN_OPEN_FAIL | SMB_OFUN_CREATE_CREATE;
        break;

    case FILE_OVERWRITE:
        return SMB_OFUN_OPEN_TRUNCATE | SMB_OFUN_CREATE_FAIL;
        break;

    case FILE_OPEN:
        return SMB_OFUN_OPEN_OPEN | SMB_OFUN_CREATE_FAIL;
        break;

    case FILE_OPEN_IF:
        return SMB_OFUN_OPEN_OPEN | SMB_OFUN_CREATE_CREATE;
        break;

    default:
        return 0;
        break;
    }
}


ULONG
MRxSmbUnmapDisposition (
    IN USHORT SmbDisposition
    )

/*++

Routine Description:

    This routine takes an OS/2 disposition and maps it into an NT
    disposition.

Arguments:

    IN USHORT SmbDisposition - Supplies the OS/2 disposition to map.

Return Value:

    ULONG - NT disposition mapping OS/2 disposition

--*/

{
    //
    //  Mask off oplocked bit.
    //

    switch (SmbDisposition & 0x7fff) {

    case SMB_OACT_OPENED:
        return FILE_OPENED;
        break;

    case SMB_OACT_CREATED:
        return FILE_CREATED;
        break;

    case SMB_OACT_TRUNCATED:
        return FILE_OVERWRITTEN;
        break;
    }

    ASSERT(!"not a reasonable smbdiposition");
    return 0;
}


USHORT
MRxSmbMapDesiredAccess (
    IN ULONG DesiredAccess
    )

/*++

Routine Description:

    This routine takes an NT DesiredAccess value and converts it
    to an OS/2 access mode.


Arguments:

    IN ULONG DesiredAccess - Supplies the NT desired access to map.

Return Value:

    USHORT - The mapped OS/2 access mode that compares to the NT code
        specified.  If there is no mapping for the NT code, we return
        -1 as the access mode.

--*/

{
    PAGED_CODE();

    //
    //  If the user asked for both read and write access, return read/write.
    //

    if ((DesiredAccess & FILE_READ_DATA)&&(DesiredAccess & FILE_WRITE_DATA)) {
        return SMB_DA_ACCESS_READ_WRITE;
    }

    //
    //  If the user requested WRITE_DATA, return write.
    //

    if (DesiredAccess & FILE_WRITE_DATA) {
        return SMB_DA_ACCESS_WRITE;
    }

    //
    //  If the user requested READ_DATA, return read.
    //
    if (DesiredAccess & FILE_READ_DATA) {
        return SMB_DA_ACCESS_READ;
    }

    //
    //  If the user requested ONLY execute access, then request execute
    //  access.  Execute access is the "weakest" of the possible desired
    //  accesses, so it takes least precedence.
    //

    if (DesiredAccess & FILE_EXECUTE) {
        return SMB_DA_ACCESS_EXECUTE;
    }

    //
    //  If we couldn't figure out what we were doing, return -1
    //
    //  Among the attributes that we do not map are:
    //
    //          FILE_READ_ATTRIBUTES
    //          FILE_WRITE_ATTRIBUTES
    //          FILE_READ_EAS
    //          FILE_WRITE_EAS
    //


    return (USHORT)-1;
}

USHORT
MRxSmbMapShareAccess (
    IN USHORT ShareAccess
    )

/*++

Routine Description:

    This routine takes an NT ShareAccess value and converts it to an
    OS/2 sharing mode.


Arguments:

    IN USHORT ShareAccess - Supplies the OS/2 share access to map.

Return Value:

    USHORT - The mapped OS/2 sharing mode that compares to the NT code
        specified

--*/

{
    USHORT ShareMode =  SMB_DA_SHARE_EXCLUSIVE;

    PAGED_CODE();

    if ((ShareAccess & (FILE_SHARE_READ | FILE_SHARE_WRITE)) ==
                       (FILE_SHARE_READ | FILE_SHARE_WRITE)) {
        ShareMode = SMB_DA_SHARE_DENY_NONE;
    } else if (ShareAccess & FILE_SHARE_READ) {
        ShareMode = SMB_DA_SHARE_DENY_WRITE;
    } else if (ShareAccess & FILE_SHARE_WRITE) {
        ShareMode = SMB_DA_SHARE_DENY_READ;
    }

    return ShareMode;

}

USHORT
MRxSmbMapFileAttributes (
    IN ULONG FileAttributes
    )

/*++

Routine Description:

    This routine takes an NT file attribute mapping and converts it into
    an OS/2 file attribute definition.


Arguments:

    IN ULONG FileAttributes - Supplies the file attributes to map.


Return Value:

USHORT

--*/

{
    USHORT ResultingAttributes = 0;

    PAGED_CODE();

    if (FileAttributes==FILE_ATTRIBUTE_NORMAL) {
        return ResultingAttributes;
    }

    if (FileAttributes & FILE_ATTRIBUTE_READONLY) {
        ResultingAttributes |= SMB_FILE_ATTRIBUTE_READONLY;
    }

    if (FileAttributes & FILE_ATTRIBUTE_HIDDEN) {
        ResultingAttributes |= SMB_FILE_ATTRIBUTE_HIDDEN;
    }

    if (FileAttributes & FILE_ATTRIBUTE_SYSTEM) {
        ResultingAttributes |= SMB_FILE_ATTRIBUTE_SYSTEM;
    }
    if (FileAttributes & FILE_ATTRIBUTE_ARCHIVE) {
        ResultingAttributes |= SMB_FILE_ATTRIBUTE_ARCHIVE;
    }
    return ResultingAttributes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\ifsprocs.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ifsprocs.h

Abstract:

    The module contains the prototype definitions for all cross referenced
    routines.

--*/

#ifndef _IFSPROCS_H_
#define _IFSPROCS_H_

//cross-referenced internal routines

//from rename.c
MRxIfsRename(
      IN PRX_CONTEXT            RxContext,
      IN FILE_INFORMATION_CLASS FileInformationClass,
      IN PVOID                  pBuffer,
      IN ULONG                  BufferLength);

//from openclos.c
NTSTATUS
MRxIfsBuildClose (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
MRxIfsBuildFindClose (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

// from usrcnnct.c

extern NTSTATUS
MRxIfsDeleteConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

// from smbutils.c , routines for manipulating strings and copying them
// to SMBs

extern
NTSTATUS
SmbPutString(
         PBYTE   *pBufferPointer,
         PSTRING pString,
         PULONG  pSize);

extern
NTSTATUS
SmbPutUnicodeString(
         PBYTE           *pBufferPointer,
         PUNICODE_STRING pUnicodeString,
         PULONG          pSize);

extern
NTSTATUS
SmbPutUnicodeStringAsOemString(
         PBYTE           *pBufferPointer,
         PUNICODE_STRING pUnicodeString,
         PULONG          pSize);


extern
NTSTATUS
SmbPutUnicodeStringAndUpcase(
         PBYTE           *pBufferPointer,
         PUNICODE_STRING pUnicodeString,
         PULONG          pSize);

extern
NTSTATUS
SmbPutUnicodeStringAsOemStringAndUpcase(
         PBYTE           *pBufferPointer,
         PUNICODE_STRING pUnicodeString,
         PULONG          pSize);


//
// Object Allocation and deletion (ifsmrxmm.c)
//

extern PVOID
SmbMmAllocateObject(SMBCEDB_OBJECT_TYPE ObjectType);

extern VOID
SmbMmFreeObject(PVOID pObject);

extern PSMBCEDB_SESSION_ENTRY
SmbMmAllocateSessionEntry(PSMBCEDB_SERVER_ENTRY pServerEntry);

extern VOID
SmbMmFreeSessionEntry(PSMBCEDB_SESSION_ENTRY pSessionEntry);

extern PVOID
SmbMmAllocateExchange(SMB_EXCHANGE_TYPE ExchangeType, PVOID pv);

extern VOID
SmbMmFreeExchange(PVOID pExchange);

extern PVOID
SmbMmAllocateServerTransport(SMBCE_SERVER_TRANSPORT_TYPE ServerTransportType);

extern VOID
SmbMmFreeServerTransport(PSMBCE_SERVER_TRANSPORT);


#define SmbMmInitializeHeader(pHeader)                        \
         RtlZeroMemory((pHeader),sizeof(SMBCE_OBJECT_HEADER))

// security session setup related routines

//
// Forward declarations ...
//

typedef struct _SECURITY_RESPONSE_CONTEXT {
   union {
      struct {
         PVOID pOutputContextBuffer;
      } LanmanSetup;
   };
} SECURITY_RESPONSE_CONTEXT,*PSECURITY_RESPONSE_CONTEXT;

extern NTSTATUS
BuildSessionSetupSecurityInformation(
    PSMB_EXCHANGE pExchange,
    PBYTE           pSmbBuffer,
    PULONG          pSmbBufferSize);

extern NTSTATUS
BuildNtLanmanResponsePrologue(
    PSMB_EXCHANGE              pExchange,
    PUNICODE_STRING            pUserName,
    PUNICODE_STRING            pDomainName,
    PSTRING                    pCaseSensitiveResponse,
    PSTRING                    pCaseInsensitiveResponse,
    PSECURITY_RESPONSE_CONTEXT pResponseContext);


extern NTSTATUS
BuildNtLanmanResponseEpilogue(
    PSECURITY_RESPONSE_CONTEXT pResponseContext);

// routines from smbadmin.c

extern NTSTATUS
SmbCeNegotiate(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PMRX_SRV_CALL         pSrvCall);

extern NTSTATUS
SmbCeDisconnect(
    PSMBCEDB_SERVER_ENTRY  pServerEntry,
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry);

extern NTSTATUS
SmbCeLogOff(
    PSMBCEDB_SERVER_ENTRY  pServerEntry,
    PSMBCEDB_SESSION_ENTRY pSessionEntry);


#endif   // _IFSPROCS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\makefile.inc ===
$(O)\umt_stff.res: ..\umt_stff.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\locks.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    locks.c

Abstract:

    This module implements the mini redirector call down routines pertaining to locks
    of file system objects.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOCKCTRL)

NTSTATUS
SmbPseExchangeStart_Locks(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

ULONG MRxSmbSrvLockBufSize = 0xffff;
ULONG MRxSmbLockSendOptions = 0;     //use the default options

NTSTATUS
MRxSmbBuildFlush (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
MRxIfsLocks(
    IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine handles network requests for filelocks

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbLocks\n", 0 ));

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    OrdinaryExchange = SmbPseCreateOrdinaryExchange(
                           RxContext,
                           capFobx->pSrvOpen->pVNetRoot,
                           SMBPSE_OE_FROM_LOCKS,
                           SmbPseExchangeStart_Locks
                           );

    if (OrdinaryExchange==NULL) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    if (Status != STATUS_PENDING) {
        BOOLEAN FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
        ASSERT(FinalizationComplete);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbLocks  exit with status=%08lx\n", Status ));
    ASSERT (Status != STATUS_NOT_SUPPORTED);

    return(Status);
}

NTSTATUS
MRxSmbBuildLocksAndX (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a LockingAndX SMB for a single unlock or a single lock.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:

--*/
{
    NTSTATUS        Status;
    PRX_CONTEXT     RxContext = StufferState->RxContext;
    PLOWIO_CONTEXT  LowIoContext = &RxContext->LowIoContext;

    RxCaptureFcb;
    RxCaptureFobx;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)StufferState->Exchange;
    PSMBCE_SERVER pServer = &StufferState->Exchange->SmbCeContext.pServerEntry->Server;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);

    BOOLEAN UseNtVersion = TRUE;

    PLARGE_INTEGER ByteOffsetAsLI,LengthAsLI;
    USHORT NumberOfLocks,NumberOfUnlocks;
    ULONG UseLargeOffsets;
    BOOLEAN UseLockList = FALSE;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildLocksAndX\n"));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    UseLargeOffsets = (UseNtVersion)?LOCKING_ANDX_LARGE_FILES:0;

    switch (LowIoContext->Operation) {
    case LOWIO_OP_SHAREDLOCK:
    case LOWIO_OP_EXCLUSIVELOCK:
        NumberOfLocks = 1; NumberOfUnlocks = 0;
        break;
    case LOWIO_OP_UNLOCK:
        NumberOfLocks = 0; NumberOfUnlocks = 1;
        break;
    case LOWIO_OP_UNLOCK_MULTIPLE:
        NumberOfLocks = 0; NumberOfUnlocks = 1;
        UseLockList = TRUE;
        break;
    }

    if (!UseLockList) {
        ByteOffsetAsLI = (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.ByteOffset;
        LengthAsLI = (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.Length;
    } else {
        //it's okay that this code is big.....see the C.I. above
        PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
        PLOWIO_LOCK_LIST LockList = rw->LockList;
        ByteOffsetAsLI = (PLARGE_INTEGER)&LockList->ByteOffset;
        LengthAsLI = (PLARGE_INTEGER)&LockList->Length;
        RxDbgTrace(0, Dbg, ("MRxSmbBuildLocksAndX using locklist, byteoffptr,lengthptr=%08lx,%08lx\n",
                                               ByteOffsetAsLI, LengthAsLI ));

    }

    if (FlagOn(pServer->DialectFlags,DF_NT_SMBS)) {
        ULONG SharedLock = (LowIoContext->Operation==LOWIO_OP_SHAREDLOCK);
        ULONG Timeout = (LowIoContext->ParamsFor.Locks.Flags&LOWIO_LOCKSFLAG_FAIL_IMMEDIATELY)?0:0xffffffff;

        COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_Never, SMB_COM_LOCKING_ANDX,
                                SMB_REQUEST_SIZE(LOCKING_ANDX),
                                NO_EXTRA_DATA,NO_SPECIAL_ALIGNMENT,RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                     );


        MRxSmbStuffSMB (StufferState,
             "XwwDwwB?",
                                        //  X         UCHAR WordCount;                    // Count of parameter words = 8
                                        //            UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
                                        //            UCHAR AndXReserved;                 // Reserved (must be 0)
                                        //            _USHORT( AndXOffset );              // Offset to next command WordCount
                  smbSrvOpen->Fid,      //  w         _USHORT( Fid );                     // File handle
                                        //
                                        //            //
                                        //            // When NT protocol is not negotiated the OplockLevel field is
                                        //            // omitted, and LockType field is a full word.  Since the upper
                                        //            // bits of LockType are never used, this definition works for
                                        //            // all protocols.
                                        //            //
                                        //
                  SharedLock            //  w         UCHAR( LockType );                  // Locking mode:
                      +UseLargeOffsets,
                                        //                                                //  bit 0: 0 = lock out all access
                                        //                                                //         1 = read OK while locked
                                        //                                                //  bit 1: 1 = 1 user total file unlock
                                        //            UCHAR( OplockLevel );               // The new oplock level
                  SMB_OFFSET_CHECK(LOCKING_ANDX,Timeout)
                  Timeout,              //  D         _ULONG( Timeout );
                  NumberOfUnlocks,      //  w         _USHORT( NumberOfUnlocks );         // Num. unlock range structs following
                  NumberOfLocks,        //  w         _USHORT( NumberOfLocks );           // Num. lock range structs following
                  SMB_WCT_CHECK(8) 0
                                        //  B?         _USHORT( ByteCount );               // Count of data bytes
                                        //            UCHAR Buffer[1];                    // Buffer containing:
                                        //            //LOCKING_ANDX_RANGE Unlocks[];     //  Unlock ranges
                                        //            //LOCKING_ANDX_RANGE Locks[];       //  Lock ranges
                 );


        //NTversion

        MRxSmbStuffSMB (StufferState,
             "wwdddd!",
                                           //        typedef struct _NT_LOCKING_ANDX_RANGE {
                  MRXSMB_PROCESS_ID     ,  //  w         _USHORT( Pid );                     // PID of process "owning" lock
                  0,                       //  w         _USHORT( Pad );                     // Pad to DWORD align (mbz)
                  ByteOffsetAsLI->HighPart,//  d         _ULONG( OffsetHigh );               // Ofset to bytes to [un]lock (high)
                  ByteOffsetAsLI->LowPart, //  d         _ULONG( OffsetLow );                // Ofset to bytes to [un]lock (low)
                  LengthAsLI->HighPart,    //  d         _ULONG( LengthHigh );               // Number of bytes to [un]lock (high)
                  LengthAsLI->LowPart      //  d         _ULONG( LengthLow );                // Number of bytes to [un]lock (low)
                                           //        } NTLOCKING_ANDX_RANGE;
                 );

    } else {
        //lockbyterange and unlockbyterange have the same format......
        COVERED_CALL(MRxSmbStartSMBCommand ( StufferState, SetInitialSMB_Never,
                                               (UCHAR)((NumberOfLocks==0)?SMB_COM_UNLOCK_BYTE_RANGE
                                                                :SMB_COM_LOCK_BYTE_RANGE),
                                               SMB_REQUEST_SIZE(LOCK_BYTE_RANGE),
                                               NO_EXTRA_DATA,NO_SPECIAL_ALIGNMENT,RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                               0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                                            );


        ASSERT(ByteOffsetAsLI->HighPart==0);
        ASSERT(LengthAsLI->HighPart==0);

        MRxSmbStuffSMB (StufferState,
            "0wddB!",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 5
               smbSrvOpen->Fid,         //  w         _USHORT( Fid );                     // File handle
               LengthAsLI->LowPart,     //  d         _ULONG( Count );                    // Count of bytes to lock
               ByteOffsetAsLI->LowPart, //  d         _ULONG( Offset );                   // Offset from start of file
                                        //  B!        _USHORT( ByteCount );               // Count of data bytes = 0
                  SMB_WCT_CHECK(5) 0
                                        //            UCHAR Buffer[1];                    // empty
                 );

    }

FINALLY:
    RxDbgTraceUnIndent(-1, Dbg);
    return(Status);
}

NTSTATUS
MRxSmbBuildLockAssert (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a LockingAndX SMB for multiple locks by calling the lock enumerator.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:

--*/
{
    NTSTATUS        Status;
    PRX_CONTEXT     RxContext = StufferState->RxContext;
    PLOWIO_CONTEXT  LowIoContext = &RxContext->LowIoContext;

    RxCaptureFcb;
    RxCaptureFobx;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)StufferState->Exchange;
    PSMBCE_SERVER pServer = &StufferState->Exchange->SmbCeContext.pServerEntry->Server;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);

    PRX_LOCK_ENUMERATOR LockEnumerator = OrdinaryExchange->AssertLocks.LockEnumerator;
    ULONG UseLargeOffsets;
    BOOLEAN LocksExclusiveForThisPacket = TRUE;
    PBYTE PtrToLockCount;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildLockAssert enum=%08lx\n",LockEnumerator));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT(smbSrvOpen->Fid != 0xffff);

    RxDbgTrace(0,Dbg,("Oplock response for FID(%lx)\n",smbSrvOpen->Fid));

    UseLargeOffsets = FlagOn(pServer->DialectFlags,DF_NT_SMBS)?LOCKING_ANDX_LARGE_FILES:0;
    //UseLargeOffsets = FALSE;

    OrdinaryExchange->AssertLocks.NumberOfLocksPlaced = 0;
    for (;;) {

        ASSERT_ORDINARY_EXCHANGE ( OrdinaryExchange );

        RxDbgTrace(0, Dbg, ("top of loop %08lx %08lx %08lx\n",
                  OrdinaryExchange->AssertLocks.NumberOfLocksPlaced,
                  OrdinaryExchange->AssertLocks.LockAreaNonEmpty,
                  OrdinaryExchange->AssertLocks.EndOfListReached
                  ));

        if (!OrdinaryExchange->AssertLocks.EndOfListReached
              && !OrdinaryExchange->AssertLocks.LockAreaNonEmpty) {
            //get a new lock

            if (LockEnumerator(
                    OrdinaryExchange->AssertLocks.SrvOpen,
                    &OrdinaryExchange->AssertLocks.ContinuationHandle,
                    &OrdinaryExchange->AssertLocks.NextLockOffset,
                    &OrdinaryExchange->AssertLocks.NextLockRange,
                    &OrdinaryExchange->AssertLocks.NextLockIsExclusive
                    )){
                OrdinaryExchange->AssertLocks.LockAreaNonEmpty = TRUE;
            } else {
                OrdinaryExchange->AssertLocks.LockAreaNonEmpty = FALSE;
                OrdinaryExchange->AssertLocks.EndOfListReached = TRUE;
                OrdinaryExchange->AssertLocks.NextLockIsExclusive = TRUE;
            }
        }

        RxDbgTrace(0, Dbg, ("got a lockorempty %08lx %08lx %08lx\n",
                  OrdinaryExchange->AssertLocks.NumberOfLocksPlaced,
                  OrdinaryExchange->AssertLocks.LockAreaNonEmpty,
                  OrdinaryExchange->AssertLocks.EndOfListReached
                  ));

        if (OrdinaryExchange->AssertLocks.NumberOfLocksPlaced == 0){

            ULONG Timeout = 0xffffffff;
            ULONG SharedLock = !OrdinaryExchange->AssertLocks.NextLockIsExclusive;

            LocksExclusiveForThisPacket = OrdinaryExchange->AssertLocks.NextLockIsExclusive;

            COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_Never, SMB_COM_LOCKING_ANDX,
                                    SMB_REQUEST_SIZE(LOCKING_ANDX),
                                    NO_EXTRA_DATA,NO_SPECIAL_ALIGNMENT,RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                         );



            MRxSmbStuffSMB (StufferState,
                 "XwrwDwrwB?",
                                            //  X         UCHAR WordCount;                    // Count of parameter words = 8
                                            //            UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
                                            //            UCHAR AndXReserved;                 // Reserved (must be 0)
                                            //            _USHORT( AndXOffset );              // Offset to next command WordCount
                      smbSrvOpen->Fid,      //  w         _USHORT( Fid );                     // File handle
                                            //
                                            //            //
                                            //            // When NT protocol is not negotiated the OplockLevel field is
                                            //            // omitted, and LockType field is a full word.  Since the upper
                                            //            // bits of LockType are never used, this definition works for
                                            //            // all protocols.
                                            //            //
                                            //
                                            //  rw         UCHAR( LockType );                  // Locking mode:
                      &OrdinaryExchange->AssertLocks.PtrToLockType,0,
                      SharedLock+UseLargeOffsets,
                                            //                                                //  bit 0: 0 = lock out all access
                                            //                                                //         1 = read OK while locked
                                            //                                                //  bit 1: 1 = 1 user total file unlock
                                            //            UCHAR( OplockLevel );               // The new oplock level
                      SMB_OFFSET_CHECK(LOCKING_ANDX,Timeout)
                      Timeout,              //  D         _ULONG( Timeout );
                      0,                    //  w         _USHORT( NumberOfUnlocks );         // Num. unlock range structs following
                                            // rw         _USHORT( NumberOfLocks );           // Num. lock range structs following
                      &PtrToLockCount,0,
                      0,
                      SMB_WCT_CHECK(8) 0
                                            //  B?         _USHORT( ByteCount );               // Count of data bytes
                                            //            UCHAR Buffer[1];                    // Buffer containing:
                                            //            //LOCKING_ANDX_RANGE Unlocks[];     //  Unlock ranges
                                            //            //LOCKING_ANDX_RANGE Locks[];       //  Lock ranges
                     );
            ASSERT_ORDINARY_EXCHANGE ( OrdinaryExchange );
            RxDbgTrace(0, Dbg, ("PTRS %08lx %08lx\n",
                      OrdinaryExchange->AssertLocks.PtrToLockType,
                      PtrToLockCount
                      ));
        }

        if (OrdinaryExchange->AssertLocks.EndOfListReached
             || (LocksExclusiveForThisPacket != OrdinaryExchange->AssertLocks.NextLockIsExclusive)
             || (OrdinaryExchange->AssertLocks.NumberOfLocksPlaced >= 20) ){
            break;
        }

        ASSERT_ORDINARY_EXCHANGE ( OrdinaryExchange );
        if (UseLargeOffsets) {
            MRxSmbStuffSMB (StufferState,
                 "wwdddd?",
                                               //        typedef struct _NT_LOCKING_ANDX_RANGE {
                      MRXSMB_PROCESS_ID     ,  //  w         _USHORT( Pid );                     // PID of process "owning" lock
                      0,                       //  w         _USHORT( Pad );                     // Pad to DWORD align (mbz)
                                               //  d         _ULONG( OffsetHigh );               // Ofset to bytes to [un]lock (high)
                      OrdinaryExchange->AssertLocks.NextLockOffset.HighPart,
                                               //  d         _ULONG( OffsetLow );                // Ofset to bytes to [un]lock (low)
                      OrdinaryExchange->AssertLocks.NextLockOffset.LowPart,
                                               //  d         _ULONG( LengthHigh );               // Number of bytes to [un]lock (high)
                      OrdinaryExchange->AssertLocks.NextLockRange.HighPart,
                                               //  d         _ULONG( LengthLow );                // Number of bytes to [un]lock (low)
                      OrdinaryExchange->AssertLocks.NextLockRange.LowPart,
                                               //        } NTLOCKING_ANDX_RANGE;
                      0
                     );
        } else {
            MRxSmbStuffSMB (StufferState,
                 "wdd?",
                     MRXSMB_PROCESS_ID     ,   //         typedef struct _LOCKING_ANDX_RANGE {
                                               //   w         _USHORT( Pid );                     // PID of process "owning" lock
                                               //   d         _ULONG( Offset );                   // Ofset to bytes to [un]lock
                      OrdinaryExchange->AssertLocks.NextLockOffset.LowPart,
                                               //   d         _ULONG( Length );                   // Number of bytes to [un]lock
                      OrdinaryExchange->AssertLocks.NextLockRange.LowPart,
                                               //         } LOCKING_ANDX_RANGE;
                      0
                     );
        }

        ASSERT_ORDINARY_EXCHANGE ( OrdinaryExchange );
        OrdinaryExchange->AssertLocks.NumberOfLocksPlaced += 1;
        SmbPutUshort(PtrToLockCount, (USHORT)(OrdinaryExchange->AssertLocks.NumberOfLocksPlaced));
        OrdinaryExchange->AssertLocks.LockAreaNonEmpty = FALSE;
        ASSERT_ORDINARY_EXCHANGE ( OrdinaryExchange );

    }

    MRxSmbStuffSMB (StufferState, "!",  0);  //fill in the bytecount

FINALLY:
    RxDbgTraceUnIndent(-1, Dbg);
    return(Status);

}

NTSTATUS
SmbPseExchangeStart_Locks(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the start routine for locks AND for flush.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    ULONG StartEntryCount;

    SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    PSMBCE_SERVER pServer = &OrdinaryExchange->SmbCeContext.pServerEntry->Server;

    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    BOOLEAN  SynchronousIo = !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Locks\n", 0 ));

    ASSERT(OrdinaryExchange->Type == ORDINARY_EXCHANGE);
    ASSERT( (OrdinaryExchange->SmbCeFlags&SMBCE_EXCHANGE_ATTEMPT_RECONNECTS) == 0 );

    OrdinaryExchange->StartEntryCount++;
    StartEntryCount = OrdinaryExchange->StartEntryCount;

    // Ensure that the Fid is validated
    SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);

    for (;;) {
        switch (OrdinaryExchange->OpSpecificState) {
        case SmbPseOEInnerIoStates_Initial:
            OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;
            if (!SynchronousIo) {
                OrdinaryExchange->Continuation = SmbPseExchangeStart_Locks;
            }
            MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));
            rw->MaximumSmbBufferSize = min(MRxSmbSrvLockBufSize,
                                       pServer->MaximumBufferSize
                                             - QuadAlign(sizeof(SMB_HEADER)+
                                                         FIELD_OFFSET(REQ_LOCKING_ANDX,Buffer[0])
                                                        )
                                       );

            rw->LockList = LowIoContext->ParamsFor.Locks.LockList;

            //lack of break is intentional
        case SmbPseOEInnerIoStates_ReadyToSend:
            OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_OperationOutstanding;
            OrdinaryExchange->SendOptions = MRxSmbLockSendOptions;

            switch (OrdinaryExchange->EntryPoint) {
            case SMBPSE_OE_FROM_FLUSH:
                OEType = SMBPSE_OETYPE_FLUSH;
                COVERED_CALL(MRxSmbBuildFlush(StufferState));
                break;
            case SMBPSE_OE_FROM_ASSERTBUFFEREDLOCKS:
                OEType = SMBPSE_OETYPE_ASSERTBUFFEREDLOCKS;
                COVERED_CALL(MRxSmbBuildLockAssert(StufferState));
                if ((OrdinaryExchange->AssertLocks.EndOfListReached)
                      && (OrdinaryExchange->AssertLocks.NumberOfLocksPlaced == 0) ) {
                   OrdinaryExchange->SendOptions = RXCE_SEND_SYNCHRONOUS;
                   OrdinaryExchange->SmbCeFlags |= SMBCE_EXCHANGE_MID_VALID;
                   OrdinaryExchange->Mid        = SMBCE_OPLOCK_RESPONSE_MID;
                   OrdinaryExchange->Flags |= SMBPSE_OE_FLAG_NO_RESPONSE_EXPECTED;
                   *(OrdinaryExchange->AssertLocks.PtrToLockType) |= 2;
                }
                break;
            case SMBPSE_OE_FROM_LOCKS:
                OEType = SMBPSE_OETYPE_LOCKS;
                switch (LowIoContext->Operation) {
                case LOWIO_OP_SHAREDLOCK:
                    if (!FlagOn(pServer->DialectFlags,DF_NT_SMBS)) {
                        DbgPrint("SharedLOCK!!!! %08lx %08lx \n",RxContext,LowIoContext);
                        DbgBreakPoint();
                        Status = STATUS_NOT_SUPPORTED;
                        goto FINALLY;
                    }
                    //no break intentional
                case LOWIO_OP_EXCLUSIVELOCK:
                    if (!FlagOn(pServer->DialectFlags,DF_NT_SMBS)) {
                        PLARGE_INTEGER ByteOffsetAsLI,LengthAsLI;
                        ByteOffsetAsLI = (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.ByteOffset;
                        LengthAsLI = (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.Length;
                        if ((ByteOffsetAsLI->HighPart!=0) || (LengthAsLI->HighPart!=0) ) {
                            Status = STATUS_NOT_SUPPORTED;
                            goto FINALLY;
                        }
                    }
                    //no break intentional
                case LOWIO_OP_UNLOCK:
                    rw->LockList = NULL;
                    COVERED_CALL(MRxSmbBuildLocksAndX(StufferState));
                    break;
                case LOWIO_OP_UNLOCK_MULTIPLE: {
                    RxDbgTrace(0, Dbg, ("--->in locks_start, remaining locklist=%08lx\n", rw->LockList));
                    ASSERT( rw->LockList != NULL );
                    COVERED_CALL(MRxSmbBuildLocksAndX(StufferState));
                    break;
                    }
                default:
                    ASSERT(!"Bad lowio op for locks\n");
                    Status = STATUS_NOT_IMPLEMENTED;
                    goto FINALLY;
                }
                break;
            default:
                ASSERT(!"Bad entrypoint for locks_start\n");
                Status = STATUS_NOT_IMPLEMENTED;
                goto FINALLY;
            }

            Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                            OEType
                                            );
            if (Status == STATUS_PENDING) {
                ASSERT(!SynchronousIo);
                goto FINALLY;
            }
            //lack of break is intentional
        case SmbPseOEInnerIoStates_OperationOutstanding:
            OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;
            Status = OrdinaryExchange->SmbStatus;

            switch (OrdinaryExchange->EntryPoint) {
            case SMBPSE_OE_FROM_FLUSH:
                goto FINALLY;
                //break;
            case SMBPSE_OE_FROM_ASSERTBUFFEREDLOCKS:
                if ((OrdinaryExchange->AssertLocks.EndOfListReached)
                      && (OrdinaryExchange->AssertLocks.NumberOfLocksPlaced == 0) ) {
                    goto FINALLY;
                }
                MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0));
                break;
            case SMBPSE_OE_FROM_LOCKS:
                // if the locklist is empty. we can get out. this can happen either because we're not using
                // the locklist OR because we advance to the end of the list. that's why there are two checks
                if (rw->LockList == NULL) goto FINALLY;
                rw->LockList = rw->LockList->Next;
                if (rw->LockList == 0) goto FINALLY;

                if (Status != STATUS_SUCCESS) { goto FINALLY; }
                MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0));
                break;
            }
            break;
        }
    }

FINALLY:
    if ( Status != STATUS_PENDING) {
        SmbPseAsyncCompletionIfNecessary(OrdinaryExchange,RxContext);
    }

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Locks exit w %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbFinishLocks (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_LOCKING_ANDX             Response
      )
/*++

Routine Description:

    This routine actually gets the stuff out of the Close response and finishes the locks.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;


    RxDbgTrace(+1, Dbg, ("MRxSmbFinishLocks\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishLocks:");

    ASSERT( (Response->WordCount==2));

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishLocks   returning %08lx\n", Status ));
    return Status;
}



NTSTATUS
MRxIfsCompleteBufferingStateChangeRequest(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRX_SRV_OPEN   SrvOpen,
    IN     PVOID       pContext
    )
/*++

Routine Description:

    This routine is called to assert the locks that the wrapper has buffered. currently, it is synchronous!


Arguments:

    RxContext - the open instance
    SrvOpen   - tells which fcb is to be used.
    LockEnumerator - the routine to call to get the locks

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSMBSTUFFER_BUFFER_STATE StufferState = NULL;
    PMRX_FCB Fcb = SrvOpen->pFcb;

    USHORT NewOplockLevel = (USHORT)(pContext);

    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;


    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCompleteBufferingStateChangeRequest\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    RxDbgTrace(0,Dbg,("@@@@@@ Old Level (%lx) to New Level %lx @@@@\n",smbSrvOpen->OplockLevel,NewOplockLevel));
    if ((smbSrvOpen->OplockLevel == SMB_OPLOCK_LEVEL_II) &&
        (NewOplockLevel == SMB_OPLOCK_LEVEL_NONE)) {
       return STATUS_SUCCESS;
    }
    smbSrvOpen->OplockLevel = (UCHAR)NewOplockLevel;
    OrdinaryExchange = SmbPseCreateOrdinaryExchange(RxContext,
                                                    SrvOpen->pVNetRoot,
                                                    SMBPSE_OE_FROM_ASSERTBUFFEREDLOCKS,
                                                    SmbPseExchangeStart_Locks
                                                    );
    if (OrdinaryExchange==NULL) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    // The SERVER has a time window of 45 seconds associated with OPLOCK responses.
    // During this period oplock responses ( the last packet ) do not elicit any
    // response. If the response at the server is received after this window has
    // elapsed the OPLOCK response will elicit a normal LOCKING_ANDX response from
    // the server. In order to simplify the MID reuse logic at the clients without
    // violating the OPLOCK semantics, all the final responses are sent on a special
    // MID(0xffff). Any response received with this MID is accepted by default and this
    // MID is not used further.
    OrdinaryExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_REUSE_MID;
    OrdinaryExchange->AssertLocks.LockEnumerator = RxLockEnumerator;
    OrdinaryExchange->AssertLocks.SrvOpen = SrvOpen;

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status != STATUS_PENDING);
    if (Status != STATUS_PENDING) {
        BOOLEAN FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
        ASSERT(FinalizationComplete);
    }
    RxDbgTrace(-1, Dbg, ("MRxSmbAssertBufferedFileLocks  exit with status=%08lx\n", Status ));
    return(Status);
}


#undef  Dbg
#define Dbg                              (DEBUG_TRACE_FLUSH)

NTSTATUS
MRxSmbBuildFlush (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a Flush SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS    Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildFlush\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_Never, SMB_COM_FLUSH,
                                SMB_REQUEST_SIZE(FLUSH),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );


    MRxSmbStuffSMB (StufferState,
         "0wB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 1
             smbSrvOpen->Fid,       //  w         _USHORT( Fid );                     // File handle
             SMB_WCT_CHECK(1) 0     //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);
}


NTSTATUS
MRxIfsFlush(
      IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine handles network requests for file flush

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;

    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFlush\n"));

    if (TypeOfOpen == RDBSS_NTC_SPOOLFILE) {
        //we don't buffer spoolfiles....just get out....
        RxDbgTrace(-1, Dbg, ("MRxSmbFlush exit on spoolfile\n"));
        return(STATUS_SUCCESS);
    }

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    OrdinaryExchange = SmbPseCreateOrdinaryExchange(
                           RxContext,
                           capFobx->pSrvOpen->pVNetRoot,
                           SMBPSE_OE_FROM_FLUSH,
                           SmbPseExchangeStart_Locks
                           );

    if (OrdinaryExchange==NULL) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status != STATUS_PENDING);
    if (Status != STATUS_PENDING) {
        BOOLEAN FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
        ASSERT(FinalizationComplete);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFlush  exit with status=%08lx\n", Status ));

    return(Status);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\init.c ===
/*++

Copyright (c) 1989-1996  Microsoft Corporation

Module Name:

    Init.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the IFSSMB mini rdr.

--*/

#include "precomp.h"
#pragma  hdrstop

#include "ntverp.h"

#include "ifsmrx.h"

#define RDBSS_DRIVER_LOAD_STRING L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Rdbss"

//
// Global data declarations.
//

MRXIFS_STATE MRxIfsState = MRXIFS_STARTABLE;

MRX_IFS_STATISTICS MRxIfsStatistics;

FAST_MUTEX   MRxIfsSerializationMutex;

MRXIFS_CONFIGURATION MRxIfsConfiguration;

SMBCE_CONTEXT SmbCeContext;
PMDL          s_pEchoSmbMdl = NULL;
ULONG         s_EchoSmbLength = 0;

#ifdef EXPLODE_POOLTAGS
ULONG         MRxIfsExplodePoolTags = 1;
#else
ULONG         MRxIfsExplodePoolTags = 0;
#endif


//
// Mini Redirector global variables.
//


//
//  This is the minirdr dispatch table. It is initialized by MRxIfsInitializeTables.
//  This table will be used by the wrapper to call into this minirdr
//

struct _MINIRDR_DISPATCH  MRxIfsDispatch;


//
// Pointer to the device Object for this minirdr. Since the device object is created
// by the wrapper when this minirdr registers, this pointer is initialized in the
// DriverEntry routine below (see RxRegisterMinirdr)
//

PRDBSS_DEVICE_OBJECT      MRxIfsDeviceObject;


MRXIFS_GLOBAL_PADDING     MRxIfsCeGlobalPadding;

//declare the shadow debugtrace controlpoints

RXDT_DefineCategory(CREATE);
RXDT_DefineCategory(CLEANUP);
RXDT_DefineCategory(CLOSE);
RXDT_DefineCategory(READ);
RXDT_DefineCategory(WRITE);
RXDT_DefineCategory(LOCKCTRL);
RXDT_DefineCategory(FLUSH);
RXDT_DefineCategory(PREFIX);
RXDT_DefineCategory(FCBSTRUCTS);
RXDT_DefineCategory(DISPATCH);
RXDT_DefineCategory(EA);
RXDT_DefineCategory(DEVFCB);

//
// The following enumerated values signify the current state of the minirdr
// initialization. With the aid of this state information, it is possible
// to determine which resources to deallocate, whether deallocation comes
// as a result of a normal stop/unload, or as the result of an exception
//

typedef enum _MRxIfs_INIT_STATES {
    MRXIFSINIT_ALL_INITIALIZATION_COMPLETED,
    MRXIFSINIT_MINIRDR_REGISTERED,
    MRXIFSINIT_START
} MRXIFS_INIT_STATES;

//
// function prototypes
//

extern NTSTATUS
MRxIfsInitializeTables(
          void
    );

extern VOID
MRxIfsUnload(
    IN PDRIVER_OBJECT DriverObject
    );

extern NTSTATUS
SmbCeGetConfigurationInformation();

VOID
MRxIfsInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN MRXIFS_INIT_STATES MRxSmbInitState
    );


NTSTATUS
MRxIfsFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This is the initialization routine for the SMB mini redirector

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    RXSTATUS - The function value is the final status from the initialization
        operation.

--*/
{
    NTSTATUS       Status;
    MRXIFS_INIT_STATES MRxIfsInitState = 0;
    UNICODE_STRING IfsMiniRedirectorName;

    PRX_CONTEXT RxContext = NULL;


#ifdef MONOLITHIC_MINIRDR
    DbgPrint("InitWrapper\n");
    Status =  RxDriverEntry(DriverObject, RegistryPath);
    DbgPrint("BackFromInitWrapper %08lx\n",Status);
    if (Status != STATUS_SUCCESS) {
        DbgPrint("Wrapper failed to initialize. Status = %08lx\n",Status);
        return(Status);
    }
#endif

    //
    // Initialize Minirdr specific statistics to zero, and place the current
    // system time in the statistics block for future reference
    //

    RtlZeroMemory(&MRxIfsStatistics,sizeof(MRxIfsStatistics));

    KeQuerySystemTime(&MRxIfsStatistics.StatisticsStartTime);


    //
    // Zero the Global Padding and build a non-paged MDL
    //


    RtlZeroMemory(&MRxIfsCeGlobalPadding,sizeof(MRxIfsCeGlobalPadding));

    MmInitializeMdl(&MRxIfsCeGlobalPadding.Mdl,
                    &MRxIfsCeGlobalPadding.Pad[0],
                    SMBCE_PADDING_DATA_SIZE);

    MmBuildMdlForNonPagedPool(&MRxIfsCeGlobalPadding.Mdl);

    ExInitializeFastMutex(&MRxIfsSerializationMutex);


    //
    // Creating an empty list of transports which can be used by this minirdr
    //

    Status = MRxIfsInitializeTransport();

    if (Status != STATUS_SUCCESS) {
       RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxIfsDriverEntry failed to init transport data structures: %08lx\n", Status ));
       return(STATUS_UNSUCCESSFUL);
    }


    try {
        MRxIfsInitState = MRXIFSINIT_START;


        //
        //  Register this minirdr with the connection engine. Registration makes the connection
        //  engine aware of the device name, driver object, and other characteristics.
        //  If registration is successful, a new device object is returned
        //
        //
        //  The name of the device is "IfsSampleMiniRedirector"
        //


        RtlInitUnicodeString(&IfsMiniRedirectorName,  DD_IFSMRX_FS_DEVICE_NAME_U);

        RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRXIFSDriverEntry: DriverObject =%08lx\n", DriverObject ));


        Status = RxRegisterMinirdr(
                     &MRxIfsDeviceObject,          // where the new device object goes
                     DriverObject,                // the Driver Object to register
                     &MRxIfsDispatch,             // the dispatch table for this driver
                     TRUE,TRUE,                   // register with unc and for mailslots
                     &IfsMiniRedirectorName,      // the device name for this minirdr
                     0,                           // IN ULONG DeviceExtensionSize,
                     0                            // IN ULONG DeviceCharacteristics
                     );

        if (Status!=STATUS_SUCCESS) {
            RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxIfsDriverEntry failed: %08lx\n", Status ));
            try_return(Status);
        }


        MRxIfsInitState = MRXIFSINIT_MINIRDR_REGISTERED;


        //
        // Build the dispatch tables for the minirdr
        //

        Status = MRxIfsInitializeTables();

        if (!NT_SUCCESS( Status )) {
            try_return(Status);
        }

        //
        // Get information from the registry
        //

        Status = SmbCeGetConfigurationInformation();

        if (!NT_SUCCESS( Status )) {
            try_return(Status);
        }

  try_exit: NOTHING;
    } finally {
        if (Status != STATUS_SUCCESS) {

            MRxIfsInitUnwind(DriverObject,MRxIfsInitState);
        }
    }

    if (Status != STATUS_SUCCESS) {

        DbgPrint("MRxIfs failed to start with %08lx %08lx\n",Status,MRxIfsInitState);
        return(Status);
    }


    //
    //  Setup Unload Routine
    //

    DriverObject->DriverUnload = MRxIfsUnload;

    //
    //setup the driverdispatch for people who come in here directly....like the browser
    //

    {
        ULONG i;

        for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
        {
            DriverObject->MajorFunction[i] = (PDRIVER_DISPATCH)MRxIfsFsdDispatch;
        }
    }

#if 0
    RxContext = RxCreateRxContext(
                    NULL,
                    MRxIfsDeviceObject,
                    RX_CONTEXT_FLAG_IN_FSP);

    if (RxContext != NULL) {
        Status = RxStartMinirdr(
                     RxContext,
                     &RxContext->PostRequest);


        if (Status == STATUS_SUCCESS) {
            MRXIFS_STATE State;

            State = (MRXIFS_STATE)InterlockedCompareExchange(
                         (PVOID *)&MRxIfsState,
                         (PVOID)MRXIFS_STARTED,
                         (PVOID)MRXIFS_STARTABLE);

            if (State != MRXIFS_STARTABLE) {
                Status = STATUS_REDIRECTOR_STARTED;
            }
        }

        RxDereferenceAndDeleteRxContext(RxContext);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
#endif

    return  STATUS_SUCCESS;
}



VOID
MRxIfsInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN MRXIFS_INIT_STATES MRxIfsInitState
    )
/*++

Routine Description:

     This routine does the common uninit work for unwinding from a bad driver entry or for unloading.

Arguments:

     RxInitState - tells how far we got into the intialization

Return Value:

     None

--*/

{
    PAGED_CODE();

    switch (MRxIfsInitState) {
    case MRXIFSINIT_ALL_INITIALIZATION_COMPLETED:

        //Nothing extra to do...this is just so that the constant in RxUnload doesn't change.......
        //lack of break intentional

    case MRXIFSINIT_MINIRDR_REGISTERED:
        RxUnregisterMinirdr(MRxIfsDeviceObject);

        //lack of break intentional

    case MRXIFSINIT_START:
        break;
    }

}

VOID
MRxIfsUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

     This is the unload routine for the SMB mini redirector.

Arguments:

     DriverObject - pointer to the driver object for the MRxIfs

Return Value:

     None

--*/

{
    PRX_CONTEXT RxContext;
    NTSTATUS    Status;

    PAGED_CODE();
    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxIfsUnload: DriverObject =%08lx\n", DriverObject) );


    MRxIfsInitUnwind(DriverObject,MRXIFSINIT_ALL_INITIALIZATION_COMPLETED);

    RxContext = RxCreateRxContext(
                    NULL,
                    MRxIfsDeviceObject,
                    RX_CONTEXT_FLAG_IN_FSP);

    if (RxContext != NULL) {
        Status = RxStopMinirdr(
                     RxContext,
                     &RxContext->PostRequest);


        if (Status == STATUS_SUCCESS) {
            MRXIFS_STATE State;

            State = (MRXIFS_STATE)InterlockedCompareExchange(
                         (PVOID *)&MRxIfsState,
                         (PVOID)MRXIFS_STARTED,
                         (PVOID)MRXIFS_STARTABLE);

            if (State != MRXIFS_STARTABLE) {
                Status = STATUS_REDIRECTOR_STARTED;
            }
        }

        RxDereferenceAndDeleteRxContext(RxContext);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

#ifdef MONOLITHIC_MINIRDR
    RxUnload(DriverObject);
#endif

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxIfsUnload exit: DriverObject =%08lx\n", DriverObject) );
}



NTSTATUS
MRxIfsInitializeTables(
          void
    )
/*++

Routine Description:

     This routine sets up the mini redirector dispatch vector and also calls
     to initialize any other tables needed.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    //
    // Ensure that the SMB mini redirector context satisfies the size constraints
    //
    ASSERT(sizeof(MRXIFS_RX_CONTEXT) <= MRX_CONTEXT_SIZE);

    //
    // Build the local minirdr dispatch table and initialize
    //

    ZeroAndInitializeNodeType( &MRxIfsDispatch, RDBSS_NTC_MINIRDR_DISPATCH, sizeof(MINIRDR_DISPATCH));

    //
    // SMB mini redirector extension sizes and allocation policies.
    //


    MRxIfsDispatch.MRxFlags = (RDBSS_MANAGE_FCB_EXTENSION |
                               RDBSS_MANAGE_SRV_OPEN_EXTENSION |
                               RDBSS_MANAGE_FOBX_EXTENSION);

    MRxIfsDispatch.MRxSrvCallSize  = 0;
    MRxIfsDispatch.MRxNetRootSize  = 0;
    MRxIfsDispatch.MRxVNetRootSize = 0;
    MRxIfsDispatch.MRxFcbSize      = sizeof(MRX_SMB_FCB);
    MRxIfsDispatch.MRxSrvOpenSize  = sizeof(MRX_SMB_SRV_OPEN);
    MRxIfsDispatch.MRxFobxSize     = sizeof(MRX_SMB_FOBX);

    // Transport update handler

    MRxIfsDispatch.MRxTransportUpdateHandler = MRxIfsTransportUpdateHandler;

    // Mini redirector cancel routine ..

    MRxIfsDispatch.MRxCancel = NULL;

    //
    // Mini redirector Start/Stop. Each mini-rdr can be started or stopped
    // while the others continue to operate.
    //

    MRxIfsDispatch.MRxStart                = MRxIfsStart;
    MRxIfsDispatch.MRxStop                 = MRxIfsStop;
    MRxIfsDispatch.MRxDevFcbXXXControlFile = MRxIfsDevFcbXXXControlFile;

    //
    // Mini redirector name resolution.
    //

    MRxIfsDispatch.MRxCreateSrvCall       = MRxIfsCreateSrvCall;
    MRxIfsDispatch.MRxSrvCallWinnerNotify = MRxIfsSrvCallWinnerNotify;
    MRxIfsDispatch.MRxCreateVNetRoot      = MRxIfsCreateVNetRoot;
    MRxIfsDispatch.MRxUpdateNetRootState  = MRxIfsUpdateNetRootState;
    MRxIfsDispatch.MRxExtractNetRootName  = MRxIfsExtractNetRootName;
    MRxIfsDispatch.MRxFinalizeSrvCall     = MRxIfsFinalizeSrvCall;
    MRxIfsDispatch.MRxFinalizeNetRoot     = MRxIfsFinalizeNetRoot;
    MRxIfsDispatch.MRxFinalizeVNetRoot    = MRxIfsFinalizeVNetRoot;

    //
    // File System Object Creation/Deletion.
    //

    MRxIfsDispatch.MRxCreate            = MRxIfsCreate;
    MRxIfsDispatch.MRxCollapseOpen      = MRxIfsCollapseOpen;
    MRxIfsDispatch.MRxExtendForCache    = MRxIfsExtendFile;
    MRxIfsDispatch.MRxTruncate          = MRxIfsTruncate;
    MRxIfsDispatch.MRxCleanupFobx       = MRxIfsCleanupFobx;
    MRxIfsDispatch.MRxCloseSrvOpen      = MRxIfsCloseSrvOpen;
    MRxIfsDispatch.MRxFlush             = MRxIfsFlush;
    MRxIfsDispatch.MRxForceClosed       = MRxIfsForcedClose;
    MRxIfsDispatch.MRxDeallocateForFcb  = MRxIfsDeallocateForFcb;
    MRxIfsDispatch.MRxDeallocateForFobx = MRxIfsDeallocateForFobx;

    //
    // File System Objects query/Set
    //

    MRxIfsDispatch.MRxQueryDirectory       = MRxIfsQueryDirectory;
    MRxIfsDispatch.MRxQueryVolumeInfo      = MRxIfsQueryVolumeInformation;
    MRxIfsDispatch.MRxQueryEaInfo          = MRxIfsQueryEaInformation;
    MRxIfsDispatch.MRxSetEaInfo            = MRxIfsSetEaInformation;
    MRxIfsDispatch.MRxQuerySdInfo          = MRxIfsQuerySecurityInformation;
    MRxIfsDispatch.MRxSetSdInfo            = MRxIfsSetSecurityInformation;
    MRxIfsDispatch.MRxQueryFileInfo        = MRxIfsQueryFileInformation;
    MRxIfsDispatch.MRxSetFileInfo          = MRxIfsSetFileInformation;
    MRxIfsDispatch.MRxSetFileInfoAtCleanup = MRxIfsSetFileInformationAtCleanup;

    //
    // Buffering state change
    //

    MRxIfsDispatch.MRxComputeNewBufferingState = MRxIfsComputeNewBufferingState;

    //
    // File System Object I/O
    //

    MRxIfsDispatch.MRxLowIOSubmit[LOWIO_OP_READ]            = MRxIfsRead;
    MRxIfsDispatch.MRxLowIOSubmit[LOWIO_OP_WRITE]           = MRxIfsWrite;
    MRxIfsDispatch.MRxLowIOSubmit[LOWIO_OP_SHAREDLOCK]      = MRxIfsLocks;
    MRxIfsDispatch.MRxLowIOSubmit[LOWIO_OP_EXCLUSIVELOCK]   = MRxIfsLocks;
    MRxIfsDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK]          = MRxIfsLocks;
    MRxIfsDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK_MULTIPLE] = MRxIfsLocks;
    MRxIfsDispatch.MRxLowIOSubmit[LOWIO_OP_FSCTL]           = MRxIfsFsCtl;
    MRxIfsDispatch.MRxLowIOSubmit[LOWIO_OP_IOCTL]           = MRxIfsIoCtl;

    MRxIfsDispatch.MRxLowIOSubmit[LOWIO_OP_NOTIFY_CHANGE_DIRECTORY] = MRxIfsNotifyChangeDirectory;

    //
    // Miscellanous
    //

    MRxIfsDispatch.MRxCompleteBufferingStateChangeRequest = MRxIfsCompleteBufferingStateChangeRequest;

    //
    // callout to initialize other tables
    //

    SmbPseInitializeTables();

    return(STATUS_SUCCESS);
}




NTSTATUS
MRxIfsStart(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

     This routine completes the initialization of the mini redirector fromn the
     RDBSS perspective. Note that this is different from the initialization done
     in DriverEntry. Any initialization that depends on RDBSS should be done as
     part of this routine while the initialization that is independent of RDBSS
     should be done in the DriverEntry routine.

Arguments:

    RxContext - Supplies the Irp that was used to startup the rdbss

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    //
    // Initialize the SMB connection engine
    //

    Status = SmbCeDbInit();

    if (NT_SUCCESS(Status))
    {
        //
        // Initialize the echo processing context.
        //

        Status = MRxIfsInitializeEchoProcessingContext();
    }


    return Status;
}





NTSTATUS
MRxIfsStop(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    This routine is used to activate the mini redirector from the RDBSS perspective

Arguments:

    RxContext - the context that was used to start the mini redirector

    pContext  - the SMB mini rdr context passed in at registration time.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;


    // Cancel the echo processing timer request.

    Status = RxCancelTimerRequest(
                 MRxIfsDeviceObject,
                 SmbCeProbeServers,
                 &EchoProbeContext);

    if (Status != STATUS_SUCCESS)
    {
       SmbCeAcquireSpinLock();

       KeInitializeEvent(&EchoProbeContext.CancelCompletionEvent,
                         NotificationEvent,FALSE);

       EchoProbeContext.Flags |= ECHO_PROBE_CANCELLED_FLAG;

       SmbCeReleaseSpinLock();

       //
       // The request is currently active. Wait for it to be completed.
       //

       KeWaitForSingleObject(&EchoProbeContext.CancelCompletionEvent,
                             Executive,KernelMode,
                             FALSE,
                             NULL);
    }

    // Tear down the connection engine database

    SmbCeDbTearDown();

    // Uninitialize the transport related data structures

    MRxIfsUninitializeTransport();

    // Uninitialize the echo processing context

    MRxIfsTearDownEchoProcessingContext();

    // Deallocate the configuration strings ....

    if (SmbCeContext.ComputerName.Buffer != NULL)
    {
       RxFreePool(SmbCeContext.ComputerName.Buffer);
    }

    if (SmbCeContext.OperatingSystem.Buffer != NULL)
    {
       RxFreePool(SmbCeContext.OperatingSystem.Buffer);
    }

    if (SmbCeContext.LanmanType.Buffer != NULL)
    {
       RxFreePool(SmbCeContext.LanmanType.Buffer);
    }

    if (SmbCeContext.Transports.Buffer != NULL)
    {
       RxFreePool(SmbCeContext.Transports.Buffer);
    }

    if (s_pNegotiateSmb != NULL)
    {
       RxFreePool(s_pNegotiateSmb);
    }

    return(STATUS_SUCCESS);
}



NTSTATUS
MRxIfsInitializeSecurity (VOID)
/*++

Routine Description:

    This routine initializes the SMB miniredirector security .

Arguments:

    None.

Return Value:

    None.

Note:

    This API can only be called from a FS process.

--*/
{
   NTSTATUS Status = STATUS_SUCCESS;

   ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

   return Status;
}


NTSTATUS
MRxIfsUninitializeSecurity(VOID)
/*++

Routine Description:

Arguments:

    None.

Return Value:

    None.

Note:

    This API can only be called from a FS process.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    return Status;
}

#define IFSMRX_CONFIG_COMPUTER_NAME \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName"

#define COMPUTERNAME L"ComputerName"

#define IFSMRX_CONFIG_TRANSPORTS \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\IfsMrx\\Linkage"

#define TRANSPORT_BINDINGS L"Bind"


NTSTATUS
SmbCeGetConfigurationInformation()
{
   ULONG            Storage[256];
   UNICODE_STRING   UnicodeString;
   HANDLE           hRegistryKey;
   HANDLE           hSmbMrxConfiguration;
   HANDLE           ParametersHandle;
   NTSTATUS         Status;
   ULONG            BytesRead;

   OBJECT_ATTRIBUTES ObjectAttributes;
   PKEY_VALUE_FULL_INFORMATION Value = (PKEY_VALUE_FULL_INFORMATION)Storage;

   PAGED_CODE();

   RtlInitUnicodeString(&SmbCeContext.OperatingSystem, NULL);
   RtlInitUnicodeString(&SmbCeContext.LanmanType, NULL);

   RtlInitUnicodeString(&UnicodeString, RDR_CONFIG_CURRENT_WINDOWS_VERSION);

   InitializeObjectAttributes(
       &ObjectAttributes,
       &UnicodeString,             // name
       OBJ_CASE_INSENSITIVE,       // attributes
       NULL,                       // root
       NULL);                      // security descriptor

   Status = ZwOpenKey (&hRegistryKey, KEY_READ, &ObjectAttributes);
   if (!NT_SUCCESS(Status)) {
       return Status;
   }

   RtlInitUnicodeString(&UnicodeString, RDR_CONFIG_OPERATING_SYSTEM);
   Status = ZwQueryValueKey(
               hRegistryKey,
               &UnicodeString,
               KeyValueFullInformation,
               Value,
               sizeof(Storage),
               &BytesRead);

   if (NT_SUCCESS(Status)) {
      SmbCeContext.OperatingSystem.MaximumLength =
          SmbCeContext.OperatingSystem.Length = (USHORT)Value->DataLength +
                                     sizeof(RDR_CONFIG_OPERATING_SYSTEM_NAME) - sizeof(WCHAR);

      SmbCeContext.OperatingSystem.Buffer = RxAllocatePoolWithTag(
                                                 PagedPool,
                                                 SmbCeContext.OperatingSystem.Length,
                                                 MRXIFS_MISC_POOLTAG);

      if (SmbCeContext.OperatingSystem.Buffer != NULL) {
         RtlCopyMemory(SmbCeContext.OperatingSystem.Buffer,
                       RDR_CONFIG_OPERATING_SYSTEM_NAME,
                       sizeof(RDR_CONFIG_OPERATING_SYSTEM_NAME));

         RtlCopyMemory((SmbCeContext.OperatingSystem.Buffer +
                        (sizeof(RDR_CONFIG_OPERATING_SYSTEM_NAME)/sizeof(WCHAR)) - 1),
                       (PCHAR)Value+Value->DataOffset,
                       Value->DataLength);
      } else {
         Status = STATUS_INSUFFICIENT_RESOURCES;
      }
   }

   if (NT_SUCCESS(Status)) {
      RtlInitUnicodeString(&UnicodeString, RDR_CONFIG_OPERATING_SYSTEM_VERSION);
      Status = ZwQueryValueKey(
                     hRegistryKey,
                     &UnicodeString,
                     KeyValueFullInformation,
                     Value,
                     sizeof(Storage),
                     &BytesRead);

      if (NT_SUCCESS(Status)) {
         SmbCeContext.LanmanType.MaximumLength =
             SmbCeContext.LanmanType.Length = (USHORT)Value->DataLength +
                                    sizeof(RDR_CONFIG_OPERATING_SYSTEM_NAME) -
                                    sizeof(WCHAR);

         SmbCeContext.LanmanType.Buffer = RxAllocatePoolWithTag(
                                             PagedPool,
                                             SmbCeContext.LanmanType.Length,
                                             MRXIFS_MISC_POOLTAG);
         if (SmbCeContext.LanmanType.Buffer != NULL) {
            RtlCopyMemory(
                  SmbCeContext.LanmanType.Buffer,
                  RDR_CONFIG_OPERATING_SYSTEM_NAME,
                  sizeof(RDR_CONFIG_OPERATING_SYSTEM_NAME));

            RtlCopyMemory(
                  (SmbCeContext.LanmanType.Buffer +
                   (sizeof(RDR_CONFIG_OPERATING_SYSTEM_NAME)/sizeof(WCHAR)) - 1),
                  (PCHAR)Value+Value->DataOffset,
                  Value->DataLength);
         } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
         }
      }
   }

   ZwClose(hRegistryKey);

   // Obtain the computer name. This is used in formulating the local NETBIOS address
   RtlInitUnicodeString(&SmbCeContext.ComputerName, NULL);
   RtlInitUnicodeString(&UnicodeString, IFSMRX_CONFIG_COMPUTER_NAME);

   InitializeObjectAttributes(
       &ObjectAttributes,
       &UnicodeString,             // name
       OBJ_CASE_INSENSITIVE,       // attributes
       NULL,                       // root
       NULL);                      // security descriptor

   Status = ZwOpenKey (&hRegistryKey, KEY_READ, &ObjectAttributes);
   if (!NT_SUCCESS(Status)) {
       return Status;
   }

   RtlInitUnicodeString(&UnicodeString, COMPUTERNAME);
   Status = ZwQueryValueKey(
               hRegistryKey,
               &UnicodeString,
               KeyValueFullInformation,
               Value,
               sizeof(Storage),
               &BytesRead);

   if (NT_SUCCESS(Status)) {
      // Rtl conversion routines require NULL char to be excluded from the
      // length.
      SmbCeContext.ComputerName.MaximumLength =
          SmbCeContext.ComputerName.Length = (USHORT)Value->DataLength - sizeof(WCHAR);

      SmbCeContext.ComputerName.Buffer = RxAllocatePoolWithTag(
                                                PagedPool,
                                                SmbCeContext.ComputerName.Length,
                                                MRXIFS_MISC_POOLTAG);

      if (SmbCeContext.ComputerName.Buffer != NULL) {
         RtlCopyMemory(SmbCeContext.ComputerName.Buffer,
                       (PCHAR)Value+Value->DataOffset,
                       Value->DataLength - sizeof(WCHAR));
      } else {
         Status = STATUS_INSUFFICIENT_RESOURCES;
      }
   }

   ZwClose(hRegistryKey);

   // Obtain the list of transports associated with SMB redirector. This is stored
   // as a multivalued string and is used subsequently to weed out the
   // appropriate transports.
   RtlInitUnicodeString(&SmbCeContext.Transports, NULL);
   RtlInitUnicodeString(&UnicodeString, IFSMRX_CONFIG_TRANSPORTS);

   InitializeObjectAttributes(
       &ObjectAttributes,
       &UnicodeString,             // name
       OBJ_CASE_INSENSITIVE,       // attributes
       NULL,                       // root
       NULL);                      // security descriptor

   Status = ZwOpenKey (&hRegistryKey, KEY_READ, &ObjectAttributes);
   if (!NT_SUCCESS(Status)) {
       return Status;
   }

   RtlInitUnicodeString(&UnicodeString, TRANSPORT_BINDINGS);
   Status = ZwQueryValueKey(
               hRegistryKey,
               &UnicodeString,
               KeyValueFullInformation,
               Value,
               sizeof(Storage),
               &BytesRead);

   if (NT_SUCCESS(Status) &&
       (Value->DataLength > 0) &&
       (Value->Type == REG_MULTI_SZ)) {
      SmbCeContext.Transports.MaximumLength =
          SmbCeContext.Transports.Length = (USHORT)Value->DataLength;

      SmbCeContext.Transports.Buffer = RxAllocatePoolWithTag(
                                             PagedPool,
                                             SmbCeContext.Transports.Length,
                                             MRXIFS_MISC_POOLTAG);

      if (SmbCeContext.Transports.Buffer != NULL) {
         RtlCopyMemory(
            SmbCeContext.Transports.Buffer,
            (PCHAR)Value+Value->DataOffset,
            Value->DataLength);
      } else {
         SmbCeContext.Transports.Length = 0;
         Status = STATUS_INSUFFICIENT_RESOURCES;
      }
   } else {
      RxLog(("Invalid Transport Binding string... using all transports"));
   }

   ZwClose(hRegistryKey);

   return Status;

}


NTSTATUS
MRxIfsFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD dispatch for the smbmini DRIVER object. Arguments:

    DeviceObject - Supplies the device object for the packet being processed.

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The Fsd status for the Irp

--*/
{
    ASSERT(DeviceObject==(PDEVICE_OBJECT)MRxIfsDeviceObject);

    if (DeviceObject!=(PDEVICE_OBJECT)MRxIfsDeviceObject) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT );
        return (STATUS_INVALID_DEVICE_REQUEST);
    }

    return RxFsdDispatch((PRDBSS_DEVICE_OBJECT)MRxIfsDeviceObject,Irp);

}



NTSTATUS
MRxIfsDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    )
{

    return(STATUS_SUCCESS);
}



NTSTATUS
MRxIfsDeallocateForFobx (
    IN OUT PMRX_FOBX pFobx
    )
{
    PMRX_SMB_FOBX smbFobx = MRxIfsGetFileObjectExtension(pFobx);
    PMRX_SRV_OPEN SrvOpen = pFobx->pSrvOpen;
    PMRX_FCB Fcb = SrvOpen->pFcb;

    IF_DEBUG {
        if (smbFobx && FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_LOUD_FINALIZE)) {
            DbgPrint("Finalizobx side buffer %08lx %08lx %08lx %08lx %08lxon %wZ\n",
                     0, 0, //sidebuffer,count
                     smbFobx,pFobx,&Fcb->AlreadyPrefixedName
                     );
        }
    }

    return(STATUS_SUCCESS);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\fileinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements the mini redirector call down routines pertaining to retrieval/
    update of file/directory/volume information.


--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable



RXDT_DefineCategory(DIRCTRL);


#define Dbg        (DEBUG_TRACE_DIRCTRL)



BOOLEAN MRxSmbBypassDownLevelRename = FALSE;

ULONG UnalignedDirEntrySideBufferSize = 16384;



//
//  All T2Find requests to the remote server request the 32 bit resume key
//  so SMB_RFIND_BUFFER2 is used instead of SMB_FIND_BUFFER2.
//

typedef struct _SMB_FIND_BUFFER2_WITH_RESUME {
    _ULONG( ResumeKey );
    SMB_FIND_BUFFER2;
} SMB_FIND_BUFFER2_WITH_RESUME;
typedef SMB_FIND_BUFFER2_WITH_RESUME SMB_UNALIGNED *PSMB_FIND_BUFFER2_WITH_RESUME;

LIST_ENTRY MRxSmbSideBuffersList = {NULL,NULL};
ULONG MRxSmbSideBuffersSpinLock = 0;
ULONG MRxSmbSideBuffersCount = 0;
ULONG MRxSmbSideBuffersSerialNumber = 0;
BOOLEAN MRxSmbLoudSideBuffers = FALSE;

typedef struct _SIDE_BUFFER {
    LIST_ENTRY ListEntry;
    PMRX_FCB Fcb;
    PMRX_FOBX Fobx;
    PMRX_SMB_FOBX smbFobx;
    ULONG SerialNumber;
    BYTE Buffer;
} SIDE_BUFFER, *PSIDE_BUFFER;

#if DBG
#define MRxSmbAllocateSideBuffer(a,b,c,d) __MRxSmbAllocateSideBuffer(a,b,c,d)
#else
#define MRxSmbAllocateSideBuffer(a,b,c,d) __MRxSmbAllocateSideBuffer(a,b,c)
#endif
VOID
__MRxSmbAllocateSideBuffer(
    IN OUT PRX_CONTEXT     RxContext,
    IN OUT PMRX_SMB_FOBX   smbFobx,
    IN     USHORT          Setup
#if DBG
    ,IN     PUNICODE_STRING smbtemplate
#endif
    )
{
    RxCaptureFcb;RxCaptureFobx;
    PSIDE_BUFFER SideBuffer;
    ULONG SideBufferSize = UnalignedDirEntrySideBufferSize+sizeof(SIDE_BUFFER);

    ASSERT( smbFobx->Enumeration.UnalignedDirEntrySideBuffer == NULL);
    SideBuffer = (PSIDE_BUFFER)RxAllocatePoolWithTag(
                                    PagedPool,
                                    SideBufferSize,
                                    MRXSMB_DIRCTL_POOLTAG);
    if (SideBuffer==NULL) {
        return;
    }
    ASSERT( smbFobx->Enumeration.UnalignedDirEntrySideBuffer == NULL);
    SideBuffer->smbFobx = smbFobx;
    SideBuffer->Fobx = capFobx;
    SideBuffer->Fcb = capFcb;
    smbFobx->Enumeration.UnalignedDirEntrySideBuffer = &SideBuffer->Buffer;
    smbFobx->Enumeration.SerialNumber = SideBuffer->SerialNumber = InterlockedIncrement(&MRxSmbSideBuffersSerialNumber);
    InterlockedIncrement(&MRxSmbSideBuffersCount);
    if (MRxSmbSideBuffersList.Flink==NULL) {
        InitializeListHead(&MRxSmbSideBuffersList);
    }
    ExAcquireFastMutexUnsafe(&MRxIfsSerializationMutex);
    InsertTailList(&MRxSmbSideBuffersList,&SideBuffer->ListEntry);
    ExReleaseFastMutexUnsafe(&MRxIfsSerializationMutex);
    if (!MRxSmbLoudSideBuffers) return;
    KdPrint(("Allocating side buffer %08lx %08lx %08lx %08lx %08lxon <%wZ> %s %wZ\n",
                     &SideBuffer->Buffer,
                     MRxSmbSideBuffersCount,
                     smbFobx,capFobx,capFobx->pSrvOpen,
                     &capFcb->AlreadyPrefixedName,
                     (Setup == TRANS2_FIND_FIRST2)?"First":"Next",
                     smbtemplate
                     ));
}

VOID
MRxSmbDeallocateSideBuffer(
    IN OUT PRX_CONTEXT    RxContext,
    IN OUT PMRX_SMB_FOBX  smbFobx,
    IN     PSZ            where
    )
{
    PSIDE_BUFFER SideBuffer;

    RxCaptureFcb;RxCaptureFobx;

    if( smbFobx->Enumeration.UnalignedDirEntrySideBuffer == NULL) return;
    SideBuffer = CONTAINING_RECORD(smbFobx->Enumeration.UnalignedDirEntrySideBuffer,SIDE_BUFFER,Buffer);
    if (MRxSmbLoudSideBuffers){
        DbgPrint("D--------- side buffer %08lx %08lx %08lx %08lx %08lxon <%wZ> %s\n",
                         &SideBuffer->Buffer,
                         MRxSmbSideBuffersCount,
                         smbFobx,capFobx,capFobx->pSrvOpen,
                         &capFcb->AlreadyPrefixedName,
                         where
                         );
    }
    ASSERT(SideBuffer->Fobx == capFobx);
    ASSERT(SideBuffer->Fcb == capFcb);
    ASSERT(SideBuffer->smbFobx == smbFobx);
    ASSERT(smbFobx->Enumeration.SerialNumber == SideBuffer->SerialNumber);

    ExAcquireFastMutexUnsafe(&MRxIfsSerializationMutex);

    InterlockedDecrement(&MRxSmbSideBuffersCount);
    RemoveEntryList(&SideBuffer->ListEntry);

    ExReleaseFastMutexUnsafe(&MRxIfsSerializationMutex);

    RxFreePool(SideBuffer);
    smbFobx->Enumeration.UnalignedDirEntrySideBuffer = NULL;
}


VOID
MRxSmbTranslateLanManFindBuffer(
    PRX_CONTEXT RxContext,
    PULONG PreviousReturnedEntry,
    PBYTE ThisEntryInBuffer
    )
{
    RxCaptureFcb; RxCaptureFobx;
    PSMBCEDB_SERVER_ENTRY pServerEntry;
    PSMBCE_SERVER Server;
    ULONG FileInformationClass = RxContext->Info.FileInformationClass;
    PFILE_FULL_DIR_INFORMATION NtBuffer = (PFILE_FULL_DIR_INFORMATION)PreviousReturnedEntry;
    PSMB_FIND_BUFFER2_WITH_RESUME SmbBuffer = (PSMB_FIND_BUFFER2_WITH_RESUME)ThisEntryInBuffer;
    SMB_TIME Time;
    SMB_DATE Date;

    PAGED_CODE();
    if (FileInformationClass==FileNamesInformation) { return; }
    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    Server = &pServerEntry->Server;

    SmbMoveTime (&Time, &SmbBuffer->CreationTime);
    SmbMoveDate (&Date, &SmbBuffer->CreationDate);
    NtBuffer->CreationTime = MRxSmbConvertSmbTimeToTime(Server, Time, Date);

    SmbMoveTime (&Time, &SmbBuffer->LastAccessTime);
    SmbMoveDate (&Date, &SmbBuffer->LastAccessDate);
    NtBuffer->LastAccessTime = MRxSmbConvertSmbTimeToTime(Server, Time, Date);

    SmbMoveTime (&Time, &SmbBuffer->LastWriteTime);
    SmbMoveDate (&Date, &SmbBuffer->LastWriteDate);
    NtBuffer->LastWriteTime = MRxSmbConvertSmbTimeToTime(Server, Time, Date);

    NtBuffer->ChangeTime.QuadPart = 0;
    NtBuffer->EndOfFile.QuadPart = SmbGetUlong(&SmbBuffer->DataSize);
    NtBuffer->AllocationSize.QuadPart = SmbGetUlong(&SmbBuffer->AllocationSize);

    NtBuffer->FileAttributes = MRxSmbMapSmbAttributes(SmbBuffer->Attributes);

    if ((FileInformationClass==FileFullDirectoryInformation)
            || (FileInformationClass==FileBothDirectoryInformation)) {
        NtBuffer->EaSize = SmbGetUlong(&SmbBuffer->EaSize);
    }
}

NTSTATUS
MrxSmbUnalignedDirEntryCopyTail(
    IN OUT PRX_CONTEXT            RxContext,
    IN     FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID                  pBuffer,
    IN OUT PULONG                 pLengthRemaining,
    IN OUT PMRX_SMB_FOBX          smbFobx
    )
/*++

Routine Description:

   This routine copies the data from the side buffer into the users buffer and adjusts the
   lengths remaining appropriately. this is called either if the server doesn't do unicode (w95) OR
   if the server does not promise to quadalign entries OR if the user's buffer is not quadaligned.

   this routine can be entered after a T2 finishes or to copy the last entries from a previous T2. in the second case, the
   pUnalignedDirEntrySideBuffer ptr will be null and it will go to acquire the correct pointer from the smbFobx.

   this routine has the responsibility to free the sidebufferptr when it is exhausted.



Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
     NTSTATUS Status = STATUS_SUCCESS;
     RxCaptureFcb;
     ULONG i,NameSizeInUnicode;
     LONG LocalLengthRemaining;   //signed arithmetic makes it easier
     PULONG PreviousReturnedEntry;
     ULONG FileNameLengthOffset = smbFobx->Enumeration.FileNameLengthOffset;
     ULONG FileNameOffset = smbFobx->Enumeration.FileNameOffset;
     PBYTE UnalignedDirEntrySideBuffer = smbFobx->Enumeration.UnalignedDirEntrySideBuffer;
     BOOLEAN IsUnicode = smbFobx->Enumeration.IsUnicode;
     BOOLEAN IsNonNtT2Find = smbFobx->Enumeration.IsNonNtT2Find;
     PMRX_SMB_DIRECTORY_RESUME_INFO ResumeInfo = smbFobx->Enumeration.ResumeInfo;
     ULONG FilesReturned = smbFobx->Enumeration.FilesReturned;
     ULONG EntryOffset = smbFobx->Enumeration.EntryOffset;
     ULONG ReturnedEntryOffset;// = smbFobx->Enumeration.ReturnedEntryOffset;
     BOOLEAN EndOfSearchReached = smbFobx->Enumeration.EndOfSearchReached;
     ULONG TotalDataBytesReturned = smbFobx->Enumeration.TotalDataBytesReturned;
     BOOLEAN FilterFailure;

     LocalLengthRemaining = (LONG)(*pLengthRemaining);

     for (i=ReturnedEntryOffset=0;;) {
        ULONG FileNameLength,ThisEntrySize; PCHAR FileNameBuffer;
        UNICODE_STRING ReturnedFileName;
        OEM_STRING FileName;
        NTSTATUS StringStatus;
        BOOLEAN TwoExtraBytes = TRUE;
        ULONG resumekey,NextEntryOffsetinBuffer;
        PULONG PreviousPreviousReturnedEntry;
        PBYTE ThisEntryInBuffer = UnalignedDirEntrySideBuffer+EntryOffset;

        // don't EVER let yourself get past the data returned...servers return funny stuff.......
        if (EntryOffset>=TotalDataBytesReturned){
            DbgPrint("limits1: %08lx %08lx \n",EntryOffset+NextEntryOffsetinBuffer,TotalDataBytesReturned);
            FilterFailure = TRUE;
            FilesReturned = i; //we're done with this buffer........
            break;
        }

        if (!IsNonNtT2Find) {
            FileNameLength = SmbGetUlong(ThisEntryInBuffer+FileNameLengthOffset);
            FileNameBuffer = ThisEntryInBuffer+FileNameOffset;
            resumekey =  SmbGetUlong(ThisEntryInBuffer
                                             +FIELD_OFFSET(FILE_FULL_DIR_INFORMATION,FileIndex));
            NextEntryOffsetinBuffer = SmbGetUlong(ThisEntryInBuffer);
        } else {

            FileNameLength = *(ThisEntryInBuffer
                                  +FIELD_OFFSET(SMB_FIND_BUFFER2_WITH_RESUME,FileNameLength));
            FileNameBuffer = ThisEntryInBuffer
                                  +FIELD_OFFSET(SMB_FIND_BUFFER2_WITH_RESUME,FileName[0]);
            resumekey =  SmbGetUlong(ThisEntryInBuffer+
                                  +FIELD_OFFSET(SMB_FIND_BUFFER2_WITH_RESUME,ResumeKey));
            NextEntryOffsetinBuffer = FIELD_OFFSET(SMB_FIND_BUFFER2_WITH_RESUME,FileName[0])
                                              + FileNameLength + 1;  //the +1 is for the null..we could have said Filename{1]

            PreviousPreviousReturnedEntry = PreviousReturnedEntry; //save this for rollback on filterfail
        }

        // some servers lie about how many entries were returned and/or send partial entries
        if (EntryOffset+NextEntryOffsetinBuffer>TotalDataBytesReturned){
            DbgPrint("limits: %08lx %08lx \n",EntryOffset+NextEntryOffsetinBuffer,TotalDataBytesReturned);
            FilterFailure = TRUE;
            FilesReturned = i; //we're done with this buffer........
            break;
        }

        FileName.Buffer = FileNameBuffer;
        FileName.Length = (USHORT)FileNameLength;
        RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: EO,REO=%08lx,%08lx\n",
                                 EntryOffset,ReturnedEntryOffset));

        //check to see if this entry will fit
        if (IsUnicode) {
            NameSizeInUnicode = FileNameLength;
            RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: length=%08lx/%08lx, name = %wZ\n",
                                 FileNameLength,NameSizeInUnicode,&FileName));
        } else {
            NameSizeInUnicode = RtlxOemStringToUnicodeSize(&FileName)-sizeof(WCHAR);
            RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: length=%08lx/%08lx, name = %.*s\n",
                                 FileNameLength,NameSizeInUnicode,FileNameLength,FileNameBuffer));
        }

        ThisEntrySize = FileNameOffset+NameSizeInUnicode;
        if (((LONG)ThisEntrySize)>LocalLengthRemaining) {
            break;
        }
        if (((LONG)ThisEntrySize)>LocalLengthRemaining-(LONG)sizeof(WCHAR)) {
            TwoExtraBytes = FALSE;
        }


        ThisEntrySize = LongAlign(ThisEntrySize);
        PreviousReturnedEntry = (PULONG)(((PBYTE)pBuffer)+ReturnedEntryOffset);

        //now make sure that the next entry is quadaligned....we know that it's longaligned
        if (!IsPtrQuadAligned((ULONG)(PreviousReturnedEntry)+ThisEntrySize) ){
            ThisEntrySize += sizeof(ULONG);
        }
        if (i!=0) {
            ASSERT(IsPtrQuadAligned(PreviousReturnedEntry));
        }

        if (!IsNonNtT2Find) {
            //copy everything in the entry up to but not including the name info
            RtlCopyMemory(PreviousReturnedEntry,UnalignedDirEntrySideBuffer+EntryOffset,FileNameOffset);
        } else {
            IF_DEBUG {
                RtlZeroMemory(PreviousReturnedEntry,FileNameOffset);
            }
        }

        // store the length of this entry and the size of the name...if this is the last
        // entry returned, then the offset field will be cleared later
        *PreviousReturnedEntry = ThisEntrySize;
        *((PULONG)(((PBYTE)PreviousReturnedEntry)+FileNameLengthOffset)) = NameSizeInUnicode;

        //copy in the name  .........this is made difficult by the oem-->unicode routine that
        //             requires space for a NULL!

        RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: REO/buf/pentry=%08lx/%08lx/%08lx\n",
                                 pBuffer,ReturnedEntryOffset,PreviousReturnedEntry));
        ReturnedFileName.Buffer = (PWCH)(((PBYTE)PreviousReturnedEntry)+FileNameOffset);

        if (!IsUnicode) {
            if (TwoExtraBytes) {
                ReturnedFileName.MaximumLength = sizeof(WCHAR)+(USHORT)NameSizeInUnicode;
                RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: filenamebuf,length=%08lx/%08lx\n",
                                         ReturnedFileName.Buffer,ReturnedFileName.MaximumLength));
                StringStatus = RtlOemStringToUnicodeString(&ReturnedFileName,&FileName,FALSE); //false means don;t allocate
            } else {
                OEM_STRING LastChar;
                UNICODE_STRING LastCharInUnicode;
                WCHAR UnicodeCharBuffer[2];
                ReturnedFileName.MaximumLength = (USHORT)NameSizeInUnicode;
                FileName.Length -= 1;
                RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: filenamebuf,length=%08lx/%08lx\n",
                                         ReturnedFileName.Buffer,ReturnedFileName.MaximumLength));
                StringStatus = RtlOemStringToUnicodeString(&ReturnedFileName,&FileName,FALSE); //false means don;t allocate
                ASSERT(StringStatus==STATUS_SUCCESS);
                LastChar.Buffer = FileName.Buffer+FileName.Length;
                LastChar.Length = 1;
                LastCharInUnicode.Buffer = (PWCH)&UnicodeCharBuffer;
                LastCharInUnicode.MaximumLength = sizeof(UnicodeCharBuffer);
                StringStatus = RtlOemStringToUnicodeString(&LastCharInUnicode,&LastChar,FALSE); //false means don;t allocate
                *((PWCH)(((PBYTE)ReturnedFileName.Buffer)+ReturnedFileName.Length)) = UnicodeCharBuffer[0];
            }
            ASSERT(StringStatus==STATUS_SUCCESS);

            //spread out the shortname which has also been returned in ascii
            if ((FileInformationClass == FileBothDirectoryInformation) && !IsNonNtT2Find) {
                PFILE_BOTH_DIR_INFORMATION BothInfo = (PFILE_BOTH_DIR_INFORMATION)PreviousReturnedEntry;
                PBYTE NameAsSingleBytes = (PBYTE)(&BothInfo->ShortName[0]);
                ULONG ShortNameLength = BothInfo->ShortNameLength;

                if (ShortNameLength != 0) {
                    ULONG i;
                    for (i=ShortNameLength;;) {
                        i--;
                        BothInfo->ShortName[i] = *(NameAsSingleBytes+i);

                        if (i==0) {break;}
                    }
                }
                ShortNameLength += ShortNameLength; //convert to UNICODE length;

                BothInfo->ShortNameLength = (CHAR)ShortNameLength;
                IF_DEBUG {
                    UNICODE_STRING LastName;
                    LastName.Buffer = (PWCHAR)NameAsSingleBytes;
                    LastName.Length = (USHORT)ShortNameLength;
                    RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: unicodeshortnamename = %wZ\n", &LastName));
                }
            }
        } else {
            //here, it's already unicode.....just copy the bytes
            RtlCopyMemory(ReturnedFileName.Buffer,FileName.Buffer,FileName.Length);
        }

        IF_DEBUG {
            UNICODE_STRING LastName;
            LastName.Buffer = ReturnedFileName.Buffer;
            LastName.Length = (USHORT)NameSizeInUnicode;
            RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: unicodename = %wZ\n", &LastName));
        }

        //now...setup to resume based on this entry

        if (ResumeInfo != NULL) {
            PREQ_FIND_NEXT2 pFindNext2Request = &ResumeInfo->FindNext2_Request;

            pFindNext2Request->ResumeKey = resumekey;
            RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: resumekey = %08lx\n", resumekey));

            RtlCopyMemory(&pFindNext2Request->Buffer[0],FileNameBuffer,FileNameLength);

            //buffer is a UCHAR...not WCHAR
            if (IsUnicode) {
               // In the case of UNICODE strings an additional NULL is required ( WCHAR NULL )
               pFindNext2Request->Buffer[FileNameLength] = 0; //nullterminated
               pFindNext2Request->Buffer[FileNameLength + 1] = 0; //nullterminated

               smbFobx->Enumeration.ResumeInfo->ParametersLength
                     = &pFindNext2Request->Buffer[FileNameLength+2] - (PBYTE)pFindNext2Request;
            } else {
               pFindNext2Request->Buffer[FileNameLength] = 0; //nullterminated

               smbFobx->Enumeration.ResumeInfo->ParametersLength
                     = &pFindNext2Request->Buffer[FileNameLength+1] - (PBYTE)pFindNext2Request;
            }

        }


        //at this point, we have copied the name and the resume key. BUT, for nonnt we have to
        //filter the names so we still may have to roll back

        if (!IsNonNtT2Find) {
            FilterFailure = FALSE;
        } else {
            FilterFailure = FALSE;
            if (smbFobx->Enumeration.WildCardsFound ) {
                RxCaptureFobx;  //do this here so it's not on the NT path
                FilterFailure = !FsRtlIsNameInExpression( &capFobx->UnicodeQueryTemplate,
                                                          &ReturnedFileName, TRUE, NULL );
            }
            if (!FilterFailure) {
                //DbgPrint("Passed Filter %wZ\n",&ReturnedFileName);
                MRxSmbTranslateLanManFindBuffer(RxContext,PreviousReturnedEntry,ThisEntryInBuffer);
            } else {
                PreviousReturnedEntry = PreviousPreviousReturnedEntry; //rollback on filterfail
            }
        }

        if (!FilterFailure) {
            if (FALSE) {
                IF_DEBUG {
                    UNICODE_STRING LastName;
                    LastName.Buffer = ReturnedFileName.Buffer;
                    LastName.Length = (USHORT)NameSizeInUnicode;
                    DbgPrint("Adding %wZ\n",&LastName);
                }
            }
            LocalLengthRemaining -= ThisEntrySize;
            i++;
            ReturnedEntryOffset += ThisEntrySize;
        } else {
            FilesReturned--;
        }


        EntryOffset += NextEntryOffsetinBuffer;
        if ((i>=FilesReturned)
            ||(LocalLengthRemaining<0)
            || (RxContext->QueryDirectory.ReturnSingleEntry&&(i>0))  ) {
            break;
        }


     }

     //ASSERT(!IsNonNtT2Find);
     if (i==0) {
         Status = FilterFailure?STATUS_MORE_PROCESSING_REQUIRED:STATUS_BUFFER_OVERFLOW;
     } else {
        *PreviousReturnedEntry = 0;
     }

     if (LocalLengthRemaining <= 0) {
         *pLengthRemaining = 0;
     } else {
         *pLengthRemaining = (ULONG)LocalLengthRemaining;
     }

     if (i>=FilesReturned) {
         RxLog(("sidebufdealloc %lx %lx\n",RxContext,smbFobx));
         MRxSmbDeallocateSideBuffer(RxContext,smbFobx,"Tail");
         if (EndOfSearchReached) {
             //smbFobx->Enumeration.Flags &= ~SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN;
             //we will close the search handle when the user's handle closes
             smbFobx->Enumeration.ErrorStatus = STATUS_NO_MORE_FILES;
         }
     } else {
         //set up to resume here
         ASSERT(smbFobx->Enumeration.UnalignedDirEntrySideBuffer == UnalignedDirEntrySideBuffer);
         smbFobx->Enumeration.EntryOffset = EntryOffset;
         smbFobx->Enumeration.FilesReturned = FilesReturned - i;
     }

     return(Status);

}

NTSTATUS
MRxIfsQueryDirectory(
    IN OUT PRX_CONTEXT            RxContext
    )
/*++

Routine Description:

   This routine does a directory query. Only the NT-->NT path is implemented.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SMB_FOBX smbFobx = MRxIfsGetFileObjectExtension(capFobx);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);
    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID   Buffer;
    PULONG  pLengthRemaining;
    USHORT    SmbFileInfoLevel;
    BOOLEAN DirEntriesAreUaligned = FALSE;
    BOOLEAN IsUnicode = TRUE;
    USHORT SearchFlags = SMB_FIND_CLOSE_AT_EOS|SMB_FIND_RETURN_RESUME_KEYS;

#if DBG
    UNICODE_STRING smbtemplate = {0,0,NULL};
#endif

    TURN_BACK_ASYNCHRONOUS_OPERATIONS();
    FileInformationClass = RxContext->Info.FileInformationClass;
    Buffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;

    ASSERT (*pLengthRemaining<0x10000);

    RxDbgTrace(+1, Dbg, ("MRxSmbQueryDirectory: directory=<%wZ>\n",
                            &(capFcb->AlreadyPrefixedName)
                        ));

#define __GET_NAME_PARAMS_FOR_TYPE(___type___) { \
           smbFobx->Enumeration.FileNameOffset = (USHORT)FIELD_OFFSET(___type___,FileName[0]); \
           smbFobx->Enumeration.FileNameLengthOffset = (USHORT)FIELD_OFFSET(___type___,FileNameLength); \
           }

    switch (FileInformationClass) {

    case FileDirectoryInformation:
        SmbFileInfoLevel = SMB_FIND_FILE_DIRECTORY_INFO;
        __GET_NAME_PARAMS_FOR_TYPE(FILE_DIRECTORY_INFORMATION);
        break;
    case FileFullDirectoryInformation:
        SmbFileInfoLevel = SMB_FIND_FILE_FULL_DIRECTORY_INFO;
        __GET_NAME_PARAMS_FOR_TYPE(FILE_FULL_DIR_INFORMATION);
        break;
    case FileBothDirectoryInformation:
        SmbFileInfoLevel = SMB_FIND_FILE_BOTH_DIRECTORY_INFO;
        __GET_NAME_PARAMS_FOR_TYPE(FILE_BOTH_DIR_INFORMATION);
        break;
    case FileNamesInformation:
        SmbFileInfoLevel = SMB_FIND_FILE_NAMES_INFO;
        __GET_NAME_PARAMS_FOR_TYPE(FILE_NAMES_INFORMATION);
        break;
   default:
      RxDbgTrace( 0, Dbg, ("MRxSmbQueryDirectory: Invalid FS information class\n"));
      Status = STATUS_INVALID_PARAMETER;
      goto FINALLY;
   }

#if DBG
   if (MRxSmbLoudSideBuffers) {
       SetFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_LOUD_FINALIZE);
   }
#endif



   //
   // force the core operation
   //

   Status = MRxSmbCoreInformation(RxContext,
                                  (ULONG)SmbFileInfoLevel,
                                  Buffer,
                                  pLengthRemaining,
                                  SMBPSE_OE_FROM_QUERYDIRECTORY
                                  );

   return Status;



FINALLY:



   if (!NT_SUCCESS(Status)) {
        RxDbgTrace( 0, Dbg, ("MRxSmbQueryDirectory: Failed .. returning %lx\n",Status));
        smbFobx->Enumeration.ErrorStatus = Status;  //keep returning this
        MRxSmbDeallocateSideBuffer(RxContext,smbFobx,"ErrOut");

        if (smbFobx->Enumeration.ResumeInfo != NULL)
        {
            RxFreePool(smbFobx->Enumeration.ResumeInfo);
            smbFobx->Enumeration.ResumeInfo = NULL;
        }
   }

   RxDbgTraceUnIndent(-1,Dbg);
   return Status;
}



RXDT_DefineCategory(VOLINFO);
#undef Dbg
#define Dbg        (DEBUG_TRACE_VOLINFO)




NTSTATUS
MRxIfsQueryVolumeInformation(
      IN OUT PRX_CONTEXT          RxContext
      )
/*++

Routine Description:

   This routine queries the volume information

Arguments:

    pRxContext         - the RDBSS context

    FsInformationClass - the kind of Fs information desired.

    pBuffer            - the buffer for copying the information

    pBufferLength      - the buffer length ( set to buffer length on input and set
                         to the remaining length on output)

Return Value:

    NTSTATUS - The return status for the operation

--*/
{

   NTSTATUS Status;

   RxCaptureFcb;
   RxCaptureFobx;
   PMRX_SRV_OPEN     SrvOpen;
   PMRX_SMB_SRV_OPEN smbSrvOpen;
   FS_INFORMATION_CLASS FsInformationClass = RxContext->Info.FsInformationClass;
   PVOID                pBuffer = RxContext->Info.Buffer;
   PLONG                pLengthRemaining  = &RxContext->Info.LengthRemaining;

   PSMBCEDB_SERVER_ENTRY        pServerEntry;


   pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

   if ( FsInformationClass == FileFsDeviceInformation )
   {
        PFILE_FS_DEVICE_INFORMATION UsersBuffer = (PFILE_FS_DEVICE_INFORMATION)pBuffer;
        PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
        UsersBuffer->Characteristics = FILE_REMOTE_DEVICE;
        UsersBuffer->DeviceType = NetRoot->DeviceType;
        *pLengthRemaining  -= (sizeof(FILE_FS_DEVICE_INFORMATION));
        RxDbgTrace( 0, Dbg, ("MRxSmbQueryVolumeInformation: devinfo .. returning\n"));
        return STATUS_SUCCESS;
    }

    if (capFobx != NULL)
    {
       SrvOpen = capFobx->pSrvOpen;
       smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);
    }
    else
    {
       return STATUS_INVALID_PARAMETER;
    }

   TURN_BACK_ASYNCHRONOUS_OPERATIONS();

   Status = MRxSmbCoreInformation(RxContext,
                                  (ULONG)FsInformationClass,
                                  pBuffer,
                                  pLengthRemaining,
                                  SMBPSE_OE_FROM_QUERYVOLUMEINFO
                                  );


   return Status;

}



NTSTATUS
MRxIfsSetVolumeInformation(
      IN OUT PRX_CONTEXT              pRxContext
      )
/*++

Routine Description:

   This routine sets the volume information

Arguments:

    pRxContext - the RDBSS context

    FsInformationClass - the kind of Fs information desired.

    pBuffer            - the buffer for copying the information

    BufferLength       - the buffer length

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    return STATUS_NOT_IMPLEMENTED;
}



RXDT_DefineCategory(FILEINFO);
#undef Dbg
#define Dbg        (DEBUG_TRACE_FILEINFO)


NTSTATUS
MRxIfsQueryFileInformation(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine does a query file info. Only the NT-->NT path is implemented.

   The NT-->NT path works by just remoting the call basically without further ado.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;
    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID              pBuffer;
    PULONG             pLengthRemaining;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PMRX_SMB_FOBX     smbFobx    = MRxIfsGetFileObjectExtension(capFobx);
    PMRX_SRV_OPEN     SrvOpen    = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);

    USHORT SmbFileInfoLevel;



    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    FileInformationClass = RxContext->Info.FileInformationClass;
    pBuffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;

    RxDbgTrace(+1, Dbg, ("MRxSmbQueryFileInformation: class=%08lx\n",FileInformationClass));


    if ( FileInformationClass == FileInternalInformation ) {

        PFILE_INTERNAL_INFORMATION UsersBuffer = (PFILE_INTERNAL_INFORMATION)pBuffer;
        //
        //  Note: We use the address of the FCB to determine the
        //  index number of the file.  If we have to maintain persistance between
        //  file opens for this request, then we might have to do something
        //  like checksuming the reserved fields on a FUNIQUE SMB response.
        //

        UsersBuffer->IndexNumber.LowPart = (ULONG )capFcb;
        UsersBuffer->IndexNumber.LowPart = (ULONG)capFcb;
        UsersBuffer->IndexNumber.HighPart = 0;
        Status = STATUS_SUCCESS;
        *pLengthRemaining -= sizeof(FILE_INTERNAL_INFORMATION);
        RxDbgTrace(-1, Dbg, ("MRxSmbQueryFileInformation: internalinfo .. returning\n"));
        return STATUS_SUCCESS;
    }

    TURN_BACK_ASYNCHRONOUS_OPERATIONS();



    ASSERT (*pLengthRemaining<0x10000);


    switch (FileInformationClass) {

    case FilePipeLocalInformation:
    case FilePipeInformation:
    case FilePipeRemoteInformation:

       //
       // N.B. No pipe support in this example mini-rdr
       //

        return STATUS_NOT_IMPLEMENTED;

    case FileBasicInformation:
        SmbFileInfoLevel =  SMB_QUERY_FILE_BASIC_INFO;
        break;
    case FileStandardInformation:
        SmbFileInfoLevel =  SMB_QUERY_FILE_STANDARD_INFO;
        break;
    case FileEaInformation:
        SmbFileInfoLevel =  SMB_QUERY_FILE_EA_INFO;
        break;
    case FileAllocationInformation:
        SmbFileInfoLevel =  SMB_QUERY_FILE_ALLOCATION_INFO;
        break;
    case FileEndOfFileInformation:
        SmbFileInfoLevel =  SMB_QUERY_FILE_END_OF_FILEINFO;
        break;
    case FileAlternateNameInformation:
        SmbFileInfoLevel =  SMB_QUERY_FILE_ALT_NAME_INFO;
        break;
    case FileStreamInformation:
        SmbFileInfoLevel =  SMB_QUERY_FILE_STREAM_INFO;
        break;
    case FileCompressionInformation:
        SmbFileInfoLevel =  SMB_QUERY_FILE_COMPRESSION_INFO;
        break;
    default:
      RxDbgTrace( 0, Dbg, ("MRxSmbQueryFile: Invalid FS information class\n"));
      Status = STATUS_INVALID_PARAMETER;
      goto FINALLY;
   }


   Status = MRxSmbCoreInformation(RxContext,
                                  (ULONG)SmbFileInfoLevel,
                                  pBuffer,
                                  pLengthRemaining,
                                  SMBPSE_OE_FROM_QUERYFILEINFO
                                  );

FINALLY:

   if (!NT_SUCCESS(Status)) {
        RxDbgTrace( 0, Dbg, ("MRxSmbQueryFile: Failed .. returning %lx\n",Status));
   }
   RxDbgTraceUnIndent(-1,Dbg);
   return Status;
}



typedef enum _INTERESTING_SFI_FOLLOWONS {
    SFI_FOLLOWON_NOTHING,
    SFI_FOLLOWON_DISPOSITION_SENT
} INTERESTING_SFI_FOLLOWONS;


NTSTATUS
MRxIfsSetFileInformation(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine does a set file info. Only the NT-->NT path is implemented.

   The NT-->NT path works by just remoting the call basically without further ado.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;
    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID                  pBuffer;
    ULONG                  BufferLength;
    PMRX_SMB_FOBX smbFobx = MRxIfsGetFileObjectExtension(capFobx);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    USHORT  SmbFileInfoLevel;

    INTERESTING_SFI_FOLLOWONS FollowOn = SFI_FOLLOWON_NOTHING;



    TURN_BACK_ASYNCHRONOUS_OPERATIONS();


    FileInformationClass = RxContext->Info.FileInformationClass;
    pBuffer = RxContext->Info.Buffer;
    BufferLength = RxContext->Info.Length;
    RxDbgTrace(+1, Dbg, ("MRxSmbSetFile: Class %08lx size %08lx\n",FileInformationClass,BufferLength));

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    switch (FileInformationClass) {

    case FileBasicInformation:
        SmbFileInfoLevel =  SMB_SET_FILE_BASIC_INFO;
        break;
    case FileDispositionInformation:
        SmbFileInfoLevel =  SMB_SET_FILE_DISPOSITION_INFO;
        FollowOn = SFI_FOLLOWON_DISPOSITION_SENT;
        break;
    case FileAllocationInformation:
        SmbFileInfoLevel =  SMB_SET_FILE_ALLOCATION_INFO;
        break;
    case FileEndOfFileInformation:
        SmbFileInfoLevel =  SMB_SET_FILE_END_OF_FILE_INFO;
        break;
    case FileRenameInformation:
      if (!MRxSmbBypassDownLevelRename) {
          Status = MRxIfsRename(RxContext,FileInformationClass,pBuffer,BufferLength);
          goto FINALLY;
      }
   default:
      RxDbgTrace( 0, Dbg, ("MRxSmbSetFile: Invalid FS information class\n"));
      Status = STATUS_INVALID_PARAMETER;
      goto FINALLY;
   }

   Status =  MRxSmbCoreInformation(RxContext,
                                    FileInformationClass,
                                    pBuffer,
                                    &BufferLength,
                                    SMBPSE_OE_FROM_SETFILEINFO
                                   );

FINALLY:
   if (!NT_SUCCESS(Status)) {
        RxDbgTrace( 0, Dbg, ("MRxSmbSetFile: Failed .. returning %lx\n",Status));
   }
   RxDbgTraceUnIndent(-1,Dbg);
   return Status;
}





NTSTATUS
MRxIfsSetFileInformationAtCleanup(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine sets the file information on cleanup. the old rdr just swallows this operation (i.e.
   it doesn't generate it). we are doing the same..........

Arguments:

    pRxContext           - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{

   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\midatlas.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    midatlas.c

Abstract:

    This module defines the data structure used in mapping MIDS to the corresponding requests/
    contexts associated with them.

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#define ENTRY_TYPE_FREE_MID_LIST  (0x1)
#define ENTRY_TYPE_VALID_CONTEXT  (0x2)
#define ENTRY_TYPE_MID_MAP        (0x3)

#define ENTRY_TYPE_MASK           (0x3)

#define MID_MAP_FLAGS_CAN_BE_EXPANDED (0x1)
#define MID_MAP_FLAGS_FREE_POOL       (0x2)

typedef struct _MID_MAP_ {
   LIST_ENTRY  MidMapList;             // the list of MID maps in the MID atlas
   USHORT      MaximumNumberOfMids;    // the maximum number of MIDs in this map
   USHORT      NumberOfMidsInUse;      // the number of MIDs in use
   USHORT      BaseMid;                // the base MID associated with the map
   USHORT      IndexMask;              // the index mask for this map
   UCHAR       IndexAlignmentCount;    // the bits by which the index field is to be shifted
   UCHAR       IndexFieldWidth;        // the index field width
   UCHAR       Flags;                  // flags ...
   UCHAR       Level;                  // the level associated with this map ( useful for expansion )
   PVOID       *pFreeMidListHead;      // the list of free mid entries in this map
   PVOID       Entries[1];             // the MID map entries.
} MID_MAP, *PMID_MAP;



#define _GetEntryType(pEntry)                               \
        ((ULONG)(pEntry) & ENTRY_TYPE_MASK)


#define _GetEntryPointer(pEntry)                            \
        ((PVOID)((ULONG)pEntry & ~ENTRY_TYPE_MASK))

#define _MakeEntry(pContext,EntryType)                      \
        (PVOID)((ULONG)(pContext) | (EntryType))


/*++

Routine Description:

    This first MID_MAP instance in the list

Return Value:

    a valid PMID_MAP, NULL if none exists.

Notes:

    This routine assumes that the necessary concurrency control action has been taken

--*/

#define _GetFirstMidMap(pListHead)                        \
               (IsListEmpty(pListHead)                    \
                ? NULL                                    \
                : (PMID_MAP)                              \
                  (CONTAINING_RECORD((pListHead)->Flink,  \
                                     MID_MAP,             \
                                     MidMapList)))

//INLINE PSMBCEDB_SERVER_ENTRY GetNextMidMap(PLIST_ENTRY pListHead, PMID_MAP pMidMap)
/*++

Routine Description:

    This routine returns the next MID_MAP in the list

Arguments:

    pListHead    - the list of MID_MAP's

    pMidMap      - the current instance

Return Value:

    a valid PMID_MAP, NULL if none exists.

Notes:

    This routine assumes that the necessary concurrency control action has been taken

--*/

#define _GetNextMidMap(pListHead,pMidMap)                      \
           (((pMidMap)->MidMapList.Flink == pListHead)         \
            ? NULL                                             \
            : (PMID_MAP)                                       \
              (CONTAINING_RECORD((pMidMap)->MidMapList.Flink,  \
                                 MID_MAP,                      \
                                 MidMapList)))


//INLINE VOID _AddMidMap(
//            PLIST_ENTRY pListHead,
//            PMID_MAP    pMidMap)
/*++

Routine Description:

    This routine adds a MID_MAP instance to a list

Arguments:

    pListHead  - the list of MID_MAP's

    pMidMap    - the MID_MAP to be added

--*/

#define _AddMidMap(pListHead,pMidMap)                                       \
        {                                                                   \
           PMID_MAP pPredecessor;                                           \
           pPredecessor = _GetFirstMidMap(pListHead);                       \
           while (pPredecessor != NULL) {                                   \
              if (pPredecessor->Level < pMidMap->Level) {                   \
                 pPredecessor = _GetNextMidMap(pListHead,pPredecessor);     \
              } else {                                                      \
                 pPredecessor = (PMID_MAP)                                  \
                                CONTAINING_RECORD(                          \
                                     pPredecessor->MidMapList.Blink,        \
                                     MID_MAP,                               \
                                     MidMapList);                           \
                 break;                                                     \
              }                                                             \
           }                                                                \
                                                                            \
           if (pPredecessor == NULL) {                                      \
              InsertTailList(pListHead,&((pMidMap)->MidMapList));         \
           } else {                                                         \
              (pMidMap)->MidMapList.Flink = pPredecessor->MidMapList.Flink; \
              pPredecessor->MidMapList.Flink = &(pMidMap)->MidMapList;      \
                                                                            \
              (pMidMap)->MidMapList.Blink = &pPredecessor->MidMapList;      \
              (pMidMap)->MidMapList.Flink->Blink = &(pMidMap)->MidMapList;  \
           }                                                                \
        }


//INLINE VOID _RemoveMidMap(PMID_MAP pMidMap)
/*++

Routine Description:

    This routine removes a MID_MAP instance from the list

Arguments:

    pMidMap - the MID_MAP instance to be removed

--*/

#define _RemoveMidMap(pMidMap)   \
            RemoveEntryList(&(pMidMap)->MidMapList)



VOID
_InitializeMidMapFreeList(PMID_MAP pMidMap)
/*++

Routine Description:

   This routine initializes a MID_MAP data structure.

Arguments:

    pMidMap  - the MID_MAP instance to be initialized.

Notes:

--*/
{
   USHORT i;

   PULONG  pEntryValue     = (PULONG)&pMidMap->Entries[1];
   PVOID  *pEntriesPointer = (PVOID *)&pMidMap->Entries;


   pMidMap->pFreeMidListHead = pMidMap->Entries;
   for (i = 1; i <= pMidMap->MaximumNumberOfMids - 1;i++,pEntryValue++) {
      *pEntriesPointer++ = _MakeEntry(pEntryValue,ENTRY_TYPE_FREE_MID_LIST);
   }

   *pEntriesPointer = _MakeEntry(NULL,ENTRY_TYPE_FREE_MID_LIST);


}


PMID_ATLAS
IfsMrxCreateMidAtlas(
   USHORT MaximumNumberOfMids,
   USHORT MidsAllocatedAtStart)
/*++

Routine Description:

   This routine allocates a new instance of MID_ATLAS data structure.

Arguments:

    MaximumNumberOfMids  - the maximum number of MIDS in the atlas.

    MidsAllocatedAtStart - the number of MIDS allocated at start

Notes:

--*/
{
   PMID_ATLAS pMidAtlas;
   PMID_MAP   pMidMap;
   ULONG      AtlasSize;
   USHORT     MidsRoundedToPowerOf2;
   UCHAR      MidFieldWidth;


   if ((MidsAllocatedAtStart & (MidsAllocatedAtStart - 1)) != 0) {
      // Round off the Mids allocated at Start to a power of two
      MidsRoundedToPowerOf2 = 0x100;
      MidFieldWidth = 8;

      if (MidsAllocatedAtStart > MidsRoundedToPowerOf2) {
         while (MidsAllocatedAtStart > MidsRoundedToPowerOf2) {
            MidsRoundedToPowerOf2 = MidsRoundedToPowerOf2 << 1;
            MidFieldWidth++;
         }
      } else {
         while (MidsAllocatedAtStart < MidsRoundedToPowerOf2) {
            MidsRoundedToPowerOf2 = MidsRoundedToPowerOf2 >> 1;
            MidFieldWidth--;
         }

         MidFieldWidth++;
         MidsRoundedToPowerOf2 = MidsRoundedToPowerOf2 << 1;
      }
   } else {
      MidsRoundedToPowerOf2 = MidsAllocatedAtStart;
   }

   AtlasSize = sizeof(MID_ATLAS) +
               FIELD_OFFSET(MID_MAP,Entries);

   if (MaximumNumberOfMids == MidsAllocatedAtStart) {
      AtlasSize += (sizeof(PVOID) * MidsAllocatedAtStart);
   } else {
      AtlasSize += (sizeof(PVOID) * MidsRoundedToPowerOf2);
   }

   pMidAtlas = (PMID_ATLAS)RxAllocatePoolWithTag(
                              NonPagedPool,
                              AtlasSize,
                              MRXSMB_MIDATLAS_POOLTAG);
   if (pMidAtlas != NULL) {
      pMidMap = (PMID_MAP)(pMidAtlas + 1);

      pMidMap->Flags                 = 0;
      pMidAtlas->MaximumNumberOfMids = MaximumNumberOfMids;
      pMidAtlas->MidsAllocated       = MidsAllocatedAtStart;
      pMidAtlas->NumberOfMidsInUse = 0;

      pMidMap->MaximumNumberOfMids = MidsAllocatedAtStart;
      pMidMap->NumberOfMidsInUse   = 0;
      pMidMap->BaseMid             = 0;
      pMidMap->IndexMask           = MidsRoundedToPowerOf2 - 1;
      pMidMap->IndexAlignmentCount = 0;
      pMidMap->IndexFieldWidth     = MidFieldWidth;
      pMidMap->Level               = 1;

      InitializeListHead(&pMidAtlas->MidMapFreeList);
      InitializeListHead(&pMidAtlas->MidMapExpansionList);
      _InitializeMidMapFreeList(pMidMap);

      _AddMidMap(&pMidAtlas->MidMapFreeList,pMidMap);
      pMidAtlas->pRootMidMap = pMidMap;

      if (MaximumNumberOfMids > MidsAllocatedAtStart) {
         // Round off the maximum number of MIDS to determine the level and the
         // size of the quantum ( allocation increments)

         if ((MaximumNumberOfMids & (MaximumNumberOfMids - 1)) != 0) {
            // Round off the Mids allocated at Start to a power of two
            MidsRoundedToPowerOf2 = 0x100;
            if (MaximumNumberOfMids > MidsRoundedToPowerOf2) {
               while (MaximumNumberOfMids > MidsRoundedToPowerOf2) {
                  MidsRoundedToPowerOf2 = MidsRoundedToPowerOf2 << 1;
               }
            } else {
               while (MaximumNumberOfMids < MidsRoundedToPowerOf2) {
                  MidsRoundedToPowerOf2 = MidsRoundedToPowerOf2 >> 1;
               }

               MidsRoundedToPowerOf2 = MidsRoundedToPowerOf2 << 1;
            }
         } else {
            MidsRoundedToPowerOf2 = MaximumNumberOfMids;
         }

         pMidMap->Flags |= MID_MAP_FLAGS_CAN_BE_EXPANDED;

         pMidAtlas->MidQuantum           = 32;
         pMidAtlas->MidQuantumFieldWidth = 5;
         MidsRoundedToPowerOf2 = MidsRoundedToPowerOf2 >> (pMidMap->IndexAlignmentCount + 5);
         if (MidsRoundedToPowerOf2 > 0) {
            pMidAtlas->NumberOfLevels = 3;
         } else {
            pMidAtlas->NumberOfLevels = 2;
         }
      } else {
         pMidAtlas->MidQuantum     = 0;
         pMidAtlas->NumberOfLevels = 1;
         pMidMap->Flags &= ~MID_MAP_FLAGS_CAN_BE_EXPANDED;
      }
   }

   return pMidAtlas;
}

VOID
_UninitializeMidMap(
         PMID_MAP            pMidMap,
         PCONTEXT_DESTRUCTOR pContextDestructor)
/*++

Routine Description:

   This routine uninitializes a MID_MAP data structure.

Arguments:

    pMidMap            -- the MID_MAP instance to be uninitialized.

    pContextDestructor -- the context destructor
Notes:

--*/
{
   USHORT i;
   ULONG  EntryType;

   //DbgPrint("_UninitializeMidMap .. Entry No.Of MIDS in Use %ld\n",pMidMap->NumberOfMidsInUse);
   RxLog(("_UninitMidMap .. num= %ld\n",pMidMap->NumberOfMidsInUse));

   for (i = 0; i < pMidMap->MaximumNumberOfMids; i++) {
      PMID_MAP pChildMidMap;

      EntryType = _GetEntryType(pMidMap->Entries[i]);
      switch (EntryType) {
      case ENTRY_TYPE_MID_MAP :
         {
            pChildMidMap = (PMID_MAP)_GetEntryPointer(pMidMap->Entries[i]);
            _UninitializeMidMap(pChildMidMap,pContextDestructor);
            RxFreePool(pChildMidMap);
         }
         break;
      case ENTRY_TYPE_VALID_CONTEXT :
         {
            if (pContextDestructor != NULL) {
               PVOID pContext;

               pContext = _GetEntryPointer(pMidMap->Entries[i]);
               DbgPrint("Finalizing Context from the MID ATLAS %lx\n",pContext);
               (pContextDestructor)(pContext);
            }
         }
         break;
      default:
         break;
      }
   }

   if (pMidMap->Flags & MID_MAP_FLAGS_FREE_POOL) {
      RxFreePool(pMidMap);
   }

   //DbgPrint("_UninitializeMidMap .. Exit\n");
}

VOID
IfsMrxDestroyMidAtlas(
   PMID_ATLAS          pMidAtlas,
   PCONTEXT_DESTRUCTOR pContextDestructor)
/*++

Routine Description:

   This routine frees a MID_ATLAS instance. As a side effect it invokes the
   passed in context destructor on every valid context in the MID_ATLAS

Arguments:

    pMidAtlas           - the MID_ATLAS instance to be freed.

    PCONTEXT_DESTRUCTOR - the associated context destructor

Notes:

--*/
{
   _UninitializeMidMap(pMidAtlas->pRootMidMap,pContextDestructor);

   RxFreePool(pMidAtlas);
}

PVOID
IfsMrxMapMidToContext(
      PMID_ATLAS pMidAtlas,
      USHORT     Mid)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;

   for (;;) {
      pContext = pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount];
      EntryType = _GetEntryType(pContext);
      pContext = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         pContext = NULL;
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      }
   }

   return pContext;
}

NTSTATUS
IfsMrxMapAndDissociateMidFromContext(
      PMID_ATLAS pMidAtlas,
      USHORT     Mid,
      PVOID      *pContextPointer)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;
   PVOID     *pEntry;

   for (;;) {
      pEntry    = &pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount];
      pContext  = *pEntry;
      EntryType = _GetEntryType(pContext);
      pContext  = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         pMidMap->NumberOfMidsInUse--;

         if (pMidMap->pFreeMidListHead == NULL) {
            if (pMidMap->Flags & MID_MAP_FLAGS_CAN_BE_EXPANDED) {
               _RemoveMidMap(pMidMap);
            }

            _AddMidMap(&pMidAtlas->MidMapFreeList,pMidMap);
         }

         *pEntry = _MakeEntry(pMidMap->pFreeMidListHead,ENTRY_TYPE_FREE_MID_LIST);
         pMidMap->pFreeMidListHead = pEntry;


         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         pContext = NULL;
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      }
   }

   pMidAtlas->NumberOfMidsInUse--;
   *pContextPointer = pContext;
   return STATUS_SUCCESS;
}

NTSTATUS
IfsMrxReassociateMid(
      PMID_ATLAS pMidAtlas,
      USHORT     Mid,
      PVOID      pNewContext)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

    pNewContext - the new context

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;

   for (;;) {
      pContext = pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount];
      EntryType = _GetEntryType(pContext);
      pContext = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount]
               = _MakeEntry(pNewContext,ENTRY_TYPE_VALID_CONTEXT);
         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         ASSERT(!"Valid MID Atlas");
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      }
   }

   return STATUS_SUCCESS;
}

NTSTATUS
IfsMrxAssociateContextWithMid(
      PMID_ATLAS     pMidAtlas,
      PVOID          pContext,
      PUSHORT        pNewMid)
/*++

Routine Description:

   This routine initializes a MID_MAP data structure.

Arguments:

    pMidMap  - the MID_MAP instance to be initialized.

Return Value:

    STATUS_SUCCESS if successful, otherwise one of the following errors

         STATUS_INSUFFICIENT_RESOURCES
         STATUS_UNSUCCESSFUL  -- no mid could be associated

Notes:

--*/
{
   NTSTATUS Status;
   PMID_MAP pMidMap;
   PVOID    *pContextPointer;

   // Scan the list of MID_MAP's which have free entries in them.
   if ((pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapFreeList)) != NULL) {
      ASSERT(pMidMap->pFreeMidListHead != _MakeEntry(NULL,ENTRY_TYPE_FREE_MID_LIST));

      pMidMap->NumberOfMidsInUse++;
      pContextPointer           = pMidMap->pFreeMidListHead;
      pMidMap->pFreeMidListHead = _GetEntryPointer(*(pMidMap->pFreeMidListHead));
      *pContextPointer          = _MakeEntry(pContext,ENTRY_TYPE_VALID_CONTEXT);
      *pNewMid                  = ((pContextPointer - (PVOID *)&pMidMap->Entries) << pMidMap->IndexAlignmentCount) | pMidMap->BaseMid;

      // Check if the MID_MAP needs to be removed from the list of MID_MAP's with
      // free entries
      if (pMidMap->pFreeMidListHead ==  NULL) {
         _RemoveMidMap(pMidMap);

         // Check if it can be added to the expansion list.
         if (pMidAtlas->NumberOfLevels > pMidMap->Level) {
            _AddMidMap(&pMidAtlas->MidMapExpansionList,pMidMap);
         }
      }

      Status = STATUS_SUCCESS;
   } else if ((pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapExpansionList)) != NULL) {
      PMID_MAP pNewMidMap;

      USHORT   i;
      ULONG    NewMidMapSize;

      // Locate the index in the mid map for the new mid map
      pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapExpansionList);
      while (pMidMap != NULL) {
         for (i = 0; i < pMidMap->MaximumNumberOfMids; i++) {
            if (_GetEntryType(pMidMap->Entries[i]) != ENTRY_TYPE_MID_MAP) {
               break;
            }
         }

         if (i < pMidMap->MaximumNumberOfMids) {
            break;
         } else {
            pMidMap->Flags &= ~MID_MAP_FLAGS_CAN_BE_EXPANDED;
            _RemoveMidMap(pMidMap);
            pMidMap = _GetNextMidMap(&pMidAtlas->MidMapExpansionList,pMidMap);
         }
      }

      if (pMidMap != NULL) {
         USHORT NumberOfEntriesInMap = pMidAtlas->MaximumNumberOfMids -
                                       pMidAtlas->NumberOfMidsInUse;

         if (NumberOfEntriesInMap > pMidAtlas->MidQuantum) {
            NumberOfEntriesInMap = pMidAtlas->MidQuantum;
         }

         NewMidMapSize = FIELD_OFFSET(MID_MAP,Entries) +
                         NumberOfEntriesInMap * sizeof(PVOID);
         pNewMidMap = (PMID_MAP)RxAllocatePoolWithTag(
                                    NonPagedPool,
                                    NewMidMapSize,
                                    MRXSMB_MIDATLAS_POOLTAG);

         if (pNewMidMap != NULL) {
            pNewMidMap->Flags = MID_MAP_FLAGS_FREE_POOL;
            pNewMidMap->MaximumNumberOfMids = NumberOfEntriesInMap;
            pNewMidMap->NumberOfMidsInUse   = 0;
            pNewMidMap->BaseMid             = (pMidMap->BaseMid |
                                               i << pMidMap->IndexAlignmentCount);
            pNewMidMap->IndexMask           = (pMidAtlas->MidQuantum - 1) << pNewMidMap->IndexAlignmentCount;
            pNewMidMap->IndexAlignmentCount = pMidMap->IndexAlignmentCount +
                                              pMidMap->IndexFieldWidth;
            pNewMidMap->IndexFieldWidth     = pMidAtlas->MidQuantumFieldWidth;

            _InitializeMidMapFreeList(pNewMidMap);

            // Set up the mid map appropriately.
            pNewMidMap->NumberOfMidsInUse = 1;
            pNewMidMap->Entries[0] = pMidMap->Entries[i];
            pNewMidMap->Level      = pMidMap->Level + 1;

            pNewMidMap->pFreeMidListHead = *(pNewMidMap->pFreeMidListHead);
            pMidMap->Entries[i] = _MakeEntry(pNewMidMap,ENTRY_TYPE_MID_MAP);

            // Update the free list and the expansion list respectively.
            _AddMidMap(&pMidAtlas->MidMapFreeList,pNewMidMap);

            pNewMidMap->NumberOfMidsInUse++;
            pContextPointer           = pMidMap->pFreeMidListHead;
            pMidMap->pFreeMidListHead = *(pMidMap->pFreeMidListHead);
            *pContextPointer          = _MakeEntry(pContext,ENTRY_TYPE_VALID_CONTEXT);
            *pNewMid                  = (((pContextPointer - (PVOID *)&pMidMap->Entries) / sizeof(PVOID)) << pMidMap->IndexAlignmentCount) | pMidMap->BaseMid;

            Status = STATUS_SUCCESS;
         } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
         }
      } else {
         Status = STATUS_UNSUCCESSFUL;
      }
   } else {
      Status = STATUS_UNSUCCESSFUL;
   }

   if (Status == STATUS_SUCCESS) {
      pMidAtlas->NumberOfMidsInUse++;
   }


   return Status;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\precomp.h ===
#define MINIRDR__NAME MRxIFS
#define ___MINIRDR_IMPORTS_NAME (MRxIfsDeviceObject->RdbssExports)

#include "rx.h"

#include "ntddnfs2.h"
#include "netevent.h"

#include "ifsmrx.h"
#include "mrxglbl.h"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\mrxglbl.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mrxglbl.h

Abstract:

    The global include file for SMB mini redirector


--*/

#ifndef _MRXGLBL_H_
#define _MRXGLBL_H_

#include "align.h"

#define INCLUDE_SMB_ALL

#include "status.h"
#include "smbtypes.h"
#include "smbmacro.h"
#include "smb.h"
#include "smbtrans.h"
#include "smbtrace.h"
#include "smbtrsup.h"
#include "smbgtpt.h"

typedef struct _SMBCE_CONTEXT_ {
   UNICODE_STRING        ComputerName;
   UNICODE_STRING        OperatingSystem;
   UNICODE_STRING        LanmanType;
   UNICODE_STRING        Transports;
} SMBCE_CONTEXT,*PSMBCE_CONTEXT;

// The following enum type defines the various states associated with the IFS
// mini redirector. This is used during initialization

typedef enum _MRXIFS_STATE_ {
   MRXIFS_STARTABLE,
   MRXIFS_START_IN_PROGRESS,
   MRXIFS_STARTED
} MRXIFS_STATE,*PMRXIFS_STATE;

extern MRXIFS_STATE MRxIfsState;

extern SMBCE_CONTEXT SmbCeContext;

extern RXCE_ADDRESS_EVENT_HANDLER    MRxSmbVctAddressEventHandler;
extern RXCE_CONNECTION_EVENT_HANDLER MRxSmbVctConnectionEventHandler;

extern PBYTE  s_pNegotiateSmb;
extern ULONG  s_NegotiateSmbLength;
extern PMDL   s_pNegotiateSmbBuffer;

extern PBYTE  s_pEchoSmb;
extern ULONG  s_EchoSmbLength;
extern PMDL   s_pEchoSmbMdl;

extern FAST_MUTEX MRxIfsSerializationMutex;

typedef REDIR_STATISTICS   MRX_IFS_STATISTICS;
typedef PREDIR_STATISTICS  PMRX_IFS_STATISTICS;

extern MRX_IFS_STATISTICS MRxIfsStatistics;

// Miscellanous definitions

extern PBYTE MRxSmb_pPaddingData;

#define NETBIOS_NAMESIZE (16)
#define SMBCE_PADDING_DATA_SIZE (32)

//   All the pool tag definitions related to the IFS mini redirector are as follows.
//   The mechanism is intended to balance the number of pool tags to be used with the
//   total number of tags available in the system.
//
//   By specifying special flags the total number of tags consumed by the mini redirector
//   can be controlled. For most builds the tags should be aliased such that about
//   6 tags are consumed by the mini redirector. In special builds the aliasing of tags
//   will be suppressed, thereby consuming more tags to track down memory leaks easily.
//
//   The following are the five major tags ....
//
//      1) IfCe -- the IFS Mini Redirector connection engine.
//
//      2) IfOe -- the IFS Mini redirector ordinary exchange related allocation.
//
//      3) IfAd -- the IFS Mini redirector ADMIN exchange/session setup/tree connect etc.
//
//      4) IfRw -- the IFS mini redirector read/write paths
//
//      5) IfMs -- the miscellanous category.

#define MRXSMB_CE_POOLTAG        ('eCfI')
#define MRXSMB_MM_POOLTAG        ('mMfI')
#define MRXSMB_ADMIN_POOLTAG     ('dAfI')
#define MRXSMB_RW_POOLTAG        ('wRfI')
#define MRXIFS_MISC_POOLTAG      ('sMfI')
#define MRXSMB_TRANSPORT_POOLTAG ('pTfI')

extern ULONG MRxIfsExplodePoolTags;

#define MRXSMB_DEFINE_POOLTAG(ExplodedPoolTag,DefaultPoolTag)  \
        ((MRxIfsExplodePoolTags == 0) ? (DefaultPoolTag) : (ExplodedPoolTag))

#define MRXSMB_FSCTL_POOLTAG     MRXSMB_DEFINE_POOLTAG('cFfI',MRXIFS_MISC_POOLTAG)
#define MRXSMB_DIRCTL_POOLTAG    MRXSMB_DEFINE_POOLTAG('cDfI',MRXIFS_MISC_POOLTAG)
#define MRXSMB_PIPEINFO_POOLTAG  MRXSMB_DEFINE_POOLTAG('iPfI',MRXIFS_MISC_POOLTAG)

#define MRXSMB_SERVER_POOLTAG    MRXSMB_DEFINE_POOLTAG('rSfI',MRXSMB_CE_POOLTAG)
#define MRXSMB_SESSION_POOLTAG   MRXSMB_DEFINE_POOLTAG('eSfI',MRXSMB_CE_POOLTAG)
#define MRXSMB_NETROOT_POOLTAG   MRXSMB_DEFINE_POOLTAG('rNfI',MRXSMB_CE_POOLTAG)

#define MRXSMB_MIDATLAS_POOLTAG  MRXSMB_DEFINE_POOLTAG('aMfI', MRXSMB_CE_POOLTAG)

#define MRXSMB_MAILSLOT_POOLTAG  MRXSMB_DEFINE_POOLTAG('tMfI', MRXSMB_CE_POOLTAG)
#define MRXSMB_VC_POOLTAG        MRXSMB_DEFINE_POOLTAG('cVfI',MRXSMB_CE_POOLTAG)

#define MRXSMB_ECHO_POOLTAG      MRXSMB_DEFINE_POOLTAG('cEfI',MRXSMB_ADMIN_POOLTAG)

#define MRXSMB_KERBEROS_POOLTAG  MRXSMB_DEFINE_POOLTAG('sKfI',MRXSMB_ADMIN_POOLTAG)


// NodeType Codes

#define SMB_EXCHANGE_CATEGORY             (0xed)
#define SMB_CONNECTION_ENGINE_DB_CATEGORY (0xea)
#define SMB_SERVER_TRANSPORT_CATEGORY     (0xeb)


#define SMB_EXCHANGE_NTC(x) ((SMB_EXCHANGE_CATEGORY << 8) | (x))

#define SMB_NTC_STUFFERSTATE  0xed80


#undef RxCaptureRequestPacket
#undef RxCaptureParamBlock


extern PEPROCESS    RDBSSProcessPtr;
extern PRDBSS_DEVICE_OBJECT MRxIfsDeviceObject;
#define RxNetNameTable (*(*___MINIRDR_IMPORTS_NAME).pRxNetNameTable)
#define RxStrucSupSpinLock (*(*___MINIRDR_IMPORTS_NAME).pRxStrucSupSpinLock)

#define MAXIMUM_PARTIAL_BUFFER_SIZE  65535  // Maximum size of a partial MDL

#define MAXIMUM_SMB_BUFFER_SIZE 4356

//
// forward declarations for all dispatch vector methods.
//

extern NTSTATUS
MRxIfsStart (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

extern NTSTATUS
MRxIfsStop (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

extern NTSTATUS
MRxIfsMinirdrControl (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PVOID pContext,
    IN OUT PUCHAR SharedBuffer,
    IN     ULONG InputBufferLength,
    IN     ULONG OutputBufferLength,
    OUT PULONG CopyBackLength
    );

extern NTSTATUS
MRxIfsDevFcb (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsCreate (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsCollapseOpen (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsRead (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsWrite (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsLocks(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsFlush(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsFsCtl(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxIfsIoCtl(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsNotifyChangeDirectory(
    IN OUT PRX_CONTEXT RxContext
    );


extern NTSTATUS
MRxIfsComputeNewBufferingState(
    IN OUT PMRX_SRV_OPEN pSrvOpen,
    IN     PVOID         pMRxContext,
       OUT ULONG         *pNewBufferingState);

extern NTSTATUS
MRxIfsFlush (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsCloseWithDelete (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsZeroExtend (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsTruncate (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsCleanupFobx (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsCloseSrvOpen (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsClosedSrvOpenTimeOut (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsQueryDirectory (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsQueryEaInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsSetEaInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

extern NTSTATUS
MRxIfsQuerySecurityInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsSetSecurityInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

extern NTSTATUS
MRxIfsQueryVolumeInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsSetVolumeInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsLowIOSubmit (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxIfsCreateVNetRoot(
    IN OUT PMRX_V_NET_ROOT            pVirtualNetRoot,
    IN OUT PMRX_CREATENETROOT_CONTEXT pContext
    );

extern NTSTATUS
MRxIfsFinalizeVNetRoot(
    IN OUT PMRX_V_NET_ROOT pVirtualNetRoot,
    IN     PBOOLEAN    ForceDisconnect);

extern NTSTATUS
MRxIfsFinalizeNetRoot(
    IN OUT PMRX_NET_ROOT pNetRoot,
    IN     PBOOLEAN      ForceDisconnect);

extern NTSTATUS
MRxIfsUpdateNetRootState(
    IN  PMRX_NET_ROOT pNetRoot);

VOID
MRxIfsExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    );

extern NTSTATUS
MRxIfsCreateSrvCall(
      PMRX_SRV_CALL                      pSrvCall,
      PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext);

extern NTSTATUS
MRxIfsFinalizeSrvCall(
      PMRX_SRV_CALL    pSrvCall,
      BOOLEAN    Force);

extern NTSTATUS
MRxIfsSrvCallWinnerNotify(
      IN OUT PMRX_SRV_CALL      pSrvCall,
      IN     BOOLEAN        ThisMinirdrIsTheWinner,
      IN OUT PVOID          pSrvCallContext);


extern NTSTATUS
MRxIfsQueryFileInformation (
    IN OUT PRX_CONTEXT            RxContext
    );

extern NTSTATUS
MRxIfsQueryNamedPipeInformation (
    IN OUT PRX_CONTEXT            RxContext,
    IN     FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID              Buffer,
    IN OUT PULONG             pLengthRemaining
    );

extern NTSTATUS
MRxIfsSetFileInformation (
    IN OUT PRX_CONTEXT            RxContext
    );

extern NTSTATUS
MRxIfsSetNamedPipeInformation (
    IN OUT PRX_CONTEXT            RxContext,
    IN     FILE_INFORMATION_CLASS FileInformationClass,
    IN     PVOID              pBuffer,
    IN     ULONG              BufferLength
    );

NTSTATUS
MRxIfsSetFileInformationAtCleanup(
      IN OUT PRX_CONTEXT            RxContext
      );

NTSTATUS
MRxIfsDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    );

NTSTATUS
MRxIfsDeallocateForFobx (
    IN OUT PMRX_FOBX pFobx
    );

extern NTSTATUS
MRxIfsForcedClose (
    IN OUT PMRX_SRV_OPEN SrvOpen
    );

extern NTSTATUS
MRxIfsExtendFile (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    );

extern NTSTATUS
MRxIfsCompleteBufferingStateChangeRequest (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRX_SRV_OPEN   SrvOpen,
    IN     PVOID       pContext
    );


extern NTSTATUS
MRxIfsExtendForCache (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PFCB Fcb,
    OUT    PLONGLONG pNewFileSize
    );

extern
NTSTATUS
MRxIfsInitializeSecurity (VOID);

extern
NTSTATUS
MRxIfsUninitializeSecurity (VOID);

extern
NTSTATUS
MRxIfsInitializeTransport(VOID);

extern
NTSTATUS
MRxIfsUninitializeTransport(VOID);

extern
NTSTATUS
GetSmbResponseNtStatus(PSMB_HEADER pSmbHeader);

extern NTSTATUS
MRxIfsTransportUpdateHandler(
      PRXCE_TRANSPORT_NOTIFICATION pTransportNotification);

extern NTSTATUS
SmbCeEstablishConnection(
    IN PMRX_V_NET_ROOT        pVNetRoot,
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext);

extern NTSTATUS
SmbCeReconnect(
    IN PMRX_V_NET_ROOT        pVNetRoot);

//
// the SMB protocol tree connections are identified by a Tree Id., each
// file opened on a tree connection by a File Id. and each outstanding request
// on that connection by a Multiplex Id.
//


typedef USHORT SMB_TREE_ID;
typedef USHORT SMB_FILE_ID;
typedef USHORT SMB_MPX_ID;


//
// Each user w.r.t a particular connection is identified by a User Id. and each
// process on the client side is identified by a Process id.
//

typedef USHORT SMB_USER_ID;
typedef USHORT SMB_PROCESS_ID;

//
// All exchanges are identified with a unique id. assigned on creation of the exchange
// which is used to track it.
//

typedef ULONG SMB_EXCHANGE_ID;

typedef struct _MRX_SMB_FCB_ {
   ULONG MFlags;
   SMB_TREE_ID Tid;
} MRX_SMB_FCB, *PMRX_SMB_FCB;

#define MRxIfsGetFcbExtension(pFcb)      \
        (((pFcb) == NULL) ? NULL : (PMRX_SMB_FCB)((pFcb)->Context))

#define SMB_FCB_FLAG_SENT_DISPOSITION_INFO     0x00000001

typedef struct _SMBPSE_FILEINFO_BUNDLE {
    FILE_BASIC_INFORMATION Basic;
    FILE_STANDARD_INFORMATION Standard;
} SMBPSE_FILEINFO_BUNDLE, *PSMBPSE_FILEINFO_BUNDLE;

typedef struct _MRX_SMB_SRV_OPEN_ {
   ULONG       Flags;
   ULONG        Version;
   SMB_FILE_ID Fid;
   UCHAR       OplockLevel;

   // the following fields are used for to save the results of a GetFileAttributes
   // and to validate whether the fields should be reused or not

   ULONG                  RxContextSerialNumber;
   LARGE_INTEGER          TimeStampInTicks;
   SMBPSE_FILEINFO_BUNDLE FileInfo;
} MRX_SMB_SRV_OPEN, *PMRX_SMB_SRV_OPEN;

#define MRxIfsGetSrvOpenExtension(pSrvOpen)  \
        (((pSrvOpen) == NULL) ? NULL : (PMRX_SMB_SRV_OPEN)((pSrvOpen)->Context))

#define SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN     0x00000001
#define SMB_SRVOPEN_FLAG_CANT_REALLY_OPEN    0x00000002
#define SMB_SRVOPEN_FLAG_CANT_GETATTRIBS     0x00000004

typedef USHORT SMB_SEARCH_HANDLE;

typedef struct _MRX_SMB_DIRECTORY_RESUME_INFO {
   REQ_FIND_NEXT2 FindNext2_Request;
   //now we have to include space for a resume name........
   WCHAR NameSpace[MAXIMUM_FILENAME_LENGTH+1]; //trailing null
   USHORT ParametersLength;
} MRX_SMB_DIRECTORY_RESUME_INFO, *PMRX_SMB_DIRECTORY_RESUME_INFO;

typedef struct _MRX_SMB_FOBX_ {
   union {
       struct {
           struct {
               SMB_SEARCH_HANDLE SearchHandle;
               ULONG Version;
               union {
                   //the close code will try to free this!
                   PMRX_SMB_DIRECTORY_RESUME_INFO ResumeInfo;
                   PSMB_RESUME_KEY CoreResumeKey;
               };
               struct {
                   //unaligned direntry sidebuffering params
                   PBYTE UnalignedDirEntrySideBuffer;    //close will try to free this too
                   ULONG SerialNumber;
                   BOOLEAN EndOfSearchReached;
                   BOOLEAN IsUnicode;
                   BOOLEAN IsNonNtT2Find;
                   ULONG   FilesReturned;
                   ULONG EntryOffset;
                   ULONG TotalDataBytesReturned;
               };
           };
           NTSTATUS ErrorStatus;
           USHORT Flags;
           USHORT FileNameOffset;
           USHORT FileNameLengthOffset;
           BOOLEAN WildCardsFound;
       } Enumeration;
   };
   union {
       struct {
           //dont do this yet
           //ULONG MaximumReadBufferLength;
           //ULONG MaximumWriteBufferLength;
           USHORT Flags;
       } File;
   };
} MRX_SMB_FOBX, *PMRX_SMB_FOBX;

#define MRxIfsGetFileObjectExtension(pFobx)  \
        (((pFobx) == NULL) ? NULL : (PMRX_SMB_FOBX)((pFobx)->Context))

#define SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST    0x0001
#define SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN      0x0002
#define SMBFOBX_ENUMFLAG_FAST_RESUME             0x0004
#define SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS 0x0008
#define SMBFOBX_ENUMFLAG_LOUD_FINALIZE           0x0010

typedef
NTSTATUS
(NTAPI *PMRXSMB_CANCEL_ROUTINE) (
      PRX_CONTEXT pRxContext);

typedef struct _MRXIFS_RX_CONTEXT {
   PMRXSMB_CANCEL_ROUTINE          pCancelRoutine;
   PVOID                           pCancelContext;
   struct _SMB_EXCHANGE            *pExchange;
   struct _SMBSTUFFER_BUFFER_STATE *pStufferState;
} MRXIFS_RX_CONTEXT, *PMRXIFS_RX_CONTEXT;


#define MRxSmbGetMinirdrContext(pRxContext)     \
        ((PMRXIFS_RX_CONTEXT)(&(pRxContext)->MRxContext[0]))

#define MRxIfsMakeSrvOpenKey(Tid,Fid) \
        (PVOID)(((ULONG)(Tid) << 16) | (ULONG)(Fid))


#define NETBIOS_NAMESIZE (16)
#define SMBCE_PADDING_DATA_SIZE (32)

//this better not be paged!


typedef struct _MRXIFS_GLOBAL_PADDING {
    MDL Mdl;
    ULONG Pages[2]; //this can't possibly span more than two pages
    UCHAR Pad[SMBCE_PADDING_DATA_SIZE];
} MRXIFS_GLOBAL_PADDING, *PMRXIFS_GLOBAL_PADDING;

extern MRXIFS_GLOBAL_PADDING MrxIfsCeGlobalPadding;


#define RxBuildPartialMdlUsingOffset(SourceMdl,DestinationMdl,Offset,Length) \
        IoBuildPartialMdl(SourceMdl,\
                          DestinationMdl,\
                          (PBYTE)MmGetMdlVirtualAddress(SourceMdl)+Offset,\
                          Length)

#define RxBuildPaddingPartialMdl(DestinationMdl,Length) \
        RxBuildPartialMdlUsingOffset(&MrxSmbCeGlobalPadding.Mdl,DestinationMdl,0,Length)


//we turn away async operations that are not wait by posting. if we can wait
//then we turn off the sync flag so that things will just act synchronous
#define TURN_BACK_ASYNCHRONOUS_OPERATIONS() {                              \
    if (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {        \
        if (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WAIT)) {               \
            ClearFlag(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)    \
        } else {                                                           \
            RxContext->PostRequest = TRUE;                                 \
            return(STATUS_PENDING);                                     \
        }                                                                  \
    }                                                                      \
  }


typedef struct _MRXIFS_CONFIGURATION_DATA_ {
   ULONG   NamedPipeDataCollectionTimeInterval;
   ULONG   NamedPipeDataCollectionSize;
   ULONG   MaximumNumberOfCommands;
   ULONG   SessionTimeoutInterval;
   ULONG   LockQuota;
   ULONG   LockIncrement;
   ULONG   MaximumLock;
   ULONG   PipeIncrement;
   ULONG   PipeMaximum;
   ULONG   CachedFileTimeout;
   ULONG   DormantFileTimeout;
   ULONG   NumberOfMailslotBuffers;
   ULONG   MaximumNumberOfThreads;
   ULONG   ConnectionTimeoutInterval;
   ULONG   CharBufferSize;

   BOOLEAN UseOplocks;
   BOOLEAN UseUnlocksBehind;
   BOOLEAN UseCloseBehind;
   BOOLEAN BufferNamedPipes;
   BOOLEAN UseLockReadUnlock;
   BOOLEAN UtilizeNtCaching;
   BOOLEAN UseRawRead;
   BOOLEAN UseRawWrite;
   BOOLEAN UseEncryption;

} MRXIFS_CONFIGURATION, *PMRXIFS_CONFIGURATION;

extern MRXIFS_CONFIGURATION MRxIfsConfiguration;


#include "smbce.h"
#include "midatlas.h"
#include "smbcedbp.h"
#include "smbcedb.h"
#include "smbxchng.h"
#include "stuffer.h"
#include "smbpse.h"
#include "transprt.h"
#include "ifsprocs.h"   // crossreferenced routines

#endif _MRXGLBL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\mm.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mm.c

Abstract:

    This module implements the memory managment routines for the IFS mini redirector

Notes:

    The SMB mini redirector manipulates entities which have very different usage patterns.
    They range from very static entities ( which are allocated and freed with a very low
    frequency ) to very dynamic entities.

    The entities manipulated in the SMB mini redirector are SMBCE_SERVER, SMBCE_NET_ROOT,
    SMBCE_VC, SMBCE_SESSION. These represent a connection to a server, a share on a particular
    server, a virtual circuit used in the connection and a session for a particular user.

    These are not very dynamic, i.e., the allocation/deallocation is very infrequent. The
    SMB_EXCHANGE and SMBCE_REQUEST map to the SMB's that are sent along that a connection.
    Every file operation in turn maps to a certain number of calls for allocationg/freeing
    exchanges and requests. Therefore it is imperative that some form of scavenging/caching
    of recently freed entries be maintained to satisfy requests quickly.

    In the current implementation the exchanges and requests are implemented using the zone
    allocation primitives.

    The exchange allocation and free routines are currently implemented as wrappers around the
    RxAllocate and RxFree routines. It would be far more efficient if a look aside cache
    of some exchange instances are maintained.

--*/

#include "precomp.h"
#pragma hdrstop

#include <vcsndrcv.h>

#define SMBMM_ZONE_ALLOCATION 0x10

// The memory management package addresses a number of concerns w.r.t debugging and performance
// By centralizing all the allocation/deallocation routines to thsi one module it is
// possible to build up profiles regarding various data structures used by the connection
// engine. In addition debugging support is provided by thereading together all allocated
// objects of a particular type are threaded together in a linked list according to type.
//
// At any stage by inspecting these lists the currently active instances of a particular
// type can be enumerated.
//
// Each type handled by this module is provided with two routines, e.g., for server entries
// there are SmbMmInitializeEntry and SmbMmUninitializeEntry. The first routine is called
// before handing over a pointer of a newly created instance. This will ensure that the
// instance is in a wll known initial state. Similarly the second routine is called just
// before deallocating the pool associated with the instance. This helps enforce the
// necessary integrity constraints, e.g., all enclosed pointers must be NULL etc.
//
// The pool allocation/deallocation is handled by the following routines
//
//    SmbMmAllocateObjectPool/SmbMmFreeObjectPool
//
//    SmbMmAllocateExchange/SmbMmFreeExchange
//
// The Object allocation routines are split up into two parts so as to be able to handle
// the session allocationson par with other objects even though they are further subtyped.
//
// On debug builds additional pool is allocated and the appropriate linking is done into the
// corresponding list. On retail builds these map to the regular pool allocation wrappers.
//

// Zone allocation to speed up memory management of RxCe entities.
//

ULONG       SmbMmRequestZoneEntrySize;
ZONE_HEADER SmbMmRequestZone;
PVOID       SmbMmRequestZoneSegmentPtr;

//
// Pool allocation resources and spin locks
//

KSPIN_LOCK  SmbMmSpinLock;

ULONG SmbMmExchangeId;

//
// List of the various objects/exchanges allocated.
//

LIST_ENTRY SmbMmExchangesInUse[SENTINEL_EXCHANGE];
LIST_ENTRY SmbMmObjectsInUse[SMBCEDB_OT_SENTINEL];

ULONG  ObjectSizeInBytes[SMBCEDB_OT_SENTINEL];
ULONG  ExchangeSizeInBytes[SENTINEL_EXCHANGE];

INLINE PSMBCE_OBJECT_HEADER
SmbMmAllocateObjectPool(
      SMBCEDB_OBJECT_TYPE  ObjectType,
      ULONG                PoolType,
      ULONG                PoolSize)
{
   KIRQL SavedIrql;
   PVOID pv = NULL;
   UCHAR Flags = 0;

   PSMBCE_OBJECT_HEADER pHeader = NULL;

   ASSERT((ObjectType >= 0) && (ObjectType < SMBCEDB_OT_SENTINEL));

   if (ObjectType == SMBCEDB_OT_REQUEST) {
      // Acquire the resource lock.
      KeAcquireSpinLock( &SmbMmSpinLock, &SavedIrql );

      if (!ExIsFullZone( &SmbMmRequestZone )) {
         pv = ExAllocateFromZone( &SmbMmRequestZone );
         Flags = SMBMM_ZONE_ALLOCATION;
      }

      // Release the resource lock.
      KeReleaseSpinLock( &SmbMmSpinLock, SavedIrql );
   }

   if (pv == NULL) {
      PLIST_ENTRY pListEntry;

      pv = RxAllocatePoolWithTag(
               PoolType,
               PoolSize + sizeof(LIST_ENTRY),
               MRXSMB_MM_POOLTAG);

      if (pv != NULL) {
         pListEntry = (PLIST_ENTRY)pv;
         pHeader    = (PSMBCE_OBJECT_HEADER)(pListEntry + 1);

         ExInterlockedInsertTailList(&SmbMmObjectsInUse[ObjectType],pListEntry,&SmbMmSpinLock);
      }
   } else {
      pHeader = (PSMBCE_OBJECT_HEADER)pv;
   }

   if (pHeader != NULL) {
      // Zero the memory.
      RtlZeroMemory( pHeader, PoolSize);

      pHeader->Flags = Flags;
   }

   return pHeader;
}

INLINE VOID
SmbMmFreeObjectPool(
      PSMBCE_OBJECT_HEADER  pHeader)
{
   KIRQL               SavedIrql;
   BOOLEAN             ZoneAllocation = FALSE;
   PLIST_ENTRY         pListEntry;

   ASSERT((pHeader->ObjectType >= 0) && (pHeader->ObjectType < SMBCEDB_OT_SENTINEL));

   // Acquire the resource lock.
   KeAcquireSpinLock( &SmbMmSpinLock, &SavedIrql );

   // Check if it was a zone allocation
   if (pHeader->Flags & SMBMM_ZONE_ALLOCATION) {
      ZoneAllocation = TRUE;
      ExFreeToZone(&SmbMmRequestZone,pHeader);
   } else {
      pListEntry = (PLIST_ENTRY)((PCHAR)pHeader - sizeof(LIST_ENTRY));
      RemoveEntryList(pListEntry);
   }

   // Release the resource lock.
   KeReleaseSpinLock( &SmbMmSpinLock, SavedIrql );

   if (!ZoneAllocation) {
      RxFreePool(pListEntry);
   }
}

// Construction and destruction of various SMB connection engine objects
//

#define SmbMmInitializeServerEntry(pServerEntry)                                \
         InitializeListHead(&(pServerEntry)->OutstandingRequests.ListHead);   \
         InitializeListHead(&(pServerEntry)->MidAssignmentRequests.ListHead); \
         InitializeListHead(&(pServerEntry)->Sessions.ListHead);              \
         InitializeListHead(&(pServerEntry)->NetRoots.ListHead);              \
         (pServerEntry)->Sessions.pDefaultSessionEntry = NULL;                  \
         (pServerEntry)->pTransport                = NULL;                      \
         (pServerEntry)->pMidAtlas                 = NULL

#define SmbMmInitializeSessionEntry(pSessionEntry)  \
         InitializeListHead(&(pSessionEntry)->Requests.ListHead)

#define SmbMmInitializeNetRootEntry(pNetRootEntry)  \
         InitializeListHead(&(pNetRootEntry)->Requests.ListHead)

#define SmbMmUninitializeServerEntry(pServerEntry)                                 \
         ASSERT(IsListEmpty(&(pServerEntry)->OutstandingRequests.ListHead) &&    \
                IsListEmpty(&(pServerEntry)->MidAssignmentRequests.ListHead) &&  \
                IsListEmpty(&(pServerEntry)->Sessions.ListHead) &&               \
                IsListEmpty(&(pServerEntry)->NetRoots.ListHead) &&               \
                ((pServerEntry)->pMidAtlas == NULL))

#define SmbMmUninitializeSessionEntry(pSessionEntry)  \
         ASSERT(IsListEmpty(&(pSessionEntry)->Requests.ListHead))

#define SmbMmUninitializeNetRootEntry(pNetRootEntry)  \
         ASSERT(IsListEmpty(&(pNetRootEntry)->Requests.ListHead))

#define SmbMmInitializeRequestEntry(pRequestEntry)

#define SmbMmUninitializeRequestEntry(pRequestEntry)

PVOID
SmbMmAllocateObject(SMBCEDB_OBJECT_TYPE ObjectType)
{
   PSMBCE_OBJECT_HEADER pHeader;

   ASSERT((ObjectType >= 0) && (ObjectType < SMBCEDB_OT_SENTINEL));

   pHeader = SmbMmAllocateObjectPool(ObjectType,NonPagedPool,ObjectSizeInBytes[ObjectType]);

   if (pHeader != NULL) {
      pHeader->ObjectType  = ObjectType;
      pHeader->State = SMBCEDB_START_CONSTRUCTION;

      switch (ObjectType) {
      case SMBCEDB_OT_SERVER :
         SmbMmInitializeServerEntry((PSMBCEDB_SERVER_ENTRY)pHeader);
         break;
      case SMBCEDB_OT_NETROOT :
         SmbMmInitializeNetRootEntry((PSMBCEDB_NET_ROOT_ENTRY)pHeader);
         break;
      case SMBCEDB_OT_REQUEST :
         SmbMmInitializeRequestEntry((PSMBCEDB_REQUEST_ENTRY)pHeader);
         break;
      default:
         ASSERT(!"Valid Type for SmbMmAllocateObject");
         break;
      }
   }

   return pHeader;
}

VOID
SmbMmFreeObject(PVOID pv)
{
   PSMBCE_OBJECT_HEADER pHeader = (PSMBCE_OBJECT_HEADER)pv;

   switch (pHeader->ObjectType) {
   case SMBCEDB_OT_SERVER :
      SmbMmUninitializeServerEntry((PSMBCEDB_SERVER_ENTRY)pHeader);
      break;
   case SMBCEDB_OT_NETROOT :
      SmbMmUninitializeNetRootEntry((PSMBCEDB_NET_ROOT_ENTRY)pHeader);
      break;
   case SMBCEDB_OT_REQUEST :
      SmbMmUninitializeRequestEntry((PSMBCEDB_REQUEST_ENTRY)pHeader);
      break;
   default:
      ASSERT(!"Valid Type for SmbMmFreeObject");
      break;
   }

   SmbMmFreeObjectPool(pHeader);
}

PSMBCEDB_SESSION_ENTRY
SmbMmAllocateSessionEntry(PSMBCEDB_SERVER_ENTRY pServerEntry)
{
   PSMBCEDB_SESSION_ENTRY pSessionEntry;
   SESSION_TYPE           SessionType;
   ULONG                  SessionSize;

   //
   // allocate a LANMAN session
   //

   SessionSize = sizeof(SMBCEDB_SESSION_ENTRY);
   SessionType = LANMAN_SESSION;

   pSessionEntry = (PSMBCEDB_SESSION_ENTRY)SmbMmAllocateObjectPool(
                                                SMBCEDB_OT_SESSION,
                                                NonPagedPool,
                                                SessionSize);

   if (pSessionEntry != NULL) {
      pSessionEntry->Header.ObjectType  = SMBCEDB_OT_SESSION;
      pSessionEntry->Header.State = SMBCEDB_START_CONSTRUCTION;
      pSessionEntry->Session.Type = SessionType;

      SmbMmInitializeSessionEntry(pSessionEntry);

      pSessionEntry->Session.CredentialHandle.dwUpper = 0xffffffff;
      pSessionEntry->Session.CredentialHandle.dwLower = 0xffffffff;
      pSessionEntry->Session.SecurityContextHandle.dwUpper = 0xffffffff;
      pSessionEntry->Session.SecurityContextHandle.dwLower = 0xffffffff;

   }

   return pSessionEntry;
}

VOID
SmbMmFreeSessionEntry(PSMBCEDB_SESSION_ENTRY pSessionEntry)
{

   SmbMmUninitializeSessionEntry(pSessionEntry);

   SmbMmFreeObjectPool(&pSessionEntry->Header);
}


PVOID
SmbMmAllocateExchange(SMB_EXCHANGE_TYPE ExchangeType, PVOID pv)
{
   KIRQL               SavedIrql;
   ULONG               SizeInBytes;
   USHORT              Flags = 0;
   PSMB_EXCHANGE       pExchange = NULL;
   PLIST_ENTRY         pListEntry;

   ASSERT((ExchangeType >= 0) && (ExchangeType < SENTINEL_EXCHANGE));

   if (pv==NULL) {
       pv = RxAllocatePoolWithTag(
                NonPagedPool,
                (sizeof(LIST_ENTRY) + ExchangeSizeInBytes[ExchangeType]),
                MRXSMB_MM_POOLTAG);
   } else {
       Flags |= SMBCE_EXCHANGE_NOT_FROM_POOL;
   }

   if (pv != NULL) {
      // Initialize the object header
      pListEntry  = (PLIST_ENTRY)pv;
      pExchange   = (PSMB_EXCHANGE)(&pListEntry[1]);

      // Zero the memory.
      RtlZeroMemory( pExchange, ExchangeSizeInBytes[ExchangeType]);

      //pExchange->Type       = ExchangeType;
      pExchange->NodeTypeCode = SMB_EXCHANGE_NTC(ExchangeType);
      pExchange->NodeByteSize = (USHORT)ExchangeSizeInBytes[ExchangeType];
      //not yet pExchange->ReferenceCount = 1;
      ASSERT(pExchange->Type == ExchangeType);

      pExchange->SmbCeState = SMBCE_EXCHANGE_INITIALIZATION_START;
      pExchange->SmbCeFlags = Flags;

      switch (pExchange->Type) {
      case CONSTRUCT_NETROOT_EXCHANGE:
         pExchange->pDispatchVector = &ConstructNetRootExchangeDispatch;
         break;
      case ADMIN_EXCHANGE:
         pExchange->pDispatchVector = &AdminExchangeDispatch;
         break;
      }

      // Acquire the resource lock.
      KeAcquireSpinLock( &SmbMmSpinLock, &SavedIrql );

      InsertTailList(&SmbMmExchangesInUse[pExchange->Type],pListEntry);

      pExchange->Id = SmbMmExchangeId++;

      // Release the resource lock.
      KeReleaseSpinLock( &SmbMmSpinLock, SavedIrql );
   } else {
      //ASSERT(!"alloc npp failed!");
   }

   return pExchange;
}

VOID
SmbMmFreeExchange(PSMB_EXCHANGE pExchange)
{
   if (pExchange != NULL) {
      KIRQL       SavedIrql;
      PLIST_ENTRY pListEntry = (PLIST_ENTRY)((PCHAR)pExchange - sizeof(LIST_ENTRY));

      ASSERT((pExchange->Type >= 0) && (pExchange->Type < SENTINEL_EXCHANGE));

      // Acquire the resource lock.
      KeAcquireSpinLock( &SmbMmSpinLock, &SavedIrql );

      RemoveEntryList(pListEntry);

      // Release the resource lock.
      KeReleaseSpinLock( &SmbMmSpinLock, SavedIrql );
      if (!FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_NOT_FROM_POOL)) {
          RxFreePool(pListEntry);
      }
   }
}

PVOID
SmbMmAllocateServerTransport(
   SMBCE_SERVER_TRANSPORT_TYPE ServerTransportType)
{
   PSMBCE_OBJECT_HEADER pHeader;

   ULONG AllocationSize;
   ULONG PoolTag;

   switch (ServerTransportType) {

   case SMBCE_STT_VC:
      AllocationSize = sizeof(SMBCE_SERVER_VC_TRANSPORT);
      PoolTag = MRXSMB_VC_POOLTAG;
      break;

   default:
      ASSERT(!"Valid Server Transport Type");
      return NULL;
   }

   pHeader = (PSMBCE_OBJECT_HEADER)RxAllocatePoolWithTag(
                                       NonPagedPool,
                                       AllocationSize,
                                       PoolTag);

   if (pHeader != NULL) {
      PSMBCE_SERVER_TRANSPORT pServerTransport;

      pHeader->ObjectCategory = SMB_SERVER_TRANSPORT_CATEGORY;
      pHeader->ObjectType     = ServerTransportType;
      pHeader->SwizzleCount   = 0;
      pHeader->State          = 0;
      pHeader->Flags          = 0;

      pServerTransport = (PSMBCE_SERVER_TRANSPORT)pHeader;

      pServerTransport->pRundownEvent = NULL;

      switch (ServerTransportType) {
      case SMBCE_STT_MAILSLOT:
         break;
      case SMBCE_STT_VC:
         {
            PSMBCE_SERVER_VC_TRANSPORT pVcTransport;

            pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pHeader;

            InitializeListHead(&pVcTransport->Vcs.ListHead);
         }
         break;
      default:
         break;
      }
   }

   return pHeader;
}

VOID
SmbMmFreeServerTransport(
   PSMBCE_SERVER_TRANSPORT pServerTransport)
{
   ASSERT((pServerTransport->SwizzleCount == 0) &&
          (pServerTransport->ObjectCategory == SMB_SERVER_TRANSPORT_CATEGORY));

   RxFreePool(pServerTransport);
}

NTSTATUS SmbMmInit()
/*++

Routine Description:

    This routine initialises the connection engine structures for memory management

Return Value:

    STATUS_SUCCESS if successful, otherwise an informative error code.

--*/
{
   NTSTATUS Status = STATUS_SUCCESS;
   ULONG ZoneSegmentSize;

   // Initialize the resource lock for the zone allocator.
   KeInitializeSpinLock( &SmbMmSpinLock );

   SmbMmRequestZoneEntrySize = QuadAlign(sizeof(SMBCEDB_REQUEST_ENTRY));

   // Currently the request zone size is restricted to that of a page. This can and should
   // be fine tuned.
   ZoneSegmentSize = PAGE_SIZE;

   SmbMmRequestZoneSegmentPtr = RxAllocatePoolWithTag(
                                    NonPagedPool,
                                    ZoneSegmentSize,
                                    MRXSMB_MM_POOLTAG);

   if (SmbMmRequestZoneSegmentPtr != NULL) {
      (VOID) ExInitializeZone( &SmbMmRequestZone,
                               SmbMmRequestZoneEntrySize,
                               SmbMmRequestZoneSegmentPtr,
                               ZoneSegmentSize );

      // set up the sizes for allocation.
      ObjectSizeInBytes[SMBCEDB_OT_SERVER] = sizeof(SMBCEDB_SERVER_ENTRY);
      ObjectSizeInBytes[SMBCEDB_OT_NETROOT] = sizeof(SMBCEDB_NET_ROOT_ENTRY);
      ObjectSizeInBytes[SMBCEDB_OT_SESSION] = sizeof(SMBCEDB_SESSION_ENTRY);
      ObjectSizeInBytes[SMBCEDB_OT_REQUEST] = sizeof(SMBCEDB_REQUEST_ENTRY);

      // set up the exchange sizes
      ExchangeSizeInBytes[CONSTRUCT_NETROOT_EXCHANGE] = sizeof(SMB_CONSTRUCT_NETROOT_EXCHANGE);
      ExchangeSizeInBytes[ORDINARY_EXCHANGE]          = sizeof(SMB_PSE_ORDINARY_EXCHANGE);
      ExchangeSizeInBytes[ADMIN_EXCHANGE]             = sizeof(SMB_ADMIN_EXCHANGE);

      InitializeListHead(&SmbMmExchangesInUse[CONSTRUCT_NETROOT_EXCHANGE]);
      InitializeListHead(&SmbMmExchangesInUse[ORDINARY_EXCHANGE]);
      InitializeListHead(&SmbMmExchangesInUse[ADMIN_EXCHANGE]);

      InitializeListHead(&SmbMmObjectsInUse[SMBCEDB_OT_SERVER]);
      InitializeListHead(&SmbMmObjectsInUse[SMBCEDB_OT_SESSION]);
      InitializeListHead(&SmbMmObjectsInUse[SMBCEDB_OT_NETROOT]);
      InitializeListHead(&SmbMmObjectsInUse[SMBCEDB_OT_REQUEST]);

      SmbMmExchangeId = 1;

   } else {
      Status = STATUS_INSUFFICIENT_RESOURCES;
   }

   return Status;
}

VOID SmbMmTearDown()
/*++

Routine Description:

    This routine tears down the memory management structures in the SMB connection
    engine

--*/
{
   NTSTATUS Status;

   // free the segment associated with RxCe object allocation.
   RxFreePool(SmbMmRequestZoneSegmentPtr);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\netroot.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    netroot.c

Abstract:

    This module implements the routines for creating the SMB net root.


--*/

#include "precomp.h"
#pragma hdrstop


//
//  The Bug check file id for this module
//

#define BugCheckFileId  (RDBSS_BUG_CHECK_SMB_NETROOT)

//
//  The local debug trace level
//

#define Dbg (DEBUG_TRACE_DISPATCH)

//
// Forward declarations ...
//

extern NTSTATUS
SmbCeParseConstructNetRootResponse(
   PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange,
   PSMB_HEADER                     pSmbHeader,
   ULONG                           BytesAvailable,
   ULONG                           BytesIndicated,
   ULONG                           *pBytesTaken);

extern NTSTATUS
SmbConstructNetRootExchangeFinalize(
         PSMB_EXCHANGE  pExchange,
         BOOLEAN        *pPostFinalize);



NTSTATUS
MRxIfsUpdateNetRootState(
    IN OUT PMRX_NET_ROOT pNetRoot)
/*++

Routine Description:

   This routine updates the mini redirector state associated with a net root.

Arguments:

    pNetRoot - the net root instance.

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    By diffrentiating the mini redirector state from the net root condition it is possible
    to permit a variety of reconnect strategies. It is conceivable that the RDBSS considers
    a net root to be good while the underlying mini redirector might mark it as invalid
    and reconnect on the fly.

--*/
{
   if (pNetRoot->Context == NULL) {
      pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_ERROR;
   } else {
      PSMBCEDB_SERVER_ENTRY   pServerEntry;

      pServerEntry = SmbCeReferenceAssociatedServerEntry(pNetRoot->pSrvCall);

      if (pServerEntry != NULL) {

      switch (pServerEntry->Header.State) {
         case SMBCEDB_ACTIVE:
            pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_GOOD;
            break;
         case SMBCEDB_INVALID:
            pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_DISCONNECTED;
            break;
         case SMBCEDB_CONSTRUCTION_IN_PROGRESS:
            pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_RECONN;
            break;
         default:
            pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_ERROR;
            break;
         }

         SmbCeDereferenceServerEntry(pServerEntry);
      } else {
         pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_ERROR;
      }
   }

   return STATUS_SUCCESS;
}

ULONG
MRxSmbGetDialectFlagsFromSrvCall(
    PMRX_SRV_CALL SrvCall
    )
{
   ULONG DialectFlags;
   PSMBCEDB_SERVER_ENTRY pServerEntry;

   pServerEntry = SmbCeReferenceAssociatedServerEntry(SrvCall);
   ASSERT(pServerEntry != NULL);
   DialectFlags = pServerEntry->Server.DialectFlags;
   SmbCeDereferenceServerEntry(pServerEntry);
   return(DialectFlags);
}


NTSTATUS
MRxIfsCreateVNetRoot(
    IN OUT PMRX_V_NET_ROOT        pVNetRoot,
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    )
/*++

Routine Description:

   This routine patches the RDBSS created net root instance with the information required
   by the mini redirector.

Arguments:

    pVNetRoot - the virtual net root instance.

    pCreateNetRootContext - the net root context for calling back

Return Value:

    NTSTATUS - The return status for the operation

Notes:

--*/
{
   NTSTATUS  Status;
   PRX_CONTEXT pRxContext = pCreateNetRootContext->RxContext;

   PMRX_SRV_CALL pSrvCall;
   PMRX_NET_ROOT pNetRoot;

   PUNICODE_STRING pNetRootName,pSrvCallName;
   BOOLEAN  fTreeConnectOpen = TRUE; // RxContext->Create.ThisIsATreeConnectOpen;
   BOOLEAN  fInitializeNetRoot;
   BOOLEAN  fDereferenceSessionEntry = FALSE;
   BOOLEAN  fDereferenceNetRootEntry = FALSE;

   if (pRxContext->Create.ThisIsATreeConnectOpen){
       InterlockedIncrement(&MRxIfsStatistics.UseCount);
   }

   pNetRoot = pVNetRoot->pNetRoot;
   pSrvCall = pNetRoot->pSrvCall;

   // The V_NET_ROOT is associated with a NET_ROOT. The two cases of interest are as
   // follows
   // 1) the V_NET_ROOT and the associated NET_ROOT are being newly created.
   // 2) a new V_NET_ROOT associated with an existing NET_ROOT is being created.
   //
   // These two cases can be distinguished by checking if the context associated with
   // NET_ROOT is NULL. Since the construction of NET_ROOT's/V_NET_ROOT's are serialized
   // by the wrapper this is a safe check.
   // ( The wrapper cannot have more then one thread tryingto initialize the same
   // NET_ROOT).

   fInitializeNetRoot = (pNetRoot->Context == NULL);

   ASSERT((NodeType(pNetRoot) == RDBSS_NTC_NETROOT) &&
          (NodeType(pNetRoot->pSrvCall) == RDBSS_NTC_SRVCALL));

   Status = STATUS_SUCCESS;

   // update the net root state to be good.

   if (fInitializeNetRoot) {
      pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_GOOD;
   }

   if (Status == STATUS_SUCCESS)
   {

       Status = SmbCeInitializeSessionEntry(pVNetRoot);
       fDereferenceSessionEntry = (Status == STATUS_SUCCESS);

      if (fInitializeNetRoot && (Status == STATUS_SUCCESS)) {
         Status = SmbCeInitializeNetRootEntry(pNetRoot);

         fDereferenceNetRootEntry = (Status == STATUS_SUCCESS);
         RxDbgTrace( 0, Dbg, ("SmbCeOpenNetRoot %lx\n",Status));
      }

      if (NT_SUCCESS(Status)) {
         if (fTreeConnectOpen &&
             (pNetRoot->Type != NET_ROOT_MAILSLOT)) {
            Status = SmbCeEstablishConnection(pVNetRoot,pCreateNetRootContext);
         } else {
            Status = STATUS_SUCCESS;
         }
      }
   }

   if (Status != STATUS_PENDING) {
      if (!NT_SUCCESS(Status)) {
         if (fInitializeNetRoot && fDereferenceNetRootEntry) {
            SmbCeDereferenceNetRootEntry(SmbCeGetAssociatedNetRootEntry(pNetRoot));
            pNetRoot->Context  = NULL;
         }

         if (fDereferenceSessionEntry) {
            SmbCeDereferenceSessionEntry(SmbCeGetAssociatedSessionEntry(pVNetRoot));
            pVNetRoot->Context = NULL;
         }
      }

      pCreateNetRootContext->VirtualNetRootStatus = Status;
      if (fInitializeNetRoot) {
         pCreateNetRootContext->NetRootStatus = Status;
      } else {
         pCreateNetRootContext->NetRootStatus = STATUS_SUCCESS;
      }

      if (pRxContext->Create.ThisIsATreeConnectOpen){
          InterlockedIncrement(&MRxIfsStatistics.FailedUseCount);
      }

      // Callback the RDBSS for resumption.
      pCreateNetRootContext->Callback(pCreateNetRootContext);

      // Map the error code to STATUS_PENDING since this triggers the synchronization
      // mechanism in the RDBSS.
      Status = STATUS_PENDING;
   }

   return Status;
}


NTSTATUS
MRxIfsFinalizeVNetRoot(
    IN PMRX_V_NET_ROOT pVNetRoot,
    IN PBOOLEAN        ForceDisconnect)
/*++

Routine Description:


Arguments:

    pVNetRoot - the virtual net root

    ForceDisconnect - disconnect is forced

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
   PSMBCEDB_SESSION_ENTRY pSessionEntry;
   PSMBCEDB_SERVER_ENTRY  pServerEntry;
   PSMBCEDB_SESSION_ENTRY pDefaultSessionEntry;

   RxDbgTrace( 0, Dbg, ("MRxSmbFinalizeVNetRoot %lx\n",pVNetRoot));

   if (pVNetRoot->Context != NULL)
   {
      pSessionEntry = SmbCeGetAssociatedSessionEntry(pVNetRoot);
      pServerEntry  = SmbCeGetAssociatedServerEntry(pVNetRoot->pNetRoot->pSrvCall);

      pDefaultSessionEntry = SmbCeGetDefaultSessionEntry(pServerEntry);

      if ((pDefaultSessionEntry != NULL) && (pDefaultSessionEntry == pSessionEntry))
      {
         SmbCeAcquireSpinLock();

         if (pDefaultSessionEntry->pRdbssVNetRoot == pVNetRoot)
         {
            SmbCeSetDefaultSessionEntryLite(pServerEntry,NULL);
         }

         SmbCeReleaseSpinLock();
         DbgPrint("Resetting default session entry to NULL\n");
      }

      SmbCeDereferenceSessionEntry(pSessionEntry);
   }

   return STATUS_SUCCESS;
}


NTSTATUS
MRxIfsFinalizeNetRoot(
    IN PMRX_NET_ROOT   pNetRoot,
    IN PBOOLEAN        ForceDisconnect)
/*++

Routine Description:


Arguments:

    pVirtualNetRoot - the virtual net root

    ForceDisconnect - disconnect is forced

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
   PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

   RxDbgTrace( 0, Dbg, ("MRxSmbFinalizeNetRoot %lx\n",pNetRoot));

   if (pNetRoot->Context != NULL)
   {
      pNetRootEntry = SmbCeGetAssociatedNetRootEntry(pNetRoot);
      SmbCeDereferenceNetRootEntry(pNetRootEntry);
   }

   return STATUS_SUCCESS;
}

VOID
SmbCeReconnectCallback(
   PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext)
/*++

Routine Description:

   This routine signals the completion of a reconnect attempt

Arguments:

    pCreateNetRootContext - the net root context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
   KeSetEvent(&pCreateNetRootContext->FinishEvent, IO_NETWORK_INCREMENT, FALSE );
}

NTSTATUS
SmbCeReconnect(
    IN PMRX_V_NET_ROOT            pVNetRoot)
/*++

Routine Description:

   This routine reconnects, i.e, establishes a new session and tree connect to a previously
   connected serverb share

Arguments:

    pVNetRoot - the virtual net root instance.

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
   NTSTATUS Status;

   PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext;

   pCreateNetRootContext = (PMRX_CREATENETROOT_CONTEXT)
                           RxAllocatePoolWithTag(
                               NonPagedPool,
                               sizeof(MRX_CREATENETROOT_CONTEXT),
                               MRXSMB_NETROOT_POOLTAG);

   if (pCreateNetRootContext != NULL) {
      pCreateNetRootContext->NetRootStatus  = STATUS_SUCCESS;
      pCreateNetRootContext->VirtualNetRootStatus = STATUS_SUCCESS;
      pCreateNetRootContext->Callback       = SmbCeReconnectCallback;
      pCreateNetRootContext->RxContext      = NULL;
      KeInitializeEvent( &pCreateNetRootContext->FinishEvent, SynchronizationEvent, FALSE );

      Status = SmbCeEstablishConnection(pVNetRoot,pCreateNetRootContext);
      if (Status == STATUS_PENDING) {
         // Wait for the construction to be completed.
         KeWaitForSingleObject(&pCreateNetRootContext->FinishEvent, Executive, KernelMode, FALSE, NULL);
         Status = pCreateNetRootContext->VirtualNetRootStatus;
      }

      RxFreePool(pCreateNetRootContext);
   } else {
      Status = STATUS_INSUFFICIENT_RESOURCES;
   }

   return Status;
}


NTSTATUS
SmbCeEstablishConnection(
    IN OUT PMRX_V_NET_ROOT        pVNetRoot,
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    )
/*++

Routine Description:

   This routine triggers off the connection attempt for initial establishment of a
   connection as well as subsequent reconnect attempts.

Arguments:

    pVNetRoot - the virtual net root instance.

    pCreateNetRootContext - the net root context for calling back

Return Value:

    NTSTATUS - The return status for the operation

Notes:

--*/
{
   NTSTATUS                Status;

   PSMBCEDB_SERVER_ENTRY   pServerEntry;
   PSMBCEDB_SESSION_ENTRY  pSessionEntry;
   PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

   pServerEntry = SmbCeReferenceAssociatedServerEntry(pVNetRoot->pNetRoot->pSrvCall);
   if (pServerEntry != NULL) {
      pNetRootEntry = SmbCeReferenceAssociatedNetRootEntry(pVNetRoot->pNetRoot);
      if (pNetRootEntry != NULL) {
         pSessionEntry = SmbCeReferenceAssociatedSessionEntry(pVNetRoot);
         if (pSessionEntry != NULL) {
            Status = STATUS_SUCCESS;
         } else {
            SmbCeDereferenceNetRootEntry(pNetRootEntry);
            Status = STATUS_CONNECTION_DISCONNECTED;
         }
      } else {
         Status = STATUS_CONNECTION_DISCONNECTED;
      }

      if (Status != STATUS_SUCCESS) {
         SmbCeDereferenceServerEntry(pServerEntry);
      }
   } else {
      Status = STATUS_BAD_NETWORK_PATH;
   }

   if (Status != STATUS_SUCCESS) {
      return Status;
   }


   if ((Status == STATUS_SUCCESS) &&
       ((pNetRootEntry->Header.State != SMBCEDB_ACTIVE) ||
        ((pSessionEntry->Header.State != SMBCEDB_ACTIVE) &&
         !(pServerEntry->Server.DialectFlags & DF_KERBEROS)))) {
      // This is a tree connect open which needs to be triggered immediately.
      PSMB_EXCHANGE                  pSmbExchange;
      PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange;

      pSmbExchange = SmbMmAllocateExchange(CONSTRUCT_NETROOT_EXCHANGE,NULL);
      if (pSmbExchange != NULL) {
         Status = SmbCeInitializeExchange(
                        &pSmbExchange,
                        pVNetRoot,
                        CONSTRUCT_NETROOT_EXCHANGE,
                        &ConstructNetRootExchangeDispatch);

         if (Status == STATUS_SUCCESS) {
            pNetRootExchange = (PSMB_CONSTRUCT_NETROOT_EXCHANGE)pSmbExchange;

            // Attempt to reconnect( In this case it amounts to establishing the
            // connection/session)
            pNetRootExchange->SmbCeFlags |= SMBCE_EXCHANGE_ATTEMPT_RECONNECTS;
            // Initialize the continuation for resumption upon completion of the
            // tree connetcion.
            pNetRootExchange->NetRootCallback       = pCreateNetRootContext->Callback;
            pNetRootExchange->pCreateNetRootContext = pCreateNetRootContext;

            // Initiate the exchange.
            Status = SmbCeInitiateExchange(pSmbExchange);

            if (Status != STATUS_PENDING) {
               SmbCeDiscardExchange(pSmbExchange);
            }
         }
      } else {
         Status = STATUS_INSUFFICIENT_RESOURCES;
      }
   }

   SmbCeDereferenceEntries(pServerEntry,pSessionEntry,pNetRootEntry);

   return Status;
}

//
// The net roots are normally constructed as part of some other exchange, i.e., the SMB for
// Tree connect is compounded with other operations. However, there is one situation in which
// the tree connect SMB needs to be sent by itself. This case refers to the prefix claim
// situation ( net use command ). This is handled by the construct net root exchange.
//

#define CONSTRUCT_NETROOT_BUFFER_SIZE (4096)

NTSTATUS
SmbConstructNetRootExchangeStart(
      PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

    This is the start routine for net root construction exchanges. This initiates the
    construction of the appropriate SMB's if required.

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
   NTSTATUS Status;
   NTSTATUS RequestLockStatus;
   NTSTATUS ResponseLockStatus;

   PVOID pSmbBuffer;
   UCHAR SmbCommand,LastCommandInHeader;
   ULONG SmbLength;

   PUCHAR pCommand;

   PMDL  pSmbRequestMdl,pSmbResponseMdl;
   ULONG SmbMdlSize;

   PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange;

   pNetRootExchange = (PSMB_CONSTRUCT_NETROOT_EXCHANGE)pExchange;

   ASSERT(pNetRootExchange->Type == CONSTRUCT_NETROOT_EXCHANGE);

   pSmbRequestMdl = pSmbResponseMdl = NULL;

   pSmbBuffer = RxAllocatePoolWithTag(
                    PagedPool | POOL_COLD_ALLOCATION,
                    CONSTRUCT_NETROOT_BUFFER_SIZE,
                    MRXSMB_NETROOT_POOLTAG);

   if (pSmbBuffer != NULL) {
      PSMBCE_SERVER pServer = &pExchange->SmbCeContext.pServerEntry->Server;

      Status = SmbCeBuildSmbHeader(
                     pExchange,
                     pSmbBuffer,
                     CONSTRUCT_NETROOT_BUFFER_SIZE,
                     &SmbLength,
                     &LastCommandInHeader,
                     &pCommand);

      // Ensure that the NET_ROOT/SESSION still needs to be constructed before
      // sending it. It is likely that they were costructed by an earlier exchange
      if (NT_SUCCESS(Status) &&
          (SmbLength > sizeof(SMB_HEADER))) {

         if (LastCommandInHeader != SMB_COM_TREE_CONNECT){
             *pCommand = SMB_COM_NO_ANDX_COMMAND;
         }

         pSmbRequestMdl  = RxAllocateMdl(pSmbBuffer,CONSTRUCT_NETROOT_BUFFER_SIZE);
         pSmbResponseMdl = RxAllocateMdl(pSmbBuffer,CONSTRUCT_NETROOT_BUFFER_SIZE);

         if ((pSmbRequestMdl != NULL) &&
             (pSmbResponseMdl != NULL)) {
            RxProbeAndLockPages(pSmbRequestMdl,KernelMode,IoModifyAccess,RequestLockStatus);
            RxProbeAndLockPages(pSmbResponseMdl,KernelMode,IoModifyAccess,ResponseLockStatus);

            if ((Status  == STATUS_SUCCESS) &&
                ((Status = RequestLockStatus)  == STATUS_SUCCESS) &&
                ((Status = ResponseLockStatus) == STATUS_SUCCESS)) {
               pNetRootExchange->pSmbResponseMdl = pSmbResponseMdl;
               pNetRootExchange->pSmbRequestMdl  = pSmbRequestMdl;
               pNetRootExchange->pSmbBuffer      = pSmbBuffer;

               Status = SmbCeTranceive(
                              pExchange,
                              (RXCE_SEND_PARTIAL | RXCE_SEND_SYNCHRONOUS),
                              pNetRootExchange->pSmbRequestMdl,
                              SmbLength);

               RxDbgTrace( 0, Dbg, ("Net Root SmbCeTranceive returned %lx\n",Status));
            }
         }

         if ((Status != STATUS_PENDING) &&
             (Status != STATUS_SUCCESS)) {
            pNetRootExchange->pSmbResponseMdl = NULL;
            pNetRootExchange->pSmbRequestMdl  = NULL;
            pNetRootExchange->pSmbBuffer      = NULL;

            if (pSmbResponseMdl != NULL) {
               if (ResponseLockStatus == STATUS_SUCCESS) {
                  MmUnlockPages(pSmbResponseMdl);
               }

               IoFreeMdl(pSmbResponseMdl);
            }

            if (pSmbRequestMdl != NULL) {
               if (RequestLockStatus == STATUS_SUCCESS) {
                  MmUnlockPages(pSmbRequestMdl);
               }

               IoFreeMdl(pSmbRequestMdl);
            }

            RxFreePool(pSmbBuffer);
         }
      } else {
         RxFreePool(pSmbBuffer);
      }
   } else {
      Status = STATUS_INSUFFICIENT_RESOURCES;
   }

   return Status;
}

NTSTATUS
SmbConstructNetRootExchangeReceive(
    IN struct _SMB_EXCHANGE *pExchange,    // The exchange instance
    IN ULONG  BytesIndicated,
    IN ULONG  BytesAvailable,
    OUT ULONG *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL *pDataBufferPointer,
    OUT PULONG             pDataSize)
/*++

Routine Description:

    This is the recieve indication handling routine for net root construction exchanges

Arguments:

    pExchange - the exchange instance

    BytesIndicated - the number of bytes indicated

    Bytes Available - the number of bytes available

    pBytesTaken     - the number of bytes consumed

    pSmbHeader      - the byte buffer

    pDataBufferPointer - the buffer into which the remaining data is to be copied.

    pDataSize       - the buffer size.

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    This routine is called at DPC level.

--*/
{
   NTSTATUS Status;

   PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange;

   pNetRootExchange = (PSMB_CONSTRUCT_NETROOT_EXCHANGE)pExchange;

   RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesIndicated/Available %ld %ld\n",BytesIndicated,BytesAvailable));
   if (BytesAvailable > BytesIndicated) {
      // The SMB response was not completely returned. Post a copy data request to
      // get the remainder of the response. If the response is greater than the original
      // buffer size, abort this connection request and consume the bytes available.
      if (BytesAvailable > CONSTRUCT_NETROOT_BUFFER_SIZE) {
         ASSERT(!"not enough bytes in parsesmbheader.....sigh.............."); // To be removed soon ...
         pExchange->Status = STATUS_NOT_IMPLEMENTED;
         *pBytesTaken = BytesAvailable;
         Status       = STATUS_SUCCESS;
      } else {
         *pBytesTaken        = 0;
         *pDataBufferPointer = pNetRootExchange->pSmbResponseMdl;
         *pDataSize          = BytesAvailable;
         Status              = STATUS_MORE_PROCESSING_REQUIRED;
      }
   } else {
      // The SMB exchange completed without an error.
      pExchange->Status = SmbCeParseConstructNetRootResponse(
                                 pNetRootExchange,
                                 pSmbHeader,
                                 BytesAvailable,
                                 BytesIndicated,
                                 pBytesTaken);

      RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesTaken %ld\n",*pBytesTaken));
      RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader Return Status %lx\n",pExchange->Status));
      Status = STATUS_SUCCESS;
   }

   return Status;
}

NTSTATUS
SmbConstructNetRootExchangeCopyDataHandler(
    IN PSMB_EXCHANGE    pExchange,    // The exchange instance
    IN PMDL       pCopyDataBuffer,
    IN ULONG            DataSize)
/*++

Routine Description:

    This is the copy data handling routine for net root construction exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
   PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange;

   PSMB_HEADER pSmbHeader;
   ULONG       ResponseSize = DataSize;
   ULONG       ResponseBytesConsumed = 0;

   pNetRootExchange = (PSMB_CONSTRUCT_NETROOT_EXCHANGE)pExchange;
   ASSERT(pCopyDataBuffer == pNetRootExchange->pSmbResponseMdl);

   pSmbHeader = (PSMB_HEADER)MmGetSystemAddressForMdl(pNetRootExchange->pSmbResponseMdl);

   pExchange->Status = SmbCeParseConstructNetRootResponse(
                           pNetRootExchange,
                           pSmbHeader,
                           ResponseSize,
                           ResponseSize,
                           &ResponseBytesConsumed);

   RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesTaken %ld\n",ResponseBytesConsumed));

   return STATUS_SUCCESS;
}

NTSTATUS
SmbCeParseConstructNetRootResponse(
   PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange,
   PSMB_HEADER                     pSmbHeader,
   ULONG                           BytesAvailable,
   ULONG                           BytesIndicated,
   ULONG                           *pBytesTaken)
{
   NTSTATUS     Status,SmbResponseStatus;
   GENERIC_ANDX CommandToProcess;

   RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesIndicated %ld\n",BytesIndicated));
   Status = SmbCeParseSmbHeader(
                              (PSMB_EXCHANGE)pNetRootExchange,
                              pSmbHeader,
                              &CommandToProcess,
                              &SmbResponseStatus,
                              BytesAvailable,
                              BytesIndicated,
                              pBytesTaken);

   if (Status == STATUS_SUCCESS) {
      *pBytesTaken = BytesIndicated;
   }

   return Status;
}

NTSTATUS
SmbConstructNetRootExchangeFinalize(
         PSMB_EXCHANGE pExchange,
         BOOLEAN       *pPostFinalize)
/*++

Routine Description:

    This routine finalizes the construct net root exchange. It resumes the RDBSS by invoking
    the call back and discards the exchange

Arguments:

    pExchange - the exchange instance

    CurrentIrql - the current interrupt request level

    pPostFinalize - a pointer to a BOOLEAN if the request should be posted

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
   PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange;
   PMRX_CREATENETROOT_CONTEXT      pCreateNetRootContext;

   PMRX_V_NET_ROOT pVNetRoot;
   PMRX_NET_ROOT   pNetRoot;

   if (RxShouldPostCompletion()) {
      *pPostFinalize = TRUE;
      return STATUS_SUCCESS;
   } else {
      *pPostFinalize = FALSE;
   }

   pVNetRoot = pExchange->SmbCeContext.pVNetRoot;
   pNetRoot  = pVNetRoot->pNetRoot;
   ASSERT((pVNetRoot == NULL) || (pVNetRoot->pNetRoot == pNetRoot));
   pNetRootExchange = (PSMB_CONSTRUCT_NETROOT_EXCHANGE)pExchange;

   ASSERT(pNetRootExchange->Type == CONSTRUCT_NETROOT_EXCHANGE);

   pCreateNetRootContext = pNetRootExchange->pCreateNetRootContext;

   pCreateNetRootContext->VirtualNetRootStatus = STATUS_SUCCESS;
   pCreateNetRootContext->NetRootStatus        = STATUS_SUCCESS;

   RxDbgTrace(0,Dbg,("SmbConstructNetRootExchangeFinalize: Net Root Exchange Status %lx\n", pExchange->Status));
   if (!NT_SUCCESS(pExchange->Status)) {
      if (pCreateNetRootContext->RxContext
           && pCreateNetRootContext->RxContext->Create.ThisIsATreeConnectOpen){
          InterlockedIncrement(&MRxIfsStatistics.FailedUseCount);
      }

      if (pExchange->SmbCeContext.pSessionEntry->Header.State != SMBCEDB_ACTIVE) {
         pCreateNetRootContext->VirtualNetRootStatus = pExchange->Status;
      }

      if (pExchange->SmbCeContext.pNetRootEntry->Header.State != SMBCEDB_ACTIVE) {
         pCreateNetRootContext->NetRootStatus = pExchange->Status;
      }
   } else {

      if (pExchange->SmbCeContext.pSessionEntry->Header.State == SMBCEDB_ACTIVE) {
         PSMBCEDB_SESSION_ENTRY pSessionEntry = pExchange->SmbCeContext.pSessionEntry;
         PSMBCEDB_SERVER_ENTRY  pServerEntry  = pSessionEntry->pServerEntry;
         PMRX_V_NET_ROOT        pVNetRoot     = pExchange->SmbCeContext.pVNetRoot;

         // Mark this session entry as the default entry if required.
         if (FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_SESSION_CONSTRUCTOR) &&
             ((pVNetRoot->pUserName != NULL) || (pVNetRoot->pPassword != NULL))) {
            SmbCeAcquireSpinLock();

            if (SmbCeGetDefaultSessionEntry(pServerEntry) == NULL) {
               SmbCeSetDefaultSessionEntryLite(pServerEntry,pSessionEntry);
            }

            SmbCeReleaseSpinLock();
         }
      }

      //if the transaction can identify the netroottype, use it. otherwise, stay with what you have!

      if (pExchange->SmbCeContext.pNetRootEntry->NetRoot.NetRootType != NET_ROOT_WILD){
          pNetRoot->Type = pExchange->SmbCeContext.pNetRootEntry->NetRoot.NetRootType;
      }


      //
      // NOTE:  In this example minirdr, only remote disk access is allowed. This means
      //        that pipes, mailslots, printers, remote comm devices, are NOT supported.
      //        If the user mode caller tries to open a pipe, the open (or tree connect)
      //        will be sent over the wire, but we intercept the response here and
      //        mark it as unsuccessful (actually un-implemented). This after-the-fact
      //        approach allows us to keep existing error recover mechanisms in the
      //        code working.


      switch (pNetRoot->Type) {

         //
         // If the remote access is for a disk, mark the device as a disk and
         // go ahead.
         //

      case NET_ROOT_DISK:
         pNetRoot->DeviceType = RxDeviceType(DISK);
         break;


      case NET_ROOT_PIPE:
      case NET_ROOT_COMM:
      case NET_ROOT_PRINT:
      case NET_ROOT_MAILSLOT:

         //
         // The remote was NOT a disk, so mark the NetRootStatus and VNetRoot
         // status as bad. Code that follows will detect this and return
         // diagnostic information to the caller. The operation fails.
         //


         pCreateNetRootContext->VirtualNetRootStatus = STATUS_NOT_IMPLEMENTED;
         pCreateNetRootContext->NetRootStatus        = STATUS_NOT_IMPLEMENTED;

         RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("SmbConstructNetRootExchangeFinalize: Non-disk attempt forcibly denied\n"));
         break;

      case NET_ROOT_WILD:
         break;

      default:
         ASSERT(!"Valid Net Root Type");
      }
   }

   //
   // Now do the callback.
   //

   pNetRootExchange->NetRootCallback(pCreateNetRootContext);

   if (pNetRootExchange->pSmbResponseMdl != NULL) {
      MmUnlockPages(pNetRootExchange->pSmbResponseMdl);
      IoFreeMdl(pNetRootExchange->pSmbResponseMdl);
   }

   if (pNetRootExchange->pSmbRequestMdl != NULL) {
      MmUnlockPages(pNetRootExchange->pSmbRequestMdl);
      IoFreeMdl(pNetRootExchange->pSmbRequestMdl);
   }

   if (pNetRootExchange->pSmbBuffer != NULL) {
      RxFreePool(pNetRootExchange->pSmbBuffer);
   }

   //
   // Get rid of the exchange
   //

   SmbCeDiscardExchange(pExchange);

   return STATUS_SUCCESS;
}

SMB_EXCHANGE_DISPATCH_VECTOR
ConstructNetRootExchangeDispatch = {
                                       SmbConstructNetRootExchangeStart,
                                       SmbConstructNetRootExchangeReceive,
                                       SmbConstructNetRootExchangeCopyDataHandler,
                                       NULL,  // No SendCompletionHandler
                                       SmbConstructNetRootExchangeFinalize
                                   };


VOID
MRxIfsExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    )
/*++

Routine Description:

    This routine parses the input name into srv, netroot, and the
    rest.

Arguments:


--*/
{
    UNICODE_STRING xRestOfName;

    ULONG length = FilePathName->Length;
    PWCH w = FilePathName->Buffer;
    PWCH wlimit = (PWCH)(((PCHAR)w)+length);
    PWCH wlow;

    w += (SrvCall->pSrvCallName->Length/sizeof(WCHAR));
    NetRootName->Buffer = wlow = w;
    for (;;) {
        if (w>=wlimit) break;
        if ( (*w == OBJ_NAME_PATH_SEPARATOR) && (w!=wlow) ){
            break;
        }
        w++;
    }
    NetRootName->Length = NetRootName->MaximumLength
                = (PCHAR)w - (PCHAR)wlow;

    if (!RestOfName) RestOfName = &xRestOfName;
    RestOfName->Buffer = w;
    RestOfName->Length = RestOfName->MaximumLength
                       = (PCHAR)wlimit - (PCHAR)w;

    RxDbgTrace( 0,Dbg,("  MRxSmbExtractNetRootName FilePath=%wZ\n",FilePathName));
    RxDbgTrace(0,Dbg,("         Srv=%wZ,Root=%wZ,Rest=%wZ\n",
                        SrvCall->pSrvCallName,NetRootName,RestOfName));

    return;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\notimpl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    notimpl.c

Abstract:

    This module includes prototypes of the functionality that has not been
    implemented in the IFS mini rdr.


--*/

#include "precomp.h"
#pragma hdrstop

//
// File System Control funcitonality
//


NTSTATUS
MRxIfsFsCtl(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs an FSCTL operation (remote) on a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation


--*/
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    RxDbgTrace(-1, Dbg, ("MRxSmbFsCtl -> %08lx\n", Status ));
    return Status;
}




NTSTATUS
MRxIfsNotifyChangeDirectoryCancellation(
   PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine is invoked when a directory change notification operation is cancelled.
   This example doesn't support it.


Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{

   UNREFERENCED_PARAMETER(RxContext);

   return STATUS_SUCCESS;
}



NTSTATUS
MRxIfsNotifyChangeDirectory(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs a directory change notification operation.
   This example doesn't support it.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation [not implemented]

--*/
{

   UNREFERENCED_PARAMETER(RxContext);

   return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
MRxIfsIoCtl(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs an IOCTL operation. Currently, no calls are remoted;
Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    return Status;
}


//
// Extended Attributes (EA) functionality
//


NTSTATUS
MRxIfsQueryEaInformation (
    IN OUT PRX_CONTEXT RxContext
    )
{
   PAGED_CODE();

   UNREFERENCED_PARAMETER(RxContext);

   return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
MRxIfsSetEaInformation (
    IN OUT PRX_CONTEXT  RxContext
    )
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(RxContext);

    return STATUS_NOT_IMPLEMENTED;
}



NTSTATUS
MRxIfsQuerySecurityInformation (
    IN OUT PRX_CONTEXT RxContext
    )
{
   return STATUS_NOT_IMPLEMENTED;
}



NTSTATUS
MRxIfsSetSecurityInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    )
{
   return STATUS_NOT_IMPLEMENTED;
}





NTSTATUS
MRxIfsLoadEaList(
    IN PRX_CONTEXT RxContext,
    IN PUCHAR  UserEaList,
    IN ULONG   UserEaListLength,
    OUT PFEALIST *ServerEaList
    )
{

   return STATUS_NOT_IMPLEMENTED;
}




NTSTATUS
MRxIfsSetEaList(
    IN PRX_CONTEXT RxContext,
    IN PFEALIST ServerEaList
    )
{
   return STATUS_NOT_IMPLEMENTED;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\midatlas.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    midatlas.h

Abstract:

    This module defines the data structure used in mapping MIDS to the corresponding requests/
    contexts associated with them.

Notes:

   MID (Multiplex ID) is used at both the server and the client ( redirector ) to distinguish
   between the concurrently active requests on any connection. This data structure has been
   designed to meet the following criterion.

   1) It should scale well to handle the differing capabilities of a server, e.g., the typical
   NT server permits 50 outstanding requests on any connection. The CORE level servers can go as
   low as one and on Gateway machines the desired number can be very high ( in the oreder of thousands)

   2) The two primary operations that need to be handled well are
      i) mapping a MID to the context associated with it.
         -- This routine will be invoked to process every packet received along any connection
         at both the server and the client.
      ii) generating a new MID for sending requests to the server.
         -- This will be used at the client both for max. command enforcement as well as
         tagging each concurrent request with a unique id.

    The most common case is that of a connection between a NT client and a NT server. All
    design decisions have been made in order to ensure that the solutions are optimal
    for this case.

    The MID data structure must be efficiently able to manage the unique tagging and identification
    of a number of mids ( typically 50 ) from a possible combination of 65536 values. In order to
    ensure a proper time space tradeoff the lookup is organized as a three level hierarchy.

    The 16 bits used to represent a MID  are split upinto three bit fields. The length of the
    rightmost field ( least signifiant ) is decided by the number of mids that are to be
    allocated on creation. The remaining length is split up equally between the next two
    fields, e.g., if 50 mids are to be allocated on creation , the length of the first field
    is 6 ( 64 ( 2 ** 6 ) is greater than 50 ), 5 and 5.

--*/

#ifndef _MIDATLAS_H_
#define _MIDATLAS_H_

typedef struct _MID_ATLAS_ {
   USHORT      MaximumNumberOfMids;
   USHORT      MidsAllocated;
   USHORT      NumberOfMidsInUse;
   USHORT      MidQuantum;
   UCHAR       MidQuantumFieldWidth;
   UCHAR       NumberOfLevels;
   LIST_ENTRY  MidMapFreeList;
   LIST_ENTRY  MidMapExpansionList;
   struct _MID_MAP_ *pRootMidMap;
} MID_ATLAS, *PMID_ATLAS;

typedef
VOID (*PCONTEXT_DESTRUCTOR)(
      PVOID pContext);

#define IfsMrxGetNumberOfMidsInUse(pMidAtlas) \
        ((pMidAtlas)->NumberOfMidsInUse)

extern PMID_ATLAS
IfsMrxCreateMidAtlas(
         USHORT MaximumNumberOfEntries,
         USHORT InitialAllocation);

extern VOID
IfsMrxDestroyMidAtlas(
         PMID_ATLAS pMidAtlas,
         PCONTEXT_DESTRUCTOR pContextDestructor);

extern PVOID
IfsMrxMapMidToContext(
         PMID_ATLAS pMidAtlas,
         USHORT     Mid);

extern NTSTATUS
IfsMrxAssociateContextWithMid(
         PMID_ATLAS pMidAtlas,
         PVOID      pContext,
         PUSHORT    pNewMid);

extern NTSTATUS
IfsMrxMapAndDissociateMidFromContext(
         PMID_ATLAS pMidAtlas,
         USHORT Mid,
         PVOID *pContextPointer);

extern NTSTATUS
IfsMrxReassociateMid(
         PMID_ATLAS pMidAtlas,
         USHORT     Mid,
         PVOID      pNewContext);

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\openclos.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    openclos.c

Abstract:

    This module implements the mini redirector call down routines pertaining to opening/
    closing of file/directories.


Revision History:

--*/

#include "precomp.h"
#pragma hdrstop



//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)


//
// forward declarations
//

NTSTATUS
SmbPseExchangeStart_Create(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
SmbPseExchangeStart_Close(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );



NTSTATUS
MRxSmbDownlevelCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

ULONG MRxSmbInitialSrvOpenFlags = 0;



#ifndef FORCE_SMALL_BUFFERS
ULONG MrxSmbLongestShortName = 0xffff; //use size calculated from the negotiated size
ULONG MrxSmbCreateTransactPacketSize = 0xffff; //use the negotiated size
#else
ULONG MrxSmbLongestShortName = 0;
ULONG MrxSmbCreateTransactPacketSize = 100;
#endif




NTSTATUS
MRxIfsCreate(
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine opens a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;

    RX_BLOCK_CONDITION FinalSrvOpenCondition;

    PMRX_SRV_OPEN SrvOpen = RxContext->Create.pSrvOpen;
    PMRX_SRV_CALL SrvCall = RxContext->Create.pSrvCall;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = NULL;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    ULONG DialectFlags;
    PUNICODE_STRING RemainingName = &(capFcb->AlreadyPrefixedName);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbCreate\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    RxDbgTrace( 0, Dbg, ("     Attempt to open %wZ\n", &(capFcb->AlreadyPrefixedName) ));


    if ((NetRoot->Type == NET_ROOT_DISK)  ||
        (NetRoot->Type == NET_ROOT_PRINT) ||
        (NetRoot->Type == NET_ROOT_WILD)  ||
        ((NetRoot->Type != NET_ROOT_MAILSLOT) &&
         (RemainingName->Length > sizeof(WCHAR)))) {

       Status = STATUS_SUCCESS;

       //
       // Get the dialect flags from the server
       //

       pServerEntry = SmbCeReferenceAssociatedServerEntry(SrvCall);

       ASSERT(pServerEntry != NULL);

       DialectFlags = pServerEntry->Server.DialectFlags;

       SmbCeDereferenceServerEntry(pServerEntry);



       //get rid of nonEA guys right now

       if (RxContext->Create.EaLength && !FlagOn(DialectFlags,DF_SUPPORTEA)) {
            RxDbgTrace(-1, Dbg, ("EAs w/o EA support!\n"));
            return((STATUS_NOT_SUPPORTED));
       }


       OrdinaryExchange = SmbPseCreateOrdinaryExchange(RxContext,
                                                       SrvOpen->pVNetRoot,
                                                       SMBPSE_OE_FROM_CREATE,
                                                       SmbPseExchangeStart_Create
                                                       );
       if (OrdinaryExchange==NULL) {
           RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
           return((STATUS_INSUFFICIENT_RESOURCES));
       }


       //
       // We don't support Eas, Sids or LongNames in this example minirdr
       //

       OrdinaryExchange->Create.CreateWithEasSidsOrLongName = FALSE;

       // For Creates, the resources need to be reacquired after sending an
       // SMB; so, do not hold onto the MIDS till finalization; instead give the MID back
       // right away

       OrdinaryExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_REUSE_MID;
       OrdinaryExchange->SmbCeFlags |= SMBCE_EXCHANGE_ATTEMPT_RECONNECTS;
       OrdinaryExchange->pSmbCeSynchronizationEvent = &RxContext->SyncEvent;

       //drop the resource before you go in! the start routine will reacquire it on the way out.....

       RxReleaseFcb( RxContext, capFcb );

       Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

       ASSERT((Status != STATUS_SUCCESS) || RxIsFcbAcquiredExclusive( capFcb ));

       if (!RxIsFcbAcquiredExclusive(capFcb)) {
           ASSERT(!RxIsFcbAcquiredShared(capFcb));
           RxAcquireExclusiveFcb( RxContext, capFcb );
       }

       OrdinaryExchange->pSmbCeSynchronizationEvent = NULL;


       FinalSrvOpenCondition = ((Status == STATUS_SUCCESS)
                                ? OrdinaryExchange->Create.FinalCondition
                                : Condition_Bad);

       SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);


    } else {

       RxFinishFcbInitialization( capFcb, RDBSS_NTC_MAILSLOT, NULL);
       Status = STATUS_SUCCESS;
    }

    ASSERT(Status != (STATUS_PENDING));
    ASSERT(RxIsFcbAcquiredExclusive( capFcb ));

    RxDbgTrace(-1, Dbg, ("MRxSmbCreate  exit with status=%08lx\n", Status ));
    return(Status);
}




NTSTATUS
MRxIfsCollapseOpen(
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine collapses a open locally

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;

    RX_BLOCK_CONDITION FinalSrvOpenCondition;

    PMRX_SRV_OPEN SrvOpen = RxContext->Create.pSrvOpen;
    PMRX_SRV_CALL SrvCall = RxContext->Create.pSrvCall;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;

    RxContext->pFobx = (PMRX_FOBX)RxCreateNetFobx( RxContext, SrvOpen);

    if (RxContext->pFobx != NULL) {
       ASSERT  ( RxIsFcbAcquiredExclusive ( capFcb )  );
       RxContext->pFobx->OffsetOfNextEaToReturn = 1;
       Status = STATUS_SUCCESS;
    } else {
       Status = (STATUS_INSUFFICIENT_RESOURCES);
       DbgBreakPoint();
    }

    return Status;
}


NTSTATUS
MRxIfsComputeNewBufferingState(
   IN OUT PMRX_SRV_OPEN   pMRxSrvOpen,
   IN     PVOID           pMRxContext,
      OUT PULONG          pNewBufferingState)
/*++

Routine Description:

   This routine maps the SMB specific oplock levels into the appropriate RDBSS
   buffering state flags

Arguments:

   pMRxSrvOpen - the MRX SRV_OPEN extension

   pMRxContext - the context passed to RDBSS at Oplock indication time

   pNewBufferingState - the place holder for the new buffering state

Return Value:


Notes:

--*/
{
   ULONG OplockLevel;

   PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(pMRxSrvOpen);

   ASSERT(pNewBufferingState != NULL);

   OplockLevel = (ULONG)pMRxContext;

   if (OplockLevel == SMB_OPLOCK_LEVEL_II) {
      *pNewBufferingState = (FCB_STATE_READBUFFERING_ENABLED  |
                             FCB_STATE_READCACHEING_ENABLED);
   } else {
      *pNewBufferingState = 0;
   }

   pMRxSrvOpen->BufferingFlags = *pNewBufferingState;

   return STATUS_SUCCESS;
}

typedef struct _MRXSMB_CREATE_PARAMETERS {
    UCHAR SecurityFlags;
} MRXSMB_CREATE_PARAMETERS, *PMRXSMB_CREATE_PARAMETERS;

VOID
MRxSmbAdjustCreateParameters (
    PRX_CONTEXT RxContext,
    PMRXSMB_CREATE_PARAMETERS smbcp
    )
/*++

Routine Description:

   This uses the RxContext as a base to reeach out and get the values of the NT create parameters.
   It also (a) implements the SMB idea that unbuffered is translated to write-through and (b) gets
   the SMB security flags.

Arguments:


Return Value:


Notes:



--*/
{

    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbAdjustCreateParameters\n"));

    cp->CreateOptions = cp->CreateOptions & ~(FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT);

    //the NT SMB spec says we have to change no-intermediate-buffering to write-through

    if (FlagOn(cp->CreateOptions,FILE_NO_INTERMEDIATE_BUFFERING)) {
        ASSERT (RxContext->CurrentIrpSp!=NULL);
        if (RxContext->CurrentIrpSp!=NULL) {
            PFILE_OBJECT capFileObject = RxContext->CurrentIrpSp->FileObject;
            ClearFlag(cp->CreateOptions,FILE_NO_INTERMEDIATE_BUFFERING);
            SetFlag(cp->CreateOptions,FILE_WRITE_THROUGH);
            SetFlag(RxContext->Flags,RX_CONTEXT_FLAG_WRITE_THROUGH);
            SetFlag(capFileObject->Flags,FO_WRITE_THROUGH);
        }
    }

    smbcp->SecurityFlags = 0;
    if (cp->SecurityContext->SecurityQos != NULL) {
        if (cp->SecurityContext->SecurityQos->ContextTrackingMode == SECURITY_DYNAMIC_TRACKING) {
            smbcp->SecurityFlags |= SMB_SECURITY_DYNAMIC_TRACKING;
        }
        if (cp->SecurityContext->SecurityQos->EffectiveOnly) {
            smbcp->SecurityFlags |= SMB_SECURITY_EFFECTIVE_ONLY;
        }
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbAdjustCreateParameters\n"));
}

VOID
MRxSmbAdjustReturnedCreateAction(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine repairs a bug in NT servers whereby the create action is contaminated
   by an oplock break. Basically, we make sure that if the guy asked for FILE_OPEN and it
   works then he does not get FILE_SUPERCEDED or FILE_CREATED as the result.

Arguments:

    RxContext - the context for the operation so as to find the place where info is returned

Return Value:

    none

Notes:



--*/
{
    ULONG q = RxContext->Create.ReturnedCreateInformation;
    if ((q==FILE_SUPERSEDED)||(q==FILE_CREATED)) {
        RxContext->Create.ReturnedCreateInformation = FILE_OPENED;
    }
}




NTSTATUS
MRxSmbBuildOpenAndX (
    PSMBSTUFFER_BUFFER_STATE StufferState,
    PMRXSMB_CREATE_PARAMETERS smbcp
    )
/*++

Routine Description:

   This builds an NtCreateAndX SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;
    PSMB_EXCHANGE Exchange = StufferState->Exchange;
    RxCaptureFcb;

    PUNICODE_STRING RemainingName;
    PMRX_SRV_OPEN SrvOpen = RxContext->Create.pSrvOpen;
    USHORT smbDisposition;
    USHORT smbSharingMode;
    USHORT smbAttributes;
    ULONG smbFileSize;
    USHORT smbOpenMode;
    USHORT OpenAndXFlags = SMB_OPEN_QUERY_INFORMATION;
    USHORT SearchAttributes = SMB_FILE_ATTRIBUTE_DIRECTORY | SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN;
    LARGE_INTEGER CurrentTime;
    ULONG SecondsSince1970;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildOpenAndX\n", 0 ));

    smbDisposition = MRxSmbMapDisposition(cp->Disposition);
    smbSharingMode = MRxSmbMapShareAccess(((USHORT)cp->ShareAccess));
    smbAttributes = MRxSmbMapFileAttributes(cp->FileAttributes);
    smbFileSize = cp->AllocationSize.LowPart;
    smbOpenMode = MRxSmbMapDesiredAccess(cp->DesiredAccess);

    smbSharingMode |= smbOpenMode;

    if (cp->CreateOptions & FILE_WRITE_THROUGH) {
        smbSharingMode |= SMB_DA_WRITE_THROUGH;
    }

    //lanman10 servers apparently don't like to get the time passed in.......
    if (FlagOn(Exchange->SmbCeContext.pServerEntry->Server.DialectFlags,DF_LANMAN20)) {

        KeQuerySystemTime(&CurrentTime);
        MRxSmbTimeToSecondsSince1970(&CurrentTime,
                                     MRxSmbExchangeToServer(StufferState->Exchange),
                                     &SecondsSince1970);
    } else {
        SecondsSince1970 = 0;
    }


    RemainingName = &(capFcb->AlreadyPrefixedName);

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_Never,
                                SMB_COM_OPEN_ANDX, SMB_REQUEST_SIZE(OPEN_ANDX),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(4,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbStuffSMB (StufferState,
         "XwwwwdwDddB",
                                    //  X         UCHAR WordCount;                    // Count of parameter words = 15
                                    //  .         UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
                                    //  .         UCHAR AndXReserved;                 // Reserved (must be 0)
                                    //  .         _USHORT( AndXOffset );              // Offset to next command WordCount
             OpenAndXFlags,         //  w         _USHORT( Flags );                   // Additional information: bit set-
                                    //                                                //  0 - return additional info
                                    //                                                //  1 - set single user total file lock
                                    //                                                //  2 - server notifies consumer of
                                    //                                                //      actions which may change file
             smbSharingMode,        //  w         _USHORT( DesiredAccess );           // File open mode
             SearchAttributes,      //  w         _USHORT( SearchAttributes );
             smbAttributes,         //  w         _USHORT( FileAttributes );
             SecondsSince1970,      //  d         _ULONG( CreationTimeInSeconds );
             smbDisposition,        //  w         _USHORT( OpenFunction );
                                    //  D         _ULONG( AllocationSize );           // Bytes to reserve on create or truncate
             SMB_OFFSET_CHECK(OPEN_ANDX,AllocationSize)
             smbFileSize,
             0xffffffff,            //  d         _ULONG( Timeout );                  // Max milliseconds to wait for resource
             0,                     //  d         _ULONG( Reserved );                 // Reserved (must be 0)
             SMB_WCT_CHECK(15) 0    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 1
                                    //            UCHAR Buffer[1];                    // File name
             );

    //proceed with the stuff because we know here that the name fits

    MRxSmbStuffSMB (StufferState,"z!", RemainingName);

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}

NTSTATUS
MRxSmbBuildOpenPrintFile (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds an OpenPrintFile SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    //RxCaptureFcb;

    PMRX_SRV_OPEN SrvOpen = RxContext->Create.pSrvOpen;
    WCHAR UserNameBuffer[UNLEN + 1];
    WCHAR UserDomainNameBuffer[UNLEN + 1];

    UNICODE_STRING UserName,UserDomainName;

    //UNICODE_STRING IdString;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbOpenPrintFile\n", 0 ));
    //ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    UserName.Length = UserName.MaximumLength = UNLEN * sizeof(WCHAR);
    UserName.Buffer = UserNameBuffer;
    UserDomainName.Length = UserDomainName.MaximumLength = UNLEN * sizeof(WCHAR);
    UserDomainName.Buffer = UserDomainNameBuffer;

    Status = SmbCeGetUserNameAndDomainName(
                   StufferState->Exchange->SmbCeContext.pSessionEntry,
                   &UserName,
                   &UserDomainName);

    if (Status != STATUS_SUCCESS) {
        RtlInitUnicodeString(&UserName,L"RDR2ID");
    } else {
        RtlUpcaseUnicodeString(&UserName,&UserName,FALSE);
    }

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_Never,
                                SMB_COM_OPEN_PRINT_FILE, SMB_REQUEST_SIZE(OPEN_PRINT_FILE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(4,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );
    MRxSmbSetFullProcessId(RxContext,((PNT_SMB_HEADER)StufferState->BufferBase));

    // note that we hardwire graphics..........
    MRxSmbStuffSMB (StufferState,
         "0wwB4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
             0,                     //  w         _USHORT( SetupLength );             // Length of printer setup data
             1,                     //  w         _USHORT( Mode );                    // 0 = Text mode (DOS expands TABs)
                                    //                                                // 1 = Graphics mode
             SMB_WCT_CHECK(2)       //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
             &UserName              //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR IdentifierString[];         //  Identifier string
             );

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}

NTSTATUS
SmbPseExchangeStart_Create(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for net root construction exchanges. This initiates the
    construction of the appropriate SMB's if required.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_NOT_IMPLEMENTED);
    NTSTATUS SetupStatus = STATUS_SUCCESS;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    RxCaptureFcb;

    PMRX_SRV_OPEN SrvOpen = RxContext->Create.pSrvOpen;

    PBOOLEAN MustRegainExclusiveResource = &OrdinaryExchange->Create.MustRegainExclusiveResource;
    BOOLEAN CreateWithEasSidsOrLongName = OrdinaryExchange->Create.CreateWithEasSidsOrLongName;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Create\n", 0 ));

    ASSERT_ORDINARY_EXCHANGE(OrdinaryExchange);

    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0)); //'FC'));

    *MustRegainExclusiveResource = TRUE;

    if (StufferState->PreviousCommand != SMB_COM_NO_ANDX_COMMAND) {
        // we have a latent session setup /tree connect command
        //the status of the embedded header commands is passed back in the flags
        SetupStatus = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                             SMBPSE_OETYPE_LATENT_HEADEROPS
                                             );
        MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0)); //'FC'));
    }

    if(SetupStatus != STATUS_SUCCESS) {
        Status = SetupStatus;
        goto FINALLY;
    }



    Status = MRxSmbDownlevelCreate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);

FINALLY:
    if (*MustRegainExclusiveResource) {
       RxAcquireExclusiveFcb( RxContext, capFcb );
    }

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Create exit w %08lx\n", Status ));
    return Status;
}

VOID
MRxSmbSetSrvOpenFlags (
    PRX_CONTEXT  RxContext,
    RX_FILE_TYPE StorageType,
    PMRX_SRV_OPEN SrvOpen,
    PMRX_SMB_SRV_OPEN smbSrvOpen
    )
{
    PMRX_SRV_CALL SrvCall = (PMRX_SRV_CALL)RxContext->Create.pSrvCall;
    BOOLEAN IsLoopBack = FALSE;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    pServerEntry = SmbCeReferenceAssociatedServerEntry(SrvCall);
    ASSERT(pServerEntry != NULL);
    IsLoopBack = pServerEntry->Server.IsLoopBack;
    SmbCeDereferenceServerEntry(pServerEntry);

    RxDbgTrace( 0, Dbg, ("MRxSmbSetSrvOpenFlags      oplockstate =%08lx\n", smbSrvOpen->OplockLevel ));

    switch (smbSrvOpen->OplockLevel) {
    case SMB_OPLOCK_LEVEL_II:
       SrvOpen->BufferingFlags |= (FCB_STATE_READBUFFERING_ENABLED  |
                                   FCB_STATE_READCACHEING_ENABLED);
       break;
    case SMB_OPLOCK_LEVEL_EXCLUSIVE:
    case SMB_OPLOCK_LEVEL_BATCH:
        {
            SrvOpen->BufferingFlags |= (FCB_STATE_WRITECACHEING_ENABLED  |
                                        FCB_STATE_FILESIZECACHEING_ENABLED |
                                        FCB_STATE_FILETIMECACHEING_ENABLED |
                                        FCB_STATE_WRITEBUFFERING_ENABLED |
                                        FCB_STATE_LOCK_BUFFERING_ENABLED |
                                        FCB_STATE_READBUFFERING_ENABLED  |
                                        FCB_STATE_READCACHEING_ENABLED);

            if (StorageType == FileTypeFile) {
               SrvOpen->BufferingFlags |= FCB_STATE_COLLAPSING_ENABLED;
            }
        }
       break;
    default:
       ASSERT(!"Valid Oplock Level for Open");
    case SMB_OPLOCK_LEVEL_NONE:
       SrvOpen->BufferingFlags = 0;
    }

    SrvOpen->Flags |= MRxSmbInitialSrvOpenFlags;
// #define MRxSmbInitialSrvOpenFlags qweeeMRxSmbInitialSrvOpenFlags

    if (IsLoopBack) {
        SrvOpen->Flags |= SRVOPEN_FLAG_DONTUSE_WRITE_CACHEING;
    }
}



NTSTATUS
MRxSmbCreateFileSuccessTail (
    PRX_CONTEXT  RxContext,
    PBOOLEAN MustRegainExclusiveResource,
    RX_FILE_TYPE StorageType,
    SMB_FILE_ID Fid,
    ULONG ServerVersion,
    UCHAR OplockLevel,
    ULONG CreateAction,
    PSMBPSE_FILEINFO_BUNDLE FileInfo
    )
/*++

Routine Description:

    This routine finishes the initialization of the fcb and srvopen for a successful open.

Arguments:


Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    PMRX_SRV_OPEN SrvOpen = RxContext->Create.pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);

    FCB_INIT_PACKET InitPacket;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCreateFileSuccessTail\n", 0 ));
    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );

    if (*MustRegainExclusiveResource) {        //this is required because of oplock breaks
        RxAcquireExclusiveFcb( RxContext, capFcb );
        *MustRegainExclusiveResource = FALSE;
    }

    RxContext->pFobx = RxCreateNetFobx( RxContext, SrvOpen);
    ASSERT  ( RxIsFcbAcquiredExclusive ( capFcb )  );
    RxDbgTrace( 0, Dbg, ("Storagetype %08lx/Fid %08lx/Action %08lx\n", StorageType, Fid, CreateAction ));

    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    SrvOpen->Key = MRxIfsMakeSrvOpenKey(pNetRootEntry->NetRoot.TreeId,Fid);

    smbSrvOpen->Fid = Fid;         //success_tail
    smbSrvOpen->Version = ServerVersion;
    smbSrvOpen->OplockLevel = OplockLevel;

    RxContext->Create.ReturnedCreateInformation = CreateAction;


    if ( ((FileInfo->Standard.AllocationSize.HighPart == FileInfo->Standard.EndOfFile.HighPart)
                           && (FileInfo->Standard.AllocationSize.LowPart < FileInfo->Standard.EndOfFile.LowPart))
           || (FileInfo->Standard.AllocationSize.HighPart < FileInfo->Standard.EndOfFile.HighPart)
       ) {
        FileInfo->Standard.AllocationSize = FileInfo->Standard.EndOfFile;
    }

    RxFormInitPacket(
        InitPacket,
        &FileInfo->Basic.FileAttributes,
        &FileInfo->Standard.NumberOfLinks,
        &FileInfo->Basic.CreationTime,
        &FileInfo->Basic.LastAccessTime,
        &FileInfo->Basic.LastWriteTime,
        &FileInfo->Basic.ChangeTime,
        &FileInfo->Standard.AllocationSize,
        &FileInfo->Standard.EndOfFile,
        &FileInfo->Standard.EndOfFile);


    if (capFcb->OpenCount == 0) {
        RxFinishFcbInitialization( capFcb,
                                   RDBSS_STORAGE_NTC(StorageType),
                                   &InitPacket
                                 );

    } else {

        ASSERT( StorageType == 0 || NodeType(capFcb) ==  RDBSS_STORAGE_NTC(StorageType));

    }

    MRxSmbSetSrvOpenFlags(RxContext,StorageType,SrvOpen,smbSrvOpen);

    RxContext->pFobx->OffsetOfNextEaToReturn = 1;
    //transition happens later

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishCreateFile   returning %08lx, fcbstate =%08lx\n", Status, wrapperFcb->FcbState ));
    return Status;
}







//force_t2_open doesn't work on an NT server......sigh........

#define ForceT2Open FALSE



NTSTATUS
MRxSmbZeroExtend(
      IN PRX_CONTEXT pRxContext)
/*++

Routine Description:

   This routine extends the data stream of a file system object

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
MRxIfsTruncate(
      IN PRX_CONTEXT pRxContext)
/*++

Routine Description:

   This routine truncates the contents of a file system object

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   ASSERT(!"Found a truncate");
   return STATUS_NOT_IMPLEMENTED;
}

VOID
MRxSmbDeallocateSideBuffer(
    IN OUT PRX_CONTEXT    RxContext,
    IN OUT PMRX_SMB_FOBX  smbFobx,
    IN     PSZ            where
    );

NTSTATUS
MRxIfsCleanupFobx(
      IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine cleansup a file system object...normally a noop. unless it's a pipe in which case
   we do the close at cleanup time and mark the file as being not open.

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING RemainingName;
    RxCaptureFcb; RxCaptureFobx;

    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_FOBX     smbFobx    = MRxIfsGetFileObjectExtension(capFobx);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;
    BOOLEAN SearchHandleOpen = FALSE;

    PAGED_CODE();

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT ( NodeTypeIsFcb(capFcb) );

    RxDbgTrace(+1, Dbg, ("MRxSmbCleanup\n", 0 ));

    if (TypeOfOpen==RDBSS_NTC_STORAGE_TYPE_DIRECTORY) {
        SearchHandleOpen = BooleanFlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN);
        MRxSmbDeallocateSideBuffer(RxContext,smbFobx,"Cleanup");
        if (smbFobx->Enumeration.ResumeInfo!=NULL) {
            RxFreePool(smbFobx->Enumeration.ResumeInfo);
            smbFobx->Enumeration.ResumeInfo = NULL;
        }
    }

    if (FlagOn(capFcb->FcbState,FCB_STATE_ORPHANED)) {
       RxDbgTrace(-1, Dbg, ("File orphaned\n"));
       return (STATUS_SUCCESS);
    }

    if ((capFcb->pNetRoot->Type != NET_ROOT_PIPE) && !SearchHandleOpen) {
       RxDbgTrace(-1, Dbg, ("File not for closing at cleanup\n"));
       return (STATUS_SUCCESS);
    }

    OrdinaryExchange = SmbPseCreateOrdinaryExchange(RxContext,
                                                    SrvOpen->pVNetRoot,
                                                    SMBPSE_OE_FROM_CLEANUPFOBX,
                                                    SmbPseExchangeStart_Close
                                                    );
    if (OrdinaryExchange==NULL) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status != (STATUS_PENDING));
    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
    RxDbgTrace(-1, Dbg, ("MRxSmbCleanup  exit with status=%08lx\n", Status ));

    return(Status);

}

NTSTATUS
MRxIfsForcedClose(
      IN PMRX_SRV_OPEN pSrvOpen)
/*++

Routine Description:

   This routine closes a file system object

Arguments:

    pSrvOpen - the instance to be closed

Return Value:

    RXSTATUS - The return status for the operation

Notes:



--*/
{
   return STATUS_NOT_IMPLEMENTED;
}



//
//  The local debug trace level
//

#undef  Dbg
#define Dbg                              (DEBUG_TRACE_CLOSE)

NTSTATUS
MRxIfsCloseSrvOpen(
      IN     PRX_CONTEXT   RxContext
      )
/*++

Routine Description:

   This routine closes a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING RemainingName;

    RxCaptureFcb;
    RxCaptureFobx;

    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PMRX_SRV_OPEN         SrvOpen    = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_FOBX     smbFobx    = MRxIfsGetFileObjectExtension(capFobx);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;


    BOOLEAN NeedDelete;

    PAGED_CODE();

    ASSERT ( NodeTypeIsFcb(capFcb) );
    ASSERT ( SrvOpen->OpenCount == 0 );

    RxDbgTrace(+1, Dbg, ("MRxSmbClose\n", 0 ));

    if ((FlagOn(capFcb->FcbState,FCB_STATE_ORPHANED)) ||
        (capFcb->pNetRoot->Type == NET_ROOT_MAILSLOT) ||
        (capFcb->pNetRoot->Type == NET_ROOT_PIPE) ) {
       RxDbgTrace(-1, Dbg, ("File orphan or ipc\n"));
       return (STATUS_SUCCESS);
    }

    if ( FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_FILE_RENAMED)
         || FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_FILE_DELETED) ){
       RxDbgTrace(-1, Dbg, ("File already closed by ren/del\n"));
       return (STATUS_SUCCESS);
    }

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT((smbSrvOpen->Fid != 0xffff));

    NeedDelete = FlagOn(capFcb->FcbState,FCB_STATE_DELETE_ON_CLOSE) && (capFcb->OpenCount == 0);

    if ( FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)
               && !NeedDelete ){
       RxDbgTrace(-1, Dbg, ("File was not really open\n"));
       return STATUS_SUCCESS;
    }

    OrdinaryExchange = SmbPseCreateOrdinaryExchange(RxContext,
                                                    SrvOpen->pVNetRoot,
                                                    SMBPSE_OE_FROM_CLOSESRVCALL,
                                                    SmbPseExchangeStart_Close
                                                    );
    if (OrdinaryExchange==NULL) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return((STATUS_INSUFFICIENT_RESOURCES));
    }

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status != (STATUS_PENDING));

    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
    RxDbgTrace(-1, Dbg, ("MRxSmbClose  exit with status=%08lx\n", Status ));

    return(Status);

}


NTSTATUS
MRxIfsBuildClose (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a Close SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildClose\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse, SMB_COM_CLOSE,
                                SMB_REQUEST_SIZE(CLOSE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );


    MRxSmbStuffSMB (StufferState,
         "0wdB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 3
             smbSrvOpen->Fid,       //  w         _USHORT( Fid );                     // File handle
             0xffffffff,            //  d         _ULONG( LastWriteTimeInSeconds );   // Time of last write, low and high
             SMB_WCT_CHECK(3) 0     //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}



NTSTATUS
MRxIfsBuildFindClose (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a Close SMB. we don't have to worry about login id and such
   since that is done by the connection engine

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;RxCaptureFobx;
    PMRX_SMB_FOBX smbFobx = MRxIfsGetFileObjectExtension(capFobx);
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);


    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildFindClose\n", 0 ));

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse, SMB_COM_FIND_CLOSE2,
                                SMB_REQUEST_SIZE(FIND_CLOSE2),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );


    MRxSmbStuffSMB (StufferState,
         "0wB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 1
                                    //  w         _USHORT( Sid );                     // Find handle
             smbFobx->Enumeration.SearchHandle,
             SMB_WCT_CHECK(1) 0     //  B!        _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}

NTSTATUS
MRxSmbCoreDeleteForSupercedeOrClose(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    BOOLEAN DeleteDirectory
    );

NTSTATUS
SmbPseExchangeStart_Close(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for close.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;

    PMRX_SMB_FCB      smbFcb     = MRxIfsGetFcbExtension(capFcb);
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_FOBX     smbFobx    = MRxIfsGetFileObjectExtension(capFobx);
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Close\n", 0 ));

    ASSERT(OrdinaryExchange->Type == ORDINARY_EXCHANGE);

    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

    if(TypeOfOpen==RDBSS_NTC_STORAGE_TYPE_DIRECTORY){
        if (FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN)) {

            // we have a search handle open.....close it


            Status = MRxIfsBuildFindClose(StufferState);

            if (Status == STATUS_SUCCESS) {

                // Ensure that the searchhandle is valid

                if (smbFobx->Enumeration.Version == OrdinaryExchange->SmbCeContext.pServerEntry->Server.Version) {
                    NTSTATUS InnerStatus;
                    InnerStatus = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                                         SMBPSE_OETYPE_FINDCLOSE
                                                         );
                } else {
                   DbgPrint("HANDLE VERSION IN FINDCLOSE MISMATCH!!!!");
                }
            }

            // if this didn't work, there's nothing you can do............

            ClearFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN);
        }
    }

    if ((OrdinaryExchange->EntryPoint == SMBPSE_OE_FROM_CLEANUPFOBX)
            && (capFcb->pNetRoot->Type != NET_ROOT_PIPE) ) {
        RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Close exit after searchhandle close %08lx\n", Status ));
        return Status;
    }

    if ( !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN) ) {

        Status = MRxIfsBuildClose(StufferState);

        if (Status == STATUS_SUCCESS) {
            // Ensure that the Fid is validated
            SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);

            Status = SmbPseOrdinaryExchange(
                            SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                            SMBPSE_OETYPE_CLOSE
                            );
            // Ensure that the Fid validation is disabled
            ClearFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);
        }
        //even if it didn't work there's nothing i can do......keep going
        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN);
    }

    if ( (Status!=STATUS_SUCCESS)
                   || (capFcb->OpenCount > 0)
                   || !FlagOn(capFcb->FcbState,FCB_STATE_DELETE_ON_CLOSE)
                   || FlagOn((smbFcb)->MFlags,SMB_FCB_FLAG_SENT_DISPOSITION_INFO) ) {
        RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Close exit w %08lx\n", Status ));
        return Status;
    }

    RxDbgTrace(0, Dbg, ("SmbPseExchangeStart_Close delete on close\n" ));


    //no need for setinitsmb here because coredelete does a int-on-resuse.....
    OrdinaryExchange->pPathArgument1 = &capFcb->AlreadyPrefixedName;
    MRxSmbCoreDeleteForSupercedeOrClose(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                        ((BOOLEAN)( NodeType(capFcb)==RDBSS_NTC_STORAGE_TYPE_DIRECTORY ))
                                       );

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Close exit w %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbFinishClose (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_CLOSE                 Response
      )
/*++

Routine Description:

    This routine actually gets the stuff out of the Close response and finishes the close.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    RxCaptureFcb; RxCaptureFobx;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishClose(orClosePrintFile)\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishClose:");

    ASSERT( (Response->WordCount==0));
    ASSERT( (SmbGetUshort(&Response->ByteCount)==0));

    if (OrdinaryExchange->OEType == SMBPSE_OETYPE_CLOSE) {
        PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
        PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);
        smbSrvOpen->Fid = 0xffff;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishClose   returning %08lx\n", Status ));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\read.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module implements the mini redirector call down routines pertaining to read
    of file system objects.


Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

NTSTATUS
SmbPseExchangeStart_Read(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

ULONG MRxSmbSrvReadBufSize = 0xffff; //use the negotiated size
ULONG MRxSmbReadSendOptions = 0;     //use the default options

//
// External declartions
//




NTSTATUS
MRxIfsRead(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles network read requests.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING RemainingName;
    RxCaptureFcb; RxCaptureFobx;
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbRead\n", 0 ));

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    OrdinaryExchange = SmbPseCreateOrdinaryExchange(RxContext,
                                                    capFobx->pSrvOpen->pVNetRoot,
                                                    SMBPSE_OE_FROM_READ,
                                                    SmbPseExchangeStart_Read
                                                    );
    if (OrdinaryExchange==NULL) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    if (Status!=STATUS_PENDING) {
        BOOLEAN FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
        ASSERT(FinalizationComplete);
    } else {
        ASSERT(BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbRead  exit with status=%08lx\n", Status ));
    return(Status);

} // MRxSmbRead





NTSTATUS
MRxSmbBuildCoreRead (
    PSMBSTUFFER_BUFFER_STATE StufferState,
    PLARGE_INTEGER ByteOffsetAsLI,
    ULONG ByteCount,
    ULONG RemainingBytes
    )
/*++

Routine Description:

   This routine builds a CoreRead SMB. We don't have to worry about login id
   and such since that is done by the connection engine....pretty neat huh?
   All we have to do is to format up the bits.


Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   NTSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something in the arguments can't be handled.

Notes:



--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;RxCaptureFobx;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);
    ULONG OffsetLow,OffsetHigh;


    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildCoreRead\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    OffsetLow = ByteOffsetAsLI->LowPart;
    OffsetHigh = ByteOffsetAsLI->HighPart;
    ASSERT(OffsetHigh==0);

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_Never, SMB_COM_READ,
                            SMB_REQUEST_SIZE(READ),
                            NO_EXTRA_DATA,NO_SPECIAL_ALIGNMENT,RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                            0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );


    // below, we just set mincount==maxcount. rdr1 did this.......
    MRxSmbStuffSMB (StufferState,
         "0wwdwB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 5
              smbSrvOpen->Fid,      //  w         _USHORT( Fid );                     // File handle
              ByteCount,            //  w         _USHORT( Count );                   // Count of bytes being requested
              OffsetLow,            //  d         _ULONG( Offset );                   // Offset in file of first byte to read
              RemainingBytes,       //  w         _USHORT( Remaining );               // Estimate of bytes to read if nonzero
                                    //  B!        _USHORT( ByteCount );               // Count of data bytes = 0
              SMB_WCT_CHECK(5) 0
                                    //            UCHAR Buffer[1];                    // empty
             );


FINALLY:
    RxDbgTraceUnIndent(-1, Dbg);
    return(Status);

} // MRxSmbBuildCoreRead



NTSTATUS
SmbPseExchangeStart_Read(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for read.

Arguments:


Return Value:

    NTSTATUS - The return status for the operation

--*/
{

    NTSTATUS Status; //this is initialized to smbbufstatus on a reenter
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    ULONG StartEntryCount;

    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;

    PSMBCE_SERVER   pServer  = &OrdinaryExchange->SmbCeContext.pServerEntry->Server;
    PSMBCE_NET_ROOT pNetRoot = &OrdinaryExchange->SmbCeContext.pNetRootEntry->NetRoot;

    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    BOOLEAN  SynchronousIo =
               !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Read\n", 0 ));

    ASSERT( (OrdinaryExchange->SmbCeFlags&SMBCE_EXCHANGE_ATTEMPT_RECONNECTS) == 0 );

    ASSERT(OrdinaryExchange->Type == ORDINARY_EXCHANGE);

    OrdinaryExchange->StartEntryCount++;
    StartEntryCount = OrdinaryExchange->StartEntryCount;

    // Ensure that the Fid is validated
    SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);

    for (;;) {
        ULONG BytesReturned;


        //
        // Case on the ordinary exchagne current state
        //

        switch (OrdinaryExchange->OpSpecificState) {

        case SmbPseOEInnerIoStates_Initial:
            OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;

            //
            // If not a synchronous read, then continue here when resumed
            //

            if (!SynchronousIo) {
                OrdinaryExchange->Continuation = SmbPseExchangeStart_Read;
            }

            MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

            rw->MaximumSmbBufferSize = pNetRoot->MaximumReadBufferSize;
            rw->UserBufferBase = RxLowIoGetBufferAddress(RxContext);
            rw->ByteOffsetAsLI.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
            rw->RemainingByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;
            rw->ThisBufferOffset = 0;
            rw->PartialBytes = 0;

            //lack of break is intentional

        case SmbPseOEInnerIoStates_ReadyToSend:
            OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_OperationOutstanding;
            ClearFlag(OrdinaryExchange->OpSpecificFlags,OE_READ_FLAG_SUCCESS_IN_COPYHANDLER);
            OrdinaryExchange->SendOptions = MRxSmbReadSendOptions;

            rw->ThisByteCount = min(rw->RemainingByteCount, rw->MaximumSmbBufferSize);



            Status =  MRxSmbBuildCoreRead(StufferState,
                                           &rw->ByteOffsetAsLI,
                                           rw->ThisByteCount,
                                           rw->RemainingByteCount);


            if (Status != STATUS_SUCCESS) {
                RxDbgTrace(0, Dbg, ("bad read stuffer status........\n"));
                goto FINALLY;
            }

            if (FALSE && FlagOn(LowIoContext->ParamsFor.ReadWrite.Flags,LOWIO_READWRITEFLAG_PAGING_IO)) {
                RxLog(("PagingIoRead: rxc/offset/length %lx/%lx/%lx",RxContext,
                                               &rw->ByteOffsetAsLI,
                                               rw->ThisByteCount
                     ));
            }

            InterlockedIncrement(&MRxIfsStatistics.ReadSmbs);
            Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                            SMBPSE_OETYPE_READ
                                            );

            //
            // If the status is PENDING, then we're done for now. We must
            // wait until we're re-entered when the receive happens.
            //

            if (Status==STATUS_PENDING) {
                ASSERT(!SynchronousIo);
                goto FINALLY;
            }

            //lack of break is intentional

        case SmbPseOEInnerIoStates_OperationOutstanding:
            OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;
            rw->RemainingByteCount -=  rw->BytesReturned;
            RxContext->InformationToReturn += rw->BytesReturned;
            Status = OrdinaryExchange->SmbStatus;

            if (NT_ERROR(Status)
                || rw->BytesReturned < rw->ThisByteCount
                || (rw->RemainingByteCount==0) ) {

                goto FINALLY;
            }

            if (Status != STATUS_SUCCESS) {
                //reset the smbstatus.....
                OrdinaryExchange->SmbStatus = STATUS_SUCCESS;
            }

            rw->ByteOffsetAsLI.QuadPart += rw->BytesReturned;
            rw->ThisBufferOffset += rw->BytesReturned;
            rw->BytesReturned = 0;

            MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));
            break;
        }
    }

FINALLY:

    if ( Status != STATUS_PENDING ) {
        SmbPseAsyncCompletionIfNecessary(OrdinaryExchange,RxContext);
    }

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Read exit w %08lx\n", Status ));
    return Status;
} // SmbPseExchangeStart_Read


NTSTATUS
MRxSmbFinishNoCopyRead (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
      )
{
    //DbgBreakPoint();
    if(FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_SMBBUF_IS_A_MDL)){
        MmPrepareMdlForReuse((PMDL)(OrdinaryExchange->AssociatedStufferState.BufferBase));
        ClearFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_SMBBUF_IS_A_MDL);
    }
    return(OrdinaryExchange->NoCopyFinalStatus);
}

UCHAR
MRxSmbReadHandler_NoCopy (
    IN OUT  PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    OUT ULONG       *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pDataBufferPointer,
    OUT PULONG      pDataSize,
#if DBG
    IN  UCHAR       ThisIsAReenter,
#endif
    IN  PRESP_READ_ANDX       Response
      )
/*++

Routine Description:

    This routine causes the bytes from the message to be transferred to the user's buffer. In order to do this,
    it takes enough bytes from the indication and then crafts up an MDL to cause the transport to do the copy.

Arguments:

  please refer to smbpse.c...the only place from which this may be called

Return Value:

    UCHAR - a value representing the action that OE receive routine will perform. options are
            discard (in case of an error), copy_for_resume (never called after this is all debugged), and normal

--*/
{
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PMDL OriginalDataMdl = LowIoContext->ParamsFor.ReadWrite.Buffer;
    PBYTE Buffer;
    ULONG BytesReturned,DataOffset;
    PMDL ReadMdl;

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishReadNoCopy\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishReadNoCopy:");

    Buffer = rw->UserBufferBase + rw->ThisBufferOffset;

    switch (OrdinaryExchange->LastSmbCommand) {
    case SMB_COM_READ_ANDX:
        ASSERT( (Response->WordCount==12));
        BytesReturned = SmbGetUshort(&Response->DataLength);
        DataOffset =  SmbGetUshort(&Response->DataOffset);
        break;
    case SMB_COM_READ:{
        PRESP_READ CoreResponse = (PRESP_READ)Response; //recast response for core read
        ASSERT( (CoreResponse->WordCount==5));
        BytesReturned = SmbGetUshort(&CoreResponse->DataLength);
        DataOffset =  sizeof(SMB_HEADER)+FIELD_OFFSET(RESP_READ,Buffer[0]);
        }break;
    }


    if ( BytesReturned > rw->ThisByteCount ) {
        //cut back if we got a bad response
        BytesReturned = rw->ThisByteCount;
    }

    RxDbgTrace(0, Dbg, ("-->ByteCount,Offset,Returned,DOffset,Buffer=%08lx/%08lx/%08lx/%08lx/%08lx\n",
                rw->ThisByteCount,
                rw->ThisBufferOffset,
                BytesReturned,DataOffset,Buffer
               ));

    OrdinaryExchange->FinishRoutine = MRxSmbFinishNoCopyRead;
    OrdinaryExchange->ReadWrite.BytesReturned =  BytesReturned;

    //
    // now, move the data to the user's buffer
    //

    //
    // If enough is showing, just copy it in.
    //

    if (BytesIndicated >= DataOffset+BytesReturned) {
        RtlCopyMemory(Buffer,
                      ((PBYTE)pSmbHeader)+DataOffset,
                      BytesReturned
                     );

        *pBytesTaken  = DataOffset+BytesReturned;

        RxDbgTrace(-1, Dbg, ("MRxSmbFinishReadNoCopy  copy fork\n" ));
        return(SMBPSE_NOCOPYACTION_NORMALFINISH);
    }

    //
    // otherwise, MDL it in.  we use the smbbuf as an Mdl!

    ASSERT(BytesIndicated>=DataOffset);

    ReadMdl = (PMDL)(StufferState->BufferBase);
    MmInitializeMdl(ReadMdl, 0, PAGE_SIZE+BytesReturned); //-1 ??
    IoBuildPartialMdl( OriginalDataMdl,
                       ReadMdl,
                       (PCHAR)MmGetMdlVirtualAddress(OriginalDataMdl) + rw->ThisBufferOffset,
                       BytesReturned );

    *pDataBufferPointer = ReadMdl;
    *pDataSize    = BytesReturned;
    *pBytesTaken  = DataOffset;

    SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_SMBBUF_IS_A_MDL);

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishReadNoCopy   mdlcopy fork \n" ));
    return(SMBPSE_NOCOPYACTION_MDLFINISH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\sessetup.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    sessetup.c

Abstract:

    This module implements the Session setup related routines


--*/

#include "precomp.h"
#pragma hdrstop


#include "ntlsapi.h"

#define IsCredentialHandleValid(pCredHandle)    \
        (((pCredHandle)->dwLower != 0xffffffff) && ((pCredHandle)->dwUpper != 0xffffffff))

#define IsSecurityContextHandleValid(pContextHandle)    \
        (((pContextHandle)->dwLower != 0xffffffff) && ((pContextHandle)->dwUpper != 0xffffffff))


NTSTATUS
BuildSessionSetupSmb(
            PSMB_EXCHANGE pExchange,
            PGENERIC_ANDX  pAndXSmb,
            PULONG         pAndXSmbBufferSize)
/*++

Routine Description:

   This routine builds the session setup SMB for a NT server

Arguments:

    pServer - the server instance

    pSession - the SMBCE session instance

    pAndXSmb - the session setup to be filled in

    pAndXSmbBufferSize - the SMB buffer size on input modified to remaining size on
                         output.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    Eventhough the general structure of the code tries to isolate dialect specific issues
    as much as possible this routine takes the opposite approach. This is because of the
    preamble and prologue to security interaction which far outweigh the dialect specific
    work required to be done. Therefore in the interests of a smaller footprint this approach
    has been adopted.

--*/
{
   NTSTATUS Status;

   PSMBCE_SERVER  pServer  = &pExchange->SmbCeContext.pServerEntry->Server;
   PSMBCE_SESSION pSession = &pExchange->SmbCeContext.pSessionEntry->Session;

   PREQ_SESSION_SETUP_ANDX pSessionSetup = (PREQ_SESSION_SETUP_ANDX)pAndXSmb;
   PREQ_NT_SESSION_SETUP_ANDX pNtSessionSetup = (PREQ_NT_SESSION_SETUP_ANDX)pSessionSetup;

   ULONG OriginalBufferSize = *pAndXSmbBufferSize;

   pSessionSetup->AndXCommand = 0xff;   // No ANDX
   pSessionSetup->AndXReserved = 0x00;  // Reserved (MBZ)

   SmbPutUshort(&pSessionSetup->AndXOffset, 0x0000); // No AndX as of yet.

   //  Since we can allocate pool dynamically, we set our buffer size
   //  to match that of the server.
   SmbPutUshort(&pSessionSetup->MaxBufferSize, (USHORT)pServer->MaximumBufferSize);
   SmbPutUshort(&pSessionSetup->MaxMpxCount, pServer->MaximumRequests);

   SmbPutUshort(&pSessionSetup->VcNumber, 0);

   SmbPutUlong(&pSessionSetup->SessionKey, pServer->SessionKey);
   SmbPutUlong(&pSessionSetup->Reserved, 0);

   if (pServer->Dialect == NTLANMAN_DIALECT) {
      // Set up the NT server session setup specific parameters.

      SmbPutUshort(&pNtSessionSetup->WordCount,13);

      // Set the capabilities
      SmbPutUlong(&pNtSessionSetup->Capabilities,
                  (CAP_NT_STATUS |
                   CAP_UNICODE |
                   CAP_LEVEL_II_OPLOCKS |
                   CAP_NT_SMBS ));
   } else {
      SmbPutUshort(&pSessionSetup->WordCount,10);
   }

   // Build the security information in the session setup SMB.
   Status = BuildSessionSetupSecurityInformation(
                        pExchange,
                        (PBYTE)pSessionSetup,
                        pAndXSmbBufferSize);
   if (NT_SUCCESS(Status)) {
      // Copy the operating system name and the LANMAN version info
      // position the buffer for copying the operating system name and the lanman type.
      PBYTE pBuffer = (PBYTE)pSessionSetup + OriginalBufferSize - *pAndXSmbBufferSize;

      if (FlagOn(pServer->DialectFlags,DF_UNICODE)){

         Status = SmbPutUnicodeString(
                       &pBuffer,
                       &SmbCeContext.OperatingSystem,
                       pAndXSmbBufferSize);

         if (NT_SUCCESS(Status)) {
            Status = SmbPutUnicodeString(
                          &pBuffer,
                          &SmbCeContext.LanmanType,
                          pAndXSmbBufferSize);

         }
      } else {
         Status = SmbPutUnicodeStringAsOemString(
                       &pBuffer,
                       &SmbCeContext.OperatingSystem,
                       pAndXSmbBufferSize);

         if (NT_SUCCESS(Status)) {
            Status = SmbPutUnicodeStringAsOemString(
                          &pBuffer,
                          &SmbCeContext.LanmanType,
                          pAndXSmbBufferSize);

         }
      }

      if (NT_SUCCESS(Status) &&
          (pServer->Dialect == NTLANMAN_DIALECT) ) {
               SmbPutUshort(
                     &pNtSessionSetup->ByteCount,
                     (USHORT)(OriginalBufferSize -
                      FIELD_OFFSET(REQ_NT_SESSION_SETUP_ANDX,Buffer) -
                      *pAndXSmbBufferSize));
      } else {
               SmbPutUshort(
                     &pSessionSetup->ByteCount,
                     (USHORT)(OriginalBufferSize -
                      FIELD_OFFSET(REQ_SESSION_SETUP_ANDX,Buffer) -
                      *pAndXSmbBufferSize));
      }
   }

   return Status;
}

NTSTATUS
BuildSessionSetupSecurityInformation(
            PSMB_EXCHANGE pExchange,
            PBYTE           pSmbBuffer,
            PULONG          pSmbBufferSize)
/*++

Routine Description:

   This routine builds the security related information for the session setup SMB

Arguments:

    pServer  - the server instance

    pLogonId - the logon id. for which the session is being setup

    pPassword - the user  supplied password if any

    pSmbBuffer - the SMB buffer

    pSmbBufferSize - the size of the buffer on input ( modified to size remaining on
                     output)

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    Eventhough the genral structure of the code tries to isolate dialect specific issues
    as much as possible this routine takes the opposite approach. This is because of the
    preamble and prologue to security interaction which far outweigh the dialect specific
    work required to be done. Therefore in the interests of a smaller footprint this approach
    has been adopted.

--*/
{
   NTSTATUS Status;
   BOOLEAN  fProcessAttached = FALSE;

   UNICODE_STRING UserName;
   UNICODE_STRING DomainName;

   STRING CaseSensitiveResponse;
   STRING CaseInsensitiveResponse;

   PSMBCE_SERVER  pServer  = &pExchange->SmbCeContext.pServerEntry->Server;
   PSMBCE_SESSION pSession = &pExchange->SmbCeContext.pSessionEntry->Session;

   SECURITY_RESPONSE_CONTEXT ResponseContext;

   PAGED_CODE();
   RxDbgTrace( +1, Dbg, ("BuildSessionSetupSecurityInformation -- Entry\n"));

   //  Attach to the redirector's FSP to allow us to call into the security impl.
   if (PsGetCurrentProcess() != RxGetRDBSSProcess()) {
       KeAttachProcess(RxGetRDBSSProcess());

       fProcessAttached = TRUE;
   }

   Status = BuildNtLanmanResponsePrologue(
                     pExchange,
                     &UserName,
                     &DomainName,
                     &CaseSensitiveResponse,
                     &CaseInsensitiveResponse,
                     &ResponseContext);

   if (NT_SUCCESS(Status)) {
      PBYTE    pBuffer    = pSmbBuffer;
      ULONG    BufferSize = *pSmbBufferSize;

      if (pServer->Dialect == NTLANMAN_DIALECT) {
         PREQ_NT_SESSION_SETUP_ANDX pNtSessionSetupReq = (PREQ_NT_SESSION_SETUP_ANDX)pSmbBuffer;

         // It it is a NT server both the case insensitive and case sensitive passwords
         // need to be copied. for share-level, just copy a token 1-byte NULL password

         // Position the buffer for copying the password.
         pBuffer += FIELD_OFFSET(REQ_NT_SESSION_SETUP_ANDX,Buffer);
         BufferSize -= FIELD_OFFSET(REQ_NT_SESSION_SETUP_ANDX,Buffer);

         if (pServer->SecurityMode == SECURITY_MODE_USER_LEVEL){

             RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- NtUserPasswords\n"));

             SmbPutUshort(&pNtSessionSetupReq->CaseInsensitivePasswordLength,
                          CaseInsensitiveResponse.Length);

             SmbPutUshort(&pNtSessionSetupReq->CaseSensitivePasswordLength,
                          CaseSensitiveResponse.Length);

             Status = SmbPutString(
                                   &pBuffer,
                                   &CaseInsensitiveResponse,
                                   &BufferSize);

             if (NT_SUCCESS(Status)) {
                Status = SmbPutString(
                                      &pBuffer,
                                      &CaseSensitiveResponse,
                                      &BufferSize);
             }
         } else {

             RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- NtSharePasswords\n"));

             SmbPutUshort(&pNtSessionSetupReq->CaseInsensitivePasswordLength, 1);
             SmbPutUshort(&pNtSessionSetupReq->CaseSensitivePasswordLength, 1);
             *pBuffer = 0;
             *(pBuffer+1) = 0;
             pBuffer += 2;
             BufferSize -= 2;

         }

      } else {
         PREQ_SESSION_SETUP_ANDX pSessionSetupReq = (PREQ_SESSION_SETUP_ANDX)pSmbBuffer;

         // Position the buffer for copying the password.
         pBuffer += FIELD_OFFSET(REQ_SESSION_SETUP_ANDX,Buffer);
         BufferSize -= FIELD_OFFSET(REQ_SESSION_SETUP_ANDX,Buffer);

         if (pServer->SecurityMode == SECURITY_MODE_USER_LEVEL) {
            // For othe lanman servers only the case sensitive password is required.
            SmbPutUshort(&pSessionSetupReq->PasswordLength,
                         CaseInsensitiveResponse.Length);

            // Copy the password
            Status = SmbPutString(
                           &pBuffer,
                           &CaseInsensitiveResponse,
                           &BufferSize);
         } else {
            // Share level security. Send a null string for the password
            SmbPutUshort(&pSessionSetupReq->PasswordLength,1);
            *pBuffer++ = '\0';
            BufferSize -= sizeof(CHAR);
         }
      }

      // The User name and the domain name strings can be either copied from
      // the information returned in the request response or the information
      // that is already present in the session entry.
      if (NT_SUCCESS(Status)) {
         if ((pServer->Dialect == NTLANMAN_DIALECT) &&
             (pServer->NtServer.NtCapabilities & CAP_UNICODE)) {
            // Copy the account/domain names as UNICODE strings
            PBYTE pTempBuffer = pBuffer;

            RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- account/domain as unicode\n"));
            pBuffer = ALIGN_SMB_WSTR(pBuffer);
            BufferSize -= (pBuffer - pTempBuffer);

            Status = SmbPutUnicodeString(
                              &pBuffer,
                              &UserName,
                              &BufferSize);

            if (NT_SUCCESS(Status)) {
               Status = SmbPutUnicodeString(
                                 &pBuffer,
                                 &DomainName,
                                 &BufferSize);

            }
         } else {
            // Copy the account/domain names as ASCII strings.
            RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- account/domain as ascii\n"));
            Status = SmbPutUnicodeStringAsOemString(
                           &pBuffer,
                           &UserName,
                           &BufferSize);

            if (NT_SUCCESS(Status)) {
               Status = SmbPutUnicodeStringAsOemString(
                              &pBuffer,
                              &DomainName,
                              &BufferSize);
            }
         }
      }

      if (NT_SUCCESS(Status)) {
         *pSmbBufferSize = BufferSize;
      }
   }

   // Free the buffer allocated by the security package.
   BuildNtLanmanResponseEpilogue(&ResponseContext);

   // Detach from the rdr process.
   if (fProcessAttached) {
      KeDetachProcess();
   }

   RxDbgTrace( -1, Dbg, ("BuildSessionSetupSecurityInformation -- Exit, status=%08lx\n",Status));
   return Status;
}
NTSTATUS
BuildTreeConnectSecurityInformation(
            PSMB_EXCHANGE  pExchange,
            PBYTE          pBuffer,
            PBYTE          pPasswordLength,
            PULONG         pSmbBufferSize)
/*++

Routine Description:

   This routine builds the security related information for the session setup SMB

Arguments:

    pServer  - the server instance

    pLogonId - the logon id. for which the session is being setup

    pPassword - the user  supplied password if any

    pBuffer - the password buffer

    pPasswordLength - where the password length is to be stored

    pSmbBufferSize - the size of the buffer on input ( modified to size remaining on
                     output)

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    Eventhough the genral structure of the code tries to isolate dialect specific issues
    as much as possible this routine takes the opposite approach. This is because of the
    preamble and prologue to security interaction which far outweigh the dialect specific
    work required to be done. Therefore in the interests of a smaller footprint this approach
    has been adopted.

--*/
{
   NTSTATUS FinalStatus,Status;
   BOOLEAN  fProcessAttached = FALSE;

   UNICODE_STRING UserName,DomainName;
   STRING         CaseSensitiveChallengeResponse,CaseInsensitiveChallengeResponse;

   SECURITY_RESPONSE_CONTEXT ResponseContext;

   ULONG PasswordLength = 0;

   PSMBCE_SERVER  pServer  = &pExchange->SmbCeContext.pServerEntry->Server;
   PSMBCE_SESSION pSession = &pExchange->SmbCeContext.pSessionEntry->Session;


   PAGED_CODE();

   Status = STATUS_SUCCESS;

   if (pServer->EncryptPasswords) {
      //  Attach to the redirector's FSP to allow us to call into the securiy impl.
      if (PsGetCurrentProcess() != RxGetRDBSSProcess()) {
          KeAttachProcess(RxGetRDBSSProcess());
          fProcessAttached = TRUE;
      }

      Status = BuildNtLanmanResponsePrologue(
                        pExchange,
                        &UserName,
                        &DomainName,
                        &CaseSensitiveChallengeResponse,
                        &CaseInsensitiveChallengeResponse,
                        &ResponseContext);

      if (NT_SUCCESS(Status)) {
          if (FlagOn(pServer->DialectFlags,DF_MIXEDCASEPW)) {
             RxDbgTrace( 0, Dbg, ("BuildTreeConnectSecurityInformation -- case sensitive password\n"));
             // Copy the password length onto the SMB buffer
             PasswordLength = CaseSensitiveChallengeResponse.Length;

             // Copy the password
             Status = SmbPutString(&pBuffer,
                                   &CaseSensitiveChallengeResponse,
                                   pSmbBufferSize);
          } else {
             RxDbgTrace( 0, Dbg, ("BuildTreeConnectSecurityInformation -- case insensitive password\n"));
             // Copy the password length onto the SMB buffer
             PasswordLength = CaseInsensitiveChallengeResponse.Length;

             // Copy the password
             Status = SmbPutString(&pBuffer,
                                   &CaseInsensitiveChallengeResponse,
                                   pSmbBufferSize);
          }

          BuildNtLanmanResponseEpilogue(&ResponseContext);
      }

      if (fProcessAttached) {
         KeDetachProcess();
      }
   } else {
      if (pSession->pPassword == NULL) {
         // The logon password cannot be sent as plain text. Send a single blank as password.

         PasswordLength = 2;
         if (*pSmbBufferSize >= 2) {
            *((PCHAR)pBuffer) = ' ';
            pBuffer += sizeof(CHAR);
            *((PCHAR)pBuffer) = '\0';
            pBuffer += sizeof(CHAR);
            Status = STATUS_SUCCESS;
         } else {
            Status = STATUS_BUFFER_OVERFLOW;
         }
      } else {
         OEM_STRING OemString;

         OemString.Length = OemString.MaximumLength = (USHORT)(*pSmbBufferSize - sizeof(CHAR));
         OemString.Buffer = pBuffer;
         Status = RtlUnicodeStringToOemString(
                             &OemString,
                             pSession->pPassword,
                             FALSE);

         if (NT_SUCCESS(Status)) {
            PasswordLength = OemString.Length+1;
         }
      }

      // reduce the byte count
      *pSmbBufferSize -= PasswordLength;
   }

   SmbPutUshort(pPasswordLength,(USHORT)PasswordLength);

   return Status;
}

NTSTATUS
BuildNtLanmanResponsePrologue(
   PSMB_EXCHANGE              pExchange,
   PUNICODE_STRING            pUserName,
   PUNICODE_STRING            pDomainName,
   PSTRING                    pCaseSensitiveResponse,
   PSTRING                    pCaseInsensitiveResponse,
   PSECURITY_RESPONSE_CONTEXT pResponseContext)
/*++

Routine Description:

   This routine builds the security related information for the session setup SMB to
   a NT server

Arguments:


Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
   NTSTATUS       Status;
   NTSTATUS       FinalStatus;

   UNICODE_STRING ServerName;

   PVOID           pTargetInformation;
   ULONG           TargetInformationSize;

   SecBufferDesc   InputToken;
   SecBuffer       InputBuffer[2];
   SecBufferDesc   *pOutputBufferDescriptor = NULL;
   SecBuffer       *pOutputBuffer           = NULL;
   ULONG           OutputBufferDescriptorSize;

   ULONG LsaFlags = ISC_REQ_ALLOCATE_MEMORY;
   TimeStamp Expiry;
   PCHALLENGE_MESSAGE InToken = NULL;
   ULONG InTokenSize;
   PNTLM_CHALLENGE_MESSAGE NtlmInToken = NULL;
   ULONG NtlmInTokenSize = 0;
   PAUTHENTICATE_MESSAGE OutToken = NULL;
   PNTLM_INITIALIZE_RESPONSE NtlmOutToken = NULL;
   PUCHAR          p = NULL;
   ULONG           AllocateSize;

   PSMBCE_SERVER  pServer  = &pExchange->SmbCeContext.pServerEntry->Server;
   PSMBCE_SESSION pSession = &pExchange->SmbCeContext.pSessionEntry->Session;


   try {
      pResponseContext->LanmanSetup.pOutputContextBuffer = NULL;

      SmbCeGetServerName(pExchange->SmbCeContext.pVNetRoot->pNetRoot->pSrvCall,&ServerName);

      TargetInformationSize = ServerName.Length;
      pTargetInformation    = ServerName.Buffer;

      InTokenSize = sizeof(CHALLENGE_MESSAGE) + TargetInformationSize;

      NtlmInTokenSize = sizeof(NTLM_CHALLENGE_MESSAGE);

      if (pSession->pPassword != NULL) {
         NtlmInTokenSize += pSession->pPassword->Length;
         LsaFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
      }

      if (pSession->pUserName != NULL) {
         NtlmInTokenSize += pSession->pUserName->Length;
         LsaFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
      }

      if (pSession->pUserDomainName != NULL) {
         NtlmInTokenSize += pSession->pUserDomainName->Length;
      }

      // For Alignment purposes, we want InTokenSize rounded up to
      // the nearest word size.

      AllocateSize = ((InTokenSize + 3) & ~3) + NtlmInTokenSize;

      ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());
      Status = ZwAllocateVirtualMemory(
                      NtCurrentProcess(),
                      &InToken,
                      0L,
                      &AllocateSize,
                      MEM_COMMIT,
                      PAGE_READWRITE);


      if (!NT_SUCCESS(Status)) {
         try_return(Status);
      }

      // Allocate the output buffer
      OutputBufferDescriptorSize = sizeof(SecBufferDesc) + 2 * sizeof(SecBuffer);

      ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());
      Status = ZwAllocateVirtualMemory(
                      NtCurrentProcess(),
                      &pOutputBufferDescriptor,
                      0L,
                      &OutputBufferDescriptorSize,
                      MEM_COMMIT,
                      PAGE_READWRITE);


      if (!NT_SUCCESS(Status)) {
         try_return(Status);
      }

      pOutputBuffer = (SecBuffer *)(pOutputBufferDescriptor + 1);
      pResponseContext->LanmanSetup.pOutputContextBuffer = pOutputBufferDescriptor;

      RxDbgTrace(0,Dbg,("Allocate VM %08lx in process %8lx\n", InToken, NtCurrentProcess()));

      // partition off the NTLM in token part of the
      // buffer
      if (LsaFlags & ISC_REQ_USE_SUPPLIED_CREDS)
      {
          NtlmInToken = (PNTLM_CHALLENGE_MESSAGE) ((PUCHAR) InToken + InTokenSize);
          NtlmInToken = (PNTLM_CHALLENGE_MESSAGE) (((ULONG) NtlmInToken + 3) & ~3);
          RtlZeroMemory(NtlmInToken,NtlmInTokenSize);
          p = (PUCHAR) NtlmInToken + sizeof(NTLM_CHALLENGE_MESSAGE);
      }

      if(!IsCredentialHandleValid(&pSession->CredentialHandle)) {
         UNICODE_STRING LMName;
         TimeStamp LifeTime;

         LMName.Buffer = (PWSTR) InToken;
         LMName.Length = NTLMSP_NAME_SIZE;
         LMName.MaximumLength = LMName.Length;
         RtlCopyMemory(LMName.Buffer, NTLMSP_NAME, NTLMSP_NAME_SIZE);

         Status = AcquireCredentialsHandleW(
                                  NULL,
                                  &LMName,
                                  SECPKG_CRED_OUTBOUND,
                                  &pSession->LogonId,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &pSession->CredentialHandle,
                                  &LifeTime);
         if(!NT_SUCCESS(Status)) {
            try_return(Status);
         }
      }

      // Copy in the pass,user,domain if they were specified
      if(pSession->pPassword != NULL) {
         NtlmInToken->Password.Buffer = (PWSTR) p;
         NtlmInToken->Password.Length = pSession->pPassword->Length;
         NtlmInToken->Password.MaximumLength = pSession->pPassword->Length;
         RtlCopyMemory(NtlmInToken->Password.Buffer,
                       pSession->pPassword->Buffer,
                       pSession->pPassword->Length);
         NtlmInToken->Password.Buffer = (PWSTR) (p - (PUCHAR)NtlmInToken);
         p += pSession->pPassword->Length;
      }

      if(pSession->pUserName != NULL) {
         NtlmInToken->UserName.Buffer = (PWSTR) p;
         NtlmInToken->UserName.Length = pSession->pUserName->Length;
         NtlmInToken->UserName.MaximumLength = pSession->pUserName->Length;
         RtlCopyMemory(NtlmInToken->UserName.Buffer,
                       pSession->pUserName->Buffer,
                       pSession->pUserName->Length);
         NtlmInToken->UserName.Buffer = (PWSTR) (p - (PUCHAR)NtlmInToken);
         p += pSession->pUserName->Length;
      }

      if (pSession->pUserDomainName != NULL) {
         NtlmInToken->DomainName.Buffer = (PWSTR) p;
         NtlmInToken->DomainName.Length = pSession->pUserDomainName->Length;
         NtlmInToken->DomainName.MaximumLength = pSession->pUserDomainName->Length;
         RtlCopyMemory(NtlmInToken->DomainName.Buffer,
                       pSession->pUserDomainName->Buffer,
                       pSession->pUserDomainName->Length);
         NtlmInToken->DomainName.Buffer = (PWSTR) (p - (PUCHAR)NtlmInToken);
         p += pSession->pUserDomainName->Length;

      }

      RtlCopyMemory(InToken->Signature,NTLMSSP_SIGNATURE,sizeof(NTLMSSP_SIGNATURE));
      InToken->MessageType = NtLmChallenge;

      InToken->NegotiateFlags = NTLMSSP_NEGOTIATE_UNICODE |
                                NTLMSSP_NEGOTIATE_OEM |
                                NTLMSSP_REQUEST_INIT_RESPONSE |
                                NTLMSSP_TARGET_TYPE_SERVER;

      RtlCopyMemory(InToken->Challenge,
                    pServer->EncryptionKey,
                    MSV1_0_CHALLENGE_LENGTH);

      InToken->TargetName.Length =
      InToken->TargetName.MaximumLength = (USHORT)TargetInformationSize;
      InToken->TargetName.Buffer = (PCHAR)InToken + sizeof(CHALLENGE_MESSAGE);

      RtlCopyMemory(InToken->TargetName.Buffer,
                    pTargetInformation,
                    TargetInformationSize);

      InputToken.pBuffers = InputBuffer;
      InputToken.cBuffers = 1;
      InputToken.ulVersion = 0;
      InputBuffer[0].pvBuffer = InToken;
      InputBuffer[0].cbBuffer = InTokenSize;
      InputBuffer[0].BufferType = SECBUFFER_TOKEN;

      if (LsaFlags & ISC_REQ_USE_SUPPLIED_CREDS)
      {
          InputToken.cBuffers = 2;
          InputBuffer[1].pvBuffer = NtlmInToken;
          InputBuffer[1].cbBuffer = NtlmInTokenSize;
          InputBuffer[1].BufferType = SECBUFFER_TOKEN;
      }

      pOutputBufferDescriptor->pBuffers = pOutputBuffer;
      pOutputBufferDescriptor->cBuffers = 2;
      pOutputBufferDescriptor->ulVersion = 0;
      pOutputBuffer[0].pvBuffer = NULL;
      pOutputBuffer[0].cbBuffer = 0;
      pOutputBuffer[0].BufferType = SECBUFFER_TOKEN;
      pOutputBuffer[1].pvBuffer = NULL;
      pOutputBuffer[1].cbBuffer = 0;
      pOutputBuffer[1].BufferType = SECBUFFER_TOKEN;

      Status = InitializeSecurityContextW(&pSession->CredentialHandle,
                                         (PCtxtHandle)NULL,
                                         NULL,
                                         LsaFlags,
                                         0,
                                         SECURITY_NATIVE_DREP,
                                         &InputToken,
                                         0,
                                         &pSession->SecurityContextHandle,
                                         pOutputBufferDescriptor,
                                         &FinalStatus,
                                         &Expiry);

      if(!NT_SUCCESS(Status) && (Status != SEC_I_CONTINUE_NEEDED)) {
         Status = MapSecurityError(Status);
         DbgPrint("Initialize Security Context returned %lx\n",Status);
         try_return(Status);
      }

      OutToken = (PAUTHENTICATE_MESSAGE) pOutputBuffer[0].pvBuffer;

      ASSERT(OutToken != NULL);
      RxDbgTrace(0,Dbg,("InitSecCtxt OutToken is %8lx\n", OutToken));

      // The security response the pointers are encoded in terms off the offset
      // from the beginning of the buffer. Make the appropriate adjustments.

      if (ARGUMENT_PRESENT(pCaseSensitiveResponse)) {
         pCaseSensitiveResponse->Length        = OutToken->NtChallengeResponse.Length;
         pCaseSensitiveResponse->MaximumLength = OutToken->NtChallengeResponse.MaximumLength;
         pCaseSensitiveResponse->Buffer = (PBYTE)OutToken + (ULONG)OutToken->NtChallengeResponse.Buffer;
      }

      if (ARGUMENT_PRESENT(pCaseInsensitiveResponse)) {
         pCaseInsensitiveResponse->Length        = OutToken->LmChallengeResponse.Length;
         pCaseInsensitiveResponse->MaximumLength = OutToken->LmChallengeResponse.MaximumLength;
         pCaseInsensitiveResponse->Buffer = (PBYTE)OutToken + (ULONG)OutToken->LmChallengeResponse.Buffer;
      }

      if (pSession->pUserDomainName != NULL) {
         *pDomainName = *(pSession->pUserDomainName);
      } else {
         pDomainName->Length        = OutToken->DomainName.Length;
         pDomainName->MaximumLength = pDomainName->Length;
         pDomainName->Buffer = (PWCHAR)((PBYTE)OutToken + (ULONG)OutToken->DomainName.Buffer);
      }

      if (pSession->pUserName != NULL) {
         *pUserName = *(pSession->pUserName);
      } else {
         pUserName->Length        = OutToken->UserName.Length;
         pUserName->MaximumLength = OutToken->UserName.MaximumLength;
         pUserName->Buffer = (PWCHAR)((PBYTE)OutToken + (ULONG)OutToken->UserName.Buffer);
      }

      NtlmOutToken = pOutputBuffer[1].pvBuffer;
      if (NtlmOutToken != NULL) {
          RtlCopyMemory(pSession->UserSessionKey, NtlmOutToken->UserSessionKey, MSV1_0_USER_SESSION_KEY_LENGTH);
          RtlCopyMemory(pSession->LanmanSessionKey, NtlmOutToken->LanmanSessionKey, MSV1_0_LANMAN_SESSION_KEY_LENGTH);
      }

try_exit:NOTHING;
   } finally {
      if (InToken != NULL) {
         NTSTATUS TemporaryStatus;

         TemporaryStatus = ZwFreeVirtualMemory(
                                    NtCurrentProcess(),
                                    &InToken,
                                    &AllocateSize,
                                    MEM_RELEASE);

         ASSERT (NT_SUCCESS(TemporaryStatus));
      }

      if (!NT_SUCCESS(Status)) {
         BuildNtLanmanResponseEpilogue(pResponseContext);
      }
   }

   return Status;
}




NTSTATUS
BuildNtLanmanResponseEpilogue(
   PSECURITY_RESPONSE_CONTEXT pResponseContext)
{
   if (pResponseContext->LanmanSetup.pOutputContextBuffer != NULL) {
      ULONG i = 0;
      SecBufferDesc *pBufferDescriptor = (SecBufferDesc *)pResponseContext->LanmanSetup.pOutputContextBuffer;
      SecBuffer     *pBuffer = pBufferDescriptor->pBuffers;

      for (i = 0; i < pBufferDescriptor->cBuffers; i++) {
         if (pBuffer[i].pvBuffer != NULL) {
            FreeContextBuffer(pBuffer[i].pvBuffer);
         }
      }
   }

   pResponseContext->LanmanSetup.pOutputContextBuffer = NULL;

   return STATUS_SUCCESS;
}


VOID
UninitializeSecurityContextsForSession(PSMBCE_SESSION pSession)
{
   BOOLEAN   fProcessAttached = FALSE;

   if (IsCredentialHandleValid(&pSession->CredentialHandle)) {
      FreeCredentialsHandle(&pSession->CredentialHandle);
   }

   if (IsSecurityContextHandleValid(&pSession->SecurityContextHandle)) {
      if (PsGetCurrentProcess() != RxGetRDBSSProcess()) {
          KeAttachProcess(RxGetRDBSSProcess());
          fProcessAttached = TRUE;
      }

      DeleteSecurityContext(&pSession->SecurityContextHandle);
   }

   if (fProcessAttached) {
      KeDetachProcess();
   }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\smbcedb.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbcedb.h

Abstract:

    This module defines all functions, along with implementations for inline functions
    related to accessing the SMB connection engine

Notes:

    The various data structures created by the mini rdr (Server Entries, Session Entries
    and Net Root Entries) are used in asynchronous operations. Hence a reference count
    mechanism is used to keep track of the creation/use/destruction of these data structures.

    The usage patterns for these data structures falls into one of two cases

      1) A prior reference exists and access is required

      2) A new reference need be created.

    These two scenarios are dealt with by two sets of access routines
      SmbCeGetAssociatedServerEntry,
      SmbCeGetAssociatedSessionEntry,
      SmbCeGetAssociatedNetRootEntry
    and
      SmbCeReferenceAssociatedServerEntry,
      SmbCeReferenceAssociatedSessionEntry,
      SmbCeReferenceAssociatedNetRootEntry.

    The first set of routines include the necessary asserts in a debug build to ensure that a
    reference does exist.

    The dereferencing mechanism is provided by the following routines
      SmbCeDereferenceServerEntry,
      SmbCeDereferenceSessionEntry,
      SmbCeDereferenceNetRootEntry.

    The dereferencing routines also ensure that the data structures are deleted if the reference
    count is zero.

    The construction of the various SMB mini redirector structures ( Server,Session and Net root entries )
    follow a two phase protocol since network traffic is involved. The first set of routines
    initiate the construction while the second set of routines complete the construction.

    These routines are
      SmbCeInitializeServerEntry,
      SmbCeCompleteServerEntryInitialization,
      SmbCeInitializeSessionEntry,
      SmbCeCompleteSessionEntryInitialization,
      SmbCeInitializeNetRootEntry,
    and SmbCeCompleteNetRootEntryInitialization.

    Each of the SMB mini redirector data structures  embodies a state diagram that consist of
    the following states

      SMBCEDB_ACTIVE,                    // the instance is in use
      SMBCEDB_INVALID,                   // the instance has been invalidated/disconnected.
      SMBCEDB_MARKED_FOR_DELETION,       // the instance has been marked for deletion.
      SMBCEDB_RECYCLE,                   // the instance is available for recycling
      SMBCEDB_START_CONSTRUCTION,        // Initiate construction.
      SMBCEDB_CONSTRUCTION_IN_PROGRESS,  // the instance construction is in progress
      SMBCEDB_DESTRUCTION_IN_PROGRESS    // the instance destruction is in progress

    A SMB MRX data structure instance begins its life in SMBCEDB_START_CONSTRUCTION state.
    When the construction is initiated the state transitions to SMBCEDB_CONSTRUCTION_IN_PROGRESS.

    On completion of the construction the state is either transitioned to SMBCEDB_ACTIVE if the
    construction was successful. If the construction was not successful the state transitions to
    SMBCEDB_MARKED_FOR_DELETION if scavenging is to be done or SMBCEDB_DESTRUCTION_IN_PROGRESS
    if the tear down has been initiated.

    An instance in the SMBCEDB_ACTIVE state transitions to SMBCEDB_INVALID when the transport/remote server
    information associated with it has been invalidated due to disconnects etc. This state is a
    cue for a reconnect attempt to be initiated.

    The SMBCEDB_RECYCLE state is not in use currently.

    All the state transitions are accomplished by the following set of routines which ensure that
    the appropriate concurrency control action is taken.

         SmbCeUpdateServerEntryState,
         SmbCeUpdateSessionEntryState,
    and  SmbCeUpdateNetRootEntryState.

    Since the Server,Session and NetRoot entries are often referenced together the following
    two routines provide a batching mechanism to minimize the concurrency control overhead.

      SmbCeReferenceAssociatedEntries,
      SmbCeDereferenceEntries

    In addition this file also contains helper functions to access certain fields of
    MRX_SRV_CALL,MRX_NET_ROOT and MRX_V_NET_ROOT which are intrepreted differently by the SMB
    mini redirector.

--*/

#ifndef _SMBCEDB_H_
#define _SMBCEDB_H_

#include <smbcedbp.h>    // To accomodate inline routines.


//
// All the Open routines return the referenced object if successful. It is the caller's
// responsibility to dereference them subsequently.
//

extern NTSTATUS
SmbCeInitializeServerEntry(
      PMRX_SRV_CALL                 pSrvCall,
      PMRX_SRVCALL_CALLBACK_CONTEXT pCallbackContext);

extern NTSTATUS
SmbCeInitializeSessionEntry(
      PMRX_V_NET_ROOT pVirtualNetRoot);

extern NTSTATUS
SmbCeInitializeNetRootEntry(
      PMRX_NET_ROOT  pNetRoot);

//
// The finalization routines are invoked in the context of a worker thread to finalize
// the construction of an entry as well as resume other entries waiting for it.
//

extern VOID
SmbCeCompleteServerEntryInitialization(PVOID  pServerEntry);

extern VOID
SmbCeCompleteSessionEntryInitialization(PVOID  pSessionEntry);

extern VOID
SmbCeCompleteNetRootEntryInitialization(PVOID  pNetRootEntry);


//
// Routines for referencing/dereferencing SMB Mini redirector information associated with
// the wrapper data structures.
//

INLINE PSMBCEDB_SERVER_ENTRY
SmbCeGetAssociatedServerEntry(PMRX_SRV_CALL pSrvCall)
{
   ASSERT(pSrvCall->Context != NULL);
   return (PSMBCEDB_SERVER_ENTRY)(pSrvCall->Context);
}

INLINE PSMBCEDB_SESSION_ENTRY
SmbCeGetAssociatedSessionEntry(PMRX_V_NET_ROOT pVNetRoot)
{
   ASSERT(pVNetRoot->Context != NULL);
   return (PSMBCEDB_SESSION_ENTRY)(pVNetRoot->Context);
}

INLINE PSMBCEDB_NET_ROOT_ENTRY
SmbCeGetAssociatedNetRootEntry(PMRX_NET_ROOT pNetRoot)
{
   ASSERT(pNetRoot->Context != NULL);
   return (PSMBCEDB_NET_ROOT_ENTRY)(pNetRoot->Context);
}

//
// All the macros for referencing and dereferencing begin with a prefix SmbCep...
// The p stands for a private version which is used for implementing reference tracking.
// By selectively turning on the desired flag it is possible to track every instance
// of a given type as the reference count is modified.
//

#define MRXSMB_REF_TRACE_SERVER_ENTRY   (0x00000001)
#define MRXSMB_REF_TRACE_NETROOT_ENTRY  (0x00000002)
#define MRXSMB_REF_TRACE_SESSION_ENTRY  (0x00000004)

extern ULONG MRxSmbReferenceTracingValue;

#define MRXSMB_REF_TRACING_ON(TraceMask)  (TraceMask & MRxSmbReferenceTracingValue)
#define MRXSMB_PRINT_REF_COUNT(TYPE,Count)                                \
        if (MRXSMB_REF_TRACING_ON( MRXSMB_REF_TRACE_ ## TYPE )) {              \
           DbgPrint("%ld\n",Count);                                \
        }

INLINE VOID
SmbCepReferenceServerEntry(PSMBCEDB_SERVER_ENTRY pServerEntry)
{
   ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);
   InterlockedIncrement(&pServerEntry->Header.SwizzleCount);
   MRXSMB_PRINT_REF_COUNT(SERVER_ENTRY,pServerEntry->Header.SwizzleCount)
}

INLINE VOID
SmbCepReferenceSessionEntry(PSMBCEDB_SESSION_ENTRY pSessionEntry)
{
   ASSERT(pSessionEntry->Header.ObjectType == SMBCEDB_OT_SESSION);
   InterlockedIncrement(&(pSessionEntry->Header.SwizzleCount));
   MRXSMB_PRINT_REF_COUNT(SESSION_ENTRY,pSessionEntry->Header.SwizzleCount)
}

INLINE VOID
SmbCepReferenceNetRootEntry(PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry)
{
   ASSERT(pNetRootEntry->Header.ObjectType == SMBCEDB_OT_NETROOT);
   InterlockedIncrement(&(pNetRootEntry->Header.SwizzleCount));
   MRXSMB_PRINT_REF_COUNT(NETROOT_ENTRY,pNetRootEntry->Header.SwizzleCount)
}


INLINE PSMBCEDB_SERVER_ENTRY
SmbCeReferenceAssociatedServerEntry(PMRX_SRV_CALL pSrvCall)
{
   PSMBCEDB_SERVER_ENTRY pServerEntry;

   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_SERVER_ENTRY)) {
      DbgPrint("Reference SrvCall's(%lx) Server Entry %lx %s %ld ",
      pSrvCall,pSrvCall->Context,__FILE__,__LINE__);                                                          \
   }

   if ((pServerEntry = pSrvCall->Context) != NULL) {
      ASSERT(pServerEntry->Header.SwizzleCount > 0);
      SmbCepReferenceServerEntry(pServerEntry);
   }

   return pServerEntry;
}

INLINE PSMBCEDB_SESSION_ENTRY
SmbCeReferenceAssociatedSessionEntry(PMRX_V_NET_ROOT pVNetRoot)
{
   PSMBCEDB_SESSION_ENTRY pSessionEntry;

   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_SESSION_ENTRY)) {
      DbgPrint("Reference VNetRoot's(%lx) Session Entry %lx %s %ld ",
      pVNetRoot,pVNetRoot->Context,__FILE__,__LINE__);                                                          \
   }

   if ((pSessionEntry = pVNetRoot->Context) != NULL) {
      ASSERT(pSessionEntry->Header.SwizzleCount > 0);
      SmbCepReferenceSessionEntry(pSessionEntry);
   }

   return pSessionEntry;
}

INLINE PSMBCEDB_NET_ROOT_ENTRY
SmbCeReferenceAssociatedNetRootEntry(PMRX_NET_ROOT pNetRoot)
{
   PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_NETROOT_ENTRY)) {
      DbgPrint("Reference NetRoot's(%lx) Net Root Entry %lx %s %ld ",
      pNetRoot,pNetRoot->Context,__FILE__,__LINE__);                                                      \
   }

   if ((pNetRootEntry = pNetRoot->Context) != NULL) {
      ASSERT(pNetRootEntry->Header.SwizzleCount > 0);
      SmbCepReferenceNetRootEntry(pNetRootEntry);
   }

   return pNetRootEntry;
}

extern VOID
SmbCepDereferenceServerEntry(PSMBCEDB_SERVER_ENTRY pServerEntry);

extern VOID
SmbCepDereferenceSessionEntry(PSMBCEDB_SESSION_ENTRY pSessionEntry);

extern VOID
SmbCepDereferenceNetRootEntry(PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry);

#define SmbCeReferenceServerEntry(pServerEntry)                                     \
   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_SERVER_ENTRY)) {                      \
      DbgPrint("Reference Server Entry(%lx) %s %ld ",pServerEntry,__FILE__,__LINE__);    \
   }                                                                                \
   SmbCepReferenceServerEntry(pServerEntry)

#define SmbCeReferenceNetRootEntry(pNetRootEntry)                                     \
   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_NETROOT_ENTRY)) {                      \
      DbgPrint("Reference NetRoot Entry(%lx) %s %ld ",pNetRootEntry,__FILE__,__LINE__);    \
   }                                                                                \
   SmbCepReferenceNetRootEntry(pNetRootEntry)

#define SmbCeReferenceSessionEntry(pSessionEntry)                                     \
   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_SESSION_ENTRY)) {                      \
      DbgPrint("Reference Session Entry(%lx) %s %ld ",pSessionEntry,__FILE__,__LINE__);    \
   }                                                                                \
   SmbCepReferenceSessionEntry(pSessionEntry)

#define SmbCeDereferenceServerEntry(pServerEntry)                                     \
   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_SERVER_ENTRY)) {                      \
      DbgPrint("Dereference Server Entry(%lx) %s %ld ",pServerEntry,__FILE__,__LINE__);    \
   }                                                                                \
   SmbCepDereferenceServerEntry(pServerEntry)

#define SmbCeDereferenceNetRootEntry(pNetRootEntry)                                     \
   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_NETROOT_ENTRY)) {                      \
      DbgPrint("Dereference NetRoot Entry(%lx) %s %ld ",pNetRootEntry,__FILE__,__LINE__);    \
   }                                                                                \
   SmbCepDereferenceNetRootEntry(pNetRootEntry)

#define SmbCeDereferenceSessionEntry(pSessionEntry)                                     \
   if (MRXSMB_REF_TRACING_ON(MRXSMB_REF_TRACE_SESSION_ENTRY)) {                      \
      DbgPrint("Dereference Session Entry(%lx) %s %ld ",pSessionEntry,__FILE__,__LINE__);    \
   }                                                                                \
   SmbCepDereferenceSessionEntry(pSessionEntry)

INLINE NTSTATUS
SmbCeReferenceAssociatedEntries(
   PMRX_V_NET_ROOT         pVNetRoot,
   PSMBCEDB_SERVER_ENTRY   *pServerEntryPtr,
   PSMBCEDB_SESSION_ENTRY  *pSessionEntryPtr,
   PSMBCEDB_NET_ROOT_ENTRY *pNetRootEntryPtr)
{
   ASSERT((pServerEntryPtr != NULL) &&
          (pSessionEntryPtr != NULL) &&
          (pNetRootEntryPtr != NULL));

   *pServerEntryPtr  = SmbCeReferenceAssociatedServerEntry(pVNetRoot->pNetRoot->pSrvCall);
   *pNetRootEntryPtr = SmbCeReferenceAssociatedNetRootEntry(pVNetRoot->pNetRoot);
   *pSessionEntryPtr = SmbCeReferenceAssociatedSessionEntry(pVNetRoot);

   if ((*pServerEntryPtr != NULL) &&
       (*pSessionEntryPtr != NULL) &&
       (*pNetRootEntryPtr != NULL)) {
      return STATUS_SUCCESS;
   } else {
      return STATUS_UNSUCCESSFUL;
   }
}

INLINE VOID
SmbCeDereferenceEntries(
   PSMBCEDB_SERVER_ENTRY   pServerEntry,
   PSMBCEDB_SESSION_ENTRY  pSessionEntry,
   PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry)
{
   SmbCeDereferenceNetRootEntry(pNetRootEntry);
   SmbCeDereferenceSessionEntry(pSessionEntry);
   SmbCeDereferenceServerEntry(pServerEntry);
}

//
// Routines for updating the state of SMB MRX data structures
//

#define SmbCeUpdateServerEntryState(pServerEntry,NEWSTATE)   \
        SmbCeAcquireSpinLock();                              \
        (pServerEntry)->Header.State = (NEWSTATE);           \
        SmbCeReleaseSpinLock()


#define SmbCeUpdateSessionEntryState(pSessionEntry,NEWSTATE)  \
        SmbCeAcquireSpinLock();                               \
        (pSessionEntry)->Header.State = (NEWSTATE);           \
        SmbCeReleaseSpinLock()


#define SmbCeUpdateNetRootEntryState(pNetRootEntry,NEWSTATE)   \
        SmbCeAcquireSpinLock();                                \
        (pNetRootEntry)->Header.State = (NEWSTATE);            \
        SmbCeReleaseSpinLock()


//
// The RDBSS wrapper stores all the server names with a backslash prepended to
// them. This helps synthesize UNC names easily. In order to manipulate the
// Server name in the SMB protocol the \ needs to be stripped off.

INLINE VOID
SmbCeGetServerName(PMRX_SRV_CALL pSrvCall, PUNICODE_STRING pServerName)
{
   ASSERT(pSrvCall->pSrvCallName != NULL);
   pServerName->Buffer        = pSrvCall->pSrvCallName->Buffer + 1;
   pServerName->Length        = pSrvCall->pSrvCallName->Length - sizeof(WCHAR);
   pServerName->MaximumLength = pServerName->Length;
}

INLINE VOID
SmbCeGetNetRootName(PMRX_NET_ROOT pNetRoot, PUNICODE_STRING pNetRootName)
{
   ASSERT(pNetRoot->pNetRootName != NULL);
   *pNetRootName  = *pNetRoot->pNetRootName;
}

extern NTSTATUS
SmbCeGetUserNameAndDomainName(
   PSMBCEDB_SESSION_ENTRY  pSessionEntry,
   PUNICODE_STRING         pUserName,
   PUNICODE_STRING         pUserDomainName);

#endif // _SMBCEDB_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\rename.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rename.c

Abstract:

    This module implements rename in the smb minirdr.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)

NTSTATUS
SmbPseExchangeStart_Rename(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );
NTSTATUS
SmbPseExchangeStart_SetDeleteDisposition(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );



MRxIfsRename(
      IN PRX_CONTEXT            RxContext,
      IN FILE_INFORMATION_CLASS FileInformationClass,
      IN PVOID                  pBuffer,
      IN ULONG                  BufferLength)
/*++

Routine Description:

   This routine does a rename. since the real NT-->NT path is not implemented at the server end,
   we implement just the downlevel path.

   //The NT-->NT path works by just remoting the call basically without further ado.

   the downlevel path works by
     1) purge and remove buffering rights....setup the FCB so that no more stuff can get thru.
     2) closing its fid along with any deferred fids.
     3) do a downlevel smb_com_rename.

   there are many provisos but i think that this is the best balance. it is a real shame that the
   NT-->NT path was never implemented in 3.51 or before.

Arguments:

    RxContext - the RDBSS context
    FILE_INFO_CLASS - must be rename....shouldn't really pass this
    pBuffer - pointer to the new name
    bufferlength - and the size

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING RemainingName;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();


    RxDbgTrace(0, Dbg, ("MRxSmbRename\n", 0 ));

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( FileInformationClass == FileRenameInformation); //later we'll do downlevel delete here as well

    OrdinaryExchange = SmbPseCreateOrdinaryExchange(RxContext,
                                                    capFobx->pSrvOpen->pVNetRoot,
                                                    SMBPSE_OE_FROM_RENAME,
                                                    SmbPseExchangeStart_Rename
                                                    );
    if (OrdinaryExchange==NULL) {
        RxDbgTrace(0, Dbg, ("Couldn't get the smb buf!\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    OrdinaryExchange->Info.Buffer = pBuffer;
    OrdinaryExchange->Info.pBufferLength = &BufferLength;    //this means we must be synchronous!

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status != STATUS_PENDING);

    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);

    RxDbgTrace(0, Dbg, ("MRxSmbRename  exit with status=%08lx\n", Status ));
    return(Status);

}


NTSTATUS
MRxSmbBuildRename (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a Rename SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   NTSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;
    NTSTATUS StufferStatus;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)StufferState->Exchange;

    PFILE_RENAME_INFORMATION RenameInformation = OrdinaryExchange->Info.Buffer;
    UNICODE_STRING RenameName;
    USHORT SearchAttributes = SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN | SMB_FILE_ATTRIBUTE_DIRECTORY;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildRename\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    RenameName.Buffer = &RenameInformation->FileName[0];
    RenameName.Length = (USHORT)RenameInformation->FileNameLength;

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse, SMB_COM_RENAME,
                                SMB_REQUEST_SIZE(RENAME),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                );


    MRxSmbStuffSMB (StufferState,
         "0wB",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 1
             SearchAttributes,      //  w         _USHORT( SearchAttributes );
             SMB_WCT_CHECK(1) 0     //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // Buffer containing:
                                    //            //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                    //            //UCHAR OldFileName[];              //  Old file name
                                    //            //UCHAR BufferFormat2;              //  0x04 -- ASCII
                                    //            //UCHAR NewFileName[];              //  New file name
             );

    Status = MRxSmbStuffSMB (StufferState,
                                    "44!", &capFcb->AlreadyPrefixedName, &RenameName );


FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}

NTSTATUS
SmbPseExchangeStart_Rename(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for rename and downlevel delete.

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_FOBX smbFobx = MRxIfsGetFileObjectExtension(capFobx);
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PSMBCE_SERVER pServer = &OrdinaryExchange->SmbCeContext.pServerEntry->Server;
    ULONG SmbLength;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Rename\n", 0 ));

    ASSERT(OrdinaryExchange->Type == ORDINARY_EXCHANGE);
    ASSERT(!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));

    //first we have to close the fid....if it's a directory, we close the search handle as well

    MRxSmbSetInitialSMB( StufferState STUFFERTRACE(Dbg,'FC') );
    ASSERT (StufferState->CurrentCommand == SMB_COM_NO_ANDX_COMMAND);

    if( (TypeOfOpen==RDBSS_NTC_STORAGE_TYPE_DIRECTORY)
            &&  FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN)  ){
        // we have a search handle open.....close it
        NTSTATUS Status2 = MRxIfsBuildFindClose(StufferState);

        if (Status2 == STATUS_SUCCESS) {
            Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                            SMBPSE_OETYPE_FINDCLOSE
                                            );
        }

        ClearFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN);
        if (smbFobx->Enumeration.ResumeInfo!=NULL) {
            RxFreePool(smbFobx->Enumeration.ResumeInfo);
        }
    }


    COVERED_CALL(MRxIfsBuildClose(StufferState));


    SetFlag(SrvOpen->Flags,SRVOPEN_FLAG_FILE_RENAMED);
    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CLOSE
                                    );
    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

    COVERED_CALL(MRxSmbBuildRename(StufferState));
    SmbLength = StufferState->CurrentPosition - StufferState->BufferBase;
    if ( (Status == STATUS_BUFFER_OVERFLOW)
                 || (SmbLength>pServer->MaximumBufferSize) ){
        RxDbgTrace(-1, Dbg, ("MRxSmbRename - name too long\n", 0 ));
        return(STATUS_OBJECT_NAME_INVALID);
    }

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_RENAME
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Rename exit w %08lx\n", Status ));
    return Status;
}


extern UNICODE_STRING MRxSmbAll8dot3Files;

NTSTATUS
MRxSmbBuildCheckEmptyDirectory (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a FindFirst SMB.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   NTSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;

    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb; RxCaptureFobx;

    PMRX_SMB_FOBX smbFobx = MRxIfsGetFileObjectExtension(capFobx);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)StufferState->Exchange;
    ULONG ResumeKeyLength = 0;

    UNICODE_STRING FindFirstPattern;

    // SearchAttributes is hardcoded to the magic number 0x16
    ULONG SearchAttributes =
            (SMB_FILE_ATTRIBUTE_DIRECTORY
                | SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN);

    RxDbgTrace(+1, Dbg, ("MRxSmbBuildCheckEmptyDirectory \n"));

    if (OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey == NULL) {
        PUNICODE_STRING DirectoryName = &capFcb->AlreadyPrefixedName;
        PUNICODE_STRING Template = &MRxSmbAll8dot3Files;
        ULONG DirectoryNameLength,TemplateLength,AllocationLength;
        PBYTE SmbFileName;

        //the stuffer cannot handle the intricate logic here so we
        //will have to preallocate for the name

        DirectoryNameLength = DirectoryName->Length;
        TemplateLength = Template->Length;
        AllocationLength = sizeof(WCHAR)  // backslash separator
                            +DirectoryNameLength
                            +TemplateLength;
        RxDbgTrace(0, Dbg, ("  --> d/t/dl/tl/al <%wZ><%wZ>%08lx/%08lx/%08lx!\n",
                      DirectoryName,Template,
                      DirectoryNameLength,TemplateLength,AllocationLength));

        FindFirstPattern.Buffer = (PWCHAR)RxAllocatePoolWithTag( PagedPool,AllocationLength,'0SxR');
        if (FindFirstPattern.Buffer==NULL) {
            RxDbgTrace(0, Dbg, ("  --> Couldn't get the findfind pattern buffer!\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            DbgBreakPoint();
            goto FINALLY;
        }

        SmbFileName = (PBYTE)FindFirstPattern.Buffer;
        RtlCopyMemory(SmbFileName,DirectoryName->Buffer,DirectoryNameLength);
        SmbFileName += DirectoryNameLength;
        if (*((PWCHAR)(SmbFileName-sizeof(WCHAR))) != L'\\') {
            *((PWCHAR)SmbFileName) = L'\\'; SmbFileName+= sizeof(WCHAR);
        }
        RtlCopyMemory(SmbFileName,Template->Buffer,TemplateLength);
        SmbFileName += TemplateLength;
        if ((TemplateLength == sizeof(WCHAR)) && (Template->Buffer[0]==DOS_STAR)) {
            *((PWCHAR)SmbFileName) = L'.'; SmbFileName+= sizeof(WCHAR);
            *((PWCHAR)SmbFileName) = L'*'; SmbFileName+= sizeof(WCHAR);
        }

        FindFirstPattern.Length = (USHORT)(SmbFileName - (PBYTE)FindFirstPattern.Buffer);
        RxDbgTrace(0, Dbg, ("  --> find1stpattern <%wZ>!\n",&FindFirstPattern));
    } else {
        ResumeKeyLength = sizeof(SMB_RESUME_KEY);
        FindFirstPattern.Buffer = NULL;
        FindFirstPattern.Length = 0;
    }


    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_Never, SMB_COM_SEARCH,
                                SMB_REQUEST_SIZE(SEARCH),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );


    MRxSmbStuffSMB (StufferState,
         "0wwB4ywc!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
               3,                   //  w         _USHORT( MaxCount );                // Number of dir. entries to return
               SearchAttributes,    //  w         _USHORT( SearchAttributes );
               SMB_WCT_CHECK(2)     //  B         _USHORT( ByteCount );               // Count of data bytes; min = 5
                                    //            UCHAR Buffer[1];                    // Buffer containing:
               &FindFirstPattern,   //  4        //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name, may be null
               0x05,                //  y         //UCHAR BufferFormat2;              //  0x05 -- Variable block
               ResumeKeyLength,     //  w         //USHORT ResumeKeyLength;           //  Length of resume key, may be 0
                                    //  c
               ResumeKeyLength,OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey
             );


FINALLY:
    if (FindFirstPattern.Buffer != NULL) {
        RxFreePool(FindFirstPattern.Buffer);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbBuildCheckEmptyDirectory exiting.......st=%08lx\n",Status));
    return(Status);
}

NTSTATUS
SmbPseExchangeStart_SetDeleteDisposition(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for SetDeleteDisposition and downlevel delete. This only thing that happens here
    is that we check for an empty directory. On core, this is harder than you think. what we do is to try to get three
    entries. if the directory is empty, we will get only two . and ..; since we do not know whether the server just terminated
    early or whether those are the only two, we go again. we do this until either we get a name that is not . or .. or until
    NO_MORE_FILES is returned. sigh..................

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_FOBX smbFobx = MRxIfsGetFileObjectExtension(capFobx);
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PSMBCE_SERVER pServer = &OrdinaryExchange->SmbCeContext.pServerEntry->Server;
    ULONG SmbLength;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_SetDeleteDisposition\n", 0 ));

    ASSERT_ORDINARY_EXCHANGE(OrdinaryExchange);

    ASSERT(!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));
    ASSERT (OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey == NULL);

    for (;;) {
        MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

        Status = MRxSmbBuildCheckEmptyDirectory(StufferState);
        SmbLength = StufferState->CurrentPosition - StufferState->BufferBase;
        if ( (Status == STATUS_BUFFER_OVERFLOW)
                     || (SmbLength>pServer->MaximumBufferSize) ){
            RxDbgTrace(-1, Dbg, ("MRxSmbSetDeleteDisposition - name too long\n", 0 ));
            return(STATUS_OBJECT_NAME_INVALID);
        } else if ( Status != STATUS_SUCCESS ){
            goto FINALLY;
        }

        Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                        SMBPSE_OETYPE_CORESEARCHFORCHECKEMPTY
                                        );
        //
        // if success is returned with a resume key then we have to go again

        if ( (Status == STATUS_SUCCESS) && (OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey != NULL) ) continue;
        break;
    }

    //
    // this is pretty strange. if it succeeds, then fail the empty check. similarly, if the search
    // fails with the right status...succeeed the check. otherwise fail

FINALLY:
    if (Status == STATUS_SUCCESS) {
        Status = STATUS_DIRECTORY_NOT_EMPTY;
    } else if (Status == STATUS_NO_MORE_FILES) {
        Status = STATUS_SUCCESS;
    }

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_SetDeleteDisposition exit w %08lx\n", Status ));
    return Status;
}


MRxSmbSetDeleteDisposition(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine does a delete for downlevel.

   It is impossible to provide exact NTish semantics on a core server. So, all we do here is to ensure that
   a directory is empty. The actual delete happens when on the last close.


Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING RemainingName;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();


    RxDbgTrace(+1, Dbg, ("MRxSmbSetDeleteDisposition\n", 0 ));

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    if (NodeType(capFcb) != RDBSS_NTC_STORAGE_TYPE_DIRECTORY ) {
        RxDbgTrace(-1, Dbg, ("MRxSmbSetDeleteDisposition not a directory!\n"));
        return(STATUS_SUCCESS);
    }

    OrdinaryExchange = SmbPseCreateOrdinaryExchange(RxContext,
                                                    capFobx->pSrvOpen->pVNetRoot,
                                                    SMBPSE_OE_FROM_FAKESETDELETEDISPOSITION,
                                                    SmbPseExchangeStart_SetDeleteDisposition
                                                    );
    if (OrdinaryExchange==NULL) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status != STATUS_PENDING);

    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);

    RxDbgTrace(-1, Dbg, ("MRxSmbSetDeleteDisposition  exit with status=%08lx\n", Status ));
    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\smbce.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbce.h

Abstract:

    This module defines all functions, along with implementations for inline functions
    related to accessing the SMB connection engine


--*/

#ifndef _SMBCE_H_
#define _SMBCE_H_

#define SECURITY_KERNEL

#define SECURITY_NTLM
#include "security.h"
#include "secint.h"

//
// The SMB protocol has a number of dialects. These reflect the extensions made
// to the core protocol over a period of time to cater to increasingly sophisticated
// file systems. The connection engine must be capable of dealing with different
// dialects implemented by server. The underlying Transport mechanism is used to
// uniquely identify the file server and the SMB protocol furnishes the remaining
// identification information to uniquely map an SMB onto a particular file opened by
// a particular client. The three important pieces of information are the SMB_TREE_ID,
// SMB_FILE_ID and SMB_USER_ID. These identify the particular connection made by a
// client machine, the particular file opened on that connection, and the user on
// behalf of whom the file has been opened. Note that there could be multiple
// connections from a client machine to a server machine. Therefore the unique id. is
// really connection based rather than machine based. The SMB connection engine
// data structures are built around these concepts.

//
// The known SMB dialects are as follows.
//

typedef enum _SMB_DIALECT_ {
    PCNET1_DIALECT,
    XENIXCORE_DIALECT,
    MSNET103_DIALECT,
    LANMAN10_DIALECT,
    WFW10_DIALECT,
    LANMAN12_DIALECT,
    LANMAN21_DIALECT,
    NTLANMAN_DIALECT
} SMB_DIALECT, *PSMB_DIALECT;

//
//      Dialect flags
//
//      These flags describe the various and sundry capabilities that
//      a server can provide. I essentially just lifted this list from rdr1 so that I
//      could also use the level2,3 of getconnectinfo which was also just lifted from rdr1.
//      Many of these guys you can get directly from the CAPS field of the negotiate response but others
//      you cannot. These is a table in the negotiate code that fills in the stuff that is just inferred
//      from the dialect negotiated (also, just lifted from rdr1....a veritable fount of just info.)
//
//      Another set of capabilities is defined in smbce.h....perhaps these should go there or vice versa.
//      The advantage to having them here is that this file has to be included by the aforementioned getconfiginfo code
//      up in the wrapper.
//

#define DF_CORE         0x00000001      // Server is a core server
#define DF_MIXEDCASEPW  0x00000002      // Server supports mixed case password
#define DF_OLDRAWIO     0x00000004      // Server supports MSNET 1.03 RAW I/O
#define DF_NEWRAWIO     0x00000008      // Server supports LANMAN Raw I/O
#define DF_LANMAN10     0x00000010      // Server supports LANMAN 1.0 protocol
#define DF_LANMAN20     0x00000020      // Server supports LANMAN 2.0 protocol
#define DF_MIXEDCASE    0x00000040      // Server supports mixed case files
#define DF_LONGNAME     0x00000080      // Server supports long named files
#define DF_EXTENDNEGOT  0x00000100      // Server returns extended negotiate
#define DF_LOCKREAD     0x00000200      // Server supports LockReadWriteUnlock
#define DF_SECURITY     0x00000400      // Server supports enhanced security
#define DF_NTPROTOCOL   0x00000800      // Server supports NT semantics
#define DF_SUPPORTEA    0x00001000      // Server supports extended attribs
#define DF_LANMAN21     0x00002000      // Server supports LANMAN 2.1 protocol
#define DF_CANCEL       0x00004000      // Server supports NT style cancel
#define DF_UNICODE      0x00008000      // Server supports unicode names.
#define DF_NTNEGOTIATE  0x00010000      // Server supports NT style negotiate.
#define DF_LARGE_FILES  0x00020000      // Server supports large files.
#define DF_NT_SMBS      0x00040000      // Server supports NT SMBs
#define DF_RPC_REMOTE   0x00080000      // Server is administrated via RPC
#define DF_NT_STATUS    0x00100000      // Server returns NT style statuses
#define DF_OPLOCK_LVL2  0x00200000      // Server supports level 2 oplocks.
#define DF_TIME_IS_UTC  0x00400000      // Server time is in UTC.
#define DF_WFW          0x00800000      // Server is Windows for workgroups.
#define DF_KERBEROS     0x01000000      // Server does kerberos authentication
#define DF_TRANS2_FSCTL 0x02000000      // Server accepts remoted fsctls in tran2s
#define DF_DFS_TRANS2   0x04000000      // Server accepts Dfs related trans2
                                        // functions. Can this be merged with
                                        // DF_TRANS2_FSCTL?
#define DF_NT_FIND      0x08000000      // Server supports NT infolevels
#define DF_W95          0x10000000      // this is a win95 server

//
// The SMBCE_NET_ROOT encapsulates the information pertaining to a share on a server. At the
// SMBCE level this corresponds to the TreeId that needs to be included as part of every SMB
// exchanged.
//

//we restrict to the first 7 characters (HPFS386)
#define SMB_MAXIMUM_SUPPORTED_VOLUME_LABEL 7

typedef struct _SMBCE_NET_ROOT_ {
    NET_ROOT_TYPE NetRootType;

    SMB_TREE_ID   TreeId;

    SMB_USER_ID   UserId;

    ULONG         MaximumReadBufferSize;

    LIST_ENTRY    ClusterSizeSerializationQueue;

    ULONG         FileSystemAttributes;

    LONG          MaximumComponentNameLength;
    union {
        struct {
            USHORT FileSystemNameLength;
            WCHAR FileSystemName[SMB_MAXIMUM_SUPPORTED_VOLUME_LABEL];
        };
        struct {
            USHORT Pad2;
            UCHAR FileSystemNameALength;
            UCHAR FileSystemNameA[SMB_MAXIMUM_SUPPORTED_VOLUME_LABEL];
            UCHAR Pad;  //this field is used for a null in a dbgprint; don't move it
        };
    };

    //ULONG         ClusterSize;
} SMBCE_NET_ROOT, *PSMBCE_NET_ROOT;

//
// There are two levels of security in the SMB protocol. User level security and Share level
// security. Corresponding to each user in the user level security mode there is a session.
//
// Typically the password, user name and domain name strings associated with the session entry
// revert to the default values, i.e., they are zero. In the event that they are not zero the
// SessionString represents a concatenated version of the password,user name and domain name in
// that order. This representation in a concatenated way yields us a savings of atleast 3
// USHORT's over other representations.
//

typedef enum _SECURITY_MODE_ {
    SECURITY_MODE_SHARE_LEVEL = 0,
    SECURITY_MODE_USER_LEVEL = 1
} SECURITY_MODE, *PSECURITY_MODE;

#define SMBCE_SHARE_LEVEL_SERVER_USERID 0xffffffff

typedef enum _SESSION_TYPE_ {
    LANMAN_SESSION,
} SESSION_TYPE, *PSESSION_TYPE;

#define SMBCE_SESSION_FLAGS_PARAMETERS_ALLOCATED (0x1)

typedef struct _SMBCE_SESSION_ {
    SESSION_TYPE    Type;
    SMB_USER_ID     UserId;

    // Flags associated with the session.
    ULONG           Flags;

    LUID            LogonId;
    PUNICODE_STRING pUserName;
    PUNICODE_STRING pPassword;
    PUNICODE_STRING pUserDomainName;

    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];

    // The credential and context handles.
    CtxtHandle    SecurityContextHandle;
    CredHandle    CredentialHandle;
} SMBCE_SESSION, *PSMBCE_SESSION;

extern VOID
UninitializeSecurityContextsForSession(PSMBCE_SESSION pSession);

//
// SMBCE_*_SERVER -- This data structure encapsulates all the information related to a server.
// Since there are multiple dialects of the SMB protocol, the capabilities as well as the
// actions that need to be taken at the client machine are very different.
//
// Owing to the number of dialects of the SMB protocol we have two design possibilities.
// Either we define an all encompassing data structure and have a code path that
// uses the dialect and the capabilities of the connection to determine the action
// required, or we use a subclassing mechanism associated with a dispatch vector.
// The advantage of the second mechanism is that it can be developed incrementally and
// it is very easily extensible. The disadvantage of this mechanism is that it can
// lead to a very large footprint, if sufficient care is not exercised during
// factorization and we could have lots and lots of procedure calls which has an
// adverse effect on the code generated.
//
// We will adopt the second approach ( Thereby implicitly defining the metrics by
// which the code should be evaluated !! ).
//
// The types of SMBCE_SERVER's can be classified in the following hierarchy
//
//    SMBCE_SERVER
//
//        SMBCE_USER_LEVEL_SERVER
//
//            SMBCE_NT_SERVER
//
//        SMBCE_SHARE_LEVEL_SERVER
//
// The dispatch vector which defines the set of methods supported by all the connections
// (virtual functions in C++ terminology) are as follows
//

#define RAW_READ_CAPABILITY         0x0001
#define RAW_WRITE_CAPABILITY        0x0002

#define ECHO_PROBE_IDLE              0x1
#define ECHO_PROBE_SEND              0x2
#define ECHO_PROBE_AWAITING_RESPONSE 0x3

#define ECHO_PROBE_LIMIT             (10)

#define CRYPT_TEXT_LEN MSV1_0_CHALLENGE_LENGTH

typedef struct _NTLANMAN_SERVER_ {
    ULONG    NtCapabilities;
} NTLANMAN_SERVER, *PNTLANMAN_SERVER;

typedef struct _SMBCE_SERVER_ {
    // the server version count
    ULONG           Version;

    // the dispatch vector
    struct _SMBCE_SERVER_DISPATCH_VECTOR_  *pDispatch;

    // the SMB dialect
    SMB_DIALECT     Dialect;

    // More Server Capabilities
    ULONG           DialectFlags;

    // the session key
    ULONG           SessionKey;

    // Security mode supported on the server
    SECURITY_MODE   SecurityMode;

    // Time zone bias for conversion.
    LARGE_INTEGER   TimeZoneBias;

    LONG            SmbsReceivedSinceLastStrobe;

    // Maximum negotiated buffer size.
    ULONG           MaximumBufferSize;

    // maximum buffer size for read operations
    ULONG           MaximumDiskFileReadBufferSize;
    ULONG           MaximumNonDiskFileReadBufferSize;

    // Maximum number of multiplexed requests
    USHORT          MaximumRequests;

    // Maximum number of VC's
    USHORT          MaximumVCs;

    USHORT          EchoProbesSent;

    // Server Capabilities
    USHORT          Capabilities;

    UCHAR           EchoProbeState;

    // encrypt passwords
    BOOLEAN         EncryptPasswords;

    // distinguishes a loopback connections
    BOOLEAN         IsLoopBack;

    USHORT          EncryptionKeyLength;
    UCHAR           EncryptionKey[CRYPT_TEXT_LEN];

    // Dialect specific information
    union {
        NTLANMAN_SERVER   NtServer;
    };
} SMBCE_SERVER, *PSMBCE_SERVER;

typedef
NTSTATUS
(*PBUILD_SESSION_SETUP_SMB)(
    IN OUT struct _SMB_EXCHANGE *pExchange,
    IN OUT PGENERIC_ANDX  pSmb,
    IN OUT PULONG          pBufferSize
    );

typedef
NTSTATUS
(*PBUILD_TREE_CONNECT_SMB)(
    IN OUT struct _SMB_EXCHANGE *pExchange,
    IN OUT PGENERIC_ANDX   pSmb,
    IN OUT PULONG          pBufferSize
    );

typedef struct _SMBCE_SERVER_DISPATCH_VECTOR_ {
    PBUILD_SESSION_SETUP_SMB  BuildSessionSetup;
    PBUILD_TREE_CONNECT_SMB   BuildTreeConnect;
} SMBCE_SERVER_DISPATCH_VECTOR, *PSMBCE_SERVER_DISPATCH_VECTOR;

#define SMBCE_SERVER_DIALECT_DISPATCH(pServer,Routine,Arguments)        \
      (*((pServer)->pDispatch->Routine))##Arguments


//
// Though the SMB protocol permits multiple number of VC's to be associated with a particular
// connection to a share, the bulk transfer of data is done in the raw mode. In this mode of
// operation the SMB protocol does not permit multiple outstanding requests.
// In the SMB protocol a number of requests can be multiplexed along a connection to the server
// There are certain kind of requests which can be completed on the client, i.e., no
// acknowledgement is neither expected nor received. In these cases the send call is completed
// synchronoulsy. On the other hand there is a second class of sends which cannot be resumed
// locally till the appropriate acknowledgement is recieved from the server. In such cases a
// list of requests is built up with each VC. On receipt of the appropriate acknowledgement
// these requests are resumed.
//

typedef enum _SMBCE_VC_STATE_ {
    SMBCE_VC_STATE_MULTIPLEXED,
    SMBCE_VC_STATE_RAW,
    SMBCE_VC_STATE_DISCONNECTED,
} SMBCE_VC_STATE, *PSMBCE_VC_STATE;

typedef struct _SMBCE_VC_ {
    RXCE_VC_HANDLE            hVc;
    SMBCE_VC_STATE            State;
} SMBCE_VC, *PSMBCE_VC;


// The SMBCE engine process all requests in an asychronous fashion. Therefore for synchronous
// requests an additional mechanism is required for synchronization. The following data structure
// provides an easy way for implementing this synchronization.
//
// NOTE: For asynchronous resumption contexts the resumption routine can be invoked
// at DPC level.

#define SMBCE_RESUMPTION_CONTEXT_FLAG_ASYNCHRONOUS (0x1)

typedef struct SMBCE_RESUMPTION_CONTEXT {
    ULONG    Flags;
    NTSTATUS Status;              // the status
    PVOID    pContext;            // a void pointer for clients to add additional context information
    union {
        PRX_WORKERTHREAD_ROUTINE pRoutine; // asynchronous contexts
        KEVENT                   Event;    // the event for synchronization
    };
} SMBCE_RESUMPTION_CONTEXT, *PSMBCE_RESUMPTION_CONTEXT;

#define SmbCeIsResumptionContextAsynchronous(pResumptionContext)   \
         ((pResumptionContext)->Flags & SMBCE_RESUMPTION_CONTEXT_FLAG_ASYNCHRONOUS)

INLINE VOID
SmbCeInitializeResumptionContext(
    PSMBCE_RESUMPTION_CONTEXT pResumptionContext)
{
    KeInitializeEvent(&(pResumptionContext)->Event,NotificationEvent,FALSE);
    pResumptionContext->Status   = STATUS_SUCCESS;
    pResumptionContext->Flags    = 0;
    pResumptionContext->pContext = NULL;
}

INLINE VOID
SmbCeInitializeAsynchronousResumptionContext(
    PSMBCE_RESUMPTION_CONTEXT pResumptionContext,
    PRX_WORKERTHREAD_ROUTINE  pResumptionRoutine,
    PVOID                     pResumptionRoutineParam)
{
    pResumptionContext->Status   = STATUS_SUCCESS;
    pResumptionContext->Flags    = SMBCE_RESUMPTION_CONTEXT_FLAG_ASYNCHRONOUS;
    pResumptionContext->pContext = pResumptionRoutineParam;
    pResumptionContext->pRoutine = pResumptionRoutine;
}

INLINE VOID
SmbCeSuspend(
    PSMBCE_RESUMPTION_CONTEXT pResumptionContext)
{
    ASSERT(!(pResumptionContext->Flags & SMBCE_RESUMPTION_CONTEXT_FLAG_ASYNCHRONOUS));
    KeWaitForSingleObject(
        &pResumptionContext->Event,
        Executive,
        KernelMode,
        FALSE,
        NULL);
}

INLINE VOID
SmbCeResume(
    PSMBCE_RESUMPTION_CONTEXT pResumptionContext)
{
    if (!(pResumptionContext->Flags & SMBCE_RESUMPTION_CONTEXT_FLAG_ASYNCHRONOUS)) {
        KeSetEvent(&(pResumptionContext)->Event,0,FALSE);
    } else {
        if (RxShouldPostCompletion()) {
            RxDispatchToWorkerThread(
                MRxIfsDeviceObject,
                CriticalWorkQueue,
                pResumptionContext->pRoutine,
                pResumptionContext->pContext);
        } else {
            (pResumptionContext->pRoutine)(pResumptionContext->pContext);
        }
    }
}

//
// The SMBCE_REQUEST struct encapsulates the continuation context associated. Typically
// the act of sending a SMB along an exchange results in a SMBCE_REQUEST structure being
// created with sufficient context information to resume the exchange upon reciept of
// response from the serve. The SMBCE_REQUEST conatins ebough information to identify
// the SMB for which the response is being obtained followed by enough context information
// to resume the exchange.
//

typedef enum _SMBCE_OPERATION_ {
    SMBCE_TRANCEIVE,
    SMBCE_RECEIVE,
    SMBCE_SEND,
    SMBCE_ASYNCHRONOUS_SEND,
    SMBCE_ACQUIRE_MID
} SMBCE_OPERATION, *PSMBCE_OPERATION;

typedef enum _SMBCE_REQUEST_TYPE_ {
    ORDINARY_REQUEST,
    COPY_DATA_REQUEST,
    RECONNECT_REQUEST,
    ACQUIRE_MID_REQUEST
} SMBCE_REQUEST_TYPE, *PSMBCE_REQUEST_TYPE;

typedef struct _SMBCE_GENERIC_REQUEST_ {
    SMBCE_REQUEST_TYPE      Type;

    // the exchange instance that originated this SMB
    struct _SMB_EXCHANGE *  pExchange;
} SMBCE_GENERIC_REQUEST, *PSMBCE_GENERIC_REQUEST;

typedef struct _SMBCE_REQUEST_ {
    SMBCE_GENERIC_REQUEST;

    // the type of request
    SMBCE_OPERATION Operation;

    // the virtual circuit along which this request was sent.
    RXCE_VC_HANDLE  hVc;

    // MPX Id of outgoing request.
    SMB_MPX_ID      Mid;

    // the pedigree of the request
    SMB_TREE_ID     TreeId;      // The Tree Id.
    SMB_FILE_ID     FileId;      // The file id.
    SMB_USER_ID     UserId;      // User Id. for cancel.
    SMB_PROCESS_ID  ProcessId;   // Process Id. for cancel.

    PMDL            pSendBuffer;
    ULONG           BytesSent;
} SMBCE_REQUEST, *PSMBCE_REQUEST;


typedef struct _SMBCE_COPY_DATA_REQUEST_ {
    SMBCE_GENERIC_REQUEST;

    // the virtual circuit along which this request was sent.
    RXCE_VC_HANDLE hVc;

    // the buffer into whihc data is being copied.
    PVOID          pBuffer;

    // the actual number of bytes copied
    ULONG          BytesCopied;
} SMBCE_COPY_DATA_REQUEST, *PSMBCE_COPY_DATA_REQUEST;


typedef struct _SMBCE_RECONNECT_REQUEST_ {
    SMBCE_GENERIC_REQUEST;
} SMBCE_RECONNECT_REQUEST, *PSMBCE_RECONNECT_REQUEST;

typedef struct _SMBCE_MID_REQUEST_ {
    SMBCE_GENERIC_REQUEST;
    PSMBCE_RESUMPTION_CONTEXT   pResumptionContext;
} SMBCE_MID_REQUEST, *PSMBCE_MID_REQUEST;

#define ECHO_PROBE_CANCELLED_FLAG (0x1)

typedef struct _MRXSMB_ECHO_PROCESSING_CONTEXT_ {
    RX_WORK_ITEM  WorkItem;
    KEVENT        CancelCompletionEvent;
    PVOID         pEchoSmb;
    ULONG         Flags;
    ULONG         EchoSmbLength;
    PMDL  pEchoSmbMdl;
    NTSTATUS      Status;
    LARGE_INTEGER Interval;
} MRXSMB_ECHO_PROCESSING_CONTEXT, *PMRXSMB_ECHO_PROCESSING_CONTEXT;

//
// extern function declarations
//

extern NTSTATUS
BuildSessionSetupSmb(
    struct _SMB_EXCHANGE *pExchange,
    PGENERIC_ANDX  pAndXSmb,
    PULONG         pAndXSmbBufferSize);

extern NTSTATUS
CoreBuildTreeConnectSmb(
    struct _SMB_EXCHANGE *pExchange,
    PGENERIC_ANDX        pAndXSmb,
    PULONG               pAndXSmbBufferSize);

extern NTSTATUS
LmBuildTreeConnectSmb(
    struct _SMB_EXCHANGE *pExchange,
    PGENERIC_ANDX        pAndXSmb,
    PULONG               pAndXSmbBufferSize);

extern NTSTATUS
NtBuildTreeConnectSmb(
    struct _SMB_EXCHANGE *pExchange,
    PGENERIC_ANDX        pAndXSmb,
    PULONG               pAndXSmbBufferSize);

extern NTSTATUS
MRxIfsInitializeEchoProcessingContext();

extern NTSTATUS
MRxIfsTearDownEchoProcessingContext();

extern NTSTATUS
BuildNegotiateSmb(
    PVOID    *pSmbBufferPointer,
    PULONG   pSmbBufferLength);

extern NTSTATUS
ParseNegotiateResponse(
    PSMBCE_SERVER   pServer,
    PUNICODE_STRING pDomainName,
    PSMB_HEADER     pSmbHeader,
    ULONG           AvailableLength,
    PULONG          pConsumedLength);

extern VOID
SmbCeProbeServers(
    PVOID    pContext);


extern struct _MINIRDR_DISPATCH MRxSmbDispatch;

extern MRXSMB_ECHO_PROCESSING_CONTEXT EchoProbeContext;

#endif // _SMBCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\smbcemid.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    smbcemid.c

Abstract:

    This module defines the routines for manipulating MIDs associated with SMB's

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

RXDT_DefineCategory(SMBCEMID);

#define Dbg        (DEBUG_TRACE_SMBCEMID)


NTSTATUS
SmbCeAssociateExchangeWithMid(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   struct _SMB_EXCHANGE  *pExchange)
/*++

Routine Description:

   This routine associates an exchange with a MID

Arguments:

    pServerEntry - the servere entry

    pExchange    - the Exchange instance.

Return Value:

    STATUS_SUCCESS if successful, otherwise one of the following errors

Notes:

   If an asynchronous mechanism to acquire MID's is to be introduced this routine
   needs to be modified. Currently this routine does not return control till a
   MID is acquired or the exchange is aborted/terminated.

--*/
{
   NTSTATUS                 Status = STATUS_SUCCESS;
   PSMBCEDB_REQUEST_ENTRY   pRequestEntry;
   SMBCE_RESUMPTION_CONTEXT ResumptionContext;
   SMBCEDB_SERVER_TYPE      ServerType;

   ServerType = SmbCeGetServerType(pServerEntry);

   // Acquire the resource
   SmbCeAcquireSpinLock();

   // Attempt to allocate a MID only for FILE Servers. Mailslot servers do
   // not require a valid MID.

   if (ServerType != SMBCEDB_MAILSLOT_SERVER) {
      if (pServerEntry->pMidAtlas != NULL) {
         if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_INDEFINITE_DELAY_IN_RESPONSE) {
            // This exchange response can be arbitrarily delayed. Ensure that
            // all the available MIDS are not tied up in such exchanges.

            if ((pServerEntry->pMidAtlas->NumberOfMidsInUse + 1) ==
                pServerEntry->pMidAtlas->MaximumNumberOfMids) {
               Status = STATUS_TOO_MANY_COMMANDS;
            }
         }

         if (Status == STATUS_SUCCESS) {
            Status = IfsMrxAssociateContextWithMid(
                              pServerEntry->pMidAtlas,
                              pExchange,
                              &pExchange->Mid);
         }
      } else {
         Status = STATUS_INVALID_PARAMETER;
      }
   }

   if (Status == STATUS_UNSUCCESSFUL) {
      // Allocate a new entry and add it to the list.
      pRequestEntry = (PSMBCEDB_REQUEST_ENTRY)SmbMmAllocateObject(SMBCEDB_OT_REQUEST);
      if (pRequestEntry != NULL) {
         // Enqueue the request entry.

         SmbCeInitializeResumptionContext(&ResumptionContext);

         pRequestEntry->MidRequest.Type               = ACQUIRE_MID_REQUEST;
         pRequestEntry->MidRequest.pExchange          = pExchange;
         pRequestEntry->MidRequest.pResumptionContext = &ResumptionContext;
         SmbCeAddRequestEntryLite(&pServerEntry->MidAssignmentRequests,pRequestEntry);
      } else {
         Status = STATUS_INSUFFICIENT_RESOURCES;
      }
   } else if (Status == STATUS_SUCCESS) {
      pExchange->SmbCeFlags |= SMBCE_EXCHANGE_MID_VALID;
   }

   // Release the resource
   SmbCeReleaseSpinLock();

   if (Status == STATUS_UNSUCCESSFUL) {
      //DbgPrint("***** Thread %lx Waiting for MID Resumption Context %lx*****\n",PsGetCurrentThread(),&ResumptionContext);
      SmbCeSuspend(&ResumptionContext);
      Status = ResumptionContext.Status;
      //DbgPrint("***** Thread %lx MID Wait Satisfied %lx *****\n",PsGetCurrentThread(),&ResumptionContext);
   }

   return Status;
}

struct _SMB_EXCHANGE *
SmbCeMapMidToExchange(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   SMB_MPX_ID            Mid)
/*++

Routine Description:

   This routine maps a given MID to the exchange associated with it

Arguments:

    pServerEntry - the servere entry

    Mid          - the mid to be mapped to an Exchange.

Return Value:

    a valid SMB_EXCHANGE instance if successful, otheriwse NULL.

--*/
{

   PSMB_EXCHANGE pExchange;

   // Acquire the resource
   SmbCeAcquireSpinLock();

   if (pServerEntry->pMidAtlas != NULL) {
      pExchange = IfsMrxMapMidToContext(
                        pServerEntry->pMidAtlas,
                        Mid);
   } else {
      pExchange = NULL;
   }

   // Release the resource
   SmbCeReleaseSpinLock();

   return pExchange;
}

NTSTATUS
SmbCeDisassociateMidFromExchange(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   struct _SMB_EXCHANGE  *pExchange)
/*++

Routine Description:

   This routine disassociates an exchange from the MID

Arguments:

    pServerEntry - the servere entry

    pExchange    - the exchange instance.

Return Value:

    a valid SMB_EXCHANGE instance if successful, otheriwse NULL.

Notes:

   If an asynchronous mechanism to acquire MID's is to be introduced this routine
   needs to be modified. This modification will also include posting requests
   for resumption of exchanges when invoked at DPC level.

--*/
{
   NTSTATUS               Status = STATUS_SUCCESS;
   SMBCEDB_SERVER_TYPE    ServerType;

   ServerType = SmbCeGetServerType(pServerEntry);

   if ((ServerType != SMBCEDB_MAILSLOT_SERVER) &&
       (pExchange->Mid != SMBCE_OPLOCK_RESPONSE_MID)) {
      PVOID                  pContext;
      PSMBCEDB_REQUEST_ENTRY pRequestEntry = NULL;

      // Acquire the resource
      SmbCeAcquireSpinLock();

      if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID) {
         // Check if there are any pending MID assignment requests and transfer the MID
         // if one exists.
         pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->MidAssignmentRequests);
         if (pRequestEntry != NULL) {
            SmbCeRemoveRequestEntryLite(&pServerEntry->MidAssignmentRequests,pRequestEntry);
         }

         if (pServerEntry->pMidAtlas != NULL) {
            if (pRequestEntry != NULL) {
               Status = IfsMrxReassociateMid(
                                 pServerEntry->pMidAtlas,
                                 pExchange->Mid,
                                 pRequestEntry->MidRequest.pExchange);

               ASSERT(Status == STATUS_SUCCESS);

               pRequestEntry->MidRequest.pExchange->SmbCeFlags |= SMBCE_EXCHANGE_MID_VALID;
               pRequestEntry->MidRequest.pExchange->Mid = pExchange->Mid;
               pRequestEntry->MidRequest.pResumptionContext->Status = STATUS_SUCCESS;
            } else {
               Status = IfsMrxMapAndDissociateMidFromContext(
                                 pServerEntry->pMidAtlas,
                                 pExchange->Mid,
                                 &pContext);

               ASSERT(pContext == pExchange);
            }
         } else {
            Status = STATUS_INVALID_PARAMETER;
         }
      }

      // Release the resource
      SmbCeReleaseSpinLock();

      if (pRequestEntry != NULL) {
         // Signal the waiter for resumption
         //DbgPrint("***** Satisfying wait on MID Resumption Context %lx*****\n",pRequestEntry->MidRequest.pResumptionContext);
         SmbCeResume(pRequestEntry->MidRequest.pResumptionContext);

         SmbCeTearDownRequestEntry(pRequestEntry);
      }
   }

   pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_MID_VALID;

   return Status;
}

struct _SMB_EXCHANGE *
SmbCeGetExchangeAssociatedWithBuffer(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   PVOID                 pBuffer)
/*++

Routine Description:

   This routine gets the exchange associated with a buffer

Arguments:

    pServerEntry - the servere entry

    pBuffer      - the buffer instance.

Return Value:

    a valid SMB_EXCHANGE instance if successful, otheriwse NULL.

Notes:

   This routine and the routines that follow enable a pipelined reuse of MID's
   If a large buffer is to be copied then this can be done without hodling onto
   a MID. This improves the throughput between the client and the server. At the
   very least this mechanism ensures that the connection engine will not be the
   constraining factor in MID reuse.

--*/
{
   PSMBCEDB_REQUEST_ENTRY pRequestEntry;
   PSMB_EXCHANGE          pExchange = NULL;

   // Acquire the resource
   SmbCeAcquireSpinLock();

   // Walk through the list of requests maintained on this and remove the one
   // matching the cached buffer ptr with the ptr indicated
   pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->OutstandingRequests);
   while (pRequestEntry != NULL) {
      if ((pRequestEntry->GenericRequest.Type == COPY_DATA_REQUEST) &&
          (pRequestEntry->CopyDataRequest.pBuffer == pBuffer)) {
         pExchange = pRequestEntry->CopyDataRequest.pExchange;
         pRequestEntry->CopyDataRequest.pBuffer = NULL;
         break;
      }

      pRequestEntry = SmbCeGetNextRequestEntry(
                              &pServerEntry->OutstandingRequests,
                              pRequestEntry);
   }

   // Release the resource
   SmbCeReleaseSpinLock();

   return pExchange;
}

NTSTATUS
SmbCeAssociateBufferWithExchange(
   PSMBCEDB_SERVER_ENTRY  pServerEntry,
   struct _SMB_EXCHANGE * pExchange,
   PVOID                  pBuffer)
/*++

Routine Description:

   This routine establishes an association between an exchange and a copy data request
   buffer

Arguments:

    pServerEntry - the servere entry

    pBuffer      - the buffer instance.

Return Value:

    STATUS_SUCCESS if succesful

--*/
{
   NTSTATUS               Status = STATUS_SUCCESS;
   PSMBCEDB_REQUEST_ENTRY pRequestEntry;

   // Acquire the resource
   SmbCeAcquireSpinLock();

   Status = pServerEntry->ServerStatus;
   if (Status == STATUS_SUCCESS) {
      // Walk through the list of requests maintained on this and remove the one
      // matching the cached buffer ptr with the ptr indicated
      pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->OutstandingRequests);
      while (pRequestEntry != NULL) {
         if ((pRequestEntry->GenericRequest.Type == COPY_DATA_REQUEST) &&
             (pRequestEntry->CopyDataRequest.pBuffer == NULL)) {
            pRequestEntry->CopyDataRequest.pExchange = pExchange;
            pRequestEntry->CopyDataRequest.pBuffer = pBuffer;
            break;
         }
         pRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);
      }
   }

   // Release the resource
   SmbCeReleaseSpinLock();

   if ((Status == STATUS_SUCCESS) &&
       (pRequestEntry == NULL)) {
      // Allocate a new entry and add it to the list.
      pRequestEntry = (PSMBCEDB_REQUEST_ENTRY)SmbMmAllocateObject(SMBCEDB_OT_REQUEST);
      if (pRequestEntry != NULL) {
         // Enqueue the request entry.
         pRequestEntry->CopyDataRequest.Type      = COPY_DATA_REQUEST;
         pRequestEntry->CopyDataRequest.pExchange = pExchange;
         pRequestEntry->CopyDataRequest.pBuffer   = pBuffer;

         // Acquire the resource
         SmbCeAcquireSpinLock();

         if ((Status = pServerEntry->ServerStatus) == STATUS_SUCCESS) {
            SmbCeAddRequestEntryLite(&pServerEntry->OutstandingRequests,pRequestEntry);
         }

         // Release the resource
         SmbCeReleaseSpinLock();

         if (Status != STATUS_SUCCESS) {
            SmbCeTearDownRequestEntry(pRequestEntry);
         }
      } else {
         Status = STATUS_INSUFFICIENT_RESOURCES;
      }
   }

   return Status;
}

VOID
SmbCePurgeBuffersAssociatedWithExchange(
   PSMBCEDB_SERVER_ENTRY  pServerEntry,
   struct _SMB_EXCHANGE * pExchange)
/*++

Routine Description:

   This routine purges all the copy data requests associated with an exchange.

Arguments:

    pServerEntry - the servere entry

    pExchange    - the exchange instance.

Notes:

   This mechanism of delaying the purging of requests associated with an exchange
   till it is discared is intended to solve the problem of repeated allocation/freeing
   of request entries. This rests on the assumption that there will not be too many
   copy data requests outstanding for any exchange. If evidence to the contrary is
   noticed this technique has to be modified.

--*/
{
   SMBCEDB_REQUESTS       ExchangeRequests;
   PSMBCEDB_REQUEST_ENTRY pRequestEntry;
   PSMBCEDB_REQUEST_ENTRY pNextRequestEntry;

   SmbCeInitializeRequests(&ExchangeRequests);

   // Acquire the resource
   SmbCeAcquireSpinLock();

   // Walk through the list of requests maintained on this and remove the one
   // matching the given exchange
   pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->OutstandingRequests);
   while (pRequestEntry != NULL) {
      pNextRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);
      if (pRequestEntry->GenericRequest.pExchange == pExchange) {
         SmbCeRemoveRequestEntryLite(&pServerEntry->OutStandingRequests,pRequestEntry);
         SmbCeAddRequestEntryLite(&ExchangeRequests,pRequestEntry);
      }
      pRequestEntry = pNextRequestEntry;
   }

   // Release the resource
   SmbCeReleaseSpinLock();

   pRequestEntry = SmbCeGetFirstRequestEntry(&ExchangeRequests);
   while (pRequestEntry != NULL) {
      SmbCeRemoveRequestEntryLite(&ExchangeRequests,pRequestEntry);
      SmbCeTearDownRequestEntry(pRequestEntry);
      pRequestEntry = SmbCeGetFirstRequestEntry(&ExchangeRequests);
   }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\smbcedbp.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    smbcedbp.h

Abstract:

    This is the include file that defines all constants and types for
    implementing the SMB mini redirector connection engine.

    This module contains all the implementation details of the connection engine
    data structures and should be included only by the implementation modules.


Notes:

--*/

#ifndef _SMBCEDBP_H_
#define _SMBCEDBP_H_

//
// There is reliance on the fact that SMBCEDB_OT_SENTINEL is the last entry in the
// enumerated type and the types have a range of values from 0. Please ensure that
// this is always true.
//

typedef enum _SMBCEDB_OBJECT_TYPE {
   SMBCEDB_OT_SERVER,
   SMBCEDB_OT_NETROOT,
   SMBCEDB_OT_SESSION,
   SMBCEDB_OT_REQUEST,
   SMBCEDB_OT_SENTINEL
} SMBCEDB_OBJECT_TYPE, *PSMBCEDB_OBJECT_TYPE;

typedef enum _SMBCEDB_OBJECT_STATE_ {
   SMBCEDB_ACTIVE,                    // the instance is in use
   SMBCEDB_INVALID,                   // the instance has been invalidated/disconnected.
   SMBCEDB_MARKED_FOR_DELETION,       // the instance has been marked for deletion.
   SMBCEDB_RECYCLE,                   // the instance is available for recycling
   SMBCEDB_START_CONSTRUCTION,        // Initiate construction.
   SMBCEDB_CONSTRUCTION_IN_PROGRESS,  // the instance construction is in progress
   SMBCEDB_DESTRUCTION_IN_PROGRESS    // the instance destruction is in progress
} SMBCEDB_OBJECT_STATE, *PSMBCEDB_OBJECT_STATE;

typedef struct _SMBCE_OBJECT_HEADER_ {
   UCHAR   ObjectType;      // type of the object
   UCHAR   ObjectCategory;  // Node type for debugging
   UCHAR   Flags;           // flags associated with the object, This is implementation dependent
   UCHAR   State;           // State of the object
   LONG    SwizzleCount;    // Number of swizzled references to this object
} SMBCE_OBJECT_HEADER, *PSMBCE_OBJECT_HEADER;

typedef struct _SMBCE_SERVERS_LIST_ {
    LIST_ENTRY ListHead;
} SMBCEDB_SERVERS, *PSMBCEDB_SERVERS;

typedef struct _SMBCEDB_SESSIONS_ {
   LIST_ENTRY                     ListHead;
   struct _SMBCEDB_SESSION_ENTRY *pDefaultSessionEntry;
} SMBCEDB_SESSIONS, *PSMBCEDB_SESSIONS;

typedef struct _SMBCEDB_NET_ROOTS_ {
   LIST_ENTRY  ListHead;
} SMBCEDB_NET_ROOTS, *PSMBCEDB_NET_ROOTS;

typedef struct _SMBCEDB_REQUESTS_ {
    LIST_ENTRY  ListHead;
    SMB_MPX_ID  NextRequestId;
} SMBCEDB_REQUESTS, *PSMBCEDB_REQUESTS;

typedef enum _SMBCEDB_SERVER_TYPE_ {
   SMBCEDB_MAILSLOT_SERVER = 1,
   SMBCEDB_FILE_SERVER     = 2
} SMBCEDB_SERVER_TYPE, *PSMBCEDB_SERVER_TYPE;

//
// The SMBCEDB_SERVER_ENTRY is the data structure which encapsulates all the information
// w.r.t a remote server for the connection engine. This information includes the dialect
// details as well as the operational data structures required to communicate with the server.
//
// All the dialect related details are further encapsulated in SMBCE_SERVER while the operational
// data structures constitute the remaining parts of the server entry. A pointer to a
// SMBCEDB_SERVER_ENTRY instance is associated with every SRV_CALL that has been hooked
// onto this mini redirector by the wrapper. It is stored in the Context field of MRX_SRV_CALL.
//
// The operational information associated with a server entry includes the Transport related
// information, a collection of requests and a mechanism for associating MID's ( See SMB
// protocol spec.) and a mechanism for posting to threads ( WORK_QUEUE_ITEM ).
//

typedef struct _SMBCEDB_SERVER_ENTRY {
    SMBCE_OBJECT_HEADER         Header;           // struct header.
    LIST_ENTRY                    ServersList;      // list of server instances.
    PMRX_SRV_CALL                 pRdbssSrvCall;
    SMBCEDB_SESSIONS              Sessions;         // the sessions associated with the server
    SMBCEDB_NET_ROOTS             NetRoots;         // the net roots associated with the server.
    RX_WORK_QUEUE_ITEM            WorkQueueItem;    // work queue item for posting
    NTSTATUS                      ServerStatus;     // the status of the server as determined by negotiate response
    struct SMBCE_SERVER_TRANSPORT *pTransport;
    SMBCEDB_REQUESTS              MidAssignmentRequests;
    SMBCEDB_REQUESTS              OutstandingRequests;
    PMID_ATLAS                    pMidAtlas;
    struct _SMB_EXCHANGE          *pNegotiateExchange;
    SMBCE_SERVER                  Server;           // the server data structure.
} SMBCEDB_SERVER_ENTRY, *PSMBCEDB_SERVER_ENTRY;

// The SMBCEDB_NET_ROOT_ENTRY encapsulates all the information associated with a particular
// TREE_CONNECT ( Net use ) made on a server. As with the server entry this data structure
// encapsulates the dialect oriented details as well as the opertaional information
// associated with handling the requests on a net root.
//
// The dialect specific information is encapsulated in the SMBCE_NET_ROOT data structure. A
// pointer to an instance of this data structure is associated with every MRX_NET_ROOT call
// associated with a MRX_SRV_CALL hooked to this mini redirector.

typedef struct _SMBCEDB_NET_ROOT_ENTRY {
    SMBCE_OBJECT_HEADER      Header;              // the struct header
    LIST_ENTRY                 NetRootsList;        // the list of net roots asssociated with a server
    PMRX_NET_ROOT              pRdbssNetRoot;       // the associated net root ( purely as a debug aid )
    PSMBCEDB_SERVER_ENTRY      pServerEntry;        // the associated server entry
    SMBCEDB_REQUESTS           Requests;            // the pending requests for this net root
    SMBCE_NET_ROOT             NetRoot;             // the net root data structure.
} SMBCEDB_NET_ROOT_ENTRY, *PSMBCEDB_NET_ROOT_ENTRY;

// The SMBCEDB_SESSION_ENTRY encapsulates all the information associated with a session
// established to a remote machine. The session encapsulates all the security information.
// The dialect specific details are encapsulated in teh SMBCE_SESSION data structure. The
// SMBCE_SESSION data structure is available in many flavours depending on the security
// package used. Currently there is support for handling LSA and KERBEROS sessions.
//
// A pointer to an instance of this data structure is associated with every MRX_V_NET_ROOT
// data structure hooked to this mini redirector by the wrapper.

typedef struct _SMBCEDB_SESSION_ENTRY {
    SMBCE_OBJECT_HEADER      Header;           // the struct header
    LIST_ENTRY                 SessionsList;     // the list of sessions associated with the server
    PMRX_V_NET_ROOT            pRdbssVNetRoot;   // the associated VNetRoot ( purely as a debug aid)
    PSMBCEDB_SERVER_ENTRY      pServerEntry;     // the associated server entry
    SMBCEDB_REQUESTS           Requests;         // Net Roots under construction
    ULONG                      SessionVCNumber;  // the VC number to be packaged with session setup
    SMBCE_SESSION              Session;          // the Session
} SMBCEDB_SESSION_ENTRY, *PSMBCEDB_SESSION_ENTRY;

//
// An SMBCEDB_REQUEST_ENTRY encapsulates an action being processed by the SMBCE connection
// engine. The requests come in vairous flavours and each of these flavours is associated
// with the appropriate context required for resumption. In order to provide better memory
// management mechanisms the REQUEST_ENTRY encapsulates a union of the requests of various
// flavours. Each SERVER_ENTRY in the connection engine is associated with a list or
// request entries. In order to hide the abstraction of a list which does not scale well to
// the case of GATEWAY redirectors a set of routines are provided to manipulate the
// collection of requests. They provide a mechanism for intializing the collection of requests,
// adding a request, deleting a request and enumeratiung requests in a collection.
//
// Special mechanisms are built in to handle batching of operations. Each operation on the
// collection of requests come in two flavours, a vanila version and a lite version. In the
// lite version it is assumed that the appropriate concurrency control action has been taken
//
// One common scenario that is often encountered in processing the requests is invocation
// of a specific function on the requests in the collection. As an example if a disconnect
// request is received on a server entry then all the outstanding requests must be resumed
// with the appropriate error. Since these indications can potentially occur at DPC levels in
// NT it is not desirable to manipulate the collection while holding onto a spinlock, nor is
// it desirable to repeatedly release and accquire the spin lock. A special operation is
// provided for transferring the requests enmasse from one collection to another and resetting
// the original. With the help of this operation it is sufficient to hold the spinlock only
// for the duration of the transfer. The remainder of the processing can be done on the newly
// created collection.
//
//
// NT Specific Implementation Note:
//
// On NT the transport indications are at DPC level, therefore it is required to protect
// the manipulation of the requests data structure with a spinlock.
//
//

typedef struct _SMBCEDB_REQUEST_ENTRY_ {
    SMBCE_OBJECT_HEADER           Header;        // the struct header
    LIST_ENTRY                      RequestsList;  // the next request for the VC.
    union {
       SMBCE_GENERIC_REQUEST    GenericRequest;
       SMBCE_REQUEST            Request;           // the next request.
       SMBCE_COPY_DATA_REQUEST  CopyDataRequest;
       SMBCE_RECONNECT_REQUEST  ReconnectRequest;
       SMBCE_MID_REQUEST        MidRequest;
    };
} SMBCEDB_REQUEST_ENTRY, *PSMBCEDB_REQUEST_ENTRY;

#define SmbCeInitializeRequests(pRequests)  \
         InitializeListHead(&(pRequests)->ListHead); \
         (pRequests)->NextRequestId = 0

#define SmbCeAddRequestEntry(pRequestList,pRequestEntry)                             \
           SmbCeAcquireSpinLock();                                                   \
           InsertTailList(&(pRequestList)->ListHead,&(pRequestEntry)->RequestsList); \
           SmbCeReleaseSpinLock()

#define SmbCeAddRequestEntryLite(pRequestList,pRequestEntry)   \
           InsertTailList(&(pRequestList)->ListHead,&(pRequestEntry)->RequestsList)

#define SmbCeRemoveRequestEntry(pRequests,pEntry)     \
           SmbCeAcquireSpinLock();                    \
           RemoveEntryList(&(pEntry)->RequestsList);  \
           SmbCeReleaseSpinLock()

#define SmbCeRemoveRequestEntryLite(pRequests,pEntry)         \
               RemoveEntryList(&(pEntry)->RequestsList)

#define SmbCeGetFirstRequestEntry(pRequestList)                    \
            (IsListEmpty(&(pRequestList)->ListHead)                \
             ? NULL                                                \
             : (PSMBCEDB_REQUEST_ENTRY)                            \
               (CONTAINING_RECORD((pRequestList)->ListHead.Flink,  \
                                  SMBCEDB_REQUEST_ENTRY,           \
                                  RequestsList)))

#define SmbCeGetNextRequestEntry(pRequestList,pRequestEntry)                     \
            (((pRequestEntry)->RequestsList.Flink == &(pRequestList)->ListHead)  \
             ? NULL                                                              \
             : (PSMBCEDB_REQUEST_ENTRY)                                          \
               (CONTAINING_RECORD((pRequestEntry)->RequestsList.Flink,           \
                                  SMBCEDB_REQUEST_ENTRY,                         \
                                  RequestsList)))

#define SmbCeTransferRequests(pDestination,pSource)                               \
         if (IsListEmpty(&(pSource)->ListHead)) {                                 \
            SmbCeInitializeRequests((pDestination));                              \
         } else {                                                                 \
            *(pDestination) = *(pSource);                                         \
            (pDestination)->ListHead.Flink->Blink = &(pDestination)->ListHead;    \
            (pDestination)->ListHead.Blink->Flink = &(pDestination)->ListHead;    \
            SmbCeInitializeRequests((pSource));                                   \
         }


// Much along the lines of a colelction of request a collection of all server entries is
// maintained as part of the connection engine. The following operations are supported on
// the colection of server entries
//    1) adding a server entry to the collection
//    2) removing a server entry from the colection
//    3) enumerating the entries in the collection
//
// As in the case of the collection of requests all these operations come in two flavours
// the vanila version in which concurrency control is enforced and the lite version in
// which the concurrency control is left to the user's discretion.

#define SmbCeAddServerEntry(pServerEntry)                                      \
            SmbCeAcquireSpinLock();                                            \
            InsertTailList(&s_DbServers.ListHead,&pServerEntry->ServersList);  \
            SmbCeReleaseSpinLock()

#define SmbCeAddServerEntryLite(pServerEntry)                                   \
            InsertTailList(&s_DbServers.ListHead,&pServerEntry->ServersList)

#define SmbCeRemoveServerEntry(pServerEntry)                \
            SmbCeAcquireSpinLock();                         \
            RemoveEntryList(&(pServerEntry)->ServersList);  \
            SmbCeReleaseSpinLock()

#define SmbCeRemoveServerEntryLite(pServerEntry)   \
            RemoveEntryList(&(pServerEntry)->ServersList)

#define SmbCeGetFirstServerEntry()                                   \
               (IsListEmpty(&s_DbServers.ListHead)                   \
                ? NULL                                               \
                : (PSMBCEDB_SERVER_ENTRY)                            \
                  (CONTAINING_RECORD(s_DbServers.ListHead.Flink,     \
                                     SMBCEDB_SERVER_ENTRY,           \
                                     ServersList)))

#define SmbCeGetNextServerEntry(pServerEntry)                               \
           (((pServerEntry)->ServersList.Flink == &s_DbServers.ListHead)    \
            ? NULL                                                          \
            : (PSMBCEDB_SERVER_ENTRY)                                       \
              (CONTAINING_RECORD((pServerEntry)->ServersList.Flink,         \
                                 SMBCEDB_SERVER_ENTRY,                      \
                                 ServersList)))


// Since the mapping between V_NET_ROOT's in the RDBSS and the session entries in the mini
// redirector is a many to one mapping a collection of session entries is maintained as part
// of each server entry. The following operations are supported on the collection of session
// entries
//    1) adding a session entry to the collection
//    2) removing a session entry from the colection
//    3) enumerating the entries in the collection
//
// As in the case of the collection of requests all these operations come in two flavours
// the vanila version in which concurrency control is enforced and the lite version in
// which the concurrency control is left to the user's discretion.
//
// In addition two more methods are specified for retrieving the default session entry and
// setting the default session entry for any given server.

#define SmbCeAddSessionEntry(pServerEntry,pSessionEntry)   \
            SmbCeAcquireSpinLock();                                              \
            InsertTailList(&(pServerEntry)->Sessions.ListHead,&(pSessionEntry)->SessionsList); \
            SmbCeReleaseSpinLock()


#define SmbCeAddSessionEntryLite(pServerEntry,pSessionEntry)   \
            InsertTailList(&(pServerEntry)->Sessions.ListHead,&(pSessionEntry)->SessionsList)

#define SmbCeRemoveSessionEntry(pServerEntry,pSessionEntry)                          \
               SmbCeAcquireSpinLock();                                               \
               if ((pServerEntry)->Sessions.pDefaultSessionEntry == pSessionEntry) { \
                  (pServerEntry)->Sessions.pDefaultSessionEntry = NULL;              \
               };                                                                    \
               RemoveEntryList(&(pSessionEntry)->SessionsList);                      \
               SmbCeReleaseSpinLock()

#define SmbCeRemoveSessionEntryLite(pServerEntry,pSessionEntry)                      \
               if ((pServerEntry)->Sessions.pDefaultSessionEntry == pSessionEntry) { \
                  (pServerEntry)->Sessions.pDefaultSessionEntry = NULL;              \
               };                                                                    \
               RemoveEntryList(&(pSessionEntry)->SessionsList)


#define SmbCeGetFirstSessionEntry(pServerEntry)                                \
            (IsListEmpty(&(pServerEntry)->Sessions.ListHead)                   \
             ? NULL                                                            \
             : (PSMBCEDB_SESSION_ENTRY)                                        \
               (CONTAINING_RECORD((pServerEntry)->Sessions.ListHead.Flink,     \
                                  SMBCEDB_SESSION_ENTRY,                       \
                                  SessionsList)))

#define SmbCeGetNextSessionEntry(pServerEntry,pSessionEntry)                  \
            (((pSessionEntry)->SessionsList.Flink ==                          \
                              &(pServerEntry)->Sessions.ListHead)             \
             ? NULL                                                           \
             : (PSMBCEDB_SESSION_ENTRY)                                       \
               (CONTAINING_RECORD((pSessionEntry)->SessionsList.Flink,        \
                                  SMBCEDB_SESSION_ENTRY,                      \
                                  SessionsList)))

#define SmbCeSetDefaultSessionEntry(pServerEntry,pSessionEntry)               \
               SmbCeAcquireSpinLock();                                        \
               (pServerEntry)->Sessions.pDefaultSessionEntry = pSessionEntry; \
               SmbCeReleaseSpinLock()

#define SmbCeSetDefaultSessionEntryLite(pServerEntry,pSessionEntry)           \
               (pServerEntry)->Sessions.pDefaultSessionEntry = pSessionEntry

#define SmbCeGetDefaultSessionEntry(pServerEntry)                 \
               ((pServerEntry)->Sessions.pDefaultSessionEntry)

// In order to encapsulate the notion of reconnects and to provide for hot reconnects,
// i.e., reconnection attempts in which the saved state in the server/client prior to
// a transport level disconnect can be reused it is required to mark each net root
// entry associated with a server as invalid on receipt of a transport level disconnect.
//
// Therefore an abstraction of a collection of net root entries is provided and is associated
// with each server entry.
//
// The following operations are supported on the collection of net root entries
//    1) adding a session entry to the collection
//    2) removing a session entry from the colection
//    3) enumerating the entries in the collection
//
// As in the case of the collection of requests all these operations come in two flavours
// the vanila version in which concurrency control is enforced and the lite version in
// which the concurrency control is left to the user's discretion.
//


#define SmbCeAddNetRootEntry(pServerEntry,pNetRootEntry)   \
            SmbCeAcquireSpinLock();                                              \
            InsertTailList(&(pServerEntry)->NetRoots.ListHead,&(pNetRootEntry)->NetRootsList); \
            SmbCeReleaseSpinLock()


#define SmbCeAddNetRootEntryLite(pServerEntry,pNetRootEntry)   \
            InsertTailList(&(pServerEntry)->NetRoots.ListHead,&(pNetRootEntry)->NetRootsList)

#define SmbCeRemoveNetRootEntry(pServerEntry,pNetRootEntry)                          \
               SmbCeAcquireSpinLock();                                               \
               RemoveEntryList(&(pNetRootEntry)->NetRootsList);                      \
               SmbCeReleaseSpinLock()

#define SmbCeRemoveNetRootEntryLite(pServerEntry,pNetRootEntry)                      \
               RemoveEntryList(&(pNetRootEntry)->NetRootsList)


#define SmbCeGetFirstNetRootEntry(pServerEntry)                                \
            (IsListEmpty(&(pServerEntry)->NetRoots.ListHead)                   \
             ? NULL                                                            \
             : (PSMBCEDB_NET_ROOT_ENTRY)                                       \
               (CONTAINING_RECORD((pServerEntry)->NetRoots.ListHead.Flink,     \
                                  SMBCEDB_NET_ROOT_ENTRY,                      \
                                  NetRootsList)))

#define SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry)                  \
            (((pNetRootEntry)->NetRootsList.Flink ==                          \
                              &(pServerEntry)->NetRoots.ListHead)             \
             ? NULL                                                           \
             : (PSMBCEDB_NET_ROOT_ENTRY)                                      \
               (CONTAINING_RECORD((pNetRootEntry)->NetRootsList.Flink,        \
                                  SMBCEDB_NET_ROOT_ENTRY,                     \
                                  NetRootsList)))

//
// SmbCe database initialization
//

extern NTSTATUS
SmbCeDbInit();

extern VOID
SmbCeDbTearDown();

//
// Object allocation and deallocation
//

extern PSMBCE_OBJECT_HEADER
SmbCeDbAllocateObject(
      SMBCEDB_OBJECT_TYPE ObjectType);

extern VOID
SmbCeDbFreeObject(
      PVOID pObject);

//
// Object destruction
//

extern VOID
SmbCeTearDownServerEntry(PSMBCEDB_SERVER_ENTRY pServerEntry);

extern VOID
SmbCeTearDownNetRootEntry(PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry);

extern VOID
SmbCeTearDownSessionEntry(PSMBCEDB_SESSION_ENTRY pSessionEntry);

extern VOID
SmbCeTearDownRequestEntry(PSMBCEDB_REQUEST_ENTRY pRequestEntry);

//
// The routines for mapping a MID with an exchange and for associating an exchange with
// a MID
//

extern NTSTATUS
SmbCeAssociateExchangeWithMid(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   struct _SMB_EXCHANGE  *pExchange);

extern struct _SMB_EXCHANGE *
SmbCeMapMidToExchange(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   SMB_MPX_ID            Mid);

extern NTSTATUS
SmbCeDisassociateMidFromExchange(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   struct _SMB_EXCHANGE  *pExchange);

extern struct _SMB_EXCHANGE *
SmbCeGetExchangeAssociatedWithBuffer(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   PVOID                 pBuffer);

extern NTSTATUS
SmbCeAssociateBufferWithExchange(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   struct _SMB_EXCHANGE * pExchange,
   PVOID                 pBuffer);

extern VOID
SmbCePurgeBuffersAssociatedWithExchange(
   PSMBCEDB_SERVER_ENTRY  pServerEntry,
   struct _SMB_EXCHANGE * pExchange);

//
// Routines for handling transport disconnects/invalidation.
//

extern VOID
SmbCeTransportDisconnectIndicated(
      PSMBCEDB_SERVER_ENTRY pServerEntry);


extern VOID
SmbCeResumeAllOutstandingRequestsOnError(
   PSMBCEDB_SERVER_ENTRY pServerEntry);

extern VOID
SmbCeHandleTransportInvalidation(
   struct _SMBCE_TRANSPORT_ *pTransport);


//
// Resource acquistion/release
//

#define SmbCeAcquireResource() ExAcquireResourceExclusiveLite(&s_SmbCeDbResource,TRUE)

#define SmbCeReleaseResource() ExReleaseResourceLite(&s_SmbCeDbResource)

#define SmbCeAcquireSpinLock() \
                KeAcquireSpinLock(&s_SmbCeDbSpinLock,&s_SmbCeDbSpinLockSavedIrql);   \
                s_SmbCeDbSpinLockAcquired = TRUE

#define SmbCeReleaseSpinLock()   \
                s_SmbCeDbSpinLockAcquired = FALSE;                                  \
                KeReleaseSpinLock(&s_SmbCeDbSpinLock,s_SmbCeDbSpinLockSavedIrql)

#define SmbCeSpinLockAcquired()   \
                (s_SmbCeDbSpinLockAcquired == TRUE)

//
// Tests for asserting the status of the resource. BUGBUG -- not yet done.
//

#define AssertServerResourceAcquired(pServerEntry)

//INLINE BOOLEAN SmbCeDbIsEntryInUse(PSMBCE_OBJECT_HEADER pHeader)
/*++

Routine Description:

    This routine determines if a SmbCe database entry is in use.

Arguments:

    pHeader - the entry header

Return Value:

    TRUE if the entry is in use otherwise FALSE

--*/

#define SmbCeIsEntryInUse(pHeader)                                                   \
                  (((PSMBCE_OBJECT_HEADER)(pHeader))->State == SMBCEDB_ACTIVE  ||    \
                   ((PSMBCE_OBJECT_HEADER)(pHeader))->State == SMBCEDB_INVALID ||    \
                   ((PSMBCE_OBJECT_HEADER)(pHeader))->State == SMBCEDB_CONSTRUCTION_IN_PROGRESS)


#define SmbCeSetServerType(pServerEntry,ServerType) \
           (pServerEntry)->Header.Flags = (UCHAR)(ServerType)

#define SmbCeGetServerType(pServerEntry)   \
           ((SMBCEDB_SERVER_TYPE)(pServerEntry)->Header.Flags)


//
// Static variable declarations that constitute the SmbCe database.
//

extern SMBCEDB_SERVERS     s_DbServers;

//
// Currently there is only one resource for synchronizing the access to all the
// entities in the connection engine database. It is possible to customize it
// subsequently since the acquistion/release methods take the type of the object
// as a parameter.
//

extern ERESOURCE  s_SmbCeDbResource;
extern RX_SPIN_LOCK s_SmbCeDbSpinLock;
extern KIRQL      s_SmbCeDbSpinLockSavedIrql;
extern BOOLEAN    s_SmbCeDbSpinLockAcquired;

#endif  // _SMBCEDBP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\smbadmin.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbadmin.c

Abstract:

    This module implements the SMB's that need to be exchanged to facilitate
    bookkeeping at the server

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId  (RDBSS_BUG_CHECK_SMB_NETROOT)

//
//  The local debug trace level
//

#define Dbg (DEBUG_TRACE_DISPATCH)

extern NTSTATUS
SmbCeInitializeAdminExchange(
    PSMB_ADMIN_EXCHANGE     pSmbAdminExchange,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMBCEDB_SESSION_ENTRY  pSessionEntry,
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    UCHAR                   SmbCommand);

extern VOID
SmbCeDiscardAdminExchange(
    PSMB_ADMIN_EXCHANGE pSmbAdminExchange);

extern NTSTATUS
SmbCeCompleteAdminExchange(
    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange);




NTSTATUS
SmbCeNegotiate(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PMRX_SRV_CALL         pSrvCall)
/*++

Routine Description:

    This routine issues the negotiate SMB to the server

Arguments:

    pServerEntry - the server entry

    pSrvCall     - the associated srv call instance in the wrapper

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    Since the negotiate SMB can be directed at either a unknown server or a server
    whose capabilitiese are known it is upto the caller to decide to wait for the
    response.

    On some transports a reconnect is possible without having to tear down an existing
    connection, i.e. attempting to send a packet reestablishes the connection at the
    lower level. Since this is not supported by all the transports ( with the exception
    of TCP/IP) the reference server entry initiates this process by tearing down the
    existing transport and reinitializsing it.

    As part of the negotiate response the domain name to which the server belongs is
    sent back. Since the negotiate response is processed at DPC level, a preparatory
    allocation needs to be made ( This will ensure minimal work at DPC level).

    In this routine this is accomplished by allocating a buffer from nonpaged
    pool of MAX_PATH and associating it with the DomainName fild in the server entry
    prior to the TRanceive. On resumption from Tranceive this buffer is deallocated and
    a buffer from paged pool corresponding to the exact length is allocated to hold the
    domain name.

--*/
{
    NTSTATUS Status;

    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange;

    ULONG    NegotiateSmbLength;
    PVOID    pNegotiateSmb;

    PAGED_CODE();

    //
    // Allocate an exchange for this negotiation
    //

    pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)SmbMmAllocateExchange(ADMIN_EXCHANGE,NULL);

    if (pSmbAdminExchange != NULL)
    {

        //
        // Bump the Server Entry reference count, make the exchange and Administrative
        // exchange, and build the negotiate SMB
        //

        SmbCeReferenceServerEntry(pServerEntry);

        Status = SmbCeInitializeAdminExchange(
                     pSmbAdminExchange,
                     pServerEntry,
                     NULL,
                     NULL,
                     SMB_COM_NEGOTIATE);

        if (Status == STATUS_SUCCESS) {

            //
            // Build the negotiate SMB and allocate the temporary buffer for
            // the DOMAIN name.
            //

            Status = BuildNegotiateSmb(
                         &pNegotiateSmb,
                         &NegotiateSmbLength);

            if (Status == STATUS_SUCCESS) {
                pSmbAdminExchange->pSmbBuffer      = pNegotiateSmb;
                pSmbAdminExchange->SmbBufferLength = NegotiateSmbLength;

                // Preparatory allocation for the domain name buffer

                pSmbAdminExchange->Negotiate.pSrvCall                 = pSrvCall;
                pSmbAdminExchange->Negotiate.DomainName.Length        = 0;
                pSmbAdminExchange->Negotiate.DomainName.MaximumLength = MAX_PATH;
                pSmbAdminExchange->Negotiate.DomainName.Buffer
                    = (PWCHAR)RxAllocatePoolWithTag(
                                  NonPagedPool,
                                  MAX_PATH,
                                  MRXSMB_ADMIN_POOLTAG);

                if (pSmbAdminExchange->Negotiate.DomainName.Buffer == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }

        if (Status == STATUS_SUCCESS) {
            SMBCE_RESUMPTION_CONTEXT ResumptionContext;

            SmbCeInitializeResumptionContext(&ResumptionContext);
            pSmbAdminExchange->pResumptionContext = &ResumptionContext;

            // Since the Negotiate SMB is the first SMB that is sent on a
            // connection the MID mapping data structures have not been setup.
            // Therefore a certain amount of additional initialization is
            // required to ensure that the Negotiate SMB can be handled correctly.
            // This involves presetting the MID field in the header and the
            // SMBCE_EXCHANGE_MID_VALID field in the exchange.
            //
            // A beneficial side effect of implementing it this way is the reduced
            // path length for the regular Send/Receives on a connection.

            pSmbAdminExchange->SmbCeFlags = (SMBCE_EXCHANGE_REUSE_MID  |
                                             SMBCE_EXCHANGE_RETAIN_MID |
                                             SMBCE_EXCHANGE_MID_VALID);

            SmbCeAcquireSpinLock();

            if (pServerEntry->Header.State != SMBCEDB_CONSTRUCTION_IN_PROGRESS) {
                Status = STATUS_CONNECTION_DISCONNECTED;
            } else {
                pServerEntry->pNegotiateExchange = (PSMB_EXCHANGE)pSmbAdminExchange;
                Status = STATUS_SUCCESS;
            }

            SmbCeReleaseSpinLock();

            if (Status == STATUS_SUCCESS) {
                // The Negotiate SMB exchange has been built successfully. Initiate it.
                Status = SmbCeInitiateExchange((PSMB_EXCHANGE)pSmbAdminExchange);

                // Wait for the finalization.
                SmbCeSuspend(&ResumptionContext);
                Status = SmbCeCompleteAdminExchange(pSmbAdminExchange);
            } else {
                SmbCeDiscardAdminExchange(pSmbAdminExchange);
            }
        } else {
            SmbCeDiscardAdminExchange(pSmbAdminExchange);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
SmbCeDisconnect(
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMBCEDB_NET_ROOT_ENTRY  pNetRootEntry)
/*++

Routine Description:

    This routine issues the disconnect SMB for an existing connection to the server

Arguments:

    pServerEntry  - the server entry

    pNetRootEntry - the associated net root entry

Return Value:

    STATUS_SUCCESS - the disconnect SMB was sent successfully

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status;

    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange;
    PSMB_HEADER          pSmbHeader;
    PREQ_TREE_DISCONNECT pReqTreeDisconnect;

    PAGED_CODE();

    // On mailslot servers no disconnects are required.

    if (SmbCeGetServerType(pServerEntry) == SMBCEDB_MAILSLOT_SERVER) {
        return STATUS_SUCCESS;
    }

    pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)SmbMmAllocateExchange(ADMIN_EXCHANGE,NULL);
    if (pSmbAdminExchange != NULL) {
        UCHAR  LastCommandInHeader;
        PUCHAR pCommand;

        Status = SmbCeInitializeAdminExchange(
                     pSmbAdminExchange,
                     pServerEntry,
                     NULL,
                     pNetRootEntry,
                     SMB_COM_TREE_DISCONNECT);

        if (Status == STATUS_SUCCESS) {
            pSmbAdminExchange->pSmbBuffer = pSmbAdminExchange->Disconnect.DisconnectSmb;

            pSmbHeader         = (PSMB_HEADER)pSmbAdminExchange->pSmbBuffer;
            pReqTreeDisconnect = (PREQ_TREE_DISCONNECT)(pSmbHeader + 1);

            // Build the header
            Status = SmbCeBuildSmbHeader(
                         (PSMB_EXCHANGE)pSmbAdminExchange,
                         pSmbAdminExchange->pSmbBuffer,
                         sizeof(SMB_HEADER),
                         &pSmbAdminExchange->SmbBufferLength,
                         &LastCommandInHeader,
                         &pCommand);
        }

        if (Status == STATUS_SUCCESS) {
            ASSERT(LastCommandInHeader == SMB_COM_NO_ANDX_COMMAND);
            *pCommand = SMB_COM_TREE_DISCONNECT;

            pReqTreeDisconnect->WordCount = 0;
            SmbPutUshort(&pReqTreeDisconnect->ByteCount,0);

            pSmbAdminExchange->SmbBufferLength += FIELD_OFFSET(REQ_TREE_DISCONNECT,Buffer);

            Status = SmbCeInitiateExchange((PSMB_EXCHANGE)pSmbAdminExchange);
        } else {
            SmbCeDiscardAdminExchange(pSmbAdminExchange);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
SmbCeLogOff(
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMBCEDB_SESSION_ENTRY  pSessionEntry)
/*++

Routine Description:

    This routine issues the logoff SMB for an existing session to the server

Arguments:

    pServerEntry  - the server entry

    pSessionEntry - the associated session entry

Return Value:

    STATUS_SUCCESS - the logoff was successfully sent.

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status;

    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange;
    PSMB_HEADER          pSmbHeader;
    PREQ_LOGOFF_ANDX     pReqLogOffAndX;

    PAGED_CODE();

    if ((SmbCeGetServerType(pServerEntry) == SMBCEDB_MAILSLOT_SERVER) ||
        (pServerEntry->Server.SecurityMode == SECURITY_MODE_SHARE_LEVEL)) {

        // On mailslot servers no logoffs are required.
        // for lanman10 and better, you send a sessionsetup to finish the negotiate even for
        // share level....BUT these servers do not do logoffs

        SmbCeDereferenceServerEntry(pServerEntry);
        return STATUS_SUCCESS;
    }

    pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)SmbMmAllocateExchange(ADMIN_EXCHANGE,NULL);
    if (pSmbAdminExchange != NULL) {
        UCHAR  LastCommandInHeader;
        PUCHAR pCommand;

        Status = SmbCeInitializeAdminExchange(
                     pSmbAdminExchange,
                     pServerEntry,
                     pSessionEntry,
                     NULL,
                     SMB_COM_LOGOFF_ANDX);

        if (Status == STATUS_SUCCESS) {
            pSmbAdminExchange->pSmbBuffer = pSmbAdminExchange->LogOff.LogOffSmb;

            pSmbHeader         = (PSMB_HEADER)pSmbAdminExchange->pSmbBuffer;
            pReqLogOffAndX     = (PREQ_LOGOFF_ANDX)(pSmbHeader + 1);

            // Build the header
            Status = SmbCeBuildSmbHeader(
                         (PSMB_EXCHANGE)pSmbAdminExchange,
                         pSmbAdminExchange->pSmbBuffer,
                         sizeof(SMB_HEADER),
                         &pSmbAdminExchange->SmbBufferLength,
                         &LastCommandInHeader,
                         &pCommand);
        }

        if (Status == STATUS_SUCCESS) {
            ASSERT(LastCommandInHeader == SMB_COM_NO_ANDX_COMMAND);
            *pCommand = SMB_COM_LOGOFF_ANDX;

            pReqLogOffAndX->WordCount    = 2;
            pReqLogOffAndX->AndXCommand  = SMB_COM_NO_ANDX_COMMAND;
            pReqLogOffAndX->AndXReserved = 0;

            SmbPutUshort(&pReqLogOffAndX->AndXOffset,0);
            SmbPutUshort(&pReqLogOffAndX->ByteCount,0);

            pSmbAdminExchange->SmbBufferLength += FIELD_OFFSET(REQ_LOGOFF_ANDX,Buffer);

            Status = SmbCeInitiateExchange((PSMB_EXCHANGE)pSmbAdminExchange);
        } else {
            SmbCeDiscardAdminExchange(pSmbAdminExchange);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
SmbCeInitializeAdminExchange(
    PSMB_ADMIN_EXCHANGE     pSmbAdminExchange,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMBCEDB_SESSION_ENTRY  pSessionEntry,
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    UCHAR                   SmbCommand)
/*++

Routine Description:

    This routine initializes the ADMIN exchange

Arguments:

    pSmbAdminExchange  - the exchange

    pServerEntry       - the associated server entry

    pSessionEntry      - the associated session entry

    pNetRootEntry      - the associated net root entry

    SmbCommand         - the SMB command

Return Value:

    STATUS_SUCCESS - the logoff was successfully sent.

    Other Status codes correspond to error situations.

Notes:

    The ADMIN_EXCHANGE is a special type of exchange used for bootstrap/teardown
    situations in which the initialization of the exchange cannot follow the noraml
    course of events. In some cases not all the components required for proper
    initialization of the exchange are present, e.g., NEGOTIATE we do not have a
    valid session/tree connect. It is for this reason that the three important
    elements of initialization, i.e., Server/Session/NetRoot have to be explicitly
    specified. NULL is used to signify a dont care situation for a particular component.

--*/
{
    NTSTATUS Status;

    Status = SmbCeIncrementActiveExchangeCount();

    if (Status == STATUS_SUCCESS) {

        pSmbAdminExchange->SmbCeContext.pServerEntry  = pServerEntry;
        pSmbAdminExchange->SmbCeContext.pSessionEntry = pSessionEntry;
        pSmbAdminExchange->SmbCeContext.pNetRootEntry = pNetRootEntry;

        pSmbAdminExchange->pSmbMdl    = NULL;
        pSmbAdminExchange->pSmbBuffer = NULL;
        pSmbAdminExchange->SmbBufferLength = 0;

        // Set the SmbCe state to overrule the common method of having to hunt
        // up a valid TID/FID etc. and reconnects.
        pSmbAdminExchange->SmbCommand = SmbCommand;
        pSmbAdminExchange->SmbCeState = SMBCE_EXCHANGE_NETROOT_INITIALIZED;

        switch (pSmbAdminExchange->SmbCommand) {
        case SMB_COM_NEGOTIATE:
            {
                pSmbAdminExchange->Negotiate.DomainName.Length = 0;
                pSmbAdminExchange->Negotiate.DomainName.MaximumLength = 0;
                pSmbAdminExchange->Negotiate.DomainName.Buffer = NULL;
            }
            break;

        case SMB_COM_TREE_DISCONNECT:
        case SMB_COM_LOGOFF_ANDX:
            break;

        default:
            ASSERT(!"Valid Command for Admin Exchange");
            break;
        }
    }

    return Status;
}

VOID
SmbCeDiscardAdminExchange(
    PSMB_ADMIN_EXCHANGE pSmbAdminExchange)
/*++

Routine Description:

    This routine discards the ADMIN exchange

Arguments:

    pSmbAdminExchange  - the exchange

--*/
{
    PSMBCEDB_SERVER_ENTRY   pServerEntry;
    PSMBCEDB_SESSION_ENTRY  pSessionEntry;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    pServerEntry  = pSmbAdminExchange->SmbCeContext.pServerEntry;
    pSessionEntry = pSmbAdminExchange->SmbCeContext.pSessionEntry;
    pNetRootEntry = pSmbAdminExchange->SmbCeContext.pNetRootEntry;

    // Tear down all the copy data requests associated with this exchange
    SmbCePurgeBuffersAssociatedWithExchange(pServerEntry,(PSMB_EXCHANGE)pSmbAdminExchange);

    SmbCeUninitializeExchangeTransport((PSMB_EXCHANGE)pSmbAdminExchange);
    SmbCeDereferenceServerEntry(pServerEntry);

    if (pSmbAdminExchange->pSmbMdl != NULL) {
        MmUnlockPages(pSmbAdminExchange->pSmbMdl);
        IoFreeMdl(pSmbAdminExchange->pSmbMdl);
    }

    switch (pSmbAdminExchange->SmbCommand) {
    case SMB_COM_NEGOTIATE:
        {
            pSmbAdminExchange->pSmbBuffer = NULL;

            if (pSmbAdminExchange->Negotiate.DomainName.Buffer != NULL) {
                RxFreePool(
                    pSmbAdminExchange->Negotiate.DomainName.Buffer);
            }
        }
        break;

    case SMB_COM_TREE_DISCONNECT:
        {
            SmbCeUpdateNetRootEntryState(pNetRootEntry,SMBCEDB_MARKED_FOR_DELETION);
            SmbCeTearDownNetRootEntry(pNetRootEntry);
        }
        break;

    case SMB_COM_LOGOFF_ANDX:
        {
            SmbCeUpdateSessionEntryState(pSessionEntry,SMBCEDB_MARKED_FOR_DELETION);
            SmbCeTearDownSessionEntry(pSessionEntry);
        }
        break;

    default:
        ASSERT(!"Valid Command For Admin Exchange");
        break;
    }

    SmbMmFreeExchange((PSMB_EXCHANGE)pSmbAdminExchange);
    SmbCeDecrementActiveExchangeCount();
}

NTSTATUS
SmbCeCompleteAdminExchange(
    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange)
/*++

Routine Description:

    This is the routine used for completing the SMB ADMIN exchanges.

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    This routine encapsulates the TAIL for all SMB admin exchanges. They carry
    out the local action required based upon the outcome of the exchange.

--*/
{
    NTSTATUS              Status = STATUS_SUCCESS;
    PSMBCEDB_SERVER_ENTRY pServerEntry;
    SMBCEDB_OBJECT_STATE  ServerState;

    pServerEntry = pSmbAdminExchange->SmbCeContext.pServerEntry;

    switch (pSmbAdminExchange->SmbCommand) {
    case SMB_COM_NEGOTIATE:
        {
            pServerEntry->pNegotiateExchange = NULL;

            if (pServerEntry->ServerStatus == STATUS_SUCCESS) {
                // Copy the domain name into the server entry
                pServerEntry->ServerStatus =
                    RxSetSrvCallDomainName(
                        pSmbAdminExchange->Negotiate.pSrvCall,
                        &pSmbAdminExchange->Negotiate.DomainName);
            }

            if (pServerEntry->ServerStatus == STATUS_SUCCESS) {
                ServerState = SMBCEDB_ACTIVE;
            } else {
                ServerState = SMBCEDB_MARKED_FOR_DELETION;
            }

            SmbCeUpdateServerEntryState(pServerEntry,ServerState);
            SmbCeCompleteServerEntryInitialization(pServerEntry);
        }
        break;

    case SMB_COM_TREE_DISCONNECT:
    case SMB_COM_LOGOFF_ANDX:
    default:
        break;
    }

    SmbCeDiscardAdminExchange(pSmbAdminExchange);

    return Status;
}

NTSTATUS
SmbAdminExchangeStart(
    PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

    This is the start routine for administrative SMB exchanges.

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS   Status;

    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange;

    pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)pExchange;

    ASSERT(pSmbAdminExchange->pSmbMdl == NULL);
    pSmbAdminExchange->pSmbMdl = RxAllocateMdl(
                                     pSmbAdminExchange->pSmbBuffer,
                                     pSmbAdminExchange->SmbBufferLength);

    if (pSmbAdminExchange->pSmbMdl != NULL) {
        RxProbeAndLockPages(
            pSmbAdminExchange->pSmbMdl,
            KernelMode,
            IoModifyAccess,
            Status);

        Status = SmbCeTranceive(
                     pExchange,
                     RXCE_SEND_SYNCHRONOUS,
                     pSmbAdminExchange->pSmbMdl,
                     pSmbAdminExchange->SmbBufferLength);

        RxDbgTrace( 0, Dbg, ("Net Root SmbCeTranceive returned %lx\n",Status));
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
SmbAdminExchangeReceive(
    IN struct _SMB_EXCHANGE *pExchange,    // The exchange instance
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT ULONG               *pBytesTaken,
    IN  PSMB_HEADER         pSmbHeader,
    OUT PMDL          *pDataBufferPointer,
    OUT PULONG              pDataSize)
/*++

Routine Description:

    This is the recieve indication handling routine for net root construction exchanges

Arguments:

    pExchange - the exchange instance

    BytesIndicated - the number of bytes indicated

    Bytes Available - the number of bytes available

    pBytesTaken     - the number of bytes consumed

    pSmbHeader      - the byte buffer

    pDataBufferPointer - the buffer into which the remaining data is to be copied.

    pDataSize       - the buffer size.

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    This routine is called at DPC level.

--*/
{
    NTSTATUS             Status;
    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange;

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesIndicated/Available %ld %ld\n",BytesIndicated,BytesAvailable));

    pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)pExchange;

    switch (pSmbAdminExchange->SmbCommand) {
    case SMB_COM_NEGOTIATE:
        {
            PSMBCEDB_SERVER_ENTRY pServerEntry;

            pServerEntry = pSmbAdminExchange->SmbCeContext.pServerEntry;
            pServerEntry->ServerStatus = ParseNegotiateResponse(
                                             &pServerEntry->Server,
                                             &pSmbAdminExchange->Negotiate.DomainName,
                                             pSmbHeader,
                                             BytesIndicated,
                                             pBytesTaken);
            Status = STATUS_SUCCESS;
        }
        break;

    case SMB_COM_TREE_DISCONNECT:
    case SMB_COM_LOGOFF_ANDX:
        {
            *pBytesTaken = BytesAvailable;
            Status       = STATUS_SUCCESS;
        }
        break;

    default:
        {
            ASSERT(!"Valid SMB Command For Admin Exchnage");
            *pBytesTaken = 0;
            Status       = STATUS_DATA_NOT_ACCEPTED;
        }
        break;
    }

    return Status;
}

NTSTATUS
SmbAdminExchangeCopyDataHandler(
    IN PSMB_EXCHANGE 	pExchange,    // The exchange instance
    IN PMDL             pCopyDataBuffer,
    IN ULONG            DataSize)
/*++

Routine Description:

    This is the copy data handling routine for administrative SMB exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    UNREFERENCED_PARAMETER(pExchange);
    return STATUS_SUCCESS;
}

NTSTATUS
SmbAdminExchangeFinalize(
    PSMB_EXCHANGE pExchange,
    BOOLEAN       *pPostFinalize)
/*++

Routine Description:

    This routine finalkzes the construct net root exchange. It resumes the RDBSS by invoking
    the call back and discards the exchange

Arguments:

    pExchange - the exchange instance

    CurrentIrql - the current interrupt request level

    pPostFinalize - a pointer to a BOOLEAN if the request should be posted

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)pExchange;

    if (pSmbAdminExchange->pResumptionContext != NULL) {
        // Signal the event
        *pPostFinalize = FALSE;
        SmbCeResume(pSmbAdminExchange->pResumptionContext);
    } else {
        if (RxShouldPostCompletion()) {
            *pPostFinalize = TRUE;
            return STATUS_SUCCESS;
        } else {
            *pPostFinalize = FALSE;
            SmbCeCompleteAdminExchange(pSmbAdminExchange);
        }
    }

   return STATUS_SUCCESS;
}

SMB_EXCHANGE_DISPATCH_VECTOR
AdminExchangeDispatch = {
                            SmbAdminExchangeStart,
                            SmbAdminExchangeReceive,
                            SmbAdminExchangeCopyDataHandler,
                            NULL,                            // No Send Completion handler
                            SmbAdminExchangeFinalize
                        };





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\smbcedb.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbcedb.c

Abstract:

    This module implements all functions related to accessing the SMB connection engine
    database

Notes:

    The construction of server, net root and session entries involve a certain amount of
    network traffic. Therefore, all these entities are constructed using a two phase protocol

    This continuation context is that of the RDBSS during construction of srv call and
    net root entries. For the session entries it is an SMB exchange that needs to be resumed.

    The three primary data structures in the SMB mini redirector, i.e., SMBCEDB_SERVER_ENTRY,
    SMBCEDB_SESSION_ENTRY and SMBCEDB_NET_ROOT_ENTRY  and their counterparts in the RDBSS
    (MRX_SRV_CALL, MRX_V_NET_ROOT and MRX_NET_ROOT) constitute the core of the SMB mini
    redirector connection engine. There exists a one to one mapping between the SERVER_ENTRY
    and the MRX_SRV_CALL, as well as NET_ROOT_ENTRY and MRX_NET_ROOT.

    On the other hand the mapping between MRX_V_NET_ROOT and SMBCEDB_SESSION_ENTRY is a many to
    one relationship, i.e., more than one MRX_V_NET_ROOT instance can be associated with the
    same SMBCEDB_SESSION_ENTRY. More than one tree connect to a server can use the same session
    on a USER level security share. Consequently mapping rules need to be established to
    manage this relationship. The SMB mini redirector implements the following rules ...

         1) The first session with explicitly specified credentials will be treated as the
         default session for all subsequent requests to any given server unless credentials
         are explicitly specified for the new session.

         2) If no session with explicitly specified credentials exist then a session with
         the same logon id. is choosen.

         3) If no session with the same logon id. exists a new session is created.

    These rules are liable to change as we experiment with rules for establishing sessions
    with differing credentials to a given server. The problem is not with creating/manipulating
    these sessions but providing an adequate set of fallback rules for emulating the behaviour
    of the old redirector.

    These rules are implemented in SmbCeInitializeSessionEntry.

--*/

#include "precomp.h"
#pragma hdrstop


#include "secext.h"

RXDT_DefineCategory(SMBCEDB);
#define Dbg        (DEBUG_TRACE_SMBCEDB)

// The flag mask to control reference count tracing.

ULONG MRxSmbReferenceTracingValue = 0;

NTSTATUS
SmbCeInitializeServerEntry(
    PMRX_SRV_CALL                 pSrvCall,
    PMRX_SRVCALL_CALLBACK_CONTEXT pCallbackContext)
/*++

Routine Description:

    This routine opens/creates a server entry in the connection engine database

Arguments:

    pSrvCall           - the SrvCall instance

    pCallbackContext   - the RDBSS context

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PSMBCEDB_SERVER_ENTRY pServerEntry   = NULL;
    SMBCEDB_SERVER_TYPE   ServerType;


    ASSERT(pSrvCall->Context == NULL);

    ServerType = (pSrvCall->Flags & SRVCALL_FLAG_MAILSLOT_SERVER)
                 ? SMBCEDB_MAILSLOT_SERVER
                 : SMBCEDB_FILE_SERVER;

    // Create a server instance, initialize its state, add it to the list
    // release the resources and rsume with the process of negotiating with
    // the server.

    pServerEntry = (PSMBCEDB_SERVER_ENTRY)SmbMmAllocateObject(SMBCEDB_OT_SERVER);

    if (pServerEntry != NULL) {

        //
        // If the allocation succeeded, bump the reference count, and add the
        // new server to the list of servers.
        //

        SmbCeReferenceServerEntry(pServerEntry);
        SmbCeAddServerEntry(pServerEntry);
        pServerEntry->pRdbssSrvCall = pSrvCall;

        if (ServerType != SMBCEDB_MAILSLOT_SERVER)
        {

            pServerEntry->Header.State = SMBCEDB_CONSTRUCTION_IN_PROGRESS;
            SmbCeSetServerType(pServerEntry,SMBCEDB_FILE_SERVER);
        }
        else
        {
            pServerEntry->Header.State = SMBCEDB_ACTIVE;
            SmbCeSetServerType(pServerEntry,SMBCEDB_MAILSLOT_SERVER);
        }

        Status = SmbCeInitializeServerTransport(pServerEntry);

        //
        // Send the negotiate SMB.
        //

        if (Status == STATUS_SUCCESS) {
            if (ServerType != SMBCEDB_MAILSLOT_SERVER) {
                Status = SmbCeNegotiate(pServerEntry,pSrvCall);
                if (Status == STATUS_SUCCESS) {
                    Status = pServerEntry->ServerStatus;
                }
            } else {
                // Initialize the mailslot server parameters.
                pServerEntry->Server.Dialect = LANMAN21_DIALECT;
                pServerEntry->Server.MaximumBufferSize = 0xffff;
            }
        } else {
            RxDbgTrace(0, Dbg, ("SmbCeOpenServer : SmbCeInitializeTransport returned %lx\n",Status));
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        RxDbgTrace(0, Dbg, ("SmbCeOpenServer : Server Entry Allocation failed\n"));
    }

    if ((Status != STATUS_SUCCESS) &&
        (pServerEntry != NULL)) {
        SmbCeDereferenceServerEntry(pServerEntry);
    } else {
        // Initialize the SrvCall flags based upon the capabilities of the remote
        // server. The only flag that the SMB mini redirector updates is the
        // SRVCALL_FLAG_DFS_AWARE
        if ((pServerEntry != NULL) &&
            (pServerEntry->Server.Capabilities & CAP_DFS)) {
            SetFlag(pSrvCall->Flags,SRVCALL_FLAG_DFS_AWARE_SERVER);
        }

        pCallbackContext->RecommunicateContext = pServerEntry;
    }

    ASSERT(Status != STATUS_PENDING);
    return Status;
}

VOID
SmbCeCompleteServerEntryInitialization(
    PVOID  pContext)
/*++

Routine Description:

    This routine is invoked in the context of a worker thread to finalize the
    construction of a server entry

Arguments:

    pContext  - the server entry to be finalized

--*/
{
    NTSTATUS                ServerStatus;
    ULONG                   ServerState;
    PSMBCEDB_SERVER_ENTRY   pServerEntry = (PSMBCEDB_SERVER_ENTRY)pContext;

    SMBCEDB_REQUESTS        ReconnectRequests;
    PSMBCEDB_REQUEST_ENTRY  pRequestEntry;

    KIRQL                   SavedIrql;

    RxDbgTrace( 0, Dbg, ("Server Entry Finalization\n"));
    ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

    InitializeListHead(&ReconnectRequests.ListHead);

    // Acquire the SMBCE resource
    SmbCeAcquireResource();
    SmbCeAcquireSpinLock();

    ServerStatus = pServerEntry->ServerStatus;
    ServerState  = pServerEntry->Header.State;

    // Weed out all the reconnect requests so that they can be resumed
    pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->OutstandingRequests);
    while (pRequestEntry != NULL) {
        if (pRequestEntry->GenericRequest.Type == RECONNECT_REQUEST) {
            PSMBCEDB_REQUEST_ENTRY pTempRequestEntry;

            pTempRequestEntry = pRequestEntry;
            pRequestEntry = SmbCeGetNextRequestEntry(
                                &pServerEntry->OutstandingRequests,
                                pRequestEntry);

            SmbCeRemoveRequestEntryLite(
                &pServerEntry->OutstandingRequests,
                pTempRequestEntry);

            SmbCeAddRequestEntryLite(
                &ReconnectRequests,
                pTempRequestEntry);
        } else {
            pRequestEntry = SmbCeGetNextRequestEntry(
                                &pServerEntry->OutstandingRequests,
                                pRequestEntry);
        }
    }

    SmbCeReleaseSpinLock();

    if ((ServerState == SMBCEDB_ACTIVE) && (ServerStatus == STATUS_SUCCESS)) {
        InterlockedIncrement(&pServerEntry->Server.Version);

        ASSERT(pServerEntry->pMidAtlas == NULL);

        // Initialize the MID Atlas
        pServerEntry->pMidAtlas = IfsMrxCreateMidAtlas(
                                       pServerEntry->Server.MaximumRequests,
                                       pServerEntry->Server.MaximumRequests);

        if (pServerEntry->pMidAtlas == NULL) {
            pServerEntry->ServerStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    // Release the resource for the server entry
    SmbCeReleaseResource();

    // Resume all the outstanding reconnect requests that were held up because an earlier
    // reconnect request was under way.
    // Iterate over the list of pending requests and resume all of them
    pRequestEntry = SmbCeGetFirstRequestEntry(&ReconnectRequests);
    while (pRequestEntry != NULL) {
        NTSTATUS       Status;
        PSMB_EXCHANGE pExchange = pRequestEntry->ReconnectRequest.pExchange;

        DbgPrint("Resuming outstanding reconnect request exchange %lx \n",pExchange);
        // Resume the exchange after completing the server initialization for it.
        // This can be done concurrently for all the outstanding requests since
        // each exchange completion can take a while.

        if (ServerStatus == STATUS_SUCCESS) {
            pExchange->SmbCeContext.pServerEntry = pServerEntry;
            pExchange->SmbCeState = SMBCE_EXCHANGE_SERVER_INITIALIZED;
        } else {
            RxDbgTrace( 0, Dbg, ("Resuming exchange%lx with error\n",pExchange));
            pExchange->Status = ServerStatus;
        }

        // Resume the exchange.
        if (pRequestEntry->Request.pExchange->pSmbCeSynchronizationEvent == NULL) {
            if (ServerState == SMBCEDB_ACTIVE) {
                Status = SmbCeInitiateExchange(pExchange);
            } else {
                // Invoke the error handler
                RxDbgTrace( 0, Dbg, ("Resuming exchange%lx with error\n",pRequestEntry->Request.pExchange));
                SmbCeFinalizeExchange(pExchange);
            }
        } else {
            KeSetEvent(
                pRequestEntry->Request.pExchange->pSmbCeSynchronizationEvent,
                0,
                FALSE);
        }

        // Delete the request entry
        SmbCeRemoveRequestEntryLite(&ReconnectRequests,pRequestEntry);

        // Tear down the continuation entry
        SmbCeTearDownRequestEntry(pRequestEntry);

        // Skip to the next one.
        pRequestEntry = SmbCeGetFirstRequestEntry(&ReconnectRequests);
    }
}


VOID
SmbCepDereferenceServerEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine dereferences a server entry instance

Arguments:

    pServerEntry - the server entry to be dereferenced

--*/
{
    if (pServerEntry != NULL) {
        BOOLEAN fTearDownEntry = FALSE;
        LONG    FinalRefCount;

        ASSERT((pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER) &&
               (pServerEntry->Header.SwizzleCount > 0));

        MRXSMB_PRINT_REF_COUNT(SERVER_ENTRY,pServerEntry->Header.SwizzleCount);

        SmbCeAcquireSpinLock();

        FinalRefCount = InterlockedDecrement(&pServerEntry->Header.SwizzleCount);

        // The transport has an outstanding reference. Therefore initiate the
        // teardown on a reference count of 1. If no transport is associated
        // with the server entry initiate it on a ref count of zero.
        if (pServerEntry->Header.State != SMBCEDB_MARKED_FOR_DELETION) {
            fTearDownEntry = (FinalRefCount == 0);
        }

        if (fTearDownEntry) {
            pServerEntry->Header.State = SMBCEDB_MARKED_FOR_DELETION;
            SmbCeRemoveServerEntryLite(pServerEntry);
        }

        SmbCeReleaseSpinLock();

        if (fTearDownEntry) {
            SmbCeTearDownServerEntry(pServerEntry);
        }
    }
}

VOID
SmbCeTearDownServerEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine tears down a server entry instance

Arguments:

    pServerEntry - the server entry to be dereferenced

--*/
{
    ASSERT(pServerEntry->Header.State == SMBCEDB_MARKED_FOR_DELETION);
    if (pServerEntry->pMidAtlas != NULL) {
        IfsMrxDestroyMidAtlas(pServerEntry->pMidAtlas,NULL);
        pServerEntry->pMidAtlas = NULL;
    }

    if (pServerEntry->pTransport != NULL) {
        SmbCeUninitializeServerTransport(pServerEntry);
    }

    SmbMmFreeObject(pServerEntry);
}

NTSTATUS
SmbCeInitializeSessionEntry(
    PMRX_V_NET_ROOT pVNetRoot)
/*++

Routine Description:

    This routine opens/creates a session for a given user in the connection engine database

Arguments:

    pVNetRoot - the RDBSS Virtual net root instance

Return Value:

    STATUS_SUCCESS - if successful

    Other Status codes correspond to error situations.

Notes:

    Please refer to the header of this module for a detailed description of the rules
    for associating session entries with V_NET_ROOT's.

    This routine assumes that the necesary concurreny control mechanism has already
    been taken.

--*/
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PSMBCEDB_SERVER_ENTRY   pServerEntry  = NULL;
    PSMBCEDB_SESSION_ENTRY  pSessionEntry = NULL;
    BOOLEAN                 fSessionEntryFound = FALSE;
    BOOLEAN                 fUserCredentialsSpecified;

    fUserCredentialsSpecified = ((pVNetRoot->pUserName != NULL) || (pVNetRoot->pPassword != NULL));

    SmbCeAcquireResource();

    // Reference the server handle
    pServerEntry = SmbCeReferenceAssociatedServerEntry(pVNetRoot->pNetRoot->pSrvCall);
    if (pServerEntry != NULL) {
        if (!fUserCredentialsSpecified) {
            SmbCeAcquireSpinLock();
            // Rule No. 1
            // 1) The first session with explicitly specified credentials will be treated as the
            // default session for all subsequent requests to any given server.
            pSessionEntry = SmbCeGetDefaultSessionEntry(pServerEntry);

            if (pSessionEntry == NULL) {
                // Rule No. 2
                // 2) If no session with explicitly specified credentials exist then a session with
                // the same logon id. is choosen.
                //
                // Enumerate the sessions to detect if a session satisfying rule 2 exists

                pSessionEntry = SmbCeGetFirstSessionEntry(pServerEntry);
                while (pSessionEntry != NULL) {
                    if (RtlCompareMemory(
                            &pSessionEntry->Session.LogonId,
                            &pVNetRoot->LogonId,
                            sizeof(pSessionEntry->Session.LogonId))) {
                        break;
                    }
                    pSessionEntry = SmbCeGetNextSessionEntry(pServerEntry,pSessionEntry);
                }
            }

            if (pSessionEntry != NULL) {
                SmbCeReferenceSessionEntry(pSessionEntry);
            }

            SmbCeReleaseSpinLock();
        } else {
            BOOLEAN SessionEntryFound = FALSE;

            SmbCeAcquireSpinLock();
            pSessionEntry = SmbCeGetFirstSessionEntry(pServerEntry);
            if (pSessionEntry != NULL) {
                SmbCeReferenceSessionEntry(pSessionEntry);
            }
            SmbCeReleaseSpinLock();

            while ((pSessionEntry != NULL) && !SessionEntryFound) {
                for (;;) {
                    PSMBCE_SESSION  pSession = &pSessionEntry->Session;

                    // For each existing session check to determine if the credentials
                    // supplied match the credentials used to construct the session.

                    if ((pVNetRoot->pUserName != NULL) &&
                        (pSession->pUserName != NULL)) {
                        if (!RtlEqualUnicodeString(
                                pVNetRoot->pUserName,
                                pSession->pUserName,
                                TRUE)) {
                            Status = STATUS_NETWORK_CREDENTIAL_CONFLICT;
                            break;
                        }
                    } else {
                        if (pSession->pUserName != pVNetRoot->pUserName) {
                            break;
                        }
                    }

                    if ((pVNetRoot->pUserDomainName != NULL) &&
                        (pSession->pUserDomainName != NULL)) {
                        if (!RtlEqualUnicodeString(
                                pVNetRoot->pUserDomainName,
                                pSession->pUserDomainName,
                                TRUE)) {
                            Status = STATUS_NETWORK_CREDENTIAL_CONFLICT;
                            break;
                        }
                    } else {
                        if (pSession->pUserDomainName != pVNetRoot->pUserDomainName) {
                            break;
                        }
                    }

                    if ((pVNetRoot->pPassword != NULL) &&
                        (pSession->pPassword != NULL)) {
                        if (!RtlEqualUnicodeString(
                                pVNetRoot->pPassword,
                                pSession->pPassword,
                                FALSE)) {
                            Status = STATUS_NETWORK_CREDENTIAL_CONFLICT;
                            break;
                        }
                    } else {
                        if (pSession->pPassword != pVNetRoot->pPassword) {
                            break;
                        }
                    }

                    // An entry that matches the credentials supplied has been found. use it.
                    SessionEntryFound = TRUE;
                    break;
                }

                if (!SessionEntryFound) {
                    if (Status == STATUS_SUCCESS) {
                        PSMBCEDB_SESSION_ENTRY pNextSessionEntry;

                        SmbCeAcquireSpinLock();
                        pNextSessionEntry = SmbCeGetNextSessionEntry(
                                                pServerEntry,
                                                pSessionEntry);
                        if (pNextSessionEntry != NULL) {
                            SmbCeReferenceSessionEntry(pNextSessionEntry);
                        }
                        SmbCeReleaseSpinLock();

                        SmbCeDereferenceSessionEntry(pSessionEntry);
                        pSessionEntry = pNextSessionEntry;
                    } else {
                        // An error situation was encountered. Terminate the iteration.
                        // Typically a set of conflicting credentials have been presented
                        SmbCeDereferenceSessionEntry(pSessionEntry);
                        pSessionEntry = NULL;
                    }
                }
            }
        }

        if ((pSessionEntry != NULL) &&
             !(pSessionEntry->Session.Flags & SMBCE_SESSION_FLAGS_PARAMETERS_ALLOCATED)) {
            // This is the point at which a many to mapping between session entries and
            // V_NET_ROOT's in the RDBSS is being established. From this point it is
            // true that the session entry can outlive the associated V_NET_ROOT entry.
            // Therefore copies of the parameters used in the session setup need be made.

            PSMBCE_SESSION  pSession = &pSessionEntry->Session;
            PUNICODE_STRING pPassword,pUserName,pUserDomainName;

            if (pSession->pPassword != NULL) {
                pPassword = (PUNICODE_STRING)
                            RxAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(UNICODE_STRING) + pSession->pPassword->Length,
                                MRXSMB_SESSION_POOLTAG);
                if (pPassword != NULL) {
                    pPassword->Buffer = (PWCHAR)((PCHAR)pPassword + sizeof(UNICODE_STRING));
                    pPassword->Length = pSession->pPassword->Length;
                    pPassword->MaximumLength = pPassword->Length;
                    RtlCopyMemory(
                        pPassword->Buffer,
                        pSession->pPassword->Buffer,
                        pPassword->Length);
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                pPassword = NULL;
            }

            if ((pSession->pUserName != NULL) &&
                (Status == STATUS_SUCCESS)) {
                pUserName = (PUNICODE_STRING)
                            RxAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(UNICODE_STRING) + pSession->pUserName->Length,
                                MRXSMB_SESSION_POOLTAG);
                if (pUserName != NULL) {
                    pUserName->Buffer = (PWCHAR)((PCHAR)pUserName + sizeof(UNICODE_STRING));
                    pUserName->Length = pSession->pUserName->Length;
                    pUserName->MaximumLength = pUserName->Length;
                    RtlCopyMemory(
                        pUserName->Buffer,
                        pSession->pUserName->Buffer,
                        pUserName->Length);
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                pUserName = NULL;
            }

            if ((pSession->pUserDomainName != NULL) &&
                (Status == STATUS_SUCCESS)) {
                pUserDomainName = (PUNICODE_STRING)
                                  RxAllocatePoolWithTag(
                                      NonPagedPool,
                                      sizeof(UNICODE_STRING) + pSession->pUserDomainName->Length,
                                      MRXSMB_SESSION_POOLTAG);
                if (pUserDomainName != NULL) {
                    pUserDomainName->Buffer = (PWCHAR)((PCHAR)pUserDomainName + sizeof(UNICODE_STRING));
                    pUserDomainName->Length = pSession->pUserDomainName->Length;
                    pUserDomainName->MaximumLength = pUserDomainName->Length;
                    RtlCopyMemory(pUserDomainName->Buffer,pSession->pUserDomainName->Buffer,pUserDomainName->Length);
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                pUserDomainName = NULL;
            }

            if (Status == STATUS_SUCCESS) {
                pSession->pUserName = pUserName;
                pSession->pUserDomainName = pUserDomainName;
                pSession->pPassword = pPassword;
                pSession->Flags |= SMBCE_SESSION_FLAGS_PARAMETERS_ALLOCATED;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                SmbCeDereferenceSessionEntry(pSessionEntry);
            }
        }

        if ((pSessionEntry == NULL) && (Status == STATUS_SUCCESS)) {
            // Rule No. 3
            // 3) If no session with the same logon id. exists a new session is created.
            //
            // Allocate a new session entry

            pSessionEntry = SmbMmAllocateSessionEntry(pServerEntry);
            if (pSessionEntry != NULL) {
                PSMBCE_SESSION pSession = & pSessionEntry->Session;

                pSessionEntry->Header.State    = SMBCEDB_START_CONSTRUCTION;
                pSessionEntry->pRdbssVNetRoot  = pVNetRoot;
                pSessionEntry->pServerEntry    = pServerEntry;

                if (pServerEntry->Server.SecurityMode == SECURITY_MODE_SHARE_LEVEL) {
                    pSessionEntry->Session.UserId = (SMB_USER_ID)SMBCE_SHARE_LEVEL_SERVER_USERID;
                }

                pSession->Flags           = 0;

                pSession->LogonId         = pVNetRoot->LogonId;
                pSession->pUserName       = pVNetRoot->pUserName;
                pSession->pPassword       = pVNetRoot->pPassword;
                pSession->pUserDomainName = pVNetRoot->pUserDomainName;

                SmbCeReferenceSessionEntry(pSessionEntry);
                SmbCeAddSessionEntry(pServerEntry,pSessionEntry);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (Status == STATUS_SUCCESS) {
            ASSERT(pVNetRoot->Context == NULL);
            pVNetRoot->Context = pSessionEntry;
        }

        SmbCeDereferenceServerEntry(pServerEntry);
    } else {
        Status = STATUS_INVALID_HANDLE;
    }

    SmbCeReleaseResource();

    return Status;
}

VOID
SmbCeCompleteSessionEntryInitialization(
    PVOID  pContext)
/*++

Routine Description:

    This routine is invoked in the context of a worker thread to finalize the
    construction of a session entry

Arguments:

    pContext  - the session entry to be activated

Notes:

    PRE_CONDITION: The session entry must have been referenced to ensure that
    even it has been finalized it will not be deleted.

--*/
{
    NTSTATUS Status;

    PSMBCEDB_SESSION_ENTRY   pSessionEntry = (PSMBCEDB_SESSION_ENTRY)pContext;
    PSMBCEDB_REQUEST_ENTRY   pRequestEntry;
    SMBCEDB_REQUESTS         Requests;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("Session Entry Finalization\n"));
    ASSERT(pSessionEntry->Header.ObjectType == SMBCEDB_OT_SESSION);

    // Acquire the SMBCE resource
    SmbCeAcquireResource();

    // Create a temporary copy of the list that can be traversed after releasing the
    // resource.
    SmbCeTransferRequests(&Requests,&pSessionEntry->Requests);

    // Release the resource for the session entry
    SmbCeReleaseResource();

    // Iterate over the list of pending requests and resume all of them
    pRequestEntry = SmbCeGetFirstRequestEntry(&Requests);
    while (pRequestEntry != NULL) {
        // Resume the exchange.
        if (pRequestEntry->Request.pExchange->pSmbCeSynchronizationEvent == NULL) {
            if (pSessionEntry->Header.State == SMBCEDB_ACTIVE) {
                Status = SmbCeInitiateExchange(pRequestEntry->Request.pExchange);
            } else {
                // Invoke the error handler
                RxDbgTrace( 0, Dbg, ("Resuming exchange%lx with error\n",pRequestEntry->Request.pExchange));
                pRequestEntry->Request.pExchange->Status = STATUS_BAD_LOGON_SESSION_STATE;
                SmbCeFinalizeExchange(pRequestEntry->Request.pExchange);
            }
        } else {
            if (pSessionEntry->Header.State == SMBCEDB_ACTIVE) {
                pRequestEntry->Request.pExchange->Status = STATUS_SUCCESS;
            } else {
                pRequestEntry->Request.pExchange->Status = STATUS_BAD_LOGON_SESSION_STATE;
            }

            KeSetEvent(
                pRequestEntry->Request.pExchange->pSmbCeSynchronizationEvent,
                0,
                FALSE);
        }

        // Delete the request entry
        SmbCeRemoveRequestEntryLite(&Requests,pRequestEntry);

        // Tear down the continuation entry
        SmbCeTearDownRequestEntry(pRequestEntry);

        // Skip to the next one.
        pRequestEntry = SmbCeGetFirstRequestEntry(&Requests);
    }

    SmbCeDereferenceSessionEntry(pSessionEntry);
}

NTSTATUS
SmbCeGetUserNameAndDomainName(
    PSMBCEDB_SESSION_ENTRY  pSessionEntry,
    PUNICODE_STRING         pUserName,
    PUNICODE_STRING         pUserDomainName)
/*++

Routine Description:

    This routine returns the user name and domain name associated with a session
    in a caller allocated buffer.

Arguments:

    pSessionEntry - the session entry to be dereferenced

    pUserName     - the User name

    pUserDomainName - the user domain name

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    NTSTATUS Status;

    PSMBCE_SESSION  pSession;
    PUNICODE_STRING pSessionUserName,pSessionDomainName;

    PSecurityUserData   pSecurityData;
    BOOLEAN             ProcessAttached;

    ASSERT(pSessionEntry != NULL);
    pSession = &pSessionEntry->Session;

    if ((pUserName == NULL) ||
        (pUserDomainName == NULL) ||
        (pUserName->MaximumLength < (UNLEN * sizeof(WCHAR))) ||
        (pUserDomainName->MaximumLength < (DNLEN * sizeof(WCHAR)))) {
        return STATUS_INVALID_PARAMETER;
    }

    Status          = STATUS_SUCCESS;
    pSecurityData   = NULL;
    ProcessAttached = FALSE;

    pSessionUserName   = pSession->pUserName;
    pSessionDomainName = pSession->pUserDomainName;

    try {
        if ((pSessionUserName == NULL) ||
            (pSessionDomainName == NULL)) {
            //  Attach to the redirector's FSP to allow us to call into the LSA.

            if (PsGetCurrentProcess() != RxGetRDBSSProcess()) {
                KeAttachProcess(RxGetRDBSSProcess());
                ProcessAttached = TRUE;
            }

            Status = GetSecurityUserInfo(
                         &pSession->LogonId,
                         UNDERSTANDS_LONG_NAMES,
                         &pSecurityData);
            if (NT_SUCCESS(Status)) {
                pSessionUserName   = &(pSecurityData->UserName);
                pSessionDomainName = &(pSecurityData->LogonDomainName);
            }
        }

        if (NT_SUCCESS(Status)) {
            ASSERT(pSessionUserName->Length <= pUserName->MaximumLength);

            ASSERT(pSessionDomainName->Length <= pUserDomainName->MaximumLength);

            pUserName->Length = pSessionUserName->Length;
            RtlCopyMemory(
                pUserName->Buffer,
                pSessionUserName->Buffer,
                pUserName->Length);

            pUserDomainName->Length = pSessionDomainName->Length;
            RtlCopyMemory(
                pUserDomainName->Buffer,
                pSessionDomainName->Buffer,
                pUserDomainName->Length);
        }
    } finally {
        if (pSecurityData != NULL) {
            LsaFreeReturnBuffer(pSecurityData);
        }

        if (ProcessAttached) {
            KeDetachProcess();
        }
    }

    return Status;
}

VOID
SmbCepDereferenceSessionEntry(
    PSMBCEDB_SESSION_ENTRY pSessionEntry)
/*++

Routine Description:

    This routine dereferences a session entry instance

Arguments:

    pSessionEntry - the session entry to be dereferenced

--*/
{
    if (pSessionEntry != NULL) {
        BOOLEAN fTearDownEntry;
        BOOLEAN fLogOffRequired;

        ASSERT((pSessionEntry->Header.ObjectType == SMBCEDB_OT_SESSION) &&
               (pSessionEntry->Header.SwizzleCount > 0));

        MRXSMB_PRINT_REF_COUNT(SESSION_ENTRY,pSessionEntry->Header.SwizzleCount);

        SmbCeAcquireSpinLock();

        if (InterlockedDecrement(&pSessionEntry->Header.SwizzleCount) == 0) {
            if ((pSessionEntry->Header.State == SMBCEDB_ACTIVE) &&
                (pSessionEntry->Session.UserId != SMBCE_SHARE_LEVEL_SERVER_USERID)) {
                SmbCeReferenceServerEntry(pSessionEntry->pServerEntry);
                fLogOffRequired = TRUE;
            } else {
                fLogOffRequired = FALSE;
                pSessionEntry->Header.State = SMBCEDB_MARKED_FOR_DELETION;
            }
            SmbCeRemoveSessionEntryLite(pSessionEntry->pServerEntry,pSessionEntry);
            fTearDownEntry = TRUE;
        } else {
            fTearDownEntry = FALSE;
        }

        SmbCeReleaseSpinLock();

        if (fTearDownEntry) {
            if (fLogOffRequired) {
                SmbCeLogOff(pSessionEntry->pServerEntry,pSessionEntry);
            } else {
                SmbCeTearDownSessionEntry(pSessionEntry);
            }
        }
    }
}

VOID
SmbCeTearDownSessionEntry(
    PSMBCEDB_SESSION_ENTRY pSessionEntry)
/*++

Routine Description:

    This routine tears down a session entry instance

Arguments:

    pSessionEntry - the session entry to be dereferenced

--*/
{
    ASSERT((pSessionEntry->Header.SwizzleCount == 0) &&
           (pSessionEntry->Header.State == SMBCEDB_MARKED_FOR_DELETION));

    if (pSessionEntry->Session.Flags & SMBCE_SESSION_FLAGS_PARAMETERS_ALLOCATED) {
        if (pSessionEntry->Session.pUserName != NULL) {
            RxFreePool(pSessionEntry->Session.pUserName);
        }

        if (pSessionEntry->Session.pPassword != NULL) {
            RxFreePool(pSessionEntry->Session.pPassword);
        }

        if (pSessionEntry->Session.pUserDomainName != NULL) {
            RxFreePool(pSessionEntry->Session.pUserDomainName);
        }
    }

    UninitializeSecurityContextsForSession(&pSessionEntry->Session);

    SmbMmFreeSessionEntry(pSessionEntry);
}

NTSTATUS
SmbCeInitializeNetRootEntry(
    PMRX_NET_ROOT pNetRoot)
/*++

Routine Description:

    This routine opens/creates a net root entry in the connection engine database

Arguments:

    pNetRoot -- the RDBSS net root instance

Return Value:

    STATUS_SUCCESS - the construction of the net root instance has been finalized

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PSMBCEDB_SERVER_ENTRY   pServerEntry   = NULL;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry  = NULL;
    PSMBCEDB_SESSION_ENTRY  pSessionEntry  = NULL;

    SMB_USER_ID UserId = 0;

    pServerEntry = SmbCeReferenceAssociatedServerEntry(pNetRoot->pSrvCall);

    if (pServerEntry != NULL) {
        pNetRootEntry = (PSMBCEDB_NET_ROOT_ENTRY)SmbMmAllocateObject(SMBCEDB_OT_NETROOT);
        if (pNetRootEntry != NULL) {
            pNetRootEntry->pServerEntry = pServerEntry;
            pNetRootEntry->pRdbssNetRoot  = pNetRoot;
            pNetRootEntry->NetRoot.UserId = UserId;
            pNetRootEntry->NetRoot.NetRootType   = pNetRoot->Type;
            InitializeListHead(&pNetRootEntry->NetRoot.ClusterSizeSerializationQueue);
            if (pNetRoot->Type == NET_ROOT_MAILSLOT) {
                pNetRootEntry->Header.State = SMBCEDB_ACTIVE;
            }

            SmbCeReferenceNetRootEntry(pNetRootEntry);
            SmbCeAddNetRootEntry(pServerEntry,pNetRootEntry);
            pNetRoot->Context = pNetRootEntry;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        SmbCeDereferenceServerEntry(pServerEntry);
    } else {
        Status = STATUS_INVALID_HANDLE;
    }

    return Status;
}

VOID
SmbCeCompleteNetRootEntryInitialization(
    PVOID  pContext)
/*++

Routine Description:

    This routine is invoked in the context of a worker thread to finalize the
    construction of a net root entry

Arguments:

    pContext  - the net root entry to be finalized


Notes:

    PRE_CONDITION: The session entry must have been referenced to ensure that
    even it has been finalized it will not be deleted.

--*/
{
    NTSTATUS Status;

    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry = (PSMBCEDB_NET_ROOT_ENTRY)pContext;
    PSMBCEDB_REQUEST_ENTRY    pRequestEntry;
    SMBCEDB_REQUESTS          Requests;

    RxDbgTrace( 0, Dbg, ("Net Root Entry Finalization\n"));
    ASSERT(pNetRootEntry->Header.ObjectType == SMBCEDB_OT_NETROOT);

    SmbCeAcquireResource();

    SmbCeTransferRequests(&Requests,&pNetRootEntry->Requests);

    SmbCeReleaseResource();

    // Iterate over the list of pending requests and resume all of them
    pRequestEntry = SmbCeGetFirstRequestEntry(&Requests);
    while (pRequestEntry != NULL) {
        // Resume the exchange.
        if (pRequestEntry->Request.pExchange->pSmbCeSynchronizationEvent == NULL) {
            if (pNetRootEntry->Header.State == SMBCEDB_ACTIVE) {
                Status = SmbCeInitiateExchange(pRequestEntry->Request.pExchange);
            } else {
                // Invoke the error handler
                RxDbgTrace( 0, Dbg, ("Resuming exchange%lx with error\n",pRequestEntry->Request.pExchange));
                pRequestEntry->Request.pExchange->Status = STATUS_INVALID_CONNECTION;
                SmbCeFinalizeExchange(pRequestEntry->Request.pExchange);
            }
        } else {
            if (pNetRootEntry->Header.State == SMBCEDB_ACTIVE) {
                pRequestEntry->Request.pExchange->Status = STATUS_SUCCESS;
            } else {
                pRequestEntry->Request.pExchange->Status = STATUS_INVALID_CONNECTION;
            }

            KeSetEvent(
                pRequestEntry->Request.pExchange->pSmbCeSynchronizationEvent,
                0,
                FALSE);
        }

        // Delete the request entry
        SmbCeRemoveRequestEntry(&Requests,pRequestEntry);

        // Tear down the continuation entry
        SmbCeTearDownRequestEntry(pRequestEntry);

        // Skip to the next one.
        pRequestEntry = SmbCeGetFirstRequestEntry(&Requests);
    }

    SmbCeDereferenceNetRootEntry(pNetRootEntry);
}


VOID
SmbCepDereferenceNetRootEntry(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry)
/*++

Routine Description:

    This routine dereferences a net root entry instance

Arguments:

    pNetRootEntry - the NEt Root entry to be dereferenced

Notes:

    Disconnects are not required for mailslot servers. They need to be
    sent to File servers only.

--*/
{
    if (pNetRootEntry != NULL) {
        BOOLEAN fTearDownEntry;
        BOOLEAN fDisconnectRequired;

        ASSERT((pNetRootEntry->Header.ObjectType == SMBCEDB_OT_NETROOT) &&
               (pNetRootEntry->Header.SwizzleCount > 0));

        MRXSMB_PRINT_REF_COUNT(NETROOT_ENTRY,pNetRootEntry->Header.SwizzleCount);

        SmbCeAcquireSpinLock();

        if (InterlockedDecrement(&pNetRootEntry->Header.SwizzleCount) == 0) {
            if ((pNetRootEntry->Header.State == SMBCEDB_ACTIVE) &&
                (SmbCeGetServerType(pNetRootEntry->pServerEntry) == SMBCEDB_FILE_SERVER)) {
                SmbCeReferenceServerEntry(pNetRootEntry->pServerEntry);
                fDisconnectRequired = TRUE;
            } else {
                fDisconnectRequired = FALSE;
                pNetRootEntry->Header.State = SMBCEDB_MARKED_FOR_DELETION;
            }
            SmbCeRemoveNetRootEntryLite(pNetRootEntry->pServerEntry,pNetRootEntry);
            fTearDownEntry = TRUE;
        } else {
            fTearDownEntry = FALSE;
        }

        SmbCeReleaseSpinLock();

        if (fTearDownEntry) {
            if (fDisconnectRequired) {
                SmbCeDisconnect(pNetRootEntry->pServerEntry,pNetRootEntry);
            } else {
                SmbCeTearDownNetRootEntry(pNetRootEntry);
            }
        }
    }
}

VOID
SmbCeTearDownNetRootEntry(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry)
/*++

Routine Description:

    This routine tears down a net root entry instance

Arguments:

    pNetRootEntry - the NEt Root entry to be dereferenced

--*/
{
    ASSERT((pNetRootEntry->Header.SwizzleCount == 0) &&
           (pNetRootEntry->Header.State == SMBCEDB_MARKED_FOR_DELETION));

    SmbMmFreeObject(pNetRootEntry);
}

VOID
SmbCeProbeServers(
    PVOID    pContext)
/*++

Routine Description:

    This routine probes all the remote servers on which no activity has been
    detected in the recent past.

Notes:

    The current implementation of walking through the list of all servers to
    initiate echo processing will not scale very well for gateway servers. A
    different mechanism needs to be implemented.


--*/
{
    ULONG EchoProbeContextFlags;

    LIST_ENTRY              DiscardedServersList;
    PSMBCEDB_SERVER_ENTRY   pServerEntry;
    PSMBCEDB_SERVER_ENTRY   pPreviousServerEntry = NULL;

    InitializeListHead(&DiscardedServersList);

    SmbCeAcquireSpinLock();
    pServerEntry = SmbCeGetFirstServerEntry();

    while (pServerEntry != NULL) {
        if (pServerEntry->Header.State == SMBCEDB_ACTIVE) {
            if ((pServerEntry->Server.SmbsReceivedSinceLastStrobe == 0) &&
                (pServerEntry->pMidAtlas != NULL) &&
                (pServerEntry->pMidAtlas->NumberOfMidsInUse > 0)) {

                switch (pServerEntry->Server.EchoProbeState) {
                case ECHO_PROBE_AWAITING_RESPONSE:
                case ECHO_PROBE_SEND:
                    {
                        NTSTATUS Status = STATUS_SUCCESS;
                        BOOLEAN  SendEchoSmb;

                        // Classify the connection as being disconnected.

                        // The additional reference is required to keep this server entry
                        // as a place marker in the list of server entries.
                        // This will be released on resumption of the processinf further
                        // down in this routine
                        InterlockedIncrement(&pServerEntry->Header.SwizzleCount);
                        SmbCeReleaseSpinLock();

                        SendEchoSmb = ((pServerEntry->Server.Dialect >= NTLANMAN_DIALECT) ||
                                       (pServerEntry->Server.EchoProbesSent < ECHO_PROBE_LIMIT));

                        if (SendEchoSmb &&
                            (pServerEntry->Server.EchoProbeState == ECHO_PROBE_SEND)) {
                            pServerEntry->Server.EchoProbesSent++;
                            pServerEntry->Server.EchoProbeState = ECHO_PROBE_AWAITING_RESPONSE;
                            Status = SmbCeSendToServer(
                                         pServerEntry,
                                         RXCE_SEND_SYNCHRONOUS,
                                         EchoProbeContext.pEchoSmbMdl,
                                        EchoProbeContext.EchoSmbLength);
                            RxDbgTrace(0,Dbg,("Sending ECHO SMB %lx Status %lx\n",pServerEntry,Status));
                        } else {
                            if (pServerEntry->Server.EchoProbesSent >= ECHO_PROBE_LIMIT) {
                                DbgPrint("****** ServerEntry(%lx) ECHO probe Limit exceeded\n",pServerEntry);
                            }
                            Status = STATUS_MORE_PROCESSING_REQUIRED;
                        }

                        if ((Status != STATUS_SUCCESS) &&
                            (Status != STATUS_PENDING)) {
                            RxDbgTrace(0,Dbg,("Disconnecting Connection %lx\n",pServerEntry));
                            InterlockedIncrement(&MRxIfsStatistics.HungSessions);
                            SmbCeTransportDisconnectIndicated(pServerEntry);
                        }

                        SmbCeAcquireSpinLock();

                        pPreviousServerEntry = pServerEntry;
                    }
                default:
                case ECHO_PROBE_IDLE:
                    {
                        // Prepare to send an ECHO SMB.
                        pServerEntry->Server.EchoProbeState = ECHO_PROBE_SEND;
                    }
                }
            } else {
                pServerEntry->Server.EchoProbesSent = 0;
                InterlockedExchange(&pServerEntry->Server.SmbsReceivedSinceLastStrobe,0);
                pServerEntry->Server.EchoProbeState = ECHO_PROBE_IDLE;
            }
        }

        pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
        if (pPreviousServerEntry != NULL) {
            LONG FinalRefCount;

            FinalRefCount = InterlockedDecrement(&pPreviousServerEntry->Header.SwizzleCount);
            if (FinalRefCount == 0) {
                pPreviousServerEntry->Header.State = SMBCEDB_MARKED_FOR_DELETION;
                SmbCeRemoveServerEntryLite(pPreviousServerEntry);
                InsertTailList(&DiscardedServersList,&pPreviousServerEntry->ServersList);
            }

            pPreviousServerEntry = NULL;
        }
    }

    EchoProbeContextFlags = EchoProbeContext.Flags;

    if (EchoProbeContextFlags & ECHO_PROBE_CANCELLED_FLAG) {
        KeSetEvent(
            &EchoProbeContext.CancelCompletionEvent,
            0,
            FALSE );
    }

    SmbCeReleaseSpinLock();

    while (!IsListEmpty(&DiscardedServersList)) {
        PLIST_ENTRY pListEntry = DiscardedServersList.Flink;

        RemoveEntryList(pListEntry);

        pServerEntry = (PSMBCEDB_SERVER_ENTRY)
                       (CONTAINING_RECORD(
                           pListEntry,
                           SMBCEDB_SERVER_ENTRY,
                           ServersList));

        SmbCeTearDownServerEntry(pServerEntry);
    }

    if (!(EchoProbeContextFlags & ECHO_PROBE_CANCELLED_FLAG)) {
        EchoProbeContext.Status = RxPostOneShotTimerRequest(
                                      MRxIfsDeviceObject,
                                      &EchoProbeContext.WorkItem,
                                      SmbCeProbeServers,
                                      &EchoProbeContext,
                                      EchoProbeContext.Interval);
    }

    RxDbgTraceLV(0, Dbg, 2000, ("SmbCeProbeServers: Reposting Request\n"));
    if (EchoProbeContext.Status != STATUS_SUCCESS) {
        RxLog(("SmbCe Echo Probe Reposting Error %lx\n", EchoProbeContext.Status));
    }
}

VOID
SmbCeTransportDisconnectIndicated(
    PSMBCEDB_SERVER_ENTRY   pServerEntry)
/*++

Routine Description:

    This routine invalidates a server entry on notification from the underlying transport

Arguments:

    pServerEntry - the server entry to be dereferenced

Notes:

    The server entry and the associated net roots and sessions are marked as invalid. A
    reconnect is facilitated on other requests as and when required. In addition all
    pending requests are resumed with the appropriate error indication.

--*/
{
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    PSMBCEDB_SESSION_ENTRY  pSessionEntry;

    RxDbgTrace(0,
              Dbg,
              ("SmbCeDbTransportDisconnectIndicated for %lx -- Entry\n",pServerEntry));

    // Acquire the database resource (DPC Level)
    SmbCeAcquireSpinLock();

    // Increment the associated version count so as to invalidate all existing Fids
    InterlockedIncrement(&pServerEntry->Server.Version);

    pServerEntry->ServerStatus = STATUS_CONNECTION_DISCONNECTED;
    pServerEntry->Header.State = SMBCEDB_DESTRUCTION_IN_PROGRESS;

    // Mark all the associated sessions as being invalid.
    pSessionEntry = SmbCeGetFirstSessionEntry(pServerEntry);
    while (pSessionEntry != NULL) {
        pSessionEntry->Header.State = SMBCEDB_INVALID;
        pSessionEntry = SmbCeGetNextSessionEntry(pServerEntry,pSessionEntry);
    }

    // Mark all the associated net roots as being invalid
    pNetRootEntry = SmbCeGetFirstNetRootEntry(pServerEntry);
    while (pNetRootEntry != NULL) {
        pNetRootEntry->Header.State = SMBCEDB_INVALID;
        pNetRootEntry = SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry);
    }

    SmbCeReferenceServerEntry(pServerEntry);

    // release the database resource (DPC Level)
    SmbCeReleaseSpinLock();

    if (!RxShouldPostCompletion()) {
        SmbCeResumeAllOutstandingRequestsOnError(pServerEntry);
    } else {
        NTSTATUS Status;

        Status = RxDispatchToWorkerThread(
                     MRxIfsDeviceObject,
                     CriticalWorkQueue,
                     SmbCeResumeAllOutstandingRequestsOnError,
                     pServerEntry);
        if (Status != STATUS_SUCCESS) {
            RxLog(("SmbCe Xport Disc.Error %lx\n", pServerEntry));
        }
    }

    RxDbgTrace(0,
              Dbg,
              ("SmbCeTransportDisconnectIndicated -- Exit\n"));
}

VOID
SmbCeHandleTransportInvalidation(
    IN PSMBCE_TRANSPORT  pTransport)
/*++

Routine Description:

    This routine invalidates all servers using a particular transport. This is different from
    a disconnect indication in which one server is invalidated. In this case a transport is being
    removed/invalidated locally and all servers using that transport must be invalidated

Arguments:

    pTransport  - the transport being invalidated

--*/
{
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    SmbCeAcquireSpinLock();

    pServerEntry = SmbCeGetFirstServerEntry();

    while (pServerEntry != NULL) {

        if ((pServerEntry->pTransport != NULL) &&
            (pServerEntry->pTransport->pTransport == pTransport)) {
            pServerEntry->Header.State = SMBCEDB_DESTRUCTION_IN_PROGRESS;

            // The invalidation needs to hold onto an extra reference to avoid
            // race conditions which could lead to premature destruction of
            // this server entry.
            SmbCeReferenceServerEntry(pServerEntry);
        }

        pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
    }

    SmbCeReleaseSpinLock();

    SmbCeAcquireResource();

    pServerEntry = SmbCeGetFirstServerEntry();

    while (pServerEntry != NULL) {
        PSMBCEDB_SERVER_ENTRY pPrevServerEntry;
        BOOLEAN               fDereferencePrevServerEntry = FALSE;

        if ((pServerEntry->pTransport != NULL) &&
            (pServerEntry->pTransport->pTransport == pTransport)) {
            SmbCeReleaseResource();
            SmbCeTransportDisconnectIndicated(pServerEntry);
            SmbCeAcquireResource();
            fDereferencePrevServerEntry = TRUE;
        }

        pPrevServerEntry = pServerEntry;
        pServerEntry = SmbCeGetNextServerEntry(pServerEntry);

        if (fDereferencePrevServerEntry) {
            SmbCeDereferenceServerEntry(pPrevServerEntry);
        }
    }

    SmbCeReleaseResource();
}


VOID
SmbCeFinalizeExchangeOnTransportDisconnect(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

    This routine handles the finalization of an exchange instance during transport disconnects

Arguments:

    pExchange  - the exchange instance

--*/
{
    ASSERT(pExchange->ReceivePendingOperations > 0);
    pExchange->Status      = STATUS_CONNECTION_DISCONNECTED;
    pExchange->SmbStatus   = STATUS_CONNECTION_DISCONNECTED;
    pExchange->ReceivePendingOperations = 0;
    SmbCeFinalizeExchange(pExchange);
}

VOID
SmbCeResumeAllOutstandingRequestsOnError(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine handles the resumption of all outstanding requests on an error

Arguments:

    pServerEntry  - the Server entry which is being classified as disconnected
Notes:

    This routine requires the caller to have obtained a reference on the corresponding
    server entry. This is required because invocation of this routine can be posted
    which implies that a reference is required to avoid premature destruction of
    the associated server entry.

--*/
{
    SMBCEDB_REQUESTS       Requests;
    SMBCEDB_REQUESTS       MidRequests;
    PSMBCEDB_REQUEST_ENTRY pRequestEntry;
    PMID_ATLAS             pMidAtlas;
    PSMB_EXCHANGE          pNegotiateExchange = NULL;

    //DbgPrint("SmbCeResumeAllOutstandingRequestsOnError: Invoked \n");

    InitializeListHead(&Requests.ListHead);

    SmbCeAcquireResource();
    SmbCeAcquireSpinLock();

    // Create a temporary copy of the list that can be traversed after releasing the
    // resource.

    // Copy all the MID assignment requests pending.
    SmbCeTransferRequests(&MidRequests,&pServerEntry->MidAssignmentRequests);

    // Weed out all the reconnect requests so that they can be resumed
    pRequestEntry = SmbCeGetFirstRequestEntry(&pServerEntry->OutstandingRequests);
    while (pRequestEntry != NULL) {
        if (pRequestEntry->GenericRequest.Type == RECONNECT_REQUEST) {
            PSMBCEDB_REQUEST_ENTRY pTempRequestEntry;

            pTempRequestEntry = pRequestEntry;
            pRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);

            SmbCeRemoveRequestEntryLite(&pServerEntry->OutstandingRequests,pTempRequestEntry);
            SmbCeAddRequestEntryLite(&Requests,pTempRequestEntry);
        } else {
            pRequestEntry = SmbCeGetNextRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);
        }
    }

    if (pServerEntry->pNegotiateExchange != NULL) {
        if (pServerEntry->pNegotiateExchange->ReceivePendingOperations > 0) {
            pNegotiateExchange = pServerEntry->pNegotiateExchange;
        }
    }

    // The exchanges that have valid MID's assigned to them fall into two categories
    // Those that have a ReceivePendingOperation count of > 0 and those that have
    // a ReceievePendingOperation count of zero. For all the exchanges that belong
    // to the first category the finalize ( quiescent state ) routine must be invoked
    // since no receives will be forthcoming. For those exchanges that are in the
    // second category it is sufficient to mark the MID as being invalid. The
    // finalization( quiescent state ) routine is going to be called on completion
    // of other opertaions in this case.

    pMidAtlas = pServerEntry->pMidAtlas;
    if (pMidAtlas != NULL) {
        PVOID  pContext;
        USHORT MidsProcessed = 0;
        USHORT NumberOfMidsInUse;
        USHORT NextMid = 0;

        NumberOfMidsInUse = IfsMrxGetNumberOfMidsInUse(pMidAtlas);

        while (NumberOfMidsInUse > MidsProcessed) {
            pContext = IfsMrxMapMidToContext(pMidAtlas,NextMid);
            if (pContext != NULL) {
                PSMB_EXCHANGE pExchange = (PSMB_EXCHANGE)pContext;

                pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_MID_VALID;

                if ((pExchange->ReceivePendingOperations > 0) &&
                    ((pExchange->LocalPendingOperations > 0) ||
                    (pExchange->CopyDataPendingOperations > 0) ||
                    (pExchange->SendCompletePendingOperations > 0))) {
                    // There are other pending operations. By merely setting the
                    // pending receive operations to zero, the finalization of
                    // the exchange is ensured.
                    pExchange->ReceivePendingOperations = 0;
                }

                if (pExchange->ReceivePendingOperations ==  0) {
                    IfsMrxMapAndDissociateMidFromContext(pMidAtlas,NextMid,&pContext);
                }

                MidsProcessed++;
            }

            NextMid++;
        }
    }

    pServerEntry->pNegotiateExchange = NULL;
    pServerEntry->pMidAtlas          = NULL;
    pServerEntry->Header.State       = SMBCEDB_INVALID;

    SmbCeReleaseSpinLock();
    SmbCeReleaseResource();

    //DbgPrint("SmbCeResumeAllOutstandingRequestsOnError: Processing outsanding request \n");

    // Ensure that all the reconnect requests are resumed with the appropriate error.
    pRequestEntry = SmbCeGetFirstRequestEntry(&Requests);
    while (pRequestEntry != NULL) {
        // Remove the request entry from the list
        SmbCeRemoveRequestEntryLite(&Requests,pRequestEntry);

        pRequestEntry->GenericRequest.pExchange->SmbStatus = pServerEntry->ServerStatus;
        SmbCeFinalizeExchange(pRequestEntry->GenericRequest.pExchange);

        SmbCeTearDownRequestEntry(pRequestEntry);
        pRequestEntry = SmbCeGetFirstRequestEntry(&Requests);
    }

    //DbgPrint("SmbCeResumeAllOutstandingRequestsOnError: Processing MID request \n");
    pRequestEntry = SmbCeGetFirstRequestEntry(&MidRequests);
    while (pRequestEntry != NULL) {
        // Remove the request entry from the list
        SmbCeRemoveRequestEntryLite(&MidRequests,pRequestEntry);

        ASSERT(pRequestEntry->GenericRequest.Type == ACQUIRE_MID_REQUEST);

        // Signal the waiter for resumption
        pRequestEntry->MidRequest.pResumptionContext->Status = STATUS_CONNECTION_DISCONNECTED;
        SmbCeResume(pRequestEntry->MidRequest.pResumptionContext);

        SmbCeTearDownRequestEntry(pRequestEntry);
        pRequestEntry = SmbCeGetFirstRequestEntry(&MidRequests);
    }

    // Resume all the outstanding requests with the error indication
    // The IfsMrxDestroyMidAtlas destroys the Mid atlas and at the same
    // time invokes the specified routine on each valid context.

    if (pMidAtlas != NULL) {
        IfsMrxDestroyMidAtlas(pMidAtlas,SmbCeFinalizeExchangeOnTransportDisconnect);
    }

    if (pNegotiateExchange != NULL) {
        SmbCeFinalizeExchangeOnTransportDisconnect(pNegotiateExchange);
    }

    SmbCeDereferenceServerEntry(pServerEntry);
}

VOID
SmbCeTearDownRequestEntry(
    PSMBCEDB_REQUEST_ENTRY  pRequestEntry)
{
    SmbMmFreeObject(pRequestEntry);
}

//
// The connection engine database initializtion/tear down routines
//

extern NTSTATUS
SmbMmInit();

extern VOID
SmbMmTearDown();

KIRQL           s_SmbCeDbSpinLockSavedIrql;
KSPIN_LOCK      s_SmbCeDbSpinLock;
ERESOURCE       s_SmbCeDbResource;
SMBCEDB_SERVERS s_DbServers;
BOOLEAN         s_SmbCeDbSpinLockAcquired;

NTSTATUS
SmbCeDbInit()
{
    NTSTATUS Status;

    // Initialize the lists associated with various database entities
    InitializeListHead(&s_DbServers.ListHead);

    // Initialize the resource associated with the database.
    KeInitializeSpinLock(&s_SmbCeDbSpinLock );
    ExInitializeResource(&s_SmbCeDbResource);
    s_SmbCeDbSpinLockAcquired = FALSE;

    MRxSmbInitializeSmbCe();

    // Initialize the memory management data structures.
    Status = SmbMmInit();

    return Status;
}

VOID
SmbCeDbTearDown()
{
    // Walk through the list of servers and tear them down.
    PSMBCEDB_SERVER_ENTRY pServerEntry = NULL;

    SmbCeAcquireResource();
    SmbCeAcquireSpinLock();

    pServerEntry = SmbCeGetFirstServerEntry();
    while (pServerEntry != NULL) {
        PSMBCEDB_SERVER_ENTRY pTempServerEntry;

        pTempServerEntry = pServerEntry;
        SmbCeReferenceServerEntry(pServerEntry);
        SmbCeReferenceServerEntry(pServerEntry);

        SmbCeReleaseSpinLock();
        SmbCeReleaseResource();

        pServerEntry->ServerStatus = STATUS_REDIRECTOR_PAUSED;
        SmbCeResumeAllOutstandingRequestsOnError(pServerEntry);

        SmbCeAcquireSpinLock();
        pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
        SmbCeReleaseSpinLock();

        SmbCeDereferenceServerEntry(pTempServerEntry);

        SmbCeAcquireResource();
        SmbCeAcquireSpinLock();
    }

    SmbCeReleaseSpinLock();
    SmbCeReleaseResource();

    MRxSmbTearDownSmbCe();

    SmbCeAcquireResource();
    SmbCeAcquireSpinLock();

    pServerEntry = SmbCeGetFirstServerEntry();
    while (pServerEntry != NULL) {
        ASSERT(pServerEntry->Header.SwizzleCount == 1);

        pServerEntry->Header.State = SMBCEDB_MARKED_FOR_DELETION;
        SmbCeRemoveServerEntryLite(pServerEntry);

        SmbCeReleaseSpinLock();
        SmbCeReleaseResource();

        SmbCeTearDownServerEntry(pServerEntry);

        SmbCeAcquireResource();
        SmbCeAcquireSpinLock();

        pServerEntry = SmbCeGetFirstServerEntry();
    }

    SmbCeReleaseSpinLock();
    SmbCeReleaseResource();

    // free the pool associated with the resource
    ExDeleteResource(&s_SmbCeDbResource);

    // Tear down the connection engine memory management data structures.
    SmbMmTearDown();
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\smbpse.c ===
/*++ Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    SmbPse.c

Abstract:

    This module defines the types and functions related to the SMB protocol
    selection engine: the component that translates minirdr calldowns into
    SMBs.

--*/

#include "precomp.h"
#pragma hdrstop

RXDT_DefineCategory(SMBPSE);
#define Dbg                              (DEBUG_TRACE_SMBPSE)

typedef struct _SMBPSE_VESTIGIAL_SMBBUF {
    NT_SMB_HEADER Header;
    union {
        REQ_WRITE Write;
        REQ_NT_WRITE_ANDX WriteAndX;
        REQ_FLUSH Flush;
        struct {
            REQ_LOCKING_ANDX LockingAndX;
            NTLOCKING_ANDX_RANGE Locks[20];
        };
        REQ_FIND_CLOSE2 FindClose;
        REQ_CLOSE Close;

    };
    ULONG Pad;
} SMBPSE_VESTIGIAL_SMBBUF;

typedef struct _SMBPSE_MUST_SUCCEEED_CONTEXT {
    struct {
        LIST_ENTRY ExchangeListEntry;
        union {
            SMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;
        };
    };
    SMBPSE_VESTIGIAL_SMBBUF SmbBuf;
    struct {
        union {
            MDL;
            MDL Mdl;
        };
        ULONG Pages[2];
    } DataPartialMdl;
} SMBPSE_MUST_SUCCEEED_CONTEXT, *PSMBPSE_MUST_SUCCEEED_CONTEXT;

BOOLEAN MRxSmbEntryPointIsMustSucceedable[SMBPSE_OE_FROM_MAXIMUM];

typedef enum {
    SmbPseMustSucceed = 0,
    SmbPseMustSucceedMaximum
};

RX_MUSTSUCCEED_DESCRIPTOR SmbPseMustSucceedDescriptor[SmbPseMustSucceedMaximum];
SMBPSE_MUST_SUCCEEED_CONTEXT SmbPseMustSucceedContext[SmbPseMustSucceedMaximum];

#define MINIMUM_SEND_SIZE 512

PVOID LastOE;

#define MIN(x,y) ((x) < (y) ? (x) : (y))

#define IM_THE_LAST_GUY (*Response==0)

//
// Generic AndX request
//

GENERIC_ANDX NullGenericAndX = {
            //    typedef struct _GENERIC_ANDX {
      0,    //        UCHAR WordCount;                    // Count of parameter words
            //        UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
      SMB_COM_NO_ANDX_COMMAND,
      0,    //        UCHAR AndXReserved;                 // Reserved
      0     //        _USHORT( AndXOffset );              // Offset (from SMB header start)
            //    } GENERIC_ANDX;
    };

NTSTATUS
SmbPseExchangeStart_default(
    IN OUT PSMB_EXCHANGE  pExchange);

NTSTATUS
SmbPseExchangeSendCallbackHandler_default(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pXmitBuffer,
    IN NTSTATUS         SendCompletionStatus);

NTSTATUS
SmbPseExchangeCopyDataHandler_default(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pDataBuffer,
    IN ULONG            DataSize);

NTSTATUS
SmbPseExchangeCopyDataHandler_Read(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pDataBuffer,
    IN ULONG            DataSize);

NTSTATUS
SmbPseExchangeReceive_default(
    IN struct _SMB_EXCHANGE *pExchange,    // The exchange instance
    IN ULONG  BytesIndicated,
    IN ULONG  BytesAvailable,
    OUT ULONG *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL *pDataBufferPointer,
    OUT PULONG  pDataSize);

NTSTATUS
SmbPseExchangeFinalize_default(
   IN OUT struct _SMB_EXCHANGE *pExchange,
   OUT    BOOLEAN              *pPostFinalize);


SMB_EXCHANGE_DISPATCH_VECTOR
SmbPseOEDispatch = {SmbPseExchangeStart_default,
                    SmbPseExchangeReceive_default,
                    SmbPseExchangeCopyDataHandler_default,
                    SmbPseExchangeSendCallbackHandler_default,
                    SmbPseExchangeFinalize_default
                    };

//
// External declarations
//


#if DBG
#define P__ASSERT(exp) {             \
    if (!(exp)) {                    \
        DbgPrint("NOT %s\n",#exp);   \
        errors++;                    \
    }}
VOID
__SmbPseOEAssertConsistentLinkage(
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line,
    PRX_CONTEXT RxContext,
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    PSMBSTUFFER_BUFFER_STATE StufferState,
    ULONG Flags
    )
/*++

Routine Description:

   This routine performs a variety of checks to ensure that the linkage between the rxcontext, the OE, and
   the stufferstate is correct and that various fields have correct values. if anything is bad....print stuff out and brkpoint;

Arguments:

     MsgPrefix          an identifying msg
     RxContext           duh
     OrdinaryExchange    .
     StufferState        .

Return Value:

    none

Notes:

--*/
{
    ULONG errors = 0;

    PMRXIFS_RX_CONTEXT pMRxSmbContext;
    PSMB_EXCHANGE Exchange = &OrdinaryExchange->Exchange;

    pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    P__ASSERT( OrdinaryExchange->SerialNumber == RxContext->SerialNumber );
    P__ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );
    P__ASSERT( NodeType(OrdinaryExchange)==SMB_EXCHANGE_NTC(ORDINARY_EXCHANGE) );
    P__ASSERT( OrdinaryExchange->RxContext == RxContext );
    P__ASSERT( NodeType(StufferState) == SMB_NTC_STUFFERSTATE );
    P__ASSERT( pMRxSmbContext->pExchange == Exchange );
    P__ASSERT( pMRxSmbContext->pStufferState == StufferState );
    P__ASSERT( Exchange == StufferState->Exchange);
    P__ASSERT( StufferState->RxContext == RxContext );
    if(StufferState->HeaderMdl!=NULL){
        P__ASSERT( !RxMdlIsPartial(StufferState->HeaderMdl) );
    }
    if (!FlagOn(Flags,OECHKLINKAGE_FLAG_NO_REQPCKT_CHECK)) {
        P__ASSERT( OrdinaryExchange->RxContextCapturedRequestPacket == RxContext->CurrentIrp);
    }
    if (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_PARTIAL_INITIALIZED)) {
        P__ASSERT( RxMdlIsPartial(StufferState->HeaderPartialMdl) );
    }
    if (errors==0) {
        return;
    }
    DbgPrint("%s INCONSISTENT OE STATE: %d errors at %s line %d\n",
                 MsgPrefix,errors,File,Line);
    DbgBreakPoint();
    return;
}

VOID
__SmbPseDbgRunMdlChain(
    PMDL MdlChain,
    ULONG CountToCompare,
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line
    )
{
    ULONG i,total;
    RxDbgTrace(0,Dbg,("__SmbPseRunMdlChain: -------------%08lx\n",MdlChain));
    for (total=i=0;MdlChain!=NULL;i++,MdlChain=MdlChain->Next) {
        total+=MdlChain->ByteCount;
        RxDbgTrace(0,Dbg,("--->%02d %08lx %08lx %08lx %6d %6d\n",i,MdlChain,MdlChain->MdlFlags,
               MmGetMdlVirtualAddress(MdlChain),MdlChain->ByteCount,total));
    }
    if (total==CountToCompare) return;
    DbgPrint("%s: MdlChain.Count!=CountToCompart c1,c2,xch.st=%08lx %08lx %08lx\n",
                             MsgPrefix,
                             total,CountToCompare,OrdinaryExchange->Status,
                             File,Line);
    DbgBreakPoint();
}
#define SmbPseDbgRunMdlChain(a,b,c,d) {\
   __SmbPseDbgRunMdlChain(a,b,c,d,__FILE__,__LINE__);\
   }

VOID
__SmbPseDbgCheckOEMdls(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line
    )
{
    ULONG errors = 0;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PMDL SubmitMdl = StufferState->HeaderPartialMdl;

    P__ASSERT (OrdinaryExchange->SaveDataMdlForDebug == SubmitMdl->Next);
    P__ASSERT (OrdinaryExchange->SaveDataMdlForDebug == StufferState->DataMdl);
    P__ASSERT (SubmitMdl != NULL);

    if (errors==0) {
        return;
    }
    DbgPrint("%s CheckOEMdls failed: %d errors at %s line %d: OE=%08lx\n",
                 MsgPrefix,errors,File,Line,OrdinaryExchange);
    DbgBreakPoint();
    return;
}
#define SmbPseDbgCheckOEMdls(a,b) {\
   __SmbPseDbgCheckOEMdls(a,b,__FILE__,__LINE__);\
   }

ULONG SmbPseShortStatus(ULONG Status)
{
    ULONG ShortStatus;

    ShortStatus = Status & 0xc0003fff;
    ShortStatus = ShortStatus | (ShortStatus >>16);
    return(ShortStatus);
}

VOID SmbPseUpdateOEHistory(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    ULONG Tag1,
    ULONG Tag2
    )
{
    ULONG MyIndex,Long0,Long1;

    MyIndex = InterlockedIncrement(&OrdinaryExchange->History.Next);
    MyIndex = (MyIndex-1) & (SMBPSE_OE_HISTORY_SIZE-1);
    Long0 = (Tag1<<16) | (Tag2 & 0xffff);
    Long1 = (SmbPseShortStatus(OrdinaryExchange->SmbStatus)<<16) | OrdinaryExchange->Flags;
    OrdinaryExchange->History.Markers[MyIndex].Longs[0] = Long0;
    OrdinaryExchange->History.Markers[MyIndex].Longs[1] = Long1;
}

VOID SmbPseVerifyDataPartialAllocationPerFlags(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange
    )
{
    BOOLEAN FlagsSayPartialAllocated,TheresADataPartial;
    ULONG t = OrdinaryExchange->Flags & (SMBPSE_OE_FLAG_OE_ALLOCATED_DATA_PARTIAL|SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_SMBBUF);
    FlagsSayPartialAllocated = (t!=0)?TRUE:FALSE;   //the compiler is getting confused
    TheresADataPartial = (OrdinaryExchange->DataPartialMdl != NULL)?TRUE:FALSE;  //the compiler is getting confused
    if ( FlagsSayPartialAllocated != TheresADataPartial){
        DbgPrint("Flags %08lx datapartial %08lx t %08lx fspa %08lx tadp %08lx\n",
                     OrdinaryExchange->Flags, OrdinaryExchange->DataPartialMdl,
                     t, FlagsSayPartialAllocated, TheresADataPartial);
        ASSERT ( FlagsSayPartialAllocated == TheresADataPartial);
    }
}

#else
#define SmbPseDbgRunMdlChain(a,b,c,d) {NOTHING;}
#define SmbPseDbgCheckOEMdls(a,b) {NOTHING;}
#define SmbPseVerifyDataPartialAllocationPerFlags(a) {NOTHING;}
#endif

#define UPDATE_OE_HISTORY_WITH_STATUS(a) UPDATE_OE_HISTORY_2SHORTS(a,SmbPseShortStatus(OrdinaryExchange->Status))

NTSTATUS
SmbPseContinueOrdinaryExchange(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine resumes processing on an exchange. This is called when work is
   required to finish processing a request that cannot be completed at DPC
   level.  This happens either because the parse routine needs access to
   structures that are not locks OR because the operation if asynchronous and
   there maybe more work to be done.

   The two cases are regularized by delaying the parse if we know that we're
   going to post: this is indicated by the presense of a resume routine.

Arguments:

    RxContext  - the context of the operation. .

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS Status;
    PMRXIFS_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                        (PSMB_PSE_ORDINARY_EXCHANGE)(pMRxSmbContext->pExchange);
    RxCaptureFobx;
    //PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PMDL SubmitMdl, HeaderFullMdl;

    RxDbgTrace(+1, Dbg, ("SmbPseContinueOrdinaryExchange entering........OE=%08lx\n",OrdinaryExchange));
    ClearFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_AWAITING_DISPATCH);

    SmbPseOEAssertConsistentLinkageFromOE("SmbPseContinueOrdinaryExchange:");

    Status = Exchange->Status;
    UPDATE_OE_HISTORY_WITH_STATUS('0c');

    SubmitMdl = StufferState->HeaderPartialMdl;
    HeaderFullMdl = StufferState->HeaderMdl;
    ASSERT(FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_PARTIAL_INITIALIZED));
    SmbPseOEAssertConsistentLinkage("Top of OE continue: ");
    RxUnprotectMdlFromFree(SubmitMdl);
    RxUnprotectMdlFromFree(HeaderFullMdl);

    SmbPseDbgCheckOEMdls(OrdinaryExchange,"SmbPseContinueOrdinaryExchange(top)");
    SmbPseDbgRunMdlChain(SubmitMdl,
                         OrdinaryExchange->SaveLengthForDebug,
                         OrdinaryExchange,
                         "SmbPseContinueOrdinaryExchange(top)");

    MmPrepareMdlForReuse(SubmitMdl);
    ClearFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_PARTIAL_INITIALIZED);

    SmbPseVerifyDataPartialAllocationPerFlags(OrdinaryExchange);

    if ( OrdinaryExchange->DataPartialMdl ) {
        MmPrepareMdlForReuse( OrdinaryExchange->DataPartialMdl );
    }

    RxDbgTrace( 0, Dbg, ("  --> P4Reuse %08lx, full %08lx is no longer unlocked here\n"
                         ,SubmitMdl,HeaderFullMdl));


  __RETRY_FINISH_ROUTINE__:
    if ( OrdinaryExchange->FinishRoutine != NULL ) {
        if ( Status == STATUS_MORE_PROCESSING_REQUIRED ){
            Exchange->Status = STATUS_SUCCESS;
        }
        Status = OrdinaryExchange->FinishRoutine( OrdinaryExchange );
        UPDATE_OE_HISTORY_WITH_STATUS('1c');
        Exchange->Status = Status;
        OrdinaryExchange->FinishRoutine = NULL;

    } else if ( Status == STATUS_MORE_PROCESSING_REQUIRED ) {
        ULONG BytesTaken;
        ULONG DataSize = 0;
        ULONG MessageLength = OrdinaryExchange->MessageLength;
        PMDL  DataBufferPointer = NULL;
        PSMB_HEADER SmbHeader = (PSMB_HEADER)StufferState->BufferBase;


        Status = SMB_EXCHANGE_DISPATCH(Exchange,Receive,
                  (Exchange,           // IN struct SMB_EXCHANGE *pExchange,
                   MessageLength,      // IN ULONG  BytesIndicated,
                   MessageLength,      // IN ULONG  BytesAvailable,
                   &BytesTaken,        // OUT ULONG *pBytesTaken,
                   SmbHeader,          // IN  PSMB_HEADER pSmbHeader,
                   &DataBufferPointer, // OUT PMDL *pDataBufferPointer,
                   &DataSize           // OUT PULONG  pDataSize)
                   ));

        if (Status==STATUS_SUCCESS) {
            Status = Exchange->Status;
            UPDATE_OE_HISTORY_WITH_STATUS('2c');
        } else {
            UPDATE_OE_HISTORY_WITH_STATUS('dd');
        }

        ASSERT( BytesTaken==MessageLength );
        ASSERT( ( DataBufferPointer==NULL ) && ( DataSize == 0 ) );
        ASSERT( Status != STATUS_MORE_PROCESSING_REQUIRED );

        // after calling the receive routine again, we may NOW have a finish routine!
        if ( OrdinaryExchange->FinishRoutine != NULL ) {
            goto __RETRY_FINISH_ROUTINE__;
        }
    } else {
        NOTHING;
    }

    if (  OrdinaryExchange->Continuation ) {

        //call the continuation is it's async
        //Exchange->SmbStatus = Status; //this is where read/write/locks pick up the status
        Status = OrdinaryExchange->Continuation( OrdinaryExchange, RxContext );
        UPDATE_OE_HISTORY_WITH_STATUS('3c');

    }

    //remove my references, if i'm the last guy then do the putaway...
    UPDATE_OE_HISTORY_WITH_STATUS('4c');
    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);

    RxDbgTrace(-1, Dbg, ("SmbPseContinueOrdinaryExchange returning %08lx.\n", Status));
    return(Status);

} // SmbPseContinueOrdinaryExchange



NTSTATUS
SmbPseOrdinaryExchange(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    IN     SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType
    )
/*++

Routine Description:

   This routine implements an ordinary exchange as viewed by the protocol
   selection routines.

Arguments:

    OrdinaryExchange  - the exchange to be conducted.
    OEType            - Ordinary Exchange Type

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS Status;
    RxCaptureFobx;

    PMRXIFS_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;
    PSMB_PSE_OE_START_ROUTINE Continuation;
    ULONG   SmbLength;
    PMDL    SubmitMdl,HeaderFullMdl;
    ULONG   SendOptions;

    RxDbgTrace(+1, Dbg, ("SmbPseOrdinaryExchange entering.......OE=%08lx\n",OrdinaryExchange));

    SmbPseOEAssertConsistentLinkageFromOE("SmbPseOrdinaryExchange:");

    OrdinaryExchange->OEType = OEType;
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    KeInitializeEvent( &RxContext->SyncEvent,
                       NotificationEvent,
                       FALSE );

    HeaderFullMdl = StufferState->HeaderMdl;
    ASSERT( HeaderFullMdl != NULL );
    SmbLength = StufferState->CurrentPosition - StufferState->BufferBase;

    SubmitMdl = StufferState->HeaderPartialMdl;
    if (SubmitMdl == NULL) {
        RxDbgTrace(0,Dbg,("SmbPseOE allocating hdr partial\n"));
        SubmitMdl = StufferState->HeaderPartialMdl = RxAllocateMdl( StufferState->BufferBase,
                                                        MmGetMdlByteCount(StufferState->HeaderMdl) );
        if (SubmitMdl==NULL) {
            RxDbgTrace(0,Dbg,("SmbPseOE cant get partial for submit mdl\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }
    }

    ASSERT(RxMdlIsOwned(SubmitMdl));
    IoBuildPartialMdl( StufferState->HeaderMdl,
                       SubmitMdl,
                       StufferState->BufferBase,
                       SmbLength );
    SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_PARTIAL_INITIALIZED);

    //
    // If there is a data MDL associated with this request, then
    // we'll have to chain it.
    //

    SubmitMdl->Next = StufferState->DataMdl;
    if (StufferState->DataMdl) {
        SmbLength += StufferState->DataSize;
    }

#if DBG
    SmbPseDbgRunMdlChain(SubmitMdl,SmbLength,OrdinaryExchange,"SmbPseOrdinaryExchange(before)");
    OrdinaryExchange->SaveDataMdlForDebug = SubmitMdl->Next;
    OrdinaryExchange->SaveLengthForDebug = SmbLength;
    if (OrdinaryExchange->RxContextCapturedRequestPacket != NULL) {
       OrdinaryExchange->SaveIrpMdlForDebug = OrdinaryExchange->RxContextCapturedRequestPacket->MdlAddress;
    }
#endif

    RxDbgTrace( 0, Dbg, ("  --> mdllength/smblength %08lx/%08lx headermdl %08lx\n",
                         MmGetMdlByteCount(SubmitMdl), SmbLength, StufferState->HeaderMdl) );

    ClearFlag( OrdinaryExchange->Flags,
                  (SMBPSE_OE_FLAG_HEADER_ALREADY_PARSED
                   | SMBPSE_OE_FLAG_OE_ALREADY_RESUMED)
             );

    SendOptions = OrdinaryExchange->SendOptions;

    SmbCeReferenceExchange( Exchange );  //this one is taken away in ContinueOE
    SmbCeReferenceExchange( Exchange );  //this one is taken away below...
                                                       //i must NOT finalize before SmbCe returns
    SmbCeResetExchange(Exchange);

    Continuation = OrdinaryExchange->Continuation;
    if ( ((OrdinaryExchange->OEType == SMBPSE_OETYPE_WRITE)
                              || (OrdinaryExchange->OEType == SMBPSE_OETYPE_READ)
                              || (OrdinaryExchange->OEType == SMBPSE_OETYPE_LOCKS))
         && BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)
       ) {
        ASSERT(Continuation!=NULL);
    }

    RxProtectMdlFromFree(SubmitMdl);
    RxProtectMdlFromFree(HeaderFullMdl);
    SmbPseOEAssertConsistentLinkage("just before transceive: ");

    UPDATE_OE_HISTORY_2SHORTS('eo',(Continuation!=NULL)?'!!':0);
    DbgDoit( InterlockedIncrement(&OrdinaryExchange->History.Submits); )

    if (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID)) {
       PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
       PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);

       if (smbSrvOpen->Version == OrdinaryExchange->SmbCeContext.pServerEntry->Server.Version) {
          Status = STATUS_SUCCESS;
       } else {
           DbgPrint("HANDLE VERSION MISMATCH!!!!");
           Exchange->SmbStatus = Status = STATUS_INVALID_HANDLE;
       }

       IF_DEBUG {
           PSMB_HEADER pSmbHeader = (PSMB_HEADER)MmGetSystemAddressForMdl(SubmitMdl);
           USHORT Flags2 = SmbGetUshort(&pSmbHeader->Flags2);
           RxDbgTrace(0, Dbg, ("Flags2 Value for Exchange %lx is %lx\n",Exchange,Flags2));
       }
    } else {
       Status = STATUS_SUCCESS;
    }

    if (Status == STATUS_SUCCESS) {
       if (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_NO_RESPONSE_EXPECTED)) {
          Status = SmbCeSend(
                      Exchange,
                      SendOptions,
                      SubmitMdl,
                      SmbLength);
       } else {
           ASSERT(SmbLength <= OrdinaryExchange->SmbCeContext.pServerEntry->Server.MaximumBufferSize);
           Status = SmbCeTranceive(
                      Exchange,
                      SendOptions,
                      SubmitMdl,
                      SmbLength);
       }
    }

    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);  //okay to finalize now that we're back

    if ( Status == STATUS_PENDING ) {
        if ( Continuation != NULL ) {
            goto FINALLY;
        }

        UPDATE_OE_HISTORY_WITH_STATUS('1o');
        RxWaitSync( RxContext );
        ASSERT(RxMdlIsOwned(SubmitMdl));
    } else {
        RxDbgTrace (0, Dbg, ("  -->Status after transceive %08lx\n",Status));
        RxUnprotectMdlFromFree(SubmitMdl);
        RxUnprotectMdlFromFree(HeaderFullMdl);
        SmbPseOEAssertConsistentLinkage("nonpending return from transceive: ");
        // if it's an error, remove the references that i placed and get out
        if (NT_ERROR(Status)) {
            SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
            goto FINALLY;
        }
    }

    //at last, call the continuation........

    SmbPseOEAssertConsistentLinkage("just before continueOE: ");
    Status = SmbPseContinueOrdinaryExchange( RxContext );
    UPDATE_OE_HISTORY_WITH_STATUS('9o');

FINALLY:
    RxDbgTrace(-1, Dbg, ("SmbPseOrdinaryExchange returning %08lx.\n", Status));
    return(Status);

} // SmbPseOrdinaryExchange



//#define MRXSMB_TEST_MUST_SUCCEED
#ifdef MRXSMB_TEST_MUST_SUCCEED
ULONG MRxSmbAllocatedMustSucceedExchange;
ULONG MRxSmbAllocatedMustSucceedSmbBuf;
#define MSFAILPAT ((0x3f)<<2)
#define FAIL_XXX_ALLOCATE() (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_MUST_SUCCEED_ALLOCATED) \
                                    &&((RxContext->SerialNumber&MSFAILPAT)==MSFAILPAT) \
                                    &&((MRxSmbEntryPointIsMustSucceedable[EntryPoint])) )
#define FAIL_EXCHANGE_ALLOCATE() ( FAIL_XXX_ALLOCATE() && (RxContext->SerialNumber&2) )
#define FAIL_SMBBUF_ALLOCATE()   ( FAIL_XXX_ALLOCATE() && (RxContext->SerialNumber&1) )
#define COUNT_MUST_SUCCEED_EXCHANGE_ALLOCATED() {MRxSmbAllocatedMustSucceedExchange++;}
#define COUNT_MUST_SUCCEED_SMBBUF_ALLOCATED() {MRxSmbAllocatedMustSucceedSmbBuf++;}
#define MUST_SUCCEED_ASSERT(x) {ASSERT(x);}
#else
#define FAIL_EXCHANGE_ALLOCATE() (FALSE)
#define FAIL_SMBBUF_ALLOCATE()   (FALSE)
#define COUNT_MUST_SUCCEED_EXCHANGE_ALLOCATED() {NOTHING;}
#define COUNT_MUST_SUCCEED_SMBBUF_ALLOCATED() {NOTHING;}
#define MUST_SUCCEED_ASSERT(x) {NOTHING;}
#endif

PSMB_PSE_ORDINARY_EXCHANGE
SmbPseCreateOrdinaryExchange (
    IN PRX_CONTEXT RxContext,
    IN PMRX_V_NET_ROOT VNetRoot,
    IN SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint,
    IN PSMB_PSE_OE_START_ROUTINE StartRoutine
    //IN PSMB_EXCHANGE_DISPATCH_VECTOR DispatchVector
    )
/*++

Routine Description:

   This routine allocates and initializes an SMB header buffer. Currently,
   we just allocate them from pool except when must_succeed is specified.

Arguments:

    RxContext       - the RDBSS context
    VNetRoot        -
    DispatchVector  -

Return Value:

    A buffer ready to go, OR NULL.

Notes:



--*/
{
    PMRXIFS_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);
    PSMBSTUFFER_BUFFER_STATE StufferState = NULL;
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = NULL;
    PSMBPSE_MUST_SUCCEEED_CONTEXT MustSucceedContext = NULL;
    PCHAR SmbBuffer = NULL;
    PMDL HeaderFullMdl = NULL;
    NTSTATUS Status;
    RxCaptureFobx;

    RxDbgTrace( +1, Dbg, ("MRxSmbCreateSmbStufferState\n") );

    if (!FAIL_EXCHANGE_ALLOCATE()) {
        OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)SmbMmAllocateExchange(ORDINARY_EXCHANGE,NULL);
    }

    //we rely on the fact that SmbMmAllocate Zeros the exchange.............
    if ( OrdinaryExchange == NULL ) {
        //ASSERT(!"must-succeed");
        if (!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_MUST_SUCCEED_ALLOCATED)
               || !MRxSmbEntryPointIsMustSucceedable[EntryPoint]) {
            RxDbgTrace( 0, Dbg, ("  --> Couldn't get the exchange!\n") );
            MUST_SUCCEED_ASSERT(!"failing the exchange");
            return NULL;
        }
        MustSucceedContext = RxAcquireMustSucceedStructure(&SmbPseMustSucceedDescriptor[SmbPseMustSucceed]);
        COUNT_MUST_SUCCEED_EXCHANGE_ALLOCATED();
        OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)SmbMmAllocateExchange(ORDINARY_EXCHANGE,
                                                                             &MustSucceedContext->ExchangeListEntry);
        SetFlag( OrdinaryExchange->Flags, SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_OE );
        SetFlag( OrdinaryExchange->Flags, SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_SMBBUF );
        SmbBuffer = (PBYTE)&MustSucceedContext->SmbBuf;
        OrdinaryExchange->SmbBufSize = sizeof(SMBPSE_VESTIGIAL_SMBBUF);
    }

    StufferState = &OrdinaryExchange->AssociatedStufferState;
    StufferState->NodeTypeCode = SMB_NTC_STUFFERSTATE;
    StufferState->NodeByteSize = sizeof(SMBSTUFFER_BUFFER_STATE);
    StufferState->Exchange = &OrdinaryExchange->Exchange;

    DbgDoit(OrdinaryExchange->SerialNumber = RxContext->SerialNumber);

    //
    // Initialize the exchange packet
    //

    SmbCeInitializeExchange( &StufferState->Exchange,
                             (PMRX_V_NET_ROOT)VNetRoot,
                             ORDINARY_EXCHANGE,
                             &SmbPseOEDispatch);

    SmbCeReferenceExchange(StufferState->Exchange);
    RxDbgTrace(0, Dbg, ("  exchng=%08lx,type=%08lx\n",&StufferState->Exchange,StufferState->Exchange->Type));

    StufferState->RxContext = RxContext;
    //place a reference on the rxcontext until we are finished
    InterlockedIncrement( &RxContext->ReferenceCount );

    OrdinaryExchange->StufferStateDbgPtr = StufferState;
    OrdinaryExchange->RxContext = RxContext;
    OrdinaryExchange->EntryPoint = EntryPoint;
    OrdinaryExchange->StartRoutine = StartRoutine;
    OrdinaryExchange->SmbBufSize = MAXIMUM_SMB_BUFFER_SIZE;

    DbgDoit(OrdinaryExchange->RxContextCapturedRequestPacket = RxContext->CurrentIrp;);

    //note: create path must turn this flag on.
    OrdinaryExchange->SmbCeFlags &= ~(SMBCE_EXCHANGE_ATTEMPT_RECONNECTS);

    ASSERT( (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_OE))
                       ||  (OrdinaryExchange->Flags == 0) );
    ASSERT( OrdinaryExchange->SendOptions == 0 );
    ASSERT( OrdinaryExchange->DataPartialMdl == NULL );

    pMRxSmbContext->pExchange     = &OrdinaryExchange->Exchange;
    pMRxSmbContext->pStufferState = StufferState;


    if (capFobx != NULL) {
       if (BooleanFlagOn(capFobx->Flags,FOBX_FLAG_DFS_OPEN)) {
          SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_TURNON_DFS_FLAG);
       }
    } else if (BooleanFlagOn(VNetRoot->pNetRoot->Flags,NETROOT_FLAG_DFS_AWARE_NETROOT)) {
       SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_TURNON_DFS_FLAG);
    }

    //
    // Allocate the SmbBuffer
    //

    if ( (SmbBuffer == NULL) && !FAIL_SMBBUF_ALLOCATE() ) {
        SmbBuffer = (PCHAR)RxAllocatePoolWithTag( PagedPool,OrdinaryExchange->SmbBufSize,'BMSx' );
    }

    if ( SmbBuffer == NULL ) {
        if (!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_MUST_SUCCEED_ALLOCATED)
               || !MRxSmbEntryPointIsMustSucceedable[EntryPoint]) {
            RxDbgTrace( 0, Dbg, ("  --> Couldn't get the smb buf!\n") );
            MUST_SUCCEED_ASSERT(!"failed the smbbuf");
            goto UNWIND;
        }
        MustSucceedContext = RxAcquireMustSucceedStructure(&SmbPseMustSucceedDescriptor[SmbPseMustSucceed]);
        COUNT_MUST_SUCCEED_SMBBUF_ALLOCATED();
        SetFlag( OrdinaryExchange->Flags, SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_SMBBUF );
        SmbBuffer = (PBYTE)&MustSucceedContext->SmbBuf;
        OrdinaryExchange->SmbBufSize = sizeof(SMBPSE_VESTIGIAL_SMBBUF);
    }

    RxDbgTrace(0, Dbg, ("  smbbuf=%08lx,stfstate=%08lx\n",SmbBuffer,StufferState));

    StufferState->ActualBufferBase =  SmbBuffer;
    StufferState->BufferBase       =  SmbBuffer;
    StufferState->BufferLimit      =  SmbBuffer + OrdinaryExchange->SmbBufSize;

    //
    // Init the HeaderMdl
    //

    HeaderFullMdl = StufferState->HeaderMdl = &OrdinaryExchange->HeaderMdl.Mdl;
    MmInitializeMdl(HeaderFullMdl,SmbBuffer, OrdinaryExchange->SmbBufSize);

    RxDbgTrace( 0, Dbg, ("  --> smbbufsize %08lx, mdllength %08lx\n",
                        OrdinaryExchange->SmbBufSize,
                        MmGetMdlByteCount(HeaderFullMdl)));

    //
    //finally, lock down the smbbuf taking different paths according to whether we are must-succeed or not

    ASSERT( !RxMdlIsLocked(HeaderFullMdl) );
    ASSERT( HeaderFullMdl->Next == NULL );

    if (MustSucceedContext==NULL) {
        RxDbgTrace( 0, Dbg, ("  --> LOCKING %08lx\n",HeaderFullMdl));
        RxProbeAndLockPages( HeaderFullMdl,
                             KernelMode,
                             IoModifyAccess,
                             Status );
        if (Status != STATUS_SUCCESS) {
            RxDbgTrace( 0, Dbg, ("  --> LOCKING FAILED\n"));
            MUST_SUCCEED_ASSERT(!"LockingFailed");
            goto UNWIND;
        }
        SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_LOCKED);
        MmGetSystemAddressForMdl(HeaderFullMdl); //and map!
    } else {
        RxDbgTrace( 0, Dbg, ("  --> LOCKING %08lx\n",HeaderFullMdl));
        MmBuildMdlForNonPagedPool(HeaderFullMdl);
        //also set up the data partial
        OrdinaryExchange->DataPartialMdl = &MustSucceedContext->DataPartialMdl.Mdl;
    }

    //
    // No initialization is required for the partial...just set the pointer

    StufferState->HeaderPartialMdl = &OrdinaryExchange->HeaderPartialMdl.Mdl;

    RxDbgTrace( -1, Dbg, ("  --> exiting w!\n") );
    return(OrdinaryExchange);


UNWIND:
    RxDbgTrace( -1, Dbg, ("  --> exiting w/o!\n") );
    MUST_SUCCEED_ASSERT(!"Finalizing on the way out");
    SmbPseFinalizeOrdinaryExchange( OrdinaryExchange );
    return(NULL);

} // MRxSmbCreateSmbStufferState



#if DBG
ULONG MRxSmbFinalizeStfStateTraceLevel = 1200;
#define FINALIZESS_LEVEL MRxSmbFinalizeStfStateTraceLevel
#define FINALIZE_TRACKING_SETUP() \
    struct {                    \
        ULONG marker1;          \
        ULONG finalstate;       \
        ULONG marker2;          \
    } Tracking = {'ereh',0,'ereh'};
#define FINALIZE_TRACKING(x) {\
    Tracking.finalstate |= x; \
    }

#define FINALIZE_TRACE(x) SmbPseFinalizeOETrace(x,Tracking.finalstate)
VOID
SmbPseFinalizeOETrace(PSZ text,ULONG finalstate)
{
    RxDbgTraceLV(0, Dbg, FINALIZESS_LEVEL,
                   ("MRxSmbFinalizeSmbStufferState  --> %s(%08lx)\n",text,finalstate));
}
#else
#define FINALIZE_TRACKING_SETUP()
#define FINALIZE_TRACKING(x)
#define FINALIZE_TRACE(x)
#endif

BOOLEAN
SmbPseFinalizeOrdinaryExchange (
    IN OUT PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange
    )
/*++

Routine Description:

    This finalizes an OE.

Arguments:

    OrdinaryExchange - pointer to the OE to be dismantled.

Return Value:

    TRUE if finalization occurs otherwise FALSE.

Notes:



--*/
{
    PMRXIFS_RX_CONTEXT pMRxSmbContext;
    PSMBSTUFFER_BUFFER_STATE StufferState;
    LONG result;
    ULONG OrdinaryExchangeFlags = OrdinaryExchange->Flags;
    ULONG ThisIsMustSucceedAllocated =
              OrdinaryExchangeFlags & (SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_SMBBUF
                                           |SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_OE);
    FINALIZE_TRACKING_SETUP()

    SmbPseOEAssertConsistentLinkageFromOEwithFlags("SmbPseFinalizeOrdinaryExchange:",OECHKLINKAGE_FLAG_NO_REQPCKT_CHECK);
    StufferState = &OrdinaryExchange->AssociatedStufferState;
    pMRxSmbContext = MRxSmbGetMinirdrContext(StufferState->RxContext);

    RxDbgTraceLV(+1, Dbg, 1000, ("MRxSmbFinalizeSmbStufferState\n"));

    result =  SmbCeDereferenceExchange(&OrdinaryExchange->Exchange);
    if ( result != 0 ) {
        RxDbgTraceLV(-1, Dbg, 1000, ("MRxSmbFinalizeSmbStufferState -- returning w/o finalizing (%d)\n",result));
        return FALSE;
    }

    RxLog((">>>OE %lx %lx %lx %lx %lx",
            OrdinaryExchange,
            OrdinaryExchange->DataPartialMdl,
            StufferState->HeaderPartialMdl,
            StufferState->HeaderMdl,
            OrdinaryExchange->Flags
         ));

    FINALIZE_TRACKING( 0x10000000 );
    FINALIZE_TRACE("ready to freedatapartial");
    if(FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_SMBBUF_IS_A_MDL)){
        MmPrepareMdlForReuse((PMDL)(OrdinaryExchange->AssociatedStufferState.BufferBase));
    }
    SmbPseVerifyDataPartialAllocationPerFlags(OrdinaryExchange);
    if ( OrdinaryExchange->DataPartialMdl ) {
        if (!FlagOn(OrdinaryExchangeFlags, SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_SMBBUF)) {
            IoFreeMdl( OrdinaryExchange->DataPartialMdl );
            FINALIZE_TRACKING( 0x8000000 );
        }
    }

    if (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_LOCKED)) {
        MmUnlockPages(StufferState->HeaderMdl);
        ClearFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_LOCKED);
        MmPrepareMdlForReuse( StufferState->HeaderMdl );
        FINALIZE_TRACKING( 0x4000000 );
    }

    FINALIZE_TRACE("ready to uninit hdr partial");
    if (FlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_HDR_PARTIAL_INITIALIZED)) {
        MmPrepareMdlForReuse( StufferState->HeaderPartialMdl ); //no harm in calling this multiple times
        FINALIZE_TRACKING( 0x300000 );
    } else {
        FINALIZE_TRACKING( 0xf00000 );
    }

    if (!FlagOn(OrdinaryExchangeFlags, SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_SMBBUF)) {
        FINALIZE_TRACE("ready to freepool actualbuffer");
        if ( StufferState->ActualBufferBase != NULL ) {
            RxFreePool( StufferState->ActualBufferBase );
            FINALIZE_TRACKING( 0x5000 );
        } else {
            FINALIZE_TRACKING( 0xf000 );
        }
    }

    if ( StufferState->RxContext != NULL ) {
        ASSERT( pMRxSmbContext->pExchange == &OrdinaryExchange->Exchange );
        ASSERT( pMRxSmbContext->pStufferState == StufferState );

        //get rid of the reference on the RxContext....if i'm the last guy this will finalize
        RxDereferenceAndDeleteRxContext( StufferState->RxContext );
        FINALIZE_TRACKING( 0x600 );
    } else {
        FINALIZE_TRACKING( 0xf00 );
    }

    FINALIZE_TRACE("ready to discard exchange");
    SmbCeDiscardExchange(OrdinaryExchange);
    FINALIZE_TRACKING( 0x2000000 );

    if (ThisIsMustSucceedAllocated) {
        RxReleaseMustSucceedStructure(&SmbPseMustSucceedDescriptor[SmbPseMustSucceed]);
    }


    FINALIZE_TRACKING( 0x8 );
    RxDbgTraceLV(-1, Dbg, 1000, ("MRxSmbFinalizeSmbStufferState  --> exit finalstate=%x\n",Tracking.finalstate));
    return(TRUE);

} // MRxSmbFinalizeSmbStufferState



NTSTATUS
SmbPseExchangeFinalize_default(
    IN OUT PSMB_EXCHANGE  pExchange,
    OUT    BOOLEAN        *pPostFinalize
    )
/*++

Routine Description:


Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                                        (PSMB_PSE_ORDINARY_EXCHANGE)pExchange;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;

    UPDATE_OE_HISTORY_WITH_STATUS('ff');
    SmbPseOEAssertConsistentLinkageFromOE("SmbPseExchangeFinalize_default: ");

    if (OrdinaryExchange->SmbStatus != STATUS_SUCCESS) {
        OrdinaryExchange->Status = OrdinaryExchange->SmbStatus;
    }

    if (OrdinaryExchange->Continuation!=NULL) {
        NTSTATUS PostStatus;
        RxDbgTraceLV(0, Dbg, 1000, ("Resume with post-to-async\n"));
        //SetFlag(RxContext->Flags,RX_CONTEXT_FLAG_NO_COMPLETE_FROM_FSP);
        //RxFsdPostRequestWithResume(RxContext,SmbPseContinueOrdinaryExchange);SMBPSE_OE_FLAG_OE_AWAITING_DISPATCH
        SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_OE_AWAITING_DISPATCH);
        IF_DEBUG {
            //fill the workqueue structure with deadbeef....all the better to diagnose
            //a failed post
            ULONG i;
            for (i=0;i+sizeof(ULONG)-1<sizeof(OrdinaryExchange->WorkQueueItem);i+=sizeof(ULONG)) {
                //*((PULONG)(((PBYTE)&OrdinaryExchange->WorkQueueItem)+i)) = 0xdeadbeef;
                PBYTE BytePtr = ((PBYTE)&OrdinaryExchange->WorkQueueItem)+i;
                PULONG UlongPtr = (PULONG)BytePtr;
                *UlongPtr = 0xdeadbeef;
            }
        }
        PostStatus = RxPostToWorkerThread(MRxIfsDeviceObject,
                                          CriticalWorkQueue,
                                          //&OrdinaryExchange->WorkQueueItemForOE,
                                          &OrdinaryExchange->WorkQueueItem,
                                          SmbPseContinueOrdinaryExchange,
                                          RxContext);
        ASSERT(PostStatus == STATUS_SUCCESS);
    } else {
        RxDbgTraceLV(0, Dbg, 1000, ("sync resume\n"));
        RxSignalSynchronousWaiter(RxContext);
    }
    *pPostFinalize = FALSE;
    return STATUS_SUCCESS;
}

NTSTATUS
SmbPseExchangeSendCallbackHandler_default(
    IN PSMB_EXCHANGE 	pExchange,
    IN PMDL       pXmitBuffer,
    IN NTSTATUS         SendCompletionStatus
    )
/*++

Routine Description:

    This is the send call back indication handling routine for ordinary
    exchanges.

Arguments:

    pExchange            - the exchange instance
    pXmitBuffer          - pointer to the transmit buffer MDL
    BytesSent            - number of bytes transmitted
    SendCompletionStatus - status for the send

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                                    (PSMB_PSE_ORDINARY_EXCHANGE)pExchange;

    SmbPseOEAssertConsistentLinkageFromOE("SmbPseExchangeSendCallbackHandler_default: ");
    UPDATE_OE_HISTORY_WITH_STATUS('cs');

    if (!NT_SUCCESS(SendCompletionStatus)) {
        pExchange->Status = SendCompletionStatus;
    }

    SmbPseDbgRunMdlChain(OrdinaryExchange->AssociatedStufferState.HeaderPartialMdl,
                         OrdinaryExchange->SaveLengthForDebug,
                         OrdinaryExchange,"SmbPseExchangeSendCallbackHandler_default");

    return STATUS_SUCCESS;

} // SmbPseExchangeSendCallbackHandler_default



NTSTATUS
SmbPseExchangeStart_default(
    IN PSMB_EXCHANGE 	pExchange
    )
/*++

Routine Description:

    This is the start routine for ordinary exchanges. irght now this is just a simple wrapper.

Arguments:

    pExchange - the exchange instance NOT an Ordinary Exchange

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                                    (PSMB_PSE_ORDINARY_EXCHANGE)pExchange;

    return OrdinaryExchange->StartRoutine((PSMB_PSE_ORDINARY_EXCHANGE)pExchange,
                                           pExchange->RxContext);

} // SmbPseExchangeStart_default


NTSTATUS
SmbPseExchangeCopyDataHandler_default(
    IN PSMB_EXCHANGE 	pExchange,
    IN PMDL             pCopyDataBuffer,
    IN ULONG            CopyDataSize
    )
/*++

Routine Description:

    This is the copy data handling routine for ordinary exchanges.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                                    (PSMB_PSE_ORDINARY_EXCHANGE)pExchange;

    SmbPseOEAssertConsistentLinkageFromOE("SmbPseExchangeCopyDataHandler_default: ");
    UPDATE_OE_HISTORY_WITH_STATUS('dd');

    OrdinaryExchange->MessageLength = CopyDataSize;
    pExchange->Status = STATUS_MORE_PROCESSING_REQUIRED;
    return STATUS_SUCCESS;
} // SmbPseExchangeCopyDataHandler_default

NTSTATUS
SmbPseExchangeReceive_default(
    IN  struct _SMB_EXCHANGE *pExchange,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    OUT ULONG       *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pDataBufferPointer,
    OUT PULONG      pDataSize
    )
/*++

Routine Description:

    This is the receive indication handling routine for ordinary exchanges

Arguments:

    pExchange - the exchange instance

    BytesIndicated - the number of bytes indicated

    Bytes Available - the number of bytes available

    pBytesTaken     - the number of bytes consumed

    pSmbHeader      - pointer to the data buffer

    pDataBufferPointer - pointer to the buffer Mdl into which the remaining
                         data is to be copied.

    pDataSize       - the buffer size.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine is called at DPC level directly from the tdi receive event handler. BUT, it is also called
    at task time from SmbPseContinueOrdinaryExchange. Often, we cannot complete processing from DPClevel because
    fileobjects, fcbs, srvopens, and fobx are pageable and not locked.

--*/
{
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                                    (PSMB_PSE_ORDINARY_EXCHANGE)pExchange;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;

    NTSTATUS SmbStatus;
    NTSTATUS Status = STATUS_SUCCESS;
    PGENERIC_ANDX CommandState;
    UCHAR Command;
    ULONG CopyBufferLength;
    BOOLEAN ThisIsAReenter = BooleanFlagOn(OrdinaryExchange->Flags,
                                        SMBPSE_OE_FLAG_HEADER_ALREADY_PARSED);
    PLOWIO_CONTEXT LowIoContext;
    ULONG ByteCount;
    ULONG Remain;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    PCHAR startVa;

    SmbPseOEAssertConsistentLinkage("SmbPseExchangeReceive_default: ");
    UPDATE_OE_HISTORY_WITH_STATUS(ThisIsAReenter?'00':'01');

    RxDbgTrace (0, Dbg, ("SmbPseExchangeReceive_default av/ind=%08lx/%08lx\n",
                           BytesAvailable,BytesIndicated)
                );
    RxDbgTrace (0, Dbg, ("  -->headermdl %08lx\n",StufferState->HeaderMdl));
    ASSERT_ORDINARY_EXCHANGE( OrdinaryExchange );

    CommandState = &OrdinaryExchange->ParseResumeState;

    if ( !ThisIsAReenter ) {
        pExchange->Status = SmbCeParseSmbHeader(
                                 pExchange,
                                 pSmbHeader,
                                 CommandState,
                                 &OrdinaryExchange->SmbStatus,
                                 BytesAvailable,
                                 BytesIndicated,
                                 pBytesTaken);
        UPDATE_OE_HISTORY_WITH_STATUS('22');

        if ( pExchange->Status == STATUS_MORE_PROCESSING_REQUIRED) {
            goto COPY_FOR_RESUME;
        }

        if ( (pExchange->Status != STATUS_SUCCESS) ){
            RxLog(("OErcv errorstatus %lx %lx %lx",pExchange->Status,RxContext,OrdinaryExchange));
        }

        if ( (pExchange->Status != STATUS_SUCCESS) ||
             ( (Command = OrdinaryExchange->ParseResumeState.AndXCommand) == SMB_COM_NO_ANDX_COMMAND) ) {
            goto FINALLY;
        }

        SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_HEADER_ALREADY_PARSED);

    } else {

        RxDbgTrace (0, Dbg, ("  -->this is a reenter\n"));
        Command = CommandState->AndXCommand;
    }

    SmbStatus = OrdinaryExchange->SmbStatus;

    if ( (SmbStatus!=STATUS_SUCCESS) ) {
        RxDbgTrace (0, Dbg, ("  STATUS NOT SUCCESS = %08lx\n", SmbStatus));
    }

    for ( ; Command != SMB_COM_NO_ANDX_COMMAND ; ) {
        PSMBPSE_RECEIVE_MODEL_PARAMETERS ReceiveModelParams = &SmbPseReceiveModelParameters[Command];
        ULONG ReceiveModelParamsFlags;
        UCHAR mappedCommand = Command;
        PCHAR Response = (PCHAR)pSmbHeader + SmbGetUshort(&CommandState->AndXOffset);

        OrdinaryExchange->LastSmbCommand = Command; //this is used to multiplex in finish routines
        UPDATE_OE_HISTORY_WITH_STATUS('88');

        //
        // Case on the Smb Command Type
        //

        ReceiveModelParamsFlags = ReceiveModelParams->Flags;
        if (ReceiveModelParamsFlags!=0) {

            //map this onto read_andx....which is the arm of the switch that implements the model
            mappedCommand = SMB_COM_READ_ANDX;

        } else {

            //
            // If there's a continuation, then copy&post. it used to always do this. now, we're
            // going to do it unless the command is modeled. the modeling code will take care of
            // correctly deciding to post/nopost.
            //

            if ( (OrdinaryExchange->Continuation != NULL) && !ThisIsAReenter ) {
                goto COPY_FOR_RESUME;
            }

        }

        switch (mappedCommand) {

        case SMB_COM_READ_ANDX:{
            NTSTATUS FinishStatus = STATUS_SUCCESS;
            NTSTATUS FinalStatus = STATUS_SUCCESS;
            BOOLEAN ThisIsAnAndX = BooleanFlagOn(ReceiveModelParamsFlags,SMBPSE_RMP_THIS_IS_ANDX);
            BOOLEAN ThisWouldBeMyError = (IM_THE_LAST_GUY || !ThisIsAnAndX);

            RxDbgTrace( 0, Dbg, ("  *(ind) %s, smbstatus=%08lx\n",ReceiveModelParams->IndicationString,SmbStatus) );
            IF_DEBUG {
                BOOLEAN BadType = FALSE;
                DbgDoit(BadType = (OrdinaryExchange->OEType < ReceiveModelParams->LowType)
                                    ||  (OrdinaryExchange->OEType > ReceiveModelParams->HighType) );
                if (BadType) {
                    DbgPrint("Bad OEType....%u,Cmd=%02lx,Exch=%08lx\n",OrdinaryExchange->OEType,Command,OrdinaryExchange);
                    ASSERT(!"proceed???");
                }
            }

            //
            // If this is an error and it's an error for this guy of the AndX chain then finishup
            // If it's a warning tho, continue according to the Flags
            //

            if ( NT_ERROR(SmbStatus) && ThisWouldBeMyError ) {

                SmbPseDiscardProtocol( SmbStatus );
                RxDbgTrace( 0, Dbg, ("--->discard1\n"));
                goto FINALLY;

            } else if ( (SmbStatus != STATUS_SUCCESS) && ThisWouldBeMyError ) {

                if (!FlagOn(ReceiveModelParamsFlags,SMBPSE_RMP_WARNINGS_OK)) {
                    SmbPseDiscardProtocol(SmbStatus);
                    RxDbgTrace( 0, Dbg, ("--->discard1\n"));
                    goto FINALLY;
                } else {
                    FinalStatus = SmbStatus;
                }

            }

            // if there's no nocopy handler then do things the old way

            if (!FlagOn(ReceiveModelParamsFlags,SMBPSE_RMP_NOCOPY_HANDLER)) {
                // TEMPORARY!!!!!!
                // If there's a continuation, then copy&post. it used to always do this. now, we're
                // going to do it unless the command is modeled. the modeling code will take care of
                // correctly deciding to post/nopost.
                //

                if ( (OrdinaryExchange->Continuation != NULL) && !ThisIsAReenter ) {
                    goto COPY_FOR_RESUME;
                }


                //eventually, we'll finish from here but for now copy
                if (RxShouldPostCompletion()) {
                    goto COPY_FOR_RESUME;
                }

                if (ReceiveModelParams->ReceiveHandlerToken < SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM){
                    PSMBPSE_RECEIVE_HANDLER ReceiveHandler = SmbPseReceiveHandlers[ReceiveModelParams->ReceiveHandlerToken];
                    FinishStatus = ReceiveHandler( OrdinaryExchange, Response);
                }
            } else {
                PSMBPSE_NOCOPY_RECEIVE_HANDLER NoCopyReceiveHandler =
                          (PSMBPSE_NOCOPY_RECEIVE_HANDLER)(SmbPseReceiveHandlers[ReceiveModelParams->ReceiveHandlerToken]);
                UCHAR Action;
                OrdinaryExchange->NoCopyFinalStatus = FinalStatus;
                Action = NoCopyReceiveHandler(
                               OrdinaryExchange,
                               BytesIndicated,
                               BytesAvailable,
                               pBytesTaken,
                               pSmbHeader,
                               pDataBufferPointer,
                               pDataSize,
#if DBG
                               ThisIsAReenter,
#endif
                               Response
                               );
                switch(Action){
                case SMBPSE_NOCOPYACTION_NORMALFINISH:
                    NOTHING;
                    break;
                case SMBPSE_NOCOPYACTION_MDLFINISH:
                    Status = STATUS_MORE_PROCESSING_REQUIRED;
                    //note that whatever does this must be the last command in the packet
                    //unless we make continueOE more complicated
                    goto FINALLY;
                case SMBPSE_NOCOPYACTION_COPY_FOR_RESUME:
                    goto COPY_FOR_RESUME;
                case SMBPSE_NOCOPYACTION_DISCARD:
                    SmbPseDiscardProtocol( FinishStatus );
                    RxDbgTrace( 0, Dbg, ("--->discardX\n"));
                    goto FINALLY;
                }
            }

            pExchange->Status =  (FinishStatus==STATUS_SUCCESS)
                                   ?FinalStatus:FinishStatus;

            if (!ThisIsAnAndX) {
                Response = (PCHAR)&NullGenericAndX;
            }

            }//this corresponds to the top level of the switch
            break;


        default:
            ASSERT( !"taking a command that's not implemented" );
            RxDbgTrace( 0, Dbg, ("  *(ind) Unimplemented cmd=%02lx,wct=%02lx\n",
                                              Command,*Response) );

            pExchange->Status = STATUS_NOT_IMPLEMENTED;
            goto FINALLY;
        }

        CommandState = (PGENERIC_ANDX)Response;
        Command = CommandState->AndXCommand;
    }

    //
    // If we get here then we're done.
    // Make everyone happy by taking all the bytes.
    //

    *pBytesTaken = BytesAvailable;
    goto FINALLY;


COPY_FOR_RESUME:
    ASSERT( !ThisIsAReenter );

    // even if we are taking by copy (as opposed to tail-MDL
    // which is how reads should work) we shouldn't copy the whole packet -
    // just the residue. of course, this is really only an issue when we have
    // significant andXing.

    CopyBufferLength = MmGetMdlByteCount(StufferState->HeaderMdl);

    ASSERT( BytesAvailable <= CopyBufferLength );

    if ( (BytesAvailable > BytesIndicated)
         || (BytesAvailable > 127) ) {

        RxDbgTrace( 0, Dbg, ("Taking data through MDL\n") );
        // Pass an MDL back in for copying the data
        *pDataBufferPointer = StufferState->HeaderMdl;
        *pDataSize    = CopyBufferLength;
        *pBytesTaken  = 0;
        Status = STATUS_MORE_PROCESSING_REQUIRED;

    } else {

        // Copy the data and resume the exchange
        ASSERT( BytesAvailable == BytesIndicated );
        RxDbgTrace( 0, Dbg, ("Taking data through copying\n") );
        *pBytesTaken = OrdinaryExchange->MessageLength = BytesAvailable;

        RtlCopyMemory(StufferState->BufferBase,
                      pSmbHeader,BytesIndicated);

        pExchange->Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

FINALLY:
    OrdinaryExchange->ParseResumeState = *CommandState;
    UPDATE_OE_HISTORY_WITH_STATUS('99');
    return Status;

} // SmbPseExchangeReceive_default




#define SmbPseRIStringsBufferSize 500
CHAR SmbPseReceiveIndicationStringsBuffer[SmbPseRIStringsBufferSize];
ULONG SmbPseRIStringsBufferUsed = 0;

VOID
__SmbPseRMTableEntry(
    UCHAR SmbCommand,
    UCHAR Flags,
    SMBPSE_RECEIVE_HANDLER_TOKEN ReceiveHandlerToken,
    PSMBPSE_RECEIVE_HANDLER ReceiveHandler
#if DBG
    ,
    PBYTE IndicationString,
    SMB_PSE_ORDINARY_EXCHANGE_TYPE LowType,
    SMB_PSE_ORDINARY_EXCHANGE_TYPE HighType
#endif
    )
{
    PSMBPSE_RECEIVE_MODEL_PARAMETERS r = &SmbPseReceiveModelParameters[SmbCommand];
#if DBG
    ULONG ISlength = strlen(IndicationString)+1;
#endif

    //DbgDoit(DbgPrint("RMT %x %s\n",SmbCommand,IndicationString););
    r->Flags = SMBPSE_RMP_MODELED | Flags;
    r->ReceiveHandlerToken = (UCHAR)ReceiveHandlerToken;
    if (ReceiveHandlerToken < SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM){
        ASSERT((SmbPseReceiveHandlers[ReceiveHandlerToken] == ReceiveHandler)
                   || (SmbPseReceiveHandlers[ReceiveHandlerToken] == NULL));
        SmbPseReceiveHandlers[ReceiveHandlerToken] = ReceiveHandler;
    }
#if DBG
    r->ReceiveHandler = ReceiveHandler;
    r->LowType = LowType;
    r->HighType = HighType;
    if (SmbPseRIStringsBufferUsed+ISlength<=SmbPseRIStringsBufferSize) {
        r->IndicationString = &SmbPseReceiveIndicationStringsBuffer[SmbPseRIStringsBufferUsed];
        RtlCopyMemory(r->IndicationString,IndicationString,ISlength);
    } else {
        if (SmbPseRIStringsBufferUsed<SmbPseRIStringsBufferSize) {
            DbgPrint("Overflowing the indicationstringarray...%s\n",IndicationString);
            ASSERT(!"fix it please");
        }
        r->IndicationString = &SmbPseReceiveIndicationStringsBuffer[SmbPseRIStringsBufferUsed];
    }
    SmbPseRIStringsBufferUsed += ISlength;
#endif
}
#if DBG
#define SmbPseRMTableEntry(__smbcommand,b,c,token,__rcv,flags) \
       __SmbPseRMTableEntry(SMB_COM_##__smbcommand,flags,token,__rcv \
                           ,#__smbcommand,b,c)
#else
#define SmbPseRMTableEntry(__smbcommand,b,c,token,__rcv,flags) \
       __SmbPseRMTableEntry(SMB_COM_##__smbcommand,flags,token,__rcv \
                           )
#endif


VOID
SmbPseInitializeTables(
    void
    )
/*++

Routine Description:

    This routine initializes tables that are used at various points by the smbpse mechanisms.
    The must succeed structure(s) is(are) also initialized.

Arguments:

    none

Return Value:

    none

--*/
{
    ULONG i;

    for (i=SmbPseMustSucceed;i<SmbPseMustSucceedMaximum;i++) {
        RxInitializeMustSucceedStructureDescriptor(
                      &SmbPseMustSucceedDescriptor[i],
                      (PVOID)(&SmbPseMustSucceedContext[i]));
    }
    for (i=0;i<SMBPSE_OE_FROM_MAXIMUM;i++) {
        MRxSmbEntryPointIsMustSucceedable[i] = FALSE;
    }
    MRxSmbEntryPointIsMustSucceedable[SMBPSE_OE_FROM_WRITE] = TRUE;
    MRxSmbEntryPointIsMustSucceedable[SMBPSE_OE_FROM_EXTENDFILEFORCACHEING] = FALSE;
    MRxSmbEntryPointIsMustSucceedable[SMBPSE_OE_FROM_FLUSH] = TRUE;
    MRxSmbEntryPointIsMustSucceedable[SMBPSE_OE_FROM_LOCKS] = TRUE;
    MRxSmbEntryPointIsMustSucceedable[SMBPSE_OE_FROM_ASSERTBUFFEREDLOCKS] = TRUE;
    MRxSmbEntryPointIsMustSucceedable[SMBPSE_OE_FROM_CLOSESRVCALL] = TRUE;
    MRxSmbEntryPointIsMustSucceedable[SMBPSE_OE_FROM_CLEANUPFOBX] = TRUE;

    for (i=0;i<256;i++) {
        SmbPseReceiveModelParameters[i].Flags = 0;
        SmbPseReceiveModelParameters[i].ReceiveHandlerToken = SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM;
    }

    for (i=0;i<SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM;i++) {
        SmbPseReceiveHandlers[i] = NULL;
    }

// egb
//    SmbPseRMTableEntry( READ_ANDX,SMBPSE_OETYPE_READ,SMBPSE_OETYPE_READ,
//                                   SMBPSE_RECEIVE_HANDLER_TOKEN_READ_ANDX_HANDLER,MRxSmbReceiveHandler_Read_NoCopy,
//                                   SMBPSE_RMP_THIS_IS_ANDX|SMBPSE_RMP_WARNINGS_OK|SMBPSE_RMP_NOCOPY_HANDLER);
    SmbPseRMTableEntry( READ,SMBPSE_OETYPE_READ,SMBPSE_OETYPE_READ,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_READ_ANDX_HANDLER,MRxSmbReceiveHandler_Read_NoCopy,
                                   SMBPSE_RMP_WARNINGS_OK|SMBPSE_RMP_NOCOPY_HANDLER);

// egb
//    SmbPseRMTableEntry( WRITE_ANDX,SMBPSE_OETYPE_WRITE,SMBPSE_OETYPE_EXTEND_WRITE,
//                                   SMBPSE_RECEIVE_HANDLER_TOKEN_WRITE_ANDX_HANDLER,MRxSmbReceiveHandler_WriteAndX,
//                                   SMBPSE_RMP_THIS_IS_ANDX);

    SmbPseRMTableEntry( WRITE,SMBPSE_OETYPE_WRITE,SMBPSE_OETYPE_CORETRUNCATE,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_WRITE_HANDLER,MRxSmbReceiveHandler_CoreWrite,
                                   0); //SMBPSE_RMP_THIS_IS_ANDX);

// egb
//
//    SmbPseRMTableEntry( WRITE_PRINT_FILE,SMBPSE_OETYPE_WRITE,SMBPSE_OETYPE_WRITE,
//                                   SMBPSE_RECEIVE_HANDLER_TOKEN_WRITE_PRINTFILE_HANDLER,MRxSmbReceiveHandler_WritePrintFile,
//                                   0);

    SmbPseRMTableEntry( LOCKING_ANDX,SMBPSE_OETYPE_LOCKS,SMBPSE_OETYPE_ASSERTBUFFEREDLOCKS,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_LOCKING_ANDX_HANDLER,MRxSmbReceiveHandler_LockingAndX,
                                   SMBPSE_RMP_THIS_IS_ANDX);
    SmbPseRMTableEntry( UNLOCK_BYTE_RANGE,SMBPSE_OETYPE_LOCKS,SMBPSE_OETYPE_LOCKS,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,NULL,
                                   0);
    SmbPseRMTableEntry( LOCK_BYTE_RANGE,SMBPSE_OETYPE_LOCKS,SMBPSE_OETYPE_LOCKS,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,NULL,
                                   0);
//
//  egb
//
//    SmbPseRMTableEntry( OPEN_PRINT_FILE,SMBPSE_OETYPE_CREATEPRINTFILE,SMBPSE_OETYPE_CREATEPRINTFILE,
//                                   SMBPSE_RECEIVE_HANDLER_TOKEN_OPEN_PRINTFILE_HANDLER,MRxSmbReceiveHandler_OpenPrintFile,
//                                   0);
//    SmbPseRMTableEntry( CLOSE_PRINT_FILE,SMBPSE_OETYPE_CLOSE,SMBPSE_OETYPE_CLOSE,
//                                   SMBPSE_RECEIVE_HANDLER_TOKEN_CLOSE_HANDLER,MRxSmbReceiveHandler_Close,
//                                   0);

 //   SmbPseRMTableEntry( NT_CREATE_ANDX,SMBPSE_OETYPE_LATENT_HEADEROPS,SMBPSE_OETYPE_CREATE,
 //                                  SMBPSE_RECEIVE_HANDLER_TOKEN_NTCREATE_ANDX_HANDLER,MRxSmbReceiveHandler_NTCreateAndX,
 //                                  SMBPSE_RMP_THIS_IS_ANDX);
 //
 // e g b
 //
 //   SmbPseRMTableEntry( OPEN_ANDX,SMBPSE_OETYPE_LATENT_HEADEROPS,SMBPSE_OETYPE_CREATE,
 //                                  SMBPSE_RECEIVE_HANDLER_TOKEN_OPEN_ANDX_HANDLER,MRxSmbReceiveHandler_OpenAndX,
 //                                  SMBPSE_RMP_THIS_IS_ANDX);
    SmbPseRMTableEntry( OPEN,SMBPSE_OETYPE_COREOPEN,SMBPSE_OETYPE_COREOPEN,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_OPEN_HANDLER,MRxSmbReceiveHandler_CoreOpen,
                                   0);
    SmbPseRMTableEntry( CREATE,SMBPSE_OETYPE_CORECREATE,SMBPSE_OETYPE_CORECREATE,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_CREATE_HANDLER,MRxSmbReceiveHandler_CoreCreate,
                                   0);
    SmbPseRMTableEntry( CREATE_NEW,SMBPSE_OETYPE_CORECREATE,SMBPSE_OETYPE_CORECREATE,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_CREATE_HANDLER,MRxSmbReceiveHandler_CoreCreate,
                                   0);
    SmbPseRMTableEntry( CLOSE,SMBPSE_OETYPE_CLOSE,SMBPSE_OETYPE_CLOSEAFTERCORECREATE,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_CLOSE_HANDLER,MRxSmbReceiveHandler_Close,
                                   0);


    SmbPseRMTableEntry( QUERY_INFORMATION,0,SMBPSE_OETYPE_MAXIMUM,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_GFA_HANDLER,MRxSmbReceiveHandler_GetFileAttributes,
                                   0);
//
// egb
//    SmbPseRMTableEntry( TRANSACTION2,
//                                   SMBPSE_OETYPE_T2_FOR_NT_FILE_ALLOCATION_INFO,
//                                   SMBPSE_OETYPE_T2_FOR_LANMAN_VOLUMELABEL_INFO,
//                                   SMBPSE_RECEIVE_HANDLER_TOKEN_TRANS2_ANDX_HANDLER,MRxSmbReceiveHandler_Transact2,
//                                   0);
//    SmbPseRMTableEntry( TRANSACTION2_SECONDARY,
//                                   SMBPSE_OETYPE_T2_FOR_NT_FILE_ALLOCATION_INFO,
//                                   SMBPSE_OETYPE_T2_FOR_LANMAN_VOLUMELABEL_INFO,
//                                   SMBPSE_RECEIVE_HANDLER_TOKEN_TRANS2_ANDX_HANDLER,MRxSmbReceiveHandler_Transact2,
//                                   0);

    SmbPseRMTableEntry( SEARCH,SMBPSE_OETYPE_COREQUERYLABEL,SMBPSE_OETYPE_CORESEARCHFORCHECKEMPTY,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_SEARCH_HANDLER,MRxSmbReceiveHandler_Search,
                                   0);
    SmbPseRMTableEntry( QUERY_INFORMATION_DISK,SMBPSE_OETYPE_COREQUERYDISKATTRIBUTES,SMBPSE_OETYPE_COREQUERYDISKATTRIBUTES,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_QUERYDISKINFO_HANDLER,MRxSmbReceiveHandler_QueryDiskInfo,
                                   0);
    SmbPseRMTableEntry( DELETE,SMBPSE_OETYPE_DELETEFORSUPERSEDEORCLOSE,SMBPSE_OETYPE_DELETEFORSUPERSEDEORCLOSE,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,NULL,
                                   0);
    SmbPseRMTableEntry( DELETE_DIRECTORY,SMBPSE_OETYPE_DELETEFORSUPERSEDEORCLOSE,SMBPSE_OETYPE_DELETEFORSUPERSEDEORCLOSE,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,NULL,
                                   0);
    SmbPseRMTableEntry( CHECK_DIRECTORY,SMBPSE_OETYPE_CORECHECKDIRECTORY,SMBPSE_OETYPE_CORECHECKDIRECTORY,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,NULL,
                                   0);
    SmbPseRMTableEntry( SET_INFORMATION,SMBPSE_OETYPE_SFA,SMBPSE_OETYPE_SFA,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,NULL,
                                   0);
    SmbPseRMTableEntry( CREATE_DIRECTORY,SMBPSE_OETYPE_CORECREATEDIRECTORY,SMBPSE_OETYPE_CORECREATEDIRECTORY,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,NULL,
                                   0);
    SmbPseRMTableEntry( FLUSH,SMBPSE_OETYPE_FLUSH,SMBPSE_OETYPE_FLUSH,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,NULL,
                                   0);
    SmbPseRMTableEntry( FIND_CLOSE2,SMBPSE_OETYPE_FINDCLOSE,SMBPSE_OETYPE_FINDCLOSE,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,NULL,
                                   0);
    SmbPseRMTableEntry( RENAME,SMBPSE_OETYPE_RENAME,SMBPSE_OETYPE_RENAME,
                                   SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM+1,NULL,
                                   0);
}




#ifndef RX_NO_DBGFIELD_HLPRS

#define DECLARE_FIELD_HLPR(x) ULONG SmbPseOeField_##x = FIELD_OFFSET(SMB_PSE_ORDINARY_EXCHANGE,x);
#define DECLARE_FIELD_HLPR2(x,y) ULONG SmbPseOeField_##x##y = FIELD_OFFSET(SMB_PSE_ORDINARY_EXCHANGE,x.y);

DECLARE_FIELD_HLPR(RxContext);
DECLARE_FIELD_HLPR(ReferenceCount);
DECLARE_FIELD_HLPR(AssociatedStufferState);
DECLARE_FIELD_HLPR(Flags);
DECLARE_FIELD_HLPR(ReadWrite);
DECLARE_FIELD_HLPR(Transact2);
DECLARE_FIELD_HLPR2(Create,FileInfo);
DECLARE_FIELD_HLPR2(Create,smbSrvOpen);
DECLARE_FIELD_HLPR2(ReadWrite,RemainingByteCount);
DECLARE_FIELD_HLPR2(Info,FileInfo);
DECLARE_FIELD_HLPR2(Info,Buffer);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\smbxchng.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    smbcxchng.c

Abstract:

    This is the include file that implements the SMB_*_EXCHANGE creation, deletion and
    dispatch routines.

Notes:


--*/

#include "precomp.h"
#pragma hdrstop


ULONG SmbCeTraceExchangeReferenceCount = 0;

RXDT_DefineCategory(SMBXCHNG);
#define Dbg        (DEBUG_TRACE_SMBXCHNG)

// The exchange engine in the mini redirector requires to maintain enough state
// to ensure that all the active exchanges are completed correctly when a shut down
// occurs. Since the exchanges can be finalized by different threads, including
// posted completions the exchange engine on startup initializes an event upon startup
// which is subsequently used to signal the terminating condition.
//
// The count of active changes has to be tracked continously and the signalling
// of the event depends upon the number of active exchanges reaching the count of
// zero and the exchange engine being in a stopped state.

SMBCE_STARTSTOP_CONTEXT SmbCeStartStopContext;

NTSTATUS
MRxSmbInitializeSmbCe()
{
    KeInitializeEvent(
        &SmbCeStartStopContext.StopEvent,
        NotificationEvent,
        FALSE);

    SmbCeStartStopContext.ActiveExchanges = 0;
    SmbCeStartStopContext.State = SMBCE_STARTED;

    return STATUS_SUCCESS;
}

NTSTATUS
MRxSmbTearDownSmbCe()
{
    BOOLEAN fWait;

    if (SmbCeStartStopContext.State == SMBCE_STARTED) {
        SmbCeAcquireSpinLock();
        SmbCeStartStopContext.State = SMBCE_STOPPED;
        fWait = (SmbCeStartStopContext.ActiveExchanges > 0);
        SmbCeReleaseSpinLock();

        if (fWait) {
            KeWaitForSingleObject(
                &SmbCeStartStopContext.StopEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL);
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SmbCeIncrementActiveExchangeCount()
{
    NTSTATUS Status = STATUS_SUCCESS;

    SmbCeAcquireSpinLock();
    if (SmbCeStartStopContext.State != SMBCE_STARTED) {
        Status = STATUS_UNSUCCESSFUL;
    } else {
        InterlockedIncrement(&SmbCeStartStopContext.ActiveExchanges);
    }
    SmbCeReleaseSpinLock();

    return Status;
}

VOID
SmbCeDecrementActiveExchangeCount()
{
    LONG FinalRefCount;

    ASSERT(SmbCeStartStopContext.ActiveExchanges > 0);
    if (InterlockedDecrement(&SmbCeStartStopContext.ActiveExchanges) == 0) {
        SmbCeAcquireSpinLock();
        if (SmbCeStartStopContext.State == SMBCE_STOPPED) {
            KeSetEvent(&SmbCeStartStopContext.StopEvent,0,FALSE);
        }
        SmbCeReleaseSpinLock();
    }
}


NTSTATUS
SmbCeReferenceServer(
    PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

   This routine initializes the server associated with an exchange.

Arguments:

    pExchange  - the exchange to be initialized.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The initiation of an exchange proceeds in multiple steps. The first step involves
    referencing the corresponding server,session and netroot entries. Subsequently the
    exchange is placed in a SMB_EXCHANGE_START state and the exchange is dispatched to the
    Start method. The act of referencing the session or the net root may suspend the exchange.

    The session and net roots are aliased entities, i.e., there is more then one reference
    to it. It is conceivable that the construction is in progress when a reference is made.
    In such cases the exchange is suspended and resumed when the construction is complete.

    On some transports a reconnect is possible without having to tear down an existing
    connection, i.e. attempting to send a packet reestablishes the connection at the
    lower level. Since this is not supported by all the transports ( with the exception
    of TCP/IP) the reference server entry initiates this process by tearing down the
    existing transport and reinitialising it.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PSMBCEDB_SERVER_ENTRY pServerEntry;
    BOOLEAN ResourceAcquired;

    pServerEntry = pExchange->SmbCeContext.pServerEntry;

    ASSERT(pExchange->SmbCeState == SMBCE_EXCHANGE_INITIALIZATION_START);

    if (pServerEntry->Header.State != SMBCEDB_ACTIVE) {
        if  (pExchange->SmbCeFlags & SMBCE_EXCHANGE_ATTEMPT_RECONNECTS) {
            // Acquire the resource
            SmbCeAcquireResource();
            ResourceAcquired = TRUE;

            switch (pServerEntry->Header.State) {
            case SMBCEDB_INVALID:
                {
                    SMBCEDB_OBJECT_STATE State;

                    // Assume the worst case. if everything goes well the ServerStatus will
                    // be updated as a result of parsing the negotiate response.

                    pServerEntry->ServerStatus = STATUS_CONNECTION_DISCONNECTED;
                    SmbCeUpdateServerEntryState(
                        pServerEntry,
                        SMBCEDB_CONSTRUCTION_IN_PROGRESS);

                    // release the resource for the server entry

                    ResourceAcquired = FALSE;
                    SmbCeReleaseResource();

                    // Initialize the transport associated with the server

                    Status = SmbCeInitializeServerTransport(pServerEntry);

                    if (Status == STATUS_SUCCESS) {
                        Status = SmbCeNegotiate(
                                     pServerEntry,
                                     (PMRX_SRV_CALL)pExchange->SmbCeContext.pVNetRoot->pNetRoot->pSrvCall);
                    }

                    if (Status != STATUS_SUCCESS) {

                        // Either the transport initialization failed or the NEGOTIATE
                        // SMB could not be sent ....

                        SmbCeUpdateServerEntryState(pServerEntry,SMBCEDB_MARKED_FOR_DELETION);
                        SmbCeCompleteServerEntryInitialization(pServerEntry);
                        InterlockedIncrement(&MRxIfsStatistics.Reconnects);
                    }
                }
                break;

            case SMBCEDB_CONSTRUCTION_IN_PROGRESS :
                {
                    PSMBCEDB_REQUEST_ENTRY pRequestEntry;

                    pRequestEntry = (PSMBCEDB_REQUEST_ENTRY)
                                    SmbMmAllocateObject(SMBCEDB_OT_REQUEST);
                    if (pRequestEntry != NULL) {
                        // Enqueue the request entry.
                        pRequestEntry->ReconnectRequest.Type      = RECONNECT_REQUEST;
                        pRequestEntry->ReconnectRequest.pExchange = pExchange;
                        SmbCeAddRequestEntry(&pServerEntry->OutstandingRequests,pRequestEntry);
                        Status = STATUS_PENDING;
                    } else {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                break;

            default :
                Status = STATUS_CONNECTION_DISCONNECTED;
                break;
            }

            if (ResourceAcquired) {
                SmbCeReleaseResource();
            }
        } else {
            Status = STATUS_CONNECTION_DISCONNECTED;
        }
    }

    if ((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING)) {
        pExchange->SmbCeState = SMBCE_EXCHANGE_SERVER_INITIALIZED;
    }

    return Status;
}

NTSTATUS
SmbCeReferenceSession(
    PSMB_EXCHANGE   pExchange)
/*++

Routine Description:

    This routine initializes the session associated with an exchange.

Arguments:

    pExchange  - the exchange to be initialized.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The initiation of an exchange proceeds in multiple steps. The first step involves
    referencing the corresponding server,session and netroot entries. Subsequently the
    exchange is placed in a SMB_EXCHANGE_START state and the exchange is dispatched to the
    Start method. The act of referencing the session or the net root may suspend the exchange.

    The session and net roots are aliased entities, i.e., there is more then one reference
    to it. It is conceivable that the construction is in progress when a reference is made.
    In such cases the exchange is suspended and resumed when the construction is complete.
--*/
{
    NTSTATUS Status;
    BOOLEAN  fReestablishSession;

    PSMBCEDB_SERVER_ENTRY  pServerEntry;
    PSMBCEDB_SESSION_ENTRY pSessionEntry;

    pServerEntry = pExchange->SmbCeContext.pServerEntry;
    pSessionEntry = pExchange->SmbCeContext.pSessionEntry;

    ASSERT(pSessionEntry != NULL);
    ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);
    ASSERT(pExchange->SmbCeState == SMBCE_EXCHANGE_SERVER_INITIALIZED);
    ASSERT(SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER);

    // Acquire the resource
    SmbCeAcquireResource();

    Status = STATUS_USER_SESSION_DELETED;
    fReestablishSession = BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_ATTEMPT_RECONNECTS);

    switch (pSessionEntry->Header.State) {
    case SMBCEDB_ACTIVE:
        Status = STATUS_SUCCESS;
        break;

    case SMBCEDB_INVALID:

        if (!fReestablishSession) {
           break;
        }

        RxDbgTrace( 0, Dbg, ("SmbCeReferenceSession: Reestablishing session\n"));
        pSessionEntry->Session.UserId = 0;
        // fall thru ...

    case SMBCEDB_START_CONSTRUCTION:
        ASSERT(SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER);
        pExchange->SmbCeFlags |= SMBCE_EXCHANGE_SESSION_CONSTRUCTOR;
        pSessionEntry->Header.State = SMBCEDB_CONSTRUCTION_IN_PROGRESS;
        Status = STATUS_SUCCESS;
        break;

    case SMBCEDB_CONSTRUCTION_IN_PROGRESS:
        if (fReestablishSession) {
            // The construction of the session is already in progress ....
            // Queue up the request to resume this exchange when the session
            // construction is complete.

            PSMBCEDB_REQUEST_ENTRY pRequestEntry;

            ASSERT(SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER);

            pRequestEntry = (PSMBCEDB_REQUEST_ENTRY)
                             SmbMmAllocateObject(SMBCEDB_OT_REQUEST);

            if (pRequestEntry != NULL) {
                pRequestEntry->Request.pExchange = pExchange;

                SmbCeAddRequestEntry(&pSessionEntry->Requests,pRequestEntry);
                Status = STATUS_PENDING;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        break;

    case SMBCEDB_MARKED_FOR_DELETION:
        Status = STATUS_USER_SESSION_DELETED;
        break;

    default:
        ASSERT(!"Valid Session State, SmbCe database corrupt");
        Status = STATUS_USER_SESSION_DELETED;
    }

    // Release the server resource ...

    SmbCeReleaseResource();


    if ((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING)) {
        pExchange->SmbCeState = SMBCE_EXCHANGE_SESSION_INITIALIZED;
    }

    return Status;
}

NTSTATUS
SmbCeReferenceNetRoot(
    PSMB_EXCHANGE   pExchange)
/*++

Routine Description:

    This routine initializes the net root associated with an exchange.

Arguments:

    pExchange  - the exchange to be initialized.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The initiation of an exchange proceeds in multiple steps. The first step involves
    referencing the corresponding server,session and netroot entries. Subsequently the
    exchange is placed in a SMB_EXCHANGE_START state and the exchange is dispatched to the
    Start method. The act of referencing the session or the net root may suspend the exchange.

    The session and net roots are aliased entities, i.e., there is more then one reference
    to it. It is conceivable that the construction is in progress when a reference is made.
    In such cases the exchange is suspended and resumed when the construction is complete.
--*/
{
    NTSTATUS Status;
    BOOLEAN  fReconnectNetRoot;

    PSMBCEDB_SERVER_ENTRY   pServerEntry;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    pServerEntry = pExchange->SmbCeContext.pServerEntry;
    pNetRootEntry = pExchange->SmbCeContext.pNetRootEntry;

    ASSERT(pNetRootEntry->Header.ObjectType == SMBCEDB_OT_NETROOT);
    ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);
    ASSERT(pExchange->SmbCeState == SMBCE_EXCHANGE_SESSION_INITIALIZED);

    // Acquire the resource
    SmbCeAcquireResource();

    Status            = STATUS_CONNECTION_DISCONNECTED;
    fReconnectNetRoot = BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_ATTEMPT_RECONNECTS);

    switch (pNetRootEntry->Header.State) {
    case SMBCEDB_ACTIVE:
        Status = STATUS_SUCCESS;
        break;

    case SMBCEDB_INVALID:
        RxDbgTrace( 0, Dbg, ("SmbCeReferenceNetRoot: Reestablishing net root\n"));
        if (!fReconnectNetRoot) {
            break;
        }
        pNetRootEntry->NetRoot.TreeId = 0;
        // fall thru

    case SMBCEDB_START_CONSTRUCTION:
        pExchange->SmbCeFlags |= SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR;
        pNetRootEntry->Header.State = SMBCEDB_CONSTRUCTION_IN_PROGRESS;
        Status = STATUS_SUCCESS;
        break;

    case SMBCEDB_CONSTRUCTION_IN_PROGRESS:
        if (fReconnectNetRoot) {
            // The construction of the net root is already in progress ....
            // Queue up the request to resume this exchange when the session
            // construction is complete.
            PSMBCEDB_REQUEST_ENTRY pRequestEntry;

            pRequestEntry = (PSMBCEDB_REQUEST_ENTRY)
                             SmbMmAllocateObject(SMBCEDB_OT_REQUEST);

            if (pRequestEntry != NULL) {
                pRequestEntry->Request.pExchange = pExchange;

                SmbCeAddRequestEntry(&pNetRootEntry->Requests,pRequestEntry);
                Status = STATUS_PENDING;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        break;

    case SMBCEDB_MARKED_FOR_DELETION:
        break;

    default:
        ASSERT(!"Valid NetRoot State, SmbCe database corrupt");
        break;
    }

    // Release the resource ...
    SmbCeReleaseResource();

    if ((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING)) {
        pExchange->SmbCeState = SMBCE_EXCHANGE_NETROOT_INITIALIZED;
    }

    return Status;
}

NTSTATUS
SmbCeInitiateExchange(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

   This routine initiates a exchange.

Arguments:

    pExchange  - the exchange to be initiated.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The initiation of an exchange proceeds in multiple steps. The first step involves
    referencing the corresponding server,session and netroot entries. Subsequently the
    exchange is placed in a SMB_EXCHANGE_START state and the exchange is dispatched to the
    Start method. The act of referencing the session or the net root may suspend the exchange.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(pExchange->SmbCeContext.pServerEntry != NULL);

    switch (SmbCeGetServerType(pExchange->SmbCeContext.pServerEntry)) {
    case SMBCEDB_FILE_SERVER:
        // Admin exchanges do not have these fields filled in. All the three
        // entries must be valid for all other exchanges.
        if ((pExchange->NodeTypeCode != SMB_EXCHANGE_NTC(ADMIN_EXCHANGE)) &&
            ((pExchange->SmbCeContext.pNetRootEntry == NULL) ||
            (pExchange->SmbCeContext.pSessionEntry == NULL))) {
            Status = STATUS_REQUEST_ABORTED;
            break;
        }
    case SMBCEDB_MAILSLOT_SERVER:
        break;
    default:
        // Prepare for aborting the request if either the server type is invalid
        // or if the netroot entry or the session entry is invalid.
        Status = STATUS_REQUEST_ABORTED;
    }

    if (Status != STATUS_SUCCESS) {
        RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: Exchange %lx Status %lx\n",pExchange,Status));
        return Status;
    }

    if (pExchange->pSmbCeSynchronizationEvent != NULL) {
        KeInitializeEvent(
            pExchange->pSmbCeSynchronizationEvent,
            SynchronizationEvent,
            FALSE);
    }

    for (;;) {
        switch (pExchange->SmbCeState) {
        case SMBCE_EXCHANGE_INITIALIZATION_START:
            {
                RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: Exchange %lx State %lx\n",pExchange,pExchange->SmbCeState));
                Status = SmbCeReferenceServer(pExchange);
                if (Status != STATUS_SUCCESS) {
                    // this covers the case when the SERVER_ENTRY is under construction
                    // and RxStatus(PENDING) is returned.
                    RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: SmbCeReferenceServer returned %lx\n",Status));
                    break;
                }
            }
            // fall through

        case SMBCE_EXCHANGE_SERVER_INITIALIZED:
            if (SmbCeGetServerType(pExchange->SmbCeContext.pServerEntry) == SMBCEDB_MAILSLOT_SERVER) {
                // Mailslot servers do not have any netroot/session associated with them.
                pExchange->SmbCeState = SMBCE_EXCHANGE_INITIATED;
                Status                = STATUS_SUCCESS;
                break;
            } else {
                RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: Exchange %lx State %lx\n",pExchange,pExchange->SmbCeState));
                Status = SmbCeReferenceSession(pExchange);
                if (!NT_SUCCESS(Status)) {
                    RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: SmbCeReferenceSession returned %lx\n",Status));
                    break;
                } if ((Status == STATUS_PENDING) &&
                      !(pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR)) {
                    break;
                }
            }
            // fall through

        case SMBCE_EXCHANGE_SESSION_INITIALIZED:
            RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: Exchange %lx State %lx\n",pExchange,pExchange->SmbCeState));

            Status = SmbCeReferenceNetRoot(pExchange);
            if (!NT_SUCCESS(Status)) {
                RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: SmbCeReferenceNetRoot returned %lx\n",Status));
                break;
            } else if ((Status == STATUS_PENDING) &&
                           !(pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR)) {
              break;
            }

            // else fall through

        case SMBCE_EXCHANGE_NETROOT_INITIALIZED:
            pExchange->SmbCeState = SMBCE_EXCHANGE_INITIATED;
            Status                = STATUS_SUCCESS;
            break;

        default:
            ASSERT(!"Valid State for a SMB exchange, exchange Initiation aborted");
            break;
        }

        if ((pExchange->pSmbCeSynchronizationEvent != NULL)     &&
            (pExchange->SmbCeState != SMBCE_EXCHANGE_INITIATED) &&
            (Status == STATUS_PENDING)) {

            KeWaitForSingleObject(
                pExchange->pSmbCeSynchronizationEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL );

            ASSERT(pExchange->Status != STATUS_PENDING);
            Status = pExchange->Status;
            if (Status != STATUS_SUCCESS) {
                break;
            }
        } else {
            break;
        }
    }

    ASSERT((Status != STATUS_PENDING) ||
           (pExchange->pSmbCeSynchronizationEvent == NULL));

    RxDbgTrace(0,Dbg,("Exchange (%lx) Type (%lx) State(%lx) Status %lx \n",pExchange,pExchange->Type,pExchange->SmbCeState,Status));
    RxDbgTrace(0,Dbg,
        ("ServerEntry(%lx) SessionEntry(%lx) NetRootEntry(%lx) \n",
        pExchange->SmbCeContext.pServerEntry,
        pExchange->SmbCeContext.pSessionEntry,
        pExchange->SmbCeContext.pNetRootEntry));

    // Note: Once the exchange has been initiated no further reference of the exchange
    // can be done since the state of the exchange is non-deterministic, i.e., depends upon
    // the scheduler.
    if (Status == STATUS_SUCCESS) {
        // Start the exchange
        ASSERT(pExchange->SmbCeState == SMBCE_EXCHANGE_INITIATED);

        if ((pExchange->SmbCeContext.pServerEntry->Header.State == SMBCEDB_ACTIVE) ||
            (pExchange->NodeTypeCode == SMB_EXCHANGE_NTC(ADMIN_EXCHANGE))) {
            Status = SmbCeInitializeExchangeTransport(pExchange);
        } else {
            Status = STATUS_CONNECTION_DISCONNECTED;
        }

        if (Status == STATUS_SUCCESS) {
            pExchange->SmbStatus = STATUS_SUCCESS;
            pExchange->ServerVersion = pExchange->SmbCeContext.pServerEntry->Server.Version;
            Status = SMB_EXCHANGE_DISPATCH(pExchange,Start,((PSMB_EXCHANGE)pExchange));
            RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: SMB_EXCHANGE_DISPATCH(Start) returned %lx\n",Status));
        }
    } else if (Status != STATUS_PENDING) {
        RxDbgTrace( 0, Dbg, ("SmbCeInitiateExchange: Exchange(%lx) Initiation failed %lx \n",pExchange,Status));
    }

    return Status;
}

NTSTATUS
SmbCeExchangeAbort(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

   This routine aborts an exchange.

Arguments:

    pExchange  - the exchange to be aborted.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    RxDbgTrace( 0, Dbg, ("SmbCeExchangeAbort: Exchange %lx aborted\n",pExchange));
    SmbCeDiscardExchange(pExchange);
    return STATUS_SUCCESS;
}

NTSTATUS
SmbCeBuildSmbHeader(
    IN OUT PSMB_EXCHANGE     pExchange,
    IN OUT PVOID             pBuffer,
    IN     ULONG             BufferLength,
    OUT    PULONG            pBufferConsumed,
    OUT    PUCHAR            pLastCommandInHeader,
    OUT    PUCHAR            *pNextCommandPtr)
/*++

Routine Description:

   This routine constructs the SMB header associated with any SMB sent as part of
   an exchange.

Arguments:

    pExchange  - the exchange for which the SMB is to be constructed.

    pBuffer    - the buffer in which the SMB header is to be constructed

    BufferLength - length of the buffer

    pBufferConsumed - the buffer consumed

    pLastCommandInHeader - the last command in header, SMB_COM_NO_ANDX_COMMAND if none

    pNextCommandPtr - the ptr to the place in the buffer where the next command
                      code should be copied.


Return Value:

    STATUS_SUCCESS  - if the header construction was successful

Notes:

    This routine is called to build the SMB header. This centralization allows us to
    compound the SMB operation with other SMB's required for the maintenance of the
    SMB connection engine data structures. It also provides us with a centralized facility
    for profiling SMB's as well as a one place mechanism for filling in all the header
    fields associated with a SMB.

--*/
{
    NTSTATUS      Status = STATUS_SUCCESS;
    PSMB_HEADER   pSmbHeader = (PSMB_HEADER)pBuffer;
    PGENERIC_ANDX pSmbBuffer;
    ULONG         SmbBufferUnconsumed = BufferLength;
    PUCHAR        pSmbCommand;

    UCHAR         LastCommandInHeader = SMB_COM_NO_ANDX_COMMAND;
    UCHAR         Flags = 0;
    USHORT        Flags2 = 0;

    PSMBCE_SERVER pServer;

    if (BufferLength < sizeof(SMB_HEADER)) {
        RxDbgTrace( 0, Dbg, ("SmbCeBuildSmbHeader: BufferLength too small %d\n",BufferLength));
        ASSERT(!"Buffer too small");
        return STATUS_BUFFER_TOO_SMALL;
    }

    SmbBufferUnconsumed = BufferLength - sizeof(SMB_HEADER);
    pServer = &pExchange->SmbCeContext.pServerEntry->Server;

    if (pServer->Dialect == LANMAN21_DIALECT) {
        Flags = (SMB_FLAGS_CASE_INSENSITIVE | SMB_FLAGS_CANONICALIZED_PATHS);
    }

    //DOWNLEVEL.NOTCORE flags for lanman10

    RtlZeroMemory(pSmbHeader,sizeof(SMB_HEADER));

    *((PULONG)&pSmbHeader->Protocol) = SMB_HEADER_PROTOCOL;
    pSmbHeader->Flags      = Flags;
    pSmbHeader->Flags2     = Flags2;
    pSmbHeader->Pid        = MRXSMB_PROCESS_ID;
    pSmbHeader->Uid        = 0;
    pSmbHeader->Tid        = 0;
    pSmbHeader->ErrorClass = 0;
    pSmbHeader->Reserved   = 0;
    pSmbCommand            = &pSmbHeader->Command;
    SmbPutUshort(&pSmbHeader->Error,0);

    switch (SmbCeGetServerType(pExchange->SmbCeContext.pServerEntry)) {
    case SMBCEDB_MAILSLOT_SERVER :
        break;

    case SMBCEDB_FILE_SERVER:
        {
            if (pExchange->SmbCeContext.pSessionEntry != NULL) {
                pSmbHeader->Uid = pExchange->SmbCeContext.pSessionEntry->Session.UserId;
            }

            if (pExchange->SmbCeContext.pNetRootEntry != NULL) {
                pSmbHeader->Tid = pExchange->SmbCeContext.pNetRootEntry->NetRoot.TreeId;
            }

            pSmbBuffer = (PGENERIC_ANDX)(pSmbHeader + 1);

            if ((pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR) ||
                (pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR)) {
                // There is an opportunity to compound some SessionSetup/TreeConnect SMB with the
                // given SMB command.
                if (pExchange->SmbCeContext.pSessionEntry->Header.State == SMBCEDB_CONSTRUCTION_IN_PROGRESS) {
                    if (( pServer->DialectFlags & DF_EXTENDNEGOT) ||
                        ( pServer->DialectFlags & DF_NTNEGOTIATE)) {
                        RxDbgTrace( 0, Dbg, ("SmbCeBuildSmbHeader: Building Session setup And X\n"));

                        *pSmbCommand = SMB_COM_SESSION_SETUP_ANDX;
                        LastCommandInHeader = *pSmbCommand;
                        pSmbCommand = &pSmbBuffer->AndXCommand;
                        pSmbHeader->Tid = 0;

                        Status = SMBCE_SERVER_DIALECT_DISPATCH(
                                     pServer,
                                     BuildSessionSetup,
                                     (pExchange,
                                      pSmbBuffer,
                                      &SmbBufferUnconsumed));
                        if (NT_SUCCESS(Status)) {
                            // Update the buffer for the construction of the following SMB.
                            SmbPutUshort(
                                &pSmbBuffer->AndXOffset,
                                (USHORT)(BufferLength - SmbBufferUnconsumed));
                            pSmbBuffer = (PGENERIC_ANDX)((PBYTE)pBuffer + BufferLength - SmbBufferUnconsumed);
                        }
                    }
                } else {
                    NOTHING; //no session for share level AT LEAST NOT FOR CORE!!!
                }

                if (NT_SUCCESS(Status) &&
                    pExchange->SmbCeContext.pNetRootEntry->Header.State == SMBCEDB_CONSTRUCTION_IN_PROGRESS) {
                    BOOLEAN BuildingTreeConnectAndX = BooleanFlagOn(pServer->DialectFlags,DF_LANMAN10);

                    if (BuildingTreeConnectAndX) {
                        RxDbgTrace( 0, Dbg, ("SmbCeBuildSmbHeader: Building Tree Connect And X\n"));
                        *pSmbCommand = SMB_COM_TREE_CONNECT_ANDX;
                        LastCommandInHeader = *pSmbCommand;
                    } else {
                        RxDbgTrace( 0, Dbg, ("SmbCeBuildSmbHeader: Building Tree Connect No X\n"));
                        *pSmbCommand = SMB_COM_TREE_CONNECT;
                        LastCommandInHeader = *pSmbCommand;
                    }


                    Status = SMBCE_SERVER_DIALECT_DISPATCH(
                                 pServer,
                                 BuildTreeConnect,
                                 (pExchange,
                                  pSmbBuffer,
                                  &SmbBufferUnconsumed));

                    if (NT_SUCCESS(Status)) {
                        // Update the buffer for the construction of the following SMB.
                        if (BuildingTreeConnectAndX) {
                            pSmbCommand = &pSmbBuffer->AndXCommand;
                            SmbPutUshort(&pSmbBuffer->AndXOffset,(USHORT)(BufferLength - SmbBufferUnconsumed));
                        } else {
                            pSmbCommand = NULL;
                        }
                    }
                }
            }
        }
        break;

    default:
        {
            ASSERT(!"Valid Server Type");
            Status = STATUS_INVALID_HANDLE;
        }
        break;
    }

    *pNextCommandPtr      = pSmbCommand;
    *pBufferConsumed      = BufferLength - SmbBufferUnconsumed;
    *pLastCommandInHeader = LastCommandInHeader;

    RxDbgTrace( 0, Dbg, ("SmbCeBuildSmbHeader: Buffer Consumed %lx\n",*pBufferConsumed));

    return Status;
}

typedef struct __Service_Name_Entry {
    NET_ROOT_TYPE NetRootType;
    USHORT NameLength;
    PBYTE  Name;
};
struct __Service_Name_Entry ServiceNameTable[] = {
    {NET_ROOT_DISK,sizeof(SHARE_TYPE_NAME_DISK),SHARE_TYPE_NAME_DISK},
    {NET_ROOT_PIPE,sizeof(SHARE_TYPE_NAME_PIPE),SHARE_TYPE_NAME_PIPE},
    {NET_ROOT_PRINT,sizeof(SHARE_TYPE_NAME_PRINT),SHARE_TYPE_NAME_PRINT},
    {NET_ROOT_COMM,sizeof(SHARE_TYPE_NAME_COMM),SHARE_TYPE_NAME_COMM}  //COMM must be last
    };

NTSTATUS
SmbCeParseSmbHeader(
    PSMB_EXCHANGE     pExchange,
    PSMB_HEADER       pSmbHeader,
    PGENERIC_ANDX     pCommandToProcess,
    NTSTATUS          *pSmbResponseStatus,
    ULONG             BytesAvailable,
    ULONG             BytesIndicated,
    PULONG            pBytesConsumed)
/*++

Routine Description:

   This routine validates the SMB header associated with any SMB received as part of
   an exchange.

Arguments:

    pExchange  - the exchange for which the SMB is to be constructed.

    pSmbHeader - the header of the SMB received

    pCommandToProcess - the SMB command to be processed after the header ( Can be NULL )

    pSmbResponseStatus - the status in the SMB response header (Can be NULL)

    BytesAvailable - the bytes available for processing but not necessarily indicated.

    BytesIndicated - the length of the SMB buffer available for perusal

    pBytesConsumed - the buffer consumed

Return Value:

    RXSTATUS - The return status for the operation
          STATUS_MORE_PROCESSING_REQUIRED -- if a copy of the data needs to be done before
          processing can be completed. This occurs because sufficient data was not
          indicated to process the header.
          STATUS_SUCCESS -- the header was processed successfully. In such cases the GENERIC_ANDX
          if not NULL will contain the offset from the start of the buffer and the command
          to be processed.
          STATUS_* -- They indicate an error which would normally lead to the abortion of the
          exchange.

Notes:

    This routine is called to parse the SMB header. This centralization allows us to
    implement a one stop mechanism for updating/validating the header fields as well as
    resuming the exchanges waiting for the construction of session/net root entry
    associated with this exchange

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SmbResponseStatus;

    PBYTE    pSmbBuffer = (PBYTE)pSmbHeader;
    UCHAR    SmbCommand;

    BOOLEAN  fSessionSetupResponse = FALSE;
    BOOLEAN  fTreeConnectResponse  = FALSE;

    SMBCEDB_OBJECT_STATE SessionState;
    SMBCEDB_OBJECT_STATE NetRootState;

    // Return Immediately if bytes indicated is less then the size of a SMB header.
    if (BytesIndicated < sizeof(SMB_HEADER)) {
        *pBytesConsumed = BytesIndicated;
        return STATUS_INVALID_NETWORK_RESPONSE;
    }

    SmbResponseStatus = GetSmbResponseNtStatus(pSmbHeader);
    if (!NT_SUCCESS(SmbResponseStatus)) {
        RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader::SMB Response Error %lx\n",SmbResponseStatus));
    }

    SmbCommand      = pSmbHeader->Command;
    *pBytesConsumed = sizeof(SMB_HEADER);
    pSmbBuffer     += *pBytesConsumed;

    // There are certain SMB's that effect the connection engine data structures as
    // well as the exchange that has been suspended. These are the SMB's used for tree
    // connect and session setup.
    // In all the other cases no special action is required for the maintenance of the
    // connection engine data structures. The Exchange that was suspended needs to be
    // resumed.
    if (SmbCommand == SMB_COM_SESSION_SETUP_ANDX) {
        if (SmbResponseStatus != STATUS_SUCCESS) {
            if ((FIELD_OFFSET(GENERIC_ANDX,AndXReserved) + *pBytesConsumed) <= BytesIndicated) {
                PGENERIC_ANDX pGenericAndX = (PGENERIC_ANDX)pSmbBuffer;

                if (pGenericAndX->WordCount == 0) {
                    Status = SmbResponseStatus;
                }
            }

            // Note that the case wherein sufficient bytes are not indicated for the
            // GENERIC_ANDX response is handled by the if statement below which
            // imposes a more stringent test.
        }

        if ((Status == STATUS_SUCCESS) &&
            (FIELD_OFFSET(RESP_SESSION_SETUP_ANDX,Buffer) + *pBytesConsumed) > BytesIndicated) {
            Status = STATUS_MORE_PROCESSING_REQUIRED;
        }

        if (Status == STATUS_SUCCESS) {
            PRESP_SESSION_SETUP_ANDX pSessionSetupResponse;
            ULONG                    SessionSetupResponseLength,ByteCount;

            RxDbgTrace( 0, Dbg, ("Processing Session Setup ANd X\n"));
            pSessionSetupResponse = (PRESP_SESSION_SETUP_ANDX)(pSmbBuffer);

            ByteCount = SmbGetUshort(&pSessionSetupResponse->ByteCount);
            if (pSessionSetupResponse->WordCount == 3) {
                SmbCommand = pSessionSetupResponse->AndXCommand;
                if (SmbCommand == SMB_COM_NO_ANDX_COMMAND) {
                    SessionSetupResponseLength =
                        FIELD_OFFSET(RESP_SESSION_SETUP_ANDX,Buffer) + ByteCount;
                    Status = SmbResponseStatus;
                } else {
                    SessionSetupResponseLength =
                        SmbGetUshort(&pSessionSetupResponse->AndXOffset) - *pBytesConsumed;
                }

            } else {
                Status = SmbResponseStatus;
            }

            if (NT_SUCCESS(Status)) {
                if (SessionSetupResponseLength + *pBytesConsumed <= BytesIndicated) {
                    *pBytesConsumed += SessionSetupResponseLength;
                    pSmbBuffer += SessionSetupResponseLength;
                    pExchange->SmbCeContext.pSessionEntry->Session.UserId = pSmbHeader->Uid;
                    fSessionSetupResponse = TRUE;
                    SessionState = SMBCEDB_ACTIVE;
                    InterlockedIncrement(&MRxIfsStatistics.Sessions);
                } else {
                    Status = STATUS_MORE_PROCESSING_REQUIRED;
                }
            } else {
                RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader::Session setup and X Response %lx\n",Status));
                fSessionSetupResponse = TRUE;
                SessionState = SMBCEDB_MARKED_FOR_DELETION;
                InterlockedIncrement(&MRxIfsStatistics.FailedSessions);

                if ((SmbCommand == SMB_COM_TREE_CONNECT_ANDX) ||
                    (SmbCommand == SMB_COM_TREE_CONNECT)) {
                    RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader:: Tearing down a tree connection\n"));
                    fTreeConnectResponse  = TRUE;
                    NetRootState = SMBCEDB_MARKED_FOR_DELETION;
                }
            }
        }
    }

    if ((SmbCommand == SMB_COM_TREE_CONNECT_ANDX) &&
        NT_SUCCESS(Status)) {
        if (SmbResponseStatus != STATUS_SUCCESS) {
            if ((FIELD_OFFSET(GENERIC_ANDX,AndXReserved) + *pBytesConsumed) <= BytesIndicated) {
                PGENERIC_ANDX pGenericAndX = (PGENERIC_ANDX)pSmbBuffer;

                if (pGenericAndX->WordCount == 0) {
                    Status = SmbResponseStatus;
                }
            }

            // Note that the case wherein sufficient bytes are not indicated for the
            // GENERIC_ANDX response is handled by the if statement below which
            // imposes a more stringent test.
        }

        if ((Status == STATUS_SUCCESS) &&
            (FIELD_OFFSET(RESP_21_TREE_CONNECT_ANDX,Buffer) + *pBytesConsumed) > BytesIndicated) {
            Status = STATUS_MORE_PROCESSING_REQUIRED;
        }

        if (Status == STATUS_SUCCESS) {
            ULONG TreeConnectResponseLength,TreeConnectByteCount,ServiceStringLength;
            PUCHAR pShareTypeResponseString = NULL;
            PRESP_21_TREE_CONNECT_ANDX p21TreeConnectAndXResponse;

            p21TreeConnectAndXResponse = (PRESP_21_TREE_CONNECT_ANDX)(pSmbBuffer);
            SmbCommand = p21TreeConnectAndXResponse->AndXCommand;

            RxDbgTrace( 0, Dbg, ("Processing Tree Connect and X\n"));

            // case out based on the actual response length. Lanman 21 clients or NT clients
            // have a longer response.....win95 negotiates NT dialect but uses a <lm21 response format
            switch (p21TreeConnectAndXResponse->WordCount) {
            case 0:
                Status = SmbResponseStatus;
                break;

            case 3:
                {
                    pShareTypeResponseString = (PUCHAR)&p21TreeConnectAndXResponse->Buffer;
                    TreeConnectByteCount  = SmbGetUshort(&p21TreeConnectAndXResponse->ByteCount);
                    if (SmbCommand == SMB_COM_NO_ANDX_COMMAND) {
                        TreeConnectResponseLength =
                            FIELD_OFFSET(RESP_21_TREE_CONNECT_ANDX,Buffer) + TreeConnectByteCount;

                        Status = SmbResponseStatus;
                    } else {
                        TreeConnectResponseLength =
                            SmbGetUshort(&p21TreeConnectAndXResponse->AndXOffset) -
                            *pBytesConsumed;
                    }
                }
                break;

            case 2:
                {
                    PRESP_TREE_CONNECT_ANDX pTreeConnectAndXResponse;

                    pTreeConnectAndXResponse = (PRESP_TREE_CONNECT_ANDX)(pSmbBuffer);
                    //SmbCommand = pTreeConnectAndXResponse->AndXCommand;
                    ASSERT(FIELD_OFFSET(RESP_TREE_CONNECT_ANDX,AndXCommand)
                           ==FIELD_OFFSET(RESP_21_TREE_CONNECT_ANDX,AndXCommand));
                    pShareTypeResponseString = (PUCHAR)&pTreeConnectAndXResponse->Buffer;
                    TreeConnectByteCount  = SmbGetUshort(&pTreeConnectAndXResponse->ByteCount);
                    if (SmbCommand == SMB_COM_NO_ANDX_COMMAND) {
                        TreeConnectResponseLength =
                            FIELD_OFFSET(RESP_TREE_CONNECT_ANDX,Buffer) + TreeConnectByteCount;

                        Status = SmbResponseStatus;
                    } else {
                        TreeConnectResponseLength =
                            SmbGetUshort(&pTreeConnectAndXResponse->AndXOffset) -
                            *pBytesConsumed;
                    }
                }
                break;

            default :
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            }

            RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader::Tree connect and X Response %lx\n",Status));
            if (NT_SUCCESS(Status)) {
                PSMBCE_NET_ROOT psmbNetRoot = &pExchange->SmbCeContext.pNetRootEntry->NetRoot;
                PSMBCE_SERVER psmbServer = &pExchange->SmbCeContext.pServerEntry->Server;

                if (TreeConnectResponseLength + *pBytesConsumed <= BytesIndicated) {
                    *pBytesConsumed += TreeConnectResponseLength;

                    // Update the NetRoot fields based on the response.

                    psmbNetRoot->TreeId = pSmbHeader->Tid;

                    {   struct __Service_Name_Entry *i;
                        for (i=ServiceNameTable;;i++) {
                            ServiceStringLength = i->NameLength;
                            if (RtlCompareMemory(
                                    pShareTypeResponseString,
                                    i->Name,
                                    ServiceStringLength)
                                == ServiceStringLength) {
                                psmbNetRoot->NetRootType = i->NetRootType;
                                if (FALSE) DbgPrint("FoundServiceStrng %s len %d type %d\n",i->Name,i->NameLength,i->NetRootType);
                                break;
                            }
                            if (i->NetRootType==NET_ROOT_COMM) {
                                ASSERT(!"Valid Share Type returned in TREE COnnect And X response");
                                psmbNetRoot->NetRootType = NET_ROOT_DISK;
                                ServiceStringLength = TreeConnectByteCount;
                                break;
                            }
                        }
                    }

                    if (psmbNetRoot->NetRootType == NET_ROOT_DISK) {
                        psmbNetRoot->MaximumReadBufferSize = psmbServer->MaximumDiskFileReadBufferSize;
                    } else {
                        psmbNetRoot->MaximumReadBufferSize = psmbServer->MaximumNonDiskFileReadBufferSize;
                    }

                    //if !(NT was negotiated) and bytecount>servicelength, we may have a NativeFs name
                    if (!FlagOn(psmbServer->DialectFlags,DF_NTNEGOTIATE)
                        && (TreeConnectByteCount>ServiceStringLength)) {
                        PBYTE NativeFs = pShareTypeResponseString+ServiceStringLength;
                        if (*NativeFs != 0) {
                            ULONG i;
                            ULONG maxlenpersmb = TreeConnectByteCount-ServiceStringLength;
                            ULONG maxlenperarraysize = SMB_MAXIMUM_SUPPORTED_VOLUME_LABEL;
                            PCHAR p = (PCHAR)(&psmbNetRoot->FileSystemNameA[0]);  //dont write into the 0th char
                            //DbgPrint("we may have one...\n");
                            for (i=1;;i++){
                                if (i==maxlenpersmb) {
                                    break;
                                }
                                if (i==maxlenperarraysize) {
                                    break;
                                }
                                if (NativeFs[i]==0) {
                                    break;
                                }
                            }
                            //save away the name for processing later

                            RtlCopyMemory(p,NativeFs,i);
                            p[i] = 0;
                            //DbgPrint("NativeFs = %s (%d)\n",p,i);
                            psmbNetRoot->FileSystemNameALength = (UCHAR)i;
                        }
                    }

                    pSmbBuffer += TreeConnectResponseLength;
                    fTreeConnectResponse = TRUE;
                    NetRootState         = SMBCEDB_ACTIVE;
                } else {
                    Status = STATUS_MORE_PROCESSING_REQUIRED;
                }
            } else {
                fTreeConnectResponse  = TRUE;
                NetRootState          = SMBCEDB_MARKED_FOR_DELETION;
            }
        }
    }

    if ((SmbCommand == SMB_COM_TREE_CONNECT) &&
        NT_SUCCESS(Status)) {
        PRESP_TREE_CONNECT   pTreeConnectResponse;
        ULONG                TreeConnectResponseLength;

        RxDbgTrace( 0, Dbg, ("Processing Tree Connect\n"));
        pTreeConnectResponse      = (PRESP_TREE_CONNECT)pSmbBuffer;
        TreeConnectResponseLength = FIELD_OFFSET(RESP_TREE_CONNECT,Buffer);

        SmbCommand = SMB_COM_NO_ANDX_COMMAND;

        if (NT_SUCCESS(SmbResponseStatus)) {
            if (TreeConnectResponseLength + *pBytesConsumed <= BytesIndicated) {
                pExchange->SmbCeContext.pNetRootEntry->NetRoot.TreeId
                    = SmbGetUshort(&pTreeConnectResponse->Tid);
                pExchange->SmbCeContext.pNetRootEntry->NetRoot.NetRootType = NET_ROOT_WILD;
                if (pExchange->SmbCeContext.pServerEntry->Server.MaximumBufferSize == 0){
                    RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader:: setting srvmaxbufsize %ld\n",
                                         SmbGetUshort(&pTreeConnectResponse->MaxBufferSize)));
                    pExchange->SmbCeContext.pServerEntry->Server.MaximumBufferSize =
                        SmbGetUshort(&pTreeConnectResponse->MaxBufferSize);
                }

                *pBytesConsumed += TreeConnectResponseLength;

                pSmbBuffer += *pBytesConsumed;

                fTreeConnectResponse = TRUE;
                NetRootState         = SMBCEDB_ACTIVE;

                //for CORE, this counts as a successful session setup as well!
                pExchange->SmbCeContext.pSessionEntry->Session.UserId = pSmbHeader->Uid;
                fSessionSetupResponse = TRUE;
                SessionState = SMBCEDB_ACTIVE;
            } else {
                Status = STATUS_MORE_PROCESSING_REQUIRED;
            }
        } else {
            Status = SmbResponseStatus;
            fTreeConnectResponse  = TRUE;
            NetRootState          = SMBCEDB_MARKED_FOR_DELETION;
        }

        RxDbgTrace( 0, Dbg, ("SmbCeParseSmbHeader::Tree connect Response %lx\n",Status));
    }

    // Initiate further action if the status of the exchange/conenction engine can be
    // updated based on the data available.
    if ((pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR) ||
        (pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR)) {
        if (fSessionSetupResponse) {
            SmbCeUpdateSessionEntryState(
                pExchange->SmbCeContext.pSessionEntry,
                SessionState);

            RxDbgTrace( 0, Dbg, ("Dispatching Session Entry Finalization\n"));
        }

        if (fTreeConnectResponse) {
            SmbCeUpdateNetRootEntryState(
                pExchange->SmbCeContext.pNetRootEntry,
                NetRootState);

            RxDbgTrace( 0, Dbg, ("Dispatching Net root Entry Finalization\n"));
        }
    } else {
        ASSERT(pSmbHeader->Uid == pExchange->SmbCeContext.pSessionEntry->Session.UserId);
        ASSERT(pSmbHeader->Tid == pExchange->SmbCeContext.pNetRootEntry->NetRoot.TreeId);
    }

    pExchange->SmbStatus = SmbResponseStatus;     //N.B. no spinlock!
    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        *pBytesConsumed = 0;
    } else if (!NT_SUCCESS(Status)) {
        *pBytesConsumed = BytesAvailable;
    } else {
        if (pSmbResponseStatus != NULL) {
            *pSmbResponseStatus = SmbResponseStatus;
        }

        if (pCommandToProcess != NULL) {
            PGENERIC_ANDX pGenericAndX = (PGENERIC_ANDX)((PBYTE)pSmbHeader + *pBytesConsumed);

            pCommandToProcess->AndXCommand = SmbCommand;
            SmbPutUshort(&pCommandToProcess->AndXOffset, (USHORT)*pBytesConsumed);

            if ((sizeof(GENERIC_ANDX) + *pBytesConsumed) <= BytesAvailable) {
                pCommandToProcess->WordCount   = pGenericAndX->WordCount;
            } else {
                pCommandToProcess->WordCount = 0;
            }
        }
    }

    return Status;
}


NTSTATUS
SmbCeInitializeExchange(
    PSMB_EXCHANGE                 *pExchangePointer,
    PMRX_V_NET_ROOT               pVNetRoot,
    SMB_EXCHANGE_TYPE             Type,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector)
/*++

Routine Description:

   This routine initializes the given exchange instance

Arguments:

    pExchangePointer  - the placeholder for the exchange instance. If it is NULL a new one
    is allocated.

    pVirtualNetRoot   - the virtual net root

    pNetRoot          - the associated net root

    Type              - the type of the exchange

    pDispatchVector   - the dispatch vector associated with this instance.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxDbgTrace( 0, Dbg, ("SmbCeInitializeExchange: Invoked\n"));

    if (*pExchangePointer == NULL) {
        // Allocate a new exchange instance.
        *pExchangePointer = SmbMmAllocateExchange(Type,NULL);
        if (*pExchangePointer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if ((Status = SmbCeIncrementActiveExchangeCount()) == STATUS_SUCCESS) {
        PSMB_EXCHANGE LocalExchangePointer = *pExchangePointer;

        LocalExchangePointer->SmbCeContext.pVNetRoot = pVNetRoot;

        LocalExchangePointer->SmbCeContext.pServerEntry  =
            SmbCeReferenceAssociatedServerEntry(pVNetRoot->pNetRoot->pSrvCall);

        LocalExchangePointer->SmbCeContext.pSessionEntry =
            SmbCeReferenceAssociatedSessionEntry(pVNetRoot);

        LocalExchangePointer->SmbCeContext.pNetRootEntry =
            SmbCeReferenceAssociatedNetRootEntry(pVNetRoot->pNetRoot);

        LocalExchangePointer->SmbCeState = SMBCE_EXCHANGE_INITIALIZATION_START;
        LocalExchangePointer->pDispatchVector = pDispatchVector;
        LocalExchangePointer->SmbCeFlags &= (SMBCE_EXCHANGE_FLAGS_TO_PRESERVE);
        LocalExchangePointer->SmbCeFlags |= (SMBCE_EXCHANGE_REUSE_MID | SMBCE_EXCHANGE_ATTEMPT_RECONNECTS);
    }

    return Status;
}

NTSTATUS
SmbCeTransformExchange(
    PSMB_EXCHANGE                 pExchange,
    SMB_EXCHANGE_TYPE             NewType,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector)
/*++

Routine Description:

   This routine transforms an exchange instance of one kind to an exchange instance
   of another kind ( A sophisticated form of casting )

Arguments:

    pExchange         - the exchange instance.

    Type              - the new type of the exchange

    pDispatchVector   - the dispatch vector associated with this instance.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    As it is currently implemented no restrictions are imposed. Once the number of exchanges
    have been established further restrictions will be imposed barring certain kinds of
    transformations. The transformation merely switches the dispatch vector associated
    with the exchange but the context is left intact.

--*/
{
    pExchange->Type = NewType;
    pExchange->pDispatchVector = pDispatchVector;
    return STATUS_SUCCESS;
}

NTSTATUS
SmbCePrepareExchangeForReuse(
    PSMB_EXCHANGE                 pExchange)
/*++

Routine Description:

   This routine transforms an exchange instance of one kind to an exchange instance
   of another kind ( A sophisticated form of casting )

Arguments:

    pExchange  - the exchange instance.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMBCEDB_SERVER_ENTRY   pServerEntry  = NULL;
    PSMBCEDB_SESSION_ENTRY  pSessionEntry = NULL;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = NULL;

    RxDbgTrace( 0, Dbg, ("SmbCePrepareExchangeForReuse: Invoked\n"));

    pNetRootEntry = pExchange->SmbCeContext.pNetRootEntry;
    pSessionEntry = pExchange->SmbCeContext.pSessionEntry;
    pServerEntry = pExchange->SmbCeContext.pServerEntry;

    if (pServerEntry != NULL) {
        // Disassociate the MID associated with the exchange
        if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID) {
            SmbCeDisassociateMidFromExchange(pServerEntry,pExchange);
        }

        // Tear down all the copy data requests associated with this exchange
        SmbCePurgeBuffersAssociatedWithExchange(pServerEntry,pExchange);

        // Uninitialize the transport associated with the exchange
        SmbCeUninitializeExchangeTransport(pExchange);

        // If this exchange has been marked as a constructor for either a
        // session or netroot finalize the appropriate entries. ( mark
        // them for deletion so that other exchanges can be resumed )

        if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_SESSION_CONSTRUCTOR) {
            ASSERT(pSessionEntry != NULL);
            RxDbgTrace( 0, Dbg, ("Dispatching Session Entry Finalization\n"));
            SmbCeReferenceSessionEntry(pSessionEntry);
            SmbCeCompleteSessionEntryInitialization(pSessionEntry);
            pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_SESSION_CONSTRUCTOR;
        }

        if (pExchange->SmbCeFlags & SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR) {
            ASSERT(pNetRootEntry != NULL);
            RxDbgTrace( 0, Dbg, ("Dispatching Net root Entry Finalization\n"));
            // Finalize the construction of the net root entry.
            SmbCeReferenceNetRootEntry(pExchange->SmbCeContext.pNetRootEntry);
            SmbCeCompleteNetRootEntryInitialization(pNetRootEntry);
            pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR;
        }

        SmbCeDereferenceEntries(
            pServerEntry,
            pSessionEntry,
            pNetRootEntry);
    } else {
        ASSERT((pSessionEntry == NULL) && (pNetRootEntry == NULL));
    }

    return STATUS_SUCCESS;
}

VOID
SmbCeDiscardExchange(PVOID pExchange)
/*++

Routine Description:

   This routine discards an exchange.

Arguments:

    pExchange  - the exchange to be discarded.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    Even though this is simple, it cannot be inlined since the destruction of an
    exchange instance can be posted to a worker thread.

--*/
{
    PSMB_EXCHANGE pSmbExchange = pExchange;

    RxDbgTrace( 0, Dbg, ("SmbCeDiscardExchange: Invoked\n"));

    RxLog((">>>Discard %lx",pSmbExchange));

    // Destroy the context
    if (pSmbExchange->ReferenceCount == 0) {
        SmbCePrepareExchangeForReuse(pSmbExchange);

        SmbCeDecrementActiveExchangeCount();

        // Discard the memory associated with the exchange
        SmbMmFreeExchange(pSmbExchange);
    } else {
        RxDbgTrace(
            0,
            Dbg,
            ("SmbCeDiscardExchange: Exchange %lx not discarded %ld\n",
              pSmbExchange,pSmbExchange->ReferenceCount)
            );
    }
}

NTSTATUS
SmbCeIncrementPendingOperations(
   PSMB_EXCHANGE pExchange,
   ULONG         PendingOperationMask)
/*++

Routine Description:

   This routine increments the appropriate pending operation count

Arguments:

    pExchange  - the exchange to be finalized.

    PendingOperationsMask -- the pending operations to be incremented

Return Value:

    RxStatus(SUCCESS) if successful

--*/
{
    NTSTATUS Status;

    SmbCeAcquireSpinLock();

    if (!BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED)) {
        if ((pExchange->SmbCeContext.pServerEntry != NULL) &&
            ((pExchange->SmbCeContext.pServerEntry->ServerStatus == STATUS_SUCCESS) ||
            (pExchange->NodeTypeCode == SMB_EXCHANGE_NTC(ADMIN_EXCHANGE)))) {

            if (PendingOperationMask & SMBCE_LOCAL_OPERATION) {
                pExchange->LocalPendingOperations++;
            }

            if (PendingOperationMask & SMBCE_SEND_COMPLETE_OPERATION) {
                pExchange->SendCompletePendingOperations++;
            }

            if (PendingOperationMask & SMBCE_COPY_DATA_OPERATION) {
                pExchange->CopyDataPendingOperations++;
            }

            if (PendingOperationMask & SMBCE_RECEIVE_OPERATION) {
                pExchange->ReceivePendingOperations++;
            }

            Status = STATUS_SUCCESS;
        } else {
            if ((PendingOperationMask & SMBCE_LOCAL_OPERATION) &&
                (PendingOperationMask & ~SMBCE_LOCAL_OPERATION) == 0) {

                pExchange->LocalPendingOperations++;
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_CONNECTION_DISCONNECTED;
            }
        }
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    SmbCeReleaseSpinLock();

    return Status;
}

VOID
SmbCeFinalizeExchangeWorkerThreadRoutine(
    PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

   This is the worker thread exchange finalization routine.

Arguments:

    pExchange  - the exchange to be finalized.

--*/
{
    BOOLEAN  fPostFinalize;
    NTSTATUS Status;

    Status = SMB_EXCHANGE_DISPATCH(
                 pExchange,
                 Finalize,
                 (pExchange,&fPostFinalize));

    ASSERT(!fPostFinalize && (Status == STATUS_SUCCESS));
}

VOID
SmbCepFinalizeExchange(
    PSMB_EXCHANGE pExchange)
/*++

Routine Description:

   This is the common finalization routine used by both the routines below

Arguments:

    pExchange  - the exchange to be finalized.

--*/
{
    NTSTATUS Status;
    BOOLEAN fPostFinalize = FALSE;

    ASSERT(FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED));

    if (!(pExchange->SmbCeFlags & SMBCE_EXCHANGE_RETAIN_MID)) {
        SmbCeDisassociateMidFromExchange(
            pExchange->SmbCeContext.pServerEntry,
            pExchange);
    }

    Status = SMB_EXCHANGE_DISPATCH(
                 pExchange,
                 Finalize,
                 (pExchange,&fPostFinalize));

    if ((Status == STATUS_SUCCESS) &&
        fPostFinalize)  {
        // Post the request to a worker thread so that the finalization can be completed
        // at a lower IRQL.
        RxPostToWorkerThread(
            MRxIfsDeviceObject,
            CriticalWorkQueue,
            &pExchange->WorkQueueItem,
            SmbCeFinalizeExchangeWorkerThreadRoutine,
            pExchange);
    }
}

SMBCE_EXCHANGE_STATUS
SmbCeFinalizeExchange(
    PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

   This routine finalizes an exchange instance.

Arguments:

    pExchange  - the exchange to be finalized.

Return Value:

    appropriate exchange status

Notes:

    When an exchange is initiated and the start routine is invoked a number of
    SMB's are sent. This routine is invoked when all processing pertaining to the
    SMB's that have been sent has ceased.

    This routine encapsulates all the idiosyncratic behaviour associated with the
    transports.

--*/
{
    BOOLEAN               fFinalizeExchange = FALSE;
    SMBCE_EXCHANGE_STATUS ExchangeStatus;

    SmbCeAcquireSpinLock();

    if (!(pExchange->SmbCeFlags & SMBCE_EXCHANGE_FINALIZED)) {
        if ((pExchange->ReceivePendingOperations == 0) &&
            (pExchange->CopyDataPendingOperations == 0) &&
            (pExchange->SendCompletePendingOperations == 0) &&
            (pExchange->LocalPendingOperations == 0)) {

            fFinalizeExchange = TRUE;
            ExchangeStatus = SmbCeExchangeFinalized;
            pExchange->SmbCeFlags |= SMBCE_EXCHANGE_FINALIZED;
        } else {
            ExchangeStatus = SmbCeExchangeNotFinalized;
        }
    } else {
        ExchangeStatus = SmbCeExchangeAlreadyFinalized;
    }

    SmbCeReleaseSpinLock();

    if (fFinalizeExchange) {
        SmbCepFinalizeExchange(pExchange);
    }

    return ExchangeStatus;
}

SMBCE_EXCHANGE_STATUS
SmbCeDecrementPendingOperationsAndFinalize(
    PSMB_EXCHANGE pExchange,
    ULONG         PendingOperationMask)
/*++

Routine Description:

   This routine decrements the corresponding pending operation count
   and finalizes an exchange instance if required

Arguments:

    pExchange  - the exchange to be finalized.

    PendingOperationsMask -- the pending operations to be decremented.

Return Value:

    appropriate exchange status

Notes:

    When an exchange is initiated and the start routine is invoked a number of
    SMB's are sent. This routine is invoked when all processing pertaining to the
    SMB's that have been sent has ceased.

    This routine encapsulates all the idiosyncratic behaviour associated with the
    transports.

--*/
{
    BOOLEAN               fFinalizeExchange = FALSE;
    SMBCE_EXCHANGE_STATUS ExchangeStatus;

    SmbCeAcquireSpinLock();

    ASSERT(!BooleanFlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_FINALIZED));

    if (PendingOperationMask & SMBCE_LOCAL_OPERATION) {
        ASSERT(pExchange->LocalPendingOperations > 0);
        pExchange->LocalPendingOperations--;
    }

    if (PendingOperationMask & SMBCE_SEND_COMPLETE_OPERATION) {
        ASSERT(pExchange->SendCompletePendingOperations > 0);
        pExchange->SendCompletePendingOperations--;
    }

    if (PendingOperationMask & SMBCE_COPY_DATA_OPERATION) {
        ASSERT(pExchange->CopyDataPendingOperations > 0);
        pExchange->CopyDataPendingOperations--;
    }

    if ((PendingOperationMask & SMBCE_RECEIVE_OPERATION) &&
        (pExchange->ReceivePendingOperations > 0)) {
        pExchange->ReceivePendingOperations--;
    }

    if ((pExchange->ReceivePendingOperations == 0) &&
        (pExchange->CopyDataPendingOperations == 0) &&
        (pExchange->SendCompletePendingOperations == 0) &&
        (pExchange->LocalPendingOperations == 0)) {

        fFinalizeExchange = TRUE;
        ExchangeStatus = SmbCeExchangeFinalized;
        pExchange->SmbCeFlags |= SMBCE_EXCHANGE_FINALIZED;
    } else {
        ExchangeStatus = SmbCeExchangeNotFinalized;
    }

    SmbCeReleaseSpinLock();

    if (fFinalizeExchange) {
        SmbCepFinalizeExchange(pExchange);
    }

    return ExchangeStatus;
}


//
// Default handler implementation of exchange handler functions.
//

NTSTATUS
DefaultSmbExchangeIndError(
    IN PSMB_EXCHANGE pExchange)     // the SMB exchange instance
{
    UNREFERENCED_PARAMETER(pExchange);
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
DefaultSmbExchangeIndReceive(
    IN PSMB_EXCHANGE 	pExchange)    // The exchange instance
{
    UNREFERENCED_PARAMETER(pExchange);
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
DefaultSmbExchangeIndSendCallback(
    IN PSMB_EXCHANGE 	pExchange)    // The exchange instance
{
    UNREFERENCED_PARAMETER(pExchange);
    return STATUS_NOT_IMPLEMENTED;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\sndrcv.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sndrcv.c

Abstract:

    This module implements all functions related to transmitting and recieving SMB's on
    all transports. The functionality common to all transports are handled in this
    module while transport specific functionality are handled in the appropriate
    ??sndrcv.c modules.

      vcsndrcv.c  -- virtual circuit(connection) related send/receive functionality


--*/

#include "precomp.h"
#pragma hdrstop

RXDT_DefineCategory(SMBSNDRCV);
#define Dbg        (DEBUG_TRACE_SMBSNDRCV)


#ifdef RDBSSLOG
//this stuff must be in nonpaged memory
                               ////       1 2 3 4 5 6 7 8 9
char MRxSmbMiniSniff_SurrogateFormat[] = "%S%S%N%N%N%N%N%N%N";
                            ////                     2       3       4       5       6         7        8        9
char MRxSmbMiniSniff_ActualFormat[]    = "Minisniff (%s) srv %lx cmd %lx mid %lx len %04lx flg %06lx xc %08lx rx %08lx";

char MRxSmbMiniSniffTranceive[] = "Tranceive";
char MRxSmbMiniSniffReceive[] = "Receive";
char MRxSmbMiniSniffReceiveEcho[] = "RcvEcho";
char MRxSmbMiniSniffReceiveDiscard[] = "RcvDiscard";
char MRxSmbMiniSniffReceiveDiscardOplock[] = "RcvDiscardOplock";
char MRxSmbMiniSniffReceiveIndicateOplock[] = "RcvIndicateOplock";
char MRxSmbMiniSniffSend[] = "Send";
char MRxSmbMiniSniffSendSrv[] = "SendToServer";

VOID
RxMiniSniffer(
    IN PSZ TagString,
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN ULONG Length,
    IN PSMB_EXCHANGE pExchange,
    IN PSMB_HEADER   pSmbHeader
    )
{
    PRX_CONTEXT RxContext = NULL;

    //return;

    if (pExchange!=NULL) {
        RxContext = pExchange->RxContext;
    }
    RxLog((MRxSmbMiniSniff_SurrogateFormat, MRxSmbMiniSniff_ActualFormat,
                    TagString,
                    pServerEntry,
                    pSmbHeader->Command,pSmbHeader->Mid,
                    Length,
                    (pSmbHeader->Flags<<16)|pSmbHeader->Flags2,
                    pExchange,RxContext));
}
#else
#define RxMiniSniffer(a,b,c,d,e) {NOTHING;}
#endif //ifdef RDBSSLOG


NTSTATUS
SmbCeTranceive(
      PSMB_EXCHANGE           pExchange,
      ULONG                   SendOptions,
      PMDL            pSmbMdl,
      ULONG                   SendLength)
/*++

Routine Description:

    This routine transmits/receives a SMB for a give exchange

Arguments:

    pServerEntry - the server entry

    pExchange  - the exchange instance issuing this SMB.

    SendOptions - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be transmitted

Return Value:

    STATUS_PENDING - the transmit/receive request has been passed on successfully to the underlying
                     connection engine.

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS                Status = STATUS_SUCCESS;

   PSMBCEDB_SERVER_ENTRY   pServerEntry = pExchange->SmbCeContext.pServerEntry;
   PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = pExchange->SmbCeContext.pNetRootEntry;

   PSMB_HEADER             pSmbHeader   = MmGetSystemAddressForMdl(pSmbMdl);
   USHORT                  Mid;

   PVOID                   pSendCompletionContext = NULL;

   Status = SmbCeIncrementPendingOperations(
                  pExchange,
                  (SMBCE_LOCAL_OPERATION | SMBCE_SEND_COMPLETE_OPERATION | SMBCE_RECEIVE_OPERATION));

   if (Status == STATUS_SUCCESS) {
      // Ensure that the transport associated with the exchange is valid.
      // It is not always possible to make decisions w.r.t changing
      // transports since it is a function of the protocol choosen at the
      // higher level. Therefore no attempts to reconnect are made at this
      // level.
      ASSERT(pServerEntry->pTransport != NULL);
      ASSERT((pExchange->Type == KERBEROS_SESSION_SETUP_EXCHANGE) ||
             (pExchange->Type == ADMIN_EXCHANGE)                  ||
             ((pNetRootEntry->Header.ObjectType == SMBCEDB_OT_NETROOT) &&
              SmbCeIsEntryInUse(&pNetRootEntry->Header)));

      if (!(pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID)) {
         // Associate the exchange with a mid
         Status = SmbCeAssociateExchangeWithMid(pServerEntry,pExchange);
      }

      if (Status == STATUS_SUCCESS) {
         if (pExchange->pDispatchVector->SendCompletionHandler != NULL) {
            Status = SmbCeAssociateBufferWithExchange(pServerEntry,pExchange,pSmbMdl);

            if (Status == STATUS_SUCCESS) {
               pSendCompletionContext = pSmbMdl;
            }
         }

         // If there is no send completion handling associated with this tranceive
         // decrement the count.
         if (pSendCompletionContext == NULL) {
            SmbCeDecrementPendingSendCompleteOperations(pExchange);
         }

         if (Status == STATUS_SUCCESS) {
            // Stamp the MID allocated for the request and send the SMB.
            pSmbHeader->Mid = pExchange->Mid;

            //RxLog(("Smb (TR) %lx %lx %lx\n",pServerEntry,pSmbHeader->Command,pSmbHeader->Mid));
            RxMiniSniffer(MRxSmbMiniSniffTranceive,pServerEntry,SendLength,pExchange,pSmbHeader);

            // Update the operation counts for the exchange instance.
            // Refer to Header for detailed explanation
            Status = (pServerEntry->pTransport->pDispatchVector->Tranceive)(
                            pServerEntry,
                            pExchange,
                            SendOptions,
                            pSmbMdl,
                            SendLength,
                            pSendCompletionContext);

            if ((Status != STATUS_PENDING) &&
                (Status != STATUS_SUCCESS)) {
               pExchange->Status = Status;
               SmbCeDecrementPendingReceiveOperations(pExchange);
               InterlockedIncrement(&MRxIfsStatistics.InitiallyFailedOperations);
            } else {
                ExInterlockedAddLargeStatistic(&MRxIfsStatistics.SmbsTransmitted,1);
                ExInterlockedAddLargeStatistic(&MRxIfsStatistics.BytesTransmitted,SendLength);
            }
         }
      } else {
         SmbCeDecrementPendingReceiveOperations(pExchange);
         SmbCeDecrementPendingSendCompleteOperations(pExchange);
      }

      if ((Status != STATUS_SUCCESS) && (Status != STATUS_PENDING)) {
         pExchange->SmbStatus = Status;
      }

      SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);
      Status = STATUS_PENDING;
   }

   return Status;
}

NTSTATUS
SmbCeReceive(
   PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

    This routine receives a SMB for a give exchange

Arguments:

    pExchange  - the exchange instance issuing this SMB.

Return Value:

    STATUS_SUCCESS - the exchange has been setup for receiving an SMB

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS Status = STATUS_SUCCESS;

   ASSERT(pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID);

   Status = SmbCeIncrementPendingOperations(pExchange, (SMBCE_RECEIVE_OPERATION));

   return Status;
}


NTSTATUS
SmbCeSend(
   PSMB_EXCHANGE         pExchange,
   ULONG                 SendOptions,
   PMDL          pSmbMdl,
   ULONG                 SendLength)
/*++

Routine Description:

    This routine transmits a SMB for a give exchange

Arguments:

    pServerEntry - the server entry

    pExchange  - the exchange instance issuing this SMB.

    SendOptions - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be transmitted

Return Value:

For asynchronous sends ....

    STATUS_PENDING - the request was passed onto the underlying transport and
                     the quiescent state routine will be called in the future.

    any other status code -- indicates an error in passing the request and the
                     quiescent state routine will never be called in the future.


For synchronous sends

    the appropriate status but will never return STATUS_PENDING.

Notes:

    This routine always expects an exchange with the appropriate SendCompletionHandler.

--*/
{
   NTSTATUS              Status       = STATUS_SUCCESS;
   PSMBCEDB_SERVER_ENTRY pServerEntry = pExchange->SmbCeContext.pServerEntry;
   PSMB_HEADER           pSmbHeader   = (PSMB_HEADER)MmGetSystemAddressForMdl(pSmbMdl);
   PVOID                 pSendCompletionContext = NULL;

   ASSERT(pExchange != NULL);

   Status = SmbCeIncrementPendingOperations(pExchange, (SMBCE_LOCAL_OPERATION | SMBCE_SEND_COMPLETE_OPERATION));

   if (Status == STATUS_SUCCESS) {
      ASSERT(pServerEntry->pTransport != NULL);
      if (SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER) {
         if (!(pExchange->SmbCeFlags & SMBCE_EXCHANGE_MID_VALID)) {
            // Associate the exchange with a mid if it does not already have a valid mid.
            Status = SmbCeAssociateExchangeWithMid(pServerEntry,pExchange);
         }

         if (Status == STATUS_SUCCESS) {
            // if the MID association was successful copy the MID onto the SMB and setup
            // a send completion context if required
            pSmbHeader->Mid = pExchange->Mid;
            if (!(SendOptions & RXCE_SEND_SYNCHRONOUS)) {
               ASSERT(pExchange->pDispatchVector->SendCompletionHandler != NULL);
               Status = SmbCeAssociateBufferWithExchange(pServerEntry,pExchange,pSmbMdl);
               if (Status == STATUS_SUCCESS) {
                  pSendCompletionContext = pSmbMdl;
               }
            }
         }
      }

      if ((pSendCompletionContext == NULL) ||
          (Status != STATUS_SUCCESS)) {
         SmbCeDecrementPendingSendCompleteOperations(pExchange);
      }

      if (Status == STATUS_SUCCESS) {
         Status = (pServerEntry->pTransport->pDispatchVector->Send)(
                       pServerEntry,
                       SendOptions,
                       pSmbMdl,
                       SendLength,
                       pSendCompletionContext);
      }

      RxMiniSniffer(MRxSmbMiniSniffSend,pServerEntry,SendLength,pExchange,pSmbHeader);

      if ((Status != STATUS_SUCCESS) && (Status != STATUS_PENDING)) {
         pExchange->SmbStatus = Status;
         InterlockedIncrement(&MRxIfsStatistics.InitiallyFailedOperations);
      } else {
          ExInterlockedAddLargeStatistic(&MRxIfsStatistics.SmbsTransmitted,1);
          ExInterlockedAddLargeStatistic(&MRxIfsStatistics.BytesTransmitted,SendLength);
      }

      SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);

      if (!(SendOptions & RXCE_SEND_SYNCHRONOUS)) {
         Status = STATUS_PENDING;
      } else {
         ASSERT(Status != STATUS_PENDING);
      }
   }

   return Status;
}

NTSTATUS
SmbCeSendToServer(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   ULONG                 SendOptions,
   PMDL          pSmbMdl,
   ULONG                 SendLength)
/*++

Routine Description:

    This routine transmits a SMB to a given server synchronously.

Arguments:

    pServerEntry - the server entry

    SendOptions - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be transmitted

Return Value:

    STATUS_SUCCESS if successful

    otherwise appropriate error code

--*/
{
   NTSTATUS    Status = STATUS_SUCCESS;
   PSMB_HEADER pSmbHeader   = (PSMB_HEADER)MmGetSystemAddressForMdl(pSmbMdl);
   PVOID       pSendCompletionContext = NULL;

   if (pServerEntry->pTransport != NULL) {
      Status = (pServerEntry->pTransport->pDispatchVector->Send)(
                    pServerEntry,
                    (SendOptions | RXCE_SEND_SYNCHRONOUS),
                    pSmbMdl,
                    SendLength,
                    pSendCompletionContext);

      if (!NT_SUCCESS(Status)) {
         InterlockedIncrement(&MRxIfsStatistics.InitiallyFailedOperations);
      } else {
          ExInterlockedAddLargeStatistic(&MRxIfsStatistics.SmbsTransmitted,1);
          ExInterlockedAddLargeStatistic(&MRxIfsStatistics.BytesTransmitted,SendLength);
      }

   } else {
      Status = STATUS_CONNECTION_DISCONNECTED;
   }

   ASSERT(Status != STATUS_PENDING);
   RxMiniSniffer(MRxSmbMiniSniffSendSrv,pServerEntry,SendLength,NULL,pSmbHeader);
   return Status;
}


NTSTATUS
SmbCeReceiveInd(
      IN PSMBCEDB_SERVER_ENTRY pServerEntry,
      IN ULONG                 BytesIndicated,
      IN ULONG                 BytesAvailable,
      OUT ULONG                *pBytesTaken,
      IN PVOID                 pTsdu,                  // pointer describing this TSDU, typically a lump of bytes
      OUT PMDL           *pDataBufferPointer,    // the buffer in which data is to be copied.
      OUT PULONG               pDataBufferSize         // amount of data to copy
     )
/*++

Routine Description:

    This routine handles the receive indication for SMB's along all vcs in a connection to a
    server.

Arguments:

    pServerEntry       - the server entry

    BytesIndicated     - the bytes that are present in the indication.

    BytesAvailable     - the total data available

    pTsdu              - the data

    pDataBufferPointer - the buffer for copying the data not indicated.

    pDataBufferSize    - the length of the buffer

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS Status;

   BYTE                     *pSmbCommand;
   PSMB_EXCHANGE            pExchange;
   PSMB_HEADER              pSmbHeader = (PSMB_HEADER)pTsdu;

   // Perform the quick tests by which ill formed SMB's, mangled SMB's can be rejected.
   // e.g., any indication which is of non zero length whihc is less then the length of
   // a SMB_HEADER cannot be a valid SMB.

   if ((BytesAvailable < sizeof(SMB_HEADER)) ||
       (SmbGetUlong(((PULONG )pSmbHeader->Protocol)) != (ULONG)SMB_HEADER_PROTOCOL)) {
      RxLog(("SmbCeReceiveInd: Invalid Response for %lx\n",pServerEntry));
      *pBytesTaken = BytesIndicated;
      return STATUS_SUCCESS;
   }

   ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

   if (pSmbHeader->Command == SMB_COM_ECHO) {
      SmbCeAcquireSpinLock();
      pServerEntry->Server.EchoProbeState = ECHO_PROBE_IDLE;
      SmbCeReleaseSpinLock();
      *pBytesTaken = BytesIndicated;
      RxMiniSniffer(MRxSmbMiniSniffReceiveEcho,pServerEntry,BytesIndicated,NULL,pSmbHeader);
      ExInterlockedAddLargeStatistic(&MRxIfsStatistics.SmbsReceived,1);
      ExInterlockedAddLargeStatistic(&MRxIfsStatistics.BytesReceived,BytesIndicated);
      return STATUS_SUCCESS;
   }

   // Perform the tests for detecting oplock break SMB's. These are SMB's with the
   // command SMB_COM_LOCKING_ANDX with the LOCKING_ANDX_OPLOCK_RELEASE bit set.
   // These SMB's are transformed into buffering state change requests which are
   // processed by the RDBSS.

   if (pSmbHeader->Command == SMB_COM_LOCKING_ANDX) {
      if (BytesIndicated == LOCK_BROKEN_SIZE) {
         PREQ_LOCKING_ANDX pOplockBreakRequest = (PREQ_LOCKING_ANDX)(pSmbHeader + 1);

         if (SmbGetUshort(&pOplockBreakRequest->LockType) & LOCKING_ANDX_OPLOCK_RELEASE) {
            ULONG NewOplockLevel;

            switch (pOplockBreakRequest->OplockLevel) {
            case OPLOCK_BROKEN_TO_II:
               NewOplockLevel = SMB_OPLOCK_LEVEL_II;
               break;
            case OPLOCK_BROKEN_TO_NONE:
            default:
               NewOplockLevel = SMB_OPLOCK_LEVEL_NONE;
            }

            RxMiniSniffer(MRxSmbMiniSniffReceiveIndicateOplock,pServerEntry,BytesIndicated,NULL,pSmbHeader);
            ExInterlockedAddLargeStatistic(&MRxIfsStatistics.SmbsReceived,1);
            ExInterlockedAddLargeStatistic(&MRxIfsStatistics.BytesReceived,BytesIndicated);

            RxIndicateChangeOfBufferingState(
                     pServerEntry->pRdbssSrvCall,
                     MRxIfsMakeSrvOpenKey(pSmbHeader->Tid,pOplockBreakRequest->Fid),
                     (PVOID)NewOplockLevel);

            RxDbgTrace(0,Dbg,("SmbCeReceiveInd: OPLOCK Break Request TID(%lx) FID(%lx)\n",
                                               pSmbHeader->Tid,pOplockBreakRequest->Fid));

            *pBytesTaken = BytesIndicated;
            return STATUS_SUCCESS;
         }
      }

      // Handle the cases when the server responds to the oplock break response.
      if (pSmbHeader->Mid == SMBCE_OPLOCK_RESPONSE_MID) {
         DbgPrint("@@@@@ Unexpected Oplock break response @@@@@\n");
         *pBytesTaken = BytesIndicated;
         ExInterlockedAddLargeStatistic(&MRxIfsStatistics.SmbsReceived,1);
         ExInterlockedAddLargeStatistic(&MRxIfsStatistics.BytesReceived,BytesIndicated);
         RxMiniSniffer(MRxSmbMiniSniffReceiveDiscardOplock,pServerEntry,BytesIndicated,NULL,pSmbHeader);
         return STATUS_SUCCESS;
      }
   }

   InterlockedIncrement(&pServerEntry->Server.SmbsReceivedSinceLastStrobe);

   // Initialize the copy data buffer and size to begin with.
   *pDataBufferPointer = NULL;
   *pDataBufferSize    = 0;

   // Map the MID to the associated exchange.
   if (pSmbHeader->Command == SMB_COM_NEGOTIATE) {
      pExchange = pServerEntry->pNegotiateExchange;
   } else {
      pExchange = SmbCeMapMidToExchange(pServerEntry,pSmbHeader->Mid);
   }

   RxMiniSniffer(MRxSmbMiniSniffReceive,pServerEntry,BytesIndicated,pExchange,pSmbHeader);

   // Note that the absence of a request entry cannot be asserted. It is conceivable that
   // requests could have been cancelled.
   if ((pExchange != NULL) &&
       (SmbCeIncrementPendingOperations(
               pExchange,
               (SMBCE_LOCAL_OPERATION | SMBCE_COPY_DATA_OPERATION)) == STATUS_SUCCESS)) {
      // Invoke the receive indication handler
      Status = SMB_EXCHANGE_DISPATCH(pExchange,
                                     Receive,
                                     (pExchange,
                                      BytesIndicated,
                                      BytesAvailable,
                                      pBytesTaken,
                                      pTsdu,
                                      pDataBufferPointer,
                                      pDataBufferSize));

      ExInterlockedAddLargeStatistic(&MRxIfsStatistics.SmbsReceived,1);
      ExInterlockedAddLargeStatistic(&MRxIfsStatistics.BytesReceived,*pBytesTaken);

      RxDbgTrace(0, Dbg, ("SmbCeReceiveInd: SMB_EXCHANGE_DISPATCH returned %lx,taken/mdl=%08lx/%08lx\n",
                                          Status,*pBytesTaken,*pDataBufferPointer));
      ASSERT ( (Status==STATUS_MORE_PROCESSING_REQUIRED)==((*pDataBufferPointer)!=NULL));

      if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
         Status = SmbCeAssociateBufferWithExchange(pServerEntry,pExchange,*pDataBufferPointer);
         if (Status != STATUS_SUCCESS) {
            DbgPrint("VctIndReceive:Error handling copy data request %lx\n",Status);
            pExchange->Status = Status;
            *pBytesTaken = BytesAvailable;
            Status = STATUS_SUCCESS;
         } else {
            Status = STATUS_MORE_PROCESSING_REQUIRED;
         }
      }

      if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
         SmbCeDecrementPendingCopyDataOperations(pExchange);
      }

      SmbCeDecrementPendingReceiveOperations(pExchange);

      SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange);

      if (((*pBytesTaken + *pDataBufferSize) < BytesAvailable)  &&
          (Status != STATUS_MORE_PROCESSING_REQUIRED)) {
         RxDbgTrace(0,Dbg,("SmbCeReceiveInd:Not consuming all indicated data\n"));
         *pBytesTaken = BytesAvailable;
      }
   } else {
      // Should we change over to a strategy in which the transport pipeline is kept
      // open by consuming all indicated data
      // DbgBreakPoint();
      DbgPrint("SmbCeReceiveInd:No resumption context .. not accepting data\n");
      Status = STATUS_SUCCESS;
      *pBytesTaken = BytesAvailable;
   }

   ASSERT((*pBytesTaken + *pDataBufferSize) >= BytesAvailable);
   return Status;
}


NTSTATUS
SmbCeDataReadyInd(
   IN PSMBCEDB_SERVER_ENTRY pServerEntry,
   IN PMDL          pBuffer,
   IN ULONG                 DataSize,
   IN NTSTATUS              CopyDataStatus
   )
/*++

Routine Description:

    This routine handles the indication when the requested data has been copied

Arguments:

    pServerEntry  - the server instance

    pBuffer       - the buffer being returned

    DataSize      - the amount of data copied in bytes

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS      Status;
   PSMB_EXCHANGE pExchange;

   // Map the buffer to the exchange
   pExchange = SmbCeGetExchangeAssociatedWithBuffer(pServerEntry,pBuffer);

   RxDbgTrace(0, Dbg, ("VctIndDataReady: Processing Exchange %lx\n",pExchange));
   if (pExchange != NULL) {
      if (CopyDataStatus == STATUS_SUCCESS) {
         // Notify the exchange of the completion
         //ExInterlockedAddLargeStatistic(&MRxIfsStatistics.SmbsReceived,1);
         ExInterlockedAddLargeStatistic(&MRxIfsStatistics.BytesReceived,DataSize);
         SMB_EXCHANGE_DISPATCH(
                           pExchange,
                           CopyDataHandler,
                           (pExchange,pBuffer,DataSize));
      }

      // Resume the exchange that was waiting for the data.
      SmbCeDecrementPendingCopyDataOperationsAndFinalize(pExchange);
   } else {
      // the exchange was cancelled while the copy was in progress. Free up the buffer
      RxDbgTrace(0, Dbg, ("VctIndDataReady: Freeing cancelled request BUGBUG !!!\n"));
      IoFreeMdl(pBuffer);
   }

   return STATUS_SUCCESS;
}

NTSTATUS
SmbCeErrorInd(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN NTSTATUS              IndicatedStatus
    )
/*++

Routine Description:

    This routine handles the error indication

Arguments:

    pEventContext - the server instance

    Status        - the error

Return Value:

    STATUS_SUCCESS

--*/
{
   NTSTATUS                 Status;
   PSMB_EXCHANGE            pExchange;

   DbgPrint("@@@@@@ Error Indication for %lx @@@@@\n",pServerEntry);
   InterlockedIncrement(&MRxIfsStatistics.NetworkErrors);
   // Post to the worker queue to resume all the outstanding requests
   pServerEntry->ServerStatus = IndicatedStatus;
   SmbCeReferenceServerEntry(pServerEntry);
   Status = RxDispatchToWorkerThread(
                  MRxIfsDeviceObject,
                  CriticalWorkQueue,
                  SmbCeResumeAllOutstandingRequestsOnError,
                  pServerEntry);
   if (Status != STATUS_SUCCESS) {
      DbgPrint("Error Indication not dispatched\n");
      RxLog(("SmbCeErrorInd(SE) %lx\n", pServerEntry));
   }

   return STATUS_SUCCESS;
}


NTSTATUS
SmbCeSendCompleteInd(
   IN PSMBCEDB_SERVER_ENTRY pServerEntry,
   IN PVOID                 pCompletionContext,
   IN NTSTATUS              SendCompletionStatus
   )
/*++

Routine Description:

    This routine handles the send complete indication for asynchronous sends

Arguments:

    pServerEntry - the server instance

    pCompletionContext - the context for identifying the send request

    SendCompletionStatus - the send completion status

Return Value:

    STATUS_SUCCESS always ..

--*/
{
   NTSTATUS      Status;

   PSMB_EXCHANGE pExchange;
   PVOID         pSendBuffer = pCompletionContext;

   if (pCompletionContext != NULL) {
      // Map the MID to the associated exchange
      pExchange = SmbCeGetExchangeAssociatedWithBuffer(
                        pServerEntry,
                        pSendBuffer);

      if (pExchange != NULL) {
         // Resume the exchange which was waiting for this response
         RxDbgTrace(0, Dbg, ("SmbCeSendCompleteInd: Send Completion Status %lx\n",SendCompletionStatus));

         if (pExchange->pDispatchVector->SendCompletionHandler != NULL) {
            Status = SMB_EXCHANGE_DISPATCH(pExchange,
                                           SendCompletionHandler,
                                           (pExchange,
                                            pSendBuffer,
                                            SendCompletionStatus));
         }

         RxDbgTrace(0, Dbg, ("SmbCeSendCompleteInd: SMB_EXCHANGE_DISPATCH returned %lx\n",Status));

         SmbCeDecrementPendingSendCompleteOperationsAndFinalize(pExchange);
      }
   }

   return STATUS_SUCCESS;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\smbpse.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    SmbPse.h

Abstract:

    This module defines the types and functions related to the SMB protocol
    selection engine: the component that translates minirdr calldowns into
    SMBs.

Revision History:

--*/

#ifndef _SMBPSE_H_
#define _SMBPSE_H_

IMPORTANT_STRUCTURE(SMB_PSE_ORDINARY_EXCHANGE);


#define MustBeDirectory(co) ((co) & FILE_DIRECTORY_FILE)
#define MustBeFile(co)      ((co) & FILE_NON_DIRECTORY_FILE)

#define SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE \
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange, \
    PRX_CONTEXT RxContext

#define SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS \
    OrdinaryExchange,RxContext

#if DBG
#define OECHKLINKAGE_FLAG_NO_REQPCKT_CHECK 0x00000001

VOID
__SmbPseOEAssertConsistentLinkage(
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line,
    PRX_CONTEXT RxContext,
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    PSMBSTUFFER_BUFFER_STATE StufferState,
    ULONG Flags
    );
#define SmbPseOEAssertConsistentLinkage(a) {\
   __SmbPseOEAssertConsistentLinkage(a,__FILE__,__LINE__,RxContext,OrdinaryExchange,StufferState,0);\
   }
#define SmbPseOEAssertConsistentLinkageFromOE(a) {\
    ASSERT_ORDINARY_EXCHANGE(OrdinaryExchange);                        \
   __SmbPseOEAssertConsistentLinkage(a,__FILE__,__LINE__,              \
                                     OrdinaryExchange->RxContext,      \
                                     OrdinaryExchange,                 \
                                     &OrdinaryExchange->AssociatedStufferState,0);  \
   }
#define SmbPseOEAssertConsistentLinkageFromOEwithFlags(a,FLAGS) {\
    ASSERT_ORDINARY_EXCHANGE(OrdinaryExchange);                        \
   __SmbPseOEAssertConsistentLinkage(a,__FILE__,__LINE__,              \
                                     OrdinaryExchange->RxContext,      \
                                     OrdinaryExchange,                 \
                                     &OrdinaryExchange->AssociatedStufferState,FLAGS);  \
   }
#else
#define SmbPseOEAssertConsistentLinkage(a) {NOTHING;}
#define SmbPseOEAssertConsistentLinkageFromOE(a) {NOTHING;}
#define SmbPseOEAssertConsistentLinkageFromOEwithFlags(a,b) {NOTHING;}
#endif

typedef
NTSTATUS
(*PSMB_PSE_OE_START_ROUTINE) (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

typedef
NTSTATUS
(*PSMB_PSE_FINISH_ROUTINE) (
    PSMB_PSE_ORDINARY_EXCHANGE
    );

#define SMBPSE_OE_HISTORY_SIZE 32
typedef struct _SMBPSE_HISTORY {
    ULONG Next;
    ULONG Submits;
    struct {
        ULONG Longs[2];
    } Markers[SMBPSE_OE_HISTORY_SIZE];
} SMBPSE_HISTORY;

#if DBG
VOID SmbPseUpdateOEHistory(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    ULONG Tag1,
    ULONG Tag2
    );
#define UPDATE_OE_HISTORY_LONG(a) {SmbPseUpdateOEHistory(OrdinaryExchange,a,0);}
#define UPDATE_OE_HISTORY_2SHORTS(a,b) {SmbPseUpdateOEHistory(OrdinaryExchange,a,b);}
#else
#define UPDATE_OE_HISTORY_LONG(a)
#define UPDATE_OE_HISTORY_2SHORTS(a,b)
#endif //if DBG


typedef enum _SMB_PSE_ORDINARY_EXCHANGE_TYPE {
    SMBPSE_OETYPE_LATENT_HEADEROPS,
    SMBPSE_OETYPE_CREATE,
    SMBPSE_OETYPE_COREOPEN,
//    SMBPSE_OETYPE_CLEANUP,
    SMBPSE_OETYPE_FINDCLOSE,
    SMBPSE_OETYPE_READ,
    SMBPSE_OETYPE_WRITE, SMBPSE_OETYPE_EXTEND_WRITE, SMBPSE_OETYPE_CORETRUNCATE,
    SMBPSE_OETYPE_LOCKS, SMBPSE_OETYPE_ASSERTBUFFEREDLOCKS,
    SMBPSE_OETYPE_FLUSH,
    SMBPSE_OETYPE_CLOSE, SMBPSE_OETYPE_CLOSEAFTERCORECREATE,
    //SMBPSE_OETYPE_SEARCH,
    SMBPSE_OETYPE_RENAME,
    SMBPSE_OETYPE_T2_FOR_NT_FILE_ALLOCATION_INFO,
    SMBPSE_OETYPE_T2_FOR_NT_DISKATTRIBUTES_INFO,
    SMBPSE_OETYPE_T2_FOR_LANMAN_DISKATTRIBUTES_INFO,
    SMBPSE_OETYPE_T2_FOR_LANMAN_VOLUMELABEL_INFO,
    SMBPSE_OETYPE_GFA,
//    SMBPSE_OETYPE_GFA2,
    SMBPSE_OETYPE_COREINFO,
    SMBPSE_OETYPE_CORECREATE,
    SMBPSE_OETYPE_DELETEFORSUPERSEDEORCLOSE,
    SMBPSE_OETYPE_CORECREATEDIRECTORY,
    SMBPSE_OETYPE_CORECHECKDIRECTORY,
    SMBPSE_OETYPE_SFA,
    SMBPSE_OETYPE_COREQUERYLABEL, SMBPSE_OETYPE_CORESEARCH, SMBPSE_OETYPE_CORESEARCHFORCHECKEMPTY,
    SMBPSE_OETYPE_COREQUERYDISKATTRIBUTES,
    SMBPSE_OETYPE_CREATEPRINTFILE,
    SMBPSE_OETYPE_MAXIMUM
} SMB_PSE_ORDINARY_EXCHANGE_TYPE;


typedef enum _SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS {
    SMBPSE_OE_FROM_QUERYDIRECTORY,
    SMBPSE_OE_FROM_QUERYFILEINFO,
    SMBPSE_OE_FROM_SETFILEINFO,
    SMBPSE_OE_FROM_QUERYVOLUMEINFO,
    SMBPSE_OE_FROM_EXTENDFILEFORCACHEING,
    SMBPSE_OE_FROM_LOCKS,
    SMBPSE_OE_FROM_FLUSH,
    SMBPSE_OE_FROM_ASSERTBUFFEREDLOCKS,
    SMBPSE_OE_FROM_CLEANUPFOBX,
    SMBPSE_OE_FROM_CLOSESRVCALL,
    SMBPSE_OE_FROM_CREATE,
    SMBPSE_OE_FROM_RENAME,
    SMBPSE_OE_FROM_READ,
    SMBPSE_OE_FROM_WRITE,
    SMBPSE_OE_FROM_FAKESETDELETEDISPOSITION,
    SMBPSE_OE_FROM_MAXIMUM
} SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS;

#define SMBPSE_DEFINE_OE_FLAG(a,c) RX_DEFINE_FLAG(SMBPSE_OE_FLAG_##a,c,0xffff)

typedef enum {
    SMBPSE_DEFINE_OE_FLAG(HEADER_ALREADY_PARSED, 0)
    SMBPSE_DEFINE_OE_FLAG(OE_ALREADY_RESUMED, 1)
    SMBPSE_DEFINE_OE_FLAG(VALIDATE_FID, 2)
    SMBPSE_DEFINE_OE_FLAG(OE_HDR_PARTIAL_INITIALIZED, 3)
    SMBPSE_DEFINE_OE_FLAG(OE_ALLOCATED_DATA_PARTIAL, 4)
    SMBPSE_DEFINE_OE_FLAG(OE_HDR_LOCKED, 5)
    SMBPSE_DEFINE_OE_FLAG(SMBBUF_IS_A_MDL, 6)
    SMBPSE_DEFINE_OE_FLAG(NO_RESPONSE_EXPECTED, 7)
    SMBPSE_DEFINE_OE_FLAG(MUST_SUCCEED_ALLOCATED_OE, 8)
    SMBPSE_DEFINE_OE_FLAG(MUST_SUCCEED_ALLOCATED_SMBBUF, 9)
    SMBPSE_DEFINE_OE_FLAG(OE_AWAITING_DISPATCH, 10)
    SMBPSE_DEFINE_OE_FLAG(TURNON_DFS_FLAG, 11)
    //SMBPSE_DEFINE_OE_FLAG(NETROOT_GOOD, 15)
} RX_CONTEXT_CREATE_FLAGS;

typedef enum _SMB_PSE_OE_INNERIO_STATE {
    SmbPseOEInnerIoStates_Initial = 0,
    SmbPseOEInnerIoStates_ReadyToSend,
    SmbPseOEInnerIoStates_OperationOutstanding
} SMB_PSE_OE_INNERIO_STATE;
typedef struct _SMB_PSE_OE_READWRITE {
    union {
    	PBYTE UserBufferBase;
    	PLOWIO_LOCK_LIST LockList;
    };
    ULONG RemainingByteCount;
    ULONG ThisByteCount;
    ULONG ThisBufferOffset;
    ULONG BytesReturned;
    //PMDL  DataPartialMdl;
    ULONG PartialBytes;
    ULONG MaximumSmbBufferSize;
    LARGE_INTEGER ByteOffsetAsLI;
} SMB_PSE_OE_READWRITE, *PSMB_PSE_OE_READWRITE;

#define OE_READ_FLAG_SUCCESS_IN_COPYHANDLER (0x01)
#define OE_READ_FLAG_REDUCE_RETURNCOUNT     (0x20) //used in pipewrites to track rawmode
#define OE_READ_FLAG_SUBSEQUENT_OPERATION   (0x40) //used in pipewrites to distinguish the first
#define OE_READ_FLAG_MSGMODE_PIPE_OPERATION (0x80) //MAX VALUE, it's just a byte.....

#define SMB_PSE_OE_HDR_MDL_PAGES (2 + (ADDRESS_AND_SIZE_TO_SPAN_PAGES( (ULONG) 0, MAXIMUM_SMB_BUFFER_SIZE )))

typedef struct _SMB_PSE_ORDINARY_EXCHANGE{
   union {
       SMB_EXCHANGE  Exchange;
       SMB_EXCHANGE;
   };
   SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType;
   SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint;
   ULONG SmbBufSize;
   ULONG StartEntryCount;
   PMDL  DataPartialMdl;
   USHORT Flags;
   UCHAR  OpSpecificFlags;
   UCHAR  OpSpecificState;
   ULONG  SendOptions;
   GENERIC_ANDX ParseResumeState;
   UCHAR LastSmbCommand;
   NTSTATUS NoCopyFinalStatus;
   ULONG MessageLength;
   PSMB_PSE_OE_START_ROUTINE Continuation;
   PSMB_PSE_OE_START_ROUTINE StartRoutine;
   PSMB_PSE_FINISH_ROUTINE FinishRoutine;
   //RX_WORK_QUEUE_ITEM WorkQueueItemForOE;
   BOOLEAN NeedToReinitializeStufferState;
   union {
       struct {
           SMBPSE_FILEINFO_BUNDLE FileInfo;
           PMRX_SMB_SRV_OPEN smbSrvOpen;
           BOOLEAN MustRegainExclusiveResource;
           BOOLEAN CreateWithEasSidsOrLongName;
           RX_BLOCK_CONDITION FinalCondition;
           ULONG FidReturnedFromCreate;
           ULONG FidReturnedFromOpen;
           ULONG FileSizeReturnedFromOpen;
           BOOLEAN FileWasCreated;
           BOOLEAN FileWasTruncated;
           //UNICODE_STRING PathNameForCoreOperation;
       } Create;
       SMB_PSE_OE_READWRITE ReadWrite;    //also used for locks
       struct {
           SMBPSE_FILEINFO_BUNDLE FileInfo;
           PMRX_SMB_SRV_OPEN smbSrvOpen;
    	   PVOID Buffer;
    	   PULONG pBufferLength;
           ULONG InfoClass;
           union {
               struct {
                   UCHAR CoreLabel[13];    //right from smb.h
               } QFSVolInfo;
               struct {
                   ULONG CountRemaining;
                   ULONG CountRemainingInSmbbuf;
                   PSMB_DIRECTORY_INFORMATION NextDirInfo;
                   //there should be a union here
                   PSMB_RESUME_KEY EmptyCheckResumeKey;
                   SMB_RESUME_KEY EmptyCheckResumeKeyBuffer;
               } CoreSearch;
           };
       } Info;
       struct {
           LARGE_INTEGER AllocationSize;
       } Transact2;
       struct {
           PUCHAR PtrToLockType;   //this must be here because the beginning of the
                                   //lockstart code sets the locklist to zero which will be this
           PMRX_SRV_OPEN SrvOpen;
           PRX_LOCK_ENUMERATOR LockEnumerator;
           PVOID ContinuationHandle;
           ULONG NumberOfLocksPlaced;
           LARGE_INTEGER NextLockOffset;
           LARGE_INTEGER NextLockRange;
           BOOLEAN NextLockIsExclusive;
           BOOLEAN LockAreaNonEmpty;
           BOOLEAN EndOfListReached;
       } AssertLocks;
   } ;
   PUNICODE_STRING   pPathArgument1;  // Unicode path
   PUNICODE_STRING   pPathArgument2;  // secondary unicode path
   PSMBSTUFFER_BUFFER_STATE StufferStateDbgPtr; //this is just for the debugger....get rid of it
   SMBSTUFFER_BUFFER_STATE AssociatedStufferState;
   struct {
       union {
           MDL;
           MDL Mdl;
       };
       ULONG Pages2[SMB_PSE_OE_HDR_MDL_PAGES];
   } HeaderMdl;
   struct {
       union {
           MDL;
           MDL Mdl;
       };
       ULONG Pages2[SMB_PSE_OE_HDR_MDL_PAGES];
   } HeaderPartialMdl;
   ULONG SerialNumber;
   SMBPSE_HISTORY History;
   PIRP RxContextCapturedRequestPacket;
   PMDL  SaveDataMdlForDebug;
   ULONG SaveLengthForDebug;
   PMDL  SaveIrpMdlForDebug;
} SMB_PSE_ORDINARY_EXCHANGE, *PSMB_PSE_ORDINARY_EXCHANGE;

#define SmbPseDiscardProtocol(__STATUS__) { \
    *pBytesTaken = BytesAvailable; \
    pExchange->Status = (__STATUS__); \
}

NTSTATUS
SmbPseOrdinaryExchange(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    IN SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType
    );

NTSTATUS
SmbPseResumeOrdinaryExchange(
    IN OUT PRX_CONTEXT RxContext
    );

#define ASSERT_ORDINARY_EXCHANGE(__p) ASSERT(NodeType(__p)==SMB_EXCHANGE_NTC(ORDINARY_EXCHANGE))


PSMB_PSE_ORDINARY_EXCHANGE
SmbPseCreateOrdinaryExchange (
    IN PRX_CONTEXT RxContext,
    IN PMRX_V_NET_ROOT VNetRoot,
    IN SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint,
    IN PSMB_PSE_OE_START_ROUTINE StartRoutine
    //IN PSMB_EXCHANGE_DISPATCH_VECTOR DispatchVector
    );

BOOLEAN
SmbPseFinalizeOrdinaryExchange (
    IN OUT PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange
    );

#define SmbPseInitiateOrdinaryExchange(OrdinaryExchange) (SmbCeInitiateExchange(&OrdinaryExchange->Exchange))

// this macro is used to do the async completion for read/write/locks. Note that the call to lowiocompletion
// will try to complete the irp thereby freeing the user's mdl. so, we better get rid of the partial first.
// we use this macro so that there will be only one version of this code. when we combine start routines,
// this will be un macroed
#define SmbPseAsyncCompletionIfNecessary(OE,RXCONTEXT) {                           \
    if (StartEntryCount>1) {                                                       \
    	BOOLEAN FinalizationComplete;                                              \
        if (FALSE) {DbgBreakPoint(); }                                             \
    	if ( (OE)->DataPartialMdl ) {                                              \
            if (FlagOn((OE)->Flags, SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_SMBBUF)){\
                MmPrepareMdlForReuse((OE)->DataPartialMdl);                        \
            } else {                                                               \
        	    IoFreeMdl((OE)->DataPartialMdl);                                   \
        	    (OE)->DataPartialMdl = NULL;                                       \
        	    ClearFlag((OE)->Flags,SMBPSE_OE_FLAG_OE_ALLOCATED_DATA_PARTIAL);   \
            }                                                                      \
    	}                                                                          \
    	(RXCONTEXT)->StoredStatus = Status;                                        \
    	RxLowIoCompletion((RXCONTEXT));                                            \
    	FinalizationComplete = SmbPseFinalizeOrdinaryExchange((OE));               \
    	ASSERT(!FinalizationComplete);                                             \
    }}


/* ------------------------------------------
   ------------------------------------------
   Receive Handler Stuff
   ------------------------------------------
   ------------------------------------------
*/

VOID
SmbPseInitializeTables(
    void
    );

typedef
NTSTATUS
(*PSMBPSE_RECEIVE_HANDLER) (
      PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
      PBYTE                        Response
    );


//boy, talk about a load of arguments
typedef
UCHAR
(*PSMBPSE_NOCOPY_RECEIVE_HANDLER) (
    IN OUT  PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    OUT ULONG       *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pDataBufferPointer,
    OUT PULONG      pDataSize,
#if DBG
    IN  UCHAR       ThisIsAReenter,
#endif
    IN  PBYTE       Response
    );
#define SMBPSE_NOCOPYACTION_NORMALFINISH  0x00
#define SMBPSE_NOCOPYACTION_MDLFINISH     0x01
#define SMBPSE_NOCOPYACTION_DISCARD 0x02
#define SMBPSE_NOCOPYACTION_COPY_FOR_RESUME 0x03


#define SMBPSE_RMP_MODELED        (0x00000001)
#define SMBPSE_RMP_THIS_IS_ANDX   (0x00000002)
#define SMBPSE_RMP_WARNINGS_OK    (0x00000004)
#define SMBPSE_RMP_NOCOPY_HANDLER (0x00000008)

typedef enum _SMBPSE_RECEIVE_HANDLER_TOKEN {
    SMBPSE_RECEIVE_HANDLER_TOKEN_READ_ANDX_HANDLER = 0,
    SMBPSE_RECEIVE_HANDLER_TOKEN_READ_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_WRITE_ANDX_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_WRITE_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_LOCKING_ANDX_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_OPEN_PRINTFILE_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_WRITE_PRINTFILE_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_CLOSE_HANDLER,  //also close_print_file
    SMBPSE_RECEIVE_HANDLER_TOKEN_NTCREATE_ANDX_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_OPEN_ANDX_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_CREATE_HANDLER,  //also create_new
    SMBPSE_RECEIVE_HANDLER_TOKEN_OPEN_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_TRANS2_ANDX_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_GFA_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_SEARCH_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_QUERYDISKINFO_HANDLER,
    SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM
} SMBPSE_RECEIVE_HANDLER_TOKEN;

PSMBPSE_RECEIVE_HANDLER SmbPseReceiveHandlers[SMBPSE_RECEIVE_HANDLER_TOKEN_MAXIMUM];
typedef struct _SMBPSE_RECEIVE_MODEL_PARAMETERS {
    UCHAR Flags;
    UCHAR ReceiveHandlerToken;
#if DBG
    USHORT Dummy;
    PSMBPSE_RECEIVE_HANDLER ReceiveHandler;
    PBYTE IndicationString;
    SMB_PSE_ORDINARY_EXCHANGE_TYPE LowType,HighType;
#endif
} SMBPSE_RECEIVE_MODEL_PARAMETERS, *PSMBPSE_RECEIVE_MODEL_PARAMETERS;

SMBPSE_RECEIVE_MODEL_PARAMETERS SmbPseReceiveModelParameters[256]; //there are 256 possible smbs


// Finishing routines - these are all cast into the correct procedure type
//                      so that the response will already have the correct SMB format
//                      on entry to the routine


NTSTATUS
MRxSmbFinishNTCreateAndX (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_NT_CREATE_ANDX        Response
      );
#define MRxSmbReceiveHandler_NTCreateAndX ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishNTCreateAndX)

NTSTATUS
MRxSmbFinishOpenAndX (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_OPEN_ANDX             Response
      );
#define MRxSmbReceiveHandler_OpenAndX ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishOpenAndX)

NTSTATUS
MRxSmbFinishClose (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_CLOSE                 Response
      );
//use the close finsh routine for closeprintfile as well
#define MRxSmbReceiveHandler_Close ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishClose)

NTSTATUS
MRxSmbFinishGFA (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_QUERY_INFORMATION     Response
      );
#define MRxSmbReceiveHandler_GetFileAttributes ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishGFA)

NTSTATUS
MRxSmbFinishTransaction2 (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_TRANSACTION           Response
      );
#define MRxSmbReceiveHandler_Transact2 ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishTransaction2)

NTSTATUS
MRxSmbFinishCoreOpen (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_OPEN                  Response
      );
#define MRxSmbReceiveHandler_CoreOpen ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishCoreOpen)

NTSTATUS
MRxSmbFinishCoreCreate (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_CREATE                Response
      );
#define MRxSmbReceiveHandler_CoreCreate ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishCoreCreate)


//NTSTATUS
//MRxSmbFinishRead (
//      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
//      IN     PRESP_READ_ANDX             Response
//      );
//#define MRxSmbReceiveHandler_ReadAndX ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishRead)

//NTSTATUS
//MRxSmbFinishCoreRead (
//      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
//      IN     PRESP_READ                  Response
//      );
//#define MRxSmbReceiveHandler_CoreRead ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishCoreRead)

UCHAR
MRxSmbReadHandler_NoCopy (
    IN OUT  PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    OUT ULONG       *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pDataBufferPointer,
    OUT PULONG      pDataSize,
#if DBG
    IN  UCHAR       ThisIsAReenter,
#endif
    IN  PRESP_READ_ANDX       Response
    );
#define MRxSmbReceiveHandler_Read_NoCopy ((PSMBPSE_RECEIVE_HANDLER)MRxSmbReadHandler_NoCopy)

NTSTATUS
MRxSmbFinishCreatePrintFile (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_OPEN_PRINT_FILE       Response
      );
#define MRxSmbReceiveHandler_OpenPrintFile ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishCreatePrintFile)
NTSTATUS
MRxSmbFinishWritePrintFile (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_WRITE_PRINT_FILE      Response
      );
#define MRxSmbReceiveHandler_WritePrintFile ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishWritePrintFile)

NTSTATUS
MRxSmbFinishWrite (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_WRITE_ANDX            Response
      );
#define MRxSmbReceiveHandler_WriteAndX ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishWrite)

NTSTATUS
MRxSmbFinishCoreWrite (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_WRITE                 Response
      );
#define MRxSmbReceiveHandler_CoreWrite ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishCoreWrite)

NTSTATUS
MRxSmbFinishLocks (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_LOCKING_ANDX          Response
      );
#define MRxSmbReceiveHandler_LockingAndX ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishLocks)


NTSTATUS
MRxSmbFinishSearch (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_SEARCH                Response
      );
#define MRxSmbReceiveHandler_Search ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishSearch)
NTSTATUS
MRxSmbFinishQueryDiskInfo (
      PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
      PRESP_QUERY_INFORMATION_DISK Response
      );
#define MRxSmbReceiveHandler_QueryDiskInfo ((PSMBPSE_RECEIVE_HANDLER)MRxSmbFinishQueryDiskInfo)

NTSTATUS
MRxSmbSimpleSyncTransact2(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    IN SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType,
    IN ULONG TransactSetupCode,
    IN PVOID Params,
    IN ULONG ParamsLength,
    IN PVOID Data,
    IN ULONG DataLength
    );


NTSTATUS
MRxSmbCoreTruncate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG Fid,
    ULONG FileTruncationPoint
    );
NTSTATUS
MRxSmbSetFileAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG SmbAttributes,
    ULONG LastWriteTime
    );

NTSTATUS
MRxSmbCoreInformation(
      IN OUT PRX_CONTEXT          RxContext,
      IN     ULONG                InformationClass,
      IN OUT PVOID                pBuffer,
      IN OUT PULONG               pBufferLength,
      IN     SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint
      );

ULONG
MRxSmbMapSmbAttributes (
    IN USHORT SmbAttribs
    );

USHORT
MRxSmbMapDisposition (
    IN ULONG Disposition
    );

USHORT
MRxSmbMapShareAccess (
    IN USHORT ShareAccess
    );

USHORT
MRxSmbMapDesiredAccess (
    IN ULONG DesiredAccess
    );

USHORT
MRxSmbMapFileAttributes (
    IN ULONG FileAttributes
    );

ULONG
MRxSmbUnmapDisposition (
    IN USHORT SmbDisposition
    );

LARGE_INTEGER
MRxSmbConvertSmbTimeToTime (
    //IN PSMB_EXCHANGE Exchange OPTIONAL,
    IN PSMBCE_SERVER Server OPTIONAL,
    IN SMB_TIME Time,
    IN SMB_DATE Date
    );


BOOLEAN
MRxSmbConvertTimeToSmbTime (
    IN PLARGE_INTEGER InputTime,
    IN PSMB_EXCHANGE Exchange OPTIONAL,
    OUT PSMB_TIME Time,
    OUT PSMB_DATE Date
    );


BOOLEAN
MRxSmbTimeToSecondsSince1970 (
    IN PLARGE_INTEGER CurrentTime,
    //IN PSMB_EXCHANGE Exchange OPTIONAL,
    IN PSMBCE_SERVER Server OPTIONAL,
    OUT PULONG SecondsSince1970
    );
#define MRxSmbExchangeToServer(EXCHANGE) (&((EXCHANGE)->SmbCeContext.pServerEntry->Server))

VOID
MRxSmbSecondsSince1970ToTime (
    IN ULONG SecondsSince1970,
    //IN PSMB_EXCHANGE Exchange OPTIONAL,
    IN PSMBCE_SERVER Server OPTIONAL,
    OUT PLARGE_INTEGER CurrentTime
    );

#endif // _SMBPSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\smbutils.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    smbutils.c

Abstract:

    This module implements the routines that aid in the assembly/disassembly of SMB's


--*/

#include "precomp.h"
#pragma hdrstop

#define BASE_DOS_ERROR  ((NTSTATUS )0xC0010000L)

#include "lmerr.h"
#include "nb30.h"


NTSTATUS
SmbPutString(
         PBYTE   *pBufferPointer,
         PSTRING pString,
         PULONG  pSize)
{
   NTSTATUS Status;
   PBYTE    pBuffer = *pBufferPointer;

   if (*pSize > pString->Length) {
      RtlCopyMemory(
               pBuffer,
               pString->Buffer,
               pString->Length);

      *pSize -= pString->Length;
      *pBufferPointer = pBuffer + pString->Length;
      Status = STATUS_SUCCESS;
   } else {
      Status = STATUS_BUFFER_OVERFLOW;
   }

   return Status;
}

NTSTATUS
SmbPutUnicodeString(
         PBYTE           *pBufferPointer,
         PUNICODE_STRING pUnicodeString,
         PULONG          pSize)
{
   NTSTATUS Status;
   PBYTE    pBuffer = *pBufferPointer;

   if (*pSize >= (pUnicodeString->Length + sizeof(WCHAR))) {
      RtlCopyMemory(
               pBuffer,
               pUnicodeString->Buffer,
               pUnicodeString->Length);

      *((PWCHAR)(pBuffer + pUnicodeString->Length)) = L'\0';
      *pSize -= (pUnicodeString->Length + sizeof(WCHAR));
      *pBufferPointer = pBuffer + (pUnicodeString->Length + sizeof(WCHAR));
      Status = STATUS_SUCCESS;
   } else {
      Status = STATUS_BUFFER_OVERFLOW;
   }

   return Status;
}

NTSTATUS
SmbPutUnicodeStringAndUpcase(
         PBYTE           *pBufferPointer,
         PUNICODE_STRING pUnicodeString,
         PULONG          pSize)
{
   NTSTATUS Status;
   PBYTE    pBuffer = *pBufferPointer;

   if (*pSize >= (pUnicodeString->Length + sizeof(WCHAR))) {
      UNICODE_STRING BufferAsUnicode;
      BufferAsUnicode.Buffer = (PWCHAR)pBuffer;
      BufferAsUnicode.Length = pUnicodeString->Length;
      BufferAsUnicode.MaximumLength = BufferAsUnicode.Length;

      RtlUpcaseUnicodeString(&BufferAsUnicode,pUnicodeString,FALSE);

      *((PWCHAR)(pBuffer + pUnicodeString->Length)) = L'\0';
      *pSize -= (pUnicodeString->Length + sizeof(WCHAR));
      *pBufferPointer = pBuffer + (pUnicodeString->Length + sizeof(WCHAR));
      Status = STATUS_SUCCESS;
   } else {
      Status = STATUS_BUFFER_OVERFLOW;
   }

   return Status;
}

NTSTATUS
SmbPutUnicodeStringAsOemString(
         PBYTE           *pBufferPointer,
         PUNICODE_STRING pUnicodeString,
         PULONG          pSize)
{
   NTSTATUS   Status;
   OEM_STRING OemString;
   PBYTE      pBuffer = *pBufferPointer;

   OemString.MaximumLength = (USHORT)*pSize;
   OemString.Buffer        = pBuffer;

   // The Rtl routine pads the converted string with a NULL.
   Status = RtlUnicodeStringToOemString(
                        &OemString,             // destination string
                        pUnicodeString,         // source string
                        FALSE);                 // No memory allocation for destination
   if (NT_SUCCESS(Status)) {
      if (OemString.Length < *pSize) {
         // put the null
         pBuffer += (OemString.Length + 1);
         *pBufferPointer = pBuffer;
         *pSize -= (OemString.Length + 1); // the NULL is not included in the length by the RTL routine.
      } else {
         Status = STATUS_BUFFER_OVERFLOW;
      }
   }

   return Status;
}

NTSTATUS
SmbPutUnicodeStringAsOemStringAndUpcase(
         PBYTE           *pBufferPointer,
         PUNICODE_STRING pUnicodeString,
         PULONG          pSize)
{
   NTSTATUS   Status;
   OEM_STRING OemString;
   PBYTE      pBuffer = *pBufferPointer;

   OemString.MaximumLength = (USHORT)*pSize;
   OemString.Buffer        = pBuffer;

   // The Rtl routine pads the converted string with a NULL.
   Status = RtlUpcaseUnicodeStringToOemString(
                        &OemString,             // destination string
                        pUnicodeString,         // source string
                        FALSE);                 // No memory allocation for destination
   if (NT_SUCCESS(Status)) {
      if (OemString.Length < *pSize) {
         // put the null
         pBuffer += (OemString.Length + 1);
         *pBufferPointer = pBuffer;
         *pSize -= (OemString.Length + 1); // the NULL is not included in the length by the RTL routine.
      } else {
         Status = STATUS_BUFFER_OVERFLOW;
      }
   }

   return Status;
}

//
// The maps for mapping various error codes into NTSTATUSs
//

typedef struct _STATUS_MAP {
    USHORT ErrorCode;
    NTSTATUS ResultingStatus;
} STATUS_MAP, *PSTATUS_MAP;

STATUS_MAP
SmbErrorMap[] = {
    { SMB_ERR_BAD_PASSWORD, STATUS_WRONG_PASSWORD },
    { SMB_ERR_ACCESS, STATUS_NETWORK_ACCESS_DENIED },
    { SMB_ERR_BAD_TID, STATUS_NETWORK_NAME_DELETED },
    { SMB_ERR_BAD_NET_NAME, STATUS_BAD_NETWORK_NAME }, // Invalid network name
    { SMB_ERR_BAD_DEVICE, STATUS_BAD_DEVICE_TYPE }, // Invalid device request
    { SMB_ERR_QUEUE_FULL, STATUS_PRINT_QUEUE_FULL }, // Print queue full
    { SMB_ERR_QUEUE_TOO_BIG, STATUS_NO_SPOOL_SPACE }, // No space on print dev
    { SMB_ERR_BAD_PRINT_FID, STATUS_PRINT_CANCELLED }, // Invalid printfile FID
    { SMB_ERR_SERVER_PAUSED, STATUS_SHARING_PAUSED }, // Server is paused
    { SMB_ERR_MESSAGE_OFF, STATUS_REQUEST_NOT_ACCEPTED }, // Server not receiving msgs
    { SMB_ERR_BAD_TYPE, STATUS_BAD_DEVICE_TYPE },           // Reserved
    { SMB_ERR_BAD_SMB_COMMAND, STATUS_NOT_IMPLEMENTED }, // SMB command not recognized
    { SMB_ERR_BAD_PERMITS, STATUS_NETWORK_ACCESS_DENIED }, // Access permissions invalid
    { SMB_ERR_NO_ROOM, STATUS_DISK_FULL }, // No room for buffer message
    { SMB_ERR_NO_RESOURCE, STATUS_REQUEST_NOT_ACCEPTED }, // No resources available for request
    { SMB_ERR_TOO_MANY_UIDS, STATUS_TOO_MANY_SESSIONS }, // Too many UIDs active in session
    { SMB_ERR_BAD_UID, STATUS_USER_SESSION_DELETED }, // UID not known as a valid UID
    { SMB_ERR_USE_MPX, STATUS_SMB_USE_MPX }, // Can't support Raw; use MPX
    { SMB_ERR_USE_STANDARD, STATUS_SMB_USE_STANDARD }, // Can't support Raw, use standard r/w
    { SMB_ERR_INVALID_NAME, STATUS_OBJECT_NAME_INVALID },
    { SMB_ERR_INVALID_NAME_RANGE, STATUS_OBJECT_NAME_INVALID },
    { SMB_ERR_NO_SUPPORT,STATUS_NOT_SUPPORTED }, // Function not supported
    { NERR_PasswordExpired, STATUS_PASSWORD_EXPIRED },
    { NERR_AccountExpired, STATUS_ACCOUNT_DISABLED },
    { NERR_InvalidLogonHours, STATUS_INVALID_LOGON_HOURS },
    { NERR_InvalidWorkstation, STATUS_INVALID_WORKSTATION },
    { NERR_DuplicateShare, STATUS_LOGON_FAILURE }


};

ULONG
SmbErrorMapLength = sizeof(SmbErrorMap) / sizeof(SmbErrorMap[0]);

STATUS_MAP
Os2ErrorMap[] = {
    { ERROR_INVALID_FUNCTION,   STATUS_NOT_IMPLEMENTED },
    { ERROR_FILE_NOT_FOUND,     STATUS_NO_SUCH_FILE },
    { ERROR_PATH_NOT_FOUND,     STATUS_OBJECT_PATH_NOT_FOUND },
    { ERROR_TOO_MANY_OPEN_FILES,STATUS_TOO_MANY_OPENED_FILES },
    { ERROR_ACCESS_DENIED,      STATUS_ACCESS_DENIED },
    { ERROR_INVALID_HANDLE,     STATUS_INVALID_HANDLE },
    { ERROR_NOT_ENOUGH_MEMORY,  STATUS_INSUFFICIENT_RESOURCES },
    { ERROR_INVALID_ACCESS,     STATUS_ACCESS_DENIED },
    { ERROR_INVALID_DATA,       STATUS_DATA_ERROR },

    { ERROR_CURRENT_DIRECTORY,  STATUS_DIRECTORY_NOT_EMPTY },
    { ERROR_NOT_SAME_DEVICE,    STATUS_NOT_SAME_DEVICE },
    { ERROR_NO_MORE_FILES,      STATUS_NO_MORE_FILES },
    { ERROR_WRITE_PROTECT,      STATUS_MEDIA_WRITE_PROTECTED},
    { ERROR_NOT_READY,          STATUS_DEVICE_NOT_READY },
    { ERROR_CRC,                STATUS_CRC_ERROR },
    { ERROR_BAD_LENGTH,         STATUS_DATA_ERROR },
    { ERROR_NOT_DOS_DISK,       STATUS_DISK_CORRUPT_ERROR }, //***
    { ERROR_SECTOR_NOT_FOUND,   STATUS_NONEXISTENT_SECTOR },
    { ERROR_OUT_OF_PAPER,       STATUS_DEVICE_PAPER_EMPTY},
    { ERROR_SHARING_VIOLATION,  STATUS_SHARING_VIOLATION },
    { ERROR_LOCK_VIOLATION,     STATUS_FILE_LOCK_CONFLICT },
    { ERROR_WRONG_DISK,         STATUS_WRONG_VOLUME },
    { ERROR_NOT_SUPPORTED,      STATUS_NOT_SUPPORTED },
    { ERROR_REM_NOT_LIST,       STATUS_REMOTE_NOT_LISTENING },
    { ERROR_DUP_NAME,           STATUS_DUPLICATE_NAME },
    { ERROR_BAD_NETPATH,        STATUS_BAD_NETWORK_PATH },
    { ERROR_NETWORK_BUSY,       STATUS_NETWORK_BUSY },
    { ERROR_DEV_NOT_EXIST,      STATUS_DEVICE_DOES_NOT_EXIST },
    { ERROR_TOO_MANY_CMDS,      STATUS_TOO_MANY_COMMANDS },
    { ERROR_ADAP_HDW_ERR,       STATUS_ADAPTER_HARDWARE_ERROR },
    { ERROR_BAD_NET_RESP,       STATUS_INVALID_NETWORK_RESPONSE },
    { ERROR_UNEXP_NET_ERR,      STATUS_UNEXPECTED_NETWORK_ERROR },
    { ERROR_BAD_REM_ADAP,       STATUS_BAD_REMOTE_ADAPTER },
    { ERROR_PRINTQ_FULL,        STATUS_PRINT_QUEUE_FULL },
    { ERROR_NO_SPOOL_SPACE,     STATUS_NO_SPOOL_SPACE },
    { ERROR_PRINT_CANCELLED,    STATUS_PRINT_CANCELLED },
    { ERROR_NETNAME_DELETED,    STATUS_NETWORK_NAME_DELETED },
    { ERROR_NETWORK_ACCESS_DENIED, STATUS_NETWORK_ACCESS_DENIED },
    { ERROR_BAD_DEV_TYPE,       STATUS_BAD_DEVICE_TYPE },
    { ERROR_BAD_NET_NAME,       STATUS_BAD_NETWORK_NAME },
    { ERROR_TOO_MANY_NAMES,     STATUS_TOO_MANY_NAMES },
    { ERROR_TOO_MANY_SESS,      STATUS_TOO_MANY_SESSIONS },
    { ERROR_SHARING_PAUSED,     STATUS_SHARING_PAUSED },
    { ERROR_REQ_NOT_ACCEP,      STATUS_REQUEST_NOT_ACCEPTED },
    { ERROR_REDIR_PAUSED,       STATUS_REDIRECTOR_PAUSED },

    { ERROR_FILE_EXISTS,        STATUS_OBJECT_NAME_COLLISION },
    { ERROR_INVALID_PASSWORD,   STATUS_WRONG_PASSWORD },
    { ERROR_INVALID_PARAMETER,  STATUS_INVALID_PARAMETER },
    { ERROR_NET_WRITE_FAULT,    STATUS_NET_WRITE_FAULT },

    { ERROR_BROKEN_PIPE,        STATUS_PIPE_BROKEN },

    { ERROR_OPEN_FAILED,        STATUS_OPEN_FAILED },
    { ERROR_BUFFER_OVERFLOW,    STATUS_BUFFER_OVERFLOW },
    { ERROR_DISK_FULL,          STATUS_DISK_FULL },
    { ERROR_SEM_TIMEOUT,        STATUS_IO_TIMEOUT },
    { ERROR_INSUFFICIENT_BUFFER,STATUS_BUFFER_TOO_SMALL },
    { ERROR_INVALID_NAME,       STATUS_OBJECT_NAME_INVALID },
    { ERROR_INVALID_LEVEL,      STATUS_INVALID_LEVEL },
    { ERROR_BAD_PATHNAME,       STATUS_OBJECT_PATH_INVALID },   //*
    { ERROR_BAD_PIPE,           STATUS_INVALID_PARAMETER },
    { ERROR_PIPE_BUSY,          STATUS_PIPE_NOT_AVAILABLE },
    { ERROR_NO_DATA,            STATUS_PIPE_EMPTY },
    { ERROR_PIPE_NOT_CONNECTED, STATUS_PIPE_DISCONNECTED },
    { ERROR_MORE_DATA,          STATUS_BUFFER_OVERFLOW },
    { ERROR_VC_DISCONNECTED,    STATUS_VIRTUAL_CIRCUIT_CLOSED },
    { ERROR_INVALID_EA_NAME,    STATUS_INVALID_EA_NAME },
    { ERROR_EA_LIST_INCONSISTENT,STATUS_EA_LIST_INCONSISTENT },
    { ERROR_EAS_DIDNT_FIT,      STATUS_EA_TOO_LARGE },
    { ERROR_EA_FILE_CORRUPT,    STATUS_EA_CORRUPT_ERROR },
    { ERROR_EA_TABLE_FULL,      STATUS_EA_CORRUPT_ERROR },
    { ERROR_INVALID_EA_HANDLE,  STATUS_EA_CORRUPT_ERROR }

};

ULONG
Os2ErrorMapLength = sizeof(Os2ErrorMap) / sizeof(Os2ErrorMap[0]);


NTSTATUS
GetSmbResponseNtStatus(PSMB_HEADER pSmbHeader)
{
    NTSTATUS Status;
    USHORT Error;
    USHORT i;

    ASSERT( pSmbHeader != NULL );

    //  If this SMB contains an NT status for the operation, return
    //  that, otherwise map the resulting error.
    if (SmbGetUshort(&pSmbHeader->Flags2) & SMB_FLAGS2_NT_STATUS) {

        Status = SmbGetUlong( & ((PNT_SMB_HEADER)pSmbHeader)->Status.NtStatus );

        if ((Status == STATUS_SUCCESS) || NT_ERROR(Status) || NT_WARNING(Status)) {
           return Status;
        }
        // else fall through and treat it as an SMB error ..
        // This needs to be done because in certain cases NT servers return SMB
        // specific error codes eventhough the NTSTATUS flag is set
    }

    if (pSmbHeader->ErrorClass == SMB_ERR_SUCCESS) {
        return STATUS_SUCCESS;
    }

    Error = SmbGetUshort(&pSmbHeader->Error);
    if (Error == SMB_ERR_SUCCESS) {
        // Umm, non success ErrorClass but success Error code.
        Status = STATUS_UNEXPECTED_NETWORK_ERROR;
    } else {
        // Map the error code depending on Error Class
        switch (pSmbHeader->ErrorClass) {
        case SMB_ERR_CLASS_DOS:
        case SMB_ERR_CLASS_HARDWARE:
            Status = BASE_DOS_ERROR + Error;
            for (i = 0; i < Os2ErrorMapLength; i++) {
                if (Os2ErrorMap[i].ErrorCode == Error) {
                    Status = Os2ErrorMap[i].ResultingStatus;
                    break;
                }
            }
            break;

        case SMB_ERR_CLASS_SERVER:
            Status = STATUS_UNEXPECTED_NETWORK_ERROR;
            for (i = 0; i < SmbErrorMapLength; i++) {
                if (SmbErrorMap[i].ErrorCode == Error) {
                    Status = SmbErrorMap[i].ResultingStatus;
                    break;
                }
            }
            break;

        default:
            Status = STATUS_UNEXPECTED_NETWORK_ERROR;
            break;
        }
    }

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\smbxchng.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    smbcxchng.h

Abstract:

    This is the include file that defines all constants and types for
    SMB exchange implementation.

Notes:

    An exchange is the core abstarction on which the SMB connection engine and the mini RDR
    are implemented. It encapsulates the notion of sending an SMB to the server and receiving
    the associated response, i.e, exchanging an SMB and hence the name.

    The exchange of an SMB with the server involves the following steps ....

         1) Submitting the formatted SMB buffer for transmission.
         2) Processing a send complete indication which ensures that at the transport level
         the SMB has been sent to the server.
         3) Processing the receive indication which contains all/part of the response sent by
         the server.
         4) Copying additional data not indicated by the transport

    There are a number of variations on this theme. For example there are certain SMB's for
    which no response is expected, e.g., write mailslots and there are certain SMB's which are
    inherently multi part in nature, TRANSACT smb's.

    In addition the steps outlined above will not always happen in that order. The precise
    sequence of events is dictated by the underlying transport chosen and the network conditions.
    It is this dependency that makes the implementation of exchanges challenging.

    The two primary goals that the current implementation was designed for are (1) performance and
    (2) encapsulation of transport dependencies. Goal(1) is important because this constitutes
    an integral part of the code path for exchanging any packet with the server. Goal (2) is
    important to ensure customization of the Rdr for different transports. This encapsulation
    provides a convenient vehicle for isolating SMB protocol level decisions from transport
    level decisons as much as possible.

    In addition the following goals were used to guide the implementation process ...

         1) The exchange implementation must be able to handle asynchronous operations and
         synchronous operations well. The trade offs were made in favour of asynchronous
         operations as and when required.

         2) Sufficient infrastructure support must be provided so as to ease the implementation
         of different flavours of exchanges.

    The SMB_EXCHANGE consists of a dispatch vector with the following functions

         1) Start                 -- to initiate the exchange
         2) Receive               -- to handle response indications from the server
         3) CopyDataHandler       -- to handle portions of the response not indicated
         4) SendCompletionHandler -- to handle send complete indications from the transport.
         5) QuiescentStateHandler -- to handle transitions to a quiescent state, i.e., no
                                     SMB connection engine operations are outstanding.
         Most kinds of exchange use the QuiescentStateHandler to finalize the operation and discard
         the exchange. However, certain kinds of exchanges which implement the notion of a macro
         exchange, i.e., exchange multiple SMB's use this to delineate different phases of the
         multiple exchange, e.g., ORDINARY_EXCHANGE which implements most file io operations.

    In addition to the dispatch vector the vanilla exchange consists of state information to
    record the current state of the exchange, sufficient context for resumption and context for
    handling SMB protocol related operations. The SMB protocol requires that each SMB sent to
    the server be stamped with a MID ( multiplex id. ) in order to distinguish between
    concurrent SMB exchanges. The connection engine provides this service.

    The exchange also encapsulates a SMBCE_EXCHANGE_CONTEXT instance which encapsulates all the
    information required for building a SMB_HEADER.

--*/

#ifndef _SMBXCHNG_H_
#define _SMBXCHNG_H_

#include <rxcontx.h>  // the RX context
#include <mrxglbl.h>   // RDBSS data structures specialized by IFSMRX

typedef enum _SMBCE_STATE_ {
    SMBCE_START_IN_PROGRESS,
    SMBCE_STARTED,
    SMBCE_STOP_IN_PROGRESS,
    SMBCE_STOPPED
} SMBCE_STATE, *PSMBCE_STATE;

typedef struct _SMBCE_STARTSTOP_CONTEXT_ {
    SMBCE_STATE  State;
    LONG         ActiveExchanges;
    KEVENT       StopEvent;
} SMBCE_STARTSTOP_CONTEXT, *PSMBCE_STARTSTOP_CONTEXT;

extern SMBCE_STARTSTOP_CONTEXT SmbCeStartStopContext;

//
// This is the pid that will be used by the rdr; rdr1 used 0xcafe.
// only this pid is ever sent except for nt<-->nt creates. in these cases,
// we have to send the full 32bit process id for RPC. actually, we only have to do
// for pipes but we do it all the time instead.
//

#define MRXSMB_PROCESS_ID (0xfeff)

#define MRxSmbSetFullProcessId(RxContext,NtSmbHeader) {\
            ULONG Pid = RxGetRequestorProcessId(RxContext);           \
            SmbPutUshort(&NtSmbHeader->Pid, (USHORT)(Pid & 0xFFFF));  \
            SmbPutUshort(&NtSmbHeader->PidHigh, (USHORT)(Pid >> 16)); \
        }

//
// SMB_PROTOCOL_EXCHANGE dispatch vector function prototypes ..
//

// the initiator or the start routine
typedef
NTSTATUS
(*PSMB_EXCHANGE_START)(
    IN struct _SMB_EXCHANGE *pExchange);

// The SMB receive handler
typedef
NTSTATUS
(*PSMB_EXCHANGE_IND_RECEIVE)(
    IN struct       _SMB_EXCHANGE *pExchange, // The exchange instance
    IN ULONG        BytesIndicated,
    IN ULONG        BytesAvailable,
    OUT ULONG       *BytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pDataBufferPointer,      // buffer to copy unindicated data
    OUT PULONG      pDataSize                 // buffer size
    );

// the SMB xmit callback
typedef
NTSTATUS
(*PSMB_EXCHANGE_IND_SEND_CALLBACK)(
    IN struct _SMB_EXCHANGE 	*pExchange,    // The exchange instance
    IN PMDL                   pDataBuffer,
    IN NTSTATUS               SendCompletionStatus
    );

// the copy data callback for fetching large data
typedef
NTSTATUS
(*PSMB_EXCHANGE_IND_COPY_DATA_CALLBACK)(
    IN struct _SMB_EXCHANGE     *pExchange,      // the exchange instance
    IN PMDL                    pCopyDataBuffer, // the buffer
    IN ULONG                   CopyDataSize     // amount of data copied
    );

// the finalization routine
// This particular routine has a signature that is NT specific the IRQL
// parameter that is passed in and the notion of posting. This helps consolidate
// the NT transport driver model of indications at DPC level in SmbCeFinalizeExchange.
// On WIN95 the lease restrictive value of IRQL can be passed in.

typedef
NTSTATUS
(*PSMB_EXCHANGE_FINALIZE)(
   IN OUT struct _SMB_EXCHANGE *pExchange,
   OUT    BOOLEAN              *pPostRequest);

// The Exchange dispatch vector definition

typedef struct _SMB_EXCHANGE_DISPATCH_VECTOR_ {
    PSMB_EXCHANGE_START                   Start;
    PSMB_EXCHANGE_IND_RECEIVE             Receive;
    PSMB_EXCHANGE_IND_COPY_DATA_CALLBACK  CopyDataHandler;
    PSMB_EXCHANGE_IND_SEND_CALLBACK       SendCompletionHandler;
    PSMB_EXCHANGE_FINALIZE                Finalize;
} SMB_EXCHANGE_DISPATCH_VECTOR, *PSMB_EXCHANGE_DISPATCH_VECTOR;

// An enumerated type listing the type of exchanges

typedef enum _SMB_EXCHANGE_TYPE_ {
    CONSTRUCT_NETROOT_EXCHANGE,
    ORDINARY_EXCHANGE,
//    TRANSACT_EXCHANGE,
    KERBEROS_SESSION_SETUP_EXCHANGE,
    ADMIN_EXCHANGE,
    SENTINEL_EXCHANGE
} SMB_EXCHANGE_TYPE, *PSMB_EXCHANGE_TYPE;

// known exchange type dispatch vectors

extern SMB_EXCHANGE_DISPATCH_VECTOR ConstructNetRootExchangeDispatch;
extern SMB_EXCHANGE_DISPATCH_VECTOR OrdinaryExchangeDispatch;
extern SMB_EXCHANGE_DISPATCH_VECTOR TransactExchangeDispatch;

// The various states of the exchange. Each exchange transitions from
// the SMBCE_EXCHANGE_INITIALIZATION_START to SMBCE_EXCHANGE_INITIATED  or
// SMBCE_EXCHANGE_ABORTED state.

typedef enum _SMBCE_EXCHANGE_STATE_ {
    SMBCE_EXCHANGE_INITIALIZATION_START,
    SMBCE_EXCHANGE_SERVER_INITIALIZED,
    SMBCE_EXCHANGE_SESSION_INITIALIZED,
    SMBCE_EXCHANGE_NETROOT_INITIALIZED,
    SMBCE_EXCHANGE_INITIATED,
    SMBCE_EXCHANGE_ABORTED
} SMBCE_EXCHANGE_STATE, *PSMBCE_EXCHANGE_STATE;

// The exchange encapsulates the transport information from the clients. The
// Exchange engine is sandwiched between the protocol selection engine in the
// mini redirector on one side and the various transports on the other side.
// The transport information encapsulates the various categories of transport
// the exchange engine understands.

typedef struct SMBCE_EXCHANGE_TRANSPORT_INFORMATION {
    union {
        struct {
            struct SMBCE_VC_ENTRY *pVcEntry;
        } Vcs;
        struct {
             ULONG Dummy;
        } Datagrams;
        struct {
             ULONG Dummy;
        } Hybrid;
     };
} SMBCE_EXCHANGE_TRANSPORT_CONTEXT,
  *PSMBCE_EXCHANGE_TRANSPORT_CONTEXT;

typedef struct _SMBCE_EXCHANGE_CONTEXT_ {
    PMRX_V_NET_ROOT                      pVNetRoot;
    struct _SMBCEDB_SERVER_ENTRY         *pServerEntry;
    struct _SMBCEDB_SESSION_ENTRY        *pSessionEntry;
    struct _SMBCEDB_NET_ROOT_ENTRY       *pNetRootEntry;
    SMBCE_EXCHANGE_TRANSPORT_CONTEXT     TransportContext;
} SMBCE_EXCHANGE_CONTEXT,*PSMBCE_EXCHANGE_CONTEXT;

//
// Similar to the subclassing of SMB net roots the SMB_EXCHANGE will be subclassed
// further to deal with various types of SMB exchanges. SMB exchanges can be roughly
// classified into the following types based on the interactions involved ...
//
// The SMB's that need to be exchanged need to be augmented with some admin SMB's which
// are required for the maintenance of SMB's in the connection engine.

#define SMBCE_EXCHANGE_MID_VALID                   (0x1)
#define SMBCE_EXCHANGE_REUSE_MID                   (0x2)
#define SMBCE_EXCHANGE_RETAIN_MID                  (SMBCE_EXCHANGE_REUSE_MID)
#define SMBCE_EXCHANGE_MULTIPLE_SENDS_POSSIBLE     (0x4)
#define SMBCE_EXCHANGE_FINALIZED                   (0x8)

#define SMBCE_EXCHANGE_ATTEMPT_RECONNECTS           (0x10)
#define SMBCE_EXCHANGE_INDEFINITE_DELAY_IN_RESPONSE (0x20)

#define SMBCE_EXCHANGE_SESSION_CONSTRUCTOR         (0x100)
#define SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR         (0x200)
#define SMBCE_EXCHANGE_TRANSPORT_INITIALIZED       (0x400)

#define SMBCE_EXCHANGE_NOT_FROM_POOL               (0x800)

#define SMBCE_EXCHANGE_FLAGS_TO_PRESERVE           (SMBCE_EXCHANGE_NOT_FROM_POOL)

#define SMBCE_OPLOCK_RESPONSE_MID   (0xffff)

// The Exchange definition

typedef struct _SMB_EXCHANGE {
    union {
        UCHAR                     Type;
        struct {
            NODE_TYPE_CODE        NodeTypeCode;     // node type.
            NODE_BYTE_SIZE        NodeByteSize;     // node size.
            LONG                  ReferenceCount;
        };
    };
    PRX_CONTEXT                   RxContext;            //use of these two fields is advisory
    PVOID                         LastExecutingThread;  //     OE and Xact will use them
    NTSTATUS                      SmbStatus;
    UCHAR                         SmbCeState;
    USHORT                        SmbCeFlags;
    SMB_MPX_ID                    Mid;
    ULONG                         ServerVersion;
    SMB_EXCHANGE_ID               Id;
    LONG                          SendCompletePendingOperations;
    LONG                          CopyDataPendingOperations;
    LONG                          ReceivePendingOperations;
    LONG                          LocalPendingOperations;
    PKEVENT                       pSmbCeSynchronizationEvent;
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector;
    SMBCE_EXCHANGE_CONTEXT        SmbCeContext;
    NTSTATUS                      Status;
    RX_WORK_QUEUE_ITEM            WorkQueueItem;
} SMB_EXCHANGE, *PSMB_EXCHANGE;

extern ULONG SmbCeTraceExchangeReferenceCount;

// The following functions ( inline, macros and otherwise ) are defined
// to manipulate the exchanges

// The reset exchange macro provides a mechanism for forcing the exchange
// instance to a well known start state. This is used by the protocol
// selection engine to transceive different SMB's. A note of caution --
// ensure that the conditions are O.K for initialization. There is no well
// known mechanism in the exchange engine to prevent overwriting an
// exchange instance while in use.

#define SmbCeResetExchange(pExchange)                                   \
        (pExchange)->SmbCeFlags &= ~SMBCE_EXCHANGE_FINALIZED;           \
        (pExchange)->ReceivePendingOperations = 0;                      \
        (pExchange)->CopyDataPendingOperations = 0;                     \
        (pExchange)->SendCompletePendingOperations = 0;                 \
        (pExchange)->LocalPendingOperations = 0;                        \
        (pExchange)->SmbStatus = STATUS_SUCCESS

// The following macros provide a mechanism for referencing and dereferencing
// the exchange. The reference count provides a mechanism for detecting
// when an exchange instance can be safely discarded. The reference count
// differs from the pending operations count maintained in the exchange
// which are used to detect when a quiescent state is reached.

#define SmbCeReferenceExchange(pExchange)                               \
        InterlockedIncrement(&(pExchange)->ReferenceCount);             \
        if (SmbCeTraceExchangeReferenceCount) {                         \
           DbgPrint("Reference Exchange %lx Type(%ld) %s %ld %ld\n",    \
                     (pExchange),                                       \
                     (pExchange)->Type,                                 \
                      __FILE__,                                         \
                      __LINE__,                                         \
                      (pExchange)->ReferenceCount);                     \
        }

#define SmbCeDereferenceExchange(pExchange)                             \
        InterlockedDecrement(&(pExchange)->ReferenceCount);             \
        if (SmbCeTraceExchangeReferenceCount) {                         \
           DbgPrint("Dereference Exchange %lx Type(%ld) %s %ld %ld\n",  \
                     (pExchange),                                       \
                     (pExchange)->Type,                                 \
                     __FILE__,                                          \
                     __LINE__,                                          \
                     (pExchange)->ReferenceCount);                      \
        }


#define SmbCeDereferenceAndDiscardExchange(pExchange)                    \
        if (InterlockedDecrement(&(pExchange)->ReferenceCount) == 0) {   \
            SmbCeDiscardExchange(pExchange);                             \
        }                                                                \
        if (SmbCeTraceExchangeReferenceCount) {                          \
            DbgPrint("Dereference Exchange %lx Type(%ld) %s %ld %ld\n",  \
                 (pExchange),                                            \
                 (pExchange)->Type,                                      \
                 __FILE__,                                               \
                 __LINE__,                                               \
                 (pExchange)->ReferenceCount);                           \
        }

// Macros to hide the syntactic details of dereferencing and calling a
// routine in a dispatch vector. These macros are purely intended for
// use in the connection engine only and is not meant for use by
// other modules.

#define SMB_EXCHANGE_DISPATCH(pExchange,Routine,Arguments)        \
      (*((pExchange)->pDispatchVector->Routine))##Arguments

#define SMB_EXCHANGE_POST(pExchange,Routine)                          \
         RxPostToWorkerThread(&(pExchange)->WorkItem.WorkQueueItem,   \
                              (pExchange)->pDispatchVector->Routine,  \
                              (pExchange))

// The following enum type defines the result of invoking the finalization routine
// on an exchange instance.

typedef enum _SMBCE_EXCHANGE_STATUS_ {
    SmbCeExchangeAlreadyFinalized,
    SmbCeExchangeFinalized,
    SmbCeExchangeNotFinalized
} SMBCE_EXCHANGE_STATUS, *PSMBCE_EXCHANGE_STATUS;

// The pending operations associated with an exchange are classified into four kinds
// Receive operations, Copy Data Operations, Send Complete and Local operations.
// These need to be incremented under the protection of a spinlock. However they
// are decremented in the absence of a spinlock ( with the respective assert ).


#define SMBCE_LOCAL_OPERATION         0x1
#define SMBCE_SEND_COMPLETE_OPERATION 0x2
#define SMBCE_COPY_DATA_OPERATION     0x4
#define SMBCE_RECEIVE_OPERATION       0x8

extern NTSTATUS
SmbCeIncrementPendingOperations(
    PSMB_EXCHANGE  pExchange,
    ULONG          PendingOperationsMask);

extern SMBCE_EXCHANGE_STATUS
SmbCeDecrementPendingOperationsAndFinalize(
    PSMB_EXCHANGE  pExchange,
    ULONG          PendingOperationsMask);

// the pending operations increment routines

#define SmbCeIncrementPendingReceiveOperations(pExchange)           \
        SmbCeIncrementPendingOperations(pExchange,(SMBCE_RECEIVE_OPERATION))

#define SmbCeIncrementPendingSendCompleteOperations(pExchange)      \
        SmbCeIncrementPendingOperations(pExchange,(SMBCE_SEND_COMPLETE_OPERATION))

#define SmbCeIncrementPendingCopyDataOperations(pExchange)         \
        SmbCeIncrementPendingOperations(pExchange,(SMBCE_COPY_DATA_OPERATION))

#define SmbCeIncrementPendingLocalOperations(pExchange)                \
        SmbCeIncrementPendingOperations(pExchange,(SMBCE_LOCAL_OPERATION))

// The pending operations decrement routines
// Note the special casing of ReceivePendingOperations since it is the only one
// that can be forced by a disconnect indication. There are two variations in
// the decrement macros. The first flavour is to be used when it can be
// guaranteed that the decrement operation will not lead to the finalization
// of the exchange and the second is to be used when we cannot ensure the criterion
// for the first. The difference between the two is that it eliminates
// acquisition/release of a spinlock.

#define SmbCeDecrementPendingReceiveOperations(pExchange)                  \
        SmbCeAcquireSpinLock();                                            \
        if ((pExchange)->ReceivePendingOperations > 0) {                   \
            InterlockedDecrement(&(pExchange)->ReceivePendingOperations);  \
        }                                                                  \
        SmbCeReleaseSpinLock()

#define SmbCeDecrementPendingSendCompleteOperations(pExchange)              \
        ASSERT((pExchange)->SendCompletePendingOperations > 0);             \
        InterlockedDecrement(&(pExchange)->SendCompletePendingOperations)

#define SmbCeDecrementPendingCopyDataOperations(pExchange)              \
        ASSERT((pExchange)->CopyDataPendingOperations > 0);             \
        InterlockedDecrement(&(pExchange)->CopyDataPendingOperations)

#define SmbCeDecrementPendingLocalOperations(pExchange)                  \
        ASSERT((pExchange)->LocalPendingOperations > 0);                 \
        InterlockedDecrement(&(pExchange)->LocalPendingOperations)

// The pending operations decrement routines

#define SmbCeDecrementPendingReceiveOperationsAndFinalize(pExchange)          \
        SmbCeDecrementPendingOperationsAndFinalize(pExchange,(SMBCE_RECEIVE_OPERATION))

#define SmbCeDecrementPendingSendCompleteOperationsAndFinalize(pExchange)     \
        SmbCeDecrementPendingOperationsAndFinalize(pExchange,(SMBCE_SEND_COMPLETE_OPERATION))

#define SmbCeDecrementPendingCopyDataOperationsAndFinalize(pExchange)         \
        SmbCeDecrementPendingOperationsAndFinalize(pExchange,(SMBCE_COPY_DATA_OPERATION))

#define SmbCeDecrementPendingLocalOperationsAndFinalize(pExchange)            \
        SmbCeDecrementPendingOperationsAndFinalize(pExchange,(SMBCE_LOCAL_OPERATION))

// The exchange engine API, for creation and manipulation of exchange instances

// Initialization/Creation of an exchange instance

extern NTSTATUS
SmbCeInitializeExchange(
    PSMB_EXCHANGE                 *pExchangePointer,
    PMRX_V_NET_ROOT               pVNetRoot,
    SMB_EXCHANGE_TYPE             ExchangeType,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector);

// converting one type of exchange to another

extern NTSTATUS
SmbCeTransformExchange(
    PSMB_EXCHANGE                 pExchange,
    SMB_EXCHANGE_TYPE             NewType,
    PSMB_EXCHANGE_DISPATCH_VECTOR pDispatchVector);

// Initiating an exchange

extern NTSTATUS
SmbCeInitiateExchange(PSMB_EXCHANGE pExchange);

// aborting an initiated exchange

extern NTSTATUS
SmbCeAbortExchange(PSMB_EXCHANGE pExchange);

// discarding an exchnge instance

extern VOID
SmbCeDiscardExchange(PVOID pExchange);

// In addition to providing a flexible mechanism for exchanging packets with
// the server the exchange engine also provides a mechanism for building and
// parsing SMB_HEADER's. This functionality is built into the connection
// engine because the meta data in the headers is used to update the connection
// engine database.

// building SMB headers

extern NTSTATUS
SmbCeBuildSmbHeader(
    IN OUT PSMB_EXCHANGE    pExchange,
    IN OUT PVOID            pBuffer,
    IN     ULONG            BufferLength,
    OUT    PULONG           pRemainingBuffer,
    OUT    PUCHAR           pLastCommandInHeader,
    OUT    PUCHAR           *pNextCommand);

// parsing SMB headers.

extern NTSTATUS
SmbCeParseSmbHeader(
    PSMB_EXCHANGE     pExchange,
    PSMB_HEADER       pSmbHeader,
    PGENERIC_ANDX     pCommandToProcess,
    NTSTATUS          *pSmbResponseStatus,
    ULONG             BytesAvailable,
    ULONG             BytesIndicated,
    PULONG            pBytesConsumed);


// The following routines are intended for use in the connection engine only.

extern NTSTATUS
MRxSmbInitializeSmbCe();

extern NTSTATUS
MRxSmbTearDownSmbCe();

extern NTSTATUS
SmbCePrepareExchangeForReuse(PSMB_EXCHANGE pExchange);


extern PVOID
SmbCeMapSendBufferToCompletionContext(
    PSMB_EXCHANGE                 pExchange,
    PVOID                         pBuffer);

extern PVOID
SmbCeMapSendCompletionContextToBuffer(
    PSMB_EXCHANGE                 pExchange,
    PVOID                         pContext);


extern SMBCE_EXCHANGE_STATUS
SmbCeFinalizeExchange(PSMB_EXCHANGE pExchange);


extern NTSTATUS
SmbCeReferenceServer(
    PSMB_EXCHANGE  pExchange);


extern NTSTATUS
SmbCeIncrementActiveExchangeCount();

extern VOID
SmbCeDecrementActiveExchangeCount();

typedef struct _SMB_CONSTRUCT_NETROOT_EXCHANGE_ {
    SMB_EXCHANGE;
    SMB_TREE_ID                 TreeId;
    SMB_USER_ID                 UserId;
    BOOLEAN                     fUpdateDefaultSessionEntry;
    PMRX_NETROOT_CALLBACK       NetRootCallback;
    PMDL                        pSmbRequestMdl;
    PMDL                        pSmbResponseMdl;
    PVOID                       pSmbBuffer;
    PMRX_CREATENETROOT_CONTEXT  pCreateNetRootContext;
} SMB_CONSTRUCT_NETROOT_EXCHANGE, *PSMB_CONSTRUCT_NETROOT_EXCHANGE;

typedef struct _SMB_ADMIN_EXCHANGE_ {
   SMB_EXCHANGE;

   UCHAR                     SmbCommand;
   ULONG                     SmbBufferLength;
   PVOID                     pSmbBuffer;
   PMDL              pSmbMdl;
   PSMBCE_RESUMPTION_CONTEXT pResumptionContext;

   union {
      struct {
         PMRX_SRV_CALL  pSrvCall;
         UNICODE_STRING DomainName;
      } Negotiate;
      struct {
         UCHAR DisconnectSmb[sizeof(SMB_HEADER) + sizeof(REQ_TREE_DISCONNECT)];
      } Disconnect;
      struct {
         UCHAR LogOffSmb[sizeof(SMB_HEADER) + sizeof(REQ_LOGOFF_ANDX)];
      } LogOff;
   };
} SMB_ADMIN_EXCHANGE, *PSMB_ADMIN_EXCHANGE;

extern SMB_EXCHANGE_DISPATCH_VECTOR AdminExchangeDispatch;

#endif // _SMBXCHNG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\srvcall.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    srvcall.c

Abstract:

    This module implements the routines for handling the creation/manipulation of
    server entries in the connection engine database. It also contains the routines
    for parsing the negotiate response from  the server.

--*/

#include "precomp.h"
#pragma hdrstop


RXDT_DefineCategory(SRVCALL);
#define Dbg        (DEBUG_TRACE_SRVCALL)

NTSTATUS
SmbCeCreateSrvCall(
      PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext)
/*++

Routine Description:

   This routine patches the RDBSS created srv call instance with the information required
   by the mini redirector.

Arguments:

    CallBackContext  - the call back context in RDBSS for continuation.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   NTSTATUS Status;

   PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = pCallbackContext;
   PMRX_SRV_CALL pSrvCall;
   PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure = (PMRX_SRVCALLDOWN_STRUCTURE)(SCCBC->SrvCalldownStructure);

   pSrvCall = SrvCalldownStructure->SrvCall;
   ASSERT( pSrvCall );
   ASSERT( NodeType(pSrvCall) == RDBSS_NTC_SRVCALL );

   Status = SmbCeInitializeServerEntry(pSrvCall,pCallbackContext);

   SCCBC->Status = Status;
   SrvCalldownStructure->CallBack(SCCBC);

   return Status;
}



NTSTATUS
MRxIfsCreateSrvCall(
      PMRX_SRV_CALL                  pSrvCall,
      PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext)
/*++

Routine Description:

   This routine patches the RDBSS created srv call instance with the information required
   by the mini redirector.

Arguments:

    RxContext        - Supplies the context of the original create/ioctl

    CallBackContext  - the call back context in RDBSS for continuation.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   NTSTATUS Status;
   UNICODE_STRING ServerName;

   PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure = (PMRX_SRVCALLDOWN_STRUCTURE)(pCallbackContext->SrvCalldownStructure);

   ASSERT( pSrvCall );
   ASSERT( NodeType(pSrvCall) == RDBSS_NTC_SRVCALL );

   //
   // If this request was made on behalf of the RDBSS, perform SmbCeCreatSrvCall
   // immediately. If the request was made from somewhere else, create a work item
   // and place it on a queue for a worker thread to process later. This distinction
   // is made to simplify transport handle management.
   //

   if (IoGetCurrentProcess() == RxGetRDBSSProcess())
   {
       //
       // Peform the processing immediately because RDBSS is the initiator of this
       // request
       //

       Status = SmbCeCreateSrvCall(pCallbackContext);
   }
   else
   {
      //
      // Dispatch the request to a worker thread because the redirected drive
      // buffering sub-system (RDBSS) was not the initiator
      //

      Status = RxDispatchToWorkerThread(
                  MRxIfsDeviceObject,
                  DelayedWorkQueue,
                  SmbCeCreateSrvCall,
                  pCallbackContext);

      if (Status == STATUS_SUCCESS)
      {
         //
         // Map the return value since the wrapper expects PENDING.
         //

         Status = STATUS_PENDING;
      }
   }

   return Status;
}



NTSTATUS
MRxIfsFinalizeSrvCall(
      PMRX_SRV_CALL pSrvCall,
      BOOLEAN       Force)
/*++

Routine Description:

   This routine destroys a given server call instance

Arguments:

    pSrvCall  - the server call instance to be disconnected.

    Force     - TRUE if a disconnection is to be enforced immediately.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   NTSTATUS              Status = STATUS_SUCCESS;
   PSMBCEDB_SERVER_ENTRY pServerEntry;

   //
   // Get the address of the server entry associated with
   // this srv_call
   //

   pServerEntry = SmbCeGetAssociatedServerEntry(pSrvCall);

   //
   // decrement the reference count. Ref counts are used
   // because this is a shared data structure
   //

   if (pServerEntry != NULL) {
      SmbCeDereferenceServerEntry(pServerEntry);
   }


   pSrvCall->Context = NULL;

   return Status;
}

NTSTATUS
MRxIfsSrvCallWinnerNotify(
      IN PMRX_SRV_CALL  pSrvCall,
      IN BOOLEAN        ThisMinirdrIsTheWinner,
      IN OUT PVOID      pSrvCallContext
      )
/*++

Routine Description:

   This routine finalizes the mini rdr context associated with an RDBSS Server call instance

Arguments:

    pSrvCall               - the Server Call

    ThisMinirdrIsTheWinner - TRUE if this mini rdr is the choosen one.

    pSrvCallContext  - the server call context created by the mini redirector.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The two phase construction protocol for Server calls is required because of parallel
    initiation of a number of mini redirectors. The RDBSS finalizes the particular mini
    redirector to be used in communicating with a given server based on quality of
    service criterion.

--*/
{

   NTSTATUS Status = STATUS_SUCCESS;
   PSMBCEDB_SERVER_ENTRY pServerEntry;

   pServerEntry = (PSMBCEDB_SERVER_ENTRY)pSrvCallContext;

   if (!ThisMinirdrIsTheWinner) {

      //
      // Some other mini rdr has been choosen to connect to the server. Destroy
      // the data structures created for this mini redirector.
      //

      SmbCeUpdateServerEntryState(pServerEntry,SMBCEDB_MARKED_FOR_DELETION);
      SmbCeDereferenceServerEntry(pServerEntry);

   }
   else
   {
      //
      // We have been chosed to connect to the server (we won). Set up the SRV_CALL
      // flags and check for a loopback
      //

      pSrvCall->Context  = pServerEntry;
      pSrvCall->Flags   |= SRVCALL_FLAG_CASE_INSENSITIVE_NETROOTS | SRVCALL_FLAG_CASE_INSENSITIVE_FILENAMES;

      {
          UNICODE_STRING ServerName;
          BOOLEAN CaseInsensitive = TRUE;
          ASSERT (pServerEntry->pRdbssSrvCall == pSrvCall);

          ServerName = *pSrvCall->pSrvCallName;
          ServerName.Buffer++; ServerName.Length -= sizeof(WCHAR);
          if (RtlEqualUnicodeString(&ServerName,&SmbCeContext.ComputerName,CaseInsensitive)) {
              DbgPrint("LOOPBACK!!!!!\n");
              pServerEntry->Server.IsLoopBack = TRUE;
          }
      }

   }

   return(STATUS_SUCCESS);
}



//
// The following type defines and data structures are used for parsing negotiate SMB
// responses.
//



#include "protocol.h"

//superceded in smbxchng.h
//#define MRXSMB_PROCESS_ID 0xCAFE

typedef enum _SMB_NEGOTIATE_TYPE_ {
   SMB_CORE_NEGOTIATE,
   SMB_EXTENDED_NEGOTIATE
} SMB_NEGOTIATE_TYPE, *PSMB_NEGOTIATE_TYPE;

typedef struct _SMB_DIALECTS_ {
   SMB_NEGOTIATE_TYPE   NegotiateType;
   USHORT               DispatchVectorIndex;
} SMB_DIALECTS, *PSMB_DIALECTS;

SMBCE_SERVER_DISPATCH_VECTOR
s_SmbServerDispatchVectors[] = {
      {BuildSessionSetupSmb,CoreBuildTreeConnectSmb},
      {BuildSessionSetupSmb,LmBuildTreeConnectSmb}
   };


SMB_DIALECTS
s_SmbDialects[] = {
    { SMB_CORE_NEGOTIATE, 0},
    { SMB_CORE_NEGOTIATE, 0 },
    { SMB_EXTENDED_NEGOTIATE, 1 },
    { SMB_EXTENDED_NEGOTIATE, 1 },
    { SMB_EXTENDED_NEGOTIATE, 1 },
    { SMB_EXTENDED_NEGOTIATE, 1 },
    { SMB_EXTENDED_NEGOTIATE, 1 }
};



//
// LANMAN21 dialect was chosen to allow user login (as opposed to just
// share level to be demonstrated in this example
//

CHAR s_DialectNames[] = {
   "\2" PCNET1 "\0"
   "\2" "noway" XENIXCORE "\0"
   "\2" "noway" MSNET103 "\0"
   "\2" "noway" LANMAN10 "\0"
   "\2"  WFW10 "\0"
   "\2" "noway"LANMAN12 "\0"
   "\2" LANMAN21
};




#define __second(a,b) (b)
ULONG
MRxSmbDialectFlags[] = {
    __second( PCNET1,    DF_CORE ),

    __second( XENIXCORE, DF_CORE | DF_MIXEDCASEPW | DF_MIXEDCASE ),

    __second( MSNET103,  DF_CORE | DF_OLDRAWIO | DF_LOCKREAD | DF_EXTENDNEGOT ),

    __second( LANMAN10,  DF_CORE | DF_NEWRAWIO | DF_LOCKREAD | DF_EXTENDNEGOT |
                    DF_LANMAN10 ),

    __second( WFW10,  DF_CORE | DF_NEWRAWIO | DF_LOCKREAD | DF_EXTENDNEGOT |
                    DF_LANMAN10 | DF_WFW),

    __second( LANMAN12,  DF_CORE | DF_NEWRAWIO | DF_LOCKREAD | DF_EXTENDNEGOT |
                    DF_LANMAN10 | DF_LANMAN20 |
                    DF_MIXEDCASE | DF_LONGNAME | DF_SUPPORTEA ),

    __second( LANMAN21,  DF_CORE | DF_NEWRAWIO | DF_LOCKREAD | DF_EXTENDNEGOT |
                    DF_LANMAN10 | DF_LANMAN20 |
                    DF_MIXEDCASE | DF_LONGNAME | DF_SUPPORTEA |
                    DF_LANMAN21),

    __second( NTLANMAN,  DF_CORE | DF_NEWRAWIO |  DF_NTNEGOTIATE |
                    DF_MIXEDCASEPW | DF_LANMAN10 | DF_LANMAN20 |
                    DF_LANMAN21 | DF_MIXEDCASE | DF_LONGNAME |
                    DF_SUPPORTEA | DF_TIME_IS_UTC )
};

ULONG s_NumberOfDialects = sizeof(s_SmbDialects) / sizeof(s_SmbDialects[0]);

PBYTE s_pNegotiateSmb =  NULL;
ULONG s_NegotiateSmbLength = 0;

PBYTE s_pEchoSmb  = NULL;
BYTE  s_EchoData[] = "JlJmIhClBsr";

MRXSMB_ECHO_PROCESSING_CONTEXT EchoProbeContext;

#define SMB_ECHO_COUNT (1)

// Number of ticks 100ns ticks in a day.
LARGE_INTEGER s_MaxTimeZoneBias;

extern NTSTATUS
GetLanmanSecurityParameters(
    PSMBCE_SERVER    pServer,
    PRESP_NEGOTIATE  pNegotiateResponse);

extern VOID
GetLanmanTimeBias(
       PSMBCE_SERVER   pServer,
       PRESP_NEGOTIATE pNegotiateResponse);

// Number of 100 ns ticks in one minute
#define ONE_MINUTE_IN_TIME (60 * 1000 * 10000)



NTSTATUS
MRxIfsInitializeEchoProcessingContext()
/*++

Routine Description:

    This routine builds the echo SMB

Return Value:

    STATUS_SUCCESS if construction of an ECHO smb was successful

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS    Status = STATUS_SUCCESS;
   ULONG       DialectIndex;

   PSMB_HEADER    pSmbHeader = NULL;
   PREQ_ECHO      pReqEcho   = NULL;

   EchoProbeContext.EchoSmbLength = sizeof(SMB_HEADER) +
                     FIELD_OFFSET(REQ_ECHO,Buffer) +
                     sizeof(s_EchoData);

   EchoProbeContext.pEchoSmb = (PBYTE)RxAllocatePoolWithTag(
                                          NonPagedPool,
                                          EchoProbeContext.EchoSmbLength,
                                          MRXSMB_ECHO_POOLTAG);
   if (EchoProbeContext.pEchoSmb != NULL) {
      pSmbHeader = (PSMB_HEADER)EchoProbeContext.pEchoSmb;
      pReqEcho   = (PREQ_ECHO)((PBYTE)EchoProbeContext.pEchoSmb + sizeof(SMB_HEADER));

      // Fill in the header
      RtlZeroMemory( pSmbHeader, sizeof( SMB_HEADER ) );

      *(PULONG)(&pSmbHeader->Protocol) = (ULONG)SMB_HEADER_PROTOCOL;

      // By default, paths in SMBs are marked as case insensitive and
      // canonicalized.
      pSmbHeader->Flags =
          SMB_FLAGS_CASE_INSENSITIVE | SMB_FLAGS_CANONICALIZED_PATHS;

      // Get the flags2 field out of the SmbContext
      SmbPutAlignedUshort( &pSmbHeader->Flags2,
                           (SMB_FLAGS2_KNOWS_LONG_NAMES |
                            SMB_FLAGS2_KNOWS_EAS        |
                            SMB_FLAGS2_IS_LONG_NAME     |
                            SMB_FLAGS2_NT_STATUS        |
                            SMB_FLAGS2_UNICODE));

      // Fill in the process id.
      SmbPutUshort(&pSmbHeader->Pid, MRXSMB_PROCESS_ID );
      SmbPutUshort(&pSmbHeader->Tid,0xffff); // Invalid TID

      // Lastly, fill in the smb command code.
      pSmbHeader->Command = (UCHAR) SMB_COM_ECHO;

      pReqEcho->WordCount = 1;

      RtlMoveMemory( pReqEcho->Buffer, s_EchoData, sizeof( s_EchoData ) );

      SmbPutUshort(&pReqEcho->EchoCount, SMB_ECHO_COUNT);
      SmbPutUshort(&pReqEcho->ByteCount, (USHORT) sizeof( s_EchoData ) );

      EchoProbeContext.pEchoSmbMdl = RxAllocateMdl(
                                          EchoProbeContext.pEchoSmb,
                                          EchoProbeContext.EchoSmbLength);
      if (EchoProbeContext.pEchoSmbMdl == NULL) {
         RxFreePool(EchoProbeContext.pEchoSmb);
         Status = STATUS_INSUFFICIENT_RESOURCES;
      } else {
         MmBuildMdlForNonPagedPool(EchoProbeContext.pEchoSmbMdl);
         EchoProbeContext.Interval.QuadPart = 5 * 1000 * 10000; // 5 seconds in 100 ns intervals
         EchoProbeContext.Status = RxPostOneShotTimerRequest(
                                       MRxIfsDeviceObject,
                                       &EchoProbeContext.WorkItem,
                                       SmbCeProbeServers,
                                       &EchoProbeContext,
                                       EchoProbeContext.Interval);

      }
   } else {
      Status = STATUS_INSUFFICIENT_RESOURCES;
   }

   return Status;
}

NTSTATUS
MRxIfsTearDownEchoProcessingContext()
/*++

Routine Description:

    This routine tears down the echo processing context

Return Value:

    STATUS_SUCCESS if tear down was successful

--*/
{
   if (EchoProbeContext.pEchoSmb != NULL) {
      RxFreePool(EchoProbeContext.pEchoSmb);
   }

   return STATUS_SUCCESS;
}




NTSTATUS
BuildNegotiateSmb(
         PVOID    *pSmbBufferPointer,
         PULONG   pSmbBufferLength)
/*++

Routine Description:

    This routine builds the negotiate SMB

Arguments:

    pSmbBufferPointer    - a placeholder for the smb buffer

    pNegotiateSmbLength  - the smb buffer size

Return Value:

    STATUS_SUCCESS - implies that pServer is a valid instnace .

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       DialectIndex;

    if (s_pNegotiateSmb == NULL)
    {
        PSMB_HEADER    pSmbHeader    = NULL;
        PREQ_NEGOTIATE pReqNegotiate = NULL;

        //
        // Allocate memory for the SMB from Paged Pool
        //

        s_NegotiateSmbLength = sizeof(SMB_HEADER) +
                               FIELD_OFFSET(REQ_NEGOTIATE,Buffer) +
                               sizeof(s_DialectNames);

        s_pNegotiateSmb = (PBYTE)RxAllocatePoolWithTag(
                                    PagedPool,
                                    s_NegotiateSmbLength,
                                    MRXSMB_ADMIN_POOLTAG);


        if (s_pNegotiateSmb != NULL)
        {

            pSmbHeader = (PSMB_HEADER)s_pNegotiateSmb;

            pReqNegotiate = (PREQ_NEGOTIATE)(s_pNegotiateSmb + sizeof(SMB_HEADER));

            //
            // Fill in the SMB header. This contains 4 bytes 0xFF, 'SMB'
            //

            RtlZeroMemory( pSmbHeader, sizeof( SMB_HEADER ) );

            *(PULONG)(&pSmbHeader->Protocol) = (ULONG)SMB_HEADER_PROTOCOL;

            //
            // Set the SMB Flags.
            //

            pSmbHeader->Flags =
                SMB_FLAGS_CASE_INSENSITIVE | SMB_FLAGS_CANONICALIZED_PATHS;

            //
            // Set the SMB Flags2
            //
             SmbPutAlignedUshort( &pSmbHeader->Flags2,  0);


            //
            // Fill in the process id and command code
            //
            //

            SmbPutUshort( &pSmbHeader->Pid, MRXSMB_PROCESS_ID );

            pSmbHeader->Command = (UCHAR) SMB_COM_NEGOTIATE;

            pReqNegotiate->WordCount = 0;

            //
            // Copy the dialect strings into the SMB. In this example mini rdr
            // the dialect support has been restricted to PC NETWORK PROGRAM 1.0,
            // which is the simplest and most limited capability set.
            //

            RtlMoveMemory( pReqNegotiate->Buffer, s_DialectNames, sizeof( s_DialectNames ) );

            SmbPutUshort( &pReqNegotiate->ByteCount, (USHORT) sizeof( s_DialectNames ) );

            //
            // Initialize the maximum time zone bias used in negotiate response parsing.
            //

            s_MaxTimeZoneBias.QuadPart = Int32x32To64(24*60*60,1000*10000);

        }
        else
        {
            //
            // Paged pool could not be allocated for the SMB.
            //

            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }


    if (NT_SUCCESS(Status))
    {
        *pSmbBufferLength  = s_NegotiateSmbLength;
        *pSmbBufferPointer = s_pNegotiateSmb;
    }

    return Status;
}





NTSTATUS
ParseNegotiateResponse(
        PSMBCE_SERVER   pServer,
        PUNICODE_STRING pDomainName,
        PSMB_HEADER     pSmbHeader,
        ULONG           BytesAvailable,
        PULONG          pBytesConsumed)
/*++

Routine Description:

    This routine parses the response from the server

Arguments:

    pServer            - the server instance

    pDomainName        - the domain name string to be extracted from the response

    pSmbHeader         - the response SMB

    BytesAvailable     - length of the response

    pBytesTaken        - response consumed

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    The SMB servers can speak a variety of dialects of the SMB protocol. The initial
    negotiate response can come in one of three possible flavours. Either we get the
    NT negotiate response SMB from a NT server or the extended response from DOS and
    OS/2 servers or the CORE response from other servers.

--*/
{
   NTSTATUS        Status = STATUS_SUCCESS;
   USHORT          DialectIndex;
   PRESP_NEGOTIATE pNegotiateResponse;
   ULONG           NegotiateSmbLength;

   ASSERT( pSmbHeader != NULL );

   pNegotiateResponse = (PRESP_NEGOTIATE) (pSmbHeader + 1);
   NegotiateSmbLength = sizeof(SMB_HEADER);

   DialectIndex = SmbGetUshort( &pNegotiateResponse->DialectIndex );

   if (DialectIndex == (USHORT) -1) {

      //
      // means server cannot accept the dialog strings we sent
      //

      *pBytesConsumed = BytesAvailable;
      return STATUS_REQUEST_NOT_ACCEPTED;
   }

   if (pNegotiateResponse->WordCount < 1 || DialectIndex > s_NumberOfDialects) {
      *pBytesConsumed = BytesAvailable;
      return( STATUS_INVALID_NETWORK_RESPONSE );
   }

   //
   // set the domain name length to zero ( default initialization )
   //

   pDomainName->Length = 0;

   //
   // Fix up the dialect type and the corresponding dispatch vector.
   //

   pServer->Dialect        = (SMB_DIALECT)DialectIndex;
   pServer->DialectFlags   = MRxSmbDialectFlags[DialectIndex];
   pServer->pDispatch      = &s_SmbServerDispatchVectors[s_SmbDialects[DialectIndex].DispatchVectorIndex];

   //
   // Parse the response based upon the type of negotiate response expected.
   //

   switch (s_SmbDialects[DialectIndex].NegotiateType) {
   case SMB_EXTENDED_NEGOTIATE :
      {
         USHORT RawMode;

         // DOS or OS2 server
         if (pNegotiateResponse->WordCount != 13 &&
             pNegotiateResponse->WordCount != 10 &&
             pNegotiateResponse->WordCount != 8) {
            Status = STATUS_INVALID_NETWORK_RESPONSE;
         } else {
            NegotiateSmbLength += FIELD_OFFSET(RESP_NEGOTIATE,Buffer) +
                     SmbGetUshort(&pNegotiateResponse->ByteCount);

            RawMode = SmbGetUshort( &pNegotiateResponse->RawMode );
            pServer->Capabilities |= ((RawMode & 0x1) != 0 ? RAW_READ_CAPABILITY : 0);
            pServer->Capabilities |= ((RawMode & 0x2) != 0 ? RAW_WRITE_CAPABILITY : 0);

            if (pSmbHeader->Flags & SMB_FLAGS_LOCK_AND_READ_OK) {
                pServer->DialectFlags |= DF_LOCKREAD;
            }

            pServer->EncryptPasswords = FALSE;
            pServer->MaximumVCs       = 1;

            pServer->MaximumBufferSize     = SmbGetUshort( &pNegotiateResponse->MaxBufferSize );
            pServer->MaximumDiskFileReadBufferSize = pServer->MaximumBufferSize -
                                                     QuadAlign(
                                                         sizeof(SMB_HEADER) +
                                                         FIELD_OFFSET(
                                                             REQ_READ_ANDX,
                                                             Buffer[0]));
            pServer->MaximumNonDiskFileReadBufferSize = pServer->MaximumDiskFileReadBufferSize;

            pServer->MaximumRequests  = SmbGetUshort( &pNegotiateResponse->MaxMpxCount );
            pServer->MaximumVCs       = SmbGetUshort( &pNegotiateResponse->MaxNumberVcs );

            if (pNegotiateResponse->WordCount == 13) {
               switch (pServer->Dialect) {
               case LANMAN10_DIALECT:
               case WFW10_DIALECT:
               case LANMAN12_DIALECT:
               case LANMAN21_DIALECT:
                   GetLanmanTimeBias( pServer,pNegotiateResponse );
                   break;
               }

               Status = GetLanmanSecurityParameters( pServer,pNegotiateResponse );
            }
         }
      }
      break;
   case SMB_CORE_NEGOTIATE :
   default :
      {
         pServer->SecurityMode = SECURITY_MODE_SHARE_LEVEL;
         pServer->EncryptPasswords = FALSE;
         pServer->MaximumBufferSize = 0;
         pServer->MaximumRequests = 1;
         pServer->MaximumVCs = 1;
         pServer->SessionKey = 0;

         NegotiateSmbLength = BytesAvailable;
      }
   }

   if (NT_SUCCESS(Status)) {
      //  Check to make sure that the time zone bias isn't more than +-24
      //  hours.
      //
      if ((pServer->TimeZoneBias.QuadPart > s_MaxTimeZoneBias.QuadPart) ||
          (-pServer->TimeZoneBias.QuadPart > s_MaxTimeZoneBias.QuadPart)) {

          //  Set the bias to 0 - assume local time zone.
          pServer->TimeZoneBias.LowPart = pServer->TimeZoneBias.HighPart = 0;
       }

       //  Do not allow negotiated buffersize to exceed the size of a USHORT.
       //  Remove 4096 bytes to avoid overrun and make it easier to handle
       //  than 0xffff

       pServer->MaximumBufferSize =
           (pServer->MaximumBufferSize < 0x00010000) ? pServer->MaximumBufferSize :
                                             0x00010000 - 4096;

       *pBytesConsumed = NegotiateSmbLength;
   } else {
      *pBytesConsumed = BytesAvailable;
   }

   if ((pServer->Capabilities & DF_NTNEGOTIATE)!=0) {

        InterlockedIncrement(&MRxIfsStatistics.LanmanNtConnects);

    } else if ((pServer->Capabilities & DF_LANMAN21)!=0) {

        InterlockedIncrement(&MRxIfsStatistics.Lanman21Connects);

    } else if ((pServer->Capabilities & DF_LANMAN20)!=0) {

        InterlockedIncrement(&MRxIfsStatistics.Lanman20Connects);

    } else {

        InterlockedIncrement(&MRxIfsStatistics.CoreConnects);

    }

   return Status;
}

NTSTATUS
GetLanmanSecurityParameters(
    PSMBCE_SERVER    pServer,
    PRESP_NEGOTIATE  pNegotiateResponse)
/*++

Routine Description:

    This routine extracts the security parameters from a LANMAN server

Arguments:

    pServer              - the server

    pNtNegotiateResponse - the response

Return Value:

    STATUS_SUCCESS - implies that pServer is a valid instnace .

    Other Status codes correspond to error situations.

--*/
{

    USHORT i;
    USHORT SecurityMode;

    pServer->SessionKey = SmbGetUlong( &pNegotiateResponse->SessionKey );

    SecurityMode = SmbGetUshort( &pNegotiateResponse->SecurityMode );
    pServer->SecurityMode = (((SecurityMode & 1) != 0)
                             ? SECURITY_MODE_USER_LEVEL
                             : SECURITY_MODE_SHARE_LEVEL);
    pServer->EncryptPasswords = ((SecurityMode & 2) != 0);

    if (pServer->EncryptPasswords) {
        if (pServer->Dialect == LANMAN21_DIALECT) {
            pServer->EncryptionKeyLength = SmbGetUshort(&pNegotiateResponse->EncryptionKeyLength);
        } else {
            pServer->EncryptionKeyLength = SmbGetUshort(&pNegotiateResponse->ByteCount);
        }

        if (pServer->EncryptionKeyLength != 0) {
            if (pServer->EncryptionKeyLength > CRYPT_TXT_LEN) {
                return( STATUS_INVALID_NETWORK_RESPONSE );
            }

            for (i = 0; i < pServer->EncryptionKeyLength; i++) {
                pServer->EncryptionKey[i] = pNegotiateResponse->Buffer[i];
            }
        }
    }

    return( STATUS_SUCCESS );
}

LARGE_INTEGER
ConvertSmbTimeToTime (
    IN SMB_TIME Time,
    IN SMB_DATE Date
    )

/*++

Routine Description:

    This routine converts an SMB time to an NT time structure.

Arguments:

    IN SMB_TIME Time - Supplies the time of day to convert
    IN SMB_DATE Date - Supplies the day of the year to convert
    IN PSERVERLISTENTRY Server - if supplied, supplies the server for tz bias.

Return Value:

    LARGE_INTEGER - Time structure describing input time.


--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER OutputTime;

    //
    // This routine cannot be paged because it is called from both the
    // RdrFileDiscardableSection and the RdrVCDiscardableSection.
    //

    if (SmbIsTimeZero(&Date) && SmbIsTimeZero(&Time)) {
        OutputTime.LowPart = OutputTime.HighPart = 0;
    } else {
        TimeFields.Year = Date.Struct.Year + (USHORT )1980;
        TimeFields.Month = Date.Struct.Month;
        TimeFields.Day = Date.Struct.Day;

        TimeFields.Hour = Time.Struct.Hours;
        TimeFields.Minute = Time.Struct.Minutes;
        TimeFields.Second = Time.Struct.TwoSeconds*(USHORT )2;
        TimeFields.Milliseconds = 0;

        //
        //  Make sure that the times specified in the SMB are reasonable
        //  before converting them.
        //

        if (TimeFields.Year < 1601) {
            TimeFields.Year = 1601;
        }

        if (TimeFields.Month > 12) {
            TimeFields.Month = 12;
        }

        if (TimeFields.Hour >= 24) {
            TimeFields.Hour = 23;
        }
        if (TimeFields.Minute >= 60) {
            TimeFields.Minute = 59;
        }
        if (TimeFields.Second >= 60) {
            TimeFields.Second = 59;

        }

        if (!RtlTimeFieldsToTime(&TimeFields, &OutputTime)) {
            OutputTime.HighPart = 0;
            OutputTime.LowPart = 0;

            return OutputTime;
        }

        ExLocalTimeToSystemTime(&OutputTime, &OutputTime);

    }

    return OutputTime;

}

VOID
GetLanmanTimeBias(
       PSMBCE_SERVER   pServer,
       PRESP_NEGOTIATE pNegotiateResponse)
/*++

Routine Description:

    This routine extracts the time bias from a Lanman server

Arguments:

    pServer              - the server

    pNtNegotiateResponse - the response

Return Value:

    STATUS_SUCCESS - implies that pServer is a valid instnace .

    Other Status codes correspond to error situations.

--*/
{
    //  If this is a LM 1.0 or 2.0 server (ie a non NT server), we
    //  remember the timezone and bias our time based on this value.
    //
    //  The redirector assumes that all times from these servers are
    //  local time for the server, and converts them to local time
    //  using this bias. It then tells the user the local time for
    //  the file on the server.

    LARGE_INTEGER Workspace, ServerTime, CurrentTime;
    BOOLEAN Negated = FALSE;
    SMB_TIME SmbServerTime;
    SMB_DATE SmbServerDate;

    SmbMoveTime(&SmbServerTime, &pNegotiateResponse->ServerTime);

    SmbMoveDate(&SmbServerDate, &pNegotiateResponse->ServerDate);

    ServerTime = ConvertSmbTimeToTime(SmbServerTime, SmbServerDate);

    KeQuerySystemTime(&CurrentTime);

    Workspace.QuadPart = CurrentTime.QuadPart - ServerTime.QuadPart;

    if ( Workspace.HighPart < 0) {
        //  avoid using -ve large integers to routines that accept only unsigned
        Workspace.QuadPart = -Workspace.QuadPart;
        Negated = TRUE;
    }

    //
    //  Workspace has the exact difference in 100ns intervals
    //  between the server and redirector times. To remove the minor
    //  difference between the time settings on the two machines we
    //  round the Bias to the nearest 30 minutes.
    //
    //  Calculate ((exact bias+15minutes)/30minutes)* 30minutes
    //  then convert back to the bias time.
    //

    Workspace.QuadPart += ((LONGLONG) ONE_MINUTE_IN_TIME) * 15;

    //  Workspace is now  exact bias + 15 minutes in 100ns units

    Workspace.QuadPart /= ((LONGLONG) ONE_MINUTE_IN_TIME) * 30;

    pServer->TimeZoneBias.QuadPart = Workspace.QuadPart * ((LONGLONG) ONE_MINUTE_IN_TIME) * 30;

    if ( Negated == TRUE ) {
        pServer->TimeZoneBias.QuadPart = -pServer->TimeZoneBias.QuadPart;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

RDR2=$(BASEDIR)\private\ntos\rdr2
!INCLUDE $(RDR2)\rdbss\master.src

MAJORCOMP=ntos
MINORCOMP=ifsmrx

TARGETNAME=ifsmrx
TARGETPATH=obj
TARGETTYPE=EXPORT_DRIVER

SYNCHRONIZE_DRAIN=1

INCLUDES=$(INCLUDES);$(BASEDIR)\private\ntos\rdr2\inc;
INCLUDES=$(INCLUDES);$(BASEDIR)\private\ntos\rdr2\rdbss\inc;
INCLUDES=$(INCLUDES);$(BASEDIR)\private\ntos\inc;
INCLUDES=$(INCLUDES);..\inc;

TARGETLIBS=\
           $(RDR2)\rdbss\daytona\$(O)\rdbss.lib  \
           $(DDK_LIB_PATH)\ksecdd.lib

MSC_WARNING_LEVEL=/W3 /WX
C_DEFINES= $(C_DEFINES) -DEXPLODE_POOLTAGS
!IF $(MONOLITHIC_MINIRDR)
C_DEFINES=$(C_DEFINES) -DMONOLITHIC_MINIRDR
!ENDIF

MOST_SOURCES=       \
    devfcb.c   \
    downlvli.c \
    fileinfo.c \
    init.c     \
    locks.c    \
    midatlas.c \
    mm.c       \
    netroot.c  \
    notimpl.c  \
    openclos.c \
    downlvlo.c \
    read.c     \
    rename.c   \
    sessetup.c \
    smbadmin.c \
    smbcedb.c  \
    smbcemid.c \
    smbutils.c \
    smbxchng.c \
    sndrcv.c   \
    srvcall.c  \
    smbpse.c   \
    stuffer.c  \
    transprt.c \
    vcsndrcv.c \
    write.c    \
    3connect.c

PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

DLLDEF=$(O)\ifsmrx.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\stuffer.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    Stuffer.h

Abstract:

    Prototypes for the SMBstuffer formating primitives

--*/

#ifndef _SMBSTUFFER_INCLUDED_
#define _SMBSTUFFER_INCLUDED_

IMPORTANT_STRUCTURE(SMBSTUFFER_BUFFER_STATE);

#define COVERED_CALL(x) {\
    Status = x;                         \
    if (Status != STATUS_SUCCESS) {  \
        RxDbgTrace(0, Dbg,("nonSUCCESS covered status = %lx\n",Status));    \
        goto FINALLY;                   \
    }                                   \
    ASSERT (StufferState->SpecificProblem == 0); \
}

#define MRXSMB_PROCESS_ID_ZERO (MRXSMB_PROCESS_ID - 1)
#define MRXSMB_MULTIPLX_ID_ZERO (0xdead)
#define MRXSMB_USER_ID_ZERO ((USHORT)'jj')
#define MRXSMB_TREE_ID_ZERO (0xbaba)

#define GetServerMaximumBufferSize(SRVCALL) 4356

#define SMB_REQUEST_SIZE(___x) (FIELD_OFFSET(REQ_##___x,Buffer[0]))
#if DBG
#define SMB_OFFSET_CHECK(___x,___y) (FIELD_OFFSET(REQ_##___x,___y)),
#define SMB_WCTBCC_CHECK(___x,___y) ( ((0x8000|(___z))<<16)+(FIELD_OFFSET(REQ_##___x,ByteCount)) ),
#define SMB_WCT_CHECK(___z) ((0x8000|(___z))<<16),
#else
#define SMB_OFFSET_CHECK(___x,___y)
#define SMB_WCTBCC_CHECK(___x,___y,___z)
#define SMB_WCT_CHECK(___z)
#endif

typedef enum _SMBbuf_STATUS_DETAIL {
    xSMBbufSTATUS_OK,
    xSMBbufSTATUS_CANT_COMPOUND,
    xSMBbufSTATUS_HEADER_OVERRUN,
    xSMBbufSTATUS_BUFFER_OVERRUN,
    xSMBbufSTATUS_SERVER_OVERRUN,
    xSMBbufSTATUS_FLAGS_CONFLICT,
    xSMBbufSTATUS_MAXIMUM
} SMBbuf_STATUS_DETAIL;

//#define STUFFER_STATE_SIGNATURE ('fftS')
typedef struct _SMBSTUFFER_BUFFER_STATE {
    NODE_TYPE_CODE        NodeTypeCode;     // node type.
    NODE_BYTE_SIZE        NodeByteSize;     // node size.
    // this stuff is fixed
    PMDL HeaderMdl;
    PMDL HeaderPartialMdl; //used for breaking up writes to avoid reallocation
    PBYTE ActualBufferBase;
    PBYTE BufferBase;
    PBYTE BufferLimit;
    //this stuff is reinitialized
    PRX_CONTEXT RxContext;
    PSMB_EXCHANGE Exchange;
    PMDL DataMdl;
    ULONG DataSize;
    //PRXCE_DATA_BUFFER FinalMdl; //for later with no chain-send rule
    PBYTE CurrentPosition;
    PBYTE CurrentWct;
    PBYTE CurrentBcc;
    PBYTE CurrentDataOffset;
    PBYTE CurrentParamOffset;
    UCHAR  PreviousCommand;
    UCHAR  CurrentCommand;
    UCHAR  SpecificProblem;  //SMBbuf_STATUS_DETAIL this is set to pass back what happened
    BOOLEAN Started;
    ULONG FlagsCopy;
    ULONG Flags2Copy;
    //ULONG FlagsMask;
    //ULONG Flags2Mask;
#if DBG
    ULONG Signature;
    PDEBUG_TRACE_CONTROLPOINT ControlPoint;
    BOOLEAN PrintFLoop;
    BOOLEAN PrintCLoop;
#endif
} SMBSTUFFER_BUFFER_STATE;


typedef enum _SMB_STUFFER_CONTROLS {
    STUFFER_CTL_NORMAL=1,
    STUFFER_CTL_SKIP, // only w,d,b can be in a skip string
    STUFFER_CTL_NOBYTES,
    STUFFER_CTL_ENDOFARGUMENTS,
    STUFFER_CTL_MAXIMUM
} SMB_STUFFER_CONTROLS;

#define StufferCondition(___c) ((___c)?STUFFER_CTL_NORMAL:STUFFER_CTL_SKIP)

#if DBG
NTSTATUS
MRxSmbStufferDebug(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbBuildSmbHeaderTestSurrogate(
      PSMB_EXCHANGE     pExchange,
      PVOID             pBuffer,
      ULONG             BufferLength,
      PULONG            pBufferConsumed,
      PUCHAR            pLastCommandInHeader,
      PUCHAR            *pCommandPtr
      );

#endif //if DBG



NTSTATUS
SmbMrxInitializeStufferFacilities(
    void
    );

NTSTATUS
SmbMrxFinalizeStufferFacilities(
    void
    );

#ifdef RDBSSTRACE

#define STUFFERTRACE(CONTROLPOINT,__b__) ,(&RxDTPrefixRx CONTROLPOINT),(__b__)
#define STUFFERTRACE_NOPREFIX(CONTROLPOINT,__b__) ,(CONTROLPOINT),(__b__)
#define STUFFERTRACE_CONTROLPOINT_ARGS \
    ,IN PDEBUG_TRACE_CONTROLPOINT ControlPoint,IN ULONG EnablePrints

#else

#define STUFFERTRACE(__a__,__b__)
#define STUFFERTRACE_NOPREFIX(__a__,__b__)
#define STUFFERTRACE_CONTROLPOINT_ARGS

#endif

NTSTATUS
MRxSmbSetInitialSMB (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState
    STUFFERTRACE_CONTROLPOINT_ARGS
    );

#define NO_EXTRA_DATA 0
#define SMB_BEST_ALIGNMENT(__x,__y) ((__x<<16)|__y)
#define NO_SPECIAL_ALIGNMENT 0
#define RESPONSE_HEADER_SIZE_NOT_SPECIFIED 0

typedef enum _INITIAL_SMBBUF_DISPOSITION {
    SetInitialSMB_yyUnconditionally,  //no one should be using this right now!
    SetInitialSMB_ForReuse,
    SetInitialSMB_Never
} INITIAL_SMBBUG_DISPOSITION;

NTSTATUS
MRxSmbStartSMBCommand (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     INITIAL_SMBBUG_DISPOSITION InitialSMBDisposition,
    IN UCHAR Command,
    IN ULONG MaximumBufferUsed,
    IN ULONG MaximumSize,
    IN ULONG InitialAlignment,
    IN ULONG MaximumResponseHeader,
    IN UCHAR Flags,
    IN UCHAR FlagsMask,
    IN USHORT Flags2,
    IN USHORT Flags2Mask
    STUFFERTRACE_CONTROLPOINT_ARGS
    );

NTSTATUS
MRxSmbStuffSMB (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    ...
    );

VOID
MRxSmbStuffAppendRawData(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PMDL Mdl
    );

VOID
MRxSmbStuffAppendSmbData(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PMDL Mdl
    );

VOID
MRxSmbStuffSetByteCount(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState
    );

BOOLEAN
MrxSMBWillThisFit(
    IN PSMBSTUFFER_BUFFER_STATE StufferState,
    IN ULONG AlignmentUnit,
    IN ULONG DataSize
    );

#endif   // ifndef _SMBSTUFFER_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\transprt.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    transport.c

Abstract:

    This module implements all transport related functions in the SMB connection engine

--*/

#include "precomp.h"
#pragma hdrstop

#include "ntddbrow.h"

SMBCE_TRANSPORTS MRxSmbTransports;

RXDT_DefineCategory(TRANSPRT);
#define Dbg        (DEBUG_TRACE_TRANSPRT)

extern VOID
SmbCePnpBindBrowser(PUNICODE_STRING pTransportName);


VOID SmbCeAddTransport(PSMBCE_TRANSPORT pNewTransport)
/*++

Routine Description:

    Adds a transport to the list of available transports and
    increment the transport count. The list is ordered by the
    transport priority.

Returns:

    Nothing

Notes:

--*/
{
   KIRQL            SavedIrql;

   PLIST_ENTRY      pListEntry,pPreviousListEntry;
   PSMBCE_TRANSPORT pTransport;

   KeAcquireSpinLock(&MRxSmbTransports.Lock,&SavedIrql);

   MRxSmbTransports.Count++;

   pPreviousListEntry = &MRxSmbTransports.ListHead;;
   pListEntry         = MRxSmbTransports.ListHead.Flink;

   while (pListEntry != &MRxSmbTransports.ListHead) {

      pTransport = (PSMBCE_TRANSPORT)CONTAINING_RECORD(
                                          pListEntry,
                                          SMBCE_TRANSPORT,
                                          TransportsList);

      if (pTransport->Priority > pNewTransport->Priority) {
         break;
      } else {
         pPreviousListEntry = pListEntry;
         pListEntry = pListEntry->Flink;
      }

   }

   InsertHeadList(pPreviousListEntry,
                  &pNewTransport->TransportsList);

   KeReleaseSpinLock(&MRxSmbTransports.Lock,SavedIrql);
}




VOID SmbCeRemoveTransport(PSMBCE_TRANSPORT pTransport)
/*++

Routine Description:

    Removes a transport from the list of available transports

Returns:

    Nothing

Notes:

--*/
{
   KIRQL SavedIrql;
   KeAcquireSpinLock(&MRxSmbTransports.Lock,&SavedIrql);
   MRxSmbTransports.Count--;
   RemoveEntryList(&pTransport->TransportsList);
   KeReleaseSpinLock(&MRxSmbTransports.Lock,SavedIrql);
}



NTSTATUS
MRxIfsInitializeTransport()
/*++

Routine Description:

    This routine initializes the transport related data structures

Returns:

    STATUS_SUCCESS if the transport data structures was successfully initialized

Notes:

--*/
{
   KeInitializeSpinLock(&MRxSmbTransports.Lock);
   InitializeListHead(&MRxSmbTransports.ListHead);
   MRxSmbTransports.Count = 0;

   return STATUS_SUCCESS;
}


NTSTATUS
MRxIfsUninitializeTransport()
/*++

Routine Description:

    This routine uninitializes the transport related data structures

Notes:

--*/
{
   PSMBCE_TRANSPORT pTransport;
   KIRQL            SavedIrql;
   ULONG            TransportCount = 0;
   PLIST_ENTRY      pTransportEntry;


   KeAcquireSpinLock(&MRxSmbTransports.Lock,&SavedIrql);

   TransportCount    = MRxSmbTransports.Count;
   pTransportEntry   = MRxSmbTransports.ListHead.Flink;
   InitializeListHead(&MRxSmbTransports.ListHead);
   MRxSmbTransports.Count = 0;

   KeReleaseSpinLock(&MRxSmbTransports.Lock,SavedIrql);

   while (TransportCount > 0) {
      pTransport = (PSMBCE_TRANSPORT)CONTAINING_RECORD(
                                               pTransportEntry,
                                               SMBCE_TRANSPORT,
                                               TransportsList);
      pTransportEntry = pTransportEntry->Flink;
      TransportCount--;

      ASSERT(pTransport->SwizzleCount == 1);
      RxCeDeregisterClientAddress(pTransport->hAddress);
      RxFreePool(pTransport);
   }

   return STATUS_SUCCESS;
}

PSMBCE_TRANSPORT
SmbCeGetNextTransport(PSMBCE_TRANSPORT pTransport)
/*++

Routine Description:

    This routine is used to enumerate the transports used by a mini redirector

Arguments:

    pTransport - the current transport instance ( can be NULL in which case the
                  first transport is returned )

Return Value:

    a valid PSMBCE_TRANSPORT if one exists otherwise NULL

Notes:

    The lock on the list of transports should be held for very small intervals of time.
    Therefore the lock is acquired and released during every step of the enumeration.
    This allows multiple threads to make progress. This behaviour is desirable since
    the typical action is to initiate a connection engine operation on accquiring a
    transport ( a long term operation )

    This routine returns referenced transport instances. It is the callers responsibility
    to dereference it.

--*/
{
   KIRQL            SavedIrql;
   PLIST_ENTRY      pEntry;
   PSMBCE_TRANSPORT pNextTransport;

   KeAcquireSpinLock(&MRxSmbTransports.Lock,&SavedIrql);

   if (pTransport == NULL) {
      pEntry = MRxSmbTransports.ListHead.Flink;
   } else {
      pEntry = pTransport->TransportsList.Flink;
   }

   if (pEntry != &MRxSmbTransports.ListHead) {
      do {
         pNextTransport = (PSMBCE_TRANSPORT)CONTAINING_RECORD(
                                                    pEntry,
                                                    SMBCE_TRANSPORT,
                                                    TransportsList);
         pEntry = pEntry->Flink;
      } while (pNextTransport != NULL &&
               !pNextTransport->Active &&
               (pEntry != &MRxSmbTransports.ListHead));

      if ((pNextTransport != NULL) && pNextTransport->Active) {
         SmbCeReferenceTransport(pNextTransport);
      } else {
         pNextTransport = NULL;
      }
    } else {
       pNextTransport = NULL;
    }

   KeReleaseSpinLock(&MRxSmbTransports.Lock,SavedIrql);

   return pNextTransport;
}


PSMBCE_TRANSPORT
SmbCeFindTransport(RXCE_TRANSPORT_HANDLE hRxCeTransport)
/*++

Routine Description:

    This routine maps a RXCE_TRANSPORT_HANDLE to the appropriate
    PSMBCE_TRANSPORT instance

Arguments:

    hTransport - the RxCe transport handle
Return Value:

    a valid PSMBCE_TRANSPORT if one exists otherwise NULL

Notes:

--*/
{
   KIRQL            SavedIrql;
   PLIST_ENTRY      pEntry;
   PSMBCE_TRANSPORT pTransport = NULL;

   KeAcquireSpinLock(&MRxSmbTransports.Lock,&SavedIrql);

   pEntry = MRxSmbTransports.ListHead.Flink;

   while (pEntry != &MRxSmbTransports.ListHead) {
      pTransport = (PSMBCE_TRANSPORT)CONTAINING_RECORD(
                                             pEntry,
                                             SMBCE_TRANSPORT,
                                             TransportsList);

      if (pTransport->hTransport == hRxCeTransport) {
         SmbCeReferenceTransport(pTransport);
         break;
      } else {
         pEntry = pEntry->Flink;
      }
   }

   if (pEntry == &MRxSmbTransports.ListHead) {
      pTransport = NULL;
   }

   KeReleaseSpinLock(&MRxSmbTransports.Lock,SavedIrql);

   return pTransport;
}

NTSTATUS
SmbCeInitializeServerTransport(
         PSMBCEDB_SERVER_ENTRY   pServerEntry)
/*++

Routine Description:

    This routine initializes the transport information corresponding to a server

Arguments:

    pServerEntry - the server entry instance in the database

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    Currently, only connection oriented transports are handled.

--*/
{
   NTSTATUS            Status;
   SMBCEDB_SERVER_TYPE ServerType   = SmbCeGetServerType(pServerEntry);
   PSMBCE_SERVER_TRANSPORT pServerTransport = NULL;

   if (pServerEntry->pTransport != NULL) {
      SmbCeUninitializeServerTransport(pServerEntry);
   }


   Status = VctInstantiateServerTransport(pServerEntry,&pServerTransport);

   if (Status == STATUS_SUCCESS) {
      ASSERT(pServerTransport != NULL);

      SmbCeAcquireSpinLock();

      pServerTransport->SwizzleCount = 1;
      pServerEntry->pTransport = pServerTransport;

      SmbCeReleaseSpinLock();
   }

   return Status;
}

NTSTATUS
SmbCeUninitializeServerTransport(
         PSMBCEDB_SERVER_ENTRY   pServerEntry)
/*++

Routine Description:

    This routine uninitializes the transport information corresponding to a server

Arguments:

    pServerEntry - the server entry instance in the database

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    Currently, only connection oriented transports are handled.

--*/
{
   NTSTATUS                Status = STATUS_SUCCESS;
   SMBCEDB_SERVER_TYPE     ServerType   = SmbCeGetServerType(pServerEntry);
   PSMBCE_SERVER_TRANSPORT pServerTransport = pServerEntry->pTransport;

   if (pServerTransport != NULL) {
      KEVENT RundownEvent;

      KeInitializeEvent(&RundownEvent,NotificationEvent,FALSE);

      SmbCeAcquireSpinLock();

      pServerTransport->State = SMBCEDB_MARKED_FOR_DELETION;
      pServerTransport->pRundownEvent = &RundownEvent;

      SmbCeReleaseSpinLock();

      SmbCeDereferenceServerTransport(pServerEntry);

      KeWaitForSingleObject(
            &RundownEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL );

      ASSERT(pServerEntry->pTransport == NULL);
   }

   return Status;
}

NTSTATUS
SmbCepReferenceServerTransport(
   PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine references the transport associated with a server entry

Arguments:

    pServerEntry - the server entry instance in the database

Return Value:

    STATUS_SUCCESS - the server transport was successfully referenced

    Other Status codes correspond to error situations.

Notes:

--*/
{
   NTSTATUS Status;

   PSMBCE_SERVER_TRANSPORT pServerTransport;

   SmbCeAcquireSpinLock();

   pServerTransport = pServerEntry->pTransport;

   if (pServerTransport->State == SMBCEDB_ACTIVE) {
      pServerTransport->SwizzleCount++;
      Status = STATUS_SUCCESS;
   } else {
      Status = STATUS_CONNECTION_DISCONNECTED;
   }

   SmbCeReleaseSpinLock();

   return Status;
}

NTSTATUS
SmbCepDereferenceServerTransport(
   PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine dereferences the transport associated with a server entry

Arguments:

    pServerEntry - the server entry instance in the database

Return Value:

    STATUS_SUCCESS - the server transport was successfully dereferenced

    Other Status codes correspond to error situations.

Notes:

    On finalization this routine sets the event to enable the process awaiting
    tear down to restart. It also tears down the associated server transport
    instance.

--*/
{
   NTSTATUS Status = STATUS_SUCCESS;

   PSMBCE_SERVER_TRANSPORT pServerTransport;

   BOOLEAN  FinalizeServerTransport = FALSE;

   SmbCeAcquireSpinLock();

   pServerTransport = pServerEntry->pTransport;
   pServerTransport->SwizzleCount--;
   FinalizeServerTransport = (pServerTransport->SwizzleCount == 0);

   SmbCeReleaseSpinLock();

   if (FinalizeServerTransport) {
      SmbCeAcquireSpinLock();
      pServerEntry->pTransport = NULL;
      SmbCeReleaseSpinLock();

      if (pServerTransport->pRundownEvent != NULL) {
         KeSetEvent( pServerTransport->pRundownEvent, 0, FALSE );
      }

      pServerTransport->pDispatchVector->TearDown(pServerTransport);
   }

   return Status;
}

NTSTATUS
MRxIfsTransportUpdateHandler(
      PRXCE_TRANSPORT_NOTIFICATION pTransportNotification)
/*++

Routine Description:

    This routine is the callback handler that is invoked by the RxCe when transports
    are either enabled or disabled. It is further possible to extend this routine
    to provide feedback regarding the transports which can aid transport selection

Arguments:

    pTransportNotification - information pertaining to the transport

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    Currently, only connection oriented transports are handled. No feedback for
    transport selection has been implemented as yet.

--*/
{
   NTSTATUS Status;

   RXCE_TRANSPORT_HANDLE         hTransport;
   RXCE_TRANSPORT_EVENT          TransportEvent;
   PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;
   PUNICODE_STRING               pTransportName;

   hTransport     = pTransportNotification->hTransport;
   pProviderInfo  = pTransportNotification->pProviderInformation;
   pTransportName = pTransportNotification->pTransportName;

   ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

   switch (pTransportNotification->TransportEvent) {
   case TransportActivated:
      {
         ULONG   Priority;
         BOOLEAN fBindToTransport = FALSE;

         ASSERT(pProviderInfo != NULL);

         // if this is one of the transports that is of interest to the SMB
         // mini rdr then register the address with it, otherwise skip it.

         if (SmbCeContext.Transports.Length == 0) {
            // No transports were specfied. There are two options -- either
            // all the available transports can be used or none. Currently
            // the later option is implemented.
            Status = STATUS_SUCCESS;
         } else {
            PWSTR          pSmbMRxTransports = (PWSTR)SmbCeContext.Transports.Buffer;
            UNICODE_STRING SmbMRxTransport;

            Priority = 1;
            while (*pSmbMRxTransports) {
               SmbMRxTransport.Length = wcslen(pSmbMRxTransports) * sizeof(WCHAR);
               if (SmbMRxTransport.Length == pTransportName->Length) {
                  SmbMRxTransport.MaximumLength = SmbMRxTransport.Length;
                  SmbMRxTransport.Buffer = pSmbMRxTransports;

                  if (RtlCompareUnicodeString(
                           &SmbMRxTransport,
                           pTransportName,
                           TRUE) == 0) {
                     fBindToTransport = TRUE;
                     break;
                  }
               }

               pSmbMRxTransports += (SmbMRxTransport.Length / sizeof(WCHAR) + 1);
               Priority++;
            }
         }

         IF_DEBUG {
            if (!fBindToTransport) {
               DbgPrint("Ignoring Transport %ws\n",pTransportName->Buffer);
            }
         }

         if (fBindToTransport &&
             (pProviderInfo->ServiceFlags & TDI_SERVICE_CONNECTION_MODE) &&
             (pProviderInfo->ServiceFlags & TDI_SERVICE_ERROR_FREE_DELIVERY)) {
            // The connection capabilities match the capabilities required by the
            // SMB mini redirector. Attempt to register the local address with the
            // transport and if successful update the local transport list to include
            // this transport for future connection considerations.

            OEM_STRING   OemServerName;
            CHAR  TransportAddressBuffer[TDI_TRANSPORT_ADDRESS_LENGTH +
                                   TDI_ADDRESS_LENGTH_NETBIOS];
            PTRANSPORT_ADDRESS pTransportAddress = (PTRANSPORT_ADDRESS)TransportAddressBuffer;
            PTDI_ADDRESS_NETBIOS pNetbiosAddress = (PTDI_ADDRESS_NETBIOS)pTransportAddress->Address[0].Address;

            RXCE_ADDRESS_HANDLE hLocalAddress;

            pTransportAddress->TAAddressCount = 1;
            pTransportAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
            pTransportAddress->Address[0].AddressType   = TDI_ADDRESS_TYPE_NETBIOS;
            pNetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

            OemServerName.MaximumLength = NETBIOS_NAMESIZE;
            OemServerName.Buffer        = pNetbiosAddress->NetbiosName;

            Status = RtlUpcaseUnicodeStringToOemString(
                          &OemServerName,
                          &SmbCeContext.ComputerName,
                          FALSE);
            if (NT_SUCCESS(Status)) {
               // Ensure that the name is always of the desired length by padding
               // white space to the end.
               RtlCopyMemory(&OemServerName.Buffer[OemServerName.Length],
                             "                ",
                             NETBIOS_NAMESIZE - OemServerName.Length);

               OemServerName.Buffer[NETBIOS_NAMESIZE - 1] = '\0';
               // Register the Transport address for this mini redirector with the connection
               // engine.
               Status = RxCeRegisterClientAddress(
                                   hTransport,
                                   pTransportAddress,
                                   &MRxSmbVctAddressEventHandler,
                                   &SmbCeContext,
                                   &hLocalAddress);

               if (NT_SUCCESS(Status)) {
                  PSMBCE_TRANSPORT pTransport;

                  pTransport = SmbCeFindTransport(hTransport);
                  if (pTransport == NULL) {
                     pTransport = RxAllocatePoolWithTag(
                                       NonPagedPool,
                                       sizeof(SMBCE_TRANSPORT),
                                       MRXSMB_TRANSPORT_POOLTAG);
                     if (pTransport != NULL) {
                        RxDbgTrace( 0, Dbg, ("MRxSmbTransportUpdateHandler: Adding new transport\n"));
                        pTransport->hTransport   = hTransport;
                        pTransport->hAddress     = hLocalAddress;
                        pTransport->Active       = TRUE;
                        pTransport->Priority     = Priority;
                        pTransport->SwizzleCount = 1;

                        SmbCeAddTransport(pTransport);

                        //SmbCePnpBindBrowser(pTransportName);  // egb
                     } else {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                     }
                  } else {
                     SmbCeDereferenceTransport(pTransport);
                     ASSERT(!"Duplicate Transport binding Notification");
                     RxDbgTrace( 0, Dbg, ("MRxSmbTransportUpdateHandler: Duplicate Transport indication, Error In RxCe\n"));
                  }
               } else {
                  RxDbgTrace( 0, Dbg, ("MRxSmbTransportUpdateHandler: Address registration failed %lx\n",Status));
               }
            }
         } else {
            // The connection capabilities do not match the capabilities required.
            // Disregard the transport in future considerations
            RxDbgTrace( 0, Dbg, ("MRxSmbTransportUpdateHandler: Ignoring transport %lx because of insufficient capabilities\n",hTransport));
         }
      }
      break;
   case TransportDeactivated:
      {
         PSMBCE_TRANSPORT pTransport;

         pTransport = SmbCeFindTransport(hTransport);

         DbgPrint("****** TRANSPORT (%lx) being invalidated\n",pTransport);
         if (pTransport != NULL) {
            // Remove this transport from the list of transports under consideration
            // in the mini redirector.

            SmbCeRemoveTransport(pTransport);

            // Enumerate the servers and mark those servers utilizing this transport
            // as having an invalid transport.

            SmbCeHandleTransportInvalidation(pTransport);

            // Deregister the address associated with the transport and uninitialize it
            RxCeDeregisterClientAddress(pTransport->hAddress);
            RxFreePool(pTransport);
         }

         DbgPrint("****** TRANSPORT (%lx) invalidated\n",pTransport);
      }
      break;
   case TransportStatusUpdate:
      break;
   default:
      break;
   }

   return Status;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\transprt.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    transport.c

Abstract:

    This module implements all transport related functions in the SMB connection
    engine

--*/

#ifndef _TRANSPRT_H_
#define _TRANSPRT_H_

// The SMBCE_TRANSPORT data structure encapsulates all the information w.r.t a
// particular transport for the connection engine. All the transports that are
// of interest to the SMB mini redirector are maintained in a doubly linked list
//
// The connection engine tries all the transports in this list when trying to
// establish a connection to a server. Currently only connection oriented
// transports are handled.

typedef struct _SMBCE_TRANSPORT_ {
   SMBCE_OBJECT_HEADER;

   LIST_ENTRY              TransportsList;
   RXCE_TRANSPORT_HANDLE   hTransport;
   RXCE_ADDRESS_HANDLE     hAddress;
   ULONG                   Priority;       // the priority in the binding list.

   BOOLEAN                 Active;

   // Additional information regarding quality of service and other selection
   // criterion for a transport will be included here.

} SMBCE_TRANSPORT, *PSMBCE_TRANSPORT;

typedef struct _SMBCE_TRANSPORTS_ {
   RX_SPIN_LOCK  Lock;
   LONG          Count;
   LIST_ENTRY    ListHead;
} SMBCE_TRANSPORTS, *PSMBCE_TRANSPORTS;

extern SMBCE_TRANSPORTS MRxSmbTransports;

// Transport entries are added to the list of known transports upon receipt of
// PnP notifications. Currently the list is static since transport disabling
// notifications are not handled by the underlying TDI/PnP layer.
// The following routines provide the ability for adding/deleting entries to
// this list.

extern VOID
SmbCeAddTransport(PSMBCE_TRANSPORT pTransport);

extern VOID
SmbCeRemoveTransport(PSMBCE_TRANSPORT pTransport);

extern
PSMBCE_TRANSPORT
SmbCeGetNextTransport(PSMBCE_TRANSPORT pTransport);

// The connection engine maintains a reference count associated with each transport
// which indicates the number of servers that are using the transport. This will
// eventually provide the mechanism for disabling/enabling transport on receipt
// of PnP notifications.

#define SmbCeReferenceTransport(pTransport)                                   \
        InterlockedIncrement(&pTransport->SwizzleCount)

#define SmbCeDereferenceTransport(pTransport)                                 \
        InterlockedDecrement(&pTransport->SwizzleCount)


// The server transport types encapsulate the various usages of the underlying
// transport to communicate with a server. For example the type of interactions
// with a mailslot server ( primarily datagrams ) is very different from the
// interactions with a FILE SERVER ( connection oriented send/receives). The
// type of interactions can be further classified by the underlying connection
// characterstics, e.g., connecting to a FILE_SERVER over a RAS connection as
// opposed to connecting to a file server over EtherNet.
//
// The interactions are currently classified into four types, MAILSOT, Virtual
// Circuit, Datagram and Htbrid ( VC + Datagram ).
//
// The type chosen will depend upon the characterstics of the available
// connection. Each type is associated with its own dispatch vector which
// encapsulates the interaction between the connection engine and the transport.
//
// This includes Send,Receive, Receive Ind. etc. These are modelled after the
// TDI interfaces.

typedef enum _SMBCE_SERVER_TRANSPORT_TYPE_ {
   SMBCE_STT_MAILSLOT,
   SMBCE_STT_VC,
   SMBCE_STT_DATAGRAM,
   SMBCE_STT_HYBRID
} SMBCE_SERVER_TRANSPORT_TYPE, *PSMBCE_SERVER_TRANSPORT_TYPE;

typedef struct SMBCE_SERVER_TRANSPORT {
   SMBCE_OBJECT_HEADER;

   struct TRANSPORT_DISPATCH_VECTOR *pDispatchVector;
   struct _SMBCE_TRANSPORT_         *pTransport;

   PKEVENT                          pRundownEvent;      // used for finalization.

   ULONG                            MaximumSendSize;    // max data size for bulk I/O
} SMBCE_SERVER_TRANSPORT, *PSMBCE_SERVER_TRANSPORT;

// The SMBCE_SERVER_TRANSPORT instances are reference counted. The following
// routines provide the referencing mechanism. Defining them as macros also
// provides us with a easy debugging capability, i.e., it can be easily modified
// to include a FILE/LINE number each time an instance is referenced and
// dereferenced

#define SmbCeReferenceServerTransport(pServerEntry)                    \
        SmbCepReferenceServerTransport(pServerEntry)

#define SmbCeDereferenceServerTransport(pServerEntry)                  \
        SmbCepDereferenceServerTransport(pServerEntry)

// The SERVER transport dispatch vector prototypes

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_SEND)(
   PSMBCEDB_SERVER_ENTRY   pServerEntry,
   ULONG                   SendOptions,
   PMDL                    pSmbMdl,
   ULONG                   SendLength,
   PVOID                   pSendCompletionContext);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_SEND_DATAGRAM)(
   PSMBCEDB_SERVER_ENTRY   pServerEntry,
   ULONG                   SendOptions,
   PMDL              pSmbMdl,
   ULONG                   SendLength,
   PVOID                   pSendCompletionContext);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_TRANCEIVE)(
   PSMBCEDB_SERVER_ENTRY   pServerEntry,
   PSMB_EXCHANGE           pExchange,
   ULONG                   SendOptions,
   PMDL              pSmbMdl,
   ULONG                   SendLength,
   PVOID                   pSendCompletionContext);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_RECEIVE)(
   PSMBCEDB_SERVER_ENTRY   pServerEntry,
   PSMB_EXCHANGE           pExchange);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_INITIALIZE_EXCHANGE)(
   PSMB_EXCHANGE         pExchange);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_UNINITIALIZE_EXCHANGE)(
   PSMB_EXCHANGE         pExchange);

typedef
VOID
(*PTRANSPORT_DISPATCH_TEARDOWN)(
   PSMBCE_SERVER_TRANSPORT    pTransport);

typedef struct TRANSPORT_DISPATCH_VECTOR {
   PTRANSPORT_DISPATCH_SEND                  Send;
   PTRANSPORT_DISPATCH_SEND_DATAGRAM         SendDatagram;
   PTRANSPORT_DISPATCH_TRANCEIVE             Tranceive;
   PTRANSPORT_DISPATCH_RECEIVE               Receive;
   PRX_WORKERTHREAD_ROUTINE                  TimerEventHandler;
   PTRANSPORT_DISPATCH_INITIALIZE_EXCHANGE   InitializeExchange;
   PTRANSPORT_DISPATCH_UNINITIALIZE_EXCHANGE UninitializeExchange;
   PTRANSPORT_DISPATCH_TEARDOWN              TearDown;
} TRANSPORT_DISPATCH_VECTOR, *PTRANSPORT_DISPATCH_VECTOR;

// A macro for invoking a routine through the SMBCE_SERVER_TRANSPORT
// dispatch vector.

#define SMBCE_TRANSPORT_DISPATCH(pServerEntry,Routine,Arguments)        \
      (*((pServerEntry)->pTransport->pDispatchVector->Routine))##Arguments

// The currently known transport type dispatch vectors and the mechanisms
// for instanting an instance.

extern TRANSPORT_DISPATCH_VECTOR MRxSmbVctTransportDispatch;
extern TRANSPORT_DISPATCH_VECTOR MRxSmbMsTransportDispatch;

extern NTSTATUS
MsInstantiateServerTransport(
   IN OUT PSMBCEDB_SERVER_ENTRY   pServerEntry,
   OUT    PSMBCE_SERVER_TRANSPORT *pServerTransportPtr);

extern NTSTATUS
VctInstantiateServerTransport(
   IN OUT PSMBCEDB_SERVER_ENTRY   pServerEntry,
   OUT    PSMBCE_SERVER_TRANSPORT *pServerTransportPtr);

// The following routines constitute the interface by which the clients of
// the connection engine initialize/send/receive/uninitialize data to the
// remote servers

extern NTSTATUS
SmbCeInitializeServerTransport(
   IN OUT PSMBCEDB_SERVER_ENTRY pServerEntry);

extern NTSTATUS
SmbCeUninitializeServerTransport(
   IN OUT PSMBCEDB_SERVER_ENTRY pServerEntry);

extern NTSTATUS
SmbCepReferenceServerTransport(
   IN OUT PSMBCEDB_SERVER_ENTRY pServerEntry);

extern NTSTATUS
SmbCepDereferenceServerTransport(
   IN OUT PSMBCEDB_SERVER_ENTRY pServerEntry);

//
// INLINE functions to hide dispatch vector related details for invoking Transport methods
//



INLINE NTSTATUS
SmbCeInitializeExchangeTransport(
   PSMB_EXCHANGE         pExchange)
{
   if (pExchange->SmbStatus == STATUS_SUCCESS) {
      if (pExchange->SmbCeContext.pServerEntry->pTransport != NULL) {
         pExchange->SmbCeFlags |= SMBCE_EXCHANGE_TRANSPORT_INITIALIZED;
         return (pExchange->SmbCeContext.pServerEntry->pTransport->pDispatchVector->InitializeExchange)(
                      pExchange);
      } else {
         return STATUS_CONNECTION_DISCONNECTED;
      }
   } else {
      return pExchange->SmbStatus;
   }
}


INLINE NTSTATUS
SmbCeUninitializeExchangeTransport(
   PSMB_EXCHANGE         pExchange)
{
   if (FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_TRANSPORT_INITIALIZED)) {
      if (pExchange->SmbCeContext.pServerEntry->pTransport != NULL) {
         return (pExchange->SmbCeContext.pServerEntry->pTransport->pDispatchVector->UninitializeExchange)(
                     pExchange);
      } else {
         return STATUS_CONNECTION_DISCONNECTED;
      }
   } else {
      return pExchange->SmbStatus;
   }
}

extern NTSTATUS
SmbCeSend(
   PSMB_EXCHANGE         pExchange,
   ULONG                 SendOptions,
   PMDL            pSmbMdl,
   ULONG                 SendLength);

extern NTSTATUS
SmbCeSendToServer(
   PSMBCEDB_SERVER_ENTRY pServerEntry,
   ULONG                 SendOptions,
   PMDL            pSmbMdl,
   ULONG                 SendLength);

extern NTSTATUS
SmbCeSendDatagram(
   PSMB_EXCHANGE         pExchange,
   ULONG                 SendOptions,
   PMDL            pSmbMdl,
   ULONG                 SendLength);

extern NTSTATUS
SmbCeTranceive(
   PSMB_EXCHANGE         pExchange,
   ULONG                 SendOptions,
   PMDL            pRxCeDataBuffer,
   ULONG                 SendLength);

extern NTSTATUS
SmbCeReceive(
   PSMB_EXCHANGE         pExchange);


//
// Call ups from the transport to the connection engine
//

extern NTSTATUS
SmbCeReceiveInd(
      IN PSMBCEDB_SERVER_ENTRY pServerEntry,
      IN ULONG                 BytesIndicated,
      IN ULONG                 BytesAvailable,
      OUT ULONG                *pBytesTaken,
      IN PVOID                 pTsdu,                  // pointer describing this TSDU, typically a lump of bytes
      OUT PMDL                 *pDataBufferPointer,    // the buffer in which data is to be copied.
      OUT PULONG               pDataBufferSize         // amount of data to copy
     );

extern NTSTATUS
SmbCeDataReadyInd(
   IN PSMBCEDB_SERVER_ENTRY pServerEntry,
   IN PMDL            pBuffer,
   IN ULONG                 DataSize,
   IN NTSTATUS              DataReadyStatus
   );

extern NTSTATUS
SmbCeErrorInd(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN NTSTATUS              IndicatedStatus
    );

extern NTSTATUS
SmbCeSendCompleteInd(
   IN PSMBCEDB_SERVER_ENTRY pServerEntry,
   IN PVOID                 pCompletionContext,
   IN NTSTATUS              SendCompletionStatus
   );

#endif // _TRANSPRT_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\vcsndrcv.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    vcsndrcv.h

Abstract:

    This is the include file that defines all constants and types for VC
    (Virtual Circuit) related Send/Receive/INitialization etc.

--*/

#ifndef _VCSNDRCV_H_
#define _VCSNDRCV_H_

// The connection oriented transport to a server can utilize multiple VC's to
// acheive better throughput to a server. It is for this reason that the
// VC transport data structure is built around multiple VC's. Howvever this
// feature is not utilized currently.

typedef struct SMBCE_VC_ENTRY {
    SMBCE_OBJECT_HEADER;                // the struct header
    NTSTATUS               Status;      // Status of the VC.
    LIST_ENTRY             VcsList;     // the next VC for the server
    SMBCEDB_REQUESTS       Requests;    // the list of outstanding request on this VC
    SMBCE_VC               Vc;          // the VC.
} SMBCE_VC_ENTRY, *PSMBCE_VC_ENTRY;

typedef struct _SMBCE_VCS_ {
    LIST_ENTRY       ListHead;
} SMBCE_VCS, *PSMBCE_VCS;

typedef struct SMBCE_SERVER_VC_TRANSPORT {
    SMBCE_SERVER_TRANSPORT;     // Anonymous struct for common fields

    RXCE_CONNECTION_HANDLE      hConnection;     // the connection handle
    ULONG                       MaximumNumberOfVCs;
    SMBCE_VCS                   Vcs;             // Additional Vcs associated with the connection.
    LARGE_INTEGER               Delay;           // the estimated delay on the connection
} SMBCE_SERVER_VC_TRANSPORT, *PSMBCE_SERVER_VC_TRANSPORT;


// The following routines provide the necessary mechanisms for manipulating
// the list of VC's. Most of them come inn two flavours a original and Lite
// version. The Lite version avoids the acquisition of Spin Lock on every
// operation, thereby providing an efficient batching mechanism.

#define VctAddVcEntry(pVcs,pEntry)                               \
           VctAcquireSpinLock();                                 \
           InsertTailList(&(pVcs)->ListHead,&(pEntry)->VcsList); \
           VctReleaseSpinLock()

#define VctAddVcEntryLite(pVcs,pEntry)                           \
           InsertTailList(&(pVcs)->ListHead,&(pEntry)->VcsList)


#define VctRemoveVcEntry(pVcs,pEntry)                    \
                  VctAcquireSpinLock();                  \
                  RemoveEntryList(&(pVcEntry)->VcsList); \
                  VctReleaseSpinLock()

#define VctRemoveVcEntryLite(pVcs,pEntry)                \
                  RemoveEntryList(&(pVcEntry)->VcsList)

#define VctReferenceVcEntry(pVcEntry)                           \
            InterlockedIncrement(&(pVcEntry)->SwizzleCount)

#define VctReferenceVcEntryLite(pVcEntry)                       \
            ASSERT(SmbCeSpinLockAcquired());                    \
            (pVcEntry)->SwizzleCount++


#define VctDereferenceVcEntry(pVcEntry)                           \
            InterlockedDecrement(&(pVcEntry)->SwizzleCount)

#define VctDereferenceVcEntryLite(pVcEntry)                       \
            ASSERT(SmbCeSpinLockAcquired());                    \
            (pVcEntry)->SwizzleCount--


#define VctGetFirstVcEntry(pVcs)                          \
            (IsListEmpty(&(pVcs)->ListHead)               \
             ? NULL                                       \
             : (PSMBCE_VC_ENTRY)                        \
               (CONTAINING_RECORD((pVcs)->ListHead.Flink, \
                                  SMBCE_VC_ENTRY,       \
                                  VcsList)))


#define VctGetNextVcEntry(pVcs,pVcEntry)                       \
            (((pVcEntry)->VcsList.Flink == &(pVcs)->ListHead)  \
             ? NULL                                            \
             : (PSMBCE_VC_ENTRY)                             \
               (CONTAINING_RECORD((pVcEntry)->VcsList.Flink,   \
                                  SMBCE_VC_ENTRY,            \
                                  VcsList)))


#define VctTransferVcs(pVcTransport,pVcs)                            \
            if (IsListEmpty(&(pVcTransport->Vcs.ListHead))) {        \
               InitializeListHead(&(pVcs)->ListHead);              \
            } else {                                                 \
               *(pVcs) = (pVcTransport)->Vcs;                        \
               (pVcs)->ListHead.Flink->Blink = &(pVcs)->ListHead;    \
               (pVcs)->ListHead.Blink->Flink = &(pVcs)->ListHead;    \
               InitializeListHead(&((pVcTransport)->Vcs.ListHead));         \
            }


#define VctAcquireResource()  SmbCeAcquireResource()

#define VctReleaseResource()  SmbCeReleaseResource()

#define VctAcquireSpinLock()  SmbCeAcquireSpinLock()

#define VctReleaseSpinLock()  SmbCeReleaseSpinLock()

#define VctSpinLockAcquired() SmbCeSpinLockAcquired()


#endif // _VCSNDRCV_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\stuffer.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Stuffer.c

Abstract:

    This module implements the SMBstuffer formating primitives. the following controlstring
    characters are defined for the stuffer: (** means nyi...**d means downlevel part not implemented)

      0     placeholder for the wct
      1     pad to word boundary
      X     placeholderfor&X
      W,w   format a word from the next parameter
      D,d   format the next parameter as a Dword
      Y,y   format the next parameter as a byte
      L,l   the next parameter is a PLARGE_INTEGER; format it in
      M,m   format a zero byte
  **  2     the next parameter points to a tagged dialect ASCIZI string to be copied in
  **  3     the next parameter points to a tagged devicename ASCIIZ string
      4     the next parameter is either 04-tagged ASCIIZ or UNICODEZ as determined by flags2
      >     the next parameters is ASCIIZ or UNICODEZ as determined by flags2; it is to be appended
                              to the previous 04-tagged item by backing up over the previous null.
      A,a   the next parameter is an ASCIIZ string
      U,u   the next parameter is a UNICODEZ string
      V,v   the next parameter is a UNICODEnoZ string
      z     the next parameter is a PUNICODE_STRING to be stringed as ASCIZI
            or UNICODEZ as determined by flags2
      N,n   the next parameter is a PNET_ROOT whose name is to be stringed as ASCIIZ
            or UNICODEZ as determined by flags2
      R,r   the next 2 parameters are a PBYTE* and a size; reserve the region and store the pointer
      Q,q   the current position is the data offset WORD...remember it
      5     the current position is the start of the data; fill in the data pointer
  **  P,p   the current position is the parameter offset WORD...remember it
  **  6     the current position is the start of the parameters; fill in the param pointer
      B,b   the current position is the Bcc WORD...remember it; also, fill in wct
      s     the next parameter has the alignment information....pad accordingly
      S     pad to DWORD
      c     the next 2 parameters are count/addr...copy in the data.
      !     End of this protocol; fill in the bcc field
      ?     next parameter is BOOLEAN_ULONG; 0=>immediate return
      .     NOOP

    For controls with a upper/lowercase pair, the uppercase version indicates that a position tag
    is supplied in the checked version.


--*/

#include "precomp.h"
#pragma hdrstop
#include <stdio.h>
#include <stdarg.h>

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_ALWAYS)


#define MRXSMB_INITIAL_WCT  (0xcc)
#define MRXSMB_INITIAL_BCC  (0xface)
#define MRXSMB_INITIAL_DATAOFFSET  (0xd0ff)
#define MRXSMB_INITIAL_PARAMOFFSET (0xb0ff)
#define MRXSMB_INITIAL_ANDX (0xdede00ff)

#if 0
//this is old...........
#if DBG

// a little presto-changeo to get assert messages in user mode
// the key is that MRxSmbRxImports->pRxNetNameTable will not be NULL...
// it will point to the netnametable. this
// seems like a small enough price to pay on the way to an rtl assert!

VOID
SmbStuffWrapRtlAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    )

{
    char STARS[] = "**************************************";
    if (MRxSmbRxImports->pRxNetNameTable == NULL){
        // do our own thing
        RxDbgTrace(0,Dbg,("%s\n%s\n",STARS,STARS));
        RxDbgTrace (0,Dbg,("Failed Assertion %s\n",FailedAssertion));
        RxDbgTrace(0,Dbg,("%s at line %lu\n",FileName,LineNumber));
        if (Message) {
            RxDbgTrace (0,Dbg,("%s\n",Message));
        }
        RxDbgTrace(0,Dbg,("%s\n%s\n",STARS,STARS));
    } else RtlAssert(FailedAssertion,FileName,LineNumber,Message);
}

#ifdef RtlAssert
#undef RtlAssert
#endif //ifdef RtlAssert
#define RtlAssert SmbStuffWrapRtlAssert

#endif
#endif //if 0


NTSTATUS
SmbMrxInitializeStufferFacilities(
    void
    )
/*++
Routine Description:

     This routine initializes things for the SMB minirdr. we will allocate enough stuff
     to get us going. right now....we do nothing.

Arguments:

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    return(STATUS_SUCCESS);
}

NTSTATUS
SmbMrxFinalizeStufferFacilities(
    void
    )
/*++
Routine Description:

     This routine finalizes things for the SMB minirdr. we give back everything that
     we have allocated. right now....we do nothing.

Arguments:

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    return(STATUS_SUCCESS);
}
#if DBG
#define BUILD_HEADER_ROUTINE BuildHeaderRoutine
typedef
NTSTATUS
(NTAPI *PMRXSMB_BUILD_HEADER_ROUTINE) (
      PSMB_EXCHANGE     pExchange,
      PVOID             pBuffer,
      ULONG             BufferLength,
      PULONG            pBufferConsumed,
      PUCHAR            pLastCommandInHeader,
      PUCHAR            *pNextCommandPtr
    );
#else
#define BUILD_HEADER_ROUTINE SmbCeBuildSmbHeader
#endif

NTSTATUS
MRxSmbSetInitialSMB (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState
    STUFFERTRACE_CONTROLPOINT_ARGS
    )
{
    NTSTATUS       Status;
    PNT_SMB_HEADER NtSmbHeader;
    ULONG          BufferConsumed;
    PBYTE          ScanPosition;
    PUCHAR         pCommand;

#if DBG
    PMRXSMB_BUILD_HEADER_ROUTINE BUILD_HEADER_ROUTINE = SmbCeBuildSmbHeader;
#endif //if DBG

    ASSERT ( StufferState != NULL );
    ASSERT ( sizeof(NT_SMB_HEADER) == sizeof(SMB_HEADER) );
    ASSERT ( (StufferState->BufferLimit - StufferState->BufferBase) > sizeof(SMB_HEADER));
    NtSmbHeader = (PNT_SMB_HEADER)(StufferState->BufferBase);
    RtlZeroMemory(NtSmbHeader,sizeof(NT_SMB_HEADER));

    //this stuff is reinitialized
    StufferState->DataMdl = NULL; //note that this is not finalized or anything
    StufferState->DataSize = 0;
    StufferState->CurrentWct = NULL;
    StufferState->PreviousCommand = SMB_COM_NO_ANDX_COMMAND;
    StufferState->CurrentCommand = SMB_COM_NO_ANDX_COMMAND;
    StufferState->FlagsCopy = 0;
    StufferState->Flags2Copy = 0;
    StufferState->CurrentPosition = ((PBYTE)NtSmbHeader);

    RxDbgTraceDoit(
            StufferState->ControlPoint = ControlPoint;
            StufferState->PrintCLoop = FALSE;
            StufferState->PrintFLoop = FALSE;
            while (EnablePrints) {
                ULONG c = EnablePrints & 0xff;
                EnablePrints >>= 8;
                if (c=='C') StufferState->PrintCLoop = TRUE;
                if (c=='F') StufferState->PrintFLoop = TRUE;
                if (c=='X') BUILD_HEADER_ROUTINE = MRxSmbBuildSmbHeaderTestSurrogate;
            }
    )

    Status = BUILD_HEADER_ROUTINE(
                  StufferState->Exchange,
                  NtSmbHeader,
                  (StufferState->BufferLimit - StufferState->BufferBase),
                  &BufferConsumed,
                  &StufferState->PreviousCommand,
                  &pCommand);

    if (Status!=STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg, ("MrxSMBSetInitialSMB  buildhdr failure st=%08lx\n",Status));
        RxLog(("BuildHdr failed %lx %lx",StufferState->Exchange,Status));
        return Status;
    }

    //copy the flags
    StufferState->FlagsCopy = NtSmbHeader->Flags;
    StufferState->Flags2Copy = SmbGetAlignedUshort(&NtSmbHeader->Flags2);
    if (StufferState->Exchange->Type == ORDINARY_EXCHANGE) {
       PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)StufferState->Exchange;
       if (BooleanFlagOn(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_TURNON_DFS_FLAG)) {
          StufferState->Flags2Copy |= SMB_FLAGS2_DFS;
          SmbPutUshort(&NtSmbHeader->Flags2,(USHORT)StufferState->Flags2Copy);
       }
    }

    StufferState->CurrentPosition += BufferConsumed;

    if (BufferConsumed > sizeof(SMB_HEADER)) {
       *pCommand = SMB_COM_NO_ANDX_COMMAND;
       StufferState->CurrentWct = StufferState->CurrentPosition;
    }

    return Status;
}

#define RETURN_A_START_PROBLEM(xxyy) {\
        RxDbgTrace(0,Dbg,("MRxSmbStartSMBCommand gotta problem= %lu\n",xxyy));   \
        StufferState->SpecificProblem = xxyy;       \
        return(STATUS_INVALID_PARAMETER);        \
}
NTSTATUS
MRxSmbStartSMBCommand (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     INITIAL_SMBBUG_DISPOSITION InitialSMBDisposition,
    IN UCHAR Command,
    IN ULONG MaximumBufferUsed,
    IN ULONG MaximumSize,
    IN ULONG InitialAlignment,
    IN ULONG MaximumResponseHeader,
    IN UCHAR Flags,
    IN UCHAR FlagsMask,
    IN USHORT Flags2,
    IN USHORT Flags2Mask
    STUFFERTRACE_CONTROLPOINT_ARGS
    )
/*++

Routine Description:

    The routine checks to see if the condition is stable. If not, it
    goes into a wait loop alternately getting the resource and then
    waiting on the event.


Arguments:
     StufferState - the header buffer being used
     InitialSMBDisposition tells when/if to reinit the stuffer state
     Command - the smb command being set up
     MaximumBufferUsed - the amount of the header buffer that will be used (as opposed to the data)
                         this has to be conjured up in advance. if you're not willing to do this, then
                         just push out the current smb. this value should include any data pads!
     MaximumSize - the size of the data. this is to keep from overrunning the srv's smbbuf
     InitialAlignment - a compound argument (i.e. you get it from a constant) the top half
                        tells the alignment unit and the bottom gives the spacing within
     MaximumResponseHeader - how much of the srv's response buffer this will use up
     Flags - the required flags settings
     FlagsMask - which bits of the flags are important
     Flags2 - the required flags2 settings
     Flags2Mask - which flags2 bits are important

Return Value:

    none.

--*/
{
    UCHAR NewFlags;
    USHORT NewFlags2;
    PBYTE *CurrentPosition = &(StufferState->CurrentPosition);
    PNT_SMB_HEADER NtSmbHeader = (PNT_SMB_HEADER)(StufferState->BufferBase);
    ULONG AlignmentUnit = InitialAlignment >> 16;
    ULONG StufferStateRequirement = MaximumBufferUsed + AlignmentUnit;
#if DBG
    PBYTE OriginalPosition = *CurrentPosition;
#endif

    if (StufferState->DataSize) {
        StufferState->SpecificProblem = xSMBbufSTATUS_CANT_COMPOUND;
        return(STATUS_INVALID_PARAMETER);
    }

    if ((InitialSMBDisposition==SetInitialSMB_yyUnconditionally)
        || ((InitialSMBDisposition==SetInitialSMB_ForReuse)&&(StufferState->Started))) {
        MRxSmbSetInitialSMB( StufferState STUFFERTRACE_NOPREFIX(ControlPoint,EnablePrints) );
    }

    StufferState->Started = TRUE;

    switch (StufferState->CurrentCommand) {
    case SMB_COM_LOCKING_ANDX:
    case SMB_COM_OPEN_ANDX:
    case SMB_COM_READ_ANDX:
    case SMB_COM_WRITE_ANDX:
    case SMB_COM_SESSION_SETUP_ANDX:
    //case SMB_COM_LOGOFF_ANDX:
    case SMB_COM_TREE_CONNECT_ANDX:
    case SMB_COM_NT_CREATE_ANDX:
    case SMB_COM_NO_ANDX_COMMAND:
        break;
    default:
        StufferState->SpecificProblem = xSMBbufSTATUS_CANT_COMPOUND;
        return(STATUS_INVALID_PARAMETER);
    }

    if (*CurrentPosition+StufferStateRequirement >= StufferState->BufferLimit ) {
        StufferState->SpecificProblem = xSMBbufSTATUS_CANT_COMPOUND;
        return(STATUS_INVALID_PARAMETER);
    }

    if (StufferState->RxContext) {
        PRX_CONTEXT RxContext = StufferState->RxContext;
        PMRX_SRV_CALL SrvCall;
        ULONG CurrentOffset;
        if (RxContext->pFcb) {
            SrvCall = RxContext->pFcb->pNetRoot->pSrvCall;
        } else {
            SrvCall = RxContext->Create.pSrvCall;
        }
        ASSERT(SrvCall);
        CurrentOffset = *CurrentPosition - StufferState->BufferBase;
        if (CurrentOffset+StufferStateRequirement+MaximumSize
                    > GetServerMaximumBufferSize(SrvCall) ) {
            StufferState->SpecificProblem = xSMBbufSTATUS_SERVER_OVERRUN;
            return(STATUS_INVALID_PARAMETER);
        }
    }

    NewFlags = Flags | (UCHAR)(StufferState->FlagsCopy);
    NewFlags2 = Flags2 | (USHORT)(StufferState->Flags2Copy);
    if ( ((NewFlags&FlagsMask)!=Flags) ||
         ((NewFlags2&Flags2Mask)!=Flags2) ) {
        StufferState->SpecificProblem = xSMBbufSTATUS_FLAGS_CONFLICT;
        return(STATUS_INVALID_PARAMETER);
    }
    StufferState->FlagsCopy = NtSmbHeader->Flags = NewFlags;
    StufferState->Flags2Copy = NewFlags2;
    SmbPutAlignedUshort(&NtSmbHeader->Flags2, NewFlags2);

    if (!StufferState->CurrentWct) {
        NtSmbHeader->Command = Command;
    } else {
        PGENERIC_ANDX GenericAndX = (PGENERIC_ANDX)StufferState->CurrentWct;
        if (AlignmentUnit) {
            ULONG AlignmentMask = (AlignmentUnit-1);
            ULONG AlignmentResidue = InitialAlignment&AlignmentMask;
            RxDbgTrace(0, Dbg, ("Aligning start of smb cp&m,m,r=%08lx %08lx %08lx\n",
                                 ((ULONG)(*CurrentPosition))&AlignmentMask,
                                 AlignmentMask, AlignmentResidue)
                       );
            for (;(((ULONG)(*CurrentPosition))&AlignmentMask)!=AlignmentResidue;) {
                **CurrentPosition = ',';
                *CurrentPosition += 1;
            }
        }
        GenericAndX->AndXCommand = Command;
        GenericAndX->AndXReserved = 0;
        SmbPutUshort (&GenericAndX->AndXOffset,
                      (USHORT)(*CurrentPosition - StufferState->BufferBase));
    }
    StufferState->CurrentWct = *CurrentPosition;
    StufferState->CurrentCommand = Command;
    StufferState->CurrentDataOffset = 0;
    return STATUS_SUCCESS;
}

BOOLEAN
MrxSMBWillThisFit(
    IN PSMBSTUFFER_BUFFER_STATE StufferState,
    IN ULONG AlignmentUnit,
    IN ULONG DataSize
    )
{
    return(StufferState->CurrentPosition+AlignmentUnit+DataSize<StufferState->BufferLimit);
}

#if RDBSSTRACE
#define StufferFLoopTrace(Z) { if (StufferState->PrintFLoop) {RxDbgTraceLV__norx(0,StufferState->ControlPoint,900,Z);}}
#define StufferCLoopTrace(Z) { if (StufferState->PrintCLoop) {RxDbgTraceLV__norx(0,StufferState->ControlPoint,800,Z);}}
#else // DBG
#define StufferFLoopTrace(Z)
#define StufferCLoopTrace(Z)
#endif // DBG

NTSTATUS
MRxSmbStuffSMB (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    ...
    )
{
    va_list AP;
    PBYTE BufferBase = (StufferState->BufferBase);
    PBYTE *CurrentPosition = &(StufferState->CurrentPosition);
    PBYTE *CurrentWct = &(StufferState->CurrentWct);
    PBYTE *CurrentBcc = &(StufferState->CurrentBcc);
    PBYTE *CurrentDataOffset = &(StufferState->CurrentDataOffset);
    PBYTE *CurrentParamOffset = &(StufferState->CurrentParamOffset);
    SMB_STUFFER_CONTROLS CurrentStufferControl = STUFFER_CTL_NORMAL;
    PSMB_HEADER SmbHeader = (PSMB_HEADER)BufferBase;
    PSZ CurrentFormatString = NULL;
    ULONG arg;
    UCHAR WordCount;
    USHORT ByteCount;
#define PADBYTE ((UCHAR)0xee)
    PBYTE CopyPtr; ULONG CopyCount,EarlyReturn;
    PBYTE *RegionPtr;
    PUNICODE_STRING Zstring;
    PSZ Astring;
    PNET_ROOT NetRoot;
    PLARGE_INTEGER LargeInteger;
    PBYTE PreviousPosition;
#if DBG
    ULONG offset, required_WCT;
    ULONG CurrentOffset_tmp;
#endif

    va_start(AP,StufferState);
    for (;;) {
        switch (CurrentStufferControl) {
        case STUFFER_CTL_SKIP:
        case STUFFER_CTL_NORMAL:
            CurrentFormatString = va_arg(AP,PSZ);
            StufferCLoopTrace(("StufferAC = %s\n",CurrentFormatString));
            ASSERT (CurrentFormatString);
            for (;*CurrentFormatString;CurrentFormatString++) {
                char CurrentFormatChar = *CurrentFormatString;
#if DBG
                { char msgbuf[80];
                switch (CurrentFormatChar) {
                case 'W': case 'w':
                case 'D': case 'd':
                case 'Y': case 'y':
                case 'M': case 'm':
                case 'L': case 'l':
                case 'c': case '4': case '>':
                case '!':
                    //this guys are skipable
                    break;
                default:
                    if (CurrentStufferControl != STUFFER_CTL_SKIP) break;
                    DbgPrint("Bad skip char '%c'\n",*CurrentFormatString);
                    DbgBreakPoint();
                }}
                //these are the ones that we do the offset check for
                { char msgbuf[80];

                RxSprintf(msgbuf,"control char '%c'\n",*CurrentFormatString);

                switch (CurrentFormatChar) {
                case 'W': case 'D': case 'Y': case 'M': case 'B':
                case 'Q': case 'A': case 'U': case 'V':
                case 'N':
                case 'L':
                case 'R':
                case 'P':
                    offset = va_arg(AP,ULONG);
                    required_WCT = offset>>16;
                    offset = offset & 0xffff;
                    CurrentOffset_tmp = *CurrentPosition-*CurrentWct;
                    if (offset && (offset != CurrentOffset_tmp)){
                        DbgPrint("Bad offset %d; should be %d\n",offset,CurrentOffset_tmp);
                        DbgBreakPoint();
                    }
                    break;
                default:
                    break;
                }}
#endif
                switch (CurrentFormatChar) {
                case '0':
                    StufferFLoopTrace(("  StufferFloop '0'\n",0));
                    //just do the wct field...
                    **CurrentPosition = (UCHAR)MRXSMB_INITIAL_WCT;
                    *CurrentPosition+=1;
                    break;
                case 'X':
                    StufferFLoopTrace(("  StufferFloop 'X'\n",0));
                    //do the wct field and the &x
                    **CurrentPosition = (UCHAR)MRXSMB_INITIAL_WCT;
                    *CurrentPosition+=1;
                    SmbPutUlong (*CurrentPosition, (ULONG)MRXSMB_INITIAL_ANDX);
                    *CurrentPosition+=sizeof(ULONG);
                    break;
                case 'W':
                case 'w':
                    arg = va_arg(AP,ULONG);
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'w' arg=%lu\n",arg));
                    SmbPutUshort (*CurrentPosition, (USHORT)arg);
                    *CurrentPosition+=sizeof(USHORT);
                    break;
                case 'Y':
                case 'y':
                    arg = va_arg(AP,UCHAR);
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'y' arg=%lu\n",arg));
                    **CurrentPosition =  (UCHAR)arg;
                    *CurrentPosition+=sizeof(UCHAR);
                    break;
                case 'M':
                case 'm':
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'm'\n",0));
                    **CurrentPosition =  0;
                    *CurrentPosition+=sizeof(UCHAR);
                    break;
                case 'D':
                case 'd':
                    arg = va_arg(AP,ULONG);
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'd' arg=%lu\n",arg));
                    SmbPutUlong (*CurrentPosition, arg);
                    *CurrentPosition+=sizeof(ULONG);
                    break;
                case 'L':
                case 'l':
                    LargeInteger = va_arg(AP,PLARGE_INTEGER);
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'l' arg=%0lx %0lx\n",
                            LargeInteger->HighPart, LargeInteger->LowPart));
                    SmbPutUlong (*CurrentPosition, LargeInteger->LowPart);
                    SmbPutUlong (*CurrentPosition, LargeInteger->HighPart);
                    *CurrentPosition+=2*sizeof(ULONG);
                    break;
                case 'B':
                case 'b':
                    ASSERT (**CurrentWct == MRXSMB_INITIAL_WCT);
                    WordCount = (*CurrentPosition-*CurrentWct)>>1; //the one gets shifted off
                    StufferFLoopTrace(("  StufferFloop 'b' Wct=%lu\n",WordCount));
                    DbgDoit( ASSERT(!required_WCT || (WordCount == (required_WCT&0x7fff)));  )
                    **CurrentWct = (UCHAR)WordCount;
                    SmbPutUshort (*CurrentPosition, (USHORT)MRXSMB_INITIAL_BCC);
                    *CurrentBcc = *CurrentPosition;
                    *CurrentPosition+=sizeof(USHORT);
                    break;
                case 'Q':
                case 'q':
                    StufferFLoopTrace(("  StufferFloop 'q' \n",0));
                    SmbPutUshort (*CurrentPosition, (USHORT)MRXSMB_INITIAL_DATAOFFSET);
                    *CurrentDataOffset = *CurrentPosition;
                    *CurrentPosition+=sizeof(USHORT);
                    break;
                case '5':
                    //fill in the data offset
                    ASSERT (SmbGetUshort (*CurrentDataOffset) == MRXSMB_INITIAL_DATAOFFSET);
                    ByteCount = *CurrentPosition-BufferBase;
                    StufferFLoopTrace(("  StufferFloop '5' offset=%lu\n",ByteCount));
                    SmbPutUshort (*CurrentDataOffset, (USHORT)ByteCount);
                    break;
                case 'P':
                case 'p':
                    StufferFLoopTrace(("  StufferFloop 'p' \n",0));
                    SmbPutUshort (*CurrentPosition, (USHORT)MRXSMB_INITIAL_PARAMOFFSET);
                    *CurrentParamOffset = *CurrentPosition;
                    *CurrentPosition+=sizeof(USHORT);
                    break;
                case '6':
                    //fill in the data offset
                    ASSERT (SmbGetUshort (*CurrentParamOffset) == MRXSMB_INITIAL_PARAMOFFSET);
                    ByteCount = *CurrentPosition-BufferBase;
                    StufferFLoopTrace(("  StufferFloop '6' offset=%lu\n",ByteCount));
                    SmbPutUshort (*CurrentParamOffset, (USHORT)ByteCount);
                    break;
                case 'S':
                    // pad to ULONG; we loop behind instead of adding so we can clear
                    // out behind ourselves; apparently, some server croak on nonzero padding
                    StufferFLoopTrace(("  StufferFloop 'S' \n",0));
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += sizeof(ULONG)-1;
                    *CurrentPosition = (PBYTE)( ((ULONG)(*CurrentPosition)) & ~(sizeof(ULONG)-1) );
                    for (;PreviousPosition!=*CurrentPosition;) {
                        //StufferFLoopTrace(("      StufferFloop 'S' prev,curr=%08lx %08lx\n",PreviousPosition,*CurrentPosition));
                        *PreviousPosition++ = PADBYTE;
                    }
                    break;
                case 's':
                    // pad to arg; we loop behind instead of adding so we can clear
                    // out behind ourselves; apparently, some server croak on nonzero padding
                    arg = va_arg(AP,ULONG);
                    StufferFLoopTrace(("  StufferFloop 's' arg=\n",arg));
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += arg-1;
                    *CurrentPosition = (PBYTE)( ((ULONG)(*CurrentPosition)) & ~(arg-1) );
                    for (;PreviousPosition!=*CurrentPosition;) {
                        //StufferFLoopTrace(("      StufferFloop 'S' prev,curr=%08lx %08lx\n",PreviousPosition,*CurrentPosition));
                        *PreviousPosition++ = PADBYTE;
                    }
                    break;
                case '1':
                    // pad to USHORT; we loop behind instead of adding so we can clear
                    // out behind ourselves; apparently, some server croak on nonzero padding
                    StufferFLoopTrace(("  StufferFloop '1' Curr=%08lx \n",*CurrentPosition));
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += sizeof(USHORT)-1;
                    StufferFLoopTrace(("                   Curr=%08lx \n",*CurrentPosition));
                    *CurrentPosition = (PBYTE)( ((ULONG)(*CurrentPosition)) & ~(sizeof(USHORT)-1) );
                    StufferFLoopTrace(("                   Curr=%08lx \n",*CurrentPosition));
                    for (;PreviousPosition!=*CurrentPosition;) {
                        StufferFLoopTrace(("      StufferFloop '1' prev,curr=%08lx %08lx\n",PreviousPosition,*CurrentPosition));
                        *PreviousPosition++ = PADBYTE;
                    }
                    break;
                case 'c':
                    // copy in the bytes....used a lot in transact
                    CopyCount = va_arg(AP,ULONG);
                    CopyPtr = va_arg(AP,PBYTE);
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    StufferFLoopTrace(("  StufferFloop 'c' copycount = %lu\n", CopyCount));
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += CopyCount;
                    for (;PreviousPosition!=*CurrentPosition;) {
                        //StufferFLoopTrace(("      StufferFloop 'S' prev,curr=%08lx %08lx\n",PreviousPosition,*CurrentPosition));
                        *PreviousPosition++ = *CopyPtr++;
                    }
                    break;
                case 'R':
                case 'r':
                    // copy in the bytes....used a lot in transact
                    RegionPtr = va_arg(AP,PBYTE*);
                    CopyCount = va_arg(AP,ULONG);
                    StufferFLoopTrace(("  StufferFloop 'r' regionsize = %lu\n", CopyCount));
                    *RegionPtr = *CurrentPosition;
                    *CurrentPosition += CopyCount;
                    IF_DEBUG {
                        PreviousPosition = *RegionPtr;
                        for (;PreviousPosition!=*CurrentPosition;) {
                            //StufferFLoopTrace(("      StufferFloop 'S' prev,curr=%08lx %08lx\n",PreviousPosition,*CurrentPosition));
                            *PreviousPosition++ = '-';
                        }
                    }
                    break;
                case 'A':
                case 'a':
                    //copy byte from an asciiz including the trailing NULL
                    Astring = va_arg(AP,PSZ);
                    StufferFLoopTrace(("  StufferFloop 'a' stringing = %s\n", Astring));
                    CopyCount = strlen(Astring)+1;
                    //if (((ULONG)(*CurrentPosition))&1) {
                    //    StufferFLoopTrace(("  StufferFloop 'a' aligning\n", 0));
                    //    *CurrentPosition+=1;
                    //}
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += CopyCount;
                    if (*CurrentPosition >= StufferState->BufferLimit) {
                        StufferFLoopTrace(("  StufferFloop 'a' bufferoverrun\n", 0));
                        ASSERT(!"BufferOverrun");
                        return(STATUS_BUFFER_OVERFLOW);
                    }
                    RtlCopyMemory(PreviousPosition,Astring,CopyCount);
                    break;
                case 'z':
                case '4':
                case '>':
                    Zstring = va_arg(AP,PUNICODE_STRING);
                    StufferFLoopTrace(("  StufferFloop '4/z/>' stringing = %wZ, cp=\n", Zstring,*CurrentPosition ));
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    if (CurrentFormatChar=='4') {
                        //first lay down a x'04' and then copy either a asciiz or a unicodez depending on the flags setting
                        **CurrentPosition = (UCHAR)4; //ascii marker
                        *CurrentPosition+=1;
                    } else if (CurrentFormatChar=='>'){
                        //back up over the previous NULL
                        //
                        *CurrentPosition-=(FlagOn(SmbHeader->Flags2,SMB_FLAGS2_UNICODE)?sizeof(WCHAR):sizeof(char));
                        StufferFLoopTrace(("  StufferFloop '4/z/>' afterroolback, cp=\n", *CurrentPosition ));
                    }
                    if (FlagOn(SmbHeader->Flags2,SMB_FLAGS2_UNICODE)){

                        if (((ULONG)(*CurrentPosition))&1) {
                            StufferFLoopTrace(("  StufferFloop '4/z/>' aligning\n", 0));
                            *CurrentPosition+=1;
                        }
                        PreviousPosition = *CurrentPosition;
                        *CurrentPosition += (Zstring->Length + sizeof(WCHAR));
                        if (*CurrentPosition >= StufferState->BufferLimit) {
                            StufferFLoopTrace(("  StufferFloop '4/z/>' bufferoverrun\n", 0));
                            ASSERT(!"BufferOverrun");
                            return(STATUS_BUFFER_OVERFLOW);
                        }
                        RtlCopyMemory(PreviousPosition,Zstring->Buffer,Zstring->Length);
                        *(((PWCHAR)(*CurrentPosition))-1) = 0;

                    } else {

                        NTSTATUS Status;
                        OEM_STRING OemString;

                        OemString.Length =
                             OemString.MaximumLength =
                                 (USHORT)( StufferState->BufferLimit - *CurrentPosition  - sizeof(CHAR));
                        OemString.Buffer = *CurrentPosition;
                        Status = RtlUnicodeStringToOemString(
                                         &OemString,
                                         Zstring,
                                         FALSE);

                        if (!NT_SUCCESS(Status)) {
                            StufferFLoopTrace(("  StufferFloop '4/z/>' bufferoverrun(ascii)\n", 0));
                            ASSERT(!"BufferOverrun");
                            return(STATUS_BUFFER_OVERFLOW);
                        }

                        *CurrentPosition += OemString.Length + 1;
                        *(*CurrentPosition-1) = 0;

                    }
                    break;
                case 'U':
                case 'u':
                    //copy bytes from an UNICODE string including a trailing NULL
                    Zstring = va_arg(AP,PUNICODE_STRING);
                    StufferFLoopTrace(("  StufferFloop 'u' stringing = %wZ\n", Zstring));
                    if (((ULONG)(*CurrentPosition))&1) {
                        StufferFLoopTrace(("  StufferFloop 'u' aligning\n", 0));
                        *CurrentPosition+=1;
                    }
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += (Zstring->Length + sizeof(WCHAR));
                    if (*CurrentPosition >= StufferState->BufferLimit) {
                        StufferFLoopTrace(("  StufferFloop 'u' bufferoverrun\n", 0));
                        ASSERT(!"BufferOverrun");
                        return(STATUS_BUFFER_OVERFLOW);
                    }
                    RtlCopyMemory(PreviousPosition,Zstring->Buffer,Zstring->Length);
                    *(((PWCHAR)(*CurrentPosition))-1) = 0;
                    break;
                case 'V':
                case 'v':
                    //copy bytes from an UNICODE string no trailing NUL
                    Zstring = va_arg(AP,PUNICODE_STRING);
                    StufferFLoopTrace(("  StufferFloop 'v' stringing = %wZ\n", Zstring));
                    if (((ULONG)(*CurrentPosition))&1) {
                        StufferFLoopTrace(("  StufferFloop 'v' aligning\n", 0));
                        *CurrentPosition+=1;
                    }
                    PreviousPosition = *CurrentPosition;
                    *CurrentPosition += Zstring->Length;
                    if (*CurrentPosition >= StufferState->BufferLimit) {
                        StufferFLoopTrace(("  StufferFloop 'v' bufferoverrun\n", 0));
                        ASSERT(!"BufferOverrun");
                        return(STATUS_BUFFER_OVERFLOW);
                    }
                    RtlCopyMemory(PreviousPosition,Zstring->Buffer,Zstring->Length);
                    break;
                case 'N':
                case 'n':
                    //copy bytes from a NetRoot name....w null
                    NetRoot = va_arg(AP,PNET_ROOT);
                    ASSERT(NodeType(NetRoot)==RDBSS_NTC_NETROOT);
                    Zstring = &NetRoot->PrefixEntry.Prefix;
                    StufferFLoopTrace(("  StufferFloop 'n' stringing = %wZ\n", Zstring));
                    if (StufferState->Flags2Copy&SMB_FLAGS2_UNICODE) {
                        if (((ULONG)(*CurrentPosition))&1) {
                            StufferFLoopTrace(("  StufferFloop 'n' aligning\n", 0));
                            *CurrentPosition+=1;
                        }
                        PreviousPosition = *CurrentPosition;
                        *CurrentPosition += (Zstring->Length + 2 * sizeof(WCHAR));  //extra \ plus a nul
                        if (*CurrentPosition >= StufferState->BufferLimit) {
                            StufferFLoopTrace(("  StufferFloop 'n' bufferoverrun\n", 0));
                            ASSERT(!"BufferOverrun");
                            return(STATUS_BUFFER_OVERFLOW);
                        }
                        *((PWCHAR)PreviousPosition) = '\\';
                        RtlCopyMemory(PreviousPosition+sizeof(WCHAR),Zstring->Buffer,Zstring->Length);
                        *(((PWCHAR)(*CurrentPosition))-1) = 0;
                    }
                    break;
                case '?':
                    //early out....used in transact to do the setup
                    EarlyReturn = va_arg(AP,ULONG);
                    StufferFLoopTrace(("  StufferFloop '?' out if 0==%08lx\n",EarlyReturn));
                    if (EarlyReturn==0) return STATUS_SUCCESS;
                    break;
                case '.':
                    //noop...used to reenter without a real formatting string
                    StufferFLoopTrace(("  StufferFloop '.'\n",0));
                    break;
                case '!':
                    if (CurrentStufferControl == STUFFER_CTL_SKIP) break;
                    ASSERT (SmbGetUshort (*CurrentBcc) == MRXSMB_INITIAL_BCC);
                    ByteCount = *CurrentPosition-*CurrentBcc-sizeof(USHORT);
                    StufferFLoopTrace(("  StufferFloop '!' arg=%lu\n",ByteCount));
                    SmbPutUshort (*CurrentBcc, (USHORT)ByteCount);
                    return STATUS_SUCCESS;
                default:
                    StufferFLoopTrace(("  StufferFloop '%c' BADBADBAD\n",*CurrentFormatString));
                    ASSERT(!"Illegal Controlstring character\n");
                } //switch
            }//for
            break;
        case 0:
            return STATUS_SUCCESS;
        default:
            StufferCLoopTrace(("  StufferCloop %u BADBADBAD\n",CurrentStufferControl));
            ASSERT(!"IllegalStufferControl\n");
        }//switch

        CurrentStufferControl = va_arg(AP,SMB_STUFFER_CONTROLS);
        StufferCLoopTrace(("  StufferCloop NewStufferControl=%u \n",CurrentStufferControl));

    } //for

    return STATUS_SUCCESS;
}

VOID
MRxSmbStuffAppendRawData(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PMDL Mdl
    )
{
    ASSERT(!StufferState->DataMdl);
    StufferState->DataMdl = Mdl;
    StufferState->DataSize = Mdl->ByteCount;
    return;
}

VOID
MRxSmbStuffAppendSmbData(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PMDL Mdl
    )
{
    ULONG Offset;
    ASSERT(!StufferState->DataMdl);
    StufferState->DataMdl = Mdl;
    StufferState->DataSize = Mdl->ByteCount;
    //now reach back into the buffer and set the SMB data offset; if it is already set...just get out
    if (SmbGetUshort (StufferState->CurrentDataOffset) == MRXSMB_INITIAL_DATAOFFSET){
        Offset = StufferState->CurrentPosition - StufferState->BufferBase;
        RxDbgTrace(0, Dbg,("MRxSmbStuffAppendSmbData offset=%lu\n",Offset));
        SmbPutUshort (StufferState->CurrentDataOffset, (USHORT)Offset);
    }
    return;
}

VOID
MRxSmbStuffSetByteCount(
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState
    )
{
    ULONG ByteCount;
    ASSERT (SmbGetUshort (StufferState->CurrentBcc) == MRXSMB_INITIAL_BCC);
    ByteCount = StufferState->CurrentPosition
                   - StufferState->CurrentBcc
                   - sizeof(USHORT)
                   + StufferState->DataSize;
    RxDbgTrace(0, Dbg,("MRxSmbStuffSetByteCount ByteCount=%lu\n",ByteCount));
    SmbPutUshort (StufferState->CurrentBcc, (USHORT)ByteCount);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\write.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module implements the mini redirector call down routines pertaining
    to write of file system objects.

--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable

#define MIN_CHUNK_SIZE 0x1000

#define MAX(a,b) ((a) > (b) ? (a) : (b))

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

//#define FORCE_NO_NTWRITEANDX

#ifndef FORCE_NO_NTWRITEANDX
#define MRxSmbForceNoNtWriteAndX FALSE
#else
BOOLEAN MRxSmbForceNoNtWriteAndX = TRUE;
#endif

#define WRITE_COPY_THRESHOLD 64
#define FORCECOPYMODE FALSE

//#define SETFORCECOPYMODE
#ifdef SETFORCECOPYMODE
#undef  FORCECOPYMODE
#define FORCECOPYMODE MRxSmbForceCopyMode
ULONG MRxSmbForceCopyMode = TRUE;
#endif //SETFORCECOPYMODE

NTSTATUS
SmbPseExchangeStart_Write(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

ULONG MRxSmbSrvWriteBufSize = 0xffff; //use the negotiated size
ULONG MRxSmbWriteSendOptions = 0;


//
// External declarations
//


NTSTATUS
MRxIfsWrite (
      IN PRX_CONTEXT RxContext)

/*++

Routine Description:

   This routine opens a file across the network.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbWrite\n", 0 ));


    OrdinaryExchange = SmbPseCreateOrdinaryExchange(RxContext,
                                                    capFobx->pSrvOpen->pVNetRoot,
                                                    SMBPSE_OE_FROM_WRITE,
                                                    SmbPseExchangeStart_Write
                                                    );
    if (OrdinaryExchange==NULL) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    if ( Status != STATUS_PENDING ) {
        BOOLEAN FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
        ASSERT( FinalizationComplete );
    } else {
        ASSERT(BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbWrite  exit with status=%08lx\n", Status ));
    return(Status);

} // MRxSmbWrite



NTSTATUS
MRxSmbBuildCoreWrite (
    IN OUT PSMBSTUFFER_BUFFER_STATE StufferState,
    IN     PLARGE_INTEGER ByteOffsetAsLI,
    IN     PBYTE Buffer,
    IN     ULONG ByteCount,
    IN     PMDL  BufferAsMdl
    )

/*++

Routine Description:

   This routine builds a core write SMB. We don't have to worry about login id
   and such since that is done by the connection engine....pretty neat huh?
   All we have to do is to format up the bits.

   The buffer is passed into this routine in one of two ways:
        1. As an MDL
        2. As buffer/bytecount.

   This routine acts accordingly.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view
   ByteOffsetAsLI - the byte offset in the file where we want to read
   Buffer - the buffer where the data resides OR NULL!
   ByteCount - the length of the Buffer described by Buffer
   BufferAsMdl - an MDL describing the data OR NULL!

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something in the arguments can't be handled

Notes:



--*/

{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;RxCaptureFobx;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PNT_SMB_HEADER NtSmbHeader = (PNT_SMB_HEADER)(StufferState->BufferBase);

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxIfsGetSrvOpenExtension(SrvOpen);
    ULONG OffsetLow,OffsetHigh;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange =
                                        (PSMB_PSE_ORDINARY_EXCHANGE)(StufferState->Exchange);
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;

    ULONG  DataLength = ByteCount;
    ULONG  BytesRemaining = 0;


    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbBuildCoreWrite\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( !(Buffer&&BufferAsMdl) );
    ASSERT( (Buffer || BufferAsMdl) );

    OffsetLow = ByteOffsetAsLI->LowPart;
    OffsetHigh = ByteOffsetAsLI->HighPart;
    ASSERT(OffsetHigh==0);


    COVERED_CALL(MRxSmbStartSMBCommand( StufferState, SetInitialSMB_Never,
                                          SMB_COM_WRITE,
                                          SMB_REQUEST_SIZE(WRITE),
                                          NO_EXTRA_DATA,
                                          NO_SPECIAL_ALIGNMENT,
                                          RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                          0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );


    MRxSmbStuffSMB (StufferState,
         "0wwdwByw",
                                    //  0   UCHAR WordCount;                    // Count of parameter words = 5
             smbSrvOpen->Fid,       //  w   _USHORT( Fid );                     // File handle
             DataLength,            //  w   _USHORT( Count );                   // Number of bytes to be written
             OffsetLow,             //  d   _ULONG( Offset );                   // Offset in file to begin write
             BytesRemaining,        //  w   _USHORT( Remaining );               // Bytes remaining to satisfy request
             SMB_WCT_CHECK(5)       //  B   _USHORT( ByteCount );               // Count of data bytes
                                    //      //UCHAR Buffer[1];                  // Buffer containing:
             0x01,                  //  y     UCHAR BufferFormat;               //  0x01 -- Data block
             DataLength,            //  w     _USHORT( DataLength );            //  Length of data
                                    //        ULONG Buffer[1];                  //  Data
         StufferCondition(Buffer!=NULL), "c!",
             ByteCount,Buffer,     //  c     the actual data
             0
             );

    if ( BufferAsMdl ) {
        MRxSmbStuffAppendRawData( StufferState, BufferAsMdl );
        MRxSmbStuffSetByteCount( StufferState );
    }

    IF_DEBUG{
        PREQ_WRITE req = (PREQ_WRITE)(NtSmbHeader+1);
        ULONG ByteCount = SmbGetUshort( &req->ByteCount );
        RxDbgTrace(0, Dbg, ("BuildCoreWrite bc=%08lx\n", ByteCount ));
        ASSERT(ByteCount!=0);
    }

FINALLY:
    RxDbgTraceUnIndent(-1, Dbg);
    return(Status);

} // MRxSmbBuildCoreWrite






NTSTATUS
SmbPseExchangeStart_Write (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )

/*++

Routine Description:

    This is the start routine for write.


Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;// no longer instead async gets status from exchange->smbstatus
                    // = RxStatus(SUCCESS); // this must be success if we are
                                         // reentered as on on an async write
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    ULONG StartEntryCount;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    PMDL DataPartialMdl = OrdinaryExchange->DataPartialMdl;
    PMDL OriginalDataMdl = LowIoContext->ParamsFor.ReadWrite.Buffer;
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    BOOLEAN  SynchronousIo =
               !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);
    BOOLEAN VestigialSmbBuf = BooleanFlagOn( OrdinaryExchange->Flags, SMBPSE_OE_FLAG_MUST_SUCCEED_ALLOCATED_SMBBUF );

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Write\n"));

    ASSERT( OrdinaryExchange->Type == ORDINARY_EXCHANGE );
    ASSERT( ((OriginalDataMdl!=NULL) && RxMdlIsLocked(OriginalDataMdl))
               || ((OriginalDataMdl==NULL) && (LowIoContext->ParamsFor.ReadWrite.ByteCount==0)) );

    ASSERT( (OrdinaryExchange->SmbCeFlags&SMBCE_EXCHANGE_ATTEMPT_RECONNECTS) == 0 );

    OrdinaryExchange->StartEntryCount++;
    StartEntryCount = OrdinaryExchange->StartEntryCount;

    // Ensure that the Fid is validated

    SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);

    for (;;) {

        PSMBCE_SERVER pServer = &OrdinaryExchange->SmbCeContext.pServerEntry->Server;
        ULONG MaximumBufferSizeThisIteration;

        switch ( OrdinaryExchange->OpSpecificState ) {

        case SmbPseOEInnerIoStates_Initial:

            OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;
            if ( !SynchronousIo ) {
                OrdinaryExchange->Continuation = SmbPseExchangeStart_Write;
            }

            MRxSmbSetInitialSMB( StufferState STUFFERTRACE(Dbg,'FC') );


            rw->MaximumSmbBufferSize =
                     min(MRxSmbSrvWriteBufSize,
                         pServer->MaximumBufferSize -
                                  QuadAlign(sizeof(SMB_HEADER) +
                                    FIELD_OFFSET(REQ_NT_WRITE_ANDX,Buffer[0])));
            if (VestigialSmbBuf) {
                rw->MaximumSmbBufferSize = min(rw->MaximumSmbBufferSize,PAGE_SIZE);
            }

            rw->UserBufferBase = RxLowIoGetBufferAddress( RxContext );
            rw->ByteOffsetAsLI.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
            rw->RemainingByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;
            if (OriginalDataMdl!=NULL) {
                rw->UserBufferBase = RxLowIoGetBufferAddress( RxContext );
            } else {
                rw->UserBufferBase = (PBYTE)1;   //any nonzero value will do
            }

            //record if this is a msgmode/pipe operation......

            if (   (capFcb->pNetRoot->Type == NET_ROOT_PIPE)
                && (capFobx->PipeHandleInformation->ReadMode != FILE_PIPE_BYTE_STREAM_MODE) ) {
                SetFlag(OrdinaryExchange->OpSpecificFlags,OE_READ_FLAG_MSGMODE_PIPE_OPERATION);
            }


            rw->ThisBufferOffset = 0;
            rw->PartialBytes = 0;

            //lack of break is intentional

        case SmbPseOEInnerIoStates_ReadyToSend:

            OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_OperationOutstanding;
            OrdinaryExchange->SendOptions = MRxSmbWriteSendOptions;
            MaximumBufferSizeThisIteration =
                        rw->MaximumSmbBufferSize -
                                ( (FlagOn(OrdinaryExchange->OpSpecificFlags,OE_READ_FLAG_MSGMODE_PIPE_OPERATION)
                                   && !FlagOn(OrdinaryExchange->OpSpecificFlags,OE_READ_FLAG_SUBSEQUENT_OPERATION))
                                  ?2:0 );
            //
            // If the write is small enough, we can just copy it into the
            // write request smb.
            //

            ASSERT( WRITE_COPY_THRESHOLD <= rw->MaximumSmbBufferSize );

            // In 3 out of 4 cases, the following assignment is correct...

            rw->ThisByteCount = rw->RemainingByteCount;

            {

                PCHAR Buffer;


                if (rw->ThisByteCount > rw->MaximumSmbBufferSize )
                {
                    rw->ThisByteCount = MaximumBufferSizeThisIteration;
                }

                Buffer = rw->UserBufferBase + rw->ThisBufferOffset;

                Status = MRxSmbBuildCoreWrite( StufferState,
                                               &rw->ByteOffsetAsLI,
                                               Buffer,
                                               rw->ThisByteCount,
                                               NULL );

            }

            if (Status != STATUS_SUCCESS) {
                RxDbgTrace(0, Dbg, ("bad write stuffer status........\n"));
                goto FINALLY;
            }
            InterlockedIncrement(&MRxIfsStatistics.WriteSmbs);
            Status = SmbPseOrdinaryExchange( SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                             SMBPSE_OETYPE_WRITE
                                            );

            if ( Status == STATUS_PENDING ) {
                ASSERT( !SynchronousIo );
                goto FINALLY;
            }

            //lack of break is intentional

        case SmbPseOEInnerIoStates_OperationOutstanding:
            SetFlag(OrdinaryExchange->OpSpecificFlags,OE_READ_FLAG_SUBSEQUENT_OPERATION);
            OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;
            rw->RemainingByteCount -= rw->BytesReturned;
            RxContext->InformationToReturn += rw->BytesReturned;
            Status = OrdinaryExchange->SmbStatus;

            if ( (Status != STATUS_SUCCESS)
                 || (rw->BytesReturned < rw->ThisByteCount)
                 || (rw->RemainingByteCount == 0) ) {

                goto FINALLY;
            }

            rw->ByteOffsetAsLI.QuadPart += rw->BytesReturned;
            rw->ThisBufferOffset += rw->BytesReturned;

            MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0));
            break;
        }
    }


FINALLY:

    if ( Status != STATUS_PENDING ) {
        SmbPseAsyncCompletionIfNecessary(OrdinaryExchange,RxContext);
    }

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Write exit w %08lx\n", Status ));
    return Status;

} // SmbPseExchangeStart_Write



NTSTATUS
MRxSmbFinishWrite (
    IN OUT  PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    IN      PRESP_WRITE_ANDX            Response
    )

/*++

Routine Description:

    This routine actually gets the stuff out of the write response and finishes
    the write. Everything you need is locked down... so we can finish in the
    indication routine

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BytesReturned;

    //PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishWrite\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishWrite:");

    ASSERT( (Response->WordCount==6) );
    ASSERT( (SmbGetUshort(&Response->ByteCount)==0) );

    BytesReturned = SmbGetUshort( &Response->Count );
    //if we added 2 headerbytes then let's get rid of them......
    if ( FlagOn(OrdinaryExchange->OpSpecificFlags,OE_READ_FLAG_REDUCE_RETURNCOUNT) ) {
        BytesReturned -= sizeof(USHORT);
        ClearFlag(OrdinaryExchange->OpSpecificFlags,OE_READ_FLAG_REDUCE_RETURNCOUNT);
    }

    RxDbgTrace(0, Dbg, ("-->BytesReturned=%08lx\n", BytesReturned));

    OrdinaryExchange->ReadWrite.BytesReturned =  BytesReturned;

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishWrite   returning %08lx\n", Status ));
    return Status;

} // MRxSmbFinishWrite



NTSTATUS
MRxSmbFinishCoreWrite (
    IN OUT  PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    IN      PRESP_WRITE                 Response
    )

/*++

Routine Description:

    This routine actually gets the stuff out of the write response and finishes
    the core write. Everything you need is locked down... so we can finish in the
    indication routine

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BytesReturned;

    //PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishCoreWrite\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishCoreWrite:");

    ASSERT( (Response->WordCount==1) );
    ASSERT( (SmbGetUshort(&Response->ByteCount)==0) );

    BytesReturned = SmbGetUshort( &Response->Count );

    RxDbgTrace(0, Dbg, ("-->BytesReturned=%08lx\n", BytesReturned));

    OrdinaryExchange->ReadWrite.BytesReturned =  BytesReturned;

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishCoreWrite   returning %08lx\n", Status ));
    return Status;

} // MRxSmbFinishCoreWrite
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\vcsndrcv.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    vcsndrcv.c

Abstract:

    This module implements all functions related to transmitting and recieving SMB's on a
    connection based transport.

--*/

#include "precomp.h"
#pragma hdrstop

#include "vcsndrcv.h"

RXDT_DefineCategory(VCSNDRCV);
#define Dbg        (DEBUG_TRACE_VCSNDRCV)

// Move this def to a common .h file.
#define MAX_SMB_PACKET_SIZE (65536)

#define MIN(a,b) ((a) < (b) ? (a) : (b))

//
// Forward references of functions ....
//

extern NTSTATUS
VctTearDownServerTransport(PSMBCE_SERVER_TRANSPORT pTransport);

extern NTSTATUS
VctInitializeExchange(
   PSMB_EXCHANGE            pExchange);

extern PSMBCE_VC_ENTRY
VctSelectVc(
   PSMBCE_SERVER_VC_TRANSPORT pVcTransport,
   BOOLEAN                    fMultiplexed);


#define SmbMmInitializeVcEntry(pVcEntry)                      \
         SmbMmInitializeHeader((pVcEntry));                   \
         InitializeListHead(&(pVcEntry)->Requests.ListHead)

#define SmbMmUninitializeVcEntry(pVcEntry)    \
         ASSERT(IsListEmpty(&(pVcEntry)->Requests.ListHead))

#define VctSelectMultiplexedVcEntry(pVcTransport)  VctSelectVc(pVcTransport,TRUE)
#define VctSelectRawVcEntry(pVcTransport)          VctSelectVc(pVcTransport,FALSE)

//
// Inline functions to update the state of a VC.
//

INLINE BOOLEAN
VctUpdateVcStateLite(
      PSMBCE_VC_ENTRY    pVcEntry,
      SMBCE_VC_STATE       NewState)
{
   BOOLEAN Result = TRUE;

   ASSERT(VctSpinLockAcquired());

   if (NewState == SMBCE_VC_STATE_RAW) {
      if (pVcEntry->SwizzleCount != 0) {
         Result = FALSE;
      } else {
         pVcEntry->Vc.State = NewState;
      }
   } else {
      pVcEntry->Vc.State = NewState;
   }

   return Result;
}

INLINE BOOLEAN
VctUpdateVcState(
      PSMBCE_VC_ENTRY    pVcEntry,
      SMBCE_VC_STATE       NewState)
{
   BOOLEAN Result = TRUE;

   VctAcquireSpinLock();

   Result = VctUpdateVcStateLite(pVcEntry,NewState);

   VctReleaseSpinLock();

   return Result;
}

NTSTATUS
VctTranceive(
      PSMBCEDB_SERVER_ENTRY   pServerEntry,
      PSMB_EXCHANGE           pExchange,
      ULONG                   SendOptions,
      PMDL                    pSmbMdl,
      ULONG                   SendLength,
      PVOID                   pSendCompletionContext)
/*++

Routine Description:

    This routine transmits/receives a SMB for a give exchange

Arguments:

    pServerEntry  - the server entry

    pExchange     - the exchange instance issuing this SMB.

    SendOptions   - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be transmitted

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    STATUS_PENDING - the open involves network traffic and the exchange has been
                     queued for notification ( pServerPointer is set to NULL)

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS                   Status = STATUS_SUCCESS;
   PSMBCE_VC_ENTRY            pVcEntry;
   PSMBCE_SERVER_VC_TRANSPORT pVcTransport;
   PSMB_HEADER                pSmbHeader = MmGetSystemAddressForMdl(pSmbMdl);
   USHORT                     Mid;
   BOOLEAN                    fInvokeSendCompleteHandler = TRUE;

   ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

   pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerEntry->pTransport;

   // Ensure that the connection is still active before satisfying the request.
   if (SmbCeIsEntryInUse(&pServerEntry->Header)) {
      pVcEntry = pExchange->SmbCeContext.TransportContext.Vcs.pVcEntry;
      if (pVcEntry == NULL) {
         // The transport connection was not initialized. Try and establish a connection if
         // possible.
         Status = VctInitializeExchange(pExchange);
         if (Status != STATUS_SUCCESS) {
            RxDbgTrace(0, Dbg, ("VctTranceive: VctInitializeExchange(Reconnect) returned %lx\n",Status));
         } else {
            pVcEntry = pExchange->SmbCeContext.TransportContext.Vcs.pVcEntry;
         }
      }

      if ((Status == STATUS_SUCCESS) &&
          (pVcEntry->Vc.State == SMBCE_VC_STATE_MULTIPLEXED)) {
         Status = RxCeSend(
                        pVcEntry->Vc.hVc,
                        SendOptions,
                        pSmbMdl,
                        SendLength,
                        pSendCompletionContext);

         if ((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING)) {
            Status = STATUS_PENDING;
            // The underlying connection engine assumes the responsibility of
            // invoking the send complete handler from this point.
            fInvokeSendCompleteHandler = FALSE;
         }
      } else {
         RxDbgTrace(0, Dbg, ("VctTranceive: Disconnected connection detected\n"));
         Status = STATUS_CONNECTION_DISCONNECTED;
      }
   } else {
      // The server entry is not valid ...
      Status = STATUS_CONNECTION_DISCONNECTED;
   }

   if (Status != STATUS_PENDING) {
      RxDbgTrace(0, Dbg, ("VctTranceive: Return Status %lx\n",Status));
   }

   // There are instances in which the send was aborted even before the underlying
   // transport was invoked. In such cases the appropriate send complete handler
   // needs to be called so that the associated exchange can be finalized.

   if (fInvokeSendCompleteHandler) {
      NTSTATUS LocalStatus;

      LocalStatus = SmbCeSendCompleteInd(
                     pServerEntry,
                     pSendCompletionContext,
                     Status);

      RxDbgTrace(0, Dbg, ("VctTranceive: Send Complete Handler Return Status %lx\n",LocalStatus));
   }

   return Status;
}


NTSTATUS
VctReceive(
      PSMBCEDB_SERVER_ENTRY   pServerEntry,
      PSMB_EXCHANGE           pExchange)
/*++

Routine Description:

    This routine transmits/receives a SMB for a give exchange

Arguments:

    pServerEntry - the server entry

    pExchange  - the exchange instance issuing this SMB.

Return Value:

    STATUS_PENDING - the request has been queued

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS                   Status = STATUS_SUCCESS;
   PSMBCEDB_NET_ROOT_ENTRY    pNetRootEntry;
   PSMBCE_VC_ENTRY            pVcEntry;
   PSMBCE_SERVER_VC_TRANSPORT pVcTransport;

   ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

   pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerEntry->pTransport;
   pVcEntry     = pExchange->SmbCeContext.TransportContext.Vcs.pVcEntry;

   // Ensure that the connection is still active before satisfying the request.
   if (SmbCeIsEntryInUse(&pServerEntry->Header)) {
      if ((pVcEntry == NULL) ||
          (pVcEntry->Vc.State == SMBCE_VC_STATE_DISCONNECTED)) {
         // The transport connection was disconnected. Try and reconnect if
         // possible.
         RxDbgTrace(0, Dbg, ("VctReceive: Disconnected connection detected, attempting to reconnect\n"));
         pExchange->SmbCeContext.TransportContext.Vcs.pVcEntry = NULL;
         Status = VctInitializeExchange(pExchange);
      }
   } else {
      // The server entry is not valid ...
      Status = STATUS_CONNECTION_DISCONNECTED;
   }

   return Status;
}

NTSTATUS
VctSend(
      PSMBCEDB_SERVER_ENTRY   pServerEntry,
      ULONG                   SendOptions,
      PMDL                    pSmbMdl,
      ULONG                   SendLength,
      PVOID                   pSendCompletionContext)
/*++

Routine Description:

    This routine opens/creates a server entry in the connection engine database

Arguments:

    pServer    - the recepient server

    pVc        - the Vc on which the SMB is sent( if it is NULL SMBCE picks one)

    SendOptions - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be sent

Return Value:

    STATUS_SUCCESS - the send was successful.

    STATUS_PENDING - the send has been queued

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS                   Status = STATUS_CONNECTION_DISCONNECTED;
   PSMBCE_VC_ENTRY            pVcEntry;
   PSMBCE_SERVER_VC_TRANSPORT pVcTransport;
   BOOLEAN                    fInvokeSendCompleteHandler = TRUE;

   ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

   pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerEntry->pTransport;
   pVcEntry = VctSelectMultiplexedVcEntry(pVcTransport);

   if  (pVcEntry != NULL) {
      if (pVcEntry->Vc.State == SMBCE_VC_STATE_MULTIPLEXED) {
         Status = RxCeSend(
                        pVcEntry->Vc.hVc,
                        SendOptions,
                        pSmbMdl,
                        SendLength,
                        pSendCompletionContext);

         if ((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING)) {
            // The underlying connection engine assumes the responsibility of
            // invoking the send complete handler from this point.
            fInvokeSendCompleteHandler = FALSE;
         }
      }
   }

   if (!NT_SUCCESS(Status)) {
      RxDbgTrace(0, Dbg, ("VctSend: RxCeSend returned %lx\n",Status));
   }

   // There are instances in which the send was aborted even before the underlying
   // transport was invoked. In such cases the appropriate send complete handler
   // needs to be called so that the associated exchange can be finalized.

   if (fInvokeSendCompleteHandler) {
      NTSTATUS LocalStatus;

      LocalStatus = SmbCeSendCompleteInd(
                     pServerEntry,
                     pSendCompletionContext,
                     Status);

      RxDbgTrace(0, Dbg, ("VctTranceive: Send Complete Handler Return Status %lx\n",LocalStatus));
   }

   return Status;
}

NTSTATUS
VctSendDatagram(
      PSMBCEDB_SERVER_ENTRY pServerEntry,
      ULONG                 SendOptions,
      PMDL                  pSmbMdl,
      ULONG                 SendLength,
      PVOID                 pSendCompletionContext)
/*++

Routine Description:

    This routine opens/creates a server entry in the connection engine database

Arguments:

    pServer    - the recepient server

    SendOptions - options for send

    pSmbMdl     - the SMB that needs to be sent.

    SendLength  - length of data to be sent

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    STATUS_PENDING - the open involves network traffic and the exchange has been
                     queued for notification ( pServerPointer is set to NULL)

    Other Status codes correspond to error situations.

--*/
{
   return STATUS_NOT_IMPLEMENTED;
}

PSMBCE_VC_ENTRY
VctSelectVc(
   PSMBCE_SERVER_VC_TRANSPORT pVcTransport,
   BOOLEAN                    fMultiplexed)
/*++

Routine Description:

    This routine embodies the logic for the selection of a VC on which the SMB exchange
    will transpire

Arguments:

    pVcTransport  - the transport structure

    fMultiplexed  - the desired mode

Return Value:

    a referenced VC entry if successful otherwise NULL

--*/
{
   NTSTATUS        Status;
   PSMBCE_VC_ENTRY pVcEntry = NULL;
   ULONG           NumberOfActiveVcs = 0;
   SMBCE_VC_STATE  DesiredState;

   if (fMultiplexed) {
      RxDbgTrace(0, Dbg, ("VctSelectVc: Referencing Multiplexed entry\n"));
      DesiredState = SMBCE_VC_STATE_MULTIPLEXED;
   } else {
      RxDbgTrace(0, Dbg, ("VctSelectVc: Referencing Raw entry\n"));
      DesiredState = SMBCE_VC_STATE_RAW;
   }

   // Acquire the resource
   SmbCeAcquireResource();

   // Choose the first VC that can support multiplexed requests
   pVcEntry = VctGetFirstVcEntry(&pVcTransport->Vcs);
   while (pVcEntry != NULL) {
      NumberOfActiveVcs++;

      if (pVcEntry->Vc.State == SMBCE_VC_STATE_MULTIPLEXED) {
         if (DesiredState == SMBCE_VC_STATE_MULTIPLEXED) {
            break;
         } else {
            // If the current number of active references to a VC is zero, it can
            // be transformed into the raw mode.
            if (VctUpdateVcState(pVcEntry,SMBCE_VC_STATE_RAW)) {
               break;
            } else {
               NumberOfActiveVcs++;
            }
         }
      }

      pVcEntry = VctGetNextVcEntry(&pVcTransport->Vcs,pVcEntry);
   }

   if (pVcEntry == NULL) {
      // Check if it is O.K. to add VCs to this connection. Currently the server
      // implementation supports only one VC per connection. Therefore if an
      // active VC exists which has been grabbed for raw mode use an error is returned.
      // Subsequently when the server is upgraded to handle multiple VCs the logic
      // for adding a new VC will be implemented as part of this routine.

      RxDbgTrace(0, Dbg, ("VctSelectVc: Allocating new VC entry\n"));
      if (NumberOfActiveVcs < pVcTransport->MaximumNumberOfVCs) {
         pVcEntry = (PSMBCE_VC_ENTRY)RxAllocatePoolWithTag(
                                             NonPagedPool,
                                             sizeof(SMBCE_VC_ENTRY),
                                             MRXSMB_VC_POOLTAG);
         if (pVcEntry != NULL) {
            SmbMmInitializeVcEntry(pVcEntry);
            Status = RxCeAddVC(pVcTransport->hConnection,&pVcEntry->Vc.hVc);
            if (NT_SUCCESS(Status)) {
               pVcEntry->Vc.State = DesiredState;
               VctAddVcEntry(&pVcTransport->Vcs,pVcEntry);
            } else {
               RxFreePool(pVcEntry);
               pVcEntry = NULL;
            }
         }
      } else {
         RxDbgTrace(0, Dbg, ("VctSelectVc: VC limit exceeded returning NULL\n"));
      }
   }

   if (pVcEntry != NULL) {
      VctReferenceVcEntry(pVcEntry);
   }

   // release the resource
   SmbCeReleaseResource();

   return pVcEntry;
}

NTSTATUS
VctInitializeExchange(
   PSMB_EXCHANGE           pExchange)
/*++

Routine Description:

    This routine initializes the transport information pertinent to a exchange

Arguments:

    pTransport         - the transport structure

    pExchange          - the exchange instance

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
   PSMBCE_SERVER_VC_TRANSPORT pVcTransport;

   SmbCeReferenceServerTransport(pExchange->SmbCeContext.pServerEntry);

   pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pExchange->SmbCeContext.pServerEntry->pTransport;

   ASSERT(pExchange->SmbCeContext.TransportContext.Vcs.pVcEntry == NULL);

   pExchange->SmbCeContext.TransportContext.Vcs.pVcEntry
                     = VctSelectMultiplexedVcEntry(pVcTransport);

   if (pExchange->SmbCeContext.TransportContext.Vcs.pVcEntry == NULL) {
      RxDbgTrace(0, Dbg, ("VctInitializeExchange: Unsuccessful\n"));
      return STATUS_CONNECTION_DISCONNECTED;
   } else {
      RxDbgTrace(0, Dbg, ("VctInitializeExchange: Successful\n"));
      return STATUS_SUCCESS;
   }
}

NTSTATUS
VctUninitializeExchange(
   PSMB_EXCHANGE         pExchange)
/*++

Routine Description:

    This routine uninitializes the transport information pertinent to a exchange

Arguments:

    pExchange          - the exchange instance

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
   PSMBCE_SERVER_VC_TRANSPORT pVcTransport;

   pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pExchange->SmbCeContext.pServerEntry->pTransport;

   RxDbgTrace(0, Dbg, ("VctUninitializeExchange: Successful\n"));

   if (pExchange->SmbCeContext.TransportContext.Vcs.pVcEntry != NULL) {
      VctDereferenceVcEntry(pExchange->SmbCeContext.TransportContext.Vcs.pVcEntry);
   }

   SmbCeDereferenceServerTransport(pExchange->SmbCeContext.pServerEntry);

   pExchange->SmbCeContext.TransportContext.Vcs.pVcEntry = NULL;

   return STATUS_SUCCESS;
}


NTSTATUS
VctIndReceive(
      IN PVOID              pEventContext,
      IN RXCE_VC_HANDLE     hVc,
      IN ULONG              ReceiveFlags,
      IN ULONG              BytesIndicated,
      IN ULONG              BytesAvailable,
      OUT ULONG             *pBytesTaken,
      IN PVOID              pTsdu,                  // pointer describing this TSDU, typically a lump of bytes
      OUT PMDL *pDataBufferPointer,    // the buffer in which data is to be copied.
      OUT PULONG            pDataBufferSize         // amount of data to copy
     )
/*++

Routine Description:

    This routine handles the receive indication for SMB's along all vcs in a connection to a
    server.

Arguments:

    pEventContext      - the server entry

    hVc                - the Vc on which the SMB has been received

    ReceiveFlags       - options for receive

    BytesIndicated     - the bytes that are present in the indication.

    BytesAvailable     - the total data available

    pTsdu              - the data

    pDataBufferPointer - the buffer for copying the data not indicated.

    pDataBufferSize    - the length of the buffer

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS Status;

   BYTE                     *pSmbCommand;
   PSMBCEDB_SERVER_ENTRY    pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;
   PSMBCE_VC_ENTRY        pVcEntry;
   PSMBCEDB_REQUEST_ENTRY   pRequestEntry;
   PSMB_EXCHANGE            pExchange;
   PSMB_HEADER              pSmbHeader = (PSMB_HEADER)pTsdu;
   PSMBCE_SERVER_VC_TRANSPORT    pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerEntry->pTransport;

   Status = SmbCeReceiveInd(
               pServerEntry,
               BytesIndicated,
               BytesAvailable,
               pBytesTaken,
               pTsdu,
               pDataBufferPointer,
               pDataBufferSize);

   return Status;
}

NTSTATUS
VctIndDataReady(
   IN PVOID        pEventContext,
   IN PMDL pBuffer,
   IN ULONG        DataSize,
   IN NTSTATUS     CopyDataStatus
   )
/*++

Routine Description:

    This routine handles the indication when the requested data has been copied

Arguments:

    pEventContext - the server instance

    pBuffer       - the buffer being returned

    DataSize      - the amount of data copied in bytes

    CopyDataStatus - CopyDataStatus

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

--*/
{
   NTSTATUS Status;
   PSMBCEDB_SERVER_ENTRY  pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;

   Status = SmbCeDataReadyInd(
                  pServerEntry,
                  pBuffer,
                  DataSize,
                  CopyDataStatus);

   return STATUS_SUCCESS;
}

NTSTATUS
VctIndDisconnect(
    IN PVOID          pEventContext,
    IN RXCE_VC_HANDLE hVc,
    IN int            DisconnectDataLength,
    IN PVOID          DisconnectData,
    IN int            DisconnectInformationLength,
    IN PVOID          DisconnectInformation,
    IN ULONG          DisconnectFlags
    )
/*++

Routine Description:

    This routine handles the disconnect indication for a VC.

Arguments:

    pEventContext               - the server instance

    hVc                         - the virtual circuit

    DisconnectDataLength        -

    DisconnectData              -

    DisconnectInformationLength -

    DisconnectInformation       -

    DisconnectFlags             -

Return Value:

    STATUS_SUCCESS - the disconnect indication has been handled

--*/
{
   PSMBCEDB_SERVER_ENTRY    pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;
   PSMBCEDB_SERVER_ENTRY    pListEntry;
   PSMBCE_VC_ENTRY        pVcEntry;
   PSMBCEDB_REQUEST_ENTRY   pRequestEntry;
   PSMB_EXCHANGE            pExchange;
   PSMBCE_SERVER_VC_TRANSPORT    pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerEntry->pTransport;

   BOOLEAN fValidServerEntry = FALSE;

   // Traverse the list of server entries to ensure that the disconnect was on a
   // valid server entry. If it is not on a valid server entry ignore it.

   SmbCeAcquireSpinLock();

   pListEntry = SmbCeGetFirstServerEntry();

   while (pListEntry != NULL) {
      if (pListEntry == pServerEntry) {
         fValidServerEntry = TRUE;
         break;
      }
      pListEntry = SmbCeGetNextServerEntry(pListEntry);
   }

   // Since the two spin locks are currently aliased to be the same.
   // VctAcquireSpinLock();
   // SmbCeDbReleaseSpinLock();

   if (fValidServerEntry && (pVcTransport != NULL)) {
      pVcEntry = VctGetFirstVcEntry(&pVcTransport->Vcs);
      while ((pVcEntry != NULL) && (pVcEntry->Vc.hVc != hVc)) {
         pVcEntry = VctGetNextVcEntry(&pVcTransport->Vcs,pVcEntry);
      }

      if (pVcEntry != NULL) {
         VctUpdateVcStateLite(pVcEntry,SMBCE_VC_STATE_DISCONNECTED);
         pVcEntry->Status   = STATUS_CONNECTION_DISCONNECTED;
      }
   }

   // Release the resource
   VctReleaseSpinLock();

   if (fValidServerEntry) {

     RxDbgTrace(0,Dbg,("@@@@@@ Disconnect Indication for %lx @@@@@\n",pServerEntry));
     InterlockedIncrement(&MRxIfsStatistics.ServerDisconnects);

      // Update the Server entry if this is the only VC associated with the transport.
      SmbCeTransportDisconnectIndicated(pServerEntry);

      RxDbgTrace(0, Dbg, ("VctIndDisconnect: Processing Disconnect indication on VC entry %lx\n",pVcEntry));
   }

   return STATUS_SUCCESS;
}

NTSTATUS
VctIndError(
    IN PVOID          pEventContext,
    IN RXCE_VC_HANDLE hVc,
    IN NTSTATUS       IndicatedStatus
    )
/*++

Routine Description:

    This routine handles the error indication

Arguments:

    pEventContext - the server instance

    hVc           - the virtual circuit handle.

    Status        - the error

Return Value:

    STATUS_SUCCESS

--*/
{
   NTSTATUS                   Status;
   PSMBCEDB_SERVER_ENTRY      pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;
   PSMBCE_VC_ENTRY            pVcEntry;
   PSMB_EXCHANGE              pExchange;
   PSMBCE_SERVER_VC_TRANSPORT pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerEntry->pTransport;

   // Acquire the resource
   VctAcquireSpinLock();

   // Map the RXCE vc handle to the appropriate SMBCE entry and get the request
   // list associated with it.

   pVcEntry = VctGetFirstVcEntry(&pVcTransport->Vcs);
   while ((pVcEntry != NULL) && (pVcEntry->Vc.hVc != hVc)) {
      pVcEntry = VctGetNextVcEntry(&pVcTransport->Vcs,pVcEntry);
   }

   if (pVcEntry != NULL) {
      VctUpdateVcStateLite(pVcEntry,SMBCE_VC_STATE_DISCONNECTED);
      pVcEntry->Status   = IndicatedStatus;
   }

   // Release the resource
   VctReleaseSpinLock();

   RxDbgTrace(0, Dbg, ("VctIndError: Processing Error indication on VC entry %lx\n",pVcEntry));

   Status = SmbCeErrorInd(
                  pServerEntry,
                  IndicatedStatus);

   return Status;
}

NTSTATUS
VctIndEndpointError(
    IN PVOID          pEventContext,
    IN NTSTATUS       IndicatedStatus
    )
/*++

Routine Description:

    This routine handles the error indication

Arguments:

    pEventContext - the server instance

    Status        - the error

Return Value:

    STATUS_SUCCESS

--*/
{
   return STATUS_SUCCESS;
}

NTSTATUS
VctIndSendPossible(
    IN PVOID          pEventContext,    // the event context.
    IN RXCE_VC_HANDLE hVc,
    IN ULONG          BytesAvailable
    )
/*++

Routine Description:

    This routine handles the error indication

Arguments:

    pEventContext - the server instance

    hVc           - the VC instance

    BytesAvailable - the number of bytes that can be sent

Return Value:

    STATUS_SUCCESS

--*/
{
   return STATUS_SUCCESS;
}

NTSTATUS
VctIndReceiveDatagram(
    IN PVOID   pRxCeEventContext,      // the event context
    IN int     SourceAddressLength,    // length of the originator of the datagram
    IN PVOID   SourceAddress,          // string describing the originator of the datagram
    IN int     OptionsLength,          // options for the receive
    IN PVOID   Options,                //
    IN ULONG   ReceiveDatagramFlags,   //
    IN ULONG   BytesIndicated,         // number of bytes this indication
    IN ULONG   BytesAvailable,         // number of bytes in complete Tsdu
    OUT ULONG  *BytesTaken,            // number of bytes used
    IN PVOID   Tsdu,                   // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL   *pDataBufferPointer,    // the buffer in which data is to be copied.
    OUT PULONG pDataBufferSize         // amount of data to copy
    )
{
   return STATUS_SUCCESS;
}

NTSTATUS
VctIndSendComplete(
   IN PVOID          pEventContext,
   IN RXCE_VC_HANDLE hVc,
   IN PVOID          pCompletionContext,
   IN NTSTATUS       SendCompletionStatus
   )
/*++

Routine Description:

    This routine handles the send complete indication for asynchronous sends

Arguments:

    pEventContext - the server instance

    hVc           - the VC instance

    pCompletionContext - the context for identifying the send request

    SendCompletionStatus - the send completion status

Return Value:

    STATUS_SUCCESS always ..

--*/
{
   NTSTATUS Status;

   PSMBCEDB_SERVER_ENTRY    pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;

   Status = SmbCeSendCompleteInd(
                  pServerEntry,
                  pCompletionContext,
                  SendCompletionStatus);

   return Status;
}

//
// Static dispatch vectors for Virtual Circuit based transports
//

RXCE_ADDRESS_EVENT_HANDLER
MRxSmbVctAddressEventHandler = {
                                   VctIndEndpointError,
                                   VctIndReceiveDatagram,
                                   VctIndDataReady,
                                   VctIndSendPossible,
                                   NULL
                               };

RXCE_CONNECTION_EVENT_HANDLER
MRxSmbVctConnectionEventHandler = {
                                      VctIndDisconnect,
                                      VctIndError,
                                      VctIndReceive,
                                      VctIndReceiveDatagram,
                                      VctIndReceive,
                                      VctIndSendPossible,
                                      VctIndDataReady,
                                      VctIndSendComplete
                                  };

TRANSPORT_DISPATCH_VECTOR
MRxSmbVctTransportDispatch = {
                                VctSend,
                                VctSendDatagram,
                                VctTranceive,
                                VctReceive,
                                NULL,
                                VctInitializeExchange,
                                VctUninitializeExchange,
                                VctTearDownServerTransport
                             };


typedef enum _RXCE_VC_FUNCTION_CODE {
   VcConnect,
   VcDisconnect
} RXCE_VC_FUNCTION_CODE, *PRXCE_VC_FUNCTION_CODE;

typedef struct _RXCE_VC_CONNECT_CONTEXT {
   RXCE_VC_FUNCTION_CODE   FunctionCode;
   PRX_WORKERTHREAD_ROUTINE pRoutine;
   PSMBCEDB_SERVER_ENTRY   pServerEntry;
   PSMBCE_SERVER_TRANSPORT pServerTransport;
   NTSTATUS                Status;
   KEVENT                  SyncEvent;
} RXCE_VC_CONNECT_CONTEXT, *PRXCE_VC_CONNECT_CONTEXT;

NTSTATUS
VctInitialize(
         PSMBCEDB_SERVER_ENTRY   pServerEntry,
         PSMBCE_TRANSPORT        pTransport,
         RXCE_CONNECTION_HANDLE  hConnection,
         RXCE_VC_HANDLE          hVc,
         PSMBCE_SERVER_TRANSPORT *pServerTransportPtr)
/*++

Routine Description:

    This routine initializes the transport information corresponding to a server

Arguments:

    pServerEntry - the server entry instance in the database

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    The remote address can be either deduced from the information in the Rx Context
    or a NETBIOS address needs to be built from the server name.
    This transport address is used subsequently to establish the connection.

--*/
{
   NTSTATUS Status;
   PSMBCE_SERVER_VC_TRANSPORT pVcTransport;
   PSMBCE_VC_ENTRY     pVcEntry;

   pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)
                  SmbMmAllocateServerTransport(SMBCE_STT_VC);

   pVcEntry     = (PSMBCE_VC_ENTRY)
                        RxAllocatePoolWithTag(
                           NonPagedPool,
                           sizeof(SMBCE_VC_ENTRY),
                           MRXSMB_VC_POOLTAG);

   if ((pVcTransport != NULL) && (pVcEntry != NULL)) {
      RXCE_CONNECTION_INFO         ConnectionInfo;
      RXCE_TRANSPORT_PROVIDER_INFO ProviderInfo;

      SmbMmInitializeVcEntry(pVcEntry);


      // Query the transport information ...
      Status = RxCeQueryInformation(
                      hConnection,
                      RxCeTransportProviderInformation,
                      &ProviderInfo,
                      sizeof(ProviderInfo));

      if (NT_SUCCESS(Status)) {
          pVcTransport->MaximumSendSize = MIN( ProviderInfo.MaxSendSize,
                                               MAXIMUM_PARTIAL_BUFFER_SIZE );
      } else {
          ASSERT( 1024 <= MAXIMUM_PARTIAL_BUFFER_SIZE );
          pVcTransport->MaximumSendSize = 1024;
      }



      // Query the connection information ....
      Status = RxCeQueryInformation(
                        hConnection,
                        RxCeConnectionEndpointInformation,
                        &ConnectionInfo,
                        sizeof(ConnectionInfo));


      if (NT_SUCCESS(Status)) {
         // The setting of the delay parameter is an important heuristic
         // that determines how quickly and how often timeouts occur. As
         // a first cut a very conservative estimate for the time has been
         // choosen, i.e., double the time required to transmit a 64 k packet.
         // This parameter should be fine tuned.

         pVcTransport->Delay.QuadPart = (-ConnectionInfo.Delay.QuadPart) +
                               (-ConnectionInfo.Delay.QuadPart);
         if (ConnectionInfo.Throughput.LowPart != 0) {
             pVcTransport->Delay.QuadPart +=
                         (MAX_SMB_PACKET_SIZE/ConnectionInfo.Throughput.LowPart) * 1000 * 10000;
         }

         RxDbgTrace( 0, Dbg, ("Connection delay set to %ld 100ns ticks\n",pVcTransport->Delay.LowPart));

         pVcTransport->pDispatchVector = &MRxSmbVctTransportDispatch;
         pVcTransport->hConnection     = hConnection;

         pVcEntry->Vc.hVc       = hVc;
         pVcEntry->Vc.State     = SMBCE_VC_STATE_MULTIPLEXED;
         VctAddVcEntry(&pVcTransport->Vcs,pVcEntry);

         pVcTransport->State = SMBCEDB_ACTIVE;
      } else {
         RxDbgTrace(0, Dbg, ("VctInitialize : RxCeQueryInformation returned %lx\n",Status));
      }

      if (NT_SUCCESS(Status)) {
         pVcTransport->pTransport   = pTransport;
      } else {
         RxDbgTrace(0, Dbg, ("VctInitialize : Connection Initialization Failed %lx\n",Status));
      }
   } else {
      RxDbgTrace(0, Dbg, ("VctInitialize : Memory Allocation failed\n"));
      Status = STATUS_INSUFFICIENT_RESOURCES;
   }

   // Cleanup if not successful
   if (!NT_SUCCESS(Status)) {
      if (pVcTransport != NULL) {
         RxFreePool(pVcTransport);
      }

      if (pVcEntry != NULL) {
         RxFreePool(pVcEntry);
      }

      pVcTransport = NULL;
   }

   *pServerTransportPtr = (PSMBCE_SERVER_TRANSPORT)pVcTransport;

   return Status;
}

NTSTATUS
VctUninitialize(
         PVOID pTransport)
/*++

Routine Description:

    This routine uninitializes the transport instance

Arguments:

    pVcTransport - the VC transport instance

Return Value:

    STATUS_SUCCESS - the server transport construction has been uninitialzied.

    Other Status codes correspond to error situations.

Notes:

--*/
{
   NTSTATUS                   Status = STATUS_SUCCESS;
   PSMBCE_VC_ENTRY            pVcEntry;
   PSMBCE_SERVER_VC_TRANSPORT pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;
   ULONG                      TransportFlags;
   SMBCE_VCS                  Vcs;


   // The spinlock needs to be acquired for manipulating the list of Vcs because of
   // indications that will be processed till the appropriate RXCE data structures are
   // dismantled

   VctAcquireSpinLock();

   VctTransferVcs(pVcTransport,&Vcs);

   VctReleaseSpinLock();

   pVcEntry = VctGetFirstVcEntry(&Vcs);
   while (pVcEntry != NULL) {
      // Remove the VC entry from the list of transports associated with this
      // transport instance.
      VctRemoveVcEntryLite(&Vcs,pVcEntry);

      // Assert the fact that the request list associated with the VC is empty.
      // Tear down the VC entry
      Status = RxCeTearDownVC(pVcEntry->Vc.hVc);

      // Discard the VC
      RxFreePool(pVcEntry);

      pVcEntry = VctGetFirstVcEntry(&Vcs);
   }

   // Tear down the connection endpoint ..
   Status = RxCeTearDownConnection(pVcTransport->hConnection);
   RxDbgTrace(0, Dbg, ("VctUninitialize : RxCeDisconnect returned %lx\n",Status));

   // Dereference the underlying transport
   SmbCeDereferenceTransport(pVcTransport->pTransport);

   // Free up the transport entry
   RxFreePool(pVcTransport);

   return Status;
}

VOID
VctpInitializeServerTransport(
         PRXCE_VC_CONNECT_CONTEXT pRxCeConnectContext)
/*++

Routine Description:

    This routine initializes the transport information corresponding to a server

Arguments:

    pServerEntry - the server entry instance in the database

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    Currently, only connection oriented transports are handled. The current TDI spec expects
    handles to be passed in as part of the connect request. This implies that connect/
    reconnect/disconnect requests need to be issued from the process which created the connection.
    In the case of the SMB mini rdr there is no FSP associated with it ( threads are borrowed
    /commandeered ) from the system process to do all the work. This is the reason for
    special casing VC initialization into a separate routine. The server transport initialization
    routine handles the other transport initialization and also provides the context for VC
    initialization.

--*/
{
   NTSTATUS Status;
   PSMBCEDB_SERVER_ENTRY  pServerEntry = pRxCeConnectContext->pServerEntry;

   UNICODE_STRING         ServerName;
   RXCE_VC_HANDLE         hVc;
   RXCE_CONNECTION_HANDLE hConnection;

   PSMBCE_TRANSPORT       pTransport;

   OEM_STRING   OemServerName;

   ULONG TransportAddressLength =   FIELD_OFFSET(TRANSPORT_ADDRESS,Address)
                                  + FIELD_OFFSET(TA_ADDRESS,Address)
                                  + TDI_ADDRESS_LENGTH_NETBIOS;
   CHAR  TransportAddressBuffer[  FIELD_OFFSET(TRANSPORT_ADDRESS,Address)
                                + FIELD_OFFSET(TA_ADDRESS,Address)
                                + TDI_ADDRESS_LENGTH_NETBIOS];

   PTRANSPORT_ADDRESS   pTransportAddress = (PTRANSPORT_ADDRESS)TransportAddressBuffer;
   PTDI_ADDRESS_NETBIOS pNetbiosAddress = (PTDI_ADDRESS_NETBIOS)pTransportAddress->Address[0].Address;

   pRxCeConnectContext->pServerTransport = NULL;

   SmbCeGetServerName(pServerEntry->pRdbssSrvCall,&ServerName);

   pTransportAddress->TAAddressCount = 1;
   pTransportAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
   pTransportAddress->Address[0].AddressType   = TDI_ADDRESS_TYPE_NETBIOS;
   pNetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

   OemServerName.MaximumLength = NETBIOS_NAMESIZE;
   OemServerName.Buffer        = pNetbiosAddress->NetbiosName;

   Status = RtlUpcaseUnicodeStringToOemString(&OemServerName,
                                              &ServerName,
                                              FALSE);
   if (NT_SUCCESS(Status)) {
      RXCE_CONNECTION_INFORMATION InitialConnectionInformation,
                                  FinalConnectionInformation;
      // Ensure that the name is always of the desired length by padding
      // white space to the end.
      RtlCopyMemory(&OemServerName.Buffer[OemServerName.Length],
                    "                ",
                    NETBIOS_NAMESIZE - OemServerName.Length);

      InitialConnectionInformation.UserDataLength = 0;
      InitialConnectionInformation.OptionsLength  = 0;
      InitialConnectionInformation.RemoteAddressLength = TransportAddressLength;
      InitialConnectionInformation.RemoteAddress       = TransportAddressBuffer;

      FinalConnectionInformation = InitialConnectionInformation;

      // Try to establish a connection on any of the active transports.
      pTransport = SmbCeGetNextTransport(NULL);

      if (pTransport != NULL) {
         BOOLEAN          SynchronousConnect = TRUE;
         PSMBCE_TRANSPORT pNextTransport;

         do {
            Status = RxCeCreateConnection(
                           pTransport->hAddress,
                           &ServerName,
                           &InitialConnectionInformation,
                           &MRxSmbVctConnectionEventHandler,
                           pServerEntry,
                           &hConnection,
                           &hVc);
            if (SynchronousConnect && (Status == STATUS_SUCCESS)) {
               break;
            }

            pNextTransport = SmbCeGetNextTransport(pTransport);
            SmbCeDereferenceTransport(pTransport);
            pTransport = pNextTransport;
         } while (pTransport != NULL);

         if (SynchronousConnect) {
            if (pTransport == NULL) {
               // all the active transports were exhausted and none of the
               // connects succeeded
               Status = STATUS_BAD_NETWORK_NAME;
            }
         } else {
            // It is an asynchronous connect. Need to wait for the results
         }
      } else {
         Status = STATUS_NETWORK_UNREACHABLE;
         RxDbgTrace(0, Dbg, ("SmbCeInitializeServerTransport : No registered transports returning%lx\n",Status));
      }
   }

   if (NT_SUCCESS(Status)) {
      Status = VctInitialize(
                  pServerEntry,        // The server entry
                  pTransport,          // the transport/address information
                  hConnection,         // the connection
                  hVc,                // the virtual circuit
                  &pRxCeConnectContext->pServerTransport);

      if (!NT_SUCCESS(Status)) {
         NTSTATUS CleanupStatus;

         if (hVc != INVALID_RXCE_HANDLE) {
            CleanupStatus = RxCeTearDownVC(hVc);
            RxDbgTrace(0, Dbg, ("SmbCeInitializeServerTransport : RxCeRemoveVc returned %lx\n",CleanupStatus));
         }

         if (hConnection != INVALID_RXCE_HANDLE) {
            CleanupStatus = RxCeTearDownConnection(hConnection);
            RxDbgTrace(0, Dbg, ("SmbCeInitializeServerTransport : RxCeDisconnect returned %lx\n",CleanupStatus));
         }

         SmbCeDereferenceTransport(pTransport);
      }
   }

   pRxCeConnectContext->Status = Status;
   KeSetEvent( &pRxCeConnectContext->SyncEvent, 0, FALSE );
}



VOID
VctpUninitializeServerTransport(
         PRXCE_VC_CONNECT_CONTEXT pRxCeConnectContext)
/*++

Routine Description:

    This routine uninitializes the transport information corresponding to a server

Arguments:

    pServerEntry - the server entry instance in the database

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    Currently, only connection oriented transports are handled.

--*/
{
   PSMBCE_SERVER_TRANSPORT pServerTransport = pRxCeConnectContext->pServerTransport;

   if (pServerTransport != NULL) {
      VctUninitialize(pServerTransport);
   }

   pRxCeConnectContext->Status = STATUS_SUCCESS;
   KeSetEvent( &pRxCeConnectContext->SyncEvent, 0, FALSE );
}

NTSTATUS
VctpInvokeTransportFunction(
      PRXCE_VC_CONNECT_CONTEXT pRxCeConnectContext)
/*++

Routine Description:

    This routine invokes the iniytialization/uninitialization function for the VC
    transport

Arguments:

    pRxCeConnectContext -- the RxCe connection context.

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    Currently, only connection oriented transports are handled.

--*/
{
   NTSTATUS Status;

   if (IoGetCurrentProcess() != RxGetRDBSSProcess()) {
      Status = RxDispatchToWorkerThread(
                  MRxIfsDeviceObject,
                  HyperCriticalWorkQueue,
                  pRxCeConnectContext->pRoutine,
                  pRxCeConnectContext);
   } else {
      Status = STATUS_SUCCESS;
      (pRxCeConnectContext->pRoutine)(pRxCeConnectContext);
   }

   if (Status == STATUS_SUCCESS) {
      KeWaitForSingleObject(
            &pRxCeConnectContext->SyncEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL );

      Status = pRxCeConnectContext->Status;
   }

   KeResetEvent( &pRxCeConnectContext->SyncEvent );

   return Status;
}

NTSTATUS
VctInstantiateServerTransport(
   PSMBCEDB_SERVER_ENTRY   pServerEntry,
   PSMBCE_SERVER_TRANSPORT *pServerTransportPtr)
{
   PRXCE_VC_CONNECT_CONTEXT pRxCeConnectContext;

   NTSTATUS Status;

   pRxCeConnectContext = (PRXCE_VC_CONNECT_CONTEXT)RxAllocatePoolWithTag(
                                                      NonPagedPool,
                                                      sizeof(RXCE_VC_CONNECT_CONTEXT),
                                                      MRXSMB_VC_POOLTAG);

   if (pRxCeConnectContext != NULL) {
      pRxCeConnectContext->pServerEntry     = pServerEntry;
      pRxCeConnectContext->Status           = STATUS_SUCCESS;
      pRxCeConnectContext->pServerTransport = NULL;
      pRxCeConnectContext->FunctionCode     = VcConnect;
      pRxCeConnectContext->pRoutine         = VctpInitializeServerTransport;

      KeInitializeEvent(&pRxCeConnectContext->SyncEvent,NotificationEvent,FALSE);

      Status = VctpInvokeTransportFunction(pRxCeConnectContext);

      *pServerTransportPtr = pRxCeConnectContext->pServerTransport;

      RxFreePool(pRxCeConnectContext);
   } else {
      Status = STATUS_INSUFFICIENT_RESOURCES;
   }

   return Status;
}

NTSTATUS
VctTearDownServerTransport(
   PSMBCE_SERVER_TRANSPORT pServerTransport)
{
   PRXCE_VC_CONNECT_CONTEXT pRxCeConnectContext;

   NTSTATUS Status;

   pRxCeConnectContext = (PRXCE_VC_CONNECT_CONTEXT)RxAllocatePoolWithTag(
                                                      NonPagedPool,
                                                      sizeof(RXCE_VC_CONNECT_CONTEXT),
                                                      MRXSMB_VC_POOLTAG);

   if (pRxCeConnectContext != NULL) {
      pRxCeConnectContext->pServerEntry     = NULL;
      pRxCeConnectContext->Status           = STATUS_SUCCESS;
      pRxCeConnectContext->pServerTransport = pServerTransport;
      pRxCeConnectContext->FunctionCode     = VcDisconnect;
      pRxCeConnectContext->pRoutine         = VctpUninitializeServerTransport;

      KeInitializeEvent(&pRxCeConnectContext->SyncEvent,NotificationEvent,FALSE);

      Status = VctpInvokeTransportFunction(pRxCeConnectContext);

      RxFreePool(pRxCeConnectContext);
   } else {
      Status = STATUS_INSUFFICIENT_RESOURCES;
   }

   return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\sys\usrcnnct.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    usrConnct.c

Abstract:

    This module implements the nt version of the high level routines dealing with connections including both the
    routines for establishing connections and the winnet connection apis.

--*/

#include "precomp.h"
#pragma hdrstop
#include <ntddnfs2.h>
#include <ntddmup.h>
#include "fsctlbuf.h"
#include "prefix.h"
#include <lmuse.h>    //need the lm constants here......because of wkssvc
#include "secext.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_NTCONNCT)

//
//  The local trace mask for this part of the module
//

#define Dbg                              (DEBUG_TRACE_CONNECT)





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\dll\nulmrxnp.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    nulmrxnp.h

Abstract:

    This module includes all network provider router interface related
    definitions for the sample

Notes:

    This module has been built and tested only in UNICODE environment

--*/

#ifndef _NULMRXNP_H_
#define _NULMRXNP_H_

#define NULMRXNP_DEBUG_CALL     0x1
#define NULMRXNP_DEBUG_ERROR    0x2
#define NULMRXNP_DEBUG_INFO     0x4

extern DWORD NulMRxNpDebugLevel;

#define TRACE_CALL(Args)    \
            if (NulMRxNpDebugLevel & NULMRXNP_DEBUG_CALL) {    \
                DbgPrint##Args;                 \
            }

#define TRACE_ERROR(Args)    \
            if (NulMRxNpDebugLevel & NULMRXNP_DEBUG_ERROR) {    \
                DbgPrint##Args;                 \
            }

#define TRACE_INFO(Args)    \
            if (NulMRxNpDebugLevel & NULMRXNP_DEBUG_INFO) {    \
                DbgPrint##Args;                 \
            }

typedef struct _NULMRXNP_ENUMERATION_HANDLE_ {
    INT  LastIndex;
} NULMRXNP_ENUMERATION_HANDLE,
  *PNULMRXNP_ENUMERATION_HANDLE;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\dll\dllmain.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    dllmain.c

Abstract:

    This module implements the initialization routines for network
    provider interface

Notes:

    This module has been built and tested only in UNICODE environment

--*/

#include <windows.h>
#include <process.h>


// NOTE:
//
// Function:	DllMain
//
// Return:	TRUE  => Success
//		FALSE => Failure

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
{
    BOOL	bStatus = TRUE;
    WORD	wVersionRequested;

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    default:
        break;
    }

    return(bStatus);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\ea.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    ea.c

Abstract:

    This module implements 'extended attributes' on a file handle

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_EA)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NulMRxQueryEaInformation)
#endif

//
//  Extended Attributes (EA) functionality
//

NTSTATUS
NulMRxQueryEaInformation (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine queries IFS for extended attributes like 
   scatter-gather list and filename for an IFS handle.
   
Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;

    PMRX_SRV_OPEN pSrvOpen = capFobx->pSrvOpen;
    PFILE_FULL_EA_INFORMATION pEaInfo = (PFILE_FULL_EA_INFORMATION) RxContext->Info.Buffer;
    ULONG BufferLength = RxContext->Info.LengthRemaining;
    ULONG UserEaListLength = RxContext->QueryEa.UserEaListLength;
    PUCHAR UserEaList = RxContext->QueryEa.UserEaList;
    PFILE_GET_EA_INFORMATION pGetEaInfo = (PFILE_GET_EA_INFORMATION) UserEaList;
    NulMRxGetFcbExtension(capFcb,pFcbExtension);
    PMRX_NET_ROOT pNetRoot = capFcb->pNetRoot;
    NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);

    RxTraceEnter("NulMRxQueryEaInformation");
    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("Ea buffer len remaining is %d\n", RxContext->Info.LengthRemaining));

    RxTraceLeave(Status);
    return(Status);
}

NTSTATUS
NulMRxSetEaInformation (
    IN OUT PRX_CONTEXT  RxContext
    )
/*++

Routine Description:

   This routine sets the EA information for this FCB
   
Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(RxContext);

    DbgPrint("NulMRxSetEaInformation");
    return STATUS_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\devfcb.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    devfcb.c

Abstract:

    This module implements the mechanism for deleting an established connection

--*/

#include "precomp.h"
#pragma hdrstop
#include "fsctlbuf.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DEVFCB)

#define FIXED_CONNECT_NAME L"\\;0:\\nulsvr\\share"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NulMRxDevFcbXXXControlFile)
#endif

NTSTATUS
NulMRxDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine handles all the device FCB related FSCTL's in the mini rdr

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    a valid NTSTATUS code.

Notes:

--*/
{
    NTSTATUS Status;
    RxCaptureFobx;
    UCHAR MajorFunctionCode  = RxContext->MajorFunction;
    NulMRxGetDeviceExtension(RxContext,pDeviceExtension);
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    ULONG ControlCode = 0;

    DbgPrint("NulMRxDevFcb\n");

    switch (MajorFunctionCode)
    {
        case IRP_MJ_FILE_SYSTEM_CONTROL:
        {
            switch (LowIoContext->ParamsFor.FsCtl.MinorFunction)
            {
                case IRP_MN_USER_FS_REQUEST:
                    switch (ControlCode) {
                        default:
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                    }
                    break;
                default :  //minor function != IRP_MN_USER_FS_REQUEST
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
        } // FSCTL case
        break;

        case IRP_MJ_DEVICE_CONTROL:
        {

            ControlCode = LowIoContext->ParamsFor.IoCtl.IoControlCode;

            switch (ControlCode) {

                case IOCTL_NULMRX_ADDCONN:
                {
                    Status = NulMRxCreateConnection( RxContext, &RxContext->PostRequest );
                }
                break;

                case IOCTL_NULMRX_DELCONN:
                    Status = NulMRxDeleteConnection( RxContext, &RxContext->PostRequest );
                    break;

                case IOCTL_NULMRX_GETLIST:
                {
                    ULONG   cbOut = LowIoContext->ParamsFor.IoCtl.OutputBufferLength;
                    PVOID   pbOut = LowIoContext->ParamsFor.IoCtl.pOutputBuffer;

                    if ( cbOut >= 26 )
                    {
                        BOOLEAN GotMutex;

                        GotMutex = ExTryToAcquireFastMutex( &pDeviceExtension->LCMutex );
                        RtlCopyMemory( pbOut, pDeviceExtension->LocalConnections, 26 );
                        if ( GotMutex );
                        {
                            ExReleaseFastMutex( &pDeviceExtension->LCMutex );
                        }
                        RxContext->InformationToReturn = 26;
                    }
                    else
                    {
                        RxContext->InformationToReturn = 0;
                    }

                    Status = STATUS_SUCCESS;
                }
                break;

                case IOCTL_NULMRX_GETCONN:
                {
                    UNICODE_STRING      LookupName;
                    UNICODE_STRING      RemainingName;
                    LOCK_HOLDING_STATE  LockHoldingState;
                    PVOID               Container;
                    ULONG               ReturnedSize = 0;

                    ULONG   ConnectNameLen  = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
                    PWCHAR  ConnectName     = LowIoContext->ParamsFor.IoCtl.pInputBuffer;
                    ULONG   RemoteNameLen   = LowIoContext->ParamsFor.IoCtl.OutputBufferLength;
                    PULONG  RemoteName      = LowIoContext->ParamsFor.IoCtl.pOutputBuffer;

                    PRX_PREFIX_TABLE  pRxNetNameTable
                                       = RxContext->RxDeviceObject->pRxNetNameTable;


                    // insert the local connection name
                    if ( ConnectNameLen > sizeof( WCHAR ) )
                    {
                        PWCHAR pLookupName = ExAllocatePool( PagedPool, sizeof(FIXED_CONNECT_NAME) );

                        RtlCopyMemory( pLookupName, FIXED_CONNECT_NAME, sizeof( FIXED_CONNECT_NAME ) );
                        pLookupName[2] = ConnectName[0];
                        LookupName.Buffer        = pLookupName;
                        LookupName.Length        = sizeof(FIXED_CONNECT_NAME);
                        LookupName.MaximumLength = sizeof(FIXED_CONNECT_NAME);
                        if ( LookupName.Buffer )
                        {
                            LockHoldingState = LHS_SharedLockHeld;

                            RxAcquirePrefixTableLockShared(pRxNetNameTable, TRUE);
                            Container = RxPrefixTableLookupName(pRxNetNameTable,
                                                      &LookupName, &RemainingName, NULL);
                            if (Container)
                            {
                                switch (NodeType(Container))
                                {
                                    case RDBSS_NTC_V_NETROOT:
                                    {
                                        PMRX_NET_ROOT pNetRoot = ((PV_NET_ROOT)Container)->pNetRoot;
                                        RtlCopyMemory( RemoteName, pNetRoot->pNetRootName->Buffer, pNetRoot->pNetRootName->Length );
                                        ReturnedSize = pNetRoot->pNetRootName->Length;
                                        RxDereferenceVNetRoot((PV_NET_ROOT)Container, LockHoldingState);
                                    }
                                    break;
                                    
                                    case RDBSS_NTC_NETROOT:
                                    {
                                        PNET_ROOT pNetRoot = (PNET_ROOT) Container;
                                        RtlCopyMemory( RemoteName, pNetRoot->pNetRootName->Buffer, pNetRoot->pNetRootName->Length );
                                        ReturnedSize = pNetRoot->pNetRootName->Length;
                                        RxDereferenceNetRoot((PNET_ROOT)Container, LockHoldingState);
                                    }
                                    break;

                                    case RDBSS_NTC_SRVCALL:
                                        RxDereferenceSrvCall((PSRV_CALL)Container, LockHoldingState);
                                        ReturnedSize = 0;
                                        break;
                                    default:
                                        RxDereference((PVOID)Container,LockHoldingState);
                                        ReturnedSize = 0;
                                        break;
                                }
                            }

                            RxReleasePrefixTableLock(pRxNetNameTable);
                            ExFreePool( LookupName.Buffer );
                        }
                    }
                    if ( ReturnedSize )
                    {
                        Status = STATUS_SUCCESS;
                    }
                    else
                    {
                        Status = STATUS_BAD_NETWORK_NAME;
                    }
                    RxContext->InformationToReturn = ReturnedSize;
                }
                break;

                default :
                    Status = STATUS_INVALID_DEVICE_REQUEST;
            }
        }
        break;

        case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        {
            switch (ControlCode) {
            default :
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }
        }
        break;

        default:
        ASSERT(!"unimplemented major function");
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    DbgPrint("NulMRxDevFcb st,info=%08lx,%08lx\n",
                            Status,RxContext->InformationToReturn);
    return(Status);
}


HANDLE
GetConnectionHandle(
    IN PUNICODE_STRING  ConnectionName
    )
{

    NTSTATUS            Status;
    HANDLE              Handle;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      FileName;

    // Connection name should get checked to be certain our device is in the path

    InitializeObjectAttributes(
        &ObjectAttributes,
        ConnectionName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);


    Status = ZwCreateFile(
        &Handle,
        SYNCHRONIZE,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,           // Allocation size
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,           // Ptr to EA Buffer
        0);         // Length of EA buffer

    DbgPrint("ZwCreateFile returned %lx\n",Status);

    if ( (STATUS_SUCCESS == Status) && (INVALID_HANDLE_VALUE != Handle) ) {
        DbgPrint("ZwCreateFile returned success\n");
    }
    else
        Handle = INVALID_HANDLE_VALUE;

    return  Handle;
}


NTSTATUS
DoCreateConnection(
    IN PRX_CONTEXT RxContext,
    ULONG   CreateDisposition
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE          Handle;
    PLOWIO_CONTEXT  LowIoContext       = &RxContext->LowIoContext;
    ULONG           ConnectNameLen     = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    PWCHAR          ConnectName        = LowIoContext->ParamsFor.IoCtl.pInputBuffer;
    UNICODE_STRING  FileName;
    NulMRxGetDeviceExtension(RxContext,pDeviceExtension);

    // The sample code passes in only the filename in the Ioctl data buffer.
    //  An actual implementation could pass in stuff like EAs, security
    // credentials, etc

    RxDbgTrace(0, Dbg,("DoCreateConnection"));

    FileName.Buffer        = ConnectName;
    FileName.Length        = (USHORT) ConnectNameLen;
    FileName.MaximumLength = (USHORT) ConnectNameLen;

    Handle = GetConnectionHandle(&FileName);

    if ( INVALID_HANDLE_VALUE != Handle )
    {
        PWCHAR pwcLC;
        ULONG i;

        DbgPrint("GetConnectionHandle returned success\n");
        ZwClose(Handle);
        for ( i = 0, pwcLC = (PWCHAR) ConnectName; i < ConnectNameLen, *pwcLC!= L':';
              i+=sizeof(WCHAR), pwcLC++ );
        if ( i >= sizeof(WCHAR) && i < ConnectNameLen )
        {
            pwcLC--;
            if ( *pwcLC >= L'A' && *pwcLC <= L'Z' )
            {
                ExAcquireFastMutex( &pDeviceExtension->LCMutex );
                pDeviceExtension->LocalConnections[*pwcLC - L'A'] = TRUE;
                ExReleaseFastMutex( &pDeviceExtension->LCMutex );
            }
        }
    }
    else
    {
        DbgPrint("GetConnectionHandle returned failure\n");
        Status = STATUS_BAD_NETWORK_NAME;
    }

    return(Status);
}


NTSTATUS
NulMRxCreateConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:


Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context....for later when i need the buffers

Return Value:

RXSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PAGED_CODE();

    DbgPrint("NulMrxCreateConnection called\n");
    RxDbgTrace(+1, Dbg, ("NulMRxCreateConnection \n"));

    if (!Wait) {
        //just post right now!
        *PostToFsp = TRUE;
        return STATUS_PENDING;
    }

    Status = DoCreateConnection(RxContext, (ULONG)FILE_OPEN_IF);

    return Status;
}


NTSTATUS
DoDeleteConnection(
    PUNICODE_STRING FileName
    )
{
    HANDLE          Handle;
    NTSTATUS        Status;
    PFILE_OBJECT    pFileObject;
    PNET_ROOT       NetRoot;
    PV_NET_ROOT     VNetRoot;
    PFOBX           Fobx;

    Handle = GetConnectionHandle(FileName);

    if ( INVALID_HANDLE_VALUE != Handle ) {
        DbgPrint("GetConnectionHandle returned success\n");

        Status = ObReferenceObjectByHandle(
                Handle,
                0L,
                NULL,
                KernelMode,
                (PVOID *)&pFileObject,
                NULL);

        DbgPrint("ObReferenceObjectByHandle worked ok\n");
        if ( NT_SUCCESS(Status) ) {

            // Got the FileObject. Now get an Fobx
            Fobx = pFileObject->FsContext2;
            if (NodeType(Fobx)==RDBSS_NTC_V_NETROOT) {
                VNetRoot = (PV_NET_ROOT)(Fobx);
                NetRoot = (PNET_ROOT)VNetRoot->NetRoot;
                DbgPrint("Calling RxFinalizeConnection\n");
                Status = RxFinalizeConnection(NetRoot,VNetRoot,TRUE);
            } else {
                ASSERT(FALSE);
                Status = STATUS_INVALID_DEVICE_REQUEST;
            }

            ObDereferenceObject(pFileObject);
        }

        ZwClose(Handle);
    }

    return Status;
}


NTSTATUS
NulMRxDeleteConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:

    This routine deletes a single vnetroot.

Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context....for later when i need the buffers

Return Value:

RXSTATUS

--*/
{
    NTSTATUS        Status;
    UNICODE_STRING  FileName;
    BOOLEAN         Wait              = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    PLOWIO_CONTEXT  LowIoContext      = &RxContext->LowIoContext;
    PWCHAR          ConnectName       = LowIoContext->ParamsFor.IoCtl.pInputBuffer;
    ULONG           ConnectNameLen    = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    NulMRxGetDeviceExtension(RxContext,pDeviceExtension);

    PAGED_CODE();

    //RxDbgTrace(+1, Dbg, ("NulMRxDeleteConnection Fobx %08lx\n", capFobx));

    if (!Wait) {
        //just post right now!
        *PostToFsp = TRUE;
        return(STATUS_PENDING);
    }

    FileName.Buffer        = ConnectName;
    FileName.Length        = (USHORT) ConnectNameLen;
    FileName.MaximumLength = (USHORT) ConnectNameLen;

    Status = DoDeleteConnection(&FileName);

    if ( NT_SUCCESS(Status) ) {
        PWCHAR pwcLC;
        ULONG i;

        for ( i = 0, pwcLC = ConnectName; i < ConnectNameLen, *pwcLC!= L':';
              i+=sizeof(WCHAR), pwcLC++ );
        if ( i >= sizeof(WCHAR) && i < ConnectNameLen )
        {
            pwcLC--;
            if ( *pwcLC >= L'A' && *pwcLC <= L'Z' )
            {
                ExAcquireFastMutex( &pDeviceExtension->LCMutex );
                pDeviceExtension->LocalConnections[*pwcLC - L'A'] = FALSE;
                ExReleaseFastMutex( &pDeviceExtension->LCMutex );
            }
        }
    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\devctrl.c ===
/*++

Copyright (c) 1989 - 1999   Microsoft Corporation

Module Name:

    devctrl.c

Abstract:

    This module implements DeviceIoControl operations.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

RXDT_DefineCategory(DEVCTRL);

#define Dbg                              (DEBUG_TRACE_DEVCTRL)


//
//  forwards & code allocation pragmas
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NulMRxIoCtl)
#endif

   
NTSTATUS
NulMRxIoCtl(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs an IOCTL operation.
   
Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN pSrvOpen = capFobx->pSrvOpen;
    NulMRxGetFcbExtension(capFcb,pFcbExtension);
    PMRX_NET_ROOT pNetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL pSrvCall = pNetRoot->pSrvCall;
    UNICODE_STRING RootName;
    NulMRxGetDeviceExtension(RxContext,pDeviceExtension);
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    ULONG IoControlCode = LowIoContext->ParamsFor.FsCtl.FsControlCode;
    PUNICODE_STRING RemainingName = pSrvOpen->pAlreadyPrefixedName;
    UNICODE_STRING  StatsFile;
    NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);
    
    RxTraceEnter("NulMRxIoCtl");
    PAGED_CODE();
 
    switch (IoControlCode) {

        default:        
        //ASSERT(!"unimplemented major function");
		break;
    }

    RxTraceLeave(Status);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\downlvli.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    DownLvlI.c

Abstract:

    This module implements downlevel fileinfo, volinfo, and dirctrl.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

RXDT_DefineCategory(DOWNLVLI);
#define Dbg                 (DEBUG_TRACE_DOWNLVLI)

NTSTATUS
NulMRxTruncateFile(
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
    OUT PLARGE_INTEGER   pNewAllocationSize
    )
/*++

Routine Description:

   This routine handles requests to truncate the file

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    NulMRxGetFcbExtension(capFcb,pFcbExtension);
    PMRX_NET_ROOT pNetRoot = capFcb->pNetRoot;
    NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);

    RxTraceEnter("NulMRxTruncateFile");
    RxDbgTrace(0,  Dbg, ("NewFileSize is %d\n", pNewFileSize->LowPart));

    RxTraceLeave(Status);
    return Status;
}

NTSTATUS
NulMRxExtendFile(
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
    OUT PLARGE_INTEGER   pNewAllocationSize
    )
/*++

Routine Description:

   This routine handles requests to extend the file for cached IO.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    NulMRxGetFcbExtension(capFcb,pFcbExtension);
    PMRX_NET_ROOT pNetRoot = capFcb->pNetRoot;
    NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);

    RxTraceEnter("NulMRxExtendFile");
    RxDbgTrace(0,  Dbg, ("NewFileSize is %d\n", pNewFileSize->LowPart));

    RxTraceLeave(Status);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifs.mrx\util\ifsrdr\ifsrdr.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ifsrdr.c

Abstract:

    This module implements a minimal app to load and unload,
    ifs monolithic minirdr. Also explicit start/stop control is
    provided

    This module also populates the registry entries for the
	driver, and the network provider.

--*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ifsmrx.h>

//
// This struct is used as a temporary in-memory representation of a registry entry.
//
// N.B. The pvValue entry serves 'double duty'. For integral datatypes (REG_DWORD) it
//      holds the value of the DWORD, not its' address. Make sure you don't dereference
//      pvValue if the type is REG_DWORD. In the remaining cases, it contains a pointer
//      to the first byte of storage containing the value.
//

typedef struct {
	PCHAR  pszKey;
	DWORD  dwType;
	DWORD  dwLength;
	PVOID  pvValue;
} REGENTRY, *PREGENTRY;

void
ReadRegistryKeyValues(
    HKEY hKey,
    DWORD Count,
    PREGENTRY pValues);

void
WriteRegistryKeyValues(
    HKEY hKey,
    DWORD Count,
    PREGENTRY pValues);

void IfsMrxStart(void);
void IfsMrxStop(void);

void IfsMrxLoad(void);
void IfsMrxUnload(void);
void IfsMrxUsage(void);

void SetupIfsMrxRegistryEntries(void);

//
// routines for manipulating registry key values
//

BOOL GetRegsz (HKEY hKey, PCHAR pszKey, PVOID * ppvValue, DWORD *pdwLength);
BOOL GetRegesz(HKEY hKey, PCHAR pszKey, PVOID * ppvValue, DWORD *pdwLength);
BOOL GetRegmsz(HKEY hKey, PCHAR pszKey, PVOID * ppvValue, DWORD *pdwLength);
BOOL GetRegdw (HKEY hKey, PCHAR pszKey, PVOID * ppvValue, DWORD *pdwLength);

//
// routines for manipulating registry keys
//

BOOL OpenKey(PCHAR pszKey, PHKEY phKey);
BOOL CreateKey(PCHAR pszKey, PHKEY phKey);
BOOL AddValue(HKEY hKey, PCHAR pszKey, DWORD dwType, DWORD dwLength, PVOID pvValue);

char* IfsMrxDriverName = "IfsMrx";


VOID
__cdecl
main(
    int argc,
    char *argv[]
    )

{

    char  command[16];
    BOOL  IfsMrxStarted = FALSE;
    BOOL  IfsMrxLoaded = FALSE;

    IfsMrxUsage();

    for (;;)
    {
        printf("\nCommand:");
        scanf("%s",command);

        if (command[0] == 'Q' || command[0] == 'q') { break; }

        if (!strncmp(command,"?",1))     { IfsMrxUsage(); }

        if (command[0] == 'R' || command[0] == 'r') {
            SetupIfsMrxRegistryEntries();
            exit(0);
        }

        if (command[0] == 'L' || command[0] == 'l') {
            if (!IfsMrxLoaded) {
                IfsMrxLoad();
            } else {
                printf("IFS Mini redirector already loaded\n");
            }
        }

        if (command[0] == 'U' || command[0] == 'l') {
            if (IfsMrxLoaded) {
                IfsMrxUnload();
            } else {
                printf("IFS Mini redirector not loaded\n");
            }
        }

        if (command[0] == 'S' || command[0] == 's') {
            if (!IfsMrxStarted) {
                IfsMrxStart();
                IfsMrxStarted = TRUE;
            } else {
                printf("IFS mini redirector already started\n");
            }
        }

        if (command[0] == 'T' || command[0] == 't')  {
            if (IfsMrxStarted) {
                IfsMrxStop();
            } else {
                printf("IFS Mini redirector not started\n");
            }
        }
    }
}

// These handles are retained

HANDLE hSharedMemory;
HANDLE hMutex;

VOID IfsMrxStart()
/*++

Routine Description:

    This routine starts the IFS sample mini redirector.

Notes:

    The start is distinguished from Load. During this phase the appropriate FSCTL
    is issued and the shared memory/mutex data structures required for the Network
    provider DLL are initialized.

--*/
{
    NTSTATUS            ntstatus;
    UNICODE_STRING      DeviceName;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              IfsMrxHandle;

    //
    // Open the Ifs Mrx device.
    //
    RtlInitUnicodeString(&DeviceName,DD_IFSMRX_FS_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    ntstatus = NtOpenFile(
                   &IfsMrxHandle,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if (ntstatus == STATUS_SUCCESS) {
        ntstatus = NtFsControlFile(
                     IfsMrxHandle,
                     0,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     FSCTL_IFSMRX_START,
                     NULL,
                     0,
                     NULL,
                     0
                     );

        NtClose(IfsMrxHandle);
    }

    if (ntstatus == STATUS_SUCCESS) {
        DWORD  Status;
        HANDLE hMutex;

        hSharedMemory = CreateFileMappingW(
                            INVALID_HANDLE_VALUE,
                            NULL,
                            PAGE_READWRITE,
                            0,
                            sizeof(IFSMRXNP_SHARED_MEMORY),
                            IFSMRXNP_SHARED_MEMORY_NAME);

        if (hSharedMemory == NULL) {
            Status = GetLastError();
            if (Status == ERROR_ALREADY_EXISTS) {
                Status = STATUS_SUCCESS;
            }

            printf("IFS MRx Net Provider Mutex Creation status %lx\n",Status);
        } else {
            PIFSMRXNP_SHARED_MEMORY pSharedMemory;

            pSharedMemory = MapViewOfFile(hSharedMemory, FILE_MAP_WRITE, 0, 0, 0);

            if (pSharedMemory != NULL) {
                pSharedMemory->HighestIndexInUse = -1;
                pSharedMemory->NumberOfResourcesInUse = 0;
            }

            UnmapViewOfFile(pSharedMemory);
        }

        hMutex = CreateMutexW(
                     NULL,
                     FALSE,
                     IFSMRXNP_MUTEX_NAME);

        if (hSharedMemory == NULL) {
            Status = GetLastError();
            if (Status == ERROR_ALREADY_EXISTS) {
                Status = STATUS_SUCCESS;
            }

            printf("IFS MRx Net Provider Mutex Creation status %lx\n",Status);
        }
    }

    printf("IFS MRx sample mini redirector start status %lx\n",ntstatus);
}

VOID IfsMrxStop()
/*++

Routine Description:

    This routine stops the IFS sample mini redirector.

Notes:

    The stop is distinguished from unload. During this phase the appropriate FSCTL
    is issued and the shared memory/mutex data structures required for the Network
    provider DLL are torn down.

--*/
{
    NTSTATUS            ntstatus;
    UNICODE_STRING      DeviceName;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              IfsMrxHandle;

    //
    // Open the Ifs Mrx device.
    //
    RtlInitUnicodeString(&DeviceName,DD_IFSMRX_FS_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    ntstatus = NtOpenFile(
                   &IfsMrxHandle,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if (ntstatus == STATUS_SUCCESS) {
        ntstatus = NtFsControlFile(
                     IfsMrxHandle,
                     0,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     FSCTL_IFSMRX_STOP,
                     NULL,
                     0,
                     NULL,
                     0
                     );

        NtClose(IfsMrxHandle);
    }

    CloseHandle(hSharedMemory);
    CloseHandle(hMutex);

    printf("IFS MRx sample mini redirector start status %lx\n",ntstatus);
}

VOID IfsMrxLoad()
{
   printf("Loading Ifs example minirdr.......\n");
   system("net start ifsmrx");
}


VOID IfsMrxUnload(void)
{
    printf("Unloading Ifs example minirdr\n");
    system("net stop ifsmrx");
}

VOID IfsMrxUsage(void){
	printf("\n");
	printf("    Ifs Example Mini-rdr Utility");
    printf("    The following commands are valid \n");
    printf("    R    -> load the registry entries for ifs minirdr\n");
    printf("    L   -> load the ifs minirdr driver\n");
    printf("    U -> unload the ifs minirdr driver\n");
    printf("    S  -> start the ifs minirdr driver\n");
    printf("    T -> stop the ifs minirdr driver\n");
}

REGENTRY LinkageKeyValues[] =
{
	{ "Bind",                 REG_MULTI_SZ,  0,   0 },
	{ "Export",               REG_MULTI_SZ,  0,   0 },
	{ "Route",                REG_MULTI_SZ,  0,   0 }
};

REGENTRY LinkageDisabledKeyValues[] =
{
	{ "Bind",                 REG_MULTI_SZ,  0,   0 },
	{ "Export",               REG_MULTI_SZ,  0,   0 },
	{ "Route",                REG_MULTI_SZ,  0,   0 }
};

REGENTRY NetworkProviderKeyValues[] =
{
	{
        "Devicename",
        REG_SZ,
        IFSMRX_DEVICE_NAME_A_LENGTH,
        IFSMRX_DEVICE_NAME_A
    },
	{
        "ProviderPath",
        REG_EXPAND_SZ,
        35,
        "%SystemRoot%\\System32\\IfsMrxNp.dll"
    },
	{
        "Name",
        REG_SZ,
        IFSMRX_PROVIDER_NAME_A_LENGTH,
        IFSMRX_PROVIDER_NAME_A
    }
};


REGENTRY IfsMrxKeyValues[] =
{
	{                   "Type",                           REG_DWORD,     4,   (PVOID) 2 },
	{                   "Start",                          REG_DWORD,     4,   (PVOID) 3 },
	{                   "ErrorControl",                   REG_DWORD,     4,   (PVOID) 1 },
	{                   "ImagePath",                      REG_EXPAND_SZ, 40,
	                                     "\\SystemRoot\\System32\\drivers\\ifsmrx.sys" },
	{                   "DisplayName",                    REG_SZ,        7,   "IfsMrx"  },
	{                   "Group",                          REG_SZ,        8,   "Network" }
};

REGENTRY ProviderOrderKeyValues[] =
{
	{ "ProviderOrder", REG_SZ, 0,   0 }
};

void SetupIfsMrxRegistryEntries(void)
/*++

Routine Description:

    This routine initializes the registry entries for the ifsmrx
    minirdr. This only needs to be done once.

Arguments:

    None

Return Value:

   None

--*/
{
    HKEY hCurrentKey;

    printf("Setting up IfsMrx registry Entries\n");

    // Open the ifs mrx key and write out the values ...

    if (CreateKey("System\\CurrentControlSet\\Services\\ifsmrx",&hCurrentKey)) {
        WriteRegistryKeyValues(
            hCurrentKey,
            sizeof(IfsMrxKeyValues)/sizeof(REGENTRY),
            IfsMrxKeyValues);
        RegCloseKey(hCurrentKey);
    } else {
        printf("Error Creating Key %s Status %d\n","ifsmrx",GetLastError());
        return;
    }

    // Read the linkage values associated with the Lanman workstation service.
    // This contains all the transports and the order in which they need to be used

    if (OpenKey("System\\CurrentControlSet\\Services\\LanmanWorkstation\\Linkage",&hCurrentKey)) {
        ReadRegistryKeyValues(
            hCurrentKey,
            sizeof(LinkageKeyValues)/sizeof(REGENTRY),
            LinkageKeyValues);

        RegCloseKey(hCurrentKey);
    } else {
        printf("Error Opening Key %s Status %d\n","LanmanWorkstation\\Linkage",GetLastError());
        return;
    }


    // Update the Ifs MRx linkage values
    if (CreateKey("System\\CurrentControlSet\\Services\\ifsmrx\\Linkage",&hCurrentKey)) {
        WriteRegistryKeyValues(
            hCurrentKey,
            sizeof(LinkageKeyValues)/sizeof(REGENTRY),
            LinkageKeyValues);
        RegCloseKey(hCurrentKey);
    } else {
        printf("Error Creating Key %s Status %d\n","ifsmrx\\linkage",GetLastError());
        return;
    }

    if (OpenKey("System\\CurrentControlSet\\Services\\LanmanWorkstation\\Linkage\\Disabled",&hCurrentKey)) {
        ReadRegistryKeyValues(
            hCurrentKey,
            sizeof(LinkageDisabledKeyValues)/sizeof(REGENTRY),
            LinkageDisabledKeyValues);
        RegCloseKey(hCurrentKey);
    } else {
        printf("Error Opening Key %s Status %d\n","LanmanWorkstation\\Linkage\\Disabled",GetLastError());
        return;
    }

    // Update the Ifs MRx linkage disabled values
    if (CreateKey("System\\CurrentControlSet\\Services\\ifsmrx\\Linkage\\Disabled",&hCurrentKey)) {
        WriteRegistryKeyValues(
            hCurrentKey,
            sizeof(LinkageDisabledKeyValues)/sizeof(REGENTRY),
            LinkageDisabledKeyValues);
        RegCloseKey(hCurrentKey);
    } else {
        printf("Error Creating Key %s Status %d\n","ifsmrx\\linkage\\disabled",GetLastError());
        return;
    }

    // Update the ifsmrx network provider section
    if (CreateKey("System\\CurrentControlSet\\Services\\ifsmrx\\networkprovider",&hCurrentKey)) {
        WriteRegistryKeyValues(
            hCurrentKey,
            sizeof(NetworkProviderKeyValues)/sizeof(REGENTRY),
            NetworkProviderKeyValues);

        RegCloseKey(hCurrentKey);
    } else {
        printf("Error Creating Key %s Status %d\n","ifsmrx\\linkage\\disabled",GetLastError());
        return;
    }

    if (CreateKey("System\\CurrentControlSet\\Services\\ifsmrx\\parameters",&hCurrentKey)) {
        RegCloseKey(hCurrentKey);
    } else {
        printf("Error Creating Key %s Status %d\n","ifsmrx\\parameters",GetLastError());
        return;
    }

    // Update the provider order to include the IFS sample mini redirector
    // as well
    printf("Updating the provider order\n");

    if (OpenKey("System\\CurrentControlSet\\control\\networkprovider\\order",&hCurrentKey)) {
        char  *pNewValue;
        DWORD ProviderNameLength = strlen(",ifsmrx");
        DWORD NewValueSize = 0;

        ReadRegistryKeyValues(
            hCurrentKey,
            sizeof(ProviderOrderKeyValues)/sizeof(REGENTRY),
            ProviderOrderKeyValues);

        RegCloseKey(hCurrentKey);

        ProviderNameLength = strlen(IfsMrxDriverName);
        if (ProviderOrderKeyValues[0].dwLength != 0) {
            // There are more than one providers. Include space for
            // a delimiter
            ProviderNameLength += sizeof(char);
        }

        // Include the Ifs sample mini redirector in the list of providers.
        NewValueSize = ProviderOrderKeyValues[0].dwLength +
                       ProviderNameLength;

        pNewValue = malloc(NewValueSize);

        if (pNewValue != NULL) {
            if (ProviderOrderKeyValues[0].dwLength != 0) {
                strcpy(
                    pNewValue,
                    ProviderOrderKeyValues[0].pvValue);

                strcat(pNewValue,",");
            } else {
                *pNewValue = '\0';
            }

            strcat(
                pNewValue,
                IfsMrxDriverName);

            // free the previously allocated string
            free( ProviderOrderKeyValues[0].pvValue );

            ProviderOrderKeyValues[0].pvValue = pNewValue;
            ProviderOrderKeyValues[0].dwLength = NewValueSize;

            if (CreateKey("System\\CurrentControlSet\\control\\networkprovider\\order",&hCurrentKey)) {
                WriteRegistryKeyValues(
                    hCurrentKey,
                    sizeof(ProviderOrderKeyValues)/sizeof(REGENTRY),
                    ProviderOrderKeyValues);

                RegCloseKey(hCurrentKey);
            }

            free(pNewValue);
        } else {
            printf("error updating order -- out of memory\n");
        }
    } else {
        printf("error opening control\\networkprovider\\order key\n");
    }
}

void
ReadRegistryKeyValues(
    HKEY       hCurrentKey,
    DWORD      NumberOfValues,
    PREGENTRY pValues)
/*++

Routine Description:

    This routine reads a bunch of values associated with a given key.

Arguments:

    hCurrentKey - the key

    NumberOfValues - the number of values

    pValues - the array of values

Return Value:

   None

--*/
{
    //
    // Iterate throught table reading the values along the way
    //

	DWORD  i;

	for (i = 0; i < NumberOfValues; i++)
	{
		DWORD dwType;
		PCHAR pszKey;

		dwType  = pValues[i].dwType;
		pszKey  = pValues[i].pszKey;

		switch (dwType)
		{
		case REG_SZ:
			(void) GetRegsz(hCurrentKey,
				            pszKey,
							&pValues[i].pvValue,
							&pValues[i].dwLength);
			break;

		case REG_DWORD:
			(void) GetRegdw(hCurrentKey,
				            pszKey,
							&pValues[i].pvValue,
							&pValues[i].dwLength);
			break;

		case REG_EXPAND_SZ:
			(void) GetRegesz(hCurrentKey,
				             pszKey,
							 &pValues[i].pvValue,
							 &pValues[i].dwLength);
			break;

		case REG_MULTI_SZ:
			(void) GetRegmsz(hCurrentKey,
				             pszKey,
							 &pValues[i].pvValue,
							 &pValues[i].dwLength);
			break;

		case REG_BINARY:
			printf("%s is a REG_BINARY and won't be duplicated\n", pszKey);
			break;

		default:
			printf("%s is an unknown type; %d (decimal)\n", pszKey, dwType);
			break;

		}		
	}
}

//
// Get a REG_SZ value and stick it in the table entry, along with the
// length
//

BOOL GetRegsz(HKEY hKey, PCHAR pszKey, PVOID * ppvValue, DWORD *pdwLength)
{
	char  achValue[1024];

	DWORD dwLength;
	LONG  Status;
	DWORD dwType   = REG_SZ;
	PCHAR pszValue = NULL;


	
	if ((NULL == pszKey) || (NULL == ppvValue) || (NULL == hKey) || (NULL == pdwLength)) {
		return FALSE;
	}

#ifdef _DEBUG
    FillMemory(achValue, sizeof(achValue), 0xcd);
#endif

	dwLength = sizeof(achValue);


	Status = RegQueryValueEx(
			       hKey,
				   pszKey,
				   NULL,
				   &dwType,
				   (PUCHAR) &achValue[0],
				   &dwLength);

	if ((ERROR_SUCCESS != Status) || (REG_SZ != dwType)) {
		return FALSE;
	}

	pszValue = malloc(dwLength);

	if (NULL == pszValue) {
		return FALSE;
	}


	CopyMemory(pszValue, achValue, dwLength);

	*ppvValue = pszValue;
	*pdwLength = dwLength;

	return TRUE;
}

//
// Get the value of a REG_EXPAND_SZ and its length
//

BOOL GetRegesz(HKEY hKey, PCHAR pszKey, PVOID * ppvValue, DWORD * pdwLength)
{
	char  achValue[1024];

	DWORD dwLength;
	LONG  Status;
	DWORD dwType   = REG_EXPAND_SZ;
	PCHAR pszValue = NULL;

	
	if ((NULL == pszKey) || (NULL == ppvValue) || (NULL == hKey) || (NULL == pdwLength)) {
		return FALSE;
	}

#ifdef _DEBUG
    FillMemory(achValue, sizeof(achValue), 0xcd);
#endif

	dwLength = sizeof(achValue);

	Status = RegQueryValueEx(
			       hKey,
				   pszKey,
				   NULL,
				   &dwType,
				   (PUCHAR) &achValue[0],
				   &dwLength);

	if ((ERROR_SUCCESS != Status) || (REG_EXPAND_SZ != dwType)) {
		return FALSE;
	}

	pszValue = malloc(dwLength);

	if (NULL == pszValue) {
		return FALSE;
	}

	CopyMemory(pszValue, achValue, dwLength);

	*ppvValue  = pszValue;
	*pdwLength = dwLength;

	return TRUE;
}


//
// Get value and length of REG_MULTI_SZ
//

BOOL GetRegmsz(HKEY hKey, PCHAR pszKey, PVOID * ppvValue, DWORD * pdwLength)
{
	char  achValue[1024];

	DWORD dwLength;
	LONG  Status;
	DWORD dwType   = REG_MULTI_SZ;
	PCHAR pszValue = NULL;

	
	if ((NULL == pszKey) || (NULL == ppvValue) || (NULL == hKey) || (NULL == pdwLength)) {
		return FALSE;
	}

#ifdef _DEBUG
    FillMemory(achValue, sizeof(achValue), 0xcd);
#endif


	dwLength = sizeof(achValue);


	Status = RegQueryValueEx(
			       hKey,
				   pszKey,
				   NULL,
				   &dwType,
				   (PUCHAR) &achValue[0],
				   &dwLength);

	if ((ERROR_SUCCESS != Status) || (REG_MULTI_SZ != dwType)) {
		return FALSE;
	}

	pszValue = malloc(dwLength);

	if (NULL == pszValue) {
		return FALSE;
	}

	CopyMemory(pszValue, achValue, dwLength);

	*ppvValue  = pszValue;
	*pdwLength = dwLength;

	return TRUE;
}


//
// Get value and length of REG_DWORD
//


BOOL GetRegdw(HKEY hKey, PCHAR pszKey, PVOID * ppvValue, DWORD * pdwLength)
{
	DWORD dwValue = 0;

	DWORD dwLength;
	LONG  Status;
	DWORD dwType   = REG_DWORD;


	
	if ((NULL == pszKey) || (NULL == ppvValue) || (NULL == hKey) || (NULL == pdwLength)) {
		return FALSE;
	}

	dwLength = sizeof(dwValue);


	Status = RegQueryValueEx(
			       hKey,
				   pszKey,
				   NULL,
				   &dwType,
				   (PUCHAR) &dwValue,
				   &dwLength);

	if ((ERROR_SUCCESS != Status) || (REG_DWORD != dwType)) {
		return FALSE;
	}

	*ppvValue  = (PVOID) dwValue;
	*pdwLength = dwLength;

	return TRUE;
}



void
WriteRegistryKeyValues(
    HKEY        hCurrentKey,
    DWORD       NumberOfValues,
    PREGENTRY  pValues)
/*++

Routine Description:

    This routine reads a bunch of values associated with a given key.

Arguments:

    hCurrentKey - the key

    NumberOfValues - the number of values

    pValues - the array of values

Return Value:

   None

--*/
{
	DWORD i;


	for (i = 0; i < NumberOfValues; i++)
	{
		DWORD dwType;
		PVOID pvValue;
		DWORD dwLength;
		PCHAR pszKey;

		pszKey   = pValues[i].pszKey;
		dwType   = pValues[i].dwType;
		dwLength = pValues[i].dwLength;
		pvValue  = pValues[i].pvValue;

		switch (dwType)
		{
		case REG_SZ:
			(void) AddValue(hCurrentKey, pszKey, dwType, dwLength, pvValue);
			break;

		case REG_DWORD:
			(void) AddValue(hCurrentKey, pszKey, dwType, dwLength, &pvValue);
			break;

		case REG_EXPAND_SZ:
			(void) AddValue(hCurrentKey, pszKey, dwType, dwLength, pvValue);
			break;

		case REG_MULTI_SZ:
			(void) AddValue(hCurrentKey, pszKey, dwType, dwLength, pvValue);
			break;

		case REG_BINARY:
			//
			// There are no binary values we need to copy. If we did, we'd
			// put something here
			//

			break;

		default:
			printf("%s is an unknown type; %d (decimal)\n", pszKey, dwType);
			break;

		}
	}
}

//
// Open a key so we can read the values
//


BOOL OpenKey(
    PCHAR pszKey,
    PHKEY phKey)
/*++

Routine Description:

    This routine opens a registry key.

Arguments:

    pszKey - the name of the key relative to HKEY_LOCAL_MACHINE

    phKey - the key handlle

Return Value:

    TRUE if successful, otherwise FALSE

--*/
{	
	HKEY  hNewKey = 0;
    DWORD Status;

	Status = RegOpenKeyEx(
				HKEY_LOCAL_MACHINE,
				pszKey,
				0,
				KEY_QUERY_VALUE,
				&hNewKey);

	if (ERROR_SUCCESS != Status)
	{
		*phKey = NULL;
        return FALSE;
	}
	else
	{
        *phKey = hNewKey;
        return TRUE;
	}
}

BOOL CreateKey(PCHAR pszKey, PHKEY phKey)
/*++

Routine Description:

    This routine creates a registry key.

Arguments:

    pszKey - the name of the key relative to HKEY_LOCAL_MACHINE

    phKey - the key handlle

Return Value:

    TRUE if successful, otherwise FALSE

--*/
{

	LONG   Status;
	DWORD  Disposition;

	Status =  RegCreateKeyEx(
				HKEY_LOCAL_MACHINE,	      // hkey
				pszKey,				      // subkey
				0,					      // reserved
				REG_NONE,                 // class
				REG_OPTION_NON_VOLATILE,  // options
				KEY_ALL_ACCESS,		      // sam desired
				NULL,				      // security structure
				phKey,				      // address of new key buf
				&Disposition);		      // status

	if ( ERROR_SUCCESS == Status)
	{
		return TRUE;
	} else {
        printf("error creating key %s Status %d\n",pszKey,Status);
		return FALSE;
	}
}


//
// Add a value to the registry
//


BOOL AddValue(HKEY hKey, PCHAR pszKey, DWORD dwType, DWORD dwLength, PVOID pvValue)
{

	BOOL fSuccess = TRUE;
	LONG Status   = ERROR_SUCCESS;


	Status = RegSetValueEx(
				hKey,
				pszKey,
				0,
				dwType,
			    pvValue,
				dwLength);


	if (Status != ERROR_SUCCESS)
	{
		fSuccess = FALSE;
		RegCloseKey(hKey);
	}

	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\dll\nulmrxnp.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ifsmrxnp.c

Abstract:

    This module implements the routines required for interaction with network
    provider router interface in NT

Notes:

    This module has been built and tested only in UNICODE environment

--*/


#include <windows.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>
#include <winnetwk.h>
#include <npapi.h>
#include <devioctl.h>

#include "nulmrx.h"


#ifdef DBG
#define DbgP(_x_) WideDbgPrint _x_
#else
#define DbgP(_x_)
#endif

ULONG _cdecl WideDbgPrint( PWCHAR Format, ... );

#define TRACE_TAG	L"NULMRXNP:    "


#define WNNC_DRIVER( major, minor ) ( major * 0x00010000 + minor )



DWORD APIENTRY
NPGetCaps(
    DWORD nIndex )
/*++

Routine Description:

    This routine returns the capaboilities of the Null Mini redirector
    network provider implementation

Arguments:

    nIndex - category of capabilities desired

Return Value:

    the appropriate capabilities

--*/
{
	DWORD rc = 0;

	DbgP(( L"GetNetCaps .....\n" ));
    switch ( nIndex )
    {
		case WNNC_SPEC_VERSION:
        	rc = WNNC_SPEC_VERSION51;
			break;

		case WNNC_NET_TYPE:
			rc = WNNC_NET_RDR2SAMPLE;
			break;

        case WNNC_DRIVER_VERSION:
            rc = WNNC_DRIVER(1, 0);
			break;

        case WNNC_CONNECTION:
            rc = WNNC_CON_GETCONNECTIONS |
                 WNNC_CON_CANCELCONNECTION |
                 WNNC_CON_ADDCONNECTION |
                 WNNC_CON_ADDCONNECTION3;
			break;

		case WNNC_ENUMERATION:
			rc = WNNC_ENUM_LOCAL;
			break;

        case WNNC_START:
            rc = 1;
			break;

        case WNNC_USER:
        case WNNC_DIALOG:
        case WNNC_ADMIN:
        default:
            rc = 0;
			break;
    }
	
	return rc;
}


DWORD APIENTRY
NPLogonNotify(
    PLUID   lpLogonId,
    LPCWSTR lpAuthentInfoType,
    LPVOID  lpAuthentInfo,
    LPCWSTR lpPreviousAuthentInfoType,
    LPVOID  lpPreviousAuthentInfo,
    LPWSTR  lpStationName,
    LPVOID  StationHandle,
    LPWSTR  *lpLogonScript)
/*++

Routine Description:

    This routine handles the logon notifications

Arguments:

    lpLogonId -- the associated LUID

    lpAuthenInfoType - the authentication information type

    lpAuthenInfo  - the authentication Information

    lpPreviousAuthentInfoType - the previous aunthentication information type

    lpPreviousAuthentInfo - the previous authentication information

    lpStationName - the logon station name

    LPVOID - logon station handle

    lpLogonScript - the logon script to be executed.

Return Value:

    WN_SUCCESS

Notes:

    This capability has not been implemented in the sample.

--*/
{
    *lpLogonScript = NULL;

    return WN_SUCCESS;
}


DWORD APIENTRY
NPPasswordChangeNotify (
    LPCWSTR	lpAuthentInfoType,
    LPVOID	lpAuthentInfo,
    LPCWSTR	lpPreviousAuthentInfoType,
    LPVOID	lpPreviousAuthentInfo,
    LPWSTR	lpStationName,
    LPVOID	StationHandle,
    DWORD	dwChangeInfo )
/*++

Routine Description:

    This routine handles the password change notifications

Arguments:

    lpAuthenInfoType - the authentication information type

    lpAuthenInfo  - the authentication Information

    lpPreviousAuthentInfoType - the previous aunthentication information type

    lpPreviousAuthentInfo - the previous authentication information

    lpStationName - the logon station name

    LPVOID - logon station handle

    dwChangeInfo - the password change information.

Return Value:

    WN_NOT_SUPPORTED

Notes:

    This capability has not been implemented in the sample.

--*/
{
    SetLastError( WN_NOT_SUPPORTED );

    return WN_NOT_SUPPORTED;
}


ULONG
SendToMiniRdr(
    IN ULONG			IoctlCode,
    IN PVOID			InputDataBuf,
    IN ULONG			InputDataLen,
    IN PVOID			OutputDataBuf,
    IN PULONG			pOutputDataLen)
/*++

Routine Description:

    This routine sends a device ioctl to the Mini Rdr.

Arguments:

    IoctlCode		- Function code for the Mini Rdr driver

    InputDataBuf	- Input buffer pointer

    InputDataLen	- Lenth of the input buffer

    OutputDataBuf	- Output buffer pointer

    pOutputDataLen	- Pointer to the length of the output buffer

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
    HANDLE	DeviceHandle;	    // The mini rdr device handle
    ULONG	BytesRet;
    BOOL	rc;
    ULONG	Status;

    Status = WN_SUCCESS;

    // Grab a handle to the redirector device object

    DeviceHandle = CreateFile(
	    DD_NULMRX_USERMODE_DEV_NAME_U,
	    GENERIC_READ | GENERIC_WRITE,
	    FILE_SHARE_READ | FILE_SHARE_WRITE,
	    (LPSECURITY_ATTRIBUTES)NULL,
	    OPEN_EXISTING,
	    0,
	    (HANDLE) NULL );

    if ( INVALID_HANDLE_VALUE != DeviceHandle )
    {
		rc = DeviceIoControl(
			DeviceHandle,
			IoctlCode,
			InputDataBuf,
			InputDataLen,
			OutputDataBuf,
			*pOutputDataLen,
			pOutputDataLen,
			NULL );

			if ( !rc )
			{
			    DbgP(( L"SendToMiniRdr: returning error from DeviceIoctl\n" ));
			    Status = GetLastError( );
			}
			else
			{
			    DbgP(( L"SendToMiniRdr: The DeviceIoctl call succeded\n" ));
			}
			CloseHandle(DeviceHandle);
    }
    else
    {
		Status = GetLastError( );
		DbgP(( L"SendToMiniRdr: error %lx opening device \n", Status ));
    }

    return Status;
}


DWORD APIENTRY
NPAddConnection(
    LPNETRESOURCE   lpNetResource,
    LPWSTR          lpPassword,
    LPWSTR          lpUserName )
/*++

Routine Description:

    This routine adds a connection to the list of connections associated
    with this network provider

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpPassword  - the password

    lpUserName - the user name

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
	DbgP(( L"NPAddConnection....\n" ));

    return NPAddConnection3( NULL, lpNetResource, lpPassword, lpUserName, 0 );
}


DWORD APIENTRY
NPAddConnection3(
    HWND            hwndOwner,
    LPNETRESOURCE   lpNetResource,
    LPWSTR          lpPassword,
    LPWSTR          lpUserName,
    DWORD           dwFlags )
/*++

Routine Description:

    This routine adds a connection to the list of connections associated
    with this network provider

Arguments:

    hwndOwner - the owner handle

    lpNetResource - the NETRESOURCE struct

    lpPassword  - the password

    lpUserName - the user name

    dwFlags - flags for the connection

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

--*/
{
	DWORD	Status;
	WCHAR	ConnectionName[128];
	WCHAR	wszScratch[128];
	WCHAR	LocalName[3];
	DWORD	CopyBytes = 0;

	DbgP(( L"NPAddConnection3....\n" ));

	DbgP(( L"Local Name:  %s\n", lpNetResource->lpLocalName ));
	DbgP(( L"Remote Name: %s\n", lpNetResource->lpRemoteName ));

	Status = WN_SUCCESS;

    //  \device\miniredirector\;<DriveLetter>:\Server\Share

	if ( lstrlen( lpNetResource->lpLocalName ) > 1 )
	{
		if ( lpNetResource->lpLocalName[1] == L':' )
		{
			// LocalName[0] = (WCHAR) CharUpper( (PWCHAR) MAKELONG( (USHORT) lpNetResource->lpLocalName[0], 0 ) );
			LocalName[0] = (WCHAR) toupper(lpNetResource->lpLocalName[0]);
			LocalName[1] = L':';
			LocalName[2] = L'\0';
			lstrcpy( ConnectionName, DD_NULMRX_FS_DEVICE_NAME_U );
			lstrcat( ConnectionName, L"\\;" );
			lstrcat( ConnectionName, LocalName );
		}
		else
		{
			Status = WN_BAD_LOCALNAME;
		}
	}
	else
	{
		Status = WN_BAD_LOCALNAME;
	}

	// format proper server name
	if ( lpNetResource->lpRemoteName[0] == L'\\' && lpNetResource->lpRemoteName[1] == L'\\' )
	{
		lstrcat( ConnectionName, lpNetResource->lpRemoteName + 1 );
	}
	else
	{
		Status = WN_BAD_NETNAME;
	}

	DbgP(( L"Full Connect Name: %s\n", ConnectionName ));
	DbgP(( L"Full Connect Name Length: %d\n", ( lstrlen( ConnectionName ) + 1 ) * sizeof( WCHAR ) ));


	if ( Status == WN_SUCCESS )
	{
		if ( QueryDosDevice( LocalName, wszScratch, 128 ) )
		{
			Status = WN_ALREADY_CONNECTED;
		}
		else if ( GetLastError( ) == ERROR_FILE_NOT_FOUND )
		{
			HANDLE hFile;

			Status = SendToMiniRdr( IOCTL_NULMRX_ADDCONN, ConnectionName,
			              ( lstrlen( ConnectionName ) + 1 ) * sizeof( WCHAR ),
			              NULL, &CopyBytes );
			if ( Status == WN_SUCCESS )
			{
				if ( !DefineDosDevice( DDD_RAW_TARGET_PATH |
				                       DDD_NO_BROADCAST_SYSTEM,
	 			                       lpNetResource->lpLocalName,
									   ConnectionName ) )
				{
					Status = GetLastError( );
				}
			}
			else
			{
					Status = WN_BAD_NETNAME;
			}
		}
	    else
	    {
			Status = WN_ALREADY_CONNECTED;
		}
	}
	
	return Status;
}


DWORD APIENTRY
NPCancelConnection(
    LPWSTR  lpName,
    BOOL    fForce )
/*++

Routine Description:

    This routine cancels ( deletes ) a connection from the list of connections
    associated with this network provider

Arguments:

    lpName - name of the connection

    fForce - forcefully delete the connection

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/

{
	WCHAR	LocalName[3];
	WCHAR	RemoteName[128];
	WCHAR	ConnectionName[128];
	ULONG	CopyBytes;
	DWORD	DisconnectResult;
	DWORD	Status = WN_NOT_CONNECTED;

	if ( lstrlen( lpName ) > 1 )
	{
		if ( lpName[1] == L':' )
		{
			// LocalName[0] = (WCHAR) CharUpper( (PWCHAR) MAKELONG( (USHORT) lpName[0], 0 ) );
			LocalName[0] = (WCHAR) toupper(lpName[0]);
			LocalName[1] = L':';
			LocalName[2] = L'\0';

			CopyBytes = 128;
			Status = SendToMiniRdr( IOCTL_NULMRX_GETCONN, LocalName, 3 * sizeof( WCHAR ),
			                        (PVOID) RemoteName, &CopyBytes );
			if ( Status == WN_SUCCESS && CopyBytes > 0 )
			{
				RemoteName[CopyBytes] = L'\0';
				lstrcpy( ConnectionName, DD_NULMRX_FS_DEVICE_NAME_U );
				lstrcat( ConnectionName, L"\\;" );
				lstrcat( ConnectionName, LocalName );
				lstrcat( ConnectionName, RemoteName );
				CopyBytes = 0;
				Status = SendToMiniRdr( IOCTL_NULMRX_DELCONN, ConnectionName,
 			                  ( lstrlen( ConnectionName ) + 1 ) * sizeof( WCHAR ),
				              NULL, &CopyBytes );
				if ( Status == WN_SUCCESS )
				{
					if ( !DefineDosDevice( DDD_REMOVE_DEFINITION | DDD_RAW_TARGET_PATH | DDD_EXACT_MATCH_ON_REMOVE,
			                            LocalName,
			                            ConnectionName ) )
					{
						Status = GetLastError( );
					}
				}
			}
			else
			{
				Status = WN_NOT_CONNECTED;
			}
		}
	}

    return Status;
}


DWORD APIENTRY
NPGetConnection(
    LPWSTR  lpLocalName,
    LPWSTR  lpRemoteName,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the information associated with a connection

Arguments:

    lpLocalName - local name associated with the connection

    lpRemoteName - the remote name associated with the connection

    lpBufferSize - the remote name buffer size

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
	DWORD	Status, len, i;
	ULONG	CopyBytes;
	WCHAR	RemoteName[128];
	WCHAR	LocalName[3];
	
	Status = WN_NOT_CONNECTED;

	DbgP(( L"NPGetConnection....\n" ));

	if ( lstrlen( lpLocalName ) > 1 )
	{
		if ( lpLocalName[1] == L':' )
		{
			CopyBytes = 128;
			// LocalName[0] = (WCHAR) CharUpper( (PWCHAR) MAKELONG( (USHORT) lpLocalName[0], 0 ) );
			LocalName[0] = (WCHAR) toupper(lpLocalName[0]);
			LocalName[1] = L':';
			LocalName[2] = L'\0';
			Status = SendToMiniRdr( IOCTL_NULMRX_GETCONN, LocalName, 3 * sizeof( WCHAR ),
			                        (PVOID) RemoteName, &CopyBytes );
		}
	}
	if ( Status == WN_SUCCESS )
	{
		if ( CopyBytes > 0 )
		{
			len = CopyBytes + 1;
			if ( *lpBufferSize > len )
			{
				*lpRemoteName++ = L'\\';
		    	CopyMemory( lpRemoteName, RemoteName, CopyBytes );
				*lpRemoteName++ = L'\0';
			}
			else
			{
				Status = WN_MORE_DATA;
				*lpBufferSize = len;
			}
		}
		else
		{
			Status = WN_NOT_CONNECTED;
		}
	}

	return Status;
}




DWORD APIENTRY
NPOpenEnum(
    DWORD          dwScope,
    DWORD          dwType,
    DWORD          dwUsage,
    LPNETRESOURCE  lpNetResource,
    LPHANDLE       lphEnum )
/*++

Routine Description:

    This routine opens a handle for enumeration of resources. The only capability
    implemented in the sample is for enumerating connected shares

Arguments:

    dwScope - the scope of enumeration

    dwType  - the type of resources to be enumerated

    dwUsage - the usage parameter

    lpNetResource - a pointer to the desired NETRESOURCE struct.

    lphEnum - aptr. for passing nack the enumeration handle

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

    The sample only supports the notion of enumerating connected shares

    The handle passed back is merely the index of the last entry returned

--*/
{
    DWORD   Status;

    DbgP((L"NPOpenEnum\n"));

    *lphEnum = NULL;

    switch ( dwScope )
    {
    	case RESOURCE_CONNECTED:
        {
            *lphEnum = HeapAlloc( GetProcessHeap( ), HEAP_ZERO_MEMORY, sizeof( ULONG ) );

            if (*lphEnum )
            {
                Status = WN_SUCCESS;
            }
            else
            {
                Status = WN_OUT_OF_MEMORY;
            }
            break;
        }
        break;

	    case RESOURCE_CONTEXT:
	    default:
	        Status  = WN_NOT_SUPPORTED;
	        break;
    }


    DbgP((L"NPOpenEnum returning Status %lx\n",Status));

    return(Status);
}


DWORD APIENTRY
NPEnumResource(
    HANDLE  hEnum,
    LPDWORD lpcCount,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize)
/*++

Routine Description:

    This routine uses the handle obtained by a call to NPOpenEnum for
    enuerating the connected shares

Arguments:

    hEnum  - the enumeration handle

    lpcCount - the number of resources returned

    lpBuffer - the buffere for passing back the entries

    lpBufferSize - the size of the buffer

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

    WN_NO_MORE_ENTRIES - if the enumeration has exhausted the entries

    WN_MORE_DATA - if nmore data is available

Notes:

    The sample only supports the notion of enumerating connected shares

    The handle passed back is merely the index of the last entry returned

--*/
{
    DWORD			Status = WN_SUCCESS;
	BYTE			ConnectionList[26];
	ULONG			CopyBytes;
	ULONG			EntriesCopied;
	ULONG			i;
    LPNETRESOURCE	pNetResource;
	ULONG			SpaceNeeded;
	ULONG			SpaceAvailable;
	WCHAR			LocalName[3];
	WCHAR			RemoteName[128];
	PWCHAR			StringZone;

    DbgP((L"NPEnumResource\n"));

    DbgP((L"NPEnumResource Count Requested %d\n", *lpcCount));

    pNetResource = (LPNETRESOURCE) lpBuffer;
    SpaceAvailable = *lpBufferSize;
	EntriesCopied = 0;
	StringZone = (PWCHAR) ((PBYTE)lpBuffer + *lpBufferSize);
	
	CopyBytes = 26;
	Status = SendToMiniRdr( IOCTL_NULMRX_GETLIST, NULL, 0,
	                        (PVOID) ConnectionList, &CopyBytes );

    if ( Status == WN_SUCCESS && CopyBytes > 0 )
    {
		for ( i = *((PULONG) hEnum); EntriesCopied < *lpcCount, i < 26; i++ )
		{
			if ( ConnectionList[i] )
			{
				CopyBytes = 128;
				LocalName[0] = L'A' + (WCHAR) i;
				LocalName[1] = L':';
				LocalName[2] = L'\0';
				Status = SendToMiniRdr( IOCTL_NULMRX_GETCONN, LocalName, 3 * sizeof(WCHAR),
				                        (PVOID) RemoteName, &CopyBytes );

				// if something strange happended then just say there are no more entries
				if ( Status != WN_SUCCESS || CopyBytes == 0 )
				{
			        Status = WN_NO_MORE_ENTRIES;
					break;
				}
				// Determine the space needed for this entry...

				SpaceNeeded  = sizeof( NETRESOURCE );			// resource struct
				SpaceNeeded += 3 * sizeof(WCHAR);				// local name
				SpaceNeeded += 2 * sizeof(WCHAR) + CopyBytes;	// remote name
				SpaceNeeded += 5 * sizeof(WCHAR);				// comment
				SpaceNeeded += sizeof(NULMRX_PROVIDER_NAME_U);	// provider name

				if ( SpaceNeeded > SpaceAvailable )
				{
					break;
				}
				else
				{
					SpaceAvailable -= SpaceNeeded;

					pNetResource->dwScope       = RESOURCE_CONNECTED;
					pNetResource->dwType        = RESOURCETYPE_DISK;
					pNetResource->dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
					pNetResource->dwUsage       = 0;

					// setup string area at opposite end of buffer
					SpaceNeeded -= sizeof( NETRESOURCE );
					StringZone = (PWCHAR)( (PBYTE) StringZone - SpaceNeeded );
					// copy local name
					pNetResource->lpLocalName = StringZone;
					*StringZone++ = L'A' + (WCHAR) i;
					*StringZone++ = L':';
					*StringZone++ = L'\0';
					// copy remote name					
					pNetResource->lpRemoteName = StringZone;
					*StringZone++ = L'\\';
					CopyMemory( StringZone, RemoteName, CopyBytes );
					StringZone += CopyBytes / sizeof(WCHAR);
					*StringZone++ = L'\0';
					// copy comment
					pNetResource->lpComment = StringZone;
					*StringZone++ = L'A';
					*StringZone++ = L'_';
					*StringZone++ = L'O';
					*StringZone++ = L'K';
					*StringZone++ = L'\0';
					// copy provider name
					pNetResource->lpProvider = StringZone;
					lstrcpy( StringZone, NULMRX_PROVIDER_NAME_U );

					EntriesCopied++;
					// set new bottom of string zone
					StringZone = (PWCHAR)( (PBYTE) StringZone - SpaceNeeded );
				}
				pNetResource++;
			}
		}
	}
	else
	{
        Status = WN_NO_MORE_ENTRIES;
	}

	*lpcCount = EntriesCopied;
	if ( EntriesCopied == 0 && Status == WN_SUCCESS )
	{
		if ( i > 25 )
		{
	        Status = WN_NO_MORE_ENTRIES;
		}
		else
		{
		    DbgP((L"NPEnumResource More Data Needed - %d\n", SpaceNeeded));
			Status = WN_MORE_DATA;
			*lpBufferSize = SpaceNeeded;
		}
    }
	// update entry index
	*(PULONG) hEnum = i;

    DbgP((L"NPEnumResource Entries returned - %d\n", EntriesCopied));

	return Status;
}




DWORD APIENTRY
NPCloseEnum(
    HANDLE hEnum )
/*++

Routine Description:

    This routine closes the handle for enumeration of resources.

Arguments:

    hEnum  - the enumeration handle

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

    The sample only supports the notion of enumerating connected shares

--*/
{
    DbgP((L"NPCloseEnum\n"));

    HeapFree( GetProcessHeap( ), 0, (PVOID) hEnum );

    return WN_SUCCESS;
}


DWORD APIENTRY
NPGetResourceParent(
    LPNETRESOURCE   lpNetResource,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the information about net resource parent

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpBuffer - the buffer for passing back the parent information

    lpBufferSize - the buffer size

Return Value:

Notes:

--*/
{
    DbgP(( L"NPGetResourceParent: WN_NOT_SUPPORTED\n" ));

    return WN_NOT_SUPPORTED;
}


DWORD APIENTRY
NPGetResourceInformation(
    LPNETRESOURCE   lpNetResource,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize,
    LPWSTR  *lplpSystem )
/*++

Routine Description:

    This routine returns the information associated net resource

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpBuffer - the buffer for passing back the parent information

    lpBufferSize - the buffer size

    lplpSystem -

Return Value:

Notes:

--*/
{
    DbgP(( L"NPGetResourceInformation: WN_NOT_SUPPORTED\n" ));

    return WN_NOT_SUPPORTED;
}

DWORD APIENTRY
NPGetUniversalName(
    LPCWSTR lpLocalPath,
    DWORD   dwInfoLevel,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the information associated net resource

Arguments:

    lpLocalPath - the local path name

    dwInfoLevel  - the desired info level

    lpBuffer - the buffer for the univeral name

    lpBufferSize - the buffer size

Return Value:

    WN_SUCCESS if successful

Notes:

--*/
{
    DbgP(( L"NPGetUniversalName: WN_NOT_SUPPORTED\n" ));

    return WN_NOT_SUPPORTED;
}


// Format and write debug information to OutputDebugString
ULONG
_cdecl
WideDbgPrint(
    PWCHAR Format,
    ...
    )
{
	ULONG rc = 0;
    WCHAR wszbuffer[255];

    va_list marker;
    va_start( marker, Format );
	{
	     rc = wvsprintf( wszbuffer, Format, marker );
	     OutputDebugString( TRACE_TAG );
	     OutputDebugString( wszbuffer );
    }

    return rc;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\init.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    Init.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for 
    the null mini rdr.

--*/

#include "precomp.h"
#pragma  hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_INIT)

#include "ntverp.h"
#include "nulmrx.h"


//
// Global data declarations.
//

NULMRX_STATE NulMRxState = NULMRX_STARTABLE;

//
//  Mini Redirector global variables.
//

//
//  LogRate
//
ULONG   LogRate = 0;

//
//  NULMRX version
//
ULONG   NulMRxVersion = VER_PRODUCTBUILD;

//
//  This is the minirdr dispatch table. It is initialized by 
//  NulMRxInitializeTables. This table will be used by the wrapper to call 
//  into this minirdr
//

struct _MINIRDR_DISPATCH  NulMRxDispatch;

//
// Pointer to the device Object for this minirdr. Since the device object is 
// created by the wrapper when this minirdr registers, this pointer is 
// initialized in the DriverEntry routine below (see RxRegisterMinirdr)
//

PRDBSS_DEVICE_OBJECT      NulMRxDeviceObject;

//
// declare the shadow debugtrace controlpoints
//

RXDT_DefineCategory(CREATE);
RXDT_DefineCategory(CLEANUP);
RXDT_DefineCategory(CLOSE);
RXDT_DefineCategory(READ);
RXDT_DefineCategory(WRITE);
RXDT_DefineCategory(LOCKCTRL);
RXDT_DefineCategory(FLUSH);
RXDT_DefineCategory(PREFIX);
RXDT_DefineCategory(FCBSTRUCTS);
RXDT_DefineCategory(DISPATCH);
RXDT_DefineCategory(EA);
RXDT_DefineCategory(DEVFCB);
RXDT_DefineCategory(INIT);

//
// The following enumerated values signify the current state of the minirdr
// initialization. With the aid of this state information, it is possible
// to determine which resources to deallocate, whether deallocation comes
// as a result of a normal stop/unload, or as the result of an exception
//

typedef enum _NULMRX_INIT_STATES {
    NULMRXINIT_ALL_INITIALIZATION_COMPLETED,
    NULMRXINIT_MINIRDR_REGISTERED,
    NULMRXINIT_START
} NULMRX_INIT_STATES;

//
// function prototypes
//

NTSTATUS
NulMRxInitializeTables(
          void
    );

VOID
NulMRxUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
NulMRxInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN NULMRX_INIT_STATES NulMRxInitState
    );


NTSTATUS
NulMRxFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
NulMRxReadRegistryParameters();

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This is the initialization routine for the mini redirector

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    RXSTATUS - The function value is the final status from the initialization
        operation.

--*/
{
    NTSTATUS        	Status;
    PRX_CONTEXT     	RxContext = NULL;
    ULONG           	Controls = 0;
    NULMRX_INIT_STATES	NulMRxInitState = 0;
    UNICODE_STRING		NulMRxName;
    UNICODE_STRING		UserModeDeviceName;
    PNULMRX_DEVICE_EXTENSION pDeviceExtension;
    ULONG i;

    DbgPrint("+++ NULMRX Driver %08lx Loaded +++\n", DriverObject);
    Status =  RxDriverEntry(DriverObject, RegistryPath);
    if (Status != STATUS_SUCCESS) {
        DbgPrint("Wrapper failed to initialize. Status = %08lx\n",Status);
        return(Status);
    }

    try {
        NulMRxInitState = NULMRXINIT_START;

        //
        //  Register this minirdr with the connection engine. Registration makes the connection
        //  engine aware of the device name, driver object, and other characteristics.
        //  If registration is successful, a new device object is returned
        //
        //


        RtlInitUnicodeString(&NulMRxName, DD_NULMRX_FS_DEVICE_NAME_U);
        SetFlag(Controls,RX_REGISTERMINI_FLAG_DONT_PROVIDE_UNCS);
        SetFlag(Controls,RX_REGISTERMINI_FLAG_DONT_PROVIDE_MAILSLOTS);
        
        Status = RxRegisterMinirdr(
                     &NulMRxDeviceObject,				// where the new device object goes
                     DriverObject,						// the Driver Object to register
                     &NulMRxDispatch,					// the dispatch table for this driver
                     Controls,							// dont register with unc and for mailslots
                     &NulMRxName,						// the device name for this minirdr
                     sizeof(NULMRX_DEVICE_EXTENSION),	// IN ULONG DeviceExtensionSize,
                     FILE_DEVICE_NETWORK_FILE_SYSTEM,	// IN ULONG DeviceType - disk ?
                     FILE_REMOTE_DEVICE					// IN  ULONG DeviceCharacteristics
                     );

        if (Status!=STATUS_SUCCESS) {
            DbgPrint("NulMRxDriverEntry failed: %08lx\n", Status );
            try_return(Status);
        }

        //
        //  Init the device extension data
        //  NOTE: the device extension actually points to fields
        //  in the RDBSS_DEVICE_OBJECT. Our space is past the end
        //  of this struct !!
        //

        pDeviceExtension = (PNULMRX_DEVICE_EXTENSION)
            ((PBYTE)(NulMRxDeviceObject) + sizeof(RDBSS_DEVICE_OBJECT));

        RxDefineNode(pDeviceExtension,NULMRX_DEVICE_EXTENSION);
        pDeviceExtension->DeviceObject = NulMRxDeviceObject;

		// initialize local connection list
        for (i = 0; i < 26; i++)
		{
			pDeviceExtension->LocalConnections[i] = FALSE;
		}
		// Mutex for synchronizining our connection list
		ExInitializeFastMutex( &pDeviceExtension->LCMutex );

        // The device object has been created. Need to setup a symbolic
        // link so that the device may be accessed from a Win32 user mode
        // application.

        RtlInitUnicodeString(&UserModeDeviceName, DD_NULMRX_USERMODE_SHADOW_DEV_NAME_U);
        Status = IoCreateSymbolicLink( &UserModeDeviceName, &NulMRxName);
        if (Status!=STATUS_SUCCESS) {
            DbgPrint("NulMRxDriverEntry failed: %08lx\n", Status );
            try_return(Status);
        }

        NulMRxInitState = NULMRXINIT_MINIRDR_REGISTERED;

        //
        // Build the dispatch tables for the minirdr
        //

        Status = NulMRxInitializeTables();

        if (!NT_SUCCESS( Status )) {
            try_return(Status);
        }

        //
        // Get information from the registry
        //
        NulMRxReadRegistryParameters();

  try_exit: NOTHING;
    } finally {
        if (Status != STATUS_SUCCESS) {

            NulMRxInitUnwind(DriverObject,NulMRxInitState);
        }
    }

    if (Status != STATUS_SUCCESS) {

        DbgPrint("NulMRx failed to start with %08lx %08lx\n",Status,NulMRxInitState);
        return(Status);
    }


    //
    //  Setup Unload Routine
    //

    DriverObject->DriverUnload = NulMRxUnload;

    //
    //setup the driver dispatch for people who come in here directly....like the browser
    //

    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
    {
        DriverObject->MajorFunction[i] = (PDRIVER_DISPATCH)NulMRxFsdDispatch;
    }
  
    //
    //  Start the mini-rdr (used to be a START IOCTL)
    //
    RxContext = RxCreateRxContext(
                    NULL,
                    NulMRxDeviceObject,
                    RX_CONTEXT_FLAG_IN_FSP);

    if (RxContext != NULL) {
        Status = RxStartMinirdr(
                             RxContext,
                             &RxContext->PostRequest);

        if (Status == STATUS_SUCCESS) {
            NULMRX_STATE State;

            State = (NULMRX_STATE)InterlockedCompareExchange(
                                                 (LONG *)&NulMRxState,
                                                 NULMRX_STARTED,
                                                 NULMRX_STARTABLE);
                    
            if (State != NULMRX_STARTABLE) {
                Status = STATUS_REDIRECTOR_STARTED;
                DbgPrint("Status is STATUS_REDIR_STARTED\n");
            }

            //
            //  Chance to get resources in context
            //  of system process.....!!!
            //
  
        } else if(Status == STATUS_PENDING ) {
    
        }
        
        RxDereferenceAndDeleteRxContext(RxContext);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
              
    return  STATUS_SUCCESS;
}

VOID
NulMRxInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN NULMRX_INIT_STATES NulMRxInitState
    )
/*++

Routine Description:

     This routine does the common uninit work for unwinding from a bad driver entry or for unloading.

Arguments:

     NulMRxInitState - tells how far we got into the intialization

Return Value:

     None

--*/

{
    PAGED_CODE();

    switch (NulMRxInitState) {
    case NULMRXINIT_ALL_INITIALIZATION_COMPLETED:

        //Nothing extra to do...this is just so that the constant in RxUnload doesn't change.......
        //lack of break intentional

    case NULMRXINIT_MINIRDR_REGISTERED:
        RxUnregisterMinirdr(NulMRxDeviceObject);

        //lack of break intentional

    case NULMRXINIT_START:
        break;
    }

}

VOID
NulMRxUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

     This is the unload routine for the Exchange mini redirector.

Arguments:

     DriverObject - pointer to the driver object for the NulMRx

Return Value:

     None

--*/

{
    PRX_CONTEXT RxContext;
    NTSTATUS    Status;
    UNICODE_STRING  UserModeDeviceName;

    PAGED_CODE();

    NulMRxInitUnwind(DriverObject,NULMRXINIT_ALL_INITIALIZATION_COMPLETED);
    RxContext = RxCreateRxContext(
                    NULL,
                    NulMRxDeviceObject,
                    RX_CONTEXT_FLAG_IN_FSP);

    if (RxContext != NULL) {
        Status = RxStopMinirdr(
                     RxContext,
                     &RxContext->PostRequest);


        if (Status == STATUS_SUCCESS) {
            NULMRX_STATE State;

            State = (NULMRX_STATE)InterlockedCompareExchange(
                         (LONG *)&NulMRxState,
                         NULMRX_STARTABLE,
                         NULMRX_STARTED);

            if (State != NULMRX_STARTABLE) {
                Status = STATUS_REDIRECTOR_STARTED;
            }
        }

        RxDereferenceAndDeleteRxContext(RxContext);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlInitUnicodeString(&UserModeDeviceName, DD_NULMRX_USERMODE_SHADOW_DEV_NAME_U);
    Status = IoDeleteSymbolicLink( &UserModeDeviceName);
    if (Status!=STATUS_SUCCESS) {
        DbgPrint("NulMRx: Could not delete Symbolic Link\n");
    }

    RxUnload(DriverObject);
    DbgPrint("+++ NULMRX Driver %08lx Unoaded +++\n", DriverObject);
}


NTSTATUS
NulMRxInitializeTables(
          void
    )
/*++

Routine Description:

     This routine sets up the mini redirector dispatch vector and also calls
     to initialize any other tables needed.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    //
    // Ensure that the Exchange mini redirector context satisfies the size constraints
    //
    //ASSERT(sizeof(NULMRX_RX_CONTEXT) <= MRX_CONTEXT_SIZE);

    //
    // Build the local minirdr dispatch table and initialize
    //

    ZeroAndInitializeNodeType( &NulMRxDispatch, RDBSS_NTC_MINIRDR_DISPATCH, sizeof(MINIRDR_DISPATCH));

    //
    // null mini redirector extension sizes and allocation policies.
    //


    NulMRxDispatch.MRxFlags = (RDBSS_MANAGE_NET_ROOT_EXTENSION |
                               RDBSS_MANAGE_FCB_EXTENSION);

    NulMRxDispatch.MRxSrvCallSize  = 0; // srvcall extension is not handled in rdbss
    NulMRxDispatch.MRxNetRootSize  = sizeof(NULMRX_NETROOT_EXTENSION);
    NulMRxDispatch.MRxVNetRootSize = 0;
    NulMRxDispatch.MRxFcbSize      = sizeof(NULMRX_FCB_EXTENSION);
    NulMRxDispatch.MRxSrvOpenSize  = 0;
    NulMRxDispatch.MRxFobxSize     = 0;

    // Mini redirector cancel routine ..
    
    NulMRxDispatch.MRxCancel = NULL;

    //
    // Mini redirector Start/Stop. Each mini-rdr can be started or stopped
    // while the others continue to operate.
    //

    NulMRxDispatch.MRxStart                = NulMRxStart;
    NulMRxDispatch.MRxStop                 = NulMRxStop;
    NulMRxDispatch.MRxDevFcbXXXControlFile = NulMRxDevFcbXXXControlFile;

    //
    // Mini redirector name resolution.
    //

    NulMRxDispatch.MRxCreateSrvCall       = NulMRxCreateSrvCall;
    NulMRxDispatch.MRxSrvCallWinnerNotify = NulMRxSrvCallWinnerNotify;
    NulMRxDispatch.MRxCreateVNetRoot      = NulMRxCreateVNetRoot;
    NulMRxDispatch.MRxUpdateNetRootState  = NulMRxUpdateNetRootState;
    NulMRxDispatch.MRxExtractNetRootName  = NulMRxExtractNetRootName;
    NulMRxDispatch.MRxFinalizeSrvCall     = NulMRxFinalizeSrvCall;
    NulMRxDispatch.MRxFinalizeNetRoot     = NulMRxFinalizeNetRoot;
    NulMRxDispatch.MRxFinalizeVNetRoot    = NulMRxFinalizeVNetRoot;

    //
    // File System Object Creation/Deletion.
    //

    NulMRxDispatch.MRxCreate            = NulMRxCreate;
    NulMRxDispatch.MRxCollapseOpen      = NulMRxCollapseOpen;
    NulMRxDispatch.MRxShouldTryToCollapseThisOpen = NulMRxShouldTryToCollapseThisOpen;
    NulMRxDispatch.MRxExtendForCache    = NulMRxExtendFile;
    NulMRxDispatch.MRxExtendForNonCache = NulMRxExtendFile;
    NulMRxDispatch.MRxTruncate          = NulMRxTruncate;
    NulMRxDispatch.MRxCleanupFobx       = NulMRxCleanupFobx;
    NulMRxDispatch.MRxCloseSrvOpen      = NulMRxCloseSrvOpen;
    NulMRxDispatch.MRxFlush             = NulMRxFlush;
    NulMRxDispatch.MRxForceClosed       = NulMRxForcedClose;
    NulMRxDispatch.MRxDeallocateForFcb  = NulMRxDeallocateForFcb;
    NulMRxDispatch.MRxDeallocateForFobx = NulMRxDeallocateForFobx;

    //
    // File System Objects query/Set
    //

    NulMRxDispatch.MRxQueryDirectory       = NulMRxQueryDirectory;
    NulMRxDispatch.MRxQueryVolumeInfo      = NulMRxQueryVolumeInformation;
    NulMRxDispatch.MRxQueryEaInfo          = NulMRxQueryEaInformation;
    NulMRxDispatch.MRxSetEaInfo            = NulMRxSetEaInformation;
    NulMRxDispatch.MRxQuerySdInfo          = NulMRxQuerySecurityInformation;
    NulMRxDispatch.MRxSetSdInfo            = NulMRxSetSecurityInformation;
    NulMRxDispatch.MRxQueryFileInfo        = NulMRxQueryFileInformation;
    NulMRxDispatch.MRxSetFileInfo          = NulMRxSetFileInformation;
    NulMRxDispatch.MRxSetFileInfoAtCleanup = NulMRxSetFileInformationAtCleanup;

    //
    // Buffering state change
    //

    NulMRxDispatch.MRxComputeNewBufferingState = NulMRxComputeNewBufferingState;

    //
    // File System Object I/O
    //

    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_READ]            = NulMRxRead;
    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_WRITE]           = NulMRxWrite;
    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_SHAREDLOCK]      = NulMRxLocks;
    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_EXCLUSIVELOCK]   = NulMRxLocks;
    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK]          = NulMRxLocks;
    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK_MULTIPLE] = NulMRxLocks;
    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_FSCTL]           = NulMRxFsCtl;
    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_IOCTL]           = NulMRxIoCtl;

    NulMRxDispatch.MRxLowIOSubmit[LOWIO_OP_NOTIFY_CHANGE_DIRECTORY] = NulMRxNotifyChangeDirectory;

    //
    // Miscellanous
    //

    NulMRxDispatch.MRxCompleteBufferingStateChangeRequest = NulMRxCompleteBufferingStateChangeRequest;

    return(STATUS_SUCCESS);
}




NTSTATUS
NulMRxStart(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

     This routine completes the initialization of the mini redirector fromn the
     RDBSS perspective. Note that this is different from the initialization done
     in DriverEntry. Any initialization that depends on RDBSS should be done as
     part of this routine while the initialization that is independent of RDBSS
     should be done in the DriverEntry routine.

Arguments:

    RxContext - Supplies the Irp that was used to startup the rdbss

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    return Status;
}





NTSTATUS
NulMRxStop(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    This routine is used to activate the mini redirector from the RDBSS perspective

Arguments:

    RxContext - the context that was used to start the mini redirector

    pContext  - the null mini rdr context passed in at registration time.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    //DbgPrint("Entering NulMRxStop \n");

    return(STATUS_SUCCESS);
}



NTSTATUS
NulMRxInitializeSecurity (VOID)
/*++

Routine Description:

    This routine initializes the null miniredirector security .

Arguments:

    None.

Return Value:

    None.

Note:

    This API can only be called from a FS process.

--*/
{
   NTSTATUS Status = STATUS_SUCCESS;

   ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());
   return Status;
}


NTSTATUS
NulMRxUninitializeSecurity(VOID)
/*++

Routine Description:

Arguments:

    None.

Return Value:

    None.

Note:

    This API can only be called from a FS process.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();
    return Status;
}

NTSTATUS
NulMRxFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD dispatch for the mini DRIVER object. 

Arguments:

    DeviceObject - Supplies the device object for the packet being processed.

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The Fsd status for the Irp

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    ASSERT(DeviceObject==(PDEVICE_OBJECT)NulMRxDeviceObject);
    if (DeviceObject!=(PDEVICE_OBJECT)NulMRxDeviceObject) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT );
        return (STATUS_INVALID_DEVICE_REQUEST);
    }

    Status = RxFsdDispatch((PRDBSS_DEVICE_OBJECT)NulMRxDeviceObject,Irp);
    return Status;
}

NTSTATUS
NulMRxGetUlongRegistryParameter(
    HANDLE ParametersHandle,
    PWCHAR ParameterName,
    PULONG ParamUlong,
    BOOLEAN LogFailure
    )
/*++

Routine Description:

    This routine is called to read a ULONG param from t he registry.

Arguments:

    ParametersHandle - the handle of the containing registry "folder"
    ParameterName    - name of the parameter to be read
    ParamUlong       - where to store the value, if successful
    LogFailure       - if TRUE and the registry stuff fails, log an error

Return Value:

    RXSTATUS - STATUS_SUCCESS

--*/
{
    ULONG Storage[16];
    PKEY_VALUE_PARTIAL_INFORMATION Value;
    ULONG ValueSize;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG BytesRead;

    PAGED_CODE(); //INIT

    Value = (PKEY_VALUE_PARTIAL_INFORMATION)Storage;
    ValueSize = sizeof(Storage);

    RtlInitUnicodeString(&UnicodeString, ParameterName);

    Status = ZwQueryValueKey(ParametersHandle,
                        &UnicodeString,
                        KeyValuePartialInformation,
                        Value,
                        ValueSize,
                        &BytesRead);


    if (NT_SUCCESS(Status)) {
        if (Value->Type == REG_DWORD) {
            PULONG ConfigValue = (PULONG)&Value->Data[0];
            *ParamUlong = *((PULONG)ConfigValue);
            DbgPrint("readRegistryvalue %wZ = %08lx\n",&UnicodeString,*ParamUlong);
            return(STATUS_SUCCESS);
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
     }

     if (LogFailure)
     {
     	// log the failure...
     }

     return Status;
}

VOID
NulMRxReadRegistryParameters()
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING ParametersRegistryKeyName;
    HANDLE ParametersHandle;
    ULONG Temp;

    RtlInitUnicodeString(&ParametersRegistryKeyName, NULL_MINIRDR_PARAMETERS);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &ParametersRegistryKeyName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwOpenKey (&ParametersHandle, KEY_READ, &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
	    Status = NulMRxGetUlongRegistryParameter(ParametersHandle,
	                              L"LogRate",
	                              (PULONG)&Temp,
	                              FALSE
	                              );
    }
    if (NT_SUCCESS(Status)) LogRate = Temp;
    
    ZwClose(ParametersHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\mrxglobs.h ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    mrxglobs.h

Abstract:

    The global include file for NULMRX mini-redirector

--*/

#ifndef _MRXGLOBS_H_
#define _MRXGLOBS_H_

extern PRDBSS_DEVICE_OBJECT NulMRxDeviceObject;
#define RxNetNameTable (*(*___MINIRDR_IMPORTS_NAME).pRxNetNameTable)

// The following enum type defines the various states associated with the null
// mini redirector. This is used during initialization

typedef enum _NULMRX_STATE_ {
   NULMRX_STARTABLE,
   NULMRX_START_IN_PROGRESS,
   NULMRX_STARTED
} NULMRX_STATE,*PNULMRX_STATE;

extern NULMRX_STATE NulMRxState;
extern ULONG        LogRate;
extern ULONG        NulMRxVersion;

//
//  Reg keys
//
#define NULL_MINIRDR_PARAMETERS \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\NulMRx\\Parameters"

//
//  Use the RxDefineObj and RxCheckObj macros
//  to enforce signed structs.
//

#define RxDefineObj( type, var )            \
        var.Signature = type##_SIGNATURE;

#define RxCheckObj( type, var )             \
        ASSERT( (var).Signature == type##_SIGNATURE );

//
//  Use the RxDefineNode and RxCheckNode macros
//  to enforce node signatures and sizes.
//

#define RxDefineNode( node, type )          \
        node->NodeTypeCode = NTC_##type;    \
        node->NodeByteSize = sizeof(type);

#define RxCheckNode( node, type )           \
        ASSERT( NodeType(node) == NTC_##type );

//
// struct node types - start from 0xFF00
//
typedef enum _NULMRX_STORAGE_TYPE_CODES {
    NTC_NULMRX_DEVICE_EXTENSION      =   (NODE_TYPE_CODE)0xFF00,
    NTC_NULMRX_SRVCALL_EXTENSION     =   (NODE_TYPE_CODE)0xFF01,
    NTC_NULMRX_NETROOT_EXTENSION     =   (NODE_TYPE_CODE)0xFF02,
    NTC_NULMRX_FCB_EXTENSION         =   (NODE_TYPE_CODE)0xFF03
    
} NULMRX_STORAGE_TYPE_CODES;

//
// typedef our device extension - stores state global to the driver
//
typedef struct _NULMRX_DEVICE_EXTENSION {
    //
    //  Node type code and size
    //
    NODE_TYPE_CODE          NodeTypeCode;
    NODE_BYTE_SIZE          NodeByteSize;
    
    //
    //  Back-pointer to owning device object
    //
    PRDBSS_DEVICE_OBJECT    DeviceObject;

    //
    //  Count of active nodes
    //  Driver can be unloaded iff ActiveNodes == 0
    //
    ULONG                   ActiveNodes;
	
	//	Keep a list of local connections used
	CHAR					LocalConnections[26];
	FAST_MUTEX				LCMutex;

} NULMRX_DEVICE_EXTENSION, *PNULMRX_DEVICE_EXTENSION;

//
// typedef our srv-call extension - stores state global to a node
// NYI since wrapper does not allocate space for this..........!
//
typedef struct _NULMRX_SRVCALL_EXTENSION {
    //
    //  Node type code and size
    //
    NODE_TYPE_CODE          NodeTypeCode;
    NODE_BYTE_SIZE          NodeByteSize;
    
} NULMRX_SRVCALL_EXTENSION, *PNULMRX_SRVCALL_EXTENSION;

//
// NET_ROOT extension - stores state global to a root
//
typedef struct _NULMRX_NETROOT_EXTENSION {
    //
    //  Node type code and size
    //
    NODE_TYPE_CODE          NodeTypeCode;
    NODE_BYTE_SIZE          NodeByteSize;

} NULMRX_NETROOT_EXTENSION, *PNULMRX_NETROOT_EXTENSION;

//
//  reinitialize netroot data
//

#define     RxResetNetRootExtension(pNetRootExtension)                          \
            RxDefineNode(pNetRootExtension,NULMRX_NETROOT_EXTENSION);          

//
//  typedef our FCB extension
//  the FCB uniquely represents an IFS stream
//  NOTE: Since we are not a paging file, this mem is paged !!!
//

typedef struct _NULMRX_FCB_EXTENSION_ {
    //
    //  Node type code and size
    //
    NODE_TYPE_CODE          NodeTypeCode;
    NODE_BYTE_SIZE          NodeByteSize;
    
} NULMRX_FCB_EXTENSION, *PNULMRX_FCB_EXTENSION;

//
//  Macros to get & validate extensions
//

#define NulMRxGetDeviceExtension(RxContext,pExt)        \
        PNULMRX_DEVICE_EXTENSION pExt = (PNULMRX_DEVICE_EXTENSION)((PBYTE)(RxContext->RxDeviceObject) + sizeof(RDBSS_DEVICE_OBJECT))

#define NulMRxGetSrvCallExtension(pSrvCall, pExt)       \
        PNULMRX_SRVCALL_EXTENSION pExt = (((pSrvCall) == NULL) ? NULL : (PNULMRX_SRVCALL_EXTENSION)((pSrvCall)->Context))

#define NulMRxGetNetRootExtension(pNetRoot,pExt)        \
        PNULMRX_NETROOT_EXTENSION pExt = (((pNetRoot) == NULL) ? NULL : (PNULMRX_NETROOT_EXTENSION)((pNetRoot)->Context))

#define NulMRxGetFcbExtension(pFcb,pExt)                \
        PNULMRX_FCB_EXTENSION pExt = (((pFcb) == NULL) ? NULL : (PNULMRX_FCB_EXTENSION)((pFcb)->Context))

//
// forward declarations for all dispatch vector methods.
//

extern NTSTATUS
NulMRxStart (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

extern NTSTATUS
NulMRxStop (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

extern NTSTATUS
NulMRxMinirdrControl (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PVOID pContext,
    IN OUT PUCHAR SharedBuffer,
    IN     ULONG InputBufferLength,
    IN     ULONG OutputBufferLength,
    OUT PULONG CopyBackLength
    );

extern NTSTATUS
NulMRxDevFcb (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxCreate (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxCollapseOpen (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxShouldTryToCollapseThisOpen (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxRead (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxWrite (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxLocks(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxFlush(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxFsCtl(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
NulMRxIoCtl(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxNotifyChangeDirectory(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxComputeNewBufferingState(
    IN OUT PMRX_SRV_OPEN pSrvOpen,
    IN     PVOID         pMRxContext,
       OUT ULONG         *pNewBufferingState);

extern NTSTATUS
NulMRxFlush (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxCloseWithDelete (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxZeroExtend (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxTruncate (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxCleanupFobx (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxCloseSrvOpen (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxClosedSrvOpenTimeOut (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxQueryDirectory (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxQueryEaInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxSetEaInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

extern NTSTATUS
NulMRxQuerySecurityInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxSetSecurityInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

extern NTSTATUS
NulMRxQueryVolumeInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxSetVolumeInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxLowIOSubmit (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
NulMRxCreateVNetRoot(
    IN OUT PMRX_CREATENETROOT_CONTEXT pContext
    );

extern NTSTATUS
NulMRxFinalizeVNetRoot(
    IN OUT PMRX_V_NET_ROOT pVirtualNetRoot,
    IN     PBOOLEAN    ForceDisconnect);

extern NTSTATUS
NulMRxFinalizeNetRoot(
    IN OUT PMRX_NET_ROOT pNetRoot,
    IN     PBOOLEAN      ForceDisconnect);

extern NTSTATUS
NulMRxUpdateNetRootState(
    IN  PMRX_NET_ROOT pNetRoot);

VOID
NulMRxExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    );

extern NTSTATUS
NulMRxCreateSrvCall(
      PMRX_SRV_CALL                      pSrvCall,
      PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext);

extern NTSTATUS
NulMRxFinalizeSrvCall(
      PMRX_SRV_CALL    pSrvCall,
      BOOLEAN    Force);

extern NTSTATUS
NulMRxSrvCallWinnerNotify(
      IN OUT PMRX_SRV_CALL      pSrvCall,
      IN     BOOLEAN        ThisMinirdrIsTheWinner,
      IN OUT PVOID          pSrvCallContext);


extern NTSTATUS
NulMRxQueryFileInformation (
    IN OUT PRX_CONTEXT            RxContext
    );

extern NTSTATUS
NulMRxQueryNamedPipeInformation (
    IN OUT PRX_CONTEXT            RxContext,
    IN     FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID              Buffer,
    IN OUT PULONG             pLengthRemaining
    );

extern NTSTATUS
NulMRxSetFileInformation (
    IN OUT PRX_CONTEXT            RxContext
    );

extern NTSTATUS
NulMRxSetNamedPipeInformation (
    IN OUT PRX_CONTEXT            RxContext,
    IN     FILE_INFORMATION_CLASS FileInformationClass,
    IN     PVOID              pBuffer,
    IN     ULONG              BufferLength
    );

NTSTATUS
NulMRxSetFileInformationAtCleanup(
      IN OUT PRX_CONTEXT            RxContext
      );

NTSTATUS
NulMRxDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    );

NTSTATUS
NulMRxDeallocateForFobx (
    IN OUT PMRX_FOBX pFobx
    );

extern NTSTATUS
NulMRxForcedClose (
    IN OUT PMRX_SRV_OPEN SrvOpen
    );

extern NTSTATUS
NulMRxExtendFile (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    );

extern NTSTATUS
NulMRxTruncateFile (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    );

extern NTSTATUS
NulMRxCompleteBufferingStateChangeRequest (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRX_SRV_OPEN   SrvOpen,
    IN     PVOID       pContext
    );


extern NTSTATUS
NulMRxExtendForCache (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PFCB Fcb,
    OUT    PLONGLONG pNewFileSize
    );

extern
NTSTATUS
NulMRxInitializeSecurity (VOID);

extern
NTSTATUS
NulMRxUninitializeSecurity (VOID);

extern
NTSTATUS
NulMRxInitializeTransport(VOID);

extern
NTSTATUS
NulMRxUninitializeTransport(VOID);

#define NulMRxMakeSrvOpenKey(Tid,Fid) \
        (PVOID)(((ULONG)(Tid) << 16) | (ULONG)(Fid))

#include "mrxprocs.h"   // crossreferenced routines

#endif _MRXGLOBS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\fileinfo.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements the mini redirector call down routines pertaining to retrieval/
    update of file/directory/volume information.

--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)

NTSTATUS
NulMRxQueryDirectory(
    IN OUT PRX_CONTEXT            RxContext
    )
/*++

Routine Description:

   This routine does a directory query. Only the NT-->NT path is implemented.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID   Buffer;
    PULONG  pLengthRemaining;
	ULONG	CopySize;

    FileInformationClass = RxContext->Info.FileInformationClass;
    Buffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;

    switch (FileInformationClass)
    {
	    case FileDirectoryInformation:
		{
	        PFILE_DIRECTORY_INFORMATION pDirInfo = (PFILE_DIRECTORY_INFORMATION) Buffer;
			CopySize = sizeof( FILE_DIRECTORY_INFORMATION );
			if ( *pLengthRemaining > CopySize )
			{
	            RtlZeroMemory( pDirInfo, CopySize );
			    pDirInfo->FileAttributes = FILE_ATTRIBUTE_DIRECTORY;
			    pDirInfo->FileNameLength = sizeof( WCHAR );
			    pDirInfo->FileName[0] = L'.';
				*pLengthRemaining = CopySize;
				Status = RxContext->QueryDirectory.InitialQuery ?
				             STATUS_SUCCESS : STATUS_NO_MORE_FILES;
			}
		}
		break;

	    case FileFullDirectoryInformation:
		{
	        PFILE_FULL_DIR_INFORMATION pFullDirInfo = (PFILE_FULL_DIR_INFORMATION) Buffer;
			CopySize = sizeof( FILE_FULL_DIR_INFORMATION );
			if ( *pLengthRemaining > CopySize )
			{
	            RtlZeroMemory( pFullDirInfo, CopySize );
			    pFullDirInfo->FileAttributes = FILE_ATTRIBUTE_DIRECTORY;
			    pFullDirInfo->FileNameLength = sizeof( WCHAR );
			    pFullDirInfo->FileName[0] = L'.';
				*pLengthRemaining = CopySize;
				Status = RxContext->QueryDirectory.InitialQuery ?
				             STATUS_SUCCESS : STATUS_NO_MORE_FILES;
			}
		}
        break;

		case FileBothDirectoryInformation:
		{
	        PFILE_BOTH_DIR_INFORMATION pBothDirInfo = (PFILE_BOTH_DIR_INFORMATION) Buffer;
			CopySize = sizeof( FILE_BOTH_DIR_INFORMATION );
			if ( *pLengthRemaining > CopySize )
			{
	            RtlZeroMemory( pBothDirInfo, CopySize );
			    pBothDirInfo->FileAttributes = FILE_ATTRIBUTE_DIRECTORY;
			    pBothDirInfo->FileNameLength = sizeof( WCHAR );
			    pBothDirInfo->FileName[0] = L'.';
			    pBothDirInfo->ShortNameLength = sizeof( WCHAR );
			    pBothDirInfo->ShortName[0] = L'.';
				*pLengthRemaining = CopySize;
				Status = RxContext->QueryDirectory.InitialQuery ?
				             STATUS_SUCCESS : STATUS_NO_MORE_FILES;
			}
		}
        break;

		case FileNamesInformation:
		{
	        PFILE_NAMES_INFORMATION pNamesDirInfo = (PFILE_NAMES_INFORMATION) Buffer;
			CopySize = sizeof( FILE_NAMES_INFORMATION );
			if ( *pLengthRemaining > CopySize )
			{
	            RtlZeroMemory( pNamesDirInfo, CopySize );
			    pNamesDirInfo->FileNameLength = sizeof( WCHAR );
			    pNamesDirInfo->FileName[0] = L'.';
				*pLengthRemaining = CopySize;
				Status = RxContext->QueryDirectory.InitialQuery ?
				             STATUS_SUCCESS : STATUS_NO_MORE_FILES;
			}
		}
        break;

		default:
			RxDbgTrace( 0, Dbg, ("NulMRxQueryDirectory: Invalid FS information class\n"));
			Status = STATUS_INVALID_PARAMETER;
			break;
	}

    DbgPrint("NulMRxQueryDirectory \n");
    return(Status);
}


NTSTATUS
NulMRxQueryVolumeInformation(
      IN OUT PRX_CONTEXT          RxContext
      )
/*++

Routine Description:

   This routine queries the volume information

Arguments:

    pRxContext         - the RDBSS context

    FsInformationClass - the kind of Fs information desired.

    pBuffer            - the buffer for copying the information

    pBufferLength      - the buffer length ( set to buffer length on input and set
                         to the remaining length on output)

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    RxCaptureFcb;

    ULONG    OriginalLength = RxContext->Info.LengthRemaining;
    FS_INFORMATION_CLASS FsInformationClass = RxContext->Info.FsInformationClass;
    PVOID OriginalBuffer = RxContext->Info.Buffer;
    UNICODE_STRING ustrVolume;
    ULONG BytesToCopy;

    RxTraceEnter("NulMRxQueryVolumeInformation");

    switch( FsInformationClass ) {
        case FileFsVolumeInformation:
		{
    		PFILE_FS_VOLUME_INFORMATION pVolInfo = (PFILE_FS_VOLUME_INFORMATION) OriginalBuffer;
            RtlZeroMemory( pVolInfo, sizeof(FILE_FS_VOLUME_INFORMATION) );
            pVolInfo->VolumeCreationTime.QuadPart = 0;
            pVolInfo->VolumeSerialNumber = 0xBABAFACE;
            pVolInfo->VolumeLabelLength = sizeof(L"NULMRX");
            pVolInfo->SupportsObjects = FALSE;
            RtlInitUnicodeString( &ustrVolume, L"NULMRX" );

            RxContext->Info.LengthRemaining -= FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel[0]);

            if (RxContext->Info.LengthRemaining >= (LONG)pVolInfo->VolumeLabelLength) {
                BytesToCopy = pVolInfo->VolumeLabelLength;
            } else {
                BytesToCopy = RxContext->Info.LengthRemaining;
            }

            RtlCopyMemory( &pVolInfo->VolumeLabel[0], (PVOID)ustrVolume.Buffer, BytesToCopy );
            RxContext->Info.LengthRemaining -= BytesToCopy;
            pVolInfo->VolumeLabelLength = BytesToCopy;
           
            Status = STATUS_SUCCESS;            
            DbgPrint("FileFsVolumeInformation\n");
		}
        break;
    
        case FileFsLabelInformation:
            DbgPrint("FileFsLabelInformation\n");
            break;
        
        case FileFsSizeInformation:
            DbgPrint("FileFsSizeInformation\n");
            break;
    
        case FileFsDeviceInformation:
            DbgPrint("FileFsDeviceInformation\n");
            break;
    
        case FileFsAttributeInformation:
		{
			PFILE_FS_ATTRIBUTE_INFORMATION pAttribInfo =
				(PFILE_FS_ATTRIBUTE_INFORMATION) OriginalBuffer;

			pAttribInfo->FileSystemAttributes = 0;
			pAttribInfo->MaximumComponentNameLength = 32;

            RxContext->Info.LengthRemaining -= FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName[0]);
			pAttribInfo->FileSystemNameLength = sizeof(L"SampleFS");
            if (RxContext->Info.LengthRemaining >= (LONG)pAttribInfo->FileSystemNameLength) {
                BytesToCopy = pAttribInfo->FileSystemNameLength;
            } else {
                BytesToCopy = RxContext->Info.LengthRemaining;
            }
            RtlCopyMemory( pAttribInfo->FileSystemName, L"SampleFS", BytesToCopy );
            RxContext->Info.LengthRemaining -= BytesToCopy;
			pAttribInfo->FileSystemNameLength = BytesToCopy;
           
            Status = STATUS_SUCCESS;            
            
            DbgPrint("FileFsAttributeInformation\n");
		}
        break;
    
        case FileFsControlInformation:
            DbgPrint("FileFsControlInformation\n");
            break;
    
        case FileFsFullSizeInformation:
            DbgPrint("FileFsFullSizeInformation\n");
            break;
    
        case FileFsObjectIdInformation:
            DbgPrint("FileFsObjectIdInformation\n");
            break;
    
        case FileFsMaximumInformation:
            DbgPrint("FileFsMaximumInformation\n");
            break;
    
        default:
            break;
    }

    RxTraceLeave(Status);
    return(Status);
}

NTSTATUS
NulMRxSetVolumeInformation(
      IN OUT PRX_CONTEXT              pRxContext
      )
/*++

Routine Description:

   This routine sets the volume information

Arguments:

    pRxContext - the RDBSS context

    FsInformationClass - the kind of Fs information desired.

    pBuffer            - the buffer for copying the information

    BufferLength       - the buffer length

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    DbgPrint("NulMRxSetVolumeInformation \n");
    return(Status);
}


NTSTATUS
NulMRxQueryFileInformation(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine does a query file info. Only the NT-->NT path is implemented.

   The NT-->NT path works by just remoting the call basically without further ado.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    FILE_INFORMATION_CLASS FunctionalityRequested = 
            RxContext->Info.FileInformationClass;
    PFILE_STANDARD_INFORMATION pFileStdInfo = 
            (PFILE_STANDARD_INFORMATION) RxContext->Info.Buffer;

    RxTraceEnter("NulMRxQueryFileInformation");

    switch( FunctionalityRequested ) {
        case FileBasicInformation:
            RxContext->Info.LengthRemaining -= sizeof(FILE_BASIC_INFORMATION);
            break;
    
        case FileInternalInformation:
            RxContext->Info.LengthRemaining -= sizeof(FILE_INTERNAL_INFORMATION);
            break;
            
        case FileEaInformation:
            RxContext->Info.LengthRemaining -= sizeof(FILE_EA_INFORMATION);
            break;
            
        case FileStandardInformation:

            RxDbgTrace(0, Dbg, ("FileSize is %d AllocationSize is %d\n",
                pFileStdInfo->EndOfFile.LowPart,pFileStdInfo->AllocationSize.LowPart));
            //(RxContext->CurrentIrp)->IoStatus.Information = sizeof(FILE_STANDARD_INFORMATION);
            RxContext->Info.LengthRemaining -= sizeof(FILE_STANDARD_INFORMATION);
            break;
        
        default:
            break;
    }
    
    RxTraceLeave(Status);
    return(Status);
}

NTSTATUS
NulMRxSetFileInformation(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine does a set file info. Only the NT-->NT path is implemented.

   The NT-->NT path works by just remoting the call basically without further ado.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    FILE_INFORMATION_CLASS FunctionalityRequested = 
            RxContext->Info.FileInformationClass;
    PFILE_END_OF_FILE_INFORMATION pEndOfFileInfo = 
            (PFILE_END_OF_FILE_INFORMATION) RxContext->Info.Buffer;
    LARGE_INTEGER NewAllocationSize;

    RxTraceEnter("NulMRxSetFileInformation");

    switch( FunctionalityRequested ) {
        case FileBasicInformation:
            RxDbgTrace(0, Dbg, ("FileBasicInformation\n"));
            break;
    
        case FileDispositionInformation:
            RxDbgTrace(0, Dbg, ("FileDispositionInformation\n"));
            break;
    
        case FilePositionInformation:
            RxDbgTrace(0, Dbg, ("FilePositionInformation\n"));
            break;
    
        case FileAllocationInformation:
            RxDbgTrace(0, Dbg, ("FileAllocationInformation\n"));
            RxDbgTrace(0, Dbg, ("AllocSize is %d AllocSizeHigh is %d\n",
            pEndOfFileInfo->EndOfFile.LowPart,pEndOfFileInfo->EndOfFile.HighPart));
            break;
    
        case FileEndOfFileInformation:
            RxDbgTrace(0, Dbg, ("FileSize is %d FileSizeHigh is %d\n",
            capFcb->Header.AllocationSize.LowPart,capFcb->Header.AllocationSize.HighPart));

            if( pEndOfFileInfo->EndOfFile.QuadPart > 
                    capFcb->Header.AllocationSize.QuadPart ) {
            
                Status = NulMRxExtendFile(
                                RxContext,
                                &pEndOfFileInfo->EndOfFile,
                                &NewAllocationSize
                                );

                RxDbgTrace(0, Dbg, ("AllocSize is %d AllocSizeHigh is %d\n",
                            NewAllocationSize.LowPart,NewAllocationSize.HighPart));

                //
                //  Change the file allocation
                //
                capFcb->Header.AllocationSize.QuadPart = NewAllocationSize.QuadPart;
            } else {
                Status = NulMRxTruncateFile(
                                RxContext,
                                &pEndOfFileInfo->EndOfFile,
                                &NewAllocationSize
                                );
            }

            RxContext->Info.LengthRemaining -= sizeof(FILE_END_OF_FILE_INFORMATION);
            break;
    
        case FileRenameInformation:
            RxDbgTrace(0, Dbg, ("FileRenameInformation\n"));
            break;
    
        default:
            break;
    }
    
    RxTraceLeave(Status);
    return Status;
}

NTSTATUS
NulMRxSetFileInformationAtCleanup(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine sets the file information on cleanup. the old rdr just swallows this operation (i.e.
   it doesn't generate it). we are doing the same..........

Arguments:

    pRxContext           - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\locks.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    locks.c

Abstract:

    This module implements the mini redirector call down routines pertaining to locks
    of file system objects.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOCKS)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NulMRxLocks)
#pragma alloc_text(PAGE, NulMRxCompleteBufferingStateChangeRequest)
#pragma alloc_text(PAGE, NulMRxFlush)
#endif

NTSTATUS
NulMRxLocks(
    IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine handles network requests for filelocks

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    //DbgPrint("NulMRxLocks \n");
    return(Status);
}

NTSTATUS
NulMRxCompleteBufferingStateChangeRequest(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRX_SRV_OPEN   SrvOpen,
    IN     PVOID       pContext
    )
/*++

Routine Description:

    This routine is called to assert the locks that the wrapper has buffered. currently, it is synchronous!


Arguments:

    RxContext - the open instance
    SrvOpen   - tells which fcb is to be used.
    LockEnumerator - the routine to call to get the locks

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    DbgPrint("NulMRxCompleteBufferingStateChangeRequest \n");
    return(Status);
}

NTSTATUS
NulMRxFlush(
      IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine handles network requests for file flush

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    DbgPrint("NulMRxFlush \n");
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\netroot.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    netroot.c

Abstract:

    This module implements the routines for creating the net root.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

RXDT_DefineCategory(NETROOT);
#define Dbg                 (DEBUG_TRACE_NETROOT)

//
// Forward declarations ...
//

NTSTATUS
NullMiniInitializeNetRootEntry(
    IN PMRX_NET_ROOT pNetRoot
    );

NTSTATUS
NulMRxUpdateNetRootState(
    IN OUT PMRX_NET_ROOT pNetRoot)
/*++

Routine Description:

   This routine updates the mini redirector state associated with a net root.

Arguments:

    pNetRoot - the net root instance.

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    By diffrentiating the mini redirector state from the net root condition it is possible
    to permit a variety of reconnect strategies. It is conceivable that the RDBSS considers
    a net root to be good while the underlying mini redirector might mark it as invalid
    and reconnect on the fly.

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    RxDbgTrace(0, Dbg, ("NulMRxUpdateNetRootState \n"));
    return(Status);
}

NTSTATUS
NulMRxInitializeNetRootEntry(
    IN PMRX_NET_ROOT pNetRoot
    )
/*++

Routine Description:

    This routine initializes a new net root.
    It also validates rootnames. Eg: attempts to create a
    file in a root that has not been created will fail.

Arguments:

    pNetRoot - the net root
    
Return Value:

    NTSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS  Status = STATUS_SUCCESS;
    PMRX_SRV_CALL pSrvCall = pNetRoot->pSrvCall;
    UNICODE_STRING RootName;
    PNULMRX_NETROOT_EXTENSION pNetRootExtension = 
        (PNULMRX_NETROOT_EXTENSION)pNetRoot->Context;

    //
    //  A valid new NetRoot is being created
    //
    RxResetNetRootExtension(pNetRootExtension);
    return Status;
}

NTSTATUS
NulMRxCreateVNetRoot(
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    )
/*++

Routine Description:

   This routine patches the RDBSS created net root instance with the information required
   by the mini redirector.

Arguments:

    pVNetRoot - the virtual net root instance.

    pCreateNetRootContext - the net root context for calling back

Return Value:

    NTSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS        Status;
    PRX_CONTEXT     pRxContext = pCreateNetRootContext->RxContext;
    PMRX_V_NET_ROOT pVNetRoot = (PMRX_V_NET_ROOT)pCreateNetRootContext->pVNetRoot;
    
    PMRX_SRV_CALL   pSrvCall;
    PMRX_NET_ROOT   pNetRoot;

	BOOLEAN Verifyer = FALSE;
    BOOLEAN  fTreeConnectOpen = TRUE; // RxContext->Create.ThisIsATreeConnectOpen;
    BOOLEAN  fInitializeNetRoot;

    RxDbgTrace(0, Dbg, ("NulMRxCreateVNetRoot\n"));
   
    pNetRoot = pVNetRoot->pNetRoot;
    pSrvCall = pNetRoot->pSrvCall;

    // The V_NET_ROOT is associated with a NET_ROOT. The two cases of interest are as
    // follows
    // 1) the V_NET_ROOT and the associated NET_ROOT are being newly created.   
    // 2) a new V_NET_ROOT associated with an existing NET_ROOT is being created.
    //
    // These two cases can be distinguished by checking if the context associated with
    // NET_ROOT is NULL. Since the construction of NET_ROOT's/V_NET_ROOT's are serialized
    // by the wrapper this is a safe check.
    // ( The wrapper cannot have more then one thread tryingto initialize the same
    // NET_ROOT).
    //
    // The above is not really true in our case. Since we have asked the wrapper,
    // to manage our netroot extension, the netroot context will always be non-NULL.
    // We will distinguish the cases by checking our root state in the context...
    //

    if(pNetRoot->Context == NULL) {
        fInitializeNetRoot = TRUE;
    } else {
        {NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);
         fInitializeNetRoot = TRUE;
        }
    }

    ASSERT((NodeType(pNetRoot) == RDBSS_NTC_NETROOT) &&
        (NodeType(pNetRoot->pSrvCall) == RDBSS_NTC_SRVCALL));

    Status = STATUS_SUCCESS;

    // update the net root state to be good.

    if (fInitializeNetRoot) {
		PWCHAR		pRootName;
		ULONG		RootNameLength;

		pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_GOOD;

		// validate the fixed netroot name

		RootNameLength = pNetRoot->pNetRootName->Length - pSrvCall->pSrvCallName->Length;

		if ( RootNameLength >= 12 )
		{
			pRootName = (PWCHAR) (pNetRoot->pNetRootName->Buffer +
			                      (pSrvCall->pSrvCallName->Length / sizeof(WCHAR)));
		
			Verifyer  = ( pRootName[0] == L'\\' );
			Verifyer &= ( pRootName[1] == L'S' )  || ( pRootName[1] == L's' );
			Verifyer &= ( pRootName[2] == L'H' )  || ( pRootName[2] == L'h' );
			Verifyer &= ( pRootName[3] == L'A' )  || ( pRootName[3] == L'a' );
			Verifyer &= ( pRootName[4] == L'R' )  || ( pRootName[4] == L'r' );
			Verifyer &= ( pRootName[5] == L'E' )  || ( pRootName[5] == L'e' );
			Verifyer &= ( pRootName[6] == L'\\' ) || ( pRootName[6] == L'\0' );
		}
		if ( !Verifyer )
		{
			Status = STATUS_BAD_NETWORK_NAME;
		}

    } else {
        DbgPrint("Creating V_NET_ROOT on existing NET_ROOT\n");
    }

    if( (Status == STATUS_SUCCESS) && fInitializeNetRoot )
    {  
        //
        //  A new NET_ROOT and associated V_NET_ROOT are being created !
        //
        Status = NulMRxInitializeNetRootEntry(pNetRoot);
        RxDbgTrace(0, Dbg, ("NulMRXInitializeNetRootEntry %lx\n",Status));
    }

    if (Status != STATUS_PENDING) {
        pCreateNetRootContext->VirtualNetRootStatus = Status;
        if (fInitializeNetRoot) {
            pCreateNetRootContext->NetRootStatus = Status;
        } else {
            pCreateNetRootContext->NetRootStatus = Status;
        }

        // Callback the RDBSS for resumption.
        pCreateNetRootContext->Callback(pCreateNetRootContext);

        // Map the error code to STATUS_PENDING since this triggers 
        // the synchronization mechanism in the RDBSS.
        Status = STATUS_PENDING;
   }

   return Status;
}

NTSTATUS
NulMRxFinalizeVNetRoot(
    IN PMRX_V_NET_ROOT pVNetRoot,
    IN PBOOLEAN        ForceDisconnect)
/*++

Routine Description:


Arguments:

    pVNetRoot - the virtual net root

    ForceDisconnect - disconnect is forced

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
   RxDbgTrace(0, Dbg, ("NulMRxFinalizeVNetRoot %lx\n",pVNetRoot));
   return STATUS_SUCCESS;
}


NTSTATUS
NulMRxFinalizeNetRoot(
    IN PMRX_NET_ROOT   pNetRoot,
    IN PBOOLEAN        ForceDisconnect)
/*++

Routine Description:


Arguments:

    pVirtualNetRoot - the virtual net root

    ForceDisconnect - disconnect is forced

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);

    RxDbgTrace(0, Dbg, ("NulMRxFinalizeNetRoot \n"));

    //
    //  This is called when all outstanding handles on this
    //  root have been cleaned up ! We can now zap the netroot
    //  extension...
    //

    return(Status);
}

VOID
NulMRxExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    )
/*++

Routine Description:

    This routine parses the input name into srv, netroot, and the
    rest.

Arguments:


--*/
{
    UNICODE_STRING xRestOfName;

    ULONG length = FilePathName->Length;
    PWCH w = FilePathName->Buffer;
    PWCH wlimit = (PWCH)(((PCHAR)w)+length);
    PWCH wlow;

    RxDbgTrace(0, Dbg, ("NulMRxExtractNetRootName \n"));
    
    w += (SrvCall->pSrvCallName->Length/sizeof(WCHAR));
    NetRootName->Buffer = wlow = w;
    for (;;) {
        if (w>=wlimit) break;
        if ( (*w == OBJ_NAME_PATH_SEPARATOR) && (w!=wlow) ){
            break;
        }
        w++;
    }
    
    NetRootName->Length = NetRootName->MaximumLength
                = (USHORT)((PCHAR)w - (PCHAR)wlow);
                
    //w = FilePathName->Buffer;
    //NetRootName->Buffer = w++;

    if (!RestOfName) RestOfName = &xRestOfName;
    RestOfName->Buffer = w;
    RestOfName->Length = (USHORT)RestOfName->MaximumLength
                       = (USHORT)((PCHAR)wlimit - (PCHAR)w);

    RxDbgTrace(0, Dbg, ("  NulMRxExtractNetRootName FilePath=%wZ\n",FilePathName));
    RxDbgTrace(0, Dbg, ("         Srv=%wZ,Root=%wZ,Rest=%wZ\n",
                        SrvCall->pSrvCallName,NetRootName,RestOfName));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\mrxprocs.h ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    mrxprocs.h

Abstract:

    The module contains the prototype definitions for all cross referenced
    routines.

--*/

#ifndef _MRXPROCS_H_
#define _MRXPROCS_H_

//cross-referenced internal routines

//from rename.c
NulMRxRename(
      IN PRX_CONTEXT            RxContext,
      IN FILE_INFORMATION_CLASS FileInformationClass,
      IN PVOID                  pBuffer,
      IN ULONG                  BufferLength);

// from usrcnnct.c
extern NTSTATUS
NulMRxDeleteConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

NTSTATUS
NulMRxCreateConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

NTSTATUS
NulMRxDoConnection(
    IN PRX_CONTEXT RxContext,
    ULONG   CreateDisposition
    );

#endif   // _MRXPROCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\minip.h ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    minip.h

Abstract:

    Macros and definitions private to the null mini driver.

Notes:

    This module has been built and tested only in UNICODE environment

--*/

#ifndef _NULLMINIP_H_
#define _NULLMINIP_H_

NTHALAPI
VOID
KeStallExecutionProcessor (
    IN ULONG MicroSeconds
    );

#ifndef min
#define min(a, b)       ((a) > (b) ? (b) : (a))
#endif

#if DBG

#ifdef SUPPRESS_WRAPPER_TRACE
#define RxTraceEnter(func)                                                  \
        PCHAR __pszFunction = func;                                         \
        BOOLEAN fEnable = FALSE;                                            \
        if( RxNextGlobalTraceSuppress ) {                                   \
            RxNextGlobalTraceSuppress = RxGlobalTraceSuppress = FALSE;      \
            fEnable = TRUE;                                                 \
        }                                                                   \
        RxDbgTrace(0,Dbg,("Entering %s\n",__pszFunction));

#define RxTraceLeave(status)                                                \
        if( fEnable ) {                                                     \
            RxNextGlobalTraceSuppress = RxGlobalTraceSuppress = TRUE;       \
        }                                                                   \
        RxDbgTrace(0,Dbg,("Leaving %s Status -> %08lx\n",__pszFunction,status));
#else
#define RxTraceEnter(func)                                                  \
        PCHAR __pszFunction = func;                                         \
        RxDbgTrace(0,Dbg,("Entering %s\n",__pszFunction));

#define RxTraceLeave(status)                                                \
        RxDbgTrace(0,Dbg,("Leaving %s Status -> %08lx\n",__pszFunction,status));
#endif

#else

#define RxTraceEnter(func)
#define RxTraceLeave(status)

#endif

#define RX_VERIFY( f )  if( (f) ) ; else ASSERT( 1==0 )

//
//  Set or Validate equal
//
#define SetOrValidate(x,y,f)                                \
        if( f ) (x) = (y); else ASSERT( (x) == (y) )
        
//
//  RXCONTEXT data - mini-rdr context stored for async completions
//  NOTE: sizeof this struct should be == MRX_CONTEXT_SIZE !!
//

typedef struct _NULMRX_COMPLETION_CONTEXT {
    //
    //  IoStatus.Information
    //
    ULONG       Information;

    //
    //  IoStatus.Status
    //
    NTSTATUS    Status;
    
    //
    //  Outstanding I/Os
    //
    ULONG       OutstandingIOs;

    //
    //  I/O type
    //
    ULONG       IoType;

} NULMRX_COMPLETION_CONTEXT, *PNULMRX_COMPLETION_CONTEXT;

#define IO_TYPE_SYNCHRONOUS     0x00000001
#define IO_TYPE_ASYNC           0x00000010

#define NulMRxGetMinirdrContext(pRxContext)     \
        ((PNULMRX_COMPLETION_CONTEXT)(&(pRxContext)->MRxContext[0]))

#endif // _NULLMINIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\notimpl.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    notimpl.c

Abstract:

    This module includes prototypes of the functionality that has not been
    implemented in the null mini rdr.

--*/

#include "precomp.h"
#pragma hdrstop

//
// File System Control funcitonality
//


NTSTATUS
NulMRxFsCtl(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs an FSCTL operation (remote) on a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation


--*/
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    DbgPrint("NulMRxFsCtl -> %08lx\n", Status);
    return Status;
}




NTSTATUS
NulMRxNotifyChangeDirectoryCancellation(
   PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine is invoked when a directory change notification operation is cancelled.
   This example doesn't support it.


Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{

   UNREFERENCED_PARAMETER(RxContext);

   return STATUS_SUCCESS;
}



NTSTATUS
NulMRxNotifyChangeDirectory(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs a directory change notification operation.
   This example doesn't support it.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation [not implemented]

--*/
{

   UNREFERENCED_PARAMETER(RxContext);

   return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
NulMRxQuerySecurityInformation (
    IN OUT PRX_CONTEXT RxContext
    )
{
   return STATUS_NOT_IMPLEMENTED;
}



NTSTATUS
NulMRxSetSecurityInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    )
{
   return STATUS_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\precomp.h ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation


--*/



#define MINIRDR__NAME NulMRx
#define ___MINIRDR_IMPORTS_NAME (NulMRxDeviceObject->RdbssExports)

#include <ntifs.h>

#include "rx.h"

#include "nodetype.h"
#include "netevent.h"

#include <windef.h>

#include "nulmrx.h"
#include "minip.h"
#include <lmcons.h>     // from the Win32 SDK
#include "mrxglobs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\openclos.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    openclos.c

Abstract:

    This module implements the mini redirector call down routines pertaining to opening/
    closing of file/directories.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

//
//  forwards & pragmas
//

NTSTATUS
NulMRxProcessCreate( 
                IN PNULMRX_FCB_EXTENSION pFcbExtension,
                IN PVOID EaBuffer,
                IN ULONG EaLength,
                OUT PLONGLONG pEndOfFile,
                OUT PLONGLONG pAllocationSize
                );

NTSTATUS
NulMRxCreateFileSuccessTail (
    PRX_CONTEXT     RxContext,
    PBOOLEAN        MustRegainExclusiveResource,
    RX_FILE_TYPE    StorageType,
    ULONG           CreateAction,
    FILE_BASIC_INFORMATION*     pFileBasicInfo,
    FILE_STANDARD_INFORMATION*  pFileStandardInfo
    );

VOID
NulMRxSetSrvOpenFlags (
    PRX_CONTEXT     RxContext,
    RX_FILE_TYPE    StorageType,
    PMRX_SRV_OPEN   SrvOpen
    );
  
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NulMRxCreate)
#pragma alloc_text(PAGE, NulMRxShouldTryToCollapseThisOpen)
#pragma alloc_text(PAGE, NulMRxProcessCreate)
#pragma alloc_text(PAGE, NulMRxCreateFileSuccessTail)
#pragma alloc_text(PAGE, NulMRxSetSrvOpenFlags)
#endif

NTSTATUS
NulMRxShouldTryToCollapseThisOpen (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine determines if the mini knows of a good reason not
   to try collapsing on this open. Presently, the only reason would
   be if this were a copychunk open.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation
        SUCCESS --> okay to try collapse
        other (MORE_PROCESSING_REQUIRED) --> dont collapse

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;

    PAGED_CODE();

    return Status;
}

NTSTATUS
NulMRxCreate(
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine opens a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN fMustRegainExclusiveResource = FALSE;
    RX_FILE_TYPE StorageType = FileTypeFile;
    ULONG CreateAction = FILE_CREATED;
    LARGE_INTEGER liSystemTime;
    LONGLONG EndOfFile = 0, AllocationSize = 0;
    FILE_BASIC_INFORMATION FileBasicInfo;
    FILE_STANDARD_INFORMATION FileStandardInfo;
    RxCaptureFcb;
    NulMRxGetFcbExtension(capFcb,pFcbExtension);
    RX_BLOCK_CONDITION FinalSrvOpenCondition;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SRV_CALL SrvCall = RxContext->Create.pSrvCall;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PUNICODE_STRING RemainingName = SrvOpen->pAlreadyPrefixedName;
    PVOID EaBuffer = RxContext->Create.EaBuffer;
    ULONG EaLength = RxContext->Create.EaLength;
    ACCESS_MASK DesiredAccess = RxContext->Create.NtCreateParameters.DesiredAccess;
    NulMRxGetNetRootExtension(NetRoot,pNetRootExtension);

    RxTraceEnter("NulMRxCreate");
    PAGED_CODE();
    
    RxDbgTrace(0, Dbg, ("     Attempt to open %wZ Len is %d\n", RemainingName, RemainingName->Length ));
    
    if( NetRoot->Type == NET_ROOT_DISK && NT_SUCCESS(Status) ) {
        RxDbgTrace(0, Dbg, ("NulMRxCreate: Type supported \n"));
            //
            //  Squirrel away the scatter list in the FCB extension.
            //  This is done only for data files.
            //
            Status = NulMRxProcessCreate( 
                                        pFcbExtension,
                                        EaBuffer,
                                        EaLength,
                                        &EndOfFile,
                                        &AllocationSize
                                        );
            if( Status != STATUS_SUCCESS ) {
                //
                //  error..
                //
                RxDbgTrace(0, Dbg, ("Failed to initialize scatter list\n"));
                goto Exit;
            }

        //
        //  Complete CreateFile contract
        //
        RxDbgTrace(0,Dbg,("EOF is %d AllocSize is %d\n",(ULONG)EndOfFile,(ULONG)AllocationSize));
        FileBasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;
        KeQuerySystemTime(&liSystemTime);
        FileBasicInfo.CreationTime = liSystemTime;
        FileBasicInfo.LastAccessTime = liSystemTime;
        FileBasicInfo.LastWriteTime = liSystemTime;
        FileBasicInfo.ChangeTime = liSystemTime;
        FileStandardInfo.AllocationSize.QuadPart = AllocationSize;
        FileStandardInfo.EndOfFile.QuadPart = EndOfFile;
        FileStandardInfo.NumberOfLinks = 0;

        Status = NulMRxCreateFileSuccessTail (    
                                    RxContext,
                                    &fMustRegainExclusiveResource,
                                    StorageType,
                                    CreateAction,
                                    &FileBasicInfo,
                                    &FileStandardInfo
                                    );

        if( Status != STATUS_SUCCESS ) {
            //
            //  alloc error..
            //
            RxDbgTrace(0, Dbg, ("Failed to allocate Fobx \n"));
            goto Exit;
        }
                                    
        if (!RxIsFcbAcquiredExclusive(capFcb)) {
           ASSERT(!RxIsFcbAcquiredShared(capFcb));
           RxAcquireExclusiveFcb( RxContext, capFcb );
        }

    } else {
        RxDbgTrace(0, Dbg, ("NulMRxCreate: Type not supported or invalid open\n"));
        Status = STATUS_NOT_IMPLEMENTED;
    }

    ASSERT(Status != (STATUS_PENDING));
    ASSERT(RxIsFcbAcquiredExclusive( capFcb ));

    RxDbgTrace(0, Dbg, ("NetRoot is 0x%x Fcb is 0x%x SrvOpen is 0x%x Fobx is 0x%x\n", 
                    NetRoot,capFcb, SrvOpen,RxContext->pFobx));
    RxDbgTrace(0, Dbg, ("NulMRxCreate exit with status=%08lx\n", Status ));

Exit:

    RxTraceLeave(Status);
    return(Status);
}

NTSTATUS
NulMRxProcessCreate( 
                IN PNULMRX_FCB_EXTENSION pFcbExtension,
                IN PVOID EaBuffer,
                IN ULONG EaLength,
                OUT PLONGLONG pEndOfFile,
                OUT PLONGLONG pAllocationSize
                )
/*++

Routine Description:

    This routine processes a create calldown.
    
Arguments:

    pFcbExtension   -   ptr to the FCB extension
    EaBuffer        -   ptr to the EA param buffer
    EaLength        -   len of EaBuffer
    pEndOfFile      -   return end of file value
    pAllocationSize -   return allocation size (which maybe > EOF)

Notes:

    It is possible to create a file with no EAs
    
Return Value:

    None

--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    RxDbgTrace(0, Dbg, ("NulMRxInitializeFcbExtension\n"));

    *pAllocationSize = *pEndOfFile = 0;
    return Status;
}

VOID
NulMRxSetSrvOpenFlags (
    PRX_CONTEXT  RxContext,
    RX_FILE_TYPE StorageType,
    PMRX_SRV_OPEN SrvOpen
    )
{
    PMRX_SRV_CALL SrvCall = (PMRX_SRV_CALL)RxContext->Create.pSrvCall;

    //
    //  set this only if cache manager will be used for mini-rdr handles !
    //
    SrvOpen->BufferingFlags |= (FCB_STATE_WRITECACHEING_ENABLED  |
                                FCB_STATE_FILESIZECACHEING_ENABLED |
                                FCB_STATE_FILETIMECACHEING_ENABLED |
                                FCB_STATE_WRITEBUFFERING_ENABLED |
                                FCB_STATE_LOCK_BUFFERING_ENABLED |
                                FCB_STATE_READBUFFERING_ENABLED  |
                                FCB_STATE_READCACHEING_ENABLED);
}

NTSTATUS
NulMRxCreateFileSuccessTail (
    PRX_CONTEXT  RxContext,
    PBOOLEAN MustRegainExclusiveResource,
    RX_FILE_TYPE StorageType,
    ULONG CreateAction,
    FILE_BASIC_INFORMATION* pFileBasicInfo,
    FILE_STANDARD_INFORMATION* pFileStandardInfo
    )
/*++

Routine Description:

    This routine finishes the initialization of the fcb and srvopen for a 
successful open.

Arguments:


Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;

    FCB_INIT_PACKET InitPacket;

    RxDbgTrace(0, Dbg, ("MRxExCreateFileSuccessTail\n"));
    PAGED_CODE();

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );

    if (*MustRegainExclusiveResource) {        //this is required because of oplock breaks
        RxAcquireExclusiveFcb( RxContext, capFcb );
        *MustRegainExclusiveResource = FALSE;
    }

    // This Fobx should be cleaned up by the wrapper
    RxContext->pFobx = RxCreateNetFobx( RxContext, SrvOpen);
    if( RxContext->pFobx == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    ASSERT  ( RxIsFcbAcquiredExclusive ( capFcb )  );
    RxDbgTrace(0, Dbg, ("Storagetype %08lx/Action %08lx\n", StorageType, CreateAction ));

    RxContext->Create.ReturnedCreateInformation = CreateAction;

    RxFormInitPacket(
        InitPacket,
        &pFileBasicInfo->FileAttributes,
        &pFileStandardInfo->NumberOfLinks,
        &pFileBasicInfo->CreationTime,
        &pFileBasicInfo->LastAccessTime,
        &pFileBasicInfo->LastWriteTime,
        &pFileBasicInfo->ChangeTime,
        &pFileStandardInfo->AllocationSize,
        &pFileStandardInfo->EndOfFile,
        &pFileStandardInfo->EndOfFile);

    if (capFcb->OpenCount == 0) {
        RxFinishFcbInitialization( capFcb,
                                   RDBSS_STORAGE_NTC(StorageType),
                                   &InitPacket
                                 );
    } else {

        ASSERT( StorageType == 0 || NodeType(capFcb) ==  RDBSS_STORAGE_NTC(StorageType));

    }

    NulMRxSetSrvOpenFlags(RxContext,StorageType,SrvOpen);

    RxContext->pFobx->OffsetOfNextEaToReturn = 1;
    //transition happens later

    return Status;
}

NTSTATUS
NulMRxCollapseOpen(
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine collapses a open locally

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureRequestPacket;

    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SRV_CALL SrvCall = RxContext->Create.pSrvCall;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;

    RxTraceEnter("NulMRxCollapseOpen");
    RxContext->pFobx = (PMRX_FOBX)RxCreateNetFobx( RxContext, SrvOpen);

    if (RxContext->pFobx != NULL) {
       ASSERT  ( RxIsFcbAcquiredExclusive ( capFcb )  );
       RxContext->pFobx->OffsetOfNextEaToReturn = 1;
       capReqPacket->IoStatus.Information = FILE_OPENED;
       Status = STATUS_SUCCESS;
    } else {
       Status = (STATUS_INSUFFICIENT_RESOURCES);
       DbgBreakPoint();
    }

    RxTraceLeave(Status);
    return Status;
}

NTSTATUS
NulMRxComputeNewBufferingState(
   IN OUT PMRX_SRV_OPEN   pMRxSrvOpen,
   IN     PVOID           pMRxContext,
      OUT PULONG          pNewBufferingState)
/*++

Routine Description:

   This routine maps specific oplock levels into the appropriate RDBSS
   buffering state flags

Arguments:

   pMRxSrvOpen - the MRX SRV_OPEN extension

   pMRxContext - the context passed to RDBSS at Oplock indication time

   pNewBufferingState - the place holder for the new buffering state

Return Value:


Notes:

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    DbgPrint("NulMRxComputeNewBufferingState \n");
    return(Status);
}

NTSTATUS
NulMRxDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NulMRxGetFcbExtension(pFcb,pFcbExtension);
    PMRX_NET_ROOT         pNetRoot = pFcb->pNetRoot;
    NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);

    RxTraceEnter("NulMRxDeallocateForFcb\n");

    RxTraceLeave(Status);
    return(Status);
}

NTSTATUS
NulMRxTruncate(
      IN PRX_CONTEXT pRxContext)
/*++

Routine Description:

   This routine truncates the contents of a file system object

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   ASSERT(!"Found a truncate");
   return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
NulMRxCleanupFobx(
      IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine cleansup a file system object...normally a noop. unless it's a pipe in which case
   we do the close at cleanup time and mark the file as being not open.

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING RemainingName;
    RxCaptureFcb; RxCaptureFobx;

    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;

    BOOLEAN SearchHandleOpen = FALSE;

    PAGED_CODE();

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT ( NodeTypeIsFcb(capFcb) );

    RxDbgTrace( 0, Dbg, ("NulMRxCleanupFobx\n"));

    if (FlagOn(capFcb->FcbState,FCB_STATE_ORPHANED)) {
       RxDbgTrace( 0, Dbg, ("File orphaned\n"));
       return (STATUS_SUCCESS);
    }

    if ((capFcb->pNetRoot->Type != NET_ROOT_PIPE) && !SearchHandleOpen) {
       RxDbgTrace( 0, Dbg, ("File not for closing at cleanup\n"));
       return (STATUS_SUCCESS);
    }

    RxDbgTrace( 0, Dbg, ("NulMRxCleanup  exit with status=%08lx\n", Status ));

    return(Status);
}

NTSTATUS
NulMRxForcedClose(
      IN PMRX_SRV_OPEN pSrvOpen)
/*++

Routine Description:

   This routine closes a file system object

Arguments:

    pSrvOpen - the instance to be closed

Return Value:

    RXSTATUS - The return status for the operation

Notes:



--*/
{
    RxDbgTrace( 0, Dbg, ("NulMRxForcedClose\n"));
    return STATUS_SUCCESS;
}

//
//  The local debug trace level
//

#undef  Dbg
#define Dbg                              (DEBUG_TRACE_CLOSE)

NTSTATUS
NulMRxCloseSrvOpen(
      IN     PRX_CONTEXT   RxContext
      )
/*++

Routine Description:

   This routine closes a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN   pSrvOpen = capFobx->pSrvOpen;
    PUNICODE_STRING RemainingName = pSrvOpen->pAlreadyPrefixedName;
    PMRX_SRV_OPEN   SrvOpen;
    NODE_TYPE_CODE  TypeOfOpen = NodeType(capFcb);
    PMRX_NET_ROOT   pNetRoot = capFcb->pNetRoot;
    NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);

    RxDbgTrace( 0, Dbg, ("NulMRxCloseSrvOpen \n"));
    SrvOpen    = capFobx->pSrvOpen;

    return(Status);
}

NTSTATUS
NulMRxDeallocateForFobx (
    IN OUT PMRX_FOBX pFobx
    )
{
    RxDbgTrace( 0, Dbg, ("NulMRxDeallocateForFobx\n"));
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\nulmrx.h ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    nulmrx.h

Abstract:

    This header exports all symbols and definitions shared between
    user-mode clients of nulmrx and the driver itself.

Notes:

    This module has been built and tested only in UNICODE environment

--*/

#ifndef _NULMRX_H_
#define _NULMRX_H_

// Device name for this driver
#define NULMRX_DEVICE_NAME_A "NullMiniRdr"
#define NULMRX_DEVICE_NAME_U L"NullMiniRdr"

// Provider name for this driver
#define NULMRX_PROVIDER_NAME_A "Sample Network"
#define NULMRX_PROVIDER_NAME_U L"Sample Network"

// The following constant defines the length of the above name.
#define NULMRX_DEVICE_NAME_A_LENGTH (15)

// The following constant defines the path in the ob namespace
#define DD_NULMRX_FS_DEVICE_NAME_U L"\\Device\\NullMiniRdr"

#ifndef NULMRX_DEVICE_NAME
#define NULMRX_DEVICE_NAME

//
//  The Devicename string required to access the nullmini device 
//  from User-Mode. Clients should use DD_NULMRX_USERMODE_DEV_NAME_U.
//
//  WARNING The next two strings must be kept in sync. Change one and you must 
//  change the other. These strings have been chosen such that they are 
//  unlikely to coincide with names of other drivers.
//
#define DD_NULMRX_USERMODE_SHADOW_DEV_NAME_U     L"\\??\\NullMiniRdrDN"
#define DD_NULMRX_USERMODE_DEV_NAME_U            L"\\\\.\\NullMiniRdrDN"

//
//  Prefix needed for disk filesystems
//
#define DD_NULMRX_MINIRDR_PREFIX                 L"\\;E:"

#endif // NULMRX_DEVICE_NAME

//
// BEGIN WARNING WARNING WARNING WARNING
//  The following are from the ddk include files and cannot be changed

#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014 // from ddk\inc\ntddk.h
#define METHOD_BUFFERED 0
#define FILE_ANY_ACCESS 0

// END WARNING WARNING WARNING WARNING

#define IOCTL_NULMRX_BASE FILE_DEVICE_NETWORK_FILE_SYSTEM

#define _NULMRX_CONTROL_CODE(request, method, access) \
                CTL_CODE(IOCTL_NULMRX_BASE, request, method, access)

//
//  IOCTL codes supported by NullMini Device.
//

#define IOCTL_CODE_ADDCONN          100
#define IOCTL_CODE_GETCONN          101
#define IOCTL_CODE_DELCONN          102
#define IOCTL_CODE_GETLIST			103

//
//  Following is the IOCTL definition and associated structs.
//  for IOCTL_CODE_SAMPLE1
//
#define IOCTL_NULMRX_ADDCONN     _NULMRX_CONTROL_CODE(IOCTL_CODE_ADDCONN, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NULMRX_GETCONN     _NULMRX_CONTROL_CODE(IOCTL_CODE_GETCONN, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NULMRX_DELCONN     _NULMRX_CONTROL_CODE(IOCTL_CODE_DELCONN, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NULMRX_GETLIST     _NULMRX_CONTROL_CODE(IOCTL_CODE_GETLIST, METHOD_BUFFERED, FILE_ANY_ACCESS)


#endif // _NULMRX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\read.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module implements the mini redirector call down routines pertaining to read
    of file system objects.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

NTSTATUS
NulMRxRead(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles network read requests.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    PVOID pbUserBuffer = NULL;
    ULONG ByteCount = (LowIoContext->ParamsFor).ReadWrite.ByteCount;
    RXVBO ByteOffset = (LowIoContext->ParamsFor).ReadWrite.ByteOffset;
    LONGLONG FileSize = 0;
    NulMRxGetFcbExtension(capFcb,pFcbExtension);
    PMRX_NET_ROOT pNetRoot = capFcb->pNetRoot;
    PNULMRX_NETROOT_EXTENSION pNetRootExtension = pNetRoot->Context;
    BOOLEAN SynchronousIo = !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);
    PNULMRX_COMPLETION_CONTEXT pIoCompContext = NulMRxGetMinirdrContext(RxContext);
    PDEVICE_OBJECT deviceObject;

    RxTraceEnter("NulMRxRead");
    RxDbgTrace(0, Dbg, ("NetRoot is 0x%x Fcb is 0x%x\n", pNetRoot, capFcb));

    RxGetFileSizeWithLock((PFCB)capFcb,&FileSize);

    //
    //  NB: This should be done by the wrapper ! It does this
    //  only if READCACHEING is enabled on the FCB !!
    //
    if (!FlagOn(capFcb->FcbState,FCB_STATE_READCACHEING_ENABLED)) {

        //
        // If the read starts beyond End of File, return EOF.
        //

        if (ByteOffset >= FileSize) {
            RxDbgTrace( 0, Dbg, ("End of File\n", 0 ));
            Status = STATUS_END_OF_FILE;
            goto Exit;
        }

        //
        //  If the read extends beyond EOF, truncate the read
        //

        if (ByteCount > FileSize - ByteOffset) {
            ByteCount = (ULONG)(FileSize - ByteOffset);
        }
    }
    
    RxDbgTrace(0, Dbg, ("UserBuffer is 0x%x\n", pbUserBuffer ));
    RxDbgTrace(0, Dbg, ("ByteCount is %x ByteOffset is %x\n", ByteCount, ByteOffset ));

    //
    //  Initialize the completion context in the RxContext
    //
    ASSERT( sizeof(*pIoCompContext) == MRX_CONTEXT_SIZE );
    RtlZeroMemory( pIoCompContext, sizeof(*pIoCompContext) );
    
    if( SynchronousIo ) {
        RxDbgTrace(0, Dbg, ("This I/O is sync\n"));
        pIoCompContext->IoType = IO_TYPE_SYNCHRONOUS;
    } else {
        RxDbgTrace(0, Dbg, ("This I/O is async\n"));
        pIoCompContext->IoType = IO_TYPE_ASYNC;
    }

    RxDbgTrace(0, Dbg, ("Status = %x Info = %x\n",RxContext->IoStatusBlock.Status,RxContext->IoStatusBlock.Information));

Exit:

    RxTraceLeave(Status);
    return(Status);
} // NulMRxRead
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\wmlkm.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wmlkm.h

Abstract:

    Kernel mode definitions for an easy wmi tracing.

Author:

    gorn

Revision History:

Comments:

    Needs to be moved to wmilib\inc when DCR is approved

--*/
#ifndef WMLKM_H
#define WMLKM_H 1

#pragma warning(disable: 4201) // error C4201: nonstandard extension used : nameless struct/union
#include <wmistr.h>
#include <evntrace.h>

#include "wmlmacro.h"
#ifdef __cplusplus
extern "C" {
#endif

#define MAX_TRACE_GUIDS_PER_CONTROL  3

typedef struct _WML_CONTROL_GUID_REG {
    GUID        Guid;
    GUID        TraceGuids[MAX_TRACE_GUIDS_PER_CONTROL];
    ULONG       EnableFlags;
    ULONG       EnableLevel;
    TRACEHANDLE LoggerHandle;
} WML_CONTROL_GUID_REG, *PWML_CONTROL_GUID_REG;

typedef struct _WML_TINY_INFO {
    PWML_CONTROL_GUID_REG    ControlGuids;
    ULONG                    GuidCount;
    PDEVICE_OBJECT           LowerDeviceObject;
    PUNICODE_STRING          DriverRegPath;
} WML_TINY_INFO, *PWML_TINY_INFO;


NTSTATUS
WmlTinySystemControl(
    IN OUT PWML_TINY_INFO WmiLibInfo,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    ... // Pairs: Address, Length
    );

ULONG
WmlPrintf(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN TRACEHANDLE LoggerHandle,
    IN PCHAR FormatString,
    ... // var args
    );



#ifdef __cplusplus
};
#endif

#endif // WMLKM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\sources.inc ===
!IF 0

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.



!ENDIF

!INCLUDE .\master.src

TARGETNAME=nulmrx
TARGETPATH=obj
TARGETTYPE=EXPORT_DRIVER

SYNCHRONIZE_DRAIN=1

INCLUDES=$(INCLUDES); \
    	 $(IFSKIT_INC_PATH);

# @@BEGIN_DDKSPLIT
!IF 0
# @@END_DDKSPLIT

TARGETLIBS=$(DDK_LIB_PATH)\ksecdd.lib	\
           $(DDK_LIB_PATH)\rdbsslib.lib


# @@BEGIN_DDKSPLIT
!ENDIF

RDR2=$(PROJECT_ROOT)\fs\rdr2

INCLUDES=$(INCLUDES); \
    	 $(RDR2)\inc;

TARGETLIBS=$(RDR2)\rdbss\monolithic\obj\*\rdbsslib.lib	\
           $(DDK_LIB_PATH)\ksecdd.lib

# @@END_DDKSPLIT

#NTLAYGO=1

MSC_WARNING_LEVEL=/W3 /WX
C_DEFINES= $(C_DEFINES) -DEXPLODE_POOLTAGS
!IF $(MONOLITHIC_MINIRDR)
C_DEFINES=$(C_DEFINES) -DMONOLITHIC_MINIRDR
!ENDIF

MOST_SOURCES=  \
    devfcb.c   \
    fileinfo.c \
    init.c     \
    locks.c    \
    netroot.c  \
    ea.c       \
    devctrl.c  \
    notimpl.c  \
    openclos.c \
    read.c     \
    rename.c   \
    srvcall.c  \
    write.c    \
    downlvli.c \
    wmlkm.c

PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

DLLDEF=$(_OBJ_DIR)\*\nulmrx.def



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\rename.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    rename.c

Abstract:

    This module implements rename in the null minirdr.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)


NulMRxRename(
      IN PRX_CONTEXT            RxContext,
      IN FILE_INFORMATION_CLASS FileInformationClass,
      IN PVOID                  pBuffer,
      IN ULONG                  BufferLength)
/*++

Routine Description:

   This routine does a rename. since the real NT-->NT path is not implemented at the server end,
   we implement just the downlevel path.

Arguments:

    RxContext - the RDBSS context
    FILE_INFO_CLASS - must be rename....shouldn't really pass this
    pBuffer - pointer to the new name
    bufferlength - and the size

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;
    UNREFERENCED_PARAMETER(RxContext);

    DbgPrint("NulMRxRename \n");
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\dll\dllmain.c ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    dllmain.c

Abstract:

    This module implements the initialization routines for network
    provider interface

Notes:

    This module has been builkt and tested only in UNICODE environment

--*/

#include <windows.h>


// NOTE:
//
// Function:    DllMain
//
// Return:  TRUE  => Success
//      FALSE => Failure

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
{
    BOOL    bStatus = TRUE;
    WORD    wVersionRequested;

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

    default:
        break;
    }

    return(bStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\write.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module implements the mini redirector call down routines pertaining
    to write of file system objects.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

NTSTATUS
NulMRxWrite (
      IN PRX_CONTEXT RxContext)

/*++

Routine Description:

   This routine opens a file across the network.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    PVOID pbUserBuffer = NULL;
    ULONG ByteCount = (LowIoContext->ParamsFor).ReadWrite.ByteCount;
    RXVBO ByteOffset = (LowIoContext->ParamsFor).ReadWrite.ByteOffset;
    LONGLONG FileSize = 0;
    NulMRxGetFcbExtension(capFcb,pFcbExtension);
    PMRX_NET_ROOT pNetRoot = capFcb->pNetRoot;
    NulMRxGetNetRootExtension(pNetRoot,pNetRootExtension);
    BOOLEAN SynchronousIo = !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);
    PNULMRX_COMPLETION_CONTEXT pIoCompContext = NulMRxGetMinirdrContext(RxContext);
    PDEVICE_OBJECT deviceObject;

    RxTraceEnter("NulMRxWrite");
    RxDbgTrace(0, Dbg, ("NetRoot is 0x%x Fcb is 0x%x\n", pNetRoot, capFcb));
    
    //
    //  Lengths that are not sector aligned will be rounded up to
    //  the next sector boundary. The rounded up length should be
    //  < AllocationSize.
    //
    RxGetFileSizeWithLock((PFCB)capFcb,&FileSize);
    
    RxDbgTrace(0, Dbg, ("UserBuffer is0x%x\n", pbUserBuffer ));
    RxDbgTrace(0, Dbg, ("ByteCount is %d ByteOffset is %d\n", ByteCount, ByteOffset ));

    //
    //  Initialize the completion context in the RxContext
    //
    ASSERT( sizeof(*pIoCompContext) == MRX_CONTEXT_SIZE );
    RtlZeroMemory( pIoCompContext, sizeof(*pIoCompContext) );
    
    if( SynchronousIo ) {
        RxDbgTrace(0, Dbg, ("This I/O is sync\n"));
        pIoCompContext->IoType = IO_TYPE_SYNCHRONOUS;
    } else {
        RxDbgTrace(0, Dbg, ("This I/O is async\n"));
        pIoCompContext->IoType = IO_TYPE_ASYNC;
    }
  
    RxDbgTrace(0, Dbg, ("Status = %x Info = %x\n",RxContext->IoStatusBlock.Status,RxContext->IoStatusBlock.Information));

    RxTraceLeave(Status);
    return(Status);
} // NulMRxWrite
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\transprt.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    transport.c

Abstract:

    This module implements all transport related functions in the SMB connection engine

--*/

#include "precomp.h"
#pragma hdrstop


NTSTATUS
NulMRxInitializeTransport()
/*++

Routine Description:

    This routine initializes the transport related data structures

Returns:

    STATUS_SUCCESS if the transport data structures was successfully initialized

Notes:

--*/
{
   return STATUS_SUCCESS;
}


NTSTATUS
NulMRxUninitializeTransport()
/*++

Routine Description:

    This routine uninitializes the transport related data structures

Notes:

--*/
{
   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\dll\smbmrxnp.h ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    ifsmrxnp.h

Abstract:

    This module includes all network provider router interface related
    definitions for the sample

Notes:

    This module has been built and tested only in UNICODE environment

--*/

#ifndef _IFSMRXNP_H_
#define _IFSMRXNP_H_

#define IFSMRXNP_DEBUG_CALL     0x1
#define IFSMRXNP_DEBUG_ERROR    0x2
#define IFSMRXNP_DEBUG_INFO     0x4

extern DWORD IfsMRxNpDebugLevel;

#define TRACE_CALL(Args)    \
            if (IfsMRxNpDebugLevel & IFSMRXNP_DEBUG_CALL) {    \
                DbgPrint##Args;                 \
            }

#define TRACE_ERROR(Args)    \
            if (IfsMRxNpDebugLevel & IFSMRXNP_DEBUG_ERROR) {    \
                DbgPrint##Args;                 \
            }

#define TRACE_INFO(Args)    \
            if (IfsMRxNpDebugLevel & IFSMRXNP_DEBUG_INFO) {    \
                DbgPrint##Args;                 \
            }

typedef struct _IFSMRXNP_ENUMERATION_HANDLE_ {
    INT  LastIndex;
} IFSMRXNP_ENUMERATION_HANDLE,
  *PIFSMRXNP_ENUMERATION_HANDLE;

extern BOOL InitializeSharedMemory();
extern VOID UninitializeSharedMemory();

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\dll\smbmrxnp.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    smbmrxnp.c

Abstract:

    This module implements the routines required for interaction with network
    provider router interface in NT

Notes:

    This module has been builkt and tested only in UNICODE environment

--*/


#include <windows.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>
#include <winnetwk.h>
#include <npapi.h>

#include <lmwksta.h>
#include <devioctl.h>
// include files from the smb inc directory

#include <smbmrx.h>

#ifndef UNICODE_STRING
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
#endif

#ifndef FILE_FULL_EA_INFORMATION
typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;
#endif

#define MAX_EA_NAME_LEN     sizeof("UserName\0")
#define MAX_CONNECT_INFO_SIZE \
                            3 * sizeof(FILE_FULL_EA_INFORMATION) + \
                            sizeof(SMBMRX_CONNECTINFO) + \
                            4 * MAX_PATH + \
                            3 * MAX_EA_NAME_LEN

typedef struct _SMBMRXNP_ENUMERATION_HANDLE_ {
    INT  LastIndex;
} SMBMRXNP_ENUMERATION_HANDLE,
  *PSMBMRXNP_ENUMERATION_HANDLE;

#ifdef DBG
#define DbgP(_x_) DbgPrint _x_
#else
#define DbgP(_x_)
#endif

ULONG _cdecl DbgPrint( LPTSTR Format, ... );

#define TRACE_TAG   L"SMBMRXNP:    "


// The debug level for this module



// the SMB mini redirector and provider name. The original constants
// are defined in smbmrx.h

UNICODE_STRING SmbMRxDeviceName = {
    sizeof(DD_SMBMRX_FS_DEVICE_NAME_U),
    sizeof(DD_SMBMRX_FS_DEVICE_NAME_U),
    DD_SMBMRX_FS_DEVICE_NAME_U
                                  };

UNICODE_STRING SmbMrxProviderName = {
    sizeof(SMBMRX_PROVIDER_NAME_U),
    sizeof(SMBMRX_PROVIDER_NAME_U),
    SMBMRX_PROVIDER_NAME_U
                                    };


DWORD
OpenSharedMemory(
    PHANDLE phMutex,
    PHANDLE phMemory,
    PVOID   *pMemory
)
/*++

Routine Description:

    This routine opens the shared memory for exclusive manipulation

Arguments:

    phMutex - the mutex handle

    phMemory - the memory handle

    pMemory - a ptr. to the shared memory which is set if successful

Return Value:

    WN_SUCCESS -- if successful

--*/
{
    DWORD   dwStatus;

    DbgP((TEXT("OpenSharedMemory\n")));

    *phMutex = 0;
    *phMemory = 0;
    *pMemory = NULL;

    *phMutex = OpenMutex(SYNCHRONIZE,
                         FALSE,
                         SMBMRXNP_MUTEX_NAME);

    if (*phMutex == NULL)
    {
        dwStatus = GetLastError();
        DbgP((TEXT("OpenSharedMemory:  OpenMutex failed\n")));
        goto OpenSharedMemoryAbort1;
    }

    DbgP((TEXT("OpenSharedMemory:  Calling WaitForSingleObject\n")));
    WaitForSingleObject(*phMutex, INFINITE);

    *phMemory = OpenFileMapping(FILE_MAP_WRITE,
                                FALSE,
                                SMBMRXNP_SHARED_MEMORY_NAME);

    if (*phMemory == NULL)
    {
        dwStatus = GetLastError();
        DbgP((TEXT("OpenSharedMemory:  OpenFileMapping failed\n")));
        goto OpenSharedMemoryAbort2;
    }

    *pMemory = MapViewOfFile(*phMemory, FILE_MAP_WRITE, 0, 0, 0);
    if (*pMemory == NULL)
    {
        dwStatus = GetLastError();
        DbgP((TEXT("OpenSharedMemory:  MapViewOfFile failed\n")));
        goto OpenSharedMemoryAbort3;
    }

    DbgP((TEXT("OpenSharedMemory: return ERROR_SUCCESS\n")));

    return ERROR_SUCCESS;

OpenSharedMemoryAbort3:
    CloseHandle(*phMemory);

OpenSharedMemoryAbort2:
    ReleaseMutex(*phMutex);
    CloseHandle(*phMutex);
    *phMutex = NULL;

OpenSharedMemoryAbort1:
    DbgP((TEXT("OpenSharedMemory: return dwStatus: %d\n"), dwStatus));

    return dwStatus;
}


VOID
CloseSharedMemory(
    PHANDLE  hMutex,
    PHANDLE  hMemory,
    PVOID   *pMemory )
/*++

Routine Description:

    This routine relinquishes control of the shared memory after exclusive
    manipulation

Arguments:

    hMutex - the mutex handle

    hMemory  - the memory handle

    pMemory - a ptr. to the shared memory which is set if successful

Return Value:

--*/
{
    DbgP((TEXT("CloseSharedMemory\n")));
    if (*pMemory)
    {
        UnmapViewOfFile(*pMemory);
        *pMemory = NULL;
    }
    if (*hMemory)
    {
        CloseHandle(*hMemory);
        *hMemory = 0;
    }
    if (*hMutex)
    {
        if (ReleaseMutex(*hMutex) == FALSE)
        {
            DbgP((TEXT("CloseSharedMemory: ReleaseMutex error: %d\n"), GetLastError()));
        }
        CloseHandle(*hMutex);
        *hMutex = 0;
    }
    DbgP((TEXT("CloseSharedMemory: Return\n")));
}


DWORD APIENTRY
NPGetCaps(
    DWORD nIndex )
/*++

Routine Description:

    This routine returns the capabilities of the SMB Mini redirector
    network provider implementation

Arguments:

    nIndex - category of capabilities desired

Return Value:

    the appropriate capabilities

--*/
{
    switch (nIndex)
    {
        case WNNC_SPEC_VERSION:
            return WNNC_SPEC_VERSION51;

        case WNNC_NET_TYPE:
            return WNNC_NET_RDR2_SAMPLE;

        case WNNC_DRIVER_VERSION:
#define WNNC_DRIVER(major,minor) (major*0x00010000 + minor)
            return WNNC_DRIVER(1, 0);


        case WNNC_CONNECTION:
            return WNNC_CON_GETCONNECTIONS | WNNC_CON_CANCELCONNECTION |
                   WNNC_CON_ADDCONNECTION | WNNC_CON_ADDCONNECTION3;

        case WNNC_ENUMERATION:
            return WNNC_ENUM_LOCAL;

        case WNNC_START:
        case WNNC_USER:
        case WNNC_DIALOG:
        case WNNC_ADMIN:
        default:
            return 0;
    }
}

DWORD APIENTRY
NPLogonNotify(
    PLUID   lpLogonId,
    LPCWSTR lpAuthentInfoType,
    LPVOID  lpAuthentInfo,
    LPCWSTR lpPreviousAuthentInfoType,
    LPVOID  lpPreviousAuthentInfo,
    LPWSTR  lpStationName,
    LPVOID  StationHandle,
    LPWSTR  *lpLogonScript)
/*++

Routine Description:

    This routine handles the logon notifications

Arguments:

    lpLogonId -- the associated LUID

    lpAuthenInfoType - the authentication information type

    lpAuthenInfo  - the authentication Information

    lpPreviousAuthentInfoType - the previous aunthentication information type

    lpPreviousAuthentInfo - the previous authentication information

    lpStationName - the logon station name

    LPVOID - logon station handle

    lpLogonScript - the logon script to be executed.

Return Value:

    WN_SUCCESS

Notes:

    This capability has not been implemented in the sample.

--*/
{
    *lpLogonScript = NULL;

    return WN_SUCCESS;
}

DWORD APIENTRY
NPPasswordChangeNotify (
    LPCWSTR lpAuthentInfoType,
    LPVOID  lpAuthentInfo,
    LPCWSTR lpPreviousAuthentInfoType,
    LPVOID  lpPreviousAuthentInfo,
    LPWSTR  lpStationName,
    LPVOID  StationHandle,
    DWORD   dwChangeInfo )
/*++

Routine Description:

    This routine handles the password change notifications

Arguments:

    lpAuthenInfoType - the authentication information type

    lpAuthenInfo  - the authentication Information

    lpPreviousAuthentInfoType - the previous aunthentication information type

    lpPreviousAuthentInfo - the previous authentication information

    lpStationName - the logon station name

    LPVOID - logon station handle

    dwChangeInfo - the password change information.

Return Value:

    WN_NOT_SUPPORTED

Notes:

    This capability has not been implemented in the sample.

--*/
{
    SetLastError(WN_NOT_SUPPORTED);
    return WN_NOT_SUPPORTED;
}

DWORD APIENTRY
NPOpenEnum(
    DWORD          dwScope,
    DWORD          dwType,
    DWORD          dwUsage,
    LPNETRESOURCE  lpNetResource,
    LPHANDLE       lphEnum )
/*++

Routine Description:

    This routine opens a handle for enumeration of resources. The only capability
    implemented in the sample is for enumerating connected shares

Arguments:

    dwScope - the scope of enumeration

    dwType  - the type of resources to be enumerated

    dwUsage - the usage parameter

    lpNetResource - a pointer to the desired NETRESOURCE struct.

    lphEnum - aptr. for passing nack the enumeration handle

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

    The sample only supports the notion of enumerating connected shares

    The handle passed back is merely the index of the last entry returned

--*/
{
    DWORD   Status = 0;

    DbgP((TEXT("NPOpenEnum\n")));

    *lphEnum = NULL;

    switch (dwScope)
    {
        case RESOURCE_CONNECTED:
        {
            *lphEnum = LocalAlloc(
                            LMEM_ZEROINIT,
                            sizeof(SMBMRXNP_ENUMERATION_HANDLE));

            if (*lphEnum != NULL)
            {
                Status = WN_SUCCESS;
            }
            else
            {
                Status = WN_OUT_OF_MEMORY;
            }
            break;
        }
        break;
        
        case RESOURCE_CONTEXT:
        default:
            Status  = WN_NOT_SUPPORTED;
            break;
    }


    DbgP((TEXT("NPOpenEnum returning Status %lx\n"),Status));

    return(Status);
}

DWORD APIENTRY
NPEnumResource(
    HANDLE  hEnum,
    LPDWORD lpcCount,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize)
/*++

Routine Description:

    This routine uses the handle obtained by a call to NPOpenEnum for
    enuerating the connected shares

Arguments:

    hEnum  - the enumeration handle

    lpcCount - the number of resources returned

    lpBuffer - the buffere for passing back the entries

    lpBufferSize - the size of the buffer

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

    WN_NO_MORE_ENTRIES - if the enumeration has exhausted the entries

    WN_MORE_DATA - if nmore data is available

Notes:

    The sample only supports the notion of enumerating connected shares

    The handle passed back is merely the index of the last entry returned

--*/
{
    DWORD           Status = WN_SUCCESS;
    LPNETRESOURCEW  pBufferResource;
    DWORD           StringOffset;
    DWORD           AvailableBufferSize;
    HANDLE          hMutex, hMemory;

    PSMBMRXNP_ENUMERATION_HANDLE    pEnumHandle;
    PSMBMRXNP_SHARED_MEMORY         pSharedMemory;

    DbgP((TEXT("NPEnumResource\n")));

    DbgP((TEXT("NPEnumResource Count Requested %d\n"),*lpcCount));

    AvailableBufferSize = *lpBufferSize;
    StringOffset        = *lpBufferSize;
    pBufferResource     = (LPNETRESOURCEW)lpBuffer;

    pEnumHandle = (PSMBMRXNP_ENUMERATION_HANDLE)hEnum;

    *lpcCount = 0;

    if (pEnumHandle->LastIndex >= SMBMRXNP_MAX_DEVICES)
    {
        return WN_NO_MORE_ENTRIES;
    }

    Status = OpenSharedMemory(
                &hMutex,
                &hMemory,
                (PVOID)&pSharedMemory);

    if (Status == WN_SUCCESS)
    {
        INT  Index;
        PSMBMRXNP_NETRESOURCE pNetResource;

        DbgP((TEXT("NPEnumResource: Highest Index %d Number Of resources %d\n"),
                    pSharedMemory->HighestIndexInUse,pSharedMemory->NumberOfResourcesInUse));

        for (Index = pEnumHandle->LastIndex; Index <= pSharedMemory->HighestIndexInUse; Index++) {
            pNetResource = &pSharedMemory->NetResources[Index];

            DbgP((TEXT("NPEnumResource: Examining Index %d\n"),Index));

            if (pNetResource->InUse)
            {
                DWORD ResourceSize;

                ResourceSize = sizeof(NETRESOURCE) +
                               pNetResource->LocalNameLength + sizeof(WCHAR) +
                               pNetResource->RemoteNameLength + sizeof(WCHAR) +
                               SmbMrxProviderName.Length + sizeof(WCHAR);

                if (AvailableBufferSize >= ResourceSize)
                {
                    *lpcCount =  *lpcCount + 1;
                    AvailableBufferSize -= ResourceSize;

                    pBufferResource->dwScope       = RESOURCE_CONNECTED;
                    pBufferResource->dwType        = pNetResource->dwType;
                    pBufferResource->dwDisplayType = pNetResource->dwDisplayType;
                    pBufferResource->dwUsage       = pNetResource->dwUsage;

                    DbgP((TEXT("NPEnumResource: Copying local name Index %d\n"),Index));

                    // set up the strings in the resource
                    StringOffset -= (pNetResource->LocalNameLength + sizeof(WCHAR));
                    pBufferResource->lpLocalName =  (PWCHAR)((PBYTE)lpBuffer + StringOffset);

                    CopyMemory(pBufferResource->lpLocalName,
                               pNetResource->LocalName,
                               pNetResource->LocalNameLength);

                    pBufferResource->lpLocalName[
                        pNetResource->LocalNameLength/sizeof(WCHAR)] = L'\0';

                    DbgP((TEXT("NPEnumResource: Copying remote name Index %d\n"),Index));

                    StringOffset -= (pNetResource->RemoteNameLength + sizeof(WCHAR));
                    pBufferResource->lpRemoteName =  (PWCHAR)((PBYTE)lpBuffer + StringOffset);

                    CopyMemory(pBufferResource->lpRemoteName,
                               pNetResource->RemoteName,
                               pNetResource->RemoteNameLength);

                    pBufferResource->lpRemoteName[
                        pNetResource->RemoteNameLength/sizeof(WCHAR)] = L'\0';

                    DbgP((TEXT("NPEnumResource: Copying provider name Index %d\n"),Index));

                    StringOffset -= (SmbMrxProviderName.Length + sizeof(WCHAR));
                    pBufferResource->lpProvider =  (PWCHAR)((PBYTE)lpBuffer + StringOffset);

                    CopyMemory(pBufferResource->lpProvider,
                               SmbMrxProviderName.Buffer,
                               SmbMrxProviderName.Length);

                    pBufferResource->lpProvider[
                        SmbMrxProviderName.Length/sizeof(WCHAR)] = L'\0';

                    pBufferResource->lpComment = NULL;

                    pBufferResource++;
                }
                else
                {
                    DbgP((TEXT("NPEnumResource: Buffer Overflow Index %d\n"),Index));
                    Status = WN_MORE_DATA;
                    break;
                }
            }
        }

        pEnumHandle->LastIndex = Index;

        if ((Status == WN_SUCCESS) &&
            (pEnumHandle->LastIndex > pSharedMemory->HighestIndexInUse) &&
            (*lpcCount == 0))
        {
            Status = WN_NO_MORE_ENTRIES;
        }

        CloseSharedMemory(
            &hMutex,
            &hMemory,
            (PVOID)&pSharedMemory);
    }

    DbgP((TEXT("NPEnumResource returning Count %d\n"),*lpcCount));

    DbgP((TEXT("NPEnumResource returning Status %lx\n"),Status));

    return Status;
}

DWORD APIENTRY
NPCloseEnum(
    HANDLE hEnum )
/*++

Routine Description:

    This routine closes the handle for enumeration of resources.

Arguments:

    hEnum  - the enumeration handle

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

    The sample only supports the notion of enumerating connected shares

--*/
{
    DbgP((TEXT("NPCloseEnum\n")));

    LocalFree(hEnum);

    return WN_SUCCESS;
}


ULONG
SendToMiniRdr(
    IN ULONG            IoctlCode,
    IN PVOID            InputDataBuf,
    IN ULONG            InputDataLen,
    IN PVOID            OutputDataBuf,
    IN PULONG           pOutputDataLen)
/*++

Routine Description:

    This routine sends a device ioctl to the Mini Rdr.

Arguments:

    IoctlCode       - Function code for the Mini Rdr driver

    InputDataBuf    - Input buffer pointer

    InputDataLen    - Lenth of the input buffer

    OutputDataBuf   - Output buffer pointer

    pOutputDataLen  - Pointer to the length of the output buffer

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
    HANDLE  DeviceHandle;       // The mini rdr device handle
    ULONG   BytesRet;
    BOOL    rc;
    ULONG   Status;

    Status = WN_SUCCESS;

    // Grab a handle to the redirector device object

    DeviceHandle = CreateFile(
        DD_SMBMRX_USERMODE_DEV_NAME,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        (LPSECURITY_ATTRIBUTES)NULL,
        OPEN_EXISTING,
        0,
        (HANDLE) NULL );

    if ( INVALID_HANDLE_VALUE != DeviceHandle )
    {
        rc = DeviceIoControl( DeviceHandle,
                              IoctlCode,
                              InputDataBuf,
                              InputDataLen,
                              OutputDataBuf,
                              *pOutputDataLen,
                              pOutputDataLen,
                              NULL );

            if ( !rc )
            {
                DbgP(( L"SendToMiniRdr - returning error from DeviceIoctl\n" ));
                Status = GetLastError( );
            }
            else
            {
                DbgP(( L"SendToMiniRdr - The DeviceIoctl call succeded\n" ));
            }
            CloseHandle(DeviceHandle);
    }
    else
    {
        Status = GetLastError( );
        DbgP(( L"SendToMiniRdr - error %lx opening device \n", Status ));
    }

    return Status;
}


ULONG FillInEaBuffer( LPTSTR pUserName, LPTSTR pPassword, PBYTE pEaData )
{
    PFILE_FULL_EA_INFORMATION thisEa = (PFILE_FULL_EA_INFORMATION) pEaData;

    PBYTE               valuePtr;
    PWKSTA_INFO_100     WkStaInfo;
    ULONG               status;
    PWCHAR              pDomain;

    // get the domain that this workstation is a member of
    status = NetWkstaGetInfo( NULL, 100, (PBYTE *) &WkStaInfo );
    if ( status == ERROR_SUCCESS )
    {
        pDomain = WkStaInfo->wki100_langroup;
    }
    else
    {
        pDomain = NULL;
    }



    thisEa->EaValueLength   = 0;
    thisEa->NextEntryOffset = 0;

    // Set the user name EA
    if ( pUserName )
    {
        thisEa->Flags = 0;
        thisEa->EaNameLength = sizeof("UserName");
        CopyMemory( thisEa->EaName, "UserName\0", thisEa->EaNameLength + 1 );
        valuePtr = (PBYTE) thisEa->EaName + thisEa->EaNameLength + 1;
        thisEa->EaValueLength = (USHORT)( *pUserName ? lstrlenW( pUserName ) + 1 : 1 ) * sizeof( WCHAR );
        CopyMemory( valuePtr, pUserName, thisEa->EaValueLength );
        thisEa->NextEntryOffset = (ULONG)(((PBYTE) valuePtr + thisEa->EaValueLength ) -
                                   (PBYTE) thisEa);
    }

    // Set the password EA.
    if ( pPassword )
    {
        thisEa = (PFILE_FULL_EA_INFORMATION) ((PBYTE) thisEa + thisEa->NextEntryOffset);

        thisEa->Flags = 0;
        thisEa->EaNameLength = sizeof("Password");
        CopyMemory( thisEa->EaName, "Password\0", thisEa->EaNameLength + 1 );
        valuePtr = (PBYTE) thisEa->EaName + thisEa->EaNameLength + 1;
        thisEa->EaValueLength = (USHORT)( *pPassword ? lstrlenW( pPassword ) + 1 : 1 ) * sizeof( WCHAR );
        CopyMemory( valuePtr, pPassword, thisEa->EaValueLength );
        thisEa->NextEntryOffset = (ULONG)(((PBYTE) valuePtr + thisEa->EaValueLength ) -
                                   (PBYTE) thisEa);
    }

    // Set the domain EA
    if ( pDomain )
    {
        thisEa = (PFILE_FULL_EA_INFORMATION) ((PBYTE) thisEa + thisEa->NextEntryOffset);

        thisEa->Flags = 0;
        thisEa->EaNameLength = sizeof("Domain");
        RtlCopyMemory( thisEa->EaName, "Domain\0", thisEa->EaNameLength + 1 );
        valuePtr = (PBYTE) thisEa->EaName + thisEa->EaNameLength + 1;
        thisEa->EaValueLength = (USHORT)( *pDomain ? lstrlenW( pDomain ) + 1 : 1 ) * sizeof( WCHAR );
        RtlCopyMemory( valuePtr, pDomain, thisEa->EaValueLength );
        thisEa->NextEntryOffset = 0;
    }

    return (ULONG)(((PBYTE) valuePtr + thisEa->EaValueLength) - (PBYTE) pEaData);
}


DWORD APIENTRY
NPAddConnection(
    LPNETRESOURCE   lpNetResource,
    LPWSTR          lpPassword,
    LPWSTR          lpUserName )
/*++

Routine Description:

    This routine adds a connection to the list of connections associated
    with this network provider

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpPassword  - the password

    lpUserName - the user name

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
    return NPAddConnection3(NULL, lpNetResource, lpPassword, lpUserName, 0);
}


DWORD APIENTRY
NPAddConnection3(
    HWND            hwndOwner,
    LPNETRESOURCE   lpNetResource,
    LPWSTR          lpPassword,
    LPWSTR          lpUserName,
    DWORD           dwFlags )
/*++

Routine Description:

    This routine adds a connection to the list of connections associated
    with this network provider

Arguments:

    hwndOwner - the owner handle

    lpNetResource - the NETRESOURCE struct

    lpPassword  - the password

    lpUserName - the user name

    dwFlags - flags for the connection

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

    The current sample does not handle explicitly passesd in credentials. Normally
    the credential information is passed in as EA parameters to the associated
    mini redirector for further manipulation

--*/
{
    DWORD   Status = 0;

    UNICODE_STRING      ConnectionName;

    PWCHAR  pLocalName,pRemoteName;
    USHORT  LocalNameLength,RemoteNameLength;
    HANDLE  hConnection;
    ULONG   TransferBytes;
    WCHAR   NullStr[] = L"\0\0";
    PWCHAR  pUserName;
    PWCHAR  pPassword;
    PWKSTA_USER_INFO_0  WkStaUserInfo;
    PSMBMRX_CONNECTINFO ConnectInfo;
    

    DbgP((TEXT("NPAddConnection3: Incoming UserName - %s, Password - %s\n"),
                lpUserName, lpPassword ));

    // if no user specified, get the current logged on user
    if ( lpUserName == NULL )
    {
        Status = NetWkstaUserGetInfo( NULL, 0, (PBYTE *)&WkStaUserInfo );
        if ( Status == ERROR_SUCCESS )
        {
            pUserName = WkStaUserInfo->wkui0_username;
        }
        else
        {
            pUserName = NullStr;
        }
    }
    else
    {
        pUserName = lpUserName;
    }

    if ( lpPassword == NULL )
    {
        pPassword = NullStr;    // use default password
        pPassword[1] = '\0';    // reset empty flag
    }
    else if ( *lpPassword == L'\0' )
    {
        pPassword = NullStr;
        pPassword[1] = '1';     // flag the password as "Empty"
    }
    else
    {
        pPassword = lpPassword;
    }
    Status = ERROR_SUCCESS;

    DbgP((TEXT("NPAddConnection3: Outgoing UserName - %s, Password - %s\n"),
                lpUserName, lpPassword ));

    // The SMB mini supports only DISK type resources. The other resources
    // are not supported.

    if ((lpNetResource->lpRemoteName == NULL) ||
        (lpNetResource->lpRemoteName[0] != L'\\') ||
        (lpNetResource->lpRemoteName[1] != L'\\') ||
        (lpNetResource->dwType != RESOURCETYPE_DISK))
    {
        return WN_BAD_NETNAME;
    }

    //
    // The remote name is in the UNC format \\Server\Share.  This name
    // needs to be translated to an appropriate NT name in order to
    // issue the request to the underlying mini redirector to create the
    // connection.
    //
    // The NT style name is of the form
    //
    //  \device\smbminiredirector\;<DriveLetter>:\Server\Share
    //
    // The additional ; is required by the new RDR for extensibility.
    //

    pLocalName  = lpNetResource->lpLocalName;
    pRemoteName = lpNetResource->lpRemoteName;

    // skip past the first back slash since the name to be appended for the
    // NT name does not require this.
    pRemoteName++;

    if (pLocalName != NULL) {
        LocalNameLength = wcslen(pLocalName) * sizeof(WCHAR);
    } else {
        LocalNameLength = 0;
    }

    RemoteNameLength = (wcslen(pRemoteName) - 1) * sizeof(WCHAR);

    ConnectionName.MaximumLength = (USHORT)(SmbMRxDeviceName.Length +
                                   (USHORT)RemoteNameLength +
                                   ((pLocalName != NULL)
                                   ? (LocalNameLength + sizeof(WCHAR)) : 0) + // space for ;
                                   sizeof(WCHAR));

    ConnectionName.Length = ConnectionName.MaximumLength;

    ConnectionName.Buffer = LocalAlloc( LMEM_ZEROINIT,
                                        ConnectionName.Length + sizeof(WCHAR));

    if (ConnectionName.Buffer == NULL)
    {
        return GetLastError();
    }

    // Copy the name into the buffer

    CopyMemory( ConnectionName.Buffer,
                SmbMRxDeviceName.Buffer,
                SmbMRxDeviceName.Length);

    wcscat(ConnectionName.Buffer, L"\\");
    wcscat(ConnectionName.Buffer, L";");
    if (pLocalName != NULL)
    {
        wcscat(ConnectionName.Buffer, pLocalName);
    }

    wcscat(ConnectionName.Buffer, pRemoteName);

    ConnectInfo = (PSMBMRX_CONNECTINFO) LocalAlloc( LMEM_ZEROINIT, MAX_CONNECT_INFO_SIZE );
    if ( ConnectInfo )
    {
        ConnectInfo->ConnectionNameOffset = 0;
        ConnectInfo->ConnectionNameLength = ConnectionName.Length;
        CopyMemory( ConnectInfo->InfoArea, ConnectionName.Buffer, ConnectionName.Length );

        ConnectInfo->EaDataOffset = ConnectInfo->ConnectionNameOffset +
                                    ConnectInfo->ConnectionNameLength;
        // check for the "no password" flag
        if ( pPassword[0] == L'\0' && pPassword[1] == L'1' )
        {
            pPassword = NULL;
        }
        ConnectInfo->EaDataLength = FillInEaBuffer( pUserName,
                                                    pPassword,
                                                    (PBYTE) ConnectInfo->InfoArea +
                                                    ConnectInfo->EaDataOffset );
        TransferBytes = 0;

        Status = SendToMiniRdr( IOCTL_SMBMRX_ADDCONN,
                                ConnectInfo,
                                MAX_CONNECT_INFO_SIZE,
                                NULL,
                                &TransferBytes );
        LocalFree( ConnectInfo );
    }
    else
    {
        Status = WN_OUT_OF_MEMORY;
    }

    if ((Status == WN_SUCCESS) && (pLocalName != NULL))
    {
        WCHAR TempBuf[64];

        if (!QueryDosDeviceW(
                pLocalName,
                TempBuf,
                64))
        {
            if (GetLastError() != ERROR_FILE_NOT_FOUND)
            {
                //
                // Most likely failure occurred because our output
                // buffer is too small.  It still means someone already
                // has an existing symbolic link for this device.
                //

                Status = ERROR_ALREADY_ASSIGNED;
            }
            else
            {
                //
                // ERROR_FILE_NOT_FOUND (translated from OBJECT_NAME_NOT_FOUND)
                // means it does not exist and we can redirect this device.
                //
                // Create a symbolic link object to the device we are redirecting
                //
                if (!DefineDosDeviceW(
                        DDD_RAW_TARGET_PATH |
                        DDD_NO_BROADCAST_SYSTEM,
                        pLocalName,
                        ConnectionName.Buffer))
                {
                    Status = GetLastError();
                }
                else
                {
                    Status = WN_SUCCESS;
                }
            }
        }
        else
        {
            //
            // QueryDosDevice successfully an existing symbolic link--
            // somebody is already using this device.
            //
            Status = ERROR_ALREADY_ASSIGNED;
        }
    }
    else
    {
        DbgP((TEXT("SendToMiniRdr returned %lx\n"),Status));
    }

    if (Status == WN_SUCCESS)
    {
        INT     Index;
        HANDLE  hMutex, hMemory;
        BOOLEAN FreeEntryFound = FALSE;

        PSMBMRXNP_SHARED_MEMORY  pSharedMemory;

        // The connection was established and the local device mapping
        // added. Include this in the list of mapped devices.

        Status = OpenSharedMemory(
                    &hMutex,
                    &hMemory,
                    (PVOID)&pSharedMemory);

        if (Status == WN_SUCCESS)
        {
            DbgP((TEXT("NPAddConnection3: Highest Index %d Number Of resources %d\n"),
                        pSharedMemory->HighestIndexInUse,pSharedMemory->NumberOfResourcesInUse));

            Index = 0;

            while (Index < pSharedMemory->HighestIndexInUse)
            {
                if (!pSharedMemory->NetResources[Index].InUse)
                {
                    FreeEntryFound = TRUE;
                    break;
                }

                Index++;
            }

            if (!FreeEntryFound &&
                (pSharedMemory->HighestIndexInUse < SMBMRXNP_MAX_DEVICES))
            {
                pSharedMemory->HighestIndexInUse += 1;
                Index = pSharedMemory->HighestIndexInUse;
                FreeEntryFound = TRUE;
            }

            if (FreeEntryFound)
            {
                PSMBMRXNP_NETRESOURCE pSmbMrxNetResource;

                pSharedMemory->NumberOfResourcesInUse += 1;

                pSmbMrxNetResource = &pSharedMemory->NetResources[Index];

                pSmbMrxNetResource->InUse                = TRUE;
                pSmbMrxNetResource->dwScope              = lpNetResource->dwScope;
                pSmbMrxNetResource->dwType               = lpNetResource->dwType;
                pSmbMrxNetResource->dwDisplayType        = lpNetResource->dwDisplayType;
                pSmbMrxNetResource->dwUsage              = RESOURCEUSAGE_CONNECTABLE;
                pSmbMrxNetResource->LocalNameLength      = LocalNameLength;
                pSmbMrxNetResource->RemoteNameLength     = wcslen(lpNetResource->lpRemoteName) * sizeof(WCHAR);
                pSmbMrxNetResource->ConnectionNameLength = ConnectionName.Length;

                // Copy the local name
                CopyMemory( pSmbMrxNetResource->LocalName,
                            lpNetResource->lpLocalName,
                            pSmbMrxNetResource->LocalNameLength);

                // Copy the remote name
                CopyMemory( pSmbMrxNetResource->RemoteName,
                            lpNetResource->lpRemoteName,
                            pSmbMrxNetResource->RemoteNameLength);

                // Copy the connection name
                CopyMemory( pSmbMrxNetResource->ConnectionName,
                            ConnectionName.Buffer,
                            pSmbMrxNetResource->ConnectionNameLength);


                // Copy the Auth info
                lstrcpy( pSmbMrxNetResource->UserName, pUserName );
                if ( *pPassword )
                {
                    lstrcpy( pSmbMrxNetResource->Password, pPassword );
                }
                else
                {
                    CopyMemory( pSmbMrxNetResource->Password, pPassword, 3 * sizeof(WCHAR) );
                }
            }
            else
            {
                Status = WN_NO_MORE_DEVICES;
            }

            CloseSharedMemory( &hMutex,
                               &hMemory,
                               (PVOID)&pSharedMemory);
        }
        else
        {
            DbgP((TEXT("NpAddConnection3: OpenSharedMemory returned %lx\n"),Status));
        }
    }

    return Status;
}


DWORD APIENTRY
NPCancelConnection(
    LPWSTR  lpName,
    BOOL    fForce )
/*++

Routine Description:

    This routine cancels ( deletes ) a connection from the list of connections
    associated with this network provider

Arguments:

    lpName - name of the connection

    fForce - forcefully delete the connection

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/

{
    BOOL    bLocalName = TRUE;
    DWORD   Status = 0;

    UNICODE_STRING Name;

    HANDLE  hMutex, hMemory;
    PSMBMRXNP_SHARED_MEMORY  pSharedMemory;

    if (*lpName == L'\\' && *(lpName + 1) == L'\\')
    {
        bLocalName = FALSE;
    }

    DbgP((TEXT("NPCancelConnection\n")));
    DbgP((TEXT("NPCancelConnection: ConnectionName: %S\n"), lpName));

    Name.MaximumLength = Name.Length = wcslen(lpName) * sizeof(WCHAR);
    Name.Buffer = lpName;

    Status = OpenSharedMemory( &hMutex,
                               &hMemory,
                               (PVOID)&pSharedMemory);

    if (Status == WN_SUCCESS)
    {
        INT  Index;
        BOOL EntryFound = FALSE;
        PSMBMRXNP_NETRESOURCE pNetResource;

        DbgP((TEXT("NPCancelConnection: Highest Index %d Number Of resources %d\n"),
                    pSharedMemory->HighestIndexInUse,pSharedMemory->NumberOfResourcesInUse));

        for (Index = 0; Index <= pSharedMemory->HighestIndexInUse; Index++)
        {
            pNetResource = &pSharedMemory->NetResources[Index];

            if (pNetResource->InUse)
            {
                UNICODE_STRING EntryName;

                if (bLocalName)
                {
                    EntryName.MaximumLength = pNetResource->LocalNameLength;
                    EntryName.Length        = EntryName.MaximumLength;
                    EntryName.Buffer        = pNetResource->LocalName;
                }
                else
                {
                    EntryName.MaximumLength = pNetResource->RemoteNameLength;
                    EntryName.Length        = EntryName.MaximumLength;
                    EntryName.Buffer        = pNetResource->RemoteName;
                }

                DbgP((TEXT("NPCancelConnection: Name %S EntryName %S\n"),
                            lpName,EntryName.Buffer));
                DbgP((TEXT("NPCancelConnection: Name Length %d Entry Name Length %d\n"),
                           Name.Length,EntryName.Length));

                if (Name.Length == EntryName.Length)
                {
                    if ( _wcsnicmp(Name.Buffer, EntryName.Buffer, Name.Length) == 0 )
                    {
                        EntryFound = TRUE;
                        break;
                    }
                }
            }
        }

        if (EntryFound)
        {
            PWCHAR  pUserName;
            PWCHAR  pPassword;
            PSMBMRX_CONNECTINFO ConnectInfo;
            UNICODE_STRING ConnectionName;
            ULONG TransferBytes;

            DbgP((TEXT("NPCancelConnection: Connection Found:\n")));

            ConnectionName.Length        = pNetResource->ConnectionNameLength;
            ConnectionName.MaximumLength = ConnectionName.Length;
            ConnectionName.Buffer        = pNetResource->ConnectionName;
            pUserName                    = pNetResource->UserName;
            pPassword                    = pNetResource->Password;

            ConnectInfo = (PSMBMRX_CONNECTINFO) LocalAlloc( LMEM_ZEROINIT, MAX_CONNECT_INFO_SIZE );
            if ( ConnectInfo )
            {
                ConnectInfo->ConnectionNameOffset = 0;
                ConnectInfo->ConnectionNameLength = ConnectionName.Length;
                CopyMemory( ConnectInfo->InfoArea, ConnectionName.Buffer, ConnectionName.Length );

                ConnectInfo->EaDataOffset = ConnectInfo->ConnectionNameOffset +
                                            ConnectInfo->ConnectionNameLength;
                // check for the "no password" flag
                if ( pPassword[0] == L'\0' && pPassword[1] == L'1' )
                {
                    pPassword = NULL;
                }
                ConnectInfo->EaDataLength = FillInEaBuffer( pUserName,
                                                            pPassword,
                                                            (PBYTE) ConnectInfo->InfoArea +
                                                            ConnectInfo->EaDataOffset );
                TransferBytes = 0;

                Status = SendToMiniRdr( IOCTL_SMBMRX_DELCONN,
                                        ConnectInfo,
                                        MAX_CONNECT_INFO_SIZE,
                                        NULL,
                                        &TransferBytes );
                LocalFree( ConnectInfo );
            }
            else
            {
                Status = WN_OUT_OF_MEMORY;
            }

            DbgP((TEXT("NPCancelConnection: SendToMiniRdr returned Status %lx\n"),Status));

            if ( bLocalName )
            {
                if (DefineDosDevice(DDD_REMOVE_DEFINITION | DDD_RAW_TARGET_PATH | DDD_EXACT_MATCH_ON_REMOVE,
                                    lpName,
                                    pNetResource->ConnectionName) == FALSE)
                {
                    DbgP((TEXT("RemoveDosDevice:  DefineDosDevice error: %d\n"), GetLastError()));
                    Status = GetLastError();
                }
                else
                {
                    pNetResource->InUse = FALSE;

                    if (Index == pSharedMemory->HighestIndexInUse)
                    {
                        pSharedMemory->HighestIndexInUse      -= 1;
                        pSharedMemory->NumberOfResourcesInUse -= 1;
                    }
                }
            }
        }

        CloseSharedMemory( &hMutex,
                           &hMemory,
                          (PVOID)&pSharedMemory);
    }

    return Status;
}


DWORD APIENTRY
NPGetConnection(
    LPWSTR  lpLocalName,
    LPWSTR  lpRemoteName,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the information associated with a connection

Arguments:

    lpLocalName - local name associated with the connection

    lpRemoteName - the remote name associated with the connection

    lpBufferSize - the remote name buffer size

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
    DWORD   Status = 0;

    UNICODE_STRING Name;

    HANDLE  hMutex, hMemory;
    PSMBMRXNP_SHARED_MEMORY  pSharedMemory;

    Name.MaximumLength = Name.Length = wcslen(lpLocalName) * sizeof(WCHAR);
    Name.Buffer        = lpLocalName;

    Status = OpenSharedMemory( &hMutex,
                               &hMemory,
                               (PVOID)&pSharedMemory);

    if (Status == WN_SUCCESS)
    {
        INT  Index;
        BOOL EntryFound = FALSE;
        PSMBMRXNP_NETRESOURCE pNetResource;

        for (Index = 0; Index <= pSharedMemory->HighestIndexInUse; Index++)
        {
            pNetResource = &pSharedMemory->NetResources[Index];

            if (pNetResource->InUse)
            {
                UNICODE_STRING EntryName;

                EntryName.MaximumLength = pNetResource->LocalNameLength;
                EntryName.Length        = EntryName.MaximumLength;
                EntryName.Buffer        = pNetResource->LocalName;

                if (Name.Length == EntryName.Length)
                {
                    if ( wcsncmp( Name.Buffer, EntryName.Buffer, Name.Length) == 0 )
                    {
                        EntryFound = TRUE;
                        break;
                    }
                }
            }
        }

        if (EntryFound)
        {
            if (*lpBufferSize < pNetResource->RemoteNameLength)
            {
                *lpBufferSize = pNetResource->RemoteNameLength;
                Status = ERROR_BUFFER_OVERFLOW;
            }
            else
            {
                *lpBufferSize = pNetResource->RemoteNameLength;
                CopyMemory( lpRemoteName,
                            pNetResource->RemoteName,
                            pNetResource->RemoteNameLength);
                Status = WN_SUCCESS;
            }
        }
        else
        {
            Status = ERROR_NO_NET_OR_BAD_PATH;
        }

        CloseSharedMemory( &hMutex, &hMemory, (PVOID)&pSharedMemory);
    }

    return Status;
}


DWORD APIENTRY
NPGetResourceParent(
    LPNETRESOURCE   lpNetResource,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the parent of a given resource

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpBuffer - the buffer for passing back the parent information

    lpBufferSize - the buffer size

Return Value:

    WN_NOT_SUPPORTED

Notes:

    The current sample does not handle this call.

--*/
{
    return WN_NOT_SUPPORTED;
}

DWORD APIENTRY
NPGetResourceInformation(
    LPNETRESOURCE   lpNetResource,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize,
    LPWSTR  *lplpSystem )
/*++

Routine Description:

    This routine returns the information associated net resource

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpBuffer - the buffer for passing back the parent information

    lpBufferSize - the buffer size

    lplpSystem -

Return Value:

Notes:

--*/
{
    DWORD dwStatus = 0;
    LPNETRESOURCE   pOutNetResource;
    DbgP((TEXT("NPGetResourceInformation\n")));

    return dwStatus;
}


DWORD APIENTRY
NPGetUniversalName(
    LPCWSTR lpLocalPath,
    DWORD   dwInfoLevel,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the information associated net resource

Arguments:

    lpLocalPath - the local path name

    dwInfoLevel  - the desired info level

    lpBuffer - the buffer for the univeral name

    lpBufferSize - the buffer size

Return Value:

    WN_SUCCESS if successful

Notes:

--*/
{
    DWORD   dwStatus;

    DWORD   BufferRequired      = 0;
    DWORD   UniversalNameLength = 0;
    DWORD   RemoteNameLength    = 0;
    DWORD   RemainingPathLength = 0;

    LPWSTR  pDriveLetter,
            pRemainingPath,
            SourceStrings[3];

    WCHAR   RemoteName[MAX_PATH],
            LocalPath[MAX_PATH],
            UniversalName[MAX_PATH],
            ReplacedChar;

    DbgP((TEXT("NPGetUniversalName: lpLocalPath: %S  InfoLevel: %d\n"), lpLocalPath, dwInfoLevel));

    if (dwInfoLevel != UNIVERSAL_NAME_INFO_LEVEL &&
        dwInfoLevel != REMOTE_NAME_INFO_LEVEL)
    {
        DbgP((TEXT("NPGetUniversalName:  bad dwInfoLevel value: %d\n"), dwInfoLevel));
        return WN_BAD_LEVEL;
    }

    wcscpy(LocalPath, lpLocalPath);
    pDriveLetter = LocalPath;
    if (pRemainingPath = wcschr(pDriveLetter, L':'))
    {
        ReplacedChar = *(++pRemainingPath);
        *pRemainingPath = L'\0';

    }

    if ((dwStatus = NPGetConnection(pDriveLetter, RemoteName, &RemoteNameLength)) != WN_SUCCESS)
    {
        DbgP((TEXT("NPGetUniversalName:  NPGetConnection return dwStatus: %d\n"), dwStatus));
        return dwStatus;
    }

    if (pRemainingPath)
    {
        *pRemainingPath = ReplacedChar;
    }

    DbgP((TEXT("NPGetUniversalName: pRemainingPath: %S  RemoteName: %S\n"), pRemainingPath, RemoteName));

    wcscpy(UniversalName, RemoteName);

    if (pRemainingPath)
    {
        wcscat(UniversalName, pRemainingPath);
    }

    DbgP((TEXT("NPGetUniversalName: UniversalName: %S\n"), UniversalName));

    // Determine if the provided buffer is large enough.
    UniversalNameLength = (wcslen(UniversalName) + 1) * sizeof(WCHAR);
    BufferRequired = UniversalNameLength;

    if (dwInfoLevel == UNIVERSAL_NAME_INFO_LEVEL)
    {
        BufferRequired += sizeof(UNIVERSAL_NAME_INFO);
    }
    else
    {
        RemoteNameLength = (wcslen(RemoteName) + 1) * sizeof(WCHAR);
        BufferRequired += sizeof(REMOTE_NAME_INFO) + RemoteNameLength;
        if (pRemainingPath)
        {
            RemainingPathLength = (wcslen(pRemainingPath) + 1) * sizeof(WCHAR);
            BufferRequired += RemainingPathLength;
        }
    }

    if (*lpBufferSize < BufferRequired)
    {
        DbgP((TEXT("NPGetUniversalName: WN_MORE_DATA BufferRequired: %d\n"), BufferRequired));
        *lpBufferSize = BufferRequired;
        return WN_MORE_DATA;
    }

    if (dwInfoLevel == UNIVERSAL_NAME_INFO_LEVEL)
    {
        LPUNIVERSAL_NAME_INFOW pUniversalNameInfo;

        pUniversalNameInfo = (LPUNIVERSAL_NAME_INFOW)lpBuffer;

        pUniversalNameInfo->lpUniversalName = (PWCHAR)((PBYTE)lpBuffer + sizeof(UNIVERSAL_NAME_INFOW));

        CopyMemory( pUniversalNameInfo->lpUniversalName,
                    UniversalName,
                    UniversalNameLength);
    }
    else
    {
        LPREMOTE_NAME_INFOW pRemoteNameInfo;

        pRemoteNameInfo = (LPREMOTE_NAME_INFOW)lpBuffer;

        pRemoteNameInfo->lpUniversalName  = (PWCHAR)((PBYTE)lpBuffer + sizeof(REMOTE_NAME_INFOW));
        pRemoteNameInfo->lpConnectionName = pRemoteNameInfo->lpUniversalName + UniversalNameLength;
        pRemoteNameInfo->lpRemainingPath  = pRemoteNameInfo->lpConnectionName + RemoteNameLength;

        CopyMemory( pRemoteNameInfo->lpUniversalName,
                    UniversalName,
                    UniversalNameLength);

        CopyMemory( pRemoteNameInfo->lpConnectionName,
                    RemoteName,
                    RemoteNameLength);

        CopyMemory( pRemoteNameInfo->lpRemainingPath,
                    pRemainingPath,
                    RemainingPathLength);
    }

    DbgP((TEXT("NPGetUniversalName: WN_SUCCESS\n")));

    return WN_SUCCESS;
}


// Format and write debug information to OutputDebugString
ULONG
_cdecl
DbgPrint(
    LPTSTR Format,
    ...
    )
{   
    ULONG rc = 0;
    TCHAR szbuffer[255];

    va_list marker;
    va_start( marker, Format );
    {
         rc = wvsprintf( szbuffer, Format, marker );
         OutputDebugString( TRACE_TAG );
         OutputDebugString( szbuffer );
    }

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\srvcall.c ===
/*

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    srvcall.c

Abstract:

    This module implements the routines for handling the creation/manipulation of
    server entries in the connection engine database. It also contains the routines
    for parsing the negotiate response from  the server.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

RXDT_DefineCategory(SRVCALL);
#define Dbg                     (DEBUG_TRACE_SRVCALL)

NTSTATUS
ExecuteCreateSrvCall(
      PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext)
/*++

Routine Description:

   This routine patches the RDBSS created srv call instance with the
   information required by the mini redirector.

Arguments:

    CallBackContext  - the call back context in RDBSS for continuation.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS	Status;
	PWCHAR		pSrvName;
	BOOLEAN		Verifyer;

    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = pCallbackContext;
    PMRX_SRV_CALL pSrvCall;
    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure =
        (PMRX_SRVCALLDOWN_STRUCTURE)(SCCBC->SrvCalldownStructure);

    pSrvCall = SrvCalldownStructure->SrvCall;

    ASSERT( pSrvCall );
    ASSERT( NodeType(pSrvCall) == RDBSS_NTC_SRVCALL );

	// validate the server name with the test name of 'nulsvr'
	DbgPrint("NulMRx - SrvCall: Connection Name Length: %d\n",  pSrvCall->pSrvCallName->Length );

	if ( pSrvCall->pSrvCallName->Length >= 14 )
	{
		pSrvName = pSrvCall->pSrvCallName->Buffer;
	
		Verifyer  = ( pSrvName[0] == L'\\' );
		Verifyer &= ( pSrvName[1] == L'N' ) || ( pSrvName[1] == L'n' );
		Verifyer &= ( pSrvName[2] == L'U' ) || ( pSrvName[2] == L'u' );
		Verifyer &= ( pSrvName[3] == L'L' ) || ( pSrvName[3] == L'l' );
		Verifyer &= ( pSrvName[4] == L'S' ) || ( pSrvName[4] == L's' );
		Verifyer &= ( pSrvName[5] == L'V' ) || ( pSrvName[5] == L'v' );
		Verifyer &= ( pSrvName[6] == L'R' ) || ( pSrvName[6] == L'r' );
		Verifyer &= ( pSrvName[7] == L'\\' ) || ( pSrvName[7] == L'\0' );
	}
	else
	{
		Verifyer = FALSE;
	}

	if ( Verifyer )
	{
        RxDbgTrace( 0, Dbg, ("Verifier Succeeded!!!!!!!!!\n"));
    	Status = STATUS_SUCCESS;
	}
	else
	{
        RxDbgTrace( 0, Dbg, ("Verifier Failed!!!!!!!!!\n"));
    	Status = STATUS_BAD_NETWORK_PATH;
	}

    SCCBC->Status = Status;
    SrvCalldownStructure->CallBack(SCCBC);

   return Status;
}


NTSTATUS
NulMRxCreateSrvCall(
      PMRX_SRV_CALL                  pSrvCall,
      PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext)
/*++

Routine Description:

   This routine patches the RDBSS created srv call instance with the information required
   by the mini redirector.

Arguments:

    RxContext        - Supplies the context of the original create/ioctl

    CallBackContext  - the call back context in RDBSS for continuation.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    UNICODE_STRING ServerName;

    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure =
        (PMRX_SRVCALLDOWN_STRUCTURE)(pCallbackContext->SrvCalldownStructure);

    ASSERT( pSrvCall );
    ASSERT( NodeType(pSrvCall) == RDBSS_NTC_SRVCALL );

    //
    // If this request was made on behalf of the RDBSS, do ExecuteCreatSrvCall
    // immediately. If the request was made from somewhere else, create a work item
    // and place it on a queue for a worker thread to process later. This distinction
    // is made to simplify transport handle management.
    //

    if (IoGetCurrentProcess() == RxGetRDBSSProcess())
    {
        RxDbgTrace( 0, Dbg, ("Called in context of RDBSS process\n"));

        //
        // Peform the processing immediately because RDBSS is the initiator of this
        // request
        //

        Status = ExecuteCreateSrvCall(pCallbackContext);
    }
    else
    {
        RxDbgTrace( 0, Dbg, ("Dispatching to worker thread\n"));

       //
       // Dispatch the request to a worker thread because the redirected drive
       // buffering sub-system (RDBSS) was not the initiator
       //

       Status = RxDispatchToWorkerThread(
                  NulMRxDeviceObject,
                  DelayedWorkQueue,
                  ExecuteCreateSrvCall,
                  pCallbackContext);

       if (Status == STATUS_SUCCESS)
       {
            //
            // Map the return value since the wrapper expects PENDING.
            //

            Status = STATUS_PENDING;
       }
    }

    return Status;
}


NTSTATUS
NulMRxFinalizeSrvCall(
      PMRX_SRV_CALL pSrvCall,
      BOOLEAN       Force)
/*++

Routine Description:

   This routine destroys a given server call instance

Arguments:

    pSrvCall  - the server call instance to be disconnected.

    Force     - TRUE if a disconnection is to be enforced immediately.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxDbgTrace( 0, Dbg, ("NulMRxFinalizeSrvCall \n"));
    pSrvCall->Context = NULL;

    return(Status);
}

NTSTATUS
NulMRxSrvCallWinnerNotify(
      IN PMRX_SRV_CALL  pSrvCall,
      IN BOOLEAN        ThisMinirdrIsTheWinner,
      IN OUT PVOID      pSrvCallContext
      )
/*++

Routine Description:

   This routine finalizes the mini rdr context associated with an RDBSS Server call instance

Arguments:

    pSrvCall               - the Server Call

    ThisMinirdrIsTheWinner - TRUE if this mini rdr is the choosen one.

    pSrvCallContext  - the server call context created by the mini redirector.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The two phase construction protocol for Server calls is required because of parallel
    initiation of a number of mini redirectors. The RDBSS finalizes the particular mini
    redirector to be used in communicating with a given server based on quality of
    service criterion.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxDbgTrace( 0, Dbg, ("NulMRxSrvCallWinnerNotify \n"));
    if( ThisMinirdrIsTheWinner ) {
        RxDbgTrace(0, Dbg, ("This minirdr is the winner \n"));
    }

    pSrvCall->Context = (PVOID)0xDEADBEEFDEADBEEF;

    return(Status);
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\nulmrx\sys\wmlkm.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cldskwmi.c

Abstract:

    km wmi tracing code. 
    
    Will be shared between our drivers.

Authors:

    GorN     10-Aug-1999

Environment:

    kernel mode only

Notes:

Revision History:

Comments:

        This code is a quick hack to enable WMI tracing in cluster drivers.
        It should eventually go away.

        WmlTinySystemControl will be replaced with WmilibSystemControl from wmilib.sys .

        WmlTrace or equivalent will be added to the kernel in addition to IoWMIWriteEvent(&TraceBuffer);

--*/
#include "precomp.h"
#pragma hdrstop

//#include <ntos.h>
//#include <ntrtl.h>
//#include <nturtl.h>


// #include <wmistr.h>
// #include <evntrace.h>

// #include "wmlkm.h"

BOOLEAN
WmlpFindGuid(
    IN PVOID GuidList,
    IN ULONG GuidCount,
    IN LPVOID Guid,
    OUT PULONG GuidIndex
    )
/*++

Routine Description:

    This routine will search the list of guids registered and return
    the index for the one that was registered.

Arguments:

    GuidList is the list of guids to search

    GuidCount is the count of guids in the list

    Guid is the guid being searched for

    *GuidIndex returns the index to the guid
        
Return Value:

    TRUE if guid is found else FALSE

--*/
{

    return(FALSE);
}


NTSTATUS
WmlTinySystemControl(
    IN OUT PVOID WmiLibInfo,
    IN PVOID DeviceObject,
    IN PVOID Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_SYSTEM_CONTROL. This routine will process
    all wmi requests received, forwarding them if they are not for this
    driver or determining if the guid is valid and if so passing it to
    the driver specific function for handing wmi requests.

Arguments:

    WmiLibInfo has the WMI information control block

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

    status

--*/

{
    return(STATUS_WMI_GUID_NOT_FOUND);
}

ULONG
WmlTrace(
    IN ULONG Type,
    IN LPVOID TraceGuid,
    IN ULONG64 LoggerHandle,
    ... // Pairs: Address, Length
    )
{
    return STATUS_SUCCESS;
}


ULONG
WmlPrintf(
    IN ULONG Type,
    IN LPCGUID TraceGuid,
    IN ULONG64 LoggerHandle,
    IN PCHAR FormatString,
    ... // printf var args
    )
{
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\exe\resource.h ===
// Used by smbrdr.rc
//
#define IDD_SMBRDR                      101
#define IDD_STATISTICS                  102
#define IDD_PROVIDER                    103
#define IDI_SMBRDR                      104
#define IDR_OPMENU                      105

#define IDC_DRVLOAD                     1000
#define IDC_DRVUNLOAD                   1001
#define IDC_RDRSTART                    1002
#define IDC_RDRSTOP                     1003
#define IDC_BUTTON1                     1004
#define IDC_PROVIDER                    1004
#define IDC_BUTTON2                     1005
#define IDC_STATISTICS                  1005
#define IDC_EDIT1                       1006
#define IDC_EDIT2                       1007
#define IDC_EDIT3                       1008
#define IDC_EDIT4                       1009
#define IDC_EDIT5                       1010
#define IDC_EDIT6                       1011
#define IDC_ORDERLIST                   1012
#define IDC_SETORDER					1013
#define IDC_EDIT7                       1015
#define IDC_EDIT8                       1016
#define IDC_DRVCONTROLTEXT				1017
#define IDC_RDRCONTROLTEXT				1018
#define IDC_SETTINGSTEXT				1019
#define IDC_LOADSTATUS					1020
#define IDC_STARTSTATUS					1021
#define IDC_STARTTIME					1022
#define IDC_HIDE						1023
#define IDC_BUSY						1024
#define IDC_MOVEUP						1025
#define IDC_MOVEDN						1026


#define IDM_OPEN						101
#define	IDM_CLOSE						102
#define	IDM_START						103
#define	IDM_STOP						104
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\exe\smbrdr.c ===
// SMBRDR.C

#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>
#include <shellapi.h>
#include <stdlib.h>
#include "srfunc.h"
#include "resource.h"


int WINAPI WinMain(
  HINSTANCE hInstance,  // handle to current instance
  HINSTANCE hPrevInstance,  // handle to previous instance
  LPSTR lpCmdLine,      // pointer to command line
  int nCmdShow          // show state of window
);

INT_PTR CALLBACK SmbRdrDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ProviderDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK StatisticsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


#define APP_TITLE       TEXT("SMB MiniRDR")
#define INSTALL_NOTICE  TEXT("Mini Redirector is not completely installed.\n") \
                        TEXT("Do you wish to complete this now?")
#define INSTALL_REPLY   TEXT("Sorry, the install must finish before using the SMB MiniRDR.")
#define INSTALL_FAIL    APP_TITLE TEXT(" installation failed to complete.")
#define INSTALL_FILES   APP_TITLE TEXT(" necessary files aren't present.")
#define INSTALL_OTHER   APP_TITLE TEXT(" not properly installed.")
#define NOSTATS         TEXT("Statistics display is unimplemented at this time.\n") \
                        TEXT("Please check back with the next version.")
#define OPERROR         TEXT("Error attempting operation.")

#define TASK_TIP        APP_TITLE TEXT(" Control")

#define WM_SHNOTIFY         WM_USER + 100
#define WM_RDRSTATECHANGE   WM_USER + 200

#define TIMER_ID    54321

typedef struct _DLGDATASTRUCT
{
    HWND hDlg;
    ULONG_PTR RdrState;
    HBRUSH    hRedBrush;
    HBRUSH    hGrnBrush;
    HBRUSH    hBluBrush;
    HBRUSH    hWhtBrush;
    HBRUSH    hYelBrush;
    HINSTANCE hInstance;
    ULONG_PTR ElapsedStartTime;
    ULONG_PTR Action;
    HANDLE    hActionThread;
    HANDLE    hBusyThread;
    HANDLE    hBusySignal;

} DLGDATASTRUCT, *PDLGDATASTRUCT;

VOID InitiateAction( PDLGDATASTRUCT pdds );
DWORD ActionProc( PDLGDATASTRUCT pdds );
VOID IndicateWait( PDLGDATASTRUCT pdds );
VOID UnindicateWait( PDLGDATASTRUCT pdds );
DWORD BusyProc( PDLGDATASTRUCT pdds );

#define GetDDS( _x_ )   (PDLGDATASTRUCT) GetWindowLongPtr( _x_, DWLP_USER )

int WINAPI WinMain(
  HINSTANCE hInstance,
  HINSTANCE hPrevInstance,
  LPSTR lpCmdLine,
  int nCmdShow)
{
    MSG msg;
    HANDLE hSingleInstance;

    msg.wParam = 1;

    hSingleInstance = CreateMutex( NULL, 0, APP_TITLE TEXT(" MUTEX") );

    if ( GetLastError( ) != ERROR_ALREADY_EXISTS )
    {
        BOOL RdrIsInstalled;
        ULONG_PTR SetupStatus;

        SetupStatus = RdrInstallCheck( );
        RdrIsInstalled = ( SetupStatus == SETUP_COMPLETE );

        if ( !RdrIsInstalled )
        {
            int answer;

            if ( SetupStatus == SETUP_INCOMPLETE )
            {
                answer = MessageBox( NULL, INSTALL_NOTICE, APP_TITLE, MB_YESNOCANCEL | MB_DEFBUTTON1 | MB_ICONEXCLAMATION );
                if ( answer == IDYES )
                {
                    if ( !( RdrIsInstalled = RdrCompleteSetup( ) ) )
                    {
                        MessageBox( NULL, INSTALL_FAIL, APP_TITLE, MB_OK | MB_ICONERROR );
                    }
                }
                else if ( answer == IDNO )
                {
                    MessageBox( NULL, INSTALL_REPLY, APP_TITLE, MB_OK | MB_ICONINFORMATION );
                }
            }
            else if ( SetupStatus == SETUP_MISSING_FILE )
            {
                MessageBox( NULL, INSTALL_FILES, APP_TITLE, MB_OK | MB_ICONERROR );
            }
            else
            {
                MessageBox( NULL, INSTALL_OTHER, APP_TITLE, MB_OK | MB_ICONERROR );
            }
        }

        if ( RdrIsInstalled )
        {
            HWND hDlg;

            DLGDATASTRUCT dds;

            dds.hRedBrush        = CreateSolidBrush( RGB( 255, 0, 0 ) );
            dds.hGrnBrush        = CreateSolidBrush( RGB( 0, 255, 0 ) );
            dds.hBluBrush        = CreateSolidBrush( RGB( 0, 0, 255 ) );
            dds.hWhtBrush        = CreateSolidBrush( RGB( 255, 255, 255 ) );
            dds.hYelBrush        = CreateSolidBrush( RGB( 255, 255, 127 ) );
            dds.hInstance        = hInstance;
            dds.ElapsedStartTime = 0;
            dds.Action           = 0;
            dds.hActionThread    = NULL;
            dds.hBusyThread      = NULL;
            dds.hBusySignal      = NULL;
            dds.hDlg             = NULL;

            dds.RdrState = RDR_NULL_STATE;

            hDlg = CreateDialogParam( hInstance, MAKEINTRESOURCE(IDD_SMBRDR), NULL, SmbRdrDlgProc, (LPARAM) &dds );
            if ( hDlg )
            {
                NOTIFYICONDATA nid;

                dds.hDlg = hDlg;

                nid.cbSize = sizeof( NOTIFYICONDATA );
                nid.hWnd = hDlg;
                nid.uFlags = NIF_ICON | NIF_TIP | NIF_MESSAGE; 
                nid.uID = IDI_SMBRDR;
                nid.uCallbackMessage = WM_SHNOTIFY;
                nid.hIcon = LoadIcon( hInstance, MAKEINTRESOURCE(IDI_SMBRDR ) );
                lstrcpy( nid.szTip, TASK_TIP );

                Shell_NotifyIcon( NIM_ADD, &nid );  
                PostMessage( hDlg, WM_SETICON, ICON_SMALL, (LPARAM) nid.hIcon );
                PostMessage( hDlg, WM_SETICON, ICON_BIG, (LPARAM) nid.hIcon );

                while ( GetMessage( &msg, NULL, 0, 0 ) ) 
                { 
                    if ( !IsWindow( hDlg ) || !IsDialogMessage( hDlg, &msg ) ) 
                    { 
                        TranslateMessage( &msg );
                        DispatchMessage( &msg );
                    } 
                }
                Shell_NotifyIcon( NIM_DELETE, &nid );   
                if ( nid.hIcon )
                {
                    DestroyIcon( nid.hIcon );
                }
            }

            DeleteObject( dds.hRedBrush );
            DeleteObject( dds.hGrnBrush );
            DeleteObject( dds.hBluBrush );
            DeleteObject( dds.hWhtBrush );
            DeleteObject( dds.hYelBrush );
            if ( dds.hActionThread )
            {
                WaitForSingleObject( dds.hActionThread, INFINITE );
                CloseHandle( dds.hActionThread );
                dds.hActionThread = NULL;
            }
        }
    }
    else
    {
        HWND hDlg = FindWindow( NULL, APP_TITLE );

        SetForegroundWindow( hDlg );
        if ( !IsWindowVisible( hDlg ) )
        {
            ShowWindow( hDlg, SW_SHOWNORMAL );
        }
    }

    CloseHandle( hSingleInstance );

    return (int) msg.wParam;
}


INT_PTR CALLBACK SmbRdrDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch ( message )
    {
    case WM_INITDIALOG:
        {
            PDLGDATASTRUCT pdds = (PDLGDATASTRUCT) lParam;
            RECT rect;
            ULONG_PTR CurrentState;

            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            CurrentState = RdrGetInitialState( );

            CheckRadioButton( hDlg, IDC_DRVLOAD, IDC_DRVUNLOAD,
                        CurrentState > RDR_UNLOADING ? IDC_DRVLOAD : IDC_DRVUNLOAD );
            CheckRadioButton( hDlg, IDC_RDRSTART, IDC_RDRSTOP,
                        CurrentState > RDR_STOPPING ? IDC_RDRSTART : IDC_RDRSTOP );
            pdds->Action = ACTION_NONE;
            PostMessage( hDlg, WM_RDRSTATECHANGE, 0, CurrentState );

            SetDlgItemText( hDlg, IDC_STARTTIME, TEXT( "00:00" ) );
            SetTimer( hDlg, TIMER_ID, 1000, NULL );

            GetWindowRect( hDlg, &rect );
            rect.right -= rect.left;
            rect.bottom -= rect.top;
            rect.left = ( GetSystemMetrics( SM_CXSCREEN ) - rect.right ) / 2;
            rect.top  = ( GetSystemMetrics( SM_CYSCREEN ) - rect.bottom ) / 3;
            MoveWindow( hDlg,
                        rect.left,
                        rect.top,
                        rect.right,
                        rect.bottom,
                        FALSE );
        }
        break;

    case WM_COMMAND:
    {
        PDLGDATASTRUCT pdds = GetDDS( hDlg );

        switch ( LOWORD( wParam ) )
        {
            case IDC_DRVLOAD:
            case IDC_DRVUNLOAD:
            {
                if ( HIWORD( wParam ) == BN_CLICKED )
                {
                    ULONG_PTR NewState, action;

                    action = ( IsDlgButtonChecked( hDlg, IDC_DRVLOAD ) == BST_CHECKED ) ?
                                ACTION_LOAD : ACTION_UNLOAD;
                    NewState = RdrGetNextState( action, pdds->RdrState );
                    if ( NewState != RDR_NULL_STATE )
                    {                       
                        pdds->Action = action;
                        PostMessage( hDlg, WM_RDRSTATECHANGE, 0, NewState );
                    }
                }
            }
            break;

            case IDC_RDRSTART:
            case IDC_RDRSTOP:
            {
                if ( HIWORD( wParam ) == BN_CLICKED )
                {
                    ULONG_PTR NewState, action;

                    action = ( IsDlgButtonChecked( hDlg, IDC_RDRSTART ) == BST_CHECKED ) ?
                                ACTION_START : ACTION_STOP;
                    NewState = RdrGetNextState( action, pdds->RdrState );
                    if ( NewState != RDR_NULL_STATE )
                    {                       
                        pdds->Action = action;
                        PostMessage( hDlg, WM_RDRSTATECHANGE, 0, NewState );
                    }
                }
            }
            break;

            case IDC_STATISTICS:
                MessageBox( hDlg, NOSTATS, APP_TITLE, MB_OK | MB_ICONINFORMATION );
                //DialogBox( pdds->hInstance, MAKEINTRESOURCE(IDD_STATISTICS), hDlg, StatisticsDlgProc );
                break;

            case IDC_PROVIDER:
                DialogBox( pdds->hInstance, MAKEINTRESOURCE(IDD_PROVIDER), hDlg, ProviderDlgProc );
                break;

            case IDC_HIDE:
            {
                PostMessage( hDlg, WM_SYSCOMMAND, SC_MINIMIZE, -1 );
            }
            break;
        }
    }
    break;

    case WM_RDRSTATECHANGE:
    {
        //Enter();
        PDLGDATASTRUCT pdds = GetDDS( hDlg );

        // must be a transitional state

        if ( (ULONG_PTR) lParam != pdds->RdrState )
        {
            pdds->RdrState = (ULONG_PTR) lParam;
            EnableWindow( GetDlgItem( hDlg, IDC_DRVLOAD ),
                    ( pdds->RdrState == RDR_UNLOADED )|| ( pdds->RdrState == RDR_LOADED ) || ( pdds->RdrState == RDR_STOPPED ));
            EnableWindow( GetDlgItem( hDlg, IDC_DRVUNLOAD ),
                    ( pdds->RdrState == RDR_UNLOADED )|| ( pdds->RdrState == RDR_LOADED ) || ( pdds->RdrState == RDR_STOPPED ));

            EnableWindow( GetDlgItem( hDlg, IDC_RDRSTART ),
                    (pdds->RdrState == RDR_LOADED )||(pdds->RdrState == RDR_STOPPED) || (pdds->RdrState == RDR_STARTED ) );
            EnableWindow( GetDlgItem( hDlg, IDC_RDRSTOP ),
                    (pdds->RdrState == RDR_LOADED )||(pdds->RdrState == RDR_STOPPED) || (pdds->RdrState == RDR_STARTED ) );

            switch ( lParam )
            {
                case RDR_UNLOADED:
                    SetDlgItemText( hDlg, IDC_LOADSTATUS, TEXT("Driver Unloaded" ) );
                    break;

                case RDR_UNLOADING:
                    SetDlgItemText( hDlg, IDC_LOADSTATUS, TEXT("Driver Unloading" ) );
                    InitiateAction( pdds );
                    break;

                case RDR_LOADING:
                    SetDlgItemText( hDlg, IDC_LOADSTATUS, TEXT("Driver Loading" ) );
                    InitiateAction( pdds );
                    break;
                case RDR_LOADED:
                    SetDlgItemText( hDlg, IDC_LOADSTATUS, TEXT("Driver Loaded" ) );
                    break;

                case RDR_STOPPING:
                    SetDlgItemText( hDlg, IDC_STARTSTATUS, TEXT("RDR Stopping" ) );
                    InitiateAction( pdds );
                    break;

                case RDR_STOPPED:
                    SetDlgItemText( hDlg, IDC_STARTSTATUS, TEXT("RDR Stopped" ) );
                    pdds->ElapsedStartTime = 0;
                    SetDlgItemText( hDlg, IDC_STARTTIME, TEXT( "00:00" ) );
                    break;

                case RDR_STARTING:
                    SetDlgItemText( hDlg, IDC_STARTSTATUS, TEXT("RDR Starting" ) );
                    InitiateAction( pdds );
                    break;

                case RDR_STARTED:
                    SetDlgItemText( hDlg, IDC_STARTSTATUS, TEXT("RDR Started" ) );
                    break;

                default:
                    break;
            }
        }
        if ( pdds->Action == ACTION_ERROR )
        {
            MessageBox( hDlg, OPERROR, APP_TITLE, MB_OK | MB_ICONERROR );
        }
//Leave();
    }
    break;

    case WM_TIMER:
    {
        TCHAR timestring[8];

        PDLGDATASTRUCT pdds = GetDDS( hDlg );
        if ( wParam == TIMER_ID && pdds->RdrState > RDR_STOPPED )
        {
            pdds->ElapsedStartTime++;
            wsprintf( timestring, TEXT("%02d:%02d"), pdds->ElapsedStartTime / 60,
                        pdds->ElapsedStartTime % 60 );
            SetDlgItemText( hDlg, IDC_STARTTIME, timestring );
        }
    }
    break;

    case WM_CTLCOLORSTATIC:
    {
        PDLGDATASTRUCT pdds = GetDDS( hDlg );
        HBRUSH hBkBrush;

        switch ( GetWindowLongPtr( (HWND) lParam, GWL_ID ) )
        {
            case IDC_DRVCONTROLTEXT:
            case IDC_RDRCONTROLTEXT:
            case IDC_SETTINGSTEXT:
                SetBkMode( (HDC) wParam, TRANSPARENT );
                hBkBrush = pdds->hWhtBrush;
                break;

            case IDC_LOADSTATUS:
            {
                SetBkMode( (HDC) wParam, TRANSPARENT );
                if ( pdds->RdrState < RDR_UNLOADING )
                {
                    hBkBrush = pdds->hRedBrush;
                }
                else if (  pdds->RdrState < RDR_LOADED )
                {
                    hBkBrush = pdds->hYelBrush;
                }
                else
                {
                    hBkBrush = pdds->hGrnBrush;
                }
            }
            break;

            case IDC_STARTSTATUS:
            {
                SetBkMode( (HDC) wParam, TRANSPARENT );
                if ( pdds->RdrState < RDR_STOPPING )
                {
                    hBkBrush = pdds->hRedBrush;
                }
                else if (  pdds->RdrState < RDR_STARTED )
                {
                    hBkBrush = pdds->hYelBrush;
                }
                else
                {
                    hBkBrush = pdds->hGrnBrush;
                }
            }
            break;

            case IDC_BUSY:
            default:
                hBkBrush = (HBRUSH) FALSE;
                break;
        }

        return (INT_PTR) hBkBrush;
    }
    break;


    case WM_SETICON:
    {
        // catch it on the second pass so it has the previous icon to now draw
        if ( wParam == ICON_BIG )
        {
            ShowWindow( hDlg, SW_SHOWNORMAL );
        }
    }
    break;

    case WM_SHNOTIFY:
    {
        if ( wParam == IDI_SMBRDR )
        {
            if ( lParam == WM_LBUTTONDBLCLK )
            {
                if ( IsWindowVisible( hDlg ) )
                {
                    SetForegroundWindow( hDlg );
                }
                else
                {
                    ShowWindow( hDlg, SW_RESTORE );
                }
            }
            else if ( lParam == WM_RBUTTONDOWN && !IsWindowVisible( hDlg ) )
            {
                HMENU hPopup = CreatePopupMenu( );
                POINT cursorpos;
                HWND hfgrd;
                ULONG_PTR popselect;
                                                
                GetCursorPos( &cursorpos );

                if ( hPopup )
                {
                    PDLGDATASTRUCT pdds = GetDDS( hDlg );
                    MENUITEMINFO mii;
                    
                    ZeroMemory( &mii, sizeof( MENUITEMINFO ) );
                    mii.cbSize = sizeof( MENUITEMINFO );
                    mii.fMask = MIIM_DATA | MIIM_ID | MIIM_TYPE;
                    mii.fType = MFT_STRING;

                    mii.wID = IDM_OPEN;
                    mii.fState = MFS_DEFAULT;
                    mii.fMask |= MIIM_STATE;
                    mii.dwTypeData = TEXT("Open ") APP_TITLE TEXT(" Control");
                    InsertMenuItem( hPopup, 0, TRUE, &mii );

                    mii.wID = IDM_CLOSE;
                    mii.fMask &= ~MIIM_STATE;
                    mii.fState &= ~MFS_DEFAULT;
                    mii.dwTypeData = TEXT("Exit");
                    InsertMenuItem( hPopup, 1, TRUE, &mii );

                    if ( ( pdds->RdrState == RDR_STOPPED ) ||
                            (pdds->RdrState == RDR_STARTED ) ||
                            (pdds->RdrState == RDR_LOADED ) )
                    {
                        mii.wID = 0;
                        mii.fMask = MIIM_TYPE;
                        mii.dwTypeData = NULL;
                        mii.fType = MFT_SEPARATOR;
                        InsertMenuItem( hPopup, 2, TRUE, &mii );

                        mii.fType = MFT_STRING;
                        mii.fMask = MIIM_DATA | MIIM_ID | MIIM_TYPE;
                        if ( ( pdds->RdrState == RDR_STOPPED ) ||
                                (pdds->RdrState == RDR_LOADED ) )
                        {
                            mii.wID = IDM_START;
                            mii.dwTypeData = TEXT( "Start the RDR" );
                            InsertMenuItem( hPopup, 3, TRUE, &mii );
                        }
                        else if ( pdds->RdrState == RDR_STARTED )
                        {
                            mii.wID = IDM_STOP;
                            mii.dwTypeData = TEXT( "Stop the RDR" );
                            InsertMenuItem( hPopup, 3, TRUE, &mii );
                        }
                    }

                    SetActiveWindow( hDlg );

                    popselect = TrackPopupMenu( hPopup,
                                      TPM_LEFTBUTTON | TPM_RIGHTALIGN | TPM_BOTTOMALIGN |
                                      TPM_NONOTIFY | TPM_RETURNCMD,
                                      cursorpos.x,
                                      cursorpos.y,
                                      0,
                                      hDlg,
                                      NULL );
                    DestroyMenu( hPopup );

                    switch ( popselect )
                    {
                        case IDM_OPEN:
                        {
                            ShowWindow( hDlg, SW_SHOWNORMAL );
                        }
                        break;

                        case IDM_CLOSE:
                        {
                            PostMessage( hDlg, WM_CLOSE, 0, 0 );
                        }
                        break;

                        case IDM_START:
                        {
                            CheckRadioButton( hDlg, IDC_RDRSTART, IDC_RDRSTOP, IDC_RDRSTART );
                            PostMessage( hDlg, WM_COMMAND, MAKELONG(IDC_RDRSTART, BN_CLICKED),
                                        (LPARAM) GetDlgItem( hDlg, IDC_RDRSTART) );
                        }
                        break;

                        case IDM_STOP:
                        {
                            CheckRadioButton( hDlg, IDC_RDRSTART, IDC_RDRSTOP, IDC_RDRSTOP );
                            PostMessage( hDlg, WM_COMMAND, MAKELONG(IDC_RDRSTOP, BN_CLICKED),
                                        (LPARAM) GetDlgItem( hDlg, IDC_RDRSTOP) );
                        }
                        break;

                        default:
                            break;
                    }
                }
            }
        }
    }
    break;

    case WM_SYSCOMMAND:
    {
        if ( wParam == SC_MINIMIZE )
        {
            ShowWindow( hDlg, SW_HIDE );
            return TRUE;            
        }   
    }
    break;

    case WM_CLOSE:
    {
        PDLGDATASTRUCT pdds = GetDDS( hDlg );

        if ( pdds->hActionThread )
        {
            if ( WaitForSingleObject( pdds->hActionThread, 0 ) != WAIT_OBJECT_0 )
            {
                return TRUE;
            }
        }
        if ( pdds->RdrState == RDR_STARTED )
        {
            return TRUE;
        }
        DestroyWindow( hDlg );
    }
    break;

    case WM_DESTROY:
        KillTimer( hDlg, TIMER_ID );
        PostQuitMessage( 0 );
        break;
    }

    return 0;
}


INT_PTR CALLBACK ProviderDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {

        case WM_INITDIALOG:
        {
            ULONG_PTR count, len, nIndex;
            LPTSTR OrderString = NULL, marker, ptr;

#if 0 // #ifdef UNICODE
            TCHAR btntext[10];

            btntext[0] = 0x25b2;    // up arrow in unicode char set
            lstrcpy( &btntext[1], TEXT(" Move Up" ));
            SetDlgItemText( hDlg, IDC_MOVEUP, btntext );
            btntext[0] = 0x25bc;    // down arrow in unicode char set
            lstrcpy( &btntext[1], TEXT(" Move Dn" ));
            SetDlgItemText( hDlg, IDC_MOVEDN, btntext );
#endif

            len = RdrGetProviderOrderString( &OrderString );
            marker = OrderString;

            for ( count = 0, ptr = OrderString; ptr && count <= len; count++, ptr++ )
            {
                switch ( *ptr )
                {
                    case TEXT(','):
                    {
                        if ( count > 0 && ptr > marker )
                        {
                            *ptr = TEXT('\0');
                            SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_ADDSTRING, 0, (LPARAM) marker );
                            *ptr = TEXT(',');
                        }
                        marker = ptr + 1;
                    }
                    break;

                    case TEXT('\0'):
                    {
                        if ( count > 0 && ptr > marker )
                        {
                            SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_ADDSTRING, 0, (LPARAM) marker );
                        }
                    }
                    break;

                    case TEXT(' '):
                        marker = ptr + 1;
                        break;

                    default:
                        break;
                }
            }
            if ( OrderString )
            {
                free( OrderString );
            }
            nIndex = SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_FINDSTRING,
                        (WPARAM) -1, (LPARAM) PROVIDER_NAME );
            SetWindowLongPtr( hDlg, DWLP_USER, nIndex );
            if ( nIndex == LB_ERR)
            {
                nIndex = 0;
                EnableWindow( GetDlgItem( hDlg, IDC_MOVEUP ), FALSE );
                EnableWindow( GetDlgItem( hDlg, IDC_MOVEDN ), FALSE );
            }
            SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_SETCURSEL,
                            (WPARAM) nIndex, 0 );
            
        }
        break;

        case WM_COMMAND:
        {
            switch ( LOWORD( wParam ) )
            {
                case IDC_ORDERLIST:
                {
                    if ( HIWORD( wParam ) == LBN_SELCHANGE )
                    {
                        ULONG_PTR staticsel, cursel;

                        staticsel = GetWindowLongPtr( hDlg, DWLP_USER );
                        cursel = SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_GETCURSEL, 0, 0 );
                        if ( staticsel != cursel && staticsel != LB_ERR )
                        {
                            SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_SETCURSEL,
                                            (WPARAM) staticsel, 0 );

                        }
                    }
                }
                break;

                case IDC_MOVEUP:
                case IDC_MOVEDN:
                {
                        ULONG_PTR staticsel, items, len;
                        LPTSTR pstr;

                        staticsel = GetWindowLongPtr( hDlg, DWLP_USER );
                        items = SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_GETCOUNT,0 ,0 );
                        if ( staticsel != LB_ERR && items != LB_ERR )
                        {
                            len = SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_GETTEXTLEN, staticsel, 0 );
                            pstr = malloc( (len + 1 ) * sizeof(TCHAR) );
                            if ( pstr )
                            {
                                if ( LOWORD( wParam ) == IDC_MOVEUP && staticsel > 0 )
                                {
                                     SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_GETTEXT, staticsel, (LPARAM) pstr );
                                     SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_DELETESTRING, staticsel, 0 );
                                     SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_INSERTSTRING, --staticsel, (LPARAM) pstr );
                                }
                                else if ( (LOWORD( wParam ) == IDC_MOVEDN) && (items > 0) && (staticsel < (items - 1) ) )
                                {
                                     SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_GETTEXT, staticsel, (LPARAM) pstr );
                                     SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_DELETESTRING, staticsel, 0 );
                                     SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_INSERTSTRING, ++staticsel, (LPARAM) pstr );
                                }
                                free( pstr );
                                SetWindowLongPtr( hDlg, DWLP_USER, staticsel );
                                SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_SETCURSEL, staticsel, 0 );
                            }
                        }
                }
                break;

                case IDOK:
                {
                    LPTSTR OrderString, pstr;
                    ULONG_PTR items, len = 0, index;

                    items = SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_GETCOUNT,0 ,0 );
                    if ( items != LB_ERR )
                    {
                        for ( index = 0; items > 0 && index < items; index++ )
                        {
                            len += SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_GETTEXTLEN, index, 0 );
                        }
                        len += items;   //commas and ending null
                        OrderString = pstr = malloc( len * sizeof( TCHAR ) );
                        if ( OrderString )
                        {
                            for ( index = 0; items > 0 && index < items; index++ )
                            {
                                len = SendDlgItemMessage( hDlg, IDC_ORDERLIST, LB_GETTEXT, index, (LPARAM) pstr );
                                pstr += len;
                                *pstr++ = ( index < ( items - 1 ) ) ? TEXT(',') : TEXT('\0');
                            }
                            RdrSetProviderOrderString( OrderString );
                            free( OrderString );
                        }
                    }
                }

                case IDCANCEL:
                    PostMessage( hDlg, WM_CLOSE, 0, 0 );
                    break;
            }
        }
        break;
                
        case WM_CLOSE:
            EndDialog( hDlg, 0 );
            break;
    }

    return FALSE;
}

INT_PTR CALLBACK StatisticsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_COMMAND:
        {
            switch ( LOWORD( wParam ) )
            {
                case IDOK:
                    PostMessage( hDlg, WM_CLOSE, 0, 0 );
                    break;
            }
        }
        break;

        case WM_CLOSE:
            EndDialog( hDlg, 0 );
            break;
    }

    return FALSE;
}

VOID IndicateWait( PDLGDATASTRUCT pdds )
{
    pdds->hBusySignal = CreateEvent( NULL, FALSE, FALSE, NULL );                    
    pdds->hBusyThread = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE) BusyProc, pdds, 0, NULL );
}

VOID UnindicateWait( PDLGDATASTRUCT pdds )
{
    SetEvent( pdds->hBusySignal );
    WaitForSingleObject( pdds->hBusyThread, 1000 );
    CloseHandle( pdds->hBusyThread );
    CloseHandle( pdds->hBusySignal );
    pdds->hBusyThread = NULL;
    pdds->hBusySignal = NULL;
}

VOID InitiateAction( PDLGDATASTRUCT pdds )
{
    if ( pdds->hActionThread )
    {
        WaitForSingleObject( pdds->hActionThread, INFINITE );
        CloseHandle( pdds->hActionThread );
        pdds->hActionThread = NULL;
    }
    //pdds->Action = ACTION_TRANS;
    pdds->hActionThread = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE) ActionProc, pdds, 0, NULL );
}

DWORD ActionProc( PDLGDATASTRUCT pdds )
{
    ULONG_PTR newstate;
    BOOL success;

    IndicateWait( pdds );
    success = RdrDoAction( pdds->Action );
    UnindicateWait( pdds );

    pdds->Action = success ? ACTION_TRANS : ACTION_ERROR;
    newstate = RdrGetNextState( pdds->Action, pdds->RdrState );
    PostMessage( pdds->hDlg, WM_RDRSTATECHANGE, 0, newstate );

    return 0;
}


DWORD BusyProc( PDLGDATASTRUCT pdds )
{
    HDC hDC;
    HWND hBusyWnd = GetDlgItem( pdds->hDlg, IDC_BUSY );
    ULONG pos = 0, width;
    RECT clRect, mRect;

    GetClientRect( hBusyWnd, &clRect );

    mRect.left   = clRect.left;
    mRect.top    = clRect.top + clRect.bottom / 6;
    mRect.right  = width = clRect.right / 8;
    mRect.bottom = clRect.bottom - clRect.bottom / 6;

    while ( WaitForSingleObject( pdds->hBusySignal, 100 ) == WAIT_TIMEOUT )
    {
        hDC = GetDC( hBusyWnd );
        FillRect( hDC, &clRect, pdds->hWhtBrush );
        FillRect( hDC, &mRect, pdds->hBluBrush );
        mRect.left += width;
        mRect.right += width;           

        if ( mRect.right > clRect.right )
        {
            mRect.left = 0;
            mRect.right = width;            
        }
        ReleaseDC( hBusyWnd, hDC );
    }
    InvalidateRect( hBusyWnd, NULL, TRUE );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\3connect.c ===
/*++
Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    3connect.c

Abstract:

    This module implements the tree connect SMB related routines. It also implements the
    three flavours of this routine ( user level and share level non NT server tree connect
    SMB construction and the tree connect SMB construction for SMB servers)

--*/

#include "precomp.h"
#pragma hdrstop

//
// The order of these names should match the order in which the enumerated type
// NET_ROOT_TYPE is defined. This facilitates easy access of share type names
//

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BuildCanonicalNetRootInformation)
#pragma alloc_text(PAGE, CoreBuildTreeConnectSmb)
#pragma alloc_text(PAGE, LmBuildTreeConnectSmb)
#pragma alloc_text(PAGE, NtBuildTreeConnectSmb)
#endif

PCHAR s_NetRootTypeName[] = {
                              SHARE_TYPE_NAME_DISK,
                              SHARE_TYPE_NAME_PIPE,
                              SHARE_TYPE_NAME_COMM,
                              SHARE_TYPE_NAME_PRINT,
                              SHARE_TYPE_NAME_WILD
                            };

extern NTSTATUS
BuildTreeConnectSecurityInformation(
    PSMB_EXCHANGE  pExchange,
    PBYTE          pBuffer,
    PBYTE          pPasswordLength,
    PULONG         pSmbBufferSize);

NTSTATUS
BuildCanonicalNetRootInformation(
    PUNICODE_STRING     pServerName,
    PUNICODE_STRING     pNetRootName,
    NET_ROOT_TYPE       NetRootType,
    BOOLEAN             fUnicode,
    BOOLEAN             fPostPendServiceString,
    PBYTE               *pBufferPointer,
    PULONG              pBufferSize)
/*++

Routine Description:

   This routine builds the desired net root information for a tree connect SMB

Arguments:

    pServerName    - the server name

    pNetRootName   - the net root name

    NetRootType    - the net root type ( print,pipe,disk etc.,)

    fUnicode       - TRUE if it is to be built in UNICODE

    pBufferPointer - the SMB buffer

    pBufferSize    - the size on input. modified to the remaining size on output

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine relies upon the names being in certain formats to ensure that a
    valid UNC name can be formulated.
    1) The RDBSS netroot names start with a \ and also include the server name as
    part of the net root name. This is mandated by the prefix table search requirements
    in RDBSS.

--*/
{
   NTSTATUS Status;

   PAGED_CODE();

   if (fUnicode) {
      // Align the buffer and adjust the size accordingly.
      PBYTE    pBuffer = *pBufferPointer;
      RxDbgTrace( 0, (DEBUG_TRACE_CREATE),
                     ("BuildCanonicalNetRootInformation -- tcstring as unicode %wZ\n", pNetRootName));
      pBuffer = ALIGN_SMB_WSTR(pBuffer);
      *pBufferSize -= (ULONG)(pBuffer - *pBufferPointer);
      *pBufferPointer = pBuffer;

      *((PWCHAR)*pBufferPointer) = L'\\';
      *pBufferPointer = *pBufferPointer + sizeof(WCHAR);
      *pBufferSize -= sizeof(WCHAR);
      Status = SmbPutUnicodeStringAndUpcase(pBufferPointer,pNetRootName,pBufferSize);
   } else {
      RxDbgTrace( 0, (DEBUG_TRACE_CREATE), ("BuildCanonicalNetRootInformation -- tcstring as ascii\n"));
      *((PCHAR)*pBufferPointer) = '\\';
      *pBufferPointer += sizeof(CHAR);
      *pBufferSize -= sizeof(CHAR);
      Status = SmbPutUnicodeStringAsOemStringAndUpcase(pBufferPointer,pNetRootName,pBufferSize);
   }

   if (NT_SUCCESS(Status) && fPostPendServiceString) {
      // Put the desired service name in ASCII ( always )
      ULONG Length = strlen(s_NetRootTypeName[NetRootType]) + 1;
      if (*pBufferSize >= Length) {
         RtlCopyMemory(*pBufferPointer,s_NetRootTypeName[NetRootType],Length);
         *pBufferSize -= Length;
      } else {
         Status = STATUS_BUFFER_OVERFLOW;
      }
   }

   return Status;
}


NTSTATUS
CoreBuildTreeConnectSmb(
    PSMB_EXCHANGE     pExchange,
    PGENERIC_ANDX     pAndXSmb,
    PULONG            pAndXSmbBufferSize)
/*++

Routine Description:

   This routine builds the tree connect SMB for a pre NT server

Arguments:

    pExchange          -  the exchange instance

    pAndXSmb           - the tree connect to be filled in...it's not really a andX

    pAndXSmbBufferSize - the SMB buffer size on input modified to remaining size on
                         output.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    USHORT   PasswordLength;

    PMRX_NET_ROOT NetRoot;

    UNICODE_STRING ServerName;
    UNICODE_STRING NetRootName;

    PSMBCE_SERVER  pServer;

    PREQ_TREE_CONNECT      pTreeConnect = (PREQ_TREE_CONNECT)pAndXSmb;

    ULONG OriginalBufferSize = *pAndXSmbBufferSize;

    BOOLEAN   AppendServiceString;
    PBYTE pBuffer;
    PCHAR ServiceName;
    ULONG Length;

    PAGED_CODE();

    NetRoot = pExchange->SmbCeContext.pVNetRoot->pNetRoot;

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS),
        ("CoreBuildTreeConnectSmb buffer,remptr %08lx %08lx, nrt=%08lx\n",
         pAndXSmb,
         pAndXSmbBufferSize,
         NetRoot->Type));

    pServer = SmbCeGetExchangeServer(pExchange);
    SmbCeGetServerName(NetRoot->pSrvCall,&ServerName);
    SmbCeGetNetRootName(NetRoot,&NetRootName);
    ServiceName = s_NetRootTypeName[NetRoot->Type];
    Length = strlen(ServiceName) + 1;

    pTreeConnect->WordCount = 0;
    AppendServiceString     = FALSE;
    pBuffer = (PBYTE)pTreeConnect + FIELD_OFFSET(REQ_TREE_CONNECT,Buffer);
    *pBuffer = 0x04;
    pBuffer++;
    *pAndXSmbBufferSize -= (FIELD_OFFSET(REQ_TREE_CONNECT,Buffer)+1);

    // put in the netname

    //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb before bcnri buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
    Status = BuildCanonicalNetRootInformation(
                 &ServerName,
                 &NetRootName,
                 pExchange->SmbCeContext.pVNetRoot->pNetRoot->Type,
                 (BOOLEAN)(pServer->Dialect >= NTLANMAN_DIALECT),
                 AppendServiceString,
                 &pBuffer,
                 pAndXSmbBufferSize);

    if (!NT_SUCCESS(Status))
        return Status;

    // put in the password
    pBuffer = (PBYTE)pTreeConnect + OriginalBufferSize - *pAndXSmbBufferSize;
    //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb88 buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));

    *pBuffer = 0x04;
    pBuffer++;
    *pAndXSmbBufferSize -= 1;

    if (pServer->SecurityMode == SECURITY_MODE_SHARE_LEVEL) {
        // The password information needs to be sent as part of the tree connect
        // SMB for share level servers.

        //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb before btcsi buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
        Status = BuildTreeConnectSecurityInformation(
                     pExchange,
                     pBuffer,
                     (PBYTE)&PasswordLength,
                     pAndXSmbBufferSize);
    }

    // string in the service string based on the netroot type

    //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb beforesscopy buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
    pBuffer = (PBYTE)pTreeConnect + OriginalBufferSize - *pAndXSmbBufferSize;
    *pBuffer = 0x04;
    pBuffer++;
    *pAndXSmbBufferSize -= 1;
    if (*pAndXSmbBufferSize >= Length) {
        RtlCopyMemory(pBuffer,ServiceName,Length);
        *pAndXSmbBufferSize -= Length;
    } else {
        Status = STATUS_BUFFER_OVERFLOW;
    }

    //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb beforesscopy buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
    SmbPutUshort(
        &pTreeConnect->ByteCount,
        (USHORT)(OriginalBufferSize
                 - *pAndXSmbBufferSize
                 - FIELD_OFFSET(REQ_TREE_CONNECT,Buffer)
                )
        );

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("CoreBuildTreeConnectSmb end buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
    return Status;
}


NTSTATUS
LmBuildTreeConnectSmb(
    PSMB_EXCHANGE     pExchange,
    PGENERIC_ANDX     pAndXSmb,
    PULONG            pAndXSmbBufferSize)
/*++

Routine Description:

   This routine builds the tree connect SMB for a pre NT server

Arguments:

    pExchange          -  the exchange instance

    pAndXSmb           - the tree connect to be filled in...it's not really a andX

    pAndXSmbBufferSize - the SMB buffer size on input modified to remaining size on
                         output.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    USHORT   PasswordLength;

    PMRX_NET_ROOT NetRoot;

    UNICODE_STRING ServerName;
    UNICODE_STRING NetRootName;

    PSMBCE_SERVER  pServer;

    PREQ_TREE_CONNECT_ANDX pTreeConnectAndX = (PREQ_TREE_CONNECT_ANDX)pAndXSmb;

    ULONG OriginalBufferSize = *pAndXSmbBufferSize;

    BOOLEAN   AppendServiceString;
    PBYTE pBuffer;
    PCHAR ServiceName;
    ULONG Length;

    PAGED_CODE();

    NetRoot = pExchange->SmbCeContext.pVNetRoot->pNetRoot;
    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS),
        ("LmBuildTreeConnectSmb buffer,remptr %08lx %08lx, nrt=%08lx\n",
          pAndXSmb,
          pAndXSmbBufferSize,
          NetRoot->Type));

    pServer = SmbCeGetExchangeServer(pExchange);
    SmbCeGetServerName(NetRoot->pSrvCall,&ServerName);
    SmbCeGetNetRootName(NetRoot,&NetRootName);
    ServiceName = s_NetRootTypeName[NetRoot->Type];
    Length = strlen(ServiceName) + 1;

    AppendServiceString         = TRUE;
    pTreeConnectAndX->WordCount = 4;
    SmbPutUshort(&pTreeConnectAndX->AndXReserved,0);
    SmbPutUshort(
        &pTreeConnectAndX->Flags,0);
    pBuffer = (PBYTE)pTreeConnectAndX + FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer);
    *pAndXSmbBufferSize -= (FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer)+1);

    if (pServer->SecurityMode == SECURITY_MODE_SHARE_LEVEL) {
        // The password information needs to be sent as part of the tree connect
        // SMB for share level servers.

        //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("LmBuildTreeConnectSmb before btcsi buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));
        Status = BuildTreeConnectSecurityInformation(
                     pExchange,
                     pBuffer,
                     (PBYTE)&PasswordLength,
                     pAndXSmbBufferSize);

        if (Status == STATUS_SUCCESS) {
            pBuffer += PasswordLength;
            SmbPutUshort(&pTreeConnectAndX->PasswordLength,PasswordLength);
        }
    } else {
        pBuffer = (PBYTE)pTreeConnectAndX + FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer);
        *pAndXSmbBufferSize -= FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer);

        // No password is required for user level security servers as part of tree
        // connect
        SmbPutUshort(&pTreeConnectAndX->PasswordLength,0x1);
        *((PCHAR)pBuffer) = '\0';
        pBuffer    += sizeof(CHAR);
        *pAndXSmbBufferSize -= sizeof(CHAR);
        Status = STATUS_SUCCESS;
    }

    if (Status == STATUS_SUCCESS) {
        Status = BuildCanonicalNetRootInformation(
                     &ServerName,
                     &NetRootName,
                     pExchange->SmbCeContext.pVNetRoot->pNetRoot->Type,
                     (BOOLEAN)(pServer->Dialect >= NTLANMAN_DIALECT),
                     AppendServiceString,
                     &pBuffer,
                     pAndXSmbBufferSize);

      //RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("LmBuildTreeConnectSmb beforesscopy buffer,rem %08lx %08lx\n",pBuffer,*pAndXSmbBufferSize));

        if (Status == STATUS_SUCCESS) {
            SmbPutUshort(
                &pTreeConnectAndX->ByteCount,
                (USHORT)(OriginalBufferSize
                         - *pAndXSmbBufferSize
                         - FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer)
                        )
                );
        }

        RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS),
            ("LmBuildTreeConnectSmb end buffer,rem %08lx %08lx\n",
             pBuffer,
             *pAndXSmbBufferSize));
    }

    return Status;
}

NTSTATUS
NtBuildTreeConnectSmb(
    PSMB_EXCHANGE     pExchange,
    PGENERIC_ANDX     pAndXSmb,
    PULONG            pAndXSmbBufferSize)
/*++

Routine Description:

   This routine builds the tree connect SMB for a pre NT server

Arguments:

    pExchange  - the exchange instance

    pAndXSmb - the session setup to be filled in

    pAndXSmbBufferSize - the SMB buffer size on input modified to remaining size on
                         output.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING ServerName;
    UNICODE_STRING NetRootName;

    PSMBCE_SERVER  pServer;

    PREQ_TREE_CONNECT_ANDX pTreeConnect = (PREQ_TREE_CONNECT_ANDX)pAndXSmb;

    ULONG OriginalBufferSize = *pAndXSmbBufferSize;
    PBYTE pBuffer;
    ULONG BufferSize;

    PAGED_CODE();

    BufferSize = OriginalBufferSize;

    pServer = SmbCeGetExchangeServer(pExchange);

    SmbCeGetServerName(pExchange->SmbCeContext.pVNetRoot->pNetRoot->pSrvCall,&ServerName);
    SmbCeGetNetRootName(pExchange->SmbCeContext.pVNetRoot->pNetRoot,&NetRootName);

    pTreeConnect->AndXCommand = 0xff;   // No ANDX
    pTreeConnect->AndXReserved = 0x00;  // Reserved (MBZ)

    SmbPutUshort(&pTreeConnect->AndXOffset, 0x0000); // No AndX as of yet.

    pTreeConnect->WordCount = 4;

    SmbPutUshort( &pTreeConnect->Flags, 0 );

    pBuffer = (PBYTE)pTreeConnect + FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer);
    BufferSize -=  FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer);

    if(pServer->SecurityMode == SECURITY_MODE_USER_LEVEL){
        // No password information is required as part of tree connect for user level
        // security servers. Therefore send a null string as the password.
        SmbPutUshort(&pTreeConnect->PasswordLength,0x1);

        *((PCHAR)pBuffer) = '\0';
        pBuffer    += sizeof(CHAR);
        BufferSize -= sizeof(CHAR);
    } else {
        USHORT PasswordLength;
        //plug in the password for this server.....qweee
        Status = BuildTreeConnectSecurityInformation(
                     pExchange,
                     pBuffer,
                     (PBYTE)&PasswordLength,
                     &BufferSize);

        if (Status == STATUS_SUCCESS ) {
            pBuffer += PasswordLength;
            SmbPutUshort(&pTreeConnect->PasswordLength,PasswordLength);
        }
    }

    if (NT_SUCCESS(Status)) {
        Status = BuildCanonicalNetRootInformation(
                     &ServerName,
                     &NetRootName,
                     NET_ROOT_WILD, //let the server tell us!  pNetRoot->Type,
                     BooleanFlagOn(pServer->DialectFlags,DF_UNICODE),
                     TRUE, //postpend the service string
                     &pBuffer,
                     &BufferSize);
    }

    if (NT_SUCCESS(Status)) {
        SmbPutUshort(
            &pTreeConnect->ByteCount,
            (USHORT)(OriginalBufferSize -
             FIELD_OFFSET(REQ_TREE_CONNECT_ANDX,Buffer) -
             BufferSize));
    }

    // update the buffer size to reflect the amount consumed.
    *pAndXSmbBufferSize = BufferSize;

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\exe\srfunc.h ===
/*++

Copyright (c) 1997 - 1999  Microsoft Corporation

Module Name:

    srfunc.h

Abstract:

--*/

#include "smbmrx.h"

typedef struct {
    LPTSTR pszKey;
    DWORD  dwType;
    DWORD  dwLength;
    PVOID  pvValue;
} REGENTRY, *PREGENTRY;

void
ReadRegistryKeyValues(
    HKEY hKey,
    DWORD Count,
    PREGENTRY pValues);

void
WriteRegistryKeyValues(
    HKEY hKey,
    DWORD Count,
    PREGENTRY pValues);


//
// routines for manipulating registry key values
//

BOOL  GetRegsz ( HKEY hKey, LPTSTR pszKey, PVOID * ppvValue, DWORD *pdwLength );
BOOL  GetRegesz( HKEY hKey, LPTSTR pszKey, PVOID * ppvValue, DWORD *pdwLength );
BOOL  GetRegmsz( HKEY hKey, LPTSTR pszKey, PVOID * ppvValue, DWORD *pdwLength );
BOOL  GetRegdw ( HKEY hKey, LPTSTR pszKey, PVOID * ppvValue, DWORD *pdwLength );

//
// routines for manipulating registry keys
//

BOOL  OpenKey(LPTSTR pszKey, PHKEY phKey);
BOOL  CreateKey(LPTSTR pszKey, PHKEY phKey);
BOOL  AddValue(HKEY hKey, LPTSTR pszKey, DWORD dwType, DWORD dwLength, PVOID pvValue);

ULONG_PTR RdrInstallCheck( void );
BOOL      RdrCompleteSetup( void );


BOOL      RdrInitGlobalContext( void );
BOOL      RdrUninitGlobalContext( void );

BOOL      RdrStart( void );
BOOL      RdrStop( void );
BOOL      RdrLoad( void );
BOOL      RdrUnload( void );
BOOL      RdrDoNothing( void );
BOOL      RdrDoAction( ULONG_PTR action );

ULONG_PTR RdrGetInitialState(void);
ULONG_PTR RdrGetNextState( ULONG_PTR Action, ULONG_PTR CurrentState );

BOOL      RdrSetupServiceEntry( void );
BOOL      RdrSetupProviderOrder( void );

ULONG_PTR RdrGetProviderOrderString( LPTSTR *OrderString );
BOOL      RdrSetProviderOrderString( LPTSTR OrderString );
BOOL      RdrFindProviderInOrder( LPTSTR OrderString, LPTSTR Provider );


typedef BOOL (*ACTIONVECTOR) ( void );

#define RDRSERVICE          TEXT("SmbMRx")
#define PROVIDER_NAME       RDRSERVICE
#define PROVIDER_PATH       TEXT("%SystemRoot%\\System32\\SmbMrxNp.dll")

#define PROVIDER_FILE_PATH  TEXT("\\System32\\SmbMrxNp.dll")
#define DRIVER_FILE_PATH    TEXT("\\System32\\Drivers\\SmbMrx.sys")

#define PROVIDER_ORDER_KEY  TEXT("System\\CurrentControlSet\\Control\\NetworkProvider\\Order")
#define RDRSERVICE_KEY      TEXT("System\\CurrentControlSet\\Services\\") RDRSERVICE
#define WKSSERVICE_KEY      TEXT("System\\CurrentControlSet\\Services\\LanmanWorkstation")


#define SETUP_COMPLETE      0
#define SETUP_MISSING_FILE  1
#define SETUP_INCOMPLETE    2



#define ACTION_LOAD     0
#define ACTION_UNLOAD   1
#define ACTION_START    2
#define ACTION_STOP     3
#define ACTION_TRANS    4
#define ACTION_ERROR    5
#define ACTION_NONE     6
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\downlvli.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    DownLvlI.c

Abstract:

    This module implements downlevel fileinfo, volinfo, and dirctrl.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbFabricateAttributesOnNetRoot)
#pragma alloc_text(PAGE, MRxSmbCoreInformation)
#pragma alloc_text(PAGE, MRxSmbLoadCoreFileSearchBuffer)
#pragma alloc_text(PAGE, MRxSmbCoreFileSearch)
#pragma alloc_text(PAGE, MrxSmbOemVolumeInfoToUnicode)
#pragma alloc_text(PAGE, MrxSmbCoreQueryFsVolumeInfo)
#pragma alloc_text(PAGE, MrxSmbQueryFsVolumeInfo)
#pragma alloc_text(PAGE, MrxSmbCoreQueryDiskAttributes)
#pragma alloc_text(PAGE, MrxSmbCoreQueryDiskAttributes)
#pragma alloc_text(PAGE, SmbPseExchangeStart_CoreInfo)
#pragma alloc_text(PAGE, MRxSmbFinishSearch)
#pragma alloc_text(PAGE, MRxSmbFinishQueryDiskInfo)
#pragma alloc_text(PAGE, MRxSmbExtendForCache)
#pragma alloc_text(PAGE, MRxSmbExtendForNonCache)
#pragma alloc_text(PAGE, MRxSmbGetNtAllocationInfo)
#pragma alloc_text(PAGE, __MRxSmbSimpleSyncTransact2)
#pragma alloc_text(PAGE, MRxSmbFinishTransaction2)
#endif

#define Dbg        (DEBUG_TRACE_VOLINFO)

//#define FORCE_CORE_GETATTRIBUTES
#ifndef FORCE_CORE_GETATTRIBUTES
#define MRxSmbForceCoreGetAttributes FALSE
#else
BOOLEAN MRxSmbForceCoreGetAttributes = TRUE;
#endif

NTSTATUS
SmbPseExchangeStart_CoreInfo(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

//these structures are used for t2_query_fs_info
typedef
struct _QFS_INFO {
    ULONG ulVSN;
    UCHAR cch;
    CHAR szVolLabel[12];   //not unicode
} QFS_INFO, *PQFS_INFO;
#define ACTUAL_QFS_INFO_LENGTH (FIELD_OFFSET(QFS_INFO,szVolLabel[12]))

typedef
struct _QFS_ALLOCATE {
    ULONG ulReserved;
    ULONG cSectorUnit;
    ULONG cUnit;
    ULONG cUnitAvail;
    USHORT cbSector;
} QFS_ALLOCATE, *PQFS_ALLOCATE;
#define ACTUAL_QFS_ALLOCATE_LENGTH (FIELD_OFFSET(QFS_ALLOCATE,cbSector)+sizeof(((PQFS_ALLOCATE)0)->cbSector))

//++
//
// VOID
// NAME_LENGTH(
//     OUT ULONG Length,
//     IN PUCHAR Ptr
//     )
//
// Routine Description:
//
//  Determines the length of a Core filename returned by search. This
//  is normally a NULL terminated string less than MAXIMUM_COMPONENT_CORE.
//  In some cases this is Non-null teminated and space filled.
//
// Arguments:
//
//     Length   -   Returns the string length
//     Ptr      -   The filename to be measured
//
// Return Value:
//
//     None.
//
//--
#define NAME_LENGTH( Length, Ptr, Max ) {                         \
    Length = 0;                                                   \
    while( ((PCHAR)Ptr)[Length] != '\0' ) {                       \
         Length++;                                                \
         if ( Length == Max ) {                                   \
             break;                                               \
         }                                                        \
    }                                                             \
    while( ((PCHAR)Ptr)[Length-1] == ' ' && Length ) {            \
        Length--;                                                 \
    }                                                             \
}
MRxSmbSetDeleteDisposition(
      IN PRX_CONTEXT            RxContext
      );

typedef struct __NativeFs_Name_Entry {
    UCHAR Last;
    UCHAR MaximumComponentNameLength;
    UCHAR FileSystemAttributes;   //this may overflow someday.....
    UCHAR NameLength;
    PWCHAR  Name;
};
struct __NativeFs_Name_Entry NativeFsNameTable[] = {
    {0,12,0,sizeof(L"FAT")-sizeof(WCHAR),L"FAT"},
    {0,254,FILE_CASE_PRESERVED_NAMES,sizeof(L"HPFS")-sizeof(WCHAR),L"HPFS"},
    {1,254,FILE_CASE_PRESERVED_NAMES,sizeof(L"HPFS386")-sizeof(WCHAR),L"HPFS386"}
    };

NTSTATUS
MRxSmbFabricateAttributesOnNetRoot(
    IN OUT  PSMBCE_NET_ROOT psmbNetRoot,
    IN      PSMBCE_SERVER   pServer
    )
/*++

Routine Description:

   This routine uses information stored in the netroot structure to hallucinate the attributes
   of the netroot. it may be that the ascii representation of the filesystem name has already been
   stored in the netroot. If so, expeand it out.....otherwise, it must be FAT.

Arguments:


Return Value:

    RXSTATUS - STATUS_SUCCESS

--*/
{
    NTSTATUS StringStatus;
    WCHAR FileSystemNameBuffer[SMB_MAXIMUM_SUPPORTED_VOLUME_LABEL+1]; //must leave room for the null
    UNICODE_STRING FileSystemNameU;
    OEM_STRING FileSystemNameA;
    UCHAR FileSystemNameALength;

    PAGED_CODE();

    // ASSERT (psmbNetRoot->MaximumComponentNameLength==0);

    FileSystemNameALength = psmbNetRoot->FileSystemNameALength;

    if (FileSystemNameALength == 0) {
        if (pServer->Dialect <= WFW10_DIALECT)
        {
            //must be Fat!
            FileSystemNameALength = 3;
            psmbNetRoot->FileSystemNameA[0] = 'F';
            psmbNetRoot->FileSystemNameA[1] = 'A';
            psmbNetRoot->FileSystemNameA[2] = 'T';
        }
        else
        {
            FileSystemNameALength = 7;
            psmbNetRoot->FileSystemNameA[0] = 'U';
            psmbNetRoot->FileSystemNameA[1] = 'N';
            psmbNetRoot->FileSystemNameA[2] = 'K';
            psmbNetRoot->FileSystemNameA[3] = 'N';
            psmbNetRoot->FileSystemNameA[4] = 'O';
            psmbNetRoot->FileSystemNameA[5] = 'W';
            psmbNetRoot->FileSystemNameA[6] = 'N';
        }
    }

    //now, translate the name to Unicode.......

    FileSystemNameA.Length = FileSystemNameALength;
    FileSystemNameA.MaximumLength = FileSystemNameALength;
    FileSystemNameA.Buffer = &psmbNetRoot->FileSystemNameA[0];
    FileSystemNameU.Length = 0;
    FileSystemNameU.MaximumLength = (USHORT)sizeof(FileSystemNameBuffer);
    FileSystemNameU.Buffer = &FileSystemNameBuffer[0];
    StringStatus = RtlOemStringToUnicodeString(&FileSystemNameU, &FileSystemNameA, FALSE);
    ASSERT(StringStatus==STATUS_SUCCESS);

    //copy back the name

    RtlCopyMemory(&psmbNetRoot->FileSystemName[0],FileSystemNameU.Buffer,FileSystemNameU.Length);
    psmbNetRoot->FileSystemNameLength = FileSystemNameU.Length;
    if (FALSE) DbgPrint("NativeFs in unicode %wZ (%d/%d) on netroot %08lx\n",
               &FileSystemNameU,FileSystemNameU.Length,FileSystemNameU.MaximumLength,psmbNetRoot);
    {   struct __NativeFs_Name_Entry *i;
       for (i=NativeFsNameTable;;i++) {
           UCHAR NameLength = i->NameLength;
           if (RtlCompareMemory(&FileSystemNameBuffer[0],
                                i->Name,
                                NameLength) == NameLength) {
              psmbNetRoot->MaximumComponentNameLength = i->MaximumComponentNameLength;
              psmbNetRoot->FileSystemAttributes = i->FileSystemAttributes;
              if (FALSE) {
                  UNICODE_STRING u;
                  u.Buffer = i->Name;
                  u.Length = i->NameLength;
                  DbgPrint("FoundNativeFsStrng %wZ len %d for %d %d\n",&u,i->NameLength,
                                       i->MaximumComponentNameLength,i->FileSystemAttributes);
              }
              break;
           }
           if (i->Last) {
               //ASSERT(!"Valid Share Type returned in TREE COnnect And X response");
               psmbNetRoot->MaximumComponentNameLength = 255;
               psmbNetRoot->FileSystemAttributes = 0;
               break;
           }
       }
    }

    return(STATUS_SUCCESS); //could be a VOID routine.....
}

NTSTATUS
MRxSmbGetFsAttributesFromNetRoot(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine uses information stored in the netroot structure to fill in a FILE
   FileFsAttributeInformation structure.

Arguments:


Return Value:

    RXSTATUS - STATUS_SUCCESS

--*/
{
    RxCaptureFcb;
    ULONG FileSystemNameLength,LengthNeeded;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    PSMBCE_NET_ROOT psmbNetRoot;
    //FILE_INFORMATION_CLASS FileInformationClass;
    PBYTE   pBuffer;
    PULONG  pBufferLength;

    //DbgPrint("yeppp!!\n");
    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    if (pNetRootEntry == NULL) {
        return (STATUS_INVALID_PARAMETER);
    }

    ASSERT(RxContext->MajorFunction==IRP_MJ_QUERY_VOLUME_INFORMATION);
    //FileInformationClass = RxContext->Info.FileInformationClass;
    ASSERT(RxContext->Info.FileInformationClass==FileFsAttributeInformation);
    pBuffer = RxContext->Info.Buffer;
    pBufferLength = &RxContext->Info.LengthRemaining;

    psmbNetRoot = &pNetRootEntry->NetRoot;

    if (psmbNetRoot->MaximumComponentNameLength==0) {
        MRxSmbFabricateAttributesOnNetRoot(psmbNetRoot, &pNetRootEntry->pServerEntry->Server);
    }

    FileSystemNameLength = psmbNetRoot->FileSystemNameLength;
    LengthNeeded = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName)+FileSystemNameLength;

    if (*pBufferLength < LengthNeeded) {
        return (STATUS_BUFFER_OVERFLOW);
    }

    {
        PFILE_FS_ATTRIBUTE_INFORMATION pTypedBuffer = (PFILE_FS_ATTRIBUTE_INFORMATION)pBuffer;

        pTypedBuffer->MaximumComponentNameLength = psmbNetRoot->MaximumComponentNameLength;
        pTypedBuffer->FileSystemAttributes = psmbNetRoot->FileSystemAttributes;
        pTypedBuffer->FileSystemNameLength = FileSystemNameLength;

        RtlCopyMemory(pTypedBuffer->FileSystemName, psmbNetRoot->FileSystemName, FileSystemNameLength);
        *pBufferLength -= LengthNeeded;
    }
    return(STATUS_SUCCESS);
}

NTSTATUS
MRxSmbCoreInformation(
      IN OUT PRX_CONTEXT          RxContext,
      IN     ULONG                InformationClass,
      IN OUT PVOID                pBuffer,
      IN OUT PULONG               pBufferLength,
      IN     SMB_PSE_ORDINARY_EXCHANGE_ENTRYPOINTS EntryPoint
      )
/*++

Routine Description:

   This routine does a core level getinfo (vol or fileinfo) a file across the network

Arguments:

    RxContext - the RDBSS context
    InformationClass - a class variable that is specific to the call. sometimes it's a SMB class; sometimes
                       an NT class.
    pBuffer - pointer to the user's buffer
    pBufferLength - a pointer to a ulong containing the bufferlength that is updated as we go;
                    if it's a setinfo then we deref and place the actual bufferlength in the OE.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_SUCCESS);
    PUNICODE_STRING RemainingName;
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("MRxSmbDownLevelQueryInformation\n", 0 ));  //0 instead of +1.....the general entrypoint already inc'd

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    //some stuff is early out............catch them here even before we initialize the stufferstate
    switch (EntryPoint) {
    case SMBPSE_OE_FROM_QUERYVOLUMEINFO:
        switch (InformationClass) {
        case FileFsVolumeInformation:
        case FileFsSizeInformation:
            break; //these are actually implemented on the wire
        case FileFsAttributeInformation: {
            Status = MRxSmbGetFsAttributesFromNetRoot(RxContext);
            goto FINALLY;
            }
            //no break needed because of gotofinally

        case FileFsDeviceInformation:
            ASSERT(!"this should have been turned away");
            //no break;
        default:
            Status = STATUS_NOT_IMPLEMENTED;
            goto FINALLY;
        }
        break;
    case SMBPSE_OE_FROM_QUERYFILEINFO:
        //notice that the designators are smb_query_info types
        switch (InformationClass) {
        case SMB_QUERY_FILE_BASIC_INFO:
        case SMB_QUERY_FILE_STANDARD_INFO:
            // go thru to the wire or get it from file information cache
            break;
        case SMB_QUERY_FILE_EA_INFO:
            //downlevel guys have no EAs....turn this backright here
            ((PFILE_EA_INFORMATION)pBuffer)->EaSize = 0;
            *pBufferLength -= sizeof(FILE_EA_INFORMATION);
            goto FINALLY;
        //case SMB_QUERY_FILE_ALLOCATION_INFO:
        //case SMB_QUERY_FILE_END_OF_FILEINFO:
        //case SMB_QUERY_FILE_ALT_NAME_INFO:
        //case SMB_QUERY_FILE_STREAM_INFO:
        default:
            Status = STATUS_NOT_IMPLEMENTED;
            goto FINALLY;
        }
        break;
    case SMBPSE_OE_FROM_SETFILEINFO:
        switch (InformationClass) {
        case FileBasicInformation:
        case FileEndOfFileInformation:
            //these go thru to the wire
            break;
        case FileDispositionInformation:
            if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_FILE_DELETED) ||
                !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
                // if it is a pseudo open, we send the delete file request to get the result;
                // otherwise, we delay the delete until close.
                goto FINALLY;
            }
            break;
        case FileRenameInformation:
            Status = MRxSmbRename(RxContext);
            goto FINALLY;
        case FileAllocationInformation:
            Status = STATUS_SUCCESS;
            goto FINALLY;
        default:
            Status = STATUS_NOT_IMPLEMENTED;
            goto FINALLY;
        }
        break;
    case SMBPSE_OE_FROM_EXTENDFILEFORCACHEING:
    case SMBPSE_OE_FROM_QUERYDIRECTORY:
        break;
    }

    Status = SmbPseCreateOrdinaryExchange(RxContext,
                                          SrvOpen->pVNetRoot,
                                          EntryPoint,
                                          SmbPseExchangeStart_CoreInfo,
                                          &OrdinaryExchange
                                          );
    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        goto FINALLY;
    }

    OrdinaryExchange->Info.Buffer = pBuffer;
    OrdinaryExchange->Info.pBufferLength = pBufferLength;
    OrdinaryExchange->Info.InfoClass = InformationClass;

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status != (STATUS_PENDING)); //async was turned away at the top level

    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbDownLevelQueryInformation  exit with status=%08lx\n", Status ));
    return(Status);
}

UNICODE_STRING MRxSmbAll8dot3Files = {sizeof(L"????????.???")-sizeof(WCHAR),sizeof(L"????????.???"),L"????????.???"};

#if 0
#include "stdarg.h"
#include "stdio.h"
#include "string.h"
VOID
MRxSmbDumpResumeKey(
    PSZ             text,
    PSMB_RESUME_KEY ResumeKey
    )
{
    PBYTE rk = (PBYTE)ResumeKey;
    CHAR Buffer[80];
    PCHAR b;
    ULONG i;

    PAGED_CODE();

    for (i=0,b=Buffer;i<sizeof(SMB_RESUME_KEY);i++,b+=2) {
        RxSprintf(b,"%02lx  ",rk[i]);
        if (i==0) b+=2;
        if (i==11) b+=2;
        if (i==16) b+=2;
    }

    RxDbgTrace(0, Dbg, ("%s  rk(%08lx)=%s\n", text, ResumeKey, Buffer));
}
#else
#define MRxSmbDumpResumeKey(x,y)
#endif


NTSTATUS
MRxSmbLoadCoreFileSearchBuffer(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a CORE_SMB_SEARCH and leaves the result in the SMBbuf.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = (STATUS_NOT_IMPLEMENTED);
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;
    PSMB_HEADER SmbHeader;

    //PUNICODE_STRING DirectoryName;
    //PUNICODE_STRING Template;
    BOOLEAN FindFirst;
    UNICODE_STRING FindFirstPattern;
    USHORT ResumeKeyLength;
    ULONG ReturnCount;
    BOOLEAN EndOfSearchReached;
    // SearchAttributes is hardcoded to the magic number 0x16
    ULONG SearchAttributes =
            (SMB_FILE_ATTRIBUTE_DIRECTORY
                | SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN);
    PULONG pCountRemainingInSmbbuf = &OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbLoadCoreFileSearchBuffer entering.......OE=%08lx\n",OrdinaryExchange));
    RxDbgTrace( 0, Dbg, (".......smbFobx/resumekey=%08lx/%08lx\n",smbFobx,smbFobx->Enumeration.CoreResumeKey));

    if (!FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST)) {

        PUNICODE_STRING DirectoryName = GET_ALREADY_PREFIXED_NAME(capFobx->pSrvOpen,capFcb);
        PUNICODE_STRING Template = &capFobx->UnicodeQueryTemplate;
        ULONG DirectoryNameLength,TemplateLength,AllocationLength;
        PBYTE SmbFileName;

        //this is the first time thru....the stuffer cannot handle the intricate logic here so we
        //will have to preallocate for the name

        if (smbFobx->Enumeration.WildCardsFound = FsRtlDoesNameContainWildCards(Template)){
            // we will need to have an upcased template for compares; we do this in place
            RtlUpcaseUnicodeString( Template, Template, FALSE );

            Template = &MRxSmbAll8dot3Files; //we will have to filter on this side
        }
        DirectoryNameLength = DirectoryName->Length;
        TemplateLength = Template->Length;
        AllocationLength = sizeof(WCHAR)  // backslash separator
                            +DirectoryNameLength
                            +TemplateLength;
        RxDbgTrace(0, Dbg, ("  --> d/t/dl/tl/al <%wZ><%wZ>%08lx/%08lx/%08lx!\n",
                      DirectoryName,Template,
                      DirectoryNameLength,TemplateLength,AllocationLength));

        FindFirstPattern.Buffer = (PWCHAR)RxAllocatePoolWithTag( PagedPool,AllocationLength,'0SxR');
        if (FindFirstPattern.Buffer==NULL) {
            RxDbgTrace(0, Dbg, ("  --> Couldn't get the findfind pattern buffer!\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }

        SmbFileName = (PBYTE)FindFirstPattern.Buffer;
        RtlCopyMemory(SmbFileName,DirectoryName->Buffer,DirectoryNameLength);
        SmbFileName += DirectoryNameLength;
        if (*((PWCHAR)(SmbFileName-sizeof(WCHAR))) != L'\\') {
            *((PWCHAR)SmbFileName) = L'\\'; SmbFileName+= sizeof(WCHAR);
        }
        RtlCopyMemory(SmbFileName,Template->Buffer,TemplateLength);
        SmbFileName += TemplateLength;
        if ((TemplateLength == sizeof(WCHAR)) && (Template->Buffer[0]==DOS_STAR)) {
            ASSERT(FALSE); //this should never happen
            *((PWCHAR)SmbFileName) = L'.'; SmbFileName+= sizeof(WCHAR);
            *((PWCHAR)SmbFileName) = L'*'; SmbFileName+= sizeof(WCHAR);
        }
        FindFirstPattern.Length = (USHORT)(SmbFileName - (PBYTE)FindFirstPattern.Buffer);
        RxDbgTrace(0, Dbg, ("  --> find1stpattern <%wZ>!\n",&FindFirstPattern));
        FindFirst = TRUE;
        ResumeKeyLength = 0;

    } else {

        RxDbgTrace(0, Dbg, ("-->FINDNEXT\n"));
        FindFirstPattern.Buffer = NULL;
        if (!FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS)) {
            Status = smbFobx->Enumeration.ErrorStatus;
            RxDbgTrace(0, Dbg, ("-->ERROR EARLY OUT\n"));
            goto FINALLY;
        }
        FindFirst = FALSE;
        FindFirstPattern.Length = 0;
        ResumeKeyLength = sizeof(SMB_RESUME_KEY);
        MRxSmbDumpResumeKey("FindNext:",smbFobx->Enumeration.CoreResumeKey);

    }

    //get the correct return count. there are three factors: countremaining from the OE,
    //     how many could fit the the user's buffer, and how many could fit in a negotiated buffer.
    //     we pick the smallest of the three except that we never go for less than 10 unless 10 won't
    //     fit in the smbbuf.
    ReturnCount = OrdinaryExchange->Info.CoreSearch.CountRemaining;

    { ULONG t = (*OrdinaryExchange->Info.pBufferLength) / smbFobx->Enumeration.FileNameOffset;
        if (t<ReturnCount) { ReturnCount = t; }
    }

    if (ReturnCount<10) { ReturnCount = 10; }

    {
        PSMBCE_SERVER         pServer;
        ULONG                 AvailableBufferSize,t;

        pServer = SmbCeGetExchangeServer(OrdinaryExchange);
        AvailableBufferSize = pServer->MaximumBufferSize -
                                      (sizeof(SMB_HEADER) +
                                         FIELD_OFFSET(RESP_SEARCH,Buffer[0])
                                         +sizeof(UCHAR)+sizeof(USHORT)       //bufferformat,datalength fields
                                      );
        t = AvailableBufferSize / sizeof(SMB_DIRECTORY_INFORMATION);
        if (t<ReturnCount) { ReturnCount = t; }
    }
    RxDbgTrace( 0, Dbg, ("-------->count=%08lx\n",ReturnCount));
    if (ReturnCount==0) {
        Status = (STATUS_MORE_PROCESSING_REQUIRED);
        RxDbgTrace(0, Dbg, ("-->Count==0 EARLY OUT\n"));
        goto FINALLY;
    }

    StufferState = &OrdinaryExchange->AssociatedStufferState;
    ASSERT( StufferState );

    *pCountRemainingInSmbbuf = 0;
    OrdinaryExchange->Info.CoreSearch.NextDirInfo = NULL;

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,
                                          SMB_COM_SEARCH, SMB_REQUEST_SIZE(SEARCH),
                                          NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                          0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    RxDbgTrace(0, Dbg,("core search command initial status = %lu\n",Status));
    MRxSmbDumpStufferState (1100,"SMB w/ core search before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wwB4ywc!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
               ReturnCount,         //  w         _USHORT( MaxCount );                // Number of dir. entries to return
               SearchAttributes,    //  w         _USHORT( SearchAttributes );
               SMB_WCT_CHECK(2)     //  B         _USHORT( ByteCount );               // Count of data bytes; min = 5
                                    //            UCHAR Buffer[1];                    // Buffer containing:
               &FindFirstPattern,   //  4        //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name, may be null
               0x05,                //  y         //UCHAR BufferFormat2;              //  0x05 -- Variable block
               ResumeKeyLength,     //  w         //USHORT ResumeKeyLength;           //  Length of resume key, may be 0
                                    //  c         //UCHAR SearchStatus[];             //  Resume key
               ResumeKeyLength,smbFobx->Enumeration.CoreResumeKey
             );


    MRxSmbDumpStufferState (700,"SMB w/ core search after stuffing",StufferState);

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORESEARCH
                                    );

    if (!NT_SUCCESS(Status)) goto FINALLY;

    smbFobx->Enumeration.Flags |= SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST|SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS;
    if (Status==(STATUS_SUCCESS) && *pCountRemainingInSmbbuf==0) {
         RxDbgTrace( 0, Dbg, ("MRxSmbLoadCoreFileSearchBuffer: no files returned...switch status\n"));
         EndOfSearchReached = TRUE;
         Status = (STATUS_NO_MORE_FILES);
    } else {
         EndOfSearchReached = FALSE;
    }
    if (EndOfSearchReached) {
        RxDbgTrace( 0, Dbg, ("MRxSmbLoadCoreFileSearchBuffer: no longer in progress...EOS\n"));
        smbFobx->Enumeration.Flags &= ~SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS;
        smbFobx->Enumeration.ErrorStatus = (STATUS_NO_MORE_FILES);
    }
    //we dont save a resume key here since each individual copy operation will have to do that


FINALLY:
    if (FindFirstPattern.Buffer != NULL) {
        RxFreePool(FindFirstPattern.Buffer);
    }
    if (!NT_SUCCESS(Status)&&(Status!=(STATUS_MORE_PROCESSING_REQUIRED))) {
        RxDbgTrace( 0, Dbg, ("MRxSmbCoreFileSearch: Failed .. returning %lx\n",Status));
        smbFobx->Enumeration.Flags &= ~SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS;
        smbFobx->Enumeration.ErrorStatus = Status;  //keep returning this
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbLoadCoreFileSearchBuffer exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));

    return(Status);
}

#define ASSERT_SAME_FIELD(__field,__t1,__t2) { \
      ASSERT(FIELD_OFFSET(__t1,__field)==FIELD_OFFSET(__t2,__field)); \
      }

#define ASSERT_SAME_DIRINFO_FIELDS(__t1,__t2) {\
      ASSERT_SAME_FIELD(LastWriteTime,__t1,__t2); \
      ASSERT_SAME_FIELD(EndOfFile,__t1,__t2); \
      ASSERT_SAME_FIELD(AllocationSize,__t1,__t2); \
      ASSERT_SAME_FIELD(FileAttributes,__t1,__t2); \
      }
#if DBG
VOID MRxSmbCoreFileSeach_AssertFields(void){
    //just move this out of the main execution path so that we don't have to look at it while
    //we Uing the code
    ASSERT_SAME_DIRINFO_FIELDS(FILE_DIRECTORY_INFORMATION,FILE_FULL_DIR_INFORMATION);
    ASSERT_SAME_DIRINFO_FIELDS(FILE_DIRECTORY_INFORMATION,FILE_BOTH_DIR_INFORMATION);
}
#else
#define MRxSmbCoreFileSeach_AssertFields()
#endif

NTSTATUS
MRxSmbCoreFileSearch(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = (STATUS_NOT_IMPLEMENTED);
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);

    PBYTE pBuffer = OrdinaryExchange->Info.Buffer;
    PULONG pLengthRemaining = OrdinaryExchange->Info.pBufferLength;
    ULONG InformationClass = OrdinaryExchange->Info.InfoClass;

    PFILE_DIRECTORY_INFORMATION pPreviousBuffer = NULL;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    ULONG SuccessCount = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreFileSearch entering.......OE=%08lx\n",OrdinaryExchange));
    MRxSmbCoreFileSeach_AssertFields();

    OrdinaryExchange->Info.CoreSearch.CountRemaining =
              RxContext->QueryDirectory.ReturnSingleEntry?1:0x7ffffff;

    if ( (smbFobx->Enumeration.CoreResumeKey ==NULL )
             && ((smbFobx->Enumeration.CoreResumeKey = RxAllocatePoolWithTag(PagedPool,sizeof(SMB_RESUME_KEY),'rbms'))==NULL) ){
        RxDbgTrace(0, Dbg, ("...couldn't allocate resume key\n"));
        Status = (STATUS_INSUFFICIENT_RESOURCES);
        goto FINALLY;
    }
    RxDbgTrace( 0, Dbg, (".......smbFobx/resumekey=%08lx/%08lx\n",smbFobx,smbFobx->Enumeration.CoreResumeKey));

    Status = MRxSmbLoadCoreFileSearchBuffer( SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS );

    for (;;) {
        BOOLEAN BufferOverflow = FALSE;
        PSMB_DIRECTORY_INFORMATION NextDirInfo;
        UNICODE_STRING FileNameU;
        OEM_STRING FileNameA;
        WCHAR FileNameU_buffer[14];
        ULONG NameLength;
        PBYTE NextFileName;
        BOOLEAN Match,BufferOverFlow;

        if (!NT_SUCCESS(Status)) {
            if (Status = (STATUS_NO_MORE_FILES)) {
                if (SuccessCount > 0) {
                    Status = (STATUS_SUCCESS);
                }
            } else if (Status = (STATUS_MORE_PROCESSING_REQUIRED)) {
                if (SuccessCount > 0) {
                    Status = (STATUS_SUCCESS);
                } else {
                    Status = (STATUS_BUFFER_OVERFLOW);
                }
            }

            goto FINALLY;
        }
        ASSERT ( OrdinaryExchange->Info.CoreSearch.CountRemaining>0 );
        ASSERT ( OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf>0 );
        RxDbgTrace(0, Dbg, ("MRxSmbCoreFileSearch looptopcheck counts=%08lx,%08lx\n",
                    OrdinaryExchange->Info.CoreSearch.CountRemaining,
                    OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf
                    ));

        //next issue: does the next dirinfo match the criteria?!?

        NextDirInfo = OrdinaryExchange->Info.CoreSearch.NextDirInfo;
        NextFileName = &NextDirInfo->FileName[0];

        // According to colinw, some core servers do not remember to insert the null at the end of the name...
        // but the namelength macro handles this correctly. some servers (Xenix, apparently) pad the
        // names with spaces. again, the macro handles it....
        //

        NAME_LENGTH(NameLength, NextFileName,sizeof(NextDirInfo->FileName));

        FileNameA.Length = (USHORT)NameLength;
        FileNameA.MaximumLength = (USHORT)NameLength;
        FileNameA.Buffer = NextFileName;
        FileNameU.Length = sizeof(FileNameU_buffer);
        FileNameU.MaximumLength = sizeof(FileNameU_buffer);
        FileNameU.Buffer = &FileNameU_buffer[0];

        Status = RtlOemStringToUnicodeString(&FileNameU, &FileNameA, TRUE);
        RxDbgTrace(0, Dbg, ("MRxSmbCoreFileSearch considering.......filename=%wZ, template=%wZ\n",
                                    &FileNameU,&capFobx->UnicodeQueryTemplate));

        ASSERT(Status==(STATUS_SUCCESS));

        // we deal with a conversion failure by skipping this guy
        Match = (Status==(STATUS_SUCCESS));
        if (Match && smbFobx->Enumeration.WildCardsFound ) {
            //DbgBreakPoint();
            Match = FsRtlIsNameInExpression( &capFobx->UnicodeQueryTemplate,
                                                      &FileNameU, TRUE, NULL );
        }

        //next issue: will the next dirinfo fit in the user's buffer?!?
        if (Match) {
            ULONG SpaceNeeded;
            PBYTE pRememberBuffer = pBuffer;
            //QuadAlign!! pBuffer = (PBYTE)LongAlign(pBuffer); //assume that this will fit
            if (SuccessCount != 0) {
                pBuffer = (PBYTE)QuadAlignPtr(pBuffer); //assume that this will fit
            }
            SpaceNeeded = smbFobx->Enumeration.FileNameOffset+FileNameU.Length;
            if (pBuffer+SpaceNeeded > pRememberBuffer+*pLengthRemaining) {
                BufferOverflow = TRUE;
                pBuffer = pRememberBuffer; //rollback
            } else {
                PSMBCEDB_SERVER_ENTRY pServerEntry;
                PFILE_DIRECTORY_INFORMATION pThisBuffer = (PFILE_DIRECTORY_INFORMATION)pBuffer;
                SMB_TIME Time;
                SMB_DATE Date;
                PSMBCE_SERVER Server;

                Server = SmbCeGetExchangeServer(Exchange);
                BufferOverflow = FALSE;
                if (pPreviousBuffer != NULL) {
                    pPreviousBuffer->NextEntryOffset =
                        (ULONG)(((PBYTE)pThisBuffer)-((PBYTE)pPreviousBuffer));
                }
                pPreviousBuffer = pThisBuffer;
                RtlZeroMemory(pBuffer,smbFobx->Enumeration.FileNameOffset);
                RtlCopyMemory(pBuffer+smbFobx->Enumeration.FileNameOffset, FileNameU.Buffer,FileNameU.Length);
                *((PULONG)(pBuffer+smbFobx->Enumeration.FileNameLengthOffset)) = FileNameU.Length;
                //hallucinate the record based on specific return type
                switch (InformationClass) {
                case SMB_FIND_FILE_NAMES_INFO:
                    break;
                case SMB_FIND_FILE_DIRECTORY_INFO:
                case SMB_FIND_FILE_FULL_DIRECTORY_INFO:
                case SMB_FIND_FILE_BOTH_DIRECTORY_INFO:
                    //just fill what we have...we do not go to a lot of trouble on allocinfo as rdr1 did.
                    //     actually, rdr1 didn't do that here...only on getfielinfo.......
                    SmbMoveTime (&Time, &NextDirInfo->LastWriteTime);
                    SmbMoveDate (&Date, &NextDirInfo->LastWriteDate);
                    pThisBuffer->LastWriteTime = MRxSmbConvertSmbTimeToTime(Server, Time, Date);
                    pThisBuffer->EndOfFile.LowPart = SmbGetUlong(&NextDirInfo->FileSize);
                    pThisBuffer->FileAttributes = MRxSmbMapSmbAttributes (NextDirInfo->FileAttributes);
                    break;
                default:
                   RxDbgTrace( 0, Dbg, ("MRxSmbCoreFileSearch: Invalid FS information class\n"));
                   ASSERT(!"this can't happen");
                   Status = STATUS_INVALID_PARAMETER;
                   goto FINALLY;
                }
                pBuffer += SpaceNeeded;
                *pLengthRemaining -= (ULONG)(pBuffer-pRememberBuffer);
                OrdinaryExchange->Info.CoreSearch.CountRemaining--;
                SuccessCount++;
            }
        }

        //
        // if no match or no overflow, move up in the buffer. this means not only juggling the
        // pointers but also saving the resume key

        if (!Match || !BufferOverflow) {
            MRxSmbDumpResumeKey("BufferKey:",&NextDirInfo->ResumeKey);
            *(smbFobx->Enumeration.CoreResumeKey) = NextDirInfo->ResumeKey;
            MRxSmbDumpResumeKey("SaveKey:  ",smbFobx->Enumeration.CoreResumeKey);
            OrdinaryExchange->Info.CoreSearch.NextDirInfo = NextDirInfo + 1;
            OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf--;
        }

        if (OrdinaryExchange->Info.CoreSearch.CountRemaining==0) {
            Status = (STATUS_SUCCESS);
            goto FINALLY;
        }

        if (BufferOverflow) {
            Status = (SuccessCount==0)?(STATUS_BUFFER_OVERFLOW):(STATUS_SUCCESS);
            goto FINALLY;
        }

        if (OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf==0) {

            Status = MRxSmbLoadCoreFileSearchBuffer( SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS );

        }

    }


FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreFileSearch exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));

    return(Status);
}

NTSTATUS
MrxSmbOemVolumeInfoToUnicode(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG *VolumeLabelLengthReturned
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:


Return Value:

    RXSTATUS - The return status for the operation
    also VolumeLabelLengthReturned is the number of bytes of the label that were stored, if any.

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING VolumeLabelU;
    OEM_STRING VolumeLabelA;
    SMB_DIRECTORY_INFORMATION Buffer;
    ULONG NameLength;
    ULONG BytesToCopy;
    PBYTE VolumeLabel = &OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0];

    PAGED_CODE();

    NAME_LENGTH(NameLength, VolumeLabel,
               sizeof(OrdinaryExchange->Info.QFSVolInfo.CoreLabel));

    VolumeLabelA.Length = (USHORT)NameLength;
    VolumeLabelA.MaximumLength = (USHORT)NameLength;
    VolumeLabelA.Buffer = VolumeLabel;

    //some core servers put a '.' in the labelname.....if it's there then remove it
    if ((NameLength>8)&& (VolumeLabel[8]=='.') ) {
        ULONG i;
        for (i=8;i<NameLength;i++) {
            VolumeLabel[i] = VolumeLabel[i+1];
        }
    }

    Status = RtlOemStringToUnicodeString(&VolumeLabelU, &VolumeLabelA, TRUE);

    if (NT_SUCCESS(Status)) {

        PULONG pBufferLength = OrdinaryExchange->Info.pBufferLength;
        PFILE_FS_VOLUME_INFORMATION pBuffer = OrdinaryExchange->Info.Buffer;
        ULONG BytesToCopy = min((ULONG)VolumeLabelU.Length, (*pBufferLength-sizeof(FILE_FS_VOLUME_INFORMATION)));

        RtlCopyMemory(&pBuffer->VolumeLabel[0],
                      VolumeLabelU.Buffer,
                      BytesToCopy);

        *VolumeLabelLengthReturned = BytesToCopy;
        pBuffer->VolumeLabelLength = VolumeLabelU.Length;
        IF_DEBUG {
            UNICODE_STRING FinalLabel;
            FinalLabel.Buffer = &pBuffer->VolumeLabel[0];
            FinalLabel.Length = (USHORT)BytesToCopy;
            RxDbgTrace(0, Dbg, ("MrxSmbOemVolumeInfoToUnicode vollabel=%wZ\n",&FinalLabel));
        }

        RtlFreeUnicodeString(&VolumeLabelU);
    }

    return(Status);
}




MrxSmbCoreQueryFsVolumeInfo(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = (STATUS_NOT_IMPLEMENTED);

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MrxSmbCoreQueryFsVolumeInfo entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_SEARCH,
                                SMB_REQUEST_SIZE(SEARCH),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ searchvolumelabel before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wwB4yw!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
               1,                   //  w         _USHORT( MaxCount );                // Number of dir. entries to return
                                    //  w         _USHORT( SearchAttributes );
               SMB_FILE_ATTRIBUTE_VOLUME,
               SMB_WCT_CHECK(2)     //  B         _USHORT( ByteCount );               // Count of data bytes; min = 5
                                    //            UCHAR Buffer[1];                    // Buffer containing:
               &MRxSmbAll8dot3Files,//  4         //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                    //           //UCHAR FileName[];                 //  File name, may be null
               0x05,                //  y         //UCHAR BufferFormat2;              //  0x05 -- Variable block
               0                    //  w         //USHORT ResumeKeyLength;           //  Length of resume key, may be 0
                                    //            //UCHAR SearchStatus[];             //  Resume key
             );


    MRxSmbDumpStufferState (700,"SMB w/ searchvolumelabel after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_COREQUERYLABEL
                                    );

    //Status = RxStatus(NOT_IMPLEMENTED);

FINALLY:
    RxDbgTrace(-1, Dbg, ("MrxSmbCoreQueryFsVolumeInfo exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MrxSmbQueryFsVolumeInfo(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a downlevel getvolumeinfo/FS_VOLUME_INFORMATION.

Arguments:

    OrdinaryExchange  - duh!

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb;
    RxCaptureFobx;

    PSMBCE_SERVER  pServer;
    BOOLEAN        UseTransactVersion;

    REQ_QUERY_FS_INFORMATION VolInfo;

    PFILE_FS_VOLUME_INFORMATION pBuffer = OrdinaryExchange->Info.Buffer;
    PULONG pBufferLength = OrdinaryExchange->Info.pBufferLength;

    ULONG VolumeLabelLengthReturned = 0;

    PAGED_CODE();

    ASSERT(pBuffer!=NULL);
    pServer = SmbCeGetExchangeServer(OrdinaryExchange);
    UseTransactVersion = BooleanFlagOn(pServer->DialectFlags,DF_LANMAN20);

    RxDbgTrace(+1, Dbg, ("MrxSmbQueryFsVolumeInfo entering.......OE=%08lx\n",OrdinaryExchange));

    pBuffer->SupportsObjects = FALSE;
    pBuffer->VolumeCreationTime.LowPart = 0;
    pBuffer->VolumeCreationTime.HighPart = 0;
    pBuffer->VolumeSerialNumber = 0;
    pBuffer->VolumeLabelLength = 0;

    OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0] = 0; //no label

    if (!UseTransactVersion) {
        Status =  MrxSmbCoreQueryFsVolumeInfo(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
    } else {
        VolInfo.InformationLevel = SMB_INFO_VOLUME;

        Status = MRxSmbSimpleSyncTransact2(
                        SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                        SMBPSE_OETYPE_T2_FOR_LANMAN_VOLUMELABEL_INFO,
                        TRANS2_QUERY_FS_INFORMATION,
                        &VolInfo,sizeof(VolInfo),
                        NULL,0
                        );
    }

    ASSERT ( *pBufferLength>=sizeof(FILE_FS_VOLUME_INFORMATION));
    RxDbgTrace(0, Dbg, ("MrxSmbQueryFsVolumeInfo OEstatus=%08lx\n",Status));
    //DbgBreakPoint();

    if ( (Status==STATUS_SUCCESS) &&
         (OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0] != 0) ) {

        Status = MrxSmbOemVolumeInfoToUnicode(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,&VolumeLabelLengthReturned);

    } else if ( (Status == STATUS_NO_SUCH_FILE)
                   || (Status == STATUS_NO_MORE_FILES) ) {
        //
        //  these statuses indicate that there's no volume label
        //  the remote volume.  Return success with no data.
        //

        Status = (STATUS_SUCCESS);

    }

    if (NT_SUCCESS(Status)) {
        *pBufferLength -= FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION,VolumeLabel);
        *pBufferLength -= VolumeLabelLengthReturned;
    }


    RxDbgTrace(-1, Dbg, ("MrxSmbQueryFsVolumeInfo exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MrxSmbCoreQueryDiskAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetDiskAttributes and remembers the reponse in a buffer pointed to
   by the exchange. this is called from the downlevel queryvolumeinfo AND ALSO from
   extend-for-cached-write.

Arguments:

    OrdinaryExchange  - duh!

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    ASSERT(OrdinaryExchange->Info.Buffer!=NULL);

    RxDbgTrace(+1, Dbg, ("MrxSmbCoreQueryDiskAttributes entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_QUERY_INFORMATION_DISK,
                                SMB_REQUEST_SIZE(QUERY_INFORMATION_DISK),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    RxDbgTrace(0, Dbg,("querydiskattribs command initial status = %lu\n",Status));
    MRxSmbDumpStufferState (1100,"SMB w/ querydiskattribs before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0B!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 0
               SMB_WCT_CHECK(0) 0   //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );

    MRxSmbDumpStufferState (700,"SMB w/ querydiskattribs after stuffing",StufferState);

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_COREQUERYDISKATTRIBUTES
                                    );
FINALLY:
    RxDbgTrace(-1, Dbg, ("MrxSmbCoreQueryDiskAttributes exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MrxSmbQueryDiskAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetDiskAttributes and remembers the reponse in a buffer pointed to
   by the exchange. this is called from the downlevel queryvolumeinfo AND ALSO from
   extend-for-cached-write.

Arguments:

    OrdinaryExchange  - duh!

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;

    PSMBCE_SERVER pServer;
    BOOLEAN UseTransactVersion;

    REQ_QUERY_FS_INFORMATION VolInfo;

    PAGED_CODE();

    ASSERT(OrdinaryExchange->Info.Buffer!=NULL);

    pServer = SmbCeGetExchangeServer(OrdinaryExchange);
    UseTransactVersion = BooleanFlagOn(pServer->DialectFlags,DF_LANMAN20) &&
                         !MRxSmbForceCoreGetAttributes;
    if (!UseTransactVersion) {
        return MrxSmbCoreQueryDiskAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
    }

    RxDbgTrace(+1, Dbg, ("MrxSmbQueryDiskAttributes entering.......OE=%08lx\n",OrdinaryExchange));

    VolInfo.InformationLevel = SMB_INFO_ALLOCATION;

    Status = MRxSmbSimpleSyncTransact2(
                    SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                    SMBPSE_OETYPE_T2_FOR_LANMAN_DISKATTRIBUTES_INFO,
                    TRANS2_QUERY_FS_INFORMATION,
                    &VolInfo,sizeof(VolInfo),
                    NULL,0
                    );

    RxDbgTrace(-1, Dbg, ("MrxSmbQueryDiskAttributes exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbGetNtAllocationInfo (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
SmbPseExchangeStart_CoreInfo(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for VOLINFO.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_NOT_IMPLEMENTED);
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    ULONG InformationClass = OrdinaryExchange->Info.InfoClass;
    PBYTE pBuffer = (PBYTE)OrdinaryExchange->Info.Buffer;
    PULONG pBufferLength = OrdinaryExchange->Info.pBufferLength;

    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_CoreInfo\n", 0 ));

    ASSERT_ORDINARY_EXCHANGE(OrdinaryExchange);

    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

    //ASSERT (StufferState->CurrentCommand == SMB_COM_NO_ANDX_COMMAND);

    switch (OrdinaryExchange->EntryPoint) {
    case SMBPSE_OE_FROM_QUERYVOLUMEINFO:
        switch (InformationClass) {
        case FileFsVolumeInformation:
            Status = MrxSmbQueryFsVolumeInfo(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
            goto FINALLY;
        case FileFsSizeInformation:
            Status = MrxSmbQueryDiskAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
            goto FINALLY;
        default:
            ASSERT(!"this should have been turned away");
            goto FINALLY;
         }
         ASSERT(!"shouldn't get here1");
         goto FINALLY;
    case SMBPSE_OE_FROM_QUERYFILEINFO:
        Status = MRxSmbGetFileAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
        if (!NT_SUCCESS(Status)) goto FINALLY;
        switch (InformationClass) {
        case SMB_QUERY_FILE_BASIC_INFO:
            *((PFILE_BASIC_INFORMATION)pBuffer) = OrdinaryExchange->Create.FileInfo.Basic;
            *pBufferLength -= sizeof(FILE_BASIC_INFORMATION);
            goto FINALLY;
        case SMB_QUERY_FILE_STANDARD_INFO:
            *((PFILE_STANDARD_INFORMATION)pBuffer) = OrdinaryExchange->Create.FileInfo.Standard;
            *pBufferLength -= sizeof(FILE_STANDARD_INFORMATION);
            goto FINALLY;
        default:
            ASSERT(!"this should have been turned away");
            goto FINALLY;
         }
        ASSERT(!"shouldn't get here2");
        goto FINALLY;
    case SMBPSE_OE_FROM_SETFILEINFO:
        switch (InformationClass) {
        case FileBasicInformation:
            {
                ULONG SmbAttributes = MRxSmbMapFileAttributes(((PFILE_BASIC_INFORMATION)pBuffer)->FileAttributes);
                PFILE_BASIC_INFORMATION BasicInfo = (PFILE_BASIC_INFORMATION)pBuffer;

                if (SmbAttributes != 0 ||
                    (BasicInfo->CreationTime.QuadPart == 0 &&
                     BasicInfo->LastWriteTime.QuadPart == 0 &&
                     BasicInfo->LastAccessTime.QuadPart == 0)) {
                    Status = MRxSmbSetFileAttributes(
                                SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                SmbAttributes);
                }

                if (BasicInfo->LastWriteTime.QuadPart == 0 &&
                    FlagOn(pServerEntry->Server.DialectFlags,DF_W95)) {
                    // Win9x server only takes last write time.
                    Status = STATUS_SUCCESS;
                    goto FINALLY;
                }

                if (BasicInfo->CreationTime.QuadPart != 0 ||
                    BasicInfo->LastWriteTime.QuadPart != 0 ||
                    BasicInfo->LastAccessTime.QuadPart != 0) {

                    Status = MRxSmbDeferredCreate(RxContext);
            
                    if (Status == STATUS_SUCCESS) {
                        Status = MRxSmbSetFileAttributes(
                                    SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SmbAttributes);
                    }
                }

            }
            goto FINALLY;

        case FileEndOfFileInformation:
            if (((PFILE_END_OF_FILE_INFORMATION)pBuffer)->EndOfFile.HighPart) {
                Status = (STATUS_INVALID_PARAMETER);
            } else {
                Status = MRxSmbCoreTruncate(
                                  SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                  smbSrvOpen->Fid,
                                  ((PFILE_END_OF_FILE_INFORMATION)pBuffer)->EndOfFile.LowPart);
            }

            goto FINALLY;

        case FileDispositionInformation:
            OrdinaryExchange->pPathArgument1 = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);
            Status = MRxSmbCoreDeleteForSupercedeOrClose(
                         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                         ((BOOLEAN)( NodeType(capFcb)==RDBSS_NTC_STORAGE_TYPE_DIRECTORY )));

            goto FINALLY;

        default:
            ASSERT(!"this should have been turned away");
            goto FINALLY;
        }

        ASSERT(!"shouldn't get here3");
        goto FINALLY;

    case SMBPSE_OE_FROM_QUERYDIRECTORY:
        Status = MRxSmbCoreFileSearch(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
        goto FINALLY;

    case SMBPSE_OE_FROM_EXTENDFILEFORCACHEING:
        {
            PSMBCE_NET_ROOT psmbNetRoot = SmbCeGetExchangeNetRoot(OrdinaryExchange);
            PMRX_V_NET_ROOT pVNetRoot = SmbCeGetExchangeVNetRoot(OrdinaryExchange);
            PMRX_NET_ROOT pNetRoot = pVNetRoot->pNetRoot;
            PSMBCE_SERVER psmbServer = SmbCeGetExchangeServer(OrdinaryExchange);
            ULONG ClusterSize;
            PLARGE_INTEGER pFileSize = (PLARGE_INTEGER)(OrdinaryExchange->Info.Buffer);
            PLARGE_INTEGER pAllocationSize = (PLARGE_INTEGER)(OrdinaryExchange->Info.pBufferLength);

            //we will need the cluster size
            if (OrdinaryExchange->ServerVersion==pNetRoot->ParameterValidationStamp) {

                ClusterSize=pNetRoot->DiskParameters.ClusterSize;

            } else {

                RxSynchronizeBlockingOperations(RxContext,&psmbNetRoot->ClusterSizeSerializationQueue);
                if (OrdinaryExchange->ServerVersion!=pNetRoot->ParameterValidationStamp) {

                    //
                    //here we have to go find out the clustersize

                    NTSTATUS LocalStatus;
                    FILE_FS_SIZE_INFORMATION UsersBuffer;
                    ULONG BufferLength = sizeof(FILE_FS_SIZE_INFORMATION);
                    //fill in the exchange params so that we can get the params we need
                    OrdinaryExchange->Info.Buffer = &UsersBuffer;
                    OrdinaryExchange->Info.pBufferLength = &BufferLength;
                    LocalStatus = MrxSmbQueryDiskAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
                    if (LocalStatus == STATUS_SUCCESS) {
                        ClusterSize = UsersBuffer.BytesPerSector * UsersBuffer.SectorsPerAllocationUnit;
                        pNetRoot->ParameterValidationStamp =OrdinaryExchange->ServerVersion;
                    } else {
                        ClusterSize = 0;
                    }
                    if (ClusterSize==0) {
                        ClusterSize = 1;
                    }
                    pNetRoot->DiskParameters.ClusterSize = ClusterSize;
                    RxDbgTrace(0, Dbg, ("clustersize set to %08lx\n", ClusterSize ));
                    RxLog(("clustersize rx/n/cs %lx %lx %lx\n",
                              OrdinaryExchange->RxContext,pNetRoot,ClusterSize ));
                } else {

                    // someone else went and got the value while i was asleep...just use it

                    ClusterSize=pNetRoot->DiskParameters.ClusterSize;

                }

                RxResumeBlockedOperations_Serially(RxContext,&psmbNetRoot->ClusterSizeSerializationQueue);
            }

            ASSERT (ClusterSize != 0);

            if (FlagOn(psmbServer->DialectFlags,DF_NT_SMBS)) {
                //i'm using this to identify a server that supports 64bit offsets
                //for these guys, we write a zero at the eof....since the filesystems
                //extend on writes this will be much better than a set-end-of-file
                LARGE_INTEGER ByteOffset,AllocationSize,ClusterSizeAsLI;
                ULONG Buffer = 0;
                UCHAR WriteCommand;
                PSMBCE_SERVER pServer = SmbCeGetExchangeServer(OrdinaryExchange);

                if (FlagOn(pServer->DialectFlags,DF_LARGE_FILES)) {
                    WriteCommand = SMB_COM_WRITE_ANDX;
                } else {
                    WriteCommand = SMB_COM_WRITE;
                }

                ByteOffset.QuadPart = pFileSize->QuadPart - 1;

                MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0));
                COVERED_CALL(MRxSmbBuildWriteRequest(
                                    OrdinaryExchange,
                                    TRUE, // IsPagingIo
                                    WriteCommand,
                                    1,
                                    &ByteOffset,
                                    (PBYTE)&Buffer,
                                    NULL //BufferAsMdl,
                                    ));
                COVERED_CALL(SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                            SMBPSE_OETYPE_EXTEND_WRITE
                                            ));

                //this is what you do if you can't do better
                ClusterSizeAsLI.QuadPart = ClusterSize;
                AllocationSize.QuadPart =
                    (pFileSize->QuadPart+ ClusterSizeAsLI.QuadPart)  &
                    ~(ClusterSizeAsLI.QuadPart - 1);

                *pAllocationSize = AllocationSize; //64bit!

                Status = MRxSmbGetNtAllocationInfo(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);

                if ( (NT_SUCCESS(Status)) &&
                     (OrdinaryExchange->Transact2.AllocationSize.QuadPart > AllocationSize.QuadPart)) {
                    *pAllocationSize = OrdinaryExchange->Transact2.AllocationSize; //64bit!
                    RxDbgTrace(0, Dbg, ("alocatedsiz222e set to %08lx\n", pAllocationSize->LowPart ));
                }
            }

            if ( (!FlagOn(psmbServer->DialectFlags,DF_NT_SMBS)) || (!NT_SUCCESS(Status)) ) {
                ULONG FileSize,AllocationSize;
                FileSize = pFileSize->LowPart;
                COVERED_CALL(MRxSmbCoreTruncate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                            smbSrvOpen->Fid, FileSize
                                            ));
                //this is what you do if you can't do better
                AllocationSize = (FileSize+ClusterSize)&~(ClusterSize-1);
                pAllocationSize->QuadPart = AllocationSize; //64bit!
                RxDbgTrace(0, Dbg, ("alocatedsize set to %08lx\n", pAllocationSize->LowPart ));
                //if we care a lot about downlevel performance, we could do the same as ntgetallocation
                //except that we would use a 32bit smb.........like query_information2
            }


        }
        goto FINALLY;
    }


FINALLY:

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_CoreInfo exit w %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbFinishSearch (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_SEARCH                Response
      )
/*++

Routine Description:

    This routine actually gets the stuff out of the VolInfo response and finishes the close.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_SUCCESS);
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);


    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishSearch\n" ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishSearch:");

    if (Response->WordCount != 1) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto FINALLY;
    }

    if (OrdinaryExchange->OEType == SMBPSE_OETYPE_COREQUERYLABEL) {
        //here, all we do is to copy the label to wherever is pointed to by
        if (SmbGetUshort(&Response->Count)>0) {
            PBYTE smbDirInfotmp = &Response->Buffer[0]
                                        +sizeof(UCHAR) //bufferformat
                                        +sizeof(USHORT); //datalength
            PSMB_DIRECTORY_INFORMATION smbDirInfo = (PSMB_DIRECTORY_INFORMATION)smbDirInfotmp;
            RxDbgTrace(+1, Dbg, ("MRxSmbFinishSearch corelabl=%s,size=%d\n",
                                     smbDirInfo->FileName, sizeof(smbDirInfo->FileName) ));
            
            if (sizeof(smbDirInfo->FileName) != 13) { //straightfrom the spec
                Status = STATUS_INVALID_NETWORK_RESPONSE;
                OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
                goto FINALLY;
            }


            RtlCopyMemory(OrdinaryExchange->Info.QFSVolInfo.CoreLabel,
                          smbDirInfo->FileName, sizeof(smbDirInfo->FileName)
                         );
        } else {
            OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0] = 0; //no label
        }
    } else if (OrdinaryExchange->OEType == SMBPSE_OETYPE_CORESEARCHFORCHECKEMPTY) {
        //here, we 're doing a search SMB to see if the directory is empty. we have to read thru the
        // entries returned (if successful). if we encounter ones that are neither '.' or '..',  set
        // resumekey to null since that will tell the guy above that the directory is nonempty
        ULONG Count = SmbGetUshort(&Response->Count);
        PSMB_DIRECTORY_INFORMATION NextDirInfo =
               (PSMB_DIRECTORY_INFORMATION)(&Response->Buffer[0]+sizeof(UCHAR)+sizeof(USHORT));

        for (;Count>0;Count--,NextDirInfo++) {
            RxDbgTrace(0, Dbg, ("--->emptydirchk: file=%s\n",&NextDirInfo->FileName[0]));
            /*
            // Since the DOS Server returns the file name ".           " instead of ".", and so does the
            // "..          ", the following if {...} statements are always past through with no action.
            // But those statements make the RMDIR not working on OS2 Server  since  it  returns the "."
            // and ".." without following blanks.  After the if {...} statements were removed, the RMDIR
            // workes on OS2 Server and no impact has been found to access the DOS Server.
            if (NextDirInfo->FileName[0]=='.') {
                CHAR c1;
                if ((c1=NextDirInfo->FileName[1])==0) {
                    continue; //skip past "."
                } else if ((c1=='.')&&(NextDirInfo->FileName[2]==0)) {
                    continue; //skip past ".."
                } else {
                    NOTHING;
                }
            }
            */
            // here we have found a bad one...make sure there's no resume key and change the status
            Status = (STATUS_NO_MORE_FILES);
            OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey = NULL;
        }
        //if we get here with success, set up the resume key and buffer
        if (Status == (STATUS_SUCCESS)) {
            NextDirInfo--;
            OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKeyBuffer =
                                    NextDirInfo->ResumeKey;
            OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKey =
                                    &OrdinaryExchange->Info.CoreSearch.EmptyCheckResumeKeyBuffer;
        }
    } else {
        //all that we do here is to setup the nextdirptr and the count in the OE
        ASSERT(OrdinaryExchange->OEType == SMBPSE_OETYPE_CORESEARCH);
        OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf = SmbGetUshort(&Response->Count);
        OrdinaryExchange->Info.CoreSearch.NextDirInfo =
               (PSMB_DIRECTORY_INFORMATION)(&Response->Buffer[0]+sizeof(UCHAR)+sizeof(USHORT));
        IF_DEBUG {
            ULONG tcount = OrdinaryExchange->Info.CoreSearch.CountRemainingInSmbbuf;
            PSMB_DIRECTORY_INFORMATION ndi = OrdinaryExchange->Info.CoreSearch.NextDirInfo;
            RxDbgTrace(0, Dbg, ("--->coresearch: count/ndi=%08lx/%08lx\n",tcount,ndi));
            if (tcount) {
                //DbgBreakPoint();
                RxDbgTrace(0, Dbg, ("--->coresearch: firstfile=%s\n",&ndi->FileName[0]));
            }
        }
    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbFinishSearch   returning %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbFinishQueryDiskInfo (
      PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
      PRESP_QUERY_INFORMATION_DISK Response
      )
/*++

Routine Description:

    This routine actually gets the stuff out of the VolInfo response and finishes the close.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_SUCCESS);
    PFILE_FS_SIZE_INFORMATION UsersBuffer = OrdinaryExchange->Info.Buffer;
    PULONG BufferLength = OrdinaryExchange->Info.pBufferLength;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishQueryDiskInfo\n" ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishQueryDiskInfo:");

    IF_DEBUG{
        PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
        RxCaptureFobx;
        PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
        PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
        ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    }

    if (Response->WordCount != 5 ||
        SmbGetUshort(&Response->ByteCount) != 0) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto FINALLY;
    }

    UsersBuffer->TotalAllocationUnits.QuadPart = SmbGetUshort(&Response->TotalUnits);
    UsersBuffer->AvailableAllocationUnits.QuadPart = SmbGetUshort(&Response->FreeUnits);
    UsersBuffer->SectorsPerAllocationUnit = SmbGetUshort(&Response->BlocksPerUnit);
    UsersBuffer->BytesPerSector = SmbGetUshort(&Response->BlockSize);

    *BufferLength -= sizeof(FILE_FS_SIZE_INFORMATION);

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbFinishQueryDiskInfo   returning %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbExtendForCache (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN     PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    )
/*++

Routine Description:

   This routine handles network requests to extend the file for cached IO. we just share the
   core_info skeleton.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen;

    PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    PSMB_EXCHANGE Exchange;

    PAGED_CODE();

    if (capFcb->Attributes & FILE_ATTRIBUTE_COMPRESSED) {
        //here, we just get out since disk reservations don't do us any good....
        pNewAllocationSize->QuadPart = (pNewFileSize->QuadPart)<<2;
        return(STATUS_SUCCESS);
    }

    RxDbgTrace(+1, Dbg, ("MRxSmbExtendForCache %08lx %08lx %08lx %08lx\n",
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->LowPart
               ));

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );
    SrvOpen = capFobx->pSrvOpen;
    smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    if (FALSE) {
        DbgPrint("Extend top  %08lx %08lx %08lx %08lx\n",
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->LowPart);
    }

    //we just pass in our info into MRxSmbCoreInformation thru the existing pointers....
    //we have two pointers.....the first two params are ptrs......
    Status = MRxSmbCoreInformation(RxContext,0,
                                   (PVOID)pNewFileSize,
                                   (PULONG)pNewAllocationSize,
                                   SMBPSE_OE_FROM_EXTENDFILEFORCACHEING
                                   );
    if (FALSE) {
        DbgPrint("Extend exit Status %lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
                     Status,
                     capFcb->Header.FileSize.HighPart,
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.HighPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->HighPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->HighPart,
                     pNewAllocationSize->LowPart);
    }

    RxLog(("Extend exit %lx %lx %lx %lx %lx\n",
                     RxContext,
                     capFcb->Header.FileSize.LowPart,
                     capFcb->Header.AllocationSize.LowPart,
                     pNewFileSize->LowPart,
                     pNewAllocationSize->LowPart));

    RxDbgTrace(-1, Dbg, ("MRxSmbExtendForCache  exit with status=%08lx %08lx %08lx\n",
                          Status, pNewFileSize->LowPart, pNewAllocationSize->LowPart));
    return(Status);

}

NTSTATUS
MRxSmbExtendForNonCache(
    IN OUT struct _RX_CONTEXT * RxContext,
    IN     PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    )
/*++

Routine Description:

   This routine handles network requests to extend the file for noncached IO. since the write
   itself will extend the file, we can pretty much just get out quickly.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    //RxCaptureFcb; RxCaptureFobx;

    //PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    //PSMB_EXCHANGE Exchange;

    PAGED_CODE();

    pNewAllocationSize->QuadPart = pNewFileSize->QuadPart;

    return(Status);
}

NTSTATUS
MRxSmbGetNtAllocationInfo (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   gets the nt allocation information by doing a simple transact........

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    REQ_QUERY_FILE_INFORMATION FileInfo;

    PAGED_CODE();

    FileInfo.Fid = smbSrvOpen->Fid;
    FileInfo.InformationLevel = SMB_QUERY_FILE_STANDARD_INFO;

    Status = MRxSmbSimpleSyncTransact2(
                    SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                    SMBPSE_OETYPE_T2_FOR_NT_FILE_ALLOCATION_INFO,
                    TRANS2_QUERY_FILE_INFORMATION,
                    &FileInfo,sizeof(FileInfo),
                    NULL,0
                    );

    return(Status);
}

NTSTATUS
__MRxSmbSimpleSyncTransact2(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    IN SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType,
    IN ULONG TransactSetupCode,
    IN PVOID Params,
    IN ULONG ParamsLength,
    IN PVOID Data,
    IN ULONG DataLength,
    IN PSMB_PSE_OE_T2_FIXUP_ROUTINE FixupRoutine
    )
/*++

Routine Description:

   This routine does a simple 1-in-1out transact2

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSimpleSyncTransact2 entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_TRANSACTION2,
                                SMB_REQUEST_SIZE(TRANSACTION),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ pseT2 before stuffing",StufferState);

    //the return sizes of 100 and 800 are chosen arbitrarily.

    MRxSmbStuffSMB (StufferState,
       "0wwwwdD",
                                    //  0         UCHAR WordCount;                    // Count of parameter words; value = (14 + SetupCount)
           ParamsLength,            //  w         _USHORT( TotalParameterCount );     // Total parameter bytes being sent
           DataLength,              //  w         _USHORT( TotalDataCount );          // Total data bytes being sent
           100,                     //  w         _USHORT( MaxParameterCount );       // Max parameter bytes to return
           800,                     //  w         _USHORT( MaxDataCount );            // Max data bytes to return
           0,                       //  d   .     UCHAR MaxSetupCount;                // Max setup words to return
                                    //      .     UCHAR Reserved;
                                    //      .     _USHORT( Flags );                   // Additional information:
                                    //                                                //  bit 0 - also disconnect TID in Tid
                                    //                                                //  bit 1 - one-way transacion (no resp)
                                    //  D         _ULONG( Timeout );
          SMB_OFFSET_CHECK(TRANSACTION,Timeout) 0,
       STUFFER_CTL_NORMAL, "wwpwQyyw",
          0,                        //  w         _USHORT( Reserved2 );
          ParamsLength,             //  w         _USHORT( ParameterCount );          // Parameter bytes sent this buffer
                                    //  p         _USHORT( ParameterOffset );         // Offset (from header start) to params
          DataLength,               //  w         _USHORT( DataCount );               // Data bytes sent this buffer
                                    //  Q         _USHORT( DataOffset );              // Offset (from header start) to data
          SMB_OFFSET_CHECK(TRANSACTION,DataOffset)
          1,                        //  y         UCHAR SetupCount;                   // Count of setup words
          0,                        //  y         UCHAR Reserved3;                    // Reserved (pad above to word)
                                    //            UCHAR Buffer[1];                    // Buffer containing:
          TransactSetupCode,        //  w         //USHORT Setup[];                   //  Setup words (# = SetupWordCount)
       STUFFER_CTL_NORMAL, "ByS6cS5c!",
           SMB_WCT_CHECK(15)        //  B         //USHORT ByteCount;                 //  Count of data bytes
           0,                       //  y         //UCHAR Name[];                     //  Name of transaction (NULL if Transact2)
                                    //  S         //UCHAR Pad[];                      //  Pad to SHORT or LONG
                                    //  6c        //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
           ParamsLength,Params,
                                    //  S         //UCHAR Pad1[];                     //  Pad to SHORT or LONG
                                    //  5c        //UCHAR Data[];                     //  Data bytes (# = DataCount)
           DataLength,Data
             );


    MRxSmbDumpStufferState (700,"SMB w/ pseT2 after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    if (FixupRoutine) {
        Status = FixupRoutine(OrdinaryExchange);
        if (Status!=STATUS_SUCCESS) {
            goto FINALLY;
        }
    }
    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    OEType
                                    );


FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbSimpleSyncTransact2 exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbFinishTransaction2 (
      IN OUT PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      IN     PRESP_TRANSACTION           Response
      )
/*++

Routine Description:

    This routine finishes a transact2. what it does depends on the OE_TYPE.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_SUCCESS);
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    PAGED_CODE();  //could actually be nonpaged

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishTransaction2\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishTransaction2:");

    switch (OrdinaryExchange->OEType) {
    case SMBPSE_OETYPE_T2_FOR_NT_FILE_ALLOCATION_INFO:{
        PFILE_STANDARD_INFORMATION StandardInfo;
        if (   (Response->WordCount!=10)
            || (SmbGetUshort(&Response->TotalParameterCount)!=2)
            || (SmbGetUshort(&Response->ParameterCount)!=2)
            || (SmbGetUshort(&Response->ParameterDisplacement)!=0)
            || (SmbGetUshort(&Response->TotalDataCount)!=24)
            || (SmbGetUshort(&Response->DataCount)!=24)
            || (SmbGetUshort(&Response->DataDisplacement)!=0)) {
            Status = STATUS_INVALID_NETWORK_RESPONSE;
            RxDbgTrace(+1, Dbg, ("Invalid parameter(s) received.\n", 0 ));
            break;
        }

        StandardInfo = (PFILE_STANDARD_INFORMATION)
                          (StufferState->BufferBase+SmbGetUshort(&Response->DataOffset));
        OrdinaryExchange->Transact2.AllocationSize.LowPart
                     =  SmbGetUlong(&StandardInfo->AllocationSize.LowPart);
        OrdinaryExchange->Transact2.AllocationSize.HighPart
                     =  SmbGetUlong(&StandardInfo->AllocationSize.HighPart);

        RxDbgTrace(0, Dbg, ("MRxSmbFinishTransaction2   nt allocation %08lx\n",
                               OrdinaryExchange->Transact2.AllocationSize.LowPart ));
        }break;

    case SMBPSE_OETYPE_T2_FOR_LANMAN_DISKATTRIBUTES_INFO:{
        PFILE_FS_SIZE_INFORMATION UsersBuffer = OrdinaryExchange->Info.Buffer;
        PULONG BufferLength = OrdinaryExchange->Info.pBufferLength;
        PQFS_ALLOCATE QfsInfo;

        if (Response->WordCount != 10 ||
            SmbGetUshort(&Response->DataDisplacement) != 0 ||
            SmbGetUshort(&Response->DataCount) != ACTUAL_QFS_ALLOCATE_LENGTH ||
            SmbGetUshort(&Response->TotalDataCount) != ACTUAL_QFS_ALLOCATE_LENGTH ||
            SmbGetUshort(&Response->TotalParameterCount) != SmbGetUshort(&Response->ParameterCount)) {
            
            Status = STATUS_INVALID_NETWORK_RESPONSE;
            RxDbgTrace(+1, Dbg, ("Invalid parameter(s) received.\n", 0 ));
            break;
        }
        
        QfsInfo = (PQFS_ALLOCATE)(StufferState->BufferBase+SmbGetUshort(&Response->DataOffset));

        UsersBuffer->TotalAllocationUnits.QuadPart = SmbGetUlong(&QfsInfo->cUnit);
        UsersBuffer->AvailableAllocationUnits.QuadPart = SmbGetUlong(&QfsInfo->cUnitAvail);
        UsersBuffer->SectorsPerAllocationUnit = SmbGetUlong(&QfsInfo->cSectorUnit);
        UsersBuffer->BytesPerSector = SmbGetUshort(&QfsInfo->cbSector);

        *BufferLength -= sizeof(FILE_FS_SIZE_INFORMATION);

        RxDbgTrace(0, Dbg, ("MRxSmbFinishTransaction2   allocation %08lx\n",
                               OrdinaryExchange->Transact2.AllocationSize.LowPart ));
        }break;
    case SMBPSE_OETYPE_T2_FOR_LANMAN_VOLUMELABEL_INFO:{
        PFILE_FS_VOLUME_INFORMATION UsersBuffer = OrdinaryExchange->Info.Buffer;
        PULONG BufferLength = OrdinaryExchange->Info.pBufferLength;
        PQFS_INFO QfsInfo;
        ULONG LabelLength;
        PBYTE VolumeLabel = &OrdinaryExchange->Info.QFSVolInfo.CoreLabel[0];

        if (Response->WordCount != 10 ||
            SmbGetUshort(&Response->DataDisplacement) != 0 ||
            SmbGetUshort(&Response->TotalParameterCount) != SmbGetUshort(&Response->ParameterCount)) {
            
            Status = STATUS_INVALID_NETWORK_RESPONSE;
            RxDbgTrace(+1, Dbg, ("Invalid parameter(s) received.\n", 0 ));
            break;
        }

        QfsInfo = (PQFS_INFO)(StufferState->BufferBase+SmbGetUshort(&Response->DataOffset));

        UsersBuffer->VolumeSerialNumber = SmbGetUlong(&QfsInfo->ulVSN);

        //copy the volumelabel to the right place in the OE where it can UNICODE-ized by the routine above

        LabelLength  = min(QfsInfo->cch,12);
        RtlCopyMemory(VolumeLabel,&QfsInfo->szVolLabel[0],LabelLength);
        VolumeLabel[LabelLength] = 0;


        RxDbgTrace(0, Dbg, ("MRxSmbFinishTransaction2   volinfo serialnum= %08lx\n",
                               UsersBuffer->VolumeSerialNumber ));
        }break;
    case SMBPSE_OETYPE_T2_FOR_ONE_FILE_DIRCTRL:{
        //do nothing here....everything is done back in the caller with the
        //whole buffer having been copied.....
        RxDbgTrace(0, Dbg, ("MRxSmbFinishTransaction2   one file \n"));
        }break;
    default:
        Status = STATUS_INVALID_NETWORK_RESPONSE;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishTransaction2   returning %08lx\n", Status ));
    return Status;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\exe\srfunc.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    smbrdr.c

Abstract:

    This module implements the functios to load and unload the
    smb monolithic minirdr. Also explicit start/stop control is
    provided

    This module also populates the registry entries for the
    driver, and the network provider.

--*/
//#ifndef UNICODE
//#define UNICODE
//#endif

#include <windows.h>
#include <devioctl.h>
#include <stdlib.h>

#include "srfunc.h"


#ifdef DBG
#define DbgP(_x_) DbgPrint _x_
#else
#define DbgP(_x_)
#endif

ULONG _cdecl DbgPrint( LPTSTR Format, ... );

#define TRACE_TAG   L"SMBRDR:    "



TCHAR* SmbMrxDriverName = TEXT("SmbMRx");


// load action states

ULONG_PTR LoadActionStates[] =
{
    RDR_NULL_STATE,
    RDR_LOADING,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE
};

// unload action states
ULONG_PTR UnloadActionStates[] =
{
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_UNLOADING,
    RDR_UNLOADING,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE
};

// Start action states
ULONG_PTR StartActionStates[] =
{
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_STARTING,
    RDR_STARTING,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE
};

// Stop action states
ULONG_PTR StopActionStates[] =
{
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_STOPPING
};

ULONG_PTR TransitionActionStates[] =
{
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_UNLOADED,
    RDR_LOADED,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_STOPPED,
    RDR_STARTED,
    RDR_NULL_STATE
};

ULONG_PTR ErrorActionStates[] =
{
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_LOADED,
    RDR_UNLOADED,
    RDR_NULL_STATE,
    RDR_NULL_STATE,
    RDR_STARTED,
    RDR_STOPPED,
    RDR_NULL_STATE
};

ULONG_PTR NoneActionStates[] =
{
    RDR_NULL_STATE,
    RDR_UNLOADED,
    RDR_UNLOADING,
    RDR_LOADING,
    RDR_LOADED,
    RDR_STOPPED,
    RDR_STOPPING,
    RDR_STARTING,
    RDR_STARTED
};


ULONG_PTR *ActionsStatesArray[] =
{
    LoadActionStates,
    UnloadActionStates,
    StartActionStates,
    StopActionStates,
    TransitionActionStates,
    ErrorActionStates,
    NoneActionStates
};

ACTIONVECTOR ActionProcs[] =
{
    RdrLoad,
    RdrUnload,
    RdrStart,
    RdrStop,
    RdrDoNothing,
    RdrDoNothing,
    RdrDoNothing
};


typedef enum _INSTALLCHECKS
{
    installcheck_start,
    installcheck_driverfile,
    installcheck_providerfile,
    installcheck_serviceentry,
    installcheck_providerorder,
    installcheck_stop,
    installcheck_done
};


ULONG_PTR RdrInstallCheck( void )
{
    TCHAR tszTestPath[_MAX_PATH];
    ULONG_PTR teststep, len;
    ULONG_PTR tc = SETUP_COMPLETE;
    HANDLE  th;

    for ( teststep = installcheck_start; teststep < installcheck_done; teststep++ )
    {
        switch ( teststep )
        {
            case installcheck_start:
            {
                len = GetWindowsDirectory( tszTestPath, _MAX_PATH );
            }
            break;

            case installcheck_driverfile:
            {
                lstrcpy( &tszTestPath[len], DRIVER_FILE_PATH );
                th = CreateFile( tszTestPath, 0, 0, NULL, OPEN_EXISTING, 0, NULL );
                if ( th == INVALID_HANDLE_VALUE )
                {
                    tc = SETUP_MISSING_FILE;
                    teststep = installcheck_stop;
                }
                else
                {
                    CloseHandle( th );
                }
            }
            break;

            case installcheck_providerfile:
            {
                lstrcpy( &tszTestPath[len], PROVIDER_FILE_PATH );
                th = CreateFile( tszTestPath, 0, 0, NULL, OPEN_EXISTING, 0, NULL );
                if ( th == INVALID_HANDLE_VALUE )
                {
                    tc = SETUP_MISSING_FILE;
                    teststep = installcheck_stop;
                }
                else
                {
                    CloseHandle( th );
                }
            }
            break;

            case installcheck_serviceentry:
            {
                HKEY hTestKey;

                if ( OpenKey( RDRSERVICE_KEY, &hTestKey ) )
                {
                    RegCloseKey( hTestKey );
                }
                else
                {
                    tc = SETUP_INCOMPLETE;
                    teststep = installcheck_stop;
                }
            }
            break;

            case installcheck_providerorder:
            {
                LPTSTR pOrder;

                RdrGetProviderOrderString( &pOrder );
                if ( pOrder )
                {
                    if ( !RdrFindProviderInOrder( pOrder, PROVIDER_NAME ) )
                    {
                        tc = SETUP_INCOMPLETE;
                        teststep = installcheck_stop;
                    }
                    free( pOrder );
                }
            }
            break;

            case installcheck_stop:
                break;
        }
    }

    return tc;
}

BOOL RdrCompleteSetup( void )
{
    return RdrSetupServiceEntry( ) && RdrSetupProviderOrder( );
}

// These handles are retained

HANDLE hSharedMemory;
HANDLE hMutex;


BOOL RdrStart(void)
/*++

Routine Description:

    This routine starts the SMB sample mini redirector.

Notes:

    The start is distinguished from Load. During this phase the appropriate FSCTL
    is issued and the shared memory/mutex data structures required for the Network
    provider DLL are initialized.

--*/
{

    HANDLE  DeviceHandle;       // The mini rdr device handle
    DWORD   BytesRet;
    BOOL    started = FALSE;

    // Grab a handle to the redirector device object

    DbgP((TEXT("Opening Rdr Device Object for Start Ioctl\n")));
    DeviceHandle = CreateFile( DD_SMBMRX_USERMODE_DEV_NAME,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL );

    DbgP((TEXT("returned from rdr device open\n")));

    if ( DeviceHandle != INVALID_HANDLE_VALUE )
    {
        DbgP(( TEXT("Issueing Rdr Start Ioctl\n") ));
        started = DeviceIoControl( DeviceHandle,
                                   IOCTL_SMBMRX_START,
                                   NULL,
                                   0,
                                   NULL,
                                   0,
                                   &BytesRet,
                                   NULL );

        // Create a section of shared memory to serve as the connection database
        if ( started )
        {
            DWORD  Status;
            HANDLE hMutex;

            hSharedMemory = CreateFileMapping( INVALID_HANDLE_VALUE,
                                               NULL,
                                               PAGE_READWRITE,
                                               0,
                                               sizeof(SMBMRXNP_SHARED_MEMORY),
                                               SMBMRXNP_SHARED_MEMORY_NAME);

            if (hSharedMemory == NULL)
            {
                Status = GetLastError();

                DbgP((TEXT("SMB MRx Net Provider shared memory Creation status %lx\n"),Status));
            }
            else
            {
                PSMBMRXNP_SHARED_MEMORY pSharedMemory;

                pSharedMemory = MapViewOfFile(hSharedMemory, FILE_MAP_WRITE, 0, 0, 0);

                if (pSharedMemory != NULL)
                {
                      pSharedMemory->HighestIndexInUse      = -1;
                      pSharedMemory->NumberOfResourcesInUse =  0;
                }

                UnmapViewOfFile(pSharedMemory);
            }

            hMutex = CreateMutex( NULL,
                                  FALSE,
                                  SMBMRXNP_MUTEX_NAME);

            if (hMutex == NULL)
            {
                Status = GetLastError();
                DbgP(( TEXT("SMB MRx Net Provider Mutex Creation status %lx\n"), Status));
            }
        }
        else
        {
            DbgP(( TEXT("The DeviceIoctl for Starting Redirector returned %lx\n"), GetLastError() ));
        }

    }
    else
    {
        DbgP(( TEXT("The CreateFile for opening device failed with error 0x%lx\n"), GetLastError() ));
        DbgP(( TEXT("Device is %s\n"),DD_SMBMRX_USERMODE_DEV_NAME ));
    }

    //DbgP((TEXT("SMB MRx sample mini redirector start status %lx\n"),ntstatus));

    CloseHandle(DeviceHandle);

    return started;


}

BOOL RdrStop( void )
/*++

Routine Description:

    This routine stops the SMB sample mini redirector.

Notes:

    The stop is distinguished from unload. During this phase the appropriate FSCTL
    is issued and the shared memory/mutex data structures required for the Network
    provider DLL are torn down.

--*/
{
    HANDLE  DeviceHandle;       // The mini rdr device handle
    DWORD   BytesRet;
    BOOL    stopped = FALSE;

    // Grab a handle to the redirector device object

    DeviceHandle = CreateFile( DD_SMBMRX_USERMODE_DEV_NAME,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL );

    DbgP((TEXT("Doing Stop DeviceIoControl\n")));
    if ( DeviceHandle != INVALID_HANDLE_VALUE )
    {
        stopped = DeviceIoControl( DeviceHandle,
                                   IOCTL_SMBMRX_STOP,
                                   NULL,
                                   0,
                                   NULL,
                                   0,
                                   &BytesRet,
                                   NULL );

        CloseHandle( DeviceHandle );
    }
    else
    {
        DbgP(( TEXT("The CreateFile for opening device failed\n") ));
    }

    CloseHandle(hMutex);
    CloseHandle(hSharedMemory);

//    DbgP(( TEXT("SMB MRx sample mini redirector start status %lx\n"),ntstatus ));

    return stopped;
}


BOOL RdrLoad( void )
{
    SC_HANDLE sch, service;
    BOOL loaded = FALSE;

    DbgP((TEXT("Loading SMB sample minirdr.......\n")));

    sch = OpenSCManager( NULL, NULL, GENERIC_EXECUTE );
    if ( sch )
    {
        service = OpenService( sch, RDRSERVICE, GENERIC_EXECUTE );
        if ( service )
        {
            loaded = StartService( service, 0, NULL );
            CloseServiceHandle( service );
        }
        CloseServiceHandle( sch );
    }

    return loaded;
}


BOOL RdrUnload( void )
{
    SC_HANDLE sch, service;
    BOOL unloaded = FALSE;

    DbgP((TEXT("Unloading SMB sample minirdr.......\n")));

    sch = OpenSCManager( NULL, NULL, GENERIC_EXECUTE );
    if ( sch )
    {
        service = OpenService( sch, RDRSERVICE, GENERIC_EXECUTE );
        if ( service )
        {
            SERVICE_STATUS ss;

            unloaded = ControlService( service, SERVICE_CONTROL_STOP, &ss );
            CloseServiceHandle( service );
        }
        CloseServiceHandle( sch );
    }

    return unloaded;
}


BOOL RdrDoNothing( void )
{
    return TRUE;
}


BOOL RdrDoAction( ULONG_PTR action )
{
    return (*ActionProcs[action])( );
}


ULONG_PTR RdrGetInitialState(void)
{
    ULONG_PTR state = RDR_UNLOADED;
    SC_HANDLE sch, service;

    sch = OpenSCManager( NULL, NULL, GENERIC_READ );
    if ( sch )
    {
        service = OpenService( sch, RDRSERVICE, GENERIC_READ );
        if ( service )
        {
            SERVICE_STATUS ss;

            if ( QueryServiceStatus( service, &ss ) )
            {
                switch ( ss.dwCurrentState )
                {
                    case SERVICE_STOPPED:
                        state = RDR_UNLOADED;
                        break;
                    case SERVICE_START_PENDING:
                        state = RDR_LOADING;
                        break;
                    case SERVICE_STOP_PENDING:
                        state = RDR_UNLOADING;
                        break;
                    case SERVICE_RUNNING:
                        state = RDR_LOADED;
                        break;
                    case SERVICE_CONTINUE_PENDING:
                    case SERVICE_PAUSE_PENDING:
                    case SERVICE_PAUSED:
                    default:
                        state = RDR_UNLOADED;
                        break;

                }
#if 0	//just check for load/unload state for now

                // go check the start/stop state
                if ( state == RDR_LOADED )
                {
                    BOOL IsOk;
                    HANDLE  DeviceHandle;
                    DWORD   BytesRet;
                    ULONG_PTR RdrStateValue;

                    DeviceHandle = CreateFile( DD_SMBMRX_USERMODE_DEV_NAME,
                                               GENERIC_READ | GENERIC_WRITE,
                                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                                               NULL,
                                               OPEN_EXISTING,
                                               0,
                                               NULL );

                    if ( DeviceHandle != INVALID_HANDLE_VALUE )
                    {
                        DbgP((TEXT("Doing Get State DeviceIoControl\n")));
                        IsOk = DeviceIoControl( DeviceHandle,
                                                IOCTL_SMBMRX_GETSTATE,
                                                NULL,
                                                0,
                                                &RdrStateValue,
                                                sizeof(ULONG),
                                                &BytesRet,
                                                NULL );
                        CloseHandle( DeviceHandle );
                    }
                    if ( IsOk )
                    {
                        state = RdrStateValue;
                    }
                }
#endif
            }
            CloseServiceHandle( service );
        }
        CloseServiceHandle( sch );
    }

    return state;
}


ULONG_PTR RdrGetNextState( ULONG_PTR Action, ULONG_PTR CurrentState )
{
    return ActionsStatesArray[Action][CurrentState];
}


REGENTRY LinkageKeyValues[] =
{
    { TEXT("Bind"),     REG_MULTI_SZ,  0,   0 },
    { TEXT("Export"),   REG_MULTI_SZ,  0,   0 },
    { TEXT("Route"),    REG_MULTI_SZ,  0,   0 }
};

REGENTRY LinkageDisabledKeyValues[] =
{
    { TEXT("Bind"),     REG_MULTI_SZ,  0,   0 },
    { TEXT("Export"),   REG_MULTI_SZ,  0,   0 },
    { TEXT("Route"),    REG_MULTI_SZ,  0,   0 }
};


REGENTRY NetworkProviderKeyValues[] =
{
    {
        TEXT("Devicename"),
        REG_SZ,
        sizeof(SMBMRX_DEVICE_NAME),
        SMBMRX_DEVICE_NAME
    },
    {
        TEXT("ProviderPath"),
        REG_EXPAND_SZ,
        sizeof(PROVIDER_PATH),
        PROVIDER_PATH
    },
    {
        TEXT("Name"),
        REG_SZ,
        sizeof(SMBMRX_PROVIDER_NAME),
        SMBMRX_PROVIDER_NAME
    }
};


REGENTRY ProviderOrderKeyValues[] =
{
    { TEXT("ProviderOrder"), REG_SZ, 0,   0 }
};

BOOL RdrSetupServiceEntry( void )
/*++

Routine Description:

    This routine initializes the registry entries for the smbmrx
    minirdr. This only needs to be done once.

Arguments:

    None

Return Value:

   None

--*/
{
    HKEY hCurrentKey;
    SC_HANDLE sch, service;
    BOOL success = TRUE;

    DbgP(( TEXT( "Setting up ") RDRSERVICE TEXT(" registry Entries\n" ) ));
    sch = OpenSCManager( NULL, NULL, GENERIC_WRITE );
    if ( sch )
    {
        service = CreateService( sch,
                                 RDRSERVICE,
                                 RDRSERVICE,
                                 SERVICE_ALL_ACCESS,
                                 SERVICE_FILE_SYSTEM_DRIVER,
                                 SERVICE_DEMAND_START,
                                 SERVICE_ERROR_NORMAL,
                                 TEXT("System32\\DRIVERS\\") RDRSERVICE TEXT(".sys"),
                                 TEXT("Network"),
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL );


        if ( service )
        {
            CloseServiceHandle( service );
        }
        else if ( GetLastError( ) != ERROR_SERVICE_EXISTS )
        {
            success = FALSE;
        }
        CloseServiceHandle( sch );
    }
    else
    {
        success = FALSE;
    }


    // Read the linkage values associated with the Lanman workstation service.
    // This contains all the transports and the order in which they need to be used
    if ( success && OpenKey( WKSSERVICE_KEY TEXT("\\Linkage"), &hCurrentKey ) )
    {
        ULONG i;

        ReadRegistryKeyValues( hCurrentKey,
                               sizeof(LinkageKeyValues) / sizeof(REGENTRY),
                               LinkageKeyValues);
        RegCloseKey(hCurrentKey);
        // Update the SMB MRx linkage values
        if ( CreateKey( RDRSERVICE_KEY TEXT("\\Linkage"), &hCurrentKey ) )
        {
            WriteRegistryKeyValues( hCurrentKey,
                                    sizeof(LinkageKeyValues) / sizeof(REGENTRY),
                                    LinkageKeyValues);
            RegCloseKey(hCurrentKey);
        }
        else
        {
            success = FALSE;
        }
        for ( i = 0; i < ( sizeof(LinkageKeyValues) / sizeof(REGENTRY) ); i++ )
        {
            if (  LinkageKeyValues[i].pvValue )
            {
                free( LinkageKeyValues[i].pvValue );
                LinkageKeyValues[i].pvValue = NULL;
            }
        }
    }
    else
    {
        success = FALSE;
    }

    //if ( OpenKey( WKSSERVICE_KEY TEXT("\\Linkage\\Disabled",&hCurrentKey))
    //{
    //    ReadRegistryKeyValues( hCurrentKey,
    //                           sizeof(LinkageDisabledKeyValues) / sizeof(REGENTRY),
    //                           LinkageDisabledKeyValues);
    //    RegCloseKey(hCurrentKey);
    //}
    //else
    //{
    //    DbgP(( TEXT("Error Opening Key %s Status %d\n"),WKSSERVICE_KEY TEXT("\\Linkage\\Disabled"),GetLastError() ));
    //    return;
    //}

    // Update the SMB MRx linkage disabled values
    //if ( CreateKey( RDRSERVICE_KEY TEXT("\\Linkage\\Disabled") ,&hCurrentKey))
    //{
    //    WriteRegistryKeyValues( hCurrentKey,
    //                            sizeof(LinkageDisabledKeyValues)/sizeof(REGENTRY),
    //                            LinkageDisabledKeyValues );
    //    RegCloseKey(hCurrentKey);
    //}
    //else
    //{
    //    DbgP(( TEXT("Error Creating Key %s Status %d\n"),RDRSERVICE_KEY TEXT("\\linkage\\disabled",GetLastError() ));
    //    return;
    //}

    // Update the SMBmrx network provider section
    if ( success && CreateKey( RDRSERVICE_KEY TEXT("\\NetworkProvider"), &hCurrentKey ) )
    {
        WriteRegistryKeyValues( hCurrentKey,
                                sizeof(NetworkProviderKeyValues)/sizeof(REGENTRY),
                                NetworkProviderKeyValues);
        RegCloseKey(hCurrentKey);
    }
    else
    {
        success = FALSE;
    }


    if ( success && CreateKey( RDRSERVICE_KEY TEXT("\\Parameters"), &hCurrentKey ) )
    {
        RegCloseKey( hCurrentKey );
    }
    else
    {
        success = FALSE;
    }

    return success;
}

BOOL RdrSetupProviderOrder( void )
{
    LPTSTR pOrderString = NULL;
    ULONG_PTR len;
    BOOL success = TRUE;

    len = RdrGetProviderOrderString( &pOrderString ) * sizeof(TCHAR);
    if ( len > 0 && pOrderString )
    {
        if ( !RdrFindProviderInOrder( pOrderString, PROVIDER_NAME ) )
        {
            LPTSTR pNewOrderString;

            len += sizeof( PROVIDER_NAME ) + (2 * sizeof(TCHAR)); // add 2 for comma delimeter and null
            pNewOrderString = malloc( len );
            if ( pNewOrderString )
            {
                lstrcpy( pNewOrderString, pOrderString );
                lstrcat( pNewOrderString, TEXT(",") );
                lstrcat( pNewOrderString, PROVIDER_NAME );
                success = RdrSetProviderOrderString( pNewOrderString );
                free( pNewOrderString );
            }
        }
    }
    else
    {
        success = RdrSetProviderOrderString( PROVIDER_NAME );
    }
    if ( pOrderString )
    {
        free( pOrderString );
    }

    return success;
}


ULONG_PTR RdrGetProviderOrderString( LPTSTR *OrderString )
{
    HKEY hOrderKey;
    ULONG_PTR len = 0;

    if ( OpenKey( PROVIDER_ORDER_KEY, &hOrderKey ) )
    {
        ReadRegistryKeyValues( hOrderKey,
                               sizeof(ProviderOrderKeyValues) / sizeof(REGENTRY),
                               ProviderOrderKeyValues);

        RegCloseKey(hOrderKey);
        len = ProviderOrderKeyValues[0].dwLength / sizeof( TCHAR ) - 1;
        *OrderString = (LPTSTR) ProviderOrderKeyValues[0].pvValue;
    }

    return len;
}


BOOL RdrSetProviderOrderString( LPTSTR OrderString )
{
    HKEY hOrderKey;
    ULONG len = 0;
    BOOL rc = FALSE;

    if ( CreateKey( PROVIDER_ORDER_KEY, &hOrderKey ) )
    {
        ProviderOrderKeyValues[0].dwLength = ( lstrlen( OrderString ) + 1 ) * sizeof( TCHAR );
        ProviderOrderKeyValues[0].pvValue = OrderString;
        WriteRegistryKeyValues( hOrderKey,
                                sizeof(ProviderOrderKeyValues) / sizeof(REGENTRY),
                                ProviderOrderKeyValues);
        RegCloseKey(hOrderKey);

        rc = TRUE;
    }

    return rc;
}


BOOL RdrFindProviderInOrder( LPTSTR OrderString, LPTSTR Provider )
{
    LPTSTR pCompare;
    BOOL match = FALSE;

    if ( OrderString && Provider && *Provider )
    {
        pCompare = Provider;

        while ( *OrderString )
        {
            if ( toupper(*OrderString++) != toupper(*pCompare++) )
            {
                pCompare = Provider;
            }
            if ( *pCompare == TEXT('\0') )
            {
                if ( ( *OrderString == TEXT(',') ) || ( *OrderString == TEXT('\0') ) )
                {
                    match = TRUE;
                    break;
                }
                else    // hmm, it's a substring of another provider name
                {
                    while ( ( *OrderString != TEXT(',') ) && ( *OrderString != TEXT('\0') ) )
                    {
                        OrderString++;
                    }
                    pCompare = Provider;
                }
            }

        }
    }

    return match;
}



void
ReadRegistryKeyValues(
    HKEY       hCurrentKey,
    DWORD      NumberOfValues,
    PREGENTRY pValues)
/*++

Routine Description:

    This routine reads a bunch of values associated with a given key.

Arguments:

    hCurrentKey - the key

    NumberOfValues - the number of values

    pValues - the array of values

Return Value:

   None

--*/
{
    //
    // Iterate through table reading the values along the way
    //

    DWORD  i;

    for (i = 0; i < NumberOfValues; i++)
    {
        DWORD dwType;
        LPTSTR pszKey;

        dwType  = pValues[i].dwType;
        pszKey  = pValues[i].pszKey;

        switch (dwType)
        {
        case REG_SZ:
            GetRegsz(hCurrentKey, pszKey, &pValues[i].pvValue,
                     &pValues[i].dwLength);
            break;

        case REG_DWORD:
            GetRegdw(hCurrentKey, pszKey,  &pValues[i].pvValue,
                     &pValues[i].dwLength);
            break;

        case REG_EXPAND_SZ:
            GetRegesz(hCurrentKey, pszKey, &pValues[i].pvValue,
                      &pValues[i].dwLength);
            break;

        case REG_MULTI_SZ:
            GetRegmsz(hCurrentKey, pszKey, &pValues[i].pvValue,
                      &pValues[i].dwLength);
            break;

        case REG_BINARY:
            DbgP(( TEXT("%s is a REG_BINARY and won't be duplicated\n"), pszKey ));
            break;

        default:
            DbgP(( TEXT("%s is an unknown type; %d (decimal)\n"), pszKey, dwType ));
            break;

        }
    }
}

//
// Get a REG_SZ value and stick it in the table entry, along with the
// length
//

BOOL GetRegsz(HKEY hKey, LPTSTR pszKey, PVOID * ppvValue, DWORD *pdwLength)
{
    BYTE  achValue[1024];

    DWORD dwLength;
    LONG  Status;
    DWORD dwType   = REG_SZ;
    PBYTE pszValue = NULL;



    if ( (NULL == pszKey) || (NULL == ppvValue) ||
         (NULL == hKey)   || (NULL == pdwLength))
    {
        return FALSE;
    }

#ifdef _DEBUG
    FillMemory(achValue, sizeof(achValue), 0xcd);
#endif

    dwLength = sizeof(achValue);


    Status = RegQueryValueEx( hKey,
                               pszKey,
                               NULL,
                               &dwType,
                               (PUCHAR) &achValue[0],
                               &dwLength);

    if ((ERROR_SUCCESS != Status) || (REG_SZ != dwType) )
    {
        return FALSE;
    }

    pszValue = malloc(dwLength);

    if (NULL == pszValue)
    {
        return FALSE;
    }


    CopyMemory(pszValue, achValue, dwLength);

    *ppvValue  = pszValue;
    *pdwLength = dwLength;

    return TRUE;
}

//
// Get the value of a REG_EXPAND_SZ and its length
//

BOOL GetRegesz(HKEY hKey, LPTSTR pszKey, PVOID * ppvValue, DWORD * pdwLength)
{
    BYTE  achValue[1024];

    DWORD dwLength;
    LONG  Status;
    DWORD dwType   = REG_EXPAND_SZ;
    PBYTE pszValue = NULL;


    if ( (NULL == pszKey) || (NULL == ppvValue) ||
         (NULL == hKey)   || (NULL == pdwLength))
    {
        return FALSE;
    }

#ifdef _DEBUG
    FillMemory(achValue, sizeof(achValue), 0xcd);
#endif

    dwLength = sizeof(achValue);

    Status = RegQueryValueEx( hKey,
                               pszKey,
                               NULL,
                               &dwType,
                               (PUCHAR) &achValue[0],
                               &dwLength);

    if ((ERROR_SUCCESS != Status) || (REG_EXPAND_SZ != dwType))
    {
        return FALSE;
    }

    pszValue = malloc(dwLength);

    if (NULL == pszValue)
    {
        return FALSE;
    }

    CopyMemory(pszValue, achValue, dwLength);

    *ppvValue  = pszValue;
    *pdwLength = dwLength;

    return TRUE;
}


//
// Get value and length of REG_MULTI_SZ
//

BOOL GetRegmsz(HKEY hKey, LPTSTR pszKey, PVOID * ppvValue, DWORD * pdwLength)
{
    //BYTE  achValue[1024];
    BYTE  achValue[2048];	// careful, some of these strings are quite long

    DWORD dwLength;
    LONG  Status;
    DWORD dwType   = REG_MULTI_SZ;
    PBYTE pszValue = NULL;


    if ( (NULL == pszKey) || (NULL == ppvValue) ||
        (NULL == hKey)    || (NULL == pdwLength))
    {
        return FALSE;
    }

#ifdef _DEBUG
    FillMemory(achValue, sizeof(achValue), 0xcd);
#endif


    dwLength = sizeof(achValue);


    Status = RegQueryValueEx( hKey,
                               pszKey,
                               NULL,
                               &dwType,
                               (PUCHAR) &achValue[0],
                               &dwLength);

    if ((ERROR_SUCCESS != Status) || (REG_MULTI_SZ != dwType))
    {
        return FALSE;
    }

    pszValue = malloc(dwLength);

    if (NULL == pszValue)
    {
        return FALSE;
    }

    CopyMemory(pszValue, achValue, dwLength);

    *ppvValue  = pszValue;
    *pdwLength = dwLength;

    return TRUE;
}


//
// Get value and length of REG_DWORD
//


BOOL GetRegdw(HKEY hKey, LPTSTR pszKey, PVOID * ppvValue, DWORD * pdwLength)
{
    DWORD dwValue = 0;

    DWORD dwLength;
    LONG  Status;
    DWORD dwType   = REG_DWORD;



    if ( (NULL == pszKey) || (NULL == ppvValue) ||
         (NULL == hKey)   || (NULL == pdwLength) )
    {
        return FALSE;
    }

    dwLength = sizeof(dwValue);


    Status = RegQueryValueEx( hKey,
                               pszKey,
                               NULL,
                               &dwType,
                               (PUCHAR) &dwValue,
                               &dwLength);

    if ((ERROR_SUCCESS != Status) || (REG_DWORD != dwType))
    {
        return FALSE;
    }

    *ppvValue  = (PVOID) (ULONG_PTR) dwValue;
    *pdwLength = dwLength;

    return TRUE;
}



void
WriteRegistryKeyValues(
    HKEY        hCurrentKey,
    DWORD       NumberOfValues,
    PREGENTRY  pValues)
/*++

Routine Description:

    This routine reads a bunch of values associated with a given key.

Arguments:

    hCurrentKey - the key

    NumberOfValues - the number of values

    pValues - the array of values

Return Value:

   None

--*/
{
    DWORD i;


    for (i = 0; i < NumberOfValues; i++)
    {
        DWORD dwType;
        PVOID pvValue;
        DWORD dwLength;
        LPTSTR pszKey;

        pszKey   = pValues[i].pszKey;
        dwType   = pValues[i].dwType;
        dwLength = pValues[i].dwLength;
        pvValue  = pValues[i].pvValue;

        switch (dwType)
        {
        case REG_SZ:
            AddValue(hCurrentKey, pszKey, dwType, dwLength, pvValue);
            break;

        case REG_DWORD:
            AddValue(hCurrentKey, pszKey, dwType, dwLength, &pvValue);
            break;

        case REG_EXPAND_SZ:
            AddValue(hCurrentKey, pszKey, dwType, dwLength, pvValue);
            break;

        case REG_MULTI_SZ:
            AddValue(hCurrentKey, pszKey, dwType, dwLength, pvValue);
            break;

        case REG_BINARY:
            //
            // There are no binary values we need to copy. If we did, we'd
            // put something here
            //

            break;

        default:
            DbgP(( TEXT("%s is an unknown type; %d (decimal)\n"), pszKey, dwType ));
            break;

        }
    }
}

//
// Open a key so we can read the values
//


BOOL OpenKey(
    LPTSTR pszKey,
    PHKEY phKey)
/*++

Routine Description:

    This routine opens a registry key.

Arguments:

    pszKey - the name of the key relative to HKEY_LOCAL_MACHINE

    phKey - the key handlle

Return Value:

    TRUE if successful, otherwise FALSE

--*/
{
    HKEY  hNewKey = 0;
    DWORD Status;

    Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            pszKey,
                            0,
                            KEY_QUERY_VALUE,
                            &hNewKey);

    if (ERROR_SUCCESS != Status)
    {
        *phKey = NULL;
        return FALSE;
    }
    else
    {
        *phKey = hNewKey;
        return TRUE;
    }
}


BOOL CreateKey(LPTSTR pszKey, PHKEY phKey)
/*++

Routine Description:

    This routine creates a registry key.

Arguments:

    pszKey - the name of the key relative to HKEY_LOCAL_MACHINE

    phKey - the key handlle

Return Value:

    TRUE if successful, otherwise FALSE

--*/
{
    LONG   Status;
    DWORD  Disposition;

    Status =  RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                               pszKey,
                               0,
                               REG_NONE,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               phKey,
                               &Disposition);

    if ( ERROR_SUCCESS == Status)
    {
        return TRUE;
    }
    else
    {
        DbgP(( TEXT("error creating key %s Status %d\n"), pszKey, Status ));
        return FALSE;
    }
}


//
// Add a value to the registry
//


BOOL AddValue(HKEY hKey, LPTSTR pszKey, DWORD dwType, DWORD dwLength, PVOID pvValue)
{

    BOOL fSuccess = TRUE;
    LONG Status   = ERROR_SUCCESS;
    HANDLE th;

    Status = RegSetValueEx( hKey,
                             pszKey,
                             0,
                             dwType,
                             pvValue,
                             dwLength);


    if (Status != ERROR_SUCCESS)
    {
        fSuccess = FALSE;
        //RegCloseKey(hKey);
    }

    return fSuccess;
}


// Format and write debug information to OutputDebugString
ULONG
_cdecl
DbgPrint(
    LPTSTR Format,
    ...
    )
{
    ULONG rc = 0;
    TCHAR szbuffer[255];

    va_list marker;
    va_start( marker, Format );
    {
         rc = wvsprintf( szbuffer, Format, marker );
         OutputDebugString( TRACE_TAG );
         OutputDebugString( szbuffer );
    }

    return rc;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\downlvlo.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    DownLvlO.c

Abstract:

    This module implements downlevel opens.

--*/

#include "precomp.h"
#pragma hdrstop
////
////  The Bug check file id for this module
////
//
//#define BugCheckFileId                   (RDBSS_BUG_CHECK_LOCAL_CREATE)

//
//  The debug trace level
//

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbGetFileAttributes)
#pragma alloc_text(PAGE, MRxSmbCoreDeleteForSupercedeOrClose)
#pragma alloc_text(PAGE, MRxSmbCoreCheckPath)
#pragma alloc_text(PAGE, MRxSmbCoreOpen)
#pragma alloc_text(PAGE, MRxSmbSetFileAttributes)
#pragma alloc_text(PAGE, MRxSmbCoreCreateDirectory)
#pragma alloc_text(PAGE, MRxSmbCoreCreate)
#pragma alloc_text(PAGE, MRxSmbCloseAfterCoreCreate)
#pragma alloc_text(PAGE, MRxSmbCoreTruncate)
#pragma alloc_text(PAGE, MRxSmbDownlevelCreate)
#pragma alloc_text(PAGE, MRxSmbFinishGFA)
#pragma alloc_text(PAGE, MRxSmbFinishCoreCreate)
#pragma alloc_text(PAGE, MRxSmbPopulateFileInfoInOE)
#pragma alloc_text(PAGE, MRxSmbFinishCoreOpen)
#pragma alloc_text(PAGE, MRxSmbPseudoOpenTailFromCoreCreateDirectory)
#pragma alloc_text(PAGE, MRxSmbPseudoOpenTailFromFakeGFAResponse)
#pragma alloc_text(PAGE, MRxSmbPseudoOpenTailFromGFAResponse)
#pragma alloc_text(PAGE, MRxSmbConvertSmbTimeToTime)
#pragma alloc_text(PAGE, MRxSmbConvertTimeToSmbTime)
#pragma alloc_text(PAGE, MRxSmbTimeToSecondsSince1970)
#pragma alloc_text(PAGE, MRxSmbSecondsSince1970ToTime)
#pragma alloc_text(PAGE, MRxSmbMapSmbAttributes)
#pragma alloc_text(PAGE, MRxSmbMapDisposition)
#pragma alloc_text(PAGE, MRxSmbUnmapDisposition)
#pragma alloc_text(PAGE, MRxSmbMapDesiredAccess)
#pragma alloc_text(PAGE, MRxSmbMapShareAccess)
#pragma alloc_text(PAGE, MRxSmbMapFileAttributes)
#endif

#define Dbg                              (DEBUG_TRACE_CREATE)

#pragma warning(error:4101)   // Unreferenced local variable

VOID
MRxSmbPopulateFileInfoInOE(
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    USHORT FileAttributes,
    ULONG LastWriteTimeInSeconds,
    ULONG FileSize
    );

PVOID
MRxSmbPopulateFcbInitPacketForCore(void);


NTSTATUS
MRxSmbPseudoOpenTailFromGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
      );
NTSTATUS
MRxSmbPseudoOpenTailFromFakeGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      RX_FILE_TYPE StorageType
      );
NTSTATUS
MRxSmbPseudoOpenTailFromCoreCreateDirectory (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      USHORT Attributes
      );

NTSTATUS
MRxSmbGetFileAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse. This routine also
   does the cache for the file information.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN     SrvOpen    = NULL;
    PMRX_SMB_SRV_OPEN smbSrvOpen = NULL;

    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(Exchange);

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSynchronousGetFileAttributes entering.......OE=%08lx\n",OrdinaryExchange));

    if (FsRtlDoesNameContainWildCards(RemainingName)) {
        Status = STATUS_OBJECT_NAME_INVALID;
        goto FINALLY;
    }

    // If the file has already been opened a QUERY_INFORMATION2 can be issued while
    // QUERY_INFORMATION can only be issued against pseudo opened and not yet
    // opened files.

    if (capFobx != NULL) {
        SrvOpen = capFobx->pSrvOpen;
        if (SrvOpen != NULL)
            smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    }

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    if (pServerEntry->Server.Dialect > PCNET1_DIALECT &&
        (smbSrvOpen != NULL) &&
        (!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN) &&
         !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DEFERRED_OPEN)   &&
         (NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE))) {
        COVERED_CALL(
            MRxSmbStartSMBCommand(
                StufferState,
                SetInitialSMB_ForReuse,
                SMB_COM_QUERY_INFORMATION2,
                SMB_REQUEST_SIZE(QUERY_INFORMATION2),
                NO_EXTRA_DATA,
                SMB_BEST_ALIGNMENT(1,0),
                RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
            );

        MRxSmbDumpStufferState (1100,"SMB w/ GFA before stuffing",StufferState);

        MRxSmbStuffSMB (
            StufferState,
            "0wB!",
                                        //  0         UCHAR WordCount;
            smbSrvOpen->Fid,            //  w         _USHORT(Fid);
            SMB_WCT_CHECK(1)  0         //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                        //            UCHAR Buffer[1];                    // Buffer containing:
            );

        MRxSmbDumpStufferState (700,"SMB w/ GFA after stuffing",StufferState);
    } else {
        COVERED_CALL(
            MRxSmbStartSMBCommand(
                StufferState,
                SetInitialSMB_ForReuse,
                SMB_COM_QUERY_INFORMATION,
                SMB_REQUEST_SIZE(QUERY_INFORMATION),
                NO_EXTRA_DATA,
                SMB_BEST_ALIGNMENT(1,0),
                RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
            );

        MRxSmbDumpStufferState (1100,"SMB w/ GFA before stuffing",StufferState);

        MRxSmbStuffSMB (
            StufferState,
            "0B4!",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 0
            SMB_WCT_CHECK(0)            //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                        //            UCHAR Buffer[1];                    // Buffer containing:
            RemainingName
                                        //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                        //            //UCHAR FileName[];                 //  File name
            );

        MRxSmbDumpStufferState (700,"SMB w/ GFA after stuffing",StufferState);
    }

    Status = SmbPseOrdinaryExchange(
                 SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                 SMBPSE_OETYPE_GFA
                 );

FINALLY:

    if (NT_SUCCESS(Status)) {
        OrdinaryExchange->Create.StorageTypeFromGFA =
            OrdinaryExchange->Create.FileInfo.Standard.Directory ?
            FileTypeDirectory : FileTypeFile;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbSynchronousGetFileAttributes exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCoreDeleteForSupercedeOrClose(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    BOOLEAN DeleteDirectory
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb;
    RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PMRX_SRV_OPEN     SrvOpen    = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreDeleteForSupercede entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    ASSERT( OrdinaryExchange->pPathArgument1 != NULL );

    //
    if (!DeleteDirectory) {
        ULONG SearchAttributes = SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN;  // a la rdr1

        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_DELETE,
                                    SMB_REQUEST_SIZE(DELETE),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                     );

        MRxSmbDumpStufferState (1100,"SMB w/ del before stuffing",StufferState);

        MRxSmbStuffSMB (StufferState,
             "0wB4!",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 1
                    SearchAttributes,   //  w         _USHORT( SearchAttributes );
                    SMB_WCT_CHECK(1)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                        //            UCHAR Buffer[1];                    // Buffer containing:
                    OrdinaryExchange->pPathArgument1
                                        //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                        //            //UCHAR FileName[];                 //  File name
                 );
    } else {


        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_DELETE_DIRECTORY,
                                    SMB_REQUEST_SIZE(DELETE_DIRECTORY),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                     );

        MRxSmbDumpStufferState (1100,"SMB w/ rmdir before stuffing",StufferState);

        MRxSmbStuffSMB (StufferState,
             "0B4!",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 0
                    SMB_WCT_CHECK(0)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                        //            UCHAR Buffer[1];                    // Buffer containing:
                    OrdinaryExchange->pPathArgument1
                                        //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                        //            //UCHAR FileName[];                 //  File name
                 );
    }


    MRxSmbDumpStufferState (700,"SMB w/ del/rmdir after stuffing",StufferState);

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_DELETEFORSUPERSEDEORCLOSE
                                    );

    if (Status == STATUS_SUCCESS) {
        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_FILE_DELETED);
    } else {
        RxLog(("Delete File: %x %wZ\n",Status,OrdinaryExchange->pPathArgument1));
    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreDeleteForSupercede exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbCoreCheckPath(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a GetFileAttributes and remembers the reponse.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreCheckPath entering.......OE=%08lx\n",
                                                            OrdinaryExchange));
    
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );


    COVERED_CALL(MRxSmbStartSMBCommand
                                (StufferState,SetInitialSMB_ForReuse,
                                SMB_COM_CHECK_DIRECTORY,
                                SMB_REQUEST_SIZE(CHECK_DIRECTORY),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),
                                RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ chkdir before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0B4!",
         //         UCHAR WordCount;       // Count of parameter words = 0
         SMB_WCT_CHECK(0)
         //  B    _USHORT( ByteCount );    // Count of data bytes; min = 2
         //       UCHAR Buffer[1];         // Buffer containing:
         OrdinaryExchange->pPathArgument1
         //  4    UCHAR BufferFormat;      //  0x04 -- ASCII
         //       UCHAR FileName[];        //  File name
    );


    MRxSmbDumpStufferState (700,"SMB w/ chkdir after stuffing",StufferState);

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORECHECKDIRECTORY
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg,
                ("MRxSmbCoreCheckPath exiting.......OE=%08lx, st=%08lx\n",
                 OrdinaryExchange,Status)
              );
    return(Status);
}

NTSTATUS
MRxSmbCoreOpen(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG    OpenShareMode,
    ULONG    Attribute
    )
/*++

Routine Description:

   This routine does a core open.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb; //RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;
    PSMBCE_SERVER pServer = SmbCeGetExchangeServer(Exchange);

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreOpen entering.......OE=%08lx\n",OrdinaryExchange));

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( RxContext->MajorFunction == IRP_MJ_CREATE );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_OPEN,
                                SMB_REQUEST_SIZE(OPEN),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ coreopen before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wwB4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 2
                OpenShareMode,      //  w         _USHORT( DesiredAccess );           // Mode - read/write/share
                Attribute,          //  w         _USHORT( SearchAttributes );
                SMB_WCT_CHECK(2)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
                RemainingName
                                    //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name
             );


    MRxSmbDumpStufferState (700,"SMB w/ coreopen after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_COREOPEN
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreOpen exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbSetFileAttributes(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG SmbAttributes
    )
/*++

Routine Description:

   This routine does a core create directory.....

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN     SrvOpen     = NULL;
    PMRX_SMB_SRV_OPEN smbSrvOpen  = NULL;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    ULONG LastWriteTime = 0;
    ULONG FileAttributes = 0;
    PLARGE_INTEGER pCreationTime = NULL;
    PLARGE_INTEGER pLastWriteTime = NULL;
    PLARGE_INTEGER pLastAccessTime = NULL;
    SMB_TIME SmbCreationTime;
    SMB_DATE SmbCreationDate;
    SMB_TIME SmbLastWriteTime;
    SMB_DATE SmbLastWriteDate;
    SMB_TIME SmbLastAccessTime;
    SMB_DATE SmbLastAccessDate;
    
    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSetFileAttributes entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    if (capFobx != NULL) {
        SrvOpen = capFobx->pSrvOpen;
        if (SrvOpen != NULL)
            smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    }

    SmbCreationTime.Ushort = 0;
    SmbCreationDate.Ushort = 0;
    SmbLastWriteTime.Ushort = 0;
    SmbLastWriteDate.Ushort = 0;
    SmbLastAccessTime.Ushort = 0;
    SmbLastAccessDate.Ushort = 0;

    if (RxContext->MajorFunction == IRP_MJ_SET_INFORMATION) {
        BOOLEAN GoodTime;
        
        FileAttributes = ((PFILE_BASIC_INFORMATION)OrdinaryExchange->Info.Buffer)->FileAttributes;
        pCreationTime = &((PFILE_BASIC_INFORMATION)OrdinaryExchange->Info.Buffer)->CreationTime;
        pLastWriteTime = &((PFILE_BASIC_INFORMATION)OrdinaryExchange->Info.Buffer)->LastWriteTime;
        pLastAccessTime = &((PFILE_BASIC_INFORMATION)OrdinaryExchange->Info.Buffer)->LastAccessTime;

        if (pLastWriteTime->QuadPart != 0) {
            GoodTime = MRxSmbTimeToSecondsSince1970(
                           pLastWriteTime,
                           SmbCeGetExchangeServer(OrdinaryExchange),
                           &LastWriteTime);

            if (!GoodTime) {
                Status = STATUS_INVALID_PARAMETER;
                goto FINALLY;
            }

            GoodTime = MRxSmbConvertTimeToSmbTime(pLastWriteTime,
                                       (PSMB_EXCHANGE)OrdinaryExchange,
                                       &SmbLastWriteTime,
                                       &SmbLastWriteDate);
        
            if (!GoodTime) {
                Status = STATUS_INVALID_PARAMETER;
                goto FINALLY;
            }
        }
    
        if (pLastAccessTime->QuadPart != 0) {
            GoodTime = MRxSmbConvertTimeToSmbTime(pLastAccessTime,
                                       (PSMB_EXCHANGE)OrdinaryExchange,
                                       &SmbLastAccessTime,
                                       &SmbLastAccessDate);
            
            if (!GoodTime) {
                Status = STATUS_INVALID_PARAMETER;
                goto FINALLY;
            }
        }
    
        if (pCreationTime->QuadPart != 0) {
            GoodTime = MRxSmbConvertTimeToSmbTime(pCreationTime,
                                       (PSMB_EXCHANGE)OrdinaryExchange,
                                       &SmbCreationTime,
                                       &SmbCreationDate);
            
            if (!GoodTime) {
                Status = STATUS_INVALID_PARAMETER;
                goto FINALLY;
            }
        }
    }

    if (smbSrvOpen == NULL ||
        FileAttributes != 0 ||
        RxContext->MajorFunction != IRP_MJ_SET_INFORMATION ||
        FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DEFERRED_OPEN) ||
        FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN) ||
        (pLastWriteTime->QuadPart == 0 && pLastAccessTime->QuadPart == 0 && pCreationTime->QuadPart == 0)) {
        
        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,
                                    SMB_COM_SET_INFORMATION,
                                    SMB_REQUEST_SIZE(SET_INFORMATION),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC')));

        MRxSmbDumpStufferState (1100,"SMB w/ sfa before stuffing",StufferState);

        MRxSmbStuffSMB (StufferState,
             "0wdwwwwwB4!",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 8
                    SmbAttributes,      //  w         _USHORT( FileAttributes );
                    LastWriteTime,      //  d         _ULONG( LastWriteTimeInSeconds );
                    0,0,0,0,0,          //  5*w       _USHORT( Reserved )[5];             // Reserved (must be 0)
                    SMB_WCT_CHECK(8)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                        //            UCHAR Buffer[1];                    // Buffer containing:
                    RemainingName
                                        //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                        //            //UCHAR FileName[];                 //  File name
                 );


        MRxSmbDumpStufferState (700,"SMB w/ sfa after stuffing",StufferState);
        //ASSERT(!"Now it's stuffed");

        Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                        SMBPSE_OETYPE_SFA);
    } else {
        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,
                                    SMB_COM_SET_INFORMATION2,
                                    SMB_REQUEST_SIZE(SET_INFORMATION2),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC')));

        MRxSmbDumpStufferState (1100,"SMB w/ sfa 2 before stuffing",StufferState);

        MRxSmbStuffSMB (StufferState,
             "0wwwwwwwB!",
                                               //  0         UCHAR WordCount;                    // Count of parameter words = 8
             smbSrvOpen->Fid,                  //  w         _USHORT( Fid );                     // File handle
             SmbCreationDate.Ushort,           //  w         SMB_TIME CreationDate;
             SmbCreationTime.Ushort,           //  w         SMB_TIME CreationTime;
             SmbLastAccessDate.Ushort,         //  w         SMB_TIME LastAccessDate;
             SmbLastAccessTime.Ushort,         //  w         SMB_TIME LastAccessTime;
             SmbLastWriteDate.Ushort,          //  w         SMB_TIME LastWriteDate;
             SmbLastWriteTime.Ushort,          //  w         SMB_TIME LastWriteTime;
             SMB_WCT_CHECK(7) 0                //            _USHORT( ByteCount );               // Count of data bytes; min = 0
                                               //            UCHAR Buffer[1];                    // Reserved buffer
             );


        MRxSmbDumpStufferState (700,"SMB w/ sfa 2 after stuffing",StufferState);
        //ASSERT(!"Now it's stuffed");

        Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                        SMBPSE_OETYPE_SFA2);
    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbSFAAfterCreateDirectory exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCoreCreateDirectory(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a core create directory.....

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; //RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreCreateDirectory entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( RxContext->MajorFunction == IRP_MJ_CREATE );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse,
                                SMB_COM_CREATE_DIRECTORY,
                                SMB_REQUEST_SIZE(CREATE_DIRECTORY),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ corecreatedir before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0B4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 0
                SMB_WCT_CHECK(0)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
                RemainingName
                                    //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name
             );


    MRxSmbDumpStufferState (700,"SMB w/ corecreatedir after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORECREATEDIRECTORY
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreCreateDirectory exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCoreCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG    Attribute,
    BOOLEAN CreateNew
    )
/*++

Routine Description:

   This routine does a core create.....if the flag is set we use create new.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; //RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreCreate entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );
    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( RxContext->MajorFunction == IRP_MJ_CREATE );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse,
                                (UCHAR)(CreateNew?SMB_COM_CREATE_NEW:SMB_COM_CREATE),
                                SMB_REQUEST_SIZE(CREATE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ coreopen before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wdB4!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 3
                Attribute,          //  w         _USHORT( FileAttributes );          // New file attributes
                0,                  //  d         _ULONG( CreationTimeInSeconds );        // Creation time
                SMB_WCT_CHECK(3)    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 2
                                    //            UCHAR Buffer[1];                    // Buffer containing:
                RemainingName
                                    //  4         //UCHAR BufferFormat;               //  0x04 -- ASCII
                                    //            //UCHAR FileName[];                 //  File name
             );


    MRxSmbDumpStufferState (700,"SMB w/ corecreate after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORECREATE
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreCreate exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCloseAfterCoreCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a close.....

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCloseAfterCoreCreate entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse,
                                SMB_COM_CLOSE,
                                SMB_REQUEST_SIZE(CLOSE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ closeaftercorecreate before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wdB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 3
                                    //  w         _USHORT( Fid );                     // File handle
             OrdinaryExchange->Create.FidReturnedFromCreate,
             0,                     //  d         _ULONG( LastWriteTimeInSeconds );   // Time of last write, low and high
             SMB_WCT_CHECK(3) 0     //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );


    MRxSmbDumpStufferState (700,"SMB w/ closeaftercorecreate after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CLOSEAFTERCORECREATE
                                    );

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCloseAfterCoreCreate exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbCoreTruncate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    ULONG Fid,
    ULONG FileTruncationPoint
    )
/*++

Routine Description:

   This routine does a truncate to implement FILE_OVERWRITE and FILE_OVERWRITE_IF.....
   it is also used in the "extend-for-cached-write" path.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;

    PSMBSTUFFER_BUFFER_STATE StufferState;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCoreTruncate entering.......OE=%08lx\n",OrdinaryExchange));
    StufferState = &OrdinaryExchange->AssociatedStufferState;

    ASSERT( StufferState );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse,
                                SMB_COM_WRITE,
                                SMB_REQUEST_SIZE(WRITE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0  STUFFERTRACE(Dbg,'FC'))
                 )

    MRxSmbDumpStufferState (1100,"SMB w/ coretruncate before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wwdwByw!",
                                    //  0   UCHAR WordCount;                    // Count of parameter words = 5
             Fid,                   //  w   _USHORT( Fid );                     // File handle
             0,                     //  w   _USHORT( Count );                   // Number of bytes to be written
             FileTruncationPoint,   //  d   _ULONG( Offset );                   // Offset in file to begin write
             0,                     //  w   _USHORT( Remaining );               // Bytes remaining to satisfy request
             SMB_WCT_CHECK(5)       //  B   _USHORT( ByteCount );               // Count of data bytes
                                    //      //UCHAR Buffer[1];                  // Buffer containing:
             0x01,                  //  y     UCHAR BufferFormat;               //  0x01 -- Data block
             0                      //  w     _USHORT( DataLength );            //  Length of data
                                    //        ULONG Buffer[1];                  //  Data
             );


    MRxSmbDumpStufferState (700,"SMB w/ coretruncate after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

    Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                    SMBPSE_OETYPE_CORETRUNCATE
                                    );

    if (Status == STATUS_SUCCESS) {
        LARGE_INTEGER FileSize;

        FileSize.HighPart = 0;
        FileSize.LowPart = FileTruncationPoint;
    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCoreTruncate exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}


NTSTATUS
MRxSmbDownlevelCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine implements downlevel creates.

Arguments:

    OrdinaryExchange  - an exchange to be used for conducting this open.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    For core, in particular, this is pretty painful because a different smb must be used
    for different dispositions. In addition, we cannot really open a directory.

    By in large, we will follow a strategy similar to rdr1. If the openmode maps into something that
    a downlevel server won't understand then we don't really open the file.....we just do a GFA to ensure
    that it's there and hope that we can do path-based ops for the duration.

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    RxCaptureFcb; //RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PUNICODE_STRING PathName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);
    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;

    ULONG CreateOptions = cp->CreateOptions;
    ULONG FileAttributes =  cp->FileAttributes;
    ACCESS_MASK   DesiredAccess = cp->DesiredAccess;
    USHORT        ShareAccess = (USHORT)(cp->ShareAccess);
    ULONG         Disposition = cp->Disposition;

    USHORT mappedDisposition = MRxSmbMapDisposition(Disposition);
    USHORT mappedSharingMode = MRxSmbMapShareAccess(ShareAccess);
    USHORT mappedAttributes  = MRxSmbMapFileAttributes(FileAttributes);
    USHORT mappedOpenMode    = MRxSmbMapDesiredAccess(DesiredAccess);

    LARGE_INTEGER AllocationSize = cp->AllocationSize;

    PMRXSMB_RX_CONTEXT pMRxSmbContext = MRxSmbGetMinirdrContext(RxContext);

    PSMB_EXCHANGE Exchange = (PSMB_EXCHANGE) OrdinaryExchange;
    PSMBCE_SERVER pServer = SmbCeGetExchangeServer(Exchange);

    PSMBSTUFFER_BUFFER_STATE StufferState;

    BOOLEAN MustBeAFile = (MustBeFile(CreateOptions)!=0);
    BOOLEAN MustBeADirectory = (MustBeDirectory(CreateOptions)!=0)
                                    || BooleanFlagOn(RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_STRIPPED_TRAILING_BACKSLASH);
    BOOLEAN ItsADirectory = FALSE;
    BOOLEAN ItsTheShareRoot = FALSE;

    PAGED_CODE();
    
    // Down level protocols don't have the execute mode.
    if (mappedOpenMode == (USHORT)SMB_DA_ACCESS_EXECUTE)
        mappedOpenMode = (USHORT)SMB_DA_ACCESS_READ;

    RxDbgTrace(+1, Dbg, ("MRxSmbDownlevelCreate entering.......OE=%08lx\n",OrdinaryExchange));
    RxDbgTrace( 0, Dbg, ("mapAtt,Shr,Disp,OM %04lx,%04lx,%04lx,%04lx\n",
                                  mappedAttributes,mappedSharingMode,mappedDisposition,mappedOpenMode));

    SmbPseOEAssertConsistentLinkageFromOE("Downlevel Create:");

    StufferState = &OrdinaryExchange->AssociatedStufferState;

    if (OrdinaryExchange->Create.CreateWithEasSidsOrLongName) {
        Status = STATUS_NOT_SUPPORTED;
        goto FINALLY;
    }

    if (AllocationSize.HighPart != 0) {
        Status = STATUS_INVALID_PARAMETER;
        goto FINALLY;
    }


    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    OrdinaryExchange->Create.smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    OrdinaryExchange->pPathArgument1 = PathName;

    //
    // we know that the root a share exists and that it's a directory....the catch is that GetFileAttributes
    // will return a NO_SUCH_FILE error for the root if it's really a root on the server. record this and use it
    // to our advantage later.
    if ((PathName->Length == 0)
           || ((PathName->Length == sizeof(WCHAR)) && (PathName->Buffer[0] == OBJ_NAME_PATH_SEPARATOR))  ) {
        //if must be a file, it's an error.........
        if (MustBeAFile) {
            Status = STATUS_FILE_IS_A_DIRECTORY;
            goto FINALLY;
        }

        //
        //if it's the right kind of open, i can just finish up now. these opens are common for GetFSInfo

        if ((Disposition == FILE_OPEN) || (Disposition == FILE_OPEN_IF)) {
            Status = MRxSmbPseudoOpenTailFromFakeGFAResponse ( OrdinaryExchange, FileTypeDirectory );
            goto FINALLY;
        }
        MustBeADirectory = TRUE;   // we know it's a directory!
        ItsTheShareRoot = TRUE;
    }

    //// if all the user wants is attributes and it's a FILE_OPEN, don't do the open now....
    //// rather, we'll send pathbased ops later (or do a deferred open if necessary)...
    
    if (Disposition == FILE_OPEN && 
        (MustBeADirectory || 
         !(cp->DesiredAccess & ~(SYNCHRONIZE | DELETE | FILE_READ_ATTRIBUTES)))) {
        Status = MRxSmbPseudoOpenTailFromFakeGFAResponse(OrdinaryExchange, MustBeADirectory?FileTypeDirectory:FileTypeFile);
        
        if (Status == STATUS_SUCCESS) {
            Status = MRxSmbQueryFileInformationFromPseudoOpen(
                         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);

            if (Status == STATUS_SUCCESS) {
                if (MustBeADirectory && 
                    !OrdinaryExchange->Create.FileInfo.Standard.Directory) {
                    Status = STATUS_NOT_A_DIRECTORY;
                }

                if (MustBeAFile &&
                    OrdinaryExchange->Create.FileInfo.Standard.Directory) {
                    Status = STATUS_FILE_IS_A_DIRECTORY;
                }
            }

            if (Status != STATUS_SUCCESS) {
                RxFreePool(smbSrvOpen->DeferredOpenContext);
            }
        }

        goto FINALLY;
    }

    if ( (mappedOpenMode == ((USHORT)-1)) ||
         (Disposition == FILE_SUPERSEDE) ||
         (!MustBeAFile)
       ) {

        //
        // go find out what's there.......

        Status = MRxSmbGetFileAttributes(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);

        if (Status == STATUS_SUCCESS && 
            MustBeADirectory &&
            !OrdinaryExchange->Create.FileInfo.Standard.Directory) {
            Status = STATUS_NOT_A_DIRECTORY;
            goto FINALLY;
        }
        
        RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate GFAorCPstatus=%08lx\n",Status));

        if (NT_SUCCESS(Status)) {
            ULONG Attributes = SmbGetUshort(&OrdinaryExchange->Create.FileInfo.Basic.FileAttributes);
            ItsADirectory = BooleanFlagOn(Attributes,SMB_FILE_ATTRIBUTE_DIRECTORY);
            RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate attributes=%08lx\n",Attributes));
            if ((Disposition==FILE_CREATE)) {
                Status = STATUS_OBJECT_NAME_COLLISION;
                goto FINALLY;
            }
            if (MustBeADirectory && !ItsADirectory && (Disposition!=FILE_SUPERSEDE)) {
                if (Disposition == FILE_OPEN) {
                    // This fix is required for the DFS driver which seems to handle
                    // STATUS_OBJECT_TYPE_MISMATCH in a special way.
                    // DFS should be fixed.
                    Status = STATUS_OBJECT_NAME_COLLISION;
                } else {
                    Status = STATUS_OBJECT_TYPE_MISMATCH;
                }
                goto FINALLY;
            }
            if (MustBeAFile && ItsADirectory && (Disposition!=FILE_SUPERSEDE)) {
                if (Disposition == FILE_OPEN) {
                    // This fix is required for the DFS driver which seems to handle
                    // STATUS_OBJECT_TYPE_MISMATCH in a special way.
                    // DFS should be fixed.
                    Status = STATUS_FILE_IS_A_DIRECTORY;
                } else {
                    Status = STATUS_OBJECT_TYPE_MISMATCH;
                }
                goto FINALLY;
            }
            //if (!MustBeAFile && ItsADirectory && (Disposition==FILE_OPEN)){
            if (Disposition==FILE_OPEN || Disposition==FILE_OPEN_IF){
                //we're done except to finish AND to set the flags in the srvopen
                MRxSmbPseudoOpenTailFromGFAResponse ( OrdinaryExchange );
                goto FINALLY;
            }
        } else if ( (Status!=STATUS_NO_SUCH_FILE)
                           && (Status!=STATUS_OBJECT_PATH_NOT_FOUND) ) {
            goto FINALLY;
        } else if ((Disposition==FILE_CREATE)
                     || (Disposition==FILE_OPEN_IF)
                     || (Disposition==FILE_OVERWRITE_IF)
                     || (Disposition==FILE_SUPERSEDE)) {
            NOTHING;
        } else if (ItsTheShareRoot) {
            PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
            PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
            //here we have run into a true root....so we can't get attributes. fill in a fake
            //response and finish. also, flip the bit that says we can't gfa this guy.
            Status = MRxSmbPseudoOpenTailFromFakeGFAResponse ( OrdinaryExchange, FileTypeDirectory );
            smbSrvOpen->Flags |= SMB_SRVOPEN_FLAG_CANT_GETATTRIBS;
            goto FINALLY;
        } else {
            goto FINALLY;
        }
    }


    SmbCeResetExchange(&OrdinaryExchange->Exchange);  //must reset!

    if (NT_SUCCESS(Status) &&(Disposition == FILE_SUPERSEDE)) {
        //
        //we have to get rid of the existing entity...using a delete or a rmdir as appropriate
        Status = MRxSmbCoreDeleteForSupercedeOrClose(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                                      OrdinaryExchange->Create.FileInfo.Standard.Directory
                                                     );
        if (!NT_SUCCESS(Status)) {
            RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate could notsupersede st=%08lx\n",Status));
            goto FINALLY;
        }
        SmbCeResetExchange(&OrdinaryExchange->Exchange);  //must reset!
    }

    if (MustBeADirectory || (ItsADirectory &&(Disposition == FILE_SUPERSEDE)) ) {

        ASSERT (Disposition!=FILE_OPEN);
        Status = MRxSmbCoreCreateDirectory(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
        if (!NT_SUCCESS(Status)) {
            RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate couldn't mkdir st=%08lx\n",Status));
            goto FINALLY;
        }

        if ((mappedAttributes &
             (SMB_FILE_ATTRIBUTE_READONLY |
              SMB_FILE_ATTRIBUTE_HIDDEN   |
              SMB_FILE_ATTRIBUTE_SYSTEM   |
              SMB_FILE_ATTRIBUTE_ARCHIVE)) != 0) {
            //
            //we have to set the attributes
            Status = MRxSmbSetFileAttributes(
                         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                         mappedAttributes);

            if (!NT_SUCCESS(Status)) {
                RxDbgTrace(0, Dbg, ("MRxSmbDownlevelCreate couldn't sfa st=%08lx\n",Status));
            }
        }

        MRxSmbPseudoOpenTailFromCoreCreateDirectory( OrdinaryExchange, mappedAttributes );

        goto FINALLY;
    }


    //if ( (mappedOpenMode != -1) && !MustBeADirectory) {
    //no pseudoOpens yet
    if ( TRUE ) {

        ULONG workingDisposition = Disposition;
        ULONG iterationcount;
        BOOLEAN MayNeedATruncate = FALSE;

       //
       // we use the disposition as a state and case out.....some are hard and some are easy
       //     for example, if it's CREATE then we use the CREATE_NEW to create the file but
       //                  the resulting open is no good so we close it and open it again using the
       //                  open. for OPEN_IF  we assume that the file will be there
       //                  and drop into create if it's not.

       for (iterationcount=0;;iterationcount++) {
           switch (workingDisposition) {
           case FILE_OVERWRITE:
           case FILE_OVERWRITE_IF:
               MayNeedATruncate = TRUE;
               //lack of break intentional
           case FILE_OPEN_IF:
           case FILE_OPEN:
               Status = MRxSmbCoreOpen(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                           mappedOpenMode|mappedSharingMode,
                                           mappedAttributes);
               //if (Status==RxStatus(NO_SUCH_FILE)) {
               //    DbgPrint("%08lx %08lx %08lx\n",Status,workingDisposition,iterationcount);
               //    DbgBreakPoint();
               //}
               if (!((workingDisposition == FILE_OPEN_IF) || (workingDisposition == FILE_OVERWRITE_IF))
                    || (Status!=STATUS_NO_SUCH_FILE)
                    || (iterationcount>6)
                    )break;
               SmbCeResetExchange(&OrdinaryExchange->Exchange);  //must reset!
           case FILE_SUPERSEDE:
           case FILE_CREATE:
               Status = MRxSmbCoreCreate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                           mappedAttributes,TRUE); //(workingDisposition==FILE_CREATE));
               if (!NT_SUCCESS(Status)) {
                    RxDbgTrace(-1, Dbg, ("MRxSmbDownlevelCreate exiting.......createnew failed st=%08lx\n",Status));
                    break;
               }

               //now, we have a network handle. BUT, it's a compatibility-mode open. since we don't want that we
               //     need to close and reopen with the parameters specified. there is a window here! what can i do??

               Status = MRxSmbCloseAfterCoreCreate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);
               if (!NT_SUCCESS(Status)) {
                    RxDbgTrace(-1, Dbg, ("MRxSmbDownlevelCreate exiting.......closeaftercreatenew failed st=%08lx\n",Status));
                    break;
               }

               workingDisposition = FILE_OPEN_IF;
               continue;     // this wraps back to the switch with a new disposition
               //break;
           //case FILE_SUPERSEDE:
           //    Status = RxStatus(NOT_SUPPORTED);
           //    break;
           default :
               ASSERT(!"Bad Disposition");
               Status = STATUS_INVALID_PARAMETER;
           }
           break; //exit the loop
       }
       if (!NT_SUCCESS(Status))goto FINALLY;
       //we may need a truncate....this is different from rdr1.
       if (MayNeedATruncate
                 && !OrdinaryExchange->Create.FileWasCreated
                 && (OrdinaryExchange->Create.FileSizeReturnedFromOpen!=0)  ) {
           Status = MRxSmbCoreTruncate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                       OrdinaryExchange->Create.FidReturnedFromOpen,
                                       0
           );
       }

       goto FINALLY;
    }

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbDownlevelCreate exiting.......OE=%08lx, st=%08lx\n",OrdinaryExchange,Status));
    return(Status);
}

NTSTATUS
MRxSmbFinishGFA (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PBYTE                       Response
      )
/*++

Routine Description:

    This routine copies the response to the GetFileAttributes SMB. But, it must be called synchronously.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    what we do here is to put the data into the ordinary exchange...it's locked down do
    we could do this at DPC level

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PFILE_BASIC_INFORMATION BasicInformation = &OrdinaryExchange->Create.FileInfo.Basic;
    PFILE_STANDARD_INFORMATION StandardInformation = &OrdinaryExchange->Create.FileInfo.Standard;

    PSMB_PARAMS pSmbParams = (PSMB_PARAMS)Response;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishGFA\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishGFA:");

    if (pSmbParams->WordCount == 10) {
        PRESP_QUERY_INFORMATION pQueryInformationResponse;

        pQueryInformationResponse = (PRESP_QUERY_INFORMATION)Response;

        //what we do here is to put the data into the ordinary exchange...it's locked down do
        //we wcould do this at DPC level

        MRxSmbPopulateFileInfoInOE(
            OrdinaryExchange,
            SmbGetUshort(&pQueryInformationResponse->FileAttributes),
            SmbGetUlong(&pQueryInformationResponse->LastWriteTimeInSeconds),
            SmbGetUlong(&pQueryInformationResponse->FileSize)
            );

    } else if (pSmbParams->WordCount == 11) {
        PRESP_QUERY_INFORMATION2 pQueryInformation2Response;
        SMB_TIME                 LastWriteSmbTime;
        SMB_DATE                 LastWriteSmbDate;
        LARGE_INTEGER            LastWriteTime;
        ULONG                    LastWriteTimeInSeconds;

        pQueryInformation2Response = (PRESP_QUERY_INFORMATION2)Response;

        RtlCopyMemory(
            &LastWriteSmbTime,
            &pQueryInformation2Response->LastWriteTime,
            sizeof(SMB_TIME));

        RtlCopyMemory(
            &LastWriteSmbDate,
            &pQueryInformation2Response->LastWriteDate,
            sizeof(SMB_DATE));

        LastWriteTime = MRxSmbConvertSmbTimeToTime(NULL,LastWriteSmbTime,LastWriteSmbDate);

        MRxSmbTimeToSecondsSince1970(
            &LastWriteTime,
            NULL,
            &LastWriteTimeInSeconds);

        MRxSmbPopulateFileInfoInOE(
            OrdinaryExchange,
            SmbGetUshort(&pQueryInformation2Response->FileAttributes),
            LastWriteTimeInSeconds,
            SmbGetUlong(&pQueryInformation2Response->FileDataSize)
            );
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishGFA   returning %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbCreateFileSuccessTail (
    PRX_CONTEXT  RxContext,
    PBOOLEAN MustRegainExclusiveResource,
    RX_FILE_TYPE StorageType,
    SMB_FILE_ID Fid,
    ULONG ServerVersion,
    UCHAR OplockLevel,
    ULONG CreateAction,
    PSMBPSE_FILEINFO_BUNDLE FileInfo
    );

NTSTATUS
MRxSmbFinishCoreCreate (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_CREATE                Response
      )
/*++

Routine Description:

    This routine copies the fid from a core create response. it does not finish the fcb......if a compatibility
    mode open is acceptable then it could.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishCoreCreate\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishCoreCreate:");

    if (Response->WordCount != 1 ||
        SmbGetUshort(&Response->ByteCount) != 0) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
    } else {
        OrdinaryExchange->Create.FidReturnedFromCreate = SmbGetUshort(&Response->Fid);
        OrdinaryExchange->Create.FileWasCreated = TRUE;
        //notice that we didn't finish here! we should IFF a compatibilty-mode open is okay
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishCoreCreate   returning %08lx\n", Status ));
    return Status;
}

#define JUST_USE_THE_STUFF_IN_THE_OE (0xfbad)
VOID
MRxSmbPopulateFileInfoInOE(
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    USHORT FileAttributes,
    ULONG LastWriteTimeInSeconds,
    ULONG FileSize
    )
{
    PFILE_BASIC_INFORMATION BasicInformation = &OrdinaryExchange->Create.FileInfo.Basic;
    PFILE_STANDARD_INFORMATION StandardInformation = &OrdinaryExchange->Create.FileInfo.Standard;

    BasicInformation->FileAttributes = MRxSmbMapSmbAttributes(FileAttributes);
    StandardInformation->NumberOfLinks = 1;
    BasicInformation->CreationTime.QuadPart = 0;
    BasicInformation->LastAccessTime.QuadPart = 0;
    MRxSmbSecondsSince1970ToTime(LastWriteTimeInSeconds,
                                 SmbCeGetExchangeServer(OrdinaryExchange),
                                 &BasicInformation->LastWriteTime);
    BasicInformation->ChangeTime.QuadPart = 0;
    StandardInformation->AllocationSize.QuadPart = FileSize; //rdr1 actually rounds up based of svr disk attribs
    StandardInformation->EndOfFile.QuadPart = FileSize;
    StandardInformation->Directory = BooleanFlagOn(BasicInformation->FileAttributes,FILE_ATTRIBUTE_DIRECTORY);
}


NTSTATUS
MRxSmbFinishCoreOpen (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_OPEN                  Response
      )
/*++

Routine Description:

    This routine finishes a core open.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    PMRX_SRV_OPEN        SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID Fid;
    ULONG CreateAction;

    ULONG FileSize;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishCoreOpen\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishCoreOpen:");

    if (Response->WordCount != 7 ||
        SmbGetUshort(&Response->ByteCount) != 0) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
        goto FINALLY;
    }

    StorageType = FileTypeFile;
    Fid = SmbGetUshort(&Response->Fid);
    OrdinaryExchange->Create.FidReturnedFromOpen = Fid;
    FileSize = OrdinaryExchange->Create.FileSizeReturnedFromOpen = SmbGetUlong(&Response->DataSize);

    CreateAction = (OrdinaryExchange->Create.FileWasCreated)?FILE_CREATED
                        : (OrdinaryExchange->Create.FileWasTruncated)?FILE_OVERWRITTEN
                        :FILE_OPENED;

    MRxSmbPopulateFileInfoInOE(
        OrdinaryExchange,
        SmbGetUshort(&Response->FileAttributes),
        SmbGetUlong(&Response->LastWriteTimeInSeconds),
        FileSize
        );

    pFileInfo->Basic.FileAttributes    = OrdinaryExchange->Create.FileInfo.Basic.FileAttributes;
    pFileInfo->Basic.CreationTime      = OrdinaryExchange->Create.FileInfo.Basic.CreationTime;
    pFileInfo->Basic.LastAccessTime    = OrdinaryExchange->Create.FileInfo.Basic.LastAccessTime;
    pFileInfo->Basic.LastWriteTime     = OrdinaryExchange->Create.FileInfo.Basic.LastWriteTime;
    pFileInfo->Basic.ChangeTime        = OrdinaryExchange->Create.FileInfo.Basic.ChangeTime;
    pFileInfo->Standard.NumberOfLinks  = OrdinaryExchange->Create.FileInfo.Standard.NumberOfLinks;
    pFileInfo->Standard.AllocationSize = OrdinaryExchange->Create.FileInfo.Standard.AllocationSize;
    pFileInfo->Standard.EndOfFile      = OrdinaryExchange->Create.FileInfo.Standard.EndOfFile;
    pFileInfo->Standard.Directory      = FALSE;

    MRxSmbCreateFileSuccessTail (   RxContext,
                                    &OrdinaryExchange->Create.MustRegainExclusiveResource,
                                    StorageType,
                                    Fid,
                                    OrdinaryExchange->ServerVersion,
                                    SMB_OPLOCK_LEVEL_NONE,
                                    CreateAction,
                                    pFileInfo);

FINALLY:
    IF_DEBUG{
        RxCaptureFcb;
        RxDbgTrace(-1, Dbg, ("MRxSmbFinishCoreOpen   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));
    }
    return Status;
}

NTSTATUS
MRxSmbPseudoOpenTailFromCoreCreateDirectory (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      USHORT Attributes
      )
/*++

Routine Description:

    This routine finishes a core create directory. but, it is not called from the receive routine......

Arguments:

    OrdinaryExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID Fid;
    ULONG CreateAction;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishCoreCreateDirectory\n", 0 ));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishCoreCreateDirectory:");

    StorageType = FileTypeDirectory;
    Fid = 0xbadd;

    CreateAction = FILE_CREATED;
    MRxSmbPopulateFileInfoInOE(
        OrdinaryExchange,
        Attributes,
        0,
        0
        );

    pFileInfo->Basic.FileAttributes    = OrdinaryExchange->Create.FileInfo.Basic.FileAttributes;
    pFileInfo->Basic.CreationTime      = OrdinaryExchange->Create.FileInfo.Basic.CreationTime;
    pFileInfo->Basic.LastAccessTime    = OrdinaryExchange->Create.FileInfo.Basic.LastAccessTime;
    pFileInfo->Basic.LastWriteTime     = OrdinaryExchange->Create.FileInfo.Basic.LastWriteTime;
    pFileInfo->Basic.ChangeTime        = OrdinaryExchange->Create.FileInfo.Basic.ChangeTime;
    pFileInfo->Standard.NumberOfLinks  = OrdinaryExchange->Create.FileInfo.Standard.NumberOfLinks;
    pFileInfo->Standard.AllocationSize = OrdinaryExchange->Create.FileInfo.Standard.AllocationSize;
    pFileInfo->Standard.EndOfFile      = OrdinaryExchange->Create.FileInfo.Standard.EndOfFile;
    pFileInfo->Standard.Directory      = TRUE;

    smbSrvOpen->Flags |=  SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN;  //this indicates a pseudoopen to success tail
    MRxSmbCreateFileSuccessTail (   RxContext,
                                    &OrdinaryExchange->Create.MustRegainExclusiveResource,
                                    StorageType,
                                    Fid,
                                    OrdinaryExchange->ServerVersion,
                                    SMB_OPLOCK_LEVEL_NONE,
                                    CreateAction,
                                    pFileInfo);

    IF_DEBUG{
        RxCaptureFcb;
        RxDbgTrace(-1, Dbg, ("MRxSmbFinishCoreCreateDirectory   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));
    }
    return Status;
}

NTSTATUS
MRxSmbPseudoOpenTailFromFakeGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      RX_FILE_TYPE StorageType
      )
/*++

Routine Description:

    This routine finishes a pseudoopen from faked up information. Basically, we fill in
    the information that would have been obtained on a GET_FILE_ATTRIBUTES smb and then call
    the PseudoOpenFromGFA routine

Arguments:

    OrdinaryExchange - the exchange instance
    StorageType - the type of thing that this is supposed to be. If it's supposed to be
                  a directory then we set the attributes bit in the GFA info.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT Attributes = 0;

    PAGED_CODE();

    RtlZeroMemory(
        &OrdinaryExchange->Create.FileInfo,
        sizeof(OrdinaryExchange->Create.FileInfo));

    if (StorageType == FileTypeDirectory) {
        Attributes = SMB_FILE_ATTRIBUTE_DIRECTORY;
    }

    MRxSmbPopulateFileInfoInOE(OrdinaryExchange,Attributes,0,0);
    OrdinaryExchange->Create.StorageTypeFromGFA = StorageType;

    return( MRxSmbPseudoOpenTailFromGFAResponse (OrdinaryExchange) );
}


NTSTATUS
MRxSmbPseudoOpenTailFromGFAResponse (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
      )
/*++

Routine Description:

    This routine finishes a pseudoopen from the information obtained on a
    GET_FILE_ATTRIBUTES smb.

Arguments:

    OrdinaryExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    SMB_FILE_ID Fid;
    ULONG CreateAction;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishPseudoOpenFromGFAResponse\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishPseudoOpenFromGFAResponse:");

    Fid = 0xbadd;

    CreateAction = FILE_OPENED;

    pFileInfo->Basic.FileAttributes    = OrdinaryExchange->Create.FileInfo.Basic.FileAttributes;
    pFileInfo->Basic.CreationTime      = OrdinaryExchange->Create.FileInfo.Basic.CreationTime;
    pFileInfo->Basic.LastAccessTime    = OrdinaryExchange->Create.FileInfo.Basic.LastAccessTime;
    pFileInfo->Basic.LastWriteTime     = OrdinaryExchange->Create.FileInfo.Basic.LastWriteTime;
    pFileInfo->Basic.ChangeTime        = OrdinaryExchange->Create.FileInfo.Basic.ChangeTime;
    pFileInfo->Standard.NumberOfLinks  = OrdinaryExchange->Create.FileInfo.Standard.NumberOfLinks;
    pFileInfo->Standard.AllocationSize = OrdinaryExchange->Create.FileInfo.Standard.AllocationSize;
    pFileInfo->Standard.EndOfFile      = OrdinaryExchange->Create.FileInfo.Standard.EndOfFile;
    pFileInfo->Standard.Directory      = (OrdinaryExchange->Create.StorageTypeFromGFA == FileTypeDirectory);

    smbSrvOpen->Flags |=  SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN;  //this indicates a pseudoopen to success tail
    MRxSmbCreateFileSuccessTail (   RxContext,
                                    &OrdinaryExchange->Create.MustRegainExclusiveResource,
                                    OrdinaryExchange->Create.StorageTypeFromGFA,
                                    Fid,
                                    OrdinaryExchange->ServerVersion,
                                    SMB_OPLOCK_LEVEL_NONE,
                                    CreateAction,
                                    pFileInfo);

    if (smbSrvOpen->DeferredOpenContext == NULL) {
        // Already has a deferred open context created on MRxSmbCreateFileSuccessTail
        Status = MRxSmbConstructDeferredOpenContext(RxContext);
    } else {
        // The flag has been cleared when a deferred open context was created.
        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DEFERRED_OPEN);
    }

    if (Status!=STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("MRxSmbFinishPseudoOpenFromGFAResponse construct dfo failed %08lx \n",Status));
    }

    IF_DEBUG{
        RxCaptureFcb;
        RxDbgTrace(-1, Dbg, ("MRxSmbFinishPseudoOpenFromGFAResponse   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));
    }
    return Status;
}

LARGE_INTEGER
MRxSmbConvertSmbTimeToTime (
    //IN PSMB_EXCHANGE Exchange OPTIONAL,
    IN PSMBCE_SERVER Server OPTIONAL,
    IN SMB_TIME Time,
    IN SMB_DATE Date
    )

/*++

Routine Description:

    This routine converts an SMB time to an NT time structure.

Arguments:

    IN SMB_TIME Time - Supplies the time of day to convert
    IN SMB_DATE Date - Supplies the day of the year to convert
    IN supplies the server for tz bias.

Return Value:

    LARGE_INTEGER - Time structure describing input time.


--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER OutputTime;

    PAGED_CODE();

    //
    // This routine cannot be paged because it is called from both the
    // MRxSmbFileDiscardableSection and the MRxSmbVCDiscardableSection.
    //

    if (SmbIsTimeZero(&Date) && SmbIsTimeZero(&Time)) {
        OutputTime.LowPart = OutputTime.HighPart = 0;
    } else {
        TimeFields.Year = Date.Struct.Year + (USHORT )1980;
        TimeFields.Month = Date.Struct.Month;
        TimeFields.Day = Date.Struct.Day;

        TimeFields.Hour = Time.Struct.Hours;
        TimeFields.Minute = Time.Struct.Minutes;
        TimeFields.Second = Time.Struct.TwoSeconds*(USHORT )2;
        TimeFields.Milliseconds = 0;

        //
        //  Make sure that the times specified in the SMB are reasonable
        //  before converting them.
        //

        if (TimeFields.Year < 1601) {
            TimeFields.Year = 1601;
        }

        if (TimeFields.Month > 12) {
            TimeFields.Month = 12;
        }

        if (TimeFields.Hour >= 24) {
            TimeFields.Hour = 23;
        }
        if (TimeFields.Minute >= 60) {
            TimeFields.Minute = 59;
        }
        if (TimeFields.Second >= 60) {
            TimeFields.Second = 59;

        }

        if (!RtlTimeFieldsToTime(&TimeFields, &OutputTime)) {
            OutputTime.HighPart = 0;
            OutputTime.LowPart = 0;

            return OutputTime;
        }

#ifndef WIN9X
        if (ARGUMENT_PRESENT(Server)) {
            OutputTime.QuadPart = OutputTime.QuadPart + Server->TimeZoneBias.QuadPart;
        }

        ExLocalTimeToSystemTime(&OutputTime, &OutputTime);
#else
        OutputTime.HighPart = 0;
        OutputTime.LowPart = 0;
#endif

    }

    return OutputTime;

}

BOOLEAN
MRxSmbConvertTimeToSmbTime (
    IN PLARGE_INTEGER InputTime,
    IN PSMB_EXCHANGE Exchange OPTIONAL,
    OUT PSMB_TIME Time,
    OUT PSMB_DATE Date
    )

/*++

Routine Description:

    This routine converts an NT time structure to an SMB time.

Arguments:

    IN LARGE_INTEGER InputTime - Supplies the time to convert.
    OUT PSMB_TIME Time - Returns the converted time of day.
    OUT PSMB_DATE Date - Returns the converted day of the year.


Return Value:

    BOOLEAN - TRUE if input time could be converted.


--*/

{
    TIME_FIELDS TimeFields;

    PAGED_CODE();

    if (InputTime->LowPart == 0 && InputTime->HighPart == 0) {
        Time->Ushort = Date->Ushort = 0;
    } else {
        LARGE_INTEGER LocalTime;

        ExSystemTimeToLocalTime(InputTime, &LocalTime);

        if (ARGUMENT_PRESENT(Exchange)) {
            PSMBCE_SERVER Server = SmbCeGetExchangeServer(Exchange);
            LocalTime.QuadPart -= Server->TimeZoneBias.QuadPart;
        }

        RtlTimeToTimeFields(&LocalTime, &TimeFields);

        if (TimeFields.Year < 1980) {
            return FALSE;
        }

        Date->Struct.Year = (USHORT )(TimeFields.Year - 1980);
        Date->Struct.Month = TimeFields.Month;
        Date->Struct.Day = TimeFields.Day;

        Time->Struct.Hours = TimeFields.Hour;
        Time->Struct.Minutes = TimeFields.Minute;

        //
        //  When converting from a higher granularity time to a lesser
        //  granularity time (seconds to 2 seconds), always round up
        //  the time, don't round down.
        //

        Time->Struct.TwoSeconds = (TimeFields.Second + (USHORT)1) / (USHORT )2;

    }

    return TRUE;
}


BOOLEAN
MRxSmbTimeToSecondsSince1970 (
    IN PLARGE_INTEGER CurrentTime,
    IN PSMBCE_SERVER Server OPTIONAL,
    OUT PULONG SecondsSince1970
    )
/*++

Routine Description:

    This routine returns the CurrentTime in UTC and returns the
    equivalent current time in the servers timezone.


Arguments:

    IN PLARGE_INTEGER CurrentTime - Supplies the current system time in UTC.

    IN PSMBCE_SERVER Server       - Supplies the difference in timezones between
                                    the server and the workstation. If not supplied
                                    then the assumption is that they are in the
                                    same timezone.

    OUT PULONG SecondsSince1970   - Returns the # of seconds since 1970 in
                                    the servers timezone or MAXULONG if conversion
                                    fails.

Return Value:

    BOOLEAN - TRUE if the time could be converted.

--*/
{
    LARGE_INTEGER ServerTime;
    LARGE_INTEGER TempTime;
    BOOLEAN ReturnValue;

    PAGED_CODE();

    if (ARGUMENT_PRESENT(Server) &&
        ((*CurrentTime).QuadPart != 0)) {

        TempTime.QuadPart = (*CurrentTime).QuadPart - Server->TimeZoneBias.QuadPart;

        ExSystemTimeToLocalTime(&TempTime, &ServerTime);
    } else {
        ExSystemTimeToLocalTime(CurrentTime, &ServerTime);
    }

    ReturnValue = RtlTimeToSecondsSince1970(&ServerTime, SecondsSince1970);

    if ( ReturnValue == FALSE ) {
        //
        //  We can't represent the time legally, peg it at
        //  the max legal time.
        //

        *SecondsSince1970 = MAXULONG;
    }

    return ReturnValue;
}

VOID
MRxSmbSecondsSince1970ToTime (
    IN ULONG SecondsSince1970,
    //IN PSMB_EXCHANGE Exchange OPTIONAL,
    IN PSMBCE_SERVER Server,
    OUT PLARGE_INTEGER CurrentTime
    )
/*++

Routine Description:

    This routine returns the Local system time derived from a time
    in seconds in the servers timezone.


Arguments:

    IN ULONG SecondsSince1970 - Supplies the # of seconds since 1970 in
                                servers timezone.

    IN PSMB_EXCHANGE Exchange - Supplies the difference in timezones between
                                the server and the workstation. If not supplied
                                then the assumption is that they are in the
                                same timezone.

    OUT PLARGE_INTEGER CurrentTime - Returns the current system time in UTC.

Return Value:

    None.


--*/

{
    LARGE_INTEGER LocalTime;

    PAGED_CODE();

    RtlSecondsSince1970ToTime (SecondsSince1970, &LocalTime);

    ExLocalTimeToSystemTime(&LocalTime, CurrentTime);

    if (ARGUMENT_PRESENT(Server)) {
        (*CurrentTime).QuadPart = (*CurrentTime).QuadPart + Server->TimeZoneBias.QuadPart;
    }

    return;

}

ULONG
MRxSmbMapSmbAttributes (
    IN USHORT SmbAttribs
    )

/*++

Routine Description:

    This routine maps an SMB (DOS/OS2) file attribute into an NT
    file attribute.


Arguments:

    IN USHORT SmbAttribs - Supplies the SMB attribute to map.


Return Value:

    ULONG - NT Attribute mapping SMB attribute


--*/

{
    ULONG Attributes = 0;

    PAGED_CODE();

    if (SmbAttribs==0) {
        Attributes = FILE_ATTRIBUTE_NORMAL;
    } else {

        ASSERT (SMB_FILE_ATTRIBUTE_READONLY == FILE_ATTRIBUTE_READONLY);
        ASSERT (SMB_FILE_ATTRIBUTE_HIDDEN == FILE_ATTRIBUTE_HIDDEN);
        ASSERT (SMB_FILE_ATTRIBUTE_SYSTEM == FILE_ATTRIBUTE_SYSTEM);
        ASSERT (SMB_FILE_ATTRIBUTE_ARCHIVE == FILE_ATTRIBUTE_ARCHIVE);
        ASSERT (SMB_FILE_ATTRIBUTE_DIRECTORY == FILE_ATTRIBUTE_DIRECTORY);

        Attributes = SmbAttribs & FILE_ATTRIBUTE_VALID_FLAGS;
    }
    return Attributes;
}

USHORT
MRxSmbMapDisposition (
    IN ULONG Disposition
    )

/*++

Routine Description:

    This routine takes an NT disposition, and maps it into an OS/2
    CreateAction to be put into an SMB.


Arguments:

    IN ULONG Disposition - Supplies the NT disposition to map.


Return Value:

    USHORT - OS/2 Access mapping that maps NT access

--*/

{
    PAGED_CODE();

    switch (Disposition) {
    case FILE_OVERWRITE_IF:
    case FILE_SUPERSEDE:
        return SMB_OFUN_OPEN_TRUNCATE | SMB_OFUN_CREATE_CREATE;
        break;

    case FILE_CREATE:
        return SMB_OFUN_OPEN_FAIL | SMB_OFUN_CREATE_CREATE;
        break;

    case FILE_OVERWRITE:
        return SMB_OFUN_OPEN_TRUNCATE | SMB_OFUN_CREATE_FAIL;
        break;

    case FILE_OPEN:
        return SMB_OFUN_OPEN_OPEN | SMB_OFUN_CREATE_FAIL;
        break;

    case FILE_OPEN_IF:
        return SMB_OFUN_OPEN_OPEN | SMB_OFUN_CREATE_CREATE;
        break;

    default:
        //InternalError(("Unknown disposition passed to MRxSmbMapDisposition"));
        //MRxSmbInternalError(EVENT_RDR_DISPOSITION);
        return 0;
        break;
    }
}


ULONG
MRxSmbUnmapDisposition (
    IN USHORT SmbDisposition,
    ULONG     Disposition
    )

/*++

Routine Description:

    This routine takes an OS/2 disposition and maps it into an NT
    disposition.

Arguments:

    IN USHORT SmbDisposition - Supplies the OS/2 disposition to map.

Return Value:

    ULONG - NT disposition mapping OS/2 disposition

--*/

{
    ULONG MapDisposition;

    PAGED_CODE();

    //
    //  Mask off oplocked bit.
    //

    switch (SmbDisposition & 0x7fff) {

    case SMB_OACT_OPENED:
        MapDisposition = FILE_OPENED;
        break;

    case SMB_OACT_CREATED:
        MapDisposition = FILE_CREATED;
        break;

    case SMB_OACT_TRUNCATED:
        MapDisposition = FILE_OVERWRITTEN;
        break;

    default:
        MapDisposition = Disposition;
    }

    return MapDisposition;
}


USHORT
MRxSmbMapDesiredAccess (
    IN ULONG DesiredAccess
    )

/*++

Routine Description:

    This routine takes an NT DesiredAccess value and converts it
    to an OS/2 access mode.


Arguments:

    IN ULONG DesiredAccess - Supplies the NT desired access to map.

Return Value:

    USHORT - The mapped OS/2 access mode that compares to the NT code
        specified.  If there is no mapping for the NT code, we return
        -1 as the access mode.

--*/

{
    PAGED_CODE();

    //
    //  If the user asked for both read and write access, return read/write.
    //

    if ((DesiredAccess & FILE_READ_DATA)&&(DesiredAccess & FILE_WRITE_DATA)) {
        return SMB_DA_ACCESS_READ_WRITE;
    }

    //
    //  If the user requested WRITE_DATA, return write.
    //

    if (DesiredAccess & FILE_WRITE_DATA) {
        return SMB_DA_ACCESS_WRITE;
    }

    //
    //  If the user requested READ_DATA, return read.
    //
    if (DesiredAccess & FILE_READ_DATA) {
        return SMB_DA_ACCESS_READ;
    }

    //
    //  If the user requested ONLY execute access, then request execute
    //  access.  Execute access is the "weakest" of the possible desired
    //  accesses, so it takes least precedence.
    //

    if (DesiredAccess & FILE_EXECUTE) {
        return  SMB_DA_ACCESS_EXECUTE;
    }

    //
    //  If we couldn't figure out what we were doing, return -1
    //
    //  Among the attributes that we do not map are:
    //
    //          FILE_READ_ATTRIBUTES
    //          FILE_WRITE_ATTRIBUTES
    //          FILE_READ_EAS
    //          FILE_WRITE_EAS
    //

//    dprintf(DPRT_ERROR, ("Could not map DesiredAccess of %08lx\n", DesiredAccess));

    return (USHORT)0;
}

USHORT
MRxSmbMapShareAccess (
    IN USHORT ShareAccess
    )

/*++

Routine Description:

    This routine takes an NT ShareAccess value and converts it to an
    OS/2 sharing mode.


Arguments:

    IN USHORT ShareAccess - Supplies the OS/2 share access to map.

Return Value:

    USHORT - The mapped OS/2 sharing mode that compares to the NT code
        specified

--*/

{
    USHORT ShareMode =  SMB_DA_SHARE_EXCLUSIVE;

    PAGED_CODE();

    if ((ShareAccess & (FILE_SHARE_READ | FILE_SHARE_WRITE)) ==
                       (FILE_SHARE_READ | FILE_SHARE_WRITE)) {
        ShareMode = SMB_DA_SHARE_DENY_NONE;
    } else if (ShareAccess & FILE_SHARE_READ) {
        ShareMode = SMB_DA_SHARE_DENY_WRITE;
    } else if (ShareAccess & FILE_SHARE_WRITE) {
        ShareMode = SMB_DA_SHARE_DENY_READ;
    }

//    else if (ShareAccess & FILE_SHARE_DELETE) {
//      InternalError(("Support for FILE_SHARE_DELETE NYI\n"));
//    }

    return ShareMode;

}

USHORT
MRxSmbMapFileAttributes (
    IN ULONG FileAttributes
    )

/*++

Routine Description:

    This routine takes an NT file attribute mapping and converts it into
    an OS/2 file attribute definition.


Arguments:

    IN ULONG FileAttributes - Supplies the file attributes to map.


Return Value:

USHORT

--*/

{
    USHORT ResultingAttributes = 0;

    PAGED_CODE();

    if (FileAttributes==FILE_ATTRIBUTE_NORMAL) {
        return ResultingAttributes;
    }

    if (FileAttributes & FILE_ATTRIBUTE_READONLY) {
        ResultingAttributes |= SMB_FILE_ATTRIBUTE_READONLY;
    }

    if (FileAttributes & FILE_ATTRIBUTE_HIDDEN) {
        ResultingAttributes |= SMB_FILE_ATTRIBUTE_HIDDEN;
    }

    if (FileAttributes & FILE_ATTRIBUTE_SYSTEM) {
        ResultingAttributes |= SMB_FILE_ATTRIBUTE_SYSTEM;
    }
    if (FileAttributes & FILE_ATTRIBUTE_ARCHIVE) {
        ResultingAttributes |= SMB_FILE_ATTRIBUTE_ARCHIVE;
    }
    return ResultingAttributes;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\devfcb.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    devfcb.c

Abstract:

    This module implements all the passthru stuff from the wrapper. currently
    there is only one such function:
         statistics


--*/

#include "precomp.h"
#pragma hdrstop
#include "smbmrx.h"


//
// Forward declarations.
//

NTSTATUS
MRxSmbCreateConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

NTSTATUS
MRxSmbDeleteConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbGetStatistics)
#pragma alloc_text(PAGE, MRxSmbDevFcbXXXControlFile)
#endif

//
//  The local trace mask for this part of the module
//

#define Dbg (DEBUG_TRACE_DEVFCB)

MRX_SMB_STATISTICS MRxSmbStatistics;

NTSTATUS
MRxSmbGetStatistics(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine gathers the statistics from the mini redirector

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS -- the Startup sequence was successfully completed.

    any other value indicates the appropriate error.

Notes:

--*/
{
   PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

   PMRX_SMB_STATISTICS pStatistics;
   ULONG BufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;

   PAGED_CODE();

   pStatistics = (PMRX_SMB_STATISTICS)(LowIoContext->ParamsFor.FsCtl.pOutputBuffer);

   if (BufferLength < sizeof(MRX_SMB_STATISTICS)) {
      return STATUS_INVALID_PARAMETER;
   }

   RxContext->InformationToReturn = sizeof(MRX_SMB_STATISTICS);
   MRxSmbStatistics.SmbsReceived.QuadPart++;

   //some stuff we have to copy from the device object......
   MRxSmbStatistics.PagingReadBytesRequested     = MRxSmbDeviceObject->PagingReadBytesRequested;
   MRxSmbStatistics.NonPagingReadBytesRequested  = MRxSmbDeviceObject->NonPagingReadBytesRequested;
   MRxSmbStatistics.CacheReadBytesRequested      = MRxSmbDeviceObject->CacheReadBytesRequested;
   MRxSmbStatistics.NetworkReadBytesRequested    = MRxSmbDeviceObject->NetworkReadBytesRequested;
   MRxSmbStatistics.PagingWriteBytesRequested    = MRxSmbDeviceObject->PagingWriteBytesRequested;
   MRxSmbStatistics.NonPagingWriteBytesRequested = MRxSmbDeviceObject->NonPagingWriteBytesRequested;
   MRxSmbStatistics.CacheWriteBytesRequested     = MRxSmbDeviceObject->CacheWriteBytesRequested;
   MRxSmbStatistics.NetworkWriteBytesRequested   = MRxSmbDeviceObject->NetworkWriteBytesRequested;
   MRxSmbStatistics.ReadOperations               = MRxSmbDeviceObject->ReadOperations;
   MRxSmbStatistics.RandomReadOperations         = MRxSmbDeviceObject->RandomReadOperations;
   MRxSmbStatistics.WriteOperations              = MRxSmbDeviceObject->WriteOperations;
   MRxSmbStatistics.RandomWriteOperations        = MRxSmbDeviceObject->RandomWriteOperations;

   MRxSmbStatistics.LargeReadSmbs                = MRxSmbStatistics.ReadSmbs - MRxSmbStatistics.SmallReadSmbs;
   MRxSmbStatistics.LargeWriteSmbs               = MRxSmbStatistics.WriteSmbs - MRxSmbStatistics.SmallWriteSmbs;

   MRxSmbStatistics.CurrentCommands              = SmbCeStartStopContext.ActiveExchanges;

   *pStatistics = MRxSmbStatistics;

   return STATUS_SUCCESS;
}

NTSTATUS
MRxSmbDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine handles all the device FCB related FSCTL's in the mini rdr

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    STATUS_SUCCESS -- the Startup sequence was successfully completed.

    any other value indicates the appropriate error in the startup sequence.

--*/
{
    NTSTATUS Status;
    RxCaptureFobx;
    UCHAR MajorFunctionCode  = RxContext->MajorFunction;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    ULONG ControlCode = LowIoContext->ParamsFor.FsCtl.FsControlCode;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbDevFcb\n"));
    switch (MajorFunctionCode) {
    case IRP_MJ_FILE_SYSTEM_CONTROL:
        {
            switch (LowIoContext->ParamsFor.FsCtl.MinorFunction) {
            case IRP_MN_USER_FS_REQUEST:
            {
                    RxDbgTrace(-1, Dbg, ("RxCommonDevFCBFsCtl -> unimplemented fsctl\n"));
                    Status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;

            default :  //minor function != IRP_MN_USER_FS_REQUEST
                Status = STATUS_INVALID_DEVICE_REQUEST;
            } // end of switch
        } // end of FSCTL case
        break;

    case IRP_MJ_DEVICE_CONTROL:
    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        {
            switch (ControlCode) {

            case IOCTL_SMBMRX_ADDCONN:
                DbgPrint("Processing Create Connection IOCTL\n");
                Status = MRxSmbCreateConnection( RxContext, &RxContext->PostRequest );
                break;

            case IOCTL_SMBMRX_DELCONN:
                DbgPrint("Processing Delete Connection IOCTL\n");
                Status = MRxSmbDeleteConnection( RxContext, &RxContext->PostRequest );
                break;

            case IOCTL_SMBMRX_GETSTATE:
            {
                ULONG   OutBufferLength  = LowIoContext->ParamsFor.IoCtl.OutputBufferLength;
                PBYTE   OutBuffer        = LowIoContext->ParamsFor.IoCtl.pOutputBuffer;
                ULONG   CurrentState     = RDR_NULL_STATE;

                if ( OutBufferLength >= sizeof(ULONG) )
                {
                    // map the states to control app's equivalents
                    switch ( MRxSmbState )
                    {
                        case MRXSMB_STARTABLE:
                        case MRXSMB_STOPPED:
                            CurrentState = RDR_STOPPED;
                            break;
                        case MRXSMB_START_IN_PROGRESS:
                            CurrentState = RDR_STARTING;
                            break;
                        case MRXSMB_STARTED:
                            CurrentState = RDR_STARTED;
                            break;
                    }
                    *(ULONG *)OutBuffer = CurrentState;
                    RxContext->InformationToReturn = sizeof(ULONG);
                    Status = STATUS_SUCCESS;
                }
                else
                {
                    Status = STATUS_INVALID_PARAMETER;
                }
            }
            break;

            case IOCTL_SMBMRX_START:
                switch (MRxSmbState) {

                case MRXSMB_STARTABLE:
                    // The correct sequence of start events issued by the workstation
                    // service would have avoided this. We can recover from this
                    // by actually invoking RxStartMiniRdr.
                    
                    if (capFobx) {
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                        goto FINALLY;
                    }

                    (MRXSMB_STATE)InterlockedCompareExchange(
                              (PLONG)&MRxSmbState,
                              MRXSMB_START_IN_PROGRESS,
                              MRXSMB_STARTABLE);
                    //lack of break is intentional

                case MRXSMB_START_IN_PROGRESS:
                    {
                        Status = RxStartMinirdr(RxContext,&RxContext->PostRequest);

                        if (Status == STATUS_REDIRECTOR_STARTED) {
                            Status = STATUS_SUCCESS;
                        }
                        else if ( Status == STATUS_PENDING && RxContext->PostRequest == TRUE )
                        {
                            Status = STATUS_MORE_PROCESSING_REQUIRED;
                        }
                    }
                    break;

                case MRXSMB_STARTED:
                    Status = STATUS_SUCCESS;
                    break;

                default:
                    Status = STATUS_INVALID_PARAMETER;

                    break;
                }

                break;

            case IOCTL_SMBMRX_STOP:
                if (capFobx) {
                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    goto FINALLY;
                }
                

                    if (RxContext->RxDeviceObject->NumberOfActiveFcbs > 0) {
                        return STATUS_REDIRECTOR_HAS_OPEN_HANDLES;
                    } else {
                        MRXSMB_STATE CurrentState;

                        CurrentState = (MRXSMB_STATE)
                                        InterlockedCompareExchange(
                                            (PLONG)&MRxSmbState,
                                            MRXSMB_STARTABLE,
                                            MRXSMB_STARTED);

                        Status = RxStopMinirdr(
                                     RxContext,
                                     &RxContext->PostRequest );
                        if ( Status == STATUS_PENDING && RxContext->PostRequest == TRUE )
                        {
                            Status = STATUS_MORE_PROCESSING_REQUIRED;
                        }
                    }
                    break;

            default :
                Status = STATUS_INVALID_DEVICE_REQUEST;

            } // end of switch
        } //end of IOCTL cases
        break;
    default:
        ASSERT(!"unimplemented major function");
        Status = STATUS_INVALID_DEVICE_REQUEST;

    }

FINALLY:    
    RxDbgTrace(
        -1,
        Dbg,
        ("MRxSmbDevFcb st,info=%08lx,%08lx\n",
         Status,
         RxContext->InformationToReturn));
    return(Status);

}


#if 0
// for ea testing
ULONG BuildCustomEAData( PVOID EaPtr )
{
    PFILE_FULL_EA_INFORMATION thisEa = (PFILE_FULL_EA_INFORMATION) EaPtr;
    PBYTE valuePtr;

    // Set the user name EA
    thisEa->Flags = 0;
    thisEa->EaNameLength = sizeof("UserName");
    RtlCopyMemory( thisEa->EaName, "UserName\0", thisEa->EaNameLength + 1 );
    valuePtr = (PBYTE) thisEa->EaName + thisEa->EaNameLength + 1;
    //thisEa->EaNameLength--;       // don't include the null in the EaName length
    thisEa->EaValueLength = sizeof(L"TestUser");
    RtlCopyMemory( valuePtr, L"TestUser", thisEa->EaValueLength );
    thisEa->NextEntryOffset = ((PBYTE) valuePtr + thisEa->EaValueLength ) -
                               (PBYTE) thisEa;

    // Set the password EA
    thisEa = (PFILE_FULL_EA_INFORMATION) ((PBYTE) thisEa + thisEa->NextEntryOffset);

    thisEa->Flags = 0;
    thisEa->EaNameLength = sizeof("Password");
    RtlCopyMemory( thisEa->EaName, "Password\0", thisEa->EaNameLength + 1 );
    valuePtr = (PBYTE) thisEa->EaName + thisEa->EaNameLength + 1;
    //thisEa->EaNameLength--;       // don't include the null in the EaName length
    thisEa->EaValueLength = sizeof(WCHAR);
    RtlCopyMemory( valuePtr, L"\0", thisEa->EaValueLength );
    thisEa->NextEntryOffset = ((PBYTE) valuePtr + thisEa->EaValueLength ) -
                               (PBYTE) thisEa;

    // Set the domain EA
    thisEa = (PFILE_FULL_EA_INFORMATION) ((PBYTE) thisEa + thisEa->NextEntryOffset);

    thisEa->Flags = 0;
    thisEa->EaNameLength = sizeof("Domain");
    RtlCopyMemory( thisEa->EaName, "Domain\0", thisEa->EaNameLength + 1 );
    valuePtr = (PBYTE) thisEa->EaName + thisEa->EaNameLength + 1;
    //thisEa->EaNameLength--;       // don't include the null in the EaName length
    thisEa->EaValueLength = sizeof(L"WORKGROUP");
    RtlCopyMemory( valuePtr, L"WORKGROUP", thisEa->EaValueLength );
    thisEa->NextEntryOffset = 0;

    return ((PBYTE) valuePtr + thisEa->EaValueLength) - (PBYTE) EaPtr;
}
#endif

NTSTATUS
GetConnectionHandle(
    IN PUNICODE_STRING  ConnectionName,
    PVOID EaBuffer,
    ULONG EaLength,
    PHANDLE Handle )
{

    NTSTATUS            Status;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      FileName;

    InitializeObjectAttributes(
        &ObjectAttributes,
        ConnectionName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);


    Status = ZwCreateFile(
        Handle,
        SYNCHRONIZE,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        EaBuffer,
        EaLength);

    DbgPrint("ZwCreateFile returned %lx\n",Status);

    if ( Status == STATUS_SUCCESS )
    {
        if ( *Handle != INVALID_HANDLE_VALUE ){
            DbgPrint("ZwCreateFile returned success\n");
        } else {
            DbgPrint("ZwCreateFile failed\n");
        }
    }

    return Status;
}

NTSTATUS
MRxSmbCreateConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:


Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context

Return Value:

RXSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    ULONG   InBufferLength  = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    PBYTE   InBuffer        = LowIoContext->ParamsFor.IoCtl.pInputBuffer;

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCreateConnection - entry\n"));

    if (!Wait) {
        //just post right now!
        *PostToFsp = TRUE;
        return(STATUS_PENDING);
    }

    Status = STATUS_INVALID_PARAMETER;

    try {
        PSMBMRX_CONNECTINFO ConnectInfo;
        UNICODE_STRING      ConnectionName;
        PBYTE               EaBuffer;
        ULONG               EaLength;
        ULONG               Validator;
        ULONG               CompareLength;
        HANDLE              Handle;

        if ( InBufferLength >= sizeof( PSMBMRX_CONNECTINFO ) )
        {
            ConnectInfo = (PSMBMRX_CONNECTINFO) InBuffer;
            if ( InBufferLength >= ( sizeof( PSMBMRX_CONNECTINFO ) +
                 ConnectInfo->ConnectionNameLength + ConnectInfo->EaDataLength ) ) 
            {
                ConnectionName.Buffer        = (PWCHAR) ((PBYTE) ConnectInfo->InfoArea +
                                                ConnectInfo->ConnectionNameOffset);
                ConnectionName.Length        = (USHORT) ConnectInfo->ConnectionNameLength;
                ConnectionName.MaximumLength = (USHORT) ConnectInfo->ConnectionNameLength;

                EaLength = ConnectInfo->EaDataLength;               
                EaBuffer = ( EaLength > 0 ) ?
                            ConnectInfo->InfoArea + ConnectInfo->EaDataOffset : NULL;
                // Validate the connection name.  The name must start with our device name.
                // We can't allow a create on some rogue pathname outside our device
                CompareLength = sizeof(DD_SMBMRX_FS_DEVICE_NAME_U);
                CompareLength -= ( CompareLength > 0 ) ? sizeof(WCHAR) : 0;
                CompareLength = min( CompareLength, ConnectionName.Length );
                Validator = (ULONG) RtlCompareMemory( ConnectionName.Buffer, DD_SMBMRX_FS_DEVICE_NAME_U,
                                              CompareLength );

                if ( Validator == CompareLength )
                {
                    Status = GetConnectionHandle( &ConnectionName, EaBuffer, EaLength, &Handle );
                    if ( Status == STATUS_SUCCESS )
                    {
                        if ( Handle != INVALID_HANDLE_VALUE )
                        {
                            ZwClose( Handle );
                        }
                        else
                        {
                            Status = STATUS_BAD_NETWORK_NAME;
                        }
                    }
                }
                else
                {
                    Status = STATUS_OBJECT_PATH_NOT_FOUND;
                }
            }
        }

        try_return(Status);

try_exit:NOTHING;

    } finally {
        RxDbgTrace(0, Dbg, ("MRxSmbCreateConnection - exit Status = %08lx\n", Status));
        RxDbgTraceUnIndent(-1,Dbg);
    }

    return Status;
}

NTSTATUS
MRxSmbDeleteConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:


Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context

Return Value:

RXSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    ULONG   InBufferLength  = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    PBYTE   InBuffer        = LowIoContext->ParamsFor.IoCtl.pInputBuffer;

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PV_NET_ROOT     VNetRoot;
    PFILE_OBJECT    pFileObject;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbDeleteConnection - entry\n"));

    if (!Wait) {
        //just post right now!
        *PostToFsp = TRUE;
        return(STATUS_PENDING);
    }

    Status = STATUS_INVALID_PARAMETER;

    try {
        PSMBMRX_CONNECTINFO ConnectInfo;
        UNICODE_STRING      ConnectionName;
        PBYTE               EaBuffer;
        ULONG               EaLength;
        ULONG               Validator;
        ULONG               CompareLength;
        HANDLE              Handle;

        if ( InBufferLength >= sizeof( PSMBMRX_CONNECTINFO ) )
        {
            ConnectInfo = (PSMBMRX_CONNECTINFO) InBuffer;
            if ( InBufferLength >= ( sizeof( PSMBMRX_CONNECTINFO ) +
                 ConnectInfo->ConnectionNameLength + ConnectInfo->EaDataLength ) ) 
            {
                ConnectionName.Buffer        = (PWCHAR) ((PBYTE) ConnectInfo->InfoArea +
                                                ConnectInfo->ConnectionNameOffset);
                ConnectionName.Length        = (USHORT) ConnectInfo->ConnectionNameLength;
                ConnectionName.MaximumLength = (USHORT) ConnectInfo->ConnectionNameLength;

                EaLength = ConnectInfo->EaDataLength;               
                EaBuffer = ( EaLength > 0 ) ?
                            ConnectInfo->InfoArea + ConnectInfo->EaDataOffset : NULL;
                // Validate the connection name.  The name must start with our device name.
                // We can't allow a create on some rogue pathname outside our device
                CompareLength = sizeof(DD_SMBMRX_FS_DEVICE_NAME_U);
                CompareLength -= ( CompareLength > 0 ) ? sizeof(WCHAR) : 0;
                CompareLength = min( CompareLength, ConnectionName.Length );
                Validator = (ULONG) RtlCompareMemory( ConnectionName.Buffer, DD_SMBMRX_FS_DEVICE_NAME_U,
                                              CompareLength );

                if ( Validator == CompareLength )
                {
                    Status = GetConnectionHandle( &ConnectionName, EaBuffer, EaLength, &Handle );
                    if ( Status == STATUS_SUCCESS )
                    {
                        if ( Handle != INVALID_HANDLE_VALUE )
                        {
                            Status = ObReferenceObjectByHandle( Handle,
                                                                0L,
                                                                NULL,
                                                                KernelMode,
                                                                (PVOID *)&pFileObject,
                                                                NULL );
                            if ( NT_SUCCESS(Status) )
                            {
                                // VNetRoot exists as FOBx in the FsContext2
                                VNetRoot = (PV_NET_ROOT) pFileObject->FsContext2;
                                // make sure the node looks right
                                if (NodeType(VNetRoot) == RDBSS_NTC_V_NETROOT)
                                {
                                    RxDbgTrace(-1, Dbg, ("MRxSmbDeleteConnection - Calling RxFinalizeConnection"));
                                    Status = RxFinalizeConnection(VNetRoot->NetRoot, VNetRoot, TRUE);
                                }
                                else
                                {
                                    Status = STATUS_BAD_NETWORK_NAME;
                                }
                                ObDereferenceObject(pFileObject);
                            }
                            ZwClose(Handle);
                        }
                        else
                        {
                            Status = STATUS_BAD_NETWORK_NAME;
                        }
                    }
                }
                else
                {
                    Status =STATUS_OBJECT_PATH_NOT_FOUND;
                }
            }
        }

        try_return(Status);

try_exit:NOTHING;

    } finally {
        RxDbgTrace(0, Dbg, ("MRxSmbDeleteConnection - exit Status = %08lx\n", Status));
        RxDbgTraceUnIndent(-1,Dbg);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\ea.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    ea.c

Abstract:

    This module implements the mini redirector call down routines pertaining to query/set ea/security.

--*/

#include "precomp.h"
#pragma hdrstop

//
// Forward declarations.
//



#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbQueryEaInformation)
#pragma alloc_text(PAGE, MRxSmbSetEaInformation)
#pragma alloc_text(PAGE, MRxSmbQuerySecurityInformation)
#pragma alloc_text(PAGE, MRxSmbSetSecurityInformation)
#pragma alloc_text(PAGE, MRxSmbLoadEaList)
#pragma alloc_text(PAGE, MRxSmbNtGeaListToOs2)
#pragma alloc_text(PAGE, MRxSmbNtGetEaToOs2)
#pragma alloc_text(PAGE, MRxSmbQueryEasFromServer)
#pragma alloc_text(PAGE, MRxSmbNtFullEaSizeToOs2)
#pragma alloc_text(PAGE, MRxSmbNtFullListToOs2)
#pragma alloc_text(PAGE, MRxSmbNtFullEaToOs2)
#pragma alloc_text(PAGE, MRxSmbSetEaList)
#endif

////
////  The Bug check file id for this module
////
//
//#define BugCheckFileId                   (RDBSS_BUG_CHECK_LOCAL_CREATE)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_EA)

//this is the largest EAs that could ever be returned! oh my god!
//this is used to simulate the nt resumable queryEA using the downlevel call
//sigh!
#define EA_QUERY_SIZE 0x0000ffff


//for QueryEA
NTSTATUS
MRxSmbLoadEaList(
    IN PRX_CONTEXT RxContext,
    IN PUCHAR  UserEaList,
    IN ULONG   UserEaListLength,
    OUT PFEALIST *ServerEaList
    );

NTSTATUS
MRxSmbQueryEasFromServer(
    IN PRX_CONTEXT RxContext,
    IN PFEALIST ServerEaList,
    IN PVOID Buffer,
    IN OUT PULONG BufferLengthRemaining,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN UserEaListSupplied
    );

//for SetEA
NTSTATUS
MRxSmbSetEaList(
//    IN PICB Icb,
//    IN PIRP Irp,
    IN PRX_CONTEXT RxContext,
    IN PFEALIST ServerEaList
    );

VOID MRxSmbExtraEaRoutine(LONG i){
    RxDbgTrace( 0, Dbg, ("MRxSmbExtraEaRoutine i=%08lx\n", i ));
}

NTSTATUS
MRxSmbQueryEaInformation (
    IN OUT PRX_CONTEXT RxContext
    )
{
    NTSTATUS Status;
    RxCaptureFcb;
    RxCaptureFobx;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PVOID Buffer = RxContext->Info.Buffer;
    PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;
    PUCHAR  UserEaList = RxContext->QueryEa.UserEaList;
    ULONG   UserEaListLength = RxContext->QueryEa.UserEaListLength;
    ULONG   UserEaIndex = RxContext->QueryEa.UserEaIndex;
    BOOLEAN RestartScan = RxContext->QueryEa.RestartScan;
    BOOLEAN ReturnSingleEntry = RxContext->QueryEa.ReturnSingleEntry;
    BOOLEAN IndexSpecified = RxContext->QueryEa.IndexSpecified;

    PFEALIST ServerEaList = NULL;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbQueryEaInformation\n"));

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    //get rid of nonEA guys right now
    if (!FlagOn(pServerEntry->Server.DialectFlags,DF_SUPPORTEA)) {
        RxDbgTrace(-1, Dbg, ("EAs w/o EA support!\n"));
        return((STATUS_NOT_SUPPORTED));
    }

    Status = MRxSmbDeferredCreate(RxContext);
    if (Status!=STATUS_SUCCESS) {
        goto FINALLY;
    }

    Status = MRxSmbLoadEaList( RxContext, UserEaList, UserEaListLength, &ServerEaList );

    if (( !NT_SUCCESS( Status ) )||
        ( ServerEaList == NULL )) {
        goto FINALLY;
    }

    if (IndexSpecified) {

        capFobx->OffsetOfNextEaToReturn = UserEaIndex;
        Status = MRxSmbQueryEasFromServer(
                    RxContext,
                    ServerEaList,
                    Buffer,
                    pLengthRemaining,
                    ReturnSingleEntry,
                    (BOOLEAN)(UserEaList != NULL) );

        //
        //  if there are no Ea's on the file, and the user supplied an EA
        //  index, we want to map the error to STATUS_NONEXISTANT_EA_ENTRY.
        //

        if ( Status == STATUS_NO_EAS_ON_FILE ) {
            Status = STATUS_NONEXISTENT_EA_ENTRY;
        }
    } else {

        if ( ( RestartScan == TRUE ) || (UserEaList != NULL) ){

            //
            // Ea Indices start at 1, not 0....
            //

            capFobx->OffsetOfNextEaToReturn = 1;
        }

        Status = MRxSmbQueryEasFromServer(  //it is offensive to have two identical calls but oh, well.....
                    RxContext,
                    ServerEaList,
                    Buffer,
                    pLengthRemaining,
                    ReturnSingleEntry,
                    (BOOLEAN)(UserEaList != NULL) );
    }

FINALLY:

    if ( ServerEaList != NULL) {
        RxFreePool(ServerEaList);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbQueryEaInformation st=%08lx\n",Status));
    return Status;

}

NTSTATUS
MRxSmbSetEaInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    )
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PVOID Buffer = RxContext->Info.Buffer;
    ULONG Length = RxContext->Info.Length;

    PFEALIST ServerEaList = NULL;
    ULONG Size;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSetEaInformation\n"));

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    //get rid of nonEA guys right now
    if (!FlagOn(pServerEntry->Server.DialectFlags,DF_SUPPORTEA)) {
        RxDbgTrace(-1, Dbg, ("EAs w/o EA support!\n"));
        return((STATUS_NOT_SUPPORTED));
    }

    Status = MRxSmbDeferredCreate(RxContext);
    if (Status!=STATUS_SUCCESS) {
        goto FINALLY;
    }

    //
    //  Convert Nt format FEALIST to OS/2 format
    //
    Size = MRxSmbNtFullEaSizeToOs2 ( Buffer );
    if ( Size > 0x0000ffff ) {
        Status = STATUS_EA_TOO_LARGE;
        goto FINALLY;
    }

    ServerEaList = RxAllocatePool ( PagedPool, EA_QUERY_SIZE );
    if ( ServerEaList == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    MRxSmbNtFullListToOs2 ( Buffer, ServerEaList );

    //
    //  Set EAs on the file/directory; if the error is EA_ERROR then SetEaList
    //     sets iostatus.information to the offset of the offender
    //

    Status = MRxSmbSetEaList( RxContext, ServerEaList);

FINALLY:

    if ( ServerEaList != NULL) {
        RxFreePool(ServerEaList);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbSetEaInformation st=%08lx\n",Status));
    return Status;

}


NTSTATUS
MRxSmbQuerySecurityInformation (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine implements the NtQuerySecurityFile api.


Arguments:



Return Value:

    Status - Result of the operation.


--*/

{
   RxCaptureFcb;
   RxCaptureFobx;
   PVOID Buffer = RxContext->Info.Buffer;
   PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;
   PMRX_SMB_SRV_OPEN smbSrvOpen;
   PSMBCEDB_SERVER_ENTRY pServerEntry;

   NTSTATUS Status;

   REQ_QUERY_SECURITY_DESCRIPTOR QuerySecurityRequest;
   RESP_QUERY_SECURITY_DESCRIPTOR QuerySecurityResponse;

   PBYTE  pInputParamBuffer       = NULL;
   PBYTE  pOutputParamBuffer      = NULL;
   PBYTE  pInputDataBuffer        = NULL;
   PBYTE  pOutputDataBuffer       = NULL;

   ULONG  InputParamBufferLength  = 0;
   ULONG  OutputParamBufferLength = 0;
   ULONG  InputDataBufferLength   = 0;
   ULONG  OutputDataBufferLength  = 0;

   PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("MRxSmbQuerySecurityInformation...\n"));

   // Turn away this call from those servers which do not support the NT SMBs

   pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

   if (!FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
       RxDbgTrace(-1, Dbg, ("QuerySecurityDescriptor not supported!\n"));
       return((STATUS_NOT_SUPPORTED));
   }

   Status = MRxSmbDeferredCreate(RxContext);
   if (Status!=STATUS_SUCCESS) {
       goto FINALLY;
   }

   Status = STATUS_MORE_PROCESSING_REQUIRED;

   smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);
   ASSERT (!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN));

   if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
       SMB_TRANSACTION_OPTIONS             TransactionOptions = RxDefaultTransactionOptions;
       SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
       //BOOLEAN printflag;

       TransactionOptions.NtTransactFunction = NT_TRANSACT_QUERY_SECURITY_DESC;
       //TransactionOptions.Flags |= SMB_XACT_FLAGS_COPY_ON_ERROR;

       QuerySecurityRequest.Fid = smbSrvOpen->Fid;
       QuerySecurityRequest.Reserved = 0;
       QuerySecurityRequest.SecurityInformation = RxContext->QuerySecurity.SecurityInformation;

       QuerySecurityResponse.LengthNeeded = 0xbaadbaad;

       //printflag = RxDbgTraceDisableGlobally();//this is debug code anyway!
       //RxDbgTraceEnableGlobally(FALSE);

       Status = SmbCeTransact(
                     RxContext,                    // the RXContext for the transaction
                     &TransactionOptions,          // transaction options
                     NULL,                         // the setup buffer
                     0,                            // input setup buffer length
                     NULL,                         // output setup buffer
                     0,                            // output setup buffer length
                     &QuerySecurityRequest,        // Input Param Buffer
                     sizeof(QuerySecurityRequest), // Input param buffer length
                     &QuerySecurityResponse,       // Output param buffer
                     sizeof(QuerySecurityResponse),// output param buffer length
                     NULL,                         // Input data buffer
                     0,                            // Input data buffer length
                     Buffer,                       // output data buffer
                     *pLengthRemaining,            // output data buffer length
                     &ResumptionContext            // the resumption context
                     );

        //DbgPrint("QSR.len=%x\n", QuerySecurityResponse.LengthNeeded);


        if (NT_SUCCESS(Status) || (Status == STATUS_BUFFER_TOO_SMALL)) {
            ULONG ReturnedDataCount = ResumptionContext.DataBytesReceived;

            RxContext->InformationToReturn = QuerySecurityResponse.LengthNeeded;
            RxDbgTrace(0, Dbg, ("MRxSmbQuerySecurityInformation...ReturnedDataCount=%08lx\n",ReturnedDataCount));
            ASSERT(ResumptionContext.ParameterBytesReceived == sizeof(RESP_QUERY_SECURITY_DESCRIPTOR));

            if (((LONG)(QuerySecurityResponse.LengthNeeded)) > *pLengthRemaining) {
                Status = STATUS_BUFFER_OVERFLOW;
            }

        }

        //RxDbgTraceEnableGlobally(printflag);
    }


FINALLY:

    RxDbgTrace(-1, Dbg, ("MRxSmbQuerySecurityInformation...exit, st=%08lx,info=%08lx\n",
                               Status, RxContext->InformationToReturn));
    return Status;


}

NTSTATUS
MRxSmbSetSecurityInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    )
{
    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SMB_SRV_OPEN     smbSrvOpen;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    NTSTATUS Status;

    REQ_SET_SECURITY_DESCRIPTOR SetSecurityRequest;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSetSecurityInformation...\n"));

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    if (!FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
        RxDbgTrace(-1, Dbg, ("Set Security Descriptor not supported!\n"));

        return((STATUS_NOT_SUPPORTED));

    }

    Status = MRxSmbDeferredCreate(RxContext);
    if (Status!=STATUS_SUCCESS) {
        goto FINALLY;
    }

    Status = STATUS_MORE_PROCESSING_REQUIRED;

    smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        SMB_TRANSACTION_OPTIONS             TransactionOptions = RxDefaultTransactionOptions;
        SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
        ULONG SdLength = RtlLengthSecurityDescriptor(RxContext->SetSecurity.SecurityDescriptor);

        TransactionOptions.NtTransactFunction = NT_TRANSACT_SET_SECURITY_DESC;

        SetSecurityRequest.Fid = smbSrvOpen->Fid;
        SetSecurityRequest.Reserved = 0;
        SetSecurityRequest.SecurityInformation = RxContext->SetSecurity.SecurityInformation;

        Status = SmbCeTransact(
                     RxContext,                    // the RXContext for the transaction
                     &TransactionOptions,          // transaction options
                     NULL,                         // the input setup buffer
                     0,                            // input setup buffer length
                     NULL,                         // the output setup buffer
                     0,                            // output setup buffer length
                     &SetSecurityRequest,          // Input Param Buffer
                     sizeof(SetSecurityRequest),   // Input param buffer length
                     NULL,                         // Output param buffer
                     0,                            // output param buffer length
                     RxContext->SetSecurity.SecurityDescriptor,  // Input data buffer
                     SdLength,                     // Input data buffer length
                     NULL,                         // output data buffer
                     0,                            // output data buffer length
                     &ResumptionContext            // the resumption context
                     );

        //the old rdr doesn't return any info...................
        //RxContext->InformationToReturn = SetSecurityResponse.LengthNeeded;

        if ( NT_SUCCESS(Status) ) {
            ULONG ReturnedDataCount = ResumptionContext.DataBytesReceived;

            RxDbgTrace(0, Dbg, ("MRxSmbSetSecurityInformation...ReturnedDataCount=%08lx\n",ReturnedDataCount));
            ASSERT(ResumptionContext.ParameterBytesReceived == 0);
            ASSERT(ResumptionContext.SetupBytesReceived == 0);
            ASSERT(ResumptionContext.DataBytesReceived == 0);
        }
    }


FINALLY:

    RxDbgTrace(-1, Dbg, ("MRxSmbSetSecurityInformation...exit, st=%08lx,info=%08lx\n",
                               Status, RxContext->InformationToReturn));
    return Status;
}


NTSTATUS
MRxSmbLoadEaList(
    IN PRX_CONTEXT RxContext,
    IN PUCHAR  UserEaList,
    IN ULONG   UserEaListLength,
    OUT PFEALIST *ServerEaList
    )

/*++

Routine Description:

    This routine implements the NtQueryEaFile api.
    It returns the following information:


Arguments:


    IN PUCHAR  UserEaList;  - Supplies the Ea names required.
    IN ULONG   UserEaListLength;

    OUT PFEALIST *ServerEaList - Eas returned by the server. Caller is responsible for
                        freeing memory.

Return Value:

    Status - Result of the operation.


--*/

{
   RxCaptureFobx;

   PMRX_SMB_SRV_OPEN smbSrvOpen;


   NTSTATUS Status;
   USHORT Setup = TRANS2_QUERY_FILE_INFORMATION;

   REQ_QUERY_FILE_INFORMATION QueryFileInfoRequest;
   RESP_QUERY_FILE_INFORMATION QueryFileInfoResponse;

   PBYTE  pInputParamBuffer       = NULL;
   PBYTE  pOutputParamBuffer      = NULL;
   PBYTE  pInputDataBuffer        = NULL;
   PBYTE  pOutputDataBuffer       = NULL;

   ULONG  InputParamBufferLength  = 0;
   ULONG  OutputParamBufferLength = 0;
   ULONG  InputDataBufferLength   = 0;
   ULONG  OutputDataBufferLength  = 0;

   CLONG OutDataCount = EA_QUERY_SIZE;

   CLONG OutSetupCount = 0;

   PFEALIST Buffer;

   PGEALIST ServerQueryEaList = NULL;
   CLONG InDataCount;

   PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("MRxSmbLoadEaList...\n"));

   Status = STATUS_MORE_PROCESSING_REQUIRED;

   smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);

    //
    //  Convert the supplied UserEaList to a GEALIST. The server will return just the Eas
    //  requested by the application.
    //
    //
    //  If the application specified a subset of EaNames then convert to OS/2 1.2 format and
    //  pass that to the server. ie. Use the server to filter out the names.
    //

    Buffer = RxAllocatePool ( PagedPool, OutDataCount );

    if ( Buffer == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    if ( UserEaList != NULL) {

        //
        //  OS/2 format is always a little less than or equal to the NT UserEaList size.
        //  This code relies on the I/O system verifying the EaList is valid.
        //

        ServerQueryEaList = RxAllocatePool ( PagedPool, UserEaListLength );
        if ( ServerQueryEaList == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        };

        MRxSmbNtGeaListToOs2((PFILE_GET_EA_INFORMATION )UserEaList, UserEaListLength, ServerQueryEaList );
        InDataCount = (CLONG)ServerQueryEaList->cbList;

    } else {
        InDataCount = 0;
    }

   if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
       PSMB_TRANSACTION_OPTIONS            pTransactionOptions = &RxDefaultTransactionOptions;
       SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;

       QueryFileInfoRequest.Fid = smbSrvOpen->Fid;

       if ( UserEaList != NULL) {
           QueryFileInfoRequest.InformationLevel = SMB_INFO_QUERY_EAS_FROM_LIST;
       } else {
           QueryFileInfoRequest.InformationLevel = SMB_INFO_QUERY_ALL_EAS;
       }

       Status = SmbCeTransact(
                     RxContext,                    // the RXContext for the transaction
                     pTransactionOptions,          // transaction options
                     &Setup,                       // the setup buffer
                     sizeof(Setup),                // setup buffer length
                     NULL,                         // the output setup buffer
                     0,                            // output setup buffer length
                     &QueryFileInfoRequest,        // Input Param Buffer
                     sizeof(QueryFileInfoRequest), // Input param buffer length
                     &QueryFileInfoResponse,       // Output param buffer
                     sizeof(QueryFileInfoResponse),// output param buffer length
                     ServerQueryEaList,            // Input data buffer
                     InDataCount,                  // Input data buffer length
                     Buffer,                       // output data buffer
                     OutDataCount,                 // output data buffer length
                     &ResumptionContext            // the resumption context
                     );

        if ( NT_SUCCESS(Status) ) {
            ULONG ReturnedDataCount = ResumptionContext.DataBytesReceived;

            RxDbgTrace(0, Dbg, ("MRxSmbLoadEaList...ReturnedDataCount=%08lx\n",ReturnedDataCount));
            ASSERT(ResumptionContext.ParameterBytesReceived == sizeof(RESP_QUERY_FILE_INFORMATION));

            if ( SmbGetUlong( &((PFEALIST)Buffer)->cbList) != ReturnedDataCount ){
                Status = STATUS_EA_CORRUPT_ERROR;
            }

            if ( ReturnedDataCount == 0 ) {
                Status = STATUS_NO_EAS_ON_FILE;
            }

        }
    }


FINALLY:
    if ( NT_SUCCESS(Status) ) {
        *ServerEaList = Buffer;
    } else {
        if (Buffer != NULL) {
            RxFreePool(Buffer);
        }
    }

    if ( ServerQueryEaList != NULL) {
        RxFreePool(ServerQueryEaList);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbLoadEaList...exit, st=%08lx\n",Status));
    return Status;

}


VOID
MRxSmbNtGeaListToOs2 (
    IN PFILE_GET_EA_INFORMATION NtGetEaList,
    IN ULONG GeaListLength,
    IN PGEALIST GeaList
    )
/*++

Routine Description:

    Converts a single NT GET EA list to OS/2 GEALIST style.  The GEALIST
    need not have any particular alignment.

Arguments:

    NtGetEaList - An NT style get EA list to be converted to OS/2 format.

    GeaListLength - the maximum possible length of the GeaList.

    GeaList - Where to place the OS/2 1.2 style GEALIST.

Return Value:

    none.

--*/
{

    PGEA gea = GeaList->list;

    PFILE_GET_EA_INFORMATION ntGetEa = NtGetEaList;

    PAGED_CODE();

    //
    // Copy the Eas up until the last one
    //

    while ( ntGetEa->NextEntryOffset != 0 ) {
        //
        // Copy the NT format EA to OS/2 1.2 format and set the gea
        // pointer for the next iteration.
        //

        gea = MRxSmbNtGetEaToOs2( gea, ntGetEa );

        ASSERT( (ULONG_PTR)gea <= (ULONG_PTR)GeaList + GeaListLength );

        ntGetEa = (PFILE_GET_EA_INFORMATION)((PCHAR)ntGetEa + ntGetEa->NextEntryOffset);
    }

    //  Now copy the last entry.

    gea = MRxSmbNtGetEaToOs2( gea, ntGetEa );

    ASSERT( (ULONG_PTR)gea <= (ULONG_PTR)GeaList + GeaListLength );



    //
    // Set the number of bytes in the GEALIST.
    //

    SmbPutUlong(
        &GeaList->cbList,
        (ULONG)((PCHAR)gea - (PCHAR)GeaList)
        );

    UNREFERENCED_PARAMETER( GeaListLength );
}


PGEA
MRxSmbNtGetEaToOs2 (
    OUT PGEA Gea,
    IN PFILE_GET_EA_INFORMATION NtGetEa
    )

/*++

Routine Description:

    Converts a single NT Get EA entry to OS/2 GEA style.  The GEA need not have
    any particular alignment.  This routine makes no checks on buffer
    overrunning--this is the responsibility of the calling routine.

Arguments:

    Gea - a pointer to the location where the OS/2 GEA is to be written.

    NtGetEa - a pointer to the NT Get EA.

Return Value:

    A pointer to the location after the last byte written.

--*/

{
    PCHAR ptr;

    PAGED_CODE();

    Gea->cbName = NtGetEa->EaNameLength;

    ptr = (PCHAR)(Gea) + 1;
    RtlCopyMemory( ptr, NtGetEa->EaName, NtGetEa->EaNameLength );

    ptr += NtGetEa->EaNameLength;
    *ptr++ = '\0';

    return ( (PGEA)ptr );

}


NTSTATUS
MRxSmbQueryEasFromServer(
    IN PRX_CONTEXT RxContext,
    IN PFEALIST ServerEaList,
    IN PVOID Buffer,
    IN OUT PULONG BufferLengthRemaining,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN UserEaListSupplied
    )

/*++

Routine Description:

    This routine copies the required number of Eas from the ServerEaList
    starting from the offset indicated in the Icb. The Icb is also updated
    to show the last Ea returned.

Arguments:

    IN PFEALIST ServerEaList - Supplies the Ea List in OS/2 format.
    IN PVOID Buffer - Supplies where to put the NT format EAs
    IN OUT PULONG BufferLengthRemaining - Supplies the user buffer space.
    IN BOOLEAN ReturnSingleEntry
    IN BOOLEAN UserEaListSupplied - ServerEaList is a subset of the Eas


Return Value:

    NTSTATUS - The status for the Irp.

--*/

{
    RxCaptureFobx;
    ULONG EaIndex = capFobx->OffsetOfNextEaToReturn;
    ULONG Index = 1;
    ULONG Size;
    ULONG OriginalLengthRemaining = *BufferLengthRemaining;
    BOOLEAN Overflow = FALSE;
    PFEA LastFeaStartLocation;
    PFEA Fea = NULL;
    PFEA LastFea = NULL;
    PFILE_FULL_EA_INFORMATION NtFullEa = Buffer;
    PFILE_FULL_EA_INFORMATION LastNtFullEa = Buffer;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("MRxSmbQueryEasFromServer...EaIndex/Buffer/Remaining=%08lx/%08lx/%08lx\n",
                                       EaIndex,Buffer,((BufferLengthRemaining)?*BufferLengthRemaining:0xbadbad)
                       ));

    //
    //  If there are no Ea's present in the list, return the appropriate
    //  error.
    //
    //  Os/2 servers indicate that a list is null if cbList==4.
    //

    if ( SmbGetUlong(&ServerEaList->cbList) == FIELD_OFFSET(FEALIST, list) ) {
        return STATUS_NO_EAS_ON_FILE;
    }

    //
    //  Find the last location at which an FEA can start.
    //

    LastFeaStartLocation = (PFEA)( (PCHAR)ServerEaList +
                               SmbGetUlong( &ServerEaList->cbList ) -
                               sizeof(FEA) - 1 );

    //
    //  Go through the ServerEaList until we find the entry corresponding to EaIndex
    //

    for ( Fea = ServerEaList->list;
          (Fea <= LastFeaStartLocation) && (Index < EaIndex);
          Index+= 1,
          Fea = (PFEA)( (PCHAR)Fea + sizeof(FEA) +
                        Fea->cbName + 1 + SmbGetUshort( &Fea->cbValue ) ) ) {
        NOTHING;
    }

    if ( Index != EaIndex ) {

        if ( Index == EaIndex+1 ) {
            return STATUS_NO_MORE_EAS;
        }

        //
        //  No such index
        //

        return STATUS_NONEXISTENT_EA_ENTRY;
    }

    //
    // Go through the rest of the FEA list, converting from OS/2 1.2 format to NT
    // until we pass the last possible location in which an FEA can start.
    //

    for ( ;
          Fea <= LastFeaStartLocation;
          Fea = (PFEA)( (PCHAR)Fea + sizeof(FEA) +
                        Fea->cbName + 1 + SmbGetUshort( &Fea->cbValue ) ) ) {

        PCHAR ptr;

        //
        //  Calculate the size of this Fea when converted to an NT EA structure.
        //
        //  The last field shouldn't be padded.
        //

        if ((PFEA)((PCHAR)Fea+sizeof(FEA)+Fea->cbName+1+SmbGetUshort(&Fea->cbValue)) < LastFeaStartLocation) {
            Size = SmbGetNtSizeOfFea( Fea );
        } else {
            Size = FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                    Fea->cbName + 1 + SmbGetUshort(&Fea->cbValue);
        }

        //
        //  Will the next Ea fit?
        //

        if ( *BufferLengthRemaining < Size ) {

            if ( LastNtFullEa != NtFullEa ) {

                if ( UserEaListSupplied == TRUE ) {
                    *BufferLengthRemaining = OriginalLengthRemaining;
                    return STATUS_BUFFER_OVERFLOW;
                }

                Overflow = TRUE;

                break;

            } else {

                //  Not even room for a single EA!

                return STATUS_BUFFER_OVERFLOW;
            }
        } else {
            *BufferLengthRemaining -= Size;
        }

        //
        //  We are comitted to copy the Os2 Fea to Nt format in the users buffer
        //

        LastNtFullEa = NtFullEa;
        LastFea = Fea;
        EaIndex++;

        //  Create new Nt Ea

        NtFullEa->Flags = Fea->fEA;
        NtFullEa->EaNameLength = Fea->cbName;
        NtFullEa->EaValueLength = SmbGetUshort( &Fea->cbValue );

        ptr = NtFullEa->EaName;
        RtlCopyMemory( ptr, (PCHAR)(Fea+1), Fea->cbName );

        ptr += NtFullEa->EaNameLength;
        *ptr++ = '\0';

        //
        // Copy the EA value to the NT full EA.
        //

        RtlCopyMemory(
            ptr,
            (PCHAR)(Fea+1) + NtFullEa->EaNameLength + 1,
            NtFullEa->EaValueLength
            );

        ptr += NtFullEa->EaValueLength;

        //
        // Longword-align ptr to determine the offset to the next location
        // for an NT full EA.
        //

        ptr = (PCHAR)( ((ULONG_PTR)ptr + 3) & ~3 );

        NtFullEa->NextEntryOffset = (ULONG)( ptr - (PCHAR)NtFullEa );

        NtFullEa = (PFILE_FULL_EA_INFORMATION)ptr;

        if ( ReturnSingleEntry == TRUE ) {
            break;
        }
    }

    //
    // Set the NextEntryOffset field of the last full EA to 0 to indicate
    // the end of the list.
    //

    LastNtFullEa->NextEntryOffset = 0;

    //
    //  Record position the default start position for the next query
    //

    capFobx->OffsetOfNextEaToReturn = EaIndex;

    if ( Overflow == FALSE ) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_BUFFER_OVERFLOW;
    }

}


ULONG
MRxSmbNtFullEaSizeToOs2 (
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    )

/*++

Routine Description:

    Get the number of bytes that would be required to represent the
    NT full EA list in OS/2 1.2 style.  This routine assumes that
    at least one EA is present in the buffer.

Arguments:

    NtFullEa - a pointer to the list of NT EAs.

Return Value:

    ULONG - number of bytes required to hold the EAs in OS/2 1.2 format.

--*/

{
    ULONG size;

    PAGED_CODE();

    //
    // Walk through the EAs, adding up the total size required to
    // hold them in OS/2 format.
    //

    for ( size = FIELD_OFFSET(FEALIST, list[0]);
          NtFullEa->NextEntryOffset != 0;
          NtFullEa = (PFILE_FULL_EA_INFORMATION)(
                         (PCHAR)NtFullEa + NtFullEa->NextEntryOffset ) ) {

        size += SmbGetOs2SizeOfNtFullEa( NtFullEa );
    }

    size += SmbGetOs2SizeOfNtFullEa( NtFullEa );

    return size;

}


VOID
MRxSmbNtFullListToOs2 (
    IN PFILE_FULL_EA_INFORMATION NtEaList,
    IN PFEALIST FeaList
    )
/*++

Routine Description:

    Converts a single NT FULL EA list to OS/2 FEALIST style.  The FEALIST
    need not have any particular alignment.

    It is the callers responsibility to ensure that FeaList is large enough.

Arguments:

    NtEaList - An NT style get EA list to be converted to OS/2 format.

    FeaList - Where to place the OS/2 1.2 style FEALIST.

Return Value:

    none.

--*/
{

    PFEA fea = FeaList->list;

    PFILE_FULL_EA_INFORMATION ntFullEa = NtEaList;

    PAGED_CODE();

    //
    // Copy the Eas up until the last one
    //

    while ( ntFullEa->NextEntryOffset != 0 ) {
        //
        // Copy the NT format EA to OS/2 1.2 format and set the fea
        // pointer for the next iteration.
        //

        fea = MRxSmbNtFullEaToOs2( fea, ntFullEa );

        ntFullEa = (PFILE_FULL_EA_INFORMATION)((PCHAR)ntFullEa + ntFullEa->NextEntryOffset);
    }

    //  Now copy the last entry.

    fea = MRxSmbNtFullEaToOs2( fea, ntFullEa );


    //
    // Set the number of bytes in the FEALIST.
    //

    SmbPutUlong(
        &FeaList->cbList,
        (ULONG)((PCHAR)fea - (PCHAR)FeaList)
        );

}


PVOID
MRxSmbNtFullEaToOs2 (
    OUT PFEA Fea,
    IN PFILE_FULL_EA_INFORMATION NtFullEa
    )

/*++

Routine Description:

    Converts a single NT full EA to OS/2 FEA style.  The FEA need not have
    any particular alignment.  This routine makes no checks on buffer
    overrunning--this is the responsibility of the calling routine.

Arguments:

    Fea - a pointer to the location where the OS/2 FEA is to be written.

    NtFullEa - a pointer to the NT full EA.

Return Value:

    A pointer to the location after the last byte written.

--*/

{
    PCHAR ptr;

    PAGED_CODE();

    Fea->fEA = (UCHAR)NtFullEa->Flags;
    Fea->cbName = NtFullEa->EaNameLength;
    SmbPutUshort( &Fea->cbValue, NtFullEa->EaValueLength );

    ptr = (PCHAR)(Fea + 1);
    RtlCopyMemory( ptr, NtFullEa->EaName, NtFullEa->EaNameLength );

    ptr += NtFullEa->EaNameLength;
    *ptr++ = '\0';

    RtlCopyMemory(
        ptr,
        NtFullEa->EaName + NtFullEa->EaNameLength + 1,
        NtFullEa->EaValueLength
        );

    return (ptr + NtFullEa->EaValueLength);

}


NTSTATUS
MRxSmbSetEaList(
    IN PRX_CONTEXT RxContext,
    IN PFEALIST ServerEaList
    )

/*++

Routine Description:

    This routine implements the NtQueryEaFile api.
    It returns the following information:


Arguments:

    IN PFEALIST ServerEaList - Eas to be sent to the server.

Return Value:

    Status - Result of the operation.


--*/

{
   RxCaptureFobx;

   PMRX_SMB_SRV_OPEN smbSrvOpen;


   NTSTATUS Status;
   USHORT Setup = TRANS2_SET_FILE_INFORMATION;

   REQ_SET_FILE_INFORMATION SetFileInfoRequest;
   RESP_SET_FILE_INFORMATION SetFileInfoResponse;

   PBYTE  pInputParamBuffer       = NULL;
   PBYTE  pOutputParamBuffer      = NULL;
   PBYTE  pInputDataBuffer        = NULL;
   PBYTE  pOutputDataBuffer       = NULL;

   ULONG  InputParamBufferLength  = 0;
   ULONG  OutputParamBufferLength = 0;
   ULONG  InputDataBufferLength   = 0;
   ULONG  OutputDataBufferLength  = 0;

   PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("MRxSmbSetEaList...\n"));

   Status = STATUS_MORE_PROCESSING_REQUIRED;
   SetFileInfoResponse.EaErrorOffset = 0;

   smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);

   if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
      PSMB_TRANSACTION_OPTIONS            pTransactionOptions = &RxDefaultTransactionOptions;
      SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;

      SetFileInfoRequest.Fid = smbSrvOpen->Fid;
      SetFileInfoRequest.InformationLevel = SMB_INFO_SET_EAS;
      SetFileInfoRequest.Flags = 0;

      Status = SmbCeTransact(
                     RxContext,                    // the RXContext for the transaction
                     pTransactionOptions,          // transaction options
                     &Setup,                        // the setup buffer
                     sizeof(Setup),                // setup buffer length
                     NULL,                         // the output setup buffer
                     0,                            // output setup buffer length
                     &SetFileInfoRequest,          // Input Param Buffer
                     sizeof(SetFileInfoRequest),   // Input param buffer length
                     &SetFileInfoResponse,         // Output param buffer
                     sizeof(SetFileInfoResponse),  // output param buffer length
                     ServerEaList,                 // Input data buffer
                     SmbGetUlong(&ServerEaList->cbList), // Input data buffer length
                     NULL,                         // output data buffer
                     0,                            // output data buffer length
                     &ResumptionContext            // the resumption context
                     );

   }

   if (!NT_SUCCESS(Status)) {
      USHORT EaErrorOffset = SetFileInfoResponse.EaErrorOffset;
      RxDbgTrace( 0, Dbg, ("MRxSmbSetEaList: Failed .. returning %lx/%lx\n",Status,EaErrorOffset));
      RxContext->InformationToReturn = (EaErrorOffset);
   }

   RxDbgTrace(-1, Dbg, ("MRxSmbSetEaList...exit\n"));
   return Status;
}

NTSTATUS
MRxSmbQueryQuotaInformation(
    IN OUT PRX_CONTEXT RxContext)
{
    RxCaptureFobx;

    PMRX_SMB_SRV_OPEN smbSrvOpen;

    NTSTATUS Status;
    USHORT   Setup = NT_TRANSACT_QUERY_QUOTA;

    PSID   StartSid;
    ULONG  StartSidLength;

    REQ_NT_QUERY_FS_QUOTA_INFO  QueryQuotaInfoRequest;
    RESP_NT_QUERY_FS_QUOTA_INFO  QueryQuotaInfoResponse;

    PBYTE  pInputParamBuffer       = NULL;
    PBYTE  pOutputParamBuffer      = NULL;
    PBYTE  pInputDataBuffer        = NULL;
    PBYTE  pOutputDataBuffer       = NULL;

    ULONG  InputParamBufferLength  = 0;
    ULONG  OutputParamBufferLength = 0;
    ULONG  InputDataBufferLength   = 0;
    ULONG  OutputDataBufferLength  = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbQueryQuotaInformation...\n"));

    Status = STATUS_MORE_PROCESSING_REQUIRED;

    if (capFobx != NULL) {
        smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);
    }

    if ((capFobx == NULL) ||
        (smbSrvOpen == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
    }

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {

        StartSid       = RxContext->QueryQuota.StartSid;

        if (StartSid != NULL) {
            StartSidLength = RtlLengthRequiredSid(((PISID)StartSid)->SubAuthorityCount);
        } else {
            StartSidLength = 0;
        }

        QueryQuotaInfoRequest.Fid = smbSrvOpen->Fid;

        QueryQuotaInfoRequest.ReturnSingleEntry = RxContext->QueryQuota.ReturnSingleEntry;
        QueryQuotaInfoRequest.RestartScan       = RxContext->QueryQuota.RestartScan;

        QueryQuotaInfoRequest.SidListLength = RxContext->QueryQuota.SidListLength;
        QueryQuotaInfoRequest.StartSidOffset =  ROUND_UP_COUNT(
                                                    RxContext->QueryQuota.SidListLength,
                                                    sizeof(ULONG));
        QueryQuotaInfoRequest.StartSidLength = StartSidLength;


        // The input data buffer to be supplied to the server consists of two pieces
        // of information the start sid and the sid list. Currently the I/O
        // subsystem allocates them in contigous memory. In such cases we avoid
        // another allocation by reusing the same buffer. If this condition is
        // not satisfied we allocate a buffer large enough for both the
        // components and copy them over.

        InputDataBufferLength = ROUND_UP_COUNT(
                                    RxContext->QueryQuota.SidListLength,
                                    sizeof(ULONG)) +
                                StartSidLength;

        QueryQuotaInfoRequest.StartSidLength = StartSidLength;

        if (((PBYTE)RxContext->QueryQuota.SidList +
             ROUND_UP_COUNT(RxContext->QueryQuota.SidListLength,sizeof(ULONG))) !=
            RxContext->QueryQuota.StartSid) {
            pInputDataBuffer = RxAllocatePoolWithTag(
                                   PagedPool,
                                   InputDataBufferLength,
                                   MRXSMB_MISC_POOLTAG);

            if (pInputDataBuffer != NULL) {
                RtlCopyMemory(
                    pInputDataBuffer ,
                    RxContext->QueryQuota.SidList,
                    RxContext->QueryQuota.SidListLength);

                RtlCopyMemory(
                    pInputDataBuffer + QueryQuotaInfoRequest.StartSidOffset,
                    StartSid,
                    StartSidLength);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            pInputDataBuffer = (PBYTE)RxContext->QueryQuota.SidList;
        }


        if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
           SMB_TRANSACTION_OPTIONS            TransactionOptions = RxDefaultTransactionOptions;
           SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;

           TransactionOptions.NtTransactFunction = NT_TRANSACT_QUERY_QUOTA;

           pOutputDataBuffer      = RxContext->Info.Buffer;
           OutputDataBufferLength = RxContext->Info.LengthRemaining;

           Status = SmbCeTransact(
                        RxContext,                       // the RXContext for the transaction
                        &TransactionOptions,             // transaction options
                        &Setup,                          // the setup buffer
                        sizeof(Setup),                   // setup buffer length
                        NULL,                            // the output setup buffer
                        0,                               // output setup buffer length
                        &QueryQuotaInfoRequest,          // Input Param Buffer
                        sizeof(QueryQuotaInfoRequest),   // Input param buffer length
                        &QueryQuotaInfoResponse,         // Output param buffer
                        sizeof(QueryQuotaInfoResponse),  // output param buffer length
                        pInputDataBuffer,                // Input data buffer
                        InputDataBufferLength,           // Input data buffer length
                        pOutputDataBuffer,               // output data buffer
                        OutputDataBufferLength,          // output data buffer length
                        &ResumptionContext               // the resumption context
                        );
        }

        if ((pInputDataBuffer != NULL) &&
            (pInputDataBuffer != (PBYTE)RxContext->QueryQuota.SidList)) {
            RxFreePool(pInputDataBuffer);
        }
    }

    if (!NT_SUCCESS(Status)) {
        RxContext->InformationToReturn = 0;
    } else {
        RxContext->InformationToReturn = QueryQuotaInfoResponse.Length;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbQueryQuotaInformation...exit\n"));

    return Status;
}

NTSTATUS
MRxSmbSetQuotaInformation(
    IN OUT PRX_CONTEXT RxContext)
{

    RxCaptureFobx;

    PMRX_SMB_SRV_OPEN smbSrvOpen;

    NTSTATUS Status;
    USHORT Setup = NT_TRANSACT_SET_QUOTA;

    REQ_NT_SET_FS_QUOTA_INFO  SetQuotaInfoRequest;

    PBYTE  pInputParamBuffer       = NULL;
    PBYTE  pOutputParamBuffer      = NULL;
    PBYTE  pInputDataBuffer        = NULL;
    PBYTE  pOutputDataBuffer       = NULL;

    ULONG  InputParamBufferLength  = 0;
    ULONG  OutputParamBufferLength = 0;
    ULONG  InputDataBufferLength   = 0;
    ULONG  OutputDataBufferLength  = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbSetQuotaInformation...\n"));

    Status = STATUS_MORE_PROCESSING_REQUIRED;

    if (capFobx != NULL) {
        smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);
    }

    if ((capFobx == NULL) ||
        (smbSrvOpen == NULL)) {
        Status = STATUS_INVALID_PARAMETER;
    }

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        SMB_TRANSACTION_OPTIONS             TransactionOptions = RxDefaultTransactionOptions;
        SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;

        TransactionOptions.NtTransactFunction = NT_TRANSACT_SET_QUOTA;

        SetQuotaInfoRequest.Fid = smbSrvOpen->Fid;

        pInputDataBuffer      = RxContext->Info.Buffer;
        InputDataBufferLength = RxContext->Info.LengthRemaining;

        Status = SmbCeTransact(
                     RxContext,                       // the RXContext for the transaction
                     &TransactionOptions,             // transaction options
                     &Setup,                          // the setup buffer
                     sizeof(Setup),                   // setup buffer length
                     NULL,                            // the output setup buffer
                     0,                               // output setup buffer length
                     &SetQuotaInfoRequest,            // Input Param Buffer
                     sizeof(SetQuotaInfoRequest),     // Input param buffer length
                     pOutputParamBuffer,              // Output param buffer
                     OutputParamBufferLength,         // output param buffer length
                     pInputDataBuffer,                // Input data buffer
                     InputDataBufferLength,           // Input data buffer length
                     pOutputDataBuffer,               // output data buffer
                     OutputDataBufferLength,          // output data buffer length
                     &ResumptionContext               // the resumption context
                     );
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbSetQuotaInformation...exit\n"));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\fileinfo.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements the mini redirector call down routines pertaining to retrieval/
    update of file/directory/volume information.

--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable

RXDT_DefineCategory(DIRCTRL);
#define Dbg        (DEBUG_TRACE_DIRCTRL)

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, __MRxSmbAllocateSideBuffer)
#pragma alloc_text(PAGE, MRxSmbDeallocateSideBuffer)
#pragma alloc_text(PAGE, MRxSmbTranslateLanManFindBuffer)
#pragma alloc_text(PAGE, MrxSmbUnalignedDirEntryCopyTail)
#pragma alloc_text(PAGE, MRxSmbQueryDirectory)
#pragma alloc_text(PAGE, MRxSmbQueryVolumeInformation)
#pragma alloc_text(PAGE, MRxSmbQueryVolumeInformationWithFullBuffer)
#pragma alloc_text(PAGE, MRxSmbSetVolumeInformation)
#pragma alloc_text(PAGE, MRxSmbQueryFileInformation)
#pragma alloc_text(PAGE, MRxSmbSetFileInformation)
#pragma alloc_text(PAGE, MRxSmbSetFileInformationAtCleanup)
#pragma alloc_text(PAGE, MRxSmbIsValidDirectory)
#pragma alloc_text(PAGE, MRxSmbQueryFileInformationFromPseudoOpen)
#endif

#define MRxSmbForceCoreInfo FALSE
//#define FORCECOREINFO
#if DBG
#ifdef FORCECOREINFO
#undef MRxSmbForceCoreInfo
BOOLEAN MRxSmbForceCoreInfo = TRUE;
#endif
#endif

BOOLEAN MRxSmbBypassDownLevelRename = FALSE;
//BOOLEAN MRxSmbBypassDownLevelRename = TRUE;

ULONG UnalignedDirEntrySideBufferSize = 16384;

//
//  All T2Find requests to the remote server request the 32 bit resume key
//  so SMB_RFIND_BUFFER2 is used instead of SMB_FIND_BUFFER2.
//

typedef struct _SMB_FIND_BUFFER2_WITH_RESUME {
    _ULONG( ResumeKey );
    SMB_FIND_BUFFER2;
} SMB_FIND_BUFFER2_WITH_RESUME;
typedef SMB_FIND_BUFFER2_WITH_RESUME SMB_UNALIGNED *PSMB_FIND_BUFFER2_WITH_RESUME;

LIST_ENTRY MRxSmbSideBuffersList = {NULL,NULL};
ULONG MRxSmbSideBuffersSpinLock = 0;
ULONG MRxSmbSideBuffersCount = 0;
ULONG MRxSmbSideBuffersSerialNumber = 0;
BOOLEAN MRxSmbLoudSideBuffers = FALSE;


typedef struct _SIDE_BUFFER {
    ULONG      Signature;
    LIST_ENTRY ListEntry;
    PMRX_FCB Fcb;
    PMRX_FOBX Fobx;
    PMRX_SMB_FOBX smbFobx;
    ULONG SerialNumber;
    BYTE Buffer;
} SIDE_BUFFER, *PSIDE_BUFFER;

#if DBG
#define MRxSmbAllocateSideBuffer(a,b,c,d) __MRxSmbAllocateSideBuffer(a,b,c,d)
#else
#define MRxSmbAllocateSideBuffer(a,b,c,d) __MRxSmbAllocateSideBuffer(a,b,c)
#endif

NTSTATUS
MRxSmbCoreCheckPath(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

VOID
__MRxSmbAllocateSideBuffer(
    IN OUT PRX_CONTEXT     RxContext,
    IN OUT PMRX_SMB_FOBX   smbFobx,
    IN     USHORT          Setup
#if DBG
    ,IN     PUNICODE_STRING smbtemplate
#endif
    )
{
    RxCaptureFcb;RxCaptureFobx;
    PSIDE_BUFFER SideBuffer;
    ULONG SideBufferSize = UnalignedDirEntrySideBufferSize+sizeof(SIDE_BUFFER);
    POOL_TYPE PoolType;

    PAGED_CODE();

    ASSERT( smbFobx->Enumeration.UnalignedDirEntrySideBuffer == NULL);

#ifdef _WIN64

    //
    // NT64: When PagedPool is used here, we get memory corruption on
    //       some findfirst/findnext operations.  Find out why.
    //

    PoolType = NonPagedPool;
#else
    PoolType = PagedPool;
#endif
    SideBuffer = (PSIDE_BUFFER)RxAllocatePoolWithTag(
                                    PoolType,
                                    SideBufferSize,
                                    MRXSMB_DIRCTL_POOLTAG);
    if (SideBuffer==NULL) {
        return;
    }
    ASSERT( smbFobx->Enumeration.UnalignedDirEntrySideBuffer == NULL);
    SideBuffer->Signature = 'JLBS';
    SideBuffer->smbFobx = smbFobx;
    SideBuffer->Fobx = capFobx;
    SideBuffer->Fcb = capFcb;
    smbFobx->Enumeration.UnalignedDirEntrySideBuffer = &SideBuffer->Buffer;
    RxLog(("Allocsidebuf %lx fo/f=%lx,%lx\n",
            smbFobx->Enumeration.UnalignedDirEntrySideBuffer,
            capFobx,capFcb));
    smbFobx->Enumeration.SerialNumber = SideBuffer->SerialNumber = InterlockedIncrement(&MRxSmbSideBuffersSerialNumber);
    InterlockedIncrement(&MRxSmbSideBuffersCount);
    if (MRxSmbSideBuffersList.Flink==NULL) {
        InitializeListHead(&MRxSmbSideBuffersList);
    }
    ExAcquireFastMutex(&MRxSmbSerializationMutex);
    InsertTailList(&MRxSmbSideBuffersList,&SideBuffer->ListEntry);
    ExReleaseFastMutex(&MRxSmbSerializationMutex);
    if (!MRxSmbLoudSideBuffers) return;
    KdPrint(("Allocating side buffer %08lx %08lx %08lx %08lx %08lxon <%wZ> %s %wZ\n",
                     &SideBuffer->Buffer,
                     MRxSmbSideBuffersCount,
                     smbFobx,capFobx,capFobx->pSrvOpen,
                     GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext),
                     (Setup == TRANS2_FIND_FIRST2)?"First":"Next",
                     smbtemplate
                     ));
}
VOID
MRxSmbDeallocateSideBuffer(
    IN OUT PRX_CONTEXT    RxContext,
    IN OUT PMRX_SMB_FOBX  smbFobx,
    IN     PSZ            where
    )
{
    PSIDE_BUFFER SideBuffer;

    RxCaptureFcb;RxCaptureFobx;

    PAGED_CODE();

    if( smbFobx->Enumeration.UnalignedDirEntrySideBuffer == NULL) return;
    SideBuffer = CONTAINING_RECORD(smbFobx->Enumeration.UnalignedDirEntrySideBuffer,SIDE_BUFFER,Buffer);
    if (MRxSmbLoudSideBuffers){
        DbgPrint("D--------- side buffer %08lx %08lx %08lx %08lx %08lxon <%wZ> %s\n",
                         &SideBuffer->Buffer,
                         MRxSmbSideBuffersCount,
                         smbFobx,capFobx,capFobx->pSrvOpen,
                         GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext),
                         where
                         );
    }
    ASSERT(SideBuffer->Signature == 'JLBS');
    ASSERT(SideBuffer->Fobx == capFobx);
    ASSERT(SideBuffer->Fcb == capFcb);
    ASSERT(SideBuffer->smbFobx == smbFobx);
    ASSERT(smbFobx->Enumeration.SerialNumber == SideBuffer->SerialNumber);

    ExAcquireFastMutex(&MRxSmbSerializationMutex);

    InterlockedDecrement(&MRxSmbSideBuffersCount);
    RemoveEntryList(&SideBuffer->ListEntry);

    ExReleaseFastMutex(&MRxSmbSerializationMutex);

    RxLog(("Deallocsidebuf %lx fo/f=%lx,%lx\n",
            smbFobx->Enumeration.UnalignedDirEntrySideBuffer,
            capFobx,capFcb));
    RxFreePool(SideBuffer);
    smbFobx->Enumeration.UnalignedDirEntrySideBuffer = NULL;
}


VOID
MRxSmbTranslateLanManFindBuffer(
    PRX_CONTEXT RxContext,
    PULONG PreviousReturnedEntry,
    PBYTE ThisEntryInBuffer
    )
{
    RxCaptureFcb; RxCaptureFobx;
    PSMBCEDB_SERVER_ENTRY pServerEntry;
    PSMBCE_SERVER Server;
    ULONG FileInformationClass = RxContext->Info.FileInformationClass;
    PFILE_FULL_DIR_INFORMATION NtBuffer = (PFILE_FULL_DIR_INFORMATION)PreviousReturnedEntry;
    PSMB_FIND_BUFFER2_WITH_RESUME SmbBuffer = (PSMB_FIND_BUFFER2_WITH_RESUME)ThisEntryInBuffer;
    SMB_TIME Time;
    SMB_DATE Date;

    PAGED_CODE();

    if (FileInformationClass==FileNamesInformation) { return; }
    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
    Server = &pServerEntry->Server;

    SmbMoveTime (&Time, &SmbBuffer->CreationTime);
    SmbMoveDate (&Date, &SmbBuffer->CreationDate);
    NtBuffer->CreationTime = MRxSmbConvertSmbTimeToTime(Server, Time, Date);

    SmbMoveTime (&Time, &SmbBuffer->LastAccessTime);
    SmbMoveDate (&Date, &SmbBuffer->LastAccessDate);
    NtBuffer->LastAccessTime = MRxSmbConvertSmbTimeToTime(Server, Time, Date);

    SmbMoveTime (&Time, &SmbBuffer->LastWriteTime);
    SmbMoveDate (&Date, &SmbBuffer->LastWriteDate);
    NtBuffer->LastWriteTime = MRxSmbConvertSmbTimeToTime(Server, Time, Date);

    NtBuffer->ChangeTime.QuadPart = 0;
    NtBuffer->EndOfFile.QuadPart = SmbGetUlong(&SmbBuffer->DataSize);
    NtBuffer->AllocationSize.QuadPart = SmbGetUlong(&SmbBuffer->AllocationSize);

    NtBuffer->FileAttributes = MRxSmbMapSmbAttributes(SmbBuffer->Attributes);

    if ((FileInformationClass==FileFullDirectoryInformation)
            || (FileInformationClass==FileBothDirectoryInformation)) {
        NtBuffer->EaSize = SmbGetUlong(&SmbBuffer->EaSize);
    }
}

NTSTATUS
MrxSmbUnalignedDirEntryCopyTail(
    IN OUT PRX_CONTEXT            RxContext,
    IN     FILE_INFORMATION_CLASS FileInformationClass,
    IN OUT PVOID                  pBuffer,
    IN OUT PULONG                 pLengthRemaining,
    IN OUT PMRX_SMB_FOBX          smbFobx
    )
/*++

Routine Description:

   This routine copies the data from the side buffer into the users buffer and adjusts the
   lengths remaining appropriately. this is called either if the server doesn't do unicode (w95) OR
   if the server does not promise to quadalign entries OR if the user's buffer is not quadaligned.

   this routine can be entered after a T2 finishes or to copy the last entries from a previous T2. in the second case, the
   pUnalignedDirEntrySideBuffer ptr will be null and it will go to acquire the correct pointer from the smbFobx.

   this routine has the responsibility to free the sidebufferptr when it is exhausted.


Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
     NTSTATUS Status = STATUS_SUCCESS;
     RxCaptureFcb;

     ULONG i,NameSizeInUnicode;

     LONG   LocalLengthRemaining;   //signed arithmetic makes it easier
     PULONG PreviousReturnedEntry = NULL;
     ULONG  FileNameLengthOffset = smbFobx->Enumeration.FileNameLengthOffset;
     ULONG  FileNameOffset = smbFobx->Enumeration.FileNameOffset;
     PBYTE  UnalignedDirEntrySideBuffer = smbFobx->Enumeration.UnalignedDirEntrySideBuffer;

     BOOLEAN IsUnicode = smbFobx->Enumeration.IsUnicode;
     BOOLEAN IsNonNtT2Find = smbFobx->Enumeration.IsNonNtT2Find;
     PMRX_SMB_DIRECTORY_RESUME_INFO ResumeInfo = smbFobx->Enumeration.ResumeInfo;

     ULONG FilesReturned = smbFobx->Enumeration.FilesReturned;

     ULONG   EntryOffset = smbFobx->Enumeration.EntryOffset;
     ULONG   ReturnedEntryOffset = 0;// = smbFobx->Enumeration.ReturnedEntryOffset;
     BOOLEAN EndOfSearchReached = smbFobx->Enumeration.EndOfSearchReached;
     ULONG   TotalDataBytesReturned = smbFobx->Enumeration.TotalDataBytesReturned;

     BOOLEAN FilterFailure = FALSE;

     PAGED_CODE();

     LocalLengthRemaining = (LONG)(*pLengthRemaining);

     //
     // keep looping until we've filled in all we can or there're no more entries

     for (i=ReturnedEntryOffset=0;;) {
        ULONG FileNameLength,ThisEntrySize; PCHAR FileNameBuffer;
        UNICODE_STRING ReturnedFileName;
        OEM_STRING FileName;
        NTSTATUS StringStatus;
        BOOLEAN TwoExtraBytes = TRUE;
        ULONG resumekey,NextEntryOffsetinBuffer;
        PULONG PreviousPreviousReturnedEntry = NULL;
        PBYTE ThisEntryInBuffer = UnalignedDirEntrySideBuffer+EntryOffset;

        //
        // don't EVER let yourself get past the data returned...servers return funny stuff.......

        if (EntryOffset>=TotalDataBytesReturned){
            FilterFailure = TRUE;
            FilesReturned = i; //we're done with this buffer........
            break;
        }

        //
        // find the name, the length, and the resume key based on whether it is a NT-T2find or a nonNT

        if (!IsNonNtT2Find) {

            //
            // NT, we use the offsets that we stored earlier.........

            FileNameLength = SmbGetUlong(ThisEntryInBuffer+FileNameLengthOffset);
            FileNameBuffer = ThisEntryInBuffer+FileNameOffset;
            resumekey =  SmbGetUlong(ThisEntryInBuffer
                                             +FIELD_OFFSET(FILE_FULL_DIR_INFORMATION,FileIndex));
            NextEntryOffsetinBuffer = SmbGetUlong(ThisEntryInBuffer);

        } else {

            //
            // for lanman, we always ask for stuff using the SMB_FIND_BUFFER2 to which
            // we have prepended a resume key. so, the name is always at a fixed offset.
            // Also, for nonNT we have read all the files and must filter out correctly; we
            // save where we are in the user's buffer so that we can roll back.


            FileNameLength = *(ThisEntryInBuffer
                                  +FIELD_OFFSET(SMB_FIND_BUFFER2_WITH_RESUME,FileNameLength));
            FileNameBuffer = ThisEntryInBuffer
                                  +FIELD_OFFSET(SMB_FIND_BUFFER2_WITH_RESUME,FileName[0]);
            resumekey =  SmbGetUlong(ThisEntryInBuffer+
                                  +FIELD_OFFSET(SMB_FIND_BUFFER2_WITH_RESUME,ResumeKey));
            NextEntryOffsetinBuffer = FIELD_OFFSET(SMB_FIND_BUFFER2_WITH_RESUME,FileName[0])
                                              + FileNameLength + 1;  //the +1 is for the null..we could have said Filename{1]

            PreviousPreviousReturnedEntry = PreviousReturnedEntry; //save this for rollback on filterfail
        }

        // some servers lie about how many entries were returned and/or send partial entries
        // dont let them trick us..........

        if (EntryOffset+NextEntryOffsetinBuffer>TotalDataBytesReturned){
            FilterFailure = TRUE;
            FilesReturned = i; //we're done with this buffer........
            break;
        }

        FileName.Buffer = FileNameBuffer;
        FileName.Length = (USHORT)FileNameLength;
        RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: EO,REO=%08lx,%08lx\n",
                                 EntryOffset,ReturnedEntryOffset));

        //check to see if this entry will fit
        if (IsUnicode) {
            NameSizeInUnicode = FileNameLength;
            RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: length=%08lx/%08lx, name = %wZ\n",
                                 FileNameLength,NameSizeInUnicode,&FileName));
        } else {
            NameSizeInUnicode = RtlxOemStringToUnicodeSize(&FileName)-sizeof(WCHAR);
            RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: length=%08lx/%08lx, name = %.*s\n",
                                 FileNameLength,NameSizeInUnicode,FileNameLength,FileNameBuffer));
        }


        //
        // now that we know the size of the name and its location, we need to copy it
        // to the user's buffer

        ThisEntrySize = FileNameOffset+NameSizeInUnicode;
        if (((LONG)ThisEntrySize)>LocalLengthRemaining) {
            break;
        }
        if (((LONG)ThisEntrySize)>LocalLengthRemaining-(LONG)sizeof(WCHAR)) {
            TwoExtraBytes = FALSE;
        }


        ThisEntrySize = LongAlign(ThisEntrySize);
        PreviousReturnedEntry = (PULONG)(((PBYTE)pBuffer)+ReturnedEntryOffset);

        //
        // next we compute where the next entry after this one will start. the definition is
        // that it must be 8-byte aligned. we know already that it's 4byte aligned.

        if (!IsPtrQuadAligned((PCHAR)(PreviousReturnedEntry)+ThisEntrySize) ){
            ThisEntrySize += sizeof(ULONG);
        }
        if (i!=0) {
            ASSERT(IsPtrQuadAligned(PreviousReturnedEntry));
        }

        //
        // if this is an NT find, we can copy in the data now. for lanman, we
        // copy in the data later........

        if (!IsNonNtT2Find) {

            //copy everything in the entry up to but not including the name info
            RtlCopyMemory(PreviousReturnedEntry,UnalignedDirEntrySideBuffer+EntryOffset,FileNameOffset);

        } else {
            // clear out all fields i cannot support.
            RtlZeroMemory(PreviousReturnedEntry,FileNameOffset);
        }

        // store the length of this entry and the size of the name...if this is the last
        // entry returned, then the offset field will be cleared later

        *PreviousReturnedEntry = ThisEntrySize;
        *((PULONG)(((PBYTE)PreviousReturnedEntry)+FileNameLengthOffset)) = NameSizeInUnicode;

        //copy in the name  .........this is made difficult by the oem-->unicode routine that
        //             requires space for a NULL!

        RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: REO/buf/pentry=%08lx/%08lx/%08lx\n",
                                 pBuffer,ReturnedEntryOffset,PreviousReturnedEntry));
        ReturnedFileName.Buffer = (PWCH)(((PBYTE)PreviousReturnedEntry)+FileNameOffset);

        if (!IsUnicode) {
            if (TwoExtraBytes) {
                ReturnedFileName.MaximumLength = sizeof(WCHAR)+(USHORT)NameSizeInUnicode;
                RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: filenamebuf,length=%08lx/%08lx\n",
                                         ReturnedFileName.Buffer,ReturnedFileName.MaximumLength));
                StringStatus = RtlOemStringToUnicodeString(&ReturnedFileName,&FileName,FALSE); //false means don;t allocate
            } else {
                OEM_STRING LastChar;
                UNICODE_STRING LastCharInUnicode;
                WCHAR UnicodeCharBuffer[2];
                ReturnedFileName.MaximumLength = (USHORT)NameSizeInUnicode;
                FileName.Length -= 1;
                RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: filenamebuf,length=%08lx/%08lx\n",
                                         ReturnedFileName.Buffer,ReturnedFileName.MaximumLength));
                StringStatus = RtlOemStringToUnicodeString(&ReturnedFileName,&FileName,FALSE); //false means don;t allocate
                ASSERT(StringStatus==STATUS_SUCCESS);
                LastChar.Buffer = FileName.Buffer+FileName.Length;
                LastChar.Length = 1;
                LastCharInUnicode.Buffer = (PWCH)&UnicodeCharBuffer;
                //LastCharInUnicode.Buffer = (PWCH)(((PBYTE)ReturnedFileName.Buffer)+ReturnedFileName.Length);
                LastCharInUnicode.MaximumLength = sizeof(UnicodeCharBuffer);
                StringStatus = RtlOemStringToUnicodeString(&LastCharInUnicode,&LastChar,FALSE); //false means don;t allocate
                *((PWCH)(((PBYTE)ReturnedFileName.Buffer)+ReturnedFileName.Length)) = UnicodeCharBuffer[0];
            }
            ASSERT(StringStatus==STATUS_SUCCESS);

            // Win95 returns the shortname in ascii....spread it out

            if ((FileInformationClass == FileBothDirectoryInformation) && !IsNonNtT2Find) {
                PFILE_BOTH_DIR_INFORMATION BothInfo = (PFILE_BOTH_DIR_INFORMATION)PreviousReturnedEntry;
                OEM_STRING     oemName;
                UNICODE_STRING UnicodeName;
                WCHAR          wcharBuffer[MAX_PATH];

                oemName.Buffer = (PBYTE)(&BothInfo->ShortName[0]);
                oemName.Length =
                oemName.MaximumLength = BothInfo->ShortNameLength;

                UnicodeName.Buffer = wcharBuffer;
                UnicodeName.Length = 0;
                UnicodeName.MaximumLength = MAX_PATH * sizeof(WCHAR);

                StringStatus = RtlOemStringToUnicodeString(&UnicodeName, &oemName, FALSE);
                ASSERT(StringStatus==STATUS_SUCCESS);

                BothInfo->ShortNameLength = (CHAR)UnicodeName.Length;
                RtlCopyMemory(BothInfo->ShortName, UnicodeName.Buffer, UnicodeName.Length);

                IF_DEBUG {
                    UNICODE_STRING LastName;
                    LastName.Buffer = (PWCHAR)wcharBuffer;
                    LastName.Length = (USHORT)UnicodeName.Length;
                    RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: unicodeshortnamename = %wZ\n", &LastName));
                }
            }
        } else {

            //here, it's already unicode.....just copy the bytes
            RtlCopyMemory(ReturnedFileName.Buffer,FileName.Buffer,FileName.Length);

        }

        IF_DEBUG {
            UNICODE_STRING LastName;
            LastName.Buffer = ReturnedFileName.Buffer;
            LastName.Length = (USHORT)NameSizeInUnicode;
            RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: unicodename = %wZ\n", &LastName));
        }

        //now...setup to resume based on this entry

        if (ResumeInfo != NULL) {
            PREQ_FIND_NEXT2 pFindNext2Request = &ResumeInfo->FindNext2_Request;
            //ULONG resumekey = ((PFILE_FULL_DIR_INFORMATION)PreviousReturnedEntry)->FileIndex;

            pFindNext2Request->ResumeKey = resumekey;
            RxDbgTrace(0,Dbg,("MRxSmbQueryDirectoryWin95: resumekey = %08lx\n", resumekey));

            RtlCopyMemory(&pFindNext2Request->Buffer[0],FileNameBuffer,FileNameLength);

            //buffer is a UCHAR...not WCHAR
            if (IsUnicode) {
               // In the case of UNICODE strings an additional NULL is required ( WCHAR NULL )
               pFindNext2Request->Buffer[FileNameLength] = 0; //nullterminated
               pFindNext2Request->Buffer[FileNameLength + 1] = 0; //nullterminated

               smbFobx->Enumeration.ResumeInfo->ParametersLength
                     = (USHORT)(&pFindNext2Request->Buffer[FileNameLength+2] - (PBYTE)pFindNext2Request);
            } else {
               pFindNext2Request->Buffer[FileNameLength] = 0; //nullterminated

               smbFobx->Enumeration.ResumeInfo->ParametersLength
                     = (USHORT)(&pFindNext2Request->Buffer[FileNameLength+1] - (PBYTE)pFindNext2Request);
            }

        }

        //ASSERT(!IsNonNtT2Find);

        //at this point, we have copied the name and the resume key. BUT, for nonnt we have to
        //filter the names so we still may have to roll back

        if (!IsNonNtT2Find) {

            //no need for filtering on NT
            FilterFailure = FALSE;

        } else {

            // here we have to filter out based on the template

            RxCaptureFobx;  //do this here so it's not on the NT path
            FilterFailure = FALSE;

            if (smbFobx->Enumeration.WildCardsFound ) {
                FilterFailure = !FsRtlIsNameInExpression(
                                       &capFobx->UnicodeQueryTemplate,
                                       &ReturnedFileName,
                                       TRUE,
                                       NULL );
            } else {
                FilterFailure = !RtlEqualUnicodeString(
                                       &capFobx->UnicodeQueryTemplate,
                                       &ReturnedFileName,
                                       TRUE );   //case-insensitive
            }

            if (!FilterFailure) {

                // since we didn't copy the data before, we have to copy it now...

                MRxSmbTranslateLanManFindBuffer(RxContext,PreviousReturnedEntry,ThisEntryInBuffer);

            } else {

                PreviousReturnedEntry = PreviousPreviousReturnedEntry; //rollback on filterfail

            }
        }

        if (!FilterFailure) {

            // filtering succeeded..... adjust returned sizes and counts
            LocalLengthRemaining -= ThisEntrySize;
            i++;
            ReturnedEntryOffset += ThisEntrySize;

        } else {

            FilesReturned--;  //we exit the loop if i passes filesreturned
        }


        //
        // complicated test to keep going.......

        //EntryOffset += SmbGetUlong(UnalignedDirEntrySideBuffer+EntryOffset);
        EntryOffset += NextEntryOffsetinBuffer;
        if ((i>=FilesReturned)
            ||(LocalLengthRemaining<0)
            || (RxContext->QueryDirectory.ReturnSingleEntry&&(i>0))  ) {
            break;
        }


     }

     //
     // if we are not returning even one entry, either we didn't have space for even one entry
     // OR we're filtering and no guys passed the filter. return an appropriate error in each case

     if (i==0) {

         Status = FilterFailure?STATUS_MORE_PROCESSING_REQUIRED:STATUS_BUFFER_OVERFLOW;

     } else {

        *PreviousReturnedEntry = 0;   // this clears the "next" link for the last returned entry
     }

     //
     // send back the right size

     if (LocalLengthRemaining <= 0) {
         *pLengthRemaining = 0;
     } else {
         *pLengthRemaining = (ULONG)LocalLengthRemaining;
     }

     //
     // if we're finished with the sidebuffer, deallocate it.
     // otherwise setup to resume........

     if (i>=FilesReturned) {

         RxLog(("sidebufdealloc %lx %lx\n",RxContext,smbFobx));
         MRxSmbDeallocateSideBuffer(RxContext,smbFobx,"Tail");
         if (EndOfSearchReached) {
             //smbFobx->Enumeration.Flags &= ~SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN;
             //we will close the search handle when the user's handle closes
             smbFobx->Enumeration.ErrorStatus = STATUS_NO_MORE_FILES;
         }

     } else {

         //set up to resume here
         ASSERT(smbFobx->Enumeration.UnalignedDirEntrySideBuffer == UnalignedDirEntrySideBuffer);
         smbFobx->Enumeration.EntryOffset = EntryOffset;
         smbFobx->Enumeration.FilesReturned = FilesReturned - i;

     }

     return(Status);
}


ULONG MRxSmbWin95Retries = 0;

NTSTATUS
MRxSmbQueryDirectory(
    IN OUT PRX_CONTEXT            RxContext
    )
/*++

Routine Description:

   This routine does a directory query. Only the NT-->NT path is implemented.


Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = SmbCeGetAssociatedVNetRootContext(SrvOpen->pVNetRoot);
    PSMBCE_SESSION pSession = &pVNetRootContext->pSessionEntry->Session;

    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID   Buffer;
    PULONG  pLengthRemaining;

    USHORT    SmbFileInfoLevel;
    ULONG     FilesReturned;
    ULONG     RetryCount = 0;

    USHORT Setup;

    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
    PSMB_TRANSACTION_OPTIONS            pTransactionOptions = &RxDefaultTransactionOptions;

    //REQ_FIND_NEXT2 FindNext2Request;
    PREQ_FIND_FIRST2 pFindFirst2Request = NULL;

    PBYTE SendParamsBuffer,ReceiveParamsBuffer;
    PBYTE UnalignedDirEntrySideBuffer;
    BOOLEAN DirEntriesAreUaligned = FALSE;
    BOOLEAN IsUnicode = TRUE;
    BOOLEAN IsNonNtT2Find;
    USHORT SearchFlags = SMB_FIND_CLOSE_AT_EOS|SMB_FIND_RETURN_RESUME_KEYS;
    USHORT NumEntries;
    ULONG SendParamsBufferLength,ReceiveParamsBufferLength;
    RESP_FIND_FIRST2 FindFirst2Response;
    UNICODE_STRING FileName = {0,0,NULL};

    struct {
        RESP_FIND_NEXT2  FindNext2Response;
        ULONG Pad; //nonnt needs this
    } XX;
#if DBG
    UNICODE_STRING smbtemplate = {0,0,NULL};
#endif

    PAGED_CODE();

    TURN_BACK_ASYNCHRONOUS_OPERATIONS();
    FileInformationClass = RxContext->Info.FileInformationClass;
    Buffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;

    RxDbgTrace(+1, Dbg, ("MRxSmbQueryDirectory: directory=<%wZ>\n",
                            GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext)
                        ));


#define __GET_NAME_PARAMS_FOR_TYPE(___type___) { \
           smbFobx->Enumeration.FileNameOffset = (USHORT)FIELD_OFFSET(___type___,FileName[0]); \
           smbFobx->Enumeration.FileNameLengthOffset = (USHORT)FIELD_OFFSET(___type___,FileNameLength); \
           }

    switch (FileInformationClass) {
    case FileDirectoryInformation:
        SmbFileInfoLevel = SMB_FIND_FILE_DIRECTORY_INFO;
        __GET_NAME_PARAMS_FOR_TYPE(FILE_DIRECTORY_INFORMATION);
        break;
    case FileFullDirectoryInformation:
        SmbFileInfoLevel = SMB_FIND_FILE_FULL_DIRECTORY_INFO;
        __GET_NAME_PARAMS_FOR_TYPE(FILE_FULL_DIR_INFORMATION);
        break;
    case FileBothDirectoryInformation:
        SmbFileInfoLevel = SMB_FIND_FILE_BOTH_DIRECTORY_INFO;
        __GET_NAME_PARAMS_FOR_TYPE(FILE_BOTH_DIR_INFORMATION);
        break;
    case FileNamesInformation:
        SmbFileInfoLevel = SMB_FIND_FILE_NAMES_INFO;
        __GET_NAME_PARAMS_FOR_TYPE(FILE_NAMES_INFORMATION);
        break;
   default:
      RxDbgTrace( 0, Dbg, ("MRxSmbQueryDirectory: Invalid FS information class\n"));
      Status = STATUS_INVALID_PARAMETER;
      goto FINALLY;
   }


#if DBG
   if (MRxSmbLoudSideBuffers) {
       SetFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_LOUD_FINALIZE);
   }
#endif

   if (FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_NO_WILDCARD) ||
       FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_READ_FROM_CACHE)) {
       // if the FindFirst has been satisfied basied on local file information cache,
       // we should fail the FindNext since the file has been found with the exact name.

       Status = STATUS_NO_MORE_FILES;
       smbFobx->Enumeration.EndOfSearchReached = TRUE;
       smbFobx->Enumeration.ErrorStatus = STATUS_NO_MORE_FILES;
       ClearFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_READ_FROM_CACHE);
       goto FINALLY;
   }

   if (capFobx->UnicodeQueryTemplate.Length != 0 &&
       !FsRtlDoesNameContainWildCards(&capFobx->UnicodeQueryTemplate) &&
       !FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST)) {
       // if it is the FindFirst, we try to find the file on local file information cache.

       PUNICODE_STRING DirectoryName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
       PUNICODE_STRING Template = &capFobx->UnicodeQueryTemplate;
       UNICODE_STRING  TargetName = {0,0,NULL};

       TargetName.Length = DirectoryName->Length + Template->Length + sizeof(WCHAR);
       TargetName.MaximumLength = TargetName.Length;
       TargetName.Buffer = (PWCHAR)RxAllocatePoolWithTag(PagedPool,
                                                         TargetName.Length,
                                                         MRXSMB_DIRCTL_POOLTAG);

       if (TargetName.Buffer == NULL) {
           Status = STATUS_INSUFFICIENT_RESOURCES;
           goto FINALLY;
       }

       RtlCopyMemory(TargetName.Buffer,
                     DirectoryName->Buffer,
                     DirectoryName->Length);

       TargetName.Buffer[DirectoryName->Length/sizeof(WCHAR)] = L'\\';

       RtlCopyMemory(&TargetName.Buffer[DirectoryName->Length/sizeof(WCHAR)+1],
                     Template->Buffer,
                     Template->Length);

       RxFreePool(TargetName.Buffer);
       SearchFlags |= SMB_FIND_CLOSE_AFTER_REQUEST;
       SetFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_NO_WILDCARD);
   }

   if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DEFERRED_OPEN)) {
       BOOLEAN AcquireExclusive = RxIsFcbAcquiredExclusive(capFcb);
       BOOLEAN AcquireShare = RxIsFcbAcquiredShared(capFcb) > 0;

       if (AcquireExclusive || AcquireShare) {
           RxReleaseFcbResourceInMRx(capFcb );
       }

       // connection could have been timed out, try to reconnect.
       Status = SmbCeReconnect(SrvOpen->pVNetRoot);

       if (AcquireExclusive) {
           RxAcquireExclusiveFcbResourceInMRx( capFcb );
       } else if (AcquireShare) {
           RxAcquireExclusiveFcbResourceInMRx( capFcb );
       }

       if (Status != STATUS_SUCCESS) {
           // connection cannot be recovered.
           goto FINALLY;
       }
   }

    if (MRxSmbForceCoreInfo ||
        !(pServerEntry->Server.DialectFlags&(DF_NT_SMBS|DF_W95|DF_LANMAN20))) {
        return MRxSmbCoreInformation(RxContext,
                                     (ULONG)SmbFileInfoLevel,
                                     Buffer,
                                     pLengthRemaining,
                                     SMBPSE_OE_FROM_QUERYDIRECTORY
                                     );
    }

    if (smbFobx->Enumeration.UnalignedDirEntrySideBuffer != NULL){
        RxDbgTrace( 0, Dbg, ("MRxSmbQueryDirectory: win95 internal resume\n"));
        Status = MrxSmbUnalignedDirEntryCopyTail(
                /*IN OUT PRX_CONTEXT            */  RxContext,
                /*IN     FILE_INFORMATION_CLASS */  FileInformationClass,
                /*IN OUT PVOID                  */  Buffer,
                /*IN OUT PULONG                 */  pLengthRemaining,
                /*IN OUT PMRX_SMB_FOBX          */  smbFobx
                );
        if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
            return(Status);
        } else {
            Status = STATUS_SUCCESS;
        }
    }

    NumEntries = RxContext->QueryDirectory.ReturnSingleEntry?1:2000;
    IsUnicode = BooleanFlagOn(pServerEntry->Server.DialectFlags,DF_UNICODE);
    IsNonNtT2Find = !(pServerEntry->Server.Dialect==NTLANMAN_DIALECT);
    if (TRUE || FlagOn(pServerEntry->Server.DialectFlags,DF_W95)){
        DirEntriesAreUaligned = TRUE;
        //SearchFlags = SMB_FIND_RETURN_RESUME_KEYS;
        //SearchFlags = SMB_FIND_CLOSE_AT_EOS;
        NumEntries = (USHORT)(1+ UnalignedDirEntrySideBufferSize
                                /(IsNonNtT2Find?FIELD_OFFSET(SMB_FIND_BUFFER2_WITH_RESUME, FileName)
                                               :FIELD_OFFSET(FILE_NAMES_INFORMATION, FileName)));
    }

    if (FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)
           && FlagOn(capFobx->Flags,FOBX_FLAG_BACKUP_INTENT)){
        SearchFlags |= SMB_FIND_WITH_BACKUP_INTENT;
    }

    if (IsNonNtT2Find) {
        SearchFlags &= ~(SMB_FIND_CLOSE_AT_EOS | SMB_FIND_CLOSE_AFTER_REQUEST);
    }

RETRY_____:

    if (!FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST)) {
        //this is the first time thru
        PUNICODE_STRING DirectoryName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
        PUNICODE_STRING Template = &capFobx->UnicodeQueryTemplate;
        ULONG DirectoryNameLength,TemplateLength,AllocationLength;
        PBYTE SmbFileName;

        RxDbgTrace(0, Dbg, ("-->FINFDIRST\n"));
        smbFobx->Enumeration.ErrorStatus = STATUS_SUCCESS;
        if (smbFobx->Enumeration.WildCardsFound = FsRtlDoesNameContainWildCards(Template)){
            //we need an upcased template for
            RtlUpcaseUnicodeString( Template, Template, FALSE );
        }
        Setup = TRANS2_FIND_FIRST2;
        DirectoryNameLength = DirectoryName->Length;
        TemplateLength = Template->Length;
        AllocationLength = sizeof(REQ_FIND_FIRST2)   //NOTE: this buffer is bigger than w95 needs
                            +2*sizeof(WCHAR)
                            +DirectoryNameLength
                            +TemplateLength;

        pFindFirst2Request = (PREQ_FIND_FIRST2)RxAllocatePoolWithTag(
                                                      PagedPool,
                                                      AllocationLength,
                                                      MRXSMB_DIRCTL_POOLTAG);
        if (pFindFirst2Request==NULL) {
            RxDbgTrace(0, Dbg, ("  --> Couldn't get the pFindFirst2Request!\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }

        SmbFileName = &pFindFirst2Request->Buffer[0];
        if (IsUnicode) {

            RtlCopyMemory(SmbFileName,DirectoryName->Buffer,DirectoryNameLength);
            SmbFileName += DirectoryNameLength;
            if (*((PWCHAR)(SmbFileName-sizeof(WCHAR))) != L'\\') {
                *((PWCHAR)SmbFileName) = L'\\'; SmbFileName+= sizeof(WCHAR);
            }
            RtlCopyMemory(SmbFileName,Template->Buffer,TemplateLength);
            SmbFileName += TemplateLength;
            *((PWCHAR)SmbFileName) = 0; SmbFileName+= sizeof(WCHAR); //trailing NULL;

            IF_DEBUG {
                DbgDoit(smbtemplate.Buffer = (PWCHAR)&pFindFirst2Request->Buffer[0];);
                DbgDoit(smbtemplate.Length = (USHORT)(SmbFileName - (PBYTE)smbtemplate.Buffer););
                RxDbgTrace(0, Dbg, ("  --> smbtemplate <%wZ>!\n",&smbtemplate));
            }

        } else {

            ULONG BufSize = AllocationLength;
            PUNICODE_STRING FinalTemplate = Template;
            UNICODE_STRING AllFiles;

            SmbPutUnicodeStringAsOemString(&SmbFileName,DirectoryName,&AllocationLength);

            // append a backslash if it doesn't exist in the unicode version
            // NB !!! Don't compare with OEM string
            // it busts DBCS characters with 0x5c at the end

            if (!DirectoryName->Length || (DirectoryName->Buffer[(DirectoryName->Length/sizeof(USHORT))-1] != (USHORT)'\\'))
            {
                *(SmbFileName-1) = '\\';
            }
            else
            {
                // there is already a backslash, backup one character
                SmbFileName -= 1; AllocationLength += 1;
            }

            if (IsNonNtT2Find) {
                //we'll get them all and filter on out side
                RtlInitUnicodeString(&AllFiles,  L"*.*");
                FinalTemplate = &AllFiles;
            }
            SmbPutUnicodeStringAsOemString(&SmbFileName,FinalTemplate,&AllocationLength);
            //already padded *SmbFileName = 0; SmbFileName+= sizeof(CHAR); //trailing NULL;

            IF_DEBUG {
                DbgDoit(smbtemplate.Buffer = (PWCHAR)&pFindFirst2Request->Buffer[0];);
                DbgDoit(smbtemplate.Length = (USHORT)(SmbFileName - (PBYTE)smbtemplate.Buffer););
                RxDbgTrace(0, Dbg, ("  --> smbtemplate <%s>!\n",&pFindFirst2Request->Buffer[0]));
            }

        }

        // SearchAttributes is hardcoded to the magic number 0x16
        pFindFirst2Request->SearchAttributes =
            (SMB_FILE_ATTRIBUTE_DIRECTORY
                | SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN);

        pFindFirst2Request->SearchCount = NumEntries;
        pFindFirst2Request->Flags = SearchFlags;
        pFindFirst2Request->InformationLevel = IsNonNtT2Find?SMB_INFO_QUERY_EA_SIZE:SmbFileInfoLevel;
        pFindFirst2Request->SearchStorageType = 0;
        SendParamsBuffer = (PBYTE)pFindFirst2Request;
        SendParamsBufferLength = (ULONG)(SmbFileName - SendParamsBuffer);
        ReceiveParamsBuffer = (PBYTE)&FindFirst2Response;
        ReceiveParamsBufferLength = sizeof(FindFirst2Response);

    } else {
        if (smbFobx->Enumeration.ResumeInfo!=NULL) {
            PREQ_FIND_NEXT2 pFindNext2Request;

            RxDbgTrace(0, Dbg, ("-->FINDNEXT\n"));
            if (smbFobx->Enumeration.ErrorStatus != STATUS_SUCCESS) {
                Status = smbFobx->Enumeration.ErrorStatus;
                RxDbgTrace(0, Dbg, ("-->ERROR EARLY OUT\n"));
                goto FINALLY;
            }
            Setup = TRANS2_FIND_NEXT2;
            pFindNext2Request = &smbFobx->Enumeration.ResumeInfo->FindNext2_Request;
            pFindNext2Request->Sid = smbFobx->Enumeration.SearchHandle;
            pFindNext2Request->SearchCount = NumEntries;
            pFindNext2Request->InformationLevel = IsNonNtT2Find?SMB_INFO_QUERY_EA_SIZE:SmbFileInfoLevel;
            //pFindNext2Request->ResumeKey and pFindNext2Request->Buffer are setup by the previous pass
            pFindNext2Request->Flags = SearchFlags;

            SendParamsBuffer = (PBYTE)pFindNext2Request;
            SendParamsBufferLength = smbFobx->Enumeration.ResumeInfo->ParametersLength;
            ReceiveParamsBuffer = (PBYTE)&XX.FindNext2Response;
            ReceiveParamsBufferLength = sizeof(XX.FindNext2Response);
            if (IsNonNtT2Find) {
                //
                // The LMX server wants this to be 10 instead of 8, for some reason.
                // If you set it to 8, the server gets very confused. Also, warp.
                //
                ReceiveParamsBufferLength = 10; //....sigh
            }
        } else {
            // if the ResumeInfo buffer was not allocated, the end of the search has been reached.
            Status = STATUS_NO_MORE_FILES;
            smbFobx->Enumeration.EndOfSearchReached = TRUE;
            smbFobx->Enumeration.ErrorStatus = STATUS_NO_MORE_FILES;
            ClearFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_READ_FROM_CACHE);
            goto FINALLY;
        }
    }

    if ((DirEntriesAreUaligned) &&
        (smbFobx->Enumeration.UnalignedDirEntrySideBuffer == NULL)) {
        MRxSmbAllocateSideBuffer(RxContext,smbFobx,
                         Setup, &smbtemplate
                         );
        if (smbFobx->Enumeration.UnalignedDirEntrySideBuffer == NULL) {
            RxDbgTrace(0, Dbg, ("  --> Couldn't get the win95 sidebuffer!\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }
        UnalignedDirEntrySideBuffer = smbFobx->Enumeration.UnalignedDirEntrySideBuffer;
        smbFobx->Enumeration.IsUnicode = IsUnicode;
        smbFobx->Enumeration.IsNonNtT2Find = IsNonNtT2Find;
    }

    {
        PSIDE_BUFFER SideBuffer;

        SideBuffer = (PSIDE_BUFFER)CONTAINING_RECORD(
                                        smbFobx->Enumeration.UnalignedDirEntrySideBuffer,
                                        SIDE_BUFFER,
                                        Buffer);


        ASSERT(SideBuffer->Signature == 'JLBS');
        ASSERT(SideBuffer->Fobx == capFobx);
        ASSERT(SideBuffer->Fcb == capFcb);
        ASSERT(SideBuffer->smbFobx == smbFobx);
        ASSERT(smbFobx->Enumeration.SerialNumber == SideBuffer->SerialNumber);
    }

    Status = SmbCeTransact(
                 RxContext,
                 pTransactionOptions,
                 &Setup,
                 sizeof(Setup),
                 NULL,
                 0,
                 SendParamsBuffer,
                 SendParamsBufferLength,
                 ReceiveParamsBuffer,
                 ReceiveParamsBufferLength,
                 NULL,
                 0,
                 DirEntriesAreUaligned?UnalignedDirEntrySideBuffer:Buffer,      // the buffer for data
                 DirEntriesAreUaligned?UnalignedDirEntrySideBufferSize:*pLengthRemaining, // the length of the buffer
                 &ResumptionContext);

    if (NT_SUCCESS(Status)) {
        BOOLEAN EndOfSearchReached;

        {
            PSIDE_BUFFER SideBuffer;

            SideBuffer = (PSIDE_BUFFER)CONTAINING_RECORD(
                                            smbFobx->Enumeration.UnalignedDirEntrySideBuffer,
                                            SIDE_BUFFER,
                                            Buffer);


            ASSERT(SideBuffer->Signature == 'JLBS');
            ASSERT(SideBuffer->Fobx == capFobx);
            ASSERT(SideBuffer->Fcb == capFcb);
            ASSERT(SideBuffer->smbFobx == smbFobx);
            ASSERT(smbFobx->Enumeration.SerialNumber == SideBuffer->SerialNumber);
        }

        if (NT_SUCCESS(Status)) {
            // a) need to set the length remaining correctly
            // b) need to setup for a resume and see if the search was closed
            ULONG LastNameOffset=0;
            PMRX_SMB_DIRECTORY_RESUME_INFO ResumeInfo = NULL;
            ULONG OriginalBufferLength = *pLengthRemaining;
            IF_DEBUG { LastNameOffset = 0x40000000; }

            RetryCount = 0;

            smbFobx->Enumeration.Flags |= SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST;
            smbFobx->Enumeration.TotalDataBytesReturned = ResumptionContext.DataBytesReceived;

            if (Setup == TRANS2_FIND_FIRST2) {
                smbFobx->Enumeration.SearchHandle = FindFirst2Response.Sid;
                smbFobx->Enumeration.Version = ResumptionContext.ServerVersion;
                smbFobx->Enumeration.Flags |= SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN; //but look right below
                EndOfSearchReached = (BOOLEAN)FindFirst2Response.EndOfSearch;
                FilesReturned = FindFirst2Response.SearchCount;
                LastNameOffset = FindFirst2Response.LastNameOffset;
            } else {
                EndOfSearchReached = (BOOLEAN)XX.FindNext2Response.EndOfSearch;
                FilesReturned = XX.FindNext2Response.SearchCount;
                LastNameOffset = XX.FindNext2Response.LastNameOffset;
            }

            //
            //  Please note: LANMAN 2.x servers prematurely set the
            //  EndOfSearch flag, so we must ignore it on LM 2.x servers.
            //
            //  NT Returns the correct information, none of the LM varients
            //  appear to do so.
            //
            if (IsNonNtT2Find) {
                EndOfSearchReached = FALSE;
            }

            if (Status==STATUS_SUCCESS && FilesReturned==0) {
                 RxDbgTrace( 0, Dbg, ("MRxSmbQueryDirectory: no files returned...switch status\n"));
                 EndOfSearchReached = TRUE;
                 Status = STATUS_NO_MORE_FILES;
            }

            if (!DirEntriesAreUaligned) {
                *pLengthRemaining -= ResumptionContext.DataBytesReceived;
                if (EndOfSearchReached) {
                    smbFobx->Enumeration.ErrorStatus = STATUS_NO_MORE_FILES;
                }
            }

            if (EndOfSearchReached ||
                SearchFlags & SMB_FIND_CLOSE_AFTER_REQUEST) {
                ClearFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN);
            }

            if (FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN)) {
                //if the search handle is open, then we set up to resume
                RxDbgTrace(0,Dbg,("MRxSmbQueryDirectory: rinfo = %08lx\n", smbFobx->Enumeration.ResumeInfo));

                if (smbFobx->Enumeration.ResumeInfo==NULL) {
                    smbFobx->Enumeration.ResumeInfo =
                         (PMRX_SMB_DIRECTORY_RESUME_INFO)RxAllocatePoolWithTag(
                                                            PagedPool,
                                                            sizeof(MRX_SMB_DIRECTORY_RESUME_INFO),
                                                            MRXSMB_DIRCTL_POOLTAG);

                    RxDbgTrace(0,Dbg,("MRxSmbQueryDirectory: allocatedinfo = %08lx\n", ResumeInfo));

                    if (smbFobx->Enumeration.ResumeInfo == NULL) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto FINALLY;
                    }
                }

                ResumeInfo = smbFobx->Enumeration.ResumeInfo;
                ASSERT (ResumeInfo!=NULL);

                {
                    PSIDE_BUFFER SideBuffer;

                    SideBuffer = (PSIDE_BUFFER)CONTAINING_RECORD(
                                                    smbFobx->Enumeration.UnalignedDirEntrySideBuffer,
                                                    SIDE_BUFFER,
                                                    Buffer);


                    ASSERT(SideBuffer->Signature == 'JLBS');
                    ASSERT(SideBuffer->Fobx == capFobx);
                    ASSERT(SideBuffer->Fcb == capFcb);
                    ASSERT(SideBuffer->smbFobx == smbFobx);
                    ASSERT(smbFobx->Enumeration.SerialNumber == SideBuffer->SerialNumber);
                }

                RxLog(("MRxqdir: rinfo = %lx", smbFobx->Enumeration.ResumeInfo));
                RxLog(("MRxqdir2: olen = %lx, thisl = %lx",
                                              OriginalBufferLength, ResumptionContext.DataBytesReceived));
                if (!DirEntriesAreUaligned) {
                    PBYTE LastEntry = ((PBYTE)Buffer)+LastNameOffset;
                    RxDbgTrace(0,Dbg,("MRxSmbQueryDirectory: lastentry = %08lx\n", LastEntry));
                    //this is for NT....the data is already in the buffer.......just setup the resume info
                    if (SmbFileInfoLevel>=SMB_FIND_FILE_DIRECTORY_INFO) { //we may start sending nonNT levels...could be an assert

                       PREQ_FIND_NEXT2 pFindNext2Request = &ResumeInfo->FindNext2_Request;
                       ULONG resumekey = ((PFILE_FULL_DIR_INFORMATION)LastEntry)->FileIndex;
                       ULONG FileNameLength; PWCHAR FileNameBuffer;

                       pFindNext2Request->ResumeKey = resumekey;
                       RxDbgTrace(0,Dbg,("MRxSmbQueryDirectory: resumekey = %08lx\n", resumekey));

                       FileNameLength = *((PULONG)(LastEntry+smbFobx->Enumeration.FileNameLengthOffset));
                       FileNameBuffer = (PWCHAR)(LastEntry+smbFobx->Enumeration.FileNameOffset);
                       IF_DEBUG {
                           UNICODE_STRING LastName;
                           LastName.Buffer = FileNameBuffer;
                           LastName.Length = (USHORT)FileNameLength;
                           RxDbgTrace(0,Dbg,("MRxSmbQueryDirectory: resumename = %wZ\n", &LastName));
                       }

                       ASSERT (  (((PBYTE)FileNameBuffer)+FileNameLength)
                                         <=(((PBYTE)Buffer)+OriginalBufferLength) );
                       RtlCopyMemory(&pFindNext2Request->Buffer[0],FileNameBuffer,FileNameLength);

                       //buffer is a UCHAR...not WCHAR
                       pFindNext2Request->Buffer[FileNameLength] = 0; //nullterminated in unicode
                       pFindNext2Request->Buffer[FileNameLength+1] = 0; //nullterminated in unicode
                       smbFobx->Enumeration.ResumeInfo->ParametersLength
                             = (USHORT)(&pFindNext2Request->Buffer[FileNameLength+2] - (PBYTE)pFindNext2Request);

                    } else {
                       ASSERT(!"don't know how to get resume key/name for nonNT");
                    }
                }
            }
            {
                PSIDE_BUFFER SideBuffer;

                SideBuffer = (PSIDE_BUFFER)CONTAINING_RECORD(
                                                smbFobx->Enumeration.UnalignedDirEntrySideBuffer,
                                                SIDE_BUFFER,
                                                Buffer);


                ASSERT(SideBuffer->Signature == 'JLBS');
                ASSERT(SideBuffer->Fobx == capFobx);
                ASSERT(SideBuffer->Fcb == capFcb);
                ASSERT(SideBuffer->smbFobx == smbFobx);
                ASSERT(smbFobx->Enumeration.SerialNumber == SideBuffer->SerialNumber);
            }

            //for NT we are finished. for win95 we have to go thru the side buffer and
            //    1) copy in the data transforming ascii->unicode on the names, and
            //    2) remember the resume key and the filename of the last guy that we process
            //       because win95 doesn't 8byte aling things and because of unicode, we could end up
            //       with more data in the sidebuffer than we can return.

            // the code is moved down because we want to do it after the unlock
        }

        if (DirEntriesAreUaligned && (Status == STATUS_SUCCESS)) {
            smbFobx->Enumeration.FilesReturned = FilesReturned;
            smbFobx->Enumeration.EntryOffset = 0;
            //smbFobx->Enumeration.ReturnedEntryOffset = 0;
            smbFobx->Enumeration.EndOfSearchReached = EndOfSearchReached;
            //smbFobx->Enumeration.UnalignedDirEntrySideBuffer = UnalignedDirEntrySideBuffer;
            Status = MrxSmbUnalignedDirEntryCopyTail(
                       /*IN OUT PRX_CONTEXT            */  RxContext,
                       /*IN     FILE_INFORMATION_CLASS */  FileInformationClass,
                       /*IN OUT PVOID                  */  Buffer,
                       /*IN OUT PULONG                 */  pLengthRemaining,
                       /*IN OUT PMRX_SMB_FOBX          */  smbFobx
                       );
        }
    } else {
        // CODE IMPROVEMENT we should cache the file not found for findfirst as well
    }

FINALLY:
    //for downlevel-T2, we will have to go back to the server for some more.....sigh.......
    if (Status==STATUS_MORE_PROCESSING_REQUIRED) {
        goto RETRY_____;
    }

    //
    // under stress, the win95 server returns this......
    if ( (Status == STATUS_UNEXPECTED_NETWORK_ERROR)
              && FlagOn(pServerEntry->Server.DialectFlags,DF_W95)
              && (RetryCount < 10) ) {

        RetryCount++;
        MRxSmbWin95Retries++;
        goto RETRY_____;

    }

    if (pFindFirst2Request) RxFreePool(pFindFirst2Request);

    if (!NT_SUCCESS(Status)) {
        RxDbgTrace( 0, Dbg, ("MRxSmbQueryDirectory: Failed .. returning %lx\n",Status));
        //smbFobx->Enumeration.Flags &= ~SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN;
        smbFobx->Enumeration.ErrorStatus = Status;  //keep returning this
        MRxSmbDeallocateSideBuffer(RxContext,smbFobx,"ErrOut");
        if (smbFobx->Enumeration.ResumeInfo!=NULL) {
            RxFreePool(smbFobx->Enumeration.ResumeInfo);
            smbFobx->Enumeration.ResumeInfo = NULL;
        }
    }

    RxDbgTraceUnIndent(-1,Dbg);
    return Status;
}

RXDT_DefineCategory(VOLINFO);
#undef Dbg
#define Dbg        (DEBUG_TRACE_VOLINFO)

NTSTATUS
MRxSmbQueryVolumeInformationWithFullBuffer(
      IN OUT PRX_CONTEXT          RxContext
      );
NTSTATUS
MRxSmbQueryVolumeInformation(
      IN OUT PRX_CONTEXT          RxContext
      )
/*++

Routine Description:

   This routine queries the volume information. Since the NT server does not
   handle bufferoverflow gracefully on query-fs-info, we allocate a buffer here
   that is big enough to hold anything passed back; then we call the "real"
   queryvolinfo routine.

Arguments:

    pRxContext         - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureFobx;
    PVOID OriginalBuffer;
    ULONG OriginalLength = RxContext->Info.LengthRemaining;
    ULONG ReturnedLength;
    BOOLEAN UsingSideBuffer = FALSE;

    struct {
        union {
            FILE_FS_LABEL_INFORMATION labelinfo;
            FILE_FS_VOLUME_INFORMATION volumeinfo;
            FILE_FS_SIZE_INFORMATION sizeinfo;
            FILE_FS_DEVICE_INFORMATION deviceinfo;
            FILE_FS_ATTRIBUTE_INFORMATION attributeinfo;
        } Info;
        WCHAR VolumeName[MAXIMUM_FILENAME_LENGTH];
    } SideBuffer;

    PAGED_CODE();

    if( RxContext->Info.LengthRemaining < sizeof( SideBuffer ) ) {
        //
        // i replace the buffer and length in the context with my stuff.
        // This, of course, means that we can't go async....for that we'd
        // have to allocate instead of using a stack-allocated buffer.

        UsingSideBuffer = TRUE;
        OriginalBuffer = RxContext->Info.Buffer;
        RxContext->Info.Buffer = &SideBuffer;
        RxContext->Info.LengthRemaining = sizeof(SideBuffer);
    }

    Status = MRxSmbQueryVolumeInformationWithFullBuffer(RxContext);

    if (Status != STATUS_SUCCESS) {
        goto FINALLY;
    }

    if( UsingSideBuffer == TRUE ) {
        ReturnedLength = sizeof(SideBuffer) - RxContext->Info.LengthRemaining;
    } else {
        ReturnedLength = OriginalLength - RxContext->Info.LengthRemaining;
    }

    if (ReturnedLength > OriginalLength) {
        Status = STATUS_BUFFER_OVERFLOW;
        ReturnedLength = OriginalLength;
    }

    if( UsingSideBuffer == TRUE ) {
        RtlCopyMemory(OriginalBuffer,&SideBuffer,ReturnedLength);
    }

    RxContext->Info.LengthRemaining = OriginalLength - ReturnedLength;

FINALLY:
    return Status;
}

NTSTATUS
MRxSmbQueryVolumeInformationWithFullBuffer(
      IN OUT PRX_CONTEXT          RxContext
      )
/*++

Routine Description:

   This routine queries the volume information

Arguments:

    pRxContext         - the RDBSS context

    FsInformationClass - the kind of Fs information desired.

    pBuffer            - the buffer for copying the information

    pBufferLength      - the buffer length ( set to buffer length on input and set
                         to the remaining length on output)

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    RxCaptureFobx;
    PMRX_SRV_OPEN     SrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen;
    FS_INFORMATION_CLASS FsInformationClass = RxContext->Info.FsInformationClass;
    PVOID                pBuffer = RxContext->Info.Buffer;
    PLONG                pLengthRemaining  = &RxContext->Info.LengthRemaining;

    PSMBCEDB_SERVER_ENTRY        pServerEntry;

    BOOLEAN DoAsDownLevel;

    PVOID                        pInputParamBuffer;
    ULONG                        InputParamBufferLength;
    USHORT                       InformationLevel;
    USHORT                       Setup;
    REQ_QUERY_FS_INFORMATION     QueryFsInformationRequest;
    REQ_QUERY_FS_INFORMATION_FID DfsQueryFsInformationRequest;

    PAGED_CODE();

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    if ( FsInformationClass == FileFsDeviceInformation ) {

        PFILE_FS_DEVICE_INFORMATION UsersBuffer = (PFILE_FS_DEVICE_INFORMATION)pBuffer;
        PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;

        UsersBuffer->Characteristics = FILE_REMOTE_DEVICE;

        if (NetRoot->Type==NET_ROOT_PIPE) {
            NetRoot->DeviceType = RxDeviceType(NAMED_PIPE);
            return STATUS_INVALID_PARAMETER;
        }
        else
        {
            UsersBuffer->DeviceType = NetRoot->DeviceType;
            *pLengthRemaining  -= (sizeof(FILE_FS_DEVICE_INFORMATION));
            RxDbgTrace( 0, Dbg, ("MRxSmbQueryVolumeInformation: devinfo .. returning\n"));

            return STATUS_SUCCESS;
        }
    }

    if (capFobx != NULL) {
       SrvOpen = capFobx->pSrvOpen;
       smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    } else {
       return STATUS_INVALID_PARAMETER;
    }

    TURN_BACK_ASYNCHRONOUS_OPERATIONS();

    for (;;) {
        if (capFobx != NULL) {
            PMRX_V_NET_ROOT pVNetRoot;

            // Avoid device opens for which the FOBX is the VNET_ROOT instance

            pVNetRoot = (PMRX_V_NET_ROOT)capFobx;

            if (NodeType(pVNetRoot) != RDBSS_NTC_V_NETROOT) {
                PUNICODE_STRING AlreadyPrefixedName =
                            GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
                ULONG FcbAlreadyPrefixedNameLength = AlreadyPrefixedName->Length;
                ULONG NetRootInnerNamePrefixLength = capFcb->pNetRoot->InnerNamePrefix.Length;
                PWCHAR pName = AlreadyPrefixedName->Buffer;

                // If an FSCTL is being attempted against the root of a share.
                // The AlreadyPrefixedName associated with the FCB is the same as
                // the AlreadyPrefixedName length associated with the NET_ROOT instance
                // or atmost one character greater than it ( appending a \) try and
                // reestablish the connection before attempting the FSCTL.
                // This solves thorny issues regarding deletion/creation of shares
                // on the server sides, DFS referrals etc.

                if ((FcbAlreadyPrefixedNameLength == NetRootInnerNamePrefixLength) ||
                    ((FcbAlreadyPrefixedNameLength == NetRootInnerNamePrefixLength + sizeof(WCHAR)) &&
                     (*((PCHAR)pName + FcbAlreadyPrefixedNameLength - sizeof(WCHAR)) ==
                        L'\\'))) {
                    Status = SmbCeReconnect(capFobx->pSrvOpen->pVNetRoot);
                }
            }
        }

        DoAsDownLevel = MRxSmbForceCoreInfo;

        if (!FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
            DoAsDownLevel = TRUE;
        }

        if (FlagOn(pServerEntry->Server.DialectFlags,DF_W95)
            && (FsInformationClass==FileFsAttributeInformation)){ //use uplevel for w95 attribute info
            DoAsDownLevel = FALSE;
        }

        if (DoAsDownLevel) {
            return MRxSmbCoreInformation(RxContext,
                                        (ULONG)FsInformationClass,
                                        pBuffer,
                                        pLengthRemaining,
                                        SMBPSE_OE_FROM_QUERYVOLUMEINFO
                                       );
        }

        Status = STATUS_MORE_PROCESSING_REQUIRED;

        switch (FsInformationClass) {
        case FileFsVolumeInformation :
            InformationLevel = SMB_QUERY_FS_VOLUME_INFO;
            break;

        case FileFsLabelInformation :
            InformationLevel = SMB_QUERY_FS_LABEL_INFO;
            break;

        case FileFsSizeInformation :
            InformationLevel = SMB_QUERY_FS_SIZE_INFO;
            break;

        case FileFsAttributeInformation :
            InformationLevel = SMB_QUERY_FS_ATTRIBUTE_INFO;
            break;

        default:
            if( FlagOn( pServerEntry->Server.DialectFlags, DF_NT_INFO_PASSTHROUGH ) ) {
                InformationLevel = FsInformationClass + SMB_INFO_PASSTHROUGH;
            } else {
                RxDbgTrace( 0, Dbg, ("MRxSmbQueryVolumeInformation: Invalid FS information class\n"));
                Status = STATUS_INVALID_PARAMETER;
            }
            break;
        }

        if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
            SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
            PSMB_TRANSACTION_OPTIONS            pTransactionOptions = &RxDefaultTransactionOptions;
            PMRX_SRV_OPEN                       SrvOpen    = capFobx->pSrvOpen;
            PMRX_SMB_SRV_OPEN                   smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

            if (!FlagOn(pServerEntry->Server.DialectFlags,DF_DFS_TRANS2)) {
                Setup                 = TRANS2_QUERY_FS_INFORMATION;
                QueryFsInformationRequest.InformationLevel = InformationLevel;
                pInputParamBuffer      = &QueryFsInformationRequest;
                InputParamBufferLength = sizeof(QueryFsInformationRequest);
            } else {
                Setup = TRANS2_QUERY_FS_INFORMATION_FID;
                DfsQueryFsInformationRequest.InformationLevel = InformationLevel;
                DfsQueryFsInformationRequest.Fid = smbSrvOpen->Fid;
                pInputParamBuffer                 = &DfsQueryFsInformationRequest;
                InputParamBufferLength            = sizeof(DfsQueryFsInformationRequest);
            }

            Status = SmbCeTransact(
                         RxContext,
                         pTransactionOptions,
                         &Setup,
                         sizeof(Setup),
                         NULL,
                         0,
                         pInputParamBuffer,
                         InputParamBufferLength,
                         NULL,
                         0,
                         NULL,
                         0,
                         pBuffer,
                         *pLengthRemaining,
                         &ResumptionContext);

            if (NT_SUCCESS(Status)) {
                *pLengthRemaining  -= ResumptionContext.DataBytesReceived;
            }
        }

        if (!NT_SUCCESS(Status)) {
            RxDbgTrace( 0, Dbg, ("MRxSmbQueryVolumeInformation: Failed .. returning %lx\n",Status));
        }

        if (Status != STATUS_NETWORK_NAME_DELETED) {
            break;
        }
    }

    return Status;
}

NTSTATUS
MRxSmbSetVolumeInformation(
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine sets the volume information

Arguments:

    pRxContext - the RDBSS context

    FsInformationClass - the kind of Fs information desired.

    pBuffer            - the buffer for copying the information

    BufferLength       - the buffer length

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;

    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID                  pBuffer;
    ULONG                  BufferLength;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    BOOLEAN ServerSupportsPassThroughForSetInfo = FALSE;

    PAGED_CODE();

    TURN_BACK_ASYNCHRONOUS_OPERATIONS();

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    FileInformationClass = RxContext->Info.FileInformationClass;
    pBuffer              = RxContext->Info.Buffer;
    BufferLength         = RxContext->Info.Length;

    if (!MRxSmbForceCoreInfo &&
        FlagOn( pServerEntry->Server.DialectFlags, DF_NT_INFO_PASSTHROUGH)) {

        ServerSupportsPassThroughForSetInfo = TRUE;
    }

    if (ServerSupportsPassThroughForSetInfo) {
        USHORT Setup = TRANS2_SET_FS_INFORMATION;

        REQ_SET_FS_INFORMATION  SetFsInfoRequest;

        SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
        PSMB_TRANSACTION_OPTIONS            pTransactionOptions = &RxDefaultTransactionOptions;


        if (capFobx != NULL) {
            PMRX_SRV_OPEN     SrvOpen = capFobx->pSrvOpen;
            PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

            SetFsInfoRequest.Fid              = smbSrvOpen->Fid;
            SetFsInfoRequest.InformationLevel = FileInformationClass +
                                                SMB_INFO_PASSTHROUGH;

            Status = SmbCeTransact(
                         RxContext,
                         pTransactionOptions,
                         &Setup,
                         sizeof(Setup),
                         NULL,
                         0,
                         &SetFsInfoRequest,
                         sizeof(SetFsInfoRequest),
                         NULL,
                         0,
                         pBuffer,
                         BufferLength,
                         NULL,
                         0,
                         &ResumptionContext);
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
    } else {
        Status = STATUS_NOT_SUPPORTED;
    }

    if (!NT_SUCCESS(Status)) {
        RxDbgTrace( 0, Dbg, ("MRxSmbSetFile: Failed .. returning %lx\n",Status));
    }

    RxDbgTraceUnIndent(-1,Dbg);
    return Status;
}

RXDT_DefineCategory(FILEINFO);
#undef Dbg
#define Dbg        (DEBUG_TRACE_FILEINFO)

LONG GFAFromLocal;

NTSTATUS
MRxSmbQueryFileInformation(
    IN PRX_CONTEXT            RxContext )
/*++

Routine Description:

   This routine does a query file info.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;

    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID              pBuffer;
    PULONG             pLengthRemaining;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PMRX_SMB_FCB      smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SMB_FOBX     smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    PMRX_SRV_OPEN     SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PUNICODE_STRING   RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PMRX_NET_ROOT     NetRoot = capFcb->pNetRoot;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)SrvOpen->pVNetRoot->Context;
    PSMBCE_NET_ROOT   pSmbNetRoot = &pVNetRootContext->pNetRootEntry->NetRoot;

    USHORT SmbFileInfoLevel;

    USHORT Setup;

    SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
    PSMB_TRANSACTION_OPTIONS            pTransactionOptions = &RxDefaultTransactionOptions;

    REQ_QUERY_FILE_INFORMATION  QueryFileInfoRequest;
    RESP_QUERY_FILE_INFORMATION QueryFileInfoResponse;
    PREQ_QUERY_PATH_INFORMATION pQueryFilePathRequest = NULL;

    PVOID pSendParameterBuffer;
    ULONG SendParameterBufferLength;

    PAGED_CODE();

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    FileInformationClass = RxContext->Info.FileInformationClass;
    pBuffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;


    RxDbgTrace(+1, Dbg, ("MRxSmbQueryFileInformation: class=%08lx\n",FileInformationClass));

    TURN_BACK_ASYNCHRONOUS_OPERATIONS();

    Status = STATUS_SUCCESS;
    
    switch (FileInformationClass) {
    case FilePipeLocalInformation:
    case FilePipeInformation:
    case FilePipeRemoteInformation:
        Status = STATUS_INVALID_PARAMETER;
        goto FINALLY;
        break;

    case FileEaInformation:
        if (smbSrvOpen->IsNtCreate && 
            smbSrvOpen->FileStatusFlags & SMB_FSF_NO_EAS &&
            (smbSrvOpen->OplockLevel == SMB_OPLOCK_LEVEL_BATCH ||
             smbSrvOpen->OplockLevel == SMB_OPLOCK_LEVEL_EXCLUSIVE)) {
            PFILE_EA_INFORMATION EaBuffer = (PFILE_EA_INFORMATION)pBuffer;

            EaBuffer->EaSize = 0;
            RxContext->Info.LengthRemaining -= sizeof(FILE_EA_INFORMATION);
            goto FINALLY;
        }
        break;
    
    case FileStreamInformation:
        if (pSmbNetRoot->NetRootFileSystem == NET_ROOT_FILESYSTEM_FAT) {
            // FAT doesn't have the stream
            Status = STATUS_INVALID_PARAMETER;
            goto FINALLY;
        }
        break;

    case FileAttributeTagInformation:
        if (pSmbNetRoot->NetRootFileSystem == NET_ROOT_FILESYSTEM_FAT ||
            smbSrvOpen->IsNtCreate && 
            smbSrvOpen->FileStatusFlags & SMB_FSF_NO_REPARSETAG &&
            (smbSrvOpen->OplockLevel == SMB_OPLOCK_LEVEL_BATCH ||
             smbSrvOpen->OplockLevel == SMB_OPLOCK_LEVEL_EXCLUSIVE)) {
            PFILE_ATTRIBUTE_TAG_INFORMATION TagBuffer = (PFILE_ATTRIBUTE_TAG_INFORMATION)pBuffer;

            TagBuffer->FileAttributes = smbSrvOpen->FileInfo.Basic.FileAttributes;
            TagBuffer->ReparseTag = 0;
            RxContext->Info.LengthRemaining -= sizeof(FILE_ATTRIBUTE_TAG_INFORMATION);
            goto FINALLY;
        }
    }
    
    if( MRxSmbForceCoreInfo ||
        !FlagOn( pServerEntry->Server.DialectFlags, DF_NT_INFO_PASSTHROUGH )) {
        switch (FileInformationClass) {
        case FileBasicInformation:
            SmbFileInfoLevel = SMB_QUERY_FILE_BASIC_INFO;
            break;

        case FileStandardInformation:
            SmbFileInfoLevel =  SMB_QUERY_FILE_STANDARD_INFO;
            break;

        case FileEaInformation:
            SmbFileInfoLevel =  SMB_QUERY_FILE_EA_INFO;
            break;

        case FileAllocationInformation:
            SmbFileInfoLevel =  SMB_QUERY_FILE_ALLOCATION_INFO;
            break;

        case FileEndOfFileInformation:
            SmbFileInfoLevel =  SMB_QUERY_FILE_END_OF_FILEINFO;
            break;

        case FileAlternateNameInformation:
            SmbFileInfoLevel =  SMB_QUERY_FILE_ALT_NAME_INFO;
            break;

        case FileStreamInformation:
            SmbFileInfoLevel =  SMB_QUERY_FILE_STREAM_INFO;
            break;

        case FileCompressionInformation:
            SmbFileInfoLevel =  SMB_QUERY_FILE_COMPRESSION_INFO;
            break;

        case FileInternalInformation:
            {
                PFILE_INTERNAL_INFORMATION UsersBuffer = (PFILE_INTERNAL_INFORMATION)pBuffer;
                //
                //  Note: We use the address of the FCB to determine the
                //  index number of the file.  If we have to maintain persistance between
                //  file opens for this request, then we might have to do something
                //  like checksuming the reserved fields on a FUNIQUE SMB response.
                //

                //
                // NT64: the address of capFcb used to be stuffed into
                //       IndexNumber.LowPart, with HighPart being zeroed.
                //
                //       Whoever is asking for this pointer value should be
                //       prepared to deal with the returned 64-bit value.
                //

                UsersBuffer->IndexNumber.QuadPart = (ULONG_PTR)capFcb;
                *pLengthRemaining -= sizeof(FILE_INTERNAL_INFORMATION);
                Status = STATUS_SUCCESS;
            }
            goto FINALLY;

        default:
            RxDbgTrace( 0, Dbg, ("MRxSmbQueryFile: Invalid FS information class\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto FINALLY;
        }

    } else {

        //
        // This server supports transparent NT information level passthrough.  So
        //  just pass the request on to the server.
        //
        SmbFileInfoLevel = FileInformationClass + SMB_INFO_PASSTHROUGH;
    }

    if (MRxSmbForceCoreInfo ||
        FlagOn(pServerEntry->Server.DialectFlags,DF_W95) ||
        !FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
        // Win9x server supports NT SMB but doesn't support transact2. Therefore we use core.

        return MRxSmbCoreInformation(
                   RxContext,
                   (ULONG)SmbFileInfoLevel,
                   pBuffer,
                   pLengthRemaining,
                   SMBPSE_OE_FROM_QUERYFILEINFO
                   );
    }

    Status = STATUS_SUCCESS;

    if (!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
       //here, the FID is valid. do a t2_QFI
        Setup = TRANS2_QUERY_FILE_INFORMATION;
        QueryFileInfoRequest.Fid = smbSrvOpen->Fid;
        QueryFileInfoRequest.InformationLevel = SmbFileInfoLevel;
        pSendParameterBuffer = &QueryFileInfoRequest;
        SendParameterBufferLength = sizeof(QueryFileInfoRequest);
        RxDbgTrace(0, Dbg, (" fid,smbclass=%08lx,%08lx\n",smbSrvOpen->Fid,SmbFileInfoLevel));
    } else {
        OEM_STRING OemName;
        BOOLEAN    FreeOemName = FALSE;

        Setup = TRANS2_QUERY_PATH_INFORMATION;

        if (!FlagOn(pServerEntry->Server.DialectFlags,DF_UNICODE)) {
            if (FlagOn(pServerEntry->Server.DialectFlags,DF_LONGNAME)) {
                Status = RtlUnicodeStringToOemString(&OemName, RemainingName, TRUE);
            } else {
                Status = RtlUpcaseUnicodeStringToOemString(&OemName, RemainingName, TRUE);
            }

            if (Status == STATUS_SUCCESS) {
                SendParameterBufferLength = FIELD_OFFSET(REQ_QUERY_PATH_INFORMATION,Buffer[0])
                                                + OemName.Length + sizeof(CHAR); //null-terminated
                FreeOemName = TRUE;
            }
        } else {
           SendParameterBufferLength = FIELD_OFFSET(REQ_QUERY_PATH_INFORMATION,Buffer[0])
                                           + RemainingName->Length + sizeof(WCHAR); //null-terminated
        }

        if (Status == STATUS_SUCCESS) {
            pSendParameterBuffer = RxAllocatePoolWithTag(PagedPool,
                                                         SendParameterBufferLength,
                                                         MRXSMB_QPINFO_POOLTAG);

            pQueryFilePathRequest = pSendParameterBuffer;
        
            if (pQueryFilePathRequest != NULL) {
                pQueryFilePathRequest->InformationLevel = SmbFileInfoLevel;
                SmbPutUlong(&pQueryFilePathRequest->Reserved,0);
    
                if (FlagOn(pServerEntry->Server.DialectFlags,DF_UNICODE)) {
                    RtlCopyMemory(&pQueryFilePathRequest->Buffer[0],RemainingName->Buffer,RemainingName->Length);
                    *((PWCHAR)(&pQueryFilePathRequest->Buffer[RemainingName->Length])) = 0;
                } else {
                    RtlCopyMemory(&pQueryFilePathRequest->Buffer[0],OemName.Buffer,OemName.Length);
                    *((PCHAR)(&pQueryFilePathRequest->Buffer[OemName.Length])) = 0;
                }
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (FreeOemName) {
            RtlFreeOemString(&OemName);
        }
    }

    if (Status == STATUS_SUCCESS) {
        Status = SmbCeTransact(
                     RxContext,
                     pTransactionOptions,
                     &Setup,
                     sizeof(Setup),
                     NULL,
                     0,
                     pSendParameterBuffer,
                     SendParameterBufferLength,
                     &QueryFileInfoResponse,
                     sizeof(QueryFileInfoResponse),
                     NULL,
                     0,
                     pBuffer,
                     *pLengthRemaining,
                     &ResumptionContext);

        if (NT_SUCCESS(Status)) {
            *pLengthRemaining -= ResumptionContext.DataBytesReceived;
        }
    }

    //
    // Check for file not found status.  If this is the case then create a
    // name cache entry in the NetRoot name cache and record the status,
    // the smb received count and set the expiration time for 5 seconds.
    // Why: NB4 case of back to back srv reqs with 2nd req upcased.
    //

FINALLY:

    if (pQueryFilePathRequest != NULL) {
        RxFreePool(pQueryFilePathRequest);
    }

    if (!NT_SUCCESS(Status)) {
         RxDbgTrace( 0, Dbg, ("MRxSmbQueryFile: Failed .. returning %lx\n",Status));
    }

    RxDbgTraceUnIndent(-1,Dbg);
    return Status;
}

NTSTATUS
MRxSmbQueryFileInformationFromPseudoOpen(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

   This routine does a query file basic info from pseudo open.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PRX_CONTEXT LocalRxContext;

    PAGED_CODE();

    LocalRxContext = RxAllocatePoolWithTag(NonPagedPool,
                                           sizeof(RX_CONTEXT),
                                           MRXSMB_RXCONTEXT_POOLTAG);

    if (LocalRxContext == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    } else {
        RtlZeroMemory(
            LocalRxContext,
            sizeof(RX_CONTEXT));

        RxInitializeContext(
            NULL,
            RxContext->RxDeviceObject,
            0,
            LocalRxContext );

        LocalRxContext->pFcb = RxContext->pFcb;
        LocalRxContext->pFobx = RxContext->pFobx;
        LocalRxContext->CurrentIrp = RxContext->CurrentIrp;
        LocalRxContext->CurrentIrpSp = RxContext->CurrentIrpSp;
        LocalRxContext->NonPagedFcb = RxContext->NonPagedFcb;
        LocalRxContext->MajorFunction = IRP_MJ_CREATE;
        LocalRxContext->pRelevantSrvOpen = RxContext->pRelevantSrvOpen;;
        LocalRxContext->Flags = RX_CONTEXT_FLAG_MINIRDR_INITIATED|RX_CONTEXT_FLAG_WAIT|RX_CONTEXT_FLAG_BYPASS_VALIDOP_CHECK;

        LocalRxContext->Info.FileInformationClass = FileBasicInformation;
        LocalRxContext->Info.LengthRemaining = sizeof(FILE_BASIC_INFORMATION);
        LocalRxContext->Info.Buffer = &OrdinaryExchange->Create.FileInfo.Basic;
        LocalRxContext->Create = RxContext->Create;

        Status = MRxSmbQueryFileInformation(LocalRxContext);
        
        RxFreePool(LocalRxContext);
    }

    if (Status == STATUS_SUCCESS) {
        OrdinaryExchange->Create.FileInfo.Standard.Directory = 
            BooleanFlagOn(OrdinaryExchange->Create.FileInfo.Basic.FileAttributes,FILE_ATTRIBUTE_DIRECTORY);

        OrdinaryExchange->Create.StorageTypeFromGFA =
            OrdinaryExchange->Create.FileInfo.Standard.Directory ?
            FileTypeDirectory : FileTypeFile;
    }

    return Status;
}

typedef enum _INTERESTING_SFI_FOLLOWONS {
    SFI_FOLLOWON_NOTHING,
    SFI_FOLLOWON_DISPOSITION_SENT
} INTERESTING_SFI_FOLLOWONS;


NTSTATUS
MRxSmbSetFileInformation (
      IN PRX_CONTEXT  RxContext
      )
/*++

Routine Description:

   This routine does a set file info. Only the NT-->NT path is implemented.

   The NT-->NT path works by just remoting the call basically without further ado.

   The file is not really open if it is created for delete. In this case, set dispostion info
   will be delayed until file is closed.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;

    FILE_INFORMATION_CLASS FileInformationClass;
    PVOID                  pBuffer;
    ULONG                  BufferLength;

    PMRX_SRV_OPEN   SrvOpen = capFobx->pSrvOpen;

    PMRX_SMB_FCB      smbFcb  = MRxSmbGetFcbExtension(capFcb);
    PMRX_SMB_FOBX     smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)SrvOpen->pVNetRoot->Context;
    PSMBCE_NET_ROOT   pSmbNetRoot = &pVNetRootContext->pNetRootEntry->NetRoot;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    USHORT SmbFileInfoLevel;

    USHORT Setup;

    INTERESTING_SFI_FOLLOWONS FollowOn = SFI_FOLLOWON_NOTHING;
    SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
    PSMB_TRANSACTION_OPTIONS            pTransactionOptions = &RxDefaultTransactionOptions;

    REQ_SET_FILE_INFORMATION SetFileInfoRequest;
    RESP_SET_FILE_INFORMATION SetFileInfoResponse;
    PREQ_SET_PATH_INFORMATION pSetFilePathRequest = NULL;

    PVOID pSendParameterBuffer;
    ULONG SendParameterBufferLength;

    BOOLEAN UseCore = FALSE;

    PAGED_CODE();

    TURN_BACK_ASYNCHRONOUS_OPERATIONS();

    FileInformationClass = RxContext->Info.FileInformationClass;

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    pBuffer = RxContext->Info.Buffer;
    BufferLength = RxContext->Info.Length;

    RxDbgTrace(+1, Dbg, ("MRxSmbSetFile: Class %08lx size %08lx\n",FileInformationClass,BufferLength));

    if (FileInformationClass != FileBasicInformation &&
        FileInformationClass != FileDispositionInformation &&
        FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {

        Status = MRxSmbDeferredCreate(RxContext);

        if (Status != STATUS_SUCCESS) {
            goto FINALLY;
        }
    }

    if( FileInformationClass == FilePipeLocalInformation ||
        FileInformationClass == FilePipeInformation ||
        FileInformationClass == FilePipeRemoteInformation ) {
        Status = STATUS_INVALID_PARAMETER;
        goto FINALLY;
    }

    if (!MRxSmbForceCoreInfo &&
        !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN) &&
        FlagOn( pServerEntry->Server.DialectFlags, DF_NT_INFO_PASSTHROUGH)) {

        SmbFileInfoLevel = FileInformationClass + SMB_INFO_PASSTHROUGH;

        if( FileInformationClass == FileRenameInformation ) {
            PFILE_RENAME_INFORMATION pRenameInformation;

            // The current implementation of pass through for rename information
            // on the server does not go all the way in implementing the
            // NT_TRANSACT, NT_RENAME function defined in SMBs. Therefore we need
            // to special case the code to accomodate the server implementation
            // The two cases that are not permitted are relative renames,
            // specifying a non null root directory and deep renames which
            // transcend the current directory structure. For these cases we will
            // have to revert back to what we had before.

            pRenameInformation = (PFILE_RENAME_INFORMATION)pBuffer;

            if (pRenameInformation->RootDirectory == NULL) {
                // Scan the name given for rename to determine if it is in
                // some other directory.
                ULONG  NameLengthInBytes = pRenameInformation->FileNameLength;
                PWCHAR pRenameTarget     = pRenameInformation->FileName;

                while ((NameLengthInBytes > 0) &&
                       (*pRenameTarget != OBJ_NAME_PATH_SEPARATOR)) {
                    NameLengthInBytes -= sizeof(WCHAR);
                }

                if (NameLengthInBytes > 0) {
                    UseCore = TRUE;
                }
            } else {
                UseCore = TRUE;
            }
        }

        if (FileInformationClass == FileLinkInformation) {
            UseCore = TRUE;
        }
    } else {
        switch( FileInformationClass ) {
        case FileBasicInformation:
            SmbFileInfoLevel =  SMB_SET_FILE_BASIC_INFO;
            break;
        case FileDispositionInformation:
            SmbFileInfoLevel =  SMB_SET_FILE_DISPOSITION_INFO;
            break;
        case FileAllocationInformation:
            SmbFileInfoLevel =  SMB_SET_FILE_ALLOCATION_INFO;
            break;
        case FileEndOfFileInformation:
            SmbFileInfoLevel =  SMB_SET_FILE_END_OF_FILE_INFO;
            break;
        case FileLinkInformation:
        case FileRenameInformation:
            UseCore = TRUE;
            break;
        default:
            Status = STATUS_INVALID_PARAMETER;
            goto FINALLY;
        }
    }

    if (UseCore ||
        MRxSmbForceCoreInfo ||
        !FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS) ||
        FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {

        if (FileInformationClass == FileLinkInformation ||
            FileInformationClass == FileRenameInformation) {
            Status = MRxSmbBypassDownLevelRename ?
                        STATUS_INVALID_PARAMETER :
                        MRxSmbRename( RxContext );
        } else {
            Status = MRxSmbCoreInformation(
                        RxContext,
                        FileInformationClass,
                        pBuffer,
                        &BufferLength,
                        SMBPSE_OE_FROM_SETFILEINFO
                        );
        }

        goto FINALLY;
    }

    Setup = TRANS2_SET_FILE_INFORMATION;
    SetFileInfoRequest.Fid = smbSrvOpen->Fid;
    SetFileInfoRequest.InformationLevel = SmbFileInfoLevel;
    SetFileInfoRequest.Flags = 0;
    pSendParameterBuffer = &SetFileInfoRequest;
    SendParameterBufferLength = sizeof(SetFileInfoRequest);
    RxDbgTrace(0, Dbg, (" fid,smbclass=%08lx,%08lx\n",smbSrvOpen->Fid,SmbFileInfoLevel));
    
    Status = SmbCeTransact(
                 RxContext,
                 pTransactionOptions,
                 &Setup,
                 sizeof(Setup),
                 NULL,
                 0,
                 pSendParameterBuffer,
                 SendParameterBufferLength,
                 &SetFileInfoResponse,
                 sizeof(SetFileInfoResponse),
                 pBuffer,
                 BufferLength,
                 NULL,
                 0,
                 &ResumptionContext);

    if (Status == STATUS_SUCCESS &&
         FileInformationClass == FileDispositionInformation ) {
        PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);

        SetFlag((((PMRX_SMB_FCB)smbFcb)->MFlags),SMB_FCB_FLAG_SENT_DISPOSITION_INFO);
        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_FILE_DELETED);
    }

FINALLY:

    if (NT_SUCCESS(Status)) {
        switch(FileInformationClass) {
        case FileBasicInformation:
            break;

        case FileEndOfFileInformation:
            break;

        case FileStandardInformation:
            break;

        case FileEaInformation:
            smbSrvOpen->FileStatusFlags &=  ~SMB_FSF_NO_EAS;
            break;

        case FileAttributeTagInformation:
            smbSrvOpen->FileStatusFlags &= ~SMB_FSF_NO_REPARSETAG;
            break;
        } 
    } else {
        RxDbgTrace( 0, Dbg, ("MRxSmbSetFile: Failed .. returning %lx\n",Status));
    }

   RxDbgTraceUnIndent(-1,Dbg);
   return Status;
}

NTSTATUS
MRxSmbSetFileInformationAtCleanup(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine sets the file information on cleanup. the old rdr just swallows this operation (i.e.
   it doesn't generate it). we are doing the same..........

Arguments:

    pRxContext           - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
   return STATUS_SUCCESS;
}


NTSTATUS
MRxSmbIsValidDirectory(
    IN OUT PRX_CONTEXT    RxContext,
    IN PUNICODE_STRING    DirectoryName
    )
/*++

Routine Description:

   This routine checks a remote directory.

Arguments:

    RxContext - the RDBSS context
    DirectoryName - the directory needs to be checked

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    BOOLEAN FinalizationComplete;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = NULL;

    PSMBSTUFFER_BUFFER_STATE StufferState;
    KEVENT                   SyncEvent;
    
    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbIsValidDirectory\n", 0 ));

    Status = SmbCeReconnect(RxContext->Create.pVNetRoot);

    if (Status != STATUS_SUCCESS) {
        goto FINALLY;
    }

    Status= SmbPseCreateOrdinaryExchange(
                RxContext,
                RxContext->Create.pVNetRoot,
                SMBPSE_OE_FROM_CREATE,
                MRxSmbCoreCheckPath,
                &OrdinaryExchange
                );

    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        goto FINALLY;
    }

    OrdinaryExchange->pPathArgument1 = DirectoryName;
    OrdinaryExchange->SmbCeFlags |= SMBCE_EXCHANGE_ATTEMPT_RECONNECTS;
    OrdinaryExchange->AssociatedStufferState.CurrentCommand = SMB_COM_NO_ANDX_COMMAND;
    OrdinaryExchange->pSmbCeSynchronizationEvent = &SyncEvent;

    StufferState = &OrdinaryExchange->AssociatedStufferState;
    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT(Status != STATUS_PENDING);

    if (Status != STATUS_SUCCESS) {
        Status = STATUS_BAD_NETWORK_PATH;
    }

    FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
    ASSERT(FinalizationComplete);


FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbIsValidDirectory  exit with status=%08lx\n", Status ));
    return(Status);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\locks.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    locks.c

Abstract:

    This module implements the mini redirector call down routines pertaining to locks
    of file system objects.

--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbLocks)
#pragma alloc_text(PAGE, MRxSmbBuildLocksAndX)
#pragma alloc_text(PAGE, MRxSmbBuildLockAssert)
#pragma alloc_text(PAGE, SmbPseExchangeStart_Locks)
#pragma alloc_text(PAGE, MRxSmbFinishLocks)
#pragma alloc_text(PAGE, MRxSmbUnlockRoutine)
#pragma alloc_text(PAGE, MRxSmbCompleteBufferingStateChangeRequest)
#pragma alloc_text(PAGE, MRxSmbBuildFlush)
#pragma alloc_text(PAGE, MRxSmbFlush)
#pragma alloc_text(PAGE, MRxSmbIsLockRealizable)
#pragma alloc_text(PAGE, MRxSmbFinishFlush)
#endif

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOCKCTRL)

NTSTATUS
SmbPseExchangeStart_Locks(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

ULONG MRxSmbSrvLockBufSize = 0xffff;
ULONG MRxSmbLockSendOptions = 0;     //use the default options

NTSTATUS
MRxSmbBuildFlush (
    PSMBSTUFFER_BUFFER_STATE StufferState
    );

NTSTATUS
MRxSmbLocks(
      IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine handles network requests for filelocks

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbLocks\n", 0 ));

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    Status = SmbPseCreateOrdinaryExchange(RxContext,
                                          SrvOpen->pVNetRoot,
                                          SMBPSE_OE_FROM_LOCKS,
                                          SmbPseExchangeStart_Locks,
                                          &OrdinaryExchange
                                          );
    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return(Status);
    }

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);


    if (Status!=STATUS_PENDING) {
        BOOLEAN FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
        ASSERT(FinalizationComplete);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbLocks  exit with status=%08lx\n", Status ));
    return(Status);

}

NTSTATUS
MRxSmbBuildLocksAndX (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a LockingAndX SMB for a single unlock or a single lock.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    RxCaptureFcb;RxCaptureFobx;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)StufferState->Exchange;
    PSMBCE_SERVER pServer = SmbCeGetExchangeServer(StufferState->Exchange);

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PLARGE_INTEGER ByteOffsetAsLI,LengthAsLI;
    USHORT NumberOfLocks,NumberOfUnlocks;
    BOOLEAN UseLockList = FALSE;
    //ULONG OffsetLow,OffsetHigh;


    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildLocksAndX\n"));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    switch (LowIoContext->Operation) {
    case LOWIO_OP_SHAREDLOCK:
    case LOWIO_OP_EXCLUSIVELOCK:
        NumberOfLocks = 1; NumberOfUnlocks = 0;
        break;
    case LOWIO_OP_UNLOCK:
        NumberOfLocks = 0; NumberOfUnlocks = 1;
        break;
    case LOWIO_OP_UNLOCK_MULTIPLE:
        NumberOfLocks = 0; NumberOfUnlocks = 1;
        UseLockList = TRUE;
        break;
    }

    if (!UseLockList) {
        ByteOffsetAsLI = (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.ByteOffset;
        LengthAsLI = (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.Length;
    } else {
        //it's okay that this code is big.....see the C.I. above
        PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
        PLOWIO_LOCK_LIST LockList = rw->LockList;
        ByteOffsetAsLI = (PLARGE_INTEGER)&LockList->ByteOffset;
        LengthAsLI = (PLARGE_INTEGER)&LockList->Length;
        RxDbgTrace(0, Dbg, ("MRxSmbBuildLocksAndX using locklist, byteoffptr,lengthptr=%08lx,%08lx\n",
                                               ByteOffsetAsLI, LengthAsLI ));
        //DbgBreakPoint();
    }

    if (FlagOn(pServer->DialectFlags,DF_LANMAN20)) {
        ULONG SharedLock = (LowIoContext->Operation==LOWIO_OP_SHAREDLOCK);
        ULONG Timeout = (LowIoContext->ParamsFor.Locks.Flags&LOWIO_LOCKSFLAG_FAIL_IMMEDIATELY)?0:0xffffffff;
        ULONG UseLargeOffsets = LOCKING_ANDX_LARGE_FILES;

        if (!FlagOn(pServer->DialectFlags,DF_NT_SMBS)) {
            UseLargeOffsets = 0;
        }

        COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_Never, SMB_COM_LOCKING_ANDX,
                                SMB_REQUEST_SIZE(LOCKING_ANDX),
                                NO_EXTRA_DATA,NO_SPECIAL_ALIGNMENT,RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                     );

        MRxSmbDumpStufferState (1000,"SMB w/ NTLOCKS&X before stuffing",StufferState);


        MRxSmbStuffSMB (StufferState,
             "XwwDwwB?",
                                        //  X         UCHAR WordCount;                    // Count of parameter words = 8
                                        //            UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
                                        //            UCHAR AndXReserved;                 // Reserved (must be 0)
                                        //            _USHORT( AndXOffset );              // Offset to next command WordCount
                  smbSrvOpen->Fid,      //  w         _USHORT( Fid );                     // File handle
                                        //
                                        //            //
                                        //            // When NT protocol is not negotiated the OplockLevel field is
                                        //            // omitted, and LockType field is a full word.  Since the upper
                                        //            // bits of LockType are never used, this definition works for
                                        //            // all protocols.
                                        //            //
                                        //
                  SharedLock            //  w         UCHAR( LockType );                  // Locking mode:
                      +UseLargeOffsets,
                                        //                                                //  bit 0: 0 = lock out all access
                                        //                                                //         1 = read OK while locked
                                        //                                                //  bit 1: 1 = 1 user total file unlock
                                        //            UCHAR( OplockLevel );               // The new oplock level
                  SMB_OFFSET_CHECK(LOCKING_ANDX,Timeout)
                  Timeout,              //  D         _ULONG( Timeout );
                  NumberOfUnlocks,      //  w         _USHORT( NumberOfUnlocks );         // Num. unlock range structs following
                  NumberOfLocks,        //  w         _USHORT( NumberOfLocks );           // Num. lock range structs following
                  SMB_WCT_CHECK(8) 0
                                        //  B?         _USHORT( ByteCount );               // Count of data bytes
                                        //            UCHAR Buffer[1];                    // Buffer containing:
                                        //            //LOCKING_ANDX_RANGE Unlocks[];     //  Unlock ranges
                                        //            //LOCKING_ANDX_RANGE Locks[];       //  Lock ranges
                 );


         if (UseLargeOffsets) {
            //NTversion
            MRxSmbStuffSMB (StufferState,
                 "wwdddd!",
                                               //        typedef struct _NT_LOCKING_ANDX_RANGE {
                      MRXSMB_PROCESS_ID     ,  //  w         _USHORT( Pid );                     // PID of process "owning" lock
                      0,                       //  w         _USHORT( Pad );                     // Pad to DWORD align (mbz)
                      ByteOffsetAsLI->HighPart,//  d         _ULONG( OffsetHigh );               // Ofset to bytes to [un]lock (high)
                      ByteOffsetAsLI->LowPart, //  d         _ULONG( OffsetLow );                // Ofset to bytes to [un]lock (low)
                      LengthAsLI->HighPart,    //  d         _ULONG( LengthHigh );               // Number of bytes to [un]lock (high)
                      LengthAsLI->LowPart      //  d         _ULONG( LengthLow );                // Number of bytes to [un]lock (low)
                                               //        } NTLOCKING_ANDX_RANGE;
                     );
         } else {
            MRxSmbStuffSMB (StufferState,
                 "wdd!",
                     MRXSMB_PROCESS_ID     ,   //         typedef struct _LOCKING_ANDX_RANGE {
                                               //   w         _USHORT( Pid );                     // PID of process "owning" lock
                                               //   d         _ULONG( Offset );                   // Ofset to bytes to [un]lock
                      ByteOffsetAsLI->LowPart,
                                               //   d         _ULONG( Length );                   // Number of bytes to [un]lock
                      LengthAsLI->LowPart
                                               //         } LOCKING_ANDX_RANGE;
                     );
         }

        MRxSmbDumpStufferState (700,"SMB w/ NTLOCKS&X after stuffing",StufferState);
    } else {
        //lockbyterange and unlockbyterange have the same format......
        COVERED_CALL(MRxSmbStartSMBCommand ( StufferState, SetInitialSMB_Never,
                                               (UCHAR)((NumberOfLocks==0)?SMB_COM_UNLOCK_BYTE_RANGE
                                                                :SMB_COM_LOCK_BYTE_RANGE),
                                               SMB_REQUEST_SIZE(LOCK_BYTE_RANGE),
                                               NO_EXTRA_DATA,NO_SPECIAL_ALIGNMENT,RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                               0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                                            );

        MRxSmbDumpStufferState (1000,"SMB w/ corelocking before stuffing",StufferState);

        ASSERT(ByteOffsetAsLI->HighPart==0);
        ASSERT(LengthAsLI->HighPart==0);

        MRxSmbStuffSMB (StufferState,
            "0wddB!",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 5
               smbSrvOpen->Fid,         //  w         _USHORT( Fid );                     // File handle
               LengthAsLI->LowPart,     //  d         _ULONG( Count );                    // Count of bytes to lock
               ByteOffsetAsLI->LowPart, //  d         _ULONG( Offset );                   // Offset from start of file
                                        //  B!        _USHORT( ByteCount );               // Count of data bytes = 0
                  SMB_WCT_CHECK(5) 0
                                        //            UCHAR Buffer[1];                    // empty
                 );

        MRxSmbDumpStufferState (700,"SMB w/ corelocking after stuffing",StufferState);
    }

FINALLY:
    RxDbgTraceUnIndent(-1, Dbg);
    return(Status);

}

NTSTATUS
MRxSmbBuildLockAssert (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a LockingAndX SMB for multiple locks by calling the lock enumerator.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    RxCaptureFcb;RxCaptureFobx;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)StufferState->Exchange;
    PSMBCE_SERVER pServer = SmbCeGetExchangeServer(StufferState->Exchange);

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PRX_LOCK_ENUMERATOR LockEnumerator = OrdinaryExchange->AssertLocks.LockEnumerator;
    ULONG UseLargeOffsets;
    BOOLEAN LocksExclusiveForThisPacket = TRUE;
    PBYTE PtrToLockCount;


    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildLockAssert enum=%08lx\n",LockEnumerator));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    if (smbSrvOpen->Fid == 0xffff) {
        return STATUS_FILE_CLOSED;
    }

    RxDbgTrace(0,Dbg,("Oplock response for FID(%lx)\n",smbSrvOpen->Fid));

    UseLargeOffsets = FlagOn(pServer->DialectFlags,DF_NT_SMBS)?LOCKING_ANDX_LARGE_FILES:0;
    //UseLargeOffsets = FALSE;

    OrdinaryExchange->AssertLocks.NumberOfLocksPlaced = 0;
    for (;;) {

        ASSERT_ORDINARY_EXCHANGE ( OrdinaryExchange );

        RxDbgTrace(0, Dbg, ("top of loop %08lx %08lx %08lx\n",
                  OrdinaryExchange->AssertLocks.NumberOfLocksPlaced,
                  OrdinaryExchange->AssertLocks.LockAreaNonEmpty,
                  OrdinaryExchange->AssertLocks.EndOfListReached
                  ));

        if (!OrdinaryExchange->AssertLocks.EndOfListReached
              && !OrdinaryExchange->AssertLocks.LockAreaNonEmpty) {
            //get a new lock
            //DbgBreakPoint();
            if (LockEnumerator(
                           OrdinaryExchange->AssertLocks.SrvOpen,
                           &OrdinaryExchange->AssertLocks.ContinuationHandle,
                           &OrdinaryExchange->AssertLocks.NextLockOffset,
                           &OrdinaryExchange->AssertLocks.NextLockRange,
                           &OrdinaryExchange->AssertLocks.NextLockIsExclusive
                           )){
                OrdinaryExchange->AssertLocks.LockAreaNonEmpty = TRUE;
            } else {
                OrdinaryExchange->AssertLocks.LockAreaNonEmpty = FALSE;
                OrdinaryExchange->AssertLocks.EndOfListReached = TRUE;
                OrdinaryExchange->AssertLocks.NextLockIsExclusive = TRUE;
            }
        }

        RxDbgTrace(0, Dbg, ("got a lockorempty %08lx %08lx %08lx\n",
                  OrdinaryExchange->AssertLocks.NumberOfLocksPlaced,
                  OrdinaryExchange->AssertLocks.LockAreaNonEmpty,
                  OrdinaryExchange->AssertLocks.EndOfListReached
                  ));
        //DbgBreakPoint();

        if (OrdinaryExchange->AssertLocks.NumberOfLocksPlaced == 0){

            ULONG Timeout = 0xffffffff;
            ULONG SharedLock = !OrdinaryExchange->AssertLocks.NextLockIsExclusive;

            LocksExclusiveForThisPacket = OrdinaryExchange->AssertLocks.NextLockIsExclusive;

            COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_Never, SMB_COM_LOCKING_ANDX,
                                    SMB_REQUEST_SIZE(LOCKING_ANDX),
                                    NO_EXTRA_DATA,NO_SPECIAL_ALIGNMENT,RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                         );

            MRxSmbDumpStufferState (1000,"SMB w/ NTLOCKS&X(assertbuf) before stuffing",StufferState);


            MRxSmbStuffSMB (StufferState,
                 "XwrwDwrwB?",
                                            //  X         UCHAR WordCount;                    // Count of parameter words = 8
                                            //            UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
                                            //            UCHAR AndXReserved;                 // Reserved (must be 0)
                                            //            _USHORT( AndXOffset );              // Offset to next command WordCount
                      smbSrvOpen->Fid,      //  w         _USHORT( Fid );                     // File handle
                                            //
                                            //            //
                                            //            // When NT protocol is not negotiated the OplockLevel field is
                                            //            // omitted, and LockType field is a full word.  Since the upper
                                            //            // bits of LockType are never used, this definition works for
                                            //            // all protocols.
                                            //            //
                                            //
                                            //  rw         UCHAR( LockType );                  // Locking mode:
                      &OrdinaryExchange->AssertLocks.PtrToLockType,0,
                      SharedLock+UseLargeOffsets,
                                            //                                                //  bit 0: 0 = lock out all access
                                            //                                                //         1 = read OK while locked
                                            //                                                //  bit 1: 1 = 1 user total file unlock
                                            //            UCHAR( OplockLevel );               // The new oplock level
                      SMB_OFFSET_CHECK(LOCKING_ANDX,Timeout)
                      Timeout,              //  D         _ULONG( Timeout );
                      0,                    //  w         _USHORT( NumberOfUnlocks );         // Num. unlock range structs following
                                            // rw         _USHORT( NumberOfLocks );           // Num. lock range structs following
                      &PtrToLockCount,0,
                      0,
                      SMB_WCT_CHECK(8) 0
                                            //  B?         _USHORT( ByteCount );               // Count of data bytes
                                            //            UCHAR Buffer[1];                    // Buffer containing:
                                            //            //LOCKING_ANDX_RANGE Unlocks[];     //  Unlock ranges
                                            //            //LOCKING_ANDX_RANGE Locks[];       //  Lock ranges
                     );
            ASSERT_ORDINARY_EXCHANGE ( OrdinaryExchange );
            RxDbgTrace(0, Dbg, ("PTRS %08lx %08lx\n",
                      OrdinaryExchange->AssertLocks.PtrToLockType,
                      PtrToLockCount
                      ));
        }

        if (OrdinaryExchange->AssertLocks.EndOfListReached
             || (LocksExclusiveForThisPacket != OrdinaryExchange->AssertLocks.NextLockIsExclusive)
             || (OrdinaryExchange->AssertLocks.NumberOfLocksPlaced >= 20)
             // the lock limit will have to take cognizance of the remaining space in the buffer. this will be
             // different depending on whether a full buffer is used or a vestigial buffer. SO, this cannot just
             // be turned into another constant
            ){
            break;
        }

        ASSERT_ORDINARY_EXCHANGE ( OrdinaryExchange );
        if (UseLargeOffsets) {
            MRxSmbStuffSMB (StufferState,
                 "wwdddd?",
                                               //        typedef struct _NT_LOCKING_ANDX_RANGE {
                      MRXSMB_PROCESS_ID     ,  //  w         _USHORT( Pid );                     // PID of process "owning" lock
                      0,                       //  w         _USHORT( Pad );                     // Pad to DWORD align (mbz)
                                               //  d         _ULONG( OffsetHigh );               // Ofset to bytes to [un]lock (high)
                      OrdinaryExchange->AssertLocks.NextLockOffset.HighPart,
                                               //  d         _ULONG( OffsetLow );                // Ofset to bytes to [un]lock (low)
                      OrdinaryExchange->AssertLocks.NextLockOffset.LowPart,
                                               //  d         _ULONG( LengthHigh );               // Number of bytes to [un]lock (high)
                      OrdinaryExchange->AssertLocks.NextLockRange.HighPart,
                                               //  d         _ULONG( LengthLow );                // Number of bytes to [un]lock (low)
                      OrdinaryExchange->AssertLocks.NextLockRange.LowPart,
                                               //        } NTLOCKING_ANDX_RANGE;
                      0
                     );
        } else {
            MRxSmbStuffSMB (StufferState,
                 "wdd?",
                     MRXSMB_PROCESS_ID     ,   //         typedef struct _LOCKING_ANDX_RANGE {
                                               //   w         _USHORT( Pid );                     // PID of process "owning" lock
                                               //   d         _ULONG( Offset );                   // Ofset to bytes to [un]lock
                      OrdinaryExchange->AssertLocks.NextLockOffset.LowPart,
                                               //   d         _ULONG( Length );                   // Number of bytes to [un]lock
                      OrdinaryExchange->AssertLocks.NextLockRange.LowPart,
                                               //         } LOCKING_ANDX_RANGE;
                      0
                     );
        }

        ASSERT_ORDINARY_EXCHANGE ( OrdinaryExchange );
        OrdinaryExchange->AssertLocks.NumberOfLocksPlaced += 1;
        SmbPutUshort(PtrToLockCount, (USHORT)(OrdinaryExchange->AssertLocks.NumberOfLocksPlaced));
        OrdinaryExchange->AssertLocks.LockAreaNonEmpty = FALSE;
        ASSERT_ORDINARY_EXCHANGE ( OrdinaryExchange );

    }

    MRxSmbStuffSMB (StufferState, "!",  0);  //fill in the bytecount
    MRxSmbDumpStufferState (700,"SMB w/ NTLOCKS&X(assertingbuffered) after stuffing",StufferState);

FINALLY:
    RxDbgTraceUnIndent(-1, Dbg);
    return(Status);

}

NTSTATUS
SmbPseExchangeStart_Locks(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the start routine for locks AND for flush.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    ULONG StartEntryCount;

    SMB_PSE_ORDINARY_EXCHANGE_TYPE OEType;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    PSMBCE_SERVER pServer = SmbCeGetExchangeServer(OrdinaryExchange);

    RxCaptureFcb; RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    BOOLEAN  SynchronousIo = !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Locks\n", 0 ));

    ASSERT(OrdinaryExchange->Type == ORDINARY_EXCHANGE);
    ASSERT( (OrdinaryExchange->SmbCeFlags&SMBCE_EXCHANGE_ATTEMPT_RECONNECTS) == 0 );

    OrdinaryExchange->StartEntryCount++;
    StartEntryCount = OrdinaryExchange->StartEntryCount;

    // Ensure that the Fid is validated
    SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);

    for (;;) {
        switch (OrdinaryExchange->OpSpecificState) {
        case SmbPseOEInnerIoStates_Initial:
            OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;
            if (!SynchronousIo) {
                OrdinaryExchange->AsyncResumptionRoutine = SmbPseExchangeStart_Locks;
            }
            MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

            rw->LockList = LowIoContext->ParamsFor.Locks.LockList;

            //lack of break is intentional
        case SmbPseOEInnerIoStates_ReadyToSend:
            OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_OperationOutstanding;
            OrdinaryExchange->SendOptions = MRxSmbLockSendOptions;

            switch (OrdinaryExchange->EntryPoint) {
            case SMBPSE_OE_FROM_FLUSH:
                OEType = SMBPSE_OETYPE_FLUSH;
                COVERED_CALL(MRxSmbBuildFlush(StufferState));
                break;
            case SMBPSE_OE_FROM_ASSERTBUFFEREDLOCKS:
                OEType = SMBPSE_OETYPE_ASSERTBUFFEREDLOCKS;
                COVERED_CALL(MRxSmbBuildLockAssert(StufferState));
                if ((OrdinaryExchange->AssertLocks.EndOfListReached)
                      && (OrdinaryExchange->AssertLocks.NumberOfLocksPlaced == 0) ) {
                   OrdinaryExchange->SendOptions = RXCE_SEND_SYNCHRONOUS;
                   OrdinaryExchange->SmbCeFlags |= SMBCE_EXCHANGE_MID_VALID;
                   OrdinaryExchange->Mid        = SMBCE_OPLOCK_RESPONSE_MID;
                   OrdinaryExchange->Flags |= SMBPSE_OE_FLAG_NO_RESPONSE_EXPECTED;
                   *(OrdinaryExchange->AssertLocks.PtrToLockType) |= 2;
                }
                break;
            case SMBPSE_OE_FROM_LOCKS:
                OEType = SMBPSE_OETYPE_LOCKS;
                switch (LowIoContext->Operation) {
                case LOWIO_OP_SHAREDLOCK:
                case LOWIO_OP_EXCLUSIVELOCK:
                    ASSERT (MRxSmbIsLockRealizable(
                                           capFcb,
                                           (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.ByteOffset,
                                           (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.Length,
                                           LowIoContext->ParamsFor.Locks.Flags
                                           )
                                  == STATUS_SUCCESS);
                    //lack of break is intentional...........
                case LOWIO_OP_UNLOCK:
                    rw->LockList = NULL;
                    COVERED_CALL(MRxSmbBuildLocksAndX(StufferState));
                    break;
                case LOWIO_OP_UNLOCK_MULTIPLE: {
                    RxDbgTrace(0, Dbg, ("--->in locks_start, remaining locklist=%08lx\n", rw->LockList));
                    ASSERT( rw->LockList != NULL );
                    COVERED_CALL(MRxSmbBuildLocksAndX(StufferState));
                    break;
                    }
                default:
                    ASSERT(!"Bad lowio op for locks\n");
                    Status = STATUS_NOT_IMPLEMENTED;
                    goto FINALLY;
                }
                break;
            default:
                ASSERT(!"Bad entrypoint for locks_start\n");
                Status = STATUS_NOT_IMPLEMENTED;
                goto FINALLY;
            }

            Status = SmbPseOrdinaryExchange(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                            OEType
                                            );
            if (Status==STATUS_PENDING) {
                ASSERT(!SynchronousIo);
                goto FINALLY;
            }
            //lack of break is intentional
        case SmbPseOEInnerIoStates_OperationOutstanding:
            OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;
            Status = OrdinaryExchange->SmbStatus;

            switch (OrdinaryExchange->EntryPoint) {
            case SMBPSE_OE_FROM_FLUSH:
                goto FINALLY;
                //break;
            case SMBPSE_OE_FROM_ASSERTBUFFEREDLOCKS:
                if ((OrdinaryExchange->AssertLocks.EndOfListReached)
                      && (OrdinaryExchange->AssertLocks.NumberOfLocksPlaced == 0) ) {
                    goto FINALLY;
                }
                MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0));
                break;
            case SMBPSE_OE_FROM_LOCKS:
                // if the locklist is empty. we can get out. this can happen either because we're not using
                // the locklist OR because we advance to the end of the list. that's why there are two checks
                if (rw->LockList == NULL) goto FINALLY;
                rw->LockList = rw->LockList->Next;
                if (rw->LockList == 0) goto FINALLY;

                if (Status != STATUS_SUCCESS) { goto FINALLY; }
                MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0));
                break;
            //default:
            //    ASSERT(!"Bad entrypoint for locks_start\n");
            //    Status = RxStatus(NOT_IMPLEMENTED);
            //    goto FINALLY;
            }
            break;
        }
    }

FINALLY:
    if ( Status != STATUS_PENDING ) {
        SmbPseAsyncCompletionIfNecessary(OrdinaryExchange,RxContext);
    }

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Locks exit w %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbFinishLocks (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_LOCKING_ANDX             Response
      )
/*++

Routine Description:

    This routine actually gets the stuff out of the Close response and finishes the locks.

Arguments:

    OrdinaryExchange - the exchange instance
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishLocks\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishLocks:");

    if (Response->WordCount != 2) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishLocks   returning %08lx\n", Status ));
    return Status;
}


NTSTATUS
MRxSmbCompleteBufferingStateChangeRequest(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRX_SRV_OPEN   SrvOpen,
    IN     PVOID       pContext
    )
/*++

Routine Description:

    This routine is called to assert the locks that the wrapper has buffered. currently, it is synchronous!


Arguments:

    RxContext - the open instance
    SrvOpen   - tells which fcb is to be used.
    LockEnumerator - the routine to call to get the locks

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSMBSTUFFER_BUFFER_STATE StufferState = NULL;
    PMRX_FCB Fcb = SrvOpen->pFcb;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(Fcb);

    USHORT NewOplockLevel = (USHORT)(pContext);

    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;


    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCompleteBufferingStateChangeRequest\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    RxDbgTrace(0,Dbg,("@@@@@@ Old Level (%lx) to New Level %lx @@@@\n",smbSrvOpen->OplockLevel,NewOplockLevel));
    smbFcb->LastOplockLevel = NewOplockLevel;
    if ((smbSrvOpen->OplockLevel == SMB_OPLOCK_LEVEL_II) &&
        (NewOplockLevel == SMB_OPLOCK_LEVEL_NONE)) {
       return STATUS_SUCCESS;
    }
    smbSrvOpen->OplockLevel = (UCHAR)NewOplockLevel;
    Status = SmbPseCreateOrdinaryExchange(RxContext,
                                          SrvOpen->pVNetRoot,
                                          SMBPSE_OE_FROM_ASSERTBUFFEREDLOCKS,
                                          SmbPseExchangeStart_Locks,
                                          &OrdinaryExchange
                                          );
    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return(Status);
    }

    // The SERVER has a time window of 45 seconds associated with OPLOCK responses.
    // During this period oplock responses ( the last packet ) do not elicit any
    // response. If the response at the server is received after this window has
    // elapsed the OPLOCK response will elicit a normal LOCKING_ANDX response from
    // the server. In order to simplify the MID reuse logic at the clients without
    // violating the OPLOCK semantics, all the final responses are sent on a special
    // MID(0xffff). Any response received with this MID is accepted by default and this
    // MID is not used further.
    OrdinaryExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_REUSE_MID;
    OrdinaryExchange->AssertLocks.LockEnumerator = RxLockEnumerator;
    OrdinaryExchange->AssertLocks.SrvOpen = SrvOpen;

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status!=STATUS_PENDING);
    if (Status!=STATUS_PENDING) {
        BOOLEAN FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
        ASSERT(FinalizationComplete);
    }
    RxDbgTrace(-1, Dbg, ("MRxSmbAssertBufferedFileLocks  exit with status=%08lx\n", Status ));
    return(Status);
}


#undef  Dbg
#define Dbg                              (DEBUG_TRACE_FLUSH)

NTSTATUS
MRxSmbBuildFlush (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a Flush SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildFlush\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_Never, SMB_COM_FLUSH,
                                SMB_REQUEST_SIZE(FLUSH),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ FLUSH before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 1
             smbSrvOpen->Fid,       //  w         _USHORT( Fid );                     // File handle
             SMB_WCT_CHECK(1) 0     //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );
    MRxSmbDumpStufferState (700,"SMB w/ FLUSH after stuffing",StufferState);

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}


NTSTATUS
MRxSmbFlush(
      IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine handles network requests for file flush

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;

    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFlush\n"));

    if (TypeOfOpen == RDBSS_NTC_SPOOLFILE) {
        //we don't buffer spoolfiles....just get out....
        RxDbgTrace(-1, Dbg, ("MRxSmbFlush exit on spoolfile\n"));
        return(STATUS_SUCCESS);
    }

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    Status = SmbPseCreateOrdinaryExchange(RxContext,
                                          SrvOpen->pVNetRoot,
                                          SMBPSE_OE_FROM_FLUSH,
                                          SmbPseExchangeStart_Locks,
                                          &OrdinaryExchange
                                          );
    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return(Status);
    }

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status!=STATUS_PENDING);
    if (Status!=STATUS_PENDING) {
        BOOLEAN FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
        ASSERT(FinalizationComplete);
    }
    RxDbgTrace(-1, Dbg, ("MRxSmbFlush  exit with status=%08lx\n", Status ));
    return(Status);

}


NTSTATUS
MRxSmbIsLockRealizable (
    IN OUT PMRX_FCB pFcb,
    IN PLARGE_INTEGER  ByteOffset,
    IN PLARGE_INTEGER  Length,
    IN ULONG  LowIoLockFlags
    )
{
    PSMBCEDB_SERVER_ENTRY pServerEntry;
    ULONG DialectFlags;

    PAGED_CODE();
    pServerEntry = SmbCeGetAssociatedServerEntry(pFcb->pNetRoot->pSrvCall);
    DialectFlags = pServerEntry->Server.DialectFlags;

    //nt servers implement all types of locks

    if (FlagOn(DialectFlags,DF_NT_SMBS)) {
        return(STATUS_SUCCESS);
    }

    //nonnt servers do not handle 64bit locks or 0-length locks

    if ( (ByteOffset->HighPart!=0)
           || (Length->HighPart!=0)
           || (Length->QuadPart==0) ) {
        return(STATUS_NOT_SUPPORTED);
    }

    //  Lanman 2.0 pinball servers don't support shared locks (even
    //  though Lanman 2.0 FAT servers support them).  As a result,
    //  we cannot support shared locks to Lanman servers.
    //

    if (!FlagOn(DialectFlags,DF_LANMAN21)
           && !FlagOn(LowIoLockFlags,LOWIO_LOCKSFLAG_EXCLUSIVELOCK)) {
        return(STATUS_NOT_SUPPORTED);
    }

    //  if a server cannot do lockingAndX, then we can't do
    //  !FailImmediately because there's no timeout

    if (!FlagOn(DialectFlags,DF_LANMAN20)
           && !FlagOn(LowIoLockFlags,LOWIO_LOCKSFLAG_FAIL_IMMEDIATELY)) {
        return(STATUS_NOT_SUPPORTED);
    }

    return(STATUS_SUCCESS);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\init.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    Init.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the SMB mini rdr.

--*/

#include "precomp.h"
#pragma hdrstop
#include "smbmrx.h"


#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, MRxSmbInitUnwind)
#pragma alloc_text(PAGE, MRxSmbUnload)
#pragma alloc_text(PAGE, MRxSmbInitializeTables)
#pragma alloc_text(PAGE, MRxSmbStart)
#pragma alloc_text(PAGE, MRxSmbStop)
#pragma alloc_text(PAGE, MRxSmbInitializeSecurity)
#pragma alloc_text(PAGE, MRxSmbUninitializeSecurity)
#pragma alloc_text(PAGE, SmbCeGetConfigurationInformation)
#pragma alloc_text(PAGE, MRxSmbFsdDispatch)
#pragma alloc_text(PAGE, MRxSmbDeallocateForFcb)
#pragma alloc_text(PAGE, MRxSmbDeallocateForFobx)
#pragma alloc_text(PAGE, MRxSmbGetUlongRegistryParameter)
#endif

extern ERESOURCE    s_SmbCeDbResource;

//
// Global data declarations .
//

PVOID MRxSmbPoRegistrationState = NULL;

FAST_MUTEX   MRxSmbSerializationMutex;

MRXSMB_CONFIGURATION MRxSmbConfiguration;

MRXSMB_STATE MRxSmbState = MRXSMB_STARTABLE;

SMBCE_CONTEXT SmbCeContext;
PMDL          s_pEchoSmbMdl = NULL;
ULONG         s_EchoSmbLength = 0;


#ifdef EXPLODE_POOLTAGS
ULONG         MRxSmbExplodePoolTags = 1;
#else
ULONG         MRxSmbExplodePoolTags = 0;
#endif

//
// Mini Redirector global variables.
//

struct _MINIRDR_DISPATCH  MRxSmbDispatch;

PRDBSS_DEVICE_OBJECT MRxSmbDeviceObject;

MRXSMB_GLOBAL_PADDING MrxSmbCeGlobalPadding;

//
// If this flag is TRUE, we strictly obey the transport binding order.  If it is FALSE,
//  we can use whatever transport we want to connect to the remote server.
//
BOOLEAN MRxSmbObeyBindingOrder = FALSE;

//
// MRxSmbSecurityInitialized indicates whether MRxSmbInitializeSecurity
// has been called.
//

BOOLEAN MRxSmbSecurityInitialized = FALSE;


LIST_ENTRY MRxSmbPagingFilesSrvOpenList;

//declare the shadow debugtrace controlpoints

RXDT_DefineCategory(CREATE);
RXDT_DefineCategory(CLEANUP);
RXDT_DefineCategory(CLOSE);
RXDT_DefineCategory(READ);
RXDT_DefineCategory(WRITE);
RXDT_DefineCategory(LOCKCTRL);
RXDT_DefineCategory(FLUSH);
RXDT_DefineCategory(PREFIX);
RXDT_DefineCategory(FCBSTRUCTS);
RXDT_DefineCategory(DISPATCH);
RXDT_DefineCategory(EA);
RXDT_DefineCategory(DEVFCB);
RXDT_DefineCategory(CONNECT);

typedef enum _MRXSMB_INIT_STATES {
    MRXSMBINIT_ALL_INITIALIZATION_COMPLETED,
    MRXSMBINIT_MINIRDR_REGISTERED,
    MRXSMBINIT_START
} MRXSMB_INIT_STATES;

VOID
MRxSmbInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN MRXSMB_INIT_STATES MRxSmbInitState
    );


NTSTATUS
MRxSmbFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This is the initialization routine for the SMB mini redirector

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    RXSTATUS - The function value is the final status from the initialization
        operation.

--*/
{
    NTSTATUS           Status;
    MRXSMB_INIT_STATES MRxSmbInitState = 0;
    UNICODE_STRING     SmbMiniRedirectorName;
    UNICODE_STRING     UserModeDeviceName;
    ULONG              Controls = 0;

    PAGED_CODE();

#ifdef MONOLITHIC_MINIRDR
    Status =  RxDriverEntry(DriverObject, RegistryPath);
    if (Status != STATUS_SUCCESS) {
        DbgPrint("Wrapper failed to initialize. Status = %08lx\n",Status);
        return(Status);
    }
#endif

    RtlZeroMemory(&MRxSmbStatistics,sizeof(MRxSmbStatistics));
    RtlZeroMemory(&MRxSmbConfiguration,sizeof(MRxSmbConfiguration));
    KeQuerySystemTime(&MRxSmbStatistics.StatisticsStartTime);
    RtlZeroMemory(&MrxSmbCeGlobalPadding,sizeof(MrxSmbCeGlobalPadding));
    MmInitializeMdl(&MrxSmbCeGlobalPadding.Mdl,&MrxSmbCeGlobalPadding.Pad[0],SMBCE_PADDING_DATA_SIZE);
    MmBuildMdlForNonPagedPool(&MrxSmbCeGlobalPadding.Mdl);

    ExInitializeFastMutex(&MRxSmbSerializationMutex);

    Status = MRxSmbInitializeTransport();
    if (Status != STATUS_SUCCESS) {
       RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxSmbDriverEntry failed to init transport data structures: %08lx\n", Status ));
       return(STATUS_UNSUCCESSFUL);
    }

    try {
        ExInitializeResource(&s_SmbCeDbResource);
        MRxSmbInitState = MRXSMBINIT_START;


        RtlInitUnicodeString(&SmbMiniRedirectorName,  DD_SMBMRX_FS_DEVICE_NAME_U);
        RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxSmbDriverEntry: DriverObject =%p\n", DriverObject ));

        SetFlag(Controls,RX_REGISTERMINI_FLAG_DONT_PROVIDE_MAILSLOTS);
        Status = RxRegisterMinirdr(&MRxSmbDeviceObject,
                                    DriverObject,
                                    &MRxSmbDispatch,
                                    Controls,
                                    &SmbMiniRedirectorName,
                                    0,
                                    FILE_DEVICE_NETWORK_FILE_SYSTEM,
                                    FILE_REMOTE_DEVICE
                                    );
        if (Status!=STATUS_SUCCESS) {
            RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxSmbDriverEntry failed: %08lx\n", Status ));
            try_return(Status);
        }
        MRxSmbInitState = MRXSMBINIT_MINIRDR_REGISTERED;

        RtlInitUnicodeString(&UserModeDeviceName, DD_SMBMRX_USERMODE_SHADOW_DEV_NAME_U);
        Status = IoCreateSymbolicLink( &UserModeDeviceName, &SmbMiniRedirectorName);

        //for all this stuff, there's no undo.....so no extra state

        Status = MRxSmbInitializeTables();
        if (!NT_SUCCESS( Status )) {
            try_return(Status);
        }

        RtlInitUnicodeString(&SmbCeContext.ComputerName,NULL);
        RtlInitUnicodeString(&SmbCeContext.OperatingSystem, NULL);
        RtlInitUnicodeString(&SmbCeContext.LanmanType, NULL);
        RtlInitUnicodeString(&SmbCeContext.Transports, NULL);
        
        MRxSmbConfiguration.SessionTimeoutInterval = MRXSMB_DEFAULT_TIMED_EXCHANGE_EXPIRY_TIME;
        MRxSmbConfiguration.LockIncrement = 0;
        MRxSmbConfiguration.MaximumLock = 1000;
        SmbCeGetConfigurationInformation();
        SmbCeGetComputerName();
        SmbCeGetOperatingSystemInformation();

  try_exit: NOTHING;
    } finally {
        if (Status != STATUS_SUCCESS) {
            MRxSmbInitUnwind(DriverObject,MRxSmbInitState);
        }
    }
    if (Status != STATUS_SUCCESS) {
        DbgPrint("MRxSmb failed to start with %08lx %08lx\n",Status,MRxSmbInitState);
        return(Status);
    }


    //  Setup Unload Routine
    DriverObject->DriverUnload = MRxSmbUnload;

    // set all IRR_MJ to the dispatch point
    {
        ULONG i;

        for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
            DriverObject->MajorFunction[i] = (PDRIVER_DISPATCH)MRxSmbFsdDispatch;
        }
    }

    //and get out
    return  STATUS_SUCCESS;

}

VOID
MRxSmbInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN MRXSMB_INIT_STATES MRxSmbInitState
    )
/*++

Routine Description:

     This routine does the common uninit work for unwinding from a bad driver entry or for unloading.

Arguments:

     RxInitState - tells how far we got into the intialization

Return Value:

     None

--*/

{
    PAGED_CODE();

    switch (MRxSmbInitState) {
    case MRXSMBINIT_ALL_INITIALIZATION_COMPLETED:
        //Nothing extra to do...this is just so that the constant in RxUnload doesn't change.......
        //lack of break intentional

    case MRXSMBINIT_MINIRDR_REGISTERED:
        RxUnregisterMinirdr(MRxSmbDeviceObject);
        //lack of break intentional

    case MRXSMBINIT_START:
	    // Deallocate the configuration strings ....
	    if (SmbCeContext.ComputerName.Buffer != NULL) {
	       RxFreePool(SmbCeContext.ComputerName.Buffer);
	    }

	    if (SmbCeContext.OperatingSystem.Buffer != NULL) {
	       RxFreePool(SmbCeContext.OperatingSystem.Buffer);
	    }

	    if (SmbCeContext.LanmanType.Buffer != NULL) {
	       RxFreePool(SmbCeContext.LanmanType.Buffer);
	    }
	    if (SmbCeContext.Transports.Buffer != NULL) {

	        // the transports buffer is at the end of a larger buffer (by 12 bytes)
	        // allocated to read the value from the registry. recover the original buffer
	        // pointer in order to free.

	        PKEY_VALUE_PARTIAL_INFORMATION TransportsValueFromRegistry;
	        TransportsValueFromRegistry = CONTAINING_RECORD(
	                                         SmbCeContext.Transports.Buffer,
	                                         KEY_VALUE_PARTIAL_INFORMATION,
	                                         Data[0]
	                                      );
	        //DbgPrint("b1 %08lx b2 %08lx\n", TransportsValueFromRegistry,SmbCeContext.Transports.Buffer);
	        RxFreePool(TransportsValueFromRegistry);

	        SmbCeContext.Transports.Buffer = NULL;
	        SmbCeContext.Transports.Length = 0;
	        SmbCeContext.Transports.MaximumLength = 0;
	    }
        MRxSmbUninitializeTransport();
        ExDeleteResource(&s_SmbCeDbResource);
        break;
    }

}


VOID
MRxSmbUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

     This is the unload routine for the SMB mini redirector.

Arguments:

     DriverObject - pointer to the driver object for the MRxSmb

Return Value:

     None

--*/

{
    UNICODE_STRING  UserModeDeviceName;

    PAGED_CODE();

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxSmbUnload: DriverObject =%p\n", DriverObject) );

    MRxSmbInitUnwind(DriverObject,MRXSMBINIT_ALL_INITIALIZATION_COMPLETED);

    RtlInitUnicodeString(&UserModeDeviceName, DD_SMBMRX_USERMODE_SHADOW_DEV_NAME_U);
    IoDeleteSymbolicLink( &UserModeDeviceName);

#ifdef MONOLITHIC_MINIRDR
    RxUnload(DriverObject);
#endif

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("MRxSmbUnload exit: DriverObject =%p\n", DriverObject) );
}



NTSTATUS
MRxSmbInitializeTables(
          void
    )
/*++

Routine Description:

     This routine sets up the mini redirector dispatch vector and also calls to initialize any other tables needed.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PAGED_CODE();

    // Ensure that the SMB mini redirector context satisfies the size constraints
    ASSERT(sizeof(MRXSMB_RX_CONTEXT) <= MRX_CONTEXT_SIZE);

    //local minirdr dispatch table init
    ZeroAndInitializeNodeType( &MRxSmbDispatch, RDBSS_NTC_MINIRDR_DISPATCH, sizeof(MINIRDR_DISPATCH));

    // SMB mini redirector extension sizes and allocation policies.

    MRxSmbDispatch.MRxFlags = (RDBSS_MANAGE_FCB_EXTENSION |
                               RDBSS_MANAGE_SRV_OPEN_EXTENSION |
                               RDBSS_MANAGE_FOBX_EXTENSION);

    MRxSmbDispatch.MRxSrvCallSize  = 0;
    MRxSmbDispatch.MRxNetRootSize  = 0;
    MRxSmbDispatch.MRxVNetRootSize = 0;
    MRxSmbDispatch.MRxFcbSize      = sizeof(MRX_SMB_FCB);
    MRxSmbDispatch.MRxSrvOpenSize  = sizeof(MRX_SMB_SRV_OPEN);
    MRxSmbDispatch.MRxFobxSize     = sizeof(MRX_SMB_FOBX);

    // Mini redirector cancel routine ..
    MRxSmbDispatch.MRxCancel = NULL;

    // Mini redirector Start/Stop
    MRxSmbDispatch.MRxStart                = MRxSmbStart;
    MRxSmbDispatch.MRxStop                 = MRxSmbStop;
    MRxSmbDispatch.MRxDevFcbXXXControlFile = MRxSmbDevFcbXXXControlFile;

    // Mini redirector name resolution
    MRxSmbDispatch.MRxCreateSrvCall       = MRxSmbCreateSrvCall;
    MRxSmbDispatch.MRxSrvCallWinnerNotify = MRxSmbSrvCallWinnerNotify;
    MRxSmbDispatch.MRxCreateVNetRoot      = MRxSmbCreateVNetRoot;
    MRxSmbDispatch.MRxUpdateNetRootState  = MRxSmbUpdateNetRootState;
    MRxSmbDispatch.MRxExtractNetRootName  = MRxSmbExtractNetRootName;
    MRxSmbDispatch.MRxFinalizeSrvCall     = MRxSmbFinalizeSrvCall;
    MRxSmbDispatch.MRxFinalizeNetRoot     = MRxSmbFinalizeNetRoot;
    MRxSmbDispatch.MRxFinalizeVNetRoot    = MRxSmbFinalizeVNetRoot;

    // File System Object Creation/Deletion.
    MRxSmbDispatch.MRxCreate              = MRxSmbCreate;
    MRxSmbDispatch.MRxCollapseOpen        = MRxSmbCollapseOpen;
    MRxSmbDispatch.MRxShouldTryToCollapseThisOpen
                                          = MRxSmbShouldTryToCollapseThisOpen;
    MRxSmbDispatch.MRxExtendForCache      = MRxSmbExtendForCache;
    MRxSmbDispatch.MRxExtendForNonCache   = MRxSmbExtendForNonCache;
    MRxSmbDispatch.MRxTruncate            = MRxSmbTruncate;
    MRxSmbDispatch.MRxCleanupFobx         = MRxSmbCleanupFobx;
    MRxSmbDispatch.MRxCloseSrvOpen        = MRxSmbCloseSrvOpen;
    MRxSmbDispatch.MRxFlush               = MRxSmbFlush;
    MRxSmbDispatch.MRxForceClosed         = MRxSmbForcedClose;
    MRxSmbDispatch.MRxDeallocateForFcb    = MRxSmbDeallocateForFcb;
    MRxSmbDispatch.MRxDeallocateForFobx   = MRxSmbDeallocateForFobx;
    MRxSmbDispatch.MRxIsLockRealizable    = MRxSmbIsLockRealizable;

    // File System Objects query/Set
    MRxSmbDispatch.MRxQueryDirectory  = MRxSmbQueryDirectory;
    MRxSmbDispatch.MRxQueryVolumeInfo = MRxSmbQueryVolumeInformation;
    MRxSmbDispatch.MRxSetVolumeInfo   = MRxSmbSetVolumeInformation;
    MRxSmbDispatch.MRxQueryEaInfo     = MRxSmbQueryEaInformation;
    MRxSmbDispatch.MRxSetEaInfo       = MRxSmbSetEaInformation;
    MRxSmbDispatch.MRxQuerySdInfo     = MRxSmbQuerySecurityInformation;
    MRxSmbDispatch.MRxSetSdInfo       = MRxSmbSetSecurityInformation;
    MRxSmbDispatch.MRxQueryQuotaInfo  = MRxSmbQueryQuotaInformation;
    MRxSmbDispatch.MRxSetQuotaInfo    = MRxSmbSetQuotaInformation;
    MRxSmbDispatch.MRxQueryFileInfo   = MRxSmbQueryFileInformation;
    MRxSmbDispatch.MRxSetFileInfo     = MRxSmbSetFileInformation;
    MRxSmbDispatch.MRxSetFileInfoAtCleanup
                                      = MRxSmbSetFileInformationAtCleanup;
    MRxSmbDispatch.MRxIsValidDirectory= MRxSmbIsValidDirectory;


    // Buffering state change
    MRxSmbDispatch.MRxComputeNewBufferingState = MRxSmbComputeNewBufferingState;

    // File System Object I/O
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_READ]            = MRxSmbRead;
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_WRITE]           = MRxSmbWrite;
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_SHAREDLOCK]      = MRxSmbLocks;
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_EXCLUSIVELOCK]   = MRxSmbLocks;
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK]          = MRxSmbLocks;
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK_MULTIPLE] = MRxSmbLocks;
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_FSCTL]           = MRxSmbFsCtl;
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_IOCTL]           = MRxSmbIoCtl;
    MRxSmbDispatch.MRxLowIOSubmit[LOWIO_OP_NOTIFY_CHANGE_DIRECTORY] = MRxSmbNotifyChangeDirectory;


    // Miscellanous
    MRxSmbDispatch.MRxCompleteBufferingStateChangeRequest = MRxSmbCompleteBufferingStateChangeRequest;

    // initialize the paging file list
    InitializeListHead(&MRxSmbPagingFilesSrvOpenList);

    // now callout to initialize other tables
    SmbPseInitializeTables();

    return(STATUS_SUCCESS);
}

NTSTATUS
MRxSmbStart(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

     This routine completes the initialization of the mini redirector fromn the
     RDBSS perspective. Note that this is different from the initialization done
     in DriverEntry. Any initialization that depends on RDBSS should be done as
     part of this routine while the initialization that is independent of RDBSS
     should be done in the DriverEntry routine.

Arguments:

    RxContext - Supplies the Irp that was used to startup the rdbss

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS      Status;
    MRXSMB_STATE  CurrentState;

    PAGED_CODE();

    CurrentState = (MRXSMB_STATE)
                    InterlockedCompareExchange(
                        (PLONG)&MRxSmbState,
                        MRXSMB_STARTED,
                        MRXSMB_START_IN_PROGRESS);

    if (CurrentState == MRXSMB_START_IN_PROGRESS) {
        MRxSmbPoRegistrationState = PoRegisterSystemState(
                                        NULL,0);

        // Initialize the SMB connection engine data structures
        Status = SmbCeDbInit();

        if (NT_SUCCESS(Status)) {

            Status = MRxSmbInitializeSecurity();

            if (NT_SUCCESS(Status)) {
               Status = SmbMrxInitializeStufferFacilities();
            } else {
                RxLogFailure (
                    MRxSmbDeviceObject,
                    NULL,
                    EVENT_RDR_UNEXPECTED_ERROR,
                    Status);
            }

            if (NT_SUCCESS(Status)) {
               Status = MRxSmbInitializeRecurrentServices();
            } else {
                RxLogFailure (
                    MRxSmbDeviceObject,
                    NULL,
                    EVENT_RDR_UNEXPECTED_ERROR,
                    Status);
            }

            if (NT_SUCCESS(Status)) {
               Status = MRxSmbRegisterForPnpNotifications();
            } else {
                RxLogFailure (
                    MRxSmbDeviceObject,
                    NULL,
                    EVENT_RDR_UNEXPECTED_ERROR,
                    Status);
            }

            if (Status == STATUS_SUCCESS) {
                if (Status != STATUS_SUCCESS) {
                    RxLogFailure (
                        MRxSmbDeviceObject,
                        NULL,
                        EVENT_RDR_UNEXPECTED_ERROR,
                        Status);
                }
            } else {
                RxLogFailure (
                    MRxSmbDeviceObject,
                    NULL,
                    EVENT_RDR_UNEXPECTED_ERROR,
                    Status);
            }
        }
    } else if (MRxSmbState == MRXSMB_STARTED) {
        Status = STATUS_REDIRECTOR_STARTED;
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}


NTSTATUS
MRxSmbStop(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    This routine is used to activate the mini redirector from the RDBSS perspective

Arguments:

    RxContext - the context that was used to start the mini redirector

    pContext  - the SMB mini rdr context passed in at registration time.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    // Tear down the registration for notifications
    MRxSmbDeregisterForPnpNotifications();

    // tear down the recurrent services
    MRxSmbTearDownRecurrentServices();

    SmbMrxFinalizeStufferFacilities();

    MRxSmbUninitializeSecurity();

    // Tear down the connection engine database
    SmbCeDbTearDown();

    PoUnregisterSystemState(
        MRxSmbPoRegistrationState);

    if (s_pNegotiateSmb != NULL) {
       RxFreePool(s_pNegotiateSmb - TRANSPORT_HEADER_SIZE);
       s_pNegotiateSmb = NULL;
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
MRxSmbInitializeSecurity (VOID)
/*++

Routine Description:

    This routine initializes the SMB miniredirector security .

Arguments:

    None.

Return Value:

    None.

Note:

    This API can only be called from a FS process.

--*/
{
   NTSTATUS Status = STATUS_SUCCESS;

   PAGED_CODE();

   if (MRxSmbSecurityInitialized)
       return STATUS_SUCCESS;

   if ( NULL == InitSecurityInterfaceW() ) {
       ASSERT(FALSE);
       Status = STATUS_INVALID_PARAMETER;
   } else {
      MRxSmbSecurityInitialized = TRUE;
      Status = STATUS_SUCCESS;
   }

   ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

   return Status;
}


NTSTATUS
MRxSmbUninitializeSecurity(VOID)
/*++

Routine Description:

Arguments:

    None.

Return Value:

    None.

Note:

    This API can only be called from a FS process.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    return Status;
}


#define SMBMRX_CONFIG_COMPUTER_NAME \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName"

#define COMPUTERNAME L"ComputerName"

#define SMBMRX_CONFIG_TRANSPORTS \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\LanmanWorkStation\\Linkage"

#define TRANSPORT_BINDINGS L"Bind"


NTSTATUS
SmbCeGetConfigurationInformation()
{
   ULONG            Storage[256];
   UNICODE_STRING   UnicodeString;
   HANDLE           hRegistryKey;
   NTSTATUS         Status;
   ULONG            BytesRead;

   OBJECT_ATTRIBUTES ObjectAttributes;
   PKEY_VALUE_FULL_INFORMATION Value = (PKEY_VALUE_FULL_INFORMATION)Storage;
   KEY_VALUE_PARTIAL_INFORMATION InitialPartialInformationValue;
   ULONG AllocationLength;
   PKEY_VALUE_PARTIAL_INFORMATION TransportsValueFromRegistry;

   PAGED_CODE();

   // Obtain the list of transports associated with SMB redirector. This is stored
   // as a multivalued string and is used subsequently to weed out the
   // appropriate transports. This is a two step process; first we try to find out
   // how much space we need; then we allocate; then we read in. unfortunately, the kind of
   // structure that we have to use to get the value has a header on it, so we have to offset the
   // returned pointer both here and in the free routine.

   RtlInitUnicodeString(&UnicodeString, SMBMRX_CONFIG_TRANSPORTS);

   InitializeObjectAttributes(
       &ObjectAttributes,
       &UnicodeString,             // name
       OBJ_CASE_INSENSITIVE,       // attributes
       NULL,                       // root
       NULL);                      // security descriptor

   Status = ZwOpenKey (&hRegistryKey, KEY_READ, &ObjectAttributes);
   if (!NT_SUCCESS(Status)) {
       return Status;
   }

   RtlInitUnicodeString(&UnicodeString, TRANSPORT_BINDINGS);
   Status = ZwQueryValueKey(
               hRegistryKey,
               &UnicodeString,
               KeyValuePartialInformation,
               &InitialPartialInformationValue,
               sizeof(InitialPartialInformationValue),
               &BytesRead);
   if (Status== STATUS_BUFFER_OVERFLOW) {
       Status = STATUS_SUCCESS;
   }

   if (!NT_SUCCESS(Status)) {
       ZwClose(hRegistryKey);
       return Status;
   }

   AllocationLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION)
                                  + InitialPartialInformationValue.DataLength;
   if (0) {
       DbgPrint("SizeofBindingInfo=%08lx %08lx\n",
                      AllocationLength,
                      InitialPartialInformationValue.DataLength);
   }

   //RtlInitUnicodeString(&UnicodeString, TRANSPORT_BINDINGS);

   if (SmbCeContext.Transports.Buffer != NULL) {

       // the transports buffer is at the end of a larger buffer (by 12 bytes)
       // allocated to read the value from the registry. recover the original buffer
       // pointer in orer to free.

       TransportsValueFromRegistry = CONTAINING_RECORD(
                                        SmbCeContext.Transports.Buffer,
                                        KEY_VALUE_PARTIAL_INFORMATION,
                                        Data[0]
                                     );
       //DbgPrint("b1 %08lx b2 %08lx\n", TransportsValueFromRegistry,SmbCeContext.Transports.Buffer);
       RxFreePool(TransportsValueFromRegistry);

       SmbCeContext.Transports.Buffer = NULL;
       SmbCeContext.Transports.Length = 0;
       SmbCeContext.Transports.MaximumLength = 0;
   }

   (PBYTE)TransportsValueFromRegistry = RxAllocatePoolWithTag(
                                             PagedPool,
                                             AllocationLength,
                                             MRXSMB_MISC_POOLTAG);

   if (TransportsValueFromRegistry == NULL) {
       ZwClose(hRegistryKey);
       return(STATUS_INSUFFICIENT_RESOURCES);
   }

   Status = ZwQueryValueKey(
               hRegistryKey,
               &UnicodeString,
               KeyValuePartialInformation,
               TransportsValueFromRegistry,
               AllocationLength,
               &BytesRead);

   if (NT_SUCCESS(Status) &&
       (TransportsValueFromRegistry->DataLength > 0) &&
       (TransportsValueFromRegistry->Type == REG_MULTI_SZ)) {

       SmbCeContext.Transports.MaximumLength =
       SmbCeContext.Transports.Length = (USHORT)TransportsValueFromRegistry->DataLength;
       SmbCeContext.Transports.Buffer = (PWCHAR)(&TransportsValueFromRegistry->Data[0]);
      //DbgPrint("b1 %08lx b2 %08lx\n", TransportsValueFromRegistry,SmbCeContext.Transports.Buffer);
   } else {
      RxLog(("Invalid Transport Binding string... using all transports"));
      RxFreePool(TransportsValueFromRegistry);
      TransportsValueFromRegistry = NULL;
   }

   ZwClose(hRegistryKey);

   return Status;
}


NTSTATUS
SmbCeGetComputerName(
   VOID
   )
{
   ULONG            Storage[256];
   UNICODE_STRING   UnicodeString;
   HANDLE           hRegistryKey;
   NTSTATUS         Status;
   ULONG            BytesRead;

   OBJECT_ATTRIBUTES ObjectAttributes;
   PKEY_VALUE_FULL_INFORMATION Value = (PKEY_VALUE_FULL_INFORMATION)Storage;
   KEY_VALUE_PARTIAL_INFORMATION InitialPartialInformationValue;
   ULONG AllocationLength;

   PAGED_CODE();

   ASSERT(SmbCeContext.ComputerName.Buffer == NULL);

   // Obtain the computer name. This is used in formulating the local NETBIOS address
   RtlInitUnicodeString(&SmbCeContext.ComputerName, NULL);
   RtlInitUnicodeString(&UnicodeString, SMBMRX_CONFIG_COMPUTER_NAME);

   InitializeObjectAttributes(
       &ObjectAttributes,
       &UnicodeString,             // name
       OBJ_CASE_INSENSITIVE,       // attributes
       NULL,                       // root
       NULL);                      // security descriptor

   Status = ZwOpenKey (&hRegistryKey, KEY_READ, &ObjectAttributes);
   if (!NT_SUCCESS(Status)) {
       return Status;
   }

   RtlInitUnicodeString(&UnicodeString, COMPUTERNAME);
   Status = ZwQueryValueKey(
               hRegistryKey,
               &UnicodeString,
               KeyValueFullInformation,
               Value,
               sizeof(Storage),
               &BytesRead);

   if (NT_SUCCESS(Status)) {
      // Rtl conversion routines require NULL char to be excluded from the
      // length.
      SmbCeContext.ComputerName.MaximumLength =
          SmbCeContext.ComputerName.Length = (USHORT)Value->DataLength - sizeof(WCHAR);

      SmbCeContext.ComputerName.Buffer = RxAllocatePoolWithTag(
                                                PagedPool,
                                                SmbCeContext.ComputerName.Length,
                                                MRXSMB_MISC_POOLTAG);

      if (SmbCeContext.ComputerName.Buffer != NULL) {
         RtlCopyMemory(SmbCeContext.ComputerName.Buffer,
                       (PCHAR)Value+Value->DataOffset,
                       Value->DataLength - sizeof(WCHAR));
      } else {
         Status = STATUS_INSUFFICIENT_RESOURCES;
      }
   }

   ZwClose(hRegistryKey);

   return Status;
}

NTSTATUS
SmbCeGetOperatingSystemInformation(
   VOID
   )
{
   ULONG            Storage[256];
   UNICODE_STRING   UnicodeString;
   HANDLE           hRegistryKey;
   NTSTATUS         Status;
   ULONG            BytesRead;

   OBJECT_ATTRIBUTES ObjectAttributes;
   PKEY_VALUE_FULL_INFORMATION Value = (PKEY_VALUE_FULL_INFORMATION)Storage;
   KEY_VALUE_PARTIAL_INFORMATION InitialPartialInformationValue;
   ULONG AllocationLength;

   PAGED_CODE();

   ASSERT(SmbCeContext.OperatingSystem.Buffer == NULL);
   ASSERT(SmbCeContext.LanmanType.Buffer == NULL);

   RtlInitUnicodeString(&UnicodeString, SMBMRX_CONFIG_CURRENT_WINDOWS_VERSION);

   InitializeObjectAttributes(
       &ObjectAttributes,
       &UnicodeString,             // name
       OBJ_CASE_INSENSITIVE,       // attributes
       NULL,                       // root
       NULL);                      // security descriptor

   Status = ZwOpenKey (&hRegistryKey, KEY_READ, &ObjectAttributes);

   if (!NT_SUCCESS(Status)) {
       return Status;
   }

   RtlInitUnicodeString(&UnicodeString, SMBMRX_CONFIG_OPERATING_SYSTEM);
   Status = ZwQueryValueKey(
               hRegistryKey,
               &UnicodeString,
               KeyValueFullInformation,
               Value,
               sizeof(Storage),
               &BytesRead);

   if (NT_SUCCESS(Status)) {
      SmbCeContext.OperatingSystem.MaximumLength =
          (USHORT)Value->DataLength + sizeof(SMBMRX_CONFIG_OPERATING_SYSTEM_NAME) - sizeof(WCHAR);

      SmbCeContext.OperatingSystem.Length = SmbCeContext.OperatingSystem.MaximumLength - sizeof(WCHAR);

      SmbCeContext.OperatingSystem.Buffer = RxAllocatePoolWithTag(
                                                 PagedPool,
                                                 SmbCeContext.OperatingSystem.MaximumLength,
                                                 MRXSMB_MISC_POOLTAG);

      if (SmbCeContext.OperatingSystem.Buffer != NULL) {
         RtlCopyMemory(SmbCeContext.OperatingSystem.Buffer,
                       SMBMRX_CONFIG_OPERATING_SYSTEM_NAME,
                       sizeof(SMBMRX_CONFIG_OPERATING_SYSTEM_NAME));

         RtlCopyMemory((SmbCeContext.OperatingSystem.Buffer +
                        (sizeof(SMBMRX_CONFIG_OPERATING_SYSTEM_NAME)/sizeof(WCHAR)) - 1),
                       (PCHAR)Value+Value->DataOffset,
                       Value->DataLength);
      } else {
         Status = STATUS_INSUFFICIENT_RESOURCES;
      }
   }

   if (NT_SUCCESS(Status)) {
      RtlInitUnicodeString(&UnicodeString, SMBMRX_CONFIG_OPERATING_SYSTEM_VERSION);
      Status = ZwQueryValueKey(
                     hRegistryKey,
                     &UnicodeString,
                     KeyValueFullInformation,
                     Value,
                     sizeof(Storage),
                     &BytesRead);

      if (NT_SUCCESS(Status)) {
         SmbCeContext.LanmanType.MaximumLength =
             SmbCeContext.LanmanType.Length = (USHORT)Value->DataLength +
                                    sizeof(SMBMRX_CONFIG_OPERATING_SYSTEM_NAME) -
                                    sizeof(WCHAR);

         SmbCeContext.LanmanType.Buffer = RxAllocatePoolWithTag(
                                             PagedPool,
                                             SmbCeContext.LanmanType.Length,
                                             MRXSMB_MISC_POOLTAG);
         if (SmbCeContext.LanmanType.Buffer != NULL) {
            RtlCopyMemory(
                  SmbCeContext.LanmanType.Buffer,
                  SMBMRX_CONFIG_OPERATING_SYSTEM_NAME,
                  sizeof(SMBMRX_CONFIG_OPERATING_SYSTEM_NAME));

            RtlCopyMemory(
                  (SmbCeContext.LanmanType.Buffer +
                   (sizeof(SMBMRX_CONFIG_OPERATING_SYSTEM_NAME)/sizeof(WCHAR)) - 1),
                  (PCHAR)Value+Value->DataOffset,
                  Value->DataLength);
         } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
         }
      }
   }

   ZwClose(hRegistryKey);

   return Status;
}

NTSTATUS
MRxSmbPnpIrpCompletion(
    PDEVICE_OBJECT pDeviceObject,
    PIRP           pIrp,
    PVOID          pContext)
/*++

Routine Description:

    This routine completes the PNP irp for SMB mini redirector.

Arguments:

    DeviceObject - Supplies the device object for the packet being processed.

    pIrp - Supplies the Irp being processed

    pContext - the completion context

--*/
{
    PKEVENT pCompletionEvent = pContext;

    KeSetEvent(
        pCompletionEvent,
        IO_NO_INCREMENT,
        FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
MRxSmbProcessPnpIrp(
    PIRP pIrp)
/*++

Routine Description:

    This routine initiates the processing of PNP irps for SMB mini redirector.

Arguments:

    pIrp - Supplies the Irp being processed

Notes:

    The query target device relation is the only call that is implemented
    currently. This is done by returing the PDO associated with the transport
    connection object. In any case this routine assumes the responsibility of
    completing the IRP and return STATUS_PENDING.

    This routine also writes an error log entry when the underlying transport
    fails the request. This should help us isolate the responsibility.

--*/
{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( pIrp );

    IoMarkIrpPending(pIrp);

    if ((IrpSp->MinorFunction == IRP_MN_QUERY_DEVICE_RELATIONS)  &&
        (IrpSp->Parameters.QueryDeviceRelations.Type==TargetDeviceRelation)) {
        PIRP         pAssociatedIrp;
        PFILE_OBJECT pConnectionFileObject = NULL;
        PMRX_FCB     pFcb = NULL;

        PSMBCEDB_SERVER_ENTRY pServerEntry = NULL;
        BOOLEAN       ServerTransportReferenced = FALSE;

        // Locate the transport connection object for the associated file object
        // and forward the query to that device.

        if ((IrpSp->FileObject != NULL) &&
            ((pFcb = IrpSp->FileObject->FsContext) != NULL) &&
            (NodeTypeIsFcb(pFcb))) {
            PMRX_SRV_CALL pSrvCall;
            PMRX_NET_ROOT pNetRoot;

            if (((pNetRoot = pFcb->pNetRoot) != NULL) &&
                ((pSrvCall = pNetRoot->pSrvCall) != NULL)) {
                pServerEntry = pSrvCall->Context;

                if (pServerEntry != NULL) {
                    SmbCeAcquireResource();

                    Status = SmbCeReferenceServerTransport(&pServerEntry->pTransport);

                    if (Status == STATUS_SUCCESS) {
                        pConnectionFileObject = SmbCepReferenceEndpointFileObject(
                                                    pServerEntry->pTransport);

                        ServerTransportReferenced = TRUE;
                    }

                    SmbCeReleaseResource();
                }
            }
        }

        if (pConnectionFileObject != NULL) {
            PDEVICE_OBJECT                     pRelatedDeviceObject;
            PIO_STACK_LOCATION                 pIrpStackLocation,
                                               pAssociatedIrpStackLocation;

            pRelatedDeviceObject = IoGetRelatedDeviceObject(pConnectionFileObject);

            pAssociatedIrp = IoAllocateIrp(
                                 pRelatedDeviceObject->StackSize,
                                 FALSE);

            if (pAssociatedIrp != NULL) {
                KEVENT CompletionEvent;

                KeInitializeEvent( &CompletionEvent,
                                   SynchronizationEvent,
                                   FALSE );

                // Fill up the associated IRP and call the underlying driver.
                pAssociatedIrpStackLocation = IoGetNextIrpStackLocation(pAssociatedIrp);
                pIrpStackLocation           = IoGetCurrentIrpStackLocation(pIrp);

                *pAssociatedIrpStackLocation = *pIrpStackLocation;

                pAssociatedIrpStackLocation->FileObject = pConnectionFileObject;
                pAssociatedIrpStackLocation->DeviceObject = pRelatedDeviceObject;

                IoSetCompletionRoutine(
                    pAssociatedIrp,
                    MRxSmbPnpIrpCompletion,
                    &CompletionEvent,
                    TRUE,TRUE,TRUE);

                pAssociatedIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

                Status = IoCallDriver(pRelatedDeviceObject,pAssociatedIrp);

                if (Status == STATUS_PENDING) {
                    (VOID) KeWaitForSingleObject(
                               &CompletionEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               (PLARGE_INTEGER) NULL );
                }

                pIrp->IoStatus = pAssociatedIrp->IoStatus;
                Status = pIrp->IoStatus.Status;

                ObDereferenceObject(pConnectionFileObject);

                IoFreeIrp(pAssociatedIrp);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            Status = STATUS_INVALID_DEVICE_REQUEST;
        }

        if (ServerTransportReferenced) {
            SmbCeDereferenceServerTransport(&pServerEntry->pTransport);
        }
    } else {
        Status = STATUS_INVALID_DEVICE_REQUEST;
    }

    if (Status != STATUS_PENDING) {
        pIrp->IoStatus.Status = Status;
        IoCompleteRequest(pIrp,IO_NO_INCREMENT);
        Status = STATUS_PENDING;
    }

    return STATUS_PENDING;
}

NTSTATUS
MRxSmbFsdDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine implements the FSD dispatch for the smbmini DRIVER object.

Arguments:

    DeviceObject - Supplies the device object for the packet being processed.

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The Fsd status for the Irp

--*/
{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );  //ok4ioget
    UCHAR  MajorFunctionCode = IrpSp->MajorFunction;
    ULONG  MinorFunctionCode = IrpSp->MinorFunction;

    BOOLEAN ForwardRequestToWrapper = TRUE;

    PSMBCEDB_SERVER_ENTRY pServerEntry = NULL;
    NTSTATUS Status;

    PAGED_CODE();

    ASSERT(DeviceObject==(PDEVICE_OBJECT)MRxSmbDeviceObject);
    if (DeviceObject!=(PDEVICE_OBJECT)MRxSmbDeviceObject) {
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT );
        return (STATUS_INVALID_DEVICE_REQUEST);
    }

    Status = STATUS_SUCCESS;

    FsRtlEnterFileSystem();

    // PnP IRPs are handled outside of the wrapper
    if (IrpSp->MajorFunction == IRP_MJ_PNP) {
        ForwardRequestToWrapper = FALSE;
        Status = MRxSmbProcessPnpIrp(Irp);
    }

    FsRtlExitFileSystem();

    if ((Status == STATUS_SUCCESS) &&
        ForwardRequestToWrapper){
        Status = RxFsdDispatch((PRDBSS_DEVICE_OBJECT)MRxSmbDeviceObject,Irp);
    } else if (Status != STATUS_PENDING) {
        Irp->IoStatus.Status = Status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT );
    }

    if (pServerEntry != NULL ) {
        FsRtlEnterFileSystem();

        pServerEntry->TransportSpecifiedByUser = 0;
        SmbCeDereferenceServerEntry(pServerEntry);

        FsRtlExitFileSystem();
    }

    return Status;
}

NTSTATUS
MRxSmbDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    )
{
    PAGED_CODE();

    return(STATUS_SUCCESS);
}

NTSTATUS
MRxSmbDeallocateForFobx (
    IN OUT PMRX_FOBX pFobx
    )
{

    PAGED_CODE();

    IF_DEBUG {
        PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(pFobx);
        PMRX_SRV_OPEN SrvOpen = pFobx->pSrvOpen;
        PMRX_FCB Fcb = SrvOpen->pFcb;

        if (smbFobx && FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_LOUD_FINALIZE)) {
            DbgPrint("Finalizobx side buffer %p %p %p %pon %wZ\n",
                     0, 0, // sidebuffer, count
                     smbFobx,pFobx,GET_ALREADY_PREFIXED_NAME(SrvOpen,Fcb)
                     );
        }
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
MRxSmbGetUlongRegistryParameter(
    HANDLE ParametersHandle,
    PWCHAR ParameterName,
    PULONG ParamUlong,
    BOOLEAN LogFailure
    )
{
    ULONG Storage[16];
    PKEY_VALUE_PARTIAL_INFORMATION Value;
    ULONG ValueSize;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG BytesRead;

    PAGED_CODE(); //INIT

    Value = (PKEY_VALUE_PARTIAL_INFORMATION)Storage;
    ValueSize = sizeof(Storage);

    RtlInitUnicodeString(&UnicodeString, ParameterName);

    Status = ZwQueryValueKey(ParametersHandle,
                        &UnicodeString,
                        KeyValuePartialInformation,
                        Value,
                        ValueSize,
                        &BytesRead);


    if (NT_SUCCESS(Status)) {
        if (Value->Type == REG_DWORD) {
            PULONG ConfigValue = (PULONG)&Value->Data[0];
            *ParamUlong = *((PULONG)ConfigValue);
            return(STATUS_SUCCESS);
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
     }

     if (!LogFailure) { return Status; }

     RxLogFailureWithBuffer(
         MRxSmbDeviceObject,
         NULL,
         EVENT_RDR_CANT_READ_REGISTRY,
         Status,
         ParameterName,
         (USHORT)(wcslen(ParameterName)*sizeof(WCHAR))
         );

     return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\midatlas.c ===
/*++
Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    midatlas.c

Abstract:

    This module defines the data structure used in mapping MIDS to the
    corresponding requests/contexts associated with them.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, _InitializeMidMapFreeList)
#pragma alloc_text(PAGE, FsRtlCreateMidAtlas)
#pragma alloc_text(PAGE, _UninitializeMidMap)
#pragma alloc_text(PAGE, FsRtlDestroyMidAtlas)
#endif

#define ENTRY_TYPE_FREE_MID_LIST  (0x1)
#define ENTRY_TYPE_VALID_CONTEXT  (0x2)
#define ENTRY_TYPE_MID_MAP        (0x3)

#define ENTRY_TYPE_MASK           (0x3)

#define MID_MAP_FLAGS_CAN_BE_EXPANDED (0x1)
#define MID_MAP_FLAGS_FREE_POOL       (0x2)

typedef struct _MID_MAP_ {
   LIST_ENTRY  MidMapList;             // the list of MID maps in the MID atlas
   USHORT      MaximumNumberOfMids;    // the maximum number of MIDs in this map
   USHORT      NumberOfMidsInUse;      // the number of MIDs in use
   USHORT      BaseMid;                // the base MID associated with the map
   USHORT      IndexMask;              // the index mask for this map
   UCHAR       IndexAlignmentCount;    // the bits by which the index field is to be shifted
   UCHAR       IndexFieldWidth;        // the index field width
   UCHAR       Flags;                  // flags ...
   UCHAR       Level;                  // the level associated with this map ( useful for expansion )
   PVOID       *pFreeMidListHead;      // the list of free mid entries in this map
   PVOID       Entries[1];             // the MID map entries.
} MID_MAP, *PMID_MAP;


//INLINE ULONG _GetEntryType(PVOID pEntry)

#define _GetEntryType(pEntry)                               \
        ((ULONG)((ULONG_PTR)pEntry) & ENTRY_TYPE_MASK)

//INLINE PVOID _GetEntryPointer(PVOID pEntry)

#define _GetEntryPointer(pEntry)                            \
        ((PVOID)((ULONG_PTR)pEntry & ~ENTRY_TYPE_MASK))

#define _MakeEntry(pContext,EntryType)                      \
        (PVOID)((ULONG_PTR)(pContext) | (EntryType))

//INLINE PMID_MAP _GetFirstMidMap()
/*++

Routine Description:

    This first MID_MAP instance in the list

Return Value:

    a valid PMID_MAP, NULL if none exists.

Notes:

    This routine assumes that the necessary concurrency control action has been taken

--*/

#define _GetFirstMidMap(pListHead)                        \
               (IsListEmpty(pListHead)                    \
                ? NULL                                    \
                : (PMID_MAP)                              \
                  (CONTAINING_RECORD((pListHead)->Flink,  \
                                     MID_MAP,             \
                                     MidMapList)))

//INLINE PSMBCEDB_SERVER_ENTRY GetNextMidMap(PLIST_ENTRY pListHead, PMID_MAP pMidMap)
/*++

Routine Description:

    This routine returns the next MID_MAP in the list

Arguments:

    pListHead    - the list of MID_MAP's

    pMidMap      - the current instance

Return Value:

    a valid PMID_MAP, NULL if none exists.

Notes:

    This routine assumes that the necessary concurrency control action has been taken

--*/

#define _GetNextMidMap(pListHead,pMidMap)                      \
           (((pMidMap)->MidMapList.Flink == pListHead)         \
            ? NULL                                             \
            : (PMID_MAP)                                       \
              (CONTAINING_RECORD((pMidMap)->MidMapList.Flink,  \
                                 MID_MAP,                      \
                                 MidMapList)))


//INLINE VOID _AddMidMap(
//            PLIST_ENTRY pListHead,
//            PMID_MAP    pMidMap)
/*++

Routine Description:

    This routine adds a MID_MAP instance to a list

Arguments:

    pListHead  - the list of MID_MAP's

    pMidMap    - the MID_MAP to be added

--*/

#define _AddMidMap(pListHead,pMidMap)                                       \
        {                                                                   \
           PMID_MAP pPredecessor;                                           \
           pPredecessor = _GetFirstMidMap(pListHead);                       \
           while (pPredecessor != NULL) {                                   \
              if (pPredecessor->Level < pMidMap->Level) {                   \
                 pPredecessor = _GetNextMidMap(pListHead,pPredecessor);     \
              } else {                                                      \
                 pPredecessor = (PMID_MAP)                                  \
                                CONTAINING_RECORD(                          \
                                     pPredecessor->MidMapList.Blink,        \
                                     MID_MAP,                               \
                                     MidMapList);                           \
                 break;                                                     \
              }                                                             \
           }                                                                \
                                                                            \
           if (pPredecessor == NULL) {                                      \
              InsertTailList(pListHead,&((pMidMap)->MidMapList));         \
           } else {                                                         \
              (pMidMap)->MidMapList.Flink = pPredecessor->MidMapList.Flink; \
              pPredecessor->MidMapList.Flink = &(pMidMap)->MidMapList;      \
                                                                            \
              (pMidMap)->MidMapList.Blink = &pPredecessor->MidMapList;      \
              (pMidMap)->MidMapList.Flink->Blink = &(pMidMap)->MidMapList;  \
           }                                                                \
        }


//INLINE VOID _RemoveMidMap(PMID_MAP pMidMap)
/*++

Routine Description:

    This routine removes a MID_MAP instance from the list

Arguments:

    pMidMap - the MID_MAP instance to be removed

--*/

#define _RemoveMidMap(pMidMap)   \
            RemoveEntryList(&(pMidMap)->MidMapList)



VOID
_InitializeMidMapFreeList(PMID_MAP pMidMap)
/*++

Routine Description:

   This routine initializes a MID_MAP data structure.

Arguments:

    pMidMap  - the MID_MAP instance to be initialized.

Notes:

--*/
{
   USHORT i;

   PVOID  *pEntryValue     = (PVOID *)&pMidMap->Entries[1];
   PVOID  *pEntriesPointer = (PVOID *)&pMidMap->Entries;

   PAGED_CODE();

   //DbgPrint("_InitializeMidMapFreeList .. Entry\n");

   if (pMidMap->MaximumNumberOfMids > 0) {
       pMidMap->pFreeMidListHead = pMidMap->Entries;
       for (i = 1; i <= pMidMap->MaximumNumberOfMids - 1;i++,pEntryValue++) {
          *pEntriesPointer++ = _MakeEntry(pEntryValue,ENTRY_TYPE_FREE_MID_LIST);
       }

       *pEntriesPointer = _MakeEntry(NULL,ENTRY_TYPE_FREE_MID_LIST);
   }

   //DbgPrint("_InitializeMidMapFreeList .. Exit\n");
}


PMID_ATLAS
FsRtlCreateMidAtlas(
   USHORT MaximumNumberOfMids,
   USHORT MidsAllocatedAtStart)
/*++

Routine Description:

   This routine allocates a new instance of MID_ATLAS data structure.

Arguments:

    MaximumNumberOfMids  - the maximum number of MIDS in the atlas.

    MidsAllocatedAtStart - the number of MIDS allocated at start

Notes:

--*/
{
    PMID_ATLAS pMidAtlas;
    PMID_MAP   pMidMap;
    ULONG      AtlasSize;
    USHORT     MidsAllocatedRoundedToPowerOf2;
    USHORT     MaximumMidsRoundedToPowerOf2;
    UCHAR      MidFieldWidth,MaximumMidFieldWidth;

    PAGED_CODE();

    // Round off the Mids allocated at Start to a power of two
    MaximumMidsRoundedToPowerOf2 = 0x100;
    MaximumMidFieldWidth = 8;

    if (MaximumMidsRoundedToPowerOf2 != MaximumNumberOfMids) {
        if (MaximumNumberOfMids > MaximumMidsRoundedToPowerOf2) {
            while (MaximumNumberOfMids > MaximumMidsRoundedToPowerOf2) {
                MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 << 1;
                MaximumMidFieldWidth++;
            }
        } else {
            while (MaximumNumberOfMids < MaximumMidsRoundedToPowerOf2) {
                MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 >> 1;
                MaximumMidFieldWidth--;
            }

            MaximumMidFieldWidth++;
            MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 << 1;
        }
    }

    MidsAllocatedRoundedToPowerOf2 = 0x100;
    MidFieldWidth = 8;

    if (MidsAllocatedRoundedToPowerOf2 != MidsAllocatedAtStart) {
        if (MidsAllocatedAtStart > MidsAllocatedRoundedToPowerOf2) {
            while (MidsAllocatedAtStart > MidsAllocatedRoundedToPowerOf2) {
                MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 << 1;
                MidFieldWidth++;
            }
        } else {
            while (MidsAllocatedAtStart < MidsAllocatedRoundedToPowerOf2) {
                MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 >> 1;
                MidFieldWidth--;
            }

            MidFieldWidth++;
            MidsAllocatedRoundedToPowerOf2 = MidsAllocatedRoundedToPowerOf2 << 1;
        }
    }

    AtlasSize = sizeof(MID_ATLAS) +
                FIELD_OFFSET(MID_MAP,Entries);

    if (MaximumNumberOfMids == MidsAllocatedAtStart) {
        AtlasSize += (sizeof(PVOID) * MidsAllocatedAtStart);
    } else {
        AtlasSize += (sizeof(PVOID) * MidsAllocatedRoundedToPowerOf2);
    }

    pMidAtlas = (PMID_ATLAS)RxAllocatePoolWithTag(
                              NonPagedPool,
                              AtlasSize,
                              MRXSMB_MIDATLAS_POOLTAG);
    if (pMidAtlas != NULL) {
        pMidMap = (PMID_MAP)(pMidAtlas + 1);

        pMidMap->Flags                 = 0;
        pMidAtlas->MaximumNumberOfMids = MaximumNumberOfMids;
        pMidAtlas->MidsAllocated       = MidsAllocatedAtStart;
        pMidAtlas->NumberOfMidsInUse = 0;
        pMidAtlas->NumberOfMidsDiscarded = 0;
        pMidAtlas->MaximumMidFieldWidth = MaximumMidFieldWidth;

        pMidMap->MaximumNumberOfMids = MidsAllocatedAtStart;
        pMidMap->NumberOfMidsInUse   = 0;
        pMidMap->BaseMid             = 0;
        pMidMap->IndexMask           = MidsAllocatedRoundedToPowerOf2 - 1;
        pMidMap->IndexAlignmentCount = 0;
        pMidMap->IndexFieldWidth     = MidFieldWidth;
        pMidMap->Level               = 1;

        InitializeListHead(&pMidAtlas->MidMapFreeList);
        InitializeListHead(&pMidAtlas->MidMapExpansionList);
        _InitializeMidMapFreeList(pMidMap);

        _AddMidMap(&pMidAtlas->MidMapFreeList,pMidMap);
        pMidAtlas->pRootMidMap = pMidMap;

        if (MaximumNumberOfMids > MidsAllocatedAtStart) {
            // Round off the maximum number of MIDS to determine the level and the
            // size of the quantum ( allocation increments)

            pMidMap->Flags |= MID_MAP_FLAGS_CAN_BE_EXPANDED;

            pMidAtlas->MidQuantum           = 32;
            pMidAtlas->MidQuantumFieldWidth = 5;
            MaximumMidsRoundedToPowerOf2 = MaximumMidsRoundedToPowerOf2 >> (pMidMap->IndexAlignmentCount + 5);

            if (MaximumMidsRoundedToPowerOf2 > 0) {
                pMidAtlas->NumberOfLevels = 3;
            } else {
                pMidAtlas->NumberOfLevels = 2;
            }
        } else {
            pMidAtlas->MidQuantum     = 0;
            pMidAtlas->NumberOfLevels = 1;
            pMidMap->Flags &= ~MID_MAP_FLAGS_CAN_BE_EXPANDED;
        }
    }

    //DbgPrint("FsRtlAllocatMidAtlas .. Exit (pMidAtlas) %lx\n",pMidAtlas);
    return pMidAtlas;
}

VOID
_UninitializeMidMap(
         PMID_MAP            pMidMap,
         PCONTEXT_DESTRUCTOR pContextDestructor)
/*++

Routine Description:

   This routine uninitializes a MID_MAP data structure.

Arguments:

    pMidMap            -- the MID_MAP instance to be uninitialized.

    pContextDestructor -- the context destructor
Notes:

--*/
{
   USHORT i;
   ULONG  EntryType;

   PAGED_CODE();

   //DbgPrint("_UninitializeMidMap .. Entry No.Of MIDS in Use %ld\n",pMidMap->NumberOfMidsInUse);
   RxLog(("_UninitMidMap .. num= %ld\n",pMidMap->NumberOfMidsInUse));

   for (i = 0; i < pMidMap->MaximumNumberOfMids; i++) {
      PMID_MAP pChildMidMap;

      EntryType = _GetEntryType(pMidMap->Entries[i]);
      switch (EntryType) {
      case ENTRY_TYPE_MID_MAP :
         {
            pChildMidMap = (PMID_MAP)_GetEntryPointer(pMidMap->Entries[i]);
            _UninitializeMidMap(pChildMidMap,pContextDestructor);
         }
         break;
      case ENTRY_TYPE_VALID_CONTEXT :
         {
            if (pContextDestructor != NULL) {
               PVOID pContext;

               pContext = _GetEntryPointer(pMidMap->Entries[i]);

               (pContextDestructor)(pContext);
            }
         }
         break;
      default:
         break;
      }
   }

   if (pMidMap->Flags & MID_MAP_FLAGS_FREE_POOL) {
      RxFreePool(pMidMap);
   }

   //DbgPrint("_UninitializeMidMap .. Exit\n");
}

VOID
FsRtlDestroyMidAtlas(
   PMID_ATLAS          pMidAtlas,
   PCONTEXT_DESTRUCTOR pContextDestructor)
/*++

Routine Description:

   This routine frees a MID_ATLAS instance. As a side effect it invokes the
   passed in context destructor on every valid context in the MID_ATLAS

Arguments:

    pMidAtlas           - the MID_ATLAS instance to be freed.

    PCONTEXT_DESTRUCTOR - the associated context destructor

Notes:

--*/
{
   PAGED_CODE();

   //DbgPrint("FsRtlFreeMidAtlas .. Entry\n");
   _UninitializeMidMap(pMidAtlas->pRootMidMap,pContextDestructor);

   RxFreePool(pMidAtlas);
   //DbgPrint("FsRtlFreeMidAtlas .. Exit\n");
}

PVOID
FsRtlMapMidToContext(
      PMID_ATLAS pMidAtlas,
      USHORT     Mid)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
    ULONG     EntryType;
    PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
    PVOID     pContext;
    ULONG     Index;

    //DbgPrint("FsRtlMapMidToContext Mid %lx ",Mid);

    for (;;) {
        Index =  (Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount;

        if (Index >= pMidMap->MaximumNumberOfMids) {
            pContext = NULL;
            break;
        }

        pContext = pMidMap->Entries[Index];
        EntryType = _GetEntryType(pContext);
        pContext = (PVOID)_GetEntryPointer(pContext);

        if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
            break;
        } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
            pContext = NULL;
            break;
        } else if (EntryType == ENTRY_TYPE_MID_MAP) {
            pMidMap = (PMID_MAP)pContext;
        } else {
            pContext = NULL;
            break;
        }
    }

    //DbgPrint("Context %lx \n",pContext);

    return pContext;
}

NTSTATUS
FsRtlMapAndDissociateMidFromContext(
      PMID_ATLAS pMidAtlas,
      USHORT     Mid,
      PVOID      *pContextPointer)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;
   PVOID     *pEntry;

   //DbgPrint("FsRtlMapAndDissociateMidFromContext Mid %lx ",Mid);

   for (;;) {
      pEntry    = &pMidMap->Entries[
                    (Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount];
      pContext  = *pEntry;
      EntryType = _GetEntryType(pContext);
      pContext  = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         pMidMap->NumberOfMidsInUse--;

         if (pMidMap->pFreeMidListHead == NULL) {
            if (pMidMap->Flags & MID_MAP_FLAGS_CAN_BE_EXPANDED) {
               _RemoveMidMap(pMidMap);
            }

            _AddMidMap(&pMidAtlas->MidMapFreeList,pMidMap);
         }

         *pEntry = _MakeEntry(pMidMap->pFreeMidListHead,ENTRY_TYPE_FREE_MID_LIST);
         pMidMap->pFreeMidListHead = pEntry;

         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         pContext = NULL;
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      }
   }

   pMidAtlas->NumberOfMidsInUse--;
   //DbgPrint("Context %lx\n",pContext);
   *pContextPointer = pContext;
   return STATUS_SUCCESS;
}

NTSTATUS
FsRtlReassociateMid(
      PMID_ATLAS pMidAtlas,
      USHORT     Mid,
      PVOID      pNewContext)
/*++

Routine Description:

   This routine maps a MID to its associated context in a MID_ATLAS.

Arguments:

    pMidAtlas  - the MID_ATLAS instance.

    Mid        - the MId to be mapped

    pNewContext - the new context

Return value:

    the associated context, NULL if none exists

Notes:

--*/
{
   ULONG     EntryType;
   PMID_MAP  pMidMap = pMidAtlas->pRootMidMap;
   PVOID     pContext;

   //DbgPrint("FsRtlReassociateMid Mid %lx ",Mid);

   for (;;) {
      pContext = pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount];
      EntryType = _GetEntryType(pContext);
      pContext = (PVOID)_GetEntryPointer(pContext);

      if (EntryType == ENTRY_TYPE_VALID_CONTEXT) {
         pMidMap->Entries[(Mid & pMidMap->IndexMask) >> pMidMap->IndexAlignmentCount]
               = _MakeEntry(pNewContext,ENTRY_TYPE_VALID_CONTEXT);
         break;
      } else if (EntryType == ENTRY_TYPE_FREE_MID_LIST) {
         ASSERT(!"Valid MID Atlas");
         break;
      } else if (EntryType == ENTRY_TYPE_MID_MAP) {
         pMidMap = (PMID_MAP)pContext;
      }
   }

   //DbgPrint("New COntext  %lx\n",pNewContext);

   return STATUS_SUCCESS;
}

NTSTATUS
FsRtlAssociateContextWithMid(
      PMID_ATLAS     pMidAtlas,
      PVOID          pContext,
      PUSHORT        pNewMid)
/*++

Routine Description:

   This routine initializes a MID_MAP data structure.

Arguments:

    pMidMap  - the MID_MAP instance to be initialized.

Return Value:

    STATUS_SUCCESS if successful, otherwise one of the following errors

         STATUS_INSUFFICIENT_RESOURCES
         STATUS_UNSUCCESSFUL  -- no mid could be associated

Notes:

--*/
{
   NTSTATUS Status;
   PMID_MAP pMidMap;
   PVOID    *pContextPointer;

   //DbgPrint("FsRtlAssociateContextWithMid Context %lx ",pContext);

   // Scan the list of MID_MAP's which have free entries in them.
   if ((pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapFreeList)) != NULL) {
      ASSERT(pMidMap->pFreeMidListHead != _MakeEntry(NULL,ENTRY_TYPE_FREE_MID_LIST));

      pMidMap->NumberOfMidsInUse++;
      pContextPointer           = pMidMap->pFreeMidListHead;
      pMidMap->pFreeMidListHead = _GetEntryPointer(*(pMidMap->pFreeMidListHead));
      *pContextPointer          = _MakeEntry(pContext,ENTRY_TYPE_VALID_CONTEXT);
      *pNewMid                  = ((USHORT)
                                   (pContextPointer - (PVOID *)&pMidMap->Entries)
                                   << pMidMap->IndexAlignmentCount) |
                                  pMidMap->BaseMid;

      // Check if the MID_MAP needs to be removed from the list of MID_MAP's with
      // free entries
      if (pMidMap->pFreeMidListHead ==  NULL) {
         _RemoveMidMap(pMidMap);

         // Check if it can be added to the expansion list.
         if (pMidAtlas->NumberOfLevels > pMidMap->Level) {
            _AddMidMap(&pMidAtlas->MidMapExpansionList,pMidMap);
         }
      }

      Status = STATUS_SUCCESS;
   } else if ((pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapExpansionList)) != NULL) {
      PMID_MAP pNewMidMap;

      USHORT   i;
      ULONG    NewMidMapSize;

      // Locate the index in the mid map for the new mid map
      pMidMap = _GetFirstMidMap(&pMidAtlas->MidMapExpansionList);
      while (pMidMap != NULL) {
         for (i = 0; i < pMidMap->MaximumNumberOfMids; i++) {
            if (_GetEntryType(pMidMap->Entries[i]) != ENTRY_TYPE_MID_MAP) {
               break;
            }
         }

         if (i < pMidMap->MaximumNumberOfMids) {
            break;
         } else {
            pMidMap->Flags &= ~MID_MAP_FLAGS_CAN_BE_EXPANDED;
            _RemoveMidMap(pMidMap);
            pMidMap = _GetNextMidMap(&pMidAtlas->MidMapExpansionList,pMidMap);
         }
      }

      if (pMidMap != NULL) {
         USHORT NumberOfEntriesInMap = pMidAtlas->MaximumNumberOfMids -
                                       pMidAtlas->NumberOfMidsInUse;

         if (NumberOfEntriesInMap > pMidAtlas->MidQuantum) {
            NumberOfEntriesInMap = pMidAtlas->MidQuantum;
         }

         if (NumberOfEntriesInMap > 0) {
             NewMidMapSize = FIELD_OFFSET(MID_MAP,Entries) +
                             NumberOfEntriesInMap * sizeof(PVOID);
             pNewMidMap = (PMID_MAP)RxAllocatePoolWithTag(
                                        NonPagedPool,
                                        NewMidMapSize,
                                        MRXSMB_MIDATLAS_POOLTAG);

             if (pNewMidMap != NULL) {
                pNewMidMap->Flags = MID_MAP_FLAGS_FREE_POOL;
                pNewMidMap->MaximumNumberOfMids = NumberOfEntriesInMap;
                pNewMidMap->NumberOfMidsInUse   = 0;
                pNewMidMap->BaseMid             = (pMidMap->BaseMid |
                                                   i << pMidMap->IndexAlignmentCount);

                pNewMidMap->IndexAlignmentCount = pMidMap->IndexAlignmentCount +
                                                  pMidMap->IndexFieldWidth;

                pNewMidMap->IndexMask           = (pMidAtlas->MidQuantum - 1) << pNewMidMap->IndexAlignmentCount;
                pNewMidMap->IndexFieldWidth     = pMidAtlas->MidQuantumFieldWidth;

                _InitializeMidMapFreeList(pNewMidMap);

                // Set up the mid map appropriately.
                pNewMidMap->NumberOfMidsInUse = 1;
                pNewMidMap->Entries[0] = pMidMap->Entries[i];
                pNewMidMap->Level      = pMidMap->Level + 1;

                pNewMidMap->pFreeMidListHead = *(pNewMidMap->pFreeMidListHead);
                pMidMap->Entries[i] = _MakeEntry(pNewMidMap,ENTRY_TYPE_MID_MAP);

                // Update the free list and the expansion list respectively.
                _AddMidMap(&pMidAtlas->MidMapFreeList,pNewMidMap);

                pNewMidMap->NumberOfMidsInUse++;
                pContextPointer     = pNewMidMap->pFreeMidListHead;
                pNewMidMap->pFreeMidListHead = _GetEntryPointer(*(pNewMidMap->pFreeMidListHead));
                *pContextPointer    = _MakeEntry(pContext,ENTRY_TYPE_VALID_CONTEXT);
                *pNewMid            = (USHORT)
                                      (((ULONG)(pContextPointer -
                                       (PVOID *)&pNewMidMap->Entries) / sizeof(PVOID))
                                       << pNewMidMap->IndexAlignmentCount) |
                                      pNewMidMap->BaseMid;

                Status = STATUS_SUCCESS;
             } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
             }
         } else {
             Status = STATUS_UNSUCCESSFUL;
         }
      } else {
         Status = STATUS_UNSUCCESSFUL;
      }
   } else {
      Status = STATUS_UNSUCCESSFUL;
   }

   if (Status == STATUS_SUCCESS) {
      pMidAtlas->NumberOfMidsInUse++;
   }

   //DbgPrint("Mid %lx\n",*pNewMid);

   return Status;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\midatlas.h ===
/*++
Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    midatlas.h

Abstract:

    This module defines the data structure used in mapping MIDS to the corresponding requests/
    contexts associated with them.

Notes:

   MID (Multiplex ID) is used at both the server and the client ( redirector ) to distinguish
   between the concurrently active requests on any connection. This data structure has been
   designed to meet the following criterion.

   1) It should scale well to handle the differing capabilities of a server, e.g., the typical
   NT server permits 50 outstanding requests on any connection. The CORE level servers can go as
   low as one and on Gateway machines the desired number can be very high ( in the oreder of thousands)

   2) The two primary operations that need to be handled well are
      i) mapping a MID to the context associated with it.
         -- This routine will be invoked to process every packet received along any connection
         at both the server and the client.
      ii) generating a new MID for sending requests to the server.
         -- This will be used at the client both for max. command enforcement as well as
         tagging each concurrent request with a unique id.

    The most common case is that of a connection between a NT client and a NT server. All
    design decisions have been made in order to ensure that the solutions are optimal
    for this case.

    The MID data structure must be efficiently able to manage the unique tagging and identification
    of a number of mids ( typically 50 ) from a possible combination of 65536 values. In order to
    ensure a proper time space tradeoff the lookup is organized as a three level hierarchy.

    The 16 bits used to represent a MID  are split upinto three bit fields. The length of the
    rightmost field ( least signifiant ) is decided by the number of mids that are to be
    allocated on creation. The remaining length is split up equally between the next two
    fields, e.g., if 50 mids are to be allocated on creation , the length of the first field
    is 6 ( 64 ( 2 ** 6 ) is greater than 50 ), 5 and 5.

--*/

#ifndef _MIDATLAS_H_
#define _MIDATLAS_H_

typedef struct _MID_ATLAS_ {
   USHORT      MaximumNumberOfMids;
   USHORT      MidsAllocated;
   USHORT      NumberOfMidsInUse;
   USHORT      NumberOfMidsDiscarded;
   USHORT      MaximumMidFieldWidth;
   USHORT      Reserved;
   USHORT      MidQuantum;
   UCHAR       MidQuantumFieldWidth;
   UCHAR       NumberOfLevels;
   LIST_ENTRY  MidMapFreeList;
   LIST_ENTRY  MidMapExpansionList;
   struct _MID_MAP_ *pRootMidMap;
} MID_ATLAS, *PMID_ATLAS;

typedef
VOID (*PCONTEXT_DESTRUCTOR)(
      PVOID pContext);

#define FsRtlGetMaximumNumberOfMids(pMidAtlas) \
        ((pMidAtlas)->MaximumNumberOfMids)

#define FsRtlGetNumberOfMidsInUse(pMidAtlas) \
        ((pMidAtlas)->NumberOfMidsInUse)

extern PMID_ATLAS
FsRtlCreateMidAtlas(
         USHORT MaximumNumberOfEntries,
         USHORT InitialAllocation);

extern VOID
FsRtlDestroyMidAtlas(
         PMID_ATLAS pMidAtlas,
         PCONTEXT_DESTRUCTOR pContextDestructor);

extern PVOID
FsRtlMapMidToContext(
         PMID_ATLAS pMidAtlas,
         USHORT     Mid);

extern NTSTATUS
FsRtlAssociateContextWithMid(
         PMID_ATLAS pMidAtlas,
         PVOID      pContext,
         PUSHORT    pNewMid);

extern NTSTATUS
FsRtlMapAndDissociateMidFromContext(
         PMID_ATLAS pMidAtlas,
         USHORT Mid,
         PVOID *pContextPointer);

extern NTSTATUS
FsRtlReassociateMid(
         PMID_ATLAS pMidAtlas,
         USHORT     Mid,
         PVOID      pNewContext);

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\mm.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    mm.c

Abstract:

    This module implements the memory managment routines for the SMB mini
    redirector

Notes:

    The SMB mini redirector manipulates entities which have very different usage
    patterns. They range from very static entities ( which are allocated and freed
    with a very low frequency ) to very dynamic entities.

    The entities manipulated in the SMB mini redirector are SMBCE_SERVER, SMBCE_NET_ROOT,
    SMBCE_VC, SMBCE_SESSION. These represent a connection to a server, a share on
    a particular server, a virtual circuit used in the connection and a session
    for a particular user.

    These are not very dynamic, i.e., the allocation/deallocation is very infrequent.
    The SMB_EXCHANGE and SMBCE_REQUEST map to the SMB's that are sent along that
    a connection. Every file operation in turn maps to a certain number of calls
    for allocationg/freeing exchanges and requests. Therefore it is imperative
    that some form of scavenging/caching of recently freed entries be maintained
    to satisfy requests quickly.

    In the current implementation the exchanges and requests are implemented
    using the zone allocation primitives.

    The exchange allocation and free routines are currently implemented as wrappers
    around the RxAllocate and RxFree routines. It would be far more efficient if
    a look aside cache of some exchange instances are maintained.

--*/

#include "precomp.h"
#pragma hdrstop

#include <vcsndrcv.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbMmAllocateSessionEntry)
#pragma alloc_text(PAGE, SmbMmFreeSessionEntry)
#pragma alloc_text(PAGE, SmbMmAllocateServerTransport)
#pragma alloc_text(PAGE, SmbMmFreeServerTransport)
#pragma alloc_text(PAGE, SmbMmInit)
#pragma alloc_text(PAGE, SmbMmTearDown)
#endif

#define SMBMM_ZONE_ALLOCATION 0x10

// The memory management package addresses a number of concerns w.r.t debugging
// and performance. By centralizing all the allocation/deallocation routines to
// thsi one module it is possible to build up profiles regarding various data
// structures used by the connection engine. In addition debugging support is
// provided by thereading together all allocated objects of a particular type
// are threaded together in a linked list according to type.
//
// At any stage by inspecting these lists the currently active instances of a
// particular type can be enumerated.
//
// Each type handled by this module is provided with two routines, e.g., for
// server entries there are SmbMmInitializeEntry and SmbMmUninitializeEntry. The
// first routine is called before handing over a pointer of a newly created
// instance. This will ensure that the instance is in a wll known initial state.
// Similarly the second routine is called just before deallocating the pool
// associated with the instance. This helps enforce the necessary integrity
// constraints, e.g., all enclosed pointers must be NULL etc.
//
// The pool allocation/deallocation is handled by the following routines
//
//    SmbMmAllocateObjectPool/SmbMmFreeObjectPool
//
//    SmbMmAllocateExchange/SmbMmFreeExchange
//
// The Object allocation routines are split up into two parts so as to be able to
// handle the session allocationson par with other objects even though they are
// further subtyped.
//
// On debug builds additional pool is allocated and the appropriate linking is
// done into the corresponding list. On retail builds these map to the regular
// pool allocation wrappers.
//

// Zone allocation to speed up memory management of RxCe entities.
//

ULONG       SmbMmRequestZoneEntrySize;
ZONE_HEADER SmbMmRequestZone;
PVOID       SmbMmRequestZoneSegmentPtr;

//
// Pool allocation resources and spin locks
//

KSPIN_LOCK  SmbMmSpinLock;

ULONG SmbMmExchangeId;

//
// List of the various objects/exchanges allocated.
//

LIST_ENTRY SmbMmExchangesInUse[SENTINEL_EXCHANGE];
LIST_ENTRY SmbMmObjectsInUse[SMBCEDB_OT_SENTINEL];

ULONG  ObjectSizeInBytes[SMBCEDB_OT_SENTINEL];
ULONG  ExchangeSizeInBytes[SENTINEL_EXCHANGE];

//
// Lookaside lists for Exchange allocation
//

NPAGED_LOOKASIDE_LIST SmbMmExchangesLookasideList[SENTINEL_EXCHANGE];

INLINE PSMBCE_OBJECT_HEADER
SmbMmAllocateObjectPool(
    SMBCEDB_OBJECT_TYPE  ObjectType,
    ULONG                PoolType,
    ULONG                PoolSize)
{
    KIRQL SavedIrql;
    PVOID pv = NULL;
    UCHAR Flags = 0;

    PSMBCE_OBJECT_HEADER pHeader = NULL;

    ASSERT((ObjectType >= 0) && (ObjectType < SMBCEDB_OT_SENTINEL));

    if (ObjectType == SMBCEDB_OT_REQUEST) {
        // Acquire the resource lock.
        KeAcquireSpinLock( &SmbMmSpinLock, &SavedIrql );

        if (!ExIsFullZone( &SmbMmRequestZone )) {
            pv = ExAllocateFromZone( &SmbMmRequestZone );
            Flags = SMBMM_ZONE_ALLOCATION;
        }

        // Release the resource lock.
        KeReleaseSpinLock( &SmbMmSpinLock, SavedIrql );
    }

    if (pv == NULL) {
        PLIST_ENTRY pListEntry;

        pv = RxAllocatePoolWithTag(
                 PoolType,
                 PoolSize + sizeof(LIST_ENTRY),
                 MRXSMB_MM_POOLTAG);

        if (pv != NULL) {
            pListEntry = (PLIST_ENTRY)pv;
            pHeader    = (PSMBCE_OBJECT_HEADER)(pListEntry + 1);

            ExInterlockedInsertTailList(
                &SmbMmObjectsInUse[ObjectType],
                pListEntry,
                &SmbMmSpinLock);
        }
    } else {
        pHeader = (PSMBCE_OBJECT_HEADER)pv;
    }

    if (pHeader != NULL) {
        // Zero the memory.
        RtlZeroMemory( pHeader, PoolSize);

        pHeader->Flags = Flags;
    }

    return pHeader;
}

INLINE VOID
SmbMmFreeObjectPool(
    PSMBCE_OBJECT_HEADER  pHeader)
{
    KIRQL               SavedIrql;
    BOOLEAN             ZoneAllocation = FALSE;
    PLIST_ENTRY         pListEntry;

    ASSERT((pHeader->ObjectType >= 0) && (pHeader->ObjectType < SMBCEDB_OT_SENTINEL));

    // Acquire the resource lock.
    KeAcquireSpinLock( &SmbMmSpinLock, &SavedIrql );

    // Check if it was a zone allocation
    if (pHeader->Flags & SMBMM_ZONE_ALLOCATION) {
        ZoneAllocation = TRUE;
        ExFreeToZone(&SmbMmRequestZone,pHeader);
    } else {
        pListEntry = (PLIST_ENTRY)((PCHAR)pHeader - sizeof(LIST_ENTRY));
        RemoveEntryList(pListEntry);
    }

    // Release the resource lock.
    KeReleaseSpinLock( &SmbMmSpinLock, SavedIrql );

    if (!ZoneAllocation) {
        RxFreePool(pListEntry);
    }
}

// Construction and destruction of various SMB connection engine objects
//

#define SmbMmInitializeServerEntry(pServerEntry)                                \
         InitializeListHead(&(pServerEntry)->OutstandingRequests.ListHead);   \
         InitializeListHead(&(pServerEntry)->MidAssignmentRequests.ListHead); \
         InitializeListHead(&(pServerEntry)->Sessions.ListHead);              \
         InitializeListHead(&(pServerEntry)->NetRoots.ListHead);              \
         InitializeListHead(&(pServerEntry)->VNetRootContexts.ListHead);      \
         InitializeListHead(&(pServerEntry)->ActiveExchanges);                \
         InitializeListHead(&(pServerEntry)->ExpiredExchanges);                \
         InitializeListHead(&(pServerEntry)->Sessions.DefaultSessionList);     \
         (pServerEntry)->pTransport                = NULL;                      \
         (pServerEntry)->pMidAtlas                 = NULL

#define SmbMmInitializeSessionEntry(pSessionEntry)  \
         InitializeListHead(&(pSessionEntry)->Requests.ListHead); \
         InitializeListHead(&(pSessionEntry)->SerializationList); \
         (pSessionEntry)->DefaultSessionLink.Flink = NULL;        \
         (pSessionEntry)->DefaultSessionLink.Blink = NULL

#define SmbMmInitializeNetRootEntry(pNetRootEntry)  \
         InitializeListHead(&(pNetRootEntry)->Requests.ListHead)

#define SmbMmUninitializeServerEntry(pServerEntry)                                 \
         ASSERT(IsListEmpty(&(pServerEntry)->OutstandingRequests.ListHead) &&   \
                IsListEmpty(&(pServerEntry)->MidAssignmentRequests.ListHead) && \
                IsListEmpty(&(pServerEntry)->Sessions.ListHead) &&              \
                IsListEmpty(&(pServerEntry)->NetRoots.ListHead) &&              \
                ((pServerEntry)->pMidAtlas == NULL))

#define SmbMmUninitializeSessionEntry(pSessionEntry)  \
         ASSERT(IsListEmpty(&(pSessionEntry)->Requests.ListHead) && \
                ((pSessionEntry)->DefaultSessionLink.Flink == NULL))

#define SmbMmUninitializeNetRootEntry(pNetRootEntry)  \
         ASSERT(IsListEmpty(&(pNetRootEntry)->Requests.ListHead))

#define SmbMmInitializeRequestEntry(pRequestEntry)

#define SmbMmUninitializeRequestEntry(pRequestEntry)

PVOID
SmbMmAllocateObject(
    SMBCEDB_OBJECT_TYPE ObjectType)
{
    PSMBCE_OBJECT_HEADER pHeader;

    ASSERT((ObjectType >= 0) && (ObjectType < SMBCEDB_OT_SENTINEL));

    pHeader = SmbMmAllocateObjectPool(
                  ObjectType,
                  NonPagedPool,
                  ObjectSizeInBytes[ObjectType]);

    if (pHeader != NULL) {
        pHeader->NodeType = SMB_CONNECTION_ENGINE_NTC(ObjectType);
        pHeader->State = SMBCEDB_START_CONSTRUCTION;

        switch (ObjectType) {
        case SMBCEDB_OT_SERVER :
            SmbMmInitializeServerEntry((PSMBCEDB_SERVER_ENTRY)pHeader);
            break;

        case SMBCEDB_OT_NETROOT :
            SmbMmInitializeNetRootEntry((PSMBCEDB_NET_ROOT_ENTRY)pHeader);
            break;

        case SMBCEDB_OT_REQUEST :
            SmbMmInitializeRequestEntry((PSMBCEDB_REQUEST_ENTRY)pHeader);
            break;

        default:
            ASSERT(!"Valid Type for SmbMmAllocateObject");
            break;
        }
    }

    return pHeader;
}

VOID
SmbMmFreeObject(
    PVOID pv)
{
    PSMBCE_OBJECT_HEADER pHeader = (PSMBCE_OBJECT_HEADER)pv;

    switch (pHeader->ObjectType) {
    case SMBCEDB_OT_SERVER :
        SmbMmUninitializeServerEntry((PSMBCEDB_SERVER_ENTRY)pHeader);
        break;

    case SMBCEDB_OT_NETROOT :
        SmbMmUninitializeNetRootEntry((PSMBCEDB_NET_ROOT_ENTRY)pHeader);
        break;

    case SMBCEDB_OT_REQUEST :
        SmbMmUninitializeRequestEntry((PSMBCEDB_REQUEST_ENTRY)pHeader);
        break;

    default:
        ASSERT(!"Valid Type for SmbMmFreeObject");
        break;
    }

    SmbMmFreeObjectPool(pHeader);
}

PSMBCEDB_SESSION_ENTRY
SmbMmAllocateSessionEntry(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
{
    PSMBCEDB_SESSION_ENTRY pSessionEntry;
    SESSION_TYPE           SessionType;
    ULONG                  SessionSize;

    PAGED_CODE();

    SessionSize = sizeof(SMBCEDB_SESSION_ENTRY);
    SessionType = LANMAN_SESSION;

    pSessionEntry = (PSMBCEDB_SESSION_ENTRY)
                    SmbMmAllocateObjectPool(
                        SMBCEDB_OT_SESSION,
                        NonPagedPool,
                        SessionSize);

    if (pSessionEntry != NULL) {
        pSessionEntry->Header.NodeType = SMB_CONNECTION_ENGINE_NTC(SMBCEDB_OT_SESSION);
        pSessionEntry->Header.State = SMBCEDB_START_CONSTRUCTION;
        pSessionEntry->Session.Type = SessionType;

        SmbMmInitializeSessionEntry(pSessionEntry);

        pSessionEntry->Session.CredentialHandle.dwUpper = 0xffffffff;
        pSessionEntry->Session.CredentialHandle.dwLower = 0xffffffff;
        pSessionEntry->Session.SecurityContextHandle.dwUpper = 0xffffffff;
        pSessionEntry->Session.SecurityContextHandle.dwLower = 0xffffffff;
    }

    return pSessionEntry;
}

VOID
SmbMmFreeSessionEntry(
    PSMBCEDB_SESSION_ENTRY pSessionEntry)
{
    PAGED_CODE();

    SmbMmUninitializeSessionEntry(pSessionEntry);

    SmbMmFreeObjectPool(&pSessionEntry->Header);
}


PVOID
SmbMmAllocateExchange(
    SMB_EXCHANGE_TYPE ExchangeType,
    PVOID pv)
{
    KIRQL               SavedIrql;
    ULONG               SizeInBytes;
    USHORT              Flags = 0;
    PSMB_EXCHANGE       pExchange = NULL;
    PLIST_ENTRY         pListEntry;

    ASSERT((ExchangeType >= 0) && (ExchangeType < SENTINEL_EXCHANGE));

    if (pv==NULL) {
        pv = ExAllocateFromNPagedLookasideList(
                 &SmbMmExchangesLookasideList[ExchangeType]);
    } else {
        Flags |= SMBCE_EXCHANGE_NOT_FROM_POOL;
    }

    if (pv != NULL) {
        // Initialize the object header
        pExchange   = (PSMB_EXCHANGE)(pv);

        // Zero the memory.
        RtlZeroMemory(
            pExchange,
            ExchangeSizeInBytes[ExchangeType]);

        pExchange->NodeTypeCode = SMB_EXCHANGE_NTC(ExchangeType);
        pExchange->NodeByteSize = (USHORT)ExchangeSizeInBytes[ExchangeType];

        pExchange->SmbCeState = SMBCE_EXCHANGE_INITIALIZATION_START;
        pExchange->SmbCeFlags = Flags;

        InitializeListHead(&pExchange->ExchangeList);

        switch (pExchange->Type) {
        case CONSTRUCT_NETROOT_EXCHANGE:
            pExchange->pDispatchVector = &ConstructNetRootExchangeDispatch;
            break;

        case TRANSACT_EXCHANGE :
            pExchange->pDispatchVector = &TransactExchangeDispatch;
            break;

        case ADMIN_EXCHANGE:
            pExchange->pDispatchVector = &AdminExchangeDispatch;
            break;
        }

        // Acquire the resource lock.
        KeAcquireSpinLock( &SmbMmSpinLock, &SavedIrql );

        InsertTailList(
            &SmbMmExchangesInUse[pExchange->Type],
            &pExchange->SmbMmInUseListEntry);

        pExchange->Id = SmbMmExchangeId++;

        // Release the resource lock.
        KeReleaseSpinLock( &SmbMmSpinLock, SavedIrql );
    }

    return pExchange;
}

VOID
SmbMmFreeExchange(
    PSMB_EXCHANGE pExchange)
{
    if (pExchange != NULL) {
        SMB_EXCHANGE_TYPE ExchangeType;

        KIRQL       SavedIrql;

        ExchangeType = pExchange->Type;

        ASSERT((ExchangeType >= 0) && (ExchangeType < SENTINEL_EXCHANGE));

        // Acquire the resource lock.
        KeAcquireSpinLock( &SmbMmSpinLock, &SavedIrql );

        RemoveEntryList(&pExchange->SmbMmInUseListEntry);

        // Release the resource lock.
        KeReleaseSpinLock( &SmbMmSpinLock, SavedIrql );

        if (!FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_NOT_FROM_POOL)) {
            ExFreeToNPagedLookasideList(
                &SmbMmExchangesLookasideList[ExchangeType],
                pExchange);
        }
    }
}

PVOID
SmbMmAllocateServerTransport(
    SMBCE_SERVER_TRANSPORT_TYPE ServerTransportType)
{
    PSMBCE_OBJECT_HEADER pHeader;

    ULONG AllocationSize;
    ULONG PoolTag;

    PAGED_CODE();

    switch (ServerTransportType) {
    case SMBCE_STT_VC:
        AllocationSize = sizeof(SMBCE_SERVER_VC_TRANSPORT);
        PoolTag = MRXSMB_VC_POOLTAG;
        break;

    default:
        ASSERT(!"Valid Server Transport Type");
        return NULL;
    }

    pHeader = (PSMBCE_OBJECT_HEADER)
              RxAllocatePoolWithTag(
                  NonPagedPool,
                  AllocationSize,
                  PoolTag);

    if (pHeader != NULL) {
        PSMBCE_SERVER_TRANSPORT pServerTransport;

        RtlZeroMemory(pHeader,AllocationSize);

        pHeader->ObjectCategory = SMB_SERVER_TRANSPORT_CATEGORY;
        pHeader->ObjectType     = (UCHAR)ServerTransportType;
        pHeader->SwizzleCount   = 0;
        pHeader->State          = 0;
        pHeader->Flags          = 0;

        pServerTransport = (PSMBCE_SERVER_TRANSPORT)pHeader;

        pServerTransport->pRundownEvent = NULL;

        switch (ServerTransportType) {
        case SMBCE_STT_VC:
            {
                PSMBCE_SERVER_VC_TRANSPORT pVcTransport;

                pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pHeader;
            }
            break;

        default:
            break;
        }
    }

    return pHeader;
}

VOID
SmbMmFreeServerTransport(
    PSMBCE_SERVER_TRANSPORT pServerTransport)
{
    PAGED_CODE();

    ASSERT((pServerTransport->SwizzleCount == 0) &&
           (pServerTransport->ObjectCategory == SMB_SERVER_TRANSPORT_CATEGORY));

    RxFreePool(pServerTransport);
}

NTSTATUS SmbMmInit()
/*++

Routine Description:

    This routine initialises the connection engine structures for memory management

Return Value:

    STATUS_SUCCESS if successful, otherwise an informative error code.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ZoneSegmentSize;

    PAGED_CODE();

    // Initialize the resource lock for the zone allocator.
    KeInitializeSpinLock( &SmbMmSpinLock );

    SmbMmRequestZoneEntrySize = QuadAlign(sizeof(SMBCEDB_REQUEST_ENTRY));

    // Currently the request zone size is restricted to that of a page. This can and should
    // be fine tuned.
    ZoneSegmentSize = PAGE_SIZE;

    SmbMmRequestZoneSegmentPtr = RxAllocatePoolWithTag(
                                     NonPagedPool,
                                     ZoneSegmentSize,
                                     MRXSMB_MM_POOLTAG);

    if (SmbMmRequestZoneSegmentPtr != NULL) {
        SMB_EXCHANGE_TYPE ExchangeType;

        ExInitializeZone(
            &SmbMmRequestZone,
            SmbMmRequestZoneEntrySize,
            SmbMmRequestZoneSegmentPtr,
            ZoneSegmentSize );

        // set up the sizes for allocation.
        ObjectSizeInBytes[SMBCEDB_OT_SERVER] = sizeof(SMBCEDB_SERVER_ENTRY);
        ObjectSizeInBytes[SMBCEDB_OT_NETROOT] = sizeof(SMBCEDB_NET_ROOT_ENTRY);
        ObjectSizeInBytes[SMBCEDB_OT_SESSION] = sizeof(SMBCEDB_SESSION_ENTRY);
        ObjectSizeInBytes[SMBCEDB_OT_REQUEST] = sizeof(SMBCEDB_REQUEST_ENTRY);

        ExchangeSizeInBytes[CONSTRUCT_NETROOT_EXCHANGE] = sizeof(SMB_CONSTRUCT_NETROOT_EXCHANGE);
        ExchangeSizeInBytes[TRANSACT_EXCHANGE]          = sizeof(SMB_TRANSACT_EXCHANGE);
        ExchangeSizeInBytes[ORDINARY_EXCHANGE]          = sizeof(SMB_PSE_ORDINARY_EXCHANGE);
        ExchangeSizeInBytes[ADMIN_EXCHANGE]             = sizeof(SMB_ADMIN_EXCHANGE);

        InitializeListHead(&SmbMmExchangesInUse[CONSTRUCT_NETROOT_EXCHANGE]);
        ExInitializeNPagedLookasideList(
            &SmbMmExchangesLookasideList[CONSTRUCT_NETROOT_EXCHANGE],
            ExAllocatePoolWithTag,
            ExFreePool,
            0,
            sizeof(SMB_CONSTRUCT_NETROOT_EXCHANGE),
            MRXSMB_MM_POOLTAG,
            1);

        InitializeListHead(&SmbMmExchangesInUse[TRANSACT_EXCHANGE]);
        ExInitializeNPagedLookasideList(
            &SmbMmExchangesLookasideList[TRANSACT_EXCHANGE],
            ExAllocatePoolWithTag,
            ExFreePool,
            0,
            sizeof(SMB_TRANSACT_EXCHANGE),
            MRXSMB_MM_POOLTAG,
            2);

        InitializeListHead(&SmbMmExchangesInUse[ORDINARY_EXCHANGE]);
        ExInitializeNPagedLookasideList(
            &SmbMmExchangesLookasideList[ORDINARY_EXCHANGE],
            ExAllocatePoolWithTag,
            ExFreePool,
            0,
            sizeof(SMB_PSE_ORDINARY_EXCHANGE),
            MRXSMB_MM_POOLTAG,
            4);

        InitializeListHead(&SmbMmExchangesInUse[ADMIN_EXCHANGE]);
        ExInitializeNPagedLookasideList(
            &SmbMmExchangesLookasideList[ADMIN_EXCHANGE],
            ExAllocatePoolWithTag,
            ExFreePool,
            0,
            sizeof(SMB_ADMIN_EXCHANGE),
            MRXSMB_MM_POOLTAG,
            1);

        InitializeListHead(&SmbMmObjectsInUse[SMBCEDB_OT_SERVER]);
        InitializeListHead(&SmbMmObjectsInUse[SMBCEDB_OT_SESSION]);
        InitializeListHead(&SmbMmObjectsInUse[SMBCEDB_OT_NETROOT]);
        InitializeListHead(&SmbMmObjectsInUse[SMBCEDB_OT_REQUEST]);

        SmbMmExchangeId = 1;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

VOID SmbMmTearDown()
/*++

Routine Description:

    This routine tears down the memory management structures in the SMB connection
    engine

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    // free the segment associated with RxCe object allocation.
    RxFreePool(SmbMmRequestZoneSegmentPtr);

    ExDeleteNPagedLookasideList(
        &SmbMmExchangesLookasideList[CONSTRUCT_NETROOT_EXCHANGE]);

    ExDeleteNPagedLookasideList(
        &SmbMmExchangesLookasideList[TRANSACT_EXCHANGE]);

    ExDeleteNPagedLookasideList(
        &SmbMmExchangesLookasideList[ORDINARY_EXCHANGE]);

    ExDeleteNPagedLookasideList(
        &SmbMmExchangesLookasideList[ADMIN_EXCHANGE]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\fsctl.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    fsctl.c

Abstract:

    This module implements the mini redirector call down routines pertaining to
    file system control(FSCTL) and Io Device Control (IOCTL) operations on file
    system objects.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbFsCtl)
#pragma alloc_text(PAGE, MRxSmbNotifyChangeDirectory)
#pragma alloc_text(PAGE, MRxSmbIoCtl)
#endif

//
//  The local debug trace level
//


RXDT_DefineCategory(FSCTRL);
#define Dbg (DEBUG_TRACE_FSCTRL)

NTSTATUS
MRxSmbCoreIoCtl(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE);


NTSTATUS
MRxSmbFsCtl(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs an FSCTL operation (remote) on a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The FSCTL's handled by a mini rdr can be classified into one of two categories.
    In the first category are those FSCTL's whose implementation are shared between
    RDBSS and the mini rdr's and in the second category are those FSCTL's which
    are totally implemented by the mini rdr's. To this a third category can be
    added, i.e., those FSCTL's which should never be seen by the mini rdr's. The
    third category is solely intended as a debugging aid.

    The FSCTL's handled by a mini rdr can be classified based on functionality

--*/
{
    RxCaptureFobx;
    RxCaptureFcb;

    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;
    ULONG          FsControlCode = pLowIoContext->ParamsFor.FsCtl.FsControlCode;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFsCtl...\n", 0));
    RxDbgTrace( 0, Dbg, ("MRxSmbFsCtl = %08lx\n", FsControlCode));
    RxDbgTrace(-1, Dbg, ("MRxSmbFsCtl -> %08lx\n", Status ));

    return Status;
}


NTSTATUS
MRxSmbNotifyChangeDirectory(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs a directory change notification operation

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    A directory change notification opertaion is an asychronous operation. It
    consists of sending a SMB requesting change notification whose response is
    obtained when the desired change is affected on the server.

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    RxDbgTrace(+1, Dbg, ("MRxNotifyChangeDirectory...Entry\n", 0));

    RxDbgTrace(-1, Dbg, ("MRxSmbNotifyChangeDirectory -> %08lx\n", Status ));

    return Status;
}



NTSTATUS
MRxSmbIoCtl(
      IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine performs an IOCTL operation. Currently, no calls are remoted; in
   fact, the only call accepted is for debugging.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;
    ULONG          IoControlCode = pLowIoContext->ParamsFor.IoCtl.IoControlCode;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbIoCtl...\n", 0));
    RxDbgTrace( 0, Dbg, ("MRxSmbIoCtl IOCTL: = %08lx\n", IoControlCode));
    RxDbgTrace(-1, Dbg, ("MRxSmbIoCtl Status -> %08lx\n", Status ));

    return Status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\mrxprocs.h ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    mrxprocs.h

Abstract:

    The global include file for SMB mini redirector

--*/

#ifndef _MRXPROCS_H_
#define _MRXPROCS_H_


#define INCLUDE_SMB_ALL

#include "cifs.h"       // contains all things SMB

#include "mrxglbl.h"    // global data declarations/defines etc.
#include "smbpoolt.h"   // Pool tag definitions


// If Count is not already aligned, then
// round Count up to an even multiple of "Pow2".  "Pow2" must be a power of 2.
//
// DWORD
// ROUND_UP_COUNT(
//     IN DWORD Count,
//     IN DWORD Pow2
//     );
#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~(((LONG)(Pow2))-1)) )

// LPVOID
// ROUND_UP_POINTER(
//     IN LPVOID Ptr,
//     IN DWORD Pow2
//     );

// If Ptr is not already aligned, then round it up until it is.
#define ROUND_UP_POINTER(Ptr,Pow2) \
        ( (LPVOID) ( (((ULONG_PTR)(Ptr))+(Pow2)-1) & (~(((LONG)(Pow2))-1)) ) )


#define SMBMRX_CONFIG_CURRENT_WINDOWS_VERSION \
    L"\\REGISTRY\\Machine\\Software\\Microsoft\\Windows Nt\\CurrentVersion"
#define SMBMRX_CONFIG_OPERATING_SYSTEM \
    L"CurrentBuildNumber"
#define SMBMRX_CONFIG_OPERATING_SYSTEM_VERSION \
    L"CurrentVersion"
#define SMBMRX_CONFIG_OPERATING_SYSTEM_NAME \
    L"Windows 2000 "
#define SMBMRX_MINIRDR_PARAMETERS \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\SmbMRx\\Parameters"
#define EVENTLOG_MRXSMB_PARAMETERS \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\EventLog\\System\\SmbMRx"

//mini's does use these
#undef RxCaptureRequestPacket
#undef RxCaptureParamBlock

//
// A pointer to an instance of MRX_SMB_FCB is stored in the context field of
// MRX_FCBs handled by the SMB mini rdr.
//

typedef struct _MRX_SMB_FCB_ {
    //M for Minirdr
    ULONG   MFlags;
    USHORT  WriteOnlySrvOpenCount;

    SMB_TREE_ID Tid;
    USHORT      LastOplockLevel;

    ULONG           dwFileAttributes;

    LARGE_INTEGER   ExpireTime; // It's time for get attributs from server

} MRX_SMB_FCB, *PMRX_SMB_FCB;

#define AttributesSyncInterval 10  // Number of seconds before local file attributes expired

#define MRxSmbGetFcbExtension(pFcb)      \
        (((pFcb) == NULL) ? NULL : (PMRX_SMB_FCB)((pFcb)->Context))

#define SMB_FCB_FLAG_SENT_DISPOSITION_INFO      0x00000001
#define SMB_FCB_FLAG_WRITES_PERFORMED           0x00000002
#define SMB_FCB_FLAG_LONG_FILE_NAME             0x00000004

typedef struct _SMBPSE_FILEINFO_BUNDLE {
    FILE_BASIC_INFORMATION Basic;
    FILE_STANDARD_INFORMATION Standard;
} SMBPSE_FILEINFO_BUNDLE, *PSMBPSE_FILEINFO_BUNDLE;

typedef struct _MRXSMB_CREATE_PARAMETERS {
    ULONG Pid;
    UCHAR SecurityFlags;
} MRXSMB_CREATE_PARAMETERS, *PMRXSMB_CREATE_PARAMETERS;

typedef struct _MRX_SMB_DEFERRED_OPEN_CONTEXT {
    NT_CREATE_PARAMETERS     NtCreateParameters; // a copy of the createparameters
    ULONG                    RxContextFlags;
    MRXSMB_CREATE_PARAMETERS SmbCp;
    USHORT                   RxContextCreateFlags;
} MRX_SMB_DEFERRED_OPEN_CONTEXT, *PMRX_SMB_DEFERRED_OPEN_CONTEXT;

//
// A pointer to an instance of MRX_SMB_SRV_OPEN is stored in the context fields
// of MRX_SRV_OPEN handled by the SMB mini rdr. This encapsulates the FID used
// to identify open files/directories in the SMB protocol.

typedef struct _MRX_SMB_SRV_OPEN_ {
    ULONG       Flags;
    ULONG       Version;
    SMB_FILE_ID Fid;
    UCHAR       OplockLevel;

    ACCESS_MASK MaximalAccessRights;
    ACCESS_MASK GuestMaximalAccessRights;

    PMRX_SMB_DEFERRED_OPEN_CONTEXT DeferredOpenContext;

    // the following fields are used for to save the results of a GetFileAttributes
    // and to validate whether the fields should be reused or not

    ULONG                  RxContextSerialNumber;
    LARGE_INTEGER          TimeStampInTicks;
    SMBPSE_FILEINFO_BUNDLE FileInfo;

    BOOLEAN                NumOfSrvOpenAdded;    // debug only

    BOOLEAN                DeferredOpenInProgress;
    LIST_ENTRY             DeferredOpenSyncContexts;
    
    USHORT                 FileStatusFlags;
    BOOLEAN                IsNtCreate;
} MRX_SMB_SRV_OPEN, *PMRX_SMB_SRV_OPEN;

typedef struct _DEFERRED_OPEN_SYNC_CONTEXT_ {
    LIST_ENTRY  ListHead;
    PRX_CONTEXT RxContext;
    NTSTATUS    Status;
} DEFERRED_OPEN_SYNC_CONTEXT, *PDEFERRED_OPEN_SYNC_CONTEXT;

typedef struct _PAGING_FILE_CONTEXT_ {
    PMRX_SRV_OPEN pSrvOpen;
    PMRX_FOBX     pFobx;

    // The following LIST_ENTRY is used for two purposes.
    // while a reconnect is not in progress it is threaded together to maintain
    // a list of all SRV_OPEN instances corresponding to paging files. Note
    // that this is not done for non paging files.
    // When a reconnect is in progress the field is used to ensure that
    // there is atmost one reconnect request in progress for any given SRV_OPEN
    // instance at the server
    // All manipulation of this list is done while owning the SmbCeSpinLock,

    LIST_ENTRY    ContextList;
} PAGING_FILE_CONTEXT, *PPAGING_FILE_CONTEXT;

#define SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN       0x00000001
#define SMB_SRVOPEN_FLAG_SUCCESSFUL_OPEN       0x00000002
#define SMB_SRVOPEN_FLAG_CANT_GETATTRIBS       0x00000004
#define SMB_SRVOPEN_FLAG_DEFERRED_OPEN         0x00000008
#define SMB_SRVOPEN_FLAG_WRITE_ONLY_HANDLE     0x00000010
#define SMB_SRVOPEN_FLAG_FILE_DELETED          0x00000100
#define SMB_SRVOPEN_FLAG_LOCAL_OPEN            0x00000200

#define MRxSmbGetSrvOpenExtension(pSrvOpen)  \
        (((pSrvOpen) == NULL) ? NULL : (PMRX_SMB_SRV_OPEN)((pSrvOpen)->Context))

typedef USHORT SMB_SEARCH_HANDLE;

typedef struct _MRX_SMB_DIRECTORY_RESUME_INFO {
   REQ_FIND_NEXT2 FindNext2_Request;
   //now we have to include space for a resume name........
   WCHAR NameSpace[MAXIMUM_FILENAME_LENGTH+1]; //trailing null
   USHORT ParametersLength;
} MRX_SMB_DIRECTORY_RESUME_INFO, *PMRX_SMB_DIRECTORY_RESUME_INFO;

// A pointer to an instance of MRX_SMB_FOBX is stored in the context field
// of MRX_FOBXs handled by the SMB mini rdr. Depending upon the file type
// i.e., file or directory the appropriate context information is stored.

typedef struct _MRX_SMB_FOBX_ {
   union {
       struct {
           struct {
               SMB_SEARCH_HANDLE SearchHandle;
               ULONG Version;
               union {
                   //the close code will try to free this!
                   PMRX_SMB_DIRECTORY_RESUME_INFO ResumeInfo;
                   PSMB_RESUME_KEY CoreResumeKey;
               };
               struct {
                   //unaligned direntry sidebuffering params
                   PBYTE UnalignedDirEntrySideBuffer;    //close will try to free this too
                   ULONG SerialNumber;
                   BOOLEAN EndOfSearchReached;
                   BOOLEAN IsUnicode;
                   BOOLEAN IsNonNtT2Find;
                   ULONG   FilesReturned;
                   ULONG EntryOffset;
                   ULONG TotalDataBytesReturned;
                   //ULONG ReturnedEntryOffset;
               };
           };
           NTSTATUS ErrorStatus;
           USHORT Flags;
           USHORT FileNameOffset;
           USHORT FileNameLengthOffset;
           BOOLEAN WildCardsFound;
       } Enumeration;
   };
   union {
       struct {
           //dont do this yet
           //ULONG MaximumReadBufferLength;
           //ULONG MaximumWriteBufferLength;
           USHORT Flags;
       } File;
   };
} MRX_SMB_FOBX, *PMRX_SMB_FOBX;

#define MRxSmbGetFileObjectExtension(pFobx)  \
        (((pFobx) == NULL) ? NULL : (PMRX_SMB_FOBX)((pFobx)->Context))

#define SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST    0x0001
#define SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN      0x0002
#define SMBFOBX_ENUMFLAG_FAST_RESUME             0x0004
#define SMBFOBX_ENUMFLAG_CORE_SEARCH_IN_PROGRESS 0x0008
#define SMBFOBX_ENUMFLAG_LOUD_FINALIZE           0x0010
#define SMBFOBX_ENUMFLAG_READ_FROM_CACHE         0x0020
#define SMBFOBX_ENUMFLAG_NO_WILDCARD             0x0200

typedef
NTSTATUS
(NTAPI *PMRXSMB_CANCEL_ROUTINE) (
      PRX_CONTEXT pRxContext);

// The RX_CONTEXT instance has four fields ( ULONG's ) provided by the wrapper
// which can be used by the mini rdr to store its context. This is used by
// the SMB mini rdr to identify the parameters for request cancellation

typedef struct _MRXSMB_RX_CONTEXT {
   PMRXSMB_CANCEL_ROUTINE          pCancelRoutine;
   PVOID                           pCancelContext;
   struct _SMB_EXCHANGE            *pExchange;
   struct _SMBSTUFFER_BUFFER_STATE *pStufferState;
} MRXSMB_RX_CONTEXT, *PMRXSMB_RX_CONTEXT;


#define MRxSmbGetMinirdrContext(pRxContext)     \
        ((PMRXSMB_RX_CONTEXT)(&(pRxContext)->MRxContext[0]))

#define MRxSmbMakeSrvOpenKey(Tid,Fid) \
        ULongToPtr(((ULONG)(Tid) << 16) | (ULONG)(Fid))

typedef struct _SECURITY_RESPONSE_CONTEXT {
   struct {
      PVOID pResponseBuffer;
   } LanmanSetup;
} SECURITY_RESPONSE_CONTEXT,*PSECURITY_RESPONSE_CONTEXT;


//
// forward declarations for all dispatch vector methods.
//

extern NTSTATUS
MRxSmbStart (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

extern NTSTATUS
MRxSmbStop (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

extern NTSTATUS
MRxSmbMinirdrControl (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PVOID pContext,
    IN OUT PUCHAR SharedBuffer,
    IN     ULONG InputBufferLength,
    IN     ULONG OutputBufferLength,
    OUT PULONG CopyBackLength
    );

extern NTSTATUS
MRxSmbDevFcb (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbCreate (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbCollapseOpen (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbShouldTryToCollapseThisOpen (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbRead (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbWrite (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbLocks(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbFlush(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbFsCtl(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbIoCtl(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbNotifyChangeDirectory(
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbComputeNewBufferingState(
    IN OUT PMRX_SRV_OPEN pSrvOpen,
    IN     PVOID         pMRxContext,
       OUT ULONG         *pNewBufferingState);

extern NTSTATUS
MRxSmbFlush (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbCloseWithDelete (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbZeroExtend (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbTruncate (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbCleanupFobx (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbCloseSrvOpen (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbClosedSrvOpenTimeOut (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbQueryDirectory (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbIsValidDirectory (
    IN OUT PRX_CONTEXT RxContext,
    IN PUNICODE_STRING DirectoryName
    );

extern NTSTATUS
MRxSmbQueryEaInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbSetEaInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

extern NTSTATUS
MRxSmbQuerySecurityInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbSetSecurityInformation (
    IN OUT struct _RX_CONTEXT * RxContext
    );

extern NTSTATUS
MRxSmbQueryVolumeInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbSetVolumeInformation (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbLowIOSubmit (
    IN OUT PRX_CONTEXT RxContext
    );

extern NTSTATUS
MRxSmbCreateVNetRoot(
    IN OUT PMRX_CREATENETROOT_CONTEXT pContext
    );

extern NTSTATUS
MRxSmbFinalizeVNetRoot(
    IN OUT PMRX_V_NET_ROOT pVirtualNetRoot,
    IN     PBOOLEAN    ForceDisconnect);

extern NTSTATUS
MRxSmbFinalizeNetRoot(
    IN OUT PMRX_NET_ROOT pNetRoot,
    IN     PBOOLEAN      ForceDisconnect);

extern NTSTATUS
MRxSmbUpdateNetRootState(
    IN  PMRX_NET_ROOT pNetRoot);

VOID
MRxSmbExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    );

extern NTSTATUS
MRxSmbCreateSrvCall(
      PMRX_SRV_CALL                      pSrvCall,
      PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext);

extern NTSTATUS
MRxSmbFinalizeSrvCall(
      PMRX_SRV_CALL    pSrvCall,
      BOOLEAN    Force);

extern NTSTATUS
MRxSmbSrvCallWinnerNotify(
      IN OUT PMRX_SRV_CALL      pSrvCall,
      IN     BOOLEAN        ThisMinirdrIsTheWinner,
      IN OUT PVOID          pSrvCallContext);

extern NTSTATUS
MRxSmbQueryFileInformation (
    IN OUT PRX_CONTEXT            RxContext
    );

extern NTSTATUS
MRxSmbSetFileInformation (
    IN OUT PRX_CONTEXT            RxContext
    );

NTSTATUS
MRxSmbSetFileInformationAtCleanup(
      IN OUT PRX_CONTEXT            RxContext
      );

NTSTATUS
MRxSmbDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    );

NTSTATUS
MRxSmbDeallocateForFobx (
    IN OUT PMRX_FOBX pFobx
    );

NTSTATUS
MRxSmbIsLockRealizable (
    IN OUT PMRX_FCB pFcb,
    IN PLARGE_INTEGER  ByteOffset,
    IN PLARGE_INTEGER  Length,
    IN ULONG  LowIoLockFlags
    );

extern NTSTATUS
MRxSmbForcedClose (
    IN OUT PMRX_SRV_OPEN SrvOpen
    );

extern NTSTATUS
MRxSmbExtendForCache (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    );

extern NTSTATUS
MRxSmbExtendForNonCache (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    );

extern NTSTATUS
MRxSmbCompleteBufferingStateChangeRequest (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRX_SRV_OPEN   SrvOpen,
    IN     PVOID       pContext
    );

NTSTATUS
MRxSmbGetFsAttributesFromNetRoot(
    IN OUT PRX_CONTEXT RxContext
    );

#include "smbutils.h"
#include "smbce.h"
#include "midatlas.h"
#include "smbcedbp.h"
#include "smbcedb.h"
#include "smbxchng.h"
#include "stuffer.h"
#include "smbpse.h"
#include "smbcaps.h"
#include "transprt.h"
#include "transact.h"
#include "recursvc.h"   // recurrent service definitions
#include "smbadmin.h"
#include "smbprocs.h"   // crossreferenced routines
#include "smbea.h"

#endif   // _MRXPROCS_H_




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\read.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module implements the mini redirector call down routines pertaining to
    read of file system objects.

Notes:

    The READ adn WRITE paths in the mini redirector have to contend with a number
    of different variations based on the kind of the server and the capabilities
    of the server.

    Currently there are atleast four variations of the read operation that needs
    to be supported.

        1) SMB_COM_READ
            This is the read operation of choice against all servers which
            support old dialects of the SMB protocol ( < DF_LANMAN10 )

        2) SMB_COM_READ_ANDX
            This is the read operation of choice against all servers which
            support read extensions in the new dialects of the SMB protocol

            However READ_ANDX itself can be further customized based upon the
            server capabilities. There are two dimensions in which this
            change can occur -- large sized reads being supported.

    In addition the SMB protocol supports the following flavours of a READ
    operation which are not supported in the redirector

        1) SMB_COM_READ_RAW
            This is used to initiate large transfers to a server. However this
            ties up the VC exclusively for this operation. The large READ_ANDX
            overcomes this by providing for large read operations which can
            be multiplexed on the VC.

        2) SMB_COM_READ_MPX,SMB_COM_READ_MPX_SECONDARY,
            These operations were designed for a direct host client. The NT
            redriector does not use these operations because the recent
            changes to NetBt allows us to go directly over a TCP connection.

    The implementation of a read operation in the RDR hinges upon two decisions --
    selecting the type of command to use and decomposing the original read
    operation into a number of smaller read operations while adhering to
    protocol/server restrictions.

    The exchange engine provides the facility for sending a packet to the server
    and picking up the associated response. Based upon the amount of data to be
    read a number of such operations need to be initiated.

    This module is organized as follows ---

        MRxSmbRead --
            This represents the top level entry point in the dispatch vector for
            read operations associated with this mini redirector.

        MRxSmbBuildReadRequest --
            This routine is used for formatting the read command to be sent to
            the server. We will require a new routine for each new type of read
            operation that we would like to support

        SmbPseExchangeStart_Read --
            This routine is the heart of the read engine. It farms out the
            necessary number of read operations and ensures the continuation
            of the local operation on completion for both synchronous and
            asynchronous reads.

    All the state information required for the read operation is captured in an
    instance of SMB_PSE_ORDINARY_EXCHANGE. This state information can be split
    into two parts - the generic state information and the state information
    specific to the read operation. The read operation specific state information
    has been encapsulated in SMB_PSE_OE_READWRITE field in the exchange instance.

    The read operation begins with the instantiation of an exchange in MRxSmbRead
    and is driven through the various stages based upon a state diagram. The
    state diagram is encoded in the OpSpecificState field in the ordinary
    exchange.

    The state diagram associated with the read exchange is as follows

                     SmbPseOEInnerIoStates_Initial
                                |
                                |
                                |
                                V
                ---->SmbPseOEInnerIoStates_ReadyToSend
                |               |
                |               |
                |               |
                |               V
                ---SmbPseOEInnerIoStates_OperationOutstanding
                                |
                                |
                                |
                                V
                    SmbPseOEInnerIoStates_OperationCompleted


--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbRead)
#pragma alloc_text(PAGE, MRxSmbBuildReadAndX)
#pragma alloc_text(PAGE, MRxSmbBuildCoreRead)
#pragma alloc_text(PAGE, MRxSmbBuildSmallRead)
#pragma alloc_text(PAGE, SmbPseExchangeStart_Read)
#pragma alloc_text(PAGE, MRxSmbFinishNoCopyRead)
#endif

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

ULONG MRxSmbSrvReadBufSize = 0xffff; //use the negotiated size
ULONG MRxSmbReadSendOptions = 0;     //use the default options

NTSTATUS
MRxSmbBuildReadRequest(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange);

NTSTATUS
MRxSmbRead(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine handles network read requests.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_V_NET_ROOT VNetRootToUse = capFobx->pSrvOpen->pVNetRoot;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbRead\n", 0 ));

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    do {
        Status = __SmbPseCreateOrdinaryExchange(
                                RxContext,
                                VNetRootToUse,
                                SMBPSE_OE_FROM_READ,
                                SmbPseExchangeStart_Read,
                                &OrdinaryExchange );

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
            return Status;
        }

        OrdinaryExchange->pSmbCeSynchronizationEvent = &RxContext->SyncEvent;

        Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

        if (Status != STATUS_PENDING) {
            BOOLEAN FinalizationComplete;

            FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
            ASSERT(FinalizationComplete);
        }

        if ((Status == STATUS_RETRY) &&
            BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
            MRxSmbResumeAsyncReadWriteRequests(RxContext);
            Status = STATUS_PENDING;
        }
    } while (Status == STATUS_RETRY);

    RxDbgTrace(-1, Dbg, ("MRxSmbRead  exit with status=%08lx\n", Status ));

    return(Status);
} // MRxSmbRead


NTSTATUS
SmbPseExchangeStart_Read(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for read.

Arguments:

    RxContext - the local context

    OrdinaryExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    ULONG StartEntryCount;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;

    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(OrdinaryExchange);
    PSMBCE_SERVER   pServer  = SmbCeGetExchangeServer(OrdinaryExchange);
    PSMBCE_NET_ROOT pNetRoot = SmbCeGetExchangeNetRoot(OrdinaryExchange);

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_FCB  SmbFcb  = MRxSmbGetFcbExtension(capFcb);
    PSMBCE_SESSION pSession = SmbCeGetExchangeSession(OrdinaryExchange);
    BOOLEAN  SynchronousIo =
               !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Read\n", 0 ));

    ASSERT( (OrdinaryExchange->SmbCeFlags&SMBCE_EXCHANGE_ATTEMPT_RECONNECTS) == 0 );

    ASSERT(OrdinaryExchange->Type == ORDINARY_EXCHANGE);

    OrdinaryExchange->StartEntryCount++;
    StartEntryCount = OrdinaryExchange->StartEntryCount;

    // Ensure that the Fid is validated
    SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);

    for (;;) {
        switch (OrdinaryExchange->OpSpecificState) {
        case SmbPseOEInnerIoStates_Initial:
            {
                OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;

                // If not a synchronous read, then continue here when resumed
                if (!SynchronousIo) {
                    OrdinaryExchange->AsyncResumptionRoutine = SmbPseExchangeStart_Read;
                }

                MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

                rw->UserBufferBase          = RxLowIoGetBufferAddress(RxContext);
                rw->ByteOffsetAsLI.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
                rw->RemainingByteCount      = LowIoContext->ParamsFor.ReadWrite.ByteCount;

                rw->ThisBufferOffset = 0;

                rw->PartialDataMdlInUse = FALSE;
                rw->PartialExchangeMdlInUse = FALSE;

                rw->UserBufferPortionLength = 0;
                rw->ExchangeBufferPortionLength = 0;

            }
            //lack of break is intentional

        case SmbPseOEInnerIoStates_ReadyToSend:
            {
                OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_OperationOutstanding;
                ClearFlag(OrdinaryExchange->OpSpecificFlags,OE_RW_FLAG_SUCCESS_IN_COPYHANDLER);
                OrdinaryExchange->SendOptions = MRxSmbReadSendOptions;

                Status = MRxSmbBuildReadRequest(
                             OrdinaryExchange);

                if (Status != STATUS_SUCCESS) {
                    RxDbgTrace(0, Dbg, ("bad read stuffer status........\n"));
                    goto FINALLY;
                }

                if (FALSE &&
                    FlagOn(
                        LowIoContext->ParamsFor.ReadWrite.Flags,
                        LOWIO_READWRITEFLAG_PAGING_IO)) {
                    RxLog(
                        ("PagingIoRead: rxc/offset/length %lx/%lx/%lx",
                         RxContext,
                         &rw->ByteOffsetAsLI,
                         rw->ThisByteCount
                         )
                        );
                }

                InterlockedIncrement(&MRxSmbStatistics.ReadSmbs);

                Status = SmbPseOrdinaryExchange(
                             SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                             SMBPSE_OETYPE_READ );

                // If the status is PENDING, then we're done for now. We must
                // wait until we're re-entered when the receive happens.

                if (Status == STATUS_PENDING) {
                    ASSERT(!SynchronousIo);
                    goto FINALLY;
                }
            }
            //lack of break is intentional

        case SmbPseOEInnerIoStates_OperationOutstanding:
            {
                OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;
                OrdinaryExchange->Status = OrdinaryExchange->SmbStatus;

                if (rw->BytesReturned > 0) {
                    if (rw->PartialDataMdlInUse) {
                        MmPrepareMdlForReuse(
                            &rw->PartialDataMdl);

                        rw->PartialDataMdlInUse = FALSE;
                    }
                } else {
                    if (OrdinaryExchange->Status == STATUS_SUCCESS) {
                        OrdinaryExchange->Status = STATUS_END_OF_FILE;
                    }
                }

                rw->RemainingByteCount -=  rw->BytesReturned;

                if ((OrdinaryExchange->Status == STATUS_END_OF_FILE) &&
                    (RxContext->InformationToReturn > 0)) {
                    OrdinaryExchange->Status = STATUS_SUCCESS;
                    rw->RemainingByteCount = 0;
                }

                RxContext->InformationToReturn += rw->BytesReturned;

                Status = OrdinaryExchange->Status;
                
                if ((NT_ERROR(Status) &&
                     Status != STATUS_RETRY) ||
                    (rw->RemainingByteCount==0) ) {
                    goto FINALLY;
                } 

                if (capFcb->pNetRoot->Type != NET_ROOT_DISK) {
                    if (Status != STATUS_BUFFER_OVERFLOW) {
                        goto FINALLY;
                    } else {
                        ASSERT (rw->BytesReturned == rw->ThisByteCount);
                    }
                }

                //reset the smbstatus.....
                rw->ByteOffsetAsLI.QuadPart += rw->BytesReturned;
                rw->ThisBufferOffset += rw->BytesReturned;
                rw->BytesReturned = 0;

                MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

                break;
            }
        }
    }

FINALLY:
    if ( Status != STATUS_PENDING) {
        if (Status != STATUS_RETRY) {
            SmbPseAsyncCompletionIfNecessary(OrdinaryExchange,RxContext);
        }
    }

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Read exit w %08lx\n", Status ));

    return Status;
} // SmbPseExchangeStart_Read


NTSTATUS
MRxSmbFinishNoCopyRead (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
      )
{
    PAGED_CODE();

    return(OrdinaryExchange->NoCopyFinalStatus);
}

UCHAR
MRxSmbReadHandler_NoCopy (
    IN OUT  PSMB_PSE_ORDINARY_EXCHANGE   OrdinaryExchange,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    OUT ULONG       *pBytesTaken,
    IN  PSMB_HEADER pSmbHeader,
    OUT PMDL        *pDataBufferPointer,
    OUT PULONG      pDataSize,
#if DBG
    IN  UCHAR       ThisIsAReenter,
#endif
    IN  PRESP_READ_ANDX       Response
      )
/*++

Routine Description:

    This routine causes the bytes from the message to be transferred to the user's
    buffer. In order to do this, it takes enough bytes from the indication and
    then crafts up an MDL to cause the transport to do the copy.

Arguments:

    please refer to smbpse.c...the only place from which this may be called

Return Value:

    UCHAR - a value representing the action that OE receive routine will perform.
            options are discard (in case of an error),
            copy_for_resume (never called after this is all debugged),
            and normal

--*/
{
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;

    PRX_CONTEXT    RxContext = OrdinaryExchange->RxContext;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PMDL           OriginalDataMdl = LowIoContext->ParamsFor.ReadWrite.Buffer;

    PBYTE UserBuffer,ExchangeBuffer;

    ULONG   BytesReturned,DataOffset;
    ULONG   UserBufferLength;
    ULONG   StartingOffsetInUserBuffer;

    UCHAR   ContinuationCode;

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishReadNoCopy\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishReadNoCopy:");

    UserBufferLength = MmGetMdlByteCount(OriginalDataMdl);
    UserBuffer = rw->UserBufferBase + rw->ThisBufferOffset;
    ExchangeBuffer = StufferState->BufferBase;

    switch (OrdinaryExchange->LastSmbCommand) {
    case SMB_COM_READ_ANDX:
        {
            if (Response->WordCount != 12) {
                OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
                ContinuationCode = SMBPSE_NOCOPYACTION_DISCARD;
                goto FINALLY;
            }

            BytesReturned = SmbGetUshort(&Response->DataLength);
            DataOffset    =  SmbGetUshort(&Response->DataOffset);

        }

        if (DataOffset > sizeof(SMB_HEADER)+sizeof(RESP_READ_ANDX)) {
            OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
            ContinuationCode = SMBPSE_NOCOPYACTION_DISCARD;
            goto FINALLY;
        }

        break;

    case SMB_COM_READ:
        {
            PRESP_READ CoreResponse = (PRESP_READ)Response; //recast response for core read
            
            if (Response->WordCount != 5) {
                OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
                ContinuationCode = SMBPSE_NOCOPYACTION_DISCARD;
                goto FINALLY;
            }
            
            BytesReturned = SmbGetUshort(&CoreResponse->DataLength);
            DataOffset =  sizeof(SMB_HEADER)+FIELD_OFFSET(RESP_READ,Buffer[0]);
        }
        break;
    }

    if ( BytesReturned > rw->ThisByteCount ) {
        //cut back if we got a bad response
        BytesReturned = rw->ThisByteCount;
    }

    RxDbgTrace(0, Dbg, ("-->ByteCount,Offset,Returned,DOffset,Buffer=%08lx/%08lx/%08lx/%08lx/%08lx\n",
                rw->ThisByteCount,
                rw->ThisBufferOffset,
                BytesReturned,DataOffset,UserBuffer
               ));

    OrdinaryExchange->ContinuationRoutine = MRxSmbFinishNoCopyRead;
    OrdinaryExchange->ReadWrite.BytesReturned =  BytesReturned;

    // now, move the data to the user's buffer If enough is showing, just copy it in.

    StartingOffsetInUserBuffer = rw->ThisBufferOffset;
    rw->UserBufferPortionLength = BytesReturned;
    rw->ExchangeBufferPortionLength = 0;

    if (BytesIndicated >= (DataOffset +
                           rw->UserBufferPortionLength +
                           rw->ExchangeBufferPortionLength)) {
        RtlCopyMemory(
            UserBuffer,
            ((PBYTE)pSmbHeader)+DataOffset,
            rw->UserBufferPortionLength);

        *pBytesTaken  = DataOffset +
                        rw->UserBufferPortionLength +
                        rw->ExchangeBufferPortionLength;

        RxDbgTrace(-1, Dbg, ("MRxSmbFinishReadNoCopy  copy fork\n" ));

        ContinuationCode = SMBPSE_NOCOPYACTION_NORMALFINISH;
    } else {
        // otherwise, MDL it in.  we use the smbbuf as an Mdl!
        if (BytesIndicated < DataOffset) {
            OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
            ContinuationCode = SMBPSE_NOCOPYACTION_DISCARD;
            goto FINALLY;
        }

        if (rw->UserBufferPortionLength > 0) {
            rw->PartialDataMdlInUse = TRUE;

            MmInitializeMdl(
                &rw->PartialDataMdl,
                0,
                PAGE_SIZE + rw->UserBufferPortionLength);

            IoBuildPartialMdl(
                OriginalDataMdl,
                &rw->PartialDataMdl,
                (PCHAR)MmGetMdlVirtualAddress(OriginalDataMdl) + StartingOffsetInUserBuffer,
                rw->UserBufferPortionLength);
        }

        if (rw->ExchangeBufferPortionLength > 0) {
            rw->PartialExchangeMdlInUse = TRUE;

            MmInitializeMdl(
                &rw->PartialExchangeMdl,
                0,
                PAGE_SIZE + rw->ExchangeBufferPortionLength);

            IoBuildPartialMdl(
                StufferState->HeaderMdl,
                &rw->PartialExchangeMdl,
                MmGetMdlVirtualAddress( StufferState->HeaderMdl ),
                rw->ExchangeBufferPortionLength);
        }

        if (rw->PartialDataMdlInUse) {
            if (rw->PartialExchangeMdlInUse) {
                rw->PartialDataMdl.Next = &rw->PartialExchangeMdl;
            }

            *pDataBufferPointer = &rw->PartialDataMdl;
        } else {
            *pDataBufferPointer = &rw->PartialExchangeMdl;
        }

        *pDataSize    = rw->UserBufferPortionLength +
                        rw->ExchangeBufferPortionLength;
        *pBytesTaken  = DataOffset;

        RxDbgTrace(-1, Dbg, ("MRxSmbFinishReadNoCopy   mdlcopy fork \n" ));

        ContinuationCode = SMBPSE_NOCOPYACTION_MDLFINISH;
    }

FINALLY:
    return ContinuationCode;
}

NTSTATUS
MRxSmbBuildReadRequest(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange)
/*++

Routine Description:

    This routine formats the appropriate type of read request issued to the
    server

Arguments:

    OrdinaryExchange - the exchange instance encapsulating the information

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    NTSTATUS Status;
    UCHAR    SmbCommand;
    ULONG    SmbCommandSize;

    ULONG OffsetLow,OffsetHigh;

    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;

    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(OrdinaryExchange);
    PSMBCE_SERVER         pServer  = SmbCeGetExchangeServer(OrdinaryExchange);
    PSMBCE_NET_ROOT       pNetRoot = SmbCeGetExchangeNetRoot(OrdinaryExchange);
    PMRX_V_NET_ROOT       pVNetRoot = SmbCeGetExchangeVNetRoot(OrdinaryExchange);

    PRX_CONTEXT              RxContext    = OrdinaryExchange->RxContext;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    RxCaptureFcb;
    RxCaptureFobx;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PMRX_SRV_OPEN     SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    rw->ThisByteCount = min(rw->RemainingByteCount,pNetRoot->MaximumReadBufferSize);

    OffsetLow  = rw->ByteOffsetAsLI.LowPart;
    OffsetHigh = rw->ByteOffsetAsLI.HighPart;

    if (FlagOn(pServer->DialectFlags,DF_LANMAN10)) {
        SmbCommand = SMB_COM_READ_ANDX;
        SmbCommandSize = SMB_REQUEST_SIZE(NT_READ_ANDX);
    } else {
        SmbCommandSize = SMB_REQUEST_SIZE(READ);
        SmbCommand = SMB_COM_READ;
    }

    MRxSmbDumpStufferState(
        1000,
        "SMB w/ READ before stuffing",
        StufferState);


    Status = MRxSmbStartSMBCommand (
                 StufferState,
                 SetInitialSMB_Never,
                 SmbCommand,
                 SmbCommandSize,
                 NO_EXTRA_DATA,
                 NO_SPECIAL_ALIGNMENT,
                 RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                 0,0,0,0 STUFFERTRACE(Dbg,'FC'));

    if (Status != STATUS_SUCCESS) {
        return Status;

    }

    switch (SmbCommand) {
    case SMB_COM_READ:
        {
            // below, we just set mincount==maxcount. rdr1 did this.......
            MRxSmbStuffSMB (
                StufferState,
                "0wwdwB!",
                                         //  0         UCHAR WordCount;
                 smbSrvOpen->Fid,        //  w         _USHORT( Fid );
                 rw->ThisByteCount,      //  w         _USHORT( Count );
                 OffsetLow,              //  d         _ULONG( Offset );
                 rw->RemainingByteCount, //  w         _USHORT( Remaining );
                                         //  B!        _USHORT( ByteCount );
                 SMB_WCT_CHECK(5) 0
                                         //            UCHAR Buffer[1];
                 );
        }
        break;

    case SMB_COM_READ_ANDX:
        {
            PNT_SMB_HEADER NtSmbHeader = (PNT_SMB_HEADER)(StufferState->BufferBase);
            BOOLEAN UseNtVersion;
            ULONG Timeout = 0;

            UseNtVersion = BooleanFlagOn(pServer->DialectFlags,DF_NT_SMBS);

            if (UseNtVersion &&
                FlagOn(
                    LowIoContext->ParamsFor.ReadWrite.Flags,
                    LOWIO_READWRITEFLAG_PAGING_IO)) {
                SmbPutAlignedUshort(
                    &NtSmbHeader->Flags2,
                    SmbGetAlignedUshort(&NtSmbHeader->Flags2) | SMB_FLAGS2_PAGING_IO );
            }

            // below, we just set mincount==maxcount. rdr1 did this.......
            MRxSmbStuffSMB (
                StufferState,
                "XwdwWdw",
                                                     //  X        UCHAR WordCount;
                                                     //           UCHAR AndXCommand;
                                                     //           UCHAR AndXReserved;
                                                     //           _USHORT( AndXOffset );
                smbSrvOpen->Fid,                     //  w        _USHORT( Fid );
                OffsetLow,                           //  d        _ULONG( Offset );
                rw->ThisByteCount,                   //  w        _USHORT( MaxCount );
                SMB_OFFSET_CHECK(READ_ANDX,MinCount)
                rw->ThisByteCount,                   //  W        _USHORT( MinCount );
                Timeout,                             //  d        _ULONG( Timeout );
                rw->RemainingByteCount,              //  w        _USHORT( Remaining );
                StufferCondition(UseNtVersion), "D",
                SMB_OFFSET_CHECK(NT_READ_ANDX,OffsetHigh)
                OffsetHigh,                          //  D NTonly _ULONG( OffsetHigh );
                                                     //
                STUFFER_CTL_NORMAL, "B!",
                                                     //  B!       _USHORT( ByteCount );
                SMB_WCT_CHECK(((UseNtVersion)?12:10)) 0
                                                     //           UCHAR Buffer[1];
                );
        }
        break;
    default:
        break;
    }

    if (Status == STATUS_SUCCESS) {
        MRxSmbDumpStufferState(
            700,
            "SMB w/ READ after stuffing",
            StufferState);

        InterlockedIncrement(&MRxSmbStatistics.SmallReadSmbs);
    }

    return Status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\recursvc.h ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    recursvc.h

Abstract:

Notes:

    Refer to recursvc.c

--*/

#ifndef _RECURSVC_H_
#define _RECURSVC_H_

extern NTSTATUS
MRxSmbInitializeRecurrentServices();

extern VOID
MRxSmbTearDownRecurrentServices();


#define RECURRENT_SERVICE_CANCELLED (0xcccccccc)
#define RECURRENT_SERVICE_ACTIVE    (0xaaaaaaaa)
#define RECURRENT_SERVICE_DORMANT   (0xdddddddd)
#define RECURRENT_SERVICE_SHUTDOWN  (0xffffffff)

typedef
NTSTATUS
(NTAPI *PRECURRENT_SERVICE_ROUTINE) (
    IN PVOID Context
    );

typedef struct _RECURRENT_SERVICE_CONTEXT_ {
    LONG           State;
    NTSTATUS       Status;
    LARGE_INTEGER  Interval;
    RX_WORK_ITEM   WorkItem;
    KEVENT         CancelCompletionEvent;
    PRECURRENT_SERVICE_ROUTINE pServiceRoutine;
    PVOID          pServiceRoutineParameter;
} RECURRENT_SERVICE_CONTEXT, *PRECURRENT_SERVICE_CONTEXT;

extern VOID
MRxSmbInitializeRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext,
    PRECURRENT_SERVICE_ROUTINE pServiceRoutine,
    PVOID                      pServiceRoutineParameter,
    PLARGE_INTEGER             pTimeInterval);

extern VOID
MRxSmbCancelRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext);

extern NTSTATUS
MRxSmbActivateRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext);

typedef struct _MRXSMB_ECHO_PROBE_SERVICE_CONTEXT_ {
    RECURRENT_SERVICE_CONTEXT RecurrentServiceContext;

    PVOID  pEchoSmb;
    ULONG  EchoSmbLength;
} MRXSMB_ECHO_PROBE_SERVICE_CONTEXT, *PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT;

extern MRXSMB_ECHO_PROBE_SERVICE_CONTEXT MRxSmbEchoProbeServiceContext;

extern NTSTATUS
SmbCeProbeServers(
    PVOID    pContext);

extern NTSTATUS
MRxSmbInitializeEchoProbeService(
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProcessingContext);

extern VOID
MRxSmbTearDownEchoProbeService(
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProcessingContext);

typedef struct _MRXSMB_SCAVENGER_SERVICE_CONTEXT_ {
    RECURRENT_SERVICE_CONTEXT RecurrentServiceContext;

    SMBCE_V_NET_ROOT_CONTEXTS VNetRootContexts;
} MRXSMB_SCAVENGER_SERVICE_CONTEXT, *PMRXSMB_SCAVENGER_SERVICE_CONTEXT;

extern MRXSMB_SCAVENGER_SERVICE_CONTEXT  MRxSmbScavengerServiceContext;

extern NTSTATUS
MRxSmbInitializeScavengerService(
    PMRXSMB_SCAVENGER_SERVICE_CONTEXT pScavengerServiceContext);

extern VOID
MRxSmbTearDownScavengerService(
    PMRXSMB_SCAVENGER_SERVICE_CONTEXT pScavengerServiceContext);

extern NTSTATUS
SmbCeScavenger(
    PVOID pContext);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\mrxglbl.h ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    mrxglbl.h

Abstract:

    The global include file for SMB mini redirector

--*/

#ifndef _MRXGLBL_H_
#define _MRXGLBL_H_

#include <lmstats.h>

#define SmbCeLog(x) \
        RxLog(x)

//
// the SMB protocol tree connections are identified by a Tree Id., each
// file opened on a tree connection by a File Id. and each outstanding request
// on that connection by a Multiplex Id.
//

typedef USHORT SMB_TREE_ID;
typedef USHORT SMB_FILE_ID;
typedef USHORT SMB_MPX_ID;


//
// Each user w.r.t a particular connection is identified by a User Id. and each
// process on the client side is identified by a Process id.
//

typedef USHORT SMB_USER_ID;
typedef USHORT SMB_PROCESS_ID;

//
// All exchanges are identified with a unique id. assigned on creation of the exchange
// which is used to track it.
//

typedef ULONG SMB_EXCHANGE_ID;

//
// Of the fields in this context the domain name is initialized during
// MRxSmbSetConfiguration. The others are initialized in init.c as
// parameters read from the registry
//

typedef STAT_WORKSTATION_0 MRX_SMB_STATISTICS;
typedef PSTAT_WORKSTATION_0 PMRX_SMB_STATISTICS;

extern MRX_SMB_STATISTICS MRxSmbStatistics;

typedef struct _SMBCE_CONTEXT_ {
    UNICODE_STRING        ComputerName;
    UNICODE_STRING        OperatingSystem;
    UNICODE_STRING        LanmanType;
    UNICODE_STRING        Transports;
} SMBCE_CONTEXT,*PSMBCE_CONTEXT;

extern SMBCE_CONTEXT SmbCeContext;

extern RXCE_ADDRESS_EVENT_HANDLER    MRxSmbVctAddressEventHandler;
extern RXCE_CONNECTION_EVENT_HANDLER MRxSmbVctConnectionEventHandler;

extern PBYTE  s_pNegotiateSmb;
extern ULONG  s_NegotiateSmbLength;
extern PMDL   s_pNegotiateSmbBuffer;

extern PBYTE  s_pEchoSmb;
extern ULONG  s_EchoSmbLength;
extern PMDL   s_pEchoSmbMdl;

extern FAST_MUTEX MRxSmbSerializationMutex;

extern BOOLEAN MRxSmbObeyBindingOrder;

// Miscellanous definitions

#define DFS_OPEN_CONTEXT                        0xFF444653

typedef struct _DFS_NAME_CONTEXT_ {
    UNICODE_STRING  UNCFileName;
    LONG            NameContextType;
    ULONG           Flags;
} DFS_NAME_CONTEXT, *PDFS_NAME_CONTEXT;

extern PBYTE MRxSmb_pPaddingData;

#define SMBCE_PADDING_DATA_SIZE (32)

typedef struct _MRXSMB_GLOBAL_PADDING {
    MDL Mdl;
    ULONG Pages[2]; //this can't possibly span more than two pages
    UCHAR Pad[SMBCE_PADDING_DATA_SIZE];
} MRXSMB_GLOBAL_PADDING, *PMRXSMB_GLOBAL_PADDING;

extern MRXSMB_GLOBAL_PADDING MrxSmbCeGlobalPadding;

extern PEPROCESS    RDBSSProcessPtr;
extern PRDBSS_DEVICE_OBJECT MRxSmbDeviceObject;

#define RxNetNameTable (*(MRxSmbDeviceObject->pRxNetNameTable))

extern LONG MRxSmbNumberOfSrvOpens;

extern PVOID MRxSmbPoRegistrationState;

NTKERNELAPI
PVOID
PoRegisterSystemState (
    IN PVOID StateHandle,
    IN EXECUTION_STATE Flags
    );

NTKERNELAPI
VOID
PoUnregisterSystemState (
    IN PVOID StateHandle
    );

//
// MRxSmbSecurityInitialized indicates whether MRxSmbInitializeSecurity
// has been called.
//

extern BOOLEAN MRxSmbSecurityInitialized;

#define MAXIMUM_PARTIAL_BUFFER_SIZE  65535  // Maximum size of a partial MDL

#define MAXIMUM_SMB_BUFFER_SIZE 4356

// The following scavenge interval is in seconds
#define MRXSMB_V_NETROOT_CONTEXT_SCAVENGER_INTERVAL (40)

// the following default interval for timed exchanges is in seconds
#define MRXSMB_DEFAULT_TIMED_EXCHANGE_EXPIRY_TIME    (60)

#define RxBuildPartialMdlUsingOffset(SourceMdl,DestinationMdl,Offset,Length) \
        IoBuildPartialMdl(SourceMdl,\
                          DestinationMdl,\
                          (PBYTE)MmGetMdlVirtualAddress(SourceMdl)+Offset,\
                          Length)

#define RxBuildPaddingPartialMdl(DestinationMdl,Length) \
        RxBuildPartialMdlUsingOffset(&MrxSmbCeGlobalPadding.Mdl,DestinationMdl,0,Length)


//we turn away async operations that are not wait by posting. if we can wait
//then we turn off the sync flag so that things will just act synchronous
#define TURN_BACK_ASYNCHRONOUS_OPERATIONS() {                              \
    if (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {        \
        if (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WAIT)) {               \
            ClearFlag(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);    \
        } else {                                                           \
            RxContext->PostRequest = TRUE;                                 \
            return(STATUS_PENDING);                                     \
        }                                                                  \
    }                                                                      \
  }


typedef struct _MRXSMB_CONFIGURATION_DATA_ {
   ULONG   MaximumNumberOfCommands;
   ULONG   SessionTimeoutInterval;
   ULONG   LockQuota;
   ULONG   LockIncrement;
   ULONG   MaximumLock;
   ULONG   CachedFileTimeout;
   ULONG   DormantFileTimeout;
   ULONG   DormantFileLimit;
   ULONG   MaximumNumberOfThreads;
   ULONG   ConnectionTimeoutInterval;
   ULONG   CharBufferSize;

   BOOLEAN UseOplocks;
   BOOLEAN UseUnlocksBehind;
   BOOLEAN UseCloseBehind;
   BOOLEAN UseLockReadUnlock;
   BOOLEAN UtilizeNtCaching;
   BOOLEAN UseRawRead;
   BOOLEAN UseRawWrite;
   BOOLEAN UseEncryption;

} MRXSMB_CONFIGURATION, *PMRXSMB_CONFIGURATION;

extern MRXSMB_CONFIGURATION MRxSmbConfiguration;

//
// Definitions for starting stopping theSMB mini redirector
//

typedef enum _MRXSMB_STATE_ {
   MRXSMB_STARTABLE,
   MRXSMB_START_IN_PROGRESS,
   MRXSMB_STARTED,
   MRXSMB_STOPPED
} MRXSMB_STATE,*PMRXSMB_STATE;

extern MRXSMB_STATE MRxSmbState;

extern
NTSTATUS
MRxSmbInitializeSecurity (VOID);

extern
NTSTATUS
MRxSmbUninitializeSecurity (VOID);

extern
NTSTATUS
MRxSmbInitializeTransport(VOID);

extern
NTSTATUS
MRxSmbUninitializeTransport(VOID);

extern
NTSTATUS
MRxSmbRegisterForPnpNotifications();

extern
NTSTATUS
MRxSmbDeregisterForPnpNotifications();

extern NTSTATUS
SmbCeEstablishConnection(
    IN PMRX_V_NET_ROOT            pVNetRoot,
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext,
    IN BOOLEAN                    fInitializeNetRoot);

extern NTSTATUS
SmbCeReconnect(
    IN PMRX_V_NET_ROOT        pVNetRoot);

NTSTATUS
SmbCeGetComputerName(
   VOID
   );

NTSTATUS
SmbCeGetOperatingSystemInformation(
   VOID
   );

#endif _MRXGLBL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\recursvc.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    recursvc.c

Abstract:

    This module implements the recurrent services in the mini rdr. These are services that
    are not triggered as a response to some request from the wrapper, they are autonomous
    services that aid in the functioning of the mini redirector.

    Scavenging -- The construction of the SMB mini redirector counterparts to SRV_CALL,
    NET_ROOT and V_NET_ROOT involve network traffic. Therefore the SMB mini redirector
    introduces a hystersis between the deletion of the data structures by the wrapper and
    effecting those changes in the mini redirector data structures and the remote server.
    This is done by transitioning the deleted data structures to a dormant state and
    scavenging them after a suitable interval( approximately 45 sec).

    Probing Servers -- Sometimes the server response to a client request is delayed. The
    mini redirector has a probing mechanism which enables it to cope with overloaded
    servers. When a response is not forthcoming from a server it sends it an ECHO SMB.
    Since the server can respond to an ECHO SMB without having to commit many resources,
    a reply to the ECHO SMB is interpreted as a sign that the server is indeed alive and
    well.

Notes:

    A recurrent service can be either periodic or aperiodic. The periodic services are
    triggered at regular time intervals. These services then perform some tasks if
    required. The advantage of having periodic recurrent services is the guarantee that
    work will get done and the disadvantage is that it consumes system resources when
    there is no work to be done. Also if the handling time happens to straddle the
    service time period multiple threads wil

    An aperiodic recurrent service is a one shot mechanism. The service once invoked gets
    to decide when the next invocation will be. The advantage of such services is that
    it provides an inbuilt throttling mechanism.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbInitializeRecurrentService)
#pragma alloc_text(PAGE, MRxSmbCancelRecurrentService)
#pragma alloc_text(PAGE, MRxSmbActivateRecurrentService)
#pragma alloc_text(PAGE, MRxSmbInitializeRecurrentServices)
#pragma alloc_text(PAGE, MRxSmbTearDownRecurrentServices)
#pragma alloc_text(PAGE, MRxSmbInitializeScavengerService)
#pragma alloc_text(PAGE, MRxSmbTearDownScavengerService)
#endif

MRXSMB_ECHO_PROBE_SERVICE_CONTEXT MRxSmbEchoProbeServiceContext;

MRXSMB_SCAVENGER_SERVICE_CONTEXT  MRxSmbScavengerServiceContext;

extern VOID
MRxSmbRecurrentServiceDispatcher(
    PVOID pContext);

VOID
MRxSmbInitializeRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext,
    PRECURRENT_SERVICE_ROUTINE pServiceRoutine,
    PVOID                      pServiceRoutineParameter,
    PLARGE_INTEGER             pTimeInterval)
/*++

Routine Description:

    This routine initializes a recurrent service

Arguments:

    pRecurrentServiceContext - the recurrent service to be initialized

    pServiceRoutine - the recurrent service routine

    pServiceRoutineParameter - the recurrent service routine parameter

    pTimeInterval - the time interval which controls the frequency of the recurrent
                    service

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    pRecurrentServiceContext->State = RECURRENT_SERVICE_DORMANT;

    pRecurrentServiceContext->pServiceRoutine = pServiceRoutine;
    pRecurrentServiceContext->pServiceRoutineParameter = pServiceRoutineParameter;
    pRecurrentServiceContext->Interval.QuadPart = pTimeInterval->QuadPart;

    // Initialize the cancel completion event associated with the service
    KeInitializeEvent(
        &pRecurrentServiceContext->CancelCompletionEvent,
        NotificationEvent,
        FALSE);
}

VOID
MRxSmbCancelRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext)
/*++

Routine Description:

    This routine cancels a recurrent service

Arguments:

    pRecurrentServiceContext - the recurrent service to be initialized

Notes:

    When the cancel request is handled the recurrent service can be in one
    of two states -- either active or on the timer queue awaiting dispatch.

    The service state is changed and an attempt is made to cancel the service
    in the timer queue and if it fails this request is suspended till the
    active invocation of the service is completed

--*/
{
    NTSTATUS Status;
    LONG    State;

    PAGED_CODE();

    State = InterlockedCompareExchange(
                &pRecurrentServiceContext->State,
                RECURRENT_SERVICE_CANCELLED,
                RECURRENT_SERVICE_ACTIVE);

    if (State == RECURRENT_SERVICE_ACTIVE) {
        // Cancel the echo processing timer request.
        Status = RxCancelTimerRequest(
                     MRxSmbDeviceObject,
                     MRxSmbRecurrentServiceDispatcher,
                     pRecurrentServiceContext);

        if (Status != STATUS_SUCCESS) {
            // The request is currently active. Wait for it to be completed.
            KeWaitForSingleObject(
                &pRecurrentServiceContext->CancelCompletionEvent,
                Executive,
                KernelMode,
                FALSE,
                NULL);
        }
    }
}

VOID
MRxSmbRecurrentServiceDispatcher(
    PVOID   pContext)
/*++

Routine Description:

    This routine dispatches the recurrent service

Arguments:

    pRecurrentServiceContext - the recurrent service to be initialized

Notes:

    The dispatcher provides a centralized location for monitoring the state
    of the recurrent service prior to and after invocation. Based on the
    state a decision as to whether a subsequent request must be posted
    is made.

--*/
{
    NTSTATUS Status;

    PRECURRENT_SERVICE_CONTEXT  pRecurrentServiceContext;

    LONG State;

    pRecurrentServiceContext = (PRECURRENT_SERVICE_CONTEXT)pContext;

    State = InterlockedCompareExchange(
                &pRecurrentServiceContext->State,
                RECURRENT_SERVICE_ACTIVE,
                RECURRENT_SERVICE_ACTIVE);

    // If the state of the service is active invoke the handler
    if (State == RECURRENT_SERVICE_ACTIVE) {
        Status = (pRecurrentServiceContext->pServiceRoutine)(
                      pRecurrentServiceContext->pServiceRoutineParameter);

        State = InterlockedCompareExchange(
                    &pRecurrentServiceContext->State,
                    RECURRENT_SERVICE_ACTIVE,
                    RECURRENT_SERVICE_ACTIVE);

        if (State == RECURRENT_SERVICE_ACTIVE) {
            // If the service is still active and further continuation
            // was desired by the handler post another timer request
            if (Status == STATUS_SUCCESS) {
                Status = RxPostOneShotTimerRequest(
                             MRxSmbDeviceObject,
                             &pRecurrentServiceContext->WorkItem,
                             MRxSmbRecurrentServiceDispatcher,
                             pRecurrentServiceContext,
                             pRecurrentServiceContext->Interval);
            } else {
                do {
                    State = InterlockedCompareExchange(
                                &pRecurrentServiceContext->State,
                                RECURRENT_SERVICE_DORMANT,
                                State);
                } while (State != RECURRENT_SERVICE_DORMANT);
            }
        }
    }

    if (State == RECURRENT_SERVICE_CANCELLED) {
        // if the recurrent service was cancelled resume the cancel request
        KeSetEvent(
             &pRecurrentServiceContext->CancelCompletionEvent,
             0,
             FALSE );
    }
}

NTSTATUS
MRxSmbActivateRecurrentService(
    PRECURRENT_SERVICE_CONTEXT pRecurrentServiceContext)
/*++

Routine Description:

    This routine activates a recurrent service

Arguments:

    pRecurrentServiceContext - the recurrent service to be initialized

Notes:

--*/
{
    NTSTATUS Status;
    LONG    State;

    PAGED_CODE();

    State = InterlockedCompareExchange(
                &pRecurrentServiceContext->State,
                RECURRENT_SERVICE_ACTIVE,
                RECURRENT_SERVICE_DORMANT);

    if (State == RECURRENT_SERVICE_DORMANT) {
        Status = RxPostOneShotTimerRequest(
                     MRxSmbDeviceObject,
                     &pRecurrentServiceContext->WorkItem,
                     MRxSmbRecurrentServiceDispatcher,
                     pRecurrentServiceContext,
                     pRecurrentServiceContext->Interval);
    } else if (State == RECURRENT_SERVICE_ACTIVE) {
        Status = STATUS_SUCCESS;
    } else if (State == RECURRENT_SERVICE_CANCELLED) {
        Status = STATUS_CANCELLED;
    }
    else if (State == RECURRENT_SERVICE_SHUTDOWN) {
        Status = STATUS_UNSUCCESSFUL;
    } else {
        ASSERT(!"Valid State for Recurrent Service");
        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}

NTSTATUS
MRxSmbInitializeRecurrentServices()
/*++

Routine Description:

    This routine initializes all the recurrent services associated with the SMB
    mini redirector

Notes:

--*/
{
    NTSTATUS Status;

    LARGE_INTEGER RecurrentServiceInterval;

    BOOLEAN       fEchoProbeServiceInitialized = FALSE;
    BOOLEAN       fScavengerServiceInitialized = FALSE;

    PAGED_CODE();

    try {
        RecurrentServiceInterval.QuadPart = 30 * 1000 * 10000; // 30 seconds in 100 ns intervals

        MRxSmbInitializeRecurrentService(
            &MRxSmbEchoProbeServiceContext.RecurrentServiceContext,
            SmbCeProbeServers,
            &MRxSmbEchoProbeServiceContext,
            &RecurrentServiceInterval);

        Status = MRxSmbInitializeEchoProbeService(
                    &MRxSmbEchoProbeServiceContext);

        if (Status == STATUS_SUCCESS) {
            fEchoProbeServiceInitialized = TRUE;

            Status = MRxSmbActivateRecurrentService(
                         &MRxSmbEchoProbeServiceContext.RecurrentServiceContext);
        }

        if (Status != STATUS_SUCCESS) {
            try_return(Status);
        }

        MRxSmbInitializeRecurrentService(
            &MRxSmbScavengerServiceContext.RecurrentServiceContext,
            SmbCeScavenger,
            &MRxSmbScavengerServiceContext,
            &RecurrentServiceInterval);

        Status = MRxSmbInitializeScavengerService(
                     &MRxSmbScavengerServiceContext);

        if (Status == STATUS_SUCCESS) {
            fScavengerServiceInitialized = TRUE;
        }

    try_exit: NOTHING;
    } finally {
        if (Status != STATUS_SUCCESS) {
            if (fEchoProbeServiceInitialized) {
                SmbCeLog(("Tearing down Echo Probe Service\n"));
                MRxSmbTearDownEchoProbeService(
                    &MRxSmbEchoProbeServiceContext);
            }
        }
    };

    return Status;
}

VOID
MRxSmbTearDownRecurrentServices()
/*++

Routine Description:

    This routine tears down the recurrent services associated with the
    SMB mini redirector

Notes:

--*/
{
    PAGED_CODE();

    MRxSmbCancelRecurrentService(
        &MRxSmbEchoProbeServiceContext.RecurrentServiceContext);

    MRxSmbEchoProbeServiceContext.RecurrentServiceContext.State = RECURRENT_SERVICE_SHUTDOWN;

    MRxSmbTearDownEchoProbeService(
        &MRxSmbEchoProbeServiceContext);

    MRxSmbCancelRecurrentService(
        &MRxSmbScavengerServiceContext.RecurrentServiceContext);

    MRxSmbScavengerServiceContext.RecurrentServiceContext.State = RECURRENT_SERVICE_SHUTDOWN;

    MRxSmbTearDownScavengerService(
        &MRxSmbScavengerServiceContext);
}


NTSTATUS
MRxSmbInitializeScavengerService(
    PMRXSMB_SCAVENGER_SERVICE_CONTEXT pScavengerServiceContext)
/*++

Routine Description:

    This routine initializes the scavenger recurrent service

Arguments:

    pScavengerServiceContext - the recurrent service to be initialized

Notes:

--*/
{
    PAGED_CODE();

    InitializeListHead(
        &pScavengerServiceContext->VNetRootContexts.ListHead);

    return STATUS_SUCCESS;
}

VOID
MRxSmbTearDownScavengerService(
    PMRXSMB_SCAVENGER_SERVICE_CONTEXT pScavengerServiceContext)
/*++

Routine Description:

    This routine tears down the scavenger recurrent service

Arguments:

    pScavengerServiceContext - the recurrent service to be initialized

Notes:

--*/
{
    PAGED_CODE();

    SmbCeScavenger(pScavengerServiceContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\openclos.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    openclos.c

Abstract:

    This module implements the mini redirector call down routines pertaining to opening/
    closing of file/directories.

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbMungeBufferingIfWriteOnlyHandles)
#pragma alloc_text(PAGE, IsReconnectRequired)
#pragma alloc_text(PAGE, MRxSmbIsCreateWithEasSidsOrLongName)
#pragma alloc_text(PAGE, MRxSmbShouldTryToCollapseThisOpen)
#pragma alloc_text(PAGE, MRxSmbCreate)
#pragma alloc_text(PAGE, MRxSmbDeferredCreate)
#pragma alloc_text(PAGE, MRxSmbCollapseOpen)
#pragma alloc_text(PAGE, MRxSmbComputeNewBufferingState)
#pragma alloc_text(PAGE, MRxSmbConstructDeferredOpenContext)
#pragma alloc_text(PAGE, MRxSmbAdjustCreateParameters)
#pragma alloc_text(PAGE, MRxSmbAdjustReturnedCreateAction)
#pragma alloc_text(PAGE, MRxSmbBuildNtCreateAndX)
#pragma alloc_text(PAGE, MRxSmbBuildOpenAndX)
#pragma alloc_text(PAGE, SmbPseExchangeStart_Create)
#pragma alloc_text(PAGE, MRxSmbSetSrvOpenFlags)
#pragma alloc_text(PAGE, MRxSmbCreateFileSuccessTail)
#pragma alloc_text(PAGE, MRxSmbFinishNTCreateAndX)
#pragma alloc_text(PAGE, MRxSmbFinishOpenAndX)
#pragma alloc_text(PAGE, MRxSmbFinishT2OpenFile)
#pragma alloc_text(PAGE, MRxSmbT2OpenFile)
#pragma alloc_text(PAGE, MRxSmbFinishLongNameCreateFile)
#pragma alloc_text(PAGE, MRxSmbCreateWithEasSidsOrLongName)
#pragma alloc_text(PAGE, MRxSmbZeroExtend)
#pragma alloc_text(PAGE, MRxSmbTruncate)
#pragma alloc_text(PAGE, MRxSmbCleanupFobx)
#pragma alloc_text(PAGE, MRxSmbForcedClose)
#pragma alloc_text(PAGE, MRxSmbCloseSrvOpen)
#pragma alloc_text(PAGE, MRxSmbBuildClose)
#pragma alloc_text(PAGE, MRxSmbBuildFindClose)
#pragma alloc_text(PAGE, SmbPseExchangeStart_Close)
#pragma alloc_text(PAGE, MRxSmbFinishClose)
#endif


//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

// forwards

NTSTATUS
SmbPseExchangeStart_Create(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
SmbPseExchangeStart_Close(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbCreateWithEasSidsOrLongName(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbDownlevelCreate(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

ULONG   MRxSmbInitialSrvOpenFlags = 0;

BOOLEAN MRxSmbDeferredOpensEnabled = TRUE;              //this is regedit-able
BOOLEAN MRxSmbOplocksDisabled = FALSE;                  //this is regedit-able

extern LIST_ENTRY MRxSmbPagingFilesSrvOpenList;

#ifndef FORCE_NO_NTCREATE
#define MRxSmbForceNoNtCreate FALSE
#else
BOOLEAN MRxSmbForceNoNtCreate = TRUE;
#endif


#ifdef RX_PRIVATE_BUILD
//#define FORCE_SMALL_BUFFERS
#endif //#ifdef RX_PRIVATE_BUILD

#ifndef FORCE_SMALL_BUFFERS

//use size calculated from the negotiated size
ULONG MrxSmbLongestShortName = 0xffff;

//use the negotiated size
ULONG MrxSmbCreateTransactPacketSize = 0xffff;

#else

ULONG MrxSmbLongestShortName = 0;
ULONG MrxSmbCreateTransactPacketSize = 100;

#endif


LONG MRxSmbNumberOfSrvOpens = 0;

INLINE VOID
MRxSmbIncrementSrvOpenCount(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PMRX_SRV_OPEN         SrvOpen)
{
    LONG NumberOfSrvOpens;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    if (!FlagOn(smbSrvOpen->FileInfo.Basic.FileAttributes,
                FILE_ATTRIBUTE_DIRECTORY)) {
        ASSERT(!smbSrvOpen->NumOfSrvOpenAdded);
        smbSrvOpen->NumOfSrvOpenAdded = TRUE;

        InterlockedIncrement(&pServerEntry->Server.NumberOfSrvOpens);

        NumberOfSrvOpens = InterlockedIncrement(&MRxSmbNumberOfSrvOpens);

        if (NumberOfSrvOpens == 1) {
            PoRegisterSystemState(
                MRxSmbPoRegistrationState,
                (ES_SYSTEM_REQUIRED | ES_CONTINUOUS));
        }
    }
}

VOID
MRxSmbDecrementSrvOpenCount(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    LONG                  SrvOpenServerVersion,
    PMRX_SRV_OPEN         SrvOpen)
{
    LONG NumberOfSrvOpens;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    if (!FlagOn(smbSrvOpen->FileInfo.Basic.FileAttributes,
                FILE_ATTRIBUTE_DIRECTORY)) {
        ASSERT(smbSrvOpen->NumOfSrvOpenAdded);
        smbSrvOpen->NumOfSrvOpenAdded = FALSE;

        if (SrvOpenServerVersion == (LONG)pServerEntry->Server.Version) {
            ASSERT(pServerEntry->Server.NumberOfSrvOpens > 0);

            InterlockedDecrement(&pServerEntry->Server.NumberOfSrvOpens);
        }

        NumberOfSrvOpens = InterlockedDecrement(&MRxSmbNumberOfSrvOpens);

        if (NumberOfSrvOpens == 0) {
            PoRegisterSystemState(
                MRxSmbPoRegistrationState,
                ES_CONTINUOUS);
        }
    }
}

INLINE VOID
MRxSmbMungeBufferingIfWriteOnlyHandles (
    ULONG WriteOnlySrvOpenCount,
    PMRX_SRV_OPEN SrvOpen
    )
/*++

Routine Description:

   This routine modifies the buffering flags on a srvopen so that
   no cacheing will be allowed if there are any write-only handles
   to the file.

Arguments:

    WriteOnlySrvOpenCount - the number of writeonly srvopens

    SrvOpen - the srvopen whose buffring flags are to be munged

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    BOOLEAN IsLoopBack = FALSE;
    PMRX_SRV_CALL pSrvCall;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    pSrvCall = SrvOpen->pVNetRoot->pNetRoot->pSrvCall;

    pServerEntry = SmbCeGetAssociatedServerEntry(pSrvCall);

    IsLoopBack = pServerEntry->Server.IsLoopBack;

    if (IsLoopBack || (WriteOnlySrvOpenCount != 0)) {
        SrvOpen->BufferingFlags &=
           ~( FCB_STATE_WRITECACHEING_ENABLED  |
              FCB_STATE_FILESIZECACHEING_ENABLED |
              FCB_STATE_FILETIMECACHEING_ENABLED |
              FCB_STATE_LOCK_BUFFERING_ENABLED |
              FCB_STATE_READCACHEING_ENABLED |
              FCB_STATE_COLLAPSING_ENABLED
            );
    }
}


INLINE BOOLEAN
IsReconnectRequired(
      PMRX_SRV_CALL SrvCall)
/*++

Routine Description:

   This routine determines if a reconnect is required to a given server

Arguments:

    SrvCall - the SRV_CALL instance

Return Value:

    TRUE if a reconnect is required

--*/
{
   BOOLEAN ReconnectRequired = FALSE;
   PSMBCEDB_SERVER_ENTRY pServerEntry;

   PAGED_CODE();

   pServerEntry = SmbCeGetAssociatedServerEntry(SrvCall);
   if (pServerEntry != NULL) {
      ReconnectRequired = (pServerEntry->Header.State != SMBCEDB_ACTIVE);
   }

   return ReconnectRequired;
}


BOOLEAN
MRxSmbIsCreateWithEasSidsOrLongName(
    IN OUT PRX_CONTEXT RxContext,
    OUT    PULONG      DialectFlags
    )
/*++

Routine Description:

    This routine determines if the create operation involves EA's or security
    desriptors. In such cases a separate protocol is required

Arguments:

    RxContext - the RX_CONTEXT instance

    DialectFlags - the dialect flags associated with the server

Return Value:

    TRUE if a reconnect is required

--*/
{
    RxCaptureFcb;

    ULONG LongestShortName,LongestShortNameFromSrvBufSize;

    PMRX_SRV_CALL SrvCall = (PMRX_SRV_CALL)RxContext->Create.pSrvCall;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    pServerEntry = SmbCeGetAssociatedServerEntry(SrvCall);

    ASSERT(pServerEntry != NULL);

    *DialectFlags = pServerEntry->Server.DialectFlags;


    // DOWN.LEVEL if the server takes OEM names or we use a different protocol
    // this would have to be different. maybe a switch or a precompute.

    LongestShortNameFromSrvBufSize =
        MAXIMUM_SMB_BUFFER_SIZE -
        QuadAlign(sizeof(NT_SMB_HEADER) +
                  FIELD_OFFSET(REQ_NT_CREATE_ANDX,Buffer[0])
                 );

    LongestShortName = min(MrxSmbLongestShortName,LongestShortNameFromSrvBufSize);

    return (RxContext->Create.EaLength  ||
            RxContext->Create.SdLength  ||
            RemainingName->Length > LongestShortName);
}

NTSTATUS
MRxSmbShouldTryToCollapseThisOpen (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine determines if the mini knows of a good reason not
   to try collapsing on this open.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation
        SUCCESS --> okay to try collapse
        other (MORE_PROCESSING_REQUIRED) --> dont collapse

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PMRX_SRV_OPEN           SrvOpen = RxContext->pRelevantSrvOpen;
    RxCaptureFcb;

    PAGED_CODE();

    if (SrvOpen)
    {
        PMRX_SMB_SRV_OPEN       smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
        PSMBCEDB_SERVER_ENTRY   pServerEntry = (PSMBCEDB_SERVER_ENTRY)(RxContext->Create.pSrvCall->Context);

        if (smbSrvOpen->Version != pServerEntry->Server.Version)
        {
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
    }

    return Status;
}

NTSTATUS
MRxSmbCreate (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine opens a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;

    PMRX_SRV_OPEN           SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN       smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SRV_CALL           SrvCall = RxContext->Create.pSrvCall;
    PSMBCEDB_SERVER_ENTRY   pServerEntry = (PSMBCEDB_SERVER_ENTRY)SrvCall->Context;
    PMRX_NET_ROOT           NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    PMRX_V_NET_ROOT         pVNetRoot = SrvOpen->pVNetRoot;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;
    PSMBCEDB_SESSION_ENTRY  pSessionEntry ;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = NULL;

    BOOLEAN         ReconnectRequired;
    BOOLEAN         CreateWithEasSidsOrLongName = FALSE;
    ULONG           DialectFlags;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

    PNT_CREATE_PARAMETERS CreateParameters = &RxContext->Create.NtCreateParameters;
    ULONG                 Disposition = CreateParameters->Disposition;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbCreate\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    RxDbgTrace( 0, Dbg, ("     Attempt to open %wZ\n", RemainingName ));

    if (FlagOn( capFcb->FcbState, FCB_STATE_PAGING_FILE )) {
        return STATUS_NOT_IMPLEMENTED;
    }

    if (!FlagOn(pServerEntry->Server.DialectFlags,DF_NT_STATUS) &&
        MRxSmbIsStreamFile(RemainingName,NULL)) {
        // The Samba server return file system type NTFS but doesn't support stream
        return STATUS_OBJECT_PATH_NOT_FOUND;
    }

    RxContext->Create.NtCreateParameters.CreateOptions &= 0xfffff;

    if( NetRoot->Type == NET_ROOT_PRINT ) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    // we cannot have a file cached on a write only handle. so we have to behave a little
    // differently if this is a write-only open. remember this in the smbsrvopen

    if (  ((CreateParameters->DesiredAccess & (FILE_EXECUTE  | FILE_READ_DATA)) == 0) &&
          ((CreateParameters->DesiredAccess & (FILE_WRITE_DATA | FILE_APPEND_DATA)) != 0)
       ) {

        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_WRITE_ONLY_HANDLE);
        SrvOpen->Flags |= SRVOPEN_FLAG_DONTUSE_WRITE_CACHEING;
    }

    //the way that SMBs work, there is no buffering effect if we open for attributes-only
    //so set that up immediately.

    if ((CreateParameters->DesiredAccess
         & ~(FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE))
                  == 0 ){
        SetFlag(SrvOpen->Flags,SRVOPEN_FLAG_NO_BUFFERING_STATE_CHANGE);
    }

    if (NetRoot->Type == NET_ROOT_MAILSLOT) {
        return STATUS_NOT_SUPPORTED;
    }

    if (NetRoot->Type == NET_ROOT_PIPE) {
        return STATUS_NOT_SUPPORTED;
    }

    // Get the control struct for the file not found name cache.
    //
    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);

    // assume Reconnection to be trivially successful
    Status = STATUS_SUCCESS;

    CreateWithEasSidsOrLongName = MRxSmbIsCreateWithEasSidsOrLongName(RxContext,&DialectFlags);

    if (!FlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS)) {
        CreateWithEasSidsOrLongName = FALSE;
    }

    ReconnectRequired           = IsReconnectRequired((PMRX_SRV_CALL)SrvCall);

    //get rid of nonEA guys right now
    if (RxContext->Create.EaLength && !FlagOn(DialectFlags,DF_SUPPORTEA)) {
         RxDbgTrace(-1, Dbg, ("EAs w/o EA support!\n"));
         Status = STATUS_NOT_SUPPORTED;
         goto FINALLY;
    }

    if (ReconnectRequired || !CreateWithEasSidsOrLongName) {
        Status = __SmbPseCreateOrdinaryExchange(
                               RxContext,
                               SrvOpen->pVNetRoot,
                               SMBPSE_OE_FROM_CREATE,
                               SmbPseExchangeStart_Create,
                               &OrdinaryExchange);

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
            goto FINALLY;
        }
        OrdinaryExchange->Create.CreateWithEasSidsOrLongName = CreateWithEasSidsOrLongName;

        // For Creates, the resources need to be reacquired after sending an
        // SMB; so, do not hold onto the MIDS till finalization; instead give the MID back
        // right away

        OrdinaryExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_REUSE_MID;
        OrdinaryExchange->SmbCeFlags |= (SMBCE_EXCHANGE_ATTEMPT_RECONNECTS |
                                         SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION);
        OrdinaryExchange->pSmbCeSynchronizationEvent = &RxContext->SyncEvent;

        // drop the resource before you go in!
        // the start routine will reacquire it on the way out.....
        RxReleaseFcbResourceInMRx( capFcb );

        Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

        ASSERT((Status != STATUS_SUCCESS) || RxIsFcbAcquiredExclusive( capFcb ));

        OrdinaryExchange->pSmbCeSynchronizationEvent = NULL;

        SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);

        if (!RxIsFcbAcquiredExclusive(capFcb)) {
            ASSERT(!RxIsFcbAcquiredShared(capFcb));
            RxAcquireExclusiveFcbResourceInMRx( capFcb );
        }
    }

    if (CreateWithEasSidsOrLongName && (Status == STATUS_SUCCESS)) {
        Status = MRxSmbCreateWithEasSidsOrLongName(RxContext);

    }

    // There are certain downlevel servers(OS/2 servers) that return the error
    // STATUS_OPEN_FAILED. This is a context sensitive error code that needs to
    // be interpreted in conjunction with the disposition specified for the OPEN.

    if (Status == STATUS_OPEN_FAILED) {
        switch (Disposition) {

        //
        //  If we were asked to create the file, and got OPEN_FAILED,
        //  this implies that the file already exists.
        //

        case FILE_CREATE:
            Status = STATUS_OBJECT_NAME_COLLISION;
            break;

        //
        //  If we were asked to open the file, and got OPEN_FAILED,
        //  this implies that the file doesn't exist.
        //

        case FILE_OPEN:
        case FILE_SUPERSEDE:
        case FILE_OVERWRITE:
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            break;

        //
        //  If there is an error from either FILE_OPEN_IF or
        //  FILE_OVERWRITE_IF, it indicates the user is trying to
        //  open a file on a read-only share, so return the
        //  correct error for that.
        //

        case FILE_OPEN_IF:
        case FILE_OVERWRITE_IF:
            Status = STATUS_NETWORK_ACCESS_DENIED;
            break;

        default:
            break;
        }
    }

FINALLY:
    ASSERT(Status != (STATUS_PENDING));

    if (Status == STATUS_SUCCESS) {
        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_SUCCESSFUL_OPEN);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCreate  exit with status=%08lx\n", Status ));
    RxLog(("MRxSmbCreate exits %lx\n", Status));

    return(Status);
}

NTSTATUS
MRxSmbDeferredCreate (
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine constructs a rxcontext from saved information and then calls
   MRxSmbCreate.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SMB_FOBX        smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    PMRX_SRV_OPEN        SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_DEFERRED_OPEN_CONTEXT DeferredOpenContext = smbSrvOpen->DeferredOpenContext;
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    PRX_CONTEXT OpenRxContext,oc;

    PAGED_CODE();

    if ((!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)
          || !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DEFERRED_OPEN))) {

        Status = STATUS_SUCCESS;
        goto FINALLY;
    }

    if (DeferredOpenContext == NULL) {
        if (FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_CLOSED)) {
            Status = STATUS_FILE_CLOSED;
            goto FINALLY;
        } else {
            DbgBreakPoint();
        }
    }

    ASSERT(RxIsFcbAcquiredExclusive(capFcb));

    SmbCeAcquireResource();

    if (!smbSrvOpen->DeferredOpenInProgress) {
        PLIST_ENTRY pListHead;
        PLIST_ENTRY pListEntry;

        smbSrvOpen->DeferredOpenInProgress = TRUE;
        InitializeListHead(&smbSrvOpen->DeferredOpenSyncContexts);

        SmbCeReleaseResource();

        OpenRxContext = RxAllocatePoolWithTag(NonPagedPool,
                                              sizeof(RX_CONTEXT),
                                              MRXSMB_RXCONTEXT_POOLTAG);
        if (OpenRxContext==NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            RtlZeroMemory(
                OpenRxContext,
                sizeof(RX_CONTEXT));

            RxInitializeContext(
                NULL,
                RxContext->RxDeviceObject,
                0,
                OpenRxContext );

            oc = OpenRxContext;
            oc->pFcb = capFcb;
            oc->pFobx = capFobx;
            oc->NonPagedFcb = RxContext->NonPagedFcb;
            oc->MajorFunction = IRP_MJ_CREATE;
            oc->pRelevantSrvOpen = SrvOpen;
            oc->Create.pVNetRoot = SrvOpen->pVNetRoot;
            oc->Create.pNetRoot = oc->Create.pVNetRoot->pNetRoot;
            oc->Create.pSrvCall = oc->Create.pNetRoot->pSrvCall;

            oc->Flags = DeferredOpenContext->RxContextFlags;
            oc->Flags |= RX_CONTEXT_FLAG_MINIRDR_INITIATED|RX_CONTEXT_FLAG_WAIT|RX_CONTEXT_FLAG_BYPASS_VALIDOP_CHECK;
            oc->Create.Flags = DeferredOpenContext->RxContextCreateFlags;
            oc->Create.NtCreateParameters = DeferredOpenContext->NtCreateParameters;

            Status = MRxSmbCreate(oc);

            if (Status==STATUS_SUCCESS) {
                if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
                    MRxSmbIncrementSrvOpenCount(pServerEntry,SrvOpen);
                } else {
                    ASSERT(smbSrvOpen->NumOfSrvOpenAdded);
                }

                ClearFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN);
            }

            RxLog(("DeferredOpen %lx %lx %lx %lx\n", capFcb, capFobx, RxContext, Status));

            ASSERT(oc->ReferenceCount==1);

            RxFreePool(oc);
        }

        if (FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_CLOSED) ||
            FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_ORPHANED)) {
            RxFreePool(smbSrvOpen->DeferredOpenContext);
            smbSrvOpen->DeferredOpenContext = NULL;
            RxDbgTrace(0, Dbg, ("Free deferred open context for file %wZ %lX\n",GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext),smbSrvOpen));
        }

        SmbCeAcquireResource();
        smbSrvOpen->DeferredOpenInProgress = FALSE;

        pListHead = &smbSrvOpen->DeferredOpenSyncContexts;
        pListEntry = pListHead->Flink;

        while (pListEntry != pListHead) {
            PDEFERRED_OPEN_SYNC_CONTEXT pWaitingContext;

            pWaitingContext = (PDEFERRED_OPEN_SYNC_CONTEXT)CONTAINING_RECORD(
                                   pListEntry,
                                   DEFERRED_OPEN_SYNC_CONTEXT,
                                   ListHead);

            pListEntry = pListEntry->Flink;
            RemoveHeadList(&pWaitingContext->ListHead);

            pWaitingContext->Status = Status;

            //DbgPrint("Signal RxContext %x after deferred open\n",pWaitingContext->RxContext);
            RxSignalSynchronousWaiter(pWaitingContext->RxContext);
        }

        SmbCeReleaseResource();

    } else {
        DEFERRED_OPEN_SYNC_CONTEXT WaitingContext;
        BOOLEAN AcquireExclusive = RxIsFcbAcquiredExclusive(capFcb);
        BOOLEAN AcquireShare = RxIsFcbAcquiredShared(capFcb) > 0;

        // put the RxContext on the waiting list
        WaitingContext.RxContext = RxContext;
        InitializeListHead(&WaitingContext.ListHead);

        InsertTailList(
            &smbSrvOpen->DeferredOpenSyncContexts,
            &WaitingContext.ListHead);

        SmbCeReleaseResource();

        if (AcquireExclusive || AcquireShare) {
            RxReleaseFcbResourceInMRx( capFcb );
        }

        RxWaitSync(RxContext);

        Status = WaitingContext.Status;

        KeInitializeEvent(
            &RxContext->SyncEvent,
            SynchronizationEvent,
            FALSE);

        if (AcquireExclusive) {
            RxAcquireExclusiveFcbResourceInMRx(capFcb);
        } else if (AcquireShare) {
            RxAcquireSharedFcbResourceInMRx(capFcb);
        }
    }

FINALLY:
    return Status;
}


NTSTATUS
MRxSmbCollapseOpen(
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine collapses a open locally

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureFcb;

    RX_BLOCK_CONDITION FinalSrvOpenCondition;

    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SRV_CALL SrvCall = RxContext->Create.pSrvCall;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;

    PAGED_CODE();

    RxContext->pFobx = (PMRX_FOBX)RxCreateNetFobx( RxContext, SrvOpen);

    if (RxContext->pFobx != NULL) {
       ASSERT  ( RxIsFcbAcquiredExclusive ( capFcb )  );
       RxContext->pFobx->OffsetOfNextEaToReturn = 1;
       Status = STATUS_SUCCESS;
    } else {
       Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
MRxSmbComputeNewBufferingState(
   IN OUT PMRX_SRV_OPEN   pMRxSrvOpen,
   IN     PVOID           pMRxContext,
      OUT PULONG          pNewBufferingState)
/*++

Routine Description:

   This routine maps the SMB specific oplock levels into the appropriate RDBSS
   buffering state flags

Arguments:

   pMRxSrvOpen - the MRX SRV_OPEN extension

   pMRxContext - the context passed to RDBSS at Oplock indication time

   pNewBufferingState - the place holder for the new buffering state

Return Value:


Notes:

--*/
{
    ULONG OplockLevel,NewBufferingState;

    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(pMRxSrvOpen);
    PMRX_SMB_FCB      smbFcb     = MRxSmbGetFcbExtension(pMRxSrvOpen->pFcb);

    PAGED_CODE();

    ASSERT(pNewBufferingState != NULL);

    OplockLevel = PtrToUlong(pMRxContext);

    if (OplockLevel == SMB_OPLOCK_LEVEL_II) {
        NewBufferingState = (FCB_STATE_READBUFFERING_ENABLED  |
                             FCB_STATE_READCACHEING_ENABLED);
    } else {
        NewBufferingState = 0;
    }

    pMRxSrvOpen->BufferingFlags = NewBufferingState;

    MRxSmbMungeBufferingIfWriteOnlyHandles(
        smbFcb->WriteOnlySrvOpenCount,
        pMRxSrvOpen);

    *pNewBufferingState = pMRxSrvOpen->BufferingFlags;

    return STATUS_SUCCESS;
}

NTSTATUS
MRxSmbConstructDeferredOpenContext (
    PRX_CONTEXT RxContext)
/*++

Routine Description:

    This routine saves enough state that we can come back later and really do an
    open if needed. We only do this for NT servers.

Arguments:

    OrdinaryExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFobx;

    PMRX_SRV_OPEN         SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN     smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBCEDB_SERVER_ENTRY pServerEntry = (PSMBCEDB_SERVER_ENTRY)RxContext->Create.pSrvCall->Context;
    PSMBCE_SERVER         pServer = &pServerEntry->Server;

    PMRX_SMB_DEFERRED_OPEN_CONTEXT DeferredOpenContext;
    PDFS_NAME_CONTEXT   pDNC=NULL;
    DWORD       cbSize;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbConstructDeferredOpenContext\n"));

    ASSERT(smbSrvOpen->DeferredOpenContext == NULL);

    cbSize = sizeof(MRX_SMB_DEFERRED_OPEN_CONTEXT);

    // if there is a dfs name context, we need to allocate memory
    // fot aht too, because the name that is included in the
    // context is deallocated by DFS when it returns from the create call

    if(pDNC = RxContext->Create.NtCreateParameters.DfsNameContext)
    {
        cbSize += (sizeof(DFS_NAME_CONTEXT)+pDNC->UNCFileName.MaximumLength+sizeof(DWORD));
    }

    DeferredOpenContext = RxAllocatePoolWithTag(
                              NonPagedPool,
                              cbSize,
                              MRXSMB_DEFROPEN_POOLTAG);

    if (DeferredOpenContext == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    smbSrvOpen->DeferredOpenContext = DeferredOpenContext;
    DeferredOpenContext->NtCreateParameters = RxContext->Create.NtCreateParameters;
    DeferredOpenContext->RxContextCreateFlags = RxContext->Create.Flags;
    DeferredOpenContext->RxContextFlags = RxContext->Flags;
    DeferredOpenContext->NtCreateParameters.SecurityContext = NULL;
    MRxSmbAdjustCreateParameters(RxContext, &DeferredOpenContext->SmbCp);

    SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DEFERRED_OPEN);
    if (pDNC)
    {
        PDFS_NAME_CONTEXT   pDNCDeferred=NULL;

        // point the dfs name context after the rxcontext

        pDNCDeferred = (PDFS_NAME_CONTEXT)((PBYTE)DeferredOpenContext+sizeof(MRX_SMB_DEFERRED_OPEN_CONTEXT));
        DeferredOpenContext->NtCreateParameters.DfsNameContext = pDNCDeferred;

        // copy the info
        *pDNCDeferred = *pDNC;

        if (pDNC->UNCFileName.Length)
        {
            ASSERT(pDNC->UNCFileName.Buffer);

            // point the name buffer after deferredcontext+dfs_name_context

            pDNCDeferred->UNCFileName.Buffer = (PWCHAR)((PBYTE)pDNCDeferred+sizeof(DFS_NAME_CONTEXT));

            memcpy(pDNCDeferred->UNCFileName.Buffer,
                   pDNC->UNCFileName.Buffer,
                   pDNC->UNCFileName.Length);

        }

    }


 FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbConstructDeferredOpenContext, Status=%08lx\n",Status));
    return Status;
}

VOID
MRxSmbAdjustCreateParameters (
    PRX_CONTEXT RxContext,
    PMRXSMB_CREATE_PARAMETERS smbcp
    )
/*++

Routine Description:

   This uses the RxContext as a base to reeach out and get the values of the NT
   create parameters. It also (a) implements the SMB idea that unbuffered is
   translated to write-through and (b) gets the SMB security flags.

Arguments:


Return Value:


Notes:

--*/
{
    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbAdjustCreateParameters\n"));

    if (!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_MINIRDR_INITIATED)) {
        cp->CreateOptions = cp->CreateOptions & ~(FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT);

        //the NT SMB spec says we have to change no-intermediate-buffering to write-through
        if (FlagOn(cp->CreateOptions,FILE_NO_INTERMEDIATE_BUFFERING)) {
            ASSERT (RxContext->CurrentIrpSp!=NULL);
            if (RxContext->CurrentIrpSp!=NULL) {
                PFILE_OBJECT capFileObject = RxContext->CurrentIrpSp->FileObject;
                ClearFlag(cp->CreateOptions,FILE_NO_INTERMEDIATE_BUFFERING);
                SetFlag(cp->CreateOptions,FILE_WRITE_THROUGH);
                SetFlag(RxContext->Flags,RX_CONTEXT_FLAG_WRITE_THROUGH);
                SetFlag(capFileObject->Flags,FO_WRITE_THROUGH);
            }
        }

        smbcp->Pid = RxGetRequestorProcessId(RxContext);
        smbcp->SecurityFlags = 0;
        if (cp->SecurityContext != NULL) {
            if (cp->SecurityContext->SecurityQos != NULL) {
                if (cp->SecurityContext->SecurityQos->ContextTrackingMode == SECURITY_DYNAMIC_TRACKING) {
                    smbcp->SecurityFlags |= SMB_SECURITY_DYNAMIC_TRACKING;
                }
                if (cp->SecurityContext->SecurityQos->EffectiveOnly) {
                    smbcp->SecurityFlags |= SMB_SECURITY_EFFECTIVE_ONLY;
                }
            }
        }

    } else {

        //here, we have a defered open!!!

        PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
        PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

        //the parameters have already been adjusted...BUT null the security context.......
        cp->SecurityContext = NULL;
        *smbcp = smbSrvOpen->DeferredOpenContext->SmbCp;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbAdjustCreateParameters\n"));
}

INLINE VOID
MRxSmbAdjustReturnedCreateAction(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine repairs a bug in NT servers whereby the create action is
   contaminated by an oplock break. Basically, we make sure that if the guy
   asked for FILE_OPEN and it works then he does not get FILE_SUPERCEDED or
   FILE_CREATED as the result.

Arguments:

    RxContext - the context for the operation so as to find the place where
                info is returned

Return Value:

    none

Notes:

--*/
{
    ULONG q = RxContext->Create.ReturnedCreateInformation;

    PAGED_CODE();

    if ((q==FILE_SUPERSEDED)||(q==FILE_CREATED)||(q >FILE_MAXIMUM_DISPOSITION)) {
        RxContext->Create.ReturnedCreateInformation = FILE_OPENED;
    }
}

UNICODE_STRING UnicodeBackslash = {2,4,L"\\"};

NTSTATUS
MRxSmbBuildNtCreateAndX (
    PSMBSTUFFER_BUFFER_STATE StufferState,
    PMRXSMB_CREATE_PARAMETERS smbcp
    )
/*++

Routine Description:

   This builds an NtCreateAndX SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   NTSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:

--*/
{
    NTSTATUS Status;

    PRX_CONTEXT RxContext = StufferState->RxContext;
    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;

    RxCaptureFcb;

    ACCESS_MASK DesiredAccess;
    ULONG       OplockFlags;

    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PSMBCE_SERVER pServer;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbBuildNtCreateAndX\n", 0 ));

    pServer = SmbCeGetExchangeServer(StufferState->Exchange);

    if (!(cp->CreateOptions & FILE_DIRECTORY_FILE) &&
        (cp->DesiredAccess & (FILE_READ_DATA | FILE_WRITE_DATA | FILE_EXECUTE )) &&
        !MRxSmbOplocksDisabled) {

       DesiredAccess = cp->DesiredAccess & ~SYNCHRONIZE;
       OplockFlags   = (NT_CREATE_REQUEST_OPLOCK | NT_CREATE_REQUEST_OPBATCH);

    } else {

       DesiredAccess = cp->DesiredAccess;
       OplockFlags   = 0;

    }

    if ((RemainingName->Length==0)
           && (FlagOn(RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_STRIPPED_TRAILING_BACKSLASH)) ) {
        RemainingName = &UnicodeBackslash;
    }
    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_Never,
                                SMB_COM_NT_CREATE_ANDX, SMB_REQUEST_SIZE(NT_CREATE_ANDX),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(4,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );
    SmbCeSetFullProcessIdInHeader(
        StufferState->Exchange,
        smbcp->Pid,
        ((PNT_SMB_HEADER)StufferState->BufferBase));

    MRxSmbStuffSMB (StufferState,
       "XmwdddDdddDddyB",
                                  //  X         UCHAR WordCount;                    // Count of parameter words = 24
                                  //  .         UCHAR AndXCommand;                  // Secondary command; 0xFF = None
                                  //  .         UCHAR AndXReserved;                 // MBZ
                                  //  .         _USHORT( AndXOffset );              // Offset to next command wordcount
                                  //  m         UCHAR Reserved;                     // MBZ
           BooleanFlagOn(pServer->DialectFlags,DF_UNICODE)?
               RemainingName->Length:RtlxUnicodeStringToOemSize(RemainingName),
                                  //  w         _USHORT( NameLength );              // Length of Name[] in bytes
           OplockFlags,           //  d         _ULONG( Flags );                    // Create flags
           0, //not used          //  d         _ULONG( RootDirectoryFid );         // If non-zero, open is relative to this directory
           DesiredAccess,         //  d         ACCESS_MASK DesiredAccess;          // NT access desired
                                  //  Dd        LARGE_INTEGER AllocationSize;       // Initial allocation size
           SMB_OFFSET_CHECK(NT_CREATE_ANDX,AllocationSize)
           cp->AllocationSize.LowPart, cp->AllocationSize.HighPart,
           cp->FileAttributes,    //  d         _ULONG( FileAttributes );           // File attributes for creation
           cp->ShareAccess,       //  d         _ULONG( ShareAccess );              // Type of share access
                                  //  D         _ULONG( CreateDisposition );        // Action to take if file exists or not
           SMB_OFFSET_CHECK(NT_CREATE_ANDX,CreateDisposition)
           cp->Disposition,
           cp->CreateOptions,     //  d         _ULONG( CreateOptions );            // Options to use if creating a file
           cp->ImpersonationLevel,//  d         _ULONG( ImpersonationLevel );       // Security QOS information
           smbcp->SecurityFlags,  //  y         UCHAR SecurityFlags;                // Security QOS information
           SMB_WCT_CHECK(24) 0    //  B         _USHORT( ByteCount );               // Length of byte parameters
                                  //  .         UCHAR Buffer[1];
                                  //  .         //UCHAR Name[];                       // File to open or create
           );

    //proceed with the stuff because we know here that the name fits

    MRxSmbStuffSMB(StufferState,
                   BooleanFlagOn(pServer->DialectFlags,DF_UNICODE)?"u!":"z!",
                   RemainingName);

    MRxSmbDumpStufferState (700,"SMB w/ NTOPEN&X after stuffing",StufferState);

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}


NTSTATUS
MRxSmbBuildOpenAndX (
    PSMBSTUFFER_BUFFER_STATE StufferState,
    PMRXSMB_CREATE_PARAMETERS smbcp
    )
/*++

Routine Description:

   This builds an OpenAndX SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:

--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;
    PSMB_EXCHANGE Exchange = StufferState->Exchange;
    RxCaptureFcb;

    PSMBCE_SERVER pServer;

    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    USHORT smbDisposition;
    USHORT smbSharingMode;
    USHORT smbAttributes;
    ULONG smbFileSize;
    USHORT smbOpenMode;
    USHORT OpenAndXFlags = (SMB_OPEN_QUERY_INFORMATION);

    USHORT SearchAttributes = SMB_FILE_ATTRIBUTE_DIRECTORY | SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN;
    LARGE_INTEGER CurrentTime;
    ULONG SecondsSince1970;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildOpenAndX\n", 0 ));

    pServer = SmbCeGetExchangeServer(Exchange);

    smbDisposition = MRxSmbMapDisposition(cp->Disposition);
    smbSharingMode = MRxSmbMapShareAccess(((USHORT)cp->ShareAccess));
    smbAttributes = MRxSmbMapFileAttributes(cp->FileAttributes);
    smbFileSize = cp->AllocationSize.LowPart;
    smbOpenMode = MRxSmbMapDesiredAccess(cp->DesiredAccess);
    smbSharingMode |= smbOpenMode;

    if (cp->CreateOptions & FILE_WRITE_THROUGH) {
        smbSharingMode |= SMB_DA_WRITE_THROUGH;
    }

    //lanman10 servers apparently don't like to get the time passed in.......
    if (FlagOn(pServer->DialectFlags,DF_LANMAN20)) {

        KeQuerySystemTime(&CurrentTime);
        MRxSmbTimeToSecondsSince1970(&CurrentTime,
                                     pServer,
                                     &SecondsSince1970);
    } else {
        SecondsSince1970 = 0;
    }

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_Never,
                                SMB_COM_OPEN_ANDX, SMB_REQUEST_SIZE(OPEN_ANDX),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(4,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbStuffSMB (StufferState,
         "XwwwwdwDddB",
                                    //  X         UCHAR WordCount;                    // Count of parameter words = 15
                                    //  .         UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
                                    //  .         UCHAR AndXReserved;                 // Reserved (must be 0)
                                    //  .         _USHORT( AndXOffset );              // Offset to next command WordCount
             OpenAndXFlags,         //  w         _USHORT( Flags );                   // Additional information: bit set-
                                    //                                                //  0 - return additional info
                                    //                                                //  1 - set single user total file lock
                                    //                                                //  2 - server notifies consumer of
                                    //                                                //      actions which may change file
             smbSharingMode,        //  w         _USHORT( DesiredAccess );           // File open mode
             SearchAttributes,      //  w         _USHORT( SearchAttributes );
             smbAttributes,         //  w         _USHORT( FileAttributes );
             SecondsSince1970,      //  d         _ULONG( CreationTimeInSeconds );
             smbDisposition,        //  w         _USHORT( OpenFunction );
                                    //  D         _ULONG( AllocationSize );           // Bytes to reserve on create or truncate
             SMB_OFFSET_CHECK(OPEN_ANDX,AllocationSize)
             smbFileSize,
             0xffffffff,            //  d         _ULONG( Timeout );                  // Max milliseconds to wait for resource
             0,                     //  d         _ULONG( Reserved );                 // Reserved (must be 0)
             SMB_WCT_CHECK(15) 0    //  B         _USHORT( ByteCount );               // Count of data bytes; min = 1
                                    //            UCHAR Buffer[1];                    // File name
             );
    //proceed with the stuff because we know here that the name fits

    MRxSmbStuffSMB (StufferState,"z!", RemainingName);

    MRxSmbDumpStufferState (700,"SMB w/ OPEN&X after stuffing",StufferState);

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}


typedef enum _SMBPSE_CREATE_METHOD {
    CreateAlreadyDone,
    CreateUseCore,
    CreateUseNT
} SMBPSE_CREATE_METHOD;

NTSTATUS
SmbPseExchangeStart_Create(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the start routine for net root construction exchanges. This initiates the
    construction of the appropriate SMB's if required.

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = (STATUS_NOT_IMPLEMENTED);
    NTSTATUS SetupStatus = STATUS_SUCCESS;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    SMBPSE_CREATE_METHOD CreateMethod = CreateAlreadyDone;
    PSMBCE_SERVER pServer;
    ULONG DialectFlags;

    RxCaptureFcb;
    PMRX_SMB_FCB      smbFcb     = MRxSmbGetFcbExtension(capFcb);

    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PBOOLEAN MustRegainExclusiveResource = &OrdinaryExchange->Create.MustRegainExclusiveResource;
    BOOLEAN CreateWithEasSidsOrLongName = OrdinaryExchange->Create.CreateWithEasSidsOrLongName;
    BOOLEAN fRetryCore = FALSE;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Create\n", 0 ));

    ASSERT_ORDINARY_EXCHANGE(OrdinaryExchange);

    pServer = SmbCeGetExchangeServer(OrdinaryExchange);
    DialectFlags = pServer->DialectFlags;

    COVERED_CALL(MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0)));

    *MustRegainExclusiveResource = TRUE;

    if (!FlagOn(DialectFlags,DF_NT_SMBS)) {
        OEM_STRING      OemString;
        PUNICODE_STRING PathName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

        if (PathName->Length != 0) {
            Status = RtlUnicodeStringToOemString(&OemString, PathName, TRUE);

            if (!NT_SUCCESS(Status)) {
                goto FINALLY;
            }

            //
            //  If we are canonicalizing as FAT, use FAT rules, otherwise use
            //  HPFS rules.
            //

            if (!FlagOn(DialectFlags,DF_LANMAN20)) {
                if (!FsRtlIsFatDbcsLegal(OemString, FALSE, TRUE, TRUE)) {
                    RtlFreeOemString(&OemString);
                    Status = STATUS_OBJECT_NAME_INVALID;
                    goto FINALLY;
                }
            } else if (!FsRtlIsHpfsDbcsLegal(OemString, FALSE, TRUE, TRUE)) {
                RtlFreeOemString(&OemString);
                Status = STATUS_OBJECT_NAME_INVALID;
                goto FINALLY;
            }

            RtlFreeOemString(&OemString);
        }
    }

    if (StufferState->PreviousCommand != SMB_COM_NO_ANDX_COMMAND) {
        // we have a latent session setup /tree connect command

        //the status of the embedded header commands is passed back in the flags.
        SetupStatus = SmbPseOrdinaryExchange(
                          SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                          SMBPSE_OETYPE_LATENT_HEADEROPS
                          );

        if(SetupStatus != STATUS_SUCCESS) {
            Status = SetupStatus;
            goto FINALLY;
        }

        // Turn off reconnect attempts now that we have successfully established
        // the session and net root.
        OrdinaryExchange->SmbCeFlags &= ~(SMBCE_EXCHANGE_ATTEMPT_RECONNECTS);

        COVERED_CALL(MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0)));
    }


    if (!CreateWithEasSidsOrLongName) {
        PUNICODE_STRING AlreadyPrefixedName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);
        PMRXSMB_CREATE_PARAMETERS SmbCp = &OrdinaryExchange->Create.SmbCp;
        PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;
        USHORT mappedOpenMode;

        MRxSmbAdjustCreateParameters(RxContext,SmbCp);
        mappedOpenMode = MRxSmbMapDesiredAccess(cp->DesiredAccess);

        if ((!MRxSmbForceNoNtCreate)
                        && FlagOn(DialectFlags,DF_NT_SMBS)) {

            BOOLEAN SecurityIsNULL =
                        (cp->SecurityContext == NULL) ||
                        (cp->SecurityContext->AccessState == NULL) ||
                        (cp->SecurityContext->AccessState->SecurityDescriptor == NULL);

            CreateMethod = CreateUseNT;

            //now catch the cases where we want to pseudoopen the file

            if ( MRxSmbDeferredOpensEnabled &&
                 !FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_MINIRDR_INITIATED) &&
                 (capFcb->pNetRoot->Type == NET_ROOT_DISK) &&
                 SecurityIsNULL) {

                ASSERT( RxContext->CurrentIrp != 0 );

                if ((cp->Disposition==FILE_OPEN) &&
                    !BooleanFlagOn(cp->CreateOptions, FILE_OPEN_FOR_BACKUP_INTENT) &&
                    (MustBeDirectory(cp->CreateOptions) ||
                     !(cp->DesiredAccess & ~(SYNCHRONIZE | DELETE | FILE_READ_ATTRIBUTES)))){

                    // NT apps expect that you will not succeed the create and then fail the attribs;
                    // if we had some way of identifying win32 apps then we could defer these (except
                    // for DFS). since we have no way to get that information (and don't even have
                    // a good SMB to send..........)

                    // we don't need to send the open for DELETE and FILE_READ_ATTRIBUTES requests since
                    // there are path basied SMB operations.

                    // we can also pseudoopen directories for file_open at the root of the
                    // share but otherwise we have to at least check that the directory
                    // exists. we might have to push out the open later. BTW, we wouldn't be
                    // in here if the name was too long for a GFA or CheckPath

                    Status = MRxSmbPseudoOpenTailFromFakeGFAResponse(
                                  OrdinaryExchange,
                                  MustBeDirectory(cp->CreateOptions)?FileTypeDirectory:FileTypeFile);

                    if (Status == STATUS_SUCCESS && AlreadyPrefixedName->Length > 0) {
                        // send query path information to make sure the file exists on the server
                        Status = MRxSmbQueryFileInformationFromPseudoOpen(
                                     SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);

                        if (Status == STATUS_SUCCESS) {
                            if (MustBeDirectory(cp->CreateOptions) &&
                                !OrdinaryExchange->Create.FileInfo.Standard.Directory) {
                                Status = STATUS_NOT_A_DIRECTORY;
                            }
                        }

                        if (Status != STATUS_SUCCESS) {
                            RxFreePool(smbSrvOpen->DeferredOpenContext);
                            smbSrvOpen->DeferredOpenContext = NULL;
                        }
                    }

                    CreateMethod = CreateAlreadyDone;
                }
            }

            //if no pseudoopen case was hit, do a real open

            if (CreateMethod == CreateUseNT) {

               //use NT_CREATE&X
                COVERED_CALL(MRxSmbBuildNtCreateAndX(StufferState,SmbCp));

                Status = SmbPseOrdinaryExchange(
                             SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                             SMBPSE_OETYPE_CREATE
                             );

                if (Status == STATUS_SUCCESS && RxContext->pFobx == NULL) {
                    Status = STATUS_INVALID_NETWORK_RESPONSE;
                }

                if ((Status == STATUS_SUCCESS) && (cp->Disposition == FILE_OPEN)) {
                    MRxSmbAdjustReturnedCreateAction(RxContext);
                }
            }
        } else if (FlagOn(DialectFlags, DF_LANMAN10) &&
                   (mappedOpenMode != ((USHORT)-1)) &&
                   !MustBeDirectory(cp->CreateOptions)) {

            if (MRxSmbDeferredOpensEnabled &&
                capFcb->pNetRoot->Type == NET_ROOT_DISK &&
                !FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_MINIRDR_INITIATED) &&
                (cp->Disposition==FILE_OPEN) &&
                ((cp->DesiredAccess & ~(SYNCHRONIZE | DELETE | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES)) == 0) ){

                // we don't need to send the open for DELETE and FILE_READ_ATTRIBUTES requests since
                // there are path basied SMB operations.
                // we should do pseudo open for FILE_WRITE_ATTRIBUTES. Othewise the server will return
                // sharing violation


                // send query path information to make sure the file exists on the server

                Status = MRxSmbPseudoOpenTailFromFakeGFAResponse(
                              OrdinaryExchange,
                              MustBeDirectory(cp->CreateOptions)?FileTypeDirectory:FileTypeFile);

                if (Status == STATUS_SUCCESS && AlreadyPrefixedName->Length > 0) {
                    Status = MRxSmbQueryFileInformationFromPseudoOpen(
                                 SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);

                    if (Status != STATUS_SUCCESS) {
                        RxFreePool(smbSrvOpen->DeferredOpenContext);
                        smbSrvOpen->DeferredOpenContext = NULL;
                    }
                }

                CreateMethod = CreateAlreadyDone;
            } else {
                //use OPEN&X
                COVERED_CALL(MRxSmbBuildOpenAndX(StufferState,SmbCp));

                Status = SmbPseOrdinaryExchange(
                             SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                             SMBPSE_OETYPE_CREATE
                             );

                if (Status == STATUS_ACCESS_DENIED && !FlagOn(DialectFlags,DF_NT_SMBS)) {
                    CreateMethod = CreateUseCore;
                    fRetryCore = TRUE;
                }
            }
        } else {

            CreateMethod = CreateUseCore;
        }

        if (CreateMethod == CreateUseCore) {

            Status = MRxSmbDownlevelCreate(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);

            // put back the real error code if we are retrying open&x
            if ((Status != STATUS_SUCCESS) && fRetryCore)
            {
                Status = STATUS_ACCESS_DENIED;
            }

        }
    }

FINALLY:

    if (*MustRegainExclusiveResource) {
        RxAcquireExclusiveFcbResourceInMRx( capFcb );
    }

    // now that we have the fcb exclusive, we can do some updates

    if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_WRITE_ONLY_HANDLE)) {
        smbFcb->WriteOnlySrvOpenCount++;
    }

    MRxSmbMungeBufferingIfWriteOnlyHandles(
        smbFcb->WriteOnlySrvOpenCount,
        SrvOpen
        );

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Create exit w %08lx\n", Status ));
    return Status;
}

VOID
MRxSmbSetSrvOpenFlags (
    PRX_CONTEXT         RxContext,
    RX_FILE_TYPE        StorageType,
    PMRX_SRV_OPEN       SrvOpen,
    PMRX_SMB_SRV_OPEN   smbSrvOpen
    )
{
    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("MRxSmbSetSrvOpenFlags      oplockstate =%08lx\n", smbSrvOpen->OplockLevel ));

    SrvOpen->BufferingFlags = 0;

    switch (smbSrvOpen->OplockLevel) {
    case SMB_OPLOCK_LEVEL_II:
        SrvOpen->BufferingFlags |= (FCB_STATE_READBUFFERING_ENABLED  |
                                   FCB_STATE_READCACHEING_ENABLED);
        break;

    case SMB_OPLOCK_LEVEL_BATCH:
        if (StorageType == FileTypeFile) {
           SrvOpen->BufferingFlags |= FCB_STATE_COLLAPSING_ENABLED;
        }
        // lack of break intentional

    case SMB_OPLOCK_LEVEL_EXCLUSIVE:
        SrvOpen->BufferingFlags |= (FCB_STATE_WRITECACHEING_ENABLED  |
                                   FCB_STATE_FILESIZECACHEING_ENABLED |
                                   FCB_STATE_FILETIMECACHEING_ENABLED |
                                   FCB_STATE_WRITEBUFFERING_ENABLED |
                                   FCB_STATE_LOCK_BUFFERING_ENABLED |
                                   FCB_STATE_READBUFFERING_ENABLED  |
                                   FCB_STATE_READCACHEING_ENABLED);

        break;

    default:
        ASSERT(!"Valid Oplock Level for Open");

    case SMB_OPLOCK_LEVEL_NONE:
        break;
    }

    SrvOpen->Flags |= MRxSmbInitialSrvOpenFlags;
}

NTSTATUS
MRxSmbCreateFileSuccessTail (
    PRX_CONTEXT             RxContext,
    PBOOLEAN                MustRegainExclusiveResource,
    RX_FILE_TYPE            StorageType,
    SMB_FILE_ID             Fid,
    ULONG                   ServerVersion,
    UCHAR                   OplockLevel,
    ULONG                   CreateAction,
    PSMBPSE_FILEINFO_BUNDLE FileInfo
    )
/*++

Routine Description:

    This routine finishes the initialization of the fcb and srvopen for a successful open.

Arguments:


Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureFcb;

    PMRX_SMB_FCB              smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN             SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN         smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBCEDB_SERVER_ENTRY     pServerEntry = (PSMBCEDB_SERVER_ENTRY)RxContext->Create.pSrvCall->Context;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)SrvOpen->pVNetRoot->Context;

    BOOLEAN ThisIsAPseudoOpen;

    FCB_INIT_PACKET LocalInitPacket, *InitPacket;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbCreateFileSuccessTail\n", 0 ));

    smbSrvOpen->Fid = Fid;
    smbSrvOpen->Version = ServerVersion;

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );

    if (*MustRegainExclusiveResource) {
        //this is required because of oplock breaks

        RxAcquireExclusiveFcbResourceInMRx( capFcb );
        *MustRegainExclusiveResource = FALSE;
    }

    if (RxContext->pFobx==NULL) {
        RxContext->pFobx = RxCreateNetFobx(RxContext, SrvOpen);
    }

    ASSERT  ( RxIsFcbAcquiredExclusive ( capFcb )  );
    RxDbgTrace(
        0, Dbg,
        ("Storagetype %08lx/Fid %08lx/Action %08lx\n", StorageType, Fid, CreateAction ));

    pVNetRootContext = SmbCeGetAssociatedVNetRootContext(SrvOpen->pVNetRoot);
    SrvOpen->Key = MRxSmbMakeSrvOpenKey(pVNetRootContext->TreeId,Fid);

    smbSrvOpen->OplockLevel = OplockLevel;

    RxContext->Create.ReturnedCreateInformation = CreateAction;

    if ( ((FileInfo->Standard.AllocationSize.HighPart == FileInfo->Standard.EndOfFile.HighPart)
                           && (FileInfo->Standard.AllocationSize.LowPart < FileInfo->Standard.EndOfFile.LowPart))
           || (FileInfo->Standard.AllocationSize.HighPart < FileInfo->Standard.EndOfFile.HighPart)
       ) {
        FileInfo->Standard.AllocationSize = FileInfo->Standard.EndOfFile;
    }

    smbFcb->dwFileAttributes = FileInfo->Basic.FileAttributes;

    if (smbSrvOpen->OplockLevel > smbFcb->LastOplockLevel) {
        ClearFlag(
            capFcb->FcbState,
            FCB_STATE_TIME_AND_SIZE_ALREADY_SET);
    }

    smbFcb->LastOplockLevel = smbSrvOpen->OplockLevel;

    //the thing is this: if we have good info (not a pseudoopen) then we make the
    //finish call passing the init packet; otherwise, we make the call NOT passing an init packet

    ThisIsAPseudoOpen = BooleanFlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN);

    if (!ThisIsAPseudoOpen) {
        MRxSmbIncrementSrvOpenCount(pServerEntry,SrvOpen);
    }

    if ((capFcb->OpenCount == 0) ||
        (!ThisIsAPseudoOpen &&
         !FlagOn(capFcb->FcbState,FCB_STATE_TIME_AND_SIZE_ALREADY_SET))) {
        if (!ThisIsAPseudoOpen) {
            RxFormInitPacket(
                LocalInitPacket,
                &FileInfo->Basic.FileAttributes,
                &FileInfo->Standard.NumberOfLinks,
                &FileInfo->Basic.CreationTime,
                &FileInfo->Basic.LastAccessTime,
                &FileInfo->Basic.LastWriteTime,
                &FileInfo->Basic.ChangeTime,
                &FileInfo->Standard.AllocationSize,
                &FileInfo->Standard.EndOfFile,
                &FileInfo->Standard.EndOfFile);
            InitPacket = &LocalInitPacket;

        } else {
            InitPacket = NULL;
        }

        RxFinishFcbInitialization( capFcb,
                                   RDBSS_STORAGE_NTC(StorageType),
                                   InitPacket
                                 );

        if (FlagOn( capFcb->FcbState, FCB_STATE_PAGING_FILE )) {
            PPAGING_FILE_CONTEXT PagingFileContext;

            ASSERT(FALSE);
            PagingFileContext = RxAllocatePoolWithTag(NonPagedPool,
                                                      sizeof(PAGING_FILE_CONTEXT),
                                                      MRXSMB_MISC_POOLTAG);

            if (PagingFileContext != NULL) {
                PagingFileContext->pSrvOpen = SrvOpen;
                PagingFileContext->pFobx = RxContext->pFobx;

                InsertHeadList(
                    &MRxSmbPagingFilesSrvOpenList,
                    &PagingFileContext->ContextList);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    MRxSmbSetSrvOpenFlags(RxContext,StorageType,SrvOpen,smbSrvOpen);

    //(wrapperFcb->Condition) = Condition_Good;

    RxContext->pFobx->OffsetOfNextEaToReturn = 1;
    //transition happens later

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishCreateFile   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));
    return Status;
}

NTSTATUS
MRxSmbFinishNTCreateAndX (
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    PRESP_NT_CREATE_ANDX        Response
    )
/*++

Routine Description:

    This routine actually gets the stuff out of the NTCreate_AndX response.

Arguments:

    OrdinaryExchange - the exchange instance

    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;

    RxCaptureFcb;

    PMRX_SRV_OPEN        SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBCE_SESSION      pSession = SmbCeGetExchangeSession(OrdinaryExchange);
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetExchangeNetRootEntry(OrdinaryExchange);

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID Fid;
    ULONG CreateAction;

    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishNTCreateAndX\n", 0 ));
    ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );

    if (RxContext->Create.NtCreateParameters.CreateOptions & FILE_DELETE_ON_CLOSE) {
        PMRX_SMB_FCB      smbFcb     = MRxSmbGetFcbExtension(capFcb);
        SetFlag((smbFcb)->MFlags,SMB_FCB_FLAG_SENT_DISPOSITION_INFO);
    }

    StorageType = RxInferFileType(RxContext);
    if (StorageType == 0) {
        StorageType = Response->Directory
                      ?(FileTypeDirectory)
                      :(FileTypeFile);
        RxDbgTrace( 0, Dbg, ("ChangedStoragetype %08lx\n", StorageType ));
    }

    Fid  = SmbGetUshort(&Response->Fid);

    CreateAction = SmbGetUlong(&Response->CreateAction);

    pFileInfo->Basic.FileAttributes             = SmbGetUlong(&Response->FileAttributes);
    pFileInfo->Standard.NumberOfLinks           = 1;
    pFileInfo->Basic.CreationTime.LowPart       = SmbGetUlong(&Response->CreationTime.LowPart);
    pFileInfo->Basic.CreationTime.HighPart      = SmbGetUlong(&Response->CreationTime.HighPart);
    pFileInfo->Basic.LastAccessTime.LowPart     = SmbGetUlong(&Response->LastAccessTime.LowPart);
    pFileInfo->Basic.LastAccessTime.HighPart    = SmbGetUlong(&Response->LastAccessTime.HighPart);
    pFileInfo->Basic.LastWriteTime.LowPart      = SmbGetUlong(&Response->LastWriteTime.LowPart);
    pFileInfo->Basic.LastWriteTime.HighPart     = SmbGetUlong(&Response->LastWriteTime.HighPart);
    pFileInfo->Basic.ChangeTime.LowPart         = SmbGetUlong(&Response->ChangeTime.LowPart);
    pFileInfo->Basic.ChangeTime.HighPart        = SmbGetUlong(&Response->ChangeTime.HighPart);
    pFileInfo->Standard.AllocationSize.LowPart  = SmbGetUlong(&Response->AllocationSize.LowPart);
    pFileInfo->Standard.AllocationSize.HighPart = SmbGetUlong(&Response->AllocationSize.HighPart);
    pFileInfo->Standard.EndOfFile.LowPart       = SmbGetUlong(&Response->EndOfFile.LowPart);
    pFileInfo->Standard.EndOfFile.HighPart      = SmbGetUlong(&Response->EndOfFile.HighPart);
    pFileInfo->Standard.Directory               = Response->Directory;


    // If the NT_CREATE_ANDX was to a downlevel server the access rights
    // information is not available. Currently we default to maximum
    // access for the current user and no access to other users in the
    // disconnected mode for such files

    smbSrvOpen->MaximalAccessRights = FILE_ALL_ACCESS;

    smbSrvOpen->GuestMaximalAccessRights = 0;

    if (Response->OplockLevel > SMB_OPLOCK_LEVEL_NONE) {
        smbSrvOpen->FileStatusFlags = Response->FileStatusFlags;
        smbSrvOpen->IsNtCreate = TRUE;
    }

    MRxSmbCreateFileSuccessTail (
        RxContext,
        &OrdinaryExchange->Create.MustRegainExclusiveResource,
        StorageType,
        Fid,
        OrdinaryExchange->ServerVersion,
        Response->OplockLevel,
        CreateAction,
        pFileInfo
        );

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishNTCreateAndX   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));

    return Status;
}

NTSTATUS
MRxSmbFinishOpenAndX (
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    PRESP_OPEN_ANDX        Response
    )
/*++

Routine Description:

    This routine actually gets the stuff out of the NTCreate_AndX response.

Arguments:

    OrdinaryExchange - the exchange instance

    Response - the response

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    ULONG       Disposition = RxContext->Create.NtCreateParameters.Disposition;

    RxCaptureFcb;

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID Fid;
    UCHAR OplockLevel = SMB_OPLOCK_LEVEL_NONE;
    ULONG CreateAction;
    PMRX_SRV_OPEN        SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishOpenAndX\n", 0 ));
    ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );

    StorageType = RxInferFileType(RxContext);
    if (StorageType == 0) {
        StorageType = FileTypeFile;
        RxDbgTrace( 0, Dbg, ("ChangedStoragetype %08lx\n", StorageType ));
    }

    ASSERT (StorageType == FileTypeFile);

    Fid = SmbGetUshort(&Response->Fid);

    if (SmbGetUshort(&Response->Action) & SMB_OACT_OPLOCK) {
        OplockLevel = SMB_OPLOCK_LEVEL_BATCH;     //we only ever ask for batch currently!!!
    }

    CreateAction =  MRxSmbUnmapDisposition(SmbGetUshort(&Response->Action),Disposition);

    pFileInfo->Basic.FileAttributes =
        MRxSmbMapSmbAttributes(SmbGetUshort(&Response->FileAttributes));

    // This is a downlevel server, the access rights
    // information is not available. Currently we default to maximum
    // access for the current user and no access to other users in the
    // disconnected mode for such files

    smbSrvOpen->MaximalAccessRights = FILE_ALL_ACCESS;

    smbSrvOpen->GuestMaximalAccessRights = 0;

    MRxSmbSecondsSince1970ToTime(
        SmbGetUlong(&Response->LastWriteTimeInSeconds),
        SmbCeGetExchangeServer(OrdinaryExchange),
        &pFileInfo->Basic.LastWriteTime);

    pFileInfo->Standard.NumberOfLinks = 1;
    pFileInfo->Basic.CreationTime.HighPart = 0;
    pFileInfo->Basic.CreationTime.LowPart = 0;
    pFileInfo->Basic.LastAccessTime.HighPart = 0;
    pFileInfo->Basic.LastAccessTime.LowPart = 0;
    pFileInfo->Basic.ChangeTime.HighPart = 0;
    pFileInfo->Basic.ChangeTime.LowPart = 0;
    pFileInfo->Standard.EndOfFile.HighPart = 0;
    pFileInfo->Standard.EndOfFile.LowPart = SmbGetUlong(&Response->DataSize);
    pFileInfo->Standard.AllocationSize.QuadPart = pFileInfo->Standard.EndOfFile.QuadPart;
    pFileInfo->Standard.Directory = (StorageType == FileTypeDirectory);

    MRxSmbCreateFileSuccessTail (
        RxContext,
        &OrdinaryExchange->Create.MustRegainExclusiveResource,
        StorageType,
        Fid,
        OrdinaryExchange->ServerVersion,
        OplockLevel,
        CreateAction,
        pFileInfo );

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishOpenAndX   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));
    return Status;
}


NTSTATUS
MRxSmbFinishT2OpenFile (
    IN OUT PRX_CONTEXT            RxContext,
    IN     PRESP_OPEN2            Response,
    IN OUT PBOOLEAN               MustRegainExclusiveResource,
    IN     ULONG                  ServerVersion
    )
/*++

Routine Description:

    This routine actually gets the stuff out of the T2/Open response.

Arguments:

    RxContext - the context of the operation being performed

    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID  Fid;
    ULONG        CreateAction;
    ULONG        Disposition = RxContext->Create.NtCreateParameters.Disposition;

    ULONG                     FileAttributes;

    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishT2OpenFile\n", 0 ));
    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );

    FileAttributes = MRxSmbMapSmbAttributes(Response->FileAttributes);

    StorageType = RxInferFileType(RxContext);
    if (StorageType == 0) {
       StorageType = (FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                     ? FileTypeDirectory
                     : FileTypeFile;
    }

    if ((capFcb->OpenCount != 0) &&
        (StorageType != 0) &&
        (NodeType(capFcb) !=  RDBSS_STORAGE_NTC(StorageType))) {
        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    Fid = Response->Fid;
    CreateAction =  MRxSmbUnmapDisposition(Response->Action,Disposition);
    RxDbgTrace( 0, Dbg, ("Storagetype %08lx/Fid %08lx/Action %08lx\n", StorageType, Fid, CreateAction ));

    if (Response->Action & SMB_OACT_OPLOCK) {
        smbSrvOpen->OplockLevel = SMB_OPLOCK_LEVEL_BATCH;     //we only ever ask for batch currently!!!
    }

    RxContext->Create.ReturnedCreateInformation = CreateAction;

    if (capFcb->OpenCount == 0) {
        //
        //  Please note that we mask off the low bit on the time stamp here.
        //
        //  We do this since the time stamps returned from other smbs (notably SmbGetAttrE and
        //  T2QueryDirectory) have a granularity of 2 seconds, while this
        //  time stamp has a granularity of 1 second.  In order to make these
        //  two times consistant, we mask off the low order second in the
        //  timestamp.  this idea was lifted from rdr1.
        //
        PSMBCEDB_SERVER_ENTRY pServerEntry;

        pServerEntry = SmbCeReferenceAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
        ASSERT(pServerEntry != NULL);
        MRxSmbSecondsSince1970ToTime(Response->CreationTimeInSeconds&0xfffffffe,
                                     &pServerEntry->Server,
                                     &pFileInfo->Basic.CreationTime);
        SmbCeDereferenceServerEntry(pServerEntry);
    }

    pFileInfo->Basic.FileAttributes             = FileAttributes;
    pFileInfo->Basic.LastAccessTime.QuadPart    = 0;
    pFileInfo->Basic.LastWriteTime.QuadPart     = 0;
    pFileInfo->Basic.ChangeTime.QuadPart        = 0;

    pFileInfo->Standard.NumberOfLinks           = 1;
    pFileInfo->Standard.AllocationSize.QuadPart =
    pFileInfo->Standard.EndOfFile.QuadPart      = Response->DataSize;
    pFileInfo->Standard.Directory               = (StorageType == FileTypeDirectory);

    MRxSmbCreateFileSuccessTail(
        RxContext,
        MustRegainExclusiveResource,
        StorageType,
        Fid,
        ServerVersion,
        smbSrvOpen->OplockLevel,
        CreateAction,
        pFileInfo);

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishT2OpenFile   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));

    return Status;
}

//#define MULTI_EA_MDL

NTSTATUS
MRxSmbT2OpenFile(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine opens a file across the network that has
        1) EAs,
        2) a name so long that it wont fit in an ordinary packet

   We silently ignore it if SDs are specified.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    RxCaptureFcb;
    USHORT Setup = TRANS2_OPEN2;

    BOOLEAN MustRegainExclusiveResource = FALSE;

    SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
    SMB_TRANSACTION_SEND_PARAMETERS     SendParameters;
    SMB_TRANSACTION_RECEIVE_PARAMETERS  ReceiveParameters;
    SMB_TRANSACTION_OPTIONS             TransactionOptions;

    PREQ_OPEN2 pCreateRequest = NULL;
    RESP_OPEN2 CreateResponse;

    PBYTE SendParamsBuffer,ReceiveParamsBuffer;
    ULONG SendParamsBufferLength,ReceiveParamsBufferLength;

    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    MRXSMB_CREATE_PARAMETERS SmbCp;
    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;
    USHORT smbDisposition;
    USHORT smbSharingMode;
    USHORT smbAttributes;
    ULONG smbFileSize;
    USHORT smbOpenMode;
    USHORT OpenFlags = SMB_OPEN_QUERY_INFORMATION;
    USHORT SearchAttributes = SMB_FILE_ATTRIBUTE_DIRECTORY | SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN;
    ULONG  SecondsSince1970;
    BOOLEAN IsUnicode;

    ULONG OS2_EaLength = 0;
    PFEALIST ServerEaList = NULL;

    ULONG EaLength = RxContext->Create.EaLength;
    PFILE_FULL_EA_INFORMATION EaBuffer = RxContext->Create.EaBuffer;

    ULONG FileNameLength,AllocationLength;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("MRxSmbT2Open---\n"));
    DbgPrint("MRxSmbT2Open---%08lx %08lx\n",EaBuffer,EaLength);
    MRxSmbAdjustCreateParameters(RxContext,&SmbCp);

    FileNameLength = RemainingName->Length;

    AllocationLength = WordAlign(FIELD_OFFSET(REQ_OPEN2,Buffer[0])) +
                       FileNameLength+sizeof(WCHAR);

    pCreateRequest = (PREQ_OPEN2)
                     RxAllocatePoolWithTag(
                        PagedPool,
                        AllocationLength,
                        'bmsX' );

    if (pCreateRequest==NULL) {
        RxDbgTrace(0, Dbg, ("  --> Couldn't get the pCreateRequest!\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    smbDisposition = MRxSmbMapDisposition(cp->Disposition);
    smbSharingMode = MRxSmbMapShareAccess(((USHORT)cp->ShareAccess));
    smbAttributes = MRxSmbMapFileAttributes(cp->FileAttributes);
    smbFileSize = cp->AllocationSize.LowPart;
    smbOpenMode = MRxSmbMapDesiredAccess(cp->DesiredAccess);
    smbSharingMode |= smbOpenMode;

    if (cp->CreateOptions & FILE_WRITE_THROUGH) {
        smbSharingMode |= SMB_DA_WRITE_THROUGH;
    }

    if (capFcb->pNetRoot->Type == NET_ROOT_DISK) {
        OpenFlags |= (SMB_OPEN_OPLOCK | SMB_OPEN_OPBATCH);
    }

    {
        BOOLEAN GoodTime;
        PSMBCEDB_SERVER_ENTRY pServerEntry;
        LARGE_INTEGER CurrentTime;

        pServerEntry = SmbCeReferenceAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
        ASSERT(pServerEntry != NULL);
        IsUnicode = BooleanFlagOn(pServerEntry->Server.DialectFlags,DF_UNICODE);

        KeQuerySystemTime(&CurrentTime);

        GoodTime = MRxSmbTimeToSecondsSince1970(
                       &CurrentTime,
                       &pServerEntry->Server,
                       &SecondsSince1970
                       );

        SmbCeDereferenceServerEntry(pServerEntry);

        if (!GoodTime) {
            SecondsSince1970 = 0;
        }
    }

    pCreateRequest->Flags = OpenFlags;      // Creation flags
    pCreateRequest->DesiredAccess = smbSharingMode;
    pCreateRequest->SearchAttributes = SearchAttributes;
    pCreateRequest->FileAttributes = smbAttributes;
    pCreateRequest->CreationTimeInSeconds = SecondsSince1970;
    pCreateRequest->OpenFunction = smbDisposition;
    pCreateRequest->AllocationSize = smbFileSize;

    RtlZeroMemory(
        &pCreateRequest->Reserved[0],
        sizeof(pCreateRequest->Reserved));

    {
        NTSTATUS StringStatus;
        PBYTE NameBuffer = &pCreateRequest->Buffer[0];
        ULONG OriginalLengthRemaining = FileNameLength+sizeof(WCHAR);
        ULONG LengthRemaining = OriginalLengthRemaining;
        if (IsUnicode) {
            StringStatus = SmbPutUnicodeString(&NameBuffer,RemainingName,&LengthRemaining);
        } else {
            StringStatus = SmbPutUnicodeStringAsOemString(&NameBuffer,RemainingName,&LengthRemaining);
            DbgPrint("This is the name <%s>\n",&pCreateRequest->Buffer[0]);
        }
        ASSERT(StringStatus==STATUS_SUCCESS);
        SendParamsBufferLength = FIELD_OFFSET(REQ_OPEN2,Buffer[0])
                                    +OriginalLengthRemaining-LengthRemaining;
    }


    SendParamsBuffer = (PBYTE)pCreateRequest;
    //SendParamsBufferLength = qweee;
    ReceiveParamsBuffer = (PBYTE)&CreateResponse;
    ReceiveParamsBufferLength = sizeof(CreateResponse);

    if (EaLength!=0) {
        //
        //  Convert Nt format FEALIST to OS/2 format
        //
        DbgPrint("MRxSmbT2Open again---%08lx %08lx\n",EaBuffer,EaLength);
        OS2_EaLength = MRxSmbNtFullEaSizeToOs2 ( EaBuffer );
        if ( OS2_EaLength > 0x0000ffff ) {
            Status = STATUS_EA_TOO_LARGE;
            goto FINALLY;
        }

        ServerEaList = RxAllocatePoolWithTag (PagedPool, OS2_EaLength, 'Ebms');
        if ( ServerEaList == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }

        MRxSmbNtFullListToOs2 ( EaBuffer, ServerEaList );
    } else {
        OS2_EaLength = 0;
        ServerEaList = NULL;
    }

    RxDbgTrace(0, Dbg, ("MRxSmbT2Open---os2ea %d buf %x\n", OS2_EaLength,ServerEaList));
    DbgPrint("MRxSmbT2Open OS2 eastuff---%08lx %08lx\n",ServerEaList,OS2_EaLength);

    TransactionOptions = RxDefaultTransactionOptions;
    TransactionOptions.Flags |= SMB_XACT_FLAGS_FID_NOT_NEEDED;

    if (BooleanFlagOn(capFcb->pNetRoot->Flags,NETROOT_FLAG_DFS_AWARE_NETROOT) &&
        (RxContext->Create.NtCreateParameters.DfsContext == UIntToPtr(DFS_OPEN_CONTEXT))) {
        TransactionOptions.Flags |= SMB_XACT_FLAGS_DFS_AWARE;
    }

    ASSERT (MrxSmbCreateTransactPacketSize>=100); //don't try something strange
    TransactionOptions.MaximumTransmitSmbBufferSize = MrxSmbCreateTransactPacketSize;

    RxReleaseFcbResourceInMRx( capFcb );
    MustRegainExclusiveResource = TRUE;

    Status = SmbCeTransact(
                 RxContext,
                 &TransactionOptions,
                 &Setup,
                 sizeof(Setup),
                 NULL,
                 0,
                 SendParamsBuffer,
                 SendParamsBufferLength,
                 ReceiveParamsBuffer,
                 ReceiveParamsBufferLength,
                 ServerEaList,
                 OS2_EaLength,
                 NULL,
                 0,
                 &ResumptionContext);

    if (NT_SUCCESS(Status)) {
        MRxSmbFinishT2OpenFile (
            RxContext,
            &CreateResponse,
            &MustRegainExclusiveResource,
            ResumptionContext.ServerVersion);

        if (cp->Disposition == FILE_OPEN) {
            MRxSmbAdjustReturnedCreateAction(RxContext);
        }
    }

FINALLY:
    ASSERT (Status != (STATUS_PENDING));

    if (pCreateRequest != NULL) {
       RxFreePool(pCreateRequest);
    }

    if (ServerEaList != NULL) {
       RxFreePool(ServerEaList);
    }

    if (MustRegainExclusiveResource) {
        //this is required because of oplock breaks
        RxAcquireExclusiveFcbResourceInMRx(capFcb );
    }

    RxDbgTraceUnIndent(-1,Dbg);
    return Status;
}

NTSTATUS
MRxSmbFinishLongNameCreateFile (
    IN OUT PRX_CONTEXT                RxContext,
    IN     PRESP_CREATE_WITH_SD_OR_EA Response,
    IN     PBOOLEAN                   MustRegainExclusiveResource,
    IN     ULONG                      ServerVersion
    )
/*++

Routine Description:

    This routine actually gets the stuff out of the NTTransact/NTCreateWithEAsOrSDs response.

Arguments:

    RxContext - the context of the operation being performed
    Response - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)SrvOpen->pVNetRoot->Context;

    RX_FILE_TYPE StorageType;
    SMB_FILE_ID Fid;
    ULONG CreateAction;

    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    FCB_INIT_PACKET InitPacket;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishLongNameCreateFile\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT( NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT );

    if (RxContext->Create.NtCreateParameters.CreateOptions & FILE_DELETE_ON_CLOSE) {
        PMRX_SMB_FCB      smbFcb     = MRxSmbGetFcbExtension(capFcb);
        SetFlag((smbFcb)->MFlags,SMB_FCB_FLAG_SENT_DISPOSITION_INFO);
    }

    StorageType = RxInferFileType(RxContext);

    if (StorageType == 0) {
        StorageType = Response->Directory
                      ?FileTypeDirectory
                      :FileTypeFile;
        RxDbgTrace( 0, Dbg, ("ChangedStoragetype %08lx\n", StorageType ));
    }

    if ((capFcb->OpenCount != 0) &&
        (StorageType != 0) &&
        (NodeType(capFcb) !=  RDBSS_STORAGE_NTC(StorageType))) {
        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    Fid = SmbGetUshort(&Response->Fid);

    CreateAction = SmbGetUlong(&Response->CreateAction);

    pFileInfo->Basic.FileAttributes = Response->FileAttributes;
    pFileInfo->Basic.CreationTime = Response->CreationTime;
    pFileInfo->Basic.LastAccessTime = Response->LastAccessTime;
    pFileInfo->Basic.LastWriteTime = Response->LastWriteTime;
    pFileInfo->Basic.ChangeTime = Response->ChangeTime;
    pFileInfo->Standard.NumberOfLinks = 1;
    pFileInfo->Standard.AllocationSize = Response->AllocationSize;
    pFileInfo->Standard.EndOfFile = Response->EndOfFile;
    pFileInfo->Standard.Directory = Response->Directory;

    if (((pFileInfo->Standard.AllocationSize.HighPart == pFileInfo->Standard.EndOfFile.HighPart) &&
         (pFileInfo->Standard.AllocationSize.LowPart < pFileInfo->Standard.EndOfFile.LowPart)) ||
        (pFileInfo->Standard.AllocationSize.HighPart < pFileInfo->Standard.EndOfFile.HighPart)) {
        pFileInfo->Standard.AllocationSize = pFileInfo->Standard.EndOfFile;
    }

    smbSrvOpen->MaximalAccessRights = (USHORT)0x1ff;

    smbSrvOpen->GuestMaximalAccessRights = (USHORT)0;

    MRxSmbCreateFileSuccessTail(
        RxContext,
        MustRegainExclusiveResource,
        StorageType,
        Fid,
        ServerVersion,
        Response->OplockLevel,
        CreateAction,
        pFileInfo);

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishLongNameCreateFile   returning %08lx, fcbstate =%08lx\n", Status, capFcb->FcbState ));
    return Status;
}


//force_t2_open doesn't work on an NT server......sigh........
#define ForceT2Open FALSE

NTSTATUS
MRxSmbCreateWithEasSidsOrLongName (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine opens a file across the network that has
        1) EAs,
        2) SIDs, or
        3) a name so long that it wont fit in an ordinary packet


Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    RxCaptureFcb;

    BOOLEAN MustRegainExclusiveResource = FALSE;

    SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
    SMB_TRANSACTION_SEND_PARAMETERS     SendParameters;
    SMB_TRANSACTION_RECEIVE_PARAMETERS  ReceiveParameters;
    SMB_TRANSACTION_OPTIONS             TransactionOptions;

    PREQ_CREATE_WITH_SD_OR_EA pCreateRequest = NULL;

    PBYTE SendParamsBuffer,ReceiveParamsBuffer,SendDataBuffer;
    ULONG SendParamsBufferLength,ReceiveParamsBufferLength,SendDataBufferLength;

    PRESP_CREATE_WITH_SD_OR_EA CreateResponse;

    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);
    MRXSMB_CREATE_PARAMETERS SmbCp;
    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;


    ULONG EaLength,SdLength,PadLength,TotalLength;
    PBYTE CombinedBuffer = NULL;
#ifdef MULTI_EA_MDL
    PRX_BUFFER  EaMdl2 = NULL;
    PRX_BUFFER  EaMdl3 = NULL;
#endif
    PMDL  EaMdl = NULL;
    PMDL  SdMdl = NULL; BOOLEAN SdMdlLocked = FALSE;
    PMDL  PadMdl = NULL;
    PMDL  DataMdl = NULL;

    ULONG FileNameLength,AllocationLength;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("!!MRxSmbCreateWithEasSidsOrLongName---\n"));

    {
        PSMBCEDB_SERVER_ENTRY pServerEntry;
        BOOLEAN DoesNtSmbs;

        pServerEntry = SmbCeReferenceAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
        ASSERT(pServerEntry != NULL);
        DoesNtSmbs = BooleanFlagOn(pServerEntry->Server.DialectFlags,DF_NT_SMBS);

        SmbCeDereferenceServerEntry(pServerEntry);
        if (!DoesNtSmbs || ForceT2Open) {
            NTSTATUS Status = MRxSmbT2OpenFile(RxContext);
            if (ForceT2Open && (Status!=STATUS_SUCCESS)) {
                DbgPrint("BadStatus = %08lx\n",Status);
            }
            return(Status);
        }
    }


    MRxSmbAdjustCreateParameters(RxContext,&SmbCp);

    RxDbgTrace(0, Dbg, ("MRxSmbCreateWithEasSidsOrLongName---\n"));
    FileNameLength = RemainingName->Length;

    AllocationLength = WordAlign(FIELD_OFFSET(REQ_CREATE_WITH_SD_OR_EA,Buffer[0]))
                        +FileNameLength;

    pCreateRequest = (PREQ_CREATE_WITH_SD_OR_EA)RxAllocatePoolWithTag( PagedPool,
                                             AllocationLength,'bmsX' );
    if (pCreateRequest==NULL) {
        RxDbgTrace(0, Dbg, ("  --> Couldn't get the pCreateRequest!\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    RtlCopyMemory((PBYTE)WordAlignPtr(&pCreateRequest->Buffer[0]),RemainingName->Buffer,FileNameLength);

    EaLength = RxContext->Create.EaLength;
    SdLength = RxContext->Create.SdLength;

    pCreateRequest->Flags = 0;           //norelopen // Optional directory for relative open
    pCreateRequest->RootDirectoryFid = 0;           //norelopen // Optional directory for relative open
    pCreateRequest->DesiredAccess = cp->DesiredAccess;              // Desired access (NT format)
    pCreateRequest->AllocationSize = cp->AllocationSize;            // The initial allocation size in bytes
    pCreateRequest->FileAttributes = cp->FileAttributes;            // The file attributes
    pCreateRequest->ShareAccess = cp->ShareAccess;                  // The share access
    pCreateRequest->CreateDisposition = cp->Disposition;            // Action to take if file exists or not
    pCreateRequest->CreateOptions = cp->CreateOptions;              // Options for creating a new file
    pCreateRequest->SecurityDescriptorLength = SdLength;        // Length of SD in bytes
    pCreateRequest->EaLength = EaLength;                        // Length of EA in bytes
    pCreateRequest->NameLength = FileNameLength;                // Length of name in characters
    pCreateRequest->ImpersonationLevel = cp->ImpersonationLevel;    // Security QOS information
    pCreateRequest->SecurityFlags = SmbCp.SecurityFlags;              // Security QOS information
                    //  UCHAR Buffer[1];
                    //  //UCHAR Name[];                     // The name of the file (not NUL terminated)

    SendParamsBuffer = (PBYTE)pCreateRequest;
    SendParamsBufferLength = AllocationLength;
    ReceiveParamsBuffer = (PBYTE)&CreateResponse;
    ReceiveParamsBufferLength = sizeof(CreateResponse);

    if ((EaLength==0)||(SdLength==0)) {
        PadLength = 0;
        if (EaLength) {
            // the EaBuffer is in nonpaged pool...so we dont lock or unlock
            PBYTE EaBuffer = RxContext->Create.EaBuffer;
#ifdef MULTI_EA_MDL
            ULONG EaLength0,EaLength2,EaLength3;
            PBYTE EaBuffer2,EaBuffer3;
            ASSERT(EaLength>11);
            RxDbgTrace(0, Dbg, ("MRxSmbCreateWithEasSidsOrLongName--MULTIEAMDL\n"));
            EaLength0 = (EaLength - 4)>>1;
            EaBuffer2 = EaBuffer + EaLength0;
            EaLength2 = 4;
            EaBuffer3 = EaBuffer2 + EaLength2;
            EaLength3 = EaLength - (EaBuffer3 - EaBuffer);
            EaMdl = RxAllocateMdl(EaBuffer,EaLength0);
            EaMdl2 = RxAllocateMdl(EaBuffer2,EaLength2);
            EaMdl3 = RxAllocateMdl(EaBuffer3,EaLength3);
            if ( (EaMdl==NULL) || (EaMdl2==NULL) || (EaMdl3==NULL) ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto FINALLY;
            }
            MmBuildMdlForNonPagedPool(EaMdl);
            MmBuildMdlForNonPagedPool(EaMdl2);
            MmBuildMdlForNonPagedPool(EaMdl3);
            EaMdl3->Next = NULL;
            EaMdl2->Next = EaMdl3;
            EaMdl->Next = EaMdl2;
#else
            EaMdl = RxAllocateMdl(EaBuffer,EaLength);
            if (EaMdl == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto FINALLY;
            }
            MmBuildMdlForNonPagedPool(EaMdl);
            EaMdl->Next = NULL;
#endif
            DataMdl = EaMdl;
        }

        if (SdLength) {
            SdMdl = RxAllocateMdl(cp->SecurityContext->AccessState->SecurityDescriptor,SdLength);
            if (SdMdl == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RxProbeAndLockPages(SdMdl,KernelMode,IoModifyAccess,Status);
            }
            if (!NT_SUCCESS(Status)) goto FINALLY;
            SdMdlLocked = TRUE;
            PadLength = LongAlign(SdLength) - SdLength;
            if (PadLength && EaLength) {
                PadMdl = RxAllocateMdl(0,(sizeof(DWORD) + PAGE_SIZE - 1));
                if (PadMdl == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto FINALLY;
                }
                RxBuildPaddingPartialMdl(PadMdl,PadLength);
                PadMdl->Next = DataMdl;
                DataMdl = PadMdl;
            }
            SdMdl->Next = DataMdl;
            DataMdl = SdMdl;
        }
    } else {
        ULONG EaOffset = LongAlign(SdLength);
        ULONG CombinedBufferLength = EaOffset + EaLength;
        CombinedBuffer = RxAllocatePoolWithTag(PagedPool,CombinedBufferLength,'bms');
        if (CombinedBuffer==NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }
        SdMdl = RxAllocateMdl(CombinedBuffer,CombinedBufferLength);
        if (SdMdl == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            RxProbeAndLockPages(SdMdl,KernelMode,IoModifyAccess,Status);
        }
        if (!NT_SUCCESS(Status)) goto FINALLY;
        SdMdlLocked = TRUE;
        RtlCopyMemory(CombinedBuffer,cp->SecurityContext->AccessState->SecurityDescriptor,SdLength);
        RtlZeroMemory(CombinedBuffer+SdLength,EaOffset-SdLength);
        RtlCopyMemory(CombinedBuffer+EaOffset,RxContext->Create.EaBuffer,EaLength);
        DataMdl = SdMdl;
    }

    RxDbgTrace(0, Dbg, ("MRxSmbCreateWithEasSidsOrLongName---s,p,ea %d,%d,%d buf %x\n",
                   SdLength,PadLength,EaLength,RxContext->Create.EaBuffer));

    TransactionOptions = RxDefaultTransactionOptions;
    TransactionOptions.NtTransactFunction = NT_TRANSACT_CREATE;
    TransactionOptions.Flags |= SMB_XACT_FLAGS_FID_NOT_NEEDED;
    //dfs is only for nt servers........
    //if (BooleanFlagOn(capFcb->pNetRoot->Flags,NETROOT_FLAG_DFS_AWARE_NETROOT)
    //                        && (RxContext->Create.NtCreateParameters.DfsContext == (PVOID)DFS_OPEN_CONTEXT)) {
    //    TransactionOptions.Flags |= SMB_XACT_FLAGS_DFS_AWARE;
    //}


    ASSERT (MrxSmbCreateTransactPacketSize>=100); //don't try something strange
    TransactionOptions.MaximumTransmitSmbBufferSize = MrxSmbCreateTransactPacketSize;

    if (DataMdl!=NULL) {
        SendDataBuffer = MmGetSystemAddressForMdlSafe(DataMdl,LowPagePriority);

        if (SendDataBuffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }

        SendDataBufferLength = EaLength+SdLength+PadLength;
    } else {
        SendDataBuffer = NULL;
        SendDataBufferLength = 0;
    }

    RxReleaseFcbResourceInMRx(capFcb );
    MustRegainExclusiveResource = TRUE;

    Status = SmbCeTransact(
                 RxContext,
                 &TransactionOptions,
                 NULL,
                 0,
                 NULL,
                 0,
                 SendParamsBuffer,
                 SendParamsBufferLength,
                 ReceiveParamsBuffer,
                 ReceiveParamsBufferLength,
                 SendDataBuffer,
                 SendDataBufferLength,
                 NULL,
                 0,
                 &ResumptionContext);

    if (NT_SUCCESS(Status)) {
        MRxSmbFinishLongNameCreateFile (
            RxContext,
            (PRESP_CREATE_WITH_SD_OR_EA)&CreateResponse,
            &MustRegainExclusiveResource,
            ResumptionContext.ServerVersion);

        if (cp->Disposition == FILE_OPEN) {
            MRxSmbAdjustReturnedCreateAction(RxContext);
        }
    }

FINALLY:
    ASSERT (Status != (STATUS_PENDING));


    if (SdMdlLocked) MmUnlockPages(SdMdl);
    if (EaMdl  != NULL) { IoFreeMdl(EaMdl);  }
#ifdef MULTI_EA_MDL
    if (EaMdl2  != NULL) { IoFreeMdl(EaMdl2);  }
    if (EaMdl3  != NULL) { IoFreeMdl(EaMdl3);  }
#endif
    if (PadMdl != NULL) { IoFreeMdl(PadMdl); }
    if (SdMdl  != NULL) { IoFreeMdl(SdMdl);  }

    if (pCreateRequest != NULL) {
       RxFreePool(pCreateRequest);
    }

    if (CombinedBuffer != NULL) {
       RxFreePool(CombinedBuffer);
    }

    if (MustRegainExclusiveResource) {
        //this is required because of oplock breaks
        RxAcquireExclusiveFcbResourceInMRx(capFcb );
    }

    RxDbgTraceUnIndent(-1,Dbg);
    return Status;
}


NTSTATUS
MRxSmbZeroExtend(
    IN PRX_CONTEXT pRxContext)
/*++

Routine Description:

   This routine extends the data stream of a file system object

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
MRxSmbTruncate(
      IN PRX_CONTEXT pRxContext)
/*++

Routine Description:

   This routine truncates the contents of a file system object

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   ASSERT(!"Found a truncate");
   return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
MRxSmbCleanupFobx(
    IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine cleansup a file system object...normally a noop.

Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PUNICODE_STRING RemainingName;

    RxCaptureFcb;
    RxCaptureFobx;

    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PMRX_SRV_OPEN        SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_FOBX        smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );
    ASSERT ( NodeTypeIsFcb(capFcb) );

    RxDbgTrace(+1, Dbg, ("MRxSmbCleanup\n", 0 ));

    MRxSmbDeallocateSideBuffer(RxContext,smbFobx,"Cleanup");

    if (FlagOn(capFcb->FcbState,FCB_STATE_ORPHANED)) {
        RxDbgTrace(-1, Dbg, ("File orphaned\n"));
    } else {
        RxDbgTrace(-1, Dbg, ("File not for closing at cleanup\n"));
    }
    return (STATUS_SUCCESS);

}

NTSTATUS
MRxSmbForcedClose(
    IN PMRX_SRV_OPEN pSrvOpen)
/*++

Routine Description:

   This routine closes a file system object

Arguments:

    pSrvOpen - the instance to be closed

Return Value:

    RXSTATUS - The return status for the operation

Notes:



--*/
{
   PAGED_CODE();

   return STATUS_NOT_IMPLEMENTED;
}

#undef  Dbg
#define Dbg                              (DEBUG_TRACE_CLOSE)

NTSTATUS
MRxSmbCloseSrvOpen(
    IN PRX_CONTEXT   RxContext
    )
/*++

Routine Description:

   This routine closes a file across the network

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING RemainingName;

    RxCaptureFcb;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);

    RxCaptureFobx;

    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PMRX_SRV_OPEN     SrvOpen    = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_FOBX     smbFobx    = MRxSmbGetFileObjectExtension(capFobx);

    PSMBCEDB_SERVER_ENTRY pServerEntry = (PSMBCEDB_SERVER_ENTRY)(capFcb->pNetRoot->pSrvCall->Context);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    BOOLEAN NeedDelete;
    BOOLEAN SearchHandleOpen = FALSE;

    PAGED_CODE();

    ASSERT ( NodeTypeIsFcb(capFcb) );

    RxDbgTrace(+1, Dbg, ("MRxSmbClose\n", 0 ));

    if (TypeOfOpen==RDBSS_NTC_STORAGE_TYPE_DIRECTORY) {
        SearchHandleOpen = BooleanFlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN);
        MRxSmbDeallocateSideBuffer(RxContext,smbFobx,"Close");
        if (smbFobx->Enumeration.ResumeInfo!=NULL) {
            RxFreePool(smbFobx->Enumeration.ResumeInfo);
            smbFobx->Enumeration.ResumeInfo = NULL;
        }
    }

    if (!smbSrvOpen->DeferredOpenInProgress &&
        smbSrvOpen->DeferredOpenContext != NULL) {
        RxFreePool(smbSrvOpen->DeferredOpenContext);
        smbSrvOpen->DeferredOpenContext = NULL;
        RxDbgTrace(0, Dbg, ("Free deferred open context for file %wZ %lX\n",GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext),smbSrvOpen));
    }

    //Remove the open context from the list if it is a paging file
    if (FlagOn( capFcb->FcbState, FCB_STATE_PAGING_FILE )) {
        PLIST_ENTRY          pListHead = &MRxSmbPagingFilesSrvOpenList;
        PLIST_ENTRY          pListEntry = pListHead->Flink;

        ASSERT(FALSE);
        while (pListEntry != pListHead) {
            PPAGING_FILE_CONTEXT PagingFileContext;

            PagingFileContext = (PPAGING_FILE_CONTEXT)CONTAINING_RECORD(pListEntry,PAGING_FILE_CONTEXT,ContextList);
            if (PagingFileContext->pSrvOpen == SrvOpen) {
                RemoveEntryList(pListEntry);

                break;
            }
        }
    }

    if (FlagOn(capFcb->FcbState,FCB_STATE_ORPHANED)) {
        RxDbgTrace(-1, Dbg, ("File orphan\n"));
        goto FINALLY;
    }

    if (FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_FILE_RENAMED) ||
        FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_FILE_DELETED) ){
        RxDbgTrace(-1, Dbg, ("File already closed by ren/del\n"));
        goto FINALLY;
    }

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    if (smbSrvOpen->Fid == 0xffff) {
        // File has already been closed on the server.
        goto FINALLY;
    }

    NeedDelete = FlagOn(capFcb->FcbState,FCB_STATE_DELETE_ON_CLOSE) && (capFcb->OpenCount == 0);

    if (!NeedDelete &&
        !SearchHandleOpen &&
        FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)){
        RxDbgTrace(-1, Dbg, ("File was not really open\n"));
        goto FINALLY;
    }

    if (smbSrvOpen->Version == pServerEntry->Server.Version) {
        Status = SmbPseCreateOrdinaryExchange(
                               RxContext,
                               SrvOpen->pVNetRoot,
                               SMBPSE_OE_FROM_CLOSESRVCALL,
                               SmbPseExchangeStart_Close,
                               &OrdinaryExchange
                               );

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
            goto FINALLY;
        }

        Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

        ASSERT (Status != (STATUS_PENDING));

        SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbClose  exit with status=%08lx\n", Status ));

FINALLY:

    if (!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN) &&
        (pServerEntry != NULL)) {

        MRxSmbDecrementSrvOpenCount(
            pServerEntry,
            smbSrvOpen->Version,
            SrvOpen);

        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN);
    }

    return(Status);
}


NTSTATUS
MRxSmbBuildClose (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a Close SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:

--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildClose\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse, SMB_COM_CLOSE,
                                SMB_REQUEST_SIZE(CLOSE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ CLOSE before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wdB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 3
             smbSrvOpen->Fid,       //  w         _USHORT( Fid );                     // File handle
             0xffffffff,            //  d         _ULONG( LastWriteTimeInSeconds );   // Time of last write, low and high
             SMB_WCT_CHECK(3) 0     //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );
    MRxSmbDumpStufferState (700,"SMB w/ close after stuffing",StufferState);

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}

NTSTATUS
MRxSmbBuildFindClose (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a Close SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;RxCaptureFobx;
    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildFindClose\n", 0 ));

    COVERED_CALL(MRxSmbStartSMBCommand (StufferState, SetInitialSMB_ForReuse, SMB_COM_FIND_CLOSE2,
                                SMB_REQUEST_SIZE(FIND_CLOSE2),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB w/ CLOSE before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
         "0wB!",
                                    //  0         UCHAR WordCount;                    // Count of parameter words = 1
                                    //  w         _USHORT( Sid );                     // Find handle
             smbFobx->Enumeration.SearchHandle,
             SMB_WCT_CHECK(1) 0     //  B!        _USHORT( ByteCount );               // Count of data bytes = 0
                                    //            UCHAR Buffer[1];                    // empty
             );
    MRxSmbDumpStufferState (700,"SMB w/ FindClose2 after stuffing",StufferState);

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}

NTSTATUS
MRxSmbCoreDeleteForSupercedeOrClose(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    BOOLEAN DeleteDirectory
    );

NTSTATUS
SmbPseExchangeStart_Close(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine for close.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;

    PMRX_SMB_FCB      smbFcb     = MRxSmbGetFcbExtension(capFcb);
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_FOBX     smbFobx    = MRxSmbGetFileObjectExtension(capFobx);
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);
    PSMBCEDB_SERVER_ENTRY pServerEntry= SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Close\n", 0 ));

    ASSERT(OrdinaryExchange->Type == ORDINARY_EXCHANGE);

    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

    if(TypeOfOpen==RDBSS_NTC_STORAGE_TYPE_DIRECTORY){
        if (FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN)) {
            // we have a search handle open.....close it

            Status = MRxSmbBuildFindClose(StufferState);

            if (Status == STATUS_SUCCESS) {
                PSMBCE_SERVER pServer;
                // Ensure that the searchhandle is valid

                pServer = SmbCeGetExchangeServer(OrdinaryExchange);

                if (smbFobx->Enumeration.Version == pServer->Version) {
                    NTSTATUS InnerStatus;
                    InnerStatus = SmbPseOrdinaryExchange(
                                      SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                      SMBPSE_OETYPE_FINDCLOSE
                                      );
                }
            }

            // if this didn't work, there's nothing you can do............
            ClearFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_HANDLE_OPEN);
            ClearFlag(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_SEARCH_NOT_THE_FIRST);
        }
    }

    if (OrdinaryExchange->EntryPoint == SMBPSE_OE_FROM_CLEANUPFOBX) {
        RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Close exit after searchhandle close %08lx\n", Status ));
        return Status;
    }

    if ( !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN) ) {
        //even if it didn't work there's nothing i can do......keep going
        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN);

        MRxSmbDecrementSrvOpenCount(pServerEntry,pServerEntry->Server.Version,SrvOpen);

        Status = MRxSmbBuildClose(StufferState);

        if (Status == STATUS_SUCCESS) {

            // Ensure that the Fid is validated
            SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);

            Status = SmbPseOrdinaryExchange(
                         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                         SMBPSE_OETYPE_CLOSE
                         );

            // Ensure that the Fid validation is disabled
            ClearFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);

            if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_WRITE_ONLY_HANDLE)) {
                smbFcb->WriteOnlySrvOpenCount--;
            }
        }
    }

    if ((Status!=STATUS_SUCCESS) ||
        (capFcb->OpenCount > 0)  ||
        !FlagOn(capFcb->FcbState,FCB_STATE_DELETE_ON_CLOSE)) {
        RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Close exit w %08lx\n", Status ));
        return Status;
    }

    RxDbgTrace(0, Dbg, ("SmbPseExchangeStart_Close delete on close\n" ));

    if ( !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_FILE_DELETED)) {
        if (!FlagOn(smbFcb->MFlags,SMB_FCB_FLAG_SENT_DISPOSITION_INFO)) {
            //no need for setinitsmb here because coredelete does a init-on-resuse.....
            //it's not good to pass the name this way...........
            OrdinaryExchange->pPathArgument1 = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);
            Status = MRxSmbCoreDeleteForSupercedeOrClose(
                         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                         ((BOOLEAN)( NodeType(capFcb)==RDBSS_NTC_STORAGE_TYPE_DIRECTORY )));

            if (Status == STATUS_FILE_IS_A_DIRECTORY) {
                Status = MRxSmbCoreDeleteForSupercedeOrClose(
                             SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                             TRUE);
            }
        } else {
            SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_FILE_DELETED);
        }
    }

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Close exit w %08lx\n", Status ));
    return Status;
}

NTSTATUS
MRxSmbFinishClose (
      PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
      PRESP_CLOSE                 Response
      )
/*++

Routine Description:

    This routine actually gets the stuff out of the Close response and finishes
    the close.

Arguments:

    OrdinaryExchange - the exchange instance

    Response - the response

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;

    RxCaptureFcb;
    RxCaptureFobx;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishClose\n", 0 ));

    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishClose:");

    if (Response->WordCount != 0 ||
        SmbGetUshort(&Response->ByteCount) !=0) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        OrdinaryExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
    } else {
        if (OrdinaryExchange->OEType == SMBPSE_OETYPE_CLOSE) {
            PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
            PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

            smbSrvOpen->Fid = 0xffff;
        }
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishClose   returning %08lx\n", Status ));
    return Status;
}

BOOLEAN
MRxSmbIsStreamFile(
    PUNICODE_STRING FileName,
    PUNICODE_STRING AdjustFileName
    )
/*++

Routine Description:

   This routine checks if it is a stream file and return the root file name if true.

Arguments:

    FileName - the file name needs to be parsed
    AdjustFileName - the file name contains only root name of the stream

Return Value:

    BOOLEAN - stream file

--*/
{
    USHORT   i;
    BOOLEAN  IsStream = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;

    for (i=0;i<FileName->Length/sizeof(WCHAR);i++) {
        if (FileName->Buffer[i] == L':') {
            IsStream = TRUE;
            break;
        }
    }

    if (AdjustFileName != NULL) {
        if (IsStream) {
            AdjustFileName->Length =
            AdjustFileName->MaximumLength = i * sizeof(WCHAR);
            AdjustFileName->Buffer = FileName->Buffer;
        } else {
            AdjustFileName->Length =
            AdjustFileName->MaximumLength = 0;
            AdjustFileName->Buffer = NULL;
        }
    }

    return IsStream;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\netroot.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    netroot.c

Abstract:

    This module implements the routines for creating the SMB net root.

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId  (RDBSS_BUG_CHECK_SMB_NETROOT)

//
//  The local debug trace level
//

#define Dbg (DEBUG_TRACE_DISPATCH)

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbUpdateNetRootState)
#pragma alloc_text(PAGE, MRxSmbGetDialectFlagsFromSrvCall)
#pragma alloc_text(PAGE, MRxSmbCreateVNetRoot)
#pragma alloc_text(PAGE, MRxSmbFinalizeNetRoot)
#pragma alloc_text(PAGE, SmbCeReconnect)
#pragma alloc_text(PAGE, SmbCeEstablishConnection)
#pragma alloc_text(PAGE, SmbConstructNetRootExchangeStart)
#pragma alloc_text(PAGE, MRxSmbExtractNetRootName)
#endif

//
// Forward declarations ...
//

extern NTSTATUS
SmbCeParseConstructNetRootResponse(
   PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange,
   PSMB_HEADER                     pSmbHeader,
   ULONG                           BytesAvailable,
   ULONG                           BytesIndicated,
   ULONG                           *pBytesTaken);

extern NTSTATUS
SmbConstructNetRootExchangeFinalize(
         PSMB_EXCHANGE  pExchange,
         BOOLEAN        *pPostFinalize);

typedef struct _SMBCE_NETROOT_CONSTRUCTION_CONTEXT {
    NTSTATUS                      Status;

    PMRX_CREATENETROOT_CONTEXT    pCreateNetRootContext;
    PMRX_V_NET_ROOT               pVNetRoot;

    RX_WORK_QUEUE_ITEM            WorkQueueItem;
} SMBCE_NETROOT_CONSTRUCTION_CONTEXT,
  *PSMBCE_NETROOT_CONSTRUCTION_CONTEXT;

NTSTATUS
MRxSmbUpdateNetRootState(
    IN OUT PMRX_NET_ROOT pNetRoot)
/*++

Routine Description:

   This routine update the mini redirector state associated with a net root.

Arguments:

    pNetRoot - the net root instance.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    By diffrentiating the mini redirewctor state from the net rot condition it is possible
    to permit a variety of reconnect strategies. It is conceivable that the RDBSS considers
    a net root to be good while the underlying mini redirector might mark it as invalid
    and reconnect on the fly.

--*/
{
    if (pNetRoot->MRxNetRootState == MRX_NET_ROOT_STATE_GOOD) {
        if (pNetRoot->Context == NULL) {
            pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_ERROR;
        } else {
            PSMBCEDB_SERVER_ENTRY   pServerEntry;

            pServerEntry = SmbCeReferenceAssociatedServerEntry(pNetRoot->pSrvCall);
            if (pServerEntry != NULL) {
                switch (pServerEntry->Header.State) {
                case SMBCEDB_ACTIVE:
                     pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_GOOD;
                     break;
                case SMBCEDB_INVALID:
                     pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_DISCONNECTED;
                     break;
                case SMBCEDB_CONSTRUCTION_IN_PROGRESS:
                     pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_RECONN;
                     break;
                default:
                     pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_ERROR;
                     break;
                }

                SmbCeDereferenceServerEntry(pServerEntry);
            } else {
                pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_ERROR;
            }
        }
    }

    return STATUS_SUCCESS;
}

ULONG
MRxSmbGetDialectFlagsFromSrvCall(
    PMRX_SRV_CALL SrvCall
    )
{
   ULONG DialectFlags;
   PSMBCEDB_SERVER_ENTRY pServerEntry;

   PAGED_CODE();

   pServerEntry = SmbCeReferenceAssociatedServerEntry(SrvCall);
   ASSERT(pServerEntry != NULL);
   DialectFlags = pServerEntry->Server.DialectFlags;
   SmbCeDereferenceServerEntry(pServerEntry);
   return(DialectFlags);
}


NTSTATUS
MRxSmbCreateVNetRoot(
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    )
/*++

Routine Description:

   This routine patches the RDBSS created net root instance with the information required
   by the mini redirector.

   In case the connection cannot be established, the mini redirector tries to transition
   the VNetRoot into disconnected mode and establishes the connection off-line. If the
   connection failes to establish in the synchronouse way, this routine will do the transition;
   Otherwise, SmbConstructNetRootExchangeFinalize routine will try the transition. In both
   cases, MRxSmbCreateVNetRoot will be called again to establish the connection in disconnected
   mode.

Arguments:

    pVNetRoot - the virtual net root instance.

    pCreateNetRootContext - the net root context for calling back

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS  Status = STATUS_MORE_PROCESSING_REQUIRED;
    PRX_CONTEXT pRxContext = pCreateNetRootContext->RxContext;
    PMRX_V_NET_ROOT pVNetRoot = (PMRX_V_NET_ROOT)pCreateNetRootContext->pVNetRoot;

    PMRX_SRV_CALL pSrvCall;
    PMRX_NET_ROOT pNetRoot;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PUNICODE_STRING pNetRootName,pSrvCallName;

    BOOLEAN  fInitializeNetRoot;
    BOOLEAN  fDeferNetworkInitialization;
    BOOLEAN  CallBack = FALSE;
    extern DWORD   hShareReint;

    PAGED_CODE();

    pNetRoot = pVNetRoot->pNetRoot;
    pSrvCall = pNetRoot->pSrvCall;

    pServerEntry = SmbCeGetAssociatedServerEntry(pSrvCall);

    if (pRxContext->Create.ThisIsATreeConnectOpen){
        InterlockedIncrement(&MRxSmbStatistics.UseCount);
    }

    SmbCeLog(("Vnetroot %wZ \n", pNetRoot->pNetRootName));

    fInitializeNetRoot = (pNetRoot->Context == NULL);
    fDeferNetworkInitialization = pRxContext->Create.TreeConnectOpenDeferred;

    ASSERT((NodeType(pNetRoot) == RDBSS_NTC_NETROOT) &&
           (NodeType(pNetRoot->pSrvCall) == RDBSS_NTC_SRVCALL));

    if (pNetRoot->Type == NET_ROOT_MAILSLOT) {
        pVNetRoot->Context = NULL;
        Status = STATUS_NOT_SUPPORTED;
        RxDbgTrace( 0, Dbg, ("Mailslot open\n"));
    } else if (pNetRoot->Type == NET_ROOT_PIPE) {
        pVNetRoot->Context = NULL;
        Status = STATUS_NOT_SUPPORTED;
        RxDbgTrace( 0, Dbg, ("pipe open to core server\n"));
    }

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        Status = SmbCeFindOrConstructVNetRootContext(
                     pVNetRoot,
                     fDeferNetworkInitialization);
    }

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        // Update the flags on the VNetRootContext to indicate if this is a
        // agent open

        Status = SmbCeEstablishConnection(
                     pVNetRoot,
                     pCreateNetRootContext,
                     fInitializeNetRoot);
    }

    if (Status != STATUS_PENDING) {
        if (!NT_SUCCESS(Status)) {
            if (fInitializeNetRoot &&
                (pNetRoot->Context != NULL)) {
                PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

                SmbCeAcquireResource();

                pNetRootEntry = SmbCeGetAssociatedNetRootEntry(pNetRoot);

                if (pNetRootEntry != NULL) {
                    pNetRootEntry->pRdbssNetRoot = NULL;
                    SmbCeDereferenceNetRootEntry(pNetRootEntry);
                }

                pNetRoot->Context = NULL;

                SmbCeReleaseResource();
            }

            SmbCeDestroyAssociatedVNetRootContext(pVNetRoot);

            if (pRxContext->Create.ThisIsATreeConnectOpen){
                InterlockedIncrement(&MRxSmbStatistics.FailedUseCount);
            }
        }

        pCreateNetRootContext->VirtualNetRootStatus = Status;

        if (fInitializeNetRoot) {
            pCreateNetRootContext->NetRootStatus = Status;
        } else {
            pCreateNetRootContext->NetRootStatus = STATUS_SUCCESS;
        }

        CallBack = TRUE;

        // Map the error code to STATUS_PENDING since this triggers the synchronization
        // mechanism in the RDBSS.
        Status = STATUS_PENDING;
    }

    if (CallBack) {
        // Callback the RDBSS for resumption.
        pCreateNetRootContext->Callback(pCreateNetRootContext);
    }

    return Status;
}

NTSTATUS
MRxSmbFinalizeVNetRoot(
    IN PMRX_V_NET_ROOT pVNetRoot,
    IN PBOOLEAN        ForceDisconnect)
/*++

Routine Description:


Arguments:

    pVNetRoot - the virtual net root

    ForceDisconnect - disconnect is forced

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;
    PSMBCEDB_SESSION_ENTRY pDefaultSessionEntry;

    // This cannot be paged code since we meed to protect the default session list with the lock

    RxDbgTrace( 0, Dbg, ("MRxSmbFinalizeVNetRoot %lx\n",pVNetRoot));

    if (pVNetRoot->Context != NULL) {
        SmbCeDestroyAssociatedVNetRootContext(pVNetRoot);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
MRxSmbFinalizeNetRoot(
    IN PMRX_NET_ROOT   pNetRoot,
    IN PBOOLEAN        ForceDisconnect)
/*++

Routine Description:


Arguments:

    pVirtualNetRoot - the virtual net root

    ForceDisconnect - disconnect is forced

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("MRxSmbFinalizeNetRoot %lx\n",pNetRoot));

    if (pNetRoot->Context != NULL) {
        SmbCeAcquireResource();

        pNetRootEntry = SmbCeGetAssociatedNetRootEntry(pNetRoot);

        InterlockedCompareExchangePointer(
            &pNetRootEntry->pRdbssNetRoot,
            NULL,
            pNetRoot);

        SmbCeDereferenceNetRootEntry(pNetRootEntry);

        ASSERT(!FlagOn(pNetRoot->Flags,NETROOT_FLAG_FINALIZE_INVOKED));
        SetFlag(pNetRoot->Flags,NETROOT_FLAG_FINALIZE_INVOKED);

        SmbCeReleaseResource();
    }

    return STATUS_SUCCESS;
}

VOID
SmbCeReconnectCallback(
   PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext)
/*++

Routine Description:

   This routine signals the completion of a reconnect attempt

Arguments:

    pCreateNetRootContext - the net root context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
   KeSetEvent(&pCreateNetRootContext->FinishEvent, IO_NETWORK_INCREMENT, FALSE );
}

NTSTATUS
SmbCeReconnect(
    IN PMRX_V_NET_ROOT            pVNetRoot)
/*++

Routine Description:

   This routine reconnects, i.e, establishes a new session and tree connect to a previously
   connected serverb share

Arguments:

    pVNetRoot - the virtual net root instance.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PSMBCEDB_SERVER_ENTRY     pServerEntry;
    PSMBCEDB_SESSION_ENTRY    pSessionEntry;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)pVNetRoot->Context;

    PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext;

    PAGED_CODE();

    if ((pVNetRootContext != NULL) &&
        (pVNetRootContext->Header.State == SMBCEDB_ACTIVE)) {
        pServerEntry  = pVNetRootContext->pServerEntry;
        pSessionEntry = pVNetRootContext->pSessionEntry;
        pNetRootEntry = pVNetRootContext->pNetRootEntry;

        if ((pServerEntry->Header.State == SMBCEDB_ACTIVE) &&
            (pSessionEntry->Header.State == SMBCEDB_ACTIVE) &&
            (pNetRootEntry->Header.State == SMBCEDB_ACTIVE)) {
            return STATUS_SUCCESS;
        }
    }

    pCreateNetRootContext = (PMRX_CREATENETROOT_CONTEXT)
                            RxAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(MRX_CREATENETROOT_CONTEXT),
                                MRXSMB_NETROOT_POOLTAG);

    if (pCreateNetRootContext != NULL) {
        for (;;) {
            pCreateNetRootContext->pVNetRoot  = (PV_NET_ROOT)pVNetRoot;
            pCreateNetRootContext->NetRootStatus  = STATUS_SUCCESS;
            pCreateNetRootContext->VirtualNetRootStatus = STATUS_SUCCESS;
            pCreateNetRootContext->Callback       = SmbCeReconnectCallback;
            pCreateNetRootContext->RxContext      = NULL;

            KeInitializeEvent(
                &pCreateNetRootContext->FinishEvent,
                SynchronizationEvent,
                FALSE );

            // Since this is a reconnect instance the net root initialization is not required
            Status = SmbCeEstablishConnection(
                         pVNetRoot,
                         pCreateNetRootContext,
                         FALSE);

            if (Status == STATUS_PENDING) {
                // Wait for the construction to be completed.
                KeWaitForSingleObject(
                    &pCreateNetRootContext->FinishEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL);

                Status = pCreateNetRootContext->VirtualNetRootStatus;
            }

            if (Status != STATUS_LINK_FAILED) {
                break;
            }
        }

        RxFreePool(pCreateNetRootContext);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
SmbCeEstablishConnection(
    IN OUT PMRX_V_NET_ROOT        pVNetRoot,
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext,
    IN BOOLEAN                    fInitializeNetRoot
    )
/*++

Routine Description:

   This routine triggers off the connection attempt for initial establishment of a
   connection as well as subsequent reconnect attempts.

Arguments:

    pVNetRoot - the virtual net root instance.

    pCreateNetRootContext - the net root context for calling back

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    PSMBCEDB_SERVER_ENTRY     pServerEntry;
    PSMBCEDB_SESSION_ENTRY    pSessionEntry;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    PAGED_CODE();

    pVNetRootContext = SmbCeGetAssociatedVNetRootContext(pVNetRoot);
    
    if (pVNetRootContext == NULL) {
        Status = STATUS_BAD_NETWORK_PATH;
    } else {
        pServerEntry  = pVNetRootContext->pServerEntry;
        pSessionEntry = pVNetRootContext->pSessionEntry;
        pNetRootEntry = pVNetRootContext->pNetRootEntry;

        Status = STATUS_SUCCESS;
    }

    if (Status == STATUS_SUCCESS) {
        //
        // The following code initializes the NetRootEntry, VNetRootContext and
        // the session entry under certain cases.
        //
        // The session entry to a doenlevel server needs to be initialized. This
        // is not handled by the previous code since the session  entry and the
        // net root entry initialization can be combined into one exchange.
        //
        // The net root entry has not been initialized, i.e., this corresponds to
        // the construction of the first SMBCE_V_NET_ROOT_CONTEXT instance for a
        // given NetRootEntry.
        //
        // Subsequent SMBCE_V_NET_ROOT context constructions. In these cases the
        // construction of each context must obtain a new TID
        //

        BOOLEAN fNetRootExchangeRequired;

        fNetRootExchangeRequired = (
                                    (pSessionEntry->Header.State != SMBCEDB_ACTIVE) ||
                                    !BooleanFlagOn(
                                        pVNetRootContext->Flags,
                                        SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID)
                                  );

        if (fNetRootExchangeRequired) {
            // This is a tree connect open which needs to be triggered immediately.
            PSMB_EXCHANGE                  pSmbExchange;
            PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange;

            pSmbExchange = SmbMmAllocateExchange(CONSTRUCT_NETROOT_EXCHANGE,NULL);
            if (pSmbExchange != NULL) {
                Status = SmbCeInitializeExchange(
                             &pSmbExchange,
                             NULL,
                             pVNetRoot,
                             CONSTRUCT_NETROOT_EXCHANGE,
                             &ConstructNetRootExchangeDispatch);

                if (Status == STATUS_SUCCESS) {
                    pNetRootExchange = (PSMB_CONSTRUCT_NETROOT_EXCHANGE)pSmbExchange;

                    // Attempt to reconnect( In this case it amounts to establishing the
                    // connection/session)
                    pNetRootExchange->SmbCeFlags |= (SMBCE_EXCHANGE_ATTEMPT_RECONNECTS |
                                                   SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION);

                    // Initialize the continuation for resumption upon completion of the
                    // tree connetcion.
                    pNetRootExchange->NetRootCallback       = pCreateNetRootContext->Callback;
                    pNetRootExchange->pCreateNetRootContext = pCreateNetRootContext;

                    pNetRootExchange->fInitializeNetRoot =  fInitializeNetRoot;

                    // Initiate the exchange.
                    Status = SmbCeInitiateExchange(pSmbExchange);

                    if (Status != STATUS_PENDING) {
                        SmbCeDiscardExchangeWorkerThreadRoutine(pSmbExchange);
                    }
                }
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    return Status;
}

//
// The net roots are normally constructed as part of some other exchange, i.e., the SMB for
// Tree connect is compounded with other operations. However, there is one situation in which
// the tree connect SMB needs to be sent by itself. This case refers to the prefix claim
// situation ( net use command ). This is handled by the construct net root exchange.
//

#define CONSTRUCT_NETROOT_BUFFER_SIZE (4096)

NTSTATUS
SmbConstructNetRootExchangeStart(
      PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

    This is the start routine for net root construction exchanges. This initiates the
    construction of the appropriate SMB's if required.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    NTSTATUS RequestLockStatus = STATUS_UNSUCCESSFUL;
    NTSTATUS ResponseLockStatus = STATUS_UNSUCCESSFUL;

    PVOID pSmbActualBuffer;
    PVOID pSmbBuffer;
    UCHAR SmbCommand,LastCommandInHeader;
    ULONG SmbLength;

    PUCHAR pCommand;

    PMDL  pSmbRequestMdl,pSmbResponseMdl;
    ULONG SmbMdlSize;

    PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange;
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(pExchange);
    PMRX_NET_ROOT pNetRoot = pExchange->SmbCeContext.pVNetRoot->pNetRoot;

    PAGED_CODE();

    pNetRootExchange = (PSMB_CONSTRUCT_NETROOT_EXCHANGE)pExchange;

    ASSERT(pNetRootExchange->Type == CONSTRUCT_NETROOT_EXCHANGE);

    if (pNetRoot->Type == NET_ROOT_PIPE) {
        RxDbgTrace( 0, Dbg, ("pipe open to core server\n"));
        return STATUS_NOT_SUPPORTED;
    }

    pSmbRequestMdl = pSmbResponseMdl = NULL;

    pSmbActualBuffer = RxAllocatePoolWithTag(
                           PagedPool,
                           (CONSTRUCT_NETROOT_BUFFER_SIZE + TRANSPORT_HEADER_SIZE),
                           MRXSMB_NETROOT_POOLTAG);

    if (pSmbActualBuffer != NULL) {
        PSMBCE_SERVER pServer = SmbCeGetExchangeServer(pExchange);

        (PCHAR) pSmbBuffer = (PCHAR) pSmbActualBuffer + TRANSPORT_HEADER_SIZE;

        Status = SmbCeBuildSmbHeader(
                     pExchange,
                     pSmbBuffer,
                     CONSTRUCT_NETROOT_BUFFER_SIZE,
                     &SmbLength,
                     &LastCommandInHeader,
                     &pCommand);

        // Ensure that the NET_ROOT/SESSION still needs to be constructed before
        // sending it. It is likely that they were costructed by an earlier exchange
        if (NT_SUCCESS(Status) &&
            (SmbLength > sizeof(SMB_HEADER))) {

            if (LastCommandInHeader != SMB_COM_TREE_CONNECT){
                *pCommand = SMB_COM_NO_ANDX_COMMAND;
            }

            RxAllocateHeaderMdl(
                pSmbBuffer,
                SmbLength,
                pSmbRequestMdl
                );

            pSmbResponseMdl = RxAllocateMdl(pSmbBuffer,CONSTRUCT_NETROOT_BUFFER_SIZE);

            if ((pSmbRequestMdl != NULL) &&
                (pSmbResponseMdl != NULL)) {

                RxProbeAndLockHeaderPages(
                    pSmbRequestMdl,
                    KernelMode,
                    IoModifyAccess,
                    RequestLockStatus);

                RxProbeAndLockPages(
                    pSmbResponseMdl,
                    KernelMode,
                    IoModifyAccess,
                    ResponseLockStatus);

                if ((Status  == STATUS_SUCCESS) &&
                    ((Status = RequestLockStatus)  == STATUS_SUCCESS) &&
                    ((Status = ResponseLockStatus) == STATUS_SUCCESS)) {

                    pNetRootExchange->pSmbResponseMdl = pSmbResponseMdl;
                    pNetRootExchange->pSmbRequestMdl  = pSmbRequestMdl;
                    pNetRootExchange->pSmbActualBuffer = pSmbActualBuffer;
                    pNetRootExchange->pSmbBuffer      = pSmbBuffer;

                    Status = SmbCeTranceive(
                                 pExchange,
                                 (RXCE_SEND_PARTIAL | RXCE_SEND_SYNCHRONOUS),
                                 pNetRootExchange->pSmbRequestMdl,
                                 SmbLength);

                    RxDbgTrace( 0, Dbg, ("Net Root SmbCeTranceive returned %lx\n",Status));
                }
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

            if ((Status != STATUS_PENDING) &&
                (Status != STATUS_SUCCESS)) {

                pNetRootExchange->pSmbResponseMdl = NULL;
                pNetRootExchange->pSmbRequestMdl  = NULL;
                pNetRootExchange->pSmbActualBuffer = NULL;
                pNetRootExchange->pSmbBuffer      = NULL;

                if (pSmbResponseMdl != NULL) {
                    if (ResponseLockStatus == STATUS_SUCCESS) {
                        MmUnlockPages(pSmbResponseMdl);
                    }

                    IoFreeMdl(pSmbResponseMdl);
                }

                if (pSmbRequestMdl != NULL) {
                    if (RequestLockStatus == STATUS_SUCCESS) {
                        RxUnlockHeaderPages(pSmbRequestMdl);
                    }

                    IoFreeMdl(pSmbRequestMdl);
                }

                RxFreePool(pSmbActualBuffer);
            }
        } else {

            RxFreePool(pSmbActualBuffer);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
SmbConstructNetRootExchangeReceive(
    IN struct _SMB_EXCHANGE *pExchange,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT ULONG               *pBytesTaken,
    IN  PSMB_HEADER         pSmbHeader,
    OUT PMDL                *pDataBufferPointer,
    OUT PULONG              pDataSize,
    IN ULONG                ReceiveFlags)
/*++

Routine Description:

    This is the recieve indication handling routine for net root construction exchanges

Arguments:

    pExchange - the exchange instance

    BytesIndicated - the number of bytes indicated

    Bytes Available - the number of bytes available

    pBytesTaken     - the number of bytes consumed

    pSmbHeader      - the byte buffer

    pDataBufferPointer - the buffer into which the remaining data is to be copied.

    pDataSize       - the buffer size.

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    This routine is called at DPC level.

--*/
{
    NTSTATUS Status;

    PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange;

    pNetRootExchange = (PSMB_CONSTRUCT_NETROOT_EXCHANGE)pExchange;

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesIndicated/Available %ld %ld\n",BytesIndicated,BytesAvailable));

    if (BytesAvailable > BytesIndicated ||
        !FlagOn(ReceiveFlags,TDI_RECEIVE_ENTIRE_MESSAGE)) {
        // The SMB response was not completely returned. Post a copy data request to
        // get the remainder of the response. If the response is greater than the original
        // buffer size, abort this connection request and consume the bytes available.

        if (BytesAvailable > CONSTRUCT_NETROOT_BUFFER_SIZE) {
            ASSERT(!"not enough bytes in parsesmbheader.....sigh.............."); // To be removed soon ...
            pExchange->Status = STATUS_NOT_IMPLEMENTED;
            *pBytesTaken = BytesAvailable;
            Status       = STATUS_SUCCESS;
        } else {
            *pBytesTaken        = 0;
            *pDataBufferPointer = pNetRootExchange->pSmbResponseMdl;
            *pDataSize          = CONSTRUCT_NETROOT_BUFFER_SIZE;
            Status              = STATUS_MORE_PROCESSING_REQUIRED;
        }
    } else {
        // The SMB exchange completed without an error.
        pExchange->Status = SmbCeParseConstructNetRootResponse(
                                 pNetRootExchange,
                                 pSmbHeader,
                                 BytesAvailable,
                                 BytesIndicated,
                                 pBytesTaken);

        RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesTaken %ld\n",*pBytesTaken));
        RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader Return Status %lx\n",pExchange->Status));
        Status = STATUS_SUCCESS;
    }

    return Status;
}

NTSTATUS
SmbConstructNetRootExchangeCopyDataHandler(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL       pCopyDataBuffer,
    IN ULONG            DataSize)
/*++

Routine Description:

    This is the copy data handling routine for net root construction exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange;

    PSMB_HEADER pSmbHeader;
    ULONG       ResponseSize = DataSize;
    ULONG       ResponseBytesConsumed = 0;
    NTSTATUS    Status = STATUS_SUCCESS;

    pNetRootExchange = (PSMB_CONSTRUCT_NETROOT_EXCHANGE)pExchange;
    ASSERT(pCopyDataBuffer == pNetRootExchange->pSmbResponseMdl);

    pSmbHeader = (PSMB_HEADER)MmGetSystemAddressForMdlSafe(pNetRootExchange->pSmbResponseMdl,LowPagePriority);

    if (pSmbHeader != NULL) {
        pExchange->Status = SmbCeParseConstructNetRootResponse(
                               pNetRootExchange,
                               pSmbHeader,
                               ResponseSize,
                               ResponseSize,
                               &ResponseBytesConsumed);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesTaken %ld\n",ResponseBytesConsumed));

    return Status;
}

NTSTATUS
SmbCeParseConstructNetRootResponse(
    PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange,
    PSMB_HEADER                     pSmbHeader,
    ULONG                           BytesAvailable,
    ULONG                           BytesIndicated,
    ULONG                           *pBytesTaken)
{
    NTSTATUS     Status,SmbResponseStatus;
    GENERIC_ANDX CommandToProcess;

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesIndicated %ld\n",BytesIndicated));
    Status = SmbCeParseSmbHeader(
                 (PSMB_EXCHANGE)pNetRootExchange,
                 pSmbHeader,
                 &CommandToProcess,
                 &SmbResponseStatus,
                 BytesAvailable,
                 BytesIndicated,
                 pBytesTaken);

    if (Status == STATUS_SUCCESS) {
        *pBytesTaken = BytesIndicated;
    }

    return Status;
}


NTSTATUS
SmbConstructNetRootExchangeFinalize(
    PSMB_EXCHANGE pExchange,
    BOOLEAN       *pPostFinalize)
/*++

Routine Description:

    This routine finalizes the construct net root exchange. It resumes the RDBSS by invoking
    the call back and discards the exchange

Arguments:

    pExchange - the exchange instance

    CurrentIrql - the current interrupt request level

    pPostFinalize - a pointer to a BOOLEAN if the request should be posted

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange;
    PMRX_CREATENETROOT_CONTEXT      pCreateNetRootContext;
    PMRX_NETROOT_CALLBACK           pNetRootCallback;

    PMRX_V_NET_ROOT pVNetRoot;
    PMRX_NET_ROOT   pNetRoot;
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;
    NTSTATUS Status = pExchange->Status;

    if (RxShouldPostCompletion()) {
        *pPostFinalize = TRUE;
        return STATUS_SUCCESS;
    } else {
        *pPostFinalize = FALSE;
    }

    pVNetRoot = SmbCeGetExchangeVNetRoot(pExchange);
    pNetRoot  = pVNetRoot->pNetRoot;

    pVNetRootContext = SmbCeGetAssociatedVNetRootContext(pVNetRoot);

    ASSERT((pVNetRoot == NULL) || (pVNetRoot->pNetRoot == pNetRoot));
    pNetRootExchange = (PSMB_CONSTRUCT_NETROOT_EXCHANGE)pExchange;
    pNetRootCallback = pNetRootExchange->NetRootCallback;

    ASSERT(pNetRootExchange->Type == CONSTRUCT_NETROOT_EXCHANGE);

    pCreateNetRootContext = pNetRootExchange->pCreateNetRootContext;

    pCreateNetRootContext->VirtualNetRootStatus = STATUS_SUCCESS;
    pCreateNetRootContext->NetRootStatus        = STATUS_SUCCESS;

    RxDbgTrace(0,Dbg,("SmbConstructNetRootExchangeFinalize: Net Root Exchange Status %lx\n", pExchange->Status));
    if (!NT_SUCCESS(pExchange->Status)) {
        if (pCreateNetRootContext->RxContext &&
            pCreateNetRootContext->RxContext->Create.ThisIsATreeConnectOpen){
            InterlockedIncrement(&MRxSmbStatistics.FailedUseCount);
        }

        pCreateNetRootContext->VirtualNetRootStatus = Status;

        if (pCreateNetRootContext->VirtualNetRootStatus == STATUS_INVALID_HANDLE) {
            pCreateNetRootContext->VirtualNetRootStatus = STATUS_UNEXPECTED_NETWORK_ERROR;
        }

        if (pNetRootExchange->fInitializeNetRoot) {
            pCreateNetRootContext->NetRootStatus = Status;

            if (pCreateNetRootContext->NetRootStatus == STATUS_INVALID_HANDLE) {
                pCreateNetRootContext->NetRootStatus = STATUS_UNEXPECTED_NETWORK_ERROR;
            }
        }

        SmbCeUpdateVNetRootContextState(
            pVNetRootContext,
            SMBCEDB_MARKED_FOR_DELETION);
    } else {
        PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

        pNetRootEntry = SmbCeGetExchangeNetRootEntry(pExchange);

        // Update the associated wrapper data structures.
        SmbCeUpdateNetRoot(pNetRootEntry,pNetRoot);
    }

    SmbCeReferenceVNetRootContext(pVNetRootContext);
    SmbCeCompleteVNetRootContextInitialization(pVNetRootContext);
    pExchange->SmbCeFlags &= ~SMBCE_EXCHANGE_NETROOT_CONSTRUCTOR;

    ASSERT((pCreateNetRootContext->VirtualNetRootStatus != STATUS_SUCCESS) || (pVNetRoot->Context != NULL));

    if ((pCreateNetRootContext->NetRootStatus == STATUS_CONNECTION_RESET)||(pCreateNetRootContext->NetRootStatus == STATUS_IO_TIMEOUT))
    {
        SmbCeLog(("!!Remote Reset Status=%x\n", pCreateNetRootContext->NetRootStatus));
    }

    if (pNetRootExchange->pSmbResponseMdl != NULL) {
        MmUnlockPages(pNetRootExchange->pSmbResponseMdl);
        IoFreeMdl(pNetRootExchange->pSmbResponseMdl);
    }

    if (pNetRootExchange->pSmbRequestMdl != NULL) {
        RxUnlockHeaderPages(pNetRootExchange->pSmbRequestMdl);
        IoFreeMdl(pNetRootExchange->pSmbRequestMdl);
    }

    if (pNetRootExchange->pSmbActualBuffer != NULL) {

        RxFreePool(pNetRootExchange->pSmbActualBuffer);
    }

    // Tear down the exchange instance ...
    SmbCeDiscardExchange(pExchange);

    // Callback the RDBSS for resumption
    pNetRootCallback(pCreateNetRootContext);

    return STATUS_SUCCESS;
}




SMB_EXCHANGE_DISPATCH_VECTOR
ConstructNetRootExchangeDispatch = {
                                       SmbConstructNetRootExchangeStart,
                                       SmbConstructNetRootExchangeReceive,
                                       SmbConstructNetRootExchangeCopyDataHandler,
                                       NULL,  // No SendCompletionHandler
                                       SmbConstructNetRootExchangeFinalize,
                                       NULL
                                   };


VOID
MRxSmbExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    )
/*++

Routine Description:

    This routine parses the input name into srv, netroot, and the
    rest.

Arguments:


--*/
{
    UNICODE_STRING xRestOfName;

    ULONG length = FilePathName->Length;
    PWCH w = FilePathName->Buffer;
    PWCH wlimit = (PWCH)(((PCHAR)w)+length);
    PWCH wlow;

    PAGED_CODE();

    w += (SrvCall->pSrvCallName->Length/sizeof(WCHAR));
    NetRootName->Buffer = wlow = w;
    for (;;) {
        if (w>=wlimit) break;
        if ( (*w == OBJ_NAME_PATH_SEPARATOR) && (w!=wlow) ){
            break;
        }
        w++;
    }
    NetRootName->Length = NetRootName->MaximumLength
                = (USHORT)((PCHAR)w - (PCHAR)wlow);

    if (!RestOfName) RestOfName = &xRestOfName;
    RestOfName->Buffer = w;
    RestOfName->Length = RestOfName->MaximumLength
                       = (USHORT)((PCHAR)wlimit - (PCHAR)w);

    RxDbgTrace( 0,Dbg,("  MRxSmbExtractNetRootName FilePath=%wZ\n",FilePathName));
    RxDbgTrace(0,Dbg,("         Srv=%wZ,Root=%wZ,Rest=%wZ\n",
                        SrvCall->pSrvCallName,NetRootName,RestOfName));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\precomp.h ===
// a minirdr must declare his name and his imports ptr

#define MINIRDR__NAME SmbMRx
#define ___MINIRDR_IMPORTS_NAME (MRxSmbDeviceObject->RdbssExports)

#include "ntifs.h"         // get the minirdr environment
#include "rx.h"         // get the minirdr environment

#include "netevent.h"

#include <windef.h>
#include "mrxprocs.h"     // the global include for this mini

#include "smbprocs.h"


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\sessetup.c ===
/*++
Copyright (c) 1987-1999  Microsoft Corporation

Module Name:

    sessetup.c

Abstract:

    This module implements the Session setup related routines

--*/

#include "precomp.h"
#pragma hdrstop

#include "ntlmsp.h"

//
//  The local debug trace level
//

#define Dbg (DEBUG_TRACE_DISPATCH)

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, BuildSessionSetupSmb)
#pragma alloc_text(PAGE, BuildNtLanmanResponsePrologue)
#pragma alloc_text(PAGE, BuildNtLanmanResponseEpilogue)
#pragma alloc_text(PAGE, BuildSessionSetupSecurityInformation)
#pragma alloc_text(PAGE, BuildTreeConnectSecurityInformation)
#endif

BOOLEAN EnablePlainTextPassword = FALSE;


NTSTATUS
BuildSessionSetupSmb(
    PSMB_EXCHANGE pExchange,
    PGENERIC_ANDX  pAndXSmb,
    PULONG         pAndXSmbBufferSize)
/*++

Routine Description:

   This routine builds the session setup SMB for a NT server

Arguments:

    pExchange - the exchange instance

    pAndXSmb  - the session setup to be filled in

    pAndXSmbBufferSize - the SMB buffer size on input modified to remaining size on
                         output.

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    Eventhough the general structure of the code tries to isolate dialect specific issues
    as much as possible this routine takes the opposite approach. This is because of the
    preamble and prologue to security interaction which far outweigh the dialect specific
    work required to be done. Therefore in the interests of a smaller footprint this approach
    has been adopted.

--*/
{
    NTSTATUS Status;

    PSMBCEDB_SESSION_ENTRY pSessionEntry;
    PSMBCE_SERVER          pServer;
    PSMBCE_SESSION         pSession;

    PREQ_SESSION_SETUP_ANDX pSessionSetup;
    PREQ_NT_SESSION_SETUP_ANDX pNtSessionSetup;

    ULONG OriginalBufferSize = *pAndXSmbBufferSize;

    PAGED_CODE();

    pSessionEntry = SmbCeGetExchangeSessionEntry(pExchange);
    pServer  = SmbCeGetExchangeServer(pExchange);
    pSession = SmbCeGetExchangeSession(pExchange);

    // There are three different variants of session setup and X that can be shipped to the
    // server. All three of them share some common fields. The setting of these common fields
    // is done in all the three cases by accessing the passed in buffer as an instance of
    // REQ_SESSION_SETUP_ANDX. The fields specific to the remaining two are conditionalized upon
    // accessing the same buffer as an instance of REQ_NT_SESSION_SETUP_ANDX.  This implies that
    // great care must be taken in shuffling the fields in these two structs.

    pSessionSetup           = (PREQ_SESSION_SETUP_ANDX)pAndXSmb;
    pNtSessionSetup         = (PREQ_NT_SESSION_SETUP_ANDX)pSessionSetup;

    pSessionSetup->AndXCommand = 0xff;   // No ANDX
    pSessionSetup->AndXReserved = 0x00;  // Reserved (MBZ)

    SmbPutUshort(&pSessionSetup->AndXOffset, 0x0000); // No AndX as of yet.

    //  Since we can allocate pool dynamically, we set our buffer size
    //  to match that of the server.
    SmbPutUshort(&pSessionSetup->MaxBufferSize, (USHORT)pServer->MaximumBufferSize);
    SmbPutUshort(&pSessionSetup->MaxMpxCount, pServer->MaximumRequests);

    SmbPutUshort(&pSessionSetup->VcNumber, (USHORT)pSessionEntry->SessionVCNumber);

    SmbPutUlong(&pSessionSetup->SessionKey, pServer->SessionKey);
    SmbPutUlong(&pSessionSetup->Reserved, 0);

    if (pServer->Dialect == NTLANMAN_DIALECT) {
        // Set up the NT server session setup specific parameters.
            SmbPutUshort(&pNtSessionSetup->WordCount,13);

            // Set the capabilities
            SmbPutUlong(
                &pNtSessionSetup->Capabilities,
                (CAP_NT_STATUS |
                 CAP_UNICODE |
                 CAP_LEVEL_II_OPLOCKS |
                 CAP_NT_SMBS ));
    } else {
        SmbPutUshort(&pSessionSetup->WordCount,10);
    }

    // Build the security information in the session setup SMB.
    Status = BuildSessionSetupSecurityInformation(
                 pExchange,
                 (PBYTE)pSessionSetup,
                 pAndXSmbBufferSize);

    if (NT_SUCCESS(Status)) {
        // Copy the operating system name and the LANMAN version info
        // position the buffer for copying the operating system name and the lanman type.
        PBYTE pBuffer = (PBYTE)pSessionSetup +
                        OriginalBufferSize -
                        *pAndXSmbBufferSize;

        if (FlagOn(pServer->DialectFlags,DF_UNICODE)){

            //
            // Make sure the UNICODE string is suitably aligned
            //
            if( ((ULONG_PTR)pBuffer) & 01 ) {
                pBuffer++;
                (*pAndXSmbBufferSize)--;
            }

            Status = SmbPutUnicodeString(
                         &pBuffer,
                         &SmbCeContext.OperatingSystem,
                         pAndXSmbBufferSize);

            if (NT_SUCCESS(Status)) {

                Status = SmbPutUnicodeString(
                             &pBuffer,
                             &SmbCeContext.LanmanType,
                             pAndXSmbBufferSize);
            }
        } else {
            Status = SmbPutUnicodeStringAsOemString(
                         &pBuffer,
                         &SmbCeContext.OperatingSystem,
                         pAndXSmbBufferSize);

            if (NT_SUCCESS(Status)) {
                Status = SmbPutUnicodeStringAsOemString(
                             &pBuffer,
                             &SmbCeContext.LanmanType,
                             pAndXSmbBufferSize);
            }
        }

        if (NT_SUCCESS(Status)) {
            if (pServer->Dialect == NTLANMAN_DIALECT) {
                    SmbPutUshort(
                        &pNtSessionSetup->ByteCount,
                        (USHORT)(OriginalBufferSize -
                        FIELD_OFFSET(REQ_NT_SESSION_SETUP_ANDX,Buffer) -
                        *pAndXSmbBufferSize));
            } else {
                SmbPutUshort(
                    &pSessionSetup->ByteCount,
                    (USHORT)(OriginalBufferSize -
                    FIELD_OFFSET(REQ_SESSION_SETUP_ANDX,Buffer) -
                    *pAndXSmbBufferSize));
            }
        }
    }

    return Status;
}


#define IsCredentialHandleValid(pCredHandle)    \
        (((pCredHandle)->dwLower != 0xffffffff) && ((pCredHandle)->dwUpper != 0xffffffff))

#define IsSecurityContextHandleValid(pContextHandle)    \
        (((pContextHandle)->dwLower != 0xffffffff) && ((pContextHandle)->dwUpper != 0xffffffff))


NTSTATUS
BuildNtLanmanResponsePrologue(
    PSMB_EXCHANGE              pExchange,
    PUNICODE_STRING            pUserName,
    PUNICODE_STRING            pDomainName,
    PSTRING                    pCaseSensitiveResponse,
    PSTRING                    pCaseInsensitiveResponse,
    PSECURITY_RESPONSE_CONTEXT pResponseContext)
/*++

Routine Description:

   This routine builds the security related information for the session setup SMB.

Arguments:


Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS       Status;
    NTSTATUS       FinalStatus;

    UNICODE_STRING ServerName;

    PVOID           pTargetInformation;
    ULONG           TargetInformationSize;

    SecBufferDesc   InputToken;
    SecBuffer       InputBuffer[2];
    SecBufferDesc   *pOutputBufferDescriptor = NULL;
    SecBuffer       *pOutputBuffer           = NULL;
    ULONG_PTR        OutputBufferDescriptorSize;

    ULONG LsaFlags = ISC_REQ_ALLOCATE_MEMORY;
    TimeStamp Expiry;
    PCHALLENGE_MESSAGE InToken = NULL;
    ULONG InTokenSize;
    PNTLM_CHALLENGE_MESSAGE NtlmInToken = NULL;
    ULONG NtlmInTokenSize = 0;
    PAUTHENTICATE_MESSAGE OutToken = NULL;
    PNTLM_INITIALIZE_RESPONSE NtlmOutToken = NULL;
    PUCHAR          p = NULL;
    ULONG_PTR       AllocateSize;

    PSMBCE_SERVER  pServer  = SmbCeGetExchangeServer(pExchange);
    PSMBCE_SESSION pSession = SmbCeGetExchangeSession(pExchange);

    PAGED_CODE();

    try {
        pResponseContext->LanmanSetup.pResponseBuffer = NULL;

            SmbCeGetServerName(
                pExchange->SmbCeContext.pVNetRoot->pNetRoot->pSrvCall,
                &ServerName);

            TargetInformationSize = ServerName.Length;
            pTargetInformation    = ServerName.Buffer;

            InTokenSize = sizeof(CHALLENGE_MESSAGE) + TargetInformationSize;

            NtlmInTokenSize = sizeof(NTLM_CHALLENGE_MESSAGE);

            if (pSession->pPassword != NULL) {
                NtlmInTokenSize += pSession->pPassword->Length;
                LsaFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
            }

            if (pSession->pUserName != NULL) {
                NtlmInTokenSize += pSession->pUserName->Length;
                LsaFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
            }

            if (pSession->pUserDomainName != NULL) {
                NtlmInTokenSize += pSession->pUserDomainName->Length;
                LsaFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
            }

            // For Alignment purposes, we want InTokenSize rounded up to
            // the nearest word size.

            AllocateSize = ((InTokenSize + 3) & ~3) + NtlmInTokenSize;

            Status = ZwAllocateVirtualMemory(
                         NtCurrentProcess(),
                         &InToken,
                         0L,
                         &AllocateSize,
                         MEM_COMMIT,
                         PAGE_READWRITE);

            if (!NT_SUCCESS(Status)) {
                try_return(Status);
            }

            // Allocate the output buffer
            OutputBufferDescriptorSize = sizeof(SecBufferDesc) + 2 * sizeof(SecBuffer);

            Status = ZwAllocateVirtualMemory(
                         NtCurrentProcess(),
                         &pOutputBufferDescriptor,
                         0L,
                         &OutputBufferDescriptorSize,
                         MEM_COMMIT,
                         PAGE_READWRITE);

            if (!NT_SUCCESS(Status)) {
                try_return(Status);
            }

            pOutputBuffer = (SecBuffer *)(pOutputBufferDescriptor + 1);
            pResponseContext->LanmanSetup.pResponseBuffer = pOutputBufferDescriptor;

            RxDbgTrace(0,Dbg,("Allocate VM %08lx in process %8lx\n", InToken, NtCurrentProcess()));

            // partition off the NTLM in token part of the
            // buffer
            if (LsaFlags & ISC_REQ_USE_SUPPLIED_CREDS)
            {
                NtlmInToken = (PNTLM_CHALLENGE_MESSAGE) ((PUCHAR) InToken + InTokenSize);
                NtlmInToken = (PNTLM_CHALLENGE_MESSAGE) (((ULONG_PTR) NtlmInToken + 3) & ~3);
                RtlZeroMemory(NtlmInToken,NtlmInTokenSize);
                p = (PUCHAR) NtlmInToken + sizeof(NTLM_CHALLENGE_MESSAGE);
            }

            if(!IsCredentialHandleValid(&pSession->CredentialHandle)) {
                UNICODE_STRING LMName;
                TimeStamp LifeTime;

                LMName.Buffer = (PWSTR) InToken;
                LMName.Length = NTLMSP_NAME_SIZE;
                LMName.MaximumLength = LMName.Length;
                RtlCopyMemory(
                    LMName.Buffer,
                    NTLMSP_NAME,
                    NTLMSP_NAME_SIZE);


                Status = AcquireCredentialsHandleW(
                             NULL,
                             &LMName,
                             SECPKG_CRED_OUTBOUND,
                             &pSession->LogonId,
                             NULL,
                             NULL,
                             (PVOID)1,
                             &pSession->CredentialHandle,
                             &LifeTime);

                if(!NT_SUCCESS(Status)) {
                    pSession->CredentialHandle.dwUpper = 0xffffffff;
                    pSession->CredentialHandle.dwLower = 0xffffffff;
                    try_return(Status);
                }
            }

            // Copy in the pass,user,domain if they were specified
            if(pSession->pPassword != NULL) {
                NtlmInToken->Password.Length = pSession->pPassword->Length;
                NtlmInToken->Password.MaximumLength = pSession->pPassword->Length;
                RtlCopyMemory(
                    p,
                    pSession->pPassword->Buffer,
                    pSession->pPassword->Length);
                NtlmInToken->Password.Buffer = (ULONG) (p - (PUCHAR)NtlmInToken);
                p += pSession->pPassword->Length;
            }

            if(pSession->pUserName != NULL) {
                NtlmInToken->UserName.Length = pSession->pUserName->Length;
                NtlmInToken->UserName.MaximumLength = pSession->pUserName->Length;
                RtlCopyMemory(
                    p,
                    pSession->pUserName->Buffer,
                    pSession->pUserName->Length);
                NtlmInToken->UserName.Buffer = (ULONG) (p - (PUCHAR)NtlmInToken);
                p += pSession->pUserName->Length;
            }

            if (pSession->pUserDomainName != NULL) {
                NtlmInToken->DomainName.Length = pSession->pUserDomainName->Length;
                NtlmInToken->DomainName.MaximumLength = pSession->pUserDomainName->Length;
                RtlCopyMemory(
                    p,
                    pSession->pUserDomainName->Buffer,
                    pSession->pUserDomainName->Length);
                NtlmInToken->DomainName.Buffer = (ULONG) (p - (PUCHAR)NtlmInToken);
                p += pSession->pUserDomainName->Length;
            }

            RtlCopyMemory(
                InToken->Signature,
                NTLMSSP_SIGNATURE,
                sizeof(NTLMSSP_SIGNATURE));
            InToken->MessageType = NtLmChallenge;

            InToken->NegotiateFlags = NTLMSSP_NEGOTIATE_UNICODE |
                                      NTLMSSP_NEGOTIATE_OEM |
                                      NTLMSSP_REQUEST_INIT_RESPONSE |
                                      NTLMSSP_TARGET_TYPE_SERVER;

            RtlCopyMemory(
                InToken->Challenge,
                pServer->EncryptionKey,
                MSV1_0_CHALLENGE_LENGTH);

            InToken->TargetName.Length =
            InToken->TargetName.MaximumLength = (USHORT)TargetInformationSize;
            InToken->TargetName.Buffer = sizeof(CHALLENGE_MESSAGE);

            RtlCopyMemory(
                (PCHAR)InToken + sizeof(CHALLENGE_MESSAGE),
                pTargetInformation,
                TargetInformationSize);

            InputToken.pBuffers = InputBuffer;
            InputToken.cBuffers = 1;
            InputToken.ulVersion = 0;
            InputBuffer[0].pvBuffer = InToken;
            InputBuffer[0].cbBuffer = InTokenSize;
            InputBuffer[0].BufferType = SECBUFFER_TOKEN;

            if (LsaFlags & ISC_REQ_USE_SUPPLIED_CREDS)
            {
                InputToken.cBuffers = 2;
                InputBuffer[1].pvBuffer = NtlmInToken;
                InputBuffer[1].cbBuffer = NtlmInTokenSize;
                InputBuffer[1].BufferType = SECBUFFER_TOKEN;
            }

            pOutputBufferDescriptor->pBuffers = pOutputBuffer;
            pOutputBufferDescriptor->cBuffers = 2;
            pOutputBufferDescriptor->ulVersion = 0;
            pOutputBuffer[0].pvBuffer = NULL;
            pOutputBuffer[0].cbBuffer = 0;
            pOutputBuffer[0].BufferType = SECBUFFER_TOKEN;
            pOutputBuffer[1].pvBuffer = NULL;
            pOutputBuffer[1].cbBuffer = 0;
            pOutputBuffer[1].BufferType = SECBUFFER_TOKEN;

                Status = InitializeSecurityContextW(
                             &pSession->CredentialHandle,
                             (PCtxtHandle)NULL,
                             NULL,
                             LsaFlags,
                             0,
                             SECURITY_NATIVE_DREP,
                             &InputToken,
                             0,
                             &pSession->SecurityContextHandle,
                             pOutputBufferDescriptor,
                             &FinalStatus,
                             &Expiry);

            if(!NT_SUCCESS(Status)) {
                Status = MapSecurityError(Status);
                SmbCeLog(("IniSecCtxStat %lx %lx\n",SmbCeGetExchangeSessionEntry(pExchange),Status));
                try_return(Status);
            }

            OutToken = (PAUTHENTICATE_MESSAGE) pOutputBuffer[0].pvBuffer;

            ASSERT(OutToken != NULL);
            RxDbgTrace(0,Dbg,("InitSecCtxt OutToken is %8lx\n", OutToken));

            // The security response the pointers are encoded in terms off the offset
            // from the beginning of the buffer. Make the appropriate adjustments.

            if (ARGUMENT_PRESENT(pCaseSensitiveResponse)) {
                pCaseSensitiveResponse->Length        = OutToken->NtChallengeResponse.Length;
                pCaseSensitiveResponse->MaximumLength = OutToken->NtChallengeResponse.MaximumLength;
                pCaseSensitiveResponse->Buffer = (PBYTE)OutToken + (ULONG_PTR)OutToken->NtChallengeResponse.Buffer;
            }

            if (ARGUMENT_PRESENT(pCaseInsensitiveResponse)) {
                pCaseInsensitiveResponse->Length        = OutToken->LmChallengeResponse.Length;
                pCaseInsensitiveResponse->MaximumLength = OutToken->LmChallengeResponse.MaximumLength;
                pCaseInsensitiveResponse->Buffer = (PBYTE)OutToken + (ULONG_PTR)OutToken->LmChallengeResponse.Buffer;
            }

            if (pSession->pUserDomainName != NULL) {
                *pDomainName = *(pSession->pUserDomainName);
            } else {
                pDomainName->Length        = OutToken->DomainName.Length;
                pDomainName->MaximumLength = pDomainName->Length;
                pDomainName->Buffer = (PWCHAR)((PBYTE)OutToken + (ULONG_PTR)OutToken->DomainName.Buffer);
            }

            if (pSession->pUserName != NULL) {
                *pUserName = *(pSession->pUserName);
            } else {
                pUserName->Length        = OutToken->UserName.Length;
                pUserName->MaximumLength = OutToken->UserName.MaximumLength;
                pUserName->Buffer = (PWCHAR)((PBYTE)OutToken + (ULONG_PTR)OutToken->UserName.Buffer);
            }

            NtlmOutToken = pOutputBuffer[1].pvBuffer;
            if (NtlmOutToken != NULL) {
                RtlCopyMemory(
                    pSession->UserSessionKey,
                    NtlmOutToken->UserSessionKey,
                    MSV1_0_USER_SESSION_KEY_LENGTH);

                RtlCopyMemory(
                    pSession->LanmanSessionKey,
                    NtlmOutToken->LanmanSessionKey,
                    MSV1_0_LANMAN_SESSION_KEY_LENGTH);
            }

try_exit:NOTHING;
    } finally {
        if (InToken != NULL) {
            NTSTATUS TemporaryStatus;

            TemporaryStatus = ZwFreeVirtualMemory(
                                  NtCurrentProcess(),
                                  &InToken,
                                  &AllocateSize,
                                  MEM_RELEASE);

            ASSERT (NT_SUCCESS(TemporaryStatus));
        }

        if (!NT_SUCCESS(Status)) {
            BuildNtLanmanResponseEpilogue(pExchange, pResponseContext);
        }
    }

    return Status;
}

NTSTATUS
BuildNtLanmanResponseEpilogue(
    PSMB_EXCHANGE              pExchange,
    PSECURITY_RESPONSE_CONTEXT pResponseContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSMBCE_SESSION pSession = SmbCeGetExchangeSession(pExchange);

    PAGED_CODE();

    if (pResponseContext->LanmanSetup.pResponseBuffer != NULL) {
        ULONG i = 0;
        SecBufferDesc *pBufferDescriptor = (SecBufferDesc *)pResponseContext->LanmanSetup.pResponseBuffer;
        SecBuffer     *pBuffer = pBufferDescriptor->pBuffers;
        ULONG_PTR      BufferDescriptorSize = sizeof(SecBufferDesc) + 2 * sizeof(SecBuffer);

        for (i = 0; i < pBufferDescriptor->cBuffers; i++) {
            if (pBuffer[i].pvBuffer != NULL) {
                FreeContextBuffer(pBuffer[i].pvBuffer);
            }
        }

        Status = ZwFreeVirtualMemory(
                     NtCurrentProcess(),
                     &pBufferDescriptor,
                     &BufferDescriptorSize,
                     MEM_RELEASE);

        pResponseContext->LanmanSetup.pResponseBuffer = NULL;
    }

    return Status;
}


VOID
UninitializeSecurityContextsForSession(
    PSMBCE_SESSION pSession)
{
    CtxtHandle CredentialHandle,SecurityContextHandle,InvalidHandle;

    SmbCeLog(("UninitSecCont %lx\n",pSession));

    InvalidHandle.dwUpper = 0xffffffff;
    InvalidHandle.dwLower = 0xffffffff;

    SmbCeAcquireSpinLock();

    CredentialHandle = pSession->CredentialHandle;
    pSession->CredentialHandle = InvalidHandle;

    SecurityContextHandle = pSession->SecurityContextHandle;
    pSession->SecurityContextHandle = InvalidHandle;

    SmbCeReleaseSpinLock();

    if (IsCredentialHandleValid(&CredentialHandle))
    {
        FreeCredentialsHandle(&CredentialHandle);
    }

    if (IsSecurityContextHandleValid(&SecurityContextHandle)) {
        DeleteSecurityContext(&SecurityContextHandle);
    }
}


NTSTATUS
BuildSessionSetupSecurityInformation(
    PSMB_EXCHANGE   pExchange,
    PBYTE           pSmbBuffer,
    PULONG          pSmbBufferSize)
/*++

Routine Description:

   This routine builds the security related information for the session setup SMB

Arguments:

    pServer  - the server instance

    pSmbBuffer - the SMB buffer

    pSmbBufferSize - the size of the buffer on input ( modified to size remaining on
                     output)

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    Eventhough the genral structure of the code tries to isolate dialect specific issues
    as much as possible this routine takes the opposite approach. This is because of the
    preamble and prologue to security interaction which far outweigh the dialect specific
    work required to be done. Therefore in the interests of a smaller footprint this approach
    has been adopted.

--*/
{
    NTSTATUS Status;

    UNICODE_STRING UserName;
    UNICODE_STRING DomainName;

    STRING CaseSensitiveResponse;
    STRING CaseInsensitiveResponse;

    PSMBCE_SERVER  pServer  = SmbCeGetExchangeServer(pExchange);
    PSMBCE_SESSION pSession = SmbCeGetExchangeSession(pExchange);
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    SECURITY_RESPONSE_CONTEXT ResponseContext;

    PAGED_CODE();
    RxDbgTrace( +1, Dbg, ("BuildSessionSetupSecurityInformation -- Entry\n"));


        Status = BuildNtLanmanResponsePrologue(
                     pExchange,
                     &UserName,
                     &DomainName,
                     &CaseSensitiveResponse,
                     &CaseInsensitiveResponse,
                     &ResponseContext);

        if (Status == STATUS_SUCCESS) {
            // If the security package returns us the credentials corresponding to a
            // NULL session mark the session as a NULL session. This will avoid
            // conflicts with the user trying to present the credentials for a NULL
            // session, i.e., explicitly specified zero length passwords, user name
            // and domain name.

            RxDbgTrace(0,Dbg,("Session %lx UN Length %lx DN length %ld IR length %ld SR length %ld\n",
                              pSession,UserName.Length,DomainName.Length,
                              CaseInsensitiveResponse.Length,CaseSensitiveResponse.Length));

            if ((UserName.Length == 0) &&
                (DomainName.Length == 0) &&
                (CaseSensitiveResponse.Length == 0) &&
                (CaseInsensitiveResponse.Length == 1)) {
                RxDbgTrace(0,Dbg,("Implicit NULL session setup\n"));
                pSession->Flags |= SMBCE_SESSION_FLAGS_NULL_CREDENTIALS;
            }
        }

    if (NT_SUCCESS(Status)) {
        PBYTE    pBuffer    = pSmbBuffer;
        ULONG    BufferSize = *pSmbBufferSize;

        if ((pServer->Dialect == NTLANMAN_DIALECT) && (pServer->EncryptPasswords)) {
            PREQ_NT_SESSION_SETUP_ANDX pNtSessionSetupReq = (PREQ_NT_SESSION_SETUP_ANDX)pSmbBuffer;

            // It it is a NT server both the case insensitive and case sensitive passwords
            // need to be copied. for share-level, just copy a token 1-byte NULL password

            // Position the buffer for copying the password.
            pBuffer += FIELD_OFFSET(REQ_NT_SESSION_SETUP_ANDX,Buffer);
            BufferSize -= FIELD_OFFSET(REQ_NT_SESSION_SETUP_ANDX,Buffer);

            if (pServer->SecurityMode == SECURITY_MODE_USER_LEVEL){

                RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- NtUserPasswords\n"));

                SmbPutUshort(
                    &pNtSessionSetupReq->CaseInsensitivePasswordLength,
                    CaseInsensitiveResponse.Length);

                SmbPutUshort(
                    &pNtSessionSetupReq->CaseSensitivePasswordLength,
                    CaseSensitiveResponse.Length);

                Status = SmbPutString(
                             &pBuffer,
                             &CaseInsensitiveResponse,
                             &BufferSize);

                if (NT_SUCCESS(Status)) {
                    Status = SmbPutString(
                                 &pBuffer,
                                 &CaseSensitiveResponse,
                                 &BufferSize);
                }
            } else {

                RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- NtSharePasswords\n"));

                SmbPutUshort(&pNtSessionSetupReq->CaseInsensitivePasswordLength, 1);
                SmbPutUshort(&pNtSessionSetupReq->CaseSensitivePasswordLength, 1);
                *pBuffer = 0;
                *(pBuffer+1) = 0;
                pBuffer += 2;
                BufferSize -= 2;
            }
        } else {
            PREQ_SESSION_SETUP_ANDX pSessionSetupReq = (PREQ_SESSION_SETUP_ANDX)pSmbBuffer;

            // Position the buffer for copying the password.
            pBuffer += FIELD_OFFSET(REQ_SESSION_SETUP_ANDX,Buffer);
            BufferSize -= FIELD_OFFSET(REQ_SESSION_SETUP_ANDX,Buffer);

            if ( (pServer->SecurityMode == SECURITY_MODE_USER_LEVEL)
                && (CaseInsensitiveResponse.Length > 0)) {

                if (pServer->EncryptPasswords) {
                    // For other lanman servers only the case insensitive password is required.
                    SmbPutUshort(
                        &pSessionSetupReq->PasswordLength,
                        CaseInsensitiveResponse.Length);

                    // Copy the password
                    Status = SmbPutString(
                                 &pBuffer,
                                 &CaseInsensitiveResponse,
                                 &BufferSize);
                } else {
                    if (EnablePlainTextPassword) {
                        if (pSession->pPassword != NULL) {
                            SmbPutUshort(
                                &pSessionSetupReq->PasswordLength,
                                pSession->pPassword->Length/2 + 1);

                            Status = SmbPutUnicodeStringAsOemString(
                                         &pBuffer,
                                         pSession->pPassword,
                                         &BufferSize);
                        } else {
                            SmbPutUshort(&pSessionSetupReq->PasswordLength,1);
                            *pBuffer++ = '\0';
                            BufferSize -= sizeof(CHAR);
                        }
                    } else {
                        Status = STATUS_LOGON_FAILURE;
                    }
                }
            } else {
                // Share level security. Send a null string for the password
                SmbPutUshort(&pSessionSetupReq->PasswordLength,1);
                *pBuffer++ = '\0';
                BufferSize -= sizeof(CHAR);
            }
        }

        // The User name and the domain name strings can be either copied from
        // the information returned in the request response or the information
        // that is already present in the session entry.
        if (NT_SUCCESS(Status)) {
            if ((pServer->Dialect == NTLANMAN_DIALECT) &&
                (pServer->NtServer.NtCapabilities & CAP_UNICODE)) {
                // Copy the account/domain names as UNICODE strings
                PBYTE pTempBuffer = pBuffer;

                RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- account/domain as unicode\n"));
                pBuffer = ALIGN_SMB_WSTR(pBuffer);
                BufferSize -= (ULONG)(pBuffer - pTempBuffer);

                Status = SmbPutUnicodeString(
                             &pBuffer,
                             &UserName,
                             &BufferSize);

                if (NT_SUCCESS(Status)) {
                    Status = SmbPutUnicodeString(
                                 &pBuffer,
                                 &DomainName,
                                 &BufferSize);

                }
            } else {
                // Copy the account/domain names as ASCII strings.
                RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- account/domain as ascii\n"));
                Status = SmbPutUnicodeStringAsOemString(
                             &pBuffer,
                             &UserName,
                             &BufferSize);

                if (NT_SUCCESS(Status)) {
                    Status = SmbPutUnicodeStringAsOemString(
                                 &pBuffer,
                                 &DomainName,
                                 &BufferSize);
                }
            }
        }

        if (NT_SUCCESS(Status)) {
            *pSmbBufferSize = BufferSize;
        }
    }

    BuildNtLanmanResponseEpilogue(pExchange, &ResponseContext);

    // Detach from the rdr process.

    RxDbgTrace( -1, Dbg, ("BuildSessionSetupSecurityInformation -- Exit, status=%08lx\n",Status));
    return Status;
}

NTSTATUS
BuildTreeConnectSecurityInformation(
    PSMB_EXCHANGE  pExchange,
    PBYTE          pBuffer,
    PBYTE          pPasswordLength,
    PULONG         pSmbBufferSize)
/*++

Routine Description:

    This routine builds the security related information for the session setup SMB

Arguments:

    pServer  - the server instance

    pLogonId - the logon id. for which the session is being setup

    pPassword - the user  supplied password if any

    pBuffer - the password buffer

    pPasswordLength - where the password length is to be stored

    pSmbBufferSize - the size of the buffer on input ( modified to size remaining on
                     output)

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    Eventhough the genral structure of the code tries to isolate dialect specific issues
    as much as possible this routine takes the opposite approach. This is because of the
    preamble and prologue to security interaction which far outweigh the dialect specific
    work required to be done. Therefore in the interests of a smaller footprint this approach
    has been adopted.

--*/
{
    NTSTATUS FinalStatus,Status;

    UNICODE_STRING UserName,DomainName;
    STRING         CaseSensitiveChallengeResponse,CaseInsensitiveChallengeResponse;

    SECURITY_RESPONSE_CONTEXT ResponseContext;

    ULONG PasswordLength = 0;

    PSMBCE_SERVER  pServer  = SmbCeGetExchangeServer(pExchange);
    PSMBCE_SESSION pSession = SmbCeGetExchangeSession(pExchange);

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    if (pServer->EncryptPasswords) {

        Status = BuildNtLanmanResponsePrologue(
                     pExchange,
                     &UserName,
                     &DomainName,
                     &CaseSensitiveChallengeResponse,
                     &CaseInsensitiveChallengeResponse,
                     &ResponseContext);

        if (NT_SUCCESS(Status)) {
            if (FlagOn(pServer->DialectFlags,DF_MIXEDCASEPW)) {
                RxDbgTrace( 0, Dbg, ("BuildTreeConnectSecurityInformation -- case sensitive password\n"));
                // Copy the password length onto the SMB buffer
                PasswordLength = CaseSensitiveChallengeResponse.Length;

                // Copy the password
                Status = SmbPutString(
                             &pBuffer,
                             &CaseSensitiveChallengeResponse,
                             pSmbBufferSize);
            } else {
                RxDbgTrace( 0, Dbg, ("BuildTreeConnectSecurityInformation -- case insensitive password\n"));
                // Copy the password length onto the SMB buffer
                PasswordLength = CaseInsensitiveChallengeResponse.Length;

                // Copy the password
                Status = SmbPutString(
                             &pBuffer,
                             &CaseInsensitiveChallengeResponse,
                             pSmbBufferSize);
            }

            BuildNtLanmanResponseEpilogue(pExchange, &ResponseContext);
        }

    } else {
        if (pSession->pPassword == NULL) {
            // The logon password cannot be sent as plain text. Send a Null string as password.

            PasswordLength = 1;
            if (*pSmbBufferSize >= 1) {
                *((PCHAR)pBuffer) = '\0';
                pBuffer += sizeof(CHAR);
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_BUFFER_OVERFLOW;
            }
        } else {
            if (EnablePlainTextPassword) {
                OEM_STRING OemString;

                OemString.Length = OemString.MaximumLength = (USHORT)(*pSmbBufferSize - sizeof(CHAR));
                OemString.Buffer = pBuffer;
                Status = RtlUnicodeStringToOemString(
                             &OemString,
                             pSession->pPassword,
                             FALSE);

                if (NT_SUCCESS(Status)) {
                    PasswordLength = OemString.Length+1;
                }
            } else {
                Status = STATUS_LOGON_FAILURE;
            }
        }

        // reduce the byte count
        *pSmbBufferSize -= PasswordLength;
    }

    SmbPutUshort(pPasswordLength,(USHORT)PasswordLength);

    return Status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbadmin.h ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    smbadmin.h

Abstract:

    This module implements the SMB's that need to be exchanged to facilitate
    bookkeeping at the server

Notes;

    In the normal course of events a TreeId/UserId which translates into a Share/Session instance
    is required to send a SMB to the server. In terms of the local data structures it translates
    to a SMBCEDB_SERVER_ENTRY/SMBCEDB_SESSION_ENTRY/SMBCEDB_NET_ROOT_ENTRY. However, there are a
    few exceptions to this rule in which one or more of the fields in not required. These are
    normally used during connection establishment/connection tear down and connection state
    maintenance.

    All these SMB's have been grouped together in the implementation of SMB_ADMIN_EXCHANGE which
    is derived from SMB_EXCHANGE. All NEGOTIATE,LOG_OFF,DISCONNECT and ECHO SMB are sent
    using this type of exchange. The important factor that distinguishes the SMB_ADMIN_EXCHANGE
    from regular exchanges is the way the state of the exchange is manipulated to take into
    account the specialized requirements of each of the above mentioned commands.

--*/

#ifndef _SMBADMIN_H_
#define _SMBADMIN_H_

#include <smbxchng.h>

typedef struct _SMB_ADMIN_EXCHANGE_ {
    SMB_EXCHANGE;

    UCHAR                     SmbCommand;
    ULONG                     SmbBufferLength;
    PVOID                     pSmbBuffer;
    PMDL              pSmbMdl;
    PSMBCE_RESUMPTION_CONTEXT pResumptionContext;

    union {
        struct {
            PMRX_SRV_CALL  pSrvCall;
            UNICODE_STRING DomainName;
            PMDL           pNegotiateMdl;
        } Negotiate;

        struct {
            UCHAR DisconnectSmb[TRANSPORT_HEADER_SIZE +
                               sizeof(SMB_HEADER) +
                               sizeof(REQ_TREE_DISCONNECT)];
        } Disconnect;

        struct {
            UCHAR LogOffSmb[TRANSPORT_HEADER_SIZE +
                           sizeof(SMB_HEADER) +
                           sizeof(REQ_LOGOFF_ANDX)];
        } LogOff;

        struct {
            PMDL  pEchoProbeMdl;
            ULONG EchoProbeLength;
        } EchoProbe;
    };
} SMB_ADMIN_EXCHANGE, *PSMB_ADMIN_EXCHANGE;

PSMB_EXCHANGE
SmbResetServerEntryNegotiateExchange(
    PSMBCEDB_SERVER_ENTRY pServerEntry);

PSMB_EXCHANGE
SmbResetServerEntryNegotiateExchange(
    PSMBCEDB_SERVER_ENTRY pServerEntry);

extern SMB_EXCHANGE_DISPATCH_VECTOR AdminExchangeDispatch;

extern NTSTATUS
SmbCeNegotiate(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PMRX_SRV_CALL         pSrvCall);

extern NTSTATUS
SmbCeDisconnect(
    PSMBCE_V_NET_ROOT_CONTEXT pNetRootEntry);

extern NTSTATUS
SmbCeLogOff(
    PSMBCEDB_SERVER_ENTRY  pServerEntry,
    PSMBCEDB_SESSION_ENTRY pSessionEntry);

extern NTSTATUS
SmbCeSendEchoProbe(
    PSMBCEDB_SERVER_ENTRY              pServerEntry,
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProbeContext);


#endif // _SMBADMIN_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\smbadmin.c ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    smbadmin.c

Abstract:

    This module implements the SMB's that need to be exchanged to facilitate
    bookkeeping at the server

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbCeNegotiate)
#pragma alloc_text(PAGE, SmbCeDisconnect)
#pragma alloc_text(PAGE, SmbCeLogOff)
#pragma alloc_text(PAGE, SmbCeInitializeAdminExchange)
#pragma alloc_text(PAGE, SmbCeDiscardAdminExchange)
#pragma alloc_text(PAGE, SmbCeCompleteAdminExchange)
#pragma alloc_text(PAGE, SmbAdminExchangeStart)
#endif

//
//  The Bug check file id for this module
//

#define BugCheckFileId  (RDBSS_BUG_CHECK_SMB_NETROOT)

//
//  The local debug trace level
//

#define Dbg (DEBUG_TRACE_DISPATCH)

extern
SMB_EXCHANGE_DISPATCH_VECTOR EchoExchangeDispatch;

extern NTSTATUS
SmbCeInitializeAdminExchange(
    PSMB_ADMIN_EXCHANGE     pSmbAdminExchange,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMBCEDB_SESSION_ENTRY  pSessionEntry,
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    UCHAR                   SmbCommand);

extern VOID
SmbCeDiscardAdminExchange(
    PSMB_ADMIN_EXCHANGE pSmbAdminExchange);

extern NTSTATUS
SmbCeCompleteAdminExchange(
    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange);

VOID
SmbReferenceRecord(
    PREFERENCE_RECORD pReferenceRecord,
    PVOID FileName,
    ULONG FileLine)
{
    int i;

    for (i=REFERENCE_RECORD_SIZE-1;i>0;i--) {
         pReferenceRecord[i].FileName = pReferenceRecord[i-1].FileName;
         pReferenceRecord[i].FileLine = pReferenceRecord[i-1].FileLine;
    }

    pReferenceRecord[0].FileName = FileName;
    pReferenceRecord[0].FileLine = FileLine;
}

PSMB_EXCHANGE
SmbSetServerEntryNegotiateExchange(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PSMB_ADMIN_EXCHANGE   pSmbAdminExchange)
{
    PSMB_EXCHANGE pStoredExchange;

    SmbCeIncrementPendingLocalOperations((PSMB_EXCHANGE)pSmbAdminExchange);

    pStoredExchange = InterlockedCompareExchangePointer(
                          &pServerEntry->pNegotiateExchange,
                          pSmbAdminExchange,
                          NULL);

    if (pStoredExchange != NULL) {
        SmbCeDecrementPendingLocalOperationsAndFinalize((PSMB_EXCHANGE)pSmbAdminExchange);
    }

    return pStoredExchange;
}

PSMB_EXCHANGE
SmbResetServerEntryNegotiateExchange(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
{
    PSMB_EXCHANGE pStoredExchange;

    pStoredExchange = (PSMB_EXCHANGE)InterlockedCompareExchangePointer(
                                         &pServerEntry->pNegotiateExchange,
                                         NULL,
                                         pServerEntry->pNegotiateExchange);

    return pStoredExchange;
}

NTSTATUS
SmbCeNegotiate(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PMRX_SRV_CALL         pSrvCall)
/*++

Routine Description:

    This routine issues the negotiate SMB to the server

Arguments:

    pServerEntry - the server entry

    pSrvCall     - the associated srv call instance in the wrapper

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    Since the negotiate SMB can be directed at either a unknown server or a server
    whose capabilitiese are known it is upto the caller to decide to wait for the
    response.

    On some transports a reconnect is possible without having to tear down an existing
    connection, i.e. attempting to send a packet reestablishes the connection at the
    lower level. Since this is not supported by all the transports ( with the exception
    of TCP/IP) the reference server entry initiates this process by tearing down the
    existing transport and reinitializsing it.

    As part of the negotiate response the domain name to which the server belongs is
    sent back. Since the negotiate response is processed at DPC level, a preparatory
    allocation needs to be made ( This will ensure minimal work at DPC level).

    In this routine this is accomplished by allocating a buffer from nonpaged
    pool of MAX_PATH and associating it with the DomainName fild in the server entry
    prior to the TRanceive. On resumption from Tranceive this buffer is deallocated and
    a buffer from paged pool corresponding to the exact length is allocated to hold the
    domain name.

--*/
{
    NTSTATUS Status;

    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange;

    ULONG    NegotiateSmbLength;
    PVOID    pNegotiateSmb;

    PAGED_CODE();

    pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)SmbMmAllocateExchange(ADMIN_EXCHANGE,NULL);
    if (pSmbAdminExchange != NULL) {
        Status = SmbCeInitializeAdminExchange(
                     pSmbAdminExchange,
                     pServerEntry,
                     NULL,
                     NULL,
                     SMB_COM_NEGOTIATE);

        if (Status == STATUS_SUCCESS) {
            // Build the negotiate SMB and allocate the temporary buffer for
            // the DOMAIN name.

            Status = BuildNegotiateSmb(
                         &pNegotiateSmb,
                         &NegotiateSmbLength);

            if (Status == STATUS_SUCCESS) {
                pSmbAdminExchange->pSmbBuffer      = pNegotiateSmb;
                pSmbAdminExchange->SmbBufferLength = NegotiateSmbLength;

                // Preparatory allocation for the domain name buffer
                pSmbAdminExchange->Negotiate.pSrvCall                 = pSrvCall;
                pSmbAdminExchange->Negotiate.DomainName.Length        = 0;
                pSmbAdminExchange->Negotiate.DomainName.MaximumLength = MAX_PATH;
                pSmbAdminExchange->Negotiate.DomainName.Buffer
                    = (PWCHAR)RxAllocatePoolWithTag(
                                  NonPagedPool,
                                  MAX_PATH,
                                  MRXSMB_ADMIN_POOLTAG);

                if (pSmbAdminExchange->Negotiate.DomainName.Buffer == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            if (Status == STATUS_SUCCESS) {
                BOOLEAN fExchangeDiscarded = FALSE;
                SMBCE_RESUMPTION_CONTEXT ResumptionContext;
                PSMB_EXCHANGE pStoredExchange;

                SmbCeInitializeResumptionContext(&ResumptionContext);
                pSmbAdminExchange->pResumptionContext = &ResumptionContext;

                // Since the Negotiate SMB is the first SMB that is sent on a
                // connection the MID mapping data structures have not been setup.
                // Therefore a certain amount of additional initialization is
                // required to ensure that the Negotiate SMB can be handled correctly.
                // This involves presetting the MID field in the header and the
                // SMBCE_EXCHANGE_MID_VALID field in the exchange.
                //
                // A beneficial side effect of implementing it this way is the reduced
                // path length for the regular Send/Receives on a connection.

                pSmbAdminExchange->SmbCeFlags = (SMBCE_EXCHANGE_REUSE_MID  |
                                                 SMBCE_EXCHANGE_RETAIN_MID |
                                                 SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION |
                                                 SMBCE_EXCHANGE_MID_VALID);

                // Prevent the admin exchange from being finalized before returning back to this routine.
                SmbCeIncrementPendingLocalOperations((PSMB_EXCHANGE)pSmbAdminExchange);

                pStoredExchange = SmbSetServerEntryNegotiateExchange(
                                      pServerEntry,
                                      pSmbAdminExchange);

                if ((pServerEntry->Header.State == SMBCEDB_CONSTRUCTION_IN_PROGRESS) &&
                    (pStoredExchange == NULL)) {

                    // The Negotiate SMB exchange has been built successfully. Initiate it.
                    Status = SmbCeInitiateExchange((PSMB_EXCHANGE)pSmbAdminExchange);

                    if ((pSmbAdminExchange->SmbStatus != STATUS_SUCCESS) ||
                        (Status != STATUS_PENDING && Status != STATUS_SUCCESS)) {
                        pStoredExchange = (PSMB_EXCHANGE)InterlockedCompareExchangePointer(
                                                             &pServerEntry->pNegotiateExchange,
                                                             NULL,
                                                             pSmbAdminExchange);

                        if (pStoredExchange == (PSMB_EXCHANGE)pSmbAdminExchange) {
                            SmbCeDecrementPendingLocalOperations((PSMB_EXCHANGE)pSmbAdminExchange);
                        }

                        if (pSmbAdminExchange->SmbStatus == STATUS_SUCCESS) {
                            pSmbAdminExchange->SmbStatus = Status;
                        }

                        pSmbAdminExchange->Status = pSmbAdminExchange->SmbStatus;
                    }

                    // Admin exchange is ready to be finalized
                    SmbCeDecrementPendingLocalOperationsAndFinalize((PSMB_EXCHANGE)pSmbAdminExchange);

                    // Wait for the finalization.
                    SmbCeSuspend(&ResumptionContext);
                    Status = SmbCeCompleteAdminExchange(pSmbAdminExchange);
                } else {
                    InterlockedCompareExchangePointer(
                         &pServerEntry->pNegotiateExchange,
                         NULL,
                         pSmbAdminExchange);

                    SmbCeDiscardAdminExchange(pSmbAdminExchange);
                    Status = STATUS_CONNECTION_DISCONNECTED;
                }
            }
        } else {
            SmbMmFreeExchange((PSMB_EXCHANGE)pSmbAdminExchange);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
SmbCeSendEchoProbe(
    PSMBCEDB_SERVER_ENTRY              pServerEntry,
    PMRXSMB_ECHO_PROBE_SERVICE_CONTEXT pEchoProbeContext)
/*++

Routine Description:

    This routine sends an echo probe to the specified server

Arguments:

    pServerEntry     - the server entry

    pEchoProbeCOntext - the echo probe context

Return Value:

    STATUS_SUCCESS - the disconnect SMB was sent successfully

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status;

    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange;

    pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)SmbMmAllocateExchange(ADMIN_EXCHANGE,NULL);
    if (pSmbAdminExchange != NULL) {
        Status = SmbCeInitializeAdminExchange(
                     pSmbAdminExchange,
                     pServerEntry,
                     NULL,
                     NULL,
                     SMB_COM_ECHO);

        if (Status == STATUS_SUCCESS) {
            ULONG EchoMdlSize;
            ULONG requestSize;

            pSmbAdminExchange->Mid = SMBCE_ECHO_PROBE_MID;
            pSmbAdminExchange->SmbCeFlags = (SMBCE_EXCHANGE_REUSE_MID  |
                                             SMBCE_EXCHANGE_RETAIN_MID |
                                             SMBCE_EXCHANGE_TIMED_RECEIVE_OPERATION |
                                             SMBCE_EXCHANGE_MID_VALID);

            requestSize = pEchoProbeContext->EchoSmbLength + TRANSPORT_HEADER_SIZE;

            EchoMdlSize = (ULONG)MmSizeOfMdl(
                                     pEchoProbeContext->pEchoSmb,
                                     requestSize);
            pSmbAdminExchange->EchoProbe.pEchoProbeMdl =
                          RxAllocatePoolWithTag(
                              NonPagedPool,
                              (EchoMdlSize + requestSize ),
                              MRXSMB_ADMIN_POOLTAG);

            if (pSmbAdminExchange->EchoProbe.pEchoProbeMdl != NULL) {
                PBYTE pEchoProbeBuffer;

                pEchoProbeBuffer = (PBYTE)pSmbAdminExchange->EchoProbe.pEchoProbeMdl +
                    EchoMdlSize + TRANSPORT_HEADER_SIZE;

                pSmbAdminExchange->EchoProbe.EchoProbeLength = pEchoProbeContext->EchoSmbLength;

                RtlCopyMemory(
                    pEchoProbeBuffer,
                    pEchoProbeContext->pEchoSmb,
                    pEchoProbeContext->EchoSmbLength);

                RxInitializeHeaderMdl(
                    pSmbAdminExchange->EchoProbe.pEchoProbeMdl,
                    pEchoProbeBuffer,
                    pEchoProbeContext->EchoSmbLength);

                MmBuildMdlForNonPagedPool(
                    pSmbAdminExchange->EchoProbe.pEchoProbeMdl);

                InterlockedIncrement(&pServerEntry->Server.NumberOfEchoProbesSent);

                // The ECHO probe SMB exchange has been built successfully. Initiate it.
                Status = SmbCeInitiateExchange((PSMB_EXCHANGE)pSmbAdminExchange);
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

            if (Status != STATUS_PENDING) {
                Status = SmbCeCompleteAdminExchange(pSmbAdminExchange);
            }
        } else {
            SmbMmFreeExchange((PSMB_EXCHANGE)pSmbAdminExchange);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
SmbCeDisconnect(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext)
/*++

Routine Description:

    This routine issues the disconnect SMB for an existing connection to the server

Arguments:

    pServerEntry     - the server entry

    pVNetRootContext - the VNetRootContext

Return Value:

    STATUS_SUCCESS - the disconnect SMB was sent successfully

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status;

    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange;
    PSMB_HEADER          pSmbHeader;
    PREQ_TREE_DISCONNECT pReqTreeDisconnect;

    PAGED_CODE();

    pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)SmbMmAllocateExchange(ADMIN_EXCHANGE,NULL);
    if (pSmbAdminExchange != NULL) {
        UCHAR  LastCommandInHeader;
        PUCHAR pCommand;

        Status = SmbCeInitializeAdminExchange(
                     pSmbAdminExchange,
                     pVNetRootContext->pServerEntry,
                     pVNetRootContext->pSessionEntry,
                     pVNetRootContext->pNetRootEntry,
                     SMB_COM_TREE_DISCONNECT);

        if (Status == STATUS_SUCCESS) {
            BOOLEAN fExchangeDiscarded = FALSE;

            pSmbAdminExchange->pSmbBuffer =
                (PCHAR) pSmbAdminExchange->Disconnect.DisconnectSmb + TRANSPORT_HEADER_SIZE;

            pSmbHeader         = (PSMB_HEADER)pSmbAdminExchange->pSmbBuffer;
            pReqTreeDisconnect = (PREQ_TREE_DISCONNECT)(pSmbHeader + 1);

            // Build the header
            Status = SmbCeBuildSmbHeader(
                         (PSMB_EXCHANGE)pSmbAdminExchange,
                         pSmbAdminExchange->pSmbBuffer,
                         sizeof(SMB_HEADER),
                         &pSmbAdminExchange->SmbBufferLength,
                         &LastCommandInHeader,
                         &pCommand);

            if (Status == STATUS_SUCCESS) {
                ASSERT(LastCommandInHeader == SMB_COM_NO_ANDX_COMMAND);
                *pCommand = SMB_COM_TREE_DISCONNECT;

                pSmbHeader->Tid = pVNetRootContext->TreeId;
                pReqTreeDisconnect->WordCount = 0;
                SmbPutUshort(&pReqTreeDisconnect->ByteCount,0);

                pSmbAdminExchange->SmbBufferLength += FIELD_OFFSET(REQ_TREE_DISCONNECT,Buffer);

                Status = SmbCeInitiateExchange((PSMB_EXCHANGE)pSmbAdminExchange);

                if ((Status == STATUS_PENDING) ||
                    (Status == STATUS_SUCCESS)) {
                    // async completion will also discard the exchange
                    fExchangeDiscarded = TRUE;
                }
            }

            if (!fExchangeDiscarded) {
                SmbCeDiscardAdminExchange(pSmbAdminExchange);
            }
        } else {
            SmbMmFreeExchange((PSMB_EXCHANGE)pSmbAdminExchange);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
SmbCeLogOff(
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMBCEDB_SESSION_ENTRY  pSessionEntry)
/*++

Routine Description:

    This routine issues the logoff SMB for an existing session to the server

Arguments:

    pServerEntry  - the server entry

    pSessionEntry - the associated session entry

Return Value:

    STATUS_SUCCESS - the logoff was successfully sent.

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status;

    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange;
    PSMB_HEADER          pSmbHeader;
    PREQ_LOGOFF_ANDX     pReqLogOffAndX;

    PAGED_CODE();

    if (pServerEntry->Server.SecurityMode == SECURITY_MODE_SHARE_LEVEL) {
        if (pSessionEntry != NULL) {
            SmbCeDereferenceSessionEntry(pSessionEntry);
        }

        return STATUS_SUCCESS;
    }

    //
    // Some servers (like linux) don't really know how to handle session logoffs.
    //  So, let's just be sure that we only do this to NT or better servers,
    //  because we know that they handle it correctly.  The version of Linux we have
    //  seems to like to negotiate the NT dialect even though it really isn't NT.  That's
    //  why the extra check is put in here for NT status codes.
    //
    if( pServerEntry->Server.Dialect < NTLANMAN_DIALECT ||
        !FlagOn(pServerEntry->Server.DialectFlags,DF_NT_STATUS) ) {
        if (pSessionEntry != NULL) {
            SmbCeDereferenceSessionEntry(pSessionEntry);
        }
        return STATUS_SUCCESS;
    }

    pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)SmbMmAllocateExchange(ADMIN_EXCHANGE,NULL);
    if (pSmbAdminExchange != NULL) {
        UCHAR  LastCommandInHeader;
        PUCHAR pCommand;

        Status = SmbCeInitializeAdminExchange(
                     pSmbAdminExchange,
                     pServerEntry,
                     pSessionEntry,
                     NULL,
                     SMB_COM_LOGOFF_ANDX);

        if (Status == STATUS_SUCCESS) {
            BOOLEAN fExchangeDiscarded = FALSE;

            pSmbAdminExchange->pSmbBuffer =
                (PCHAR) pSmbAdminExchange->LogOff.LogOffSmb + TRANSPORT_HEADER_SIZE;

            pSmbHeader         = (PSMB_HEADER)pSmbAdminExchange->pSmbBuffer;
            pReqLogOffAndX     = (PREQ_LOGOFF_ANDX)(pSmbHeader + 1);

            // Build the header
            Status = SmbCeBuildSmbHeader(
                         (PSMB_EXCHANGE)pSmbAdminExchange,
                         pSmbAdminExchange->pSmbBuffer,
                         sizeof(SMB_HEADER),
                         &pSmbAdminExchange->SmbBufferLength,
                         &LastCommandInHeader,
                         &pCommand);


            if (Status == STATUS_SUCCESS) {
                ASSERT(LastCommandInHeader == SMB_COM_NO_ANDX_COMMAND);
                *pCommand = SMB_COM_LOGOFF_ANDX;

                pReqLogOffAndX->WordCount    = 2;
                pReqLogOffAndX->AndXCommand  = SMB_COM_NO_ANDX_COMMAND;
                pReqLogOffAndX->AndXReserved = 0;

                SmbPutUshort(&pReqLogOffAndX->AndXOffset,0);
                SmbPutUshort(&pReqLogOffAndX->ByteCount,0);

                pSmbAdminExchange->SmbBufferLength += FIELD_OFFSET(REQ_LOGOFF_ANDX,Buffer);

                Status = SmbCeInitiateExchange((PSMB_EXCHANGE)pSmbAdminExchange);

                if ((Status == STATUS_PENDING) ||
                    (Status == STATUS_SUCCESS)) {

                    // async completion will discard the exchange
                    fExchangeDiscarded = TRUE;
                }
            }

            if (!fExchangeDiscarded) {
                SmbCeDiscardAdminExchange(pSmbAdminExchange);
            }
        } else {
            SmbMmFreeExchange((PSMB_EXCHANGE)pSmbAdminExchange);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
SmbCeInitializeAdminExchange(
    PSMB_ADMIN_EXCHANGE     pSmbAdminExchange,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMBCEDB_SESSION_ENTRY  pSessionEntry,
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry,
    UCHAR                   SmbCommand)
/*++

Routine Description:

    This routine initializes the ADMIN exchange

Arguments:

    pSmbAdminExchange  - the exchange

    pServerEntry       - the associated server entry

    pSessionEntry      - the associated session entry

    pNetRootEntry      - the associated net root entry

    SmbCommand         - the SMB command

Return Value:

    STATUS_SUCCESS - the logoff was successfully sent.

    Other Status codes correspond to error situations.

Notes:

    The ADMIN_EXCHANGE is a special type of exchange used for bootstrap/teardown
    situations in which the initialization of the exchange cannot follow the noraml
    course of events. In some cases not all the components required for proper
    initialization of the exchange are present, e.g., NEGOTIATE we do not have a
    valid session/tree connect. It is for this reason that the three important
    elements of initialization, i.e., Server/Session/NetRoot have to be explicitly
    specified. NULL is used to signify a dont care situation for a particular component.

--*/
{
    NTSTATUS Status;

    PAGED_CODE();

    Status = SmbCeIncrementActiveExchangeCount();

    if (Status == STATUS_SUCCESS) {
        PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

        pSmbAdminExchange->CancellationStatus = SMBCE_EXCHANGE_NOT_CANCELLED;

        if ((SmbCommand == SMB_COM_NEGOTIATE) ||
            (SmbCommand == SMB_COM_ECHO)) {
            pSmbAdminExchange->SmbCeContext.pServerEntry     = pServerEntry;
            pSmbAdminExchange->SmbCeContext.pVNetRootContext = NULL;
        } else {
            pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)
                       RxAllocatePoolWithTag(
                            NonPagedPool,
                            sizeof(SMBCE_V_NET_ROOT_CONTEXT),
                            MRXSMB_VNETROOT_POOLTAG);

            if (pVNetRootContext != NULL) {
                pVNetRootContext->pServerEntry = pServerEntry;
                pVNetRootContext->pSessionEntry = pSessionEntry;
                pVNetRootContext->pNetRootEntry = pNetRootEntry;

                pSmbAdminExchange->SmbCeContext.pVNetRootContext = pVNetRootContext;
                pSmbAdminExchange->SmbCeContext.pServerEntry = pServerEntry;
            }  else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (Status == STATUS_SUCCESS) {
            SmbCeReferenceServerEntry(pServerEntry);

            pSmbAdminExchange->pSmbMdl    = NULL;
            pSmbAdminExchange->pSmbBuffer = NULL;
            pSmbAdminExchange->SmbBufferLength = 0;

            // Set the SmbCe state to overrule the common method of having to hunt
            // up a valid TID/FID etc. and reconnects.
            pSmbAdminExchange->SmbCommand = SmbCommand;
            pSmbAdminExchange->SmbCeState = SMBCE_EXCHANGE_NETROOT_INITIALIZED;

            switch (pSmbAdminExchange->SmbCommand) {
            case SMB_COM_NEGOTIATE:
                {
                    pSmbAdminExchange->Negotiate.DomainName.Length = 0;
                    pSmbAdminExchange->Negotiate.DomainName.MaximumLength = 0;
                    pSmbAdminExchange->Negotiate.DomainName.Buffer = NULL;
                    pSmbAdminExchange->Negotiate.pNegotiateMdl  = NULL;
                }
                break;

            case SMB_COM_TREE_DISCONNECT:
            case SMB_COM_LOGOFF_ANDX:
                break;

            case SMB_COM_ECHO:
                {
                    pSmbAdminExchange->pDispatchVector = &EchoExchangeDispatch;
                    pSmbAdminExchange->EchoProbe.pEchoProbeMdl = NULL;
                    pSmbAdminExchange->EchoProbe.EchoProbeLength = 0;
                }
                break;

            default:
                ASSERT(!"Valid Command for Admin Exchange");
                break;
            }
        }
    }

    return Status;
}

VOID
SmbCeDiscardAdminExchange(
    PSMB_ADMIN_EXCHANGE pSmbAdminExchange)
/*++

Routine Description:

    This routine discards the ADMIN exchange

Arguments:

    pSmbAdminExchange  - the exchange

--*/
{
    PSMBCEDB_SERVER_ENTRY     pServerEntry;
    PSMBCEDB_SESSION_ENTRY    pSessionEntry;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    PAGED_CODE();

    SmbCeAcquireResource();
    RemoveEntryList(&pSmbAdminExchange->ExchangeList);
    SmbCeReleaseResource();

    pServerEntry  = SmbCeGetExchangeServerEntry(pSmbAdminExchange);
    pSessionEntry = SmbCeGetExchangeSessionEntry(pSmbAdminExchange);
    pNetRootEntry = SmbCeGetExchangeNetRootEntry(pSmbAdminExchange);

    pVNetRootContext = SmbCeGetExchangeVNetRootContext(pSmbAdminExchange);

    if (pSmbAdminExchange->pSmbMdl != NULL) {
        RxUnlockHeaderPages(pSmbAdminExchange->pSmbMdl);
        IoFreeMdl(pSmbAdminExchange->pSmbMdl);
    }

    switch (pSmbAdminExchange->SmbCommand) {
    case SMB_COM_NEGOTIATE:
        {
            pSmbAdminExchange->pSmbBuffer = NULL;

            if (pSmbAdminExchange->Negotiate.DomainName.Buffer != NULL) {
                RxFreePool(
                    pSmbAdminExchange->Negotiate.DomainName.Buffer);
            }

            if (pSmbAdminExchange->Negotiate.pNegotiateMdl != NULL) {
                IoFreeMdl(
                    pSmbAdminExchange->Negotiate.pNegotiateMdl);
            }
        }
        break;

    case SMB_COM_TREE_DISCONNECT:
        break;

    case SMB_COM_LOGOFF_ANDX:
        {
            SmbCeUpdateSessionEntryState(pSessionEntry,SMBCEDB_MARKED_FOR_DELETION);
            SmbCeDereferenceSessionEntry(pSessionEntry);
        }
        break;

    case SMB_COM_ECHO:
        {
            if (pSmbAdminExchange->EchoProbe.pEchoProbeMdl != NULL) {
                MmPrepareMdlForReuse(pSmbAdminExchange->EchoProbe.pEchoProbeMdl);
                RxFreePool(pSmbAdminExchange->EchoProbe.pEchoProbeMdl);
            }
        }
        break;

    default:
        ASSERT(!"Valid Command For Admin Exchange");
        break;
    }

    // Tear down all the copy data requests associated with this exchange
    SmbCePurgeBuffersAssociatedWithExchange(pServerEntry,(PSMB_EXCHANGE)pSmbAdminExchange);

    SmbCeUninitializeExchangeTransport((PSMB_EXCHANGE)pSmbAdminExchange);

    SmbCeDereferenceServerEntry(pServerEntry);

    if (pVNetRootContext != NULL) {
        RxFreePool(pVNetRootContext);
    }

    SmbMmFreeExchange((PSMB_EXCHANGE)pSmbAdminExchange);
    SmbCeDecrementActiveExchangeCount();
}

NTSTATUS
SmbCeCompleteAdminExchange(
    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange)
/*++

Routine Description:

    This is the routine used for completing the SMB ADMIN exchanges.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine encapsulates the TAIL for all SMB admin exchanges. They carry
    out the local action required based upon the outcome of the exchange.

--*/
{
    NTSTATUS              Status = STATUS_SUCCESS;
    PSMBCEDB_SERVER_ENTRY pServerEntry;
    SMBCEDB_OBJECT_STATE  ServerState;

    PAGED_CODE();

    pServerEntry = SmbCeGetExchangeServerEntry(pSmbAdminExchange);

    switch (pSmbAdminExchange->SmbCommand) {
    case SMB_COM_NEGOTIATE:
        {
            if (pSmbAdminExchange->Status != STATUS_SUCCESS) {
                pServerEntry->ServerStatus = pSmbAdminExchange->Status;
            }

            if (pServerEntry->ServerStatus == STATUS_SUCCESS) {
                if (pServerEntry->DomainName.Buffer) {
                    RxFreePool(pServerEntry->DomainName.Buffer);
                    pServerEntry->DomainName.Buffer = NULL;
                }

                pServerEntry->DomainName.Length = pSmbAdminExchange->Negotiate.DomainName.Length;
                pServerEntry->DomainName.MaximumLength = pServerEntry->DomainName.Length;

                if (pServerEntry->DomainName.Length > 0) {
                    pServerEntry->DomainName.Buffer = RxAllocatePoolWithTag(
                                                          NonPagedPool,
                                                          pServerEntry->DomainName.Length,
                                                          MRXSMB_SERVER_POOLTAG);
                }

                if (pServerEntry->DomainName.Buffer != NULL) {
                    // Copy the domain name into the server entry
                    RtlCopyMemory(
                        pServerEntry->DomainName.Buffer,
                        pSmbAdminExchange->Negotiate.DomainName.Buffer,
                        pServerEntry->DomainName.Length);
                } else {
                    //The downlevel server doesn't have a domain name. It's not a problem if the
                    //DomainName.Buffer equals to NULL.
                    if (pServerEntry->DomainName.Length > 0) {
                        pServerEntry->DomainName.Length = 0;
                        pServerEntry->DomainName.MaximumLength = 0;
                        pServerEntry->ServerStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                if (pServerEntry->ServerStatus == STATUS_SUCCESS) {
                    pServerEntry->ServerStatus = SmbCeUpdateSrvCall(pServerEntry);
                }
            }

            Status = pServerEntry->ServerStatus;

            if (pServerEntry->ServerStatus == STATUS_SUCCESS) {
                pServerEntry->Server.EchoProbeState = ECHO_PROBE_IDLE;
            }
        }
        break;

    case SMB_COM_TREE_DISCONNECT:
    case SMB_COM_LOGOFF_ANDX:
    case SMB_COM_ECHO:
    default:
        break;
    }

    SmbCeDiscardAdminExchange(pSmbAdminExchange);

    return Status;
}

NTSTATUS
SmbAdminExchangeStart(
    PSMB_EXCHANGE  pExchange)
/*++

Routine Description:

    This is the start routine for administrative SMB exchanges.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS   Status;

    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange;

    PAGED_CODE();

    pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)pExchange;

    switch (pSmbAdminExchange->SmbCommand) {
    case SMB_COM_NEGOTIATE:
    case SMB_COM_LOGOFF_ANDX:
    case SMB_COM_TREE_DISCONNECT:
        {
            ASSERT(pSmbAdminExchange->pSmbMdl == NULL);
            RxAllocateHeaderMdl(
                pSmbAdminExchange->pSmbBuffer,
                pSmbAdminExchange->SmbBufferLength,
                pSmbAdminExchange->pSmbMdl
                );

            if (pSmbAdminExchange->pSmbMdl != NULL) {

                RxProbeAndLockHeaderPages(
                    pSmbAdminExchange->pSmbMdl,
                    KernelMode,
                    IoModifyAccess,
                    Status);

                if (Status == STATUS_SUCCESS) {
                    Status = SmbCeTranceive(
                                 pExchange,
                                 RXCE_SEND_SYNCHRONOUS,
                                 pSmbAdminExchange->pSmbMdl,
                                 pSmbAdminExchange->SmbBufferLength);

                    RxDbgTrace( 0, Dbg, ("Net Root SmbCeTranceive returned %lx\n",Status));
                } else {
                    IoFreeMdl(pSmbAdminExchange->pSmbMdl);
                    pSmbAdminExchange->pSmbMdl = NULL;
                }
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        break;

    case SMB_COM_ECHO:
        {
            Status = SmbCeSend(
                         pExchange,
                         0,
                         pSmbAdminExchange->EchoProbe.pEchoProbeMdl,
                         pSmbAdminExchange->EchoProbe.EchoProbeLength);
        }
        break;

    default:
        break;
    }

    return Status;
}

NTSTATUS
SmbAdminExchangeReceive(
    IN struct _SMB_EXCHANGE *pExchange,    // The exchange instance
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT ULONG               *pBytesTaken,
    IN  PSMB_HEADER         pSmbHeader,
    OUT PMDL                *pDataBufferPointer,
    OUT PULONG              pDataSize,
    IN ULONG                ReceiveFlags)
/*++

Routine Description:

    This is the recieve indication handling routine for net root construction exchanges

Arguments:

    pExchange - the exchange instance

    BytesIndicated - the number of bytes indicated

    Bytes Available - the number of bytes available

    pBytesTaken     - the number of bytes consumed

    pSmbHeader      - the byte buffer

    pDataBufferPointer - the buffer into which the remaining data is to be copied.

    pDataSize       - the buffer size.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    This routine is called at DPC level.

--*/
{
    NTSTATUS             Status;
    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange;

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("ParseSmbHeader BytesIndicated/Available %ld %ld\n",BytesIndicated,BytesAvailable));

    pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)pExchange;

    switch (pSmbAdminExchange->SmbCommand) {
    case SMB_COM_NEGOTIATE:
        {
            Status = ParseNegotiateResponse(
                         pSmbAdminExchange,
                         BytesIndicated,
                         BytesAvailable,
                         pBytesTaken,
                         pSmbHeader,
                         pDataBufferPointer,
                         pDataSize);

            if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                if (*pDataBufferPointer != NULL &&
                    ((*pBytesTaken + *pDataSize) <= BytesAvailable ||
                     !FlagOn(ReceiveFlags,TDI_RECEIVE_ENTIRE_MESSAGE))) {
                    pSmbAdminExchange->Negotiate.pNegotiateMdl = *pDataBufferPointer;
                } else {
                    *pBytesTaken = BytesAvailable;
                    Status       = STATUS_SUCCESS;
                    pExchange->Status = STATUS_INVALID_NETWORK_RESPONSE;
                }
            }
        }
        break;

    case SMB_COM_TREE_DISCONNECT:
    case SMB_COM_LOGOFF_ANDX:
        {
            *pBytesTaken = BytesAvailable;
            Status       = STATUS_SUCCESS;
        }
        break;

    case SMB_COM_ECHO:
        // Since the echo probe responses are handled by the receive indication routine
        // at DPC level this routine should never be called for echo probes.

    default:
        {
            *pBytesTaken = 0;
            Status       = STATUS_DATA_NOT_ACCEPTED;
        }
        break;
    }

    return Status;
}

NTSTATUS
SmbAdminExchangeCopyDataHandler(
    IN PSMB_EXCHANGE    pExchange,    // The exchange instance
    IN PMDL             pCopyDataBuffer,
    IN ULONG            DataSize)
/*++

Routine Description:

    This is the copy data handling routine for administrative SMB exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    UNREFERENCED_PARAMETER(pExchange);
    return STATUS_SUCCESS;
}

NTSTATUS
SmbAdminExchangeSendCallbackHandler(
    IN PSMB_EXCHANGE    pExchange,
    IN PMDL             pXmitBuffer,
    IN NTSTATUS         SendCompletionStatus)
/*++

Routine Description:

    This is the send call back indication handling routine for transact exchanges

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(pExchange);
    UNREFERENCED_PARAMETER(pXmitBuffer);
    UNREFERENCED_PARAMETER(SendCompletionStatus);
}

NTSTATUS
SmbAdminExchangeFinalize(
    PSMB_EXCHANGE pExchange,
    BOOLEAN       *pPostFinalize)
/*++

Routine Description:

    This routine finalkzes the construct net root exchange. It resumes the RDBSS by invoking
    the call back and discards the exchange

Arguments:

    pExchange - the exchange instance

    CurrentIrql - the current interrupt request level

    pPostFinalize - a pointer to a BOOLEAN if the request should be posted

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    PSMB_ADMIN_EXCHANGE  pSmbAdminExchange = (PSMB_ADMIN_EXCHANGE)pExchange;

    if (pSmbAdminExchange->pResumptionContext != NULL) {
        // Signal the event
        *pPostFinalize = FALSE;
        SmbCeResume(pSmbAdminExchange->pResumptionContext);
    } else {
        if (RxShouldPostCompletion()) {
            *pPostFinalize = TRUE;
            return STATUS_SUCCESS;
        } else {
            *pPostFinalize = FALSE;
            SmbCeCompleteAdminExchange(pSmbAdminExchange);
        }
    }

   return STATUS_SUCCESS;
}



SMB_EXCHANGE_DISPATCH_VECTOR
AdminExchangeDispatch = {
                            SmbAdminExchangeStart,
                            SmbAdminExchangeReceive,
                            SmbAdminExchangeCopyDataHandler,
                            NULL,                            // No Send Completion handler
                            SmbAdminExchangeFinalize
                        };

SMB_EXCHANGE_DISPATCH_VECTOR
EchoExchangeDispatch = {
                            SmbAdminExchangeStart,
                            SmbAdminExchangeReceive,
                            SmbAdminExchangeCopyDataHandler,
                            SmbAdminExchangeSendCallbackHandler,
                            SmbAdminExchangeFinalize
                        };







=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ifskit.mrx\smbmrx\sys\rename.c ===
/*++

Copyright (c) 1989 - 1999 Microsoft Corporation

Module Name:

    rename.c

Abstract:

    This module implements rename in the smb minirdr.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbRename)
#pragma alloc_text(PAGE, MRxSmbBuildRename)
#pragma alloc_text(PAGE, MRxSmbBuildDeleteForRename)
#pragma alloc_text(PAGE, SmbPseExchangeStart_Rename)
#pragma alloc_text(PAGE, MRxSmbFinishRename)
#pragma alloc_text(PAGE, MRxSmbBuildCheckEmptyDirectory)
#pragma alloc_text(PAGE, SmbPseExchangeStart_SetDeleteDisposition)
#pragma alloc_text(PAGE, MRxSmbSetDeleteDisposition)
#endif

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_FILEINFO)

NTSTATUS
SmbPseExchangeStart_Rename(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );
NTSTATUS
SmbPseExchangeStart_SetDeleteDisposition(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );



MRxSmbRename(
      IN PRX_CONTEXT            RxContext
      )
/*++

Routine Description:

   This routine does a rename by
     1) purge and remove buffering rights....setup the FCB so that no more stuff can get thru.
     2) closing its fid along with any deferred fids.
     3) if replace...do a delete
     4) do a downlevel smb_com_rename.

   there are many provisos but i think that this is the best balance. it is a real shame that the
   NT-->NT path was never implemented in nt4.0 or before.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb; RxCaptureFobx;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("MRxSmbRename\n", 0 ));

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );
    //ASSERT( RxContext->Info.FileInformationClass == FileRenameInformation); //later we'll do downlevel delete here as well

    Status = SmbPseCreateOrdinaryExchange(RxContext,
                                          capFobx->pSrvOpen->pVNetRoot,
                                          SMBPSE_OE_FROM_RENAME,
                                          SmbPseExchangeStart_Rename,
                                          &OrdinaryExchange);

    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg, ("Couldn't get the smb buf!\n"));
        return(Status);
    }

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status != STATUS_PENDING);

    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);

    RxDbgTrace(0, Dbg, ("MRxSmbRename  exit with status=%08lx\n", Status ));
    return(Status);
}


NTSTATUS
MRxSmbBuildRename (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a Rename SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;
    NTSTATUS StufferStatus;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PUNICODE_STRING RemainingName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)StufferState->Exchange;

    PFILE_RENAME_INFORMATION RenameInformation = RxContext->Info.Buffer;
    UNICODE_STRING RenameName;
    USHORT SearchAttributes = SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN | SMB_FILE_ATTRIBUTE_DIRECTORY;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuildRename\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    RenameName.Buffer = &RenameInformation->FileName[0];
    RenameName.Length = (USHORT)RenameInformation->FileNameLength;

    if (RxContext->Info.FileInformationClass == FileRenameInformation) {
        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse, SMB_COM_RENAME,
                                    SMB_REQUEST_SIZE(RENAME),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                    );
    
        MRxSmbDumpStufferState (1100,"SMB w/ RENAME before stuffing",StufferState);
    
        MRxSmbStuffSMB (StufferState,
             "0wB",
                                        //  0         UCHAR WordCount;                    // Count of parameter words = 1
                 SearchAttributes,      //  w         _USHORT( SearchAttributes );
                 SMB_WCT_CHECK(1) 0     //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                        //            UCHAR Buffer[1];                    // Buffer containing:
                                        //            //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                        //            //UCHAR OldFileName[];              //  Old file name
                                        //            //UCHAR BufferFormat2;              //  0x04 -- ASCII
                                        //            //UCHAR NewFileName[];              //  New file name
                 );
    } else {
        COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse, SMB_COM_NT_RENAME,
                                    SMB_REQUEST_SIZE(NTRENAME),
                                    NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                    0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                    );
    
        MRxSmbDumpStufferState (1100,"SMB w/ NTRENAME before stuffing",StufferState);
    
        MRxSmbStuffSMB (StufferState,
             "0wwdB",
                                              //  0         UCHAR WordCount;                    // Count of parameter words = 1
                 SearchAttributes,            //  w         _USHORT( SearchAttributes );
                 SMB_NT_RENAME_SET_LINK_INFO, //  w         _USHORT( InformationLevel );
                 0,                           //  d         _ULONG( ClusterCount );
                 SMB_WCT_CHECK(4) 0           //  B         _USHORT( ByteCount );               // Count of data bytes = 0
                                              //            UCHAR Buffer[1];                    // Buffer containing:
                                              //            //UCHAR BufferFormat1;              //  0x04 -- ASCII
                                              //            //UCHAR OldFileName[];              //  Old file name
                                              //            //UCHAR BufferFormat2;              //  0x04 -- ASCII
                                              //            //UCHAR NewFileName[];              //  New file name
                 );
    }
    
    Status = MRxSmbStuffSMB (StufferState,
                                    "44!", RemainingName, &RenameName );

    MRxSmbDumpStufferState (700,"SMB w/ RENAME after stuffing",StufferState);
    //ASSERT(!"Now it's stuffed");

FINALLY:
    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

}

NTSTATUS
MRxSmbBuildDeleteForRename (
    PSMBSTUFFER_BUFFER_STATE StufferState
    )
/*++

Routine Description:

   This builds a Delete SMB. we don't have to worry about login id and such
   since that is done by the connection engine....pretty neat huh? all we have to do
   is to format up the bits.

Arguments:

   StufferState - the state of the smbbuffer from the stuffer's point of view

Return Value:

   RXSTATUS
      SUCCESS
      NOT_IMPLEMENTED  something has appeared in the arguments that i can't handle

Notes:



--*/
{
    NTSTATUS Status;
    NTSTATUS StufferStatus;
    PRX_CONTEXT RxContext = StufferState->RxContext;
    RxCaptureFcb;RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange = (PSMB_PSE_ORDINARY_EXCHANGE)StufferState->Exchange;

    PFILE_RENAME_INFORMATION RenameInformation = RxContext->Info.Buffer;
    UNICODE_STRING RenameName;
    ULONG SearchAttributes = SMB_FILE_ATTRIBUTE_SYSTEM | SMB_FILE_ATTRIBUTE_HIDDEN;  // a la rdr1

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("MRxSmbBuild Delete 4RENAME\n", 0 ));

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    RenameName.Buffer = &RenameInformation->FileName[0];
    RenameName.Length = (USHORT)RenameInformation->FileNameLength;


    COVERED_CALL(MRxSmbStartSMBCommand (StufferState,SetInitialSMB_ForReuse,SMB_COM_DELETE,
                                SMB_REQUEST_SIZE(DELETE),
                                NO_EXTRA_DATA,SMB_BEST_ALIGNMENT(1,0),RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                                0,0,0,0 STUFFERTRACE(Dbg,'FC'))
                 );

    MRxSmbDumpStufferState (1100,"SMB  Delete 4RENAME before stuffing",StufferState);

    MRxSmbStuffSMB (StufferState,
  